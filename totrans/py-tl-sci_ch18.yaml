- en: '**18'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**18'
- en: 'NUMPY: NUMERICAL PYTHON**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 'NUMPY: 数值计算 Python**'
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: Short for *Numerical Python*, *NumPy* serves as Python’s foundational library
    for numerical computing. It extends Python’s mathematical capability and forms
    the basis of many scientific and mathematical packages. As a result, you’ll need
    to understand NumPy in order to effectively use Python’s scientific libraries
    such as Matplotlib (for plotting) and pandas (for data analysis).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*NumPy* 是 *Numerical Python* 的缩写，是 Python 数值计算的基础库。它扩展了 Python 的数学功能，成为许多科学和数学包的基础。因此，你需要了解
    NumPy，才能有效使用 Python 的科学库，如 Matplotlib（用于绘图）和 pandas（用于数据分析）。'
- en: NumPy is open source and comes preinstalled with Anaconda. It augments the built-in
    tools in the Python Standard Library, which can be too simple for many data analysis
    calculations. Using NumPy, you can perform fast operations, including mathematical,
    logical, shape manipulation, sorting, selecting, I/O, discrete Fourier transforms,
    basic linear algebra, basic statistical operations, random simulation, and more.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 是开源的，并且与 Anaconda 一起预安装。它增强了 Python 标准库中内置工具的功能，这些工具对于许多数据分析计算来说可能过于简单。使用
    NumPy，你可以执行快速操作，包括数学、逻辑、形状操作、排序、选择、I/O、离散傅里叶变换、基本线性代数、基本统计运算、随机模拟等。
- en: At the core of NumPy is the *array* data structure, which is basically a grid
    of values. By using precompiled C code, multidimensional arrays, and functions
    that operate on arrays, NumPy speeds up the running of slower algorithms and performs
    high-level mathematical calculations in a highly efficient manner. NumPy also
    makes it easier to work with large, uniform datasets with millions to billions
    of samples.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的核心是 *array* 数据结构，基本上是一个值的网格。通过使用预编译的 C 代码、多维数组和操作数组的函数，NumPy 加速了较慢算法的运行，并以高效的方式执行高级数学计算。NumPy
    还使得处理具有数百万到数十亿样本的大型均匀数据集变得更加容易。
- en: You can’t understand NumPy if you don’t understand arrays, so in this chapter,
    we’ll focus on these features first and then look at some of the library’s basic
    functionality. For further study, visit the official site (*[https://numpy.org/](https://numpy.org/)*),
    which contains both “quickstart” and more detailed tutorials and guides.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不理解数组，就无法理解 NumPy，因此在本章中，我们将首先关注这些特性，然后再查看库的一些基本功能。有关进一步学习，请访问官方站点 (*[https://numpy.org/](https://numpy.org/)*)，该站点包含“快速入门”和更详细的教程和指南。
- en: '**Introducing the Array**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**介绍数组**'
- en: In computer science, an array is a data structure that contains a group of elements
    (values or variables) of the same size and data type (referred to as *dytpes*
    in NumPy). An array can be indexed by a tuple of nonnegative integers, by Booleans,
    by another array, or by integers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，数组是一种数据结构，包含一组具有相同大小和数据类型（在NumPy中称为*dytpes*）的元素（值或变量）。数组可以通过非负整数的元组、布尔值、另一个数组或整数进行索引。
- en: 'Here’s an example of a two-dimensional array of integers, comprising a grid
    of two rows and three columns. Because arrays use square brackets, they look a
    lot like Python lists:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个二维整数数组的示例，由两行三列组成的网格。由于数组使用方括号，因此它们看起来与 Python 列表非常相似：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To select an element from this array, you can use standard indexing and slicing
    techniques. For example, to select the element `2`, you would index first the
    row and then the column, using `[0][2]`(remember: Python starts counting at 0,
    not 1).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要从这个数组中选择一个元素，可以使用标准的索引和切片技术。例如，要选择元素 `2`，你需要先索引行，然后是列，使用 `[0][2]`（记住：Python
    从 0 开始计数，而不是从 1）。
- en: There are several reasons why you might want to work with arrays. Accessing
    individual elements by index is extremely efficient, making runtimes constant
    regardless of the array size. In fact, arrays let you perform complex computations
    on entire blocks of data without the need to loop through and access each element
    one at a time. As a result, NumPy-based algorithms run orders of magnitude faster
    than those in native Python.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能有几个理由想要使用数组。通过索引访问单个元素非常高效，使得无论数组大小如何，运行时间都是常数。实际上，数组让你能够对整块数据执行复杂的计算，而无需逐个循环并访问每个元素。因此，基于
    NumPy 的算法运行速度比原生 Python 中的算法快几个数量级。
- en: In addition to being faster, arrays store data in contiguous memory blocks,
    resulting in a significantly smaller memory footprint than built-in Python sequences,
    like lists. A list, for example, is basically an array of pointers to (potentially)
    heterogeneous Python objects stored in non-contiguous blocks, making it much less
    compact than a NumPy array. Consequently, arrays are often the preferred data
    structure for storing data reliably and efficiently. The popular OpenCV computer
    vision library, for example, manipulates and stores digital images as NumPy arrays.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更快之外，数组还将数据存储在连续的内存块中，与Python内置的非连续块列表等序列相比，内存占用显著较小。例如，列表基本上是指向（可能是）非连续块中存储的异构Python对象的指针数组，使其比NumPy数组非常不紧凑。因此，数组通常是存储数据的首选数据结构，可靠且高效。例如，流行的OpenCV计算机视觉库将数字图像操作和存储为NumPy数组。
- en: '***Describing Arrays Using Dimension and Shape***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用维度和形状描述数组***'
- en: Understanding arrays requires knowledge of their layout. The number of *dimensions*
    in an array is the number of indexes needed to select an element from the array.
    You can think of a dimension as an array’s *axis*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 理解数组需要了解它们的布局。数组中的*维度*是从数组中选择元素所需的索引数量。你可以将维度看作是数组的*轴*。
- en: The number of dimensions in an array, also called its *rank*, can be used to
    describe the array. [Figure 18-1](ch18.xhtml#ch018fig1) is a graphical example
    of one-, two-, and three-dimensional arrays.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的维度数量，也称为其*秩*，可用于描述数组。图18-1是一维、二维和三维数组的图形示例。
- en: '![Image](../images/18fig01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/18fig01.jpg)'
- en: '*Figure 18-1: Graphical representations of arrays in one, two, and three dimensions*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-1：一维、二维和三维数组的图形表示*'
- en: The *shape* of an array is a tuple of integers representing the size of the
    array along each dimension, starting with the first dimension (axis 0). Example
    shape tuples are shown below each array in [Figure 18-1](ch18.xhtml#ch018fig1).
    The number of integers in these tuples equals the array’s rank.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的*形状*是一个整数元组，表示沿每个维度的数组大小，从第一个维度（轴0）开始。示例形状元组如下所示，每个数组下方显示在图18-1中。
- en: 'A one-dimensional array, also referred to as a *vector*, has a single axis.
    This is the simplest form of array and is the NumPy equivalent to Python’s `list`
    data type. Here’s an example of how the 1D array in [Figure 18-1](ch18.xhtml#ch018fig1)
    looks in Python:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一维数组，也称为*向量*，具有单个轴。这是数组的最简单形式，是Python的`list`数据类型的NumPy等效形式。以下是图18-1中1D数组在Python中的示例外观：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Arrays with more than one dimension are basically arrays within arrays. An array
    with both rows and columns is called a 2D array. The 2D array in [Figure 18-1](ch18.xhtml#ch018fig1)
    has a shape tuple of (2, 3) because the length of its first axis (0) is 2 and
    the length of its second axis (1) is 3.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 具有多个维度的数组基本上是数组内的数组。具有行和列的数组称为2D数组。图18-1中的2D数组具有形状元组(2, 3)，因为其第一个轴（0）的长度为2，第二个轴（1）的长度为3。
- en: A 2D array is used to represent a *matrix*. You might remember from math class
    that these are rectangular grids of elements such as numbers or algebraic expressions,
    arranged in rows and columns and enclosed by square brackets. Matrices store data
    in an elegant and compact manner, and despite containing many elements, each matrix
    is treated as one unit.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 2D数组用于表示*矩阵*。您可能还记得数学课上的矩阵，这些是元素（例如数字或代数表达式）的矩形网格，排列在行和列中，并用方括号括起来。矩阵以一种优雅而紧凑的方式存储数据，尽管包含许多元素，但每个矩阵被视为一个单位。
- en: 'Here’s an example of the 2D array in [Figure 18-1](ch18.xhtml#ch018fig1) rendered
    in Python:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Python中图18-1中2D数组的示例：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'An array with three or more dimensions is called a *tensor*. As mentioned earlier,
    arrays can have any number of dimensions. Here’s an example of the 3D array in
    [Figure 18-1](ch18.xhtml#ch018fig1):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 具有三个或更多维度的数组称为*张量*。如前所述，数组可以具有任意数量的维度。以下是图18-1中3D数组的示例：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tensors can be difficult to visualize in a two-dimensional display, but Python
    tries to help you out. Note how a blank line separates the two stacked matrices
    that comprise the 3D grid. You can also determine the rank of an array by counting
    the number of square brackets at the start of the output. Three square brackets
    in a row means that you’re dealing with a 3D array.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 张量在二维显示中可能难以可视化，但Python会尽量帮助你。注意空行如何将两个堆叠的矩阵分开，这些矩阵组成了3D网格。你还可以通过计算输出中方括号的数量来确定数组的秩。连续三个方括号意味着你正在处理一个3D数组。
- en: '***Creating Arrays***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建数组***'
- en: NumPy handles arrays through its `ndarray` class, also known by the alias `array`.
    The `ndarray` name is short for *N-dimensional*, as this class can handle any
    number of dimensions. NumPy `ndarray`s have a fixed size at creation and can’t
    grow like a Python list or tuple. Changing the size of an `ndarray` creates a
    new array and deletes the original.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy通过其`ndarray`类来处理数组，也称为`array`别名。`ndarray`这个名称是*N维*的缩写，因为这个类可以处理任意数量的维度。NumPy的`ndarray`在创建时具有固定大小，无法像Python列表或元组那样增长。更改`ndarray`的大小会创建一个新数组并删除原始数组。
- en: '**NOTE**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You should know numpy.array is not the same as array.array, found in the Python
    Standard Library. The latter is only a one-dimensional array and has limited functionality
    compared to NumPy arrays.*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*你应该知道numpy.array不同于Python标准库中的array.array。后者只是一个一维数组，并且与NumPy数组相比功能有限。*'
- en: NumPy comes with several built-in functions for creating `ndarray`s. These let
    you create arrays outright or convert existing sequence data types, like tuples
    and lists, to arrays. [Table 18-1](ch18.xhtml#ch018tab1) lists some of the more
    common creation functions. We’ll look at some of these in more detail in the sections
    that follow. You can find a complete listing of creation functions at *[https://numpy.org/doc/stable/reference/routines.array-creation.html](https://numpy.org/doc/stable/reference/routines.array-creation.html)*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy提供了多个内置函数来创建`ndarray`。这些函数让你能够直接创建数组，或将现有的序列数据类型（如元组和列表）转换为数组。[表18-1](ch18.xhtml#ch018tab1)列出了其中一些常见的创建函数。我们将在接下来的章节中详细介绍其中一些。你可以在*[https://numpy.org/doc/stable/reference/routines.array-creation.html](https://numpy.org/doc/stable/reference/routines.array-creation.html)*找到完整的创建函数列表。
- en: '**Table 18-1:** Array Creation Functions'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**表18-1：** 数组创建函数'
- en: '| **Function** | **Description** |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `array` | Convert (copy) input sequence to an `ndarray` by inferring or specifying
    a `dtype` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `array` | 通过推断或指定`dtype`将输入序列转换（复制）为`ndarray` |'
- en: '| `asarray` | Like `array` but with fewer options and does not create a copy
    by default |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `asarray` | 类似于`array`，但选项较少，默认情况下不创建副本 |'
- en: '| `arange` | Like built-in `range()` function but returns an `ndarray` instead
    of a list |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `arange` | 类似于内置的`range()`函数，但返回的是`ndarray`而不是列表 |'
- en: '| `linspace` | Return evenly spaced numbers over a specified interval |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `linspace` | 在指定区间内返回均匀间隔的数字 |'
- en: '| `ones` | Produce an `ndarray` of all 1s with a given shape and `dtype` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `ones` | 生成一个所有值为1的`ndarray`，具有给定的形状和`dtype` |'
- en: '| `ones_like` | Produce a ones `ndarray` of the same shape and `dtype` as an
    input array |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `ones_like` | 生成与输入数组形状和`dtype`相同的全1`ndarray` |'
- en: '| `zeros` | Produce an `ndarray` of all 0s with a given shape and `dtype` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `zeros` | 生成一个所有值为0的`ndarray`，具有给定的形状和`dtype` |'
- en: '| `zeros_like` | Produce a `zeros ndarray` of the same shape and `dtype` as
    an input array |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `zeros_like` | 生成与输入数组形状和`dtype`相同的`zeros ndarray` |'
- en: '| `empty` | Allocate new memory for a new unpopulated `ndarray` of a given
    shape |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `empty` | 为一个给定形状的新未填充的`ndarray`分配内存 |'
- en: '| `empty_like` | Allocate new memory for a new unpopulated `ndarray` based
    on an input array |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `empty_like` | 基于输入数组为一个新的未填充的`ndarray`分配内存 |'
- en: '| `full` | Produce an `ndarray` of a given shape and `dtype` with all values
    set to a fill value |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `full` | 生成一个具有给定形状和`dtype`的`ndarray`，所有值都设置为填充值 |'
- en: '| `full_like` | Take an input array and produce a filled array of the same
    shape and `dtype` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `full_like` | 采用输入数组，并生成一个与输入数组形状和`dtype`相同的填充数组 |'
- en: '| `eye` | Return a square 2D array with ones on the diagonal and zeros elsewhere
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `eye` | 返回一个二维方阵，对角线为1，其它位置为0 |'
- en: '| `identity` | Like `eye` but without the option to specify the index of the
    diagonal |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `identity` | 类似于`eye`，但没有指定对角线索引的选项 |'
- en: Because arrays must contain data of the same type, the array needs to know the
    `dtype` that’s being passed to it. You’ll have the choice of letting the functions
    infer the most suitable `dtype` (although you’ll want to check the result) or
    providing the `dtype` explicitly as an additional argument.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数组必须包含相同类型的数据，所以数组需要知道传递给它的 `dtype` 类型。你可以选择让函数推断出最合适的 `dtype`（尽管你会想检查一下结果），或者显式地提供
    `dtype` 作为额外的参数。
- en: Some commonly used `dtype`s are listed in [Table 18-2](ch18.xhtml#ch018tab2).
    The Code column lists the shorthand arguments you can pass to the functions in
    single quotes, such as `dtype=` `'i8` `'`, in place of `dtype=` `'int64` `'`.
    For a full list of supported data types, visit *[https://numpy.org/doc/stable/user/basics.types.html](https://numpy.org/doc/stable/user/basics.types.html)*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常用的 `dtype` 类型列在 [表 18-2](ch18.xhtml#ch018tab2) 中。代码列列出了你可以传递给函数的简写参数，例如 `dtype=`
    `'i8` `'`，以替代 `dtype=` `'int64` `'`。要查看完整的支持数据类型列表，请访问 *[https://numpy.org/doc/stable/user/basics.types.html](https://numpy.org/doc/stable/user/basics.types.html)*。
- en: '**Table 18-2:** Common NumPy Data Types'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 18-2：** 常见的 NumPy 数据类型'
- en: '| **Type** | **Code** | **Description** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **代码** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `bool` | `?` | Boolean type (True and False). |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | `?` | 布尔类型（True 和 False）。 |'
- en: '| `object` | `O` | Any Python object type. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `object` | `O` | 任意 Python 对象类型。 |'
- en: '| `string_` | `S`n | Fixed-length ASCII string type with 1 byte per character.
    The n parameter represents the length of the longest string, such as `''S15''`.
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `string_` | `S`n | 固定长度的 ASCII 字符串类型，每个字符占用 1 字节。n 参数表示最长字符串的长度，例如 `''S15''`。
    |'
- en: '| `unicode_` | `U`n | Fixed-length Unicode type with number of bytes platform
    specific. The n parameter represents the longest length, such as `''U12''`. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `unicode_` | `U`n | 固定长度的 Unicode 类型，字节数与平台相关。n 参数表示最长的长度，例如 `''U12''`。 |'
- en: '| `int8, uint8` | `i1, u1` | Signed and unsigned 8-bit (1 byte) integer types.
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `int8, uint8` | `i1, u1` | 有符号和无符号 8 位（1 字节）整数类型。 |'
- en: '| `int16, uint16` | `i2, u2` | Signed and unsigned 16-bit integer types. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `int16, uint16` | `i2, u2` | 有符号和无符号 16 位整数类型。 |'
- en: '| `int32, uint32` | `i4, u4` | Signed and unsigned 32-bit integer types. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `int32, uint32` | `i4, u4` | 有符号和无符号 32 位整数类型。 |'
- en: '| `int64, uint64` | `i8, u8` | Signed and unsigned 64-bit integer types. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `int64, uint64` | `i8, u8` | 有符号和无符号 64 位整数类型。 |'
- en: '| `float32` | `f4` or `f` | Single-precision floating-point type. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `float32` | `f4` 或 `f` | 单精度浮动点类型。 |'
- en: '| `float64` | `f8` or `d` | Double-precision floating-point type compatible
    with Python float. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `float64` | `f8` 或 `d` | 双精度浮动点类型，与 Python 的浮点数兼容。 |'
- en: '| `float128` | `f16` or `g` | Extended-precision floating-point type. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `float128` | `f16` 或 `g` | 扩展精度浮动点类型。 |'
- en: '| `complex64` | `c8` | Complex number represented by two 32-bit floats. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `complex64` | `c8` | 由两个 32 位浮点数组成的复数类型。 |'
- en: '| `complex128` | `c16` | Complex number represented by two 64-bit floats. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `complex128` | `c16` | 由两个 64 位浮点数组成的复数类型。 |'
- en: '| `complex256` | `c32` | Complex number represented by two 128-bit floats.
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `complex256` | `c32` | 由两个 128 位浮点数组成的复数类型。 |'
- en: For string and Unicode dtypes, the length of the longest string or Unicode object
    must be included in the `dtype` argument. For example, if the longest string in
    a dataset has 12 characters, the assigned `dtype` should be `'S12'`. This is necessary
    because all the `ndarray` elements should be of the same size. There’s no way
    to create variable-length strings, so you must ensure that enough memory is allocated
    to hold every possible string in the dataset. When using *existing input*, such
    as when converting a list of strings to an array, NumPy can make this calculation
    for you.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字符串和 Unicode 数据类型，`dtype` 参数必须包括最长字符串或 Unicode 对象的长度。例如，如果数据集中最长的字符串有 12 个字符，指定的
    `dtype` 应为 `'S12'`。这是必要的，因为所有的 `ndarray` 元素应该具有相同的大小。无法创建变长字符串，因此必须确保分配足够的内存来容纳数据集中每个可能的字符串。在使用
    *现有输入* 时，例如将字符串列表转换为数组时，NumPy 可以为你进行这个计算。
- en: Because the amount of memory used by the `dtype`s is automatically assigned
    (or can be input), NumPy knows how much memory to allocate when creating `ndarray`s.
    The choices in [Table 18-2](ch18.xhtml#ch018tab2) give you plenty of control over
    how data is stored in memory, but don’t let that intimidate you. Most of the time,
    all you’ll need to know is the basic type of data you’re using, such as a float
    or integer.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `dtype` 占用的内存量是自动分配的（或者可以手动输入），所以 NumPy 知道在创建 `ndarray` 时应该分配多少内存。[表 18-2](ch18.xhtml#ch018tab2)
    中的选项让你对数据在内存中的存储方式有充分的控制，但不要因此感到害怕。大多数情况下，你只需要知道你使用的数据的基本类型，例如浮点数或整数。
- en: '**HOW NUMPY ALLOCATES MEMORY**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**NUMPY 如何分配内存**'
- en: The genius of NumPy is in how it allocates memory. The following figure shows
    information stored in a 3x4 2D array of numbers from 0 to 11, represented by the
    “Python View” diagram at the bottom of the figure. You’re already familiar with
    parameters such as `dtype`, dimensions, and data, so let’s focus on memory allocation
    and strides.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的聪明之处在于它如何分配内存。下图显示了一个 3x4 的二维数组，其中包含从 0 到 11 的数字，这些信息通过图底部的“Python 视图”示意图表示。你已经熟悉了像
    `dtype`、维度和数据这样的参数，接下来我们重点关注内存分配和步幅。
- en: '![Image](../images/f0496-01.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0496-01.jpg)'
- en: The values of an `ndarray` are stored as a contiguous block of memory in your
    computer’s RAM, as shown by the Memory Block diagram in the figure. This is efficient,
    as processors prefer items in memory to be in chunks rather than randomly scattered
    about. The latter occurs when you store data in Python data types like lists,
    which keep track of *pointers* to objects in memory, creating “overhead” that
    slows down processing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`ndarray` 的值作为计算机 RAM 中一个连续的内存块存储，如图中的内存块示意图所示。这种方式非常高效，因为处理器更喜欢将内存中的数据按块存储，而不是随机散布。如果你将数据存储在像列表这样的
    Python 数据类型中，内存中会保存到对象的*指针*，这会产生“开销”，从而降低处理速度。'
- en: To help NumPy interpret the bytes in memory, the `dtype` object stores additional
    information about the *layout* of the array, such as the size of the data (in
    bytes) and the byte order of the data. Because we’re using the `int32` `dtype`
    in the example, each number occupies 4 bytes of memory (32 bits/8 bits per byte).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助 NumPy 解释内存中的字节，`dtype` 对象存储了关于数组*布局*的附加信息，例如数据的大小（以字节为单位）和数据的字节顺序。因为我们在示例中使用了
    `int32` 类型的 `dtype`，所以每个数字占用 4 字节的内存（32 位/每字节 8 位）。
- en: '`Ndarray`s come with an attribute, `strides`, which is a tuple of the number
    of bytes to step in each dimension when traversing an array. This tuple informs
    NumPy on how to convert from the contiguous Memory Block to the Python View array
    shown in the figure.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ndarray` 拥有一个属性，`strides`，它是一个元组，表示在遍历数组时，在每个维度上步进所需的字节数。这个元组告诉 NumPy 如何将连续的内存块转换为图中所示的
    Python 视图数组。'
- en: In the figure, the memory block consists of 48 bytes (12 integers x 4 bytes
    each), stored one after the other. The array strides indicate how many bytes must
    be skipped in memory to move to the next position along a certain axis. For example,
    we must skip 4 bytes (1 integer) to reach the next column, but 16 bytes (4 integers)
    to move to the same position in the next row. Thus, the strides for the array
    are (16, 4).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，内存块由 48 字节组成（12 个整数，每个占 4 字节），一个接一个地存储。数组步幅指示了在内存中跳过多少字节才能移动到某一轴上的下一个位置。例如，我们需要跳过
    4 字节（1 个整数）才能到达下一列，但要跳过 16 字节（4 个整数）才能到达下一行的同一位置。因此，数组的步幅为 (16, 4)。
- en: '**Using the array() Function**'
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 array() 函数**'
- en: 'The simplest way to create an array is to pass the NumPy `array()` function
    a sequence, such as a list, which is then converted into an `ndarray`. Let’s do
    that now to create a 1D array. We’ll begin by importing NumPy using the alias
    `np` (this is by convention and will reduce the amount of typing needed to call
    NumPy functions):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组的最简单方法是将一个序列（例如列表）传递给 NumPy 的 `array()` 函数，之后它会被转换为 `ndarray`。我们现在来做一个例子，创建一个一维数组。首先，我们通过别名
    `np` 导入 NumPy（这是约定俗成的做法，可以减少调用 NumPy 函数时的输入量）：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can also create an `ndarray` by passing the `array()` function a variable,
    like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过传递一个变量给 `array()` 函数来创建 `ndarray`，比如这样：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To create a multidimensional array, pass `array()` a nested sequence, where
    each nested sequence is the same length. Here’s an example that uses a list containing
    three nested lists to create a 2D array:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建多维数组，可以将 `array()` 函数传递一个嵌套序列，其中每个嵌套序列的长度相同。下面是一个例子，使用一个包含三个嵌套列表的列表来创建一个二维数组：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each nested list became a new row in the 2D array. To build the same array from
    tuples, you would replace all the square brackets `[]` in line `In [8]` with parentheses
    `()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每个嵌套列表变成了二维数组中的一行。要从元组构建相同的数组，你需要将 `In [8]` 行中的所有方括号 `[]` 替换为圆括号 `()`。
- en: '**NOTE**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When you print an array, NumPy displays it with the following layout: the
    last axis is printed from left to right, the second-to-last is printed from top
    to bottom, the rest are also printed from top to bottom, with each slice separated
    from the next by an empty line. So, 1D arrays are printed as rows, 2D arrays as
    matrices, and 3D arrays as lists of matrices.*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*当你打印一个数组时，NumPy 会按照以下布局显示它：最后一个轴从左到右打印，倒数第二个从上到下打印，其他轴也从上到下打印，每个切片之间用空行分隔。所以，1D
    数组打印为行，2D 数组为矩阵，3D 数组为矩阵列表。*'
- en: Now, let’s check some of the 2D array’s attributes, such as its shape
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们查看一些二维数组的属性，比如它的形状：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: its number of dimensions
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它的维度数量
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'and its strides:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以及它的步长：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Although the items in an array must be the same data type, this doesn’t mean
    that you can’t pass these items to the `array()` function within a mixture of
    sequence types, such as tuples and lists:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数组中的项必须是相同的数据类型，但这并不意味着你不能将这些项作为混合序列类型（如元组和列表）传递给 `array()` 函数：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This worked because NumPy reads the data type of the elements in a sequence
    rather than the data type of the sequence itself.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以有效，是因为 NumPy 读取的是序列中元素的数据类型，而不是序列本身的数据类型。
- en: 'You won’t have the same luck, however, if you try to pass nested lists of different
    lengths:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你尝试传递不同长度的嵌套列表，你可能不会这么幸运：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can avoid this warning by changing the `dtype` to `object`, as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将 `dtype` 更改为 `object` 来避免此警告，如下所示：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that you now have a 1D array of list objects rather than the 2D array of
    integers you wanted. Just as with mathematical matrices, arrays need to have the
    *same number of rows and columns* if you plan to use them for mathematical calculations
    (there’s some flexibility to this, but we’ll save it for the section on “broadcasting”).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你现在得到的是一个包含列表对象的一维数组，而不是你想要的二维整数数组。就像数学矩阵一样，数组如果要用于数学计算，它们需要具有 *相同的行和列数*（虽然在这方面有一定的灵活性，但我们会把它留到“广播”一节讲解）。
- en: 'Now, let’s look at arrays with more than two dimensions. The `array()` function
    transforms sequences of sequences into two-dimensional arrays; sequences of sequences
    of sequences into three-dimensional arrays; and so on. So, to make a 3D array,
    you need to pass the function multiple nested sequences. Here’s an example using
    nested lists:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看具有多于两个维度的数组。`array()` 函数将序列的序列转换为二维数组；序列的序列的序列转换为三维数组；依此类推。所以，要创建一个
    3D 数组，你需要传递多个嵌套的序列。下面是一个使用嵌套列表的示例：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, we passed a list containing two nested lists that each contained
    two nested lists. Notice how the output array has a blank line in the middle.
    This visually separates the two stacked 2D arrays created by the function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们传递了一个包含两个嵌套列表的列表，每个嵌套列表中又包含两个嵌套列表。注意输出的数组中间有一个空行，这在视觉上分隔了函数创建的两个堆叠的二维数组。
- en: Keeping track of all those brackets when creating high-dimension arrays can
    be cumbersome and dangerous to your eyesight. Fortunately, NumPy provides additional
    methods for creating arrays that can be more convenient than the `array()` function.
    We’ll look at some of these in the next sections.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建高维数组时，跟踪所有的括号可能既繁琐又对视力有害。幸运的是，NumPy 提供了其他创建数组的方法，这些方法比 `array()` 函数更方便。我们将在接下来的部分中探讨这些方法。
- en: '**Using the arange() Function**'
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用 arange() 函数**'
- en: To create arrays that hold sequences of numbers, NumPy provides the `arange()`
    function, which works like Python’s built-in `range()` function, only it returns
    an array rather than an immutable sequence of numbers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建包含数字序列的数组，NumPy 提供了 `arange()` 函数，它的功能类似于 Python 内置的 `range()` 函数，只不过它返回的是数组，而不是不可变的数字序列。
- en: 'The `arange()` function takes similar arguments to `range()`. Here, we make
    a 1D array of the integers from 0 to 9:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`arange()` 函数接受与 `range()` 相似的参数。这里，我们创建一个从 0 到 9 的一维数组：'
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can also add a start, stop, and step argument to create an array of the
    even numbers between 0 and 10:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加起始、结束和步长参数来创建一个包含 0 到 10 之间偶数的数组：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we start the sequence at 5 and stop at 9:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从 5 开始序列，并在 9 停止：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Whereas `range()` always produces a sequence of integers, `arange()` lets you
    specify the data type of the numbers in the array. Here, we use double-precision
    floating-point numbers:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `range()` 总是产生整数序列，`arange()` 则允许你指定数组中数字的数据类型。这里，我们使用双精度浮点数：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Interestingly, `arange()` accepts a float for the step parameter:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`arange()` 允许为步长参数传入浮动数值：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**NOTE**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When arange() is used with floating-point arguments, it’s usually not possible
    to predict the number of elements obtained, due to the finite floating-point precision.
    For this reason, it’s better to use the NumPy linspace() function, which receives
    as an argument the number of elements desired instead of the step argument. We’ll
    look at linspace() shortly.*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*当`arange()`与浮点数参数一起使用时，通常无法预测获得的元素数量，因为浮点数的精度有限。因此，最好使用NumPy的`linspace()`函数，该函数接收所需元素数量作为参数，而不是步长参数。我们稍后将详细讨论`linspace()`。*'
- en: 'With the `arange()` and `reshape()` functions, you can create a multidimensional
    array—and generate a lot of data—with a single line of code. The `arange()` function
    creates a 1D array, and `reshape()` divides this linear array into different parts
    as specified by a shape argument. Here’s an example using the 3D shape tuple (2,
    2, 4):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`arange()`和`reshape()`函数，你可以通过一行代码创建多维数组——并生成大量数据。`arange()`函数创建一个一维数组，`reshape()`将这个线性数组按照形状参数划分为不同的部分。以下是使用3D形状元组(2,
    2, 4)的示例：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Because arrays need to be symmetrical, the product of the shape tuple must
    equal the size of the array. In this case, `(8, 2, 1)` and `(4, 2, 2)` will work,
    but `(2, 3, 4)` will raise an error because the resulting array has 24 elements,
    whereas you specified 16 (`np.arange(16)`):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数组需要对称，形状元组的乘积必须等于数组的大小。在这种情况下，`(8, 2, 1)`和`(4, 2, 2)`是有效的，但`(2, 3, 4)`会报错，因为结果数组包含24个元素，而你指定的是16个元素（`np.arange(16)`）：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Using the linspace() Function**'
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用linspace()函数**'
- en: The NumPy `linspace()` function creates an `ndarray` of evenly spaced numbers
    within a defined interval. It’s basically the `arange()` function with a `num`
    (number of samples) argument rather than a `step` argument. The `num` argument
    determines how many elements will be in the array, and the function calculates
    the intervening numbers so that the intervals between them are the same.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy的`linspace()`函数创建一个在定义区间内均匀间隔的`ndarray`。它基本上是带有`num`（样本数量）参数的`arange()`函数，而不是`step`参数。`num`参数决定数组中将包含多少个元素，函数会计算它们之间的数值，使间隔相等。
- en: 'Suppose that you want an array of size 6 with values between 0 and 20\. All
    you need to do is pass the function a start, stop, and `num` value, as follows,
    using keyword arguments for clarity:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要一个大小为6的数组，值在0和20之间。你只需传递一个起始值、终止值和`num`值，如下所示，并为清晰起见使用关键字参数：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This produced a 1D array of six floating-point values, with all the values evenly
    spaced. Note that the stop value (`20`) is included in the array.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这生成了一个包含六个浮点值的一维数组，所有值均匀分布。请注意，终止值（`20`）包含在数组中。
- en: 'You can force the function to not include the endpoint by setting the Boolean
    parameter `endpoint` to `False`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将布尔参数`endpoint`设置为`False`，强制函数不包括终点：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you want to retrieve the size of the intervals between values, set the Boolean
    parameter `retstep` to `True`. This returns the step value:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想获取值之间间隔的大小，可以将布尔参数`retstep`设置为`True`。这样会返回步长值：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By default, the `linspace()` function returns a `dtype` of `float64`. You can
    override this by passing it a `dtype` argument:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`linspace()`函数返回`dtype`为`float64`。你可以通过传递`dtype`参数来覆盖这一点：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You’ll need to be careful when changing the data type, however, as the result
    may no longer be a linear space due to rounding.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在更改数据类型时需要小心，因为由于四舍五入，结果可能不再是线性空间。
- en: 'As with `arange()`, you can reshape the array on the fly. Here, we produce
    a 2D array with the same `linspace()` arguments:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 和`arange()`一样，你可以实时地重塑数组。在这里，我们使用相同的`linspace()`参数生成一个二维数组：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**NOTE**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*It’s possible to create sequences with uneven spacing. The np.logspace() function,
    for example, creates a logarithmic space with numbers evenly spaced on a log scale.*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*可以创建间隔不均匀的序列。例如，`np.logspace()`函数创建一个对数空间，其中的数字在对数尺度上均匀分布。*'
- en: The `linspace()` function lets you control the number of elements in an array,
    something that can be challenging to do when using `arange()`. Arrays of evenly
    spaced numbers are useful when working with mathematical functions of continuous
    variables. Likewise, linear spaces come in handy when you need to evenly sample
    an object, such as a waveform. To see some useful examples of `linspace()` in
    action, visit *[https://realpython.com/np-linspace-numpy/](https://realpython.com/np-linspace-numpy/)*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`linspace()` 函数让你控制数组中元素的数量，这是使用 `arange()` 时可能遇到的挑战。均匀间隔的数字数组在处理连续变量的数学函数时非常有用。同样，当你需要均匀地采样一个对象，比如波形时，线性空间也非常有用。要查看
    `linspace()` 的一些有用示例，请访问 *[https://realpython.com/np-linspace-numpy/](https://realpython.com/np-linspace-numpy/)*。'
- en: Along these lines, the `meshgrid()` function creates a rectangular grid out
    of two given 1D arrays. The resulting indexing matrix holds in each cell the x
    and y coordinates for each point in the 2D space. Whereas `meshgrid()` is useful
    when plotting and interpolating 2D arrays, the `mgrid()` function calls `meshgrid()`
    to produce a dense “meshgrid” with multiple dimensions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`meshgrid()` 函数根据给定的两个一维数组创建一个矩形网格。生成的索引矩阵在每个单元格中保存二维空间中每个点的 x 和 y 坐标。虽然 `meshgrid()`
    在绘图和插值二维数组时非常有用，但 `mgrid()` 函数调用 `meshgrid()` 来生成一个密集的“网格”，支持多个维度。'
- en: '**Creating Prefilled Arrays**'
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建预填充数组**'
- en: For convenience, NumPy lets you create `ndarray`s using prefilled ones, zeros,
    random values, or values of your own choosing. You can even create an empty array
    with no predefined values. These arrays are commonly used when you need a structure
    for holding computation results, for training machine learning applications, for
    creating image masks, for performing linear algebra, and so on.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，NumPy 允许你使用预填充的 1、0、随机值或自定义值来创建 `ndarray`。你甚至可以创建一个没有预定义值的空数组。这些数组通常用于需要一个用于存储计算结果的结构，机器学习训练应用，创建图像掩膜，执行线性代数等情况。
- en: 'To create a zero-filled array, simply pass the `zero()` function a shape tuple,
    as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个填充为零的数组，只需传递 `zero()` 函数一个形状元组，如下所示：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To create an array filled with ones, repeat the process with the `ones()` function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个填充为 1 的数组，使用 `ones()` 函数重复此过程：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `np.eye()` function creates an array where all items are equal to zero,
    except for the *k*th diagonal, whose values are equal to one:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.eye()` 函数创建一个数组，其中所有元素的值都为零，除了 *k* 维度的对角线元素，其值为一：'
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: By default, these functions return `float64` values, but you can override this
    using a `dtype` argument, such as `dtype=int`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这些函数返回 `float64` 值，但你可以通过 `dtype` 参数覆盖这一点，比如 `dtype=int`。
- en: 'To fill an array with a custom value and data type, use the `full()` function
    with following syntax:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要用自定义值和数据类型填充数组，请使用 `full()` 函数，语法如下：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `empty()` function returns a new `ndarray` of a given shape and filled
    with uninitialized (arbitrary) data of the given data type:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`empty()` 函数返回一个新的 `ndarray`，其形状为给定的形状，并填充了未初始化（任意）数据，数据类型为给定的数据类型：'
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: According to the documentation, `empty()` does not set the array values to zero
    and may therefore be marginally faster than the `zeros()` function. On the other
    hand, it requires the user to manually set all the values in the array, thus you
    should use it with caution.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 根据文档，`empty()` 不会将数组的值设置为零，因此可能比 `zeros()` 函数稍快。但它要求用户手动设置数组中的所有值，因此应谨慎使用。
- en: 'Finally, you can generate arrays of pseudo-random numbers using NumPy. For
    floating-point values between 0 and 1, just pass `random()` a shape tuple:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用 NumPy 生成伪随机数数组。对于 0 到 1 之间的浮动值，只需传递一个形状元组给 `random()`：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In addition, you can generate random integers, sample values from a “standard
    normal” distribution, shuffle an existing array’s contents in place, and more.
    We’ll look at some of these options later in the chapter, and you can find the
    official documentation at *[https://numpy.org/doc/stable/reference/random/generator.html](https://numpy.org/doc/stable/reference/random/generator.html)*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以生成随机整数，从“标准正态”分布中采样值，打乱现有数组的内容等。我们将在本章稍后介绍这些选项，你也可以在 *[https://numpy.org/doc/stable/reference/random/generator.html](https://numpy.org/doc/stable/reference/random/generator.html)*
    找到官方文档。
- en: '***Accessing Array Attributes***'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***访问数组属性***'
- en: As objects, `ndarray`s have attributes accessible through dot notation. We’ve
    looked at some of these already, and you can find more listed in [Table 18-3](ch18.xhtml#ch018tab3).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对象，`ndarray` 具有可通过点符号访问的属性。我们已经查看了一些这些属性，你可以在 [表 18-3](ch18.xhtml#ch018tab3)
    中找到更多。
- en: '**Table 18-3:** Important `ndarray` Attributes'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 18-3:** 重要的 `ndarray` 属性'
- en: '| **Attribute** | **Description** |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| --- | --- |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ndim` | The number of axes (dimensions) of the array |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `ndim` | 数组的轴（维度）数量 |'
- en: '| `shape` | A tuple of integers indicating the size of the array in each dimension
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `shape` | 一个整数元组，表示数组在每个维度的大小 |'
- en: '| `size` | The total number of elements in the array |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `size` | 数组中元素的总数 |'
- en: '| `itemsize` | The size in bytes of each element in the array |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `itemsize` | 数组中每个元素的字节大小 |'
- en: '| `dtype` | An object describing the data type of the elements in the array
    |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `dtype` | 描述数组元素数据类型的对象 |'
- en: '| `strides` | A tuple of bytes to step in each dimension when traversing an
    array |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `strides` | 在遍历数组时每个维度的步长（字节元组） |'
- en: 'For example, to get the shape of the `arr1d` object, enter the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要获取 `arr1d` 对象的形状，可以输入以下内容：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As a 1D array, there’s only one axis and thus only one index. Note the comma
    after the index, which tells Python that this is a tuple data type and not just
    an integer in parentheses.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个一维数组，只有一个轴，因此只有一个索引。注意索引后的逗号，它告诉 Python 这是一个元组数据类型，而不仅仅是括号中的整数。
- en: 'The size of the array is the total number of elements it contains. This is
    the same as the product of the elements returned by `shape`. To get the array’s
    size, enter the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的大小是它包含的元素总数。这与通过 `shape` 返回的元素的乘积相同。要获取数组的大小，输入以下内容：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To get the array’s `dtype`, enter:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取数组的 `dtype`，请输入：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Note that, even if you have a 64-bit machine, the default `dtype` for numbers
    *may be* 32-bit, such as `int32` or `float32`. To ensure that you’re using 64-bit
    numbers, you can specify the `dtype` when creating the array, as follows (for
    `int64`):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使你使用的是 64 位机器，数字的默认 `dtype` *可能是* 32 位，例如 `int32` 或 `float32`。为了确保使用 64
    位数字，你可以在创建数组时指定 `dtype`，如下所示（对于 `int64`）：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To get the array’s strides, access the `strides` attribute with dot notation:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取数组的步长，使用点符号访问`strides`属性：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When using strings in arrays, the `dtype` needs to include the length of the
    longest string. NumPy can generally figure this out on its own, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组中使用字符串时，`dtype` 需要包括最长字符串的长度。NumPy 通常可以自动推断出来，如下所示：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note how the unicode (`U`) `dtype` includes the number 8, which is the length
    of `soybeans`, the longest string item.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，unicode（`U`）`dtype` 包括数字 8，这是 `soybeans`（最长的字符串项）的长度。
- en: 'To see the data type and number of bits each item occupies, call the `name`
    attribute on `dtype`, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看每个项目所占的位数和数据类型，可以调用`dtype`的`name`属性，如下所示：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this case, each item in the array is a `string` occupying 256 bits (8 characters
    x 32 bits). This is different from the `itemsize` attribute, which just displays
    the size of an individual character *in bytes*:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，数组中的每个项目都是占用 256 位（8 个字符 x 32 位）的 `string`。这与 `itemsize` 属性不同，后者只显示单个字符的大小，*以字节为单位*：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的知识**'
- en: 1.  What is *not* a characteristic of an array?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  什么不是数组的特征？
- en: a.  Enables fast computations with small memory footprint
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: a.  使得计算快速且内存占用小
- en: b.  Composed entirely of elements of a single data type
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: b.  完全由单一数据类型的元素组成
- en: c.  Can accommodate up to four dimensions
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: c.  最多支持四个维度
- en: d.  Provides an efficient alternative to looping
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: d.  提供了比循环更高效的替代方案
- en: '2.  A two-dimensional array is also known as a:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  二维数组也称为：
- en: a.  Linear array
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: a.  线性数组
- en: b.  Tensor
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: b.  张量
- en: c.  Rank
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: c.  秩
- en: d.  Matrix
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: d.  矩阵
- en: '3.  A strides tuple tells NumPy:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  步长元组告诉 NumPy：
- en: a.  The number of different data types in the array
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: a.  数组中不同数据类型的数量
- en: b.  The number of bytes to step in each dimension when traversing an array
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: b.  遍历数组时，在每个维度中步进的字节数
- en: c.  The step size when sampling an array
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: c.  采样数组时的步长
- en: d.  The size of the array in bytes
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: d.  数组的字节大小
- en: 4.  You’ve been given a dataset of various-sized digital images and asked to
    take 100 evenly spaced samples of pixel intensity from each. Which NumPy function
    do you use to choose the sample locations?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  你已经得到一个包含各种大小数字图像的数据集，并被要求从每张图像中均匀地抽取 100 个像素强度样本。你会使用哪个 NumPy 函数来选择样本位置？
- en: a.  `arange()`
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: a.  `arange()`
- en: b.  `empty()`
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: b.  `empty()`
- en: c.  `empty_like()`
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: c.  `empty_like()`
- en: d.  `full()`
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: d.  `full()`
- en: e.  `linspace()`
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: e.  `linspace()`
- en: 5.  Write an expression to generate a square matrix of 100 zeros.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  写一个表达式生成一个 100×100 的零矩阵。
- en: '***Indexing and Slicing Arrays***'
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***数组的索引和切片***'
- en: The elements within an `ndarray` can be accessed using indexes and slices. This
    lets you extract the value of elements as well as change the values using assignment
    statements. Array indexing uses square brackets `[]`, just like Python lists.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '**Indexing and Slicing 1D Arrays**'
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One-dimensional arrays are zero-indexed, so the first index is always `0`. For
    indexing and slicing in reverse, the first value is `-1`. [Figure 18-2](ch18.xhtml#ch018fig2)
    describes the indexes of five elements in an array.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig02.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-2: The indexes of a 1D ndarray*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re familiar with list indexing, you won’t have any problems indexing
    1D arrays. Let’s look at some examples in which we select elements using both
    positive and negative indexing:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To access every other element in the array, include a step value of 2:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To access multiple elements at once, use an array of comma-separated indexes,
    as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'After you’ve selected these elements, you can assign them a new value and change
    the values in the underlying array, like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can also assign new values to a group of array elements with array slices.
    In this next example, we use slicing to change the first three elements to a value
    of 100:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the previous example, the value of 100 was propagated across the entire slice.
    This process is known as *broadcasting*. Because array slices are views of the
    source array rather than copies, any changes to the view will modify the original
    array. This is advantageous when working with very large arrays, as it keeps NumPy
    from making memory-intensive copies on the fly.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this assignment behavior persists even when array slices are assigned
    to a variable:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Because the slice itself is an array, it has its own set of indexes that are
    different from those of the source array. Thus, `a_slice[:]` corresponds to `arr2d[3:]`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'To make an actual copy rather than a view, call the `copy()` method, as shown
    here:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, the `a_slice` array is separate from `arr1d`, and changing its elements
    does not affect the source array.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can first call the `array` function on the slice and then
    mutate the result:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Changing the `a_slice` array had no effect on `arr1d`, because the arrays represent
    separate objects.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '**Indexing and Slicing 2D Arrays**'
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Two-dimensional arrays are indexed with a pair of values. These value pairs
    resemble Cartesian coordinates, except that the row index (the axis-0 value) comes
    before the column index (the axis-1 value), as shown in [Figure 18-3](ch18.xhtml#ch018fig3).
    Square brackets are used again.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/18fig03.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-3: Indexes of a 2D ndarray*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the 2D array in [Figure 18-3](ch18.xhtml#ch018fig3) to study this
    further:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In a 2D array, each value in the index pair references a 1D array (a whole
    row or column) rather than a single element. For example, specifying an integer
    index of `1` outputs the 1D array that comprises the second row of the 2D array:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Slicing a 2D array also works along 1D arrays. Here we slice over rows, taking
    the last two:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对 2D 数组进行切片也可以沿 1D 数组进行。在这里，我们沿着行切片，取最后两行：
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This produced a 2D array of shape (2, 3).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了一个形状为 (2, 3) 的 2D 数组。
- en: 'To obtain a whole column in the 2D array, use the following syntax:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取 2D 数组中的整列，可以使用以下语法：
- en: '[PRE51]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The colon (`:`) tells NumPy to take all the rows; the `1` then selects only
    column 1, leaving you with only a 1D array from the center column of `arr2d`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号（`:`）告诉 NumPy 获取所有行；`1` 则选择仅第 1 列，这样你就只剩下来自 `arr2d` 中心列的 1D 数组。
- en: 'You can also extract a column with the following syntax, though in this case,
    rather than outputting a 1D array containing the column’s values, you generate
    a 2D array of shape (3, 1):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用以下语法提取一列，尽管在这种情况下，与其输出包含列值的 1D 数组，不如生成形状为 (3, 1) 的 2D 数组：
- en: '[PRE52]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As a rule of thumb, if you slice a 2D array using a mixture of integer indexes
    and slices, you’ll get a 1D array. If you slice along both axes, you’ll get another
    2D array. For a reference, see [Figure 18-4](ch18.xhtml#ch018fig4), which shows
    the results of using various expressions to sample a 2D array.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果你使用整数索引和切片的混合方式对 2D 数组进行切片，你会得到一个 1D 数组。如果你沿着两个轴进行切片，你会得到另一个 2D 数组。参考
    [图 18-4](ch18.xhtml#ch018fig4)，它展示了使用各种表达式从 2D 数组中采样的结果。
- en: As with 1D arrays, 2D slices are views of the array that you can use to modify
    the values in the source array. In this example, we select the middle column in
    the array in [Figure 18-3](ch18.xhtml#ch018fig3) and change all of its elements
    to `42`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 与 1D 数组一样，2D 切片是数组的视图，你可以使用这些视图来修改源数组中的值。在这个示例中，我们选择了 [图 18-3](ch18.xhtml#ch018fig3)
    中数组的中间列，并将其所有元素更改为 `42`。
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![Image](../images/18fig04.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/18fig04.jpg)'
- en: '*Figure 18-4: Example slices through a 2D ndarray*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-4：2D ndarray 的示例切片*'
- en: 'To select individual elements from 2D arrays, specify a pair of integers as
    the element’s indexes. For example, to obtain the element from the intersection
    of the second row and second column, enter the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 2D 数组中选择单个元素，指定一对整数作为元素的索引。例如，要获取第二行和第二列交点处的元素，可以输入以下内容：
- en: '[PRE54]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Note that this syntax is a less cumbersome version of the more traditional
    nested list syntax in which each index is surrounded by brackets:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种语法是更传统的嵌套列表语法的简化版本，在传统语法中，每个索引都被括号包围：
- en: '[PRE55]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '**Indexing and Slicing Higher-Dimensional Arrays**'
  id: totrans-263
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**索引和切片高维数组**'
- en: The key to indexing and slicing arrays with more than two dimensions is to think
    of them as a *series of stacked arrays of a lower dimension*. We’ll refer to these
    stacked arrays as *plans*. As with 2D arrays, the order in which you index 3D
    arrays is determined by their shape tuples.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有多于两个维度的数组，索引和切片的关键是将它们视为 *一系列堆叠的低维数组*。我们将这些堆叠的数组称为 *plans*。与 2D 数组一样，索引
    3D 数组的顺序由它们的形状元组决定。
- en: 'Let’s start by looking at a 3D array with a shape of (2, 3, 4). You can think
    of the first value in the shape tuple as the number of 2D arrays within that 3D
    array. The next two numbers are treated as the shape tuple for these 2D arrays,
    representing its rows and columns, respectively. Here’s an example:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来看一个形状为 (2, 3, 4) 的 3D 数组。你可以将形状元组中的第一个值看作是该 3D 数组中的 2D 数组的数量。接下来的两个数字被视为这些
    2D 数组的形状元组，分别表示其行数和列数。这里有一个示例：
- en: '[PRE56]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: When you look at the output, you should see two separate 2D arrays of shape
    `(3, 4)` stacked one atop the other. These are demarcated by a space in the output
    as well as by a new set of square brackets around the second 2D array.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 查看输出时，你应该会看到两个形状为 `(3, 4)` 的 2D 数组，一个叠放在另一个上面。这些数组通过输出中的空格以及第二个 2D 数组周围的一组新的方括号来区分。
- en: Because the array contains two matrices, the 3D component to the shape tuple
    is `2`. This number comes first, so you can think of the shape tuple as recording
    the number of plans, rows, and columns.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数组包含两个矩阵，形状元组中的 3D 维度是 `2`。这个数字排在前面，因此你可以将形状元组看作记录了计划、行和列的数量。
- en: 'To see how this works, let’s use indexes to retrieve the value `20` in the
    array. We can use the array’s shape tuple (plans, rows, columns) to guide us:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看看这如何工作，我们可以使用索引来检索数组中的值 `20`。我们可以使用数组的形状元组 (plans, rows, columns) 来指导我们：
- en: '[PRE57]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: First, we had to choose the second 2D array, which has an index of `1` because
    Python starts counting at 0\. Next, we selected the third row using `2`. Finally,
    we selected the first column using `0`. The key is to work your way through the
    shape tuple in order. The dimension of the array will let you know how many indexes
    you’ll need (three for a 3D array, four for a 4D array, and so on).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须选择第二个 2D 数组，它的索引是 `1`，因为 Python 从 0 开始计数。接下来，我们使用 `2` 选择了第三行。最后，我们使用
    `0` 选择了第一列。关键是按顺序处理形状元组。数组的维度会告诉你需要多少个索引（三维数组需要三个，四维数组需要四个，以此类推）。
- en: 'Slicing also follows the order of the shape tuple. For example, to get a view
    of the `arr3d` array’s lower 2D array, you would enter `1` for the plan and then
    use the colon shorthand notation to select all of its rows and columns:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 切片也遵循形状元组的顺序。例如，要查看 `arr3d` 数组的下方 2D 数组，您需要输入 `1` 作为平面索引，然后使用冒号简写符号选择所有行和列：
- en: '[PRE58]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: For reference, [Figure 18-5](ch18.xhtml#ch018fig5) shows some example slices
    through a 3D array, along with the resulting shapes.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 供参考，[图 18-5](ch18.xhtml#ch018fig5)展示了通过 3D 数组的一些示例切片，以及相应的形状。
- en: '![Image](../images/18fig05.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/18fig05.jpg)'
- en: '*Figure 18-5: Some example slices through a 3D ndarray*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-5：通过 3D ndarray 的一些示例切片*'
- en: 'As always, changing the values of elements in a slice will change the source
    array, unless the slice is a copy:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，改变切片中元素的值将会改变源数组，除非该切片是一个副本：
- en: '[PRE59]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Before we move on, let’s practice indexing and slicing an array with more than
    three dimensions. For example, look at the following 4D array:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，先练习一下对多于三维的数组进行索引和切片。例如，看看以下 4D 数组：
- en: '[PRE60]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Note how the array starts with four square brackets and uses two blank lines
    to separate the two stacked 3D arrays. Because we’re dealing with a 4D array,
    to select the `20` element, you will need to enter four indexes:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，数组以四个方括号开始，并且使用两个空行将两个堆叠的 3D 数组分开。由于我们处理的是一个 4D 数组，要选择 `20` 元素，您需要输入四个索引：
- en: '[PRE61]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, from left to right, you indexed a 4D array to a 3D array; a 3D array to
    a 2D array; a 2D array to a 1D array; and a 1D array to a single element. This
    might be more obvious in [Figure 18-6](ch18.xhtml#ch018fig6), which demonstrates
    stepping through these in order.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，从左到右，您将 4D 数组索引到 3D 数组；3D 数组索引到 2D 数组；2D 数组索引到 1D 数组；最后将 1D 数组索引到单个元素。这在[图
    18-6](ch18.xhtml#ch018fig6)中可能更加明显，它演示了这些操作的顺序。
- en: '![Image](../images/18fig06.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/18fig06.jpg)'
- en: '*Figure 18-6: Indexing a 4D array down to a single element at [1, 1, 0, 2]*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-6：将 4D 数组索引到单个元素 [1, 1, 0, 2]*'
- en: This style of ordering will hold true for any number of dimensions.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这种排序风格适用于任意数量的维度。
- en: Finally, for 4D arrays, where the fourth dimension represents time, it can be
    useful to think of the arrays arranged horizontally, rather than vertically ([Figure
    18-7](ch18.xhtml#ch018fig7)).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于 4D 数组，其中第四维表示时间，考虑将数组水平排列而不是垂直排列会很有帮助（[图 18-7](ch18.xhtml#ch018fig7)）。
- en: '![Image](../images/18fig07.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/18fig07.jpg)'
- en: '*Figure 18-7: Each 4D slice can represent the same 3D array sampled at a different
    time.*'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-7：每个 4D 切片可以代表同一个 3D 数组，在不同的时间进行采样。*'
- en: In this case, each single 4D slice would represent the same dataset (the 3D
    array) measured at a different point in time. So, to look at the first set of
    measurements, you would enter `arr4d[0, :, :]`, and for the last set of measurements,
    you could enter `arr4d[-1, :, :]`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个单一的 4D 切片将代表同一数据集（3D 数组），但是在不同的时间点进行测量的。因此，要查看第一组测量结果，您可以输入 `arr4d[0,
    :, :]`，而查看最后一组测量结果时，可以输入 `arr4d[-1, :, :]`。
- en: '**Boolean Indexing**'
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**布尔索引**'
- en: In addition to using numerical indexing and slicing, you can select elements
    in arrays using conditions and Boolean operators. This lets you extract elements
    without any prior knowledge of where they are in the array. For example, you might
    have hundreds of monitor wells around a landfill, and you want to find all the
    wells that detect the pollutant toluene above a certain threshold value. With
    Boolean indexing, not only can you identify these wells, but you can also create
    a new array based on the output.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用数值索引和切片，您还可以通过条件和布尔运算符在数组中选择元素。这使您能够在不知道元素位置的情况下提取数组中的元素。例如，您可能在一个垃圾填埋场周围有数百个监测井，您想找到所有检测到有毒污染物甲苯超过某一阈值的井。使用布尔索引，您不仅可以识别这些井，还可以基于输出创建一个新的数组。
- en: 'To illustrate, the following condition searches an array for any elements that
    are integers greater than or equal to four:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，以下条件会在数组中搜索任何大于或等于四的整数元素：
- en: '[PRE62]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As you can see, Python will return an array of Boolean values containing `True`
    values where the condition is satisfied. Note that this syntax works for `ndarray`s
    of any dimension.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Python 会返回一个布尔值数组，其中条件满足的地方会有 `True` 值。请注意，这种语法适用于任何维度的 `ndarray`。
- en: 'NumPy can also use the Booleans behind the scenes, allowing you to slice an
    array based on a conditional:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 还可以在后台使用布尔值，允许你基于条件对数组进行切片：
- en: '[PRE63]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Comparing two arrays also produces a Boolean array. In this example we flag
    as `True` all the values in `arr_2` that are greater than those in `arr_1`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个数组也会生成一个布尔数组。在这个例子中，我们标记所有在 `arr_2` 中大于 `arr_1` 中对应元素的值为 `True`：
- en: '[PRE64]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'A common use of Boolean indexing is to partition a grayscale image into foreground
    and background segments, a process called *thresholding*. This produces a binary
    image based on a cutoff value. Here’s an example in which we create a 2D image
    array and then threshold on values above 4:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔索引的常见用法是将灰度图像分割为前景和背景部分，这个过程叫做 *阈值处理*。这会生成一个基于截断值的二值图像。以下是一个示例，其中我们创建一个二维图像数组，然后对大于
    4 的值进行阈值处理：
- en: '[PRE65]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Remember that `True` evaluates to `1`, and `False` evaluates to `0`. This lets
    us convert a Boolean array to a numerical array by tacking on the `astype()` function
    and passing it the integer data type.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`True` 等价于 `1`，`False` 等价于 `0`。这使得我们可以通过附加 `astype()` 函数并传入整数数据类型来将布尔数组转换为数值数组。
- en: 'After thresholding, the `0` values in the new array should form the number
    4:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 阈值处理后，新的数组中 `0` 值的区域应该形成数字 4：
- en: '[PRE66]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To assign values based on a Boolean array, you index the source array based
    on a conditional and then assign a value. Here, we assign `0` to all the elements
    in the array with a value less than `5`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据布尔数组赋值，你需要基于条件索引源数组，然后赋予一个值。在这里，我们将 `0` 赋值给所有值小于 `5` 的数组元素：
- en: '[PRE67]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Likewise, you can change entire rows, columns, and plans in a Boolean array
    using indexing. For example, `img[0] = 0` changes all the elements in the first
    row of the `img` array to `0`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你也可以使用索引改变布尔数组中的整行、整列和整块。例如，`img[0] = 0` 会将 `img` 数组的第一行所有元素都改为 `0`。
- en: The use of Booleans in arrays involves a few quirks. Extracting elements from
    an array using Boolean indexing creates a copy of the data by default, meaning
    that there is no need to use the `copy()` function. Another idiosyncrasy of Boolean
    arrays is that you must replace the `and` and `or` keywords with the `&` and `|`characters,
    respectively, when writing comparison statements.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组中使用布尔值涉及一些怪癖。通过布尔索引提取数组中的元素会默认创建数据的副本，这意味着不需要使用 `copy()` 函数。布尔数组的另一个特殊之处是，在编写比较语句时，你必须将
    `and` 和 `or` 关键字分别替换为 `&` 和 `|` 符号。
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的知识**'
- en: '6.  Create a 2D `ndarray` of size 30 and shape (5, 6). Then, slice the array
    to sample the values highlighted in gray:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 6.  创建一个大小为 30、形状为 (5, 6) 的二维 `ndarray`。然后，切片数组以提取灰色高亮的值：
- en: '![Image](../images/f0517.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0517.jpg)'
- en: '7.  Resample the array from Question 6 to retrieve the elements highlighted
    in gray:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 7.  对第 6 题中的数组进行重采样，提取灰色高亮的元素：
- en: '![Image](../images/f0517-1.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0517-1.jpg)'
- en: '8.  Slicing an `ndarray` produces:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 8.  切片一个 `ndarray` 会得到：
- en: a.  A new array object
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: a.  一个新的数组对象
- en: b.  A copy of the source array
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: b.  源数组的副本
- en: c.  A view of the source array
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: c.  源数组的视图
- en: d.  A Python `list` object
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: d.  一个 Python `list` 对象
- en: '9.  Slicing a 2D array with a combination of a scalar index and another slice
    produces:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 9.  使用标量索引和另一个切片组合切片二维数组会得到：
- en: a.  A 2D array
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: a.  一个二维数组
- en: b.  A 1D array
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: b.  一个一维数组
- en: d.  A single element (0D array)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: d.  一个单一元素（0D 数组）
- en: e.  None of the above
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: e.  以上都不是
- en: 10.  What is the rank of this array?
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 10.  这个数组的秩是多少？
- en: array([[[[ 0,  1,  2,  3],
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: array([[[[ 0,  1,  2,  3],
- en: '[ 4,  5,  6,  7]],'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 4,  5,  6,  7]],'
- en: '[[ 8,  9, 10, 11],'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '[[ 8,  9, 10, 11],'
- en: '[12, 13, 14, 15]]],'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[12, 13, 14, 15]]],'
- en: '[[[16, 17, 18, 19],'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '[[[16, 17, 18, 19],'
- en: '[20, 21, 22, 23]],'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '[20, 21, 22, 23]],'
- en: '[[24, 25, 26, 27],'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '[[24, 25, 26, 27],'
- en: '[28, 29, 30, 31]]]])'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '[28, 29, 30, 31]]]])'
- en: '**Manipulating Arrays**'
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**操作数组**'
- en: NumPy provides tools for working with existing arrays. Common manipulations
    include reshaping arrays, swapping their axes, and merging and splitting arrays.
    These come in handy for jobs like rotating, enlarging, and translating images
    and for fitting machine learning models.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy提供了处理现有数组的工具。常见的操作包括重塑数组、交换轴以及合并和拆分数组。这些操作在旋转、放大、平移图像以及拟合机器学习模型时非常有用。
- en: '***Shaping and Transposing***'
  id: totrans-335
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***改变形状与转置***'
- en: NumPy comes with functions to change the shape of arrays and to transpose arrays
    (invert columns with rows) and swap axes. You’ve already been working with one
    of these, the `reshape()` function.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy提供了更改数组形状、转置数组（交换列和行）以及交换轴的函数。你已经在使用其中的一个函数——`reshape()`。
- en: 'One thing to be aware of with `reshape()` is that, like all NumPy assignments,
    it creates a *view* of an array rather than a *copy*. In the following example,
    reshaping the `arr1d` array produces only a temporary change to the array:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`reshape()`时要注意的一点是，像所有NumPy赋值一样，它创建的是数组的*视图*而不是*副本*。在以下示例中，重塑`arr1d`数组只会对数组进行临时更改：
- en: '[PRE68]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This behavior is useful when you want to temporarily change the shape of the
    array for use in a computation, without copying any data.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为在你希望暂时更改数组的形状以便进行计算时非常有用，而不需要复制任何数据。
- en: 'Likewise, assigning an array to a new variable just creates another reference
    to the source array. In the following example, despite assigning the reshaped
    `arr1d` array to a new variable named `arr2d`, changing values in `arr2d` also
    changes the corresponding values in `arr1d`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，将数组赋值给一个新变量只是创建了对源数组的另一个引用。在以下示例中，尽管将重塑后的`arr1d`数组赋值给一个名为`arr2d`的新变量，但更改`arr2d`中的值也会更改`arr1d`中相应的值：
- en: '[PRE69]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Obviously, this type of behavior can really trip you up. As mentioned earlier,
    if you want to create a distinct `ndarray` object from an existing array, use
    the `copy()` function.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这种行为可能会让你陷入困境。如前所述，如果你想从现有数组创建一个独立的`ndarray`对象，使用`copy()`函数。
- en: 'To modify an array in place rather than just create a view, use the `shape()`
    function and pass it a shape tuple:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改数组本身而不是仅创建视图，使用`shape()`函数并传递一个形状元组：
- en: '[PRE70]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Compare this code to `In [114] – Out [116]`. Here, the source array is permanently
    changed.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 将这段代码与`In [114] – Out [116]`进行比较。在这里，源数组被永久更改。
- en: '**Flattening an Array**'
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**展平数组**'
- en: There are times when you’ll want to use 1D arrays as input to some process,
    even though your data is of a higher dimension. For example, standard plotting
    routines typically expect simple data structures, such as a list or single flat
    array. Likewise, image data is generally converted to 1D arrays before being fed
    to the input layer of a neural network.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，即使你的数据是高维的，你也希望使用1D数组作为某些过程的输入。例如，标准的绘图程序通常期望使用简单的数据结构，如列表或单一的平面数组。同样，图像数据通常会在输入神经网络的输入层之前转换为1D数组。
- en: 'Going from a higher dimension array to a 1D array is known as *flattening*.
    The `ravel()` function lets you do this while making a *view* of the array. Here’s
    an example:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 从高维数组转到1D数组称为*展平*。`ravel()`函数可以在创建数组*视图*的同时完成这一操作。以下是一个示例：
- en: '[PRE71]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To create a copy of the array when flattening, you can use the `flatten()`
    method of the `ndarray` object. Because this produces a copy rather than a view,
    it’s a bit slower than `ravel()`. Here’s the syntax:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在展平数组时创建数组副本，可以使用`ndarray`对象的`flatten()`方法。由于该方法生成的是副本而不是视图，因此比`ravel()`稍慢。以下是语法：
- en: '[PRE72]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You can also flatten the original array in place by using the `shape()` function
    and passing it the number of elements in the array:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用`shape()`函数并传递数组中元素的数量来原地展平原始数组：
- en: '[PRE73]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Remember, you can get the size of an array by calling its `size` attribute using
    dot notation.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你可以通过调用数组的`size`属性并使用点符号获取数组的大小。
- en: '**Swapping an Array’s Columns and Rows**'
  id: totrans-355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**交换数组的列和行**'
- en: When analyzing data, it’s good to examine it in multiple ways. [Figure 18-8](ch18.xhtml#ch018fig8)
    shows average temperature data by month for three Texas cities. How you present
    the data, either *by month* or *by location*, can be beneficial depending on the
    questions you’re trying to answer as well as how much space you have for printing
    the information in a report.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析数据时，最好从多个角度进行检查。[图18-8](ch18.xhtml#ch018fig8)显示了三个德州城市的月平均气温数据。如何展示数据——是*按月份*展示，还是*按地点*展示——取决于你想回答的问题以及你在报告中可以用于展示数据的空间。
- en: '![Image](../images/18fig08.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/18fig08.jpg)'
- en: '*Figure 18-8: The average monthly temperatures ( ^°F) for three Texas cities
    displayed by month and by city*'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-8：显示德克萨斯州三个城市的平均月度温度（^°F），按月和城市展示*'
- en: 'Just as Microsoft Excel lets you easily invert columns and rows, NumPy provides
    the handy `transpose()` function for this operation:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 就像Microsoft Excel可以轻松地反转列和行一样，NumPy提供了便捷的`transpose()`函数来执行此操作：
- en: '[PRE74]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This is still a view of the original array. To create a new array, you can
    add the `copy()` function, like so:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然是原始数组的视图。要创建一个新数组，你可以添加`copy()`函数，如下所示：
- en: '[PRE75]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'For higher-dimension arrays, you can pass `transpose()` a tuple of axis numbers
    in the order you desire. Let’s transpose a 3D array so that the axes are reordered
    with the third axis first, the first axis second, and the second axis unchanged:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高维度的数组，你可以将`transpose()`传递一个轴编号的元组，按照你希望的顺序进行转置。让我们将一个3D数组转置，使轴的顺序变为第三轴优先，第一轴第二，第二轴保持不变：
- en: '[PRE76]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Another method for swapping axes is `swapaxes()`. It takes a pair of axes and
    rearranges the array, returning a view of the array. Here’s an example:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 交换轴的另一种方法是`swapaxes()`。它接受一对轴并重新排列数组，返回数组的视图。这里是一个例子：
- en: '[PRE77]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '***Joining Arrays***'
  id: totrans-367
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***连接数组***'
- en: 'NumPy provides several functions that let you merge, or *stack*, multiple existing
    arrays into a new array. Let’s begin by making two 2D arrays, the first composed
    of zeros, and the second composed of ones:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy提供了几个函数，让你可以将多个现有数组合并或*堆叠*成一个新数组。让我们首先创建两个2D数组，第一个由零组成，第二个由一组成：
- en: '[PRE78]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now let’s vertically stack the two arrays using the `vstack()` function. This
    will add the second array to the first as new rows along axis 0:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`vstack()`函数将两个数组按垂直方向堆叠。这将把第二个数组作为新行沿轴0添加到第一个数组中：
- en: '[PRE79]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `hstack()` function adds the second array as new columns on the first:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`hstack()`函数将第二个数组作为新列添加到第一个数组上：'
- en: '[PRE80]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `row_stack()` and `column_stack()` functions stack 1D arrays to form new
    2D arrays. For example:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`row_stack()`和`column_stack()`函数将1D数组堆叠成新的2D数组。例如：'
- en: '[PRE81]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: You also can accomplish column stacking along axis 2 using the depth stacking
    function (`dstack((x, y, z)`). This function is like `hstack()`, except that it
    first converts 1D arrays to 2D column vectors.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用深度堆叠函数（`dstack((x, y, z))`）在轴2上进行列堆叠。此函数类似于`hstack()`，不同之处在于它首先将1D数组转换为2D列向量。
- en: '***Splitting Arrays***'
  id: totrans-377
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***分割数组***'
- en: NumPy also lets you divide, or *split*, arrays. As with joining, you can perform
    splitting both vertically and horizontally.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy还允许你对数组进行除法或*分割*。与连接一样，你可以垂直或水平地进行分割。
- en: 'Here’s an example using the `vsplit()` function. First, let’s create an array:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用`vsplit()`函数的例子。首先，让我们创建一个数组：
- en: '[PRE82]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'To split the `source` array in half vertically (axis=0), pass the `vsplit()`
    function the array and `2` as arguments:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`source`数组垂直（沿轴0）分割为两部分，传递`vsplit()`函数数组和`2`作为参数：
- en: '[PRE83]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'To split the `source` array in half horizontally (axis=1), pass `hsplit()`
    the array and `2` as arguments:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`source`数组水平（沿轴1）分割为两部分，传递`hsplit()`数组和`2`作为参数：
- en: '[PRE84]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In the previous examples, the array split must result in an *equal division*.
    With the `split()` function, you can split an array into multiple arrays along
    an axis. You pass the function the original array and the indexes for the parts
    to be split, along with an optional axis number (the default is axis 0). For example,
    to divide the `source` array into three arrays of two, three, and one columns,
    you would enter the following:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，数组分割必须是*均等划分*。使用`split()`函数，你可以沿一个轴将数组分割成多个数组。你将原始数组和要分割的部分的索引传递给该函数，并且可以选择传递一个轴编号（默认为轴0）。例如，要将`source`数组分割成包含两列、三列和一列的三个数组，你将输入如下：
- en: '[PRE85]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The indexes`[2, 5]` told NumPy where along axis 1 to split the array. To repeat
    this over the rows, just change the `axis` argument to `0`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 索引`[2, 5]`告诉NumPy在轴1上哪里分割数组。要在行上重复此操作，只需将`axis`参数改为`0`。
- en: '**Doing Math Using Arrays**'
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用数组进行数学运算**'
- en: 'Now that you know how to create and manipulate arrays, it’s time to apply them
    to their main purpose: mathematical operations. NumPy uses two internal implementations
    to efficiently perform math on arrays: *vectorization* and *broadcasting*. Vectorization
    supports operations between equal-sized arrays, and broadcasting extends this
    behavior to arrays with different shapes.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何创建和操作数组，是时候将它们应用于它们的主要目的：数学运算了。NumPy使用两种内部实现来高效地对数组进行数学运算：*矢量化*和*广播*。矢量化支持在相同大小的数组之间进行运算，而广播则将这种行为扩展到形状不同的数组。
- en: '***Vectorization***'
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***矢量化***'
- en: One of the most powerful features of `ndarray`s, *vectorization* lets you perform
    batch operations on data without the need for explicit `for` loops. This means
    that you can apply an operation on a entire array at once without selecting each
    individual element from it.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`ndarray` 的最强大特性之一，*矢量化* 让你无需显式的 `for` 循环就能对数据执行批量操作。这意味着你可以一次性对整个数组应用操作，而不需要选择其中的每一个元素。'
- en: For equal-sized arrays, arithmetic operations are applied elementwise, as shown
    in [Figure 18-9](ch18.xhtml#ch018fig9).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 对于相同大小的数组，算术运算会逐元素应用，如 [图 18-9](ch18.xhtml#ch018fig9) 所示。
- en: '![Image](../images/18fig09.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/18fig09.jpg)'
- en: '*Figure 18-9: Mathematical operations involving equal-sized arrays are performed
    on corresponding elements.*'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-9：涉及相同大小数组的数学运算会在对应元素上执行。*'
- en: Because looping takes place behind the scenes with code implemented in C, vectorization
    leads to faster processing. Let’s look at an example in which we compare looping
    in Python to vectorization in NumPy.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 因为循环背后是用 C 语言实现的，所以矢量化可以加速处理。我们来看看一个例子，比较 Python 中的循环和 NumPy 中的矢量化。
- en: 'Start by creating two datasets of 100,000 randomly-selected integers between
    0 and 500:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 从创建两个包含 100,000 个随机选择的整数（范围是 0 到 500）的数据集开始：
- en: '[PRE86]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now, make an empty list and then loop through the two datasets, appending each
    item in `data_a` to the list if it also occurs in `data_b`:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个空列表，然后遍历这两个数据集，如果 `data_a` 中的每一项也出现在 `data_b` 中，就将它添加到列表中：
- en: '[PRE87]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Note that this can also be written as `shared_list = [item for item in data_a
    if item in data_b]` using list comprehension.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这也可以通过列表推导式写成 `shared_list = [item for item in data_a if item in data_b]`。
- en: Depending on your hardware, you’ll need to wait around five seconds or more
    for this loop to complete.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的硬件配置，可能需要等待五秒钟或更长时间，才能完成这个循环。
- en: 'Here’s the first three values in the list (yours may differ, as these were
    randomly generated):'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这是列表中的前三个值（你的可能不同，因为这些是随机生成的）：
- en: '[PRE88]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Let’s repeat this exercise using the NumPy `isin()` function. This optimized
    function compares each element in a target array to another array and returns
    a Boolean. We can combine this with indexing to return the elements with values
    of `True`:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 NumPy 的 `isin()` 函数重复这个练习。这个优化函数会将目标数组中的每个元素与另一个数组进行比较，并返回一个布尔值。我们可以将其与索引结合使用，返回值为
    `True` 的元素：
- en: '[PRE89]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This computation ran almost instantly compared to the previous standard Python
    loop.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前标准的 Python 循环相比，这个计算几乎是瞬间完成的。
- en: 'Vectorization also permits more concise and readable code that can resemble
    mathematical expressions. For example, to multiply two arrays together, you can
    forgo writing nested loops and just state `arr1 * arr2`, as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 矢量化还允许更简洁和可读的代码，看起来像数学表达式。例如，要将两个数组相乘，你可以省略嵌套循环，直接写成 `arr1 * arr2`，如下所示：
- en: '[PRE90]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This behavior applies to all basic arithmetic operations, such as adding, subtracting,
    multiplying, and dividing.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为适用于所有基本的算术运算，例如加法、减法、乘法和除法。
- en: '***Broadcasting***'
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***广播***'
- en: The technique of *broadcasting* allows operations on arrays of different shapes.
    To understand how it works, consider [Figure 18-10](ch18.xhtml#ch018fig10), in
    which a 1D array of four elements is multiplied by a 1D array of a single element.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '*广播* 技术允许对不同形状的数组执行运算。为了理解它的工作原理，考虑 [图 18-10](ch18.xhtml#ch018fig10)，其中一个包含四个元素的
    1D 数组与一个包含单个元素的 1D 数组相乘。'
- en: '![Image](../images/18fig10.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/18fig10.jpg)'
- en: '*Figure 18-10: An example of broadcasting when multiplying a 1D ndarray by
    a scalar*'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-10：当将 1D ndarray 与标量相乘时的广播示例*'
- en: As you can see, the smaller array is stretched across the larger array until
    they have compatible shapes. The array of shape (1,) becomes an array of shape
    (4,) with its single value repeated so that element-by-element multiplication
    can occur. This same behavior applies to operations between scalars and arrays.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，较小的数组会扩展到较大的数组，直到它们具有兼容的形状。形状为 (1,) 的数组会变成形状为 (4,) 的数组，其中单一的值会被重复，以便可以进行逐元素乘法操作。这种行为同样适用于标量与数组之间的运算。
- en: For broadcasting to work, the dimensions of the two arrays must be compatible.
    Two dimensions are compatible when they are equal or one of them is 1\. NumPy
    determines this compatibility by comparing the array shape tuples, starting with
    the trailing (rightmost) dimension and moving left. For example, to check whether
    different 24-element 3D arrays are broadcastable, NumPy would compare their shape
    tuples, as shown in [Figure 18-11](ch18.xhtml#ch018fig11).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 要使广播生效，两个数组的维度必须兼容。当两个维度相等或其中一个维度为 1 时，它们是兼容的。NumPy 通过比较数组形状元组来确定这种兼容性，从右到左进行比较。例如，要检查不同的
    24 元素 3D 数组是否可以广播，NumPy 将比较它们的形状元组，如 [图 18-11](ch18.xhtml#ch018fig11) 所示。
- en: '![Image](../images/18fig11.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/18fig11.jpg)'
- en: '*Figure 18-11: Checking 3D array dimensions for compatibility (gray-shaded
    values)*'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-11：检查 3D 数组的维度是否兼容（灰色阴影值）*'
- en: Starting with the trailing dimension ➊, NumPy determines that both pairs of
    arrays are compatible, as at least one is equal to 1\. This holds true for the
    next comparison ➋, but the bottom pair fails in the last comparison ➌, because
    6 and 3 are not equal. Consequently, we can’t perform any mathematical operations
    between these two arrays.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 从尾部维度 ➊ 开始，NumPy 确定这两对数组是兼容的，因为至少有一个维度等于 1。对于下一个比较 ➋，这仍然成立，但在最后的比较 ➌ 中，底部的那一对数组失败了，因为
    6 和 3 不相等。因此，我们无法在这两个数组之间执行任何数学操作。
- en: By contrast, in [Figure 18-12](ch18.xhtml#ch018fig12), a 2D and 1D array are
    compatible, so the 1D array can broadcast down to fill in the missing rows.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，在 [图 18-12](ch18.xhtml#ch018fig12) 中，一个 2D 数组和一个 1D 数组是兼容的，因此 1D 数组可以广播到缺失的行中。
- en: '![Image](../images/18fig12.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/18fig12.jpg)'
- en: '*Figure 18-12: An example of broadcasting when adding a 2D array to a 1D array*'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-12：将 2D 数组与 1D 数组相加时广播的示例*'
- en: This allows for element-by-element addition. Broadcasting can occur along rows,
    columns, or plans, as needed. For more on broadcasting, including a practical
    example, visit *[https://numpy.org/doc/stable/user/basics.broadcasting.html](https://numpy.org/doc/stable/user/basics.broadcasting.html)*.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许按元素进行加法运算。广播可以沿着行、列或平面进行，具体取决于需要。有关广播的更多信息，包括实际示例，请访问 *[https://numpy.org/doc/stable/user/basics.broadcasting.html](https://numpy.org/doc/stable/user/basics.broadcasting.html)*。
- en: '***The Matrix Dot Product***'
  id: totrans-423
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***矩阵点积***'
- en: In NumPy, basic multiplication between arrays is executed element for element.
    In other words, each element in one array is multiplied by the corresponding element
    in a second array. This includes the multiplication of 2D arrays, also known as
    matrices.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NumPy 中，数组之间的基本乘法是按元素执行的。换句话说，一个数组中的每个元素都与第二个数组中对应的元素相乘。这也包括 2D 数组的乘法，通常称为矩阵乘法。
- en: You might remember from math class, however, that proper matrix multiplication
    involves performing operations on rows and columns, not elements. This is the
    *matrix dot product*, in which the horizontals in the first matrix are multiplied
    by the verticals in the second matrix. The results are then added, as shown by
    the gray-shaded values in [Figure 18-13](ch18.xhtml#ch018fig13). Not only is this
    process not *by element*, but it’s also noncommutative, as `arr1 * arr2` is not
    equal to `arr2 * arr1`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能还记得数学课上，正确的矩阵乘法涉及对行和列进行操作，而不是按元素进行。这就是 *矩阵点积*，其中第一个矩阵的水平方向与第二个矩阵的垂直方向相乘，结果然后相加，如
    [图 18-13](ch18.xhtml#ch018fig13) 中的灰色阴影值所示。这个过程不仅不是 *按元素* 执行的，而且是不可交换的，因为 `arr1
    * arr2` 不等于 `arr2 * arr1`。
- en: '![Image](../images/18fig13.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/18fig13.jpg)'
- en: '*Figure 18-13: The matrix dot product*'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-13：矩阵点积*'
- en: 'For multiplying two matrices in this way, NumPy provides the `dot()` function.
    Here’s an example using the matrices in [Figure 18-13](ch18.xhtml#ch018fig13):'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 要以这种方式相乘两个矩阵，NumPy 提供了 `dot()` 函数。以下是使用 [图 18-13](ch18.xhtml#ch018fig13) 中的矩阵的示例：
- en: '[PRE91]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: You can also use the alternate syntax `arr1.dot(arr2)` to compute the dot product.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用替代语法 `arr1.dot(arr2)` 来计算点积。
- en: In addition to the dot product, NumPy comes with other functions for performing
    linear algebra. To see the full list, visit *[https://numpy.org/doc/stable/reference/routines.linalg.html](https://numpy.org/doc/stable/reference/routines.linalg.html)*.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 除了点积外，NumPy 还提供了其他进行线性代数运算的函数。要查看完整列表，请访问 *[https://numpy.org/doc/stable/reference/routines.linalg.html](https://numpy.org/doc/stable/reference/routines.linalg.html)*。
- en: '***Incrementing and Decrementing Arrays***'
  id: totrans-432
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***递增和递减数组***'
- en: 'You can use augmented operators such as `+=` to change the values in an array
    without creating a new array. Here are some examples using a 1D array:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用增强运算符，如 `+=`，在不创建新数组的情况下更改数组中的值。以下是使用一维数组的一些示例：
- en: '[PRE92]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: In these cases, the scalar value is applied to every element in the array.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，标量值会应用到数组中的每个元素。
- en: '***Using NumPy Functions***'
  id: totrans-436
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 NumPy 函数***'
- en: Like Python’s standard `math` module, NumPy comes with its own set of mathematical
    functions. These include universal functions and aggregate functions. A *universal*
    function, also known as a *ufunc*, acts in an element-by-element fashion and generates
    a new array with the same size as the input. *Aggregate* functions act on a whole
    array and produce a single value, such as the sum of the elements in the array.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Python 的标准 `math` 模块类似，NumPy 也提供了一套自己的数学函数。这些函数包括通用函数和聚合函数。*通用*函数，也称为 *ufunc*，按元素逐个处理，并生成一个与输入大小相同的新数组。*聚合*函数作用于整个数组，生成一个单一值，例如数组中元素的总和。
- en: '**Universal Functions**'
  id: totrans-438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**通用函数**'
- en: 'Universal functions that perform simple element-by-element transformations,
    such as taking the log or squaring an element, are referred to as *unary* ufuncs.
    To use them, call the function and pass it an `ndarray`, as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 执行简单逐元素转换的通用函数，例如取对数或平方一个元素，称为 *一元* ufunc。使用它们时，调用该函数并传入一个 `ndarray`，如下所示：
- en: '[PRE93]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Some of the more useful unary ufuncs are listed in [Table 18-4](ch18.xhtml#ch018tab4).
    You can find a complete list at *[https://numpy.org/doc/stable/reference/ufuncs.html#ufuncs/](https://numpy.org/doc/stable/reference/ufuncs.html#ufuncs/)*.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常用的一元 ufunc 已列在 [表 18-4](ch18.xhtml#ch018tab4) 中。你可以在 *[https://numpy.org/doc/stable/reference/ufuncs.html#ufuncs/](https://numpy.org/doc/stable/reference/ufuncs.html#ufuncs/)*
    上找到完整的列表。
- en: '**Table 18-4:** Useful NumPy Unary Universal Functions'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 18-4：** 有用的 NumPy 一元通用函数'
- en: '| **Function** | **Description** |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| --- | --- |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `abs` | Compute absolute value of each element |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| `abs` | 计算每个元素的绝对值 |'
- en: '| `fabs` | Compute absolute value of each element and return float |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| `fabs` | 计算每个元素的绝对值并返回浮动类型 |'
- en: '| `all` | Test whether all array elements along an axis evaluate to True |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| `all` | 测试沿指定轴的所有数组元素是否均为 True |'
- en: '| `any` | Test whether any array element along an axis evaluates to True |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| `any` | 测试沿指定轴的任意数组元素是否为 True |'
- en: '| `ceil` | Compute smallest integer greater than or equal to each element |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '| `ceil` | 计算每个元素大于或等于它的最小整数 |'
- en: '| `floor` | Compute largest integer less than or equal to each element |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| `floor` | 计算每个元素小于或等于它的最大整数 |'
- en: '| `clip` | Limit values in array to a specified min, max range |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| `clip` | 将数组中的值限制在指定的最小值和最大值范围内 |'
- en: '| `round` | Round values in array to a specified number of decimals |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| `round` | 将数组中的值四舍五入到指定的小数位数 |'
- en: '| `exp` | Compute the exponent (ex) of each element |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| `exp` | 计算每个元素的指数（ex） |'
- en: '| `log, log10, log2` | Compute the natural, base 10, or base 2 log per element
    |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| `log, log10, log2` | 计算每个元素的自然对数、以 10 为底的对数或以 2 为底的对数 |'
- en: '| `rint` | Round elements to the nearest integer preserving the dtype |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| `rint` | 将元素四舍五入到最接近的整数，同时保持数据类型 |'
- en: '| `sign` | Compute sign of each element (positive=1, zero=0, negative=-1) |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| `sign` | 计算每个元素的符号（正数=1，零=0，负数=-1） |'
- en: '| `sqrt` | Compute square root of each element |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| `sqrt` | 计算每个元素的平方根 |'
- en: '| `square` | Compute the square of each element |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| `square` | 计算每个元素的平方 |'
- en: '| `modf` | Return the fractional and integral parts of array as a new array
    |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| `modf` | 返回数组的整数部分和小数部分，作为新数组 |'
- en: '| `isnan` | Return Boolean array indicating NaN (Not a Number) values |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| `isnan` | 返回布尔数组，指示 NaN（非数字）值 |'
- en: '| `degrees` | Convert elements representing radians to degrees |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| `degrees` | 将表示弧度的元素转换为角度 |'
- en: '| `radians` | Convert elements representing degrees to radians |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| `radians` | 将表示角度的元素转换为弧度 |'
- en: '| `cos, sin, tan` | Compute cosine, sine, or tangent for each element |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| `cos, sin, tan` | 计算每个元素的余弦、正弦或正切 |'
- en: '| `cosh, sinh, tanh` | Compute hyperbolic cosine, sine, or tangent for each
    element |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| `cosh, sinh, tanh` | 计算每个元素的双曲余弦、双曲正弦或双曲正切 |'
- en: '| `arccos, arcsin, arctan` | Compute inverse trigonometric functions per element
    |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| `arccos, arcsin, arctan` | 计算每个元素的反三角函数 |'
- en: '| `arccosh, arcsinh, arctanh` | Compute inverse hyperbolic trigonometric functions
    per element |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| `arccosh, arcsinh, arctanh` | 计算每个元素的反双曲三角函数 |'
- en: '| `sort` | `arr.sort()` sorts in-place; `np.sort()` returns a sorted copy |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| `sort` | `arr.sort()` 就地排序；`np.sort()` 返回排序后的副本 |'
- en: 'Universal functions that accept two arrays as input and return a single array
    are called *binary* ufuncs. The following binary functions find the maximum and
    minimum values in two arrays and return them in new arrays:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 接受两个数组作为输入并返回单一数组的通用函数称为*二元* ufunc。以下二元函数用于找到两个数组中的最大值和最小值，并将结果返回为新数组：
- en: '[PRE94]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Some other binary functions are listed in [Table 18-5](ch18.xhtml#ch018tab5).
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些二元函数列在[表 18-5](ch18.xhtml#ch018tab5)中。
- en: '**Table 18-5:** Useful NumPy Binary Universal Functions'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 18-5：** 有用的 NumPy 二元通用函数'
- en: '| **Function** | **Description** |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| --- | --- |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `add` | Add arrays element by element |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| `add` | 按元素相加 |'
- en: '| `subtract` | Subtract second argument array from first argument array by
    element |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| `subtract` | 按元素从第一个数组中减去第二个数组 |'
- en: '| `multiply` | Multiply arrays element by element |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| `multiply` | 按元素相乘 |'
- en: '| `divide` | Divide arrays element by element |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| `divide` | 按元素相除 |'
- en: '| `floor_divide` | Divide arrays and truncate the remainder |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '| `floor_divide` | 对数组进行除法运算并截断余数 |'
- en: '| `power` | Raise elements in first array to powers in second array |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '| `power` | 将第一个数组中的元素提升到第二个数组中的幂 |'
- en: '| `maximum, fmax` | Return the maximum value by element, ignoring NaN values
    for `fmax` |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| `maximum, fmax` | 按元素返回最大值，`fmax`忽略 NaN 值 |'
- en: '| `minimum, fmin` | Return the minimum value by element, ignoring NaN values
    for `fmax` |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '| `minimum, fmin` | 按元素返回最小值，`fmax`忽略 NaN 值 |'
- en: '| `mod` | Return the modulus by element |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '| `mod` | 按元素返回模值 |'
- en: '| `copysign` | Copy sign of values in second array to values in first array
    |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '| `copysign` | 将第二个数组中的符号复制到第一个数组的值上 |'
- en: '| `greater` | Return Boolean array for elementwise *greater than* comparison
    |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '| `greater` | 返回元素逐一*大于*的布尔数组 |'
- en: '| `greater_equal` | Return Boolean array for elementwise *greater than or equal
    to* comparison |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '| `greater_equal` | 返回元素逐一*大于或等于*的布尔数组 |'
- en: '| `less` | Return Boolean array for elementwise *less than* comparison |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| `less` | 返回元素逐一*小于*的布尔数组 |'
- en: '| `less_equal` | Return Boolean array for elementwise *less than or equal to*
    comparison |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| `less_equal` | 返回元素逐一*小于或等于*的布尔数组 |'
- en: '| `equal` | Return Boolean array for elementwise *equality* comparison |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '| `equal` | 返回元素逐一*相等*的布尔数组 |'
- en: '| `not_equal` | Return Boolean array for elementwise negative equality comparison
    |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '| `not_equal` | 返回元素逐一负相等的布尔数组 |'
- en: 'For more on universal functions visit: *[https://numpy.org/doc/stable/user/basics.ufuncs.html](https://numpy.org/doc/stable/user/basics.ufuncs.html)*.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多关于通用函数的信息，请访问：*[https://numpy.org/doc/stable/user/basics.ufuncs.html](https://numpy.org/doc/stable/user/basics.ufuncs.html)*。
- en: '**Statistical Methods**'
  id: totrans-491
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**统计方法**'
- en: NumPy also comes with methods that compute statistics for an entire array or
    for data along an axis. Reducing the elements in an array to a single value can
    be referred to as *aggregation* or *reduction*.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 还提供了一些方法，用于计算整个数组或沿某一轴的数据的统计值。将数组中的元素减少为单一值的操作称为*聚合*或*归约*。
- en: 'Let’s try out some of these using a 2D array of randomly generated integers:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个包含随机生成整数的二维数组来尝试一下这些方法：
- en: '[PRE95]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'To calculate the mean value for all the elements in this array, call `mean()`
    on the array using dot notation:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算这个数组中所有元素的均值，可以使用点符号在数组上调用`mean()`：
- en: '[PRE96]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'You can also pass the array to the `mean()` function, like so:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将数组传递给`mean()`函数，像这样：
- en: '[PRE97]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The optional `axis` argument lets you specify the axis over which to compute
    the statistics. For example, specifying axis 1 means that the calculation is performed
    *across the columns*, producing a 1D array with the same number of elements as
    rows in the array:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的`axis`参数允许你指定计算统计值的轴。例如，指定轴 1 意味着计算将在*列方向*进行，结果是一个一维数组，元素个数等于数组中的行数：
- en: '[PRE98]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Specifying axis 0 tells the function to compute the *down the rows*. In the
    following example, this yields a 1D array of five elements, equal to the number
    of columns:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 指定轴 0 告诉函数沿*行方向*进行计算。在下面的示例中，这将生成一个一维数组，包含五个元素，等于列的数量：
- en: '[PRE99]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'These functions can also be called without the `axis` keyword:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数也可以在没有`axis`关键字的情况下调用：
- en: '[PRE100]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[Table 18-6](ch18.xhtml#ch018tab6) lists some useful statistical methods for
    arrays. You can use the whole array or specify an axis.'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 18-6](ch18.xhtml#ch018tab6)列出了一些有用的数组统计方法。你可以使用整个数组，也可以指定轴。'
- en: '**Table 18-6:** Useful NumPy Statistical Methods'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 18-6：** 有用的 NumPy 统计方法'
- en: '| **Function** | **Description** |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| --- | --- |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `argmin` | Index of the element with the minimum value |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '| `argmin` | 最小值元素的索引 |'
- en: '| `argmax` | Index of the element with the maximum value |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '| `argmax` | 最大值元素的索引 |'
- en: '| `count_nonzero` | Counts the number of non-zero values in an array |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '| `count_nonzero` | 计算数组中非零值的数量 |'
- en: '| `cumprod` | Cumulative product of elements starting with index 1 |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
  zh: '| `cumprod` | 从索引1开始的元素累积积 |'
- en: '| `cumsum` | Cumulative sum of elements starting with index 0 |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| `cumsum` | 从索引0开始的元素累积和 |'
- en: '| `mean` | Arithmetic mean of elements |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| `mean` | 元素的算术平均值 |'
- en: '| `min` | Minimum value of elements |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| `min` | 元素的最小值 |'
- en: '| `max` | Maximum value of elements |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '| `max` | 元素的最大值 |'
- en: '| `std` | Standard deviation of elements |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '| `std` | 元素的标准差 |'
- en: '| `sum` | Sum of the elements |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '| `sum` | 元素的和 |'
- en: '| `var` | Variance of the elements |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| `var` | 元素的方差 |'
- en: 'Note that NumPy also comes with the `apply_along_axis()` aggregate function
    that lets you supply the statistical function, axis, and array as arguments. Here’s
    an example using the previous array:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，NumPy 还提供了 `apply_along_axis()` 聚合函数，它允许你传递统计函数、轴和数组作为参数。以下是使用前述数组的一个示例：
- en: '[PRE101]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'You can also define your own functions and pass them to `apply_along_axis()`:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以定义自己的函数并将它们传递给 `apply_along_axis()`：
- en: '[PRE102]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Notice how, in these examples, you were able to work with the array without
    explicitly iterating over every element. Again, this is one of the great strengths
    of NumPy.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这些示例中，你能够在不显式遍历每个元素的情况下操作数组。这再次展示了NumPy的一个强大优势。
- en: '**Generating Pseudorandom Numbers**'
  id: totrans-525
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**生成伪随机数**'
- en: NumPy comes with functions for creating arrays from different types of probability
    distributions. These are useful for tasks such as generating randomized data to
    test machine learning models, creating data distributions with a known shape or
    distribution, randomly drawing data for a Monte Carlo simulation, and so on. They’re
    also at least an order of magnitude faster than similar functions in Python’s
    built-in `random` module.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 提供了用于从不同类型的概率分布创建数组的函数。这些函数对于生成随机数据来测试机器学习模型、创建具有已知形状或分布的数据分布、为蒙特卡洛模拟随机抽取数据等任务非常有用。它们的运行速度通常比
    Python 内建的 `random` 模块中的类似函数快至少一个数量级。
- en: Table18-7 lists some of the functions you can find in `np.random`. For the full
    list, visit *[https://numpy.org/doc/stable/reference/random/index.html](https://numpy.org/doc/stable/reference/random/index.html)*.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 表18-7列出了你可以在 `np.random` 中找到的一些函数。完整列表请访问 *[https://numpy.org/doc/stable/reference/random/index.html](https://numpy.org/doc/stable/reference/random/index.html)*。
- en: '**Table 18-7:** Useful NumPy Pseudorandom Functions'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '**表18-7：** 有用的NumPy伪随机函数'
- en: '| **Function** | **Description** |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| --- | --- |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `beta` | Draw samples from a Beta distribution |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
  zh: '| `beta` | 从Beta分布中绘制样本 |'
- en: '| `binomial` | Draw samples from a binomial distribution |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '| `binomial` | 从二项分布中绘制样本 |'
- en: '| `chisquare` | Draw samples from a chi-square distribution |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '| `chisquare` | 从卡方分布中绘制样本 |'
- en: '| `gamma` | Draw samples from a Gamma distribution |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '| `gamma` | 从Gamma分布中绘制样本 |'
- en: '| `normal` | Draw random samples from a normal (Gaussian) distribution |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '| `normal` | 从正态（高斯）分布中绘制随机样本 |'
- en: '| `permutation` | Return a permuted range or random permutation of a sequence
    |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '| `permutation` | 返回一个排列的范围或序列的随机排列 |'
- en: '| `power` | Draw from a power function distribution |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '| `power` | 从幂函数分布中绘制样本 |'
- en: '| `rand` | Create an array of a given shape populated with random samples from
    a uniform distribution over (0, 1) |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '| `rand` | 创建一个给定形状的数组，填充来自（0, 1）区间的均匀分布随机样本 |'
- en: '| `randint` | Return random integers from low (inclusive) to high (exclusive)
    |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '| `randint` | 返回从低（包含）到高（不包含）的随机整数 |'
- en: '| `randn` | Return a sample (or samples) from the “standard normal” distribution
    |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '| `randn` | 从“标准正态”分布中返回一个样本（或多个样本） |'
- en: '| `random` | Return random floats in the half-open interval (0.0, 1.0) |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
  zh: '| `random` | 返回位于半开区间（0.0, 1.0）中的随机浮点数 |'
- en: '| `seed` | Change the seed for the random number generator |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
  zh: '| `seed` | 更改随机数生成器的种子 |'
- en: '| `shuffle` | Randomly permute a sequence in-place |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
  zh: '| `shuffle` | 原地随机排列序列 |'
- en: '| `uniform` | Draw samples from uniform distribution over half-open interval
    (low, high) |'
  id: totrans-544
  prefs: []
  type: TYPE_TB
  zh: '| `uniform` | 从半开区间（low, high）中绘制均匀分布的样本 |'
- en: '**Reading and Writing Array Data**'
  id: totrans-545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**读取和写入数组数据**'
- en: NumPy can load and save data from and to disk in both binary and text format.
    Supported text formats are **.txt* and **.csv*. Generally, you will want to use
    the pandas library, built on NumPy, to work with text or tabular data. We look
    at pandas in [Chapter 20](ch20.xhtml).
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 可以以二进制和文本格式从磁盘加载和保存数据。支持的文本格式有 **.txt** 和 **.csv**。通常，你会使用基于 NumPy 的 pandas
    库来处理文本或表格数据。我们将在[第 20 章](ch20.xhtml)中讨论 pandas。
- en: 'For storing and retrieving data in binary format, NumPy provides the `save()`
    and `load()` functions. To save an array to disk, just pass a filename and the
    array as arguments, as shown here:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以二进制格式存储和检索数据，NumPy 提供了 `save()` 和 `load()` 函数。要将数组保存到磁盘，只需将文件名和数组作为参数传递，如下所示：
- en: '[PRE103]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This will produce the binary file *my_array.npy* (the *.npy* extension is added
    automatically).
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成二进制文件 *my_array.npy*（*.npy* 扩展名会自动添加）。
- en: 'To reload this file, enter the following:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新加载此文件，请输入以下命令：
- en: '[PRE104]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The `np.savez()` function lets you save several arrays into a single file in
    uncompressed *.npz* format. Providing keyword arguments lets you store them under
    the corresponding name in the output file:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.savez()` 函数允许你将多个数组保存到一个未压缩的 *.npz* 文件中。提供关键字参数可以将它们按相应的名称存储在输出文件中：'
- en: '[PRE105]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: If arrays are specified as *positional* arguments (no keywords), their names
    will be *arr_0*, *arr_1*, and so on, by default.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组作为 *位置* 参数（没有关键字）指定，它们的名称默认会是 *arr_0*、*arr_1* 等。
- en: 'To compress data when archiving, use the `savez_compressed()` function:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 要在归档时压缩数据，使用 `savez_compressed()` 函数：
- en: '[PRE106]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'In the event you do want to read-in a text file, NumPy provides the `genfromtxt()`
    (generate from text) function. To load a *.csv* file, for example, you would pass
    the function the file path, the character (comma) that separates the values, and
    whether the data columns have headers, as follows:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实想要读取文本文件，NumPy 提供了 `genfromtxt()`（从文本生成）函数。例如，要加载一个 *.csv* 文件，你需要将文件路径、分隔值的字符（如逗号），以及数据列是否有标题等信息传递给该函数。
- en: '[PRE107]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: This will produce a *structured* array that contains records rather than individual
    items. We haven’t discussed structured arrays, because they are a low-level tool
    and we’ll be using pandas for operations such as loading *.csv* files. However,
    you can read more about structured arrays at *[https://numpy.org/doc/stable/user/basics.rec.html](https://numpy.org/doc/stable/user/basics.rec.html)*.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个 *结构化* 数组，该数组包含记录而不是单独的元素。我们没有讨论结构化数组，因为它们是低级工具，我们将使用 pandas 来执行加载 *.csv*
    文件等操作。不过，你可以在 *[https://numpy.org/doc/stable/user/basics.rec.html](https://numpy.org/doc/stable/user/basics.rec.html)*
    阅读更多关于结构化数组的信息。
- en: '**TEST YOUR KNOWLEDGE**'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的知识**'
- en: '11.  Why is there so much whitespace in the first two elements in this output
    array: ([ 0, 2, -10000])?'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 11.  为什么在输出数组的前两个元素中会有这么多空白（[ 0, 2, -10000]）？
- en: 12.  Which function would you use to flatten a higher-dimension array to a 1D
    array?
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 12.  你会使用哪个函数将高维数组压缩为一维数组？
- en: a.  `meshgrid()`
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: a.  `meshgrid()`
- en: b.  `vsplit()`
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: b.  `vsplit()`
- en: c.  `ravel()`
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: c.  `ravel()`
- en: d.  `thresh()`
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: d.  `thresh()`
- en: 13.  For the array [[0, 1, 2], [3, 4, 5], [6, 7, 8]], what does the slice arr2d[:2,
    2] produce?
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 13.  对于数组 [[0, 1, 2], [3, 4, 5], [6, 7, 8]]，切片 arr2d[:2, 2] 会产生什么结果？
- en: a.  `array([1])`
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: a.  `array([1])`
- en: b.  `array([2, 5])`
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: b.  `array([2, 5])`
- en: c.  `array([6, 7])`
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: c.  `array([6, 7])`
- en: d.  `array([3, 4, 5])`
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: d.  `array([3, 4, 5])`
- en: '14.  In NumPy, array multiplication is done:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 14.  在 NumPy 中，数组的乘法是如何执行的：
- en: a.  Row by column
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: a.  按行列排列
- en: b.  Column by row
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: b.  按行列排列
- en: c.  Element by element
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: c.  按元素逐个执行
- en: d.  Row by row then column by column
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: d.  按行排列然后按列排列
- en: 15.  Which array is broadcastable with an array of shape (4, 3, 6, 1)?
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 15.  哪个数组可以与形状为 (4, 3, 6, 1) 的数组进行广播？
- en: a.  (4, 6, 6, 1)
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: a.  (4, 6, 6, 1)
- en: b.  (1, 6, 3, 1)
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: b.  (1, 6, 3, 1)
- en: c.  (4, 1, 6, 6)
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: c.  (4, 1, 6, 6)
- en: d.  (6, 3, 1, 6)
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: d.  (6, 3, 1, 6)
- en: '**Summary**'
  id: totrans-582
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: When working with uniform datasets, NumPy’s `ndarray`s represent a faster, more
    efficient alternative to competing data structures such as Python lists. Complex
    computations can be performed without the use of `for` loops, and `ndarray`s require
    significantly less memory than other Python data types.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理统一数据集时，NumPy 的 `ndarray` 是比 Python 列表等竞争数据结构更快、更高效的替代方案。可以在不使用 `for` 循环的情况下执行复杂计算，并且
    `ndarray` 占用的内存比其他 Python 数据类型少得多。
- en: 'This chapter touched on a lot of NumPy basics, but there’s still more to learn.
    To expand your knowledge of NumPy, I recommend NumPy’s “Beyond the Basics” page
    (*[https://numpy.org/doc/stable/user/c-info.beyond-basics.html](https://numpy.org/doc/stable/user/c-info.beyond-basics.html)*)
    and Wes McKinney’s *Python for Data Analysis: Data Wrangling with Pandas, NumPy,
    and IPython*, 2nd edition (O’Reilly, 2018).'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涉及了许多NumPy的基础知识，但仍有更多内容需要学习。为了扩展你对NumPy的了解，我推荐NumPy的“Beyond the Basics”页面
    (*[https://numpy.org/doc/stable/user/c-info.beyond-basics.html](https://numpy.org/doc/stable/user/c-info.beyond-basics.html)*)
    和Wes McKinney的*《Python数据分析：Pandas、NumPy与IPython数据清洗》*，第二版（O'Reilly，2018）。
- en: Before you run off and start applying NumPy, you’ll want to check out the next
    two chapters on Matplotlib and pandas. These libraries are built on top of NumPy
    and provide higher-level wrappers for performing data analysis and plotting.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始应用NumPy之前，建议先阅读接下来的两章，内容涉及Matplotlib和pandas。这些库是基于NumPy构建的，并提供了更高级的封装，用于执行数据分析和绘图。
