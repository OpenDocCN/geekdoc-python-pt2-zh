- en: '[1](nsp-venkitachalam503045-0008.xhtml#rch01)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Koch Snowflake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We’ll start our Python adventures by figuring out how to draw an interesting
    shape called the *Koch snowflake*, invented by Swedish mathematician Helge von Koch
    in 1904\. The Koch snowflake is a *fractal*—a type of figure that repeats itself
    as you zoom in to it.
  prefs: []
  type: TYPE_NORMAL
- en: Fractals derive their repeating nature from *recursion*, a technique where something
    is defined in terms of itself. In particular, you draw a fractal using a *recursive
    algorithm*, a repeating process where one repetition’s output becomes the input
    of the next repetition.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you work through this chapter, you’ll learn:'
  prefs: []
  type: TYPE_NORMAL
- en: • The basics of recursive algorithms and functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • How to create graphics using the `turtle` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • A recursive algorithm to draw the Koch snowflake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Some linear algebra
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah0301)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Figure 1-1](nsp-venkitachalam503045-0012.xhtml#fig1-1) shows what the Koch
    snowflake looks like. Notice how the large branch in the middle is repeated on
    a smaller scale by branches on the left and right. Similarly, the large branch
    in the middle is itself made up of smaller branches that echo the larger shape.
    This is the repeating, self-similar nature of a fractal.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f01001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-1: The Koch snowflake'
  prefs: []
  type: TYPE_NORMAL
- en: If you know how to calculate the points that form the basic shape making up
    the snowflake, you can develop an algorithm to perform the same calculations recursively.
    This way, you’ll draw smaller and smaller versions of that shape, building up
    the fractal. In this section, we’ll look generally at how recursion works. Then
    we’ll consider how to apply recursion, along with some linear algebra and Python’s
    `turtle` module, to draw the Koch snowflake.
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Recursion](nsp-venkitachalam503045-0008.xhtml#rbh0301)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get a feel for how recursion works, let’s take a look at a simple recursive
    algorithm: computing the factorial of a number. The factorial of a number can
    be defined by a function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '*f*(*N*) = 1 × 2 × 3 × . . . × (*N* − 1) × *N*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, the factorial of *N* is just the product of the numbers 1 through
    *N*. You can rewrite this as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*f*(*N*) = *N* × (*N* − 1) × . . . × 3 × 2 × 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'which can again be rewritten as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*f*(*N*) = *N* × *f*(*N* − 1)'
  prefs: []
  type: TYPE_NORMAL
- en: Wait, what did you just do? You defined *f* in terms of itself! That’s recursion.
    Calling *f*(*N*) will end up calling *f*(*N* − 1), which will end up calling *f*(*N*
    − 2), and so on. But how do you know when to stop? Well, you have to define *f*(1)
    as 1, and that will be the deepest step of the recursion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to implement the recursive factorial function in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You handle the case where *N* is equal to 1 by simply returning `1` ❶, and you
    implement the recursive call by calling `factorial()` again ❷, this time passing
    in `N-1`. The function will keep calling itself until *N* equals 1\. The net effect
    is that when the function returns, it will have computed the product of all numbers
    1 through *N*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, when you’re trying to implement an algorithm using recursion, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Define a base case where the recursion ends. In our factorial example, you
    did this by defining *f*(1) as 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Define the recursive step. For this you need to think about how to express
    the algorithm as a recursive process. In some algorithms, there can be multiple
    recursive calls from a function—as you’ll see soon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recursion is a helpful tool for problems that can be naturally partitioned into
    smaller versions of themselves. The factorial algorithm is a perfect example of
    this partitioning, and as you’ll soon see, so is drawing the Koch snowflake. That
    said, recursion isn’t always the most efficient way to solve a problem. In some
    cases, it would make sense to re-implement the recursive algorithm in terms of
    loops. But the fact remains that recursive algorithms are often more compact and
    elegant compared to their loopy counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: Computing the Snowflake
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s look at how to construct the Koch snowflake. [Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2)
    shows the basic pattern for drawing the snowflake. I’ll call this pattern a *flake*.
    The basis of the figure is the line segment ![](images/nsp-venkitachalam503045-m01001.jpg)
    of length *d*. The segment is split into three equal parts, ![](images/nsp-venkitachalam503045-m01002.jpg),
    ![](images/nsp-venkitachalam503045-m01003.jpg), and ![](images/nsp-venkitachalam503045-m01004.jpg),
    each of which has a length *r*. Instead of directly connecting points *P*[1] and
    *P*[3], these points are connected through *P*[2], which is chosen such that *P*[1],
    *P*[2], and *P*[3] form an equilateral triangle of side length *r* and height
    *h*. Point *C*, the midpoint of *P*[1] and *P*[3] (and by extension of *A* and
    *B*), falls directly beneath *P*[2], such that ![](images/nsp-venkitachalam503045-m01005.jpg)
    and ![](images/nsp-venkitachalam503045-m01006.jpg) are perpendicular.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f01002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-2: The basic pattern for drawing a Koch snowflake'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you understand how to calculate the points shown in [Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2),
    you’ll be able to recursively draw smaller and smaller flakes to reproduce the
    Koch snowflake. Essentially, your goal is this: given points *A* and *B*, you
    want to compute the points *P*[1], *P*[2], and *P*[3] and join them up as shown
    in the figure. To calculate those points, you’ll need to use some linear algebra,
    a mathematical discipline that lets you compute distances and figure out coordinates
    of points based on *vectors*, quantities that have both magnitude and direction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple formula from linear algebra that you’ll be using. Say you have
    a point *A* in 3D space and a unit vector ![](images/nsp-venkitachalam503045-m01007.jpg)
    (a *unit vector* is a vector with a length of 1 unit). Point *B* at a distance
    *d* along this unit vector is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '*B* = *A* + *d* × ![](images/nsp-venkitachalam503045-m01007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily verify this with an example. Take the case where *A* = (5, 0,
    0) and ![](images/nsp-venkitachalam503045-m01007.jpg) = (0, 1, 0). What are the
    coordinates for a point *B* that’s 10 units away from *A* along ![](images/nsp-venkitachalam503045-m01007.jpg)?
    Using the previous formula, you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '*B* = (5, 0, 0) + 10 × (0, 1, 0) = (5, 10, 0)'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, to get from *A* to *B*, you move 10 units along the positive
    y-axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another result you’ll use—let’s call it the *perpendicular vector trick*.
    Say you have a vector ![](images/nsp-venkitachalam503045-m01008.jpg) = (*a*, *b*).
    If you have another vector ![](images/nsp-venkitachalam503045-m01009.jpg) that’s
    perpendicular to ![](images/nsp-venkitachalam503045-m01008.jpg), it can be expressed
    as ![](images/nsp-venkitachalam503045-m01009.jpg) = (−*b*, *a*). You can verify
    that this trick works by taking the dot product of ![](images/nsp-venkitachalam503045-m01008.jpg)
    and ![](images/nsp-venkitachalam503045-m01009.jpg). To take the dot product of
    a pair of two-dimensional vectors, multiply the first components from each vector,
    then multiply the second components from each vector, and finally add the results
    together. In this case, the dot product of ![](images/nsp-venkitachalam503045-m01008.jpg)
    and ![](images/nsp-venkitachalam503045-m01009.jpg) is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-m01010.jpg) = (*a* × −*b*) + (*b* × *a*)
    = −*ab* + *ab* = 0'
  prefs: []
  type: TYPE_NORMAL
- en: The dot product of two perpendicular vectors will always be zero, so ![](images/nsp-venkitachalam503045-m01009.jpg)
    is indeed perpendicular to ![](images/nsp-venkitachalam503045-m01008.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, let’s return to the flake in [Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2).
    How can you calculate the position of *P*[2], given the coordinates for points
    *A* and *B*? You know that *P*[2] falls *h* distance away from point *C* along
    unit vector ![](images/nsp-venkitachalam503045-m01007.jpg). Your first linear
    algebra formula tells you:'
  prefs: []
  type: TYPE_NORMAL
- en: '*P*[2] = *C* + *h* × ![](images/nsp-venkitachalam503045-m01007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s put those variables in terms that you know. First, *C* is the midpoint
    of line ![](images/nsp-venkitachalam503045-m01011.jpg), so *C* = (*A* + *B*) /
    2\. Next, *h* is the height of an equilateral triangle with side length *r*. The
    Pythagorean theorem tells you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-m01012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, *r* is simply a third of the distance from *A* to *B*. If *A*
    has coordinates (*x*[1], *y*[1]) and *B* has coordinates (*x*[2], *y*[2]), you
    can calculate the distance between them as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-m01013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then simply divide *d* by 3 to get *r*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need a way to express ![](images/nsp-venkitachalam503045-m01007.jpg).
    You know that ![](images/nsp-venkitachalam503045-m01007.jpg) is perpendicular
    to vector ![](images/nsp-venkitachalam503045-m01014.jpg), and you can express
    ![](images/nsp-venkitachalam503045-m01014.jpg) by subtracting point *A*’s coordinates
    from point *B*’s:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-m01014.jpg) = (*x*[2] − *x*[1], *y*[2] −
    *y*[1])'
  prefs: []
  type: TYPE_IMG
- en: 'The magnitude of ![](images/nsp-venkitachalam503045-m01014.jpg) is given by
    *d* = ![](images/nsp-venkitachalam503045-m01015.jpg). You can now use the perpendicular
    vector trick to express ![](images/nsp-venkitachalam503045-m01007.jpg) in terms
    of *A* and *B*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-m01016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next you need to compute *P*[1] and *P*[3]. For this you’re going to use another
    result from linear algebra. Let’s say you have a line ![](images/nsp-venkitachalam503045-m01011.jpg)
    and a point *C* on the line. Let *a* be the distance of *C* from *A* and *b* be
    the distance of *C* from *B*. The point *C* is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-m01017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To understand this formula, think about what happens if *C* is the midpoint
    of *A* and *B*, meaning *a* and *b* would be the same. In this case, you can intuit
    that *C* ought to equal (*A* + *B*) / 2\. Substitute all the *b*s for *a*s in
    the previous equation. You’ll get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-m01018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With this new formula in mind, you can now compute *P*[1] and *P*[3]. These
    points divide line ![](images/nsp-venkitachalam503045-m01011.jpg) into thirds,
    meaning the distance from *P*[1] to *B* is twice the distance from *P*[1] to *A*
    (*b* = 2*a*), and the distance from *P*[3] to *A* is twice the distance from *P*[3]
    to *B* (*a* = 2*b*). Feeding this into the formula, you can therefore calculate
    the points as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-m01019.jpg) and ![](images/nsp-venkitachalam503045-m01020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you have everything you need to draw the first level of the snowflake fractal.
    Once you decide on *A* and *B*, you know how to compute the points *P*[1], *P*[2],
    and *P*[3]. But what happens at the second level of the fractal? You take each
    individual line segment from the flake at the first level ([Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2))
    and replace it with a smaller flake. The result is shown in [Figure 1-3](nsp-venkitachalam503045-0012.xhtml#fig1-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f01003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-3: The second step of Koch snowflake construction'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how each of the four line segments from [Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2),
    ![](images/nsp-venkitachalam503045-m01021.jpg), ![](images/nsp-venkitachalam503045-m01022.jpg),
    ![](images/nsp-venkitachalam503045-m01023.jpg), and ![](images/nsp-venkitachalam503045-m01024.jpg),
    has become the basis for a new flake. In the Koch snowflake program, you’ll be
    able to use the endpoints of each line segment, for example, *A* and *P*[1], as
    new values for *A* and *B* and recursively perform the same calculations used
    to arrive at the points in [Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2).
  prefs: []
  type: TYPE_NORMAL
- en: At each level of the fractal, you’ll subdivide the snowflake again, drawing
    smaller and smaller self-similar figures. This is the *recursive step* of the
    algorithm, which you’ll repeat until you reach a *base case*. This should happen
    when ![](images/nsp-venkitachalam503045-m01011.jpg) is smaller than a certain
    threshold—say, 10 pixels. When you hit that threshold, just draw the line segments
    and stop recursing.
  prefs: []
  type: TYPE_NORMAL
- en: To make the final output a bit fancy, you can draw three linked flakes as the
    first level of the fractal. This will give you the hexagonal symmetry of an actual
    snowflake. [Figure 1-4](nsp-venkitachalam503045-0012.xhtml#fig1-4) shows what
    the starting drawing will look like.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f01004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-4: Combining three snowflakes'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to calculate the coordinates for making the snowflake,
    let’s see how to use those coordinates in Python to actually draw an image.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing with turtle Graphics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you’ll use Python’s `turtle` module to draw the snowflake;
    it’s a simple drawing program modeled after the idea of a turtle dragging its
    tail through the sand, creating patterns. The `turtle` module includes methods
    you can use to set the position and color of the pen (the turtle’s tail) and many
    other useful functions for drawing.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you’ll see, all you need is a handful of graphics functions to draw the
    Koch snowflake. In fact, from the standpoint of `turtle`, drawing the snowflake
    is almost as easy as drawing a triangle. To prove it, and to give you a feel for
    how `turtle` works, the following program uses `turtle` to draw said triangle.
    Enter the code, save it as *test_turtle.py*, and run it in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You start by importing the `turtle` module ❶. Next, you define the `draw_triangle()`
    method, whose parameters are three pairs of x-coordinates and y-coordinates (the
    three corners of a triangle), as well as `t`, a `turtle` object. The method starts
    by calling `up()` ❷. This tells Python to move the pen up; in other words, take
    the pen off the virtual paper so that it won’t draw as you move the turtle. You
    want to position the turtle before you start drawing. The `setpos()` call ❸ sets
    the position of the turtle to the first pair of x- and y-coordinates. Calling
    `down()` ❹ sets the pen down, and for each of the subsequent `setpos()` calls,
    a line is drawn as the turtle moves to the next set of coordinates. The net result
    is a triangle drawing.
  prefs: []
  type: TYPE_NORMAL
- en: Next you declare a `main()` function to actually do the drawing. In it, you
    create the `turtle` object for drawing ❺ and hide the turtle ❻. Without this command,
    you’d see a small shape representing the turtle at the front of the line being
    drawn. You then call `draw_triangle()` to draw the triangle ❼, passing in the
    desired coordinates as arguments. The call to `mainloop()` ❽ keeps the `tkinter`
    window open after the triangle has been drawn. (`tkinter` is Python’s default
    GUI library.)
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-5](nsp-venkitachalam503045-0012.xhtml#fig1-5) shows the output of
    this simple program.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f01005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-5: The output of a simple `turtle` program'
  prefs: []
  type: TYPE_NORMAL
- en: You now have everything you need for the project. Let’s draw some flakes!
  prefs: []
  type: TYPE_NORMAL
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah0302)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, you’ll use the Python `turtle` module to draw the snowflake.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah0303)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To draw the Koch snowflake, define a recursive function, `drawKochSF()`. This
    function computes *P*[1], *P*[2], and *P*[3] in terms of *A* and *B* from [Figure
    1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2) and then recursively calls itself
    to perform the same calculation for smaller and smaller line segments until it
    reaches the smallest base case. Then it draws the flakes using `turtle`. For the
    full project code, skip ahead to [“The Complete Code”](nsp-venkitachalam503045-0012.xhtml#ah0307)
    on [page 16](nsp-venkitachalam503045-0012.xhtml#p16). The code is also available
    in the book’s GitHub repository at [https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py](https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py).
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the Points
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Begin the `drawKochSF()` function by calculating the coordinates for all the
    points needed to draw the basic flake pattern shown in [Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You define `drawKochSF()`, passing in the x- and y-coordinates for the endpoints
    of a line segment ![](images/nsp-venkitachalam503045-m01011.jpg), which forms
    the basis for one of the sides of the snowflake, as shown in [Figure 1-4](nsp-venkitachalam503045-0012.xhtml#fig1-4).
    You also pass in the `turtle` object `t`, which you use for the actual drawing.
    Then you compute all the parameters shown in [Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2),
    as discussed in the [“Computing the Snowflake”](nsp-venkitachalam503045-0012.xhtml#bh0302)
    section, starting with `d`, the distance from *A* to *B*. Dividing `d` by 3 gives
    you `r`, the length of each of the four line segments that makes up a flake. You
    use `r` to find `h`, the height of the “cone” at the heart of the flake.
  prefs: []
  type: TYPE_NORMAL
- en: You calculate the rest of the parameters as tuples containing an x- and a y-coordinate.
    The `p3` and `p1` tuples describe the two points at the base of the cone portion
    of the flake. Point `c` is the midpoint of `p1` and `p3`, and `n` is the unit
    vector perpendicular to line ![](images/nsp-venkitachalam503045-m01011.jpg). Along
    with `h`, they help you calculate `p2`, the apex of the flake’s cone.
  prefs: []
  type: TYPE_NORMAL
- en: Recursing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next part of the `drawKochSF()` function uses recursion to break down the
    first-level flake into smaller and smaller versions of itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First you check for the recursion-stopping criteria ❶. If `d`, the length of
    segment ![](images/nsp-venkitachalam503045-m01011.jpg), is greater than 10 pixels,
    you continue the recursion. You do this by calling the `drawKochSF()` function
    again—four times! With each call, you pass in a different set of arguments corresponding
    to the coordinates for one of the four line segments that make up a flake, which
    you calculated at the start of the function. At ❷, for example, you call `drawKochSF()`
    for the segment ![](images/nsp-venkitachalam503045-m01021.jpg). The other function
    calls are for segments ![](images/nsp-venkitachalam503045-m01022.jpg), ![](images/nsp-venkitachalam503045-m01023.jpg),
    and ![](images/nsp-venkitachalam503045-m01024.jpg). Within each of these recursive
    calls, you’ll perform a new set of calculations based on the new values for points
    *A* and *B*, and if `d` is still greater than 10 pixels, you’ll make another four
    recursive calls to `drawKochSF()`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing a Flake
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s look at what happens if segment ![](images/nsp-venkitachalam503045-m01011.jpg)
    is less than 10 pixels. This is the base case for the recursive algorithm. Since
    you’re below the threshold, you aren’t going to recurse. Instead, you actually
    draw the four line segments that make up a single flake pattern and return from
    the function. You use the `up()`, `down()`, and `setpos()` methods from the `turtle`
    module, which you learned about in the “Drawing with `turtle` Graphics” section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: First you draw the cone formed by points `p1`, `p2`, and `p3` ❶. Then you draw
    lines ![](images/nsp-venkitachalam503045-m01021.jpg) ❷ and ![](images/nsp-venkitachalam503045-m01024.jpg)
    ❸. Since you already performed all the required calculations at the start of the
    function, drawing is simply a matter of passing the appropriate coordinates to
    the `setpos()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[Writing the main() Function](nsp-venkitachalam503045-0008.xhtml#rbh0307)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `main()` function sets up a `turtle` object and calls `drawKochSF()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Figure 1-4](nsp-venkitachalam503045-0012.xhtml#fig1-4), you saw how you
    were going to draw three of the snowflakes to get a hexagonally symmetric image
    as the final output. You do this by making three calls to `drawKochSF()`. The
    coordinates used for points *A* and *B* are `(-100, 0), (100, 0)` for the first
    snowflake ❶, `(0, -173.2), (-100, 0)` for the second ❷, and `(100, 0), (0, -173.2)`
    for the third ❸. Notice that these are the same coordinates you used earlier to
    draw a triangle in your *test_turtle.py* program. Try to work out the coordinates
    for yourself. (Hint: ![](images/nsp-venkitachalam503045-m01025.jpg).)'
  prefs: []
  type: TYPE_NORMAL
- en: The `drawKochSF()` calls are enclosed in a Python `try` block to catch any exceptions
    that happen during drawing. For example, if you close the window while the drawing
    is still in process, an exception is thrown. You catch it in the `except` block
    ❹, where you print a message and exit the program. If you allow the drawing to
    complete, you’ll get to `turtle.Screen().exitonclick()` ❺, which will wait until
    you close the window by clicking anywhere inside it.
  prefs: []
  type: TYPE_NORMAL
- en: '[Running the Snowflake Code](nsp-venkitachalam503045-0008.xhtml#rah0304)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Run the code in a terminal as follows. [Figure 1-6](nsp-venkitachalam503045-0012.xhtml#fig1-6)
    shows the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](images/nsp-venkitachalam503045-f01006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-6: The Koch snowflake output'
  prefs: []
  type: TYPE_NORMAL
- en: There’s your beautiful snowflake!
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah0305)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned the basics of recursive functions and algorithms.
    You also learned how to draw simple graphics with Python’s `turtle` module. You
    put these concepts together to create a nice drawing of an interesting fractal
    called the Koch snowflake.
  prefs: []
  type: TYPE_NORMAL
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah0306)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have completed one fractal drawing, let’s look at another interesting
    one called the *Sierpi*ń*ski triangle*, named after the Polish mathematician Wacław
    Sierpiński. [Figure 1-7](nsp-venkitachalam503045-0012.xhtml#fig1-7) shows what
    it looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f01007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-7: The Sierpiński triangle'
  prefs: []
  type: TYPE_NORMAL
- en: Try drawing the Sierpiński triangle with `turtle` graphics. You can use a recursive
    algorithm like you did to draw the Koch snowflake. If you look at [Figure 1-7](nsp-venkitachalam503045-0012.xhtml#fig1-7),
    you’ll see that the large triangle is divided into three smaller triangles, with
    an upside-down triangular hole in the middle. Each of the three smaller triangles
    is itself divided into another three triangles plus a hole in the middle, and
    so on. That gives you a hint on how to split up your recursion.
  prefs: []
  type: TYPE_NORMAL
- en: (The solution to this problem is in the GitHub repository for the book [https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py](https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py))
  prefs: []
  type: TYPE_NORMAL
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah0307)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s the complete code listing for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
