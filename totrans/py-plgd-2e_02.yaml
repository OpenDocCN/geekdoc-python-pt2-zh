- en: '[1](nsp-venkitachalam503045-0008.xhtml#rch01)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[1](nsp-venkitachalam503045-0008.xhtml#rch01)'
- en: The Koch Snowflake
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 科赫雪花
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: We’ll start our Python adventures by figuring out how to draw an interesting
    shape called the *Koch snowflake*, invented by Swedish mathematician Helge von Koch
    in 1904\. The Koch snowflake is a *fractal*—a type of figure that repeats itself
    as you zoom in to it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过研究如何绘制一个有趣的形状——*科赫雪花*，来开始我们的 Python 探险。这个形状是由瑞典数学家 Helge von Koch 于 1904
    年发明的。科赫雪花是一个*分形*——一种随着你放大图形，图形会不断重复的类型。
- en: Fractals derive their repeating nature from *recursion*, a technique where something
    is defined in terms of itself. In particular, you draw a fractal using a *recursive
    algorithm*, a repeating process where one repetition’s output becomes the input
    of the next repetition.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 分形从*递归*中获得它的重复特性，递归是一种通过自我定义某个事物的技术。具体来说，你使用*递归算法*绘制分形，这是一种重复的过程，其中每次重复的输出成为下一次重复的输入。
- en: 'As you work through this chapter, you’ll learn:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: • The basics of recursive algorithms and functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 递归算法和函数的基础
- en: • How to create graphics using the `turtle` module
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 如何使用 `turtle` 模块创建图形
- en: • A recursive algorithm to draw the Koch snowflake
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一个递归算法来绘制科赫雪花
- en: • Some linear algebra
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 一些线性代数知识
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah0301)'
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[它是如何工作的](nsp-venkitachalam503045-0008.xhtml#rah0301)'
- en: '[Figure 1-1](nsp-venkitachalam503045-0012.xhtml#fig1-1) shows what the Koch
    snowflake looks like. Notice how the large branch in the middle is repeated on
    a smaller scale by branches on the left and right. Similarly, the large branch
    in the middle is itself made up of smaller branches that echo the larger shape.
    This is the repeating, self-similar nature of a fractal.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-1](nsp-venkitachalam503045-0012.xhtml#fig1-1)展示了科赫雪花的形态。注意中间的大分支是如何通过左侧和右侧的较小分支重复的。类似地，中间的大分支本身由一些较小的分支组成，这些分支呈现出类似的形态。这就是分形的重复、自相似特性。'
- en: '![](images/nsp-venkitachalam503045-f01001.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f01001.jpg)'
- en: 'Figure 1-1: The Koch snowflake'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-1：科赫雪花
- en: If you know how to calculate the points that form the basic shape making up
    the snowflake, you can develop an algorithm to perform the same calculations recursively.
    This way, you’ll draw smaller and smaller versions of that shape, building up
    the fractal. In this section, we’ll look generally at how recursion works. Then
    we’ll consider how to apply recursion, along with some linear algebra and Python’s
    `turtle` module, to draw the Koch snowflake.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道如何计算组成雪花基本形状的点，你可以开发一个算法来递归地执行相同的计算。通过这种方式，你将绘制出越来越小的该形状版本，逐步构建分形。在本节中，我们将大致了解递归的工作原理。然后，我们将考虑如何结合线性代数和
    Python 的 `turtle` 模块应用递归来绘制科赫雪花。
- en: '[Using Recursion](nsp-venkitachalam503045-0008.xhtml#rbh0301)'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[使用递归](nsp-venkitachalam503045-0008.xhtml#rbh0301)'
- en: 'To get a feel for how recursion works, let’s take a look at a simple recursive
    algorithm: computing the factorial of a number. The factorial of a number can
    be defined by a function, as shown here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解递归是如何工作的，我们来看看一个简单的递归算法：计算一个数字的阶乘。一个数字的阶乘可以通过一个函数来定义，如下所示：
- en: '*f*(*N*) = 1 × 2 × 3 × . . . × (*N* − 1) × *N*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(*N*) = 1 × 2 × 3 × . . . × (*N* − 1) × *N*'
- en: 'In other words, the factorial of *N* is just the product of the numbers 1 through
    *N*. You can rewrite this as:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，*N* 的阶乘只是从 1 到 *N* 的数字的积。你可以将其重写为：
- en: '*f*(*N*) = *N* × (*N* − 1) × . . . × 3 × 2 × 1'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(*N*) = *N* × (*N* − 1) × . . . × 3 × 2 × 1'
- en: 'which can again be rewritten as:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以再次重写为：
- en: '*f*(*N*) = *N* × *f*(*N* − 1)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(*N*) = *N* × *f*(*N* − 1)'
- en: Wait, what did you just do? You defined *f* in terms of itself! That’s recursion.
    Calling *f*(*N*) will end up calling *f*(*N* − 1), which will end up calling *f*(*N*
    − 2), and so on. But how do you know when to stop? Well, you have to define *f*(1)
    as 1, and that will be the deepest step of the recursion.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，你刚才做了什么？你将 *f* 定义为自己！这就是递归。调用 *f*(*N*) 最终会调用 *f*(*N* − 1)，然后再调用 *f*(*N* −
    2)，以此类推。但是你怎么知道什么时候停止呢？好吧，你必须将 *f*(1) 定义为 1，这将是递归的最深一步。
- en: 'Here’s how to implement the recursive factorial function in Python:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何在 Python 中实现递归阶乘函数：
- en: 'def factorial(N):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '定义阶乘函数（factorial）(N):'
- en: '❶ if N == 1:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ 如果 N == 1:'
- en: return 1
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 1
- en: 'else:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: ❷ return N * factorial(N-1)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回 N * factorial(N-1)
- en: You handle the case where *N* is equal to 1 by simply returning `1` ❶, and you
    implement the recursive call by calling `factorial()` again ❷, this time passing
    in `N-1`. The function will keep calling itself until *N* equals 1\. The net effect
    is that when the function returns, it will have computed the product of all numbers
    1 through *N*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当*N*等于1时，你通过简单地返回`1` ❶来处理该情况，然后通过再次调用`factorial()` ❷来实现递归调用，这次传入`N-1`。该函数将不断调用自身，直到*N*等于1。最终的效果是，当函数返回时，它将计算出从1到*N*所有数字的乘积。
- en: 'In general, when you’re trying to implement an algorithm using recursion, follow
    these steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，当你试图使用递归实现一个算法时，遵循以下步骤：
- en: 1\. Define a base case where the recursion ends. In our factorial example, you
    did this by defining *f*(1) as 1.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 定义递归结束的基准情况。在我们的阶乘例子中，你通过定义*f*(1)为1来做到这一点。
- en: 2\. Define the recursive step. For this you need to think about how to express
    the algorithm as a recursive process. In some algorithms, there can be multiple
    recursive calls from a function—as you’ll see soon.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 定义递归步骤。为此，你需要考虑如何将算法表示为一个递归过程。在某些算法中，可能会有多个递归调用来自一个函数——正如你很快就会看到的那样。
- en: Recursion is a helpful tool for problems that can be naturally partitioned into
    smaller versions of themselves. The factorial algorithm is a perfect example of
    this partitioning, and as you’ll soon see, so is drawing the Koch snowflake. That
    said, recursion isn’t always the most efficient way to solve a problem. In some
    cases, it would make sense to re-implement the recursive algorithm in terms of
    loops. But the fact remains that recursive algorithms are often more compact and
    elegant compared to their loopy counterparts.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是处理那些可以自然划分为更小版本的问题时的一个有用工具。阶乘算法就是这种划分的完美例子，正如你很快会看到的，绘制科赫雪花也是如此。不过，递归并不总是解决问题的最有效方式。在某些情况下，重新用循环来实现递归算法是有意义的。但事实是，递归算法通常比其循环算法更加简洁和优雅。
- en: Computing the Snowflake
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算雪花图形
- en: Now let’s look at how to construct the Koch snowflake. [Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2)
    shows the basic pattern for drawing the snowflake. I’ll call this pattern a *flake*.
    The basis of the figure is the line segment ![](images/nsp-venkitachalam503045-m01001.jpg)
    of length *d*. The segment is split into three equal parts, ![](images/nsp-venkitachalam503045-m01002.jpg),
    ![](images/nsp-venkitachalam503045-m01003.jpg), and ![](images/nsp-venkitachalam503045-m01004.jpg),
    each of which has a length *r*. Instead of directly connecting points *P*[1] and
    *P*[3], these points are connected through *P*[2], which is chosen such that *P*[1],
    *P*[2], and *P*[3] form an equilateral triangle of side length *r* and height
    *h*. Point *C*, the midpoint of *P*[1] and *P*[3] (and by extension of *A* and
    *B*), falls directly beneath *P*[2], such that ![](images/nsp-venkitachalam503045-m01005.jpg)
    and ![](images/nsp-venkitachalam503045-m01006.jpg) are perpendicular.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看如何构造科赫雪花。[图1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2)展示了绘制雪花的基本模式。我将这个模式称为*雪片*。图形的基础是长度为*d*的线段
    ![](images/nsp-venkitachalam503045-m01001.jpg)。该线段被分为三个相等的部分，分别是 ![](images/nsp-venkitachalam503045-m01002.jpg)、![](images/nsp-venkitachalam503045-m01003.jpg)
    和 ![](images/nsp-venkitachalam503045-m01004.jpg)，每一部分的长度为*r*。而不是直接连接点*P*[1]和*P*[3]，这些点通过*P*[2]连接，*P*[2]的选择使得*P*[1]、*P*[2]和*P*[3]*构成一个边长为*r*，高度为*h*的等边三角形。点*C*是*P*[1]和*P*[3]的中点（并且由此也为*A*和*B*的中点），它正好位于*P*[2]的正下方，使得
    ![](images/nsp-venkitachalam503045-m01005.jpg) 和 ![](images/nsp-venkitachalam503045-m01006.jpg)
    垂直。
- en: '![](images/nsp-venkitachalam503045-f01002.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f01002.jpg)'
- en: 'Figure 1-2: The basic pattern for drawing a Koch snowflake'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-2：绘制科赫雪花的基本模式
- en: 'Once you understand how to calculate the points shown in [Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2),
    you’ll be able to recursively draw smaller and smaller flakes to reproduce the
    Koch snowflake. Essentially, your goal is this: given points *A* and *B*, you
    want to compute the points *P*[1], *P*[2], and *P*[3] and join them up as shown
    in the figure. To calculate those points, you’ll need to use some linear algebra,
    a mathematical discipline that lets you compute distances and figure out coordinates
    of points based on *vectors*, quantities that have both magnitude and direction.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了如何计算[图1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2)中展示的点，你就能够递归地绘制越来越小的雪片，最终重现科赫雪花。基本上，你的目标是这样的：给定点*A*和*B*，你需要计算出点*P*[1]、*P*[2]和*P*[3]并将它们连接起来，如图所示。为了计算这些点，你需要使用一些线性代数，线性代数是一门数学学科，它使你能够计算距离并根据*向量*（具有大小和方向的量）确定点的坐标。
- en: 'Here’s a simple formula from linear algebra that you’ll be using. Say you have
    a point *A* in 3D space and a unit vector ![](images/nsp-venkitachalam503045-m01007.jpg)
    (a *unit vector* is a vector with a length of 1 unit). Point *B* at a distance
    *d* along this unit vector is given by:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你将使用的一个简单的线性代数公式。假设你有一个三维空间中的点 *A* 和一个单位向量 ![](images/nsp-venkitachalam503045-m01007.jpg)（*单位向量*是长度为
    1 单位的向量）。沿着该单位向量距离 *d* 的点 *B* 给出如下：
- en: '*B* = *A* + *d* × ![](images/nsp-venkitachalam503045-m01007.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*B* = *A* + *d* × ![](images/nsp-venkitachalam503045-m01007.jpg)'
- en: 'You can easily verify this with an example. Take the case where *A* = (5, 0,
    0) and ![](images/nsp-venkitachalam503045-m01007.jpg) = (0, 1, 0). What are the
    coordinates for a point *B* that’s 10 units away from *A* along ![](images/nsp-venkitachalam503045-m01007.jpg)?
    Using the previous formula, you get:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过一个例子轻松验证这一点。假设 *A* = (5, 0, 0) 且 ![](images/nsp-venkitachalam503045-m01007.jpg)
    = (0, 1, 0)。那么，沿着 ![](images/nsp-venkitachalam503045-m01007.jpg) 从 *A* 移动 10 个单位，*B*
    点的坐标是多少？使用之前的公式，你可以得到：
- en: '*B* = (5, 0, 0) + 10 × (0, 1, 0) = (5, 10, 0)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*B* = (5, 0, 0) + 10 × (0, 1, 0) = (5, 10, 0)'
- en: In other words, to get from *A* to *B*, you move 10 units along the positive
    y-axis.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，要从 *A* 移动到 *B*，你沿着正 y 轴移动了 10 个单位。
- en: 'Here’s another result you’ll use—let’s call it the *perpendicular vector trick*.
    Say you have a vector ![](images/nsp-venkitachalam503045-m01008.jpg) = (*a*, *b*).
    If you have another vector ![](images/nsp-venkitachalam503045-m01009.jpg) that’s
    perpendicular to ![](images/nsp-venkitachalam503045-m01008.jpg), it can be expressed
    as ![](images/nsp-venkitachalam503045-m01009.jpg) = (−*b*, *a*). You can verify
    that this trick works by taking the dot product of ![](images/nsp-venkitachalam503045-m01008.jpg)
    and ![](images/nsp-venkitachalam503045-m01009.jpg). To take the dot product of
    a pair of two-dimensional vectors, multiply the first components from each vector,
    then multiply the second components from each vector, and finally add the results
    together. In this case, the dot product of ![](images/nsp-venkitachalam503045-m01008.jpg)
    and ![](images/nsp-venkitachalam503045-m01009.jpg) is:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你将使用的另一个结果——我们称之为 *垂直向量技巧*。假设你有一个向量 ![](images/nsp-venkitachalam503045-m01008.jpg)
    = (*a*, *b*)。如果你有另一个与 ![](images/nsp-venkitachalam503045-m01008.jpg) 垂直的向量 ![](images/nsp-venkitachalam503045-m01009.jpg)，它可以表示为
    ![](images/nsp-venkitachalam503045-m01009.jpg) = (−*b*, *a*)。你可以通过对 ![](images/nsp-venkitachalam503045-m01008.jpg)
    和 ![](images/nsp-venkitachalam503045-m01009.jpg) 进行点积来验证这个技巧是否有效。对一对二维向量进行点积时，首先将每个向量的第一个分量相乘，然后将每个向量的第二个分量相乘，最后将结果相加。在这种情况下，
    ![](images/nsp-venkitachalam503045-m01008.jpg) 和 ![](images/nsp-venkitachalam503045-m01009.jpg)
    的点积是：
- en: '![](images/nsp-venkitachalam503045-m01010.jpg) = (*a* × −*b*) + (*b* × *a*)
    = −*ab* + *ab* = 0'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![](images/nsp-venkitachalam503045-m01010.jpg) = (*a* × −*b*) + (*b* × *a*)
    = −*ab* + *ab* = 0'
- en: The dot product of two perpendicular vectors will always be zero, so ![](images/nsp-venkitachalam503045-m01009.jpg)
    is indeed perpendicular to ![](images/nsp-venkitachalam503045-m01008.jpg).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 两个垂直向量的点积总是零，因此 ![](images/nsp-venkitachalam503045-m01009.jpg) 确实与 ![](images/nsp-venkitachalam503045-m01008.jpg)
    垂直。
- en: 'With this in mind, let’s return to the flake in [Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2).
    How can you calculate the position of *P*[2], given the coordinates for points
    *A* and *B*? You know that *P*[2] falls *h* distance away from point *C* along
    unit vector ![](images/nsp-venkitachalam503045-m01007.jpg). Your first linear
    algebra formula tells you:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点，让我们回到 [图 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2) 中的雪花。如何根据 *A*
    和 *B* 的坐标来计算 *P*[2] 的位置呢？你知道 *P*[2] 距离点 *C* 沿单位向量 ![](images/nsp-venkitachalam503045-m01007.jpg)
    的距离是 *h*。你的第一个线性代数公式告诉你：
- en: '*P*[2] = *C* + *h* × ![](images/nsp-venkitachalam503045-m01007.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*[2] = *C* + *h* × ![](images/nsp-venkitachalam503045-m01007.jpg)'
- en: 'Now let’s put those variables in terms that you know. First, *C* is the midpoint
    of line ![](images/nsp-venkitachalam503045-m01011.jpg), so *C* = (*A* + *B*) /
    2\. Next, *h* is the height of an equilateral triangle with side length *r*. The
    Pythagorean theorem tells you:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这些变量转化为你已知的形式。首先，*C* 是线 ![](images/nsp-venkitachalam503045-m01011.jpg)
    的中点，所以 *C* = (*A* + *B*) / 2。接下来，*h* 是边长为 *r* 的等边三角形的高度。毕达哥拉斯定理告诉你：
- en: '![](images/nsp-venkitachalam503045-m01012.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m01012.jpg)'
- en: 'In this case, *r* is simply a third of the distance from *A* to *B*. If *A*
    has coordinates (*x*[1], *y*[1]) and *B* has coordinates (*x*[2], *y*[2]), you
    can calculate the distance between them as:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，*r* 只是 *A* 到 *B* 距离的三分之一。如果 *A* 的坐标是 (*x*[1], *y*[1])，*B* 的坐标是 (*x*[2],
    *y*[2])，你可以通过以下公式计算它们之间的距离：
- en: '![](images/nsp-venkitachalam503045-m01013.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m01013.jpg)'
- en: Then simply divide *d* by 3 to get *r*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，只需将 *d* 除以 3 即可得到 *r*。
- en: 'Finally, you need a way to express ![](images/nsp-venkitachalam503045-m01007.jpg).
    You know that ![](images/nsp-venkitachalam503045-m01007.jpg) is perpendicular
    to vector ![](images/nsp-venkitachalam503045-m01014.jpg), and you can express
    ![](images/nsp-venkitachalam503045-m01014.jpg) by subtracting point *A*’s coordinates
    from point *B*’s:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要一种方式来表示 ![](images/nsp-venkitachalam503045-m01007.jpg)。你知道 ![](images/nsp-venkitachalam503045-m01007.jpg)
    与向量 ![](images/nsp-venkitachalam503045-m01014.jpg) 垂直，而且你可以通过从点 *B* 的坐标中减去点 *A*
    的坐标来表示 ![](images/nsp-venkitachalam503045-m01014.jpg)：
- en: '![](images/nsp-venkitachalam503045-m01014.jpg) = (*x*[2] − *x*[1], *y*[2] −
    *y*[1])'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m01014.jpg) = (*x*[2] − *x*[1], *y*[2] −
    *y*[1])'
- en: 'The magnitude of ![](images/nsp-venkitachalam503045-m01014.jpg) is given by
    *d* = ![](images/nsp-venkitachalam503045-m01015.jpg). You can now use the perpendicular
    vector trick to express ![](images/nsp-venkitachalam503045-m01007.jpg) in terms
    of *A* and *B*:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![](images/nsp-venkitachalam503045-m01014.jpg) 的大小由 *d* = ![](images/nsp-venkitachalam503045-m01015.jpg)
    给出。现在，你可以使用垂直向量技巧，将 ![](images/nsp-venkitachalam503045-m01007.jpg) 用 *A* 和 *B*
    来表示：'
- en: '![](images/nsp-venkitachalam503045-m01016.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m01016.jpg)'
- en: 'Next you need to compute *P*[1] and *P*[3]. For this you’re going to use another
    result from linear algebra. Let’s say you have a line ![](images/nsp-venkitachalam503045-m01011.jpg)
    and a point *C* on the line. Let *a* be the distance of *C* from *A* and *b* be
    the distance of *C* from *B*. The point *C* is given by:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要计算 *P*[1] 和 *P*[3]。为此，你将使用线性代数中的另一个结果。假设你有一条直线 ![](images/nsp-venkitachalam503045-m01011.jpg)
    和一条在线上的点 *C*。让 *a* 为 *C* 到 *A* 的距离，*b* 为 *C* 到 *B* 的距离。点 *C* 可以表示为：
- en: '![](images/nsp-venkitachalam503045-m01017.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m01017.jpg)'
- en: 'To understand this formula, think about what happens if *C* is the midpoint
    of *A* and *B*, meaning *a* and *b* would be the same. In this case, you can intuit
    that *C* ought to equal (*A* + *B*) / 2\. Substitute all the *b*s for *a*s in
    the previous equation. You’ll get:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这个公式，可以想象如果 *C* 是 *A* 和 *B* 的中点，即 *a* 和 *b* 相同会发生什么。在这种情况下，你可以直观地知道 *C* 应该等于
    (*A* + *B*) / 2\. 将前面的公式中所有的 *b* 替换为 *a*，你将得到：
- en: '![](images/nsp-venkitachalam503045-m01018.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m01018.jpg)'
- en: 'With this new formula in mind, you can now compute *P*[1] and *P*[3]. These
    points divide line ![](images/nsp-venkitachalam503045-m01011.jpg) into thirds,
    meaning the distance from *P*[1] to *B* is twice the distance from *P*[1] to *A*
    (*b* = 2*a*), and the distance from *P*[3] to *A* is twice the distance from *P*[3]
    to *B* (*a* = 2*b*). Feeding this into the formula, you can therefore calculate
    the points as:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个新公式，你现在可以计算 *P*[1] 和 *P*[3]。这些点将直线 ![](images/nsp-venkitachalam503045-m01011.jpg)
    分成三等份，这意味着从 *P*[1] 到 *B* 的距离是从 *P*[1] 到 *A* 距离的两倍（*b* = 2*a*），而从 *P*[3] 到 *A*
    的距离是从 *P*[3] 到 *B* 距离的两倍（*a* = 2*b*）。将其代入公式中，你可以计算出这些点：
- en: '![](images/nsp-venkitachalam503045-m01019.jpg) and ![](images/nsp-venkitachalam503045-m01020.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m01019.jpg) 和 ![](images/nsp-venkitachalam503045-m01020.jpg)'
- en: Now you have everything you need to draw the first level of the snowflake fractal.
    Once you decide on *A* and *B*, you know how to compute the points *P*[1], *P*[2],
    and *P*[3]. But what happens at the second level of the fractal? You take each
    individual line segment from the flake at the first level ([Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2))
    and replace it with a smaller flake. The result is shown in [Figure 1-3](nsp-venkitachalam503045-0012.xhtml#fig1-3).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你拥有了绘制雪花分形第一层所需的所有信息。一旦你确定了 *A* 和 *B*，你就知道如何计算点 *P*[1]、*P*[2] 和 *P*[3]。但是，分形的第二层会发生什么呢？你取第一层雪花中每一条线段（[图
    1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2)）并将其替换为一个更小的雪花。结果如 [图 1-3](nsp-venkitachalam503045-0012.xhtml#fig1-3)
    所示。
- en: '![](images/nsp-venkitachalam503045-f01003.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f01003.jpg)'
- en: 'Figure 1-3: The second step of Koch snowflake construction'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-3：Koch 雪花构造的第二步
- en: Notice how each of the four line segments from [Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2),
    ![](images/nsp-venkitachalam503045-m01021.jpg), ![](images/nsp-venkitachalam503045-m01022.jpg),
    ![](images/nsp-venkitachalam503045-m01023.jpg), and ![](images/nsp-venkitachalam503045-m01024.jpg),
    has become the basis for a new flake. In the Koch snowflake program, you’ll be
    able to use the endpoints of each line segment, for example, *A* and *P*[1], as
    new values for *A* and *B* and recursively perform the same calculations used
    to arrive at the points in [Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从[图1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2)，![](images/nsp-venkitachalam503045-m01021.jpg)，![](images/nsp-venkitachalam503045-m01022.jpg)，![](images/nsp-venkitachalam503045-m01023.jpg)，和![](images/nsp-venkitachalam503045-m01024.jpg)的每一条线段，已经成为了一个新雪花的基础。在科赫雪花程序中，你可以使用每条线段的端点，例如，*A*和*P*[1]，作为新的*A*和*B*值，并递归地执行相同的计算来得出[图1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2)中的点。
- en: At each level of the fractal, you’ll subdivide the snowflake again, drawing
    smaller and smaller self-similar figures. This is the *recursive step* of the
    algorithm, which you’ll repeat until you reach a *base case*. This should happen
    when ![](images/nsp-venkitachalam503045-m01011.jpg) is smaller than a certain
    threshold—say, 10 pixels. When you hit that threshold, just draw the line segments
    and stop recursing.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在分形的每一层，你会再次细分雪花，绘制越来越小的自相似图形。这是算法的*递归步骤*，你会重复这个步骤直到到达*基准情况*。当![](images/nsp-venkitachalam503045-m01011.jpg)小于某个阈值时——比如10像素——就停止递归并绘制线段。
- en: To make the final output a bit fancy, you can draw three linked flakes as the
    first level of the fractal. This will give you the hexagonal symmetry of an actual
    snowflake. [Figure 1-4](nsp-venkitachalam503045-0012.xhtml#fig1-4) shows what
    the starting drawing will look like.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让最终输出看起来更精美，你可以将三个相连的雪花作为分形的第一层绘制。这将给你一个实际雪花的六边形对称性。[图1-4](nsp-venkitachalam503045-0012.xhtml#fig1-4)显示了起始绘图的样子。
- en: '![](images/nsp-venkitachalam503045-f01004.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f01004.jpg)'
- en: 'Figure 1-4: Combining three snowflakes'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-4：三个雪花的组合
- en: Now that you know how to calculate the coordinates for making the snowflake,
    let’s see how to use those coordinates in Python to actually draw an image.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何计算雪花的坐标，让我们看看如何在Python中使用这些坐标来实际绘制图像。
- en: Drawing with turtle Graphics
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用turtle图形绘制
- en: In this chapter, you’ll use Python’s `turtle` module to draw the snowflake;
    it’s a simple drawing program modeled after the idea of a turtle dragging its
    tail through the sand, creating patterns. The `turtle` module includes methods
    you can use to set the position and color of the pen (the turtle’s tail) and many
    other useful functions for drawing.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用Python的`turtle`模块绘制雪花；这是一个简单的绘图程序，模拟了乌龟用尾巴拖过沙子，创造图案的想法。`turtle`模块包括一些可以设置笔的位置和颜色（即乌龟的尾巴）的方法，以及许多其他有用的绘图函数。
- en: 'As you’ll see, all you need is a handful of graphics functions to draw the
    Koch snowflake. In fact, from the standpoint of `turtle`, drawing the snowflake
    is almost as easy as drawing a triangle. To prove it, and to give you a feel for
    how `turtle` works, the following program uses `turtle` to draw said triangle.
    Enter the code, save it as *test_turtle.py*, and run it in Python:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，绘制科赫雪花只需要一些图形函数。事实上，从`turtle`的角度来看，绘制雪花几乎和绘制三角形一样简单。为了证明这一点，并让你感受`turtle`是如何工作的，下面的程序使用`turtle`绘制一个三角形。输入代码，将其保存为*test_turtle.py*，并在Python中运行：
- en: ❶ import turtle
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入turtle
- en: 'def draw_triangle(x1, y1, x2, y2, x3, y3, t):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw_triangle(x1, y1, x2, y2, x3, y3, t):'
- en: '# go to start of triangle'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '# 转到三角形起点'
- en: ❷ t.up()
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ t.up()
- en: ❸ t.setpos(x1, y1)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ t.setpos(x1, y1)
- en: ❹ t.down()
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ t.down()
- en: t.setpos(x2, y2)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: t.setpos(x2, y2)
- en: t.setpos(x3, y3)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: t.setpos(x3, y3)
- en: t.setpos(x1, y1)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: t.setpos(x1, y1)
- en: t.up()
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: t.up()
- en: 'def main():'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: print('testing turtle graphics...')
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: print('测试turtle图形...')
- en: ❺ t = turtle.Turtle()
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ t = turtle.Turtle()
- en: ❻ t.hideturtle()
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ t.hideturtle()
- en: ❼ draw_triangle(-100, 0, 0, -173.2, 100, 0, t)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ draw_triangle(-100, 0, 0, -173.2, 100, 0, t)
- en: ❽ turtle.mainloop()
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ turtle.mainloop()
- en: call main
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用main
- en: 'if __name__ == ''__main__'':'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: main()
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: You start by importing the `turtle` module ❶. Next, you define the `draw_triangle()`
    method, whose parameters are three pairs of x-coordinates and y-coordinates (the
    three corners of a triangle), as well as `t`, a `turtle` object. The method starts
    by calling `up()` ❷. This tells Python to move the pen up; in other words, take
    the pen off the virtual paper so that it won’t draw as you move the turtle. You
    want to position the turtle before you start drawing. The `setpos()` call ❸ sets
    the position of the turtle to the first pair of x- and y-coordinates. Calling
    `down()` ❹ sets the pen down, and for each of the subsequent `setpos()` calls,
    a line is drawn as the turtle moves to the next set of coordinates. The net result
    is a triangle drawing.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先导入`turtle`模块❶。接下来，定义`draw_triangle()`方法，该方法的参数是三对x坐标和y坐标（三个三角形的角），以及`t`，一个`turtle`对象。该方法开始时调用`up()`❷。这告诉Python将笔抬起；换句话说，将笔从虚拟纸张上拿开，这样移动turtle时就不会绘制。你希望在开始绘制之前先定位turtle的位置。`setpos()`调用❸将turtle的位置设置为第一对x和y坐标。调用`down()`❹将笔放下，并且每次调用`setpos()`时，turtle移动到下一个坐标时都会绘制一条线。最终的结果是绘制出一个三角形。
- en: Next you declare a `main()` function to actually do the drawing. In it, you
    create the `turtle` object for drawing ❺ and hide the turtle ❻. Without this command,
    you’d see a small shape representing the turtle at the front of the line being
    drawn. You then call `draw_triangle()` to draw the triangle ❼, passing in the
    desired coordinates as arguments. The call to `mainloop()` ❽ keeps the `tkinter`
    window open after the triangle has been drawn. (`tkinter` is Python’s default
    GUI library.)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，声明一个`main()`函数来实际进行绘图。在其中，你创建`turtle`对象进行绘图❺并隐藏该turtle❻。如果没有这个命令，你会看到一个小形状，表示turtle在绘制的路径前方。然后你调用`draw_triangle()`绘制三角形❼，并传入所需的坐标作为参数。调用`mainloop()`❽会在绘制完三角形后保持`tkinter`窗口打开。（`tkinter`是Python的默认GUI库。）
- en: '[Figure 1-5](nsp-venkitachalam503045-0012.xhtml#fig1-5) shows the output of
    this simple program.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-5](nsp-venkitachalam503045-0012.xhtml#fig1-5)显示了这个简单程序的输出。'
- en: '![](images/nsp-venkitachalam503045-f01005.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f01005.jpg)'
- en: 'Figure 1-5: The output of a simple `turtle` program'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-5：一个简单`turtle`程序的输出
- en: You now have everything you need for the project. Let’s draw some flakes!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在拥有完成项目所需的一切。让我们开始绘制雪花吧！
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah0302)'
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[需求](nsp-venkitachalam503045-0008.xhtml#rah0302)'
- en: In this project, you’ll use the Python `turtle` module to draw the snowflake.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用Python的`turtle`模块来绘制雪花。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah0303)'
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah0303)'
- en: To draw the Koch snowflake, define a recursive function, `drawKochSF()`. This
    function computes *P*[1], *P*[2], and *P*[3] in terms of *A* and *B* from [Figure
    1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2) and then recursively calls itself
    to perform the same calculation for smaller and smaller line segments until it
    reaches the smallest base case. Then it draws the flakes using `turtle`. For the
    full project code, skip ahead to [“The Complete Code”](nsp-venkitachalam503045-0012.xhtml#ah0307)
    on [page 16](nsp-venkitachalam503045-0012.xhtml#p16). The code is also available
    in the book’s GitHub repository at [https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py](https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制科赫雪花，定义一个递归函数`drawKochSF()`。这个函数根据[图1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2)中的*P*[1]、*P*[2]和*P*[3]的定义，以*A*和*B*为基础，然后递归调用自身，计算更小的线段，直到达到最小的基础情况。然后它使用`turtle`绘制雪花。完整的项目代码请跳到[“完整代码”](nsp-venkitachalam503045-0012.xhtml#ah0307)，位于[第16页](nsp-venkitachalam503045-0012.xhtml#p16)。代码也可以在本书的GitHub仓库中找到，地址为[https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py](https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py)。
- en: Calculating the Points
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算各个点
- en: Begin the `drawKochSF()` function by calculating the coordinates for all the
    points needed to draw the basic flake pattern shown in [Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从`drawKochSF()`函数开始，计算绘制基本雪花图案所需的所有点的坐标，如[图1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2)所示。
- en: 'def drawKochSF(x1, y1, x2, y2, t):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 'def drawKochSF(x1, y1, x2, y2, t):'
- en: d = math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2))
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: d = math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2))
- en: r = d/3.0
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: r = d/3.0
- en: h = r*math.sqrt(3)/2.0
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: h = r*math.sqrt(3)/2.0
- en: p3 = ((x1 + 2*x2)/3.0, (y1 + 2*y2)/3.0)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: p3 = ((x1 + 2*x2)/3.0, (y1 + 2*y2)/3.0)
- en: p1 = ((2*x1 + x2)/3.0, (2*y1 + y2)/3.0)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: p1 = ((2*x1 + x2)/3.0, (2*y1 + y2)/3.0)
- en: c = (0.5*(x1+x2), 0.5*(y1+y2))
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: c = (0.5*(x1+x2), 0.5*(y1+y2))
- en: n = ((y1-y2)/d, (x2-x1)/d)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: n = ((y1-y2)/d, (x2-x1)/d)
- en: p2 = (c[0]+h*n[0], c[1]+h*n[1])
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: p2 = (c[0]+h*n[0], c[1]+h*n[1])
- en: You define `drawKochSF()`, passing in the x- and y-coordinates for the endpoints
    of a line segment ![](images/nsp-venkitachalam503045-m01011.jpg), which forms
    the basis for one of the sides of the snowflake, as shown in [Figure 1-4](nsp-venkitachalam503045-0012.xhtml#fig1-4).
    You also pass in the `turtle` object `t`, which you use for the actual drawing.
    Then you compute all the parameters shown in [Figure 1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2),
    as discussed in the [“Computing the Snowflake”](nsp-venkitachalam503045-0012.xhtml#bh0302)
    section, starting with `d`, the distance from *A* to *B*. Dividing `d` by 3 gives
    you `r`, the length of each of the four line segments that makes up a flake. You
    use `r` to find `h`, the height of the “cone” at the heart of the flake.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义了`drawKochSF()`，传入线段的端点 x 和 y 坐标 ![](images/nsp-venkitachalam503045-m01011.jpg)，这些端点构成了雪花的一边，如[图
    1-4](nsp-venkitachalam503045-0012.xhtml#fig1-4)所示。你还传入了`turtle`对象`t`，用于实际绘制。然后，你计算[图
    1-2](nsp-venkitachalam503045-0012.xhtml#fig1-2)中显示的所有参数，如在[“计算雪花”](nsp-venkitachalam503045-0012.xhtml#bh0302)章节中讨论的那样，从`d`开始，`d`是从*A*到*B*的距离。将`d`除以
    3 得到`r`，这是构成雪花的四个线段的长度。你用`r`来计算`h`，雪花中心“锥体”的高度。
- en: You calculate the rest of the parameters as tuples containing an x- and a y-coordinate.
    The `p3` and `p1` tuples describe the two points at the base of the cone portion
    of the flake. Point `c` is the midpoint of `p1` and `p3`, and `n` is the unit
    vector perpendicular to line ![](images/nsp-venkitachalam503045-m01011.jpg). Along
    with `h`, they help you calculate `p2`, the apex of the flake’s cone.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你计算剩下的参数，这些参数是包含 x 和 y 坐标的元组。`p3`和`p1`元组描述了雪花锥体部分底部的两个点。点`c`是`p1`和`p3`的中点，`n`是垂直于线段![](images/nsp-venkitachalam503045-m01011.jpg)的单位向量。连同`h`一起，它们帮助你计算`p2`，雪花锥体的顶点。
- en: Recursing
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归
- en: The next part of the `drawKochSF()` function uses recursion to break down the
    first-level flake into smaller and smaller versions of itself.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawKochSF()`函数的下一部分使用递归将第一层的雪花分解成更小的版本。'
- en: '❶ if d > 10:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果 d > 10：
- en: '# flake #1'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '# 雪花 #1'
- en: ❷ drawKochSF(x1, y1, p1[0], p1[1], t)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ drawKochSF(x1, y1, p1[0], p1[1], t)
- en: '# flake #2'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '# 雪花 #2'
- en: drawKochSF(p1[0], p1[1], p2[0], p2[1], t)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: drawKochSF(p1[0], p1[1], p2[0], p2[1], t)
- en: '# flake #3'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '# 雪花 #3'
- en: drawKochSF(p2[0], p2[1], p3[0], p3[1], t)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: drawKochSF(p2[0], p2[1], p3[0], p3[1], t)
- en: '# flake #4'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '# 雪花 #4'
- en: drawKochSF(p3[0], p3[1], x2, y2, t)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: drawKochSF(p3[0], p3[1], x2, y2, t)
- en: First you check for the recursion-stopping criteria ❶. If `d`, the length of
    segment ![](images/nsp-venkitachalam503045-m01011.jpg), is greater than 10 pixels,
    you continue the recursion. You do this by calling the `drawKochSF()` function
    again—four times! With each call, you pass in a different set of arguments corresponding
    to the coordinates for one of the four line segments that make up a flake, which
    you calculated at the start of the function. At ❷, for example, you call `drawKochSF()`
    for the segment ![](images/nsp-venkitachalam503045-m01021.jpg). The other function
    calls are for segments ![](images/nsp-venkitachalam503045-m01022.jpg), ![](images/nsp-venkitachalam503045-m01023.jpg),
    and ![](images/nsp-venkitachalam503045-m01024.jpg). Within each of these recursive
    calls, you’ll perform a new set of calculations based on the new values for points
    *A* and *B*, and if `d` is still greater than 10 pixels, you’ll make another four
    recursive calls to `drawKochSF()`, and so on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你检查递归停止的条件 ❶。如果`d`（线段的长度）![](images/nsp-venkitachalam503045-m01011.jpg)大于
    10 像素，你就继续递归。你通过再次调用`drawKochSF()`函数来实现这一点——四次！每次调用时，你传入一个不同的参数集，分别对应构成雪花的四个线段的坐标，这些坐标在函数开始时已经计算过。例如，在
    ❷，你调用`drawKochSF()`来绘制线段![](images/nsp-venkitachalam503045-m01021.jpg)。其他的函数调用对应的线段是![](images/nsp-venkitachalam503045-m01022.jpg)、![](images/nsp-venkitachalam503045-m01023.jpg)和![](images/nsp-venkitachalam503045-m01024.jpg)。在这些递归调用中，你将基于新的*A*和*B*点的值执行一组新的计算，如果`d`仍然大于
    10 像素，你将再次进行四次递归调用`drawKochSF()`，以此类推。
- en: Drawing a Flake
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制雪花
- en: Now let’s look at what happens if segment ![](images/nsp-venkitachalam503045-m01011.jpg)
    is less than 10 pixels. This is the base case for the recursive algorithm. Since
    you’re below the threshold, you aren’t going to recurse. Instead, you actually
    draw the four line segments that make up a single flake pattern and return from
    the function. You use the `up()`, `down()`, and `setpos()` methods from the `turtle`
    module, which you learned about in the “Drawing with `turtle` Graphics” section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如果线段 ![](images/nsp-venkitachalam503045-m01011.jpg) 小于 10 像素会发生什么。这是递归算法的基本情况。由于你低于阈值，所以不会进行递归。相反，你会绘制出构成单个雪花图案的四条线段，并从函数中返回。你使用了
    `turtle` 模块中的 `up()`、`down()` 和 `setpos()` 方法，这些你在“使用 `turtle` 图形绘制”部分已经学习过。
- en: 'else:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: '# draw cone'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绘制圆锥'
- en: t.up()
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: t.up()
- en: ❶ t.setpos(p1[0], p1[1])
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ t.setpos(p1[0], p1[1])
- en: t.down()
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: t.down()
- en: t.setpos(p2[0], p2[1])
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: t.setpos(p2[0], p2[1])
- en: t.setpos(p3[0], p3[1])
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: t.setpos(p3[0], p3[1])
- en: '# draw sides'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绘制边'
- en: t.up()
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: t.up()
- en: ❷ t.setpos(x1, y1)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ t.setpos(x1, y1)
- en: t.down()
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: t.down()
- en: t.setpos(p1[0], p1[1])
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: t.setpos(p1[0], p1[1])
- en: t.up()
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: t.up()
- en: ❸ t.setpos(p3[0], p3[1])
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ t.setpos(p3[0], p3[1])
- en: t.down()
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: t.down()
- en: t.setpos(x2, y2)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: t.setpos(x2, y2)
- en: First you draw the cone formed by points `p1`, `p2`, and `p3` ❶. Then you draw
    lines ![](images/nsp-venkitachalam503045-m01021.jpg) ❷ and ![](images/nsp-venkitachalam503045-m01024.jpg)
    ❸. Since you already performed all the required calculations at the start of the
    function, drawing is simply a matter of passing the appropriate coordinates to
    the `setpos()` method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 首先绘制由点 `p1`、`p2` 和 `p3` 形成的圆锥 ❶。然后绘制线段 ![](images/nsp-venkitachalam503045-m01021.jpg)
    ❷ 和 ![](images/nsp-venkitachalam503045-m01024.jpg) ❸。由于你在函数开始时已经完成了所有必需的计算，绘制只是将适当的坐标传递给
    `setpos()` 方法的过程。
- en: '[Writing the main() Function](nsp-venkitachalam503045-0008.xhtml#rbh0307)'
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[编写 main() 函数](nsp-venkitachalam503045-0008.xhtml#rbh0307)'
- en: The `main()` function sets up a `turtle` object and calls `drawKochSF()`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数创建了一个 `turtle` 对象并调用了 `drawKochSF()`。'
- en: 'def main():'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: print('Drawing the Koch Snowflake...')
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: print('绘制科赫雪花...')
- en: t = turtle.Turtle()
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: t = turtle.Turtle()
- en: t.hideturtle()
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: t.hideturtle()
- en: '# draw'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绘制'
- en: 'try:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: ❶ drawKochSF(-100, 0, 100, 0, t)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ drawKochSF(-100, 0, 100, 0, t)
- en: ❷ drawKochSF(0, -173.2, -100, 0, t)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ drawKochSF(0, -173.2, -100, 0, t)
- en: ❸ drawKochSF(100, 0, 0, -173.2, t)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ drawKochSF(100, 0, 0, -173.2, t)
- en: '❹ except:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '❹ except:'
- en: print("Exception, exiting.")
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: print("异常，退出。")
- en: exit(0)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: exit(0)
- en: '# wait for user to click on screen to exit'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '# 等待用户点击屏幕以退出'
- en: ❺ turtle.Screen().exitonclick()
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ turtle.Screen().exitonclick()
- en: 'In [Figure 1-4](nsp-venkitachalam503045-0012.xhtml#fig1-4), you saw how you
    were going to draw three of the snowflakes to get a hexagonally symmetric image
    as the final output. You do this by making three calls to `drawKochSF()`. The
    coordinates used for points *A* and *B* are `(-100, 0), (100, 0)` for the first
    snowflake ❶, `(0, -173.2), (-100, 0)` for the second ❷, and `(100, 0), (0, -173.2)`
    for the third ❸. Notice that these are the same coordinates you used earlier to
    draw a triangle in your *test_turtle.py* program. Try to work out the coordinates
    for yourself. (Hint: ![](images/nsp-venkitachalam503045-m01025.jpg).)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 1-4](nsp-venkitachalam503045-0012.xhtml#fig1-4) 中，你看到如何绘制三个雪花以得到一个六角对称的最终图像。你通过调用三次
    `drawKochSF()` 来实现这一点。用于点 *A* 和 *B* 的坐标为 `(-100, 0), (100, 0)` 用于第一个雪花 ❶，`(0,
    -173.2), (-100, 0)` 用于第二个雪花 ❷，以及 `(100, 0), (0, -173.2)` 用于第三个雪花 ❸。注意，这些坐标与你在
    *test_turtle.py* 程序中绘制三角形时使用的坐标相同。试着自己算出这些坐标。（提示：![](images/nsp-venkitachalam503045-m01025.jpg)）
- en: The `drawKochSF()` calls are enclosed in a Python `try` block to catch any exceptions
    that happen during drawing. For example, if you close the window while the drawing
    is still in process, an exception is thrown. You catch it in the `except` block
    ❹, where you print a message and exit the program. If you allow the drawing to
    complete, you’ll get to `turtle.Screen().exitonclick()` ❺, which will wait until
    you close the window by clicking anywhere inside it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawKochSF()` 调用被包含在 Python 的 `try` 块中，以捕获绘图过程中发生的任何异常。例如，如果在绘图过程中关闭窗口，将抛出异常。你可以在
    `except` 块 ❹ 捕获异常，打印消息并退出程序。如果允许绘图完成，将会执行 `turtle.Screen().exitonclick()` ❺，它会等待你通过点击窗口内的任意地方关闭窗口。'
- en: '[Running the Snowflake Code](nsp-venkitachalam503045-0008.xhtml#rah0304)'
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行雪花代码](nsp-venkitachalam503045-0008.xhtml#rah0304)'
- en: Run the code in a terminal as follows. [Figure 1-6](nsp-venkitachalam503045-0012.xhtml#fig1-6)
    shows the output.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式在终端中运行代码。[图 1-6](nsp-venkitachalam503045-0012.xhtml#fig1-6) 显示了输出结果。
- en: $ `python koch.py`
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: $ `python koch.py`
- en: '![](images/nsp-venkitachalam503045-f01006.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f01006.jpg)'
- en: 'Figure 1-6: The Koch snowflake output'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-6：科赫雪花输出
- en: There’s your beautiful snowflake!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你的美丽雪花已经完成！
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah0305)'
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[总结](nsp-venkitachalam503045-0008.xhtml#rah0305)'
- en: In this chapter, you learned the basics of recursive functions and algorithms.
    You also learned how to draw simple graphics with Python’s `turtle` module. You
    put these concepts together to create a nice drawing of an interesting fractal
    called the Koch snowflake.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了递归函数和算法的基础知识。你还学习了如何使用 Python 的 `turtle` 模块绘制简单的图形。你将这些概念结合起来，创建了一个有趣的分形图案——科赫雪花。
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah0306)'
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实验！](nsp-venkitachalam503045-0008.xhtml#rah0306)'
- en: Now that you have completed one fractal drawing, let’s look at another interesting
    one called the *Sierpi*ń*ski triangle*, named after the Polish mathematician Wacław
    Sierpiński. [Figure 1-7](nsp-venkitachalam503045-0012.xhtml#fig1-7) shows what
    it looks like.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了一个分形图案的绘制，让我们来看看另一个有趣的分形图案——*谢尔宾斯基三角形*，它以波兰数学家瓦茨瓦夫·谢尔宾斯基命名。[图 1-7](nsp-venkitachalam503045-0012.xhtml#fig1-7)展示了它的样子。
- en: '![](images/nsp-venkitachalam503045-f01007.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f01007.jpg)'
- en: 'Figure 1-7: The Sierpiński triangle'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-7：谢尔宾斯基三角形
- en: Try drawing the Sierpiński triangle with `turtle` graphics. You can use a recursive
    algorithm like you did to draw the Koch snowflake. If you look at [Figure 1-7](nsp-venkitachalam503045-0012.xhtml#fig1-7),
    you’ll see that the large triangle is divided into three smaller triangles, with
    an upside-down triangular hole in the middle. Each of the three smaller triangles
    is itself divided into another three triangles plus a hole in the middle, and
    so on. That gives you a hint on how to split up your recursion.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用`turtle`图形绘制谢尔宾斯基三角形。你可以像绘制科赫雪花那样使用递归算法。如果你查看[图 1-7](nsp-venkitachalam503045-0012.xhtml#fig1-7)，你会看到大三角形被分成了三个更小的三角形，中央有一个倒置的三角形孔。每个较小的三角形本身又被分成三个小三角形，并且中间有一个孔，依此类推。这给了你如何分割递归的提示。
- en: (The solution to this problem is in the GitHub repository for the book [https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py](https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py))
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: (这个问题的解决方案在 GitHub 仓库中，书籍链接为 [https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py](https://github.com/mkvenkit/pp2e/blob/main/koch/koch.py))
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah0307)'
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整代码](nsp-venkitachalam503045-0008.xhtml#rah0307)'
- en: 'Here’s the complete code listing for this project:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该项目的完整代码清单：
- en: '"""'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: koch.py
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: koch.py
- en: A program that draws the Koch snowflake.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一个绘制科赫雪花的程序。
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：Mahesh Venkitachalam
- en: '"""'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: import turtle
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: import turtle
- en: import math
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: import math
- en: draw the recursive Koch snowflake
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制递归科赫雪花
- en: 'def drawKochSF(x1, y1, x2, y2, t):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 'def drawKochSF(x1, y1, x2, y2, t):'
- en: d = math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2))
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: d = math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2))
- en: r = d/3.0
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: r = d/3.0
- en: h = r*math.sqrt(3)/2.0
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: h = r*math.sqrt(3)/2.0
- en: p3 = ((x1 + 2*x2)/3.0, (y1 + 2*y2)/3.0)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: p3 = ((x1 + 2*x2)/3.0, (y1 + 2*y2)/3.0)
- en: p1 = ((2*x1 + x2)/3.0, (2*y1 + y2)/3.0)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: p1 = ((2*x1 + x2)/3.0, (2*y1 + y2)/3.0)
- en: c = (0.5*(x1+x2), 0.5*(y1+y2))
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: c = (0.5*(x1+x2), 0.5*(y1+y2))
- en: n = ((y1-y2)/d, (x2-x1)/d)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: n = ((y1-y2)/d, (x2-x1)/d)
- en: p2 = (c[0]+h*n[0], c[1]+h*n[1])
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: p2 = (c[0]+h*n[0], c[1]+h*n[1])
- en: 'if d > 10:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'if d > 10:'
- en: '# flake #1'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '# 雪花 #1'
- en: drawKochSF(x1, y1, p1[0], p1[1], t)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: drawKochSF(x1, y1, p1[0], p1[1], t)
- en: '# flake #2'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '# 雪花 #2'
- en: drawKochSF(p1[0], p1[1], p2[0], p2[1], t)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: drawKochSF(p1[0], p1[1], p2[0], p2[1], t)
- en: '# flake #3'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '# 雪花 #3'
- en: drawKochSF(p2[0], p2[1], p3[0], p3[1], t)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: drawKochSF(p2[0], p2[1], p3[0], p3[1], t)
- en: '# flake #4'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '# 雪花 #4'
- en: drawKochSF(p3[0], p3[1], x2, y2, t)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: drawKochSF(p3[0], p3[1], x2, y2, t)
- en: 'else:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: '# draw cone'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绘制锥体'
- en: t.up()
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: t.up()
- en: t.setpos(p1[0], p1[1])
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: t.setpos(p1[0], p1[1])
- en: t.down()
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: t.down()
- en: t.setpos(p2[0], p2[1])
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: t.setpos(p2[0], p2[1])
- en: t.setpos(p3[0], p3[1])
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: t.setpos(p3[0], p3[1])
- en: '# draw sides'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绘制边'
- en: t.up()
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: t.up()
- en: t.setpos(x1, y1)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: t.setpos(x1, y1)
- en: t.down()
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: t.down()
- en: t.setpos(p1[0], p1[1])
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: t.setpos(p1[0], p1[1])
- en: t.up()
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: t.up()
- en: t.setpos(p3[0], p3[1])
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: t.setpos(p3[0], p3[1])
- en: t.down()
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: t.down()
- en: t.setpos(x2, y2)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: t.setpos(x2, y2)
- en: main() function
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: main() 函数
- en: 'def main():'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: print('Drawing the Koch Snowflake...')
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: print('绘制科赫雪花...')
- en: t = turtle.Turtle()
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: t = turtle.Turtle()
- en: t.hideturtle()
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: t.hideturtle()
- en: '# draw'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '# 绘制'
- en: 'try:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: drawKochSF(-100, 0, 100, 0, t)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: drawKochSF(-100, 0, 100, 0, t)
- en: drawKochSF(0, -173.2, -100, 0, t)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: drawKochSF(0, -173.2, -100, 0, t)
- en: drawKochSF(100, 0, 0, -173.2, t)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: drawKochSF(100, 0, 0, -173.2, t)
- en: 'except:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 'except:'
- en: print("Exception, exiting.")
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: print("异常，程序退出。")
- en: exit(0)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: exit(0)
- en: '# wait for user to click on screen to exit'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '# 等待用户点击屏幕退出'
- en: turtle.Screen().exitonclick()
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: turtle.Screen().exitonclick()
- en: call main
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用 main
- en: 'if __name__ == ''__main__'':'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: main()
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: main()
