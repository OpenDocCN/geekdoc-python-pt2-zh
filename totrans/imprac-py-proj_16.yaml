- en: '**16'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**16'
- en: FINDING FRAUDS WITH BENFORD’S LAW**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本福德定律发现欺诈行为**
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Prior to the invention of electronic calculators, if you needed to take the
    log of a number, you looked it up in a table. Astronomer Simon Newcomb used such
    tables, and in 1881, he noticed that the pages in the front, used for numbers
    beginning with the lowest digits, were more worn than those in the back. From
    this mundane observation, he realized that—at least for measurements and constants
    in nature—the leading digits were much more likely to be small than large. He
    published a short article about it and moved on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在电子计算器发明之前，如果需要计算一个数字的对数，你会查找表格。天文学家西蒙·纽科姆使用了这样的表格，在1881年，他注意到，用来查找以最小数字开头的数字的前面几页比后面的页数更磨损。通过这一平凡的观察，他意识到——至少对于自然界的度量和常数——领先数字小的可能性远大于大的。他发表了一篇简短的文章，并继续前行。
- en: For decades, this statistical curiosity, like Tolkien’s One Ring, “passed out
    of all knowledge.” Then, in 1938, physicist Frank Benford rediscovered and confirmed
    the phenomenon by collecting over 20,000 samples of real-world numbers, using
    data sources as diverse as the measurements of rivers, street addresses, numbers
    contained in *Reader’s Digest* magazine, molecular weights, baseball statistics,
    death rates, and more. As the person who popularized this scientific discovery,
    he got all the credit.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年来，这一统计学上的好奇现象，如同托尔金的“魔戒”，“消失在所有人的记忆中”。直到1938年，物理学家弗兰克·本福德通过收集超过20,000个真实世界数字样本重新发现并确认了这一现象，数据来源包括河流测量、街道地址、*《读者文摘》*杂志中的数字、分子质量、棒球统计、死亡率等各类数据。作为普及这一科学发现的人，他获得了所有的荣誉。
- en: According to *Benford’s law*, also known as the *first-digit law*, the frequency
    of occurrence of the leading digits in naturally occurring numerical distributions
    is predictable and nonuniform. In fact, a given number is six times more likely
    to start with a 1 than a 9! This is very counterintuitive, as most people would
    expect a uniform distribution, with each number having a one in nine (11.1 percent)
    chance of occupying the first slot. Due to this cognitive disconnect, Benford’s
    law has become a useful tool for fraud detection in financial, scientific, and
    election data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*本福德定律*，也称为*首位数字定律*，自然发生的数字分布中，领先数字的出现频率是可预测的且不均匀的。事实上，一个数字以1开头的概率是以9开头的六倍！这一点非常反直觉，因为大多数人会预期数字的分布是均匀的，每个数字有九分之一（11.1%）的概率占据首位。由于这种认知上的脱节，本福德定律已成为金融、科学和选举数据中用于欺诈检测的有力工具。
- en: In this chapter, you’ll write a Python program that compares real-life datasets
    to Benford’s law and determines whether they appear fraudulent or not. You’ll
    also dust off matplotlib one last time to add a useful visual component to the
    analysis. For a dataset, you’ll use votes cast in the contentious 2016 US presidential
    election.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将编写一个Python程序，将现实生活中的数据集与本福德定律进行比较，并判断它们是否可能存在欺诈行为。你还将最后一次使用matplotlib，为分析增添一个有用的可视化组件。数据集将使用2016年美国总统选举中的选票。
- en: '**Project #24: Benford’s Law of Leading Digits**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目#24：领先数字的本福德定律**'
- en: '[Figure 16-1](ch16.xhtml#ch16fig1) depicts a bar chart of the leading significant
    digits in a set of numbers following Benford’s law. Surprisingly, scale doesn’t
    matter. A tabulation of the length of Australian roads will follow Benford’s law
    whether it is in miles, kilometers, or cubits! As a statistical principle, it
    is *scale invariant*.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16-1](ch16.xhtml#ch16fig1)展示了遵循本福德定律的一组数字中领先有效数字的条形图。令人惊讶的是，尺度并不重要。无论是以英里、公里还是古代长度单位来记录澳大利亚的道路长度，都将遵循本福德定律！作为一个统计学原理，它是*尺度不变*的。'
- en: '![image](../images/f0348-01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0348-01.jpg)'
- en: '*Figure 16-1: The frequency of occurrence of leading digits according to Benford’s
    law*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-1：根据本福德定律，领先数字的出现频率*'
- en: It took mathematicians about a hundred years to come up with an explanation
    for Benford’s law that *they* found satisfactory. For the rest of us, let’s just
    say that there are more little things in the universe than large things. Frank
    Benford used the analogy that owning *one* acre of land is easier than owning
    *nine* acres. In fact, you can closely duplicate the frequency produced by Benford’s
    law by simply assuming that there are twice as many 1s as 2s, three times as many
    1s as 3s, and so on. You just take the inverse of each of the nine digits (1 /
    *d*) and divide by the sum of all the inverses (2.83). Then multiply the results
    by 100 to get the percentage (see [Figure 16-2](ch16.xhtml#ch16fig2)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 数学家们花了大约一百年的时间才提出一个他们认为令人满意的本福德定律解释。对于我们其他人来说，可以这么说：宇宙中小的东西比大的东西更多。Frank Benford用了一个类比，拥有*一*英亩土地比拥有*九*英亩土地要容易。实际上，你可以通过简单地假设1的数量是2的两倍，1的数量是3的三倍，依此类推，来紧密复制本福德定律所产生的频率。你只需要取每个数字的倒数（1
    / *d*），然后除以所有倒数之和（2.83）。然后，将结果乘以100得到百分比（见[图16-2](ch16.xhtml#ch16fig2)）。
- en: '![image](../images/f0349-01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0349-01.jpg)'
- en: '*Figure 16-2: Comparison of Benford’s law with an approximation proportional
    to the inverse of the first digit*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-2：本福德定律与近似值的比较，近似值与首位数字的倒数成比例*'
- en: Because of the size relationships just discussed, Benford’s law can be visualized
    with a *logarithmic* scale, which is used to graph data that are related according
    to an exponential relationship. In *semilogarithmic* (“semilog”) plots, one variable
    tends to be restricted, like the set of leading digits (1–9), while the other
    covers a wide range of values that includes several orders of magnitude.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面讨论的大小关系，本福德定律可以通过*对数*刻度进行可视化，后者用于绘制符合指数关系的数据。在*半对数*（“semilog”）图中，一个变量通常会受到限制，比如领先数字的集合（1-9），而另一个变量则覆盖包含多个数量级的广泛值范围。
- en: On semilog graph paper, the horizontal x-axis values are log values, and the
    vertical y-axis values, represented by horizontal lines, are not (see [Figure
    16-3](ch16.xhtml#ch16fig3)). On the x-axis, the horizontal divisions aren’t regular,
    and this nonlinear pattern repeats with powers of 10\. For every *decade* on the
    log paper, such as 1 through 10 or 10 through 100, the *width* of the divisions
    between numbers is proportional to the *length* of the bars in [Figure 16-1](ch16.xhtml#ch16fig1).
    For example, the distance between the 1 and 2 in [Figure 16-3](ch16.xhtml#ch16fig3)
    is 30.1 percent of the distance between 1 and 10\. As one author put it, you could
    derive Benford’s law by simply throwing darts at a piece of log paper!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在半对数图纸上，水平x轴的数值是对数值，垂直y轴的数值由水平线表示，并不是（见[图16-3](ch16.xhtml#ch16fig3)）。在x轴上，水平分隔线不规则，这种非线性模式以10的幂次方重复。在对数纸的每个*十年*（如从1到10，或从10到100）上，数字之间分隔线的*宽度*与[图16-1](ch16.xhtml#ch16fig1)中的条形*长度*成比例。例如，[图16-3](ch16.xhtml#ch16fig3)中1和2之间的距离是1和10之间距离的30.1%。正如一位作者所说，你可以通过简单地在对数纸上扔飞镖来推导本福德定律！
- en: '![image](../images/f0349-02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0349-02.jpg)'
- en: '*Figure 16-3: Example of two-decade semilogarithmic graph paper*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-3：两十年期半对数图纸示例*'
- en: For a collection of numeric data to conform to Benford’s law, certain conditions
    have to be met. The numbers need to be random and not assigned, with no imposed
    minimums or maximums. The numbers should cover several orders of magnitude, and
    the dataset should be large; recommendations in the literature call for 100 to
    1,000 samples as a minimum, though Benford’s law has been shown to hold true for
    datasets containing as few as 50 numbers. Examples of distributions that won’t
    follow Benford’s law are the heights of professional basketball players, US telephone
    numbers (for which only the last four digits are truly random), prices influenced
    by psychological barriers ($1.99 versus $2.00), and medical copayments.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使一组数字数据符合本福德定律，必须满足一些条件。这些数字需要是随机的，而不是指定的，不应存在强加的最小值或最大值。这些数字应涵盖多个数量级，且数据集应较大；文献中的建议是至少100到1000个样本，尽管本福德定律已被证明适用于包含多达50个数字的数据集。不会遵循本福德定律的分布示例包括职业篮球运动员的身高、美国电话号码（其中只有最后四位数字是真正随机的）、受到心理障碍影响的价格（如1.99美元与2.00美元）以及医疗共付费用。
- en: '***Applying Benford’s Law***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***应用本福德定律***'
- en: Most financial and accounting data conform to naturally occurring numbers and
    are thus subject to Benford’s law. For example, assume you own a stock mutual
    fund with a value of $1,000\. For your fund to reach $2,000 in value, it would
    have to double by growing 100 percent. To increase from $2,000 to $3,000, it would
    only need to grow by 50 percent. For the first digit to be a 4, it needs to grow
    by another 33 percent. As Benford’s law predicts, for the leading digit 1 to become
    2, there needs to be more growth than for the 3 to become 4, and so on. Because
    a Benford distribution is a “distribution of distributions,” financial datasets
    tend to conform, as they result from combining numbers—though exceptions do occur.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Because people are generally unaware of Benford’s law, they don’t account for
    it when falsifying numerical records. This gives forensic accountants a powerful
    tool for quickly identifying datasets that may be fraudulent. In fact, comparisons
    to Benford’s law are legally admissible as evidence in US criminal cases at the
    federal, state, and local levels.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: In the 1993 case of *State of Arizona v. Nelson*, the accused diverted nearly
    $2 million to bogus vendors in an attempt to defraud the state. Despite taking
    care to make the fake checks look legitimate, the first-digit distribution clearly
    violated Benford’s law ([Figure 16-4](ch16.xhtml#ch16fig4)), leading to a conviction.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0350-01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-4: Comparison of the frequency of first digits in fraudulent checks
    to anticipated Benford’s law frequency, State of Arizona v. Wayne James Nelson
    (CV92-18841)*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Benford’s law is also useful for internal business audits. Imagine a case where
    any travel and entertainment expenses over $10,000 must be approved by the company
    vice president. This type of financial threshold can tempt employees to do things
    like split invoices to game the system. [Figure 16-5](ch16.xhtml#ch16fig5) is
    based on a group of expenses ranging from $100 to $12,000, where all values greater
    than $9,999 were split into two equal halves. As you can guess, there is a spike
    in first-digit frequencies around 5 and 6, in clear violation of Benford’s law.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0351-01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-5: Splitting invoices over $9,999 for a dataset ranging from $100
    to $12,000 violates Benford’s law.*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: On a grander scale, Benford’s law has revealed irregularities in the financial
    data—such as revenue numbers—of large corporations. An example from Enron, which
    practiced institutionalized accounting fraud, is shown in [Figure 16-6](ch16.xhtml#ch16fig6).
    Enron’s bankruptcy in 2001 was the largest in history at the time, and it resulted
    in the jailing of several top executives. The scandal also brought about the dissolution
    of Arthur Andersen, a “Big Five” accounting firm and one of the world’s largest
    multinational corporations.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0351-02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-6: Frequency of first digits from Enron’s year 2000 financial data
    versus anticipated frequency based on Benford’s law (after the* Wall Street Journal*)*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, Benford’s law works best for fraud detection when the criminals are
    unaware of it. If you know how the law works, you can fool it, which we’ll do
    in a practice project at the end of this chapter. As a result, you can use Benford’s
    law to flag datasets that might be fraudulent, but you can’t use it to prove the
    opposite.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '***Performing the Chi-Square Test***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Auditors and investigators use multiple statistical methods to verify that a
    dataset obeys Benford’s law. In this project, you’ll use the *chi-square goodness-of-fit
    test*, which is a commonly used method for determining whether an empirical (observed)
    distribution differs significantly from a theoretical (expected) distribution.
    A significance level, or p*-value*, is used as the discriminator. The most common
    significance level is 0.05, but other common ones include 0.01 and 0.10\. A significance
    level of 0.05 indicates a 5 percent risk of erroneously concluding that a difference
    exists when it doesn’t.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps for performing a chi-square goodness-of-fit test:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the *degrees of freedom* (*df*), defined as the number of categories (*k*)
    minus 1:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*df* = *k* – 1'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For Benford’s law, the categorical levels are the first digits (1–9), so *df*
    = 8.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Calculate the expected frequency count at each level by multiplying the sample
    size by the theoretical proportions at each level:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*E[i]* = *np*[*i*]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: where *E* is the expected frequency at the *i*th level, *n* is the sample size,
    and *p* is the theoretical probability at the *i*th level. For 1,000 samples,
    the number of samples expected to start with 1 in a Benford’s law distribution
    would be 1,000 × 0.301 = 301 (see [Figure 16-1](ch16.xhtml#ch16fig1)).
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Calculate the chi-square random variable (*X*²), also known as the *test statistic*,
    which will allow you to judge whether the two distributions are the same:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0352-01.jpg)'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: where *O* is the observed frequency count for the *i*th level of the categorical
    variable, *E* is the expected frequency count for the *i*th level of the categorical
    variable, and *df* represents the *degrees of freedom*.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Refer to the *chi-square distribution table* ([Table 16-1](ch16.xhtml#ch16tab1)),
    reading across the row corresponding to the calculated degrees of freedom. If
    the test statistic is *less than* the value shown in the *p*-value column considered
    significant, then you can’t reject the hypothesis that the observed and theoretical
    distributions are the same.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Table 16-1:** Chi-Square Distribution Table'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '| **Degrees of freedom** | **Probability of exceeding the critical value**
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: '| **0.99** | **0.95** | **0.90** | **0.75** | **0.50** | **0.25** | **0.10**
    | **0.05** | **0.01** |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0.000 | 0.004 | 0.016 | 0.102 | 0.455 | 1.32 | 2.71 | 3.84 | 6.63 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| 2 | 0.020 | 0.103 | 0.211 | 0.575 | 1.386 | 2.77 | 4.61 | 5.99 | 9.21 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 0.020 | 0.103 | 0.211 | 0.575 | 1.386 | 2.77 | 4.61 | 5.99 | 9.21 |'
- en: '| 3 | 0.115 | 0.352 | 0.584 | 1.212 | 2.366 | 4.11 | 6.25 | 7.81 | 11.34 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 0.115 | 0.352 | 0.584 | 1.212 | 2.366 | 4.11 | 6.25 | 7.81 | 11.34 |'
- en: '| 4 | 0.297 | 0.711 | 1.064 | 1.923 | 3.357 | 5.39 | 7.78 | 9.49 | 13.28 |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 0.297 | 0.711 | 1.064 | 1.923 | 3.357 | 5.39 | 7.78 | 9.49 | 13.28 |'
- en: '| 5 | 0.554 | 1.145 | 1.610 | 2.675 | 4.351 | 6.63 | 9.24 | 11.07 | 15.09 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 0.554 | 1.145 | 1.610 | 2.675 | 4.351 | 6.63 | 9.24 | 11.07 | 15.09 |'
- en: '| 6 | 0.872 | 1.635 | 2.204 | 3.455 | 5.348 | 7.84 | 10.64 | 12.59 | 16.81
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 0.872 | 1.635 | 2.204 | 3.455 | 5.348 | 7.84 | 10.64 | 12.59 | 16.81
    |'
- en: '| 7 | 1.239 | 2.167 | 2.833 | 4.255 | 6.346 | 9.04 | 12.02 | 14.07 | 18.48
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 1.239 | 2.167 | 2.833 | 4.255 | 6.346 | 9.04 | 12.02 | 14.07 | 18.48
    |'
- en: '| 8 | 1.647 | 2.733 | 3.490 | 5.071 | 7.344 | 10.22 | 13.36 | 15.51 | 20.09
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 1.647 | 2.733 | 3.490 | 5.071 | 7.344 | 10.22 | 13.36 | 15.51 | 20.09
    |'
- en: '| 9 | 2.088 | 3.325 | 4.168 | 5.899 | 8.343 | 11.39 | 14.68 | 16.92 | 21.67
    |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 2.088 | 3.325 | 4.168 | 5.899 | 8.343 | 11.39 | 14.68 | 16.92 | 21.67
    |'
- en: '| 10 | 2.558 | 3.940 | 4.865 | 6.737 | 9.342 | 12.55 | 15.99 | 18.31 | 23.21
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 2.558 | 3.940 | 4.865 | 6.737 | 9.342 | 12.55 | 15.99 | 18.31 | 23.21
    |'
- en: '|  | Not significant | Significant |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|  | 不显著 | 显著 |'
- en: In Table 16-2, the critical value for a *p*-value of 0.05—at 8 degrees of freedom—is
    15.51\. If your calculated test statistic is less than 15.51, then the corresponding
    *p*-value is greater than 0.05, and you would conclude that there is *no statistically
    significant difference* between the observed distribution and the one predicted
    by Benford’s law. The *p*-value here is the probability that a test statistic
    having 8 degrees of freedom is more extreme than 15.51.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在表16-2中，0.05 的 *p* 值对应的临界值——在 8 自由度下——为 15.51。如果你计算出的检验统计量小于 15.51，则相应的 *p*
    值大于 0.05，你将得出结论，观察到的分布与本福特定律预测的分布之间*没有统计学上的显著差异*。这里的 *p* 值是指具有 8 自由度的检验统计量超过 15.51
    的概率。
- en: Note that you should perform the chi-square test on *counts*. If your data is
    in percentages, averages, ratios, or so on, then you’ll need to convert the values
    to counts before running the test.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你应该对 *计数* 进行卡方检验。如果你的数据是百分比、平均数、比率等，你需要在进行检验前将数据转换为计数值。
- en: '**THE OBJECTIVE**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Write a Python program that loads numerical data, records the frequency of occurrence
    of the first digits, compares these to Benford’s law using the chi-square goodness-of-fit
    test, and presents the comparison in both tabular and graphical form.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，加载数值数据，记录首位数字的出现频率，使用卡方拟合优度检验将这些频率与本福特定律进行比较，并以表格和图形两种形式呈现比较结果。
- en: '**The Dataset**'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**数据集**'
- en: The 2016 US presidential election was rife with allegations of voter fraud.
    Most famously, the Russians were accused of supporting Donald Trump, and the Democratic
    National Committee was accused of favoring Hillary Clinton over Bernie Sanders
    in that party’s nomination process. President Trump also alleged that 5 to 6 million
    people voted illegally, and in May 2017, he signed an executive order that launched
    a commission to review voter fraud and voter suppression.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 2016 年美国总统选举充斥着选民欺诈的指控。最著名的是，俄罗斯被指控支持唐纳德·特朗普，民主党全国委员会被指控在该党提名过程中偏袒希拉里·克林顿而非伯尼·桑德斯。特朗普总统还声称有
    500 万到 600 万人非法投票，并且在 2017 年 5 月，他签署了一项行政命令，成立委员会来审查选民欺诈和选民压制问题。
- en: For this project, you’ll use a dataset of voting records from the 2016 presidential
    election. This consists of the final *by-county* votes for the 102 counties in
    the state of Illinois, which was won by Hillary Clinton. Starting in June 2016,
    the Illinois Voter Registration System database was the victim of a malicious
    cyberattack of unknown origin. Illinois election officials confirmed that hackers
    had accessed thousands of records but apparently didn’t alter any data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你将使用来自 2016 年总统选举的投票记录数据集。该数据集包含伊利诺伊州 102 个县的最终 *按县* 投票结果，希拉里·克林顿赢得了该州。从
    2016 年 6 月开始，伊利诺伊州选民注册系统数据库成为了一次来源不明的恶意网络攻击的受害者。伊利诺伊州选举官员确认黑客已经访问了成千上万的记录，但显然没有更改任何数据。
- en: 'There were a surprising number of candidates on the Illinois ballot for president,
    so the dataset has been parsed to include only Hillary Clinton, Donald Trump,
    Gary Johnson, and Jill Stein. Votes for these candidates have been lumped together
    in a 408-line text file, with these first 5 lines:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 伊利诺伊州总统选举的候选人出人意料地多，因此数据集已被解析，只包含希拉里·克林顿、唐纳德·特朗普、加里·约翰逊和吉尔·斯坦。这些候选人的选票已合并到一个包含
    408 行文本的文件中，以下是前 5 行：
- en: '962'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '962'
- en: '997'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '997'
- en: '1020'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '1020'
- en: '1025'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '1025'
- en: '1031'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '1031'
- en: You can find the complete tally of candidates and votes online at *[https://www.elections.il.gov/ElectionInformation/DownloadVoteTotals.aspx](https://www.elections.il.gov/ElectionInformation/DownloadVoteTotals.aspx)*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: For this project, you need only the votes, which can be downloaded from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    as *Illinois_votes.txt*. You’ll need to keep this file in the same folder as your
    Python code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '**The Strategy**'
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s pretend you’re an investigator looking into allegations of voter fraud
    in the 2016 presidential election and you’ve been assigned the state of Illinois.
    Before doing a deep dive into the data, you’ll want to flag any obvious anomalies.
    Benford’s law can’t help you determine whether people are voting illegally, but
    it’s a good place to start for detecting vote *tampering*—that is, changing votes
    after they are cast.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: In cases like this, the ability to communicate the results is every bit as important
    as the quantitative analysis. Voting commissions don’t just include experts but
    also many laypeople with limited knowledge of statistics. And juries probably
    will not include a single expert. To convince yourself—and others—that the vote
    counts are valid (or not), you’ll want to show multiple comparisons, like a table,
    a graph, and the quantitative chi-square variable (test statistic).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'The individual steps involved in the analysis lend themselves well to encapsulation
    in functions. So, instead of pseudocode, let’s look at what functions you may
    need:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: load_data() Load the data as a list.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: count_first_digits() Tabulate the first digits in each county’s observed vote
    total.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: get_expected_counts() Determine the counts for each first digit as predicted
    by Benford.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: chi_square_test() Run a chi-square goodness-of-fit test on the observed versus
    expected counts.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: bar_chart() Generate a bar chart to compare observed first-digit percentages
    to those expected.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: main() Get the dataset filename, call the functions, and print the statistics.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '**The Code**'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll use the *benford.py* code in this section to investigate voter fraud,
    but it’s flexible enough to be used on *any* dataset where categorical values
    have been counted, such as medical test results, income tax revenues, or customer
    refunds. Non-fraud-related applications are also possible, such as detecting process
    inefficiencies caused by a large number of low-value transactions; problems with
    data collection and handling, such as missing data, truncated values, or typos;
    and bias in measurement strategies or surveys, such as favoring best-case or worst-case
    sampling.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: You can download the code from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    You’ll also need the *Illinois_votes.txt* text file described in “[The Dataset](ch16.xhtml#lev381)”
    on [page 353](ch16.xhtml#page_353).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '***Importing Modules and Loading Data***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 16-1](ch16.xhtml#ch16list1) imports modules and defines a function
    to load data. For this project, you’ll use data in the form of a tab-delimited
    text file exported from Microsoft Excel, which you load as a list of strings.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '*benford.py,* part 1'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: import math
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: ➊ from collections import defaultdict
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: ➋ import matplotlib.pyplot as plt
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '# Benford''s law percentages for leading digits 1-9'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: ➌ BENFORD = [30.1, 17.6, 12.5, 9.7, 7.9, 6.7, 5.8, 5.1, 4.6]
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '➍ def load_data(filename):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '"""Open a text file & return a list of strings."""'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '➎ with open(filename) as f:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: return f.read().strip().split('\n')
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-1: Imports modules and defines a function for loading data*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Most of the imports should be familiar at this point. The collections module
    provides specialized alternatives to standard Python containers like sets, tuples,
    lists, and dictionaries ➊. For counting first-digit frequencies, you’ll need defaultdict,
    which is a dict subclass that calls a factory function to supply missing values.
    With defaultdict, you can build a dictionary using a loop, and it will automatically
    create new keys rather than throwing an error. It returns a dictionary object.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The final import is for plotting with matplotlib ➋. For more information on
    matplotlib and how to install it, see “[The Probability-of-Detection Code](ch10.xhtml#lev226)”
    on [page 194](ch10.xhtml#page_194).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Now, assign a variable to a list containing the Benford’s law percentages, ordered
    from 1 to 9 ➌. Then, define a function to read a text file and return a list ➍.
    As you’ve done before, use with, as it will automatically close the file when
    done ➎.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '***Counting First Digits***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 16-2](ch16.xhtml#ch16list2) defines a function to count the first
    digits and store the results in a dictionary data structure. The final counts,
    and the frequency of each count as a percentage, are returned as lists to use
    in subsequent functions. The function will also run quality control on the data.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '*benford.py,* part 2'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def count_first_digits(data_list):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '"""Count 1st digits in list of numbers; return counts & frequency."""'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: ➋ first_digits = defaultdict(int)  # default value of int is 0
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '➌ for sample in data_list:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '➍ if sample == '''':'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: continue
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: int(sample)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'except ValueError as e:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: print(e, file=sys.stderr)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: print("Samples must be integers. Exiting", file=sys.stderr)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit(1)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: ➎ first_digits[sample[0]] += 1
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '# check for missing digits'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: keys = [str(digit) for digit in range(1, 10)]
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'for key in keys:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'if key not in first_digits:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: first_digits[key] = 0
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: ➏ data_count = [v for (k, v) in sorted(first_digits.items())]
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: total_count = sum(data_count)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: data_pct = [(i / total_count) * 100 for i in data_count]
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: ➐ return data_count, data_pct, total_count
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-2: Defines a function to count first digits and return counts and
    frequency*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: The count_first_digits() function takes the list of strings returned from the
    load_data() function as an argument ➊. You’ll call it in main().
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Start a dictionary, named first_digits, using defaultdict ➋. This step just
    sets up the dictionary for later population. The first argument for defaultdict
    is any callable (with no arguments). In this case, the callable is the type constructor
    for int, as you want to count integers. With defaultdict, whenever an operation
    encounters a missing key, a function named default_factory is called with no arguments,
    and the output is used as the value. Nonexistent keys get the value returned by
    default_factory.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`defaultdict`➋启动一个名为`first_digits`的字典。这个步骤只是为后续填充字典做准备。`defaultdict`的第一个参数是任何可调用对象（无参数）。在这种情况下，可调用对象是`int`的类型构造器，因为你希望统计整数。在使用`defaultdict`时，每当操作遇到一个缺失的键时，会调用名为`default_factory`的函数，且该函数无参数，返回的输出将作为该键的值。不存在的键会获得`default_factory`返回的值。
- en: Now start a for loop and go through the samples in data_list ➌. If the sample
    is empty—that is, if the text file contains a blank line ➍—skip it with continue.
    Otherwise, use try to convert the sample to an integer. If an exception occurs,
    the sample isn’t a proper count value, so let the user know and exit the program.
    In the following output example, the input file contains a float value (0.01)
    and the main() function prints the filename.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始一个`for`循环，遍历`data_list`中的样本➌。如果样本为空——也就是说，如果文本文件包含空行 ➍——则使用`continue`跳过。否则，使用`try`尝试将样本转换为整数。如果发生异常，说明样本不是有效的计数值，程序将提示用户并退出。在以下输出示例中，输入文件包含一个浮动值（0.01），`main()`函数会打印文件名。
- en: 'Name of file with COUNT data: bad_data.txt'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 包含COUNT数据的文件名：bad_data.txt
- en: 'invalid literal for int() with base 10: ''0.01'''
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 无效的整数文字：'0.01'
- en: Samples must be integers. Exiting.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 样本必须是整数。程序退出。
- en: If the sample passes the test, make its first element (leading digit) the dictionary
    key and add 1 to the value ➎. Because you used defaultdict with int, the key is
    initially assigned a default value of 0 on the fly.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果样本通过测试，将其第一个元素（领先数字）作为字典的键，并将值➎加1。因为你使用了`defaultdict`并指定了`int`，所以键会被自动赋予默认值0。
- en: 'To compare the counts to a Benford’s law distribution, you need the keys listed
    in numerical order, so use list comprehension and sorted to make a new version
    of first_digits, named data_count ➏. This will yield the values sorted by key,
    as shown here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将计数与本福德定律分布进行比较，你需要按数字顺序列出键，因此可以使用列表推导和`sorted`来生成`first_digits`的一个新版本，命名为`data_count`➏。这样会按键排序返回值，如下所示：
- en: '[129, 62, 45, 48, 40, 25, 23, 21, 15]'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[129, 62, 45, 48, 40, 25, 23, 21, 15]'
- en: Next, sum the counts, then make a new list and convert the counts to percentages.
    End the function by returning these two lists and the summed counts ➐. Because
    the counts in the lists are sorted from 1 to 9, you don’t need the associated
    first digit—it is implicit in the ordering.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，计算计数的总和，然后创建一个新列表，将计数转换为百分比。最后通过返回这两个列表和总计数➐来结束函数。由于列表中的计数是从1到9排序的，因此不需要关联的第一个数字——它在排序中是隐含的。
- en: '***Getting the Expected Counts***'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***获取预期的计数***'
- en: '[Listing 16-3](ch16.xhtml#ch16list3) defines the get_expected_counts() function
    that takes the observed data and calculates what the expected counts should be
    for the leading digits, based on Benford’s law. These expected counts are returned
    as a list that you’ll use later with the chi-square goodness-of-fit test to see
    how well the observed data conform to Benford’s law.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 16-3](ch16.xhtml#ch16list3) 定义了`get_expected_counts()`函数，该函数接收观测数据并根据本福德定律计算领先数字的预期计数。这些预期计数会作为一个列表返回，之后你将使用该列表与卡方拟合度检验一起检查观测数据是否符合本福德定律。'
- en: '*benford.py,* part 3'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*benford.py,* 第三部分'
- en: '➊ def get_expected_counts(total_count):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def get_expected_counts(total_count):'
- en: '"""Return list of expected Benford''s law counts for a total sample count."""'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '"""返回一个包含预期本福德定律计数的列表，基于总样本数量。"""'
- en: ➋ return [round(p * total_count / 100) for p in BENFORD]
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ return [round(p * total_count / 100) for p in BENFORD]
- en: '*Listing 16-3: Defines a function to calculate expected Benford’s law counts
    for a dataset*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 16-3: 定义了一个函数，用于计算数据集的预期本福德定律计数*'
- en: The argument for this function is the summed count that you returned from the
    count_first_digits() function in [Listing 16-2](ch16.xhtml#ch16list2) ➊. To get
    the counts you would expect for Benford’s law, you’ll need to use the frequency
    *probability* of each digit, so convert the percentages in the BENFORD list by
    dividing by 100\. Then multiply the total_count variable by this probability.
    You can do all this with list comprehension as part of the return statement ➋.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '***Determining Goodness of Fit***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 16-4](ch16.xhtml#ch16list4) defines a function to implement the chi-square
    test described in “[Performing the Chi-Square Test](ch16.xhtml#lev380)” on [page
    352](ch16.xhtml#page_352). This test calculates the goodness of fit of the observed
    counts to the expected counts predicted by Benford’s law. The function will first
    calculate the chi-square test statistic, then compare it to the chi-square distribution
    table entry at a *p*-value of 0.05 for 8 degrees of freedom. Based on the comparison,
    the function returns either True or False.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '*benford.py,* part 4'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def chi_square_test(data_count, expected_counts):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '"""Return boolean on chi-square test (8 degrees of freedom & P-val=0.05)."""'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: ➋ chi_square_stat = 0  # chi-square test statistic
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '➌ for data, expected in zip(data_count, expected_counts):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: ➍ chi_square = math.pow(data - expected, 2)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: chi_square_stat += chi_square / expected
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: ➎ print("\nChi Squared Test Statistic = {:.3f}".format(chi_square_stat))
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: print("Critical value at a P-value of 0.05 is 15.51.")
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: ➏ return chi_square_stat < 15.51
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-4: Defines a function to measure goodness of fit of observed data
    versus Benford’s law*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The chi-square test works on counts, so the function needs the lists of data
    counts and expected counts that the count_first_digits() and get_expected_counts()
    functions returned ➊. Assign a variable, named chi_square_stat, to hold the chi-square
    test statistic, and assign it a value of 0 ➋.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Use zip to loop through the nine values in data_count and expected_counts; zip
    will pair the first item in one list with the first item in the second list, and
    so on ➌. To calculate the chi-square statistic, first subtract the counts for
    each digit and square the result ➍. Then, divide this value by the expected count
    for the digit and add the result to the chi_square_stat variable. Then print the
    result to three decimal places ➎.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Return the boolean test for the chi_square_stat variable versus 15.51, which
    is the critical value corresponding to a *p*-value of 0.05 at 8 degrees of freedom
    (see [Table 16-1](ch16.xhtml#ch16tab1)) ➏. If chi_square_stat is less than this
    value, the function will return True; otherwise, it will return False.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining the Bar Chart Function***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 16-5](ch16.xhtml#ch16list5) defines the first part of a function to
    display the observed count percentages as a matplotlib bar chart. You used similar
    code in [Chapter 12](ch12.xhtml#ch12) to graph the outcomes of the retirement
    nest-egg simulations. This function will also plot the Benford’s law percentages
    as red dots, so you can visually estimate how well the observed data fit the expected
    distribution.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The matplotlib website contains many code examples for building a wide variety
    of plots. This code is partly based on the demo example at *[https://matplotlib.org/examples/api/barchart_demo.html](https://matplotlib.org/examples/api/barchart_demo.html)*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '*benford.py,* part 5'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def bar_chart(data_pct):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '"""Make bar chart of observed vs expected 1st-digit frequency (%)."""'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: ➋ fig, ax = plt.subplots()
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: ➌ index = [i + 1 for i in range(len(data_pct))]  # 1st digits for x-axis
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '# text for labels, title, and ticks'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: ➍ fig.canvas.set_window_title('Percentage First Digits')
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: ➎ ax.set_title('Data vs. Benford Values', fontsize=15)
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: ➏ ax.set_ylabel('Frequency (%)', fontsize=16)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: ➐ ax.set_xticks(index)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: ax.set_xticklabels(index, fontsize=14)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-5: Defines the first part of the* bar_chart() *function*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Define the bar_chart() function that takes as an argument the list of frequencies—as
    percentages—of the first digits in the observed data ➊. The plt.subplots() function
    returns a tuple of figure and axes objects; unpack this tuple into variables named
    fig and ax ➋.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Next, use list comprehension to make a list of digits from 1 to 9 ➌. This index
    variable will define the x-axis location of each of the nine vertical bars in
    the chart.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Set up the plot’s title, labels, and so on. Name the plot *window* 'Percentage
    First Digits' ➍, then display a title *within* the plot ➎. I am using generic
    titles, but you can customize these to be more specific. Use the fontsize keyword
    argument to set the text size to 15. Note that the window title is an attribute
    of fig, but the other labels will be attributes of ax.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Use set_ylabel() to name the y-axis “Frequency (%)” ➏, then set the x-axis tick
    marks based on the index variable ➐. The tick labels will be the numbers 1 through
    9, so use the index variable again and set the font size to 14.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '***Completing the Bar Chart Function***'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 16-6](ch16.xhtml#ch16list6) completes the bar_chart() function by
    defining the bars, annotating the top of each bar with its frequency value, and
    plotting the Benford distribution values as red-filled circles.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '*benford.py,* part 6'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '# build bars'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: ➊ rects = ax.bar(index, data_pct, width=0.95, color='black', label='Data')
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '# attach a text label above each bar displaying its height'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '➋ for rect in rects:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: ➌ height = rect.get_height()
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: ➍ ax.text(rect.get_x() + rect.get_width()/2, height,
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '''{:0.1f}''.format(height), ha=''center'', va=''bottom'','
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: fontsize=13)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '# plot Benford values as red dots'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: ➎ ax.scatter(index, BENFORD, s=150, c='red', zorder=2, label='Benford')
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '# Hide the right and top spines & add legend'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: ➏ ax.spines['right'].set_visible(False)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: ax.spines['top'].set_visible(False)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: ➐ ax.legend(prop={'size':15}, frameon=False)
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: ➑ plt.show()
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-6: Completes the function for generating a bar chart*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Name a variable, called rects, for rectangles, and use it to hold the bars for
    the bar chart ➊. You generate these with the bar() method, which returns a container
    with all the bars. Pass it the index variable and list of frequency counts as
    percentages, set the width of each bar to 0.95, fill them with black, and set
    the label argument to 'Data'. The last parameter is a very handy way to autogenerate
    a legend. You’ll take advantage of this near the end of the function.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: I’m a fan of plotting the actual bar value just above the bar so you don’t have
    to squint over at the y-axis and try to guess it. To do this, start by looping
    through each bar (rect) in rects ➋ and get its height ➌, which is its y-axis value.
    Then, call the ax object’s text() method ➍ and pass it the x-location of the left-hand
    side of the bar—obtained with the get_x() method—and add to it half the width
    of the bar in order to center the label over the bar. Because you use the get_width()
    method, you only have to assign the bar width once, which you did in step ➊. Next
    comes the bar height—formatted to one decimal place—followed by the horizontal
    and vertical alignments. Set these to the center and the bottom of the text bounding
    box, respectively. Finish by assigning the text size.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Now, start building the matplotlib “markers”—in this case, dots—that will flag
    the location of the Benford distribution frequencies for each first digit. Do
    this using the scatter() method, which builds scatterplots ➎.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: The first two arguments for scatter() are the x-y locations for each marker,
    represented by consecutive pairs from the index and BENFORD lists. Next is the
    marker size, set at 150, followed by a color. Both red and DodgerBlue work well.
    You want the markers to post on top of the bars, so set the zorder to 2. Elements
    in the figure are referred to as matplotlib “artists,” and artists with higher
    zorder values will plot over those with lower values. Finish with the label argument
    used to make a legend.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The next two statements are for aesthetics. By default, matplotlib will draw
    a box around the interior of the plot, and the upper border may interfere with
    the labels posted at the top of each bar. So, remove the top and right borders
    by setting their visibility to False ➏.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Use legend() to build a legend for the plot ➐. This will work with no arguments,
    but set its size attribute to 15 and turn off the frame around the legend for
    an arguably more attractive result. End by calling plt.show() to display the chart
    ➑. An example bar chart is shown in [Figure 16-7](ch16.xhtml#ch16fig7).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0360-01.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-7: Example output of the* bar_chart() *function*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: In the main() function, you will display additional information as text in the
    interpreter window. This will include the value of the chi-square test statistic.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '***Defining and Running the main() Function***'
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 16-7](ch16.xhtml#ch16list7) defines the main() function and runs the
    program as a module or stand-alone. Since most of the work is done in the individual
    functions, main() “mainly” calls these functions and prints some statistics.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '*benford.py,* part 7'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '"""Call functions and print stats."""'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '# load data'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '➊ filename = input("\nName of file with COUNT data: ")'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: data_list = load_data(filename)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'except IOError as e:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: print("{}. Try again.".format(e), file=sys.stderr)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: break
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: ➋ data_count, data_pct, total_count = count_first_digits(data_list)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: ➌ expected_counts = get_expected_counts(total_count)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: print("\nobserved counts = {}".format(data_count))
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: print("expected counts = {}".format(expected_counts), "\n")
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: ➍ print("First Digit Probabilities:")
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '➎ for i in range(1, 10):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'print("{}: observed: {:.3f}  expected: {:.3f}".'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: format(i, data_pct[i - 1] / 100, BENFORD[i - 1] / 100))
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '➏ if chi_square_test(data_count, expected_counts):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: print("Observed distribution matches expected distribution.")
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: print("Observed distribution does not match expected.",
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: file=sys.stderr)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: ➐ bar_chart(data_pct)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '➑ if __name__ == ''__main__'':'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: main()
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-7: Defines the* main() *function and runs the program as a module
    or stand-alone*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by asking the user to input the name of the file with the count data
    to be analyzed ➊; embed this request in a while loop that will continue until
    the user enters a valid filename or closes the window. The user can enter a filename
    or a full pathname if they want to load a dataset that isn’t stored in the current
    working directory. For example, in Windows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Name of file with COUNT data: C:\Python35\Benford\Illinois_votes.txt'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Use a try statement to call the load_data() function you built earlier and pass
    the function the filename. If the filename is valid, the returned list is assigned
    to the data_list variable. If an exception occurs, catch it and print the error.
    Otherwise, break from the while loop.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Next, pass the returned list of data counts to the count_first_digits() function
    and unpack the results as the variables data_count, data_pct, and total_count,
    which are lists of the first-digit counts, percentages, and total number of counts,
    respectively ➋. Then, generate a list of the counts expected for a Benford’s law
    distribution by calling the get_expected_counts() function and passing it the
    total_count variable ➌. Print the lists of observed and expected counts.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Now, make a table that compares the first-digit frequency in the data with the
    expected values. Use probabilities, as decimal values are easy to keep attractively
    aligned in the shell. Start with a header print statement ➍, then loop through
    the numbers 1 to 9, printing the results for the observed counts (data), followed
    by the expected counts, each to three decimal places ➎. Note that the indexes
    in the two lists start with zero, so you have to subtract 1 from i.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Pass the two count lists to the chi_square_test() function in order to calculate
    how well the observed data fit the expected distribution ➏. If the function returns
    True, use a print statement to let the user know the observed distribution matches
    Benford’s law (or, more technically, *there is no significant difference* between
    the two). Otherwise, report that they don’t match, and for shell users, color
    the font red.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: The chi_square_test() function will display its results in the interpreter window,
    so call the bar_chart() function to generate a bar chart ➐. Pass it the list of
    data counts as percentages.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Back in the global space, end the program with the code for running it as a
    module or in stand-alone mode ➑.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: If you run the program on the *Illinois_votes.txt* dataset, you will see the
    output shown in [Figure 16-8](ch16.xhtml#ch16fig8). There is no apparent anomaly
    in the voting results, based on Benford’s law.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0362-01.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-8: Output of* benford.py *for the dataset* Illinois_votes.txt'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: If you run the program using only the Trump votes, then only the Clinton votes,
    you get the results shown in [Figure 16-9](ch16.xhtml#ch16fig9). Trump’s distribution,
    with a test statistic of 15.129, barely passes the chi-square test.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0363-01.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-9: Comparison of Trump results (left) versus Clinton results (right)
    for the state of Illinois*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: In cases like this, you should be careful about drawing immediate conclusions.
    The dataset is small—only 102 samples per candidate—and the results may be influenced
    by things like demographic and voter turnout differences between rural and urban
    areas. An interesting article on this urban-rural divide can be found at *[http://www.chicagotribune.com/news/data/ct-illinois-election-urban-rural-divide-2016-htmlstory.html](http://www.chicagotribune.com/news/data/ct-illinois-election-urban-rural-divide-2016-htmlstory.html)*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'In “[Practice Project: Beating Benford](ch16.xhtml#lev393)” on [page 364](ch16.xhtml#page_364),
    you’ll get a chance to tamper with the Illinois vote counts and alter the outcome.
    You’ll then use the preceding code to see how well the results conform to Benford’s
    law.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Way back in [Chapter 1](ch01.xhtml#ch01), we used the “[Poor Man’s Bar Chart](ch01.xhtml#lev28)”
    practice project on [page 15](ch01.xhtml#page_15) and the “[Poor Foreign Man’s
    Bar Chart](ch01.xhtml#lev30)” challenge project on [page 16](ch01.xhtml#page_16)
    to look at how the frequency of occurrence of letters in a language is both irregular
    and predictable. This provides a powerful tool for cryptanalysis. Here at the
    end of the book, we’ve come full circle and found that even numbers share this
    trait, resulting in a powerful tool for fraud detection. With a short and simple
    Python program, you can shake the very pillars of heaven and bring the high and
    mighty crashing down to earth—all because someone noticed that the front pages
    of a book were dirty.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Well, that does it for *Impractical Python Projects*. I hope you had fun, learned
    something new, and were inspired to create your own set of impractical projects!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Benford’s Law: Applications for Forensic Accounting, Auditing, and Fraud Detection*
    (John Wiley & Sons, 2012) by Mark Nigrini covers the mathematics, theory, and
    testing of Benford’s law together with example applications, including fraud,
    tax evasion, and Ponzi schemes.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: Beating Benford**'
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Test your skill at rigging an election using this practice project. You can
    find a solution, *beat_benford_practice.py*, in the appendix or download it from
    *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'A dataset shouldn’t be considered valid just because it follows Benford’s law.
    The reason is simple: if you know about Benford’s law, then you can beat it.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: To prove this, pretend you’re a high-level hacker for a nefarious foreign government
    with access to all the voting records in the state of Illinois. Write a Python
    program that tampers with county-wide votes so that Donald Trump wins the state,
    but the vote counts still obey Benford’s law. Be careful; Illinois is a “blue”
    state, so you don’t want to engineer a landslide victory (loosely defined as a
    10–15 percentage point advantage in the popular vote). To avoid suspicion, Trump
    should squeak by with a few percentage points.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '*States have rules regarding the recount of votes. Before manipulating an election,
    a fraudster would want to be aware of these to avoid the scrutiny a recount would
    bring. The actual statutory rules for each state are no fun to read, but the Citizens
    for Election Integrity Minnesota provides approachable summaries. The one for
    Illinois can be found at* [https://ceimn.org/searchable-databases/recount-database/illinois/](https://ceimn.org/searchable-databases/recount-database/illinois/).'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Your program should steal votes from the other candidates, while preserving
    the by-county totals; that way, the total number of votes cast doesn’t change.
    As a quality-control step, print out the old and new vote totals by county for
    Trump and Clinton, as well as their old and new statewide totals. Then, write
    out a text file that you can input into *benford.py* so you can check how you
    did with respect to Benford’s law.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Datasets for each candidate are already prepared and listed here; you can download
    them from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    Each of these datasets is just a column of numbers, representing votes, that has
    been sorted alphabetically by county (so don’t change the order!).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '*Clinton_votes_Illinois.txt*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '*Johnson_votes_Illinois.txt*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '*Stein_votes_Illinois.txt*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '*Trump_votes_Illinois.txt*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 16-10](ch16.xhtml#ch16fig10) shows the results of running *benford.py*
    on the output from my attempt, *beat_benford_practice.py*, which used the preceding
    datasets. The distribution passes the chi-square test and yields a visually convincing—but
    plausibly imperfect—fit to the values predicted by Benford’s law.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0365-01.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-10: Results of running the distribution from* beat_benford_practice.py
    *in* benford.py*. Mischief managed!*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Shown here are a few lines of output from *beat_benford_practice.py*, with
    the old and new vote totals by county:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0365-02.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: The third line from the top represents Cook County, which contains Chicago.
    Note that Clinton still wins here, but by a lower margin. For Trump to win this
    blue county outright would be a tremendous red flag that vote tampering had occurred,
    even if he won the whole state by only a small margin!
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Projects**'
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try your hand at these challenge projects. No solutions are provided.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '***Benfording the Battlegrounds***'
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: No candidate needs to cheat in a state they’re guaranteed to win. If you’re
    an investigator looking into voter fraud, you would most likely start with the
    battleground states. These could swing either way, and candidates spend much of
    their war chest—and time—on these places. According to Ballotpedia (*[https://ballotpedia.org](https://ballotpedia.org)*),
    Trump’s battleground states in 2016 were Arizona, Iowa, Michigan, Wisconsin, Ohio,
    Pennsylvania, North Carolina, and Florida. Clinton’s were Colorado, Nevada, New
    Hampshire, and Virginia.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'The online voting records for states are commonly provided in a number of formats,
    such as Microsoft Excel spreadsheets. Gather the ones for the battleground states,
    convert them to text files, and run them through *benford.py*. To get you started,
    you can find the Ohio records here: *[https://www.sos.state.oh.us/elections/](https://www.sos.state.oh.us/elections/)*.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '***While No One Was Looking***'
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Former Speaker of the US House of Representatives Tip O’Neill was famous for
    saying, “All politics is local.” Take this to heart and use the *benford.py* program
    to check out some of your local area races, such as for judges, mayors, county
    supervisors, sheriffs, and city council members. These events generally attract
    less scrutiny than do races for Senate seats, governor, or president. If you find
    an irregularity, make sure the voting dataset is a valid application for Benford’s
    law before raising a stink!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
