- en: '4'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: POINTS AND VECTORS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Points and vectors are the basis of geometry. In this book, we’ll use them as
    our *primitives*, the building blocks for the rest of our geometry library. For
    our geometry library to be usable, it’s crucial that we implement points and vectors
    using bug-free code. A bug in our code will not only cause errors in the library’s
    functions but also could propagate to all the other libraries we build on top
    of it, giving us all sorts of false calculations.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have two main tasks. First, we need to implement classes
    to represent both points and vectors. Then, we need to make sure our code is bug-free
    by unit testing, a process we’ll repeat throughout this book. Before we can do
    either, though, we need to implement a few useful methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Comparing Numbers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When it comes to representing real numbers, computers don’t have infinite precision.
    Most computers use floating-point numbers to store these values, which cannot
    represent every rational number, let alone irrational numbers. Thus, when comparing
    floating-point numbers, you have to specify a *tolerance*: a number *ϵ* as small
    as you need such that'
  prefs: []
  type: TYPE_NORMAL
- en: '|*a – b*| < *ϵ*'
  prefs: []
  type: TYPE_NORMAL
- en: where *a* and *b* are the two numbers you want to compare.
  prefs: []
  type: TYPE_NORMAL
- en: A tolerance’s order of magnitude needs to be consistent with the problem’s magnitudes
    and your desired precision. For example, it wouldn’t make much sense to use a
    tolerance of 1*E*^(–20) mm when working with a planet’s orbital lengths, which
    are on the order of millions of kilometers. Similarly, it would be pointless to
    use a tolerance of 1*E*^(–2) cm when working with atomic distances.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start writing our primitives, we’ll need a way of knowing whether
    two floating-point numbers can be considered equal or not given a tolerance *ϵ*.
    But we can’t rely on the computer to compare floating-point numbers, as a different
    digit in the hundredth decimal is logically considered to be a completely different
    number. So, we’ll start this chapter by writing a function that compares two numbers
    using a given tolerance. For our geometrical calculations, we’ll use a default
    tolerance of 1*E*^(–10), which is an acceptable level of precision for most of
    the calculations we’ll do throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Open your project in the IDE, right-click the project’s root folder, and select
    **New** ▸ **Python Package**. Name it *geom2d* and click **OK**. This will be
    the package for all of our geometry code.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Because the package name establishes that everything inside is in 2D, we won’t
    repeat this piece of information when giving names to our files and classes. Inside
    the package, we’ll use names like* point *or* segment *instead of* point2d *or*
    segment2d*. If we wanted to create a three-dimensional geometry package,* geom3d*,
    we’d still use* point *and* segment*, only with different, three-dimensional implementations.*'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file by right-clicking the *geom2d* package folder and selecting
    **New** ▸ **Python File**. Name it *nums*, leave the Kind drop-down as is, and
    click **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: With the file created, let’s implement our first comparison function. [Listing
    4-1](ch04.xhtml#ch4lis1) has the code for our function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-1: Comparing numbers*'
  prefs: []
  type: TYPE_NORMAL
- en: First, we import the *math* module, part of Python’s standard library that contains
    useful mathematical functions. Our function takes two numbers, a and b, and an
    optional tolerance parameter that will default to 1*E*^(–10) if no other value
    is provided. Last, we use the math library’s fabs function to check whether the
    absolute value of the difference between a and b is smaller than the tolerance,
    and we return the appropriate boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, we’ll find there are two particular values we’re comparing against:
    zero and one. To save us from repeatedly writing something like'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: let’s implement them as functions. After the previous function, add the code
    in [Listing 4-2](ch04.xhtml#ch4lis2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-2: Comparing number to zero or one*'
  prefs: []
  type: TYPE_NORMAL
- en: Functions like the ones in [Listing 4-2](ch04.xhtml#ch4lis2) aren’t strictly
    necessary, but they are convenient, and they make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Point Class**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A point, according to Euclid’s first volume of the *Elements*, is “that of which
    there is no part.” In other words, a point is an entity with no width, length,
    or depth. It is just a position in space, something you can’t see with your naked
    eye. Points are the basis of all Euclidean geometry, and everything else in his
    writings is based on this simple concept. Accordingly, our geometry library will
    also be based on this powerful primitive.
  prefs: []
  type: TYPE_NORMAL
- en: A point consists of two numbers, *x* and *y*. These are its coordinates, sometimes
    also called *projections*. [Figure 4-1](ch04.xhtml#ch4fig1) depicts a point *P*
    and its coordinates in the Euclidean plane.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: A point P in the plane*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement a class representing a two-dimensional point. As before, we’ll
    create a new file by right-clicking the *geom2d* package folder and selecting
    **New** ▸ **Python File**. Name it *point* and click **OK**. Inside the file,
    enter the code in [Listing 4-3](ch04.xhtml#ch4lis3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-3: Our Point class*'
  prefs: []
  type: TYPE_NORMAL
- en: The coordinates are passed to the initializer method (__init__) and stored as
    attributes of the class.
  prefs: []
  type: TYPE_NORMAL
- en: With our initializer written, let’s implement some functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '***Calculating Distance Between Points***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To compute the distance *d*(*P, Q*) between the two points *P* and *Q*, we use
    [Equation 4.1](ch04.xhtml#ch04eqa01).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04eqa01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *P*[*x*] and *P*[*y*] are *P*’s coordinates, and *Q*[*x*] and *Q*[*y*]
    are *Q*’s coordinates. We can see this graphically in [Figure 4-2](ch04.xhtml#ch4fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Distance between the points P and Q*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement our distance calculation in two ways. We could call the method
    on a point p to compute the distance to another point q, as in p.distance_to(q).
    We could also implement the same calculation as a function where both points are
    given as arguments: distance_between(p, q). The former is the object-oriented
    style; the latter is functional. Because we’re doing object-oriented programming
    here, we’ll go with the former.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-4](ch04.xhtml#ch4lis4) has the code to implement [Equation 4.1](ch04.xhtml#ch04eqa01)
    in our class.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-4: Calculating the distance between two points*'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the *math* module, which loads a bunch of useful mathematical
    operations into our class. We define the distance_to method with self and other
    as arguments: self is the current point, and other is the point we want to calculate
    the distance to. We then calculate the distance (or *delta*) between the two coordinates
    and use the power (**) operator to square both deltas and return the square root
    of their sum.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s test this out. Open the Python console from the IDE and try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Exciting! We’ve taken the first major step in building our geometry library—Euclid
    would be proud. You can try that same operation with your calculator and see whether
    our implementation yields the correct result. Later in the chapter, we’ll automate
    a test that checks that the distance method yields the right result.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we have the console open and p and q loaded, try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Evaluating point p yields a string telling us p is an object of the Point class
    at memory position 0x10f8a2588. Note that the memory address you obtain will likely
    be different than mine. Without knowing everything in the computer’s memory (and
    reading hexadecimal), this description isn’t much help. You can also inspect the
    __dict__ attribute of any class to get a dictionary of all the attributes it holds.
    That gives you more interesting information about the instance. Later in the chapter,
    we’ll be implementing a special method that will help print a cleaner description
    of the object, something like (2, 5).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now focus our attention on overloading the + and – operators for the Point
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '***Addition and Subtraction Operators***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next basic operations we’ll need are addition and subtraction, operations
    that we’ll also implement for vectors. We’ll use these basic methods quite often,
    both on their own and to build more complex methods. We could implement them as
    normal methods, calling them with something like p.plus(q) and p.minus(q), but
    we can do better. Python allows us to overload + and – operators (as we learned
    in “Magic Methods” on [page 43](ch02.xhtml#ch00lev2sec25)) so that we can write
    p + q and p - q and have Python know to add and subtract the points correctly.
    Overloading operators makes code like this much easier to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: '*Overloading* an operator in Python involves implementing a method using a
    specific name that corresponds to the operator. Then, when Python finds the operator,
    it will replace it with the method you’ve defined and call it. For the + operator,
    the name is __add__, and for –, it is __sub__. [Table 4-1](ch04.xhtml#ch4tab1)
    contains common operators we can overload in our classes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-1:** Python’s Overloadable Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Method Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| + | __add__(self, other) | Addition |'
  prefs: []
  type: TYPE_TB
- en: '| - | __sub__(self, other) | Subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| * | __mul__(self, other) | Multiplication |'
  prefs: []
  type: TYPE_TB
- en: '| / | __truediv__(self, other) | Division |'
  prefs: []
  type: TYPE_TB
- en: '| % | __mod__(self, other) | Modulo |'
  prefs: []
  type: TYPE_TB
- en: '| == | __eq__(self, other) | Equality |'
  prefs: []
  type: TYPE_TB
- en: '| != | __ne__(self, other) | Inequality |'
  prefs: []
  type: TYPE_TB
- en: '| < | __lt__(self, other) | Less than |'
  prefs: []
  type: TYPE_TB
- en: '| <= | __le__(self, other) | Less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| > | __gt__(self, other) | Greater than |'
  prefs: []
  type: TYPE_TB
- en: '| >= | __ge__(self, other) | Greater than or equal to |'
  prefs: []
  type: TYPE_TB
- en: Let’s implement the addition and subtraction operations as methods. Inside the
    Point class and after the distance_to method, add the code in [Listing 4-5](ch04.xhtml#ch4lis5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-5: Adding and subtracting points*'
  prefs: []
  type: TYPE_NORMAL
- en: The method __add__ creates and returns a new Point where its projections are
    the sum of the two parameters’ projections. This operation doesn’t make a lot
    of sense algebraically speaking, but we may find it useful later. The method __sub__
    does the same where the resulting projections are the subtraction of the input
    points’ projections. Subtracting two points *P – Q* yields a vector going from
    *Q* to *P*, but we haven’t created a class for vectors yet. We will refactor this
    code in the next section so that it returns a vector instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement our next major primitive: the vector.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Vector Class**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to points, *vectors* in the Euclidean plane are composed of two numbers,
    called the coordinates, that encode a magnitude and a direction. The vector ⟨3,
    5⟩, for instance, can be understood as the displacement achieved by moving 3 units
    in the positive direction of the horizontal axis and 5 units in the positive direction
    of the vertical axis. [Figure 4-3](ch04.xhtml#ch4fig3) depicts a vector ![Image](../images/pvictorit.jpg)
    in the Euclidean plane.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: A vector ![Image](../images/pvictor.jpg) in the plane*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many physical quantities are vectorial: they require both a magnitude and a
    direction to be completely defined. For example, velocities, accelerations, and
    forces are all vector quantities. Since vectors are so common, let’s create a
    class to represent them.'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the *geom2d* package folder and select **New** ▸ **Python File**.
    Name it *vector* and click **OK**. Then enter the code in [Listing 4-6](ch04.xhtml#ch4lis6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-6: Vector class*'
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of Vector is similar to that of the Point class. The coordinates
    are named u and v instead of x and y. This is just a convention to avoid mixing
    points and vectors unwittingly.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on, let’s refactor the Point class’s __sub__ method so that it
    returns a Vector. Recall that subtracting two points *P – Q* yields a vector going
    from *Q* to *P*. Modify your *point.py* file so that it now matches the code in
    [Listing 4-7](ch04.xhtml#ch4lis7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-7: Refactoring Point __sub__ method*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll take a closer look at this operation in “Vector Factories” on [page 89](ch04.xhtml#ch00lev2sec52),
    where we’ll use this operation to create vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now implement some useful methods for the Vector class.
  prefs: []
  type: TYPE_NORMAL
- en: '***Addition and Subtraction Operators***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like with points, adding vectors and subtracting them are common operations.
    For example, we can get the sum of two forces (which are vector quantities) by
    summing the vectors representing them.
  prefs: []
  type: TYPE_NORMAL
- en: After the __init__ method, enter the code in [Listing 4-8](ch04.xhtml#ch4lis8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-8: Vector addition and subtraction*'
  prefs: []
  type: TYPE_NORMAL
- en: In both the __add__ and __sub__ methods, we create a new instance of Vector
    to hold the addition or subtraction of projections.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-4](ch04.xhtml#ch4fig4) depicts the addition and subtraction operations
    of two vectors, ![Image](../images/pvictorit.jpg) and ![Image](../images/qvictorit.jpg).
    Notice how subtracting ![Image](../images/pvictorit.jpg) – ![Image](../images/qvictorit.jpg)
    can be interpreted as the sum of ![Image](../images/pvictorit.jpg) and –![Image](../images/qvictorit.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: A sum of two vectors: ![Image](../images/pvictor.jpg) + ![Image](../images/qvictor.jpg)
    and a subtraction of two vectors: ![Image](../images/pvictor.jpg) – ![Image](../images/qvictor.jpg)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you might be wondering if we’ll do the same thing for the other operators.
    Addition and subtraction translate easily to the world of points and vectors,
    but for something like the __mul__ operator (used to overload the multiplication
    operation), it’s not as simple. It’s unclear whether multiplication would be the
    dot product, the cross product, or a vector scaling operation. Instead of using
    a single operator, we’ll simply implement these operations as methods with descriptive
    names: scaled_by, dot, and cross.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin with scaling.
  prefs: []
  type: TYPE_NORMAL
- en: '***Scaling Vectors***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To *scale* a vector ![Image](../images/uvictorit.jpg), you multiply it by a
    magnitude *k* called a *scalar*, which will stretch or shrink the vector. Mathematically,
    the scalar multiplication looks like [Equation 4.2](ch04.xhtml#ch04eqa02):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04eqa02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s create a scaling method in the Vector class. Enter the code in [Listing
    4-9](ch04.xhtml#ch4lis9) under the __sub__ method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-9: Scaling a vector*'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous code, we simply return a new Vector whose u and v attributes
    are multiplied by factor, the passed-in scalar.
  prefs: []
  type: TYPE_NORMAL
- en: '***Displacing Points***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Using the scaled method, we can implement another operation: displacing a point
    *P* by a given vector ![Image](../images/uvictorit.jpg) *k* times. Mathematically,
    that looks like [Equation 4.3](ch04.xhtml#ch04eqa03).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04eqa03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Graphically it looks like [Figure 4-5](ch04.xhtml#ch4fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: Displacing a point P by a vector ![Image](../images/uvictor.jpg)
    a given number of times k (2 in this case)*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement it programmatically inside our Point class, as the displacement
    subject is the point ([Listing 4-10](ch04.xhtml#ch4lis10)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-10: Displacing a point P by a vector ![Image](../images/vvictorit.jpg)
    a given number of times k*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The method gets passed two arguments: a vector vector and a scalar times. The
    vector is scaled according to times to produce the net displacement. For instance,
    a vector ⟨3, 5⟩ scaled with times = 2 would result in a displacement of ⟨6, 10⟩.
    Note the parameter times gets a default value of 1, as often the passed vector
    already has the desired length. The returned point results from adding the coordinates
    of the source point and the displacement vector’s coordinates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to move a point in the Python shell. Restart the console so the previously
    imported Point and Vector classes don’t get in the way, and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can use a calculator to confirm that the math works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '***Vector Norms***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *norm* of a vector is its length. A *unitary norm* is a norm whose length
    is exactly one unit. Vectors with a unitary norm are useful for defining directions;
    hence, we’ll frequently want to know whether a vector has a unitary norm (whether
    it’s *normal*). We’ll also frequently want to *normalize* a vector: keep its direction
    but scale it to have a length of 1\. The norm of a two-dimensional vector is given
    by [Equation 4.4](ch04.xhtml#ch04eqa04).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04eqa04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s implement a property that returns the norm of Vector, and let’s implement
    another property that checks whether the vector is normal. Both are included in
    [Listing 4-11](ch04.xhtml#ch4lis11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-11: Norm of a vector*'
  prefs: []
  type: TYPE_NORMAL
- en: The value obtained from the norm property follows exactly the definition from
    [Equation 4.4](ch04.xhtml#ch04eqa04). To know whether a vector has a norm of 1,
    we use our numeric comparison is_close_to_one and pass in the vector’s norm.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll implement two other important operations: a method that normalizes a
    vector ![Image](../images/uvictorit.jpg), yielding a vector *û* with the same
    direction but unitary length, and a method that scales a vector to have a given
    length. A normalized version of a vector, which we’ll call a *unit vector* or
    *versor*, can be obtained using [Equation 4.5](ch04.xhtml#ch04eqa05).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04eqa05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A vector computed this way will have a length of 1\. Multiplying that vector
    by a scalar *k* results in a vector ![Image](../images/uvictorit.jpg)*[k]*, which
    has the same direction as the original but with a new length that’s exactly the
    value of the scalar, as shown in [Equation 4.6](ch04.xhtml#ch04eqa06).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04eqa06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In [Listing 4-12](ch04.xhtml#ch4lis12), we’ll turn those equations into code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-12: Vectors with unit or chosen length*'
  prefs: []
  type: TYPE_NORMAL
- en: To normalize a vector, we scale it by the inverse of its norm (which is equivalent
    to dividing the vector’s length by its norm). When we want a vector scaled to
    a given length, we simply normalize the vector and then scale it by the desired
    length.
  prefs: []
  type: TYPE_NORMAL
- en: '***Immutable Design***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You may have realized by now that we never mutate the attributes of any of our
    objects but rather create and return a new Point or Vector instance. To normalize
    a vector, for instance, we could have used the code in [Listing 4-13](ch04.xhtml#ch4lis13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-13: Normalization of a vector in place*'
  prefs: []
  type: TYPE_NORMAL
- en: Calling that method would result in a *normalization in place*, that is, a mutation
    of the current object’s attributes. Normalizing in place is faster and requires
    less memory but is also much more error-prone. It’s easier than it seems for your
    program to mistakenly mutate an object that is being used by other parts of the
    program not expecting the change. Finding these kinds of bugs is really tricky
    and requires extensive debugging. Furthermore, programs using immutable data are
    much easier to understand and reason about, as you don’t need to keep track of
    how objects change their state with respect to time.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the following code. It implements the normalize method in a similar
    way to the previous one, but it contains a subtle error. In this case, the normalization
    would yield a wrong result. Can you spot why?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is a tricky one. By mutating the self.x attribute in the first line, the
    second call to get the self.norm property will use the updated value for self.x.
    The first and second calls to self.norm yield different results, which is why
    we had to store the value of self.norm in a variable.
  prefs: []
  type: TYPE_NORMAL
- en: When the amount of data the object has is small, you’re better off avoiding
    mutations altogether. Your program will behave correctly if executed concurrently,
    and your code will be simpler to understand. Reducing mutability to a minimum
    will make your code more robust; as you’ll see throughout the book, we’ll adhere
    to this principle as much as we can.
  prefs: []
  type: TYPE_NORMAL
- en: '***Naming Convention***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Notice the naming convention for methods. Methods mutating the state of the
    object upon calling are named as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: normalize    Normalizes the vector in place
  prefs: []
  type: TYPE_NORMAL
- en: scale_by    Scales the vector in place
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods creating a new object as their result are named as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: normalized    Returns a new normalized vector
  prefs: []
  type: TYPE_NORMAL
- en: scaled_by    Returns a new scaled vector
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll implement the dot and cross products in our Vector class. These
    simple products will open the door to some useful operations such as computing
    the angle between two vectors or testing for perpendicularity.
  prefs: []
  type: TYPE_NORMAL
- en: '***Dot Product***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *dot product* between two vectors ![Image](../images/uvictorit.jpg) and
    ![Image](../images/vvictorit.jpg) yields a scalar value, a measure of how different
    the directions of the two vectors are. In two dimensions, with *θ* being the angle
    between the vectors, this product is given by [Equation 4.7](ch04.xhtml#ch04eqa07).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04eqa07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To understand the different values the dot product can have depending on the
    relative directions of the two operand vectors, let’s take a look at [Figure 4-6](ch04.xhtml#ch4fig6).
    This figure depicts a reference vector ![Image](../images/vvictorit.jpg) and three
    other vectors: ![Image](../images/avictorit.jpg), ![Image](../images/bvictorit.jpg),
    and ![Image](../images/cvictorit.jpg). A line perpendicular to ![Image](../images/vvictorit.jpg)
    divides the space in two half-planes. Vector ![Image](../images/bvictorit.jpg)
    lies on that line, so the angle *θ* between ![Image](../images/vvictorit.jpg)
    and ![Image](../images/bvictorit.jpg) is 90°, and since cos(90^°) = 0, then ![Image](../images/vvictorit.jpg)
    · ![Image](../images/bvictorit.jpg) = 0\. Perpendicular vectors yield a dot product
    of zero. Vector ![Image](../images/avictorit.jpg) happens to be on the same half-plane
    as ![Image](../images/vvictorit.jpg); therefore, ![Image](../images/vvictorit.jpg)
    · ![Image](../images/avictorit.jpg) > 0\. Lastly, ![Image](../images/cvictorit.jpg)
    is on the opposite half-plane of ![Image](../images/vvictorit.jpg); hence, ![Image](../images/vvictorit.jpg)
    · ![Image](../images/cvictorit.jpg) < 0.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Vector directions with respect to ![Image](../images/normal_avictor.jpg)
    yield different dot products.*'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the dot product is straightforward from [Equation 4.7](ch04.xhtml#ch04eqa07).
    Inside the Vector class, enter the code in [Listing 4-14](ch04.xhtml#ch4lis14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-14: Dot product*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to the cross product, let’s stop for a minute and analyze
    one of its applications: obtaining the projection of a vector in a given direction.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Projecting Vectors***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When one of the vectors involved in a dot product is a unit vector, this operation’s
    result is the length of the projection of one vector over the other vector. To
    see why, let’s use [Equation 4.7](ch04.xhtml#ch04eqa07). Given a vector ![Image](../images/uvictorit.jpg)
    and a unit vector ![Image](../images/vcapit.jpg), the dot product is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where ![Image](../images/udouble_line.jpg) · cos*θ* is exactly the projection
    of ![Image](../images/uvictorit.jpg) over the direction of ![Image](../images/vcapit.jpg).
    This will be handy for computing projections over a direction, which we could
    use to obtain the axial component of a force on a truss member, for example, as
    illustrated in [Figure 4-7](ch04.xhtml#ch4fig7). In this case, we’d simply have
    to do ![Image](../images/f0078-1.jpg) to compute the axial component ![Image](../images/fapvictor.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-7: Projection of a force ![Image](../images/fvictor.jpg) in the axial
    direction ![Image](../images/ucap.jpg) of a truss member*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement this operation as a new method. Enter the code from [Listing
    4-15](ch04.xhtml#ch4lis15) into your class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-15: Projection of a vector over another vector*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the direction argument may not be a unit vector. To make sure our
    formula works, we normalize it.
  prefs: []
  type: TYPE_NORMAL
- en: '***Cross Product***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *cross product* of two three-dimensional vectors yields a new vector that
    is perpendicular to the plane containing the other two. The order of operands
    matters and defines the direction of the resulting vector. You can figure out
    the direction of the cross product using the right-hand rule. Notice that this
    product is therefore noncommutative: ![Image](../images/f0079-3.jpg) [Figure 4-8](ch04.xhtml#ch4fig8)
    illustrates this phenomenon.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-8: Cross products are noncommutative.*'
  prefs: []
  type: TYPE_NORMAL
- en: In 3D space, the cross product can be computed using [Equation 4.8](ch04.xhtml#ch04eqa08).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04eqa08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When working in two dimensions, every vector is contained in the same plane;
    thus, every cross product yields a vector perpendicular to that plane. That is
    easy to observe from the previous expression by simply noting that *u*[*z*] =
    *v*[*z*] = 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0080-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In two-dimensional applications, the cross product is therefore considered to
    yield a scalar value, which is the z-coordinate of the previous expression’s resulting
    vector. You can think of this coordinate as being the length of the resulting
    vector. Since the x- and y-coordinates are zero, this magnitude given by the z-coordinate
    is all we need to keep. Given *θ* as the angle between vectors ![Image](../images/uvictorit.jpg)
    and ![Image](../images/vvictorit.jpg), the cross product operation in two dimensions
    can be obtained by applying [Equation 4.9](ch04.xhtml#ch04eqa09).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04eqa09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s implement the cross product. Enter the code in [Listing 4-16](ch04.xhtml#ch4lis16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-16: Cross product*'
  prefs: []
  type: TYPE_NORMAL
- en: One important application of the cross product in two dimensions is determining
    the rotational direction of angles. From [Figure 4-8](ch04.xhtml#ch4fig8) you
    can see that ![Image](../images/uvictorit.jpg) × ![Image](../images/vvictorit.jpg)
    > 0, since going from ![Image](../images/uvictorit.jpg) to ![Image](../images/vvictorit.jpg)
    describes a positive (counterclockwise) angle. Conversely, going from ![Image](../images/vvictorit.jpg)
    to ![Image](../images/uvictorit.jpg) describes a negative angle resulting in a
    negative cross product ![Image](../images/uvictorit.jpg) × ![Image](../images/vvictorit.jpg)
    < 0\. Lastly, note that parallel vectors have a cross product of zero, which is
    easy to see because sin 0 = 0\. Let’s take a closer look at this fact and write
    methods in our class that determine whether two vectors are parallel or perpendicular.
  prefs: []
  type: TYPE_NORMAL
- en: '***Parallel and Perpendicular Vectors***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using the dot and cross products, it’s easy to test whether two vectors are
    parallel or perpendicular to each other. [Listing 4-17](ch04.xhtml#ch4lis17) contains
    the code for these operations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-17: Checking whether vectors are parallel or perpendicular*'
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether two vectors are parallel to each other is as simple as checking
    that their cross product is zero. Likewise, checking whether two vectors are perpendicular
    is as simple as checking whether the dot product is zero. Notice that we use the
    function is_close_to_zero to account for floating-point number comparison difficulties
    in the calculations.
  prefs: []
  type: TYPE_NORMAL
- en: '***Angles Between Vectors***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Computing the angle between two vectors can be done with the help of the dot
    product expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0081-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Dividing the dot product term on one side by the norm product on the other
    and taking the inverse of the cosine of that expression, we get [Equation 4.10](ch04.xhtml#ch04eqa10):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04eqa10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This expression computes only the magnitude of the angle; if we want to know
    the direction, we’ll need to make use of the cross product. The sign of the angle
    can be obtained using
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0081-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'where sgn, the sign function, is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0081-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To understand why we only get the magnitude of the angle using [Equation 4.10](ch04.xhtml#ch04eqa10),
    we need to remember an important property of the cosine function. Recall from
    basic geometry that a unit vector’s angle cosine is exactly the value of its horizontal
    projection. As you can see by inspecting the unit circle from [Figure 4-9](ch04.xhtml#ch4fig9),
    two vectors with opposite angles (angles where the sum equals zero) get assigned
    the same cosine value. In other words, cos *α* = cos (–*α*), which means that
    once an angle goes through the cosine function, its sign is forever lost. That
    makes it impossible to determine what the angle’s sign is from a computed value
    of the dot product.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-9: Cosines of opposite angles are equal.*'
  prefs: []
  type: TYPE_NORMAL
- en: For many of our applications, we’ll be needing both the magnitude and sign of
    angles; with the help of the cross product, we can bring this information back.
    Let’s create two new methods, one that yields the absolute value of the angle
    (for those cases where the magnitude is enough) and another one that includes
    the sign. Enter the code in [Listing 4-18](ch04.xhtml#ch4lis18) in your Vector
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-18: Calculating the angle between two vectors*'
  prefs: []
  type: TYPE_NORMAL
- en: The first method, angle_value_to, computes the angle between self and other
    using [Equation 4.10](ch04.xhtml#ch04eqa10). We first obtain the dot product value
    and divide it by the product of norms. The angle is then the arc cosine of the
    result. The second method, angle_to, returns the value of the angle with the sign
    from the cross product. The math.copysign(x, y) function in Python returns the
    magnitude of x with the sign of y.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try these two methods in the console. Reload it and write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Just for reference, the angle value of 0.78539... is *π*/4 rad (45^°).
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s suppose we have a vector and want to create a new one by rotating
    the original by a certain angle.
  prefs: []
  type: TYPE_NORMAL
- en: '***Rotating Vectors***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Imagine that in the case of the bar subject to an external force, as we saw
    in [Figure 4-7](ch04.xhtml#ch4fig7), we’re also interested in knowing the projection
    of force ![Image](../images/fvictorit.jpg) in the direction perpendicular to the
    bar. This is the force’s shear component. To find the projection of the force,
    we first need to figure out a vector perpendicular to the direction of the bar
    *û*, which is obtained by rotating this vector *π*/2 radians, as illustrated in
    [Figure 4-10](ch04.xhtml#ch4fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-10: Rotating the bar’s direction vector *π*/2 radians*'
  prefs: []
  type: TYPE_NORMAL
- en: 'A rotation preserves the length of the original vector because a rotation is
    a transformation that respects lengths. Assuming *α* is the angle that we want
    the vector rotated by, we can use [Equation 4.11](ch04.xhtml#ch04eqa11):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04eqa11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: which in Python becomes the code in [Listing 4-19](ch04.xhtml#ch4lis19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-19: Rotating a vector*'
  prefs: []
  type: TYPE_NORMAL
- en: The rotated_radians function returns a new vector, the result of rotating the
    original one by the given number of radians. Following our immutability guidelines,
    we never mutate the source vector; instead, we return a new one with the rotation
    applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one angle, *π*/2 rad (90^°), which is quite useful for rotating a vector.
    Using *π*/2 rad, we get a new vector perpendicular to the original one. To avoid
    writing v.rotated_radians(math.pi / 2) over and over again, we can define a new
    method in our Vector class. Knowing that cos (*π*/2) = 0 and sin (*π*/2) = 1,
    the angle in [Equation 4.11](ch04.xhtml#ch04eqa11) simplifies to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0084-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s call the method perpendicular. In Python, it looks like [Listing 4-20](ch04.xhtml#ch4lis20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-20: Obtaining a perpendicular vector*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s another angle we’ll often use for rotations: *π* rad (180^°). Rotating
    a vector *π* rad results in a vector that is colinear but in the opposite direction.
    This time, cos (*π*) = –1 and sin (*π*) = 0\. The angle in [Equation 4.11](ch04.xhtml#ch04eqa11)
    now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0084-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s call the method opposite. In Python, it looks like [Listing 4-21](ch04.xhtml#ch4lis21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-21: Obtaining the opposite vector*'
  prefs: []
  type: TYPE_NORMAL
- en: These two methods, perpendicular and opposite, don’t really add anything we
    didn’t have before; we could just use rotated_radians. Nevertheless, they’re convenient,
    and we’ll be using them often.
  prefs: []
  type: TYPE_NORMAL
- en: '***Sine and Cosine***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To project a vector quantity in the x- and y-axes, we use the sine or cosine
    values of the vector’s angle, as depicted in [Figure 4-11](ch04.xhtml#ch4fig11).
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use these to compute the stiffness matrices in global coordinates of truss
    structure bars in [Part V](part05.xhtml#part05) of the book. The stiffness matrix
    of a bar is computed relative to a reference frame whose x-axis is in the direction
    of the bar’s directrix, but we’ll need to project this matrix in the direction
    of the global x- and y-axes to build the structure’s global system of equations.
  prefs: []
  type: TYPE_NORMAL
- en: If the Vector class didn’t provide these two properties, clients of this class
    could get its angle value and then compute the sine or cosine of it. Even though
    this is perfectly acceptable, it requires a few operations to first compute the
    angle and then one extra sine or cosine operation. But as you know, we can compute
    the sine and cosine values much more efficiently by their mathematical definition.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-11: Vector projections*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we have vector ![Image](../images/avictorit.jpg) with norm ∥![Image](../images/avictorit.jpg)∥,
    whose projections are labeled *u* and *v*. The sine and cosine can be computed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0085-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s implement these as attributes of the Vector class. Enter the code in [Listing
    4-22](ch04.xhtml#ch4lis22).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-22: Vector’s direction sine and cosine*'
  prefs: []
  type: TYPE_NORMAL
- en: The implementation is straightforward given the previous expressions. Let’s
    complete our Point and Vector classes by adding the last touches.
  prefs: []
  type: TYPE_NORMAL
- en: '**Completing Our Classes**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our Point and Vector classes are looking good, but they’re missing some small
    details. If we compare two instances of any of them, Python may not be able to
    determine whether they are equivalent; we’ll fix that shortly. Also, if you remember,
    Python prints object instances to the console giving their class name accompanied
    with a memory address, which is not that helpful for us; we’ll also fix this here.
  prefs: []
  type: TYPE_NORMAL
- en: '***Checking Equality***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Try entering the following in the shell (don’t forget to reload it).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'I bet ➊ didn’t surprise you: a Point is equal to itself. What about ➋? Did
    you raise your eyebrows? We are comparing two points with the same coordinates,
    but Python states they are different. Shouldn’t (1, 0) be equal to (1, 0)? It
    should, but first we have to teach Python how to compare two given instances of
    our class. By default Python considers two instances of a class to be equal if
    they’re effectively the same instance, that is, if they live in the same memory
    region. To be more explicit, write this to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Python sees instance p as the one on the memory address 0x10baa3f60 and instance
    q on 0x10c63b438. Don’t forget that the memory addresses of your instances will
    differ from these. We must instruct Python to compare our Point instances by checking
    whether the projections are close enough to be considered the same. If you recall
    from [Table 4-1](ch04.xhtml#ch4tab1), by implementing a method called __eq__(self,
    other), you are effectively overloading the == operator. Let’s do this for both
    the Point and Vector classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-23](ch04.xhtml#ch4lis23) contains the code for the Point class (don’t
    forget to import nums).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-23: Point equality implementation*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-24](ch04.xhtml#ch4lis24) contains the code for the Vector class.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-24: Implementing vector equality*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, in both cases the idea is the same: comparing coordinates against
    another given instance. Prior to that, we do two important checks, though. The
    first one is to check for the case where we are comparing the same instance against
    itself, in which case we don’t require any further comparison, so we directly
    return True. The second check is for the case where other is not an instance of
    the class. Since Python allows us to compare any two objects, we may be comparing
    an instance of Vector against a string, for example. If we detect this case where
    we try to compare instances from different classes, we return False, and we’re
    done. You’ll see this comparison pattern throughout the book, as all of our classes
    implementing __eq__ will use this same approach.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure we got it right, let’s repeat the experiment. Don’t forget to
    reload the console to import the last version of the code, and enter the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There you go! Now our Point and Vector classes comparison actually works as
    it is supposed to work.
  prefs: []
  type: TYPE_NORMAL
- en: '***String Representation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As you’ve seen in the console when evaluating an instance of a class, the output
    is not super helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to convert the instance to its string representation using the str
    function, we get the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When printing the string representation of Vector instances to the console,
    we’d find something like the following much more useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: That message has the information of the coordinate values and the value of the
    norm. Function str() in Python converts an instance of a class to its string representation.
    This function first checks whether the passed argument implements method __str__.
    If it does, the function calls it and returns the result. If it doesn’t, the function
    simply returns the default string representation, which in our case is that unhelpful
    memory position mess.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement __str__ in our classes. Enter [Listing 4-25](ch04.xhtml#ch4lis25)
    inside the Point class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-25: Overriding string representation for Point*'
  prefs: []
  type: TYPE_NORMAL
- en: Then enter [Listing 4-26](ch04.xhtml#ch4lis26) inside the Vector class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-26: Overriding string representation for Vector*'
  prefs: []
  type: TYPE_NORMAL
- en: We include instance attributes in the string using *f-strings* (f’’). The attributes
    are inserted between curly brackets, and Python calls their __str__ methods to
    get their string representation and concatenate the result. For example, you can
    think of the f-string,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'as being translated by Python to something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when using str() on instances of our classes, a much nicer description
    will be printed. Let’s reload the Python shell and give it a second try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Much better, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: '***Vector Factories***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *factory function* is just a function that builds an object. Factory functions
    are a good option for initializing objects that require some calculation. An initializer
    should ideally only set its class attributes and avoid any computation; for that
    we will use factories.
  prefs: []
  type: TYPE_NORMAL
- en: A factory function is also helpful to improve the readability of the code. For
    instance, if you wanted to create a Vector from a point *P* to another point *Q*,
    the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'reads much better than this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Not only that, but the latter is likely to be written many times, which should
    tell you there is an algorithm that needs to be abstracted into its own concept.
    In this particular case, the algorithm is the formula to create a vector between
    two ordered points (see [Equation 4.12](ch04.xhtml#ch04eqa12)).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*A missing abstraction is a common problem. It happens when an algorithm representing
    a concrete concept is not properly encapsulated into its own function or class
    with a descriptive name. Its main hazards are that it takes longer for our brains
    to understand code when abstractions are not well encapsulated and that the same
    algorithm is copied and pasted in many places, making it difficult to maintain.*'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file inside *geom2d*, call it *vectors*, and enter the code from
    [Listing 4-27](ch04.xhtml#ch4lis27).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-27: Vector factory functions*'
  prefs: []
  type: TYPE_NORMAL
- en: This file defines several functions, all of which have the purpose of creating
    vectors. The first function we define, make_vector_between, creates a vector going
    from a point p to another point q. We’ve harnessed our Point class’s __sub__ implementation
    to create the vector between the points. That is one handy way of creating vectors,
    expressed mathematically as shown in [Equation 4.12](ch04.xhtml#ch04eqa12).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04eqa12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we have a function called make_versor, which creates versors, or vectors
    of unit length. *Versors* are frequently used to express direction or orientation,
    so we’ll want a convenient way of creating them. Note that versors are written
    with a hat over them, as in *û*, signifying their length is unitary.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have make_versor_between to create a versor between two points, which
    reuses the make_vector_between function to return the normalized result of it.
    The resulting versor could also be computed with [Equation 4.13](ch04.xhtml#ch04eqa13).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/04eqa13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Unit Testing**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far we’ve implemented a couple of methods on classes Point and Vector, and
    we’ve tested some of them in the console by hand, but now we face some big questions:
    How can we convince someone else that our code always works as expected? How can
    we be sure what we’ve written works all the time? How can we make sure we don’t
    break anything when we modify existing code or add new code?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Often enough, you’ll need to go back to some piece of code you wrote a long
    time ago to fix a bug. The problem comes when you want to change that code but
    don’t know whether making that change will break what’s already working. In fact,
    you may not be aware of what all the code is supposed to be doing, so you end
    up changing something you shouldn’t have and break something else. This phenomenon
    happens so regularly it has its own name: *regression*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing code by hand in the console is tiresome and boring, ensuring that you
    probably won’t test everything you need to test. Besides that, it’s not a repeatable
    process: you’ll forget about which tests you executed for each method, or if someone
    else needs to run them, they’ll have to figure out what to test and how. But still,
    we really need to make sure our changes won’t break anything. Code is entirely
    useless if it doesn’t do what it’s supposed to.'
  prefs: []
  type: TYPE_NORMAL
- en: What would make our lives much easier is an automated test we could execute,
    which takes a few milliseconds to run and spits out output that clearly states
    whether anything went wrong, where, and why. This is the basic idea behind *unit
    testing*, a crucial activity for any serious developer. Your code cannot be considered
    finished until it’s accompanied with good unit tests that prove its quality. I
    consider this part of development so vital I want to cover it early in the book
    and make extensive use of it. Writing automated, unitary tests for our code is
    a simple process, and there’s really no excuse for not doing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating unit tests for your code is simple: create a new file, and inside
    it add a new class with methods that test small portions of the test subject.
    Each test case has an *assertion* function that ensures a specific result is obtained
    given a set of inputs. The test is considered to pass when the assertion succeeds
    and to fail otherwise. When the test class is executed (as we’ll see next), the
    methods are executed, and their assertions are checked.'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if this still doesn’t make sense; we’re going to use unit testing
    so much in this book you’ll get to fully understand it.
  prefs: []
  type: TYPE_NORMAL
- en: '***Testing Distances***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first method we wrote for Point was distance_to, so let’s start our unit
    test adventure there. In the *geom2d* package, create a new file named *point
    _test.py*. Your project’s structure should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Mechanics
  prefs: []
  type: TYPE_NORMAL
- en: '|- geom2d'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- __init__.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- nums.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- point.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- point_test.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- vector.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- vectors.py'
  prefs: []
  type: TYPE_NORMAL
- en: In *point_test.py*, enter the code from [Listing 4-28](ch04.xhtml#ch4lis28).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-28: Distance between points test*'
  prefs: []
  type: TYPE_NORMAL
- en: We start by importing the *unittest* module, shipped with Python. This module
    provides us with most of the infrastructure we need to write and execute unit
    tests. After importing our Point class, we define the class TestPoint, which inherits
    unittest.TestCase ➊. The TestCase class defines a good collection of assertion
    methods that we gain access to inside our class when we inherit it.
  prefs: []
  type: TYPE_NORMAL
- en: Next we have the test_distance_to method ➋. It’s important that the method name
    starts with the word *test_*, because this is how the class discovers which of
    its methods are tests to be executed. You can define other methods in the class,
    but as long as their names don’t start with *test*, they won’t be executed as
    tests. Inside the test we create two points that we know are 5 units apart from
    each other and assert that their distance p.distance_to(q) is close to that value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The* unittest *module’s choice of words may be confusing. The name* UnitTest
    *is used for the class even though the tests themselves are actually the methods
    inside the class. Our class extending* UnitTest *is just a way of grouping related
    test cases.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The assertion method assertAlmostEqual ➌ (defined in the class we inherited
    from: unittest.TestCase) checks for floating-point number equality with a given
    tolerance, which is expressed as the number of decimal positions to compare. The
    default number of decimal positions to check is 7, and in this test, we’ll stick
    to the default (as we didn’t provide any other value). Remember that when dealing
    with floating-point number comparisons, a tolerance must be used or, in this case,
    a given number of decimal positions (see the “Comparing Numbers” on [page 4](ch01.xhtml#page_4)).'
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to run tests. Let’s explore how to do it from both PyCharm
    and the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**Running the Test from PyCharm**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you take a look at your test file in PyCharm, you’ll see a little green
    play button to the left of the class and method definitions. The class button
    executes all the tests inside of it (so far we have only one), whereas the button
    next to the method will run only that one test. Click the class one; from the
    menu, select **Run ‘Unittest for point**.’ The Run pane appears in the lower part
    of the IDE, and the result of executing your tests is displayed. If you did everything
    right, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now learn how to run the same test from the console.
  prefs: []
  type: TYPE_NORMAL
- en: '**Running the Test from the Console**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'IDEs other than PyCharm may have their own way to run tests. But regardless
    of the IDE you use, you can always run tests from the console. Open the console
    or shell and make sure you’re in the *Mechanics* project directory. Then run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We’ll run most of the tests throughout the book from the IDE, but feel free
    to run them from the console if you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Assertion Errors**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s see what would’ve happened if the assertion detected a wrong result.
    Inside *point_test.py*, change the expected value for the distance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This assertion is expecting points (1, 2) and (4, 6) to be 567 units apart,
    which is totally wrong. Now execute the test again by clicking the green play
    button beside the class. This is the result you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The message with the most valuable information is the last one. It’s telling
    us that there was an assertion error; that is, the assertion failed when it found
    5.0 where 567 was expected. It used 7 decimal places in the comparison and still
    found a difference of 562.
  prefs: []
  type: TYPE_NORMAL
- en: Before this assertion error is the *traceback*, the execution path Python took
    until it got the error. As the message states, calls closer to the failure appear
    last in the list. As you can see, the test execution failed in file *point _test.py*
    (no surprise) on line 14 (yours may be different), in a test named test_distance_to.
    This information will prove invaluable when you modify existing code and run the
    tests only to find out whether a test fails, as it can tell you what exactly broke.
    These test failure messages will give you precise information.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to put our unit test back to how we initially wrote it and make
    sure it still runs successfully.
  prefs: []
  type: TYPE_NORMAL
- en: '***Testing Vector Plus and Minus Operations***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To ensure + and – operations work properly for vectors (doing the same for
    the Point class is left as an exercise for you), let’s use the following test
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0094.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0094a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Create a new file inside package *geom2d* for testing the Vector class. Name
    it *vector_test* and enter the code from [Listing 4-29](ch04.xhtml#ch4lis29).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-29: Tests for plus and minus operations*'
  prefs: []
  type: TYPE_NORMAL
- en: Run all tests using the green play button to the left of the class definition.
    If you got everything right, your two new tests should succeed. Yay! Our operations
    were properly implemented. The nice thing is, if there had been a bug in the implementation,
    these tests would have pointed out where and why.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s worth noting that this time we’re using assertion method assertEqual,
    which under the hood compares both arguments using the == operator. If we hadn’t
    overloaded this operator in the Vector class, the tests would fail even if the
    results were right. Try this: comment out the __eq__(self, other) method definition
    (by appending a # character at the beginning of the line) in the Vector class
    and rerun the tests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll find how the last two tests fail with a message like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Familiar? That’s Python assuming two objects from the class can be equal only
    if they are the same actual object living in the same memory position. Our __eq__
    operator overload explains to Python the rules to determine when two objects should
    be considered the same. Don’t forget to uncomment the method.
  prefs: []
  type: TYPE_NORMAL
- en: '***Testing Vector Product Operations***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s add two new test cases for dot and cross products using the same two
    vectors defined in the test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0095-p1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0095-p2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In code, this looks like [Listing 4-30](ch04.xhtml#ch4lis30).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-30: Tests vector dot and cross products*'
  prefs: []
  type: TYPE_NORMAL
- en: Run all test cases to make sure the new ones also succeed. Note that, as we’re
    comparing numbers again, we use assertion method assertAlmostEqual.
  prefs: []
  type: TYPE_NORMAL
- en: '***Testing Vector Parallelism and Perpendicularity***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next we’ll test the is_parallel_to and is_perpendicular_to methods. Since we’re
    checking a Boolean expression, we want to have two tests, one checking that the
    two vectors are parallel (a positive test) and one checking whether they’re not
    (a negative test). For the positive case, we’ll rely on the fact that a vector
    is always parallel to itself. Enter the [Listing 4-31](ch04.xhtml#ch4lis31) code
    inside TestVector.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-31: Testing vector parallelism*'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two new assertion methods in this listing that are interesting ones:
    assertTrue, which checks whether a given expression evaluates to True; and assertFalse,
    which checks whether a given expression evaluates to False.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll follow the same pattern for checking perpendicularity. After the last
    two tests, enter the two in [Listing 4-32](ch04.xhtml#ch4lis32).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-32: Testing vector perpendicularity*'
  prefs: []
  type: TYPE_NORMAL
- en: Run all tests inside the TestVector class to make sure they succeed. Congratulations!
    You’ve implemented your first unit tests. These tests will ensure the methods
    in our geometry classes work as expected. Additionally, if you find a better implementation
    for one of the methods we covered with tests, to make sure it still works as expected,
    just run its tests. Tests also serve to document the expected behavior of your
    code. If at some point you need a reminder about what the code you wrote is supposed
    to do in a particular case, unit tests should help.
  prefs: []
  type: TYPE_NORMAL
- en: Writing good tests is not a simple endeavor. One gets good at it by writing
    many, but there are some guidelines we can follow that will help us. Let’s take
    a look at three simple rules that will make our tests much more resilient.
  prefs: []
  type: TYPE_NORMAL
- en: '***Three Golden Rules for Unit Testing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ve covered tests for a small fraction of the methods from the Point and
    Vector classes. Now that you have the required knowledge, try testing all the
    methods that we wrote in both the Point and Vector classes. I’ll leave this for
    you as an exercise, but you can take a look at the code provided with the book
    if you need help: it includes a lot of unit tests. Look for all the methods we
    didn’t test and write the tests you think are needed to make sure they work properly.
    I encourage you to try, but if you still feel like unit testing is foreign to
    you, don’t worry, we’ll be writing unit tests in other chapters of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, I believe writing unit tests is an integral part of coding, and
    handling software not covered by unit tests should be considered a poor practice.
    Moreover, writing code for the open-source community requires good unit tests.
    You’ve got to give the community a reason to believe what you did actually works.
    Proving this with automated tests that anybody can easily run and see for themselves
    is always a good approach, as it’s unlikely anybody is going to take the time
    to think about how to test your code and then open the console and manually try
    it all.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll get better at writing reliable unit tests as you practice. For now, I’d
    like to give you some basic rules to follow. Don’t expect to fully grasp their
    meanings now, but come back to this section from time to time as you move through
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 1: One Reason to Fail**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unit tests should have one and only one reason to fail. This sounds simple,
    but in many cases the *test subject* (what you are testing) is complex and made
    up of several components working together.
  prefs: []
  type: TYPE_NORMAL
- en: 'If tests fail for only one reason, it’s straightforward to find the bug in
    the code. Imagine the opposite: a test that could fail for, say, five different
    reasons. When that test fails, you’ll find yourself spending too much time reading
    error messages and debugging code, trying to understand what made it fail this
    particular time.'
  prefs: []
  type: TYPE_NORMAL
- en: Some developers and test professionals (testing is a profession on its own,
    which I spent several years doing) state that each test should have one and only
    one assertion. Being pragmatic, sometimes having more than one assertion is not
    that harmful, but if it’s one, that’s much better.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s analyze a particular case. Take the test we wrote for checking whether
    two vectors are perpendicular. If instead of
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: we had written
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: then the test could fail because of an error in the is_perpendicular_to method
    or because of an error in the implementation of perpendicular, which we use to
    compute a perpendicular vector to ![Image](../images/uvictorit.jpg). See the difference?
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 2: Controlled Environment**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We use the word *fixture* to refer to the environment where a test runs. The
    environment includes all pieces of data surrounding our test and the state of
    the test subject itself, all of which may alter the results of the test. This
    rule states that you should have total control of the fixture where your test
    runs. Inputs and expected outputs of the test should always be known beforehand.
    Everything happening inside your tests should be *deterministic*; that is, there
    should be no randomness or dependence on anything out of your control: dates or
    times, operating systems, machine environment variables not set by the test, and
    so on.'
  prefs: []
  type: TYPE_NORMAL
- en: If your tests seem to fail at random, they are useless, and you should get rid
    of them. People get used to random failing tests fast and start ignoring them.
    The problem comes when they also ignore tests that are failing because of a bug
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Rule 3: Test Independence**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Tests should never depend on other tests. Each test should run on its own and
    never depend on a fixture set by other tests.
  prefs: []
  type: TYPE_NORMAL
- en: There are at least three reasons for this. First, you’ll want to run or debug
    tests independently. Second, many test frameworks do not guarantee the execution
    order of tests. Finally, it’s much simpler to read and understand tests that don’t
    depend on other surrounding tests.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s illustrate this with the TestSwitch class in [Listing 4-33](ch04.xhtml#ch4lis33).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4-33: Test depending on another test*'
  prefs: []
  type: TYPE_NORMAL
- en: See how test_switch_off depends on test_switch_on? By using a method called
    toggle, we could get the wrong result if the tests run in a different order and
    the switch has a state of *off* when this test runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Never rely on test execution order; that results in trouble. Tests should always
    run independently: they should work the same way no matter the order of execution.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we created two important classes: Point and Vector. The rest
    of our *geom2d* library will be built upon these simple but powerful abstractions.
    We taught Python how to determine whether two given instances of Point or Vector
    are logically equal by implementing the special method __eq__, and provided a
    better textual representation with __str__. We covered some of the methods in
    these classes with unit tests, and I encouraged you to extend the coverage on
    your own. The best way to learn to write good unit tests is by practicing. In
    the next chapter, we’ll add two new geometrical abstractions to *geom2d*: lines
    and segments. These provide a new dimension that can be used to construct more
    complex shapes.'
  prefs: []
  type: TYPE_NORMAL
