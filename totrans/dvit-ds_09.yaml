- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Recommendation Systems
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐系统
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Every talented salesperson knows how to make intelligent, targeted recommendations
    to customers, and as online retailers have grown in size and sophistication, they
    have enthusiastically automated this sales tactic. But these recommendations are
    hard to make. For this reason, many businesses create automated *recommendation
    systems* that analyze data about products and customers to determine which customers
    would be most receptive to which products.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每个有才能的销售员都知道如何向顾客提出聪明、精准的推荐，随着在线零售商规模和技术的不断发展，他们热衷于自动化这一销售策略。但是，做出这些推荐并不容易。为此，许多企业创建了自动化的*推荐系统*，通过分析产品和顾客的数据来确定哪些顾客最有可能对哪些产品感兴趣。
- en: 'In this chapter, we’ll go over recommendation systems in detail. We’ll start
    with the simplest possible recommendation system: one that merely recommends the
    most popular items to every customer. We’ll go on to discuss an important technique
    called *collaborative filtering* that enables us to make unique, personalized
    recommendations for each customer and each product. We’ll go over two types of
    collaborative filtering: item based and user based. We’ll conclude with a case
    study and advanced ideas related to recommendation systems.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细讨论推荐系统。我们将从最简单的推荐系统开始：一个仅向每个顾客推荐最受欢迎商品的系统。接下来，我们将讨论一个重要的技术——*协同过滤*，它使我们能够为每个顾客和每个商品提供独特、个性化的推荐。我们将讨论两种协同过滤方法：基于商品的和基于用户的协同过滤。最后，我们将通过一个案例研究和一些与推荐系统相关的高级概念来结束本章。
- en: Popularity-Based Recommendations
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于受欢迎程度的推荐
- en: Before we write code for recommendation systems, we should consider how to make
    recommendations in general. Imagine that you’re a salesperson and you want to
    make recommendations to a customer who walks into your store. If you’re acquainted
    with the customer, you could make recommendations based on your knowledge of the
    customer’s tastes and situation. If a new customer walks into your store and you
    want to make recommendations without knowing anything about the person, you could
    observe what they’re browsing and make a recommendation based on that. But it’s
    possible that you’ll be asked to make a recommendation before they’ve browsed
    anything at all. The dilemma of needing to make intelligent recommendations without
    any specific knowledge about the customer is referred to as the *cold-start problem*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写推荐系统的代码之前，我们应该考虑如何进行推荐。假设你是一个销售员，想要向走进店里的顾客推荐商品。如果你了解这位顾客，你可以根据你对顾客口味和情况的了解来做推荐。如果是新顾客走进店里，且你对他们一无所知，你可以观察他们正在浏览的商品，并根据这个信息来推荐。但也有可能，在他们浏览任何商品之前，你就被要求做出推荐。需要在没有任何顾客具体信息的情况下做出智能推荐的问题，称为*冷启动问题*。
- en: One reasonable thing to do when faced with the cold-start problem is to recommend
    the most popular items. Doing this is simple and easy. It doesn’t have the sophistication
    of knowing everything about a customer and making a personalized recommendation,
    but if something is popular with the general public, it’s reasonable to think
    it could be appealing to your new customer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 面对冷启动问题时，一个合理的做法是推荐最受欢迎的商品。这样做简单且易于实施。虽然它不具备了解顾客所有信息并做出个性化推荐的复杂性，但如果某个商品在大众中很受欢迎，那么它很可能也会吸引新顾客。
- en: 'Online retailers have an analogous challenge: new visitors visit their websites,
    and maybe those visitors don’t have browsing history or are unfamiliar to the
    online retailers. The retailers want to make personalized recommendations based
    on detailed knowledge about customers, but when they face the cold-start problem,
    they have to fall back on something else like general popularity. The cold-start
    problem is especially common for online retailers, since it’s easy for prospective
    customers to view a website anonymously without giving any personal information
    to the website or its sales team.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在线零售商面临着类似的挑战：新的访客访问他们的网站，这些访客可能没有浏览历史记录，或者对于在线零售商来说是陌生的。这些零售商希望基于详细的顾客信息做出个性化推荐，但当他们面临冷启动问题时，只能依赖其他方法，比如普遍的受欢迎程度。冷启动问题在在线零售商中尤为常见，因为潜在顾客可以匿名访问网站，而不需要向网站或其销售团队提供任何个人信息。
- en: 'Let’s think about the code that we would use to make a popularity-based recommendation.
    For this, or any other recommendation system, having data related to transaction
    history is helpful. We can download, read, and look at some fabricated transaction
    history data as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来思考一下我们会用什么代码来做基于流行度的推荐。对于这个或任何其他推荐系统，拥有与交易历史相关的数据是很有帮助的。我们可以下载、读取并查看一些伪造的交易历史数据，如下所示：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we import the pandas package to do data wrangling. We read a *.csv* file
    from the internet into the `interaction` variable, and we store it as a pandas
    dataframe. We specify that the first column of the data should be the index (the
    row name) and print the dataframe. The output we see at the end is shown in [Listing
    9-1](#listing9-1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入了pandas包来进行数据处理。我们从互联网读取一个*.csv*文件到`interaction`变量，并将其存储为一个pandas数据框。我们指定数据的第一列作为索引（行名称），然后打印数据框。最终输出的结果显示在[列表
    9-1](#listing9-1)中。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 9-1: An interaction matrix, showing the history of purchases for each
    item'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-1：一个交互矩阵，显示每个商品的购买历史
- en: '[Listing 9-1](#listing9-1) shows a matrix representing the sales history of
    a retailer that has five customers and five items for sale. Note we’re calling
    the customers *users*, assuming that they’re users of the retailer’s website.
    But whatever we call them, the recommendation techniques we use will be the same.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9-1](#listing9-1) 显示了一个矩阵，表示一个零售商的销售历史，该零售商有五个客户和五个待售商品。请注意，我们称客户为*用户*，假设他们是零售商网站的用户。但无论我们如何称呼他们，我们使用的推荐技术都是相同的。'
- en: The matrix contains a `0` if a user did not purchase a particular item and a
    `1` if a user did. For example, you can see that `user2` purchased `item3` but
    not `item2`, and `user3` purchased `item2` but not `item3`. This type of 0/1 matrix
    is a common format to encounter when we’re building recommendation systems. We
    can call this matrix the *interaction matrix*; it represents information about
    interactions between users and items. Since nearly every company has records related
    to its items and their purchase histories, building recommendation systems based
    on interaction matrices is an extremely common practice.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 该矩阵如果用户没有购买某个商品，则该位置为`0`，如果用户购买了该商品，则为`1`。例如，你可以看到`user2`购买了`item3`但没有购买`item2`，而`user3`购买了`item2`但没有购买`item3`。这种
    0/1 矩阵是在构建推荐系统时常见的格式。我们可以称这个矩阵为*交互矩阵*；它表示了用户与商品之间的互动信息。由于几乎每家公司都有与其商品和购买历史相关的记录，因此基于交互矩阵构建推荐系统是一种非常常见的做法。
- en: 'Suppose that a new customer, whom we’ll call `user6`, walks into your store
    (or visits your website). You face a cold start, since you know nothing about
    `user6`. If you want to make recommendations for items that `user6` can purchase,
    you could make a list of the most popular items, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个新客户，我们称之为`user6`，走进了你的商店（或访问了你的网站）。你面临一个冷启动问题，因为你对`user6`一无所知。如果你想为`user6`推荐可以购买的商品，你可以列出最受欢迎的商品，方法如下：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here we create a copy of our interaction matrix called `interaction_withcounts`.
    We’ll use this copy to find the most popular items by counting the number of users
    who have ever purchased each item. Note that our matrix doesn’t record whether
    a user purchased an item multiple times or only once, so our analysis will look
    at only whether users have purchased items at all; we won’t analyze how many times
    each user purchased each item.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为`interaction_withcounts`的交互矩阵副本。我们将使用这个副本来通过计算购买每个商品的用户数量来找出最受欢迎的商品。请注意，我们的矩阵并不记录用户是否多次购买某个商品或只购买了一次，因此我们的分析只会查看用户是否购买过商品；我们不会分析每个用户购买每个商品的次数。
- en: 'Since each row of our matrix records purchases of a unique item, we use the
    `sum()` method to take the sum of purchases in each row and store the result in
    a new column called `counts`. We then use the `sort_values()` method, which sorts
    the rows of our matrix from the highest to lowest purchase counts. By sorting
    from most to least purchased, it is ordering the items by popularity. Finally,
    we print out the index of our sorted matrix, which tells us the item names of
    all of our items, sorted from most to least popular:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们矩阵的每一行记录的是某个特定商品的购买情况，因此我们使用`sum()`方法计算每一行的购买总和，并将结果存储在一个名为`counts`的新列中。然后我们使用`sort_values()`方法，它会将我们的矩阵行按购买数量从高到低排序。通过从最受欢迎到最不受欢迎排序，它将商品按流行度进行排序。最后，我们打印出排序后的矩阵的索引，显示出所有商品的名称，从最受欢迎到最不受欢迎：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can interpret this to mean that `item1` is the most popular item (in fact,
    tied with `item3`), `item2` is the third-most popular, and so on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以理解为`item1`是最受欢迎的项目（实际上与`item3`并列），`item2`是第三受欢迎的，依此类推。
- en: 'Now that you have this list, you’re ready to make recommendations to unfamiliar
    customers. The way you present your recommendations will depend on your business
    strategy, your web development team’s capabilities, and your marketing team’s
    preferences. The data science portion of a recommendation system project is to
    create the list of prioritized recommendations and let marketers or web developers
    present these to users. This is one reason that recommendation system projects
    can be challenging: they require cooperation among several teams.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了这个列表，你可以准备向不熟悉的客户提供推荐。推荐的呈现方式将取决于你的商业战略、网站开发团队的能力以及市场营销团队的偏好。推荐系统项目中的数据科学部分是创建优先推荐列表，并让市场营销人员或网页开发人员将这些推荐呈现给用户。这也是推荐系统项目具有挑战性的原因之一：它们需要多个团队的合作。
- en: 'We can create a function that generates popularity-based recommendations for
    any interaction matrix by putting together all of our code so far:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个函数，通过将我们迄今为止的所有代码结合起来，生成适用于任何交互矩阵的基于受欢迎程度的推荐：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function merely wraps up the capabilities we’ve written code for previously
    in the chapter. It takes an interaction matrix as its input. It sums up the counts
    of purchases for each item, sorts by number of purchases, and returns a list of
    item names that is sorted from most to least popular. This final sorted list can
    be used to make recommendations to customers, even if you’re unfamiliar with the
    customers. You can call this function on your interaction matrix by running `print(popularity_based(interaction))`
    in Python.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数只是将我们之前在本章中编写的代码功能进行了封装。它以交互矩阵作为输入，汇总每个项目的购买次数，按购买数量排序，并返回按从最受欢迎到最不受欢迎排序的项目名称列表。这个最终的排序列表可以用于向客户提供推荐，即使你对客户不熟悉。你可以通过在
    Python 中运行 `print(popularity_based(interaction))` 来调用这个函数。
- en: A popularity-based recommendation system is a simple, reasonable way to solve
    the cold-start problem and make some kind of recommendation to users. You can
    see popularity-based recommendations on many websites today, where *trending*
    content is highlighted. You can also see popularity-based recommendations in brick-and-mortar
    retailers, like bookstores that prominently display bestsellers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 基于受欢迎程度的推荐系统是一种简单合理的方式，用来解决冷启动问题，并向用户提供某种推荐。你可以在今天的许多网站上看到基于受欢迎程度的推荐，其中*热门*内容被突出显示。你也可以在实体零售商店看到基于受欢迎程度的推荐，例如书店中显著展示畅销书。
- en: But popularity-based recommendations are not as effective as personalized ones.
    Recommendation systems that can use detailed information about people and items
    can be more successful than generic popularity-based recommendation systems. Let’s
    take a look at one now.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但是基于受欢迎程度的推荐不如个性化推荐有效。能够使用关于人和项目的详细信息的推荐系统，比通用的基于受欢迎程度的推荐系统更有可能成功。让我们现在来看一个这样的例子。
- en: Item-Based Collaborative Filtering
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于项目的协同过滤
- en: 'Suppose that you don’t face a completely cold start. Instead, you have just
    a little information about a sixth customer: in particular, you know that they’re
    interested in `item1`. This information is all you need to make recommendations
    when using *collaborative filtering*.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你并没有完全面临冷启动问题。相反，你对第六个客户有一些信息：特别是，你知道他们对`item1`感兴趣。这个信息就是你在使用*协同过滤*时所需要的一切来做出推荐。
- en: 'Let’s look at our interaction matrix again to get some ideas for how we should
    make recommendations to someone who’s interested in `item1`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一遍我们的交互矩阵，从中获取一些关于如何向对`item1`感兴趣的人推荐的思路：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we look at the first row of our interaction matrix, we can see the full history
    of customer interactions with `item1`. This item was purchased by `user1`, `user2`,
    `user4`, and `user5`, and it was not purchased by `user3`. If we look at `item3`,
    we can see that it has exactly the same purchase history as `item1`. They could
    be similar items, like two James Bond movies, or they could be complementary,
    like peanut butter and jelly. Regardless, if two items were purchased together
    in the past, they’re likely to be purchased together in the future.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看互动矩阵的第一行，就能看到客户与 `item1` 的完整互动历史。该商品被 `user1`、`user2`、`user4` 和 `user5`
    购买，但没有被 `user3` 购买。如果我们查看 `item3`，我们会发现它与 `item1` 的购买历史完全相同。它们可能是类似的商品，比如两部詹姆斯·邦德电影，或者它们可能是互补的，比如花生酱和果酱。不管怎样，如果两个商品曾经一起被购买过，那么它们未来很可能会被一起购买。
- en: 'By contrast, look at the purchase histories of `item1` and `item2`; they have
    less overlap in customers. These items do not have highly similar purchase histories.
    Since they haven’t been purchased together often in the past, they won’t likely
    be purchased together often in the future. One way to make intelligent recommendations
    is by using this idea: if a user is interested in an item, recommend to that customer
    other items whose purchase histories have the most in common with the item they’re
    interested in. This method is called *item-based collaborative filtering*.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，看看 `item1` 和 `item2` 的购买历史；它们的客户重叠较少。这些商品的购买历史不太相似。由于它们过去没有经常一起被购买，因此它们未来也不太可能经常一起被购买。做出智能推荐的一种方式是使用这个思路：如果一个用户对某个商品感兴趣，就向他推荐其他购买历史与该商品最相似的商品。这种方法叫做*基于商品的协同过滤*。
- en: To recommend items with the most similar purchase histories, we need a way to
    quantitatively measure exactly how similar two purchase histories are. We saw
    that `item1` and `item3` have very similar (identical) purchase histories, while
    `item1` and `item2` have more different purchase histories. If we compare `item1`
    and `item5`, we can see some similarity in their histories and some differences.
    But instead of making qualitative judgments that two purchase histories are *very
    similar* or *not very similar*, using numbers to precisely quantify that similarity
    will be useful. If we can find a metric that quantifies the similarity of two
    items, we can use that metric to recommend items.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了推荐购买历史最相似的商品，我们需要一种方法来定量衡量两个购买历史之间的相似度。我们看到 `item1` 和 `item3` 的购买历史非常相似（完全相同），而
    `item1` 和 `item2` 的购买历史差异较大。如果我们比较 `item1` 和 `item5`，我们会看到它们的历史之间有一些相似性，也有一些差异。但与其做出定性的判断，认为两个购买历史是*非常相似*还是*不太相似*，用数字精确量化这种相似性将会更有用。如果我们能找到一种量化两个商品相似度的度量标准，我们就可以使用这个标准来推荐商品。
- en: Measuring Vector Similarity
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测量向量相似性
- en: 'Let’s look more closely at one item’s purchase history to get ideas for ways
    to quantitatively measure similarities:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下某个商品的购买历史，以获得定量衡量相似性的灵感：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This line of code prints out the purchase history of `item1`. The output looks
    like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码打印出 `item1` 的购买历史。输出如下所示：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We can think of this purchase history in several ways. It may seem like nothing
    more than a collection of numbers. Since the numbers are sandwiched between square
    brackets, Python will interpret this collection as a list. We could also think
    of it as a row of a matrix (our interaction matrix). Most importantly, we can
    think of this collection of numbers as a *vector*. You may remember from math
    class that a vector is a directed line segment. One way to write a vector is as
    a collection of coordinate numbers. For example, [Figure 9-1](#figure9-1) depicts
    two vectors, *A⃗* and *B⃗*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从几个角度来思考这个购买历史。它可能看起来只是一些数字的集合。由于这些数字被方括号括起来，Python 会将这个集合解释为一个列表。我们也可以将它看作一个矩阵中的一行（我们的互动矩阵）。最重要的是，我们可以将这个数字集合看作一个*向量*。你可能还记得在数学课上，向量是一个有方向的线段。表示一个向量的一种方式是将其表示为一组坐标数字。例如，[图
    9-1](#figure9-1) 描绘了两个向量，*A⃗* 和 *B⃗*。
- en: '![](image_fi/502888c09/f09001.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502888c09/f09001.png)'
- en: 'Figure 9-1: Two vectors, represented by coordinate pairs'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-1：两个向量，由坐标对表示
- en: 'In this example, *A⃗* and *B⃗* are directed line segments, or vectors. They
    are both two-dimensional. Just like every vector, both can be fully described
    by their coordinates: after we know that both vectors start at the origin, the
    coordinate pair (3,7) fully describes vector *A⃗*, and the coordinate pair (8,4)
    fully describes vector *B⃗*. The purchase history we looked at previously, `[1,1,0,1,1]`,
    can be thought of as the vector representing the purchase history of `item1`.
    In fact, all the rows of our interaction matrix, or any interaction matrix, can
    be thought of as vectors.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，*A⃗* 和 *B⃗* 是有向线段，或者说是向量。它们都是二维的。就像每个向量一样，这两个向量也可以通过它们的坐标完全描述：在我们知道这两个向量都从原点出发后，坐标对
    (3,7) 完全描述了向量 *A⃗*，而坐标对 (8,4) 完全描述了向量 *B⃗*。我们之前看到的购买历史 `[1,1,0,1,1]` 可以看作是表示 `item1`
    购买历史的向量。事实上，我们的交互矩阵中的所有行，或者任何交互矩阵，都可以看作是向量。
- en: Since we have vectors representing items, we may want to draw our vectors in
    a plot like [Figure 9-1](#figure9-1). However, in our interaction matrix, our
    item vectors have five coordinates each, so if we wanted to draw them, we would
    have to draw them in a five-dimensional plot, which is not possible to do in a
    way that humans can easily comprehend. Since we can’t draw our item vectors, let’s
    look at the *A⃗* and *B⃗* vectors in [Figure 9-1](#figure9-1) to understand how
    to measure vector similarity, then apply what we learn to our item vectors later.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有表示项目的向量，我们可能想要像[图 9-1](#figure9-1)那样在图表中绘制我们的向量。然而，在我们的交互矩阵中，每个项目向量都有五个坐标，因此如果我们想绘制它们，我们将不得不在一个五维图中绘制，而这在直观上是无法用人类轻松理解的方式表示的。由于我们无法绘制项目向量，我们可以看一下[图
    9-1](#figure9-1)中的 *A⃗* 和 *B⃗* 向量，来理解如何测量向量相似性，然后将我们学到的内容应用到后面的项目向量中。
- en: 'You can see that vectors *A⃗* and *B⃗* are somewhat similar: both are pointing
    generally upward and generally toward the right. We want to find a quantitative
    measurement that signifies exactly how similar the two vectors are. All we need
    to do is measure the angle between the two vectors, as in [Figure 9-2](#figure9-2).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，向量 *A⃗* 和 *B⃗* 有些相似：它们都大致指向上方并朝向右侧。我们想要找到一个量化的度量，准确表示两个向量之间有多相似。我们所需要做的就是测量两个向量之间的角度，如在[图
    9-2](#figure9-2)中所示。
- en: '![](image_fi/502888c09/f09002.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502888c09/f09002.png)'
- en: 'Figure 9-2: An angle between two vectors, represented by the Greek letter theta'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2：两个向量之间的角度，用希腊字母 theta 表示
- en: Every pair of vectors will have an angle between them that we can measure. In
    two dimensions, we can get out a protractor and physically measure the angle between
    two vectors. In [Figure 9-2](#figure9-2), the angle is labeled with the Greek
    letter theta. If the angle theta is small, we conclude that the two vectors are
    similar. If theta is large, we conclude that the two vectors are very different.
    The smallest possible angle between two vectors is 0; a 0-degree angle between
    two vectors means that they’re pointing in exactly the same direction (they overlap).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每一对向量之间都有一个角度，我们可以测量这个角度。在二维空间中，我们可以拿出量角器，实际测量两个向量之间的角度。在[图 9-2](#figure9-2)中，角度用希腊字母
    theta 标注。如果角度 theta 很小，我们可以得出结论，两个向量是相似的。如果 theta 很大，我们可以得出结论，两个向量非常不同。两个向量之间的最小角度是
    0；两个向量之间的 0 度角意味着它们指向完全相同的方向（它们重合）。
- en: 'This isn’t a geometry book, but try to remember just one more thing from your
    math and geometry classes: the *cosine*. The cosine is a function that we can
    measure for every angle. The cosine of a 0-degree angle is 1; that’s the maximum
    value a cosine can be. As an angle gets larger than 0, its cosine decreases. For
    a 90-degree angle (also called a *perpendicular*, or *right*, angle), the cosine
    will be 0.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一本几何学书籍，但试着记住你在数学和几何课上学到的最后一件事：*余弦*。余弦是我们可以测量的每个角度的一个函数。0 度角的余弦是 1；这是余弦能达到的最大值。随着角度大于
    0，余弦值减小。对于 90 度角（也叫做*垂直*角，或*直角*），余弦值为 0。
- en: The cosine is important because we can use it to measure the similarity of two
    vectors. If two vectors are similar, the angle between them will be small, so
    the cosine of the angle between them will be large (1 or close to 1). If two vectors
    are perpendicular, they’re quite different, and the cosine of the angle between
    them will be 0\. Vectors like *A⃗* and *B⃗* in [Figure 9-1](#figure9-1) are not
    completely similar and not completely different, so the cosine of the angle between
    them will be between 0 and 1\. When comparing vectors, we often refer to the *cosine
    similarity* of the two vectors (the cosine of the angle between the vectors).
    Similar vectors will have high cosine similarity, and different vectors will have
    low cosine similarity.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 余弦函数很重要，因为我们可以用它来衡量两个向量的相似性。如果两个向量相似，它们之间的角度会很小，因此它们之间的角度余弦值会很大（接近1）。如果两个向量垂直，它们非常不同，它们之间的角度余弦值将是0。像[图
    9-1](#figure9-1)中的*A⃗*和*B⃗*这样的向量并不完全相似，也不完全不同，因此它们之间的角度余弦值会在0和1之间。在比较向量时，我们通常提到两向量的*余弦相似度*（即两个向量之间的角度余弦值）。相似的向量将具有较高的余弦相似度，而不同的向量将具有较低的余弦相似度。
- en: When vectors have many dimensions, like the five-dimensional vectors in our
    purchase histories, we don’t physically measure the angles. Instead, we can use
    a special formula that enables us to calculate the cosine of the angle between
    any pair of vectors without requiring the physical use of a protractor; see [Figure
    9-3](#figure9-3).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当向量具有许多维度时，比如我们购买历史中的五维向量，我们不会实际测量角度。相反，我们可以使用一个特殊的公式，允许我们在不使用量角器的情况下计算任意一对向量之间的角度余弦值；请参见[图
    9-3](#figure9-3)。
- en: '![](image_fi/502888c09/f09003.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502888c09/f09003.png)'
- en: 'Figure 9-3: A formula for calculating the cosine of the angle between two vectors'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-3：计算两个向量之间角度余弦值的公式
- en: We’ll unpack this formula in the next section.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中详细解释这个公式。
- en: Calculating Cosine Similarity
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算余弦相似度
- en: 'Let’s look more closely at the formula in [Figure 9-3](#figure9-3). The numerator
    is *A* · *B*. In this case the dot between the vectors *A⃗* and *B⃗* is indicating
    a *dot product*, a special way to multiply vectors together. The following function
    calculates the dot product of any two vectors that are the same length:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看[图 9-3](#figure9-3)中的公式。分子是*A* · *B*。在这个公式中，向量*A⃗*和*B⃗*之间的点表示是*点积*，这是一种特殊的向量乘法方式。以下函数计算任何两个相同长度向量的点积：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The denominator of the formula in [Figure 9-3](#figure9-3) shows pipe symbols
    (`||`) surrounding both *A* and *B*. These pipe symbols indicate the respective
    sizes of vectors *A⃗* and *B⃗*, also called their vector *norms*. The following
    function calculates the vector norm of any vector:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-3](#figure9-3)中的公式的分母显示了围绕*A*和*B*的管道符号（`||`）。这些管道符号表示向量*A⃗*和*B⃗*的大小，也称为它们的向量*范数*。以下函数计算任何向量的范数：'
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The cosine of the angle between any two vectors (that is, the cosine similarity
    of the two vectors) is the dot product of the two vectors, divided by the product
    of the norms of the vectors. We can create a Python function that calculates the
    cosine similarity of any two vectors by using the two functions we just defined,
    combined as shown in the formula in [Figure 9-3](#figure9-3):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 两个向量之间的角度余弦值（即两个向量的余弦相似度）是两个向量的点积，除以这两个向量的范数的乘积。我们可以通过使用我们刚刚定义的两个函数，按[图 9-3](#figure9-3)中所示的公式组合，创建一个Python函数来计算任何两个向量的余弦相似度：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The cosine similarity that this function calculates is a common similarity measurement
    that’s used in many data science applications, not just for recommendation systems.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数计算的余弦相似度是一种常见的相似度度量，广泛应用于许多数据科学领域，不仅仅用于推荐系统。
- en: 'Let’s try to calculate some cosine similarity measurements for our item vectors:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试计算一些我们项目向量的余弦相似度：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This snippet yields a simple output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码段会产生一个简单的输出：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can see that `item1` and `item3` have a cosine similarity of `1.0`, meaning
    that the angle between these vectors is 0\. Therefore, they’re identical vectors,
    and they’re as similar as it is possible to be. By contrast, you can check the
    cosine similarity of `item2` and `item5` by running the following snippet:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`item1`和`item3`的余弦相似度为`1.0`，这意味着这两个向量之间的角度为0。因此，它们是完全相同的向量，它们是能够达到的最相似的向量。相比之下，你可以通过运行以下代码段来检查`item2`和`item5`之间的余弦相似度：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'These have a cosine similarity of `0.3333`, meaning that the angle between
    these vectors is relatively large—about 71 degrees, not far from a right angle.
    Therefore, these two items are very different from each other. We can see that
    when we look at their vectors: only one user out of five purchased both items.
    If we follow a similar process to check the cosine similarity of `item3` and `item5`,
    we find that it’s `0.866`, indicating that these vectors are similar but not completely
    identical.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个商品的余弦相似度为`0.3333`，意味着这两个向量之间的角度相对较大——大约71度，接近直角。因此，这两件商品非常不同。我们从它们的向量中可以看到这一点：五个用户中只有一个同时购买了这两件商品。如果我们按照类似的过程检查`item3`和`item5`的余弦相似度，我们会发现它是`0.866`，表示这些向量相似但并非完全相同。
- en: Now that we can measure the similarity of any two items’ histories, we’re ready
    to use this calculation to create a recommendation system.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以衡量任何两件商品的历史相似度，准备好利用这一计算来创建推荐系统了。
- en: Implementing Item-Based Collaborative Filtering
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现基于物品的协同过滤
- en: Let’s think back to our hypothetical salesperson and a hypothetical sales scenario.
    You have an interaction matrix that describes the purchase history of all five
    of your customers and all five of your items. You observe a new, unfamiliar customer
    entering your store (or visiting your website), and all you know about the new
    customer is that they are interested in `item1`. How should you make recommendations
    to them?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下假设的销售人员和假设的销售场景。你有一个互动矩阵，描述了所有五个客户和五个商品的购买历史。你看到一个新的、不熟悉的顾客进入你的商店（或访问你的网站），你所知道的唯一信息是这个新顾客对`item1`感兴趣。你应该如何为他们做出推荐呢？
- en: You can rank every item based on how similar its purchase history is to the
    purchase history of `item1`. Your recommendations will be an ordered list of items,
    ranked from the item whose purchase history is the most similar to `item1` to
    the item whose purchase history is the least similar to `item1`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据每个商品的购买历史与`item1`的购买历史相似度对所有商品进行排序。你的推荐将是一个有序的商品列表，按购买历史与`item1`最相似的商品到最不相似的商品排列。
- en: 'Let’s write Python code for this, using cosine similarity. We can start by
    defining the vectors we’ll need to do our calculations:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一下Python代码来实现这一点，使用余弦相似度。我们可以首先定义需要进行计算的向量：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we can calculate how similar each item is to our selected item and make
    recommendations by finding the other items that are most similar to our selected
    item:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以计算每个商品与我们选择的商品的相似度，并通过找到与我们选择的商品最相似的其他商品来进行推荐：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this snippet, we create a `similarities` variable, which starts as an empty
    list. Then we create a loop that calculates the cosine similarity between our
    item and every other item. After that, we get our final list of recommendations:
    a list of all other items, sorted from most similar to least similar to our item.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们创建了一个`similarities`变量，初始为空列表。然后，我们创建了一个循环，计算我们选择的商品与每个其他商品之间的余弦相似度。之后，我们得到了最终的推荐列表：一个所有其他商品的列表，从最相似到最不相似的商品排序。
- en: 'You can check the recommendations by running `print(recommendations)`, which
    will show you the following list:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行`print(recommendations)`来检查推荐结果，它会显示以下列表：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This list is the output of your recommendation system. This final output is
    similar to the output of our popularity-based recommendation system: just a list
    of items, sorted in order of most relevant to least relevant (the highest-priority
    to the lowest-priority recommendations). The difference is that instead of measuring
    relevance in terms of overall popularity, we are measuring relevance in terms
    of the similarity of purchase histories: the more similar purchase histories are
    rated as more relevant, and therefore a higher priority to recommend to users.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表是你推荐系统的输出。最终输出类似于基于人气的推荐系统的输出：只是一个商品列表，按相关性从高到低排序（从最相关到最不相关的推荐）。不同之处在于，我们不再根据整体人气来衡量相关性，而是根据购买历史的相似度来衡量：购买历史越相似，越被视为更相关，因此在推荐给用户时具有更高的优先级。
- en: 'We can also create a function that combines all of these capabilities together:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一个函数，将所有这些功能整合在一起：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can run `get_item_recommendations(interaction,'item1')` to see the items
    recommended for any user who’s interested in `item1`. You could also substitute
    any other item for `item1` to see recommendations for users interested in other
    items.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行`get_item_recommendations(interaction,'item1')`来查看对任何对`item1`感兴趣的用户推荐的商品。你也可以替换`item1`为其他任何商品，来查看对其他商品感兴趣的用户的推荐。
- en: The recommendation system we have created here is *item-based collaborative
    filtering*. It’s *filtering* because instead of recommending every item to users,
    we filter and show only the most relevant. It’s *collaborative* because we’re
    using information related to all items and all users, so it’s as if the users
    and items are collaborating to help us determine relevance. It’s *item-based*
    because our recommendations are based on the similarity between items’ purchase
    histories, rather than similarity between users or anything else.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建的推荐系统是*基于物品的协同过滤*。它之所以是*过滤*，是因为我们不是向用户推荐每一件商品，而是过滤并仅展示最相关的商品。它之所以是*协同*，是因为我们使用与所有商品和所有用户相关的信息，所以就像用户和商品在协作帮助我们确定相关性一样。它之所以是*基于物品*，是因为我们的推荐是基于商品购买历史之间的相似性，而不是用户之间或其他任何因素的相似性。
- en: Item-based collaborative filtering is relatively simple to implement, and it
    can be used to make “warm” recommendations even if we know only one fact about
    a potential customer (a single item that they’re interested in). You can see that
    it can be implemented with just a few lines of code, and the only input data that’s
    needed is an interaction matrix.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 基于物品的协同过滤相对容易实现，即使我们只知道潜在客户的一个信息（他们感兴趣的单一商品），也可以用它来做出“温暖”的推荐。你可以看到，它只需要几行代码就能实现，而唯一需要的输入数据就是交互矩阵。
- en: Item-based collaborative filtering has a reputation for making *obvious* recommendations.
    Multiple James Bond films are likely to have high overlap in their purchase histories,
    so using item-based collaborative filtering to make recommendations related to
    one James Bond film will likely yield a recommendation to view a different James
    Bond film. But James Bond fans are already familiar with James Bond films and
    don’t need to get a recommendation to watch a film that they’re already familiar
    with. Recommendation systems can be more valuable when they recommend items that
    are less obvious. Next, let’s take a look at a method that has a reputation for
    generating some less obvious recommendations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 基于物品的协同过滤有时会做出*显而易见*的推荐。比如，多个詹姆斯·邦德电影在购买历史上可能有很高的重叠，因此使用基于物品的协同过滤推荐一部詹姆斯·邦德电影时，可能会推荐另一部詹姆斯·邦德电影。但是詹姆斯·邦德的粉丝已经熟悉这些电影，他们不需要被推荐观看他们已经看过的电影。推荐系统在推荐那些不那么显而易见的商品时会更具价值。接下来，让我们看一下一个以生成一些不那么显而易见的推荐而闻名的方法。
- en: User-Based Collaborative Filtering
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于用户的协同过滤
- en: Suppose you want to make recommendations for a customer you’re already familiar
    with. For example, suppose that our fifth customer, `user5`, walks into your store
    (or visits your website). Your interaction matrix already has detailed records
    related to `user5` and everything they’ve purchased before. We can use this detailed
    information to make intelligent, “warm” recommendations for `user5` with *user-based
    collaborative filtering*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想为一个你已经熟悉的客户提供推荐。例如，假设我们的第五个客户`user5`走进你的商店（或访问你的网站）。你的交互矩阵已经包含了与`user5`相关的详细记录以及他们之前购买的所有商品。我们可以利用这些详细信息为`user5`做出智能的、“温暖”的推荐，采用*基于用户的协同过滤*。
- en: This approach is based on the idea that people who are similar may be interested
    in the same items. If we need to make recommendations for a particular customer,
    we find the customers who are most similar to that customer and recommend items
    that those similar customers purchased.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法基于这样一个理念：相似的人可能对相同的商品感兴趣。如果我们需要为一个特定客户提供推荐，我们会找到与该客户最相似的客户，并推荐这些相似客户购买过的商品。
- en: 'Let’s start by looking at our interaction matrix yet again:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次查看一下我们的交互矩阵：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This time, instead of thinking of the *rows* as vectors related to *items*,
    let’s think of the *columns* as vectors related to *customers*. The vector `[1,0,1,1,1]`
    (the last column of the matrix) represents the full purchase history of `user5`.
    If we look at other customer purchase history vectors, we can see that `user2`
    has a purchase history that’s similar to `user5`’s purchase history. We can see
    that `user3` has a purchase history that’s very different from the purchase history
    of `user5`—almost no overlap. Just as we did when we were implementing item-based
    collaborative filtering, we can calculate the similarity of customers based on
    their purchase histories:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，不再把*行*看作与*商品*相关的向量，而是把*列*看作与*顾客*相关的向量。向量`[1,0,1,1,1]`（矩阵的最后一列）代表了`user5`的完整购买历史。如果我们查看其他顾客的购买历史向量，可以看到`user2`的购买历史与`user5`的购买历史相似。我们还可以看到`user3`的购买历史与`user5`的购买历史非常不同——几乎没有重叠。正如我们在实现基于商品的协同过滤时所做的那样，我们可以基于顾客的购买历史来计算顾客之间的相似度：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output of this snippet is `0.866`, indicating that `user2` and `user5`
    have relatively high cosine similarity (remember that the closer to 1 this measurement
    is, the more similar two vectors are). We can change the users whose similarity
    we calculate by making small adjustments to this snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段的输出是`0.866`，这表示`user2`和`user5`的余弦相似度相对较高（记住，越接近1，两个向量就越相似）。我们可以通过对这个片段进行小的调整，来改变我们计算相似度的用户：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we find that `user3` and `user5` have cosine similarity 0.3536, which
    is relatively low, just as expected.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们发现`user3`和`user5`的余弦相似度是0.3536，说明它们的相似度相对较低，正如预期的那样。
- en: 'We can also create a function that calculates the most similar customers to
    a given customer:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一个函数，用来计算与给定顾客最相似的顾客：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This function takes a customer name and an interaction matrix as its inputs.
    It calculates the similarity of the input customer to all other customers specified
    in the interaction matrix. The final output is a ranked list of customers, sorted
    from the most similar customer to the least similar customer.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数以顾客名称和交互矩阵作为输入。它计算输入顾客与交互矩阵中所有其他顾客的相似度。最终输出是一个顾客的排名列表，按与输入顾客的相似度从最相似到最不相似排序。
- en: 'We can use this function in several ways to get recommendations. Here’s one
    way to get recommendations for `user5`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过多种方式使用这个函数来获取推荐。以下是获取`user5`推荐的一种方式：
- en: Calculate how similar every user is to `user5`.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算每个用户与`user5`的相似度。
- en: Rank customers from most similar to least similar to `user5`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将顾客按与`user5`的相似度从高到低进行排序。
- en: Find the most similar customer to `user5`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出与`user5`最相似的顾客。
- en: Recommend everything the most similar customer has purchased that `user5` has
    not purchased.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推荐最相似的顾客所购买的，但`user5`没有购买的所有商品。
- en: 'We can write code that implements this algorithm as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写实现这个算法的代码如下：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this snippet, we have a function that takes an interaction matrix and a user
    name as its inputs. It finds the most similar user to the input user, and it stores
    the purchase history of that user in a variable called `purchase_history`. Next,
    it finds everything that the most similar user purchased (stored in the variable
    `purchased`) and everything that the input user purchased (stored in the variable
    `purchased2`). Then it finds everything that the most similar user purchased that
    was not purchased by the input user. It does this by using the `set()` function.
    The `set()` function creates a collection of the unique elements in a list. So
    when you run `set(purchased) - set(purchased2)`, you’ll get the unique elements
    of `purchased` that are not also elements of `purchased2`. Finally, it returns
    the list of these elements as the final recommendations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们有一个函数，它以交互矩阵和用户名作为输入。该函数找到与输入用户最相似的用户，并将该用户的购买历史存储在名为`purchase_history`的变量中。接下来，它找出最相似的用户购买的所有商品（存储在变量`purchased`中）和输入用户购买的所有商品（存储在变量`purchased2`中）。然后，它找出最相似的用户购买的，但输入用户没有购买的商品。它通过使用`set()`函数来实现这一点。`set()`函数创建一个列表中唯一元素的集合。所以，当你运行`set(purchased)
    - set(purchased2)`时，你会得到`purchased`中那些不属于`purchased2`的唯一元素。最后，它将这些元素的列表作为最终推荐返回。
- en: 'You can run this function simply, by running `get_user_recommendations(interaction,''user2'')`.
    You should see the following output:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以简单地运行此函数，执行`get_user_recommendations(interaction,'user2')`。你应该会看到以下输出：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this case, `item4` is our recommendation because it was purchased by `user5`,
    the user who’s most similar to `user2`, and it hasn’t yet been purchased by `user2`.
    We’ve created a function that performs user-based collaborative filtering!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`item4`是我们的推荐，因为它是由与`user2`最相似的`user5`购买的，而且`user2`还没有购买它。我们已经创建了一个执行基于用户的协同过滤的函数！
- en: You could make many adjustments to this function. For example, you might want
    more recommendations than you get by looking at one similar customer. If so, you
    could look at more similar customers than just one. You could also add item-based
    similarity calculations so that you recommend only items that were purchased by
    similar users and are also similar to the items that have been purchased by the
    focal user.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对这个函数做出许多调整。例如，你可能希望获得比只看一个相似客户更多的推荐。如果是这样，你可以查看比仅一个更相似的客户。你还可以添加基于项目的相似度计算，这样你就只会推荐那些由相似用户购买且也与焦点用户已经购买的项目相似的项目。
- en: Ensuring that you understand the similarities and differences between user-based
    and item-based collaborative filtering is worthwhile. Both rely on cosine similarity
    calculations, and both rely on an interaction matrix as input. In item-based collaborative
    filtering, we calculate the cosine similarity between items and recommend items
    that are similar to an item of interest. In user-based collaborative filtering,
    we calculate the cosine similarity between users and recommend items from the
    purchase histories of similar users. Both can lead to good recommendations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你理解基于用户和基于项目的协同过滤之间的相似性和差异是值得的。两者都依赖于余弦相似度计算，并且都依赖于交互矩阵作为输入。在基于项目的协同过滤中，我们计算项目之间的余弦相似度，并推荐与感兴趣的项目相似的其他项目。在基于用户的协同过滤中，我们计算用户之间的余弦相似度，并推荐来自相似用户购买历史中的项目。两者都能产生不错的推荐。
- en: 'To determine which method is right for your business, you could try both and
    check which one leads to better results: either more revenue, more profit, more
    satisfied customers, more customer engagement, or more of whatever metric you
    want to maximize. The best way to do this type of experimental comparison is with
    an A/B test, which you’ve already learned in Chapter 4.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定哪种方法适合你的业务，你可以同时尝试两种方法，看看哪一种能带来更好的结果：无论是更多的收入、更多的利润、更多的满意客户、更多的客户参与，还是任何你希望最大化的指标。进行这种实验比较的最佳方式是A/B测试，你在第4章中已经学过了。
- en: User-based collaborative filtering has a reputation for giving more surprising
    results than item-based collaborative filtering. However, it also tends to be
    more computationally difficult. Most retailers have more customers than items,
    so user-based collaborative filtering usually requires more calculations than
    item-based collaborative filtering.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 基于用户的协同过滤以比基于项目的协同过滤提供更多惊喜结果而闻名。然而，它也通常计算上更加复杂。大多数零售商的客户数通常比项目数多，因此基于用户的协同过滤通常需要比基于项目的协同过滤更多的计算。
- en: 'So far, we’ve been working with an unrealistically tiny and entirely fabricated
    dataset. Applying the ideas we’ve gone over so far to data that comes from a real
    business would be more beneficial, with real users and their real interaction
    histories. In the next section, we’ll do just that: we’ll go through a case study
    of generating recommendations for real users and the real items that we expect
    will interest them.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用一个不切实际的小型完全虚构的数据集。将我们迄今为止讲解的想法应用于来自真实业务的数据会更有益，真实的用户和他们的真实交互历史。在下一节中，我们将进行这样的操作：我们将通过一个案例研究，生成针对真实用户和他们可能感兴趣的真实项目的推荐。
- en: 'Case Study: Music Recommendations'
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究：音乐推荐
- en: We’ll use data from Last.fm ([https://last.fm](https://last.fm)). This website
    allows people to log in and listen to music. In this case, the “items” in our
    interaction matrix will be musical artists, and a 1 in the interaction matrix
    will indicate that a user has listened to an artist, rather than representing
    a purchase. Despite these minor differences, we can use all the methods we’ve
    discussed in this chapter to make recommendations about music that users should
    listen to next.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自Last.fm的数据（[https://last.fm](https://last.fm)）。这个网站允许人们登录并听音乐。在这个案例中，我们交互矩阵中的“项目”将是音乐艺术家，而交互矩阵中的1表示用户听过某个艺术家的音乐，而不是代表购买。尽管存在这些小的差异，我们仍然可以使用本章中讨论的所有方法来推荐用户应该接下来听的音乐。
- en: 'Let’s read some data related to Last.fm users and look at it:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看一些与Last.fm用户相关的数据并进行分析：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As usual, we import the pandas package, read our *.csv* file, and store the
    data in the `lastfm` variable. When we print out the top few rows of the data,
    we see the following output:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们导入了pandas包，读取我们的*.csv*文件，并将数据存储在`lastfm`变量中。当我们打印出数据的前几行时，看到如下输出：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this data, every row represents a unique (anonymous) user. Every column
    represents a musical artist. The entries in the matrix can be interpreted in the
    same way as the entries in our previous interaction matrix: every entry equal
    to `1` means that a particular user has listened to a particular artist, and every
    entry equal to `0` means that the user has not listened to that artist. In this
    case, we can talk about a user’s or an item’s listening history instead of purchase
    history. Regardless, the entries of this matrix show the history of interactions
    between users and items. We don’t need the first column (the user ID number),
    so we can drop it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些数据中，每一行代表一个独特的（匿名）用户。每一列代表一个音乐艺术家。矩阵中的条目可以像我们之前的交互矩阵中的条目一样进行解释：每个等于`1`的条目表示某个用户听过某个艺术家的音乐，每个等于`0`的条目表示用户没有听过该艺术家的音乐。在这种情况下，我们可以谈论一个用户或一个项目的听歌历史，而不是购买历史。不管怎样，这个矩阵中的条目展示了用户和项目之间的交互历史。我们不需要第一列（用户ID），所以我们可以删除它：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Before we proceed, notice the difference between this interaction matrix and
    the previous one. In our previous interaction matrix, the rows corresponded to
    items, and the columns corresponded to users. This interaction matrix is reversed:
    the rows correspond to users, and the columns correspond to items (songs). The
    functions we wrote are meant to work with interaction matrices that have the former
    shape (rows for items, columns for users). To make sure our interaction matrix
    can work with our functions, we should *transpose* it, or rewrite its rows as
    columns and its columns as rows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，注意这个交互矩阵和之前那个矩阵的区别。在我们之前的交互矩阵中，行对应的是项目，列对应的是用户。这个交互矩阵是反转的：行对应的是用户，列对应的是项目（歌曲）。我们编写的函数是针对具有前一种形状（行是项目，列是用户）的交互矩阵来工作的。为了确保我们的交互矩阵可以与我们的函数兼容，我们应该*转置*它，或者将它的行作为列，列作为行：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This snippet uses our matrix’s `T` attribute to transpose our interaction matrix,
    and it stores the result in the variable `lastfmt`. Let’s check the number of
    rows and columns in this data:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了我们的矩阵的`T`属性来转置我们的交互矩阵，并将结果存储在`lastfmt`变量中。让我们查看一下数据的行数和列数：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output here is `(285,1257)`: the data has 285 rows and 1,257 columns. So,
    we’re looking at information about 1,257 real users and 285 real artists whose
    music these users listened to. This is much more substantial than our previous,
    fabricated data. Let’s get recommendations for these users. It’s as simple as
    calling a function we already created earlier in the chapter:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是`(285,1257)`：数据有285行和1,257列。所以，我们在查看1,257个真实用户和285个真实艺术家的信息，这些用户听过这些艺术家的音乐。相比我们之前的虚构数据，这要更为详实。现在让我们为这些用户生成推荐。只需要调用我们在本章之前已经创建的一个函数：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You’ll see the following output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到如下输出：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For people who are interested in music by ABBA, these artists are recommended
    via item-based collaborative filtering. They’re listed in order of most relevant
    to least relevant. Remember, these artists were selected based on similar purchase
    histories: out of all artists, Madonna’s listening history was the most similar
    to ABBA’s, and Robbie Williams’s listening history was the second most similar,
    and so on.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些对ABBA音乐感兴趣的人，推荐了通过基于项目的协同过滤方法选择的这些艺术家。它们是按相关性从高到低排序的。记住，这些艺术家是基于相似的购买历史选择的：在所有艺术家中，麦当娜的听歌历史与ABBA最相似，而罗比·威廉姆斯的听歌历史是第二相似的，以此类推。
- en: 'This is all it takes; we can call the recommendation function for any artist
    that interests us. Going from fabricated to real data is quite simple. We can
    also call our user recommendation function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所需要做的；我们可以为任何我们感兴趣的艺术家调用推荐函数。从虚构数据到真实数据的过渡非常简单。我们还可以调用我们的用户推荐函数：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output shows us three recommendations for the first user (the user with
    index 0 in the dataset):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了给第一个用户（数据集中索引为0的用户）提供的三个推荐：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'These recommendations were obtained using user-based collaborative filtering.
    Remember what that means: our code found the user whose listening history is the
    most similar to the listening history of the first user. The final recommendations
    are artists that the most similar user listened to but the focal user has not
    yet listened to.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些推荐是通过基于用户的协同过滤获得的。记住这意味着什么：我们的代码找到了一个与第一个用户的听歌历史最相似的用户。最终的推荐是最相似用户听过的，但焦点用户尚未听过的艺术家。
- en: Generating Recommendations with Advanced Systems
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用高级系统生成推荐
- en: Collaborative filtering is the most common way to build recommendation systems,
    but it’s not the only one. Several other techniques allow generation of intelligent
    recommendations. One approach, called *singular value decomposition*, relies on
    matrix algebra to *decompose* the interaction matrix into several smaller matrices.
    These smaller matrices can be multiplied in various ways to predict which products
    will appeal to which customers. Singular-value decomposition is one of several
    methods that use linear algebra to predict customer preferences. Another such
    linear algebra method is called *alternating least squares*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 协同过滤是构建推荐系统最常见的方式，但它不是唯一的。还有几种其他技术可以生成智能推荐。一种方法叫做*奇异值分解*，它依赖于矩阵代数将互动矩阵*分解*为几个较小的矩阵。这些较小的矩阵可以通过多种方式相乘，从而预测哪些产品会吸引哪些顾客。奇异值分解是使用线性代数来预测顾客偏好的几种方法之一。另一种这样的线性代数方法叫做*交替最小二乘法*。
- en: 'The clustering methods we discussed in Chapter 7 can also be used to generate
    recommendation systems. These clustering-based recommendation systems use an approach
    like the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第7章讨论的聚类方法也可以用于生成推荐系统。这些基于聚类的推荐系统采用以下类似的方法：
- en: Generate clusters of users.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成用户集群。
- en: Find the most popular items in each cluster of users.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个用户集群中找到最受欢迎的项目。
- en: Recommend those popular items, but only within each cluster.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推荐那些流行的项目，但仅限于每个集群内部。
- en: 'This method is the same as the popularity-based recommendation system we discussed
    at the beginning of the chapter, with one improvement: we look at popularity within
    clusters of similar customers, instead of global popularity.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与我们在本章开头讨论的基于流行度的推荐系统相同，但有一个改进：我们查看相似顾客群体内的流行度，而不是全局流行度。
- en: Other recommendation systems rely on the analysis of content. For example, to
    make recommendations about songs on a music-streaming service, you might download
    a database of song lyrics. You could use some NLP tools to measure the similarity
    between distinct songs’ lyrics. If a user listened to Song X, you could recommend
    that they listen to the songs whose lyrics have the highest similarity to Song
    X’s lyrics. This is an item-based recommendation system, but instead of using
    purchase histories, it uses item attributes to find relevant recommendations.
    *Attribute-based systems* (also called *content-based recommender systems*) like
    this can work effectively in some situations. Many corporations that implement
    recommendation systems today collect a wide variety of data to use as inputs,
    and a wide variety of prediction methods, including neural networks, to predict
    what each user will like. The problem with a content-based approach is that it
    can be difficult to get attribute data that’s reliable and comparable across items.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 其他推荐系统依赖于内容分析。例如，为了在音乐流媒体服务中推荐歌曲，你可以下载一份歌曲歌词的数据库。你可以使用一些自然语言处理工具来衡量不同歌曲歌词之间的相似性。如果用户听过X歌曲，你可以推荐那些与X歌曲歌词最相似的歌曲。这是一个基于项目的推荐系统，但它使用项目属性而不是购买历史来找到相关的推荐。像这样的*基于属性的系统*（也叫做*内容推荐系统*）在某些情况下可以有效工作。今天实现推荐系统的许多公司收集各种各样的数据作为输入，并使用包括神经网络在内的各种预测方法来预测每个用户喜欢什么。基于内容的方法的问题是，它可能很难获得可靠且在各项目之间具有可比性的属性数据。
- en: Attribute data is not the only kind of data that can be added to recommendation
    systems. Using dates in your recommendation systems could also be valuable. In
    a popularity-based system, dates or timestamps can enable you to replace *all-time
    most popular* lists with *today’s most popular* lists, or lists that show trending
    content across the most recent hour, week, or any other time frame.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 属性数据并不是唯一可以添加到推荐系统中的数据类型。在推荐系统中使用日期也可能非常有价值。在基于流行度的系统中，日期或时间戳可以让你将*所有时间最受欢迎*的列表替换为*今天最受欢迎*的列表，或者展示最近一小时、一周或任何其他时间段的趋势内容。
- en: 'You may also need to build recommendation systems with interaction matrices
    that are not 0/1 matrices. For example, you could have an interaction matrix whose
    entries indicate the number of times a song has been played, rather than a 0/1
    indicator of whether a song has been played. You might also find an interaction
    matrix that contains ratings rather than interactions. The same methods you implemented
    in this chapter can be applied to these alternative types of interaction matrices:
    you can still calculate cosine similarities and make recommendations based on
    the most similar items and users.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还需要构建包含非0/1矩阵的推荐系统。例如，你可以拥有一个交互矩阵，其条目表示某首歌曲播放的次数，而不是用0/1来指示歌曲是否被播放。你还可能会遇到一个包含评分而非交互的矩阵。在本章中实现的相同方法也可以应用于这些替代类型的交互矩阵：你仍然可以计算余弦相似度，并基于最相似的项目和用户进行推荐。
- en: The world of recommendation systems is big. There’s room for creativity and
    new approaches, and you can open your mind while trying to discover new ways to
    improve the field.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐系统的世界很大。这里有空间让你发挥创造力并尝试新的方法，在探索改进这一领域的过程中可以敞开思维。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed recommendation systems. We started with popularity-based
    systems to show how to recommend trending items and bestsellers. We continued
    with collaborative filtering, including how to measure the similarity of items
    and customers and how to use similarity to make item-based and user-based recommendations.
    We presented a case study in which we used our collaborative-filtering code to
    get recommendations related to a music-streaming service. We concluded with some
    advanced considerations, including other approaches that could be used and other
    data that can be leveraged.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了推荐系统。我们从基于流行度的系统开始，展示如何推荐流行项目和畅销书。接着介绍了协同过滤，包括如何衡量项目和顾客的相似性，以及如何利用相似性进行基于项目和用户的推荐。我们展示了一个案例研究，使用我们的协同过滤代码获取与音乐流媒体服务相关的推荐。最后，我们讨论了一些高级考量，包括其他可使用的方法和可以利用的其他数据。
- en: Next, we’ll go over some advanced natural language processing methods for analysis
    of text.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论一些用于文本分析的高级自然语言处理方法。
