<html><head></head><body>
<div id="sbo-rt-content"><h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_111"/><strong><span class="big">8</span><br/>INTENT RECOGNITION</strong></h2>&#13;
<div class="image1"><img src="../Images/comm1.jpg" alt="Image" width="191" height="191"/></div>&#13;
<p class="noindents">A chatbot should be smart enough to understand a user’s needs. For example, a conversational chatbot must recognize a user’s intent to properly sustain a conversation with the user, and a food-ordering chatbot needs to understand a customer’s intent to take an order. Although the task of intent recognition was touched on in previous chapters, this chapter discusses it in more depth.</p>&#13;
<p class="indent">You’ll start by recognizing a user’s intent by extracting the transitive verb and direct object of an utterance. Then you’ll explore how to derive a user’s intent from a sequence of sentences, recognize synonyms for different possible intents, and determine a user’s intent using semantic similarity.</p>&#13;
<h3 class="h3" id="lev104"><span epub:type="pagebreak" id="page_112"/><strong>Extracting the Transitive Verb and Direct Object for Intent Recognition</strong></h3>&#13;
<p class="noindent">You can typically recognize a user’s intent in three steps: parsing the sentence into tokens, connecting the tokens with labeled arcs representing syntactic relations, and navigating the arcs to extract the relevant tokens. In many cases, extracting the sentence’s transitive verb and direct object can identify the user’s intent, as shown by the syntactic dependency parsing in <a href="../Text/ch08.xhtml#ch08fig01">Figure 8-1</a>.</p>&#13;
<div class="image"><a id="ch08fig01"/><img src="../Images/fig8-1.jpg" alt="image" width="581" height="172"/></div>&#13;
<p class="figcap"><em>Figure 8-1: An example of a graphical representation of a sentence’s syntactic structure</em></p>&#13;
<p class="indent">The arc connecting the transitive verb with the direct object indicates that the user’s intent is finding a hotel, or just <span class="literal">findHotel</span>, if you merged the transitive verb and the direct object into a single word. You could use this structure as an <em>intent identifier</em> in a later part of a program, as in the following code fragment:</p>&#13;
<p class="programs">      intent = extract_intent(doc) <br/>&#13;
      if intent == 'orderPizza': <br/>&#13;
        print('We need you to answer some questions to place your order.') <br/>&#13;
        ...<br/>&#13;
      elif intent == 'showPizza': <br/>&#13;
        print('Would you like to look at our menu?')<br/>&#13;
        ...</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>In <a href="../Text/ch11.xhtml#ch11">Chapter 11</a>, you’ll see more detailed examples of how to use intent identifiers in a chatbot app’s code.</em></p>&#13;
</div>&#13;
<p class="indent">But sometimes finding the meaning from the transitive verb/direct object pair isn’t so easy. You might need to explore the transitive verb and direct object’s syntactic relations to find the verb and noun that best describe the intent.</p>&#13;
<p class="indent">In other situations, a user’s intent isn’t expressed explicitly, so you must figure out an implied intent. In this section, you’ll learn strategies for extracting intent using the syntactic dependency structure.</p>&#13;
<h4 class="h4" id="lev105"><span epub:type="pagebreak" id="page_113"/><strong><em>Obtaining the Transitive Verb/Direct Object Pair</em></strong></h4>&#13;
<p class="noindent">Let’s start by extracting the transitive verb/direct object pair from a sentence by checking the dependency label of each token, looking for <span class="literal">dobj</span>. Once we find the direct object, we can easily get the corresponding transitive verb by obtaining the syntactic head of the direct object, as illustrated in the following script:</p>&#13;
<p class="programs">   import spacy<br/>&#13;
   nlp = spacy.load('en')<br/>&#13;
<span class="ent">➊</span> doc = nlp(u'show me the best hotel in berlin')<br/>&#13;
<span class="ent">➋</span> for token in doc:<br/>&#13;
     if token.dep_ == 'dobj':<br/>&#13;
       print(<span class="ent">➌</span>token.head.text + token.text.capitalize())</p>&#13;
<p class="indent">In this script, we apply the pipeline to a sample sentence <span class="ent">➊</span> and then iterate over the tokens, searching for the one whose dependency label is <span class="literal">dobj</span> <span class="ent">➋</span>. When it’s found, we determine the corresponding transitive verb by obtaining the direct object’s head <span class="ent">➌</span>. In this example, we also concatenate the transitive verb and its direct object to express the intent in the form of a single word.</p>&#13;
<p class="indent">The script generates the following string:</p>&#13;
<p class="programs">showHotel</p>&#13;
<p class="indent">Keep in mind that not all sentences containing a transitive verb/direct object pair express intent. For example, “He gave me a book” is just a statement of fact. We could filter out such sentences by checking the verb’s characteristics, picking up only those sentences whose verbs are in the present tense and not third person. Still, it would be uncommon to hear a sentence like that from a customer talking to a chatbot that takes orders for a business.</p>&#13;
<h4 class="h4" id="lev106"><strong><em>Extracting Multiple Intents with token.conjuncts</em></strong></h4>&#13;
<p class="noindent">Sometimes, you might find a sentence that seems to express more than one intent. For example, consider the following sentence:</p>&#13;
<p class="programs">I want a pizza and cola.</p>&#13;
<p class="indent">In this scenario, a user wants to order a pizza and a cola. But in most cases, you can consider these intents part of a single complex intent. Although a user requests items of different types, you’d typically treat this sentence as a single order consisting of several items. In this example, you might recognize the intent as <span class="literal">orderPizza</span>, formed by combining the transitive verb and direct object pair, but extract <span class="literal">pizza</span> and <span class="literal">cola</span> as items for the order being placed.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_114"/><a href="../Text/ch08.xhtml#ch08fig02">Figure 8-2</a> shows the dependency tree for the sample sentence.</p>&#13;
<div class="image"><a id="ch08fig02"/><img src="../Images/fig8-2.jpg" alt="image" width="480" height="211"/></div>&#13;
<p class="figcap"><em>Figure 8-2: The dependency tree of a sentence containing a direct object and its conjunct</em></p>&#13;
<p class="indent">In the diagram, you can see two arrows pointing to the arcs for the direct object “pizza” and the conjunct “cola” associated with it. The <em>conjunct</em> of a noun is another noun that is joined to it by a conjunction, such as “and,” “or,” and so on. To extract the direct object and the conjunct associated with it, we can use the following code:</p>&#13;
<p class="programs">   doc = nlp(u'I want a pizza and cola.')<br/>&#13;
   #extract the direct object and the conjunct associated with it<br/>&#13;
   for token in doc:<br/>&#13;
     if token.dep_ == 'dobj':<br/>&#13;
       dobj = [token.text]<br/>&#13;
       conj = [t.text for t in <span class="ent">➊</span>token.conjuncts]<br/>&#13;
   #compose the list of the extracted elements<br/>&#13;
<span class="ent">➋</span> dobj_conj = dobj + conj <br/>&#13;
   print(dobj_conj)</p>&#13;
<p class="indent">We extract the conjunct associated with the direct object using the <span class="literal">conjuncts</span> property of the Token object used for the direct object <span class="ent">➊</span>. Once we’ve obtained the direct object and its conjuncts, we combine them into a single list <span class="ent">➋</span>.</p>&#13;
<p class="indent">The script output should be as follows:</p>&#13;
<p class="programs">['pizza', 'cola']</p>&#13;
<p class="indent">To compose the intent, we should extract the verb, too. The simplest way to obtain it when we already have the direct object is to obtain the direct object’s syntactic head (you saw an example of this in “<a href="../Text/ch08.xhtml#lev105">Obtaining the Transitive Verb/Direct Object Pair</a>” on <a href="../Text/ch08.xhtml#page_113">page 113</a>):</p>&#13;
<p class="programs">verb = dobj.head</p>&#13;
<p class="indent">Then, using the text property of the verb and the direct object, we can compose the intent.</p>&#13;
<h4 class="h4" id="lev107"><span epub:type="pagebreak" id="page_115"/><strong><em>Try This</em></strong></h4>&#13;
<p class="noindent">In the script provided in on <a href="../Text/ch08.xhtml#page_114">page 114</a>, you accessed the conjunct linked to the direct object through the Token object’s <span class="literal">conjuncts</span> property. In a new script, replace that line with code that extracts the conjunct by finding the arc labeled <span class="literal">conj</span> moving outward from the direct object. You can do this within the same loop in which you obtain the direct object by finding the arc labeled <span class="literal">dobj</span>. Be sure to check that the head of the <span class="literal">conj</span> arc matches the direct object.</p>&#13;
<h4 class="h4" id="lev108"><strong><em>Using Word Lists to Extract the Intent</em></strong></h4>&#13;
<p class="noindent">In some cases, tokens other than the transitive verb and direct object best describe the user’s intent. These tokens are typically related to the transitive verb or direct object. So you’ll need to go a step further and explore the transitive verb and direct object’s syntactic relations to discover the words that best formulate the intent.</p>&#13;
<p class="indent">As an example, consider the following utterance:</p>&#13;
<p class="programs">I want to place an order for a pizza.</p>&#13;
<p class="indent">In this sentence, the words “want” and “pizza” best describe the intent, but neither word is a direct object or transitive verb. However, looking at the utterance’s dependency tree, you’ll see that “want” and “pizza” are related to the transitive verb “place” and the direct object “order,” respectively. <a href="../Text/ch08.xhtml#ch08fig03">Figure 8-3</a> shows the dependency tree discussed here.</p>&#13;
<div class="image"><a id="ch08fig03"/><img src="../Images/fig8-3.jpg" alt="image" width="662" height="153"/></div>&#13;
<p class="figcap"><em>Figure 8-3: The dependency tree of an utterance whose transitive verb and direct object don’t convey the user’s intent</em></p>&#13;
<p class="indent">To extract these words from the utterance, we’ll use a list of predefined words, and then search the user’s utterance for those words.</p>&#13;
<p class="indent">An experienced programmer might call into question the effectiveness of hardcoding such a list, because it can be quite long, especially if used in many different contexts. But if the list is intended for a specific context, say, ordering pizza, it can be surprisingly short, which makes this approach very efficient. The following code implements this approach:</p>&#13;
<p class="programs">   #apply the pipeline to the sample sentence<br/>&#13;
   doc = nlp(u'I want to place an order for a pizza.')<br/>&#13;
   # extract the direct object and its transitive verb<br/>&#13;
   dobj = ''<br/>&#13;
<span epub:type="pagebreak" id="page_116"/>   tverb = ''<br/>&#13;
   for token in doc:<br/>&#13;
  <span class="ent">➊</span> if token.dep_ == 'dobj':<br/>&#13;
       dobj = token<br/>&#13;
       tverb = token.head <br/>&#13;
   # extract the verb for the intent's definition<br/>&#13;
   intentVerb = ''<br/>&#13;
   verbList = ['want', 'like', 'need', 'order']<br/>&#13;
<span class="ent">➋</span> if tverb.text in verbList: <br/>&#13;
     intentVerb = tverb<br/>&#13;
<span class="ent">➌</span> else:<br/>&#13;
     if tverb.head.dep_ == 'ROOT':<br/>&#13;
       intentVerb = tverb.head<br/>&#13;
   # extract the object for the intent's definition<br/>&#13;
   intentObj = ''<br/>&#13;
   objList = ['pizza', 'cola']<br/>&#13;
<span class="ent">➍</span> if dobj.text in objList: <br/>&#13;
     intentObj = dobj<br/>&#13;
   else:<br/>&#13;
     for child in dobj.children:<br/>&#13;
       if child.dep_ == 'prep': <br/>&#13;
        <span class="ent">➎</span> intentObj = list(child.children)[0]<br/>&#13;
           break<br/>&#13;
    <span class="ent">➏</span> elif child.dep_ == 'compound': <br/>&#13;
           intentObj = child<br/>&#13;
           break<br/>&#13;
   # print the intent expressed in the sample sentence <br/>&#13;
   print(intentVerb.text + intentObj.text.capitalize())</p>&#13;
<p class="indent">As always, we start by finding and extracting the direct object and its transitive verb <span class="ent">➊</span>. Once we’ve obtained them, we check whether they can be found in the corresponding lists of predefined words. Here, we use simplified lists, of course: the <span class="literal">verbList</span> list contains the verbs a customer might use to place an order, and the <span class="literal">objList</span> contains direct objects that are possible menu items. We start by checking the transitive verb <span class="ent">➋</span>. If it’s not in the list of allowed verbs <span class="ent">➌</span>, we check the main verb (<span class="literal">ROOT</span>) of the sentence, which is the head of the transitive verb. If the transitive verb is the main verb of the sentence, this implementation will work anyway, because the head of the main verb (<span class="literal">ROOT</span>) refers to itself.</p>&#13;
<p class="indent">Next, we move on to checking the direct object <span class="ent">➍</span>. If it’s not in the list of allowed words, we check its syntactic children. We start by checking the preposition of the direct object. If it exists, we pick up the preposition’s child (it can have only one child) <span class="ent">➎</span>, which is always the object of the preposition.</p>&#13;
<p class="indent">To make this approach applicable to a wider variety of cases, it’s not enough to just check for prepositions in the direct object’s children. For example, this logic wouldn’t work for the following utterance: “I want to place a pizza order,” where there is no preposition child branch. Instead, the direct object has a left child, “pizza,” which spaCy tags as a compound. Therefore, we check for compounds in the direct object’s children <span class="ent">➏</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_117"/>Finally, we print the string representing the intent identifier. We should get the following string:</p>&#13;
<p class="programs">wantPizza</p>&#13;
<p class="indent">Notice that we use <span class="literal">wantPizza</span> as the intent identifier instead of <span class="literal">placeOrder</span> (which we would have gotten if we’d simply used the transitive verb/direct object pair). This approach allows us to reduce the number of intent identifiers used in the application.</p>&#13;
<h3 class="h3" id="lev109"><strong>Finding the Meanings of Words Using Synonyms and Semantic Similarity</strong></h3>&#13;
<p class="noindent">English, like many other natural languages, lets you express the same thoughts and intents in different ways, because it contains <em>synonyms</em>—words or phrases that mean nearly the same thing.</p>&#13;
<p class="indent">As a developer of a chatbot application, you need to account for the fact that your users might use a fairly wide set of phrases for each intent the application is supposed to support. This means that your application must recognize synonymous phrases in user input. In fact, if you’re building your chatbot on a popular bot platform, such as Google’s Dialogflow, you’re required to submit a set of phrases for each possible intent. You then use these utterances behind the scenes to train the bot’s model.</p>&#13;
<p class="indent">There’s more than one approach to recognizing synonyms. One option is to use a set of predefined lists of synonyms. You check a word of interest against those lists, recognizing the word’s meaning based on the list in which it was found. Another option is to recognize synonyms based on semantic similarity, a task described in <a href="../Text/ch05.xhtml#ch05">Chapter 5</a> in detail. I discuss both approaches in the following sections.</p>&#13;
<h4 class="h4" id="lev110"><strong><em>Recognizing Synonyms Using Predefined Lists</em></strong></h4>&#13;
<p class="noindent">You already know that, in most cases, the transitive verb and its direct object best describe the intent of a phrase. A simple way to recognize whether two phrases express the same intent is to make sure the transitive verbs in both phrases are synonymous and their direct objects are synonyms as well.</p>&#13;
<p class="indent">For example, the following three sentences express the same intent, which you might define as <span class="literal">orderPizza</span>:</p>&#13;
<p class="programs">I <span class="codestrong1">want</span> a <span class="codestrong1">dish</span>. I'd like to <span class="codestrong1">order</span> a <span class="codestrong1">pizza</span>. <span class="codestrong1">Give</span> me a <span class="codestrong1">pie</span>.</p>&#13;
<p class="indent">To process these utterances, you use the following steps:</p>&#13;
<ol>&#13;
<li class="noindent">Perform dependency parsing to extract a transitive verb and its direct object from a sentence.</li>&#13;
<li class="noindent">Check with the predefined lists of synonyms to replace the transitive verb and the direct object with words that the application recognizes.</li>&#13;
<li class="noindent">Compose the string that represents the intent.</li>&#13;
</ol>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_118"/>The diagram in <a href="../Text/ch08.xhtml#ch08fig04">Figure 8-4</a> summarizes these steps, illustrating how this might work for, say, “I want a dish.”</p>&#13;
<div class="image"><a id="ch08fig04"/><img src="../Images/fig8-4.jpg" alt="image" width="654" height="629"/></div>&#13;
<p class="figcap"><em>Figure 8-4: Processing intent recognition using lists of synonyms</em></p>&#13;
<p class="indent">After dependency parsing (done implicitly when you apply the pipeline to an utterance), you extract the direct object and the transitive verb, and then check them against the corresponding list of synonyms. If you find a match, you replace the word with the one that tops the list, which the application should recognize.</p>&#13;
<p class="indent">Let’s examine what a Python implementation of this scenario might look like:</p>&#13;
<p class="programs">   #apply the pipeline to the sample sentence<br/>&#13;
   doc = nlp(u'I want a dish.')<br/>&#13;
   #extract the transitive verb and its direct object from the dependency tree<br/>&#13;
<span class="ent">➊</span> for token in doc:<br/>&#13;
     if token.dep_ == 'dobj':<br/>&#13;
       verb = token.head.text <br/>&#13;
       dobj = token.text<br/>&#13;
   #create a list of tuples for possible verb synonyms<br/>&#13;
<span class="ent">➋</span> verbList = [('order','want','give','make'),('show','find')]<br/>&#13;
   #find the tuple containing the transitive verb extracted from the sample<br/>&#13;
<span class="ent">➌</span> verbSyns = [item for item in verbList if verb in item]<br/>&#13;
<span epub:type="pagebreak" id="page_119"/>   #create a list of tuples for possible direct object synonyms<br/>&#13;
<span class="ent">➍</span> dobjList = [('pizza','pie','dish'),('cola','soda')]<br/>&#13;
   #find the tuple containing the direct object extracted from the sample<br/>&#13;
   dobjSyns = [item for item in dobjList if dobj in item]<br/>&#13;
   #replace the transitive verb and the direct object with synonyms supported by<br/>&#13;
   the application<br/>&#13;
   #and compose the string that represents the intent <br/>&#13;
<span class="ent">➎</span> intent = verbSyns[0][0] + dobjSyns[0][0].capitalize()<br/>&#13;
   print(intent)</p>&#13;
<p class="indent">We start by creating a Doc object instance for the sample sentence. Then we iterate over the dependency tree available through the Doc object, extracting the transitive verb and its direct object <span class="ent">➊</span>. Next, we create a list of tuples containing all allowable transitive verbs along with their synonyms <span class="ent">➋</span>. The first element in each tuple contains a transitive verb that the application can recognize, and the other elements in the tuple are its synonyms.</p>&#13;
<p class="indent">Now that we’ve defined the allowable transitive verbs and their synonyms and put them all in a list of tuples, we can loop over the entire list to find a tuple that contains the transitive verb extracted from the sample sentence <span class="ent">➌</span>.</p>&#13;
<p class="indent">Similarly, we create a list of tuples for the recognized direct objects and their synonyms, and then find the tuple containing the direct object extracted from the sample <span class="ent">➍</span>.</p>&#13;
<p class="indent">Finally, we concatenate the first elements of the chosen tuples to compose the intent name <span class="ent">➎</span>. As a result, the print command should output the following string:</p>&#13;
<p class="programs">orderPizza</p>&#13;
<p class="indent">Keep in mind that the set of synonyms to choose for a given verb depends largely on the type of application we’re creating. For example, in the context of a bot application that takes pizza orders, the verbs “make” and “give” can be considered synonymous. The reason is that users might interchangeably use the phrases “Make me a pizza” and “Give me a pizza” when ordering a pizza.</p>&#13;
<h4 class="h4" id="lev111"><strong><em>Try This</em></strong></h4>&#13;
<p class="noindent">Use the sample code provided on <a href="../Text/ch08.xhtml#page_118">page 118</a> as the basis for creating a new script. Make the script retain the original functionality but generate “unrecognized” as the intent name when the transitive verb, its direct object, or both can’t be found in the respective lists. To test your code, experiment with the sample sentence, changing it so the new functionality can be seen in action. For example, you might use the following sentence:</p>&#13;
<p class="programs">I want an apple.</p>&#13;
<p class="indent">Test it with a sentence containing a verb that isn’t included in the list.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_120"/>Also, you might try to handle the conjunction problem discussed in the previous sections using synonym lists.</p>&#13;
<h4 class="h4" id="lev112"><strong><em>Recognizing Implied Intents Using Semantic Similarity</em></strong></h4>&#13;
<p class="noindent">Real-world implementations will likely include more complex logic than you’ve seen in the examples provided in this chapter so far. Even using a large set of predefined lists of synonyms won’t always work. The reason is that users express their intentions in many different ways, and they don’t always do so explicitly.</p>&#13;
<p class="indent">Recognizing an implied intent depends heavily on the context. For example, if your bot is designed for a specific type of task, say, ordering food, it should recognize phrases that imply a request, such as “I feel like eating a pie.”, as the intention to place a pizza order.</p>&#13;
<p class="indent">One widely known technique to make the user express their intent more clearly is asking clarifying questions. To determine what question to ask, you can calculate the semantic similarity of the previous user utterance.</p>&#13;
<p class="indent"><a href="../Text/ch08.xhtml#ch08fig05">Figure 8-5</a> illustrates how to implement this task.</p>&#13;
<div class="image"><a id="ch08fig05"/><img src="../Images/fig8-5.jpg" alt="image" width="661" height="512"/></div>&#13;
<p class="figcap"><em>Figure 8-5: Recognizing an implied intent by calculating semantic similarity and asking clarifying questions</em></p>&#13;
<p class="indent">You start by analyzing the dependency tree of the input utterance to extract the direct object and its transitive verb. If, for example, the direct object can’t be found in the predefined list of synonyms, as discussed in <span epub:type="pagebreak" id="page_121"/>“<a href="../Text/ch08.xhtml#lev110">Recognizing Synonyms Using Predefined Lists</a>” on <a href="../Text/ch08.xhtml#page_117">page 117</a>, you might try to determine how similar the direct object is to the words included in the list. Based on the results of calculating semantic similarity, you can then generate a clarifying user question.</p>&#13;
<p class="indent">Let’s implement this technique in code, which I’ll break up into sections. As usual, we start with applying the text-processing pipeline to the sample sentence:</p>&#13;
<p class="programs">doc = nlp(u'I feel like eating a pie.')</p>&#13;
<p class="indent">Then we extract the direct object token:</p>&#13;
<p class="programs">for token in doc:<br/>&#13;
  if token.dep_ == 'dobj':<br/>&#13;
    dobj = token</p>&#13;
<p class="indent">We create a token for the word “food.” We’ll calculate the semantic similarity between this token and the direct object token:</p>&#13;
<p class="programs">tokens = nlp(u'food')</p>&#13;
<p class="indent">If the level of similarity is greater than a predefined threshold, the application guesses that the user is most likely interested in placing an order. Then it asks a clarifying question to confirm this:</p>&#13;
<p class="programs">if dobj.similarity(tokens[0]) &gt; 0.6:<br/>&#13;
  question = 'Would you like to look at our menu?'</p>&#13;
<p class="indent">Recall from <a href="../Text/ch05.xhtml#ch05">Chapter 5</a> that spaCy uses word vectors to calculate the semantic similarity of tokens. The closer two vectors are in the vector space, the higher the level of similarity is between them. In this example, we use 0.6 as the minimum degree of similarity required to assume the direct object resembles a food product.</p>&#13;
<h4 class="h4" id="lev113"><strong><em>Try This</em></strong></h4>&#13;
<p class="noindent">Of course, you won’t know in advance which phrases the user will use and how easy it will be to recognize the user’s intent. Neither will your application. That’s why real-world applications typically combine several approaches to recognize intent. Combine the approach based on recognizing synonyms with the approach based on handling implied intents, discussed in the previous sections, so you can handle more possible situations. Start by trying to extract the intent from an utterance using the synonyms-based approach. Then, if that fails, try the approach based on using semantic similarity. If both approaches fail, you might label the utterance as expressing an unrecognized intent.</p>&#13;
<h3 class="h3" id="lev114"><span epub:type="pagebreak" id="page_122"/><strong>Extracting Intent from a Sequence of Sentences</strong></h3>&#13;
<p class="noindent">In a discourse, the words reflecting a user’s intent might appear across different sentences, as in the following example:</p>&#13;
<p class="programs">I have finished my pizza. I want another one.</p>&#13;
<p class="indent">Your bot should be ready to handle this scenario by extracting a user’s intent from an entire discourse. In this section, I’ll walk you through a technique for doing this.</p>&#13;
<h4 class="h4" id="lev115"><strong><em>Walking the Dependency Structures of a Discourse</em></strong></h4>&#13;
<p class="noindent">Let’s start by looking at the dependency parsing for the discourse, which will disclose the transitive verb/direct object pairs in each sentence, as shown in <a href="../Text/ch08.xhtml#ch08fig06">Figure 8-6</a>.</p>&#13;
<div class="image"><a id="ch08fig06"/><img src="../Images/fig8-6.jpg" alt="image" width="516" height="180"/></div>&#13;
<p class="figcap"><em>Figure 8-6: A visual representation of the dependency parsing of the entire discourse</em></p>&#13;
<p class="indent">The pale arrow in the diagram represents the dependency of interest. In other words, you want to replace the substitute “one” with the noun “pizza” it stands for. But the dependency parser in spaCy doesn’t show this link because it can’t connect tokens from different sentences. So the task of determining these dependencies is left to you.</p>&#13;
<h4 class="h4" id="lev116"><strong><em>Replacing Proforms with Their Antecedents</em></strong></h4>&#13;
<p class="noindent">An <em>antecedent</em> is an expression (such as a word or clause) that gives its meaning to a <em>proform</em> (such as a pronoun or pro-verb). In this kind of intent extraction, you’ll have to determine the antecedents and replace the corresponding proforms with them. You can do so using the following steps:</p>&#13;
<ol>&#13;
<li class="noindent">Parse the dependencies of the entire discourse.</li>&#13;
<li class="noindent">Dissect the discourse into sentences.</li>&#13;
<li class="noindent">Find the antecedent for the pronoun that is the direct object of the transitive verb to be used in the intent definition.</li>&#13;
</ol>&#13;
<p class="indent"><a href="../Text/ch08.xhtml#ch08fig07">Figure 8-7</a> shows these steps diagrammatically.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_123"/><a id="ch08fig07"/><img src="../Images/fig8-7.jpg" alt="image" width="656" height="596"/></div>&#13;
<p class="figcap"><em>Figure 8-7: A graphical depiction of extracting intent from a sequence of sentences</em></p>&#13;
<p class="indent">In spaCy, we can implement the first two steps with a couple lines of code:</p>&#13;
<p class="programs">doc = nlp(u'I have finished my pizza. I want another one.')</p>&#13;
<p class="indent">We convert the object that the <span class="literal">doc.sents</span> property returns into a list so we can refer to each sentence in the text by its index. (We could also directly iterate over a sequence of sentences contained in <span class="literal">doc.sents</span> using a <span class="literal">for</span> loop.)</p>&#13;
<p class="indent">Next, we define two lists containing the allowable transitive verbs and allowable direct objects, respectively:</p>&#13;
<p class="programs">verbList = [('order','want','give','make'),('show','find')]<br/>&#13;
dobjList = [('pizza','pie','pizzaz'),('cola','soda')]</p>&#13;
<p class="indent">These lists contain tuples of synonyms (refer to “<a href="../Text/ch08.xhtml#lev110">Recognizing Synonyms Using Predefined Lists</a>” on <a href="../Text/ch08.xhtml#page_117">page 117</a> for details).</p>&#13;
<p class="indent">We also need to define a list for allowable substitutes. To do so, we must determine what proforms the direct object could be. Let’s first figure out <span epub:type="pagebreak" id="page_124"/>what other phrases we could use in place of the last sentence, and then highlight the direct object in each phrase. Possible alternatives include the following:</p>&#13;
<p class="programs">I want another <span class="codestrong1">one</span>. I want <span class="codestrong1">it</span> again. I want the <span class="codestrong1">same</span>. I want <span class="codestrong1">more</span>.</p>&#13;
<p class="indent">So, we can define the substitute list as follows:</p>&#13;
<p class="programs">substitutes = ('one','it','same','more')</p>&#13;
<p class="indent">Unlike the transitive verb and direct object lists, the substitute list has a simple structure, because we don’t need to group substitutes. The same substitute could refer to any of the direct objects.</p>&#13;
<p class="indent">In addition to the lists, we might want to define a dictionary to hold the intent definition parts as they’re being extracted:</p>&#13;
<p class="programs">intent = {'verb': '', 'dobj': ''}</p>&#13;
<p class="indent">Now we’re ready to start the intent recognition process:</p>&#13;
<p class="programs">for sent in doc.sents:<br/>&#13;
  for token in sent:<br/>&#13;
    if token.dep_ == 'dobj':<br/>&#13;
      verbSyns = [item for item in verbList if token.head.text in item]<br/>&#13;
   <span class="ent">➊</span> dobjSyns = [item for item in dobjList if token.text in item]<br/>&#13;
      substitute =  [item for item in substitutes if token.text in item]<br/>&#13;
      if <span class="ent">➋</span>(dobjSyns != [] or substitute != []) and <span class="ent">➌</span>verbSyns != []:<br/>&#13;
          intent['verb'] = verbSyns[0][0]<br/>&#13;
   <span class="ent">➍</span> if dobjSyns != []:<br/>&#13;
          intent['dobj'] = dobjSyns[0][0]</p>&#13;
<p class="indent">The outer loop iterates over the sequence of sentences held in the Doc object. The inner loop, in turn, iterates over the tokens found in a sentence. We check each token to see whether it’s a direct object. If it is, we determine whether the direct object is part of either the direct object synonyms list or the substitutes list <span class="ent">➊</span>. We also check whether the corresponding transitive verb is in the transitive verb synonyms list.</p>&#13;
<p class="indent">We extract the direct object only if it’s in either the direct object synonyms list or the substitutes list <span class="ent">➋</span>. For example, we wouldn’t be interested in extracting the transitive verb from the following phrase (unless we sell apples, of course):</p>&#13;
<p class="programs">I want an apple.</p>&#13;
<p class="indent">Nor are we interested in a transitive verb if it’s not in the allowable list <span class="ent">➌</span>, even if its direct object satisfies this condition, as in the following phrase:</p>&#13;
<p class="programs">I like it.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_125"/>That’s why, before picking up the transitive verb, we check not only whether the direct object is in either the direct object synonyms list or the substitutes list, but also whether the transitive verb is in the transitive verb synonyms list.</p>&#13;
<p class="indent">Finally, to pick up the direct object that defines the intent, we make sure we can find it in the direct object synonyms list <span class="ent">➍</span>. Now we can compose the intent definition:</p>&#13;
<p class="programs">intentStr = intent['verb'] + intent['dobj'].capitalize()</p>&#13;
<p class="indent">Optionally, we might want to print it to make sure everything works as expected:</p>&#13;
<p class="programs">print(intentStr)</p>&#13;
<p class="indent">We should get the following output:</p>&#13;
<p class="programs">orderPizza</p>&#13;
<p class="indent">This result indicates that the user intends to order a pizza.</p>&#13;
<h4 class="h4" id="lev117"><strong><em>Try This</em></strong></h4>&#13;
<p class="noindent">In some discourses, several sentences might separate an antecedent from its proform. For example, consider the following sequence of sentences:</p>&#13;
<p class="programs">I have finished my pizza. It was delicious. I want another one.</p>&#13;
<p class="indent">Edit the script provided on <a href="../Text/ch08.xhtml#page_124">page 124</a> so it can handle this or a similar sequence of sentences.</p>&#13;
<h3 class="h3" id="lev118"><strong>Summary</strong></h3>&#13;
<p class="noindent">Intent recognition is a complex task that might require you to combine several approaches. In this chapter, you learned how to extract the most important parts of an utterance’s dependency tree for intent recognition. Then you analyzed them using predefined lists, semantic similarity, or both approaches. You also extracted the intent from a sequence of sentences by replacing proforms with their antecedents.<span epub:type="pagebreak" id="page_126"/></p>&#13;
</div>&#13;
</body></html>