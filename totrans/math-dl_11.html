<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_271"/><strong><span class="big">11</span><br/>GRADIENT DESCENT</strong></h2>&#13;
<div class="imagec"><img src="Images/common.jpg" alt="image" width="189" height="189"/></div>&#13;
<p class="noindents">In this final chapter, we’ll slow down a bit and consider gradient descent afresh. We’ll begin by reviewing the idea of gradient descent using illustrations, discussing what it is and how it works. Next, we’ll explore the meaning of <em>stochastic</em> in <em>stochastic gradient descent</em>. Gradient descent is a simple algorithm that invites tweaking, so after we explore stochastic gradient descent, we’ll consider a useful and commonly used tweak: momentum. We’ll conclude the chapter by discussing more advanced, adaptive gradient descent algorithms, specifically RMSprop, Adagrad, and Adam.</p>&#13;
<p class="indent">This is a math book, but gradient descent is very much applied math, so we’ll learn by experimentation. The equations are straightforward, and the math we saw in previous chapters is relevant as background. Therefore, consider this chapter an opportunity to apply what we’ve learned so far.</p>&#13;
<h3 class="h3" id="ch11lev1_1"><span epub:type="pagebreak" id="page_272"/>The Basic Idea</h3>&#13;
<p class="noindent">We’ve encountered gradient descent several times already. We know the form of the basic gradient descent update equations from <a href="ch10.xhtml#ch10equ14">Equation 10.14</a>:</p>&#13;
<div class="imagec" id="ch11equ01"><img src="Images/11equ01.jpg" alt="Image" width="419" height="83"/></div>&#13;
<p class="noindent">Here, <strong>Δ<em>W</em></strong> and <strong>Δ<em>b</em></strong> are errors based on the partial derivatives of the weights and biases, respectively; η (eta) is a step size or learning rate, a value we use to adjust how we move.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11equ01">Equation 11.1</a> isn’t specific to machine learning. We can use the same form to implement gradient descent on arbitrary functions. Let’s discuss gradient descent using 1D and 2D examples to lay a foundation for how it operates. We’ll use an unmodified form of gradient descent known as <em>vanilla gradient descent</em>.</p>&#13;
<h4 class="h4" id="ch11lev2_1">Gradient Descent in One Dimension</h4>&#13;
<p class="noindent">Let’s begin with a scalar function of <em>x</em>:</p>&#13;
<div class="imagec" id="ch11equ02"><img src="Images/11equ02.jpg" alt="Image" width="440" height="24"/></div>&#13;
<p class="noindent"><a href="ch11.xhtml#ch11equ02">Equation 11.2</a> is a parabola facing upward. Therefore, it has a minimum. Let’s find the minimum analytically by setting the derivative to zero and solving for <em>x</em>:</p>&#13;
<div class="imagec"><img src="Images/272equ01.jpg" alt="Image" width="315" height="163"/></div>&#13;
<p class="indent">The minimum of the parabola is at <em>x</em> = 1. Now, let’s instead use gradient descent to find the minimum of <a href="ch11.xhtml#ch11equ02">Equation 11.2</a>. How should we begin?</p>&#13;
<p class="indent">First, we need to write the proper update equation, the form of <a href="ch11.xhtml#ch11equ01">Equation 11.1</a> that applies in this case. We need the gradient, which for a 1D function is simply the derivative, <em>f</em>′(<em>x</em>) = 12<em>x</em> − 12. With the derivative, gradient descent becomes</p>&#13;
<div class="imagec" id="ch11equ03"><img src="Images/11equ03.jpg" alt="Image" width="498" height="22"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_273"/>Notice that we subtract η (12<em>x</em> − 12). This is why the algorithm is called gradient <em>descent</em>. Recall that the gradient points in the direction of maximum change in the function’s value. We’re interested in minimizing the function, not maximizing it, so we move in the direction opposite to the gradient toward smaller function values; therefore, we subtract.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11equ03">Equation 11.3</a> is one gradient descent step. It moves from an initial position, <em>x</em>, to a new position based on the value of the slope at the current position. Again η, the learning rate, governs how far we move.</p>&#13;
<p class="indent">Now that we have the equation, let’s implement gradient descent. We’ll plot <a href="ch11.xhtml#ch11equ02">Equation 11.2</a>, pick a starting position, say <em>x</em> = −0.9, and iterate <a href="ch11.xhtml#ch11equ03">Equation 11.3</a>, plotting the function value at each new position of <em>x</em>. If we do this, we should see a series of points on the function that move ever closer to the minimum position at <em>x</em> = 1. Let’s write some code.</p>&#13;
<p class="indent">First, we implement <a href="ch11.xhtml#ch11equ02">Equation 11.2</a> and its derivative:</p>&#13;
<pre>&#13;
def f(x):<br/>&#13;
    return 6*x**2 - 12*x + 3<br/>&#13;
def d(x):<br/>&#13;
    return 12*x - 12</pre>&#13;
<p class="noindent">Next, we plot the function, and then we iterate <a href="ch11.xhtml#ch11equ03">Equation 11.3</a>, plotting the new pair, (<em>x</em>, <em>f</em>(<em>x</em>)), each time:</p>&#13;
<pre>   import numpy as np<br/>&#13;
   import matplotlib.pylab as plt<br/>&#13;
<br/>&#13;
<span class="ent">❶</span> x = np.linspace(-1,3,1000)<br/>&#13;
   plt.plot(x,f(x))<br/>&#13;
<br/>&#13;
<span class="ent">❷</span> x = -0.9<br/>&#13;
   eta = 0.03<br/>&#13;
<span class="ent">❸</span> for i in range(15):<br/>&#13;
      plt.plot(x, f(x), marker='o', color='r')<br/>&#13;
    <span class="ent">❹</span> x = x - eta * d(x)</pre>&#13;
<p class="indent">Let’s walk through the code. After importing NumPy and Matplotlib, we plot <a href="ch11.xhtml#ch11equ02">Equation 11.2</a> <span class="ent">❶</span>. Next, we set our initial <em>x</em> position <span class="ent">❷</span> and take 15 gradient descent steps <span class="ent">❸</span>. We plot before stepping, so we see the initial <em>x</em> but do not plot the last step, which is fine in this case.</p>&#13;
<p class="indent">The final line <span class="ent">❹</span> is key. It implements <a href="ch11.xhtml#ch11equ03">Equation 11.3</a>. We update the current <em>x</em> position by multiplying the derivative’s value at <em>x</em> by η = 0.03 as the step size. The code above is in the file <em>gd_1d.py</em>. If we run it, we get <a href="ch11.xhtml#ch11fig01">Figure 11-1</a>.</p>&#13;
<span epub:type="pagebreak" id="page_274"/>&#13;
<div class="image" id="ch11fig01"><img src="Images/11fig01.jpg" alt="image" width="680" height="510"/></div>&#13;
<p class="figcap"><em>Figure 11-1: Gradient descent in one dimension with small steps (η = 0.03)</em></p>&#13;
<p class="indent">Our initial position, which we can think of as an initial guess at the location of the minimum, is <em>x</em> = −0.9. Clearly, this isn’t the minimum. As we take gradient descent steps, we move successively closer to the minimum, as the sequence of circles moving toward it shows.</p>&#13;
<p class="indent">Notice two things here. First, we do get closer and closer to the minimum. After 14 steps, we are, for all intents and purposes, at the minimum: <em>x</em> = 0.997648. Second, each gradient descent step leads to smaller and smaller changes in <em>x</em>. The learning rate is constant at <em>η</em> = 0.03, so the source of the smaller updates to <em>x</em> must be smaller and smaller values of the derivative at each <em>x</em> position. This makes sense if we think about it. As we approach the minimum position, the derivative gets smaller and smaller, until it reaches zero at the minimum, so the update using the derivative gets successively smaller as well.</p>&#13;
<p class="indent">We selected the step size for <a href="ch11.xhtml#ch11fig01">Figure 11-1</a> to move smoothly toward the minimum of the parabola. What if we change the step size? Further along in <em>gd_1d.py</em>, the code repeats the steps above, starting at <em>x</em> = 0.75 and setting <em>η</em> = 0.15 to take steps that are five times larger than those plotted in <a href="ch11.xhtml#ch11fig01">Figure 11-1</a>. The result is <a href="ch11.xhtml#ch11fig02">Figure 11-2</a>.</p>&#13;
<span epub:type="pagebreak" id="page_275"/>&#13;
<div class="image" id="ch11fig02"><img src="Images/11fig02.jpg" alt="image" width="694" height="521"/></div>&#13;
<p class="figcap"><em>Figure 11-2: Gradient descent in one dimension with large steps (η = 0.15)</em></p>&#13;
<p class="indent">In this case, the steps overshoot the minimum. The new <em>x</em> positions oscillate, bouncing back and forth over the true minimum position. The dashed lines connect successive <em>x</em> positions. The overall search still approaches the minimum but takes longer to reach it, as the large step size makes each update to <em>x</em> tend to move past the minimum.</p>&#13;
<p class="indent">Small gradient descent steps move short distances along the function, whereas large steps move large distances. If the learning rate is too small, many gradient descent steps are necessary. If the learning rate is too large, the search overshoots and oscillates around the minimum position. The proper learning rate is not immediately obvious, so intuition and experience come into play when selecting it. Additionally, these examples fixed <em>η</em>. There’s no reason why <em>η</em> has to be a constant. In many deep learning applications, the learning rate is not constant but evolves as training progresses, effectively making <em>η</em> a function of the number of gradient descent steps taken.</p>&#13;
<h4 class="h4" id="ch11lev2_2"><span epub:type="pagebreak" id="page_276"/>Gradient Descent in Two Dimensions</h4>&#13;
<p class="noindent">Gradient descent in one dimension is straightforward enough. Let’s move to two dimensions to increase our intuition about the algorithm. The code referenced below is in the file <em>gd_2d.py</em>. We’ll first consider the case where the function has a single minimum, then look at cases with multiple minima.</p>&#13;
<h5 class="h5" id="ch11lev3_1">Gradient Descent with a Single Minimum</h5>&#13;
<p class="noindent">To work in two dimensions, we need a scalar function of a vector, <em>f</em>(<em><strong>x</strong></em>) = <em>f</em>(<em>x</em>, <em>y</em>), where, to make it easier to follow, we separate the vector into its components, <em><strong>x</strong></em> = (<em>x</em>, <em>y</em>).</p>&#13;
<p class="indent">The first function we’ll work with is</p>&#13;
<p class="center"><em>f</em>(<em>x</em>, <em>y</em>) = 6<em>x</em><sup>2</sup> + 9<em>y</em><sup>2</sup> − 12<em>x</em> − 14<em>y</em> + 3</p>&#13;
<p class="indent">To implement gradient descent, we need the partial derivatives as well:</p>&#13;
<div class="imagec"><img src="Images/276equ01.jpg" alt="Image" width="127" height="133"/></div>&#13;
<p class="indent">Our update equations become</p>&#13;
<div class="imagec"><img src="Images/276equ02.jpg" alt="Image" width="287" height="132"/></div>&#13;
<p class="indent">In code, we define the function and partial derivatives:</p>&#13;
<pre>&#13;
def f(x,y):<br/>&#13;
    return 6*x**2 + 9*y**2 - 12*x - 14*y + 3<br/>&#13;
def dx(x):<br/>&#13;
    return 12*x - 12<br/>&#13;
def dy(y):<br/>&#13;
    return 18*y - 14</pre>&#13;
<p class="indent">Since the partial derivatives are independent of the other variable, we get away with passing only <em>x</em> or <em>y</em>. We’ll see an example later in this section where that’s not the case.</p>&#13;
<p class="indent">Gradient descent follows the same pattern as before: select an initial position, this time a vector, iterate for some number of steps, and plot the path. The function is 2D, so we first plot it using contours, as shown next.</p>&#13;
<pre><span epub:type="pagebreak" id="page_277"/>N = 100<br/>&#13;
x,y = np.meshgrid(np.linspace(-1,3,N), np.linspace(-1,3,N))<br/>&#13;
z = f(x,y)<br/>&#13;
plt.contourf(x,y,z,10, cmap="Greys")<br/>&#13;
plt.contour(x,y,z,10, colors='k', linewidths=1)<br/>&#13;
plt.plot([0,0],[-1,3],color='k',linewidth=1)<br/>&#13;
plt.plot([-1,3],[0,0],color='k',linewidth=1)<br/>&#13;
plt.plot(1,0.7777778,color='k',marker='+')</pre>&#13;
<p class="indent">This code requires some explanation. To plot contours, we need a representation of the function over a grid of (<em>x</em>, <em>y</em>) pairs. To generate the grid, we use NumPy, specifically <code>np.meshgrid</code>. The arguments to <code>np.meshgrid</code> are the <em>x</em> and <em>y</em> points, here provided by <code>np.linspace</code>, which itself generates a vector from −1 to 3 of <em>N</em> = 100 evenly spaced values. The <code>np.meshgrid</code> function returns two 100 × 100 matrices. The first contains the <em>x</em> values over the given range, and the second contains the <em>y</em> values. All possible (<em>x</em>, <em>y</em>) pairs are represented in the return value to form a grid of points covering the region of −1 . . . 3 in both <em>x</em> and <em>y</em>. Passing these points to the function then returns <code>z</code>, a 100 × 100 matrix of the function value at each (<em>x</em>, <em>y</em>) pair.</p>&#13;
<p class="indent">We could plot the function in 3D, but that’s difficult to see and unnecessary in this case. Instead, we’ll use the function values in <em>x</em>, <em>y</em>, and <em>z</em> to generate contour plots. Contour plots show 3D information as a series of lines of equal <em>z</em> value. Think of lines around a hill on a topographic map, where each line is at the same altitude. As the hill gets higher, the lines enclose successively smaller regions.</p>&#13;
<p class="indent">Contour plots come in two varieties, as either lines of equal function value or shading over ranges of the function. We’ll plot both varieties using a grayscale map. That’s the net result of calling Matplotlib’s <code>plt.contourf</code> and <code>plt.contour</code> functions. The remaining <code>plt.plot</code> calls show the axes and mark the function minimum with a plus sign. The contour plots are such that lighter shades imply lower function values.</p>&#13;
<p class="indent">We’re now ready to plot the sequence of gradient descent steps. We’ll plot each position in the sequence and connect them with a dashed line to make the path clear (see <a href="ch11.xhtml#ch11ex01">Listing 11-1</a>). In code, that’s</p>&#13;
<pre>x = xold = -0.5<br/>&#13;
y = yold = 2.9<br/>&#13;
for i in range(12):<br/>&#13;
    plt.plot([xold,x],[yold,y], marker='o', linestyle='dotted', color='k')<br/>&#13;
    xold = x<br/>&#13;
    yold = y<br/>&#13;
    x = x - 0.02 * dx(x)<br/>&#13;
    y = y - 0.02 * dy(y)</pre>&#13;
<p class="ex-caption" id="ch11ex01"><em>Listing 11-1: Gradient descent in two dimensions</em></p>&#13;
<p class="indent">We begin at (<em>x</em>, <em>y</em>) = (−0.5, 2.9) and take 12 gradient descent steps. To connect the last position to the new position using a dashed line, we track <span epub:type="pagebreak" id="page_278"/>both the current position in <em>x</em> and <em>y</em> and the previous position, (<em>x</em><sub>old</sub>, <em>y</em><sub>old</sub>). The gradient descent step updates both <em>x</em> and <em>y</em> using <em>η</em> = 0.02 and calling the respective partial derivative functions, <code>dx</code> and <code>dy</code>.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11fig03">Figure 11-3</a> shows the gradient descent path that <a href="ch11.xhtml#ch11ex01">Listing 11-1</a> follows (circles) along with two other paths starting at (1.5, −0.8) (squares) and (2.7, 2.3) (triangles).</p>&#13;
<div class="image" id="ch11fig03"><img src="Images/11fig03.jpg" alt="image" width="694" height="516"/></div>&#13;
<p class="figcap"><em>Figure 11-3: Gradient descent in two dimensions for small steps</em></p>&#13;
<p class="indent">All three gradient descent paths converge toward the minimum of the function. This isn’t surprising, as the function has only one minimum. If the function has a single minimum, then gradient descent will eventually find it. If the step size is too small, many steps might be necessary, but they will ultimately converge on the minimum. If the step size is too large, gradient descent may oscillate around the minimum but continually step over it.</p>&#13;
<p class="indent">Let’s change our function a bit to stretch it in the <em>x</em> direction relative to the <em>y</em> direction:</p>&#13;
<p class="center"><em>f</em>(<em>x</em>, <em>y</em>) = 6<em>x</em><sup>2</sup> + 40<em>y</em><sup>2</sup> − 12<em>x</em> − 30<em>y</em> + 3</p>&#13;
<p class="noindent">This function has partials ∂<em>f</em>/∂<em>x</em> = 12<em>x</em> − 12 and ∂<em>f</em>/∂<em>y</em> = 80<em>y</em> − 30.</p>&#13;
<p class="indent">Additionally, let’s pick two starting locations, (−0.5, 2.3) and (2.3, 2.3), and generate a sequence of gradient descent steps with <em>η</em> = 0.02 and <em>η</em> = 0.01, respectively. <a href="ch11.xhtml#ch11fig04">Figure 11-4</a> shows the resulting paths.</p>&#13;
<span epub:type="pagebreak" id="page_279"/>&#13;
<div class="image" id="ch11fig04"><img src="Images/11fig04.jpg" alt="image" width="694" height="522"/></div>&#13;
<p class="figcap"><em>Figure 11-4: Gradient descent in 2D with larger steps and a slightly different function</em></p>&#13;
<p class="indent">Consider the <em>η</em> = 0.02 (circle) path first. The new function is like a canyon, narrow in <em>y</em> but long in <em>x</em>. The larger step size oscillates up and down in <em>y</em> as it moves toward the minimum in <em>x</em>. Bouncing off the canyon walls aside, we still find the minimum.</p>&#13;
<p class="indent">Now, take a look at the <em>η</em> = 0.01 (square) path. It quickly falls into the canyon and then moves slowly over the flat region along the canyon floor toward the minimum position. The component of the vector gradient (the <em>x</em> and <em>y</em> partial derivative values) along the <em>x</em> direction is small in the canyon, so motion along <em>x</em> is proportionately slow. There is no motion in the <em>y</em> direction—the canyon is steep, and the relatively small learning rate has already located the canyon floor, where the gradient is primarily along <em>x</em>.</p>&#13;
<p class="indent">What’s the lesson here? Again, the step size matters. However, the shape of the function matters even more. The minimum of the function lies at the bottom of a long, narrow canyon. The gradient along the canyon is tiny; the canyon floor is flat in the <em>x</em> direction, so motion is slow because it depends on the gradient value. We frequently encounter this effect in deep learning: if the gradient is small, learning is slow. This is why the rectified linear unit has come to dominate deep learning; the gradient is a constant one for positive inputs. For a sigmoid or hyperbolic tangent, the gradient approaches zero when inputs are far from zero.</p>&#13;
<h5 class="h5" id="ch11lev3_2"><span epub:type="pagebreak" id="page_280"/>Gradient Descent with Multiple Minima</h5>&#13;
<p class="noindent">The functions we’ve examined so far have a single minimum value. What if that isn’t the case? Let’s see what happens to gradient descent when the function has more than one minimum. Consider this function:</p>&#13;
<div class="imagec" id="ch11equ04"><img src="Images/11equ04.jpg" alt="Image" width="797" height="45"/></div>&#13;
<p class="noindent"><a href="ch11.xhtml#ch11equ04">Equation 11.4</a> is the sum of two inverted Gaussians, one with a minimum value of −2 at (−1, 1) and the other with a minimum of −1 at (1, −1). If gradient descent is to find the global minimum, it should find it at (−1, 1). The code for this example is in <em>gd_multiple.py</em>.</p>&#13;
<p class="indent">The partial derivatives are</p>&#13;
<div class="imagec"><img src="Images/280equ01.jpg" alt="Image" width="776" height="124"/></div>&#13;
<p class="noindent">which translates into the following code:</p>&#13;
<pre>&#13;
def f(x,y):<br/>&#13;
    return -2*np.exp(-0.5*((x+1)**2+(y-1)**2)) + \<br/>&#13;
           -np.exp(-0.5*((x-1)**2+(y+1)**2))<br/>&#13;
<br/>&#13;
def dx(x,y):<br/>&#13;
    return 2*(x+1)*np.exp(-0.5*((x+1)**2+(y-1)**2)) + \<br/>&#13;
           (x-1)*np.exp(-0.5*((x-1)**2+(y+1)**2))<br/>&#13;
<br/>&#13;
def dy(x,y):<br/>&#13;
    return (y+1)*np.exp(-0.5*((x-1)**2+(y+1)**2)) + \<br/>&#13;
           2*(y-1)*np.exp(-0.5*((x+1)**2+(y-1)**2))</pre>&#13;
<p class="noindent">Notice, in this case, the partial derivatives do depend on both <em>x</em> and <em>y</em>.</p>&#13;
<p class="indent">The code for the gradient descent portion of <em>gd_multiple.py</em> is as before. Let’s run the cases in <a href="ch11.xhtml#ch11tab01">Table 11-1</a>.</p>&#13;
<p class="tabcap" id="ch11tab01"><strong>Table 11-1:</strong> Different Starting Positions and Number of Gradient Descent Steps Taken</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr class="borderb">&#13;
<th style="vertical-align: top"><p class="tab"><strong>Starting point</strong></p></th>&#13;
<th style="vertical-align: top"><p class="tab"><strong>Steps</strong></p></th>&#13;
<th style="vertical-align: top"><p class="tab"><strong>Symbol</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="bg-g">&#13;
<td style="vertical-align: top"><p class="tab">(–1.5,1.2)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">9</p></td>&#13;
<td style="vertical-align: top"><p class="tab">circle</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">(1.5,–1.8)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">9</p></td>&#13;
<td style="vertical-align: top"><p class="tab">square</p></td>&#13;
</tr>&#13;
<tr class="bg-g">&#13;
<td style="vertical-align: top"><p class="tab">(0,0)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">20</p></td>&#13;
<td style="vertical-align: top"><p class="tab">plus</p></td>&#13;
</tr>&#13;
<tr class="bg-g">&#13;
<td style="vertical-align: top"><p class="tab">(0.7,–0.2)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">20</p></td>&#13;
<td style="vertical-align: top"><p class="tab">triangle</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">(1.5,1.5)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">30</p></td>&#13;
<td style="vertical-align: top"><p class="tab">asterisk</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_281"/>The Symbol column refers to the plot symbol used in <a href="ch11.xhtml#ch11fig05">Figure 11-5</a>. For all cases, <em>η</em> = 0.4.</p>&#13;
<div class="image" id="ch11fig05"><img src="Images/11fig05.jpg" alt="image" width="694" height="521"/></div>&#13;
<p class="figcap"><em>Figure 11-5: Gradient descent for a function with two minima</em></p>&#13;
<p class="indent">The gradient descent paths indicated in <a href="ch11.xhtml#ch11fig05">Figure 11-5</a> make sense. In three of the five cases, the path does move into the well that the deeper of the two minima defines—a successful search. However, for the triangle and the square, gradient descent fell into the wrong minimum. Clearly, how successful gradient descent is, in this case, depends on where we start the process. Once the path moves downhill to a deeper position, gradient descent has no way to escape upward to find a potentially better minimum.</p>&#13;
<p class="indent">Current thinking is that the loss landscape for a deep learning model contains many minima. It’s also currently believed that in most cases, the minima are pretty similar, which partially explains the success of deep learning models—to train them, you don’t need to find the one, magic, global minimum of the loss, only one of the (probably) many that are (probably) about as good as any of the others.</p>&#13;
<p class="indent">I selected the initial positions used for the examples in this section intentionally based on knowledge of the function’s form. For a deep learning model, picking the starting point means random initialization of the weights and biases. In general, we don’t know the form of the loss function, so initialization is a shot in the dark. Most of the time, or at least much of the time, gradient descent produces a well-performing model. Sometimes, however, it doesn’t; it fails miserably. In those cases, it’s possible the initial position was like the square in <a href="ch11.xhtml#ch11fig05">Figure 11-5</a>: it fell into an inferior local minimum because it started in a bad place.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_282"/>Now that we have a handle on gradient descent, what it is, and how it works, let’s investigate how we can apply it in deep learning.</p>&#13;
<h3 class="h3" id="ch11lev1_2">Stochastic Gradient Descent</h3>&#13;
<p class="noindent">Training a neural network is primarily the act of minimizing the loss function while preserving generalizability via various forms of regularization. In <a href="ch10.xhtml#ch10">Chapter 10</a>, we wrote the loss as <em>L</em>(<strong>θ</strong>; <em><strong>x</strong></em>, <em>y</em>) for a vector of the weights and biases, <strong>θ</strong> (theta), and training instances (<em><strong>x</strong></em>, <em>y</em>), where <em><strong>x</strong></em> is the input vectors and y is the known labels. Note how here, <em><strong>x</strong></em> is a stand-in for <em>all</em> training data, not just a single sample.</p>&#13;
<p class="indent">Gradient descent needs ∂<em>L</em>/∂<strong>θ</strong>, which we get via backpropagation. The expression ∂<em>L</em>/∂<strong>θ</strong> is a concise way of referring to all the individual weight and bias error terms backpropagation gives us. We get ∂<em>L</em>/∂<strong>θ</strong> by averaging the error over the training data. This begs the question: Do we average over all of the training data or only some of the training data?</p>&#13;
<p class="indent">Passing all the training data through the model before taking a gradient descent step is called batch training. At first blush, batch training seems sensible. After all, if our training set is a good sample from the parent distribution that generates the sort of data our model intends to work with, then why not use all of that sample to do gradient descent?</p>&#13;
<p class="indent">When datasets were small, batch training was the natural thing to do. However, models got bigger, as did datasets, and suddenly the computational burden of passing <em>all</em> the training data through the model for each gradient descent step became too much. This chapter’s examples already hint that many gradient descent steps might be necessary to find a good minimum position, especially for tiny learning rates.</p>&#13;
<p class="indent">Therefore, practitioners began to use subsets of the training data for each gradient descent step—the <em>minibatch</em>. Minibatch training was probably initially viewed as a compromise, as the gradient calculated over the minibatch was “wrong” because it wasn’t based on the performance of the full training set.</p>&#13;
<p class="indent">Of course, the difference between <em>batch</em> and <em>minibatch</em> is just an agreed-upon fiction. In truth, it’s a continuum from a minibatch of one to a minibatch of all available samples. With that in mind, all the gradients computed during network training are “wrong,” or at least incomplete, as they are based on incomplete knowledge of the data generator and the full set of data it could generate.</p>&#13;
<p class="indent">Rather than a concession, then, minibatch training is reasonable. The gradient over a small minibatch is noisy compared to that computed over a larger minibatch, in the sense that the small minibatch gradient is a coarser estimate of the “real” gradient. When things are noisy or random, the word <em>stochastic</em> tends to show up, as it does here. Gradient descent with minibatches is <em>stochastic gradient descent (SGD)</em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_283"/>In practice, gradient descent using smaller minibatches often leads to models that perform better than those trained with larger minibatches. The rationale generally given is that the noisy gradient of the smaller minibatch helps gradient descent avoid falling into poor local minima of the loss landscape. We saw this effect in <a href="ch11.xhtml#ch11fig05">Figure 11-5</a>, where the triangle and the square both fell into the wrong minimum.</p>&#13;
<p class="indent">Again, we find ourselves strangely fortunate. Before, we were fortunate because first-order gradient descent succeeded in training models that shouldn’t train due to nonlinear loss landscapes, and now we get a boost by intentionally using small amounts of data to estimate gradients, thereby skipping a computational burden likely to make the entire enterprise of deep learning too cumbersome to implement in many cases.</p>&#13;
<p class="indent">How large should our minibatch be? Minibatch size is a <em>hyperparameter</em>, something we need to select to train the model, but is not part of the model itself. The proper minibatch size is dataset-dependent. For example, in the extreme, we could take a gradient descent step for each sample, which sometimes works well. This case is often referred to as <em>online learning</em>. However, especially if we use layers like batch normalization, we need a minibatch large enough to make the calculated means and standard deviations reasonable estimates. Again, as with most everything else in deep learning at present, it’s empirical, and you need to both have intuition and try many variations to optimize the training of the model. This is why people work on <em>AutoML</em> systems, systems that seek to do all the hyperparameter tuning for you.</p>&#13;
<p class="indent">Another good question: What should be in the minibatch? That is, what small subset of the full dataset should we use? Typically, the order of the samples in the training set is randomized, and minibatches are pulled from the set as successive chunks of samples until all samples have been used. Using all the samples in the dataset defines one epoch, so the number of samples in the training set divided by the minibatch size determines the number of minibatches per epoch.</p>&#13;
<p class="indent">Alternatively, as we did for <em>NN.py</em>, a minibatch might genuinely be a random sampling from the available data. It’s possible that a particular training sample is never used while another is used many times, but on the whole, the majority of the dataset is used during training.</p>&#13;
<p class="indent">Some toolkits train for a specified number of minibatches. Both <em>NN.py</em> and Caffe operate this way. Other toolkits, like Keras and <code>sklearn</code>, use epochs. Gradient descent steps happen after a minibatch is processed. Larger minibatches result in fewer gradient descent steps per epoch. To compensate, practitioners using toolkits that use epochs need to ensure that the number of gradient descent steps increases as minibatch size increases—larger minibatches require more epochs to train well.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_284"/>To recap, deep learning does not use full batch training for at least the following reasons:</p>&#13;
<ol>&#13;
<li><p>The computational burden is too great to pass the entire training set through the model for each gradient descent step.</p></li>&#13;
<li><p>The gradient computed from the average loss over a minibatch is a noisy but reasonable estimate of the true, and ultimately unknowable, gradient.</p></li>&#13;
<li><p>The noisy gradient points in a slightly wrong direction in the loss landscape, thereby possibly avoiding bad minima.</p></li>&#13;
<li><p>Minibatch training simply works better in practice for many datasets.</p></li>&#13;
</ol>&#13;
<p class="noindent">Reason #4 should not be underestimated: many practices in deep learning are employed initially because they simply work better. Only later are they justified by theory, if at all.</p>&#13;
<p class="indent">As we already implemented SGD in <a href="ch10.xhtml#ch10">Chapter 10</a> (see <em>NN.py</em>), we won’t reimplement it here, but in the next section, we’ll add momentum to see how that affects neural network training.</p>&#13;
<h3 class="h3" id="ch11lev1_3">Momentum</h3>&#13;
<p class="noindent">Vanilla gradient descent relies solely on the value of the partial derivative multiplied by the learning rate. If the loss landscape has many local minima, especially if they’re steep, vanilla gradient descent might fall into one of the minima and be unable to recover. To compensate, we can modify vanilla gradient descent to include a <em>momentum</em> term, a term that uses a fraction of the previous step’s update. Including this momentum in gradient descent adds inertia to the algorithm’s motion through the loss landscape, thereby potentially allowing gradient descent to move past bad local minima.</p>&#13;
<p class="indent">Let’s define and then experiment with momentum using 1D and 2D examples, as we did earlier. After that, we’ll update our <em>NN.py</em> toolkit to use momentum to see how that affects models trained on more complex datasets.</p>&#13;
<h4 class="h4" id="ch11lev2_3">What Is Momentum?</h4>&#13;
<p class="noindent">In physics, the momentum of a moving object is defined as the mass times the velocity, <em><strong>p</strong></em> = <em>m<strong>v</strong></em>. However, velocity itself is the first derivative of the position, <em><strong>v</strong></em> = <em>d<strong>x</strong></em>/<em>dt</em>, so momentum is mass times how fast the position of the object is changing in time.</p>&#13;
<p class="indent">For gradient descent, <em>position</em> is the function value, and <em>time</em> is the argument to the function. The <em>velocity</em>, then, is how fast the function value changes with a change in the argument, ∂<em>f</em>/∂<em><strong>x</strong></em>. Therefore, we can think of <em>momentum</em> as a scaled velocity term. In physics, the scale factor is the mass. For gradient descent, the scale factor is <em>μ</em> (mu), a number between zero and one.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_285"/>If we call the gradient including the momentum term <em><strong>v</strong></em>, then the gradient descent update equation that was</p>&#13;
<div class="imagec"><img src="Images/285equ01.jpg" alt="Image" width="119" height="44"/></div>&#13;
<p class="noindent">becomes</p>&#13;
<div class="imagec" id="ch11equ05"><img src="Images/11equ05.jpg" alt="Image" width="412" height="106"/></div>&#13;
<p class="noindent">for some initial velocity, <em><strong>v</strong></em> = 0, and the “mass,” <em>μ</em>.</p>&#13;
<p class="indent">Let’s walk through <a href="ch11.xhtml#ch11equ05">Equation 11.5</a> to understand what it means. The two-step update, first <em><strong>v</strong></em> and then <em><strong>x</strong></em>, makes it easy to iterate, as we know we must do for gradient descent. If we substitute <em><strong>v</strong></em> into the update equation for <em><strong>x</strong></em>, we get</p>&#13;
<div class="imagec"><img src="Images/285equ02.jpg" alt="Image" width="166" height="45"/></div>&#13;
<p class="noindent">This makes it clear that the update includes the gradient step we had previously but adds back in a fraction of the previous step size. It’s a fraction because we restrict <em>μ</em> to [0, 1]. If <em>μ</em> = 0, we’re back to vanilla gradient descent. It might be helpful to think of <em>μ</em> as a scale factor, the fraction of the previous velocity to keep along with the current gradient value.</p>&#13;
<p class="indent">The momentum term tends to keep motion through the loss landscape heading in its previous direction. The value of <em>μ</em> determines the strength of that tendency. Deep learning practitioners typically use <em>μ</em> = 0.9, so most of the previous update direction is maintained in the next step, with the current gradient providing a small adjustment. Again, like many things in deep learning, this number was chosen empirically.</p>&#13;
<p class="indent">Newton’s first law of motion states that an object in motion remains in motion unless acted upon by an outside force. Resistance to an external force is related to the object’s mass and is called <em>inertia</em>. So, we might also view the <em>μ<strong>v</strong></em> term as inertia, which might have been a better name for it.</p>&#13;
<p class="indent">Regardless of the name, now that we have it, let’s see what it does to the 1D and 2D examples we worked through earlier using vanilla gradient descent.</p>&#13;
<h4 class="h4" id="ch11lev2_4">Momentum in 1D</h4>&#13;
<p class="noindent">Let’s modify the 1D and 2D examples above to use a momentum term. We’ll start with the 1D case. The updated code is in the file <em>gd_1d_momentum.py</em> and appears here as <a href="ch11.xhtml#ch11ex02">Listing 11-2</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_286"/>   import matplotlib.pylab as plt<br/>&#13;
<br/>&#13;
   def f(x):<br/>&#13;
       return 6*x**2 - 12*x + 3<br/>&#13;
   def d(x):<br/>&#13;
       return 12*x - 12<br/>&#13;
<br/>&#13;
<span class="ent">❶</span> m = ['o','s','&gt;','&lt;','*','+','p','h','P','D']<br/>&#13;
   x = np.linspace(0.75,1.25,1000)<br/>&#13;
   plt.plot(x,f(x))<br/>&#13;
<br/>&#13;
<span class="ent">❷</span> x = xold = 0.75<br/>&#13;
   eta = 0.09<br/>&#13;
   mu = 0.8<br/>&#13;
   v = 0.0<br/>&#13;
<br/>&#13;
   for i in range(10):<br/>&#13;
    <span class="ent">❸</span> plt.plot([xold,x], [f(xold),f(x)], marker=m[i], linestyle='dotted',<br/>&#13;
       color='r')<br/>&#13;
       xold = x<br/>&#13;
       v = mu*v - eta * d(x)<br/>&#13;
       x = x + v<br/>&#13;
<br/>&#13;
   for i in range(40):<br/>&#13;
       v = mu*v - eta * d(x)<br/>&#13;
       x = x + v<br/>&#13;
<br/>&#13;
<span class="ent">❹</span> plt.plot(x,f(x),marker='X', color='k')</pre>&#13;
<p class="ex-caption" id="ch11ex02"><em>Listing 11-2: Gradient descent in one dimension with momentum</em></p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11ex02">Listing 11-2</a> is a bit dense, so let’s parse it out. First, we are plotting, so we include Matplotlib. Next, we define the function, <code>f(x)</code>, and its derivative, <code>d(x)</code>, as we did before. To configure plotting, we define a collection of markers <span class="ent">❶</span> and then plot the function itself. As before, we begin at <em>x</em> = 0.75 <span class="ent">❷</span> and set the step size (<code>eta</code>), momentum (<code>mu</code>), and initial velocity (<code>v</code>).</p>&#13;
<p class="indent">We’re now ready to iterate. We’ll use two gradient descent loops. The first plots each step <span class="ent">❸</span> and the second continues gradient descent to demonstrate that we do eventually locate the minimum, which we mark with an <code>'X'</code> <span class="ent">❹</span>. For each step, we calculate the new velocity by mimicking <a href="ch11.xhtml#ch11equ05">Equation 11.5</a>, and then we add the velocity to the current position to get the next position.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11fig06">Figure 11-6</a> shows the output of <em>gd_1d_momentum.py</em>.</p>&#13;
<span epub:type="pagebreak" id="page_287"/>&#13;
<div class="image" id="ch11fig06"><img src="Images/11fig06.jpg" alt="image" width="694" height="521"/></div>&#13;
<p class="figcap"><em>Figure 11-6: Gradient descent in one dimension with momentum</em></p>&#13;
<p class="indent">Note that we intentionally used a large step size (<em>η</em>), so we overshoot the minimum. The momentum term tends to overshoot minima as well. If you follow the dashed line and the sequence of plot markers, you can walk through the first 10 gradient descent steps. There is oscillation, but the oscillation is damped and eventually settles at the minimum, as marked. Adding momentum enhanced the overshoot due to the large step size. However, even with the momentum term, which isn’t advantageous here, because there’s only one minimum, with enough gradient descent steps, we find the minimum in the end.</p>&#13;
<h4 class="h4" id="ch11lev2_5">Momentum in 2D</h4>&#13;
<p class="noindent">Now, let’s update our 2D example. We’re working with the code in <em>gd _momentum.py</em>. Recall that, for the 2D example, the function is the sum of two inverted Gaussians. Including momentum updates the code slightly, as shown in <a href="ch11.xhtml#ch11ex03">Listing 11-3</a>:</p>&#13;
<pre>&#13;
   def gd(x,y, eta,mu, steps, marker):<br/>&#13;
       xold = x<br/>&#13;
       yold = y<br/>&#13;
    <span class="ent">❶</span> vx = vy = 0.0<br/>&#13;
       for i in range(steps):<br/>&#13;
           plt.plot([xold,x],[yold,y], marker=marker,<br/>&#13;
                    linestyle='dotted', color='k')<br/>&#13;
<br/>&#13;
<span epub:type="pagebreak" id="page_288"/>&#13;
           xold = x<br/>&#13;
           yold = y<br/>&#13;
        <span class="ent">❷</span> vx = mu*vx - eta * dx(x,y)<br/>&#13;
           vy = mu*vy - eta * dy(x,y)<br/>&#13;
        <span class="ent">❸</span> x = x + vx<br/>&#13;
           y = y + vy<br/>&#13;
<br/>&#13;
<span class="ent">❹</span> gd( 0.7,-0.2, 0.1, 0.9, 25, '&gt;')<br/>&#13;
   gd( 1.5, 1.5, 0.02, 0.9, 90, '*')</pre>&#13;
<p class="ex-caption" id="ch11ex03"><em>Listing 11-3: Gradient descent in two dimensions with momentum</em></p>&#13;
<p class="noindent">Here, we have the new function, <code>gd</code>, which performs gradient descent with momentum beginning at <code>(x,y)</code>, using the given <em>μ</em> and <em>η</em>, and runs for <code>steps</code> iterations.</p>&#13;
<p class="indent">The initial velocity is set <span class="ent">❶</span>, and the loop begins. The velocity update of <a href="ch11.xhtml#ch11equ05">Equation 11.5</a> becomes <code>vx = mu*vx - eta * dx(x,y)</code> <span class="ent">❷</span>, and the position update becomes <code>x = x + vx</code> <span class="ent">❸</span>. As before, a line is plotted between the last position and the current one to track motion through the function landscape.</p>&#13;
<p class="indent">The code in <em>gd_momentum.py</em> traces the motion starting at two of the points we used before, (0.7, −0.2) and (1.5, 1.5) <span class="ent">❹</span>. Note the number of steps and learning rate vary by point to keep the plot from becoming too cluttered. The output of <em>gd_momentum.py</em> is <a href="ch11.xhtml#ch11fig07">Figure 11-7</a>.</p>&#13;
<div class="image" id="ch11fig07"><img src="Images/11fig07.jpg" alt="image" width="694" height="521"/></div>&#13;
<p class="figcap"><em>Figure 11-7: Gradient descent in two dimensions with momentum</em></p>&#13;
<p class="indent">Compare the paths in <a href="ch11.xhtml#ch11fig07">Figure 11-7</a> with those in <a href="ch11.xhtml#ch11fig05">Figure 11-5</a>. Adding momentum has pushed the paths, so they tend to keep moving in the same <span epub:type="pagebreak" id="page_289"/>direction. Notice how the path beginning at (1.5, 1.5) spirals toward the minimum, while the other path curves toward the shallower minimum, passes it, and backtracks toward it again.</p>&#13;
<p class="indent">The momentum term alters the dynamics of motion through the function space. However, it’s not immediately evident that momentum adds anything helpful. After all, the (1.5, 1.5) starting position using vanilla gradient descent moved directly to the minimum position without spiraling.</p>&#13;
<p class="indent">Let’s add momentum to our <em>NN.py</em> toolkit and see if it buys us anything when training real neural networks.</p>&#13;
<h4 class="h4" id="ch11lev2_6">Training Models with Momentum</h4>&#13;
<p class="noindent">To support momentum in <em>NN.py</em>, we need to tweak the <code>FullyConnectedLayer</code> method in two places. First, as shown in <a href="ch11.xhtml#ch11ex04">Listing 11-4</a>, we modify the constructor to allow a <code>momentum</code> keyword:</p>&#13;
<pre>&#13;
def __init__(self, input_size, output_size, momentum=0.0):<br/>&#13;
    self.delta_w = np.zeros((input_size, output_size))<br/>&#13;
    self.delta_b = np.zeros((1,output_size))<br/>&#13;
    self.passes = 0<br/>&#13;
    self.weights = np.random.rand(input_size, output_size) - 0.5<br/>&#13;
    self.bias = np.random.rand(1, output_size) - 0.5<br/>&#13;
 <span class="ent">❶</span> self.vw = np.zeros((input_size, output_size))<br/>&#13;
    self.vb = np.zeros((1, output_size))<br/>&#13;
    self.momentum = momentum</pre>&#13;
<p class="ex-caption" id="ch11ex04"><em>Listing 11-4: Adding the momentum keyword</em></p>&#13;
<p class="noindent">Here, we add a <code>momentum</code> keyword, with a default of zero, into the argument list. Then, we define initial velocities for the weights (<code>vw</code>) and biases (<code>vb</code>) <span class="ent">❶</span>. These are matrices of the proper shape initialized to zero. We also keep the momentum argument for later use.</p>&#13;
<p class="indent">The second modification is to the <code>step</code> method, as <a href="ch11.xhtml#ch11ex05">Listing 11-5</a> shows:</p>&#13;
<pre>&#13;
def step(self, eta):<br/>&#13;
 <span class="ent">❶</span> self.vw = self.momentum * self.vw - eta * self.delta_w / self.passes<br/>&#13;
    self.vb = self.momentum * self.vb - eta * self.delta_b / self.passes<br/>&#13;
 <span class="ent">❷</span> self.weights = self.weights + self.vw<br/>&#13;
    self.bias = self.bias + self.vb<br/>&#13;
    self.delta_w = np.zeros(self.weights.shape)<br/>&#13;
    self.delta_b = np.zeros(self.bias.shape)<br/>&#13;
    self.passes = 0</pre>&#13;
<p class="ex-caption" id="ch11ex05"><em>Listing 11-5: Updating the step to include momentum</em></p>&#13;
<p class="noindent">We implement <a href="ch11.xhtml#ch11equ05">Equation 11.5</a>, first for the weights <span class="ent">❶</span>, then for the biases in the line after. We multiply the momentum (<em>μ</em>) by the previous velocity, then subtract the average error over the minibatch, multiplied by the learning rate. We then move the weights and biases by adding the velocity <span class="ent">❷</span>. That’s all we need to do to incorporate momentum. Then, to use it, we add the <span epub:type="pagebreak" id="page_290"/>momentum keyword to each fully connected layer when building the network, as shown in <a href="ch11.xhtml#ch11ex06">Listing 11-6</a>:</p>&#13;
<pre>net = Network()<br/>&#13;
net.add(FullyConnectedLayer(14*14, 100, momentum=0.9))<br/>&#13;
net.add(ActivationLayer())<br/>&#13;
net.add(FullyConnectedLayer(100, 50, momentum=0.9))<br/>&#13;
net.add(ActivationLayer())<br/>&#13;
net.add(FullyConnectedLayer(50, 10, momentum=0.9))<br/>&#13;
net.add(ActivationLayer())</pre>&#13;
<p class="ex-caption" id="ch11ex06"><em>Listing 11-6: Specifying momentum when building the network</em></p>&#13;
<p class="indent">Adding momentum per layer opens up the possibility of using layer-specific momentum values. While I’m unaware of any research doing so, it seems a fairly obvious thing to try, so by now, someone has likely experimented with it. For our purposes, we’ll set the momentum of all layers to 0.9 and move on.</p>&#13;
<p class="indent">How should we test our new momentum? We could use the MNIST dataset we used above, but it’s not a good candidate, because it’s too easy. Even a simple fully connected network achieves better than 97 percent accuracy. Therefore, we’ll replace the MNIST digits dataset with another, similar dataset that’s known to be more of a challenge: the Fashion-MNIST dataset. (See “Fashion-MNIST: A Novel Image Dataset for Benchmarking Machine Learning Algorithms” by Han Xiao et al., arXiv:1708.07747 [2017].)</p>&#13;
<p class="indent">The <em>Fashion-MNIST dataset (FMNIST)</em> is a drop-in replacement for the existing MNIST dataset. It contains images from 10 classes of clothing, all 28×28-pixel grayscale. For our purposes, we’ll do as we did for MNIST and reduce the 28×28-pixel images to 14 ×14 pixels. The images are in the <code>dataset</code> directory as NumPy arrays. Let’s train a model using them. The code for the model is similar to that of <a href="ch10.xhtml#ch10ex07">Listing 10-7</a>, except in <a href="ch11.xhtml#ch11ex07">Listing 11-7</a> we replace the MNIST dataset with FMNIST:</p>&#13;
<pre>x_train = np.load("fmnist_train_images_small.npy")/255<br/>&#13;
x_test = np.load("fmnist_test_images_small.npy")/255<br/>&#13;
y_train = np.load("fmnist_train_labels_vector.npy")<br/>&#13;
y_test = np.load("fmnist_test_labels.npy")</pre>&#13;
<p class="ex-caption" id="ch11ex07"><em>Listing 11-7: Loading the Fashion-MNIST dataset</em></p>&#13;
<p class="noindent">We also include code to calculate the Matthews correlation coefficient (MCC) on the test data. We first encountered the MCC in <a href="ch04.xhtml#ch04">Chapter 4</a>, where we learned that it’s a better measure of a model’s performance than the accuracy is. The code to run is in <em>fmnist.py</em>. Taking around 18 minutes on an older Intel i5 box, one run of it produced</p>&#13;
<pre>&#13;
[[866   1  14  28   8   1  68   0  14   0]<br/>&#13;
 [  5 958   2  25   5   0   3   0   2   0]<br/>&#13;
 [ 20   1 790  14 126   0  44   1   3   1]<br/>&#13;
 [ 29  21  15 863  46   1  20   0   5   0]<br/>&#13;
<span epub:type="pagebreak" id="page_291"/>&#13;
 [  0   0  91  22 849   1  32   0   5   0]<br/>&#13;
 [  0   0   0   1   0 960   0  22   2  15]<br/>&#13;
 [161   2 111  38 115   0 556   0  17   0]<br/>&#13;
 [  0   0   0   0   0  29   0 942   0  29]<br/>&#13;
 [  1   0   7   5   6   2   2   4 973   0]<br/>&#13;
 [  0   0   0   0   0   6   0  29   1 964]]<br/>&#13;
<br/>&#13;
accuracy = 0.8721000<br/>&#13;
MCC = 0.8584048</pre>&#13;
<p class="indent">The confusion matrix, still 10 × 10 because of the 10 classes in FMNIST, is quite noisy compared to the very clean confusion matrix we saw with MNIST proper. This is a challenging dataset for fully connected models. Recall that the MCC is a measure where the closer it is to one, the better the model.</p>&#13;
<p class="indent">The confusion matrix above is for a model trained without momentum. The learning rate was 1.0, and it was trained for 40,000 minibatches of 64 samples. What happens if we add momentum of 0.9 to each fully connected layer and reduce the learning rate to 0.2? When we add momentum, it makes sense to reduce the learning rate so we aren’t taking large steps compounded by the momentum already moving in a particular direction. Do explore what happens if you run <em>fmnist.py</em> with a learning rate of 0.2 and no momentum.</p>&#13;
<p class="indent">The version of the code with momentum is in <em>fmnist_momentum.py</em>. After about 20 minutes, one run of this code produced</p>&#13;
<pre>&#13;
[[766   5  14  61   2   1 143   0   8   0]<br/>&#13;
 [  1 958   2  30   3   0   6   0   0   0]<br/>&#13;
 [ 12   0 794  16  98   0  80   0   0   0]<br/>&#13;
 [  8  11  13 917  21   0  27   0   3   0]<br/>&#13;
 [  0   0  84  44 798   0  71   0   3   0]<br/>&#13;
 [  0   0   0   1   0 938   0  31   1   29]<br/>&#13;
 [ 76   2  87  56  60   0 714   0   5   0]<br/>&#13;
 [  0   0   0   0   0  11   0 963   0  26]<br/>&#13;
 [  1   1   6   8   5   1  10   4 964   0]<br/>&#13;
 [  0   0   0   0   0   6   0  33   0 961]]<br/>&#13;
<br/>&#13;
accuracy = 0.8773000<br/>&#13;
MCC = 0.8638721</pre>&#13;
<p class="noindent">giving us a slightly higher MCC. Does that mean momentum helped? Maybe. As we well understand by now, training neural networks is a stochastic process. So, we can’t rely on results from a single training of the models. We need to train the models many times and perform statistical tests on the results. Excellent! This gives us a chance to put the hypothesis testing knowledge we gained in <a href="ch04.xhtml#ch04">Chapter 4</a> to good use.</p>&#13;
<p class="indent">Instead of running <em>fmnist.py</em> and <em>fmnist_momentum.py</em> one time each, let’s run them 22 times each. This takes the better part of a day on my old Intel <span epub:type="pagebreak" id="page_292"/>i5 system, but patience is a virtue. The net result is 22 MCC values for the model with momentum and 22 for the model without momentum. There’s nothing magical about 22 samples, but we intend to use the Mann-Whitney U test, and the rule of thumb for that test is to have at least 20 samples in each dataset.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11fig08">Figure 11-8</a> displays histograms of the results.</p>&#13;
<div class="image" id="ch11fig08"><img src="Images/11fig08.jpg" alt="image" width="694" height="521"/></div>&#13;
<p class="figcap"><em>Figure 11-8: Histograms showing the distribution of MCC for models trained with momentum (light gray) and without (dark gray)</em></p>&#13;
<p class="indent">The darker gray bars are the no-momentum MCC values, and the lighter bars are those with momentum. Visually, the two are largely distinct from each other. The code producing <a href="ch11.xhtml#ch11fig08">Figure 11-8</a> is in the file <em>fmnist_analyze.py</em>. Do take a look at the code. It uses SciPy’s <code>ttest_ind</code> and <code>mannwhitneyu</code> along with the implementation we gave in <a href="ch04.xhtml#ch04">Chapter 4</a> of Cohen’s <em>d</em> to calculate the effect size. The MCC values themselves are in the NumPy files listed in the code.</p>&#13;
<p class="indent">Along with the graph, <em>fmnist_analyze.py</em> produces the following output:</p>&#13;
<pre>no momentum: 0.85778 +/- 0.00056<br/>&#13;
momentum   : 0.86413 +/- 0.00075<br/>&#13;
<br/>&#13;
t-test momentum vs no (t,p): (6.77398299, 0.00000003)<br/>&#13;
Mann-Whitney U             : (41.00000000, 0.00000126)<br/>&#13;
Cohen's d                  : 2.04243</pre>&#13;
<p class="noindent">where the top two lines are the mean and the standard error of the mean. The t-test results are (<em>t</em>, <em>p</em>), the <em>t</em>-test statistic and associated <em>p</em>-value. Similarly, <span epub:type="pagebreak" id="page_293"/>the Mann-Whitney U test results are (<em>U</em>, <em>p</em>), the <em>U</em> statistic and its <em>p</em>-value. Recall how the Mann-Whitney U test is a nonparametric test assuming nothing about the shape of the distribution of MCC values. The t-test assumes they are normally distributed. As we have only 22 samples each, we really can’t make any definitive statement about whether the results are normally distributed; the histograms don’t look much like Gaussian curves. That’s why we included the Mann-Whitney U test results.</p>&#13;
<p class="indent">A glance at the respective <em>p</em>-values tells us that the difference in means between the MCC values with and without momentum is highly statistically significant in favor of the with-momentum results. The <em>t</em>-value is positive, and the with-momentum result was the first argument. What of Cohen’s <em>d</em>-value? It’s a bit above 2.0, indicating a (very) large effect size.</p>&#13;
<p class="indent">Can we <em>now</em> say that momentum helps in this case? Probably. It produced better performing models given the hyperparameters we used. The stochastic nature of training neural networks makes it possible that we could tweak the hyperparameters of both models to eliminate the difference we see in the data we have. The architecture between the two is fixed, but nothing says the learning rate and minibatch size are optimized for either model.</p>&#13;
<p class="indent">A punctilious researcher would feel compelled to run an optimization process over the hyperparameters and, once satisfied that they’d found the very best model for both approaches, make a more definite statement after repeating the experiment. We, thankfully, are not punctilious researchers. Instead, we’ll use the evidence we have, along with the several decades of wisdom acquired by the world’s machine learning researchers regarding the utility of momentum in gradient descent, to state that, yes, momentum helps models learn, and you should use it in most cases.</p>&#13;
<p class="indent">However, the normality question is begging for further investigation. We are, after all, seeking to improve our mathematical <em>and</em> practical intuition regarding deep learning. Therefore, let’s train the with-momentum model for FMNIST, not 22 times but 100 times. As a concession, we’ll reduce the number of minibatches from 40,000 to 10,000. Still, expect to spend the better part of a day waiting for the program to finish. The code, which we won’t walk through here, is in <em>fmnist_repeat.py</em>.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11fig09">Figure 11-9</a> presents a histogram of the results.</p>&#13;
<p class="indent">Clearly, this distribution does not look at all like a normal curve. The output of <em>fmnist_repeat.py</em> includes the result of SciPy’s <code>normaltest</code> function. This function performs a statistical test on a set of data under the null hypothesis that the data <em>is</em> normally distributed. Therefore, a <em>p</em>-value below, say, 0.05 or 0.01, indicates data that is not normally distributed. Our <em>p</em>-value is virtually zero.</p>&#13;
<p class="indent">What to make of <a href="ch11.xhtml#ch11fig09">Figure 11-9</a>? First, as the results are certainly not normal, we aren’t justified in using a t-test. However, we also used the nonparametric Mann-Whitney U test and found highly statistically significant results, so our claims above are still valid. Second, the long tail of the distribution in <a href="ch11.xhtml#ch11fig09">Figure 11-9</a> is to the left. We might even make an argument that the result is possibly bimodal: that there are two peaks, one near 0.83 and the other, smaller one near an MCC of 0.75.</p>&#13;
<span epub:type="pagebreak" id="page_294"/>&#13;
<div class="image" id="ch11fig09"><img src="Images/11fig09.jpg" alt="image" width="694" height="523"/></div>&#13;
<p class="figcap"><em>Figure 11-9: Distribution of MCC values for 100 trainings of the FMNIST model</em></p>&#13;
<p class="indent">Most models trained to a relatively consistent level of performance, with an MCC near 0.83. However, the long tail indicates that when the model wasn’t reasonably good, it was just plain horrid.</p>&#13;
<p class="indent">Intuitively, <a href="ch11.xhtml#ch11fig09">Figure 11-9</a> seems reasonable to me. We know stochastic gradient descent is susceptible to improper initialization, and our little toolkit is using old-school small random value initialization. It seems likely that we have an increased chance of starting at a poor location in the loss landscape and are doomed after that to poor performance.</p>&#13;
<p class="indent">What if the tail were on the right? What might that indicate? A long tail on the right would mean most model performance is mediocre to poor, but, on occasion, an especially “bright” model comes along. Such a scenario would mean that better models are out there, but that our training and/or initialization strategy isn’t particularly good at finding them. I think the tail on the left is preferable—most models find reasonably good local minima, so most trainings, unless horrid, end up in pretty much the same place in terms of performance.</p>&#13;
<p class="indent">Now, let’s examine a common variant of momentum, one that you’ll no doubt run across during your sojourn through deep learning.</p>&#13;
<h4 class="h4" id="ch11lev2_7">Nesterov Momentum</h4>&#13;
<p class="noindent">Many deep learning toolkits include the option to use <em>Nesterov momentum</em> during gradient descent. Nesterov momentum is a modification of gradient descent widely used in the optimization community. The version typically implemented in deep learning updates standard momentum from</p>&#13;
<span epub:type="pagebreak" id="page_295"/>&#13;
<div class="imagec"><img src="Images/295equ01.jpg" alt="Image" width="152" height="81"/></div>&#13;
<p class="noindent">to</p>&#13;
<div class="imagec" id="ch11equ06"><img src="Images/11equ06.jpg" alt="Image" width="447" height="83"/></div>&#13;
<p class="noindent">where we’re using gradient notation instead of partials of a loss function to indicate that the technique is general and applies to any function, <em>f</em>(<em><strong>x</strong></em>).</p>&#13;
<p class="indent">The difference between standard momentum and deep learning Nesterov momentum is subtle, just a term that’s added to the argument of the gradient. The idea is to use the existing momentum to calculate the gradient, not at the current position, <em><strong>x</strong></em>, but the position gradient descent would be at if it continued further using the current momentum, <em><strong>x</strong></em> + <em>μ <strong>v</strong></em>. We then use the gradient’s value at that position to update the current position, as before.</p>&#13;
<p class="indent">The claim, well demonstrated for optimization in general, is that this tweak leads to faster convergence, meaning gradient descent will find the minimum in fewer steps. However, even though toolkits implement it, there is reason to believe the noise that stochastic gradient descent with minibatches introduces offsets the adjustment to the point where it’s unlikely Nesterov momentum is any more useful for training deep learning models than regular momentum. (For more on this, see the comment on page 292 of <em>Deep Learning</em> by Ian Goodfellow et al.)</p>&#13;
<p class="indent">However, the 2D example in this chapter uses the actual function to calculate gradients, so we might expect Nesterov momentum to be effective in that case. Let’s update the 2D example, minimizing the sum of two inverted Gaussians, and see if Nesterov momentum improves convergence, as claimed. The code we’ll run is in <em>gd_nesterov.py</em> and is virtually identical to the code in <em>gd_momentum.py</em>. Additionally, I tweaked both files a tiny bit to return the final position after gradient descent is complete. That way, we can see how close we are to the known minima.</p>&#13;
<p class="indent">Implementing <a href="ch11.xhtml#ch11equ06">Equation 11.6</a> is straightforward and affects only the velocity update, causing</p>&#13;
<p class="program1">vx = mu*vx - eta * dx(x,y)<br/>&#13;
vy = mu*vy - eta * dy(x,y)</p>&#13;
<p class="noindent">to become</p>&#13;
<p class="program1">vx = mu * vx - eta * dx(x + mu * vx,y)<br/>&#13;
vy = mu * vy - eta * dy(x,y + mu * vy)</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_296"/>to add the momentum for each component, <em>x</em> and <em>y</em>. Everything else remains the same.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11fig010">Figure 11-10</a> compares standard momentum (top, from <a href="ch11.xhtml#ch11fig07">Figure 11-7</a>) and Nesterov momentum (bottom).</p>&#13;
<div class="image" id="ch11fig010"><img src="Images/11fig10.jpg" alt="image" width="591" height="889"/></div>&#13;
<p class="figcap"><em>Figure 11-10: Standard momentum (top) and Nesterov momentum (bottom)</em></p>&#13;
<p class="indent">Visually, Nesterov momentum shows less of an overshoot, especially for the spiral marking the path beginning at (1.5, 1.5). What about the final location that each approach returns? We get <a href="ch11.xhtml#ch11tab02">Table 11-2</a>.</p>&#13;
<p class="tabcap" id="ch11tab02"><span epub:type="pagebreak" id="page_297"/><strong>Table 11-2</strong>: Final Location for Gradient Descent With and Without Nesterov Momentum</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr class="borderb">&#13;
<th style="vertical-align: top"><p class="tab"><strong>Initial point</strong></p></th>&#13;
<th style="vertical-align: top"><p class="tab"><strong>Standard</strong></p></th>&#13;
<th style="vertical-align: top"><p class="tab"><strong>Nesterov</strong></p></th>&#13;
<th style="vertical-align: top"><p class="tab"><strong>Minimum</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">(1.5,1.5)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">(–0.9496, 0.9809)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">(–0.9718, 0.9813)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">(–1,1)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">(0.7,–0.2)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">(0.8807, –0.9063)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">(0.9128, –0.9181)</p></td>&#13;
<td style="vertical-align: top"><p class="tab">(1,–1)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent">The Nesterov momentum results are closer to the known minima than the standard momentum results after the same number of gradient descent steps.</p>&#13;
<h3 class="h3" id="ch11lev1_4">Adaptive Gradient Descent</h3>&#13;
<p class="noindent">The gradient descent algorithm is almost trivial, which invites adaptation. In this section, we’ll walk through the math behind three variants of gradient descent popular with the deep learning community: RMSprop, Adagrad, and Adam. Of the three, Adam is the most popular by far, but the others are well worth understanding, as they build in succession leading up to Adam. All three of these algorithms adapt the learning rate on the fly in some manner.</p>&#13;
<h4 class="h4" id="ch11lev2_8">RMSprop</h4>&#13;
<p class="noindent">Geoffrey Hinton introduced <em>RMSprop</em>, which stands for <em>root mean square propagation</em>, in his 2012 Coursera lecture series. Much like momentum (with which it can be combined), RMSprop is gradient descent that tracks the value of the gradient as it changes and uses that value to modify the step taken.</p>&#13;
<p class="indent">RMSprop uses a <em>decay term</em>, γ (gamma), to calculate a running average of the gradients as the algorithm progresses. In his lecture, Hinton uses γ = 0.9.</p>&#13;
<p class="indent">The gradient descent update becomes</p>&#13;
<div class="imagec" id="ch11equ07"><img src="Images/11equ07.jpg" alt="Image" width="463" height="169"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_298"/>First, we update <em>m</em>, the running average of the squares of the gradients, weighted by γ, the decay term. Next comes the velocity term, which is almost the same as in vanilla gradient descent, but we divide the learning rate by the running average’s square root, hence the RMS part of RMSprop. We then subtract the scaled velocity from the current position to take the step. We’re writing the step as an addition, similar to the momentum equations above (<a href="ch11.xhtml#ch11equ05">Equations 11.5</a> and <a href="ch11.xhtml#ch11equ06">11.6</a>); note the minus sign before the velocity update.</p>&#13;
<p class="indent">RMSprop works with momentum as well. For example, extending RMSprop with Nesterov momentum is straightforward:</p>&#13;
<div class="imagec" id="ch11equ08"><img src="Images/11equ08.jpg" alt="Image" width="486" height="169"/></div>&#13;
<p class="noindent">with <em>μ</em> the momentum factor, as before.</p>&#13;
<p class="indent">It’s claimed that RMSprop is a robust classifier. We’ll see below how it fared on one test. We’re considering it an adaptive technique because the learning rate (<em>η</em>) is scaled by the square root of the running gradient mean; therefore, the effective learning rate is adjusted based on the history of the descent—it isn’t fixed once and for all.</p>&#13;
<p class="indent">RMSprop is often used in reinforcement learning, the branch of machine learning that attempts to learn how to act. For example, playing Atari video games uses reinforcement learning. RMSprop is believed to be robust when the optimization process is <em>nonstationary</em>, meaning the statistics change in time. Conversely, a <em>stationary</em> process is one where the statistics do not change in time. Training classifiers using supervised learning is stationary, as the training set is, typically, fixed and not changing, as should be the data fed to the classifier over time, though that is harder to enforce. In reinforcement learning, time is a factor, and the statistics of the dataset might change over time; therefore, reinforcement learning might involve nonstationary optimization.</p>&#13;
<h4 class="h4" id="ch11lev2_9"><span epub:type="pagebreak" id="page_299"/>Adagrad and Adadelta</h4>&#13;
<p class="noindent"><em>Adagrad</em> appeared in 2011 (see “Adaptive Subgradient Methods for Online Learning and Stochastic Optimization” by John Duchi et al., <em>Journal of Machine Learning Research</em> 12[7], [2011]). At first glance, it looks quite similar to RMSprop, though there are important differences.</p>&#13;
<p class="indent">We can write the basic update rule for Adagrad as</p>&#13;
<div class="imagec" id="ch11equ09"><img src="Images/11equ09.jpg" alt="Image" width="463" height="134"/></div>&#13;
<p class="noindent">This requires some explanation.</p>&#13;
<p class="indent">First, notice the <em>i</em> subscript on the velocity update, both on the velocity, <em><strong>v</strong></em>, and the gradient, <em>▽f <strong>(x</strong></em>). Here, <em>i</em> refers to a component of the velocity, meaning the update must be applied per component. The top of <a href="ch11.xhtml#ch11equ09">Equation 11.9</a> repeats for all the components of the system. For a deep neural network, this means all the weights and biases.</p>&#13;
<p class="indent">Next, look at the sum in the denominator of the per-component velocity update. Here, τ (tau) is a counter over <em>all</em> the gradient steps taken during the optimization process, meaning for each component of the system, Adagrad tracks the sum of the square of the gradient calculated at each step. If we’re using <a href="ch11.xhtml#ch11equ09">Equation 11.9</a> for the 11th gradient descent step, then the sum in the denominator will have 11 terms, and so on. As before, <em>η</em> is a learning rate, which here is global to all components.</p>&#13;
<p class="indent">A variant of Adagrad is also in widespread use: <em>Adadelta</em>. (See “Adadelta: An Adaptive Learning Rate Method” by Matthew Zeiler, [2012].) Adadelta replaces the square root of the sum over all steps in the velocity update with a running average of the last few steps, much like the running average of RMSprop. Adadelta also replaces the manually selected global learning rate, <em>η</em>, with a running average of the previous few velocity updates. This eliminates the selection of an appropriate <em>η</em> but introduces a new parameter, γ, to set the window’s size, as was done for RMSprop. It’s likely that γ is less sensitive to the properties of the dataset than <em>η</em> is. Note how in the original Adadelta paper, γ is written as <em>ρ</em> (rho).</p>&#13;
<h4 class="h4" id="ch11lev2_10"><span epub:type="pagebreak" id="page_300"/>Adam</h4>&#13;
<p class="noindent">Kingma and Ba published <em>Adam</em>, from “adaptive moment estimation,” in 2015, and it has been cited over 66,000 times as of this writing. Adam uses the square of the gradient, as RMSprop and Adagrad do, but also tracks a momentum-like term. Let’s present the update equations and then walk through them:</p>&#13;
<div class="imagec" id="ch11equ10"><img src="Images/11equ10.jpg" alt="Image" width="470" height="339"/></div>&#13;
<p class="indent">The first two lines of <a href="ch11.xhtml#ch11equ10">Equation 11.10</a> define <em><strong>m</strong></em> and <em><strong>v</strong></em> as running averages of the first and second moments. The first moment is the mean; the second moment is akin to the variance, which is the second moment of the difference between a data point and the mean. Note the squaring of the gradient value in the definition of <em><strong>v</strong></em>. The running moments are weighted by two scalar parameters, <em>β</em><sub>1</sub> and <em>β</em><sub>2</sub>.</p>&#13;
<p class="indent">The next two lines define <img src="Images/300equ01.jpg" alt="Image" width="16" height="16"/> and <img src="Images/300equ02.jpg" alt="Image" width="10" height="16"/>. These are bias correction terms to make <em><strong>m</strong></em> and <em><strong>v</strong></em> better estimates of the first and second moments. Here, <em>t</em>, an integer starting at zero, is the timestep.</p>&#13;
<p class="indent">The actual step updates <em><strong>x</strong></em> by subtracting the bias-corrected first moment, <img src="Images/300equ01.jpg" alt="Image" width="16" height="16"/>, scaled by the ratio of the global learning rate, <em>η</em>, and the square root of the bias-corrected second moment, <img src="Images/300equ02.jpg" alt="Image" width="10" height="16"/>. The ∊ term is a constant to avoid division by zero.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_301"/><a href="ch11.xhtml#ch11equ10">Equation 11.10</a> has four parameters, which seems excessive, but three of them are straightforward to set and are seldom changed. The original paper suggests <em>β</em><sub>1</sub> = 0.9, <em>β</em><sub>2</sub> = 0.999, and ∊ = 10<sup>−8</sup>. Therefore, as with vanilla gradient descent, the user is left to select <em>η</em>. For example, Keras defaults to <em>η</em> = 0.001, which works well in many cases.</p>&#13;
<p class="indent">The Kingma and Ba paper shows via experiment that Adam generally outperforms SGD with Nesterov momentum, RMSprop, Adagrad, and Adadelta. This is likely why Adam is currently the go-to optimizer for many deep learning tasks.</p>&#13;
<h4 class="h4" id="ch11lev2_11">Some Thoughts About Optimizers</h4>&#13;
<p class="noindent">Which optimization algorithm to use and when depends on the dataset. As mentioned, Adam is currently favored for many tasks, though properly tuned SGD can be quite effective as well, and some swear by it. While it’s not possible to make a blanket statement about which is the best algorithm, for there is no such thing, we can conduct a little experiment and discuss the results.</p>&#13;
<p class="indent">This experiment, for which I’ll present only the results, trained a small convolutional neural network on MNIST using 16,384 random samples for the training set, a minibatch of 128, and 12 epochs. The results show the mean and standard error of the mean for five runs of each optimizer: SGD, RMSprop, Adagrad, and Adam. Of interest is the accuracy of the test set and the training clock time. I trained all models on the same machine, so relative timing is what we should look at. No GPU was used.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11fig011">Figure 11-11</a> shows the overall test set accuracy (top) and the training time (bottom) by optimizer.</p>&#13;
<p class="indent">On average, SGD and RMSprop were about 0.5 percent less accurate than the other optimizers, with RMSprop varying widely but never matching Adagrad or Adam. Arguably, Adam performed the best in terms of accuracy. For training time, SGD was the fastest and Adam the slowest, as we might expect, given the multiple per-step calculations Adam performs relative to the simplicity of SGD. Overall, the results support the community’s intuition that Adam is a good optimizer.</p>&#13;
<span epub:type="pagebreak" id="page_302"/>&#13;
<div class="image" id="ch11fig011"><img src="Images/11fig11.jpg" alt="image" width="694" height="1042"/></div>&#13;
<p class="figcap"><em>Figure 11-11: MNIST model accuracy (top) and training time (bottom) by optimizer</em></p>&#13;
<h3 class="h3" id="ch11lev1_5"><span epub:type="pagebreak" id="page_303"/>Summary</h3>&#13;
<p class="noindent">This chapter presented gradient descent, working through the basic form, vanilla gradient descent, with 1D and 2D examples. We followed by introducing stochastic gradient descent and justified its use in deep learning.</p>&#13;
<p class="indent">We discussed momentum next, both standard and Nesterov. With standard momentum, we demonstrated that it does help in training deep models (well, relatively “deep”). We showed the effect of Nesterov momentum visually using a 2D example and discussed why Nesterov momentum and stochastic gradient descent might counteract each other.</p>&#13;
<p class="indent">The chapter concluded with a look at the gradient descent update equations for advanced algorithms, thereby illustrating how vanilla gradient descent invites modification. A simple experiment gave us insight into how the algorithms perform and appeared to justify the deep learning community’s belief in Adam’s general suitability over SGD.</p>&#13;
<p class="indent">And, with this chapter, our exploration of the mathematics of deep learning draws to a close. All that remains is a final appendix that points you to places where you can go to learn more.</p>&#13;
<h3 class="h3" id="ch11lev1_6">Epilogue</h3>&#13;
<p class="noindent">As the great computer scientist Edsger W. Dijkstra said, “There should be no such thing as boring mathematics.” I sincerely hope you didn’t find this book boring. I’d hate to offend Dijkstra’s ghost. If you’re still reading at this point, I suspect you did find something of merit. Good! Thanks for sticking with it. Math should never be boring.</p>&#13;
<p class="indent">We’ve covered the basics of what you need to understand and work with deep learning. Don’t stop here, however: use the references in the Appendix and continue your mathematical explorations. You should never be satisfied with your knowledge base—always seek to broaden it.</p>&#13;
<p class="indent">If you have questions or comments, please do reach out to me at <em><a href="mailto:mathfordeeplearning@gmail.com">mathfordeeplearning@gmail.com</a></em>.<span epub:type="pagebreak" id="page_304"/></p>&#13;
</div></body></html>