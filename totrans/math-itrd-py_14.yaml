- en: '11'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CELLULAR AUTOMATA
  prefs: []
  type: TYPE_NORMAL
- en: '*I like to put a humidifier and a dehumidifier in a room and just let them
    fight it out.'
  prefs: []
  type: TYPE_NORMAL
- en: —Steven Wright*
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fintro-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Math equations are a very powerful tool for modeling things we can measure;
    equations even got us to the moon, after all. But as powerful as they are, equations
    are of limited use in the biological and social sciences because organisms don’t
    grow according to equations.
  prefs: []
  type: TYPE_NORMAL
- en: Organisms grow in an environment among many other organisms and spend their
    day performing innumerable interactions. That web of interactions determines how
    something will grow, and equations often can’t capture this complicated relationship.
    Equations can help us calculate the energy or mass converted by a single interaction
    or reaction, but to model a biological system, for example, you’d have to repeat
    that calculation hundreds or thousands of times.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there’s a tool that models how cells, organisms, and other living
    systems grow and change according to their environment. Because of their similarity
    to independent biological organisms, these models are called *cellular automata
    (CAs)*. The term *automaton* refers to something that can run on its own. [Figure
    11-1](ch11.xhtml#ch11fig1) shows two examples of cellular automata generated using
    a computer.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f226-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: An example of an elementary cellular automaton, and a screen
    full of virtual organisms*'
  prefs: []
  type: TYPE_NORMAL
- en: The CAs we’ll create in this chapter are grids made up of *cells*. Each cell
    in a CA has a number of *states* (for example, on/off, alive/dead, or colored/blank).
    Cells change according to the state of their neighbors, which allows them to grow
    and change as if they were alive!
  prefs: []
  type: TYPE_NORMAL
- en: CAs have been the subject of some study, as far back as the 1940s, but they
    really took off when computers became more commonplace. In fact, CAs can really
    only be studied using computers because, even though they follow very simple rules,
    like “if an organism doesn’t have enough neighbors, it dies,” these rules produce
    useful results only if hundreds or thousands of these organisms are created and
    allowed to run for hundreds or thousands of generations.
  prefs: []
  type: TYPE_NORMAL
- en: Because math is the study of patterns, the math topic of cellular automata is
    rife with interesting ideas, programming challenges, and endless possibilities
    for beautiful output!
  prefs: []
  type: TYPE_NORMAL
- en: CREATING A CELLULAR AUTOMATON
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a new Processing sketch and name it *cellularAutomata.pyde*. Let’s start
    with a square grid where our cells will reside. We can easily draw a 10-by-10
    grid of squares of size 20, as shown in [Listing 11-1](ch11.xhtml#ch11list1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-1: Creating a grid of squares*'
  prefs: []
  type: TYPE_NORMAL
- en: Save and run this sketch, and you should see a grid like the one shown in [Figure
    11-2](ch11.xhtml#ch11fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f227-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: A 10 × 10 grid*'
  prefs: []
  type: TYPE_NORMAL
- en: However, we need to change a bunch of numbers every time we want bigger cells,
    for example, or a grid with different dimensions. Therefore, it’s much easier
    to change things later if we use variables. Because the keywords `height`, `width`,
    and `size` already exist for the graphics window, we have to use different variable
    names. [Listing 11-2](ch11.xhtml#ch11list2) improves on [Listing 11-1](ch11.xhtml#ch11list1)
    by creating a grid that’s easy to resize, with cells that are also easy to resize—all
    by using variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-2: Improved grid program using variables*'
  prefs: []
  type: TYPE_NORMAL
- en: We create variables for the height (`GRID_H`) and width (`GRID_W`) of the grid
    using all capital letters to indicate that these are constants and their values
    won’t be changing. The size of the cell is also a constant (for now), so we capitalize
    it as well (`SZ`) when declaring its initial value. Now when you run this code,
    you should see a larger grid, like the one shown in [Figure 11-3](ch11.xhtml#ch11fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f228-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: A larger grid, made with variables*'
  prefs: []
  type: TYPE_NORMAL
- en: WRITING A CELL CLASS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We need to write a class because every cell we create needs its own location,
    state (“on” or “off”), neighbors (the cells next to it), and so on. We create
    the `Cell` class by adding the code shown in [Listing 11-3](ch11.xhtml#ch11list3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-3: Creating the `Cell` class*'
  prefs: []
  type: TYPE_NORMAL
- en: The cell’s initial `state` property is 0 (or off). The code `state=0` in the
    parameters of the `__init__` method means that if we don’t specify a state, `state`
    is set to 0\. The `display()` method just tells the `Cell` object how to display
    itself on the screen. If it’s “on,” the cell is black; otherwise, it’s white.
    Also, each cell is a square, and we need to spread out the cells by multiplying
    their column and row numbers by their size (`self.SZ`).
  prefs: []
  type: TYPE_NORMAL
- en: After the `draw()` function, we need to write a function to create an empty
    list to put our `Cell` objects in and use a nested loop to append these `Cell`
    objects to the list instead of drawing them one by one, as shown in [Listing 11-4](ch11.xhtml#ch11list4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-4: Function for creating a list of cells*'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create an empty list called `newList` ➊ and add an empty list as a
    row ➋ to be filled in with `Cell` objects ➌. Then, we get the index of the center
    square by dividing the number of rows and columns by 2 (the double slash means
    integer division) and setting that cell’s `state` property to 1 (or “on”) ➍.
  prefs: []
  type: TYPE_NORMAL
- en: In `setup()`, we’ll use the `createCellList()` function and declare `cellList`
    as a global variable so it can be used in the `draw()` function. Finally, in `draw()`,
    we’ll loop over each row in `cellList` and update it. The new `setup()` and `draw()`
    functions are shown in [Listing 11-5](ch11.xhtml#ch11list5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-5: The new `setup()` and `draw()` functions for creating a grid*'
  prefs: []
  type: TYPE_NORMAL
- en: However, when we run this code, we get a grid with smaller cells in the corner
    of the display window, as shown in [Figure 11-4](ch11.xhtml#ch11fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f230-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: A grid of cells that’s not yet centered*'
  prefs: []
  type: TYPE_NORMAL
- en: Now we’re able to make as big or small a list of cells as we want by changing
    the size of our 15-by-15 grid.
  prefs: []
  type: TYPE_NORMAL
- en: RESIZING EACH CELL
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To resize our cells, we can make `SZ` automatically dependent on the width of
    the window. Right now the width is 600, so let’s change `setup()` using the code
    in [Listing 11-6](ch11.xhtml#ch11list6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-6: Resizing the cells to autofit the display window*'
  prefs: []
  type: TYPE_NORMAL
- en: The double forward slash (`//`) means *integer division*, which returns only
    the integer part of the quotient. Now, when you run the program, it should produce
    a grid with all empty cells except for one colored cell in the center, like in
    [Figure 11-5](ch11.xhtml#ch11fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f231-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: Grids with the center cell “on”*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that this code works better when you add 1 to `SZ`, the size of the `Cell`,
    as in Listing 11-16, because otherwise the grid sometimes doesn’t fill the whole
    display window. But feel free to leave it out.
  prefs: []
  type: TYPE_NORMAL
- en: MAKING A CA GROW
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we want to make the cells change according to the number of their neighbors
    whose state is “on.” This section was inspired by a two-dimensional CA from Stephen
    Wolfram’s *New Kind of Science*. You can see how a version of this CA grows in
    [Figure 11-6](ch11.xhtml#ch11fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f231-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: Stages of growth of a cellular automaton*'
  prefs: []
  type: TYPE_NORMAL
- en: In this design, if a cell has *one or four* neighbors that are on, we make it
    turn on (and stay on).
  prefs: []
  type: TYPE_NORMAL
- en: PUTTING THE CELLS INTO A MATRIX
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s easy to find the cells immediately before and after a cell in the list,
    which gives us the neighbors to its left and right. But how do we find the neighbors
    above and below a cell? To do this more easily, we can put the cells in a two-dimensional
    *array* or *matrix*, which is a list with lists for the rows. That way, if a cell
    is in column 5, for example, we know that its “above” and “below” neighbors will
    also be in column 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Cell` class, we add a method called `checkNeighbors()` so that a cell
    can count how many of its neighbors are on, and if the count is 1 or 4, that cell
    will return 1 for “on.” Otherwise, it returns 0 for “off.” We begin by checking
    the neighbor above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code checks for the item in `cellList` that’s in the same column (`self.c`)
    but in the previous row (`self.r – 1`). If that item’s `state` property is 1,
    then it’s on, and we increment the `neighbs` variable by 1\. Then we have to do
    the same for the cell’s neighbor below, and then for the neighbors to the left
    and right. Do you see an easy pattern here?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We only need to keep track of the change in the row number and the change in
    the column number. There are only four directions we need to check, for the “one
    to the left, one to the right” neighbors, and so on: `[-1,0]`, `[1,0]`, `[0,-1]`
    and `[0,1]`. If we call those `dr` and `dc` (*d*, or the Greek letter *delta*,
    is the traditional math symbol for change), we can keep from repeating ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if the neighbor count is 1 or 4, the `state` property will be set to
    1\. In Python, `if neighbs in [1,4]` is the same as saying `if neighbs == 1 or
    neighbs == 4:`.
  prefs: []
  type: TYPE_NORMAL
- en: CREATING THE CELL LIST
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So far, we’ve created the cell list by running the `createCellList()` function
    in `setup()` and assigning the output to `cellList`, and we’ve gone through every
    row in `cellList` and updated each cell in the row. Now we have to check whether
    the rules work. The four squares surrounding the center cell should change state
    in the next step. That means we’ll have to run the `checkNeighbors()` method and
    then show the result. Update your `draw()` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The updated line ➊ runs all the `checkNeighbors()` code and sets the cell on
    or off according to the result. Run it, and you should get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The error is in the line that checks the neighbor to the right. Sure enough,
    because there are only 15 cells in a row, it makes sense that the 15th cell has
    no neighbor to the right.
  prefs: []
  type: TYPE_NORMAL
- en: If a cell has no neighbor to the right (meaning its column number is `GRID_W`
    minus one), we obviously don’t need to check that neighbor and can continue on
    to the next cell. The same for checking the neighbor above the cells in row 0,
    because they have no cells above them. Similarly, the cells in column 0 have no
    neighbors to the left, and the cells in row 14 (`GRID_H` minus 1) have no cells
    below them. In [Listing 11-7](ch11.xhtml#ch11list7), we add a valuable Python
    trick called *exception handling* to the `checkNeighbors()` method using the keywords
    `try` and `except`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-7: Adding conditionals to `checkNeighbors()`*'
  prefs: []
  type: TYPE_NORMAL
- en: The `try` keyword ➊ literally means “try to run this next line of code.” In
    the earlier error message, we got an `IndexError`. We use the `except` keyword ➋
    to mean “if you get this error, do this.” Therefore, if we get an `IndexError`,
    we continue on to the next loop. Run this code, and you’ll get something interesting,
    as shown in [Figure 11-7](ch11.xhtml#ch11fig7). This is definitely not what we
    saw in [Figure 11-6](ch11.xhtml#ch11fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f234-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: Not what we expected!*'
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that we’re checking neighbors and changing the state of the current
    cell. Then the cell’s neighbors are checking their neighbors, but they’re checking
    the new state of their neighbors. We want all the cells to check their neighbors
    and save the information in a new list; then, when all the cells are done, we
    can update the grid all at once. That calls for another list for our cells, `newList`,
    that will replace `cellList` at the end of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: So all we need to do is declare that `newList` is equal to `cellList`, right?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Although that seems to make sense, Python doesn’t copy the contents of `newList`
    over the previous contents of `cellList`, which is what you might have expected.
    It technically refers to the `newList`, but when you change `newList`, you end
    up changing `cellList` as well.
  prefs: []
  type: TYPE_NORMAL
- en: PYTHON LISTS ARE STRANGE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python lists have an odd behavior. Let’s say you declare a list and set another
    one equal to it, and then you change the first list. You wouldn’t expect the second
    one to change too, but that’s exactly what happens, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we created list `a`, then assigned the value of list `a` to
    list `b`. When we change list `a` without updating list `b`, Python also changes
    list `b`!
  prefs: []
  type: TYPE_NORMAL
- en: LIST INDEX NOTATION
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One way to make sure when we’re updating one list that we’re not updating another
    one accidentally is to use index notation. Giving list `b` all the contents of
    list `a` should prevent this from happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use `b = a[::]` to say “assign all the contents inside list `a` to
    the variable `b`,” as opposed to simply declaring that list `a` is equal to list
    `b`. This way, the lists aren’t linked to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we declare `SZ`, we need to add the following line of code to declare
    the initial value of the `generation` variable, which will keep track of which
    generation we’re looking at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We’re going to avoid the list reference problem by using the index notation
    at the end of the updating code. Let’s create a new `update()` function after
    `draw()` so that all the updating will be done in that separate function. [Listing
    11-8](ch11.xhtml#ch11list8) shows how your `setup()` and `draw()` functions should
    look.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-8: Checking whether the updating is working and then stopping after
    three generations*'
  prefs: []
  type: TYPE_NORMAL
- en: We create the first `cellList` once in the `setup()` function and then declare
    it a global variable so we can use it in other functions. In the `draw()` function,
    we use the `generation` variable for however many generations we want to check
    (in this case, three); then we make a call to update the `cellList`. We draw the
    cells as before, using the `display()` method, and then increment `generation`
    and check whether it has reached our desired generation. If it has, the built-in
    Processing function `noLoop()` stops the loop.
  prefs: []
  type: TYPE_NORMAL
- en: We use `noLoop()` to turn off the infinite loop, because we only want to draw
    the given number of generations. If you comment it out, the program will keep
    going! [Figure 11-8](ch11.xhtml#ch11fig8) shows what the CA looks like after three
    generations.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f236-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-8: A working CA!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s great about using variables for our grid size is that we can change
    the CA drastically by simply changing the `GRID_W` and `GRID_H` variables, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If we increase the number of generations to 13 (in the line that currently reads
    `if generation == 3`), the output should look like [Figure 11-9](ch11.xhtml#ch11fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f237-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-9: Our CA at a higher level, with a grid (left) and without a grid
    (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove the grid around the empty cells in the CA, simply add this line to
    the `setup()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That should turn off the outline around the squares, but the fill color will
    still be drawn, like [Figure 11-9](ch11.xhtml#ch11fig9).
  prefs: []
  type: TYPE_NORMAL
- en: So far we’ve done a lot! We’ve created two-dimensional lists, filled them with
    cells, and turned on certain cells according to a simple rule. Then we updated
    the cells and displayed them. The CA just keeps growing!
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 11-1: MANUALLY GROWING THE CA'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `keyPressed()` function you learned about in [Chapter 10](ch10.xhtml#ch10)
    to manually grow the CA.
  prefs: []
  type: TYPE_NORMAL
- en: '#### LETTING YOUR CA GROW AUTOMATICALLY'
  prefs: []
  type: TYPE_NORMAL
- en: If you want the CA to cycle from level 0 to a maximum number of generations
    (you choose the right number for your window), simply change the `draw()` function
    to what’s shown in [Listing 11-9](ch11.xhtml#ch11list9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-9: Making the CA grow and regrow automatically*'
  prefs: []
  type: TYPE_NORMAL
- en: To slow down the animation, we use Processing’s built-in `frameRate()` function
    ➊. The default is 60 frames per second, so here we slowed it down to 10\. Then
    we tell the program that if the `generation` variable reaches 30 ➋ (you can change
    this to another number), reset `generation` to 1, and create a new `cellList`.
    Now you should be able to watch the CA grow as quickly or slowly as you want.
    Change the rule and see how that changes the CA. You can change the colors too!
  prefs: []
  type: TYPE_NORMAL
- en: We’ve just taken a simple rule (if a cell has 1 or 4 neighbors, it’s “on”) and
    wrote a program to apply that rule to thousands of cells at once! The result looks
    like a living, growing organism. Now we’ll expand our code into a famous CA where
    the virtual organisms can move around, grow, and die!
  prefs: []
  type: TYPE_NORMAL
- en: PLAYING THE GAME OF LIFE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a 1970 issue of *Scientific American*, math popularizer Martin Gardner brought
    attention to a strange and wonderful game where cells live or die according to
    how many neighbors they have. The brainchild of English mathematician John Conway,
    this game features three simple rules:'
  prefs: []
  type: TYPE_NORMAL
- en: If a living cell has less than two living neighbors, it dies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a living cell has more than three living neighbors, it dies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a dead cell has exactly three living neighbors, it comes to life.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With a simple set of rules like that, it’s surprising how intricate this game
    gets. In 1970, most people could only use checkers on a board to visualize the
    game, and one generation could take quite a while to calculate. Conveniently,
    we have a computer, and the CA code we just wrote has most of the code necessary
    to create this game in Python. Save the CA file we’ve been working on so far and
    then save it with different name, like *GameOfLife*.
  prefs: []
  type: TYPE_NORMAL
- en: In this game, our cells will have diagonal neighbors too. That means we have
    to add four more values to our `dr,dc` line. [Listing 11-10](ch11.xhtml#ch11list10)
    shows the changes you need to make to the `checkNeighbors()` code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-10: Changes to the `checkNeighbors()` code to include diagonal
    neighbors*'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add four values ➊ to check the diagonal neighbors: `[-1,-1]` for
    the neighbor to the left and up, `[1,1]` for the neighbor to the right and down,
    and so on. Then we tell the program that if the cell is on ➋, check if it has
    two or three neighbors that are also on. If so, we tell the program to return
    1, and if not, we tell the program to return 0\. Otherwise, if the cell is off,
    we tell it to check if it has three neighbors that are on. If it does, return
    1; if doesn’t, return 0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we place living cells randomly around the grid, so we have to import the
    `choice()` function from Python’s `random` module. Add this line to the top of
    the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we use the `choice()` function to randomly choose whether a new `Cell`
    is on or off. So all we have to do is change the `append` line in the `createCellList()`
    function to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we no longer need the generation code from the previous file. The remaining
    code in the `draw()` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Run this code, and you’ll see a wild, dynamic game play out, where organisms
    are moving, morphing, splitting, and interacting with other organisms, like in
    [Figure 11-10](ch11.xhtml#ch11fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f240-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-10: The Game of Life in action!*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s interesting how the “clouds” of cells morph, move, and collide with other
    clouds (families? colonies?). Some organisms wander around the screen until, eventually,
    the grid will settle into a kind of equilibrium. [Figure 11-11](ch11.xhtml#ch11fig11)
    shows an example of that kind of equilibrium.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f240-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-11: An example of the Game of Life that has entered a stable state*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example of a state of equilibrium, some shapes appear stable and unmoving,
    while other shapes become stuck in repeating patterns.
  prefs: []
  type: TYPE_NORMAL
- en: THE ELEMENTARY CELLULAR AUTOMATON
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This last CA is really cool and involves a little more math, but it’s still
    a simple pattern that’s extended, though only in one dimension (which is why it’s
    called an “elementary CA”). We start off with one row of cells and set the middle
    cell’s state to one, as shown in [Figure 11-12](ch11.xhtml#ch11fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f241-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-12: The first row of an elementary CA*'
  prefs: []
  type: TYPE_NORMAL
- en: This is easy to code. Start a new Processing sketch and call it *elementaryCA.pyde*.
    The code to draw the first row of cells is shown in [Listing 11-11](ch11.xhtml#ch11list11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-11: Drawing the first row (generation) of the elementary CA*'
  prefs: []
  type: TYPE_NORMAL
- en: First, we declare a few important variables ➊, such as the size of each cell
    and the number of rows and columns in our CA. Next, we start our `cells` list
    ➋. We create `rows` number of rows and append `cols` number of 0’s in each list
    inside `cells`. We set the middle cell in the row to 1 (or on) ➌. In the `draw()`
    function, we loop through the rows (there will be more than one row soon!) and
    columns using `enumerate`. We check if the element is a 1, and if so, we color
    it black ➍. Otherwise, we color it white. Finally, we draw the square for the
    cell ➎. The x-value looks a bit complicated, but this just makes sure the CA is
    always centered.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this code, you should see what’s shown in [Figure 11-12](ch11.xhtml#ch11fig12):
    a row of cells with one “on” cell in the center. The state of the cells in the
    next row of the CA will depend on the rules we set up for a cell and its two neighbors.
    How many possibilities are there? Each cell has two possible states (1 or 0, or
    “on” or “off”) so that’s two states for the left neighbor, two for the center
    cell, and two for the right neighbor. That’s 2 × 2 × 2 = 8 possibilities. All
    the combinations are shown in [Figure 11-13](ch11.xhtml#ch11fig13).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f242-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-13: All the possible combinations of a cell and its two neighbors*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first possibility is that the center cell is on and both its neighbors
    are on. The next possibility is that the center cell is on, the left neighbor
    is on, and the right neighbor is off—and so on. This order is very important.
    (Do you see the pattern?) How are we going to describe these possibilities to
    the computer program? We could write eight conditional statements like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: But there’s an easier way. In A *New Kind of Science*, Stephen Wolfram assigns
    numbers to the possibilities according to the binary number the three cells represent.
    Keeping in mind that 1 is on and 0 is off, you can see that 111 is 7 in binary,
    110 is 6 in binary, and so on, as illustrated in [Figure 11-14](ch11.xhtml#ch11fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f242-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-14: The numbering method for the eight possibilities*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve numbered each possibility, we can create a rule set—that is,
    a list that will contain the rules for what to do with each possibility in the
    next generation. Notice the numbers are like the indices of a list, except backwards.
    We can easily get around that. We can assign a result to each one randomly or
    because of some plan. [Figure 11-15](ch11.xhtml#ch11fig15) shows one set of results.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f242-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-15: A set of results assigned to each possibility in the CA*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The box under each possibility signifies the result, or the state of the cell
    in the next generation of the CA. The white box under “possibility 7” on the left
    means “if the cell is on and both of its neighbors are on, it will be off in the
    next generation.” Same for the next two possibilities (which don’t exist in our
    CA so far): the result is “off.” As illustrated earlier in [Figure 11-12](ch11.xhtml#ch11fig12),
    we have a lot of “off” cells surrounded by “off” cells, which is the possibility
    shown on the far right of [Figure 11-14](ch11.xhtml#ch11fig14): three white squares.
    In this case, the cell in the middle will be off in the next generation. We also
    have one “on” cell surrounded by two “off” cells (possibility 5). In the next
    generation, the cell will be on. We’ll use 0’s and 1’s for our `ruleset` list,
    as illustrated in [Figure 11-16](ch11.xhtml#ch11fig16).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f243-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-16: Putting the rules for generating the next row into a list*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll collect all these numbers into a list called `ruleset`, which we’ll add
    just before the `setup()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The order of the possibilities is important because this rule set is referred
    to as “Rule 30” (00011110 is 30 in binary). Our task is to create the next row
    according to the rules. Let’s create a `generate()` function that looks at the
    first row and generates the second row, then looks at the second row and generates
    the third row, and so on. Add the code shown in [Listing 11-12](ch11.xhtml#ch11list12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 11-12: Writing the `generate()` function to generate new rows in the
    CA*'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we make the CA larger by updating the number of rows and columns ➊.
    Next, we create the `rules()` function ➋, which takes three parameters: the left
    neighbor’s number, the current cell’s number, and the right neighbor’s number.
    The function checks the `ruleset` and returns the value for the cell in the next
    generation. We make use of the binary numbers, and the line `4*a + 2*b + c` converts
    “1,1,1” to 7 and “1,1,0” to 6, and so on. However, as you’ll recall from [Figure
    11-15](ch11.xhtml#ch11fig15), the indices are in reverse order, so we subtract
    the total from 7 to get the proper index of the `ruleset`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line to the end of the `setup()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This creates the full CA and not just the first row. When you run this code,
    you should see the first 10 rows of a CA made using “Rule 30,” as illustrated
    in [Figure 11-17](ch11.xhtml#ch11fig17).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f244-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-17: The first 10 rows of Rule 30*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f244-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-18: More of Rule 30*'
  prefs: []
  type: TYPE_NORMAL
- en: The program is going through each row, starting at the top, and generating the
    next row according to the rules we gave it in the `ruleset`. What if we keep going?
    Change the number of rows and columns to 1000 and the width (`w`) of each cell
    to 3\. Add `noStroke()` to the `setup()` function to get rid of the outline of
    the cells, and then run the sketch. You should see what’s in [Figure 11-18](ch11.xhtml#ch11fig18).
  prefs: []
  type: TYPE_NORMAL
- en: Rule 30 is a fascinating design because it’s not completely random, but it’s
    not completely regular either. Rule 73 is also cool; in fact a woman named Fabienne
    Serriere programs the rule into a knitting machine to create scarves with the
    pattern, like in [Figure 11-19](ch11.xhtml#ch11fig19). You can order scarves with
    this and other algorithmically generated rules on them from *[https://knityak.com/](https://knityak.com/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f245-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-19: A scarf whose design is a cellular automaton: Rule 73!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 11-2: CHANGING THE RULE SET'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change `ruleset` to the binary form of the number 90\. What does the resulting
    CA look like? Hint: it’s a fractal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 11-3: ZOOMING IN AND OUT'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `keyPressed()` function you learned about in [Chapter 10](ch10.xhtml#ch10)
    to change the value of the width variable `w` using the up and down arrow keys.
    This should let you zoom in and out of the CA!
  prefs: []
  type: TYPE_NORMAL
- en: '### SUMMARY'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned to use Python to create cellular automata, or cells
    that act independently, according to specific rules. We wrote programs to make
    a huge grid of these cells follow certain rules and update themselves, generation
    after generation, and we created unexpectedly beautiful designs and surprisingly
    life-like behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll create virtual organisms that solve problems for
    us! These organisms will be able to guess a secret phrase and find the shortest
    route through a bunch of cities just by evolving better and better solutions.
  prefs: []
  type: TYPE_NORMAL
