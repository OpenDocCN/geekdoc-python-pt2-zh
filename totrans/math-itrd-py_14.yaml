- en: '11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CELLULAR AUTOMATA
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '*I like to put a humidifier and a dehumidifier in a room and just let them
    fight it out.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: —Steven Wright*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fintro-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
- en: Math equations are a very powerful tool for modeling things we can measure;
    equations even got us to the moon, after all. But as powerful as they are, equations
    are of limited use in the biological and social sciences because organisms don’t
    grow according to equations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Organisms grow in an environment among many other organisms and spend their
    day performing innumerable interactions. That web of interactions determines how
    something will grow, and equations often can’t capture this complicated relationship.
    Equations can help us calculate the energy or mass converted by a single interaction
    or reaction, but to model a biological system, for example, you’d have to repeat
    that calculation hundreds or thousands of times.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there’s a tool that models how cells, organisms, and other living
    systems grow and change according to their environment. Because of their similarity
    to independent biological organisms, these models are called *cellular automata
    (CAs)*. The term *automaton* refers to something that can run on its own. [Figure
    11-1](ch11.xhtml#ch11fig1) shows two examples of cellular automata generated using
    a computer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f226-01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: An example of an elementary cellular automaton, and a screen
    full of virtual organisms*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The CAs we’ll create in this chapter are grids made up of *cells*. Each cell
    in a CA has a number of *states* (for example, on/off, alive/dead, or colored/blank).
    Cells change according to the state of their neighbors, which allows them to grow
    and change as if they were alive!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: CAs have been the subject of some study, as far back as the 1940s, but they
    really took off when computers became more commonplace. In fact, CAs can really
    only be studied using computers because, even though they follow very simple rules,
    like “if an organism doesn’t have enough neighbors, it dies,” these rules produce
    useful results only if hundreds or thousands of these organisms are created and
    allowed to run for hundreds or thousands of generations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Because math is the study of patterns, the math topic of cellular automata is
    rife with interesting ideas, programming challenges, and endless possibilities
    for beautiful output!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: CREATING A CELLULAR AUTOMATON
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open a new Processing sketch and name it *cellularAutomata.pyde*. Let’s start
    with a square grid where our cells will reside. We can easily draw a 10-by-10
    grid of squares of size 20, as shown in [Listing 11-1](ch11.xhtml#ch11list1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 11-1: Creating a grid of squares*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Save and run this sketch, and you should see a grid like the one shown in [Figure
    11-2](ch11.xhtml#ch11fig2).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f227-01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: A 10 × 10 grid*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: However, we need to change a bunch of numbers every time we want bigger cells,
    for example, or a grid with different dimensions. Therefore, it’s much easier
    to change things later if we use variables. Because the keywords `height`, `width`,
    and `size` already exist for the graphics window, we have to use different variable
    names. [Listing 11-2](ch11.xhtml#ch11list2) improves on [Listing 11-1](ch11.xhtml#ch11list1)
    by creating a grid that’s easy to resize, with cells that are also easy to resize—all
    by using variables.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，每次我们想要更大的单元格，或者一个维度不同的网格时，都需要更改一堆数字。因此，如果我们使用变量，稍后修改起来会更容易。由于`height`、`width`
    和 `size` 这些关键字已经用于图形窗口，我们需要使用不同的变量名。[列表 11-2](ch11.xhtml#ch11list2)通过创建一个易于调整大小的网格来改进[列表
    11-1](ch11.xhtml#ch11list1)，同时这些单元格也易于调整大小——这一切都通过使用变量来实现。
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 11-2: Improved grid program using variables*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-2：使用变量改进的网格程序*'
- en: We create variables for the height (`GRID_H`) and width (`GRID_W`) of the grid
    using all capital letters to indicate that these are constants and their values
    won’t be changing. The size of the cell is also a constant (for now), so we capitalize
    it as well (`SZ`) when declaring its initial value. Now when you run this code,
    you should see a larger grid, like the one shown in [Figure 11-3](ch11.xhtml#ch11fig3).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为网格的高度（`GRID_H`）和宽度（`GRID_W`）创建变量，使用大写字母表示这些是常量，并且它们的值不会变化。单元格的大小也是一个常量（目前如此），因此在声明其初始值时我们也将其大写（`SZ`）。现在，当你运行这段代码时，你应该能看到一个更大的网格，像[图
    11-3](ch11.xhtml#ch11fig3)中所示的那样。
- en: '![image](../images/f228-01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f228-01.jpg)'
- en: '*Figure 11-3: A larger grid, made with variables*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-3：使用变量创建的更大的网格*'
- en: WRITING A CELL CLASS
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写一个单元格类
- en: We need to write a class because every cell we create needs its own location,
    state (“on” or “off”), neighbors (the cells next to it), and so on. We create
    the `Cell` class by adding the code shown in [Listing 11-3](ch11.xhtml#ch11list3).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写一个类，因为我们创建的每个单元格都需要有自己的位置、状态（“开”或“关”）、邻居（它旁边的单元格）等等。我们通过添加[列表 11-3](ch11.xhtml#ch11list3)中所示的代码来创建`Cell`类。
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 11-3: Creating the `Cell` class*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-3：创建`Cell`类*'
- en: The cell’s initial `state` property is 0 (or off). The code `state=0` in the
    parameters of the `__init__` method means that if we don’t specify a state, `state`
    is set to 0\. The `display()` method just tells the `Cell` object how to display
    itself on the screen. If it’s “on,” the cell is black; otherwise, it’s white.
    Also, each cell is a square, and we need to spread out the cells by multiplying
    their column and row numbers by their size (`self.SZ`).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 单元格的初始`state`属性为0（即关闭）。`__init__`方法中的`state=0`代码意味着如果我们没有指定状态，`state`将被设置为0。`display()`方法只是告诉`Cell`对象如何在屏幕上显示自己。如果它是“开”的，单元格将显示为黑色；否则，显示为白色。此外，每个单元格都是正方形的，我们需要通过将其列和行号乘以它们的大小（`self.SZ`）来将单元格分开。
- en: After the `draw()` function, we need to write a function to create an empty
    list to put our `Cell` objects in and use a nested loop to append these `Cell`
    objects to the list instead of drawing them one by one, as shown in [Listing 11-4](ch11.xhtml#ch11list4).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw()`函数之后，我们需要写一个函数来创建一个空列表，用于存放我们的`Cell`对象，并使用嵌套循环将这些`Cell`对象添加到列表中，而不是像之前一样一个一个地绘制它们，如[列表
    11-4](ch11.xhtml#ch11list4)所示。
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 11-4: Function for creating a list of cells*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-4：创建单元格列表的函数*'
- en: First, we create an empty list called `newList` ➊ and add an empty list as a
    row ➋ to be filled in with `Cell` objects ➌. Then, we get the index of the center
    square by dividing the number of rows and columns by 2 (the double slash means
    integer division) and setting that cell’s `state` property to 1 (or “on”) ➍.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`newList`的空列表 ➊，并添加一个空列表作为一行 ➋，这个列表将填充`Cell`对象 ➌。然后，我们通过将行数和列数除以
    2（双斜杠表示整数除法）来获取中心单元格的索引，并将该单元格的`state`属性设置为1（即“开”） ➍。
- en: In `setup()`, we’ll use the `createCellList()` function and declare `cellList`
    as a global variable so it can be used in the `draw()` function. Finally, in `draw()`,
    we’ll loop over each row in `cellList` and update it. The new `setup()` and `draw()`
    functions are shown in [Listing 11-5](ch11.xhtml#ch11list5).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setup()`中，我们将使用`createCellList()`函数，并将`cellList`声明为全局变量，这样它就可以在`draw()`函数中使用。最后，在`draw()`中，我们将循环遍历`cellList`中的每一行并更新它。新的`setup()`和`draw()`函数见[列表
    11-5](ch11.xhtml#ch11list5)。
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 11-5: The new `setup()` and `draw()` functions for creating a grid*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-5：用于创建网格的新的`setup()`和`draw()`函数*'
- en: However, when we run this code, we get a grid with smaller cells in the corner
    of the display window, as shown in [Figure 11-4](ch11.xhtml#ch11fig4).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们运行这段代码时，我们得到的是一个显示窗口角落里有更小单元格的网格，像[图 11-4](ch11.xhtml#ch11fig4)中所示的那样。
- en: '![image](../images/f230-01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f230-01.jpg)'
- en: '*Figure 11-4: A grid of cells that’s not yet centered*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-4：尚未居中的单元格网格*'
- en: Now we’re able to make as big or small a list of cells as we want by changing
    the size of our 15-by-15 grid.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过改变 15x15 网格的大小，来创建我们想要的任意大小的单元格列表。
- en: RESIZING EACH CELL
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调整每个单元格的大小
- en: To resize our cells, we can make `SZ` automatically dependent on the width of
    the window. Right now the width is 600, so let’s change `setup()` using the code
    in [Listing 11-6](ch11.xhtml#ch11list6).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调整单元格的大小，我们可以让 `SZ` 自动依赖于窗口的宽度。现在宽度是 600，所以我们可以按照[列表 11-6](ch11.xhtml#ch11list6)中的代码修改
    `setup()` 函数。
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 11-6: Resizing the cells to autofit the display window*'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-6：调整单元格大小以自动适应显示窗口*'
- en: The double forward slash (`//`) means *integer division*, which returns only
    the integer part of the quotient. Now, when you run the program, it should produce
    a grid with all empty cells except for one colored cell in the center, like in
    [Figure 11-5](ch11.xhtml#ch11fig5).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 双斜杠 (`//`) 表示 *整数除法*，它只返回商的整数部分。现在，当你运行程序时，它应该会生成一个网格，除了中心有一个彩色单元格外，其他单元格都是空的，像在[图
    11-5](ch11.xhtml#ch11fig5)中那样。
- en: '![image](../images/f231-01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f231-01.jpg)'
- en: '*Figure 11-5: Grids with the center cell “on”*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-5：中心单元格为“开启”的网格*'
- en: Note that this code works better when you add 1 to `SZ`, the size of the `Cell`,
    as in Listing 11-16, because otherwise the grid sometimes doesn’t fill the whole
    display window. But feel free to leave it out.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当你像在列表 11-16 中那样将 `SZ` （单元格的大小）加 1 时，这段代码的效果会更好，因为如果不加，网格有时无法填满整个显示窗口。但你也可以选择不加。
- en: MAKING A CA GROW
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 让 CA 生长
- en: Now we want to make the cells change according to the number of their neighbors
    whose state is “on.” This section was inspired by a two-dimensional CA from Stephen
    Wolfram’s *New Kind of Science*. You can see how a version of this CA grows in
    [Figure 11-6](ch11.xhtml#ch11fig6).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们希望根据邻居的状态为“开启”的数量来改变单元格的状态。本部分灵感来源于斯蒂芬·沃尔夫拉姆（Stephen Wolfram）的《新科学》中描述的二维
    CA。你可以在[图 11-6](ch11.xhtml#ch11fig6)中看到这个 CA 的一个版本是如何生长的。
- en: '![image](../images/f231-02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f231-02.jpg)'
- en: '*Figure 11-6: Stages of growth of a cellular automaton*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-6：细胞自动机的生长阶段*'
- en: In this design, if a cell has *one or four* neighbors that are on, we make it
    turn on (and stay on).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中，如果一个单元格有 *一个或四个* 开启的邻居，我们就让它变为开启状态（并保持开启）。
- en: PUTTING THE CELLS INTO A MATRIX
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将单元格放入矩阵中
- en: It’s easy to find the cells immediately before and after a cell in the list,
    which gives us the neighbors to its left and right. But how do we find the neighbors
    above and below a cell? To do this more easily, we can put the cells in a two-dimensional
    *array* or *matrix*, which is a list with lists for the rows. That way, if a cell
    is in column 5, for example, we know that its “above” and “below” neighbors will
    also be in column 5.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易找到列表中该单元格前后紧挨的单元格，这样我们就能得到它左边和右边的邻居。那么，如何找到单元格上方和下方的邻居呢？为了更容易做到这一点，我们可以将单元格放入一个二维
    *数组* 或 *矩阵* 中，这是一种每一行都是列表的列表。这样，如果一个单元格位于第 5 列，我们就知道它的“上方”和“下方”邻居也会在第 5 列。
- en: 'In the `Cell` class, we add a method called `checkNeighbors()` so that a cell
    can count how many of its neighbors are on, and if the count is 1 or 4, that cell
    will return 1 for “on.” Otherwise, it returns 0 for “off.” We begin by checking
    the neighbor above:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Cell` 类中，我们添加了一个名为 `checkNeighbors()` 的方法，使得单元格能够统计有多少邻居是开启状态的。如果开启邻居的数量是
    1 或 4，那么该单元格将返回 1 表示“开启”。否则，它返回 0 表示“关闭”。我们从检查上方的邻居开始：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code checks for the item in `cellList` that’s in the same column (`self.c`)
    but in the previous row (`self.r – 1`). If that item’s `state` property is 1,
    then it’s on, and we increment the `neighbs` variable by 1\. Then we have to do
    the same for the cell’s neighbor below, and then for the neighbors to the left
    and right. Do you see an easy pattern here?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码检查 `cellList` 中与当前单元格在同一列（`self.c`）但位于上一行（`self.r – 1`）的项。如果该项的 `state`
    属性是 1，那么它是开启状态，我们将 `neighbs` 变量加 1。然后，我们需要对该单元格下面的邻居进行相同的操作，再对左侧和右侧的邻居进行相同操作。你能在这里看到简单的规律吗？
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We only need to keep track of the change in the row number and the change in
    the column number. There are only four directions we need to check, for the “one
    to the left, one to the right” neighbors, and so on: `[-1,0]`, `[1,0]`, `[0,-1]`
    and `[0,1]`. If we call those `dr` and `dc` (*d*, or the Greek letter *delta*,
    is the traditional math symbol for change), we can keep from repeating ourselves:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要跟踪行号和列号的变化。我们只需检查四个方向，对于“左边一个，右边一个”邻居，依此类推：`[-1,0]`、`[1,0]`、`[0,-1]` 和
    `[0,1]`。如果我们把它们叫做 `dr` 和 `dc`（*d*，或希腊字母*delta*，是表示变化的传统数学符号），我们就可以避免重复自己：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Finally, if the neighbor count is 1 or 4, the `state` property will be set to
    1\. In Python, `if neighbs in [1,4]` is the same as saying `if neighbs == 1 or
    neighbs == 4:`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果邻居数量是1或4，`state` 属性将被设置为1。在 Python 中，`if neighbs in [1,4]` 等同于说 `if neighbs
    == 1 or neighbs == 4:`。
- en: CREATING THE CELL LIST
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建单元格列表
- en: 'So far, we’ve created the cell list by running the `createCellList()` function
    in `setup()` and assigning the output to `cellList`, and we’ve gone through every
    row in `cellList` and updated each cell in the row. Now we have to check whether
    the rules work. The four squares surrounding the center cell should change state
    in the next step. That means we’ll have to run the `checkNeighbors()` method and
    then show the result. Update your `draw()` function as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过在 `setup()` 中运行 `createCellList()` 函数并将输出赋值给 `cellList` 来创建了单元格列表，接着我们遍历了
    `cellList` 中的每一行并更新了每个单元格。现在我们需要检查规则是否有效。围绕中心单元格的四个方格应该在下一步中改变状态。这意味着我们需要运行 `checkNeighbors()`
    方法，然后显示结果。请按照以下方式更新你的 `draw()` 函数：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The updated line ➊ runs all the `checkNeighbors()` code and sets the cell on
    or off according to the result. Run it, and you should get the following error:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的第 ➊ 行运行所有的 `checkNeighbors()` 代码，并根据结果设置单元格的开关状态。运行它，你应该会得到如下错误：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The error is in the line that checks the neighbor to the right. Sure enough,
    because there are only 15 cells in a row, it makes sense that the 15th cell has
    no neighbor to the right.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 错误出现在检查右边邻居的那一行。果然，由于每行只有15个单元格，15号单元格右边没有邻居是合乎逻辑的。
- en: If a cell has no neighbor to the right (meaning its column number is `GRID_W`
    minus one), we obviously don’t need to check that neighbor and can continue on
    to the next cell. The same for checking the neighbor above the cells in row 0,
    because they have no cells above them. Similarly, the cells in column 0 have no
    neighbors to the left, and the cells in row 14 (`GRID_H` minus 1) have no cells
    below them. In [Listing 11-7](ch11.xhtml#ch11list7), we add a valuable Python
    trick called *exception handling* to the `checkNeighbors()` method using the keywords
    `try` and `except`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个单元格右边没有邻居（意味着它的列号是 `GRID_W` 减一），显然我们不需要检查那个邻居，可以直接跳到下一个单元格。对于检查位于第0行的单元格上方的邻居也是如此，因为它们上面没有单元格。类似地，第0列的单元格没有左边的邻居，第14行（即
    `GRID_H` 减1）的单元格也没有下面的邻居。在[示例 11-7](ch11.xhtml#ch11list7)中，我们使用了一个有价值的 Python
    技巧，称为*异常处理*，通过 `try` 和 `except` 关键字添加到 `checkNeighbors()` 方法中。
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 11-7: Adding conditionals to `checkNeighbors()`*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 11-7：在 `checkNeighbors()` 中添加条件判断*'
- en: The `try` keyword ➊ literally means “try to run this next line of code.” In
    the earlier error message, we got an `IndexError`. We use the `except` keyword ➋
    to mean “if you get this error, do this.” Therefore, if we get an `IndexError`,
    we continue on to the next loop. Run this code, and you’ll get something interesting,
    as shown in [Figure 11-7](ch11.xhtml#ch11fig7). This is definitely not what we
    saw in [Figure 11-6](ch11.xhtml#ch11fig6).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`try` 关键字 ➊ 字面意思是“尝试运行下一行代码”。在早期的错误信息中，我们遇到了一个 `IndexError`。我们使用 `except` 关键字
    ➋ 来表示“如果遇到这个错误，就执行这个”。因此，如果我们遇到 `IndexError`，我们就继续进行下一轮循环。运行这段代码，你会得到一些有趣的结果，如[图
    11-7](ch11.xhtml#ch11fig7)所示。这显然与我们在[图 11-6](ch11.xhtml#ch11fig6)中看到的不同。'
- en: '![image](../images/f234-01.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f234-01.jpg)'
- en: '*Figure 11-7: Not what we expected!*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-7：不是我们预期的结果！*'
- en: The problem is that we’re checking neighbors and changing the state of the current
    cell. Then the cell’s neighbors are checking their neighbors, but they’re checking
    the new state of their neighbors. We want all the cells to check their neighbors
    and save the information in a new list; then, when all the cells are done, we
    can update the grid all at once. That calls for another list for our cells, `newList`,
    that will replace `cellList` at the end of the loop.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: So all we need to do is declare that `newList` is equal to `cellList`, right?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Although that seems to make sense, Python doesn’t copy the contents of `newList`
    over the previous contents of `cellList`, which is what you might have expected.
    It technically refers to the `newList`, but when you change `newList`, you end
    up changing `cellList` as well.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: PYTHON LISTS ARE STRANGE
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python lists have an odd behavior. Let’s say you declare a list and set another
    one equal to it, and then you change the first list. You wouldn’t expect the second
    one to change too, but that’s exactly what happens, as shown here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, we created list `a`, then assigned the value of list `a` to
    list `b`. When we change list `a` without updating list `b`, Python also changes
    list `b`!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: LIST INDEX NOTATION
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One way to make sure when we’re updating one list that we’re not updating another
    one accidentally is to use index notation. Giving list `b` all the contents of
    list `a` should prevent this from happening:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we use `b = a[::]` to say “assign all the contents inside list `a` to
    the variable `b`,” as opposed to simply declaring that list `a` is equal to list
    `b`. This way, the lists aren’t linked to each other.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'After we declare `SZ`, we need to add the following line of code to declare
    the initial value of the `generation` variable, which will keep track of which
    generation we’re looking at:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We’re going to avoid the list reference problem by using the index notation
    at the end of the updating code. Let’s create a new `update()` function after
    `draw()` so that all the updating will be done in that separate function. [Listing
    11-8](ch11.xhtml#ch11list8) shows how your `setup()` and `draw()` functions should
    look.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 11-8: Checking whether the updating is working and then stopping after
    three generations*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: We create the first `cellList` once in the `setup()` function and then declare
    it a global variable so we can use it in other functions. In the `draw()` function,
    we use the `generation` variable for however many generations we want to check
    (in this case, three); then we make a call to update the `cellList`. We draw the
    cells as before, using the `display()` method, and then increment `generation`
    and check whether it has reached our desired generation. If it has, the built-in
    Processing function `noLoop()` stops the loop.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: We use `noLoop()` to turn off the infinite loop, because we only want to draw
    the given number of generations. If you comment it out, the program will keep
    going! [Figure 11-8](ch11.xhtml#ch11fig8) shows what the CA looks like after three
    generations.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `noLoop()` 来关闭无限循环，因为我们只想绘制给定数量的世代。如果你注释掉它，程序将继续运行！[图11-8](ch11.xhtml#ch11fig8)
    显示了三代之后 CA 的样子。
- en: '![image](../images/f236-01.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f236-01.jpg)'
- en: '*Figure 11-8: A working CA!*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-8：一个正常工作的 CA！*'
- en: 'What’s great about using variables for our grid size is that we can change
    the CA drastically by simply changing the `GRID_W` and `GRID_H` variables, like
    so:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变量来定义网格大小的好处是，我们可以通过简单地改变 `GRID_W` 和 `GRID_H` 变量来大幅改变 CA，如下所示：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we increase the number of generations to 13 (in the line that currently reads
    `if generation == 3`), the output should look like [Figure 11-9](ch11.xhtml#ch11fig9).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将世代数增加到13（在当前显示 `if generation == 3` 的行中），输出结果应该像[图11-9](ch11.xhtml#ch11fig9)那样。
- en: '![image](../images/f237-01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f237-01.jpg)'
- en: '*Figure 11-9: Our CA at a higher level, with a grid (left) and without a grid
    (right)*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-9：我们的 CA 在更高级别上的样子，带有网格（左）和不带网格（右）*'
- en: 'To remove the grid around the empty cells in the CA, simply add this line to
    the `setup()` function:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要去掉 CA 中空细胞周围的网格，只需在 `setup()` 函数中添加这一行：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That should turn off the outline around the squares, but the fill color will
    still be drawn, like [Figure 11-9](ch11.xhtml#ch11fig9).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会关闭方格的轮廓，但填充颜色仍会显示，像[图11-9](ch11.xhtml#ch11fig9)那样。
- en: So far we’ve done a lot! We’ve created two-dimensional lists, filled them with
    cells, and turned on certain cells according to a simple rule. Then we updated
    the cells and displayed them. The CA just keeps growing!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们做了很多工作！我们创建了二维列表，填充了细胞，并根据简单的规则打开了某些细胞。然后我们更新了这些细胞并展示了它们。CA 就这样不断生长！
- en: 'EXERCISE 11-1: MANUALLY GROWING THE CA'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 11-1：手动生长 CA
- en: Use the `keyPressed()` function you learned about in [Chapter 10](ch10.xhtml#ch10)
    to manually grow the CA.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你在[第10章](ch10.xhtml#ch10)中学到的 `keyPressed()` 函数手动让 CA 生长。
- en: '#### LETTING YOUR CA GROW AUTOMATICALLY'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 让你的 CA 自动生长'
- en: If you want the CA to cycle from level 0 to a maximum number of generations
    (you choose the right number for your window), simply change the `draw()` function
    to what’s shown in [Listing 11-9](ch11.xhtml#ch11list9).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望 CA 从第0级循环到最大世代数（你为窗口选择适当的数字），只需将 `draw()` 函数更改为[清单11-9](ch11.xhtml#ch11list9)中所示的内容。
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 11-9: Making the CA grow and regrow automatically*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-9: 使 CA 自动生长和再生*'
- en: To slow down the animation, we use Processing’s built-in `frameRate()` function
    ➊. The default is 60 frames per second, so here we slowed it down to 10\. Then
    we tell the program that if the `generation` variable reaches 30 ➋ (you can change
    this to another number), reset `generation` to 1, and create a new `cellList`.
    Now you should be able to watch the CA grow as quickly or slowly as you want.
    Change the rule and see how that changes the CA. You can change the colors too!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减慢动画的速度，我们使用了 Processing 内置的 `frameRate()` 函数 ➊。默认情况下是每秒60帧，所以我们将其减慢至10帧。然后我们告诉程序，如果
    `generation` 变量达到30 ➋（你可以将其更改为其他数字），就重置 `generation` 为1，并创建一个新的 `cellList`。现在你应该能够根据需要观看
    CA 以任何速度生长。更改规则，看看这如何改变 CA。你也可以更改颜色！
- en: We’ve just taken a simple rule (if a cell has 1 or 4 neighbors, it’s “on”) and
    wrote a program to apply that rule to thousands of cells at once! The result looks
    like a living, growing organism. Now we’ll expand our code into a famous CA where
    the virtual organisms can move around, grow, and die!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义了一个简单的规则（如果一个细胞有1个或4个邻居，它是“开启”的），并编写了一个程序，将这个规则应用到成千上万的细胞上！结果看起来像一个活的、不断生长的有机体。接下来，我们将把代码扩展到一个著名的元胞自动机（CA），其中虚拟有机体可以移动、成长并死亡！
- en: PLAYING THE GAME OF LIFE
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 玩《生命游戏》
- en: 'In a 1970 issue of *Scientific American*, math popularizer Martin Gardner brought
    attention to a strange and wonderful game where cells live or die according to
    how many neighbors they have. The brainchild of English mathematician John Conway,
    this game features three simple rules:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在1970年出版的《科学美国人》杂志中，数学科普作家马丁·加德纳（Martin Gardner）引起了人们对一个奇怪而美妙的游戏的关注，其中细胞的生死取决于它们有多少个邻居。这款游戏由英国数学家约翰·康威（John
    Conway）发明，具有三个简单的规则：
- en: If a living cell has less than two living neighbors, it dies.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个活细胞有少于两个活邻居，它会死亡。
- en: If a living cell has more than three living neighbors, it dies.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个活细胞有超过三个活邻居，它会死亡。
- en: If a dead cell has exactly three living neighbors, it comes to life.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个死细胞有恰好三个活邻居，它将复生。
- en: With a simple set of rules like that, it’s surprising how intricate this game
    gets. In 1970, most people could only use checkers on a board to visualize the
    game, and one generation could take quite a while to calculate. Conveniently,
    we have a computer, and the CA code we just wrote has most of the code necessary
    to create this game in Python. Save the CA file we’ve been working on so far and
    then save it with different name, like *GameOfLife*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: In this game, our cells will have diagonal neighbors too. That means we have
    to add four more values to our `dr,dc` line. [Listing 11-10](ch11.xhtml#ch11list10)
    shows the changes you need to make to the `checkNeighbors()` code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 11-10: Changes to the `checkNeighbors()` code to include diagonal
    neighbors*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add four values ➊ to check the diagonal neighbors: `[-1,-1]` for
    the neighbor to the left and up, `[1,1]` for the neighbor to the right and down,
    and so on. Then we tell the program that if the cell is on ➋, check if it has
    two or three neighbors that are also on. If so, we tell the program to return
    1, and if not, we tell the program to return 0\. Otherwise, if the cell is off,
    we tell it to check if it has three neighbors that are on. If it does, return
    1; if doesn’t, return 0.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we place living cells randomly around the grid, so we have to import the
    `choice()` function from Python’s `random` module. Add this line to the top of
    the program:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then we use the `choice()` function to randomly choose whether a new `Cell`
    is on or off. So all we have to do is change the `append` line in the `createCellList()`
    function to the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we no longer need the generation code from the previous file. The remaining
    code in the `draw()` function looks like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run this code, and you’ll see a wild, dynamic game play out, where organisms
    are moving, morphing, splitting, and interacting with other organisms, like in
    [Figure 11-10](ch11.xhtml#ch11fig10).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f240-01.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-10: The Game of Life in action!*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: It’s interesting how the “clouds” of cells morph, move, and collide with other
    clouds (families? colonies?). Some organisms wander around the screen until, eventually,
    the grid will settle into a kind of equilibrium. [Figure 11-11](ch11.xhtml#ch11fig11)
    shows an example of that kind of equilibrium.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f240-02.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-11: An example of the Game of Life that has entered a stable state*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: In this example of a state of equilibrium, some shapes appear stable and unmoving,
    while other shapes become stuck in repeating patterns.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: THE ELEMENTARY CELLULAR AUTOMATON
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This last CA is really cool and involves a little more math, but it’s still
    a simple pattern that’s extended, though only in one dimension (which is why it’s
    called an “elementary CA”). We start off with one row of cells and set the middle
    cell’s state to one, as shown in [Figure 11-12](ch11.xhtml#ch11fig12).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f241-01.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-12: The first row of an elementary CA*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: This is easy to code. Start a new Processing sketch and call it *elementaryCA.pyde*.
    The code to draw the first row of cells is shown in [Listing 11-11](ch11.xhtml#ch11list11).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 11-11: Drawing the first row (generation) of the elementary CA*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: First, we declare a few important variables ➊, such as the size of each cell
    and the number of rows and columns in our CA. Next, we start our `cells` list
    ➋. We create `rows` number of rows and append `cols` number of 0’s in each list
    inside `cells`. We set the middle cell in the row to 1 (or on) ➌. In the `draw()`
    function, we loop through the rows (there will be more than one row soon!) and
    columns using `enumerate`. We check if the element is a 1, and if so, we color
    it black ➍. Otherwise, we color it white. Finally, we draw the square for the
    cell ➎. The x-value looks a bit complicated, but this just makes sure the CA is
    always centered.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this code, you should see what’s shown in [Figure 11-12](ch11.xhtml#ch11fig12):
    a row of cells with one “on” cell in the center. The state of the cells in the
    next row of the CA will depend on the rules we set up for a cell and its two neighbors.
    How many possibilities are there? Each cell has two possible states (1 or 0, or
    “on” or “off”) so that’s two states for the left neighbor, two for the center
    cell, and two for the right neighbor. That’s 2 × 2 × 2 = 8 possibilities. All
    the combinations are shown in [Figure 11-13](ch11.xhtml#ch11fig13).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f242-01.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-13: All the possible combinations of a cell and its two neighbors*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'The first possibility is that the center cell is on and both its neighbors
    are on. The next possibility is that the center cell is on, the left neighbor
    is on, and the right neighbor is off—and so on. This order is very important.
    (Do you see the pattern?) How are we going to describe these possibilities to
    the computer program? We could write eight conditional statements like this one:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: But there’s an easier way. In A *New Kind of Science*, Stephen Wolfram assigns
    numbers to the possibilities according to the binary number the three cells represent.
    Keeping in mind that 1 is on and 0 is off, you can see that 111 is 7 in binary,
    110 is 6 in binary, and so on, as illustrated in [Figure 11-14](ch11.xhtml#ch11fig14).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f242-02.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-14: The numbering method for the eight possibilities*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve numbered each possibility, we can create a rule set—that is,
    a list that will contain the rules for what to do with each possibility in the
    next generation. Notice the numbers are like the indices of a list, except backwards.
    We can easily get around that. We can assign a result to each one randomly or
    because of some plan. [Figure 11-15](ch11.xhtml#ch11fig15) shows one set of results.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f242-03.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-15: A set of results assigned to each possibility in the CA*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'The box under each possibility signifies the result, or the state of the cell
    in the next generation of the CA. The white box under “possibility 7” on the left
    means “if the cell is on and both of its neighbors are on, it will be off in the
    next generation.” Same for the next two possibilities (which don’t exist in our
    CA so far): the result is “off.” As illustrated earlier in [Figure 11-12](ch11.xhtml#ch11fig12),
    we have a lot of “off” cells surrounded by “off” cells, which is the possibility
    shown on the far right of [Figure 11-14](ch11.xhtml#ch11fig14): three white squares.
    In this case, the cell in the middle will be off in the next generation. We also
    have one “on” cell surrounded by two “off” cells (possibility 5). In the next
    generation, the cell will be on. We’ll use 0’s and 1’s for our `ruleset` list,
    as illustrated in [Figure 11-16](ch11.xhtml#ch11fig16).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f243-01.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-16: Putting the rules for generating the next row into a list*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll collect all these numbers into a list called `ruleset`, which we’ll add
    just before the `setup()` function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The order of the possibilities is important because this rule set is referred
    to as “Rule 30” (00011110 is 30 in binary). Our task is to create the next row
    according to the rules. Let’s create a `generate()` function that looks at the
    first row and generates the second row, then looks at the second row and generates
    the third row, and so on. Add the code shown in [Listing 11-12](ch11.xhtml#ch11list12).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 11-12: Writing the `generate()` function to generate new rows in the
    CA*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we make the CA larger by updating the number of rows and columns ➊.
    Next, we create the `rules()` function ➋, which takes three parameters: the left
    neighbor’s number, the current cell’s number, and the right neighbor’s number.
    The function checks the `ruleset` and returns the value for the cell in the next
    generation. We make use of the binary numbers, and the line `4*a + 2*b + c` converts
    “1,1,1” to 7 and “1,1,0” to 6, and so on. However, as you’ll recall from [Figure
    11-15](ch11.xhtml#ch11fig15), the indices are in reverse order, so we subtract
    the total from 7 to get the proper index of the `ruleset`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line to the end of the `setup()` function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This creates the full CA and not just the first row. When you run this code,
    you should see the first 10 rows of a CA made using “Rule 30,” as illustrated
    in [Figure 11-17](ch11.xhtml#ch11fig17).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f244-01.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-17: The first 10 rows of Rule 30*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f244-02.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-18: More of Rule 30*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The program is going through each row, starting at the top, and generating the
    next row according to the rules we gave it in the `ruleset`. What if we keep going?
    Change the number of rows and columns to 1000 and the width (`w`) of each cell
    to 3\. Add `noStroke()` to the `setup()` function to get rid of the outline of
    the cells, and then run the sketch. You should see what’s in [Figure 11-18](ch11.xhtml#ch11fig18).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Rule 30 is a fascinating design because it’s not completely random, but it’s
    not completely regular either. Rule 73 is also cool; in fact a woman named Fabienne
    Serriere programs the rule into a knitting machine to create scarves with the
    pattern, like in [Figure 11-19](ch11.xhtml#ch11fig19). You can order scarves with
    this and other algorithmically generated rules on them from *[https://knityak.com/](https://knityak.com/)*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f245-01.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-19: A scarf whose design is a cellular automaton: Rule 73!*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 11-2: CHANGING THE RULE SET'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Change `ruleset` to the binary form of the number 90\. What does the resulting
    CA look like? Hint: it’s a fractal.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'EXERCISE 11-3: ZOOMING IN AND OUT'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Use the `keyPressed()` function you learned about in [Chapter 10](ch10.xhtml#ch10)
    to change the value of the width variable `w` using the up and down arrow keys.
    This should let you zoom in and out of the CA!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '### SUMMARY'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned to use Python to create cellular automata, or cells
    that act independently, according to specific rules. We wrote programs to make
    a huge grid of these cells follow certain rules and update themselves, generation
    after generation, and we created unexpectedly beautiful designs and surprisingly
    life-like behavior.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll create virtual organisms that solve problems for
    us! These organisms will be able to guess a secret phrase and find the shortest
    route through a bunch of cities just by evolving better and better solutions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
