- en: '11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '11'
- en: CELLULAR AUTOMATA
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 元胞自动机
- en: '*I like to put a humidifier and a dehumidifier in a room and just let them
    fight it out.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*我喜欢把加湿器和除湿器放在同一个房间里，让它们互相“争斗”。*'
- en: —Steven Wright*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —史蒂文·赖特*
- en: '![image](../images/fintro-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fintro-01.jpg)'
- en: Math equations are a very powerful tool for modeling things we can measure;
    equations even got us to the moon, after all. But as powerful as they are, equations
    are of limited use in the biological and social sciences because organisms don’t
    grow according to equations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 数学方程式是建模我们可以测量的事物的强大工具；毕竟，方程式还让我们登上了月球。但尽管它们很强大，在生物学和社会科学中，它们的应用是有限的，因为生物体的生长并不是根据方程式来进行的。
- en: Organisms grow in an environment among many other organisms and spend their
    day performing innumerable interactions. That web of interactions determines how
    something will grow, and equations often can’t capture this complicated relationship.
    Equations can help us calculate the energy or mass converted by a single interaction
    or reaction, but to model a biological system, for example, you’d have to repeat
    that calculation hundreds or thousands of times.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 生物体在许多其他生物体的环境中生长，并在一天内进行无数次互动。这些互动的网络决定了事物将如何生长，而方程式往往无法捕捉这种复杂的关系。方程式可以帮助我们计算单一互动或反应所转换的能量或质量，但要模拟一个生物系统，比如说，你必须重复计算数百次甚至上千次。
- en: Fortunately, there’s a tool that models how cells, organisms, and other living
    systems grow and change according to their environment. Because of their similarity
    to independent biological organisms, these models are called *cellular automata
    (CAs)*. The term *automaton* refers to something that can run on its own. [Figure
    11-1](ch11.xhtml#ch11fig1) shows two examples of cellular automata generated using
    a computer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个工具可以模拟细胞、生物体和其他生物系统如何根据环境生长和变化。由于它们与独立的生物体相似，这些模型被称为*元胞自动机 (CAs)*。术语*自动机*指的是能够自主运行的东西。[图
    11-1](ch11.xhtml#ch11fig1)展示了使用计算机生成的两个元胞自动机的例子。
- en: '![image](../images/f226-01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f226-01.jpg)'
- en: '*Figure 11-1: An example of an elementary cellular automaton, and a screen
    full of virtual organisms*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-1：一个基础元胞自动机的例子，屏幕上充满了虚拟生物*'
- en: The CAs we’ll create in this chapter are grids made up of *cells*. Each cell
    in a CA has a number of *states* (for example, on/off, alive/dead, or colored/blank).
    Cells change according to the state of their neighbors, which allows them to grow
    and change as if they were alive!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将创建的元胞自动机是由*细胞*组成的网格。每个元胞自动机中的细胞都有若干*状态*（例如，开/关、存活/死亡或有色/空白）。细胞根据其邻居的状态变化，从而像活的生物一样生长和变化！
- en: CAs have been the subject of some study, as far back as the 1940s, but they
    really took off when computers became more commonplace. In fact, CAs can really
    only be studied using computers because, even though they follow very simple rules,
    like “if an organism doesn’t have enough neighbors, it dies,” these rules produce
    useful results only if hundreds or thousands of these organisms are created and
    allowed to run for hundreds or thousands of generations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 元胞自动机自1940年代以来就成为了研究的主题，但它们真正兴起是在计算机变得更加普及之后。事实上，元胞自动机实际上只能通过计算机来研究，因为尽管它们遵循非常简单的规则，例如“如果一个生物体没有足够的邻居，它就会死亡”，这些规则只有在创建了数百或数千个这些生物体并让它们运行数百或数千代时，才能产生有用的结果。
- en: Because math is the study of patterns, the math topic of cellular automata is
    rife with interesting ideas, programming challenges, and endless possibilities
    for beautiful output!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数学是模式的研究，元胞自动机这一数学主题充满了有趣的思想、编程挑战，以及无尽的美丽输出可能！
- en: CREATING A CELLULAR AUTOMATON
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个元胞自动机
- en: Open a new Processing sketch and name it *cellularAutomata.pyde*. Let’s start
    with a square grid where our cells will reside. We can easily draw a 10-by-10
    grid of squares of size 20, as shown in [Listing 11-1](ch11.xhtml#ch11list1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的Processing草图，并命名为*cellularAutomata.pyde*。我们从一个方格网格开始，在其中放置我们的细胞。我们可以轻松绘制一个10×10的20大小的正方形网格，如[示例
    11-1](ch11.xhtml#ch11list1)所示。
- en: '*cellular Automata.pyde*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*cellular Automata.pyde*'
- en: 'def setup():'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: 'for x in range(10):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 'for x in range(10):'
- en: 'for y in range(10):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 'for y in range(10):'
- en: rect(20*x,20*y,20,20)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: rect(20*x,20*y,20,20)
- en: '*Listing 11-1: Creating a grid of squares*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 11-1：创建一个正方形网格*'
- en: Save and run this sketch, and you should see a grid like the one shown in [Figure
    11-2](ch11.xhtml#ch11fig2).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 保存并运行这个草图，你应该能看到像[图 11-2](ch11.xhtml#ch11fig2)中显示的网格。
- en: '![image](../images/f227-01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f227-01.jpg)'
- en: '*Figure 11-2: A 10 × 10 grid*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-2：一个10 × 10的网格*'
- en: However, we need to change a bunch of numbers every time we want bigger cells,
    for example, or a grid with different dimensions. Therefore, it’s much easier
    to change things later if we use variables. Because the keywords height, width,
    and size already exist for the graphics window, we have to use different variable
    names. [Listing 11-2](ch11.xhtml#ch11list2) improves on [Listing 11-1](ch11.xhtml#ch11list1)
    by creating a grid that’s easy to resize, with cells that are also easy to resize—all
    by using variables.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，每次我们想要更大的单元格（例如）或一个不同尺寸的网格时，我们都需要更改一堆数字。因此，如果我们使用变量，稍后更改起来就会容易得多。因为图形窗口已经存在关键字height、width和size，所以我们必须使用不同的变量名。[清单
    11-2](ch11.xhtml#ch11list2)通过创建一个易于调整大小的网格来改进[清单 11-1](ch11.xhtml#ch11list1)，而且这些网格的单元格也很容易调整大小——这一切都是通过使用变量实现的。
- en: '*cellular Automata.pyde*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*cellular Automata.pyde*'
- en: GRID_W = 15
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: GRID_W = 15
- en: GRID_H = 15
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: GRID_H = 15
- en: '#size of cell'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '#单元格大小'
- en: SZ = 18
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: SZ = 18
- en: 'def setup():'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: size(600,600)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: 'def draw():'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: 'for c in range(GRID_W): #the columns'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 'for c in range(GRID_W): #列'
- en: 'for r in range(GRID_H): #the rows'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 'for r in range(GRID_H): #行'
- en: rect(SZ*c,SZ*r,SZ,SZ)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: rect(SZ*c,SZ*r,SZ,SZ)
- en: '*Listing 11-2: Improved grid program using variables*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-2：使用变量改进的网格程序*'
- en: We create variables for the height (GRID_H) and width (GRID_W) of the grid using
    all capital letters to indicate that these are constants and their values won’t
    be changing. The size of the cell is also a constant (for now), so we capitalize
    it as well (SZ) when declaring its initial value. Now when you run this code,
    you should see a larger grid, like the one shown in [Figure 11-3](ch11.xhtml#ch11fig3).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为网格的高度（GRID_H）和宽度（GRID_W）创建了变量，使用全大写字母表示这些是常量，并且它们的值不会改变。单元格的大小也是常量（目前如此），因此在声明其初始值时，我们也将其大写（SZ）。现在，当你运行这段代码时，应该会看到一个更大的网格，就像[图11-3](ch11.xhtml#ch11fig3)中显示的那样。
- en: '![image](../images/f228-01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f228-01.jpg)'
- en: '*Figure 11-3: A larger grid, made with variables*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-3：使用变量创建的更大网格*'
- en: WRITING A CELL CLASS
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写单元格类
- en: We need to write a class because every cell we create needs its own location,
    state (“on” or “off”), neighbors (the cells next to it), and so on. We create
    the Cell class by adding the code shown in [Listing 11-3](ch11.xhtml#ch11list3).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写一个类，因为我们创建的每个单元格都需要有自己的位置、状态（“开”或“关”）、邻居（它旁边的单元格）等等。我们通过添加在[清单 11-3](ch11.xhtml#ch11list3)中显示的代码来创建Cell类。
- en: '*cellular Automata.pyde*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*cellular Automata.pyde*'
- en: '#size of cell'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '#单元格大小'
- en: SZ = 18
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: SZ = 18
- en: 'class Cell:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Cell:'
- en: 'def __init__(self,c,r,state=0):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self,c,r,state=0):'
- en: self.c = c
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: self.c = c
- en: self.r = r
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: self.r = r
- en: self.state = state
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: self.state = state
- en: 'def display(self):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 'def display(self):'
- en: 'if self.state == 1:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '如果self.state == 1:'
- en: 'fill(0) #black'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 'fill(0) #黑色'
- en: 'else:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: 'fill(255) #white'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 'fill(255) #白色'
- en: rect(SZ*self.r,SZ*self.c,SZ,SZ)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: rect(SZ*self.r,SZ*self.c,SZ,SZ)
- en: '*Listing 11-3: Creating the Cell class*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-3：创建Cell类*'
- en: The cell’s initial state property is 0 (or off). The code state=0 in the parameters
    of the __init__ method means that if we don’t specify a state, state is set to
    0\. The display() method just tells the Cell object how to display itself on the
    screen. If it’s “on,” the cell is black; otherwise, it’s white. Also, each cell
    is a square, and we need to spread out the cells by multiplying their column and
    row numbers by their size (self.SZ).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 单元格的初始状态属性是0（或关闭）。在__init__方法的参数中，state=0表示如果我们没有指定状态，则默认状态为0。display()方法只是告诉Cell对象如何在屏幕上显示自己。如果状态为“开”，单元格为黑色；否则，它为白色。此外，每个单元格都是正方形的，我们需要通过将它们的列和行号乘以它们的大小（self.SZ）来分散这些单元格。
- en: After the draw() function, we need to write a function to create an empty list
    to put our Cell objects in and use a nested loop to append these Cell objects
    to the list instead of drawing them one by one, as shown in [Listing 11-4](ch11.xhtml#ch11list4).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在draw()函数之后，我们需要编写一个函数，创建一个空列表来存放我们的Cell对象，并使用嵌套循环将这些Cell对象添加到列表中，而不是像之前一样逐一绘制它们，这在[清单
    11-4](ch11.xhtml#ch11list4)中有展示。
- en: '*cellular Automata.pyde*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*cellular Automata.pyde*'
- en: 'def createCellList():'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 'def createCellList():'
- en: '''''''Creates a big list of off cells with'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '''''''创建一个包含关闭状态单元格的大列表'
- en: one on Cell in the center'''
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 中心的单元格状态为开启'''
- en: ➊ newList=[]#empty list for cells
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ newList=[]#用于存储单元格的空列表
- en: '#populate the initial cell list'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '#填充初始单元格列表'
- en: 'for j in range(GRID_H):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(GRID_H):'
- en: '➋ newList.append([]) #add empty row'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ newList.append([]) #添加空行'
- en: 'for i in range(GRID_W):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(GRID_W):'
- en: '➌ newList [j].append(Cell(i,j,0)) #add off Cells or zeroes'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ newList [j].append(Cell(i,j,0)) #添加关闭状态的单元格或零'
- en: '#center cell is set to on'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '#中心单元格设置为开启'
- en: ➍ newList [GRID_H//2][GRID_W//2].state = 1
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ newList [GRID_H//2][GRID_W//2].state = 1
- en: return newList
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: return newList
- en: '*Listing 11-4: Function for creating a list of cells*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-4：创建单元格列表的函数*'
- en: First, we create an empty list called newList ➊ and add an empty list as a row
    ➋ to be filled in with Cell objects ➌. Then, we get the index of the center square
    by dividing the number of rows and columns by 2 (the double slash means integer
    division) and setting that cell’s state property to 1 (or “on”) ➍.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个空列表，命名为newList ➊，并添加一个空列表作为行 ➋，待填充Cell对象 ➌。然后，我们通过将行数和列数各自除以2（双斜杠表示整数除法）来获取中心单元格的索引，并将该单元格的状态属性设置为1（或“开启”）
    ➍。
- en: In setup(), we’ll use the createCellList() function and declare cellList as
    a global variable so it can be used in the draw() function. Finally, in draw(),
    we’ll loop over each row in cellList and update it. The new setup() and draw()
    functions are shown in [Listing 11-5](ch11.xhtml#ch11list5).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在setup()中，我们将使用createCellList()函数，并声明cellList为全局变量，这样它就可以在draw()函数中使用。最后，在draw()中，我们将遍历cellList中的每一行并进行更新。新的setup()和draw()函数如[示例
    11-5](ch11.xhtml#ch11list5)所示。
- en: 'def setup():'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: global cellList
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: global cellList
- en: size(600,600)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: cellList = createCellList()
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: cellList = createCellList()
- en: 'def draw():'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: 'for row in cellList:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 'for row in cellList:'
- en: 'for cell in row:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 'for cell in row:'
- en: cell.display()
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: cell.display()
- en: '*Listing 11-5: The new setup() and draw() functions for creating a grid*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 11-5: 用于创建网格的新的setup()和draw()函数*'
- en: However, when we run this code, we get a grid with smaller cells in the corner
    of the display window, as shown in [Figure 11-4](ch11.xhtml#ch11fig4).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们运行这段代码时，我们会得到一个显示窗口角落中较小单元格的网格，如[图 11-4](ch11.xhtml#ch11fig4)所示。
- en: '![image](../images/f230-01.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f230-01.jpg)'
- en: '*Figure 11-4: A grid of cells that’s not yet centered*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-4: 还没有居中的单元格网格*'
- en: Now we’re able to make as big or small a list of cells as we want by changing
    the size of our 15-by-15 grid.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过改变我们的15x15网格的大小，我们可以创建任何大小的单元格列表。
- en: RESIZING EACH CELL
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调整每个单元格的大小
- en: To resize our cells, we can make SZ automatically dependent on the width of
    the window. Right now the width is 600, so let’s change setup() using the code
    in [Listing 11-6](ch11.xhtml#ch11list6).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调整单元格的大小，我们可以让SZ自动根据窗口的宽度进行调整。目前窗口宽度是600，所以让我们使用[示例 11-6](ch11.xhtml#ch11list6)中的代码来更改setup()。
- en: '*cellular Automata.pyde*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*cellular Automata.pyde*'
- en: 'def setup():'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: global SZ,cellList
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: global SZ,cellList
- en: size(600,600)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: SZ = width // GRID_W + 1
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: SZ = width // GRID_W + 1
- en: cellList = createCellList()
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: cellList = createCellList()
- en: '*Listing 11-6: Resizing the cells to autofit the display window*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 11-6: 调整单元格大小以自动适应显示窗口*'
- en: The double forward slash (//) means *integer division*, which returns only the
    integer part of the quotient. Now, when you run the program, it should produce
    a grid with all empty cells except for one colored cell in the center, like in
    [Figure 11-5](ch11.xhtml#ch11fig5).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 双斜杠（//）表示*整数除法*，只返回商的整数部分。现在，当你运行程序时，它应该会生成一个网格，除了中央的一个有颜色的单元格外，其余单元格都是空的，如[图
    11-5](ch11.xhtml#ch11fig5)所示。
- en: '![image](../images/f231-01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f231-01.jpg)'
- en: '*Figure 11-5: Grids with the center cell “on”*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-5: 中心单元格“开启”的网格*'
- en: Note that this code works better when you add 1 to SZ, the size of the Cell,
    as in Listing 11-16, because otherwise the grid sometimes doesn’t fill the whole
    display window. But feel free to leave it out.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当你像示例 11-16 中那样将1加到SZ（单元格大小）时，代码会表现得更好，因为否则网格有时不会填满整个显示窗口。但如果你不加这一步也可以。
- en: MAKING A CA GROW
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 让细胞自动机生长
- en: Now we want to make the cells change according to the number of their neighbors
    whose state is “on.” This section was inspired by a two-dimensional CA from Stephen
    Wolfram’s *New Kind of Science*. You can see how a version of this CA grows in
    [Figure 11-6](ch11.xhtml#ch11fig6).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们希望根据每个单元格的邻居状态来改变它们的状态。如果邻居中有状态为“开启”的单元格，就改变当前单元格的状态。这一部分的灵感来自于Stephen
    Wolfram的*《新科学》*中的二维CA。你可以在[图 11-6](ch11.xhtml#ch11fig6)中看到这种细胞自动机如何生长。
- en: '![image](../images/f231-02.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f231-02.jpg)'
- en: '*Figure 11-6: Stages of growth of a cellular automaton*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-6: 一个细胞自动机的生长阶段*'
- en: In this design, if a cell has *one or four* neighbors that are on, we make it
    turn on (and stay on).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中，如果一个单元格有*一个或四个*邻居是开启的，我们就让它开启（并保持开启）。
- en: PUTTING THE CELLS INTO A MATRIX
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将单元格放入矩阵
- en: It’s easy to find the cells immediately before and after a cell in the list,
    which gives us the neighbors to its left and right. But how do we find the neighbors
    above and below a cell? To do this more easily, we can put the cells in a two-dimensional
    *array* or *matrix*, which is a list with lists for the rows. That way, if a cell
    is in column 5, for example, we know that its “above” and “below” neighbors will
    also be in column 5.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 直接找到列表中紧挨着某个单元格的前后单元格是很容易的，这样我们就可以找到它左右的邻居。但是，如何找到单元格上下的邻居呢？为了更方便地做这个，我们可以将单元格放入一个二维*数组*或*矩阵*中，这就是一个包含行的列表。这样，如果一个单元格在第
    5 列，我们就知道它的“上方”和“下方”邻居也会在第 5 列。
- en: 'In the Cell class, we add a method called checkNeighbors() so that a cell can
    count how many of its neighbors are on, and if the count is 1 or 4, that cell
    will return 1 for “on.” Otherwise, it returns 0 for “off.” We begin by checking
    the neighbor above:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Cell` 类中，我们添加了一个名为 `checkNeighbors()` 的方法，使得每个单元格能够计算它有多少个邻居是开启的，如果邻居数是 1
    或 4，那么该单元格就会返回 1 表示“开启”。否则，它返回 0 表示“关闭”。我们首先检查上方的邻居：
- en: 'def checkNeighbors(self):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `checkNeighbors(self)`：
- en: 'if self.state == 1: return 1 #on Cells stay on'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 `self.state == 1`：返回 1  # 开启的单元格保持开启'
- en: neighbs = 0
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`neighbs = 0`'
- en: '#check the neighbor above'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查上方的邻居'
- en: 'if cellList[self.r-1][self.c].state == 1:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `cellList[self.r-1][self.c].state == 1`：
- en: neighbs += 1
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`neighbs += 1`'
- en: This code checks for the item in cellList that’s in the same column (self.c)
    but in the previous row (self.r – 1). If that item’s state property is 1, then
    it’s on, and we increment the neighbs variable by 1\. Then we have to do the same
    for the cell’s neighbor below, and then for the neighbors to the left and right.
    Do you see an easy pattern here?
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码检查 `cellList` 中与当前单元格在同一列（`self.c`）但位于上一行（`self.r - 1`）的项。如果该项的状态属性为 1，那么它是开启的，我们将
    `neighbs` 变量增加 1。然后，我们需要对单元格下方的邻居做相同的检查，再检查左右邻居。你看到这里有一个简单的模式吗？
- en: 'cellList[self.r - 1][self.c + 0] #above'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`cellList[self.r - 1][self.c + 0]`  # 上方'
- en: 'cellList[self.r + 1][self.c + 0] #below'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`cellList[self.r + 1][self.c + 0]`  # 下方'
- en: 'cellList[self.r + 0][self.c - 1] #left'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`cellList[self.r + 0][self.c - 1]`  # 左边'
- en: 'cellList[self.r + 0][self.c + 1] #right'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`cellList[self.r + 0][self.c + 1]`  # 右边'
- en: 'We only need to keep track of the change in the row number and the change in
    the column number. There are only four directions we need to check, for the “one
    to the left, one to the right” neighbors, and so on: [-1,0], [1,0], [0,-1] and
    [0,1]. If we call those dr and dc (*d*, or the Greek letter *delta*, is the traditional
    math symbol for change), we can keep from repeating ourselves:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要跟踪行号和列号的变化。我们只需要检查四个方向的邻居，即“左边一个，右边一个”等等：[-1,0]，[1,0]，[0,-1] 和 [0,1]。如果我们将它们称为
    `dr` 和 `dc`（*d* 或希腊字母 *delta* 是表示变化的传统数学符号），这样就可以避免重复：
- en: '*cellular Automata.pyde*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*cellular Automata.pyde*'
- en: 'def checkNeighbors(self):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `checkNeighbors(self)`：
- en: 'if self.state == 1: return 1 #on Cells stay on'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 `self.state == 1`：返回 1  # 开启的单元格保持开启'
- en: 'neighbs = 0 #check the neighbors'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`neighbs = 0`  # 检查邻居'
- en: 'for dr,dc in [[-1,0],[1,0],[0,-1],[0,1]]:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `dr, dc` 在 [[-1,0],[1,0],[0,-1],[0,1]] 中：
- en: 'if cellList[self.r + dr][self.c + dc].state == 1:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `cellList[self.r + dr][self.c + dc].state == 1`：
- en: neighbs += 1
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`neighbs += 1`'
- en: 'if neighbs in [1,4]:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `neighbs in [1,4]`：
- en: return 1
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 1
- en: 'else:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: return 0
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 0
- en: Finally, if the neighbor count is 1 or 4, the state property will be set to
    1\. In Python, if neighbs in [1,4] is the same as saying if neighbs == 1 or neighbs
    == 4:.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果邻居计数为 1 或 4，状态属性将设置为 1。在 Python 中，`if neighbs in [1,4]` 等价于 `if neighbs
    == 1 or neighbs == 4:`。
- en: CREATING THE CELL LIST
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建单元格列表
- en: 'So far, we’ve created the cell list by running the createCellList() function
    in setup() and assigning the output to cellList, and we’ve gone through every
    row in cellList and updated each cell in the row. Now we have to check whether
    the rules work. The four squares surrounding the center cell should change state
    in the next step. That means we’ll have to run the checkNeighbors() method and
    then show the result. Update your draw() function as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过在 `setup()` 中运行 `createCellList()` 函数并将输出赋值给 `cellList`，已经创建了单元格列表，并且我们遍历了
    `cellList` 中的每一行并更新了每个单元格。现在我们需要检查规则是否有效。围绕中心单元格的四个方格应在下一步中改变状态。这意味着我们必须运行 `checkNeighbors()`
    方法，然后显示结果。更新你的 `draw()` 函数如下：
- en: 'def draw():'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 `draw()`：
- en: 'for row in cellList:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `cellList` 中的每一行：
- en: 'for cell in row:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一行中的 `cell`：
- en: ➊ cell.state = cell.checkNeighbors()
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ `cell.state = cell.checkNeighbors()`
- en: cell.display()
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`cell.display()`'
- en: 'The updated line ➊ runs all the checkNeighbors() code and sets the cell on
    or off according to the result. Run it, and you should get the following error:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的第 ➊ 行执行所有 `checkNeighbors()` 代码，并根据结果设置单元格的状态为开启或关闭。运行它，你应该会得到以下错误：
- en: 'IndexError: index out of range: 15'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 'IndexError: 索引超出范围：15'
- en: The error is in the line that checks the neighbor to the right. Sure enough,
    because there are only 15 cells in a row, it makes sense that the 15th cell has
    no neighbor to the right.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 错误出现在检查右侧邻居的那一行。果然，由于每行只有15个单元格，因此第15个单元格右侧没有邻居是合理的。
- en: If a cell has no neighbor to the right (meaning its column number is GRID_W
    minus one), we obviously don’t need to check that neighbor and can continue on
    to the next cell. The same for checking the neighbor above the cells in row 0,
    because they have no cells above them. Similarly, the cells in column 0 have no
    neighbors to the left, and the cells in row 14 (GRID_H minus 1) have no cells
    below them. In [Listing 11-7](ch11.xhtml#ch11list7), we add a valuable Python
    trick called *exception handling* to the checkNeighbors() method using the keywords
    try and except.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个单元格右侧没有邻居（即它的列号是 GRID_W 减去 1），显然我们不需要检查那个邻居，可以继续检查下一个单元格。对于检查第0行的单元格上方的邻居也是一样，因为它们上方没有单元格。类似地，第0列的单元格左侧没有邻居，第14行（GRID_H
    减去 1）的单元格下方没有单元格。在[Listing 11-7](ch11.xhtml#ch11list7)中，我们向 checkNeighbors() 方法添加了一个有用的
    Python 技巧，称为 *异常处理*，它使用了 try 和 except 关键字。
- en: '*cellular Automata.pyde*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*cellular Automata.pyde*'
- en: 'def checkNeighbors(self,cellList):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 'def checkNeighbors(self, cellList):'
- en: 'if self.state == 1: return 1 #on Cells stay on'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 self.state == 1: 返回 1 #单元格保持开启'
- en: neighbs = 0
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: neighbs = 0
- en: '#check the neighbors'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '#检查邻居'
- en: 'for dr,dc in [[-1,0],[1,0],[0,-1],[0,1]]:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 'for dr, dc in [[-1, 0], [1, 0], [0, -1], [0, 1]]:'
- en: '➊ try:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ 尝试:'
- en: 'if cellList[self.r + dr][self.c + dc].state == 1:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 cellList[self.r + dr][self.c + dc].state == 1:'
- en: neighbs += 1
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: neighbs += 1
- en: '➋ except IndexError:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 除了 IndexError：
- en: continue
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 继续
- en: 'if neighbs in [1,4]:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果邻居数在 [1, 4] 之间：
- en: return 1
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 1
- en: 'else:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: return 0
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 0
- en: '*Listing 11-7: Adding conditionals to checkNeighbors()*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-7: 向 checkNeighbors() 添加条件判断*'
- en: The try keyword ➊ literally means “try to run this next line of code.” In the
    earlier error message, we got an IndexError. We use the except keyword ➋ to mean
    “if you get this error, do this.” Therefore, if we get an IndexError, we continue
    on to the next loop. Run this code, and you’ll get something interesting, as shown
    in [Figure 11-7](ch11.xhtml#ch11fig7). This is definitely not what we saw in [Figure
    11-6](ch11.xhtml#ch11fig6).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: try 关键字 ➊ 字面意思是“尝试运行下一行代码”。在之前的错误信息中，我们遇到了一个 IndexError。我们使用 except 关键字 ➋ 来表示“如果你遇到这个错误，就做这个”。因此，如果我们遇到
    IndexError，我们会继续执行下一个循环。运行此代码后，你会看到一些有趣的结果，如[Figure 11-7](ch11.xhtml#ch11fig7)所示。这绝对不是我们在[Figure
    11-6](ch11.xhtml#ch11fig6)中看到的结果。
- en: '![image](../images/f234-01.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f234-01.jpg)'
- en: '*Figure 11-7: Not what we expected!*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 11-7: 不是我们预期的！*'
- en: The problem is that we’re checking neighbors and changing the state of the current
    cell. Then the cell’s neighbors are checking their neighbors, but they’re checking
    the new state of their neighbors. We want all the cells to check their neighbors
    and save the information in a new list; then, when all the cells are done, we
    can update the grid all at once. That calls for another list for our cells, newList,
    that will replace cellList at the end of the loop.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们正在检查邻居并更改当前单元格的状态。然后，单元格的邻居开始检查它们的邻居，但它们正在检查新状态的邻居。我们希望所有单元格检查它们的邻居，并将信息保存在一个新的列表中；然后，当所有单元格都完成时，我们可以一次性更新网格。这就需要另一个列表来存储我们的单元格，newList，它将在循环结束时替代
    cellList。
- en: So all we need to do is declare that newList is equal to cellList, right?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们只需要做的是声明 newList 等于 cellList，对吧？
- en: cellList = newList  #?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 'cellList = newList  #?'
- en: Although that seems to make sense, Python doesn’t copy the contents of newList
    over the previous contents of cellList, which is what you might have expected.
    It technically refers to the newList, but when you change newList, you end up
    changing cellList as well.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这似乎是有道理的，Python 并没有将 newList 的内容复制到 cellList 的原内容中，这是你可能预期的行为。它实际上是引用了 newList，但当你更改
    newList 时，cellList 也会被更改。
- en: PYTHON LISTS ARE STRANGE
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PYTHON 列表是奇怪的
- en: 'Python lists have an odd behavior. Let’s say you declare a list and set another
    one equal to it, and then you change the first list. You wouldn’t expect the second
    one to change too, but that’s exactly what happens, as shown here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Python 列表有个奇怪的行为。假设你声明了一个列表并将另一个列表设置为与其相等，然后你更改第一个列表。你不会期望第二个列表也会变化，但实际情况正是如此，正如这里所展示的那样：
- en: '>>> a = [1,2,3]'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = [1, 2, 3]'
- en: '>>> b = a'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = a'
- en: '>>> b'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b'
- en: '[1, 2, 3]'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 2, 3]'
- en: '>>> a.append(4)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a.append(4)'
- en: '>>> a'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a'
- en: '[1, 2, 3, 4]'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 2, 3, 4]'
- en: '>>> b'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b'
- en: '[1, 2, 3, 4]'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 2, 3, 4]'
- en: As you can see, we created list a, then assigned the value of list a to list
    b. When we change list a without updating list b, Python also changes list b!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们创建了列表 a，然后将列表 a 的值赋给了列表 b。当我们更改列表 a 时，如果没有更新列表 b，Python 也会更改列表 b！
- en: LIST INDEX NOTATION
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列表索引表示法
- en: 'One way to make sure when we’re updating one list that we’re not updating another
    one accidentally is to use index notation. Giving list b all the contents of list
    a should prevent this from happening:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一种确保我们在更新一个列表时不会不小心更新另一个列表的方法是使用索引表示法。将列表 b 赋值为列表 a 的所有内容应该能避免这种情况：
- en: '>>> a = [1,2,3]'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = [1,2,3]'
- en: '>>> b = a[::]'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = a[::]'
- en: '>>> b'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b'
- en: '[1, 2, 3]'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 2, 3]'
- en: '>>> a.append(4)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a.append(4)'
- en: '>>> a'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a'
- en: '[1, 2, 3, 4]'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 2, 3, 4]'
- en: '>>> b'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b'
- en: '[1, 2, 3]'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 2, 3]'
- en: Here, we use b = a[::] to say “assign all the contents inside list a to the
    variable b,” as opposed to simply declaring that list a is equal to list b. This
    way, the lists aren’t linked to each other.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 b = a[::] 来表示“将列表 a 中的所有内容赋值给变量 b”，而不是简单地声明列表 a 等于列表 b。这样，两个列表就不会互相关联。
- en: 'After we declare SZ, we need to add the following line of code to declare the
    initial value of the generation variable, which will keep track of which generation
    we’re looking at:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们声明 SZ 后，我们需要添加以下代码行来声明 generation 变量的初始值，它将跟踪我们正在查看的代数：
- en: generation = 0
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: generation = 0
- en: We’re going to avoid the list reference problem by using the index notation
    at the end of the updating code. Let’s create a new update() function after draw()
    so that all the updating will be done in that separate function. [Listing 11-8](ch11.xhtml#ch11list8)
    shows how your setup() and draw() functions should look.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在更新代码的末尾使用索引表示法来避免列表引用问题。让我们在 draw() 后创建一个新的 update() 函数，这样所有的更新就会在那个独立的函数中完成。[清单11-8](ch11.xhtml#ch11list8)
    显示了你的 setup() 和 draw() 函数应该是什么样子。
- en: '*cellular Automata.pyde*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*cellular Automata.pyde*'
- en: 'def setup():'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: global SZ, cellList
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: global SZ, cellList
- en: size(600,600)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: SZ = width // GRID_W + 1
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: SZ = width // GRID_W + 1
- en: cellList = createCellList()
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: cellList = createCellList()
- en: 'def draw():'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: global generation,cellList
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: global generation,cellList
- en: cellList = update(cellList)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: cellList = update(cellList)
- en: 'for row in cellList:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 'for row in cellList:'
- en: 'for cell in row:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'for cell in row:'
- en: cell.display()
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: cell.display()
- en: generation += 1
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: generation += 1
- en: 'if generation == 3:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 'if generation == 3:'
- en: noLoop()
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: noLoop()
- en: 'def update(cellList):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update(cellList):'
- en: newList = []
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: newList = []
- en: 'for r,row in enumerate(cellList):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 'for r,row in enumerate(cellList):'
- en: newList.append([])
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: newList.append([])
- en: 'for c,cell in enumerate(row):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 'for c,cell in enumerate(row):'
- en: newList[r].append(Cell(c,r,cell.checkNeighbors()))
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: newList[r].append(Cell(c,r,cell.checkNeighbors()))
- en: return newList[::]
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: return newList[::]
- en: '*Listing 11-8: Checking whether the updating is working and then stopping after
    three generations*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单11-8：检查更新是否正常工作，并在三代后停止*'
- en: We create the first cellList once in the setup() function and then declare it
    a global variable so we can use it in other functions. In the draw() function,
    we use the generation variable for however many generations we want to check (in
    this case, three); then we make a call to update the cellList. We draw the cells
    as before, using the display() method, and then increment generation and check
    whether it has reached our desired generation. If it has, the built-in Processing
    function noLoop() stops the loop.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 setup() 函数中创建第一个 cellList，然后将其声明为全局变量，以便在其他函数中使用。在 draw() 函数中，我们使用 generation
    变量来表示我们想检查的代数（在本例中为三代）；然后我们调用 update 函数来更新 cellList。我们像之前一样使用 display() 方法绘制单元格，然后增加代数，并检查是否已达到我们想要的代数。如果达到了，内置的
    Processing 函数 noLoop() 将停止循环。
- en: We use noLoop() to turn off the infinite loop, because we only want to draw
    the given number of generations. If you comment it out, the program will keep
    going! [Figure 11-8](ch11.xhtml#ch11fig8) shows what the CA looks like after three
    generations.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 noLoop() 来关闭无限循环，因为我们只希望绘制指定数量的代数。如果你将其注释掉，程序将继续运行！[图11-8](ch11.xhtml#ch11fig8)
    显示了元胞自动机在三代后的样子。
- en: '![image](../images/f236-01.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f236-01.jpg)'
- en: '*Figure 11-8: A working CA!*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-8：一个正在工作的元胞自动机！*'
- en: 'What’s great about using variables for our grid size is that we can change
    the CA drastically by simply changing the GRID_W and GRID_H variables, like so:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变量来表示网格大小的好处是，我们只需修改 GRID_W 和 GRID_H 变量，就可以大幅度改变元胞自动机，例如：
- en: GRID_W = 41
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: GRID_W = 41
- en: GRID_H = 41
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: GRID_H = 41
- en: If we increase the number of generations to 13 (in the line that currently reads
    if generation == 3), the output should look like [Figure 11-9](ch11.xhtml#ch11fig9).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将代数增加到 13（在当前读取 if generation == 3 的那行），输出应该像 [图11-9](ch11.xhtml#ch11fig9)
    所示。
- en: '![image](../images/f237-01.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f237-01.jpg)'
- en: '*Figure 11-9: Our CA at a higher level, with a grid (left) and without a grid
    (right)*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-9：我们的元胞自动机在更高层次上的表现，带有网格（左）和没有网格（右）*'
- en: 'To remove the grid around the empty cells in the CA, simply add this line to
    the setup() function:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除元胞自动机中空单元格周围的网格，只需在 setup() 函数中添加这一行：
- en: noStroke()
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: noStroke()
- en: That should turn off the outline around the squares, but the fill color will
    still be drawn, like [Figure 11-9](ch11.xhtml#ch11fig9).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会关闭方格的轮廓，但填充颜色仍会显示，就像[图11-9](ch11.xhtml#ch11fig9)所示。
- en: So far we’ve done a lot! We’ve created two-dimensional lists, filled them with
    cells, and turned on certain cells according to a simple rule. Then we updated
    the cells and displayed them. The CA just keeps growing!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们做了很多工作！我们创建了二维列表，填充了细胞，并根据一个简单的规则开启了某些细胞。然后我们更新了这些细胞并展示出来。CA就这样不断生长！
- en: 'EXERCISE 11-1: MANUALLY GROWING THE CA'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 11-1：手动生成 CA
- en: Use the keyPressed() function you learned about in [Chapter 10](ch10.xhtml#ch10)
    to manually grow the CA.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你在[第10章](ch10.xhtml#ch10)中学到的keyPressed()函数手动生成CA。
- en: '#### LETTING YOUR CA GROW AUTOMATICALLY'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 让你的CA自动生长'
- en: If you want the CA to cycle from level 0 to a maximum number of generations
    (you choose the right number for your window), simply change the draw() function
    to what’s shown in [Listing 11-9](ch11.xhtml#ch11list9).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望CA从第0级周期到最大代数（你可以根据窗口选择合适的数值），只需将draw()函数修改为[清单 11-9](ch11.xhtml#ch11list9)中所示的样子。
- en: '*cellular Automata.pyde*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*cellular Automata.pyde*'
- en: 'def draw():'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: global generation,cellList
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: global generation, cellList
- en: ➊ frameRate(10)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ frameRate(10)
- en: cellList = update(cellList)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: cellList = update(cellList)
- en: 'for row in cellList:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 'for row in cellList:'
- en: 'for cell in row:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 'for cell in row:'
- en: cell.display()
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: cell.display()
- en: generation += 1
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: generation += 1
- en: '➋ if generation == 30:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ if generation == 30:'
- en: generation = 1
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: generation = 1
- en: cellList = createCellList()
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: cellList = createCellList()
- en: '*Listing 11-9: Making the CA grow and regrow automatically*'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-9：让CA自动生长与再生*'
- en: To slow down the animation, we use Processing’s built-in frameRate() function
    ➊. The default is 60 frames per second, so here we slowed it down to 10\. Then
    we tell the program that if the generation variable reaches 30 ➋ (you can change
    this to another number), reset generation to 1, and create a new cellList. Now
    you should be able to watch the CA grow as quickly or slowly as you want. Change
    the rule and see how that changes the CA. You can change the colors too!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减慢动画速度，我们使用了Processing内建的frameRate()函数➊。默认速度是每秒60帧，所以在这里我们将其减慢到了10。接着我们告诉程序，如果generation变量达到30 ➋（你可以将这个数字改为其他值），则重置generation为1，并创建一个新的cellList。现在你应该可以根据需要观察CA的生长速度了。改变规则，看看会如何影响CA。你也可以改变颜色！
- en: We’ve just taken a simple rule (if a cell has 1 or 4 neighbors, it’s “on”) and
    wrote a program to apply that rule to thousands of cells at once! The result looks
    like a living, growing organism. Now we’ll expand our code into a famous CA where
    the virtual organisms can move around, grow, and die!
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚写了一个程序，应用一个简单的规则（如果一个细胞有1个或4个邻居，它是“开启”的），并且一次性对成千上万的细胞进行应用！结果看起来像一个活着的、不断生长的有机体。现在我们将把代码扩展成一个著名的CA模型，在这个模型中，虚拟的有机体可以四处移动、成长和死亡！
- en: PLAYING THE GAME OF LIFE
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 玩生命游戏
- en: 'In a 1970 issue of *Scientific American*, math popularizer Martin Gardner brought
    attention to a strange and wonderful game where cells live or die according to
    how many neighbors they have. The brainchild of English mathematician John Conway,
    this game features three simple rules:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在1970年《科学美国人》的一期中，数学普及者马丁·加德纳（Martin Gardner）提到了一个奇怪且神奇的游戏，细胞根据它们的邻居数来决定生死。这个游戏是由英国数学家约翰·康威（John
    Conway）创作的，拥有三条简单的规则：
- en: If a living cell has less than two living neighbors, it dies.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个活细胞有少于两个活邻居，它会死亡。
- en: If a living cell has more than three living neighbors, it dies.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个活细胞有超过三个活邻居，它会死亡。
- en: If a dead cell has exactly three living neighbors, it comes to life.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个死细胞有恰好三个活邻居，它会复活。
- en: With a simple set of rules like that, it’s surprising how intricate this game
    gets. In 1970, most people could only use checkers on a board to visualize the
    game, and one generation could take quite a while to calculate. Conveniently,
    we have a computer, and the CA code we just wrote has most of the code necessary
    to create this game in Python. Save the CA file we’ve been working on so far and
    then save it with different name, like *GameOfLife*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以这样的简单规则来讲，游戏竟然变得如此复杂。1970年，大多数人只能使用棋盘上的跳棋来可视化游戏，而且一代的计算可能需要很长时间。幸运的是，我们有计算机，而我们刚刚写的CA代码已经包含了用Python创建这个游戏所需的大部分代码。保存我们迄今为止编写的CA文件，然后另存为不同的名称，如*GameOfLife*。
- en: In this game, our cells will have diagonal neighbors too. That means we have
    to add four more values to our dr,dc line. [Listing 11-10](ch11.xhtml#ch11list10)
    shows the changes you need to make to the checkNeighbors() code.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，我们的细胞也有对角线邻居。这意味着我们必须在dr, dc行中添加四个额外的值。[清单 11-10](ch11.xhtml#ch11list10)显示了你需要对checkNeighbors()代码进行的更改。
- en: '*GameOfLife.pyde*'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameOfLife.pyde*'
- en: 'def checkNeighbors(self):'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 checkNeighbors(self):'
- en: neighbs = 0  #check the neighbors
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 'neighbs = 0  # 检查邻居'
- en: '➊ for dr,dc in [[-1,-1],[-1,0],[-1,1],[1,0],[1,-1],[1,1],[0,-1],[0,1]]:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 对于 dr,dc 在 [[-1,-1],[-1,0],[-1,1],[1,0],[1,-1],[1,1],[0,-1],[0,1]] 中：
- en: 'try:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: 'if cellList[self.r + dr][self.c + dc].state == 1:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 cellList[self.r + dr][self.c + dc].state == 1：
- en: neighbs += 1
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: neighbs += 1
- en: 'except IndexError:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 IndexError：
- en: continue
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 继续
- en: '➋ if self.state == 1:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 如果 self.state == 1：
- en: 'if neighbs in [2,3]:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果邻居数在 [2,3] 中：
- en: return 1
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 1
- en: return 0
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 0
- en: 'if neighbs == 3:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果邻居数为 3：
- en: return 1
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 1
- en: return 0
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 0
- en: '*Listing 11-10: Changes to the checkNeighbors() code to include diagonal neighbors*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表11-10：修改后的 checkNeighbors() 代码以包括对角线邻居*'
- en: 'First, we add four values ➊ to check the diagonal neighbors: [-1,-1] for the
    neighbor to the left and up, [1,1] for the neighbor to the right and down, and
    so on. Then we tell the program that if the cell is on ➋, check if it has two
    or three neighbors that are also on. If so, we tell the program to return 1, and
    if not, we tell the program to return 0\. Otherwise, if the cell is off, we tell
    it to check if it has three neighbors that are on. If it does, return 1; if doesn’t,
    return 0.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加四个值 ➊ 来检查对角线邻居：[-1,-1] 为左上邻居，[1,1] 为右下邻居，依此类推。然后我们告诉程序，如果单元格处于 ➋ 状态，检查是否有两个或三个邻居也处于开启状态。如果是这样，我们告诉程序返回
    1，否则返回 0。否则，如果单元格关闭，我们告诉它检查是否有三个邻居是开启的。如果有，返回 1；如果没有，返回 0。
- en: 'Then we place living cells randomly around the grid, so we have to import the
    choice() function from Python’s random module. Add this line to the top of the
    program:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们随机地在网格周围放置活跃的单元格，因此我们需要从 Python 的 random 模块导入 choice() 函数。将这行代码添加到程序的顶部：
- en: from random import choice
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 random 的 choice 函数
- en: 'Then we use the choice() function to randomly choose whether a new Cell is
    on or off. So all we have to do is change the append line in the createCellList()
    function to the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用 choice() 函数随机选择一个新的单元格是开启还是关闭。所以，我们只需将 createCellList() 函数中的 append 行修改为以下内容：
- en: newList [j].append(Cell(i,j,choice([0,1])))
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: newList [j].append(Cell(i,j,choice([0,1])))
- en: 'Now we no longer need the generation code from the previous file. The remaining
    code in the draw() function looks like this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不再需要前一个文件中的代代码。draw() 函数中的其余代码如下：
- en: 'def draw():'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '定义 draw():'
- en: global cellList
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量 cellList
- en: frameRate(10)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: frameRate(10)
- en: cellList = update(cellList)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: cellList = update(cellList)
- en: 'for row in cellList:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 cellList 中的每一行：
- en: 'for cell in row:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 对于行中的每个单元格：
- en: cell.display()
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: cell.display()
- en: Run this code, and you’ll see a wild, dynamic game play out, where organisms
    are moving, morphing, splitting, and interacting with other organisms, like in
    [Figure 11-10](ch11.xhtml#ch11fig10).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码，你会看到一场充满活力的动态游戏展现出来，生物在其中移动、变形、分裂，并与其他生物互动，正如在[图11-10](ch11.xhtml#ch11fig10)中所示。
- en: '![image](../images/f240-01.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f240-01.jpg)'
- en: '*Figure 11-10: The Game of Life in action!*'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-10：生命游戏的实际操作！*'
- en: It’s interesting how the “clouds” of cells morph, move, and collide with other
    clouds (families? colonies?). Some organisms wander around the screen until, eventually,
    the grid will settle into a kind of equilibrium. [Figure 11-11](ch11.xhtml#ch11fig11)
    shows an example of that kind of equilibrium.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 很有趣的是，这些单元格的“云”是如何变形、移动并与其他“云”（家庭？群体？）碰撞的。一些生物在屏幕上游荡，直到最终网格会趋于某种平衡状态。[图 11-11](ch11.xhtml#ch11fig11)
    显示了这种平衡的示例。
- en: '![image](../images/f240-02.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f240-02.jpg)'
- en: '*Figure 11-11: An example of the Game of Life that has entered a stable state*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-11：进入稳定状态的生命游戏示例*'
- en: In this example of a state of equilibrium, some shapes appear stable and unmoving,
    while other shapes become stuck in repeating patterns.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种平衡状态的示例中，一些形状看起来稳定且不动，而其他形状则陷入了重复的模式。
- en: THE ELEMENTARY CELLULAR AUTOMATON
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初级元胞自动机
- en: This last CA is really cool and involves a little more math, but it’s still
    a simple pattern that’s extended, though only in one dimension (which is why it’s
    called an “elementary CA”). We start off with one row of cells and set the middle
    cell’s state to one, as shown in [Figure 11-12](ch11.xhtml#ch11fig12).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这个 CA 非常酷，涉及一些更复杂的数学，但它仍然是一个简单的模式，只不过是扩展的，尽管只是扩展到一维（这就是它被称为“初级 CA”的原因）。我们从一行单元格开始，将中间的单元格状态设置为
    1，如[图11-12](ch11.xhtml#ch11fig12)所示。
- en: '![image](../images/f241-01.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f241-01.jpg)'
- en: '*Figure 11-12: The first row of an elementary CA*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-12：一个初级 CA 的第一行*'
- en: This is easy to code. Start a new Processing sketch and call it *elementaryCA.pyde*.
    The code to draw the first row of cells is shown in [Listing 11-11](ch11.xhtml#ch11list11).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很容易编写。创建一个新的Processing草图并命名为*elementaryCA.pyde*。绘制第一行细胞的代码见于[Listing 11-11](ch11.xhtml#ch11list11)。
- en: '*elementaryCA.pyde*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*elementaryCA.pyde*'
- en: '➊ #CA variables'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ #CA变量'
- en: w = 50
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: w = 50
- en: rows = 1
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: rows = 1
- en: cols = 11
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: cols = 11
- en: 'def setup():'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 'def setup():'
- en: global cells
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: global cells
- en: size(600,600)
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: size(600,600)
- en: '#first row:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '#第一行：'
- en: ➋ cells = []
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ cells = []
- en: 'for r in range(rows):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 'for r in range(rows):'
- en: cells.append([])
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: cells.append([])
- en: 'for c in range(cols):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 'for c in range(cols):'
- en: cells[r].append(0)
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: cells[r].append(0)
- en: ➌ cells[0][cols//2] = 1
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ cells[0][cols//2] = 1
- en: 'def draw():'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw():'
- en: 'background(255) #white'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 'background(255) #白色'
- en: '#draw the CA'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '#绘制CA'
- en: 'for i, cell in enumerate(cells): #rows'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i, cell in enumerate(cells): #行'
- en: 'for j, v in enumerate(cell): #columns'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j, v in enumerate(cell): #列'
- en: '➍ if v == 1:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ if v == 1:'
- en: fill(0)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: fill(0)
- en: 'else: fill(255)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 'else: fill(255)'
- en: ➎ rect(j*w-(cols*w-width)/2,w*i,w,w)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ rect(j*w-(cols*w-width)/2,w*i,w,w)
- en: '*Listing 11-11: Drawing the first row (generation) of the elementary CA*'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-11：绘制基础CA的第一行（世代）*'
- en: First, we declare a few important variables ➊, such as the size of each cell
    and the number of rows and columns in our CA. Next, we start our cells list ➋.
    We create rows number of rows and append cols number of 0’s in each list inside
    cells. We set the middle cell in the row to 1 (or on) ➌. In the draw() function,
    we loop through the rows (there will be more than one row soon!) and columns using
    enumerate. We check if the element is a 1, and if so, we color it black ➍. Otherwise,
    we color it white. Finally, we draw the square for the cell ➎. The x-value looks
    a bit complicated, but this just makes sure the CA is always centered.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们声明一些重要的变量 ➊，例如每个细胞的大小以及CA中的行数和列数。接下来，我们开始创建cells列表 ➋。我们创建行数为rows的行，并在每个列表中附加列数为cols的0。我们将行中的中间细胞设置为1（或开启）
    ➌。在draw()函数中，我们使用enumerate遍历行（很快会有不止一行！）和列。我们检查元素是否为1，如果是，就将其涂黑 ➍。否则，我们将其涂白。最后，我们绘制细胞的正方形
    ➎。x值看起来有点复杂，但这只是为了确保CA始终居中。
- en: 'When you run this code, you should see what’s shown in [Figure 11-12](ch11.xhtml#ch11fig12):
    a row of cells with one “on” cell in the center. The state of the cells in the
    next row of the CA will depend on the rules we set up for a cell and its two neighbors.
    How many possibilities are there? Each cell has two possible states (1 or 0, or
    “on” or “off”) so that’s two states for the left neighbor, two for the center
    cell, and two for the right neighbor. That’s 2 × 2 × 2 = 8 possibilities. All
    the combinations are shown in [Figure 11-13](ch11.xhtml#ch11fig13).'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你应该看到[图11-12](ch11.xhtml#ch11fig12)所示的效果：一行细胞，中间有一个“开启”的细胞。CA中下一行细胞的状态将取决于我们为一个细胞及其两个邻居设置的规则。有多少种可能性？每个细胞有两种可能的状态（1或0，或“开启”或“关闭”），所以左邻居有两种状态，中间细胞有两种状态，右邻居也有两种状态。这就是2
    × 2 × 2 = 8种可能性。所有组合见于[图11-13](ch11.xhtml#ch11fig13)。
- en: '![image](../images/f242-01.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f242-01.jpg)'
- en: '*Figure 11-13: All the possible combinations of a cell and its two neighbors*'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-13：细胞及其两个邻居的所有可能组合*'
- en: 'The first possibility is that the center cell is on and both its neighbors
    are on. The next possibility is that the center cell is on, the left neighbor
    is on, and the right neighbor is off—and so on. This order is very important.
    (Do you see the pattern?) How are we going to describe these possibilities to
    the computer program? We could write eight conditional statements like this one:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种可能性是中心细胞开启，且两个邻居都开启。接下来的可能性是中心细胞开启，左邻居开启，右邻居关闭，依此类推。这个顺序非常重要。（你看出规律了吗？）我们怎么将这些可能性描述给计算机程序呢？我们可以写出类似这样的八个条件语句：
- en: 'if left == 1 and me == 1 and right == 1:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 'if left == 1 and me == 1 and right == 1:'
- en: But there’s an easier way. In A *New Kind of Science*, Stephen Wolfram assigns
    numbers to the possibilities according to the binary number the three cells represent.
    Keeping in mind that 1 is on and 0 is off, you can see that 111 is 7 in binary,
    110 is 6 in binary, and so on, as illustrated in [Figure 11-14](ch11.xhtml#ch11fig14).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有一种更简单的方法。在《*新科学的本质*》中，斯蒂芬·沃尔夫拉姆根据三个细胞所代表的二进制数字给这些可能性分配了数字。记住，1代表开，0代表关，你可以看到111在二进制中是7，110是6，以此类推，正如[图11-14](ch11.xhtml#ch11fig14)所示。
- en: '![image](../images/f242-02.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f242-02.jpg)'
- en: '*Figure 11-14: The numbering method for the eight possibilities*'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-14：八种可能性的编号方法*'
- en: Now that we’ve numbered each possibility, we can create a rule set—that is,
    a list that will contain the rules for what to do with each possibility in the
    next generation. Notice the numbers are like the indices of a list, except backwards.
    We can easily get around that. We can assign a result to each one randomly or
    because of some plan. [Figure 11-15](ch11.xhtml#ch11fig15) shows one set of results.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为每个可能性编号，我们可以创建一个规则集——即一个包含在下一代中如何处理每个可能性的规则的列表。注意，这些数字像列表的索引，只是反向排列。我们可以轻松地解决这个问题。我们可以随机或根据某些计划为每个可能性分配一个结果。[图
    11-15](ch11.xhtml#ch11fig15) 展示了一组结果。
- en: '![image](../images/f242-03.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f242-03.jpg)'
- en: '*Figure 11-15: A set of results assigned to each possibility in the CA*'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-15：分配给 CA 中每个可能性的结果集*'
- en: 'The box under each possibility signifies the result, or the state of the cell
    in the next generation of the CA. The white box under “possibility 7” on the left
    means “if the cell is on and both of its neighbors are on, it will be off in the
    next generation.” Same for the next two possibilities (which don’t exist in our
    CA so far): the result is “off.” As illustrated earlier in [Figure 11-12](ch11.xhtml#ch11fig12),
    we have a lot of “off” cells surrounded by “off” cells, which is the possibility
    shown on the far right of [Figure 11-14](ch11.xhtml#ch11fig14): three white squares.
    In this case, the cell in the middle will be off in the next generation. We also
    have one “on” cell surrounded by two “off” cells (possibility 5). In the next
    generation, the cell will be on. We’ll use 0’s and 1’s for our ruleset list, as
    illustrated in [Figure 11-16](ch11.xhtml#ch11fig16).'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可能性下方的框表示结果，或该细胞在 CA 下一代中的状态。左侧“可能性 7”下方的白色框表示“如果该细胞开启且其两个邻居都开启，它将在下一代中关闭。”
    接下来的两个可能性（在我们的 CA 中尚未出现）：结果是“关闭”。如之前在 [图 11-12](ch11.xhtml#ch11fig12) 中所示，我们有许多“关闭”细胞被“关闭”细胞包围，这正是
    [图 11-14](ch11.xhtml#ch11fig14) 最右侧所示的可能性：三个白色方块。在这种情况下，中间的细胞将在下一代中关闭。我们还看到一个“开启”的细胞被两个“关闭”的细胞包围（可能性
    5）。在下一代中，这个细胞将保持开启。我们将使用 0 和 1 来表示我们的规则集，如 [图 11-16](ch11.xhtml#ch11fig16) 中所示。
- en: '![image](../images/f243-01.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f243-01.jpg)'
- en: '*Figure 11-16: Putting the rules for generating the next row into a list*'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-16：将生成下一行的规则放入列表中*'
- en: 'We’ll collect all these numbers into a list called ruleset, which we’ll add
    just before the setup() function:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把所有这些数字收集到一个名为 ruleset 的列表中，并将在 setup() 函数之前添加它：
- en: ruleset = [0,0,0,1,1,1,1,0]
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ruleset = [0,0,0,1,1,1,1,0]
- en: The order of the possibilities is important because this rule set is referred
    to as “Rule 30” (00011110 is 30 in binary). Our task is to create the next row
    according to the rules. Let’s create a generate() function that looks at the first
    row and generates the second row, then looks at the second row and generates the
    third row, and so on. Add the code shown in [Listing 11-12](ch11.xhtml#ch11list12).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 可能性的重要性在于，这组规则被称为“规则 30”（00011110 在二进制中是 30）。我们的任务是根据这些规则创建下一行。让我们创建一个 generate()
    函数，它查看第一行并生成第二行，然后查看第二行并生成第三行，以此类推。添加 [列表 11-12](ch11.xhtml#ch11list12) 中显示的代码。
- en: '*elementaryCA.pyde*'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '*elementaryCA.pyde*'
- en: '#CA variables'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '#CA 变量'
- en: w = 50
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: w = 50
- en: ➊ rows = 10
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ rows = 10
- en: cols = 100
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: cols = 100
- en: --snip--
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: --省略--
- en: 'ruleset = [0,0,0,1,1,1,1,0] #rule 30'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 'ruleset = [0,0,0,1,1,1,1,0] #规则 30'
- en: '➋ def rules(a,b,c):'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ def rules(a,b,c):'
- en: return ruleset[7 - (4*a + 2*b + c)]
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: return ruleset[7 - (4*a + 2*b + c)]
- en: 'def generate():'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 'def generate():'
- en: 'for i, row in enumerate(cells): #look at first row'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i, row in enumerate(cells): #查看第一行'
- en: 'for j in range(1,len(row)-1):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(1,len(row)-1):'
- en: left = row[j-1]
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: left = row[j-1]
- en: me = row[j]
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: me = row[j]
- en: right = row[j+1]
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: right = row[j+1]
- en: 'if i < len(cells) - 1:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 'if i < len(cells) - 1:'
- en: cells[i+1][j] = rules(left,me,right)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: cells[i+1][j] = rules(left,me,right)
- en: return cells
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: return cells
- en: '*Listing 11-12: Writing the generate() function to generate new rows in the
    CA*'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-12：编写 generate() 函数来生成 CA 中的新行*'
- en: 'First, we make the CA larger by updating the number of rows and columns ➊.
    Next, we create the rules() function ➋, which takes three parameters: the left
    neighbor’s number, the current cell’s number, and the right neighbor’s number.
    The function checks the ruleset and returns the value for the cell in the next
    generation. We make use of the binary numbers, and the line 4*a + 2*b + c converts
    “1,1,1” to 7 and “1,1,0” to 6, and so on. However, as you’ll recall from [Figure
    11-15](ch11.xhtml#ch11fig15), the indices are in reverse order, so we subtract
    the total from 7 to get the proper index of the ruleset.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过更新行数和列数 ➊ 来增大 CA 的大小。接下来，我们创建 rules() 函数 ➋，该函数接受三个参数：左邻居的值、当前细胞的值和右邻居的值。该函数检查规则集，并返回下一代中该细胞的值。我们利用二进制数字，行
    4*a + 2*b + c 将“1,1,1”转换为 7，将“1,1,0”转换为 6，依此类推。然而，正如你从[图 11-15](ch11.xhtml#ch11fig15)中回忆起的那样，索引的顺序是反的，所以我们从
    7 中减去总值，以获得规则集中的正确索引。
- en: 'Add the following line to the end of the setup() function:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在 setup() 函数的末尾添加以下代码：
- en: cells = generate()
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: cells = generate()
- en: This creates the full CA and not just the first row. When you run this code,
    you should see the first 10 rows of a CA made using “Rule 30,” as illustrated
    in [Figure 11-17](ch11.xhtml#ch11fig17).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成完整的 CA，而不仅仅是第一行。当你运行这段代码时，你应该能看到使用“规则 30”生成的 CA 的前 10 行，如[图 11-17](ch11.xhtml#ch11fig17)所示。
- en: '![image](../images/f244-01.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f244-01.jpg)'
- en: '*Figure 11-17: The first 10 rows of Rule 30*'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-17：规则 30 的前 10 行*'
- en: '![image](../images/f244-02.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f244-02.jpg)'
- en: '*Figure 11-18: More of Rule 30*'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-18：更多的规则 30*'
- en: The program is going through each row, starting at the top, and generating the
    next row according to the rules we gave it in the ruleset. What if we keep going?
    Change the number of rows and columns to 1000 and the width (w) of each cell to
    3\. Add noStroke() to the setup() function to get rid of the outline of the cells,
    and then run the sketch. You should see what’s in [Figure 11-18](ch11.xhtml#ch11fig18).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 程序正在逐行生成，从上到下，并根据我们在规则集中提供的规则生成下一行。如果我们继续进行呢？将行数和列数更改为 1000，将每个细胞的宽度（w）更改为 3。将
    noStroke() 添加到 setup() 函数中以去掉细胞的轮廓，然后运行草图。你应该看到[图 11-18](ch11.xhtml#ch11fig18)中的内容。
- en: Rule 30 is a fascinating design because it’s not completely random, but it’s
    not completely regular either. Rule 73 is also cool; in fact a woman named Fabienne
    Serriere programs the rule into a knitting machine to create scarves with the
    pattern, like in [Figure 11-19](ch11.xhtml#ch11fig19). You can order scarves with
    this and other algorithmically generated rules on them from *[https://knityak.com/](https://knityak.com/)*.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 规则 30 是一个非常有趣的设计，因为它既不完全是随机的，也不完全是规则的。规则 73 也很酷；事实上，一位名叫 Fabienne Serriere 的女性将这个规则编程到一台编织机上，创造出带有这种图案的围巾，正如在[图
    11-19](ch11.xhtml#ch11fig19)所示。你可以从 *[https://knityak.com/](https://knityak.com/)*
    订购带有这种以及其他算法生成规则的围巾。
- en: '![image](../images/f245-01.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f245-01.jpg)'
- en: '*Figure 11-19: A scarf whose design is a cellular automaton: Rule 73!*'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-19：一条围巾，图案为细胞自动机：规则 73！*'
- en: 'EXERCISE 11-2: CHANGING THE RULE SET'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 11-2：更改规则集
- en: 'Change ruleset to the binary form of the number 90\. What does the resulting
    CA look like? Hint: it’s a fractal.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 将规则集更改为数字 90 的二进制形式。生成的 CA 看起来怎么样？提示：它是一个分形。
- en: 'EXERCISE 11-3: ZOOMING IN AND OUT'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 11-3：放大和缩小
- en: Use the keyPressed() function you learned about in [Chapter 10](ch10.xhtml#ch10)
    to change the value of the width variable w using the up and down arrow keys.
    This should let you zoom in and out of the CA!
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你在[第 10 章](ch10.xhtml#ch10)中学到的 keyPressed() 函数，通过上下箭头键来改变变量 w 的值。这应该能让你在
    CA 中进行放大和缩小！
- en: '### SUMMARY'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '### 小结'
- en: In this chapter, you learned to use Python to create cellular automata, or cells
    that act independently, according to specific rules. We wrote programs to make
    a huge grid of these cells follow certain rules and update themselves, generation
    after generation, and we created unexpectedly beautiful designs and surprisingly
    life-like behavior.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何使用 Python 创建细胞自动机，或者说是根据特定规则独立行动的细胞。我们编写程序，使这些细胞形成一个巨大的网格，遵循特定规则并自我更新，一代又一代，我们创造了出乎意料的美丽图案和惊人地像生命一样的行为。
- en: In the next chapter, we’ll create virtual organisms that solve problems for
    us! These organisms will be able to guess a secret phrase and find the shortest
    route through a bunch of cities just by evolving better and better solutions.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建能够为我们解决问题的虚拟生物！这些生物将能够通过不断进化更好的解决方案来猜测一个秘密短语，并找到通过一堆城市的最短路线。
