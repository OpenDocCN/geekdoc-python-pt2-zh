["```py\nif __name__ == '__main__':\n   print('Ready!')\n```", "```py\n#!/usr/bin/env bash\nPYTHONPATH=$PWD python3 apps/aff_transf_motion/main.py\n```", "```py\n$ bash ./aff_motion.sh < apps/aff_transf_motion/test.txt\n```", "```py\n$ chmod +x aff_motion.sh\n```", "```py\n$ ./aff_motion.sh < apps/aff_transf_motion/test.txt\n```", "```py\n{\n  \"frames\": 200,\n  \"axes\": {\n    \"length\": 100,\n    \"arrow-length\": 20,\n    \"arrow-height\": 15,\n    \"stroke-width\": 2,\n    \"x-color\": \"#D53636\",\n    \"y-color\": \"#33FF86\"\n  },\n  \"geometry\": {\n    \"stroke-color\": \"#3F4783\",\n    \"stroke-width\": 3\n  }\n}\n```", "```py\nimport json\n\nimport pkg_resources as res\n\ndef read_config():\n    config = res.resource_string(__name__, 'config.json')\n    return json.loads(config)\n```", "```py\nsx <value>\nsy <value>\nshx <value>\nshy <value>\ntx <value>\nty <value>\n```", "```py\ntransformation: <value> <value> <value> <value> <value> <value>\n```", "```py\ncirc <cx> <cy> <r>\n```", "```py\nrect <ox> <oy> <w> <h>\n```", "```py\npoly [<x1> <y1> <x2> <y2> <x3> <y3> ...]\n```", "```py\nsegm <sx> <sy> <ex> <ey>\n```", "```py\nsx 1.2\nsy 1.4\nshx 2.0\nshy 3.0\ntx 50.0\nty 25.0\n\ncirc 150 40 20\nrect 70 60 40 100\nrect 100 90 40 100\npoly 30 10 80 10 30 90\nsegm 10 20 200 240\n```", "```py\ndef read_input():\n    transform = __read_transform()\n    primitives = __read_primitives()\n    return transform, primitives\n\ndef __read_transform():\n    return None\n\ndef __read_primitives():\n    return None\n```", "```py\nimport re\n\n__TRANSF_VAL_RE = r'(?P<val>-?\\d+(\\.\\d+)?)'\n\ndef parse_transform_term(term, line):\n    __ensure_term_name(term, line)\n    return __parse_transform_term(line)\n\ndef __ensure_term_name(name, line):\n    if name not in line:\n        raise ValueError(f'Expected {name} term')\n\ndef __parse_transform_term(line):\n    matches = re.search(__TRANSF_VAL_RE, line)\n    if not matches:\n        raise ValueError('Couldn\\'t read transform term')\n\n    return float(matches.group('val'))\n```", "```py\nfrom apps.aff_transf_motion.parse_transform import parse_transform_term\nfrom geom2d import AffineTransform\n```", "```py\n--snip--\n\ndef __read_transform():\n    return AffineTransform(\n        sx=parse_transform_term('sx', input()),\n        sy=parse_transform_term('sy', input()),\n        shx=parse_transform_term('shx', input()),\n        shy=parse_transform_term('shy', input()),\n        tx=parse_transform_term('tx', input()),\n        ty=parse_transform_term('ty', input())\n    )\n```", "```py\nfrom apps.aff_transf_motion.input import read_input\n\nif __name__ == '__main__':\n    (transform, primitives) = read_input()\n    print(transform)\n```", "```py\nInput is being redirected from .../test.txt\n(sx: 1.2, sy: 1.4, shx: 2.0, shy: 3.0, tx: 50.0, ty: 25.0)\n\nProcess finished with exit code 0\n```", "```py\n--snip--\n\ndef __read_primitives():\n    has_more_lines = True\n\n    while has_more_lines:\n        try:\n            line = input()\n            print('got line -->', line)\n\n        except EOFError:\n            has_more_lines = False\n```", "```py\ngot line -->\ngot line --> circ 150 40 20\ngot line --> rect 70 60 40 100\ngot line --> rect 100 90 40 100\ngot line --> poly 30 10 80 10 30 90\ngot line --> segm 10 20 200 240\n```", "```py\nimport re\n\nfrom geom2d import Circle, Point, Rect, Size, Segment\nfrom geom2d import make_polygon_from_coords\n\n__NUM_RE = r'\\d+(\\.\\d+)?'\n\n__CIRC_RE = rf'circ (?P<cx>{__NUM_RE}) (?P<cy>{__NUM_RE}) ' \\\n    rf'(?P<r>{__NUM_RE})'\n\n__RECT_RE = rf'rect (?P<ox>{__NUM_RE}) (?P<oy>{__NUM_RE}) ' \\\n    rf'(?P<w>{__NUM_RE}) (?P<h>{__NUM_RE})'\n\n__POLY_RE = rf'poly (?P<coords>[\\d\\s\\.]+)'\n\n__SEGM_RE = rf'segm (?P<sx>{__NUM_RE}) (?P<sy>{__NUM_RE}) ' \\\n    rf'(?P<ex>{__NUM_RE}) (?P<ey>{__NUM_RE})'\n```", "```py\nif can_parse_circle(line):\n    parse_circle(line)\n\nelif can_parse_rect(line):\n    parse_rect(line)\n\nelif can_parse_polygon(line):\n    parse_polygon(line)\n\nelif can_parse_segment(line):\n    parse_segment(line)\n\nelse:\n    handle_unknown_line(line)\n```", "```py\n--snip--\n\ndef can_parse_circle(line):\n    return re.match(__CIRC_RE, line)\n\ndef parse_circle(line):\n    match = re.match(__CIRC_RE, line)\n    return Circle(\n        center=Point(\n            float(match.group('cx')),\n            float(match.group('cy'))\n        ),\n        radius=float(match.group('r'))\n    )\n```", "```py\n--snip--\n\ndef can_parse_rect(line):\n    return re.match(__RECT_RE, line)\n\ndef parse_rect(line):\n    match = re.match(__RECT_RE, line)\n    return Rect(\n        origin=Point(\n            float(match.group('ox')),\n            float(match.group('oy'))\n        ),\n        size=Size(\n            float(match.group('w')),\n            float(match.group('h'))\n        )\n    )\n```", "```py\n--snip--\n\ndef can_parse_polygon(line):\n    return re.match(__POLY_RE, line)\n\ndef parse_polygon(line):\n    match = re.match(__POLY_RE, line)\n    coords = [float(n) for n in match.group('coords').split(' ')]\n    return make_polygon_from_coords(coords)\n```", "```py\nfrom geom2d import make_polygon_from_coords\n```", "```py\n--snip--\n\ndef can_parse_segment(line):\n    return re.match(__SEGM_RE, line)\n\ndef parse_segment(line):\n    match = re.match(__SEGM_RE, line)\n    return Segment(\n        start=Point(\n            float(match.group('sx')),\n            float(match.group('sy'))\n        ),\n        end=Point(\n            float(match.group('ex')),\n            float(match.group('ey'))\n        )\n    )\n```", "```py\nfrom apps.aff_transf_motion.parse_geom import *\n```", "```py\n--snip--\n\ndef __read_primitives():\n    prims = {'circs': [], 'rects': [], 'polys': [], 'segs': []}\n    has_more_lines = True\n\n    while has_more_lines:\n        try:\n            line = input()\n\n            if can_parse_circle(line):\n                prims['circs'].append(parse_circle(line))\n\n            elif can_parse_rect(line):\n                prims['rects'].append(parse_rect(line))\n\n            elif can_parse_polygon(line):\n                prims['polys'].append(parse_polygon(line))\n\n            elif can_parse_segment(line):\n                prims['segs'].append(parse_segment(line))\n\n        except EOFError:\n            has_more_lines = False\n\n    return prims\n```", "```py\nfrom apps.aff_transf_motion.parse_geom import *\nfrom apps.aff_transf_motion.parse_transform import parse_transform_term\nfrom geom2d import AffineTransform\n\ndef read_input():\n    transform = __read_transform()\n    primitives = __read_primitives()\n    return transform, primitives\n\ndef __read_transform():\n    return AffineTransform(\n        sx=parse_transform_term('sx', input()),\n        sy=parse_transform_term('sy', input()),\n        shx=parse_transform_term('shx', input()),\n        shy=parse_transform_term('shy', input()),\n        tx=parse_transform_term('tx', input()),\n        ty=parse_transform_term('ty', input())\n    )\n\ndef __read_primitives():\n    prims = {'circs': [], 'rects': [], 'polys': [], 'segs': []}\n    has_more_lines = True\n\n    while has_more_lines:\n        try:\n            line = input()\n\n            if can_parse_circle(line):\n                prims['circs'].append(parse_circle(line))\n\n            elif can_parse_rect(line):\n                prims['rects'].append(parse_rect(line))\n\n            elif can_parse_polygon(line):\n                prims['polys'].append(parse_polygon(line))\n\n            elif can_parse_segment(line):\n                prims['segs'].append(parse_segment(line))\n\n        except EOFError:\n            has_more_lines = False\n\n    return prims\n```", "```py\nfrom tkinter import Tk, Canvas, Button\n\ndef simulate(transform, primitives, config):\n    # ---------- UI DEFINITION ---------- #\n    tk = Tk()\n    tk.title(\"Affine Transformations\")\n\n    canvas = Canvas(tk, width=800, height=800)\n    canvas.grid(row=0, column=0)\n\n    def start_simulation():\n        tk.update()\n        print('Starting Simulation...')\n\n    Button(tk, text='Play', command=start_simulation) \\\n        .grid(row=1, column=0)\n\n    # ---------- UPDATE, DRAW & CONTINUE ---------- #\n    def update_system(time_delta_s, time_s, frame):\n        pass\n\n    def redraw():\n        pass\n\n    def should_continue(frame, time_s):\n        pass\n\n    # ---------- MAIN LOOP ---------- #\n    redraw()\n    tk.mainloop()\n```", "```py\nfrom apps.aff_transf_motion.config import read_config\nfrom apps.aff_transf_motion.input import read_input\nfrom apps.aff_transf_motion.simulation import simulate\n\nif __name__ == '__main__':\n    (transform, primitives) = read_input()\n    config = read_config()\n    simulate(transform, primitives, config)\n```", "```py\nfrom tkinter import Tk, Canvas, Button\n\nfrom geom2d import affine_transforms as tf\n\ndef simulate(transform, primitives, config):\n    # ---------- UI DEFINITION ---------- #\n    --snip--\n\n    # ---------- UPDATE, DRAW & CONTINUE ---------- #\n    frames = config['frames']\n    transform_seq = __make_transform_sequence(transform, frames)\n\n    --snip--\n\ndef __make_transform_sequence(end_transform, frames):\n    start_transform = tf.AffineTransform(sx=1, sy=1, tx=20, ty=20)\n    return tf.ease_in_out_interpolation(\n        start_transform, end_transform, frames\n    )\n```", "```py\nfrom tkinter import Tk, Canvas, Button\n\nfrom geom2d import affine_transforms as tf\nfrom graphic.simulation import CanvasDrawing\n\ndef simulate(transform, primitives, config):\n    # ---------- UI DEFINITION ---------- #\n    --snip--\n\n    # ---------- UPDATE, DRAW & CONTINUE ---------- #\n    frames = config['frames']\n    transform_seq = __make_transform_sequence(transform, frames)\n  ➊ drawing = CanvasDrawing(canvas, transform_seq[0])\n\n    def update_system(time_delta_s, time_s, frame):\n     ➋ drawing.transform = transform_seq[frame - 1]\n        tk.update()\n\n  ➌ def redraw():\n        drawing.clear_drawing()\n\n        drawing.outline_width = config['geometry']['stroke-width']\n        drawing.outline_color = config['geometry']['stroke-color']\n\n        for circle in primitives['circs']:\n            drawing.draw_circle(circle)\n\n        for rect in primitives['rects']:\n            drawing.draw_rectangle(rect)\n\n        for polygon in primitives['polys']:\n            drawing.draw_polygon(polygon)\n\n        for segment in primitives['segs']:\n            drawing.draw_segment(segment)\n\n    def should_continue(frame, time_s):\n     ➍ return frame <= frames\n\n    # ---------- MAIN LOOP ---------- #\n    redraw()\n    tk.mainloop()\n\n--snip--\n```", "```py\nfrom tkinter import Tk, Canvas, Button\n\nfrom geom2d import affine_transforms as tf, Segment, Point\nfrom graphic.simulation import CanvasDrawing, main_loop\n\ndef simulate(transform, primitives, config):\n    # ---------- UI DEFINITION ---------- #\n    --snip--\n\n    def start_simulation():\n        tk.update()\n     ➊ main_loop(update_system, redraw, should_continue)\n\n    Button(tk, text='Play', command=start_simulation) \\\n        .grid(row=1, column=0)\n\n    # ---------- UPDATE, DRAW & CONTINUE ---------- #\n    frames = config['frames']\n    transform_seq = __make_transform_sequence(transform, frames)\n    axis_length = config['axes']['length']\n ➋ x_axis = Segment(Point(0, 0), Point(axis_length, 0))\n ➌ y_axis = Segment(Point(0, 0), Point(0, axis_length))\n    drawing = CanvasDrawing(canvas, transform_seq[0])\n\n    def update_system(time_delta_s, time_s, frame):\n        drawing.transform = transform_seq[frame - 1]\n        tk.update()\n\n    def redraw():\n        drawing.clear_drawing()\n\n        drawing.outline_width = config['axes']['stroke-width']\n        drawing.outline_color = config['axes']['x-color']\n     ➍ drawing.draw_arrow(\n            x_axis,\n            config['axes']['arrow-length'],\n            config['axes']['arrow-height']\n        )\n\n        drawing.outline_color = config['axes']['y-color']\n     ➎ drawing.draw_arrow(\n            y_axis,\n            config['axes']['arrow-length'],\n            config['axes']['arrow-height']\n        )\n\n        --snip--\n\n    def should_continue(frame, time_s):\n        return frame <= frames\n    # ---------- MAIN LOOP ---------- #\n    redraw()\n    tk.mainloop()\n\n--snip--\n```", "```py\nfrom tkinter import Tk, Canvas, Button\n\nfrom geom2d import affine_transforms as tf, Segment, Point\nfrom graphic.simulation import CanvasDrawing, main_loop\n\ndef simulate(transform, primitives, config):\n    # ---------- UI DEFINITION ---------- #\n    tk = Tk()\n    tk.title(\"Affine Transformations\")\n\n    canvas = Canvas(tk, width=800, height=800)\n    canvas.grid(row=0, column=0)\n\n    def start_simulation():\n        tk.update()\n        main_loop(update_system, redraw, should_continue)\n\n    Button(tk, text='Play', command=start_simulation) \\\n        .grid(row=1, column=0)\n\n    # ---------- UPDATE, DRAW & CONTINUE ---------- #\n    frames = config['frames']\n    transform_seq = __make_transform_sequence(transform, frames)\n    axis_length = config['axes']['length']\n    x_axis = Segment(Point(0, 0), Point(axis_length, 0))\n    y_axis = Segment(Point(0, 0), Point(0, axis_length))\n    drawing = CanvasDrawing(canvas, transform_seq[0])\n\n    def update_system(time_delta_s, time_s, frame):\n        drawing.transform = transform_seq[frame - 1]\n        tk.update()\n\n    def redraw():\n        drawing.clear_drawing()\n\n        drawing.outline_width = config['axes']['stroke-width']\n        drawing.outline_color = config['axes']['x-color']\n        drawing.draw_arrow(\n            x_axis,\n            config['axes']['arrow-length'],\n            config['axes']['arrow-height']\n        )\n\n        drawing.outline_color = config['axes']['y-color']\n        drawing.draw_arrow(\n            y_axis,\n            config['axes']['arrow-length'],\n            config['axes']['arrow-height']\n        )\n\n        drawing.outline_width = config['geometry']['stroke-width']\n        drawing.outline_color = config['geometry']['stroke-color']\n\n        for circle in primitives['circs']:\n            drawing.draw_circle(circle)\n\n        for rect in primitives['rects']:\n            drawing.draw_rectangle(rect)\n\n        for polygon in primitives['polys']:\n            drawing.draw_polygon(polygon)\n\n        for segment in primitives['segs']:\n            drawing.draw_segment(segment)\n\n    def should_continue(frame, time_s):\n        return frame <= frames\n\n    # ---------- MAIN LOOP ---------- #\n    redraw()\n    tk.mainloop()\n\ndef __make_transform_sequence(end_transform, frames):\n    start_transform = tf.AffineTransform(sx=1, sy=1, tx=20, ty=20)\n    return tf.ease_in_out_interpolation(\n        start_transform, end_transform, frames\n    )\n```"]