<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="header1001" class="chapter" epub:type="chapter" id="ch10" role="doc-chapter">
<header id="header1001">
<h1 class="cn"><span aria-label=" Page 178. " class="page" epub:type="pagebreak" id="p178" role="doc-pagebreak"/><span aria-label=" Page 179. " class="page" epub:type="pagebreak" id="p179" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rch10">10</a></h1>
<h1 class="ct">Conway’s Game of Life on a Torus</h1>
</header>
<figure class="figure">
<p class="fig"><img alt="" height="100" src="images/nsp-venkitachalam503045-circle-image.jpg" width="100"/></p>
</figure>
<p class="pf">In <a class="xref" href="nsp-venkitachalam503045-0015.xhtml#ch03">Chapter 3</a>, we implemented Conway’s Game of Life using Python and the <code>matplotlib</code> library. You may recall one interesting aspect of that project: it used toroidal boundary conditions. <a class="xref" href="nsp-venkitachalam503045-0015.xhtml#fig3-2">Figure 3-2</a> on <a class="xref" href="nsp-venkitachalam503045-0015.xhtml#p48">page 48</a> showed how we were effectively treating the flat, 2D grid of the simulation as a 3D toroidal surface, thanks to how the boundary conditions stitched the edges together. In the <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#ch09">previous chapter</a>, you were introduced to OpenGL and learned how to render 3D objects. Let’s now put together your experience with the Game of Life and OpenGL to re-create the Conway’s simulation in 3D, on an actual torus.</p>
<p><span aria-label=" Page 180. " class="page" epub:type="pagebreak" id="p180" role="doc-pagebreak"/>In this project, you’ll start by computing the 3D geometry of a torus. Then you’ll arrange the vertices of the torus in a way that’s easy to draw and color in OpenGL. You’ll set up a revolving camera to view the torus from all sides and also implement some basic lighting in the shaders. Finally, you’ll adapt the Game of Life code from <a class="xref" href="nsp-venkitachalam503045-0015.xhtml#ch03">Chapter 3</a> to color the grid on the torus. As the simulation proceeds, you’ll see the Game of Life come alive on the surface of the torus!</p>
<p>Here are the main topics covered in this project:</p>
<ul style="list-style-type:none">
<li class="blf">• Using matrix math to construct the 3D geometry of a torus</li>
<li class="bl">• Implementing a coloring scheme for the Game of Life grid on the torus</li>
<li class="bl">• Implementing a revolving camera in OpenGL</li>
<li class="bl">• Implementing simple lighting in OpenGL</li>
</ul>
<section>
<h2 class="ah" id="ah1201"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1201">How It Works</a></h2>
<p class="paft">Before getting into the code, let’s consider how you can render, light, and view a 3D torus using OpenGL. It all begins with computing the vertices that make up the torus.</p>
<section>
<h3 class="bh" id="bh1201"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1201">Computing Vertices</a></h3>
<p class="paft">A torus is essentially a collection of circles, or rings, arranged in a circle around a central point. However, you can’t actually draw circles with OpenGL; they need to be <i>discretized</i>, or represented as a series of vertices connected by straight lines. The simplified model in <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#fig10-1">Figure 10-1</a> illustrates how you can begin defining the <span class="idx" data-level1="computing vertices" data-term="torus"/>torus as a collection of vertices.</p>
<figure class="figure" id="fig10-1">
<p class="fig"><img alt="" height="559" src="images/nsp-venkitachalam503045-f10001.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 10-1:</span> A torus rendering model. The simplified torus is on the left. An individual “ring” that makes up the torus is on the right.</p>
</figcaption>
</figure>
<p>The right side of <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#fig10-1">Figure 10-1</a> shows a ring with radius <i>r</i> discretized to have <i>M</i> = 5 points. The left side of <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#fig10-1">Figure 10-1</a> models a simple torus with major radius <i>R</i> by arranging <i>N</i> = 6 such discretized rings (labeled 0 through 5) around a central point. (The <i>major radius</i> is the distance from <span aria-label=" Page 181. " class="page" epub:type="pagebreak" id="p181" role="doc-pagebreak"/>the center of the torus’s hole to the center of its outer ring.) Don’t worry about the blocky nature of the torus shown in the figure. It gets smoother as you increase the values of <i>N</i> and <i>M</i>.</p>
<p>The torus is filled out by drawing bands to connect adjacent rings. You’ll draw the bands using <code>GL_TRIANGLE_STRIP</code> primitives, and each cell in the Game of Life simulation will consist of two adjacent triangles on a strip, which together form a <i>quad</i>, or quadrilateral. When a cell is ON you’ll color its quad black, and when a cell is OFF you’ll color it white.</p>
<p>To compute the vertices of the torus, you first need to define a coordinate system for it. Let’s assume that the torus is on the XY plane, centered at the origin, with the line through the center of the torus aligned along the z-axis, as shown in <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#fig10-2">Figure 10-2</a>.</p>
<figure class="figure" id="fig10-2">
<p class="fig"><img alt="" height="925" src="images/nsp-venkitachalam503045-f10002.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 10-2:</span> The rendering strategy for the torus</p>
</figcaption>
</figure>
<p>The vertices for a circle <i>C</i><sub>3</sub> on the torus at an angle <span class="dcrit-i">θ</span> relative to the x-axis can be computed as follows:</p>
<ol style="list-style-type:none">
<li class="nlf">1. Compute the vertices for a circle <i>C</i><sub>1</sub> of radius <i>r</i> in the XZ plane and with the center at the origin.</li>
<li class="nl">2. Rotate the circle <i>C</i><sub>1</sub> around the z-axis by the angle <span class="dcrit-i">θ</span>. This gives you the circle <i>C</i><sub>2</sub>.</li>
<li class="nll">3. Translate the circle <i>C</i><sub>2</sub> by <i>R</i> amount along the angle <span class="dcrit-i">θ</span> to get the circle <i>C</i><sub>3</sub> in the correct position on the torus.</li>
</ol>
<p><span aria-label=" Page 182. " class="page" epub:type="pagebreak" id="p182" role="doc-pagebreak"/>You may recall the use of parametric equations to define a circle in the spirograph project in <a class="xref" href="nsp-venkitachalam503045-0013.xhtml#ch02">Chapter 2</a>. We’re going to use the same concept here. The vertices marking the circumference of a circle <i>C</i><sub>1</sub> of radius <i>r</i> on the XZ plane centered at the origin are given by:</p>
<div class="equation">
<p class="eq"><i>P</i> = (<i>r</i> cos(<span class="dcrit-i">α</span>), 0, <i>r</i> sin(<span class="dcrit-i">α</span>))</p>
</div>
<p>Here, <span class="dcrit-i">α</span> is the angle made by the point <i>P</i> with respect to the x-axis. As <span class="dcrit-i">α</span> varies from 0 to 360 degrees (or 2π radians), a circle will be formed by the <i>P</i> points. Notice that the y-coordinates of the points are zero in the previous equation. This is expected, since the circle is on the XZ plane.</p>
<p>You must now rotate the points around the z-axis by angle <span class="dcrit-i">θ</span>. The rotation matrix for this operation is given by:</p>
<div class="equation">
<p class="eq"><img alt="" height="204" src="images/nsp-venkitachalam503045-m10001.jpg" width="485"/></p>
</div>
<p>Once you rotate the points, you need to translate them to the right place. This is done using the following translation matrix. (This format was discussed in <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#ch09">Chapter 9</a>.)</p>
<div class="equation">
<p class="eq"><img alt="" height="204" src="images/nsp-venkitachalam503045-m10002.jpg" width="510"/></p>
</div>
<p>Thus, the <span class="idx" data-level1="transformation matrix" data-term="torus"/>transformed points on a ring on the torus are given by:</p>
<div class="equation">
<p class="eq"><i>P</i><span class="dcrit">ʹ</span> = <i>T</i> × <i>R</i> <sub class="i">θ,Z</sub> × <i>P</i></p>
</div>
<p class="pcon">which is the same as:</p>
<div class="equation">
<p class="eq"><img alt="" height="204" src="images/nsp-venkitachalam503045-m10003.jpg" style="width:95%; height:auto;" width="1099"/></p>
</div>
<p>In the previous equation, <i>P</i> is first multiplied by the rotation matrix, which aligns it correctly, and is then multiplied by the translation matrix, which “pushes” the points to the right place on the torus. Notice that <i>P</i> is represented with <span class="idx" data-term="homogeneous coordinates"/><i>homogeneous</i> coordinates (<i>x</i>, <i>y</i>, <i>z</i>, 1.0), discussed in the <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#ch09">previous chapter</a>.</p>
</section>
<section>
<h3 class="bh" id="bh1202"><span aria-label=" Page 183. " class="page" epub:type="pagebreak" id="p183" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1202"><span class="idx" data-level1="computing normals" data-term="torus"/>Computing Normals for Lighting</a></h3>
<p class="paft">For the torus to look nice, you’ll need to apply lighting to the geometry, which in turn means you’ll need to compute the <i>normal vectors</i> for the points <i>P</i> calculated in the previous section. The lighting on a surface depends on the orientation of the surface to the incoming light, and the orientation can be quantified by the normal vector, which is the vector perpendicular to the surface at a particular point. Take a look at <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#fig10-3">Figure 10-3</a> to see an example.</p>
<figure class="figure" id="fig10-3">
<p class="fig"><img alt="" height="724" src="images/nsp-venkitachalam503045-f10003.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 10-3:</span> Computing normal vectors</p>
</figcaption>
</figure>
<p>Because of the geometry of the torus, the normal vector for point <i>s</i> on a ring is in the same direction as the line connecting point <i>s</i> to the center of the ring. This means that the normal vectors are the same as rotated points. The translation doesn’t matter, as the direction of the normals is unaffected by it. You can therefore compute the normals as follows:</p>
<div class="equation">
<p class="eq"><i>N</i> = <i>R</i><sub class="i">θ,Z</sub> × <i>P</i></p>
</div>
<p>Note that you need to <span class="idx" data-term="normalize vector"/><i>normalize</i> the normal vectors before doing any lighting computations. You do this by dividing the normal by its magnitude.</p>
<p>The actual lighting will come from a single light source at a fixed position. This will be defined in the vertex shader.</p>
</section>
<section>
<h3 class="bh" id="bh1203"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1203"><span class="idx" data-level1="rendering" data-term="torus"/>Rendering</a></h3>
<p class="paft">Now that you have the vertices and normals for the torus, let’s talk about how to render it using OpenGL. You first need to split it up into bands, as shown in <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#fig10-4">Figure 10-4</a>. Each band is the region between two adjacent rings on the torus.</p>
<figure class="figure" id="fig10-4">
<p class="fig"><span aria-label=" Page 184. " class="page" epub:type="pagebreak" id="p184" role="doc-pagebreak"/><img alt="" height="814" src="images/nsp-venkitachalam503045-f10004.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 10-4:</span> Rendering the torus with triangle strips</p>
</figcaption>
</figure>
<p>Each of the bands is rendered using OpenGL as a <span class="idx" data-level1="GL_TRIANGLE_STRIP" data-term="OpenGL"/><code>GL_TRIANGLE_STRIP</code> primitive. Besides forming the building blocks of the torus, these triangle strips also provide a convenient way to create the Game of Life simulation grid: each cell in the grid is represented by a quad formed from two adjacent triangles in the strip. <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#fig10-5">Figure 10-5</a> gives a closer look at one band in the torus.</p>
<figure class="figure" id="fig10-5">
<p class="fig"><img alt="" height="610" src="images/nsp-venkitachalam503045-f10005.jpg" style="width:95%; height:auto;" width="609"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 10-5:</span> Rendering a band from triangle strips</p>
</figcaption>
</figure>
<p><span aria-label=" Page 185. " class="page" epub:type="pagebreak" id="p185" role="doc-pagebreak"/>The band is formed by the adjacent rings <i>C</i><sup>0</sup> and <i>C</i><sup>1</sup>. Each ring has <i>M</i> vertices. The triangle strip making up the band is formed as <i>M</i> pairs of vertices that zigzag back and forth between the rings:</p>
<div class="equation">
<p class="eq"><img alt="" height="33" src="images/nsp-venkitachalam503045-m10004.jpg" width="446"/></p>
</div>
<p>But there’s one additional pair of vertices you need to add: <img alt="" height="33" src="images/nsp-venkitachalam503045-m10005.jpg" width="93"/>. You need to repeat the first two vertices to close out the gap at the end of the band. Hence, the total number of vertices in the triangle strip that forms the band is given by 2 × <i>M</i> + 2.</p>
<p>The band shown in <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#fig10-5">Figure 10-5</a> was composed of rings <img alt="" height="23" src="images/nsp-venkitachalam503045-m10006.jpg" width="98"/>. The torus is divided into <i>N</i> bands, where <i>N</i> is the number of rings:</p>
<div class="equation">
<p class="eq"><img alt="" height="28" src="images/nsp-venkitachalam503045-m10007.jpg" width="458"/></p>
</div>
<p>Notice how the last band wraps around by coming back to the first ring, <i>C</i><sup>0</sup>. This means the total number of vertices needed to render the torus is given by <i>N</i> × (2 × <i>M</i> + 2). You’ll see more details of the implementation as you look at the code.</p>
<p>Now let’s take a look at the coloring scheme for the torus.</p>
</section>
<section>
<h3 class="bh" id="bh1204"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1204"><span class="idx" data-level1="coloring" data-term="torus"/>Coloring the Triangle Strips</a></h3>
<p class="paft">You need to color the cells in the Game of Life simulation individually. You know that each cell is a quad—two triangles that are part of a larger triangle strip. As an example, the quad made of vertices <img alt="" height="33" src="images/nsp-venkitachalam503045-m10008.jpg" width="228"/> is composed of two triangles: <img alt="" height="33" src="images/nsp-venkitachalam503045-m10009.jpg" width="163"/> and <img alt="" height="33" src="images/nsp-venkitachalam503045-m10010.jpg" width="161"/>. Each vertex has a corresponding color associated with it, which is a triplet of the form (<i>r</i>, <i>g</i>, <i>b</i>), denoting the red, green, and blue components of the color. By default, the color of the first vertex in the quad (in this case, <img alt="" height="30" src="images/nsp-venkitachalam503045-m10011.jpg" width="29"/>) sets the value for the first triangle in the quad, and the color of the second vertex (<img alt="" height="30" src="images/nsp-venkitachalam503045-m10012.jpg" width="29"/>) sets the value for the second triangle in the quad. As long as you set these two colors to be identical, you’ll color the quad uniformly. We’ll discuss OpenGL’s vertex color convention further when we look at the code.</p>
<p class="pcust1"><span class="ccust3">NOTE</span> The OpenGL function called <code>glProvokingVertex()</code> changes the convention of which color value is mapped to the vertex.</p>
</section>
<section>
<h3 class="bh" id="bh1205"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1205"><span class="idx" data-level1="camera" data-term="torus"/>Controlling the Camera</a></h3>
<p class="paft">To view the torus, you’ll create a camera that revolves around the origin of the 3D scene and looks down at an angle from above. <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#fig10-6">Figure 10-6</a> shows the camera setup.</p>
<figure class="figure" id="fig10-6">
<p class="fig"><span aria-label=" Page 186. " class="page" epub:type="pagebreak" id="p186" role="doc-pagebreak"/><img alt="" height="927" src="images/nsp-venkitachalam503045-f10006.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 10-6:</span> Implementing a revolving camera</p>
</figcaption>
</figure>
<p>Think of the camera, represented by point <i>E</i>, as being placed on a cylinder of radius <i>R</i> at a height <i>H</i> from the origin. The camera points toward the origin <i>O</i>. The camera is defined by the mutually perpendicular vectors <i>V</i>, <i>U</i>, and <i>N</i>, where <i>V</i> is the <i>view vector</i> that points from <i>E</i> to <i>O</i>; <i>U</i> is the <i>up vector</i>, which is up relative to the camera; and <i>N</i> is a vector perpendicular to both <i>V</i> and <i>U</i>. For every time step, you move the camera by a constant distance along the rim of the cylinder. This movement is parameterized by the angle <span class="dcrit-i">β</span>, as shown in <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#fig10-6">Figure 10-6</a>. As you learned in <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#ch09">Chapter 9</a>, you use a <code>lookAt()</code> method to set up the view, which takes three parameters: the eye, the center, and the up vector. The center is just the origin: (0, 0, 0). The 3D coordinates of the eye are given by:</p>
<div class="equation">
<p class="eq"><i>E</i> = (<i>R</i> cos(<span class="dcrit-i">β</span>), <i>R</i> sin(<span class="dcrit-i">β</span>), <i>H</i>)</p>
</div>
<p>As the camera moves along the rim of the cylinder, it will keep its direction pointed to <i>O</i>, and the up vector <i>U</i> will keep changing as well. To compute the up vector <i>U</i>, start with an initial guess <i>U</i><span class="dcrit">ʹ</span> that’s parallel to the z-axis. Then find <i>N</i>, the vector perpendicular to the plane given by <i>U</i><span class="dcrit">ʹ</span> and <i>V</i>. It can be calculated as:</p>
<div class="equation">
<p class="eq"><i>N</i> = <i>V</i> × <i>U</i><span class="dcrit">ʹ</span></p>
</div>
<p><i>N</i> is given by the cross product of <i>V</i> and <i>U</i><span class="dcrit">ʹ</span>. Now, what happens if you take the cross product of <i>N</i> and <i>V</i>? You get a vector perpendicular to the NV plane, which is the up vector <i>U</i> that you’re looking for!</p>
<div class="equation">
<p class="eq"><span aria-label=" Page 187. " class="page" epub:type="pagebreak" id="p187" role="doc-pagebreak"/><i>U</i> = <i>N</i> × <i>V</i> = (<i>V</i> × <i>U</i><span class="dcrit">ʹ</span>) × <i>V</i></p>
</div>
<p>Once <i>U</i> is calculated, make sure that it’s normalized before use. Once that’s done, you’ll have everything you need to set up the camera with <code>lookAt()</code>: <i>E</i> (the eye), <i>O</i> (the center), and <i>U</i> (the up vector).</p>
</section>
<section>
<h3 class="bh" id="bh1206"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1206"><span class="idx" data-level1="mapping simulation grid" data-term="torus"/>Mapping the Grid to the Torus</a></h3>
<p class="paft">Finally, let’s look at how the 2D Game of Life simulation grid maps to the 3D torus because of the grid’s toroidal boundary conditions. <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#fig10-7">Figure 10-7</a> shows the mapping.</p>
<figure class="figure" id="fig10-7">
<p class="fig"><img alt="" height="798" src="images/nsp-venkitachalam503045-f10007.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 10-7:</span> Mapping the simulation grid to a torus</p>
</figcaption>
</figure>
<p>The two-dimensional Game of Life grid has <i>NX</i> columns and <i>NY</i> rows. You can see on the right of the figure how the <i>NX</i> points that divide each row wrap around the tube of the torus. The point indices go from 0 to <i>NX</i> − 1. The next index, <i>NX</i>, is the same as 0 because of the wrap. A similar wrap happens in the y-direction, where you have <i>NY</i> cells: the point with index <i>NY</i> is the same as the point with index 0.</p>
<p>You saw earlier how each ring in the torus is discretized to have <i>M</i> points. To go from the two-dimensional grid to the torus, set <i>NX</i> = <i>M</i>. Similarly, set <i>NY</i> = <i>N</i>, where <i>N</i> is the number of bands on the torus.</p>
</section>
</section>
<section>
<h2 class="ah" id="ah1202"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1202">Requirements</a></h2>
<p class="paft">We’ll use <span class="idx" data-term="PyOpenGL module"/><code>PyOpenGL</code> and GLFW for OpenGL rendering, as in <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#ch09">Chapter 9</a>, and <code>numpy</code> for matrix/vector computations.</p>
</section>
<section>
<h2 class="ah" id="ah1203"><span aria-label=" Page 188. " class="page" epub:type="pagebreak" id="p188" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1203">The Code</a></h2>
<p class="paft">The code for this project is organized into several files:</p>
<p class="pcust2"><span class="bi">torus.py</span> This contains the geometry computation and rendering code for the torus.</p>
<p class="pcust2"><span class="bi">gol.py</span> This implements Conway’s Game of Life, adapted from <a class="xref" href="nsp-venkitachalam503045-0015.xhtml#ch03">Chapter 3</a>.</p>
<p class="pcust2"><span class="bi">camera.py</span> This contains the implementation for the revolving camera for viewing the torus.</p>
<p class="pcust2"><span class="bi">gol_torus.py</span> This is the main file that sets up OpenGL and GLFW and calls the rendering code from other modules.</p>
<p>The full project code is available online at <a class="url-i" href="https://github.com/mkvenkit/pp2e/blob/main/gol_torus">https://github.com/mkvenkit/pp2e/blob/main/gol_torus</a>.</p>
<section>
<h3 class="bh" id="bh1207"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1207">Rendering the Torus</a></h3>
<p class="paft">We’ll first consider the code for rendering the torus, which is encapsulated in a class called <code>Torus</code> defined in the file <i>torus.py</i>. To see the complete code listing, skip ahead to <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#ah1207">“The Complete Torus Rendering Code”</a> on <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#p203">page 203</a>.</p>
<section>
<h4 class="ch" id="ch1201">Defining the Shaders</h4>
<p class="paft">First, define the GLSL shaders for the torus. Here’s the <span class="idx" data-level1="vertex shader" data-term="torus"/>vertex shader, which takes the per-vertex attributes of position, color, and normal and computes the transformed inputs for the fragment shader:</p>
<div class="codeline">
<p class="clf">strVS = """</p>
<p class="cl"># version 410 core</p>
<p class="cl">layout(location = 0) in vec3 aVert;</p>
<p class="cl">layout(location = 1) in vec3 aColor;</p>
<p class="cl">layout(location = 2) in vec3 aNormal;</p>
<p class="cl">uniform mat4 uMVMatrix;</p>
<p class="cl">uniform mat4 uPMatrix;</p>
<p class="cl2"><!--<ccust1>1</ccust1>-->❶ flat out vec3 vColor;</p>
<p class="cl2"><!--<ccust1>2</ccust1>-->❷ out vec3 vNormal;</p>
<p class="cl2"><!--<ccust1>3</ccust1>-->❸ out vec3 fragPos;</p>
<p class="cl">void main() {</p>
<p class="cl">  // transform vertex</p>
<p class="cl">  gl_Position = uPMatrix * uMVMatrix * vec4(aVert, 1.0);</p>
<p class="cl2"><!--<ccust1>4</ccust1>-->❹ fragPos = aVert;</p>
<p class="cl">  vColor = aColor;</p>
<p class="cl">  vNormal = aNormal;</p>
<p class="cl">}</p>
<p class="cll">"""</p>
</div>
<p>You define the vertex shader code as a string stored in <code>strVS</code>. The attribute variables for the shader are <code>aVert</code>, <code>aColor</code>, and <code>aNormal</code>, representing the coordinates, color, and normal vector for each vertex. Notice the <span aria-label=" Page 189. " class="page" epub:type="pagebreak" id="p189" role="doc-pagebreak"/><code>flat</code> qualifier when you initialize <code>vColor</code>, one of the outputs of the vertex shader <!--<ccust1>1</ccust1>-->❶, indicating that this variable won’t be interpolated in the fragment shader. In effect, we’re saying that this variable will remain constant across the primitive (one of the triangles in a triangle strip). This ensures that every Game of Life cell will be a single color. This type of shading across a primitive is called <i>flat shading</i>. The next vertex shader output is <code>vNormal</code> <!--<ccust1>2</ccust1>-->❷, which by default will be interpolated in the fragment shader. You need this so you can compute lighting across a primitive, but later you’ll see how to modify this shader code to support flat shading. The other output is called <code>fragPos</code> <!--<ccust1>3</ccust1>-->❸. In the main shader code, you set this output to <code>aVert</code> <!--<ccust1>4</ccust1>-->❹ so it can be passed into the fragment shader for lighting calculations. The shader also computes <code>gl_Position</code> and passes to the fragment shader the color and normal data as it is received.</p>
<p>Here’s the <span class="idx" data-level1="fragment shader" data-term="torus"/>fragment shader, which applies lighting and computes the final color of the fragment. It’s defined as another string, called <code>strFS</code>.</p>
<div class="codeline">
<p class="clf">strFS = """</p>
<p class="cl"># version 410 core</p>
<p class="cl">flat in vec3 vColor;</p>
<p class="cl">in vec3 vNormal;</p>
<p class="cl">in vec3 fragPos;</p>
<p class="cl">out vec4 fragColor;</p>
<p class="cl">void main() {</p>
<p class="cl2"><!--<ccust1>1</ccust1>-->❶ vec3 lightPos = vec3(10.0, 10.0, 10.0);</p>
<p class="cl2"><!--<ccust1>2</ccust1>-->❷ vec3 lightColor = vec3(1.0, 1.0, 1.0);</p>
<p class="cl2"><!--<ccust1>3</ccust1>-->❸ vec3 lightDir = normalize(lightPos - fragPos);</p>
<p class="cl">  float diff = max(dot(vNormal, lightDir), 0.0);</p>
<p class="cl">  vec3 diffuse = diff * lightColor;</p>
<p class="cl">  float ambient = 0.1;</p>
<p class="cl2"><!--<ccust1>4</ccust1>-->❹ vec3 result = (ambient + diffuse) * vColor.xyz;</p>
<p class="cl">  fragColor = vec4(result, 1.0);</p>
<p class="cl">}</p>
<p class="cll">"""</p>
</div>
<p>Notice that the color, normal, and fragment position variables, which were outputs from the vertex shader, are now inputs to the fragment shader. In the main shader code, you define the position <!--<ccust1>1</ccust1>-->❶ and color <!--<ccust1>2</ccust1>-->❷ for a light source. Then you compute the light direction <!--<ccust1>3</ccust1>-->❸. The resulting color <!--<ccust1>4</ccust1>-->❹ is a mix of ambient and diffuse components of the light and is set as the output from the fragment shader.</p>
<p>Keep in mind that <code>fragPos</code> and <code>vNormal</code> are computed for each fragment via interpolation, whereas <code>vColor</code> is constant for a given primitive. The net effect is that the intrinsic color of a primitive (a triangle strip, in this case) remains constant, while the perceived color varies across the primitive based on its orientation with respect to the light source. This is exactly what you need to set each Game of Life cell to a solid color, while varying that color to create the appearance of lighting.</p>
</section>
<section>
<h4 class="ch" id="ch1202"><span aria-label=" Page 190. " class="page" epub:type="pagebreak" id="p190" role="doc-pagebreak"/>Initializing the Torus Class</h4>
<p class="paft">Now let’s look at the initialization code in the <span class="idx" data-level1="Torus class" data-term="torus"/><code>Torus</code> class constructor:</p>
<div class="codeline">
<p class="clf">class Torus:</p>
<p class="cl">    """ OpenGL 3D scene class"""</p>
<p class="cl">    # initialization</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ def __init__(self, R, r, NX, NY):</p>
<p class="cl">        global strVS, strFS</p>
<p class="cl">        # modify shader for flat shading</p>
<p class="cl">        # create shader</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ self.program = glutils.loadShaders(strVS, strFS)</p>
<p class="cl">        glProvokingVertex(GL_FIRST_VERTEX_CONVENTION)</p>
<p class="cl">        self.pMatrixUniform = <span class="idx" data-level1="glGetUniformLocation" data-term="OpenGL"/>glGetUniformLocation(self.program,</p>
<p class="cl">                                                   b'uPMatrix')</p>
<p class="cl">        self.mvMatrixUniform = <span class="idx" data-level1="glGetUniformLocation" data-term="OpenGL"/>glGetUniformLocation(self.program,</p>
<p class="cl">                                                    b'uMVMatrix')</p>
<p class="cl">        # torus geometry</p>
<p class="cl">        self.R = R</p>
<p class="cl">        self.r = r</p>
<p class="cl">        # grid size</p>
<p class="cl">        self.NX = NX</p>
<p class="cl">        self.NY = NY</p>
<p class="cl">        # no. of points</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ self.N = self.NX</p>
<p class="cl">        self.M = self.NY</p>
<p class="cl">        # time</p>
<p class="cl">        self.t = 0</p>
<p class="cl">        # compute parameters for glMultiDrawArrays</p>
<p class="cl">        M1 = 2*self.M + 2</p>
<p class="cl">      <!--<ccust1>4</ccust1>-->❹ self.first_indices = [2*M1*i for i in range(self.N)]</p>
<p class="cl">        self.counts = [2*M1 for i in range(self.N)]</p>
<p class="cl">        # colors: {(i, j) : (r, g, b)}</p>
<p class="cl">        # with NX * NY entries</p>
<p class="cl">      <!--<ccust1>5</ccust1>-->❺ self.colors_dict = self.init_colors(self.NX, self.NY)</p>
<p class="cl">        # create an empty array to hold colors</p>
<p class="cl">      <!--<ccust1>6</ccust1>-->❻ self.colors = np.<span class="idx" data-level1="zeros" data-term="numpy module"/>zeros((3*self.N*(2*self.M + 2), ), np.float32)</p>
<p class="cl">        # get vertices, normals, indices</p>
<p class="cl">      <!--<ccust1>7</ccust1>-->❼ vertices, normals = self.compute_vertices()</p>
<p class="cl">      <!--<ccust1>8</ccust1>-->❽ self.compute_colors()</p>
<p class="cl">        # set up vertex buffer objects</p>
<p class="cll">      <!--<ccust1>9</ccust1>-->❾ self.setup_vao(vertices, normals, self.colors)</p>
</div>
<p>The <code>Torus</code> class has the following parameters in its constructor <!--<ccust1>1</ccust1>-->❶: the radius <code>R</code> of the outer ring of the torus, the radius <code>r</code> of the torus tube, and <code>NX</code> and <code>NY</code> for the number of Game of Life simulation cells in the x- and y-directions. The constructor’s first order of business is to load the shaders. You use the <code>loadShaders()</code> method <!--<ccust1>2</ccust1>-->❷ defined in the common <i>glutils.py</i> file. In the subsequent lines, you store the variables passed into the <code>Torus</code> constructor in instance variables such as <code>self.R</code> so they can be accessed later from other methods. Then you set <code>N</code>, the number of points on the outer circle of the torus, to be <code>NX</code>, the number of cells in the x-direction <!--<ccust1>3</ccust1>-->❸. You similarly set <code>M</code>, the number of points along the smaller radius <code>r</code> of the torus, to <code>NY</code>. This scheme is discussed in the <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#bh1206">“Mapping the Grid to the Torus”</a> section.</p>
<p><span aria-label=" Page 191. " class="page" epub:type="pagebreak" id="p191" role="doc-pagebreak"/>Next, you do some additional preparation for rendering the triangle strips that will form the bands along the outer ring of the torus. You’ll eventually be using the <span class="idx" data-level1="glMultiDrawArrays" data-term="OpenGL"/><code>glMultiDrawArrays()</code> OpenGL method to render all the triangle strips at once. This method is an efficient way to draw multiple triangle strip primitives using just one function call. As you saw in the <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#bh1203">“Rendering”</a> section, each triangle strip has 2<i>M</i> + 2 vertices, and you have <i>N</i> of these strips. So, the starting indices for these triangle strips will be [0, (2<i>M</i> + 2), (2<i>M</i> + 2) × 2, . . . , (2<i>M</i> + 2) × <i>N</i>]. Accordingly, you set <code>first_indices</code> and <code>counts</code> <!--<ccust1>4</ccust1>-->❹, which will be required parameters when you call <code>glMultiDrawArrays()</code>.</p>
<p>The <code>init_colors()</code> method <!--<ccust1>5</ccust1>-->❺ initializes <code>color_dict</code>, which maps each grid cell to a color—black or white. We’ll look at the details of the <code>init_colors()</code> method soon. You initialize the <code>numpy</code> array <code>colors</code> to zeros <!--<ccust1>6</ccust1>-->❻. You’ll later populate this array with the correct values. You conclude the constructor by computing the vertices and normals for the torus <!--<ccust1>7</ccust1>-->❼, as well as the colors <!--<ccust1>8</ccust1>-->❽, and by setting up the vertex array object (VAO) for rendering the torus <!--<ccust1>9</ccust1>-->❾.</p>
<p>Now let’s look at the <code>Torus</code> class’s <code>init_colors()</code> method that was just mentioned:</p>
<div class="codeline">
<p class="clf">def init_colors(self, NX, NY):</p>
<p class="cl">    """initialize color dictionary"""</p>
<p class="cl">    colors = {}</p>
<p class="cl">    c1 = [1.0, 1.0, 1.0]</p>
<p class="cl">    for i in range(NX):</p>
<p class="cl">        for j in range(NY):</p>
<p class="cl">          <!--<ccust1>1</ccust1>-->❶ colors[(i, j)] = c1</p>
<p class="cll">    return colors</p>
</div>
<p>The <code>init_colors()</code> method creates a dictionary called <code>colors</code> mapping from simulation cell index (<i>i</i>, <i>j</i>) to the color that should be applied to the cell. To begin, you simply set all the cell color values to <code>c1</code>, which is just plain white <!--<ccust1>1</ccust1>-->❶. As the Game of Life simulation unfolds, the values in this dictionary will be updated to turn cells on and off.</p>
</section>
<section>
<h4 class="ch" id="ch1203"><span class="idx" data-level1="calculating vertices" data-term="torus"/>Calculating the Vertices</h4>
<p class="paft">The next few methods we’ll consider work together to compute all the torus vertices. We begin with the <code>compute_vertices()</code> method:</p>
<div class="codeline">
<p class="clf">def compute_vertices(self):</p>
<p class="cl">        R, r, N, M = self.R, self.r, self.N, self.M</p>
<p class="cl">        # create an empty array to hold vertices/normals</p>
<p class="cl">        vertices = []</p>
<p class="cl">        normals = []</p>
<p class="cl">        for i in range(N):</p>
<p class="cl">            # for all M points around a ring</p>
<p class="cl">            for j in range(M+1):</p>
<p class="cl">                # compute angle theta of point</p>
<p class="cl">              <!--<ccust1>1</ccust1>-->❶ theta = (j % M) *2*math.pi/M</p>
<p class="cl">                #---ring #1------</p>
<p class="cl">                # compute angle</p>
<p class="cl"><span aria-label=" Page 192. " class="page" epub:type="pagebreak" id="p192" role="doc-pagebreak"/>              <!--<ccust1>2</ccust1>-->❷ alpha1 = i*2*math.pi/N</p>
<p class="cl">                # compute transforms</p>
<p class="cl">              <!--<ccust1>3</ccust1>-->❸ RM1, TM1 = self.compute_rt(R, alpha1)</p>
<p class="cl">                # compute points</p>
<p class="cl">              <!--<ccust1>4</ccust1>-->❹ Pt1, NV1 = self.compute_pt(r, theta, RM1, TM1)</p>
<p class="cl">                #---ring #2------</p>
<p class="cl">                # index of next ring</p>
<p class="cl">              <!--<ccust1>5</ccust1>-->❺ ip1 = (i + 1) % N</p>
<p class="cl">                # compute angle</p>
<p class="cl">              <!--<ccust1>6</ccust1>-->❻ alpha2 = ip1*2*math.pi/N</p>
<p class="cl">                # compute transforms</p>
<p class="cl">                RM2, TM2 = self.compute_rt(R, alpha2)</p>
<p class="cl">                # compute points</p>
<p class="cl">                Pt2, NV2 = self.compute_pt(r, theta, RM2, TM2)</p>
<p class="cl">                # store vertices/normals in right order for GL_TRIANGLE_STRIP</p>
<p class="cl">              <!--<ccust1>7</ccust1>-->❼ vertices.append(Pt1[0:3])</p>
<p class="cl">                vertices.append(Pt2[0:3])</p>
<p class="cl">                # add normals</p>
<p class="cl">                normals.append(NV1[0:3])</p>
<p class="cl">                normals.append(NV2[0:3])</p>
<p class="cl">        # return vertices and colors in correct format</p>
<p class="cl">      <!--<ccust1>8</ccust1>-->❽ vertices = np.array(vertices, np.float32).reshape(-1)</p>
<p class="cl">        normals = np.array(normals, np.float32).reshape(-1)</p>
<p class="cl">        # print(vertices.shape)</p>
<p class="cll">        return vertices, normals</p>
</div>
<p>The <code>compute_vertices()</code> method begins by creating empty lists to store the vertices and normals. Then you compute the vertices and normals for the torus, using a nested loop to implement the strategy we discussed in the <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#bh1203">“Rendering”</a> section. The outer loop iterates over the <code>N</code> rings that make up the torus. The inner loop iterates over the <code>M</code> points on each of those rings. Within the loops, you first compute the angle <code>theta</code> subtended by a point on the ring with index <code>j</code> <!--<ccust1>1</ccust1>-->❶. You use <code>j % M</code> and have the inner loop iterate over range <code>[0, M+1)</code> so that when <i>j</i> is equal to <code>M</code>, <code>(j % M)</code> rolls back to <code>0</code>. This is to complete the last segment of the ring.</p>
<p>The torus is rendered as a set of bands (triangle strips), and each band consists of two adjacent rings of points. You compute <code>alpha1</code>, the angle subtended by the first ring in a band, at index <code>i</code> <!--<ccust1>2</ccust1>-->❷, and use <code>alpha1</code> to compute the rotation and translation matrices for this first ring using the <code>compute_rt()</code> method <!--<ccust1>3</ccust1>-->❸. Then you pass these matrices to the <code>compute_pt()</code> method to calculate the vertex and normal for the point on the ring at angle <code>theta</code> <!--<ccust1>4</ccust1>-->❹. We’ll look at how the <code>compute_rt()</code> and <code>compute_pt()</code> methods work soon.</p>
<p>Next, you move on to the adjacent ring at index <code>i+1</code>, using <code>ip1 = (i+1) % N</code> to ensure that you roll back to zero at the end <!--<ccust1>5</ccust1>-->❺. You compute the angle <code>alpha2</code> of the ring at index <code>ip1</code> <!--<ccust1>6</ccust1>-->❻ and then compute the vertex and normal for the point on the <code>ip1</code> ring at angle <code>theta</code>, just as you did for the first ring.</p>
<p>Beginning at <!--<ccust1>7</ccust1>-->❼, you append the vertices and normals for the adjacent rings to the lists you created at the beginning of the method. You pick only the first three coordinates of each vertex and normal, as in <code>Pt1[0:3]</code>, since all the matrix transformations are done with homogeneous <span aria-label=" Page 193. " class="page" epub:type="pagebreak" id="p193" role="doc-pagebreak"/>coordinates in the form (<i>x</i>, <i>y</i>, <i>z</i>, <i>w</i>), and you need only (<i>x</i>, <i>y</i>, <i>z</i>). This action stores the vertices and normals in a Python list of triplets of the form <code>[[x1, y1, z1], [x2, y2, z2], ...]</code>. However, OpenGL expects vertex attributes to be provided in a flat array with a known size. Therefore, you convert the <code>vertices</code> and <code>normals</code> lists into <code>numpy</code> arrays of 32-bit floats <!--<ccust1>8</ccust1>-->❽, using <code>reshape(-1)</code> to ensure that they’re flat arrays of the form <code>[x1, y1, z1, x2, y2, z2, ...]</code>.</p>
<p>Now let’s look at the <code>compute_rt()</code> and <code>compute_pt()</code> methods that helped you compute the vertices and normals. We’ll start with <code>compute_rt()</code>, which calculates the rotation and translation matrices needed to render a given ring in the torus:</p>
<div class="codeline">
<p class="clf">def compute_rt(self, R, alpha):</p>
<p class="cl">        # compute position of ring</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ Tx = R*math.cos(alpha)</p>
<p class="cl">        Ty = R*math.sin(alpha)</p>
<p class="cl">        Tz = 0.0</p>
<p class="clf">        # rotation matrix</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ RM = np.array([</p>
<p class="cl">            [math.cos(alpha), -math.sin(alpha), 0.0, 0.0],</p>
<p class="cl">            [math.sin(alpha), math.cos(alpha), 0.0, 0.0],</p>
<p class="cl">            [0.0, 0.0, 1.0, 0.0],</p>
<p class="cl">            [0.0, 0.0, 0.0, 1.0]</p>
<p class="cl">            ], dtype=np.float32)</p>
<p class="clf">        # translation matrix</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ TM = np.array([</p>
<p class="cl">            [1.0, 0.0, 0.0, Tx],</p>
<p class="cl">            [0.0, 1.0, 0.0, Ty],</p>
<p class="cl">            [0.0, 0.0, 1.0, Tz],</p>
<p class="cl">            [0.0, 0.0, 0.0, 1.0]</p>
<p class="cl">            ], dtype=np.float32)</p>
<p class="cls">        return (RM, TM)</p>
</div>
<p>You first calculate the translation components of the matrix <!--<ccust1>1</ccust1>-->❶, using parametric equations. Then you create the rotation matrix <!--<ccust1>2</ccust1>-->❷ and translation matrix <!--<ccust1>3</ccust1>-->❸ as <code>numpy</code> arrays. You’ve seen these matrices before in the <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#bh1201">“Computing Vertices”</a> section. You return the arrays at the end of the method.</p>
<p>Here’s the other helper method, <code>compute_pt()</code>, which uses the translation and rotation matrices to determine the vertex and normal vector of a given point on a ring of the torus:</p>
<div class="codeline">
<p class="clf">def compute_pt(self, r, theta, RM, TM):</p>
<p class="cl">    # compute point coords</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ P = np.array([r*math.cos(theta), 0.0, r*math.sin(theta), 1.0],</p>
<p class="cl">                 dtype=np.float32)</p>
<p class="cl">    # print(P)</p>
<p class="cl">    # apply rotation - this also gives us the vertex normals</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ NV = np.dot(RM, P)</p>
<p class="cl"><span aria-label=" Page 194. " class="page" epub:type="pagebreak" id="p194" role="doc-pagebreak"/>    # apply translation</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ Pt = np.dot(TM, NV)</p>
<p class="cll">    return (Pt, NV)</p>
</div>
<p>You compute the point <code>P</code> at angle <code>theta</code> on a ring lying on the XZ plane <!--<ccust1>1</ccust1>-->❶. Then you apply a rotation to this point by multiplying it by the rotation matrix <!--<ccust1>2</ccust1>-->❷. This also gives you the point’s normal vector. You multiply the normal by the translation matrix to give you the vertex on the torus <!--<ccust1>3</ccust1>-->❸.</p>
</section>
<section>
<h4 class="ch" id="ch1204"><span class="idx" data-level1="cell colors" data-term="torus"/>Managing Cell Colors</h4>
<p class="paft">Now we’ll examine some methods that help set the colors of the cells on the torus. First is the <code>compute_colors()</code> method, which we originally called as part of the <code>Torus</code> class’s constructor. It sets the color of each triangle in the triangle strips that make up the torus, based on the values determined by the Game of Life simulation.</p>
<div class="codeline">
<p class="clf">def compute_colors(self):</p>
<p class="cl">    R, r, N, M = self.R, self.r, self.N, self.M</p>
<p class="clf">    # the points on the ring are generated on the X-Z plane</p>
<p class="cl">    # then they are rotated and translated into the correct</p>
<p class="cl">    # position on the torus</p>
<p class="clf">    # for all N rings around the torus</p>
<p class="cl">    for i in range(N):</p>
<p class="cl">        # for all M points around a ring</p>
<p class="cl">        for j in range(M+1):</p>
<p class="cl">            # j value</p>
<p class="cl">            jj = j % M</p>
<p class="cl">            # store colors - same color applies to (V_i_j, V_ip1_j)</p>
<p class="cl">          <!--<ccust1>1</ccust1>-->❶ col = self.colors_dict[(i, jj)]</p>
<p class="cl">            # get index into array</p>
<p class="cl">          <!--<ccust1>2</ccust1>-->❷ index = 3*(2*i*(M+1) + 2*j)</p>
<p class="cl">            # set color</p>
<p class="cl">          <!--<ccust1>3</ccust1>-->❸ self.colors[index:index+3] = col</p>
<p class="cll">          <!--<ccust1>4</ccust1>-->❹ self.colors[index+3:index+6] = col</p>
</div>
<p>This method follows the logic described in <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#bh1204">“Coloring the Triangle Strips”</a> on <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#p185">page 185</a> to update the values in the <code>colors</code> array, which was initialized as an array of all zeros. You retrieve the color for cell <code>(i, jj)</code> from <code>colors_dict</code>, the dictionary mapping cells to colors that you created earlier <!--<ccust1>1</ccust1>-->❶. (You define <code>jj = j % M</code> so it rolls over to zero at the end.) Then you compute the index into the <code>colors</code> array at which you should update the new computed values <!--<ccust1>2</ccust1>-->❷. Each pair of rings that makes up a band has <code>2*(M+1)</code> vertices, and there are <code>N</code> of these pairs. Starting at each location in the array, you store three sequential values (the RGB components of a cell’s color). Hence, the index of the <i>j</i>th color in a ring for the <i>i</i>th segment of the torus will be given by <code>3*(2*i*(M+1) + 2*j)</code>. Note that you use <code>j</code> and not <code>jj</code> in computing the index, since you’re storing the computed values here and you don’t want the index to roll over to zero. Now that you have the index, <span aria-label=" Page 195. " class="page" epub:type="pagebreak" id="p195" role="doc-pagebreak"/>you update the <code>colors</code> array with the new computed values. You update the array both at <code>[index:index+3]</code> <!--<ccust1>3</ccust1>-->❸ and at <code>[index+3:index+6]</code> <!--<ccust1>4</ccust1>-->❹ since each cell on the torus is a quad, made of two adjacent triangles.</p>
<p>Let’s now look at <code>recalc_colors()</code>, a method for updating the color values stored on the GPU at each step in the Game of Life simulation:</p>
<div class="codeline">
<p class="clf">def recalc_colors(self):</p>
<p class="cl">    # get colors</p>
<p class="cl">    self.compute_colors()</p>
<p class="cl">    # bind VAO</p>
<p class="cl">    <span class="idx" data-level1="glBindVertexArray" data-term="OpenGL"/>glBindVertexArray(self.vao)</p>
<p class="cl">    <span class="idx" data-level1="glBindBuffer" data-term="OpenGL"/>glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)</p>
<p class="cl">    # set buffer data</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ <span class="idx" data-level1="glBufferSubData" data-term="OpenGL"/>glBufferSubData(GL_ARRAY_BUFFER, 0, 4*len(self.colors), self.colors)</p>
<p class="cl">    # unbind VAO</p>
<p class="cll">    <span class="idx" data-level1="glBindVertexArray" data-term="OpenGL"/>glBindVertexArray(0)</p>
</div>
<p>For every step of the simulation, the colors of the cells are updated, which means you need to update the colors of all the triangle strips on the torus, and you need to do it efficiently so you don’t slow down the rendering. The <code>recalc_colors()</code> method does this using the OpenGL <code>glBufferSubData()</code> method <!--<ccust1>1</ccust1>-->❶. The vertices, normals, and colors are stored in attribute arrays on the GPU. The vertices and normals don’t change, so you computed them only once in the beginning, with a call to <code>compute_vertices()</code> in the class’s constructor method. When the colors change, <code>glBufferSubData()</code> updates the color attribute arrays rather than creating them afresh.</p>
</section>
<section>
<h4 class="ch" id="ch1205">Drawing the Torus</h4>
<p class="paft">Finally, here’s the <code>render()</code> method that draws the torus:</p>
<div class="codeline">
<p class="clf">def render(self, pMatrix, mvMatrix):</p>
<p class="cl">    # use shader</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ <span class="idx" data-level1="glUseProgram" data-term="OpenGL"/>glUseProgram(self.program)</p>
<p class="cl">    # set proj matrix</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ <span class="idx" data-level1="glUniformMatrix4fv" data-term="OpenGL"/>glUniformMatrix4fv(self.pMatrixUniform, 1, GL_FALSE, pMatrix)</p>
<p class="cl">    # set modelview matrix</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ <span class="idx" data-level1="glUniformMatrix4fv" data-term="OpenGL"/>glUniformMatrix4fv(self.mvMatrixUniform, 1, GL_FALSE, mvMatrix)</p>
<p class="cl">    # bind VAO</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ <span class="idx" data-level1="glBindVertexArray" data-term="OpenGL"/>glBindVertexArray(self.vao)</p>
<p class="cl">    # draw</p>
<p class="cl">  <!--<ccust1>5</ccust1>-->❺ <span class="idx" data-level1="glMultiDrawArrays" data-term="OpenGL"/>glMultiDrawArrays(GL_TRIANGLE_STRIP, self.first_indices,</p>
<p class="cl">                      self.counts, self.N)</p>
<p class="cl">    # unbind VAO</p>
<p class="cll">    glBindVertexArray(0)</p>
</div>
<p>This method is similar to the render methods you saw in the <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#ch09">previous chapter</a>. You make a call to use the shader program <!--<ccust1>1</ccust1>-->❶ and set the projection <!--<ccust1>2</ccust1>-->❷ and modelview <!--<ccust1>3</ccust1>-->❸ matrix uniform variables. Then you bind to the vertex array object <!--<ccust1>4</ccust1>-->❹, which you created by calling <code>setup_vao()</code> in the class’s <span aria-label=" Page 196. " class="page" epub:type="pagebreak" id="p196" role="doc-pagebreak"/>constructor. The VAO has all the attribute array buffers you need. Next, you use the <code>glMultiDrawArrays()</code> method to draw <code>N</code> triangle strips <!--<ccust1>5</ccust1>-->❺. You already computed <code>first_indices</code> and <code>counts</code> in the <code>Torus</code> constructor.</p>
</section>
</section>
<section>
<h3 class="bh" id="bh1208"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1208">Implementing the Game of Life Simulation</a></h3>
<p class="paft"><span class="idx" data-level1="Game of Life " data-term="torus"/>In <a class="xref" href="nsp-venkitachalam503045-0015.xhtml#ch03">Chapter 3</a>, you implemented Conway’s Game of Life (GOL) by using <code>matplotlib</code> to visualize the updated values of the simulation grid. Here you’ll adapt the earlier implementation to update a dictionary of cell colors instead, which will be used to update the colors of the torus. The relevant code is encapsulated in a class called <code>GOL</code>, declared in the file <i>gol.py</i>. To see the complete code listing, skip ahead to <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#ah1208">“The Complete Game of Life Simulation Code”</a> on <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#p209">page 209</a>.</p>
<section>
<h4 class="ch" id="ch1206">The Class Constructor</h4>
<p class="paft">First, let’s look at the <code>GOL</code> class constructor:</p>
<div class="codeline">
<p class="clf">class GOL:</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ def __init__(self, NX, NY, glider):</p>
<p class="cl">        """GOL constructor"""</p>
<p class="cl">        # a grid of NX x NY random values</p>
<p class="cl">        self.NX, self.NY = NX, NY</p>
<p class="cl">        if glider:</p>
<p class="cl">          <!--<ccust1>2</ccust1>-->❷ self.addGlider(1, 1, NX, NY)</p>
<p class="cl">        else:</p>
<p class="cl">          <!--<ccust1>3</ccust1>-->❸ self.grid = np.random.<span class="idx" data-level1="random" data-level2="choice" data-term="numpy module"/>choice([1, 0], NX * NY,</p>
<p class="cll">                                         p=[0.2, 0.8]).reshape(NX, NY)</p>
</div>
<p>The <code>GOL</code> constructor takes as input the grid dimensions <code>NX</code> and <code>NY</code>, as well as a Boolean flag <code>glider</code> <!--<ccust1>1</ccust1>-->❶. If this flag is set, you initialize the simulation grid with the “glider” pattern using the <code>addGlider()</code> method <!--<ccust1>2</ccust1>-->❷. Since we already discussed this method in <a class="xref" href="nsp-venkitachalam503045-0015.xhtml#ch03">Chapter 3</a>, we won’t examine it here. If the <code>glider</code> flag isn’t set, you just initialize the grid to random ones and zeros <!--<ccust1>3</ccust1>-->❸.</p>
<p>The <code>GOL</code> class uses an <code>update()</code> method to update the simulation grid at each time step. Again, this is identical to the previous implementation.</p>
</section>
<section>
<h4 class="ch" id="ch1207">The get_colors() Method</h4>
<p class="paft">The <code>get_colors()</code> method is what distinguishes this chapter’s Game of Life implementation from that of <a class="xref" href="nsp-venkitachalam503045-0015.xhtml#ch03">Chapter 3</a>. The method builds up a dictionary mapping of each Game of Life cell to its color value at a given step in the simulation: black for ON or white for OFF. This dictionary is passed to the <code>Torus</code> object when the scene is updated.</p>
<div class="codeline">
<p class="clf">def get_colors(self):</p>
<p class="cl">    colors = {}</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ c1 = np.array([1.0, 1.0, 1.0], np.float32)</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ c2 = np.array([0.0, 0.0, 0.0], np.float32)</p>
<p class="cl">    for i in range(self.NX):</p>
<p class="cl">        for j in range (self.NY):</p>
<p class="cl">            if self.grid[i, j] == 1:</p>
<p class="cl"><span aria-label=" Page 197. " class="page" epub:type="pagebreak" id="p197" role="doc-pagebreak"/>                colors[(i, j)] = c2</p>
<p class="cl">            else :</p>
<p class="cl">                colors[(i, j)] = c1</p>
<p class="cll">    return colors</p>
</div>
<p>Here you iterate through all the cells in the simulation grid and set the RGB colors based on whether the grid value is <code>0</code> or <code>1</code>. The possible colors are defined as <code>c1</code> for white <!--<ccust1>1</ccust1>-->❶ or <code>c2</code> for black <!--<ccust1>2</ccust1>-->❷. These colors will be used while rendering the torus.</p>
</section>
</section>
<section>
<h3 class="bh" id="bh1209"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1209"><span class="idx" data-level1="creating the camera" data-term="torus"/>Creating the Camera</a></h3>
<p class="paft">In <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#bh1205">“Controlling the Camera”</a> on <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#p185">page 185</a>, we discussed how to build a camera that orbits around the torus. Now let’s look at the implementation. The code is encapsulated in the class <code>OrbitCamera</code>, which is declared in the file <i>camera.py</i>. To see the complete code listing, skip ahead to <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#ah1209">“The Complete Camera Code”</a> on <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#p211">page 211</a>.</p>
<section>
<h4 class="ch" id="ch1208">Constructing the Class</h4>
<p class="paft">Here’s the constructor for the <code>OrbitCamera</code> class:</p>
<div class="codeline">
<p class="clf">class OrbitCamera:</p>
<p class="cl">    """helper class for viewing"""</p>
<p class="cl">    def __init__(self, height, radius, beta_step=1):</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ self.radius = radius</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ self.beta = 0</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ self.beta_step = beta_step</p>
<p class="cl">      <!--<ccust1>4</ccust1>-->❹ self.height = height</p>
<p class="cl">        # initial eye vector is (-R, 0, -H)</p>
<p class="cl">        rr = radius/math.<span class="idx" data-level1="sqrt" data-term="math module"/>sqrt(2.0)</p>
<p class="cl">      <!--<ccust1>5</ccust1>-->❺ self.eye = np.array([rr, rr, height], np.float32)</p>
<p class="cl">        # compute up vector</p>
<p class="cl">      <!--<ccust1>6</ccust1>-->❻ self.up = self.__compute_up_vector(self.eye )</p>
<p class="cl">        # center is origin</p>
<p class="cll">      <!--<ccust1>7</ccust1>-->❼ self.center = np.array([0, 0, 0], np.float32)</p>
</div>
<p>You start by setting the camera parameters passed into the <code>OrbitCamera</code> constructor. These include the camera’s orbit radius <!--<ccust1>1</ccust1>-->❶ and <code>beta</code>, the angle that the view vector (projected on the XY plane) makes with the x-axis <!--<ccust1>2</ccust1>-->❷. You also set the amount <code>beta</code> should increment with each time step of the camera rotation <!--<ccust1>3</ccust1>-->❸ and the height of the camera from the XY plane <!--<ccust1>4</ccust1>-->❹.</p>
<p>Next, you set the initial value of the eye position to be midway between the positive x- and positive y-axis, at a distance <code>R</code> from the origin, suspended at the specified <code>height</code> <!--<ccust1>5</ccust1>-->❺. You can calculate this as:</p>
<div class="equation">
<p class="eq"><img alt="" height="96" src="images/nsp-venkitachalam503045-m10013.jpg" width="306"/></p>
</div>
<p>Finally, you compute the camera’s up vector <!--<ccust1>6</ccust1>-->❻ and set the center as the origin (0, 0, 0) <!--<ccust1>7</ccust1>-->❼. Remember that these are the pieces of information, along with the eye position, that OpenGL needs to model a camera.</p>
</section>
<section>
<h4 class="ch" id="ch1209"><span aria-label=" Page 198. " class="page" epub:type="pagebreak" id="p198" role="doc-pagebreak"/>Calculating the Up Vector</h4>
<p class="paft">Here’s the method that you call in the <code>OrbitCamera</code> class constructor to compute the up vector:</p>
<div class="codeline">
<p class="clf">def __compute_up_vector(self, E):</p>
<p class="cl">    # N = (E x k) x E</p>
<p class="cl">    Z = np.array([0, 0, 1], np.float32)</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ U = np.<span class="idx" data-level1="cross" data-term="numpy module"/>cross(np.cross(E, Z), E)</p>
<p class="cl">    # normalize</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ U = U / np.linalg.<span class="idx" data-level1="linalg" data-level2="norm" data-term="numpy module"/>norm(U)</p>
<p class="cll">    return U</p>
</div>
<p>The <code>__compute_up_vector()</code> method calculates the up vector <code>U</code> based on the method we discussed earlier in <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#bh1205">“Controlling the Camera”</a> on <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#p185">page 185</a>. Specifically, you use cross products and the initial up vector guess of (0, 0, 1) to compute the correct up vector <!--<ccust1>1</ccust1>-->❶. Then you normalize the up vector <!--<ccust1>2</ccust1>-->❷ before returning it.</p>
</section>
<section>
<h4 class="ch" id="ch1210"><span class="idx" data-level1="rotating camera" data-term="torus"/>Rotating the Camera</h4>
<p class="paft">The <code>OrbitCamera</code> class’s <code>rotate()</code> method is called every time you need to rotate the camera around the torus by one step. Here’s the method’s definition:</p>
<div class="codeline">
<p class="clf">def rotate(self):</p>
<p class="cl">    """rotate by one step and compute new camera parameters"""</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ self.beta = (self.beta + self.beta_step) % 360</p>
<p class="cl">    # recalculate eye E</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ self.eye = np.array([self.radius*math.cos(math.<span class="idx" data-level1="math" data-level2="radians" data-term="numpy module"/>radians(self.beta)),</p>
<p class="cl">                         self.radius*math.sin(math.radians(self.beta)),</p>
<p class="cl">                         self.height], np.float32)</p>
<p class="cl">    # up vector</p>
<p class="cll">  <!--<ccust1>3</ccust1>-->❸ self.up = self.__compute_up_vector(self.eye)</p>
</div>
<p>You increase the angle <code>beta</code> by the increment <code>beta_step</code>, using the <code>%</code> operator to ensure that the angle rolls over to 0 when it reaches 360 degrees <!--<ccust1>1</ccust1>-->❶. Then you use the new <code>beta</code> value to compute the updated eye position <!--<ccust1>2</ccust1>-->❷, and you use the new eye position to compute the new up vector with the <code>__compute_up_vector()</code> method <!--<ccust1>3</ccust1>-->❸.</p>
</section>
</section>
<section>
<h3 class="bh" id="bh1210"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1210">Putting Everything Together</a></h3>
<p class="paft">You’ve built all the classes necessary for rendering the torus. Now you need some code to bring those classes together, create and manage the OpenGL window, and coordinate the rendered objects. Create the class <code>RenderWindow</code> (defined in <i>gol_torus.py</i>) for this purpose. It’s similar to the <code>RenderWindow</code> class used in <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#ch09">Chapter 9</a>, so we’ll discuss only the parts of the code that are unique to the current project. To see the complete code listing, skip ahead to <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#ah1210">“The Complete RenderWindow Code”</a> on <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#p211">page 211</a>.</p>
<section>
<h4 class="ch" id="ch1211"><span aria-label=" Page 199. " class="page" epub:type="pagebreak" id="p199" role="doc-pagebreak"/>The main() Function</h4>
<p class="paft">Before we examine the <code>RenderWindow</code> class, let’s look the program’s <code>main()</code> function, which sets the whole simulation in motion. This function is also defined in <i>gol_torus.py</i>.</p>
<div class="codeline">
<p class="clf">def main():</p>
<p class="cl">    print("Starting GOL. Press ESC to quit.")</p>
<p class="cl">    # parse arguments</p>
<p class="cl">    parser = argparse.<span class="idx" data-level1="ArgumentParser" data-term="argparse module"/>ArgumentParser(description="Runs Conway's Game of Life</p>
<p class="cl">                                     simulation on a Torus.")</p>
<p class="cl">    # add arguments</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ parser.<span class="idx" data-level1="ArgumentParser" data-level2="add_argument" data-term="argparse module"/>add_argument('--glider', action='store_true', required=False)</p>
<p class="cl">    args = parser.<span class="idx" data-level1="ArgumentParser" data-level2="parse_args" data-term="argparse module"/>parse_args()</p>
<p class="cl">    glider = False</p>
<p class="cl">    if args.glider:</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ glider = True</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ rw = RenderWindow(glider)</p>
<p class="cll">  <!--<ccust1>4</ccust1>-->❹ rw.run()</p>
</div>
<p>You add a command line argument called <code>--glider</code> so you can bring up the torus with just a glider pattern on it <!--<ccust1>1</ccust1>-->❶ and set the corresponding flag <!--<ccust1>2</ccust1>-->❷. Then you create a <code>RenderWindow</code> object <!--<ccust1>3</ccust1>-->❸, which initializes all the other objects needed for the program, and start the rendering with a call to the <code>RenderWindow</code> object’s <code>run()</code> method <!--<ccust1>4</ccust1>-->❹.</p>
</section>
<section>
<h4 class="ch" id="ch1212">The RenderWindow Constructor</h4>
<p class="paft">The constructor on the <code>RenderWindow</code> class starts with the standard GLFW OpenGL setup you saw in <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#ch09">Chapter 9</a>, including setting the window size, calling the render methods, and handling window and keyboard events. Then the constructor goes on with the following Game of Life–specific initializations:</p>
<div class="codeline">
<p class="clf">class RenderWindow:</p>
<p class="cl">    def __init__(self, glider):</p>
<p class="cl">    --<code class="i">snip</code>--</p>
<p class="cl">       # create 3D</p>
<p class="cl">        NX = 64</p>
<p class="cl">        NY = 64</p>
<p class="cl">        R = 4.0</p>
<p class="cl">        r = 1.0</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ self.torus = Torus(R, r, NX, NY)</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ self.gol = GOL(NX, NY, glider)</p>
<p class="cl">        # create a camera</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ self.camera = OrbitCamera(5.0, 10.0)</p>
<p class="cl">        # exit flag</p>
<p class="cl">      <!--<ccust1>4</ccust1>-->❹ self.exitNow = False</p>
<p class="cl">      # rotation flag</p>
<p class="cl">      <!--<ccust1>5</ccust1>-->❺ self.rotate = True</p>
<p class="cl">        # skip count</p>
<p class="cll">      <!--<ccust1>6</ccust1>-->❻ self.skip = 0</p>
</div>
<p><span aria-label=" Page 200. " class="page" epub:type="pagebreak" id="p200" role="doc-pagebreak"/>First you set some parameters for the simulation, including the number of cells in the grid and the inner and outer radiuses of the torus. Then you create the <code>Torus</code> object using these parameters <!--<ccust1>1</ccust1>-->❶, as well as the <code>GOL</code> object that will manage the simulation <!--<ccust1>2</ccust1>-->❷. You also create the orbiting camera at a radius of 5 units from the origin and a height of 10 units from the XY plane <!--<ccust1>3</ccust1>-->❸.</p>
<p>Next, you set the exit flag used to quit the program <!--<ccust1>4</ccust1>-->❹, and you initialize the rotation flag to <code>True</code> <!--<ccust1>5</ccust1>-->❺. Finally, you set a <code>skip</code> variable <!--<ccust1>6</ccust1>-->❻, which you’ll use to control the frequency at which the simulation updates. You’ll see how the <code>skip</code> variable works later in this section.</p>
</section>
<section>
<h4 class="ch" id="ch1213">The run() and step() Methods</h4>
<p class="paft">The <code>run()</code> method of the <code>RenderWindow</code> object is responsible for running the simulation, with help from the <code>step()</code> method. Let’s take a look at the <code>run()</code> method first:</p>
<div class="codeline">
<p class="clf">def run(self):</p>
<p class="cl">    # initializer timer</p>
<p class="cl">    glfw.<span class="idx" data-level1="glfwSetTime" data-term="GLFW"/>glfwSetTime(0)</p>
<p class="cl">    t = 0.0</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ while not glfw.<span class="idx" data-level1="glfwWindowShouldClose" data-term="GLFW"/>glfwWindowShouldClose(self.win) and not self.exitNow:</p>
<p class="cl">        # update every x seconds</p>
<p class="cl">        currT = glfw.<span class="idx" data-level1="glfwGetTime" data-term="GLFW"/>glfwGetTime()</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ if currT - t &gt; 0.05:</p>
<p class="cl">            # update time</p>
<p class="cl">            t = currT</p>
<p class="cl">            # set viewport</p>
<p class="cl">          <!--<ccust1>3</ccust1>-->❸ self.width, self.height = glfw.<span class="idx" data-level1="glfwGetFramebufferSize" data-term="GLFW"/>glfwGetFramebufferSize(self.win)</p>
<p class="cl">            self.aspect = self.width/float(self.height)</p>
<p class="cl">            <span class="idx" data-level1="glViewport" data-term="OpenGL"/>glViewport(0, 0, self.width, self.height)</p>
<p class="clf">            # clear</p>
<p class="cl">            <span class="idx" data-level1="glClear" data-term="OpenGL"/>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)</p>
<p class="cl">            # build projection matrix</p>
<p class="cl">            pMatrix = glutils.perspective(60.0, self.aspect, 0.1, 100.0)</p>
<p class="clf">            mvMatrix = glutils.lookAt(self.camera.eye, self.camera.center,</p>
<p class="cl">                                      self.camera.up)</p>
<p class="cl">            # render</p>
<p class="cl">          <!--<ccust1>4</ccust1>-->❹ self.torus.render(pMatrix, mvMatrix)</p>
<p class="clf">            # step</p>
<p class="cl">          <!--<ccust1>5</ccust1>-->❺ if self.rotate:</p>
<p class="cl">                self.step()</p>
<p class="cl">            glfw.glfwSwapBuffers(self.win)</p>
<p class="cl">            # poll for and process events</p>
<p class="cl">            glfw.glfwPollEvents()</p>
<p class="cl">    # end</p>
<p class="cll">    glfw.<span class="idx" data-level1="glfwTerminate" data-term="GLFW"/>glfwTerminate()</p>
</div>
<p>The rendering scheme is designed to keep rendering frames in a loop until the window is closed or the <span class="sm">ESC</span> key is pressed <!--<ccust1>1</ccust1>-->❶. Before you proceed, <span aria-label=" Page 201. " class="page" epub:type="pagebreak" id="p201" role="doc-pagebreak"/>you check whether the time elapsed since the last render is greater than 0.05 seconds <!--<ccust1>2</ccust1>-->❷. This helps maintain a maximum frame rate. Starting at <!--<ccust1>3</ccust1>-->❸, you perform some standard OpenGL operations, such as setting the viewport, clearing the screen, and computing the current transformation that needs to be set into the vertex shader. Then you render the torus <!--<ccust1>4</ccust1>-->❹ and call the <code>step()</code> method <!--<ccust1>5</ccust1>-->❺, which will rotate the camera and update the Game of Life simulation by one time step. Once the rendering is done, you swap the OpenGL buffers and poll for further window events. If you exit the loop, you call the <code>glfwTerminate()</code> method for cleanup.</p>
<p>Here’s the <code>step()</code> method that increments the camera and the simulation:</p>
<div class="codeline">
<p class="clf">def step(self):</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ if self.skip == 9:</p>
<p class="cl">        # update GOL</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ self.gol.update()</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ colors = self.gol.get_colors()</p>
<p class="cl">      <!--<ccust1>4</ccust1>-->❹ self.torus.set_colors(colors)</p>
<p class="cl">        # step</p>
<p class="cl">      <!--<ccust1>5</ccust1>-->❺ self.torus.step()</p>
<p class="cl">        # reset</p>
<p class="cl">      <!--<ccust1>6</ccust1>-->❻ self.skip = 0</p>
<p class="cl">    # update skip</p>
<p class="cl">  <!--<ccust1>7</ccust1>-->❼ self.skip += 1</p>
<p class="cl">    # rotate camera</p>
<p class="cll">  <!--<ccust1>8</ccust1>-->❽ self.camera.rotate()</p>
</div>
<p>Every time this method is called, it rotates the camera by one step <!--<ccust1>8</ccust1>-->❽. You also want to update the Game of Life simulation, but doing so at the same rate that the camera moves would not be visually pleasing. You therefore use the <code>skip</code> variable to slow down the simulation by a factor of 9 relative to the camera motion. This variable starts from <code>0</code> and is incremented each time the <code>step()</code> method is called <!--<ccust1>7</ccust1>-->❼. When <code>skip</code> gets to <code>9</code> <!--<ccust1>1</ccust1>-->❶, you update the simulation by one time step. To do this, you first call the <code>GOL</code> class’s <code>update()</code> method <!--<ccust1>2</ccust1>-->❷, which turns cells on or off according to the Conway’s Game of Life rules. Then you get the updated cell colors from the simulation <!--<ccust1>3</ccust1>-->❸, set them to the torus <!--<ccust1>4</ccust1>-->❹, and call <code>torus.step()</code> <!--<ccust1>5</ccust1>-->❺, which will update the attribute buffers with the new colors. Finally, you reset the <code>skip</code> variable to <code>0</code> so the process can repeat <!--<ccust1>6</ccust1>-->❻.</p>
</section>
</section>
</section>
<section>
<h2 class="ah" id="ah1204"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1204">Running the 3D Game of Life Simulation</a></h2>
<p class="paft"><span class="idx" data-level1="running the code" data-term="torus"/>Now we’re ready to run the code. Enter the following at the terminal:</p>
<div class="codeline">
<p class="cls">$ <code class="b">python gol_torus.py</code></p>
</div>
<p><a class="xref" href="nsp-venkitachalam503045-0024.xhtml#fig10-8">Figure 10-8</a> shows the output.</p>
<figure class="figure" id="fig10-8">
<p class="fig"><span aria-label=" Page 202. " class="page" epub:type="pagebreak" id="p202" role="doc-pagebreak"/><img alt="" height="803" src="images/nsp-venkitachalam503045-f10008.jpg" style="width:95%; height:auto;" width="1021"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 10-8:</span> A rendering of the Game of Life on a torus</p>
</figcaption>
</figure>
<p>The program will open a window that shows the torus you meticulously constructed, with the Game of Life simulation running on its surface! As the simulation evolves, try to find some of the familiar Game of Life patterns you saw in <a class="xref" href="nsp-venkitachalam503045-0015.xhtml#ch03">Chapter 3</a>. Notice that the light direction remains constant while the camera orbits the torus. As the camera turns, you’ll be able to see the light and dark portions of the torus.</p>
<p>Now let’s try the glider option:</p>
<div class="codeline">
<p class="cls">$ <span class="idx" data-level1="Game of Life rendering" data-term="torus"/><code class="b">python gol_torus.py --glider</code></p>
</div>
<p><a class="xref" href="nsp-venkitachalam503045-0024.xhtml#fig10-9">Figure 10-9</a> shows the output.</p>
<figure class="figure" id="fig10-9">
<p class="fig"><img alt="" height="805" src="images/nsp-venkitachalam503045-f10009.jpg" style="width:95%; height:auto;" width="1022"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 10-9:</span> A Game of Life glider on a torus</p>
</figcaption>
</figure>
<p><span aria-label=" Page 203. " class="page" epub:type="pagebreak" id="p203" role="doc-pagebreak"/>Sit back and enjoy watching the lone glider make its way along the surface of the torus!</p>
</section>
<section>
<h2 class="ah" id="ah1205"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1205">Summary</a></h2>
<p class="paft">In this chapter, you implemented Conway’s Game of Life on a torus. You learned how to compute the vertices of a torus and how to render it using OpenGL, and you saw how code can be adapted from one context (a flat rendering of the Game of Life simulation) to another (a 3D rendering of the same simulation). In the process, I hope you’ve gotten a more intuitive feeling for how the toroidal boundary conditions we discussed in <a class="xref" href="nsp-venkitachalam503045-0015.xhtml#ch03">Chapter 3</a> work.</p>
</section>
<section>
<h2 class="ah" id="ah1206"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1206">Experiments!</a></h2>
<p class="paft">Here are a few experiments you can try with this project:</p>
<ol style="list-style-type:none">
<li class="nlf">1. In this chapter’s implementation, the torus is lit by a single light source. Try adding another light source in the shader code. Now the computed color of a vertex will be the sum of contributions from both light sources. Try changing the positions and colors of the light sources and see the effect on the torus lighting.</li>
<li class="nl">2. To get a representative view of the simulation, you defined a camera that revolves around the z-axis of the torus, in a plane parallel to the XY plane. Now create a camera that flies over the torus instead. Your camera will start by looking down at the torus along the negative z-axis and will move in a circle along the XZ plane, at a fixed distance from the center of the torus. Think about how you will compute the eye point, view direction, and up vector for each step of the movement.</li>
</ol>
</section>
<section>
<h2 class="ah" id="ah1207"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1207">The Complete Torus Rendering Code</a></h2>
<p class="paft"><span class="idx" data-level1="complete code" data-term="torus"/>Here’s the complete listing for the file <i>torus.py</i>:</p>
<div class="codeline">
<p class="clf">"""</p>
<p class="cl">torus.py</p>
<p class="clf">A Python OpenGL program that generates a torus.</p>
<p class="clf">Author: Mahesh Venkitachalam</p>
<p class="cl">"""</p>
<p class="clf">import OpenGL</p>
<p class="cl">from OpenGL.GL import *</p>
<p class="clf">import numpy as np</p>
<p class="cl">import math, sys, os</p>
<p class="cl">import glutils</p>
<p class="clf">import glfw</p>
<p class="clf"><span aria-label=" Page 204. " class="page" epub:type="pagebreak" id="p204" role="doc-pagebreak"/>strVS = """</p>
<p class="cl"># version 330 core</p>
<p class="clf">layout(location = 0) in vec3 aVert;</p>
<p class="cl">layout(location = 1) in vec3 aColor;</p>
<p class="cl">layout(location = 2) in vec3 aNormal;</p>
<p class="clf">uniform mat4 uMVMatrix;</p>
<p class="cl">uniform mat4 uPMatrix;</p>
<p class="clf">flat out vec3 vColor;</p>
<p class="cl">out vec3 vNormal;</p>
<p class="cl">out vec3 fragPos;</p>
<p class="clf">void main() {</p>
<p class="cl">  // transform vertex</p>
<p class="cl">  gl_Position = uPMatrix * uMVMatrix * vec4(aVert, 1.0);</p>
<p class="cl">  fragPos = aVert;</p>
<p class="cl">  vColor = aColor;</p>
<p class="cl">  vNormal = aNormal;</p>
<p class="cl">}</p>
<p class="cl">"""</p>
<p class="clf">strFS = """</p>
<p class="cl"># version 330 core</p>
<p class="cl">flat in vec3 vColor;</p>
<p class="clf">in vec3 vNormal;</p>
<p class="cl">in vec3 fragPos;</p>
<p class="clf">out vec4 fragColor;</p>
<p class="clf">void main() {</p>
<p class="cl">  vec3 lightPos = vec3(10.0, 10.0, 10.0);</p>
<p class="cl">  vec3 lightColor = vec3(1.0, 1.0, 1.0);</p>
<p class="cl">  vec3 lightDir = normalize(lightPos - fragPos);</p>
<p class="cl">  float diff = max(dot(vNormal, lightDir), 0.0);</p>
<p class="cl">  vec3 diffuse = diff * lightColor;</p>
<p class="cl">  float ambient = 0.1;</p>
<p class="cl">  vec3 result = (ambient + diffuse) * vColor.xyz;</p>
<p class="cl">  fragColor = vec4(result, 1.0);</p>
<p class="cl">}</p>
<p class="cl">"""</p>
<p class="clf">class Torus:</p>
<p class="cl">    """ OpenGL 3D scene class"""</p>
<p class="cl">    # initialization</p>
<p class="cl">    def __init__(self, R, r, NX, NY):</p>
<p class="cl">        global strVS, strFS</p>
<p class="clf">        # create shader</p>
<p class="cl">        self.program = glutils.loadShaders(strVS, strFS)</p>
<p class="clf">        glProvokingVertex(GL_FIRST_VERTEX_CONVENTION)</p>
<p class="clf"><span aria-label=" Page 205. " class="page" epub:type="pagebreak" id="p205" role="doc-pagebreak"/>        self.pMatrixUniform = glGetUniformLocation(self.program,</p>
<p class="cl">                                                   b'uPMatrix')</p>
<p class="cl">        self.mvMatrixUniform = glGetUniformLocation(self.program,</p>
<p class="cl">                                                    b'uMVMatrix')</p>
<p class="clf">        # torus geometry</p>
<p class="cl">        self.R = R</p>
<p class="cl">        self.r = r</p>
<p class="cl">        # grid size</p>
<p class="cl">        self.NX = NX</p>
<p class="cl">        self.NY = NY</p>
<p class="cl">        # no. of points</p>
<p class="cl">        self.N = self.NX</p>
<p class="cl">        self.M = self.NY</p>
<p class="clf">        # time</p>
<p class="cl">        self.t = 0</p>
<p class="clf">        # compute parameters for glMultiDrawArrays</p>
<p class="cl">        M1 = 2*self.M + 2</p>
<p class="cl">        self.first_indices = [2*M1*i for i in range(self.N)]</p>
<p class="cl">        self.counts = [2*M1 for i in range(self.N)]</p>
<p class="clf">        # colors: {(i, j) : (r, g, b)}</p>
<p class="cl">        # with NX * NY entries</p>
<p class="cl">        self.colors_dict = self.init_colors(self.NX, self.NY)</p>
<p class="clf">        # create an empty array to hold colors</p>
<p class="cl">        self.colors = np.zeros((3*self.N*(2*self.M + 2), ), np.float32)</p>
<p class="clf">        # get vertices, normals, indices</p>
<p class="cl">        vertices, normals = self.compute_vertices()</p>
<p class="cl">        self.compute_colors()</p>
<p class="cl">        # set up vertex buffer objects</p>
<p class="cl">        self.setup_vao(vertices, normals, self.colors)</p>
<p class="clf">    def init_colors(self, NX, NY):</p>
<p class="cl">        """initialize color dictionary"""</p>
<p class="cl">        colors = {}</p>
<p class="cl">        c1 = [1.0, 1.0, 1.0]</p>
<p class="cl">        for i in range(NX):</p>
<p class="cl">            for j in range (NY):</p>
<p class="cl">                colors[(i, j)] = c1</p>
<p class="cl">        return colors</p>
<p class="clf">    def compute_rt(self, R, alpha):</p>
<p class="cl">        # compute position of ring</p>
<p class="cl">        Tx = R*math.cos(alpha)</p>
<p class="cl">        Ty = R*math.sin(alpha)</p>
<p class="cl">        Tz = 0.0</p>
<p class="clf">        # rotation matrix</p>
<p class="cl">        RM = np.array([</p>
<p class="cl">            [math.cos(alpha), -math.sin(alpha), 0.0, 0.0],</p>
<p class="cl">            [math.sin(alpha), math.cos(alpha), 0.0, 0.0],</p>
<p class="cl"><span aria-label=" Page 206. " class="page" epub:type="pagebreak" id="p206" role="doc-pagebreak"/>            [0.0, 0.0, 1.0, 0.0],</p>
<p class="cl">            [0.0, 0.0, 0.0, 1.0]</p>
<p class="cl">            ], dtype=np.float32)</p>
<p class="clf">        # translation matrix</p>
<p class="cl">        TM = np.array([</p>
<p class="cl">            [1.0, 0.0, 0.0, Tx],</p>
<p class="cl">            [0.0, 1.0, 0.0, Ty],</p>
<p class="cl">            [0.0, 0.0, 1.0, Tz],</p>
<p class="cl">            [0.0, 0.0, 0.0, 1.0]</p>
<p class="cl">            ], dtype=np.float32)</p>
<p class="clf">        return (RM, TM)</p>
<p class="clf">    def compute_pt(self, r, theta, RM, TM):</p>
<p class="cl">        # compute point coords</p>
<p class="cl">        P = np.array([r*math.cos(theta), 0.0, r*math.sin(theta), 1.0],</p>
<p class="cl">                     dtype=np.float32)</p>
<p class="cl">        # print(P)</p>
<p class="cl">        # apply rotation - this also gives us the vertex normals</p>
<p class="cl">        NV = np.dot(RM, P)</p>
<p class="cl">        # normalize</p>
<p class="cl">        # NV = NV / np.linalg.norm(NV)</p>
<p class="cl">        # apply translation</p>
<p class="cl">        Pt = np.dot(TM, NV)</p>
<p class="clf">        return (Pt, NV)</p>
<p class="clf">    def compute_vertices(self):</p>
<p class="cl">        """compute vertices for the torus</p>
<p class="cl">           returns np float32 array of n coords (x, y, z): shape (3*n, )</p>
<p class="cl">        """</p>
<p class="clf">        R, r, N, M = self.R, self.r, self.N, self.M</p>
<p class="clf">        # create an empty array to hold vertices/normals</p>
<p class="cl">        vertices = []</p>
<p class="cl">        normals = []</p>
<p class="clf">        # the points on the ring are generated on the X-Z plane</p>
<p class="cl">        # then they are rotated and translated into the correct</p>
<p class="cl">        # position on the torus</p>
<p class="clf">        # for all N rings around the torus</p>
<p class="cl">        for i in range(N):</p>
<p class="clf">            # for all M points around a ring</p>
<p class="cl">            for j in range(M+1):</p>
<p class="clf">                # compute angle theta of point</p>
<p class="cl">                theta = (j % M) *2*math.pi/M</p>
<p class="clf">                #---ring #1------</p>
<p class="clf">                # compute angle</p>
<p class="cl"><span aria-label=" Page 207. " class="page" epub:type="pagebreak" id="p207" role="doc-pagebreak"/>                alpha1 = i*2*math.pi/N</p>
<p class="cl">                # compute transforms</p>
<p class="cl">                RM1, TM1 = self.compute_rt(R, alpha1)</p>
<p class="cl">                # compute points</p>
<p class="cl">                Pt1, NV1 = self.compute_pt(r, theta, RM1, TM1)</p>
<p class="clf">                #---ring #2------</p>
<p class="cl">                # index of next ring</p>
<p class="cl">                ip1 = (i + 1) % N</p>
<p class="clf">                # compute angle</p>
<p class="cl">                alpha2 = ip1*2*math.pi/N</p>
<p class="cl">                # compute transforms</p>
<p class="cl">                RM2, TM2 = self.compute_rt(R, alpha2)</p>
<p class="cl">                # compute points</p>
<p class="cl">                Pt2, NV2 = self.compute_pt(r, theta, RM2, TM2)</p>
<p class="clf">                # store vertices/normals in right order for GL_TRIANGLE_STRIP</p>
<p class="cl">                vertices.append(Pt1[0:3])</p>
<p class="cl">                vertices.append(Pt2[0:3])</p>
<p class="clf">                # add normals</p>
<p class="cl">                normals.append(NV1[0:3])</p>
<p class="cl">                normals.append(NV2[0:3])</p>
<p class="clf">        # return vertices and colors in correct format</p>
<p class="cl">        vertices = np.array(vertices, np.float32).reshape(-1)</p>
<p class="cl">        normals = np.array(normals, np.float32).reshape(-1)</p>
<p class="cl">        # print(vertices.shape)</p>
<p class="cl">        return vertices, normals</p>
<p class="clf">    def compute_colors(self):</p>
<p class="cl">        """compute vertices for the torus</p>
<p class="cl">           returns np float32 array of n coords (x, y, z): shape (3*n, )</p>
<p class="cl">        """</p>
<p class="clf">        R, r, N, M = self.R, self.r, self.N, self.M</p>
<p class="clf">        # the points on the ring are generated on the X-Z plane</p>
<p class="cl">        # then they are rotated and translated into the correct</p>
<p class="cl">        # position on the torus</p>
<p class="clf">        # for all N rings around the torus</p>
<p class="cl">        for i in range(N):</p>
<p class="clf">            # for all M points around a ring</p>
<p class="cl">            for j in range(M+1):</p>
<p class="clf">                # j value</p>
<p class="cl">                jj = j % M</p>
<p class="clf">                # store colors - same color applies to (V_i_j, V_ip1_j)</p>
<p class="cl">                col = self.colors_dict[(i, jj)]</p>
<p class="cl">                # get index into array</p>
<p class="cl">                index = 3*(2*i*(M+1) + 2*j)</p>
<p class="cl"><span aria-label=" Page 208. " class="page" epub:type="pagebreak" id="p208" role="doc-pagebreak"/>                # set color</p>
<p class="cl">                self.colors[index:index+3] = col</p>
<p class="cl">                self.colors[index+3:index+6] = col</p>
<p class="clf">    def setup_vao(self, vertices, normals, colors):</p>
<p class="cl">        # set up vertex array object (VAO)</p>
<p class="cl">        self.vao = glGenVertexArrays(1)</p>
<p class="cl">        glBindVertexArray(self.vao)</p>
<p class="clf">        # --------</p>
<p class="cl">        # vertices</p>
<p class="cl">        # --------</p>
<p class="cl">        self.vertexBuffer = glGenBuffers(1)</p>
<p class="cl">        glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)</p>
<p class="cl">        # set buffer data</p>
<p class="cl">        glBufferData(GL_ARRAY_BUFFER, 4*len(vertices), vertices,</p>
<p class="cl">                     GL_STATIC_DRAW)</p>
<p class="cl">        # enable vertex attribute array</p>
<p class="cl">        glEnableVertexAttribArray(0)</p>
<p class="cl">        # set buffer data pointer</p>
<p class="cl">        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, None)</p>
<p class="clf">        # normals</p>
<p class="cl">        # --------</p>
<p class="cl">        self.normalBuffer = glGenBuffers(1)</p>
<p class="cl">        glBindBuffer(GL_ARRAY_BUFFER, self.normalBuffer)</p>
<p class="cl">        # set buffer data</p>
<p class="cl">        glBufferData(GL_ARRAY_BUFFER, 4*len(normals), normals,</p>
<p class="cl">                     GL_STATIC_DRAW)</p>
<p class="cl">        # enable vertex attribute array</p>
<p class="cl">        glEnableVertexAttribArray(2)</p>
<p class="cl">        # set buffer data pointer</p>
<p class="cl">        glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, None)</p>
<p class="clf">        # --------</p>
<p class="cl">        # colors</p>
<p class="cl">        # --------</p>
<p class="cl">        self.colorBuffer = glGenBuffers(1)</p>
<p class="cl">        glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)</p>
<p class="cl">        # set buffer data</p>
<p class="cl">        glBufferData(GL_ARRAY_BUFFER, 4*len(colors), colors,</p>
<p class="cl">                     GL_STATIC_DRAW)</p>
<p class="cl">        # enable color attribute array</p>
<p class="cl">        glEnableVertexAttribArray(1)</p>
<p class="cl">        # set buffer data pointer</p>
<p class="cl">        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, None)</p>
<p class="clf">        # unbind VAO</p>
<p class="cl">        glBindVertexArray(0)</p>
<p class="clf">    def set_colors(self, colors):</p>
<p class="cl">        self.colors_dict = colors</p>
<p class="cl">        self.recalc_colors()</p>
<p class="clf">    def recalc_colors(self):</p>
<p class="clf"><span aria-label=" Page 209. " class="page" epub:type="pagebreak" id="p209" role="doc-pagebreak"/>        # get colors</p>
<p class="cl">        self.compute_colors()</p>
<p class="clf">        # bind VAO</p>
<p class="cl">        glBindVertexArray(self.vao)</p>
<p class="cl">        # --------</p>
<p class="cl">        # colors</p>
<p class="cl">        # --------</p>
<p class="cl">        glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)</p>
<p class="cl">        # set buffer data</p>
<p class="cl">        glBufferSubData(GL_ARRAY_BUFFER, 0, 4*len(self.colors), self.colors)</p>
<p class="cl">        # unbind VAO</p>
<p class="cl">        glBindVertexArray(0)</p>
<p class="clf">    # step</p>
<p class="cl">    def step(self):</p>
<p class="cl">        # recompute colors</p>
<p class="cl">        self.recalc_colors()</p>
<p class="clf">    # render</p>
<p class="cl">    def render(self, pMatrix, mvMatrix):</p>
<p class="cl">        # use shader</p>
<p class="cl">        glUseProgram(self.program)</p>
<p class="clf">        # set proj matrix</p>
<p class="cl">        glUniformMatrix4fv(self.pMatrixUniform, 1, GL_FALSE, pMatrix)</p>
<p class="clf">        # set modelview matrix</p>
<p class="cl">        glUniformMatrix4fv(self.mvMatrixUniform, 1, GL_FALSE, mvMatrix)</p>
<p class="clf">        # bind VAO</p>
<p class="cl">        glBindVertexArray(self.vao)</p>
<p class="cl">        # draw</p>
<p class="cl">        glMultiDrawArrays(GL_TRIANGLE_STRIP, self.first_indices,</p>
<p class="cl">                          self.counts, self.N)</p>
<p class="cl">        # unbind VAO</p>
<p class="cl">        glBindVertexArray(0)</p>
</div>
</section>
<section>
<h2 class="ah" id="ah1208"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1208">The Complete Game of Life Simulation Code</a></h2>
<p class="paft"><span class="idx" data-level1="Game of Life" data-level2="complete code" data-term="torus"/>Here’s the full code listing for the file <i>gol.py</i>.</p>
<div class="codeline1">
<p class="cl1f">"""</p>
<p class="cl1">gol.py</p>
<p class="cl1f">Implements Conway's Game of Life.</p>
<p class="cl1f">Author: Mahesh Venkitachalam</p>
<p class="cl1">"""</p>
<p class="cl1f">import numpy as np</p>
<p class="cl1f">class GOL:</p>
<p class="cl1">    """GOL - class that implements Conway's Game of Life</p>
<p class="cl1"><span aria-label=" Page 210. " class="page" epub:type="pagebreak" id="p210" role="doc-pagebreak"/>    """</p>
<p class="cl1">    def __init__(self, NX, NY, glider):</p>
<p class="cl1">        """GOL constructor"""</p>
<p class="cl1">        # a grid of NX x NY random values</p>
<p class="cl1">        self.NX, self.NY = NX, NY</p>
<p class="cl1">        if glider:</p>
<p class="cl1">            self.addGlider(1, 1, NX, NY)</p>
<p class="cl1">        else:</p>
<p class="cl1">            self.grid = np.random.choice([1, 0], NX * NY, p=[0.2, 0.8]).reshape(NX, NY)</p>
<p class="cl1f">    def addGlider(self, i, j, NX, NY):</p>
<p class="cl1">        """adds a glider with top left cell at (i, j)"""</p>
<p class="cl1">        self.grid = np.zeros(NX * NY).reshape(NX, NY)</p>
<p class="cl1">        glider = np.array([[0,    0, 1],</p>
<p class="cl1">                          [1,  0, 1],</p>
<p class="cl1">                          [0,  1, 1]])</p>
<p class="cl1">        self.grid[i:i+3, j:j+3] = glider</p>
<p class="cl1f">    def update(self):</p>
<p class="cl1">        """update the GOL simulation by one time step"""</p>
<p class="cl1">        # copy grid since we require 8 neighbors for calculation</p>
<p class="cl1">        # and we go line by line</p>
<p class="cl1">        newGrid = self.grid.copy()</p>
<p class="cl1">        NX, NY = self.NX, self.NY</p>
<p class="cl1">        for i in range(NX):</p>
<p class="cl1">            for j in range(NY):</p>
<p class="cl1">                # compute 8-neighbor sum</p>
<p class="cl1">                # using toroidal boundary conditions - x and y wrap around</p>
<p class="cl1">                # so that the simulation takes place on a toroidal surface</p>
<p class="cl1">                total = (self.grid[i, (j-1) % NY] + self.grid[i, (j+1) % NY] +</p>
<p class="cl1">                        self.grid[(i-1) % NX, j] + self.grid[(i+1) % NX, j] +</p>
<p class="cl1">                        self.grid[(i-1) % NX, (j-1) % NY] + self.grid[(i-1) % NX, (j+1) % NY] +</p>
<p class="cl1">                        self.grid[(i+1) % NX, (j-1) % NY] + self.grid[(i+1) % NX, (j+1) % NY])</p>
<p class="cl1">                # apply Conway's rules</p>
<p class="cl1">                if self.grid[i, j]  == 1:</p>
<p class="cl1">                    if (total &lt; 2) or (total &gt; 3):</p>
<p class="cl1">                        newGrid[i, j] = 0</p>
<p class="cl1">                else:</p>
<p class="cl1">                    if total == 3:</p>
<p class="cl1">                        newGrid[i, j] = 1</p>
<p class="cl1">        # update data</p>
<p class="cl1">        self.grid[:] = newGrid[:]</p>
<p class="cl1f">    def get_colors(self):</p>
<p class="cl1">        """returns a dictionary of colors"""</p>
<p class="cl1">        colors = {}</p>
<p class="cl1">        c1 = np.array([1.0, 1.0, 1.0], np.float32)</p>
<p class="cl1">        c2 = np.array([0.0, 0.0, 0.0], np.float32)</p>
<p class="cl1">        for i in range(self.NX):</p>
<p class="cl1">            for j in range (self.NY):</p>
<p class="cl1">                if self.grid[i, j] == 1:</p>
<p class="cl1">                    colors[(i, j)] = c2</p>
<p class="cl1">                else :</p>
<p class="cl1">                    colors[(i, j)] = c1</p>
<p class="cl1">        return colors</p>
</div>
</section>
<section>
<h2 class="ah" id="ah1209"><span aria-label=" Page 211. " class="page" epub:type="pagebreak" id="p211" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1209">The Complete Camera Code</a></h2>
<p class="paft"><span class="idx" data-level1="camera" data-level2="complete code" data-term="torus"/>Here’s the complete code in the file <i>camera.py</i>:</p>
<div class="codeline">
<p class="clf">"""</p>
<p class="cl">camera.py</p>
<p class="clf">A simple camera class for OpenGL rendering.</p>
<p class="clf">Author: Mahesh Venkitachalam</p>
<p class="cl">"""</p>
<p class="clf">import numpy as np</p>
<p class="cl">import math</p>
<p class="clf">class OrbitCamera:</p>
<p class="cl">    """helper class for viewing"""</p>
<p class="cl">    def __init__(self, height, radius, beta_step=1):</p>
<p class="cl">        self.radius = radius</p>
<p class="cl">        self.beta = 0</p>
<p class="cl">        self.beta_step = beta_step</p>
<p class="cl">        self.height = height</p>
<p class="cl">        # initial eye vector is (-R, 0, -H)</p>
<p class="cl">        rr = radius/math.sqrt(2.0)</p>
<p class="cl">        self.eye = np.array([rr, rr, height], np.float32)</p>
<p class="cl">        # compute up vector</p>
<p class="cl">        self.up = self.__compute_up_vector(self.eye )</p>
<p class="cl">        # center is origin</p>
<p class="cl">        self.center = np.array([0, 0, 0], np.float32)</p>
<p class="clf">    def __compute_up_vector(self, E):</p>
<p class="cl">        """compute up vector</p>
<p class="cl">        N = (E x k) x E</p>
<p class="cl">        """</p>
<p class="cl">        # N = (E x k) x E</p>
<p class="cl">        Z = np.array([0, 0, 1], np.float32)</p>
<p class="cl">        U = np.cross(np.cross(E, Z), E)</p>
<p class="cl">        # normalize</p>
<p class="cl">        U = U / np.linalg.norm(U)</p>
<p class="cl">        return U</p>
<p class="clf">    def rotate(self):</p>
<p class="cl">        """rotate by one step and compute new camera parameters"""</p>
<p class="cl">        self.beta = (self.beta + self.beta_step) % 360</p>
<p class="cl">        # recalculate eye E</p>
<p class="cl">        self.eye = np.array([self.radius*math.cos(math.radians(self.beta)),</p>
<p class="cl">                             self.radius*math.sin(math.radians(self.beta)),</p>
<p class="cl">                             self.height], np.float32)</p>
<p class="cl">        # up vector</p>
<p class="cl">        self.up = self.__compute_up_vector(self.eye)</p>
</div>
</section>
<section>
<h2 class="ah" id="ah1210"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1210">The Complete RenderWindow Code</a></h2>
<p class="paft"><span class="idx" data-level1="RenderWindow" data-level2="complete code" data-term="torus"/>The complete code listing for <i>gol_torus.py</i>, including the <code>RenderWindow</code> class and the <code>main()</code> function, follows.</p>
<div class="codeline1">
<p class="cl1f"><span aria-label=" Page 212. " class="page" epub:type="pagebreak" id="p212" role="doc-pagebreak"/>"""</p>
<p class="cl1">gol_torus.py</p>
<p class="cl1f">Python OpenGL program that displays a torus.</p>
<p class="cl1f">Author: Mahesh Venkitachalam</p>
<p class="cl1">"""</p>
<p class="cl1f">import OpenGL</p>
<p class="cl1">from OpenGL.GL import *</p>
<p class="cl1f">import numpy, math, sys, os</p>
<p class="cl1">import argparse</p>
<p class="cl1">import glutils</p>
<p class="cl1f">import glfw</p>
<p class="cl1f">from torus import Torus</p>
<p class="cl1">from camera import OrbitCamera</p>
<p class="cl1">from gol import GOL</p>
<p class="cl1f">class RenderWindow:</p>
<p class="cl1">    """GLFW Rendering window class"""</p>
<p class="cl1">    def __init__(self, glider):</p>
<p class="cl1f">        # save current working directory</p>
<p class="cl1">        cwd = os.getcwd()</p>
<p class="cl1f">        # initialize glfw - this changes cwd</p>
<p class="cl1">        glfw.glfwInit()</p>
<p class="cl1f">        # restore cwd</p>
<p class="cl1">        os.chdir(cwd)</p>
<p class="cl1f">        # version hints</p>
<p class="cl1">        glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MAJOR, 3)</p>
<p class="cl1">        glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MINOR, 3)</p>
<p class="cl1">        glfw.glfwWindowHint(glfw.GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE)</p>
<p class="cl1">        glfw.glfwWindowHint(glfw.GLFW_OPENGL_PROFILE, glfw.GLFW_OPENGL_CORE_PROFILE)</p>
<p class="cl1f">        # make a window</p>
<p class="cl1">        self.width, self.height = 640, 480</p>
<p class="cl1">        self.aspect = self.width/float(self.height)</p>
<p class="cl1">        self.win = glfw.glfwCreateWindow(self.width, self.height, b'gol_torus')</p>
<p class="cl1">        # make context current</p>
<p class="cl1">        glfw.glfwMakeContextCurrent(self.win)</p>
<p class="cl1f">        # initialize GL</p>
<p class="cl1">        glViewport(0, 0, self.width, self.height)</p>
<p class="cl1">        glEnable(GL_DEPTH_TEST)</p>
<p class="cl1">        #glClearColor(0.2, 0.2, 0.2, 1.0)</p>
<p class="cl1">        glClearColor(0.11764706, 0.11764706, 0.11764706, 1.0)</p>
<p class="cl1f">        # set window callbacks</p>
<p class="cl1"><span aria-label=" Page 213. " class="page" epub:type="pagebreak" id="p213" role="doc-pagebreak"/>        glfw.glfwSetMouseButtonCallback(self.win, self.onMouseButton)</p>
<p class="cl1">        glfw.glfwSetKeyCallback(self.win, self.onKeyboard)</p>
<p class="cl1f">        # create 3D</p>
<p class="cl1">        NX = 64</p>
<p class="cl1">        NY = 64</p>
<p class="cl1">        R = 4.0</p>
<p class="cl1">        r = 1.0</p>
<p class="cl1">        self.torus = Torus(R, r, NX, NY)</p>
<p class="cl1">        self.gol = GOL(NX, NY, glider)</p>
<p class="cl1f">        # create a camera</p>
<p class="cl1">        self.camera = OrbitCamera(5.0, 10.0)</p>
<p class="cl1f">        # exit flag</p>
<p class="cl1">        self.exitNow = False</p>
<p class="cl1f">        # rotation flag</p>
<p class="cl1">        self.rotate = True</p>
<p class="cl1f">        # skip count</p>
<p class="cl1">        self.skip = 0</p>
<p class="cl1f">    def onMouseButton(self, win, button, action, mods):</p>
<p class="cl1">        # print 'mouse button: ', win, button, action, mods</p>
<p class="cl1">        pass</p>
<p class="cl1f">    def onKeyboard(self, win, key, scancode, action, mods):</p>
<p class="cl1">        # print 'keyboard: ', win, key, scancode, action, mods</p>
<p class="cl1">        if action == glfw.GLFW_PRESS:</p>
<p class="cl1">            # ESC to quit</p>
<p class="cl1">            if key == glfw.GLFW_KEY_ESCAPE:</p>
<p class="cl1">                self.exitNow = True</p>
<p class="cl1">            elif key == glfw.GLFW_KEY_R:</p>
<p class="cl1">                self.rotate = not self.rotate</p>
<p class="cl1f">    def run(self):</p>
<p class="cl1">        # initializer timer</p>
<p class="cl1">        glfw.glfwSetTime(0)</p>
<p class="cl1">        t = 0.0</p>
<p class="cl1">        while not glfw.glfwWindowShouldClose(self.win) and not self.exitNow:</p>
<p class="cl1">            # update every x seconds</p>
<p class="cl1">            currT = glfw.glfwGetTime()</p>
<p class="cl1">            if currT - t &gt; 0.05:</p>
<p class="cl1">                # update time</p>
<p class="cl1">                t = currT</p>
<p class="cl1f">                # set viewport</p>
<p class="cl1">                self.width, self.height = glfw.glfwGetFramebufferSize(self.win)</p>
<p class="cl1">                self.aspect = self.width/float(self.height)</p>
<p class="cl1">                glViewport(0, 0, self.width, self.height)</p>
<p class="cl1f">                # clear</p>
<p class="cl1">                glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)</p>
<p class="cl1f"><span aria-label=" Page 214. " class="page" epub:type="pagebreak" id="p214" role="doc-pagebreak"/>                # build projection matrix</p>
<p class="cl1">                pMatrix = glutils.perspective(60.0, self.aspect, 0.1, 100.0)</p>
<p class="cl1f">                mvMatrix = glutils.lookAt(self.camera.eye, self.camera.center, self.camera.up)</p>
<p class="cl1f">                # render</p>
<p class="cl1">                self.torus.render(pMatrix, mvMatrix)</p>
<p class="cl1f">                # step</p>
<p class="cl1">                if self.rotate:</p>
<p class="cl1">                    self.step()</p>
<p class="cl1f">                glfw.glfwSwapBuffers(self.win)</p>
<p class="cl1">                # poll for and process events</p>
<p class="cl1">                glfw.glfwPollEvents()</p>
<p class="cl1">        # end</p>
<p class="cl1">        glfw.glfwTerminate()</p>
<p class="cl1f">    def step(self):</p>
<p class="cl1f">        if self.skip == 9:</p>
<p class="cl1">            # update GOL</p>
<p class="cl1">            self.gol.update()</p>
<p class="cl1">            colors = self.gol.get_colors()</p>
<p class="cl1">            self.torus.set_colors(colors)</p>
<p class="cl1">            # step</p>
<p class="cl1">            self.torus.step()</p>
<p class="cl1">            # reset</p>
<p class="cl1">            self.skip = 0</p>
<p class="cl1f">        # update skip</p>
<p class="cl1">        self.skip += 1</p>
<p class="cl1">        # rotate camera</p>
<p class="cl1">        self.camera.rotate()</p>
<p class="cl1f"># main() function</p>
<p class="cl1">def main():</p>
<p class="cl1">    print("Starting GOL. Press ESC to quit.")</p>
<p class="cl1">    # parse arguments</p>
<p class="cl1">    parser = argparse.ArgumentParser(description="Runs Conway's Game of Life simulation</p>
<p class="cl1">                                                  on a Torus.")</p>
<p class="cl1">    # add arguments</p>
<p class="cl1">    parser.add_argument('--glider', action='store_true', required=False)</p>
<p class="cl1">    args = parser.parse_args()</p>
<p class="cl1f">    # set args</p>
<p class="cl1">    glider = False</p>
<p class="cl1">    if args.glider:</p>
<p class="cl1">        glider = True</p>
<p class="cl1f">    rw = RenderWindow(glider)</p>
<p class="cl1">    rw.run()</p>
<p class="cl1f"># call main</p>
<p class="cl1">if __name__ == '__main__':</p>
<p class="cl1">    main()</p>
</div>
</section>
</section>
</div></body></html>