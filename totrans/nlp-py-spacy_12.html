<html><head></head><body>
<div id="sbo-rt-content"><h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_169"/><strong><span class="big">12</span><br/>IMPLEMENTING WEB DATA AND PROCESSING IMAGES</strong></h2>&#13;
<div class="image1"><img src="../Images/comm1.jpg" alt="Image" width="191" height="191"/></div>&#13;
<p class="noindents">Real-life chatbots should respond to a variety of inputs, such as questions from users on unfamiliar topics or even images sent through messaging apps. For example, chatbot app users can send not only text messages, but also photos, and the bot is supposed to react appropriately to both.</p>&#13;
<p class="indent">This chapter provides some examples of how to use other libraries from Python’s AI ecosystem when developing a bot application. First, you’ll combine spaCy with Wikipedia to find information about keywords taken from a user’s question. Next, you’ll obtain descriptive tags for a submitted image with the help of Clarifai, an image and video recognition tool, so your app can interpret visual content.</p>&#13;
<p class="indent">Then you’ll put all the components together to build a Telegram bot that can generate relevant responses to text and images by extracting information from Wikipedia.</p>&#13;
<h3 class="h3" id="lev157"><span epub:type="pagebreak" id="page_170"/><strong>How It Works</strong></h3>&#13;
<p class="noindent"><a href="../Text/ch12.xhtml#ch12fig01">Figure 12-1</a> shows a diagram of the bot we’ll build in this chapter. The bot is designed to understand text messages and pictures, and respond with text from Wikipedia.</p>&#13;
<div class="image"><a id="ch12fig01"/><img src="../Images/fig12-1.jpg" alt="image" width="654" height="568"/></div>&#13;
<p class="figcap"><em>Figure 12-1: How a bot that can process text messages and pictures works</em></p>&#13;
<p class="indent">Using this bot, the user can post either a text message or a picture. If the post is a picture, the bot sends it to an image recognition tool for processing. This tool returns a verbal description of the picture in the form of descriptive tags. If the post is a text message, the bot uses an NLP tool like spaCy to extract a keyword or a keyphrase from it. The bot then uses either the tag or the keyphrase to find the most relevant content on Wikipedia (or somewhere else on the web) and return a piece of it to the user. You can use this scenario in chatbots you design to hold a conversation on various topics for fun, learning, or personal use.</p>&#13;
<h3 class="h3" id="lev158"><strong>Making Your Bot Find Answers to Questions from Wikipedia</strong></h3>&#13;
<p class="noindent">Let’s start with a discussion of techniques that you can implement in your bot to make it interpret a wide range of text messages. Previous chapters talked about how bots used for business purposes typically ask for certain <span epub:type="pagebreak" id="page_171"/>information from the user and then use the answer to fill an order or booking request. In contrast, a bot designed to hold informal conversations should be able to answer a diverse range of user questions.</p>&#13;
<p class="indent">One way to help a chatbot answer user questions is to choose a keyword or keyphrase in the question that provides a clue as to what information should be included in the answer. Once you have this keyword or keyphrase, you can use it to search for the answer using tools like the Wikipedia API for Python. Wikipedia’s API lets you access and parse Wikipedia content programmatically, performing a search for a keyword to retrieve content from the most relevant Wikipedia article. The following sections describe how to do this.</p>&#13;
<p class="indent">But before proceeding to the examples, make sure you’re using one of the most recent spaCy models, because the accuracy of the dependency parsing is higher in newer versions. You can check the version of your current model using the following command:</p>&#13;
<pre>nlp.meta['version']</pre>&#13;
<p class="indent">Then visit the <em><a href="https://explosion.ai/demos/displacy/">https://explosion.ai/demos/displacy/</a></em> demo page (discussed in <a href="../Text/ch07.xhtml#ch07">Chapter 7</a>) to see the latest stable versions of spaCy models available. Alternatively, you can visit spaCy’s documentation at <em><a href="https://spacy.io/usage/">https://spacy.io/usage/</a></em> to check for the newest version of spaCy. Both spaCy and its models follow the same versioning scheme. Based on that information, you might want to update the model you currently use. Refer to <a href="../Text/ch02.xhtml#ch02">Chapter 2</a> for details on how to download and install a spaCy model.</p>&#13;
<h4 class="h4" id="lev159"><strong><em>Determining What the Question Is About</em></strong></h4>&#13;
<p class="noindent">Some words in a question are more important than others when you’re trying to determine what the speaker is asking about. Sometimes it’s enough to look at a single word in the question, such as the noun that follows a preposition. For example, a user might use any of the following questions to ask the bot to find some information about rhinos:</p>&#13;
<pre>Have you heard of rhinos? Are you familiar with rhinos? What could you tell me about rhinos?</pre>&#13;
<p class="indent">Let’s look at what the dependency parsing of such sentences might look like. <a href="../Text/ch12.xhtml#ch12fig02">Figure 12-2</a> shows a graphical representation of the parsing of the first sentence.</p>&#13;
<div class="image"><a id="ch12fig02"/><img src="../Images/fig12-2.jpg" alt="image" width="371" height="166"/></div>&#13;
<p class="figcap"><em>Figure 12-2: The dependency parsing of a sentence containing an object of a preposition</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_172"/>The parsing illustrates that in this kind of question you can get the word “rhinos” by extracting the object of the preposition. “Rhinos” would be the most helpful word in the question for finding an answer. The following code fragment shows how you might extract the first occurrence of an object of the preposition in the question:</p>&#13;
<pre>doc = nlp(u"Have you heard of rhinos?")<br/>&#13;
for t in doc:<br/>&#13;
  if t.dep_ == 'pobj' and (t.pos_ == 'NOUN' or t.pos_ == 'PROPN'):<br/>&#13;
    phrase = (' '.join([child.text for child in t.lefts]) + ' ' + t.text).lstrip()<br/>&#13;
    break</pre>&#13;
<p class="indent">In the code, we also pick up the left children of the object of the preposition, because the object might have important modifiers, as in the following example: “What can you say about wild mountain goats?” When given this question, the code should assign “wild mountain goats” to the <code>phrase</code> variable.</p>&#13;
<p class="indent">Notice the use of the <code>break</code> statement at the end, which guarantees that only the first object of a preposition in a sentence will be picked up. For example, in the sentence, “Tell me about the United States of America,” the phrase “the United States” would be picked up, but not “America.”</p>&#13;
<p class="indent">But this is not always desirable behavior. What if a user asked, “Tell me about the color of the sky.”? This is where we need to apply more complicated logic. In particular, we might want to to pick up any prepositional object that follows the first prepositional object, provided the latter is dependent on the former.</p>&#13;
<p class="indent">Here is how you might implement this logic:</p>&#13;
<pre>doc = nlp(u"Tell me about the color of the sky.")<br/>&#13;
for t in doc:<br/>&#13;
  if t.dep_ == 'pobj' and (t.pos_ == 'NOUN' or t.pos_ == 'PROPN'):<br/>&#13;
    phrase = (' '.join([child.text for child in t.lefts]) + ' ' + t.text).lstrip()<br/>&#13;
    if bool([prep for prep in t.rights if prep.dep_ == 'prep']): <br/>&#13;
      prep = list(t.rights)[0]<br/>&#13;
      pobj = list(prep.children)[0] <br/>&#13;
      phrase = phrase + ' ' + prep.text + ' ' + pobj.text<br/>&#13;
    break</pre>&#13;
<p class="indent">Note that this code will process a prepositional object that is a dependent of the first prepositional object only if the former exists in the sentence. Otherwise, this code will work the same as the code shown previously.</p>&#13;
<p class="indent">Now let’s look at another type of question in the following examples where two words, a verb and its subject, provide the best information about what a user wants in response to the questions:</p>&#13;
<pre>Do you know what an elephant eats? Tell me how dolphins sleep. What is an API?</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_173"/><a href="../Text/ch12.xhtml#ch12fig03">Figure 12-3</a> shows what a dependency parsing for one of these sentences might look like.</p>&#13;
<div class="image"><a id="ch12fig03"/><img src="../Images/fig12-3.jpg" alt="image" width="380" height="219"/></div>&#13;
<p class="figcap"><em>Figure 12-3: The dependency parsing of a sentence in which a subject/verb pair is the most informative element for discovering what the speaker wants to know</em></p>&#13;
<p class="indent">Looking through the parsing shown in the figure, notice that the subject/verb pair that occurs at the end of the sentence is the most informative when trying to determine what the speaker asks about. Programmatically, you can extract the subject and verb pair from a sentence using the following code:</p>&#13;
<pre>doc = nlp(u"Do you know what an elephant eats?")<br/>&#13;
for t in reversed(doc):<br/>&#13;
  if t.dep_ == 'nsubj' and (t.pos_ == 'NOUN' or t.pos_ == 'PROPN'):<br/>&#13;
    phrase = t.text + ' ' + t.head.text<br/>&#13;
    break<br/>&#13;
</pre>&#13;
<p class="indent">While examining this code, notice that we loop backward from the end of the sentence using Python’s <code>reversed()</code> function. The reason is that we need to pick up the last subject/verb pair in the sentence, as in this example: “Do you know what an elephant eats?” In this sentence, we’re interested in the phrase “elephant eats” rather than “you know,” which is also a subject/verb pair.</p>&#13;
<p class="indent">Additionally, in some questions, the last noun in the sentence is the direct object of a verb that matters to determine what the question is about, as in the following example:</p>&#13;
<pre>How to feed a cat?</pre>&#13;
<p class="indent">In this sentence, extracting the direct object “cat” wouldn’t be sufficient, because we also need the word “feed” to understand the question. Ideally, we’d generate the keyphrase “feeding a cat.” That is, we’d replace the infinitive “to” form of the verb with a gerund by adding “-ing,” optimizing the keyphrase for an internet search. <a href="../Text/ch12.xhtml#ch12fig04">Figure 12-4</a> shows the dependency parsing for this sentence.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_174"/><a id="ch12fig04"/><img src="../Images/fig12-4.jpg" alt="image" width="345" height="145"/></div>&#13;
<p class="figcap"><em>Figure 12-4: Dependency parsing of a sentence with a verb/direct object pair as the most informative phrase</em></p>&#13;
<p class="indent">This syntactic parsing shows that extracting the required phrase is easy, because the direct object and its transitive verb are connected with a direct link.</p>&#13;
<p class="indent">The code implementation for the extraction discussed here might look like this:</p>&#13;
<pre>doc = nlp(u"How to feed a cat?")<br/>&#13;
for t in reversed(doc):<br/>&#13;
  if t.dep_ == 'dobj' and (t.pos_ == 'NOUN' or t.pos_ == 'PROPN'):<br/>&#13;
    phrase = t.head.lemma_ + 'ing' + ' ' + t.text<br/>&#13;
    break<br/>&#13;
</pre>&#13;
<p class="indent">In this case, we once again loop backward from the end of the sentence. To understand why, consider the following sentence: “Tell me something about how to feed a cat.” It contains two verb/direct object pairs, but we’re interested only in the one that occurs at the end of the sentence.</p>&#13;
<h4 class="h4" id="lev160"><strong><em>Try This</em></strong></h4>&#13;
<p class="noindent">Modify the code in the previous section that extracts the phrase “elephant eats” so the keyphrase being extracted from the sentence includes possible modifiers of the subject, excluding a possible determiner. For example, in the sentence, “Tell me how a female cheetah hunts,” your script should return “female cheetah hunts” and remove the “a” determiner from the noun chunk. As an example of how you might implement this, look at the code that follows <a href="../Text/ch12.xhtml#ch12fig02">Figure 12-2</a>. In that code, you picked up modifiers for the object of the preposition being extracted.</p>&#13;
<p class="indent">Also, add a check to see whether the verb included in the phrase being extracted has a direct object, and if so, append the direct object to the keyphrase. For example, the question “Do you know how many eggs a sea turtle lays?” should give you the following keyphrase: “sea turtle lays eggs.”</p>&#13;
<h4 class="h4" id="lev161"><strong><em>Using Wikipedia to Answer User Questions</em></strong></h4>&#13;
<p class="noindent">Now that you have a keyphrase that can help you find the information needed to generate a relevant response to the user’s question, you need to retrieve the information. A bot can get answers to user questions from several places, and the proper source to use depends on the application, but <span epub:type="pagebreak" id="page_175"/>Wikipedia is a good place to start. The <code>wikipedia</code> Python library (<em><a href="https://pypi.org/project/wikipedia/">https://pypi.org/project/wikipedia/</a></em>) allows you to access Wikipedia articles from within your Python code.</p>&#13;
<p class="indent">You can install the library via <code>pip</code> as follows:</p>&#13;
<pre>pip install wikipedia</pre>&#13;
<p class="indent">To test the newly installed library, use the following script, which relies on a code fragment from the previous section to extract a keyword from a submitted sentence. Then it uses that keyword as a Wikipedia search term.</p>&#13;
<pre>   import spacy<br/>&#13;
   import wikipedia<br/>&#13;
   nlp = spacy.load('en')<br/>&#13;
   doc = nlp(u"What do you know about rhinos?")<br/>&#13;
   for t in doc:<br/>&#13;
     if t.dep_ == 'pobj' and (t.pos_ == 'NOUN' or t.pos_ == 'PROPN'):<br/>&#13;
 <span class="ent">➊</span> phrase = (' '.join([child.text for child in t.lefts]) + ' ' + t.text).<br/>&#13;
       lstrip()<br/>&#13;
       break<br/>&#13;
<span class="ent">➋</span> wiki_resp = wikipedia.page(phrase)<br/>&#13;
   print("Article title: ", wiki_resp.title)<br/>&#13;
   print("Article url: ", wiki_resp.url)<br/>&#13;
   print("Article summary: ", wikipedia.summary(phrase, sentences=1))</pre>&#13;
<p class="indent">In this script, we extract a keyword or keyphrase from the submitted sentence <span class="ent">➊</span> and send it to the <code>wikipedia.page()</code> function, which returns the most relevant article for the given keyword <span class="ent">➋</span>. Then we simply print out the article’s title, URL, and first sentence.</p>&#13;
<p class="indent">The output this script generates should look like this:</p>&#13;
<pre>Article title:  Rhinoceros<br/>&#13;
Article url:  https://en.wikipedia.org/wiki/Rhinoceros<br/>&#13;
Article summary:  A rhinoceros (, from Greek  rhinokero–s, meaning 'nose-horned', from  rhis,<br/>&#13;
meaning 'nose', and  keras, meaning 'horn'), commonly abbreviated to rhino, is one of ...</pre>&#13;
<h4 class="h4" id="lev162"><strong><em>Try This</em></strong></h4>&#13;
<p class="noindent">Enhance the script in the previous section so it can “see” the children of the first prepositional object and the dependent prepositional objects. For example, in the question, “Have you heard of fried eggs with yellow tomatoes?” it should extract the keyphrase “fried eggs with yellow tomatoes.”</p>&#13;
<h3 class="h3" id="lev163"><strong>Reacting to Images Sent in a Chat</strong></h3>&#13;
<p class="noindent">In addition to text messages, users of messenger apps often post images. Other people usually respond to these with comments about what is shown in the picture. For example, a user posts a photo of grapes, to which another user leaves the following comment: “I love fruit. It contains lots of fiber and <span epub:type="pagebreak" id="page_176"/>vitamins.” How can you teach a bot to do the same? One way is to generate descriptive tags for an image that the bot can use in processing. This is where you need an image recognition tool, like Clarifai, which provides built-in models trained with photos from different domains, such as apparel, travel, or celebrities.</p>&#13;
<p class="indent">Clarifai allows a bot to obtain a set of categories for a submitted photo, making it possible for the bot to guess what is depicted in the image. You can get useful categories for a photo in two steps. First, you use Clarifai’s general image recognition model to obtain descriptive tags (objects with probabilities) that can give you a general idea of what is shown in the photo. For example, the presence of the “no person” tag indicates that no people are in the photo.</p>&#13;
<p class="indent">Second, after examining the tags, you can apply more specific models to the same photo, such as Clarifai’s Food or Apparel models. Both are trained to recognize food and fashion-related items, respectively. This time, you’ll obtain another, more granular set of tags to give you a better idea of the contents of the photo. For the entire list of Clarifai’s image recognition models, visit its Models page at <em><a href="https://www.clarifai.com/models/">https://www.clarifai.com/models/</a></em>.</p>&#13;
<h4 class="h4" id="lev164"><strong><em>Generating Descriptive Tags for Images Using Clarifai</em></strong></h4>&#13;
<p class="noindent">Clarifai offers a Python client to interact with its recognition API. You can install the latest stable package using <code>pip</code>:</p>&#13;
<pre>pip install clarifai --upgrade</pre>&#13;
<p class="indent">Before you can start using the Clarifai library, you must obtain an API key by creating an account and then clicking the <strong>GET API KEY</strong> button at <em><a href="https://www.clarifai.com/">https://www.clarifai.com/</a></em>.</p>&#13;
<p class="indent">Once you have the key, you can test the Clarifai library. The following simple script passes an image to a Clarifai model and prints a list of tags expressing possible categories for the image:</p>&#13;
<pre>   from clarifai.rest import ClarifaiApp, client, Image<br/>&#13;
   app = ClarifaiApp(api_key='YOUR_API_KEY')<br/>&#13;
<span class="ent">➊</span> model = app.public_models.general_model<br/>&#13;
   filename = '/your_path/grape.jpg'<br/>&#13;
<span class="ent">➋</span> image = Image(file_obj=open(filename, 'rb'))<br/>&#13;
   response = model.predict([image])<br/>&#13;
<span class="ent">➌</span> concepts = response['outputs'][0]['data']['concepts']<br/>&#13;
   for concept in concepts:<br/>&#13;
     print(concept['name'], concept['value'])</pre>&#13;
<p class="indent">In this example, we call Clarifai’s Predict API with the general model <span class="ent">➊</span>. Clarifai takes only the pixels as input, so make sure you’re opening an image file in <code>'rb'</code> mode <span class="ent">➋</span>, which opens the file in binary format for reading. The <span epub:type="pagebreak" id="page_177"/>Predict API generates a list of descriptive tags, such as fruit, grape, health, and so on <span class="ent">➌</span>, for the submitted photo, allowing the code to “understand” what it shows.</p>&#13;
<p class="indent">The <em>grape.jpg</em> file used in this example contains the photo shown in <a href="../Text/ch12.xhtml#ch12fig05">Figure 12-5</a>.</p>&#13;
<div class="image"><a id="ch12fig05"/><img src="../Images/fig12-5.jpg" alt="image" width="694" height="520"/></div>&#13;
<p class="figcap"><em>Figure 12-5: The photo submitted to Clarifai in the preceding script</em></p>&#13;
<p class="indent">The list of concepts that the script generates for the photo should look as follows:</p>&#13;
<pre>no person 0.9968359470367432<br/>&#13;
wine 0.9812138080596924<br/>&#13;
fruit 0.9805494546890259<br/>&#13;
juicy 0.9788177013397217<br/>&#13;
health 0.9755384922027588<br/>&#13;
grow 0.9669009447097778<br/>&#13;
grape 0.9660607576370239<br/>&#13;
...</pre>&#13;
<p class="indent">Each entry represents a category and the probability that the image fits within the category. Thus, the first tag in the list tells us that the submitted photo contains no person with a probability of 0.99. Note that not all the tags will provide a direct description of the depicted content. For example, <span epub:type="pagebreak" id="page_178"/>the tag “wine” is included here, perhaps because wine is made from grapes. The presence of indirect tags in the list gives your bot more options to interpret the image.</p>&#13;
<h4 class="h4" id="lev165"><strong><em>Using Tags to Generate Text Responses to Images</em></strong></h4>&#13;
<p class="noindent">Now that you know how to obtain descriptive tags for an image, how can you use these tags to respond to the image? Or how can you choose the most important tags from the generated list? Think about the following general considerations:</p>&#13;
<ul>&#13;
<li class="noindent">You might want to take into account only the tags with high likelihoods. For that, you can choose a threshold of likelihood for the tags. For example, consider only the top five or 10 tags.</li>&#13;
<li class="noindent">You might choose only those tags that are in the context of the current chat. <a href="../Text/ch11.xhtml#ch11">Chapter 11</a> showed an example of how to maintain the context of the current chat in a Telegram bot using the <code>context.user_data</code> dictionary.</li>&#13;
<li class="noindent">You might iterate over the generated tags, searching for a particular tag. For example, you might search for the tag “fruit” or “health” to determine whether you should continue the conversation on this topic.</li>&#13;
</ul>&#13;
<p class="indent">The bot discussed in the next section will implement the third option.</p>&#13;
<h3 class="h3" id="lev166"><strong>Putting All the Pieces Together in a Telegram Bot</strong></h3>&#13;
<p class="noindent">In the rest of this chapter, we’ll build a Telegram chatbot that uses the Wikipedia API and the Clarifai API. This bot will respond intelligently to text and images of food. Refer back to <a href="../Text/ch11.xhtml#ch11">Chapter 11</a> for details on how to create a new bot in Telegram.</p>&#13;
<h4 class="h4" id="lev167"><strong><em>Importing the Libraries</em></strong></h4>&#13;
<p class="noindent">The import section of the code must include all the libraries that we’ll use in the bot’s code. In this example, we include the libraries required to access the Telegram Bot API, Wikipedia API, Clarifai API, and spaCy.</p>&#13;
<pre>import spacy<br/>&#13;
import wikipedia<br/>&#13;
from telegram.ext import Updater, CommandHandler, MessageHandler, Filters<br/>&#13;
from clarifai.rest import ClarifaiApp, Image</pre>&#13;
<p class="indent">If you’ve followed the instructions provided in this chapter and <a href="../Text/ch11.xhtml#ch11">Chapter 11</a>, all of these libraries should be available on your system.</p>&#13;
<h4 class="h4" id="lev168"><strong><em>Writing the Helper Functions</em></strong></h4>&#13;
<p class="noindent">Next, we need to implement the helper functions that will be invoked from within the bot’s callback functions. The <code>keyphrase()</code> function takes a <span epub:type="pagebreak" id="page_179"/>sentence as a Doc object and tries to extract the most informative word or a phrase from it, as discussed earlier in “<a href="../Text/ch12.xhtml#lev159">Determining What the Question Is About</a>” on <a href="../Text/ch12.xhtml#page_171">page 171</a>. The following implementation uses the code fragments you saw in that section, adjusting them so we can use them within a single function:</p>&#13;
<pre>def keyphrase(doc): <br/>&#13;
  for t in doc:<br/>&#13;
    if t.dep_ == 'pobj' and (t.pos_ == 'NOUN' or t.pos_ == 'PROPN'):<br/>&#13;
      return (' '.join([child.text for child in t.lefts]) + ' ' + t.text).<br/>&#13;
      lstrip()<br/>&#13;
  for t in reversed(doc):<br/>&#13;
    if t.dep_ == 'nsubj' and (t.pos_ == 'NOUN' or t.pos_ == 'PROPN'):<br/>&#13;
      return t.text + ' ' + t.head.text<br/>&#13;
  for t in reversed(doc):<br/>&#13;
    if t.dep_ == 'dobj' and (t.pos_ == 'NOUN' or t.pos_ == 'PROPN'):<br/>&#13;
      return t.head.text + 'ing' + ' ' + t.text <br/>&#13;
  return False</pre>&#13;
<p class="indent">Note that the conditions are arranged in order of priority in this code. Thus, if the object of the preposition is found, we extract it and quit without checking for the other conditions. Of course, some complicated questions might meet multiple conditions, but checking for this would complicate the function implementation.</p>&#13;
<p class="indent">Like the <code>keyphrase()</code> function, the <code>photo_tags()</code> function is supposed to determine the most descriptive word for a user’s input. But unlike <code>keyphrase()</code>, it analyzes a photo. It performs the analysis with the help of Clarifai, which generates a set of descriptive tags for a submitted photo. This implementation uses only two Clarifai models: the general model and the food model.</p>&#13;
<pre>def photo_tags(filename):<br/>&#13;
  app = ClarifaiApp(api_key=CLARIFAI_API_KEY)<br/>&#13;
  model = app.public_models.general_model<br/>&#13;
  image = Image(file_obj=open(filename, 'rb'))<br/>&#13;
  response = model.predict([image])<br/>&#13;
  concepts = response['outputs'][0]['data']['concepts']<br/>&#13;
  for concept in concepts:<br/>&#13;
    if concept['name'] == 'food':<br/>&#13;
      food_model = app.public_models.food_model<br/>&#13;
      result = food_model.predict([image])<br/>&#13;
      first_concept = result['outputs'][0]['data']['concepts'][0]['name']<br/>&#13;
      return first_concept<br/>&#13;
  return response['outputs'][0]['data']['concepts'][1]['name']</pre>&#13;
<p class="indent">This code starts by applying the general model. If the tag <code>'food'</code> is found in the generated list, it applies the food model to obtain more descriptive tags for the food items shown in the image. This implementation will use the first tag only as the keyword for the search.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_180"/>Now that we have the keyword or keyphrase, determined either in the <code>keyphrase()</code> function or in the <code>photo_tags()</code> function, we need to obtain a piece of information that is closely related to this keyword or keyphrase. The following <code>wiki()</code> function does the trick:</p>&#13;
<pre>def wiki(concept):<br/>&#13;
  nlp = spacy.load('en')<br/>&#13;
  wiki_resp = wikipedia.page(concept)<br/>&#13;
  doc = nlp(wiki_resp.content)<br/>&#13;
  if len(concept.split()) == 1:<br/>&#13;
    for sent in doc.sents:<br/>&#13;
      for t in sent:<br/>&#13;
        if t.text == concept and t.dep_ == 'dobj':<br/>&#13;
          return sent.text<br/>&#13;
  return list(doc.sents)[0].text</pre>&#13;
<p class="indent">The algorithm we use here searches for a sentence in the retrieved content that includes the keyword as the direct object.</p>&#13;
<p class="indent">But this simple implementation can intelligently process only a single-word input. When a word is submitted, the algorithm we use here just extracts the first sentence from the Wikipedia article found with the help of this word.</p>&#13;
<h4 class="h4" id="lev169"><strong><em>Writing the Callback and main() Functions</em></strong></h4>&#13;
<p class="noindent">Next, we add the bot’s callback functions. The <code>start()</code> function simply sends a greeting to the user in response to the <code>/start</code> command.</p>&#13;
<pre>def start(update, context):<br/>&#13;
    update.message.reply_text('Hi! This is a conversational bot. Ask me something.')</pre>&#13;
<p class="indent">The <code>text_msg()</code> function is the callback for the bot’s user text messages handler.</p>&#13;
<pre>def text_msg(update, context):<br/>&#13;
  msg = update.message.text<br/>&#13;
  nlp = spacy.load('en')<br/>&#13;
  doc = nlp(msg)<br/>&#13;
  concept = keyphrase(doc)<br/>&#13;
  if concept != False:<br/>&#13;
    update.message.reply_text(wiki(concept))<br/>&#13;
  else: <br/>&#13;
    update.message.reply_text('Please rephrase your question.')</pre>&#13;
<p class="indent">First, we apply spaCy’s pipeline to the message, converting it to a Doc object. Then we send the Doc to the <code>keyphrase()</code> function discussed earlier to extract a keyword or keyphrase from the message. The returned keyword or keyphrase is then sent to the <code>wiki()</code> function to obtain a piece of relevant information, which should be a single sentence in this implementation.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_181"/>The <code>photo()</code> function shown in the following code is the callback for the bot’s handler for the photos submitted by the user:</p>&#13;
<pre>def photo(update, context):<br/>&#13;
  photo_file = update.message.photo[-1].get_file()<br/>&#13;
  filename = '{}.jpg'.format(photo_file.file_id)<br/>&#13;
  photo_file.download(filename) <br/>&#13;
  concept = photo_tags(filename)<br/>&#13;
  update.message.reply_text(wiki(concept))</pre>&#13;
<p class="indent">The function retrieves the submitted image as a file and sends it for further processing to the helper functions discussed earlier in “<a href="../Text/ch12.xhtml#lev168">Writing the Helper Functions</a>” on <a href="../Text/ch12.xhtml#page_178">page 178</a>.</p>&#13;
<p class="indent">Finally, we add the <code>main()</code> function in which we register handlers for both text messages and photos.</p>&#13;
<pre>def main():<br/>&#13;
    updater = Updater("YOUR_TOKEN", use_context=True)<br/>&#13;
    disp = updater.dispatcher<br/>&#13;
    disp.add_handler(CommandHandler("start", start))<br/>&#13;
    disp.add_handler(MessageHandler(Filters.text, text_msg))<br/>&#13;
    disp.add_handler(MessageHandler(Filters.photo, photo))<br/>&#13;
    updater.start_polling()<br/>&#13;
    updater.idle()<br/>&#13;
if __name__ == '__main__':<br/>&#13;
    main()</pre>&#13;
<p class="indent">The <code>main()</code> function for this Telegram bot is quite concise. We create the <code>Updater</code> and pass the bot’s token to it. Then we obtain the dispatcher to register handlers. In this example, we register just three handlers. The first one is the handler for the <code>/start</code> command. The second handles text messages coming from the user. The third one handles photos posted by the user. After registering handlers, we start the bot by invoking <code>updater.start_polling()</code> and then invoking <code>updater.idle()</code> to block the script to wait for a user message or an exit shortcut (<span class="smallcaps">CTRL</span>-C).</p>&#13;
<h4 class="h4" id="lev170"><strong><em>Testing the Bot</em></strong></h4>&#13;
<p class="noindent">Now that we’ve created the bot, it’s time to test it. You can test it either on a smartphone or a computer. On a smartphone, in the Telegram app search for your bot’s name followed by the @ sign, and then enter the <code>/start</code> command to start a chat. On a computer, use Telegram Web at <em><a href="https://web.telegram.org">https://web.telegram.org</a></em>.</p>&#13;
<p class="indent">After receiving a greeting from the bot, send it a simple request, such as “Tell me about fruit.” The bot should respond with a single sentence that it extracts from a relevant Wikipedia article. For simplicity, choose a sentence that uses the direct object from the sentence (“fruit” in this example) as the keyword.</p>&#13;
<p class="indent">You can also submit a photo to check which comment the bot will give in response. <a href="../Text/ch12.xhtml#ch12fig06">Figure 12-6</a> illustrates a screenshot of such a test.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_182"/><a id="ch12fig06"/><img src="../Images/fig12-6.jpg" alt="image" width="694" height="644"/></div>&#13;
<p class="figcap"><em>Figure 12-6: A screenshot of the bot we created</em></p>&#13;
<p class="indent">Remember that this implementation can properly process only photos of food.</p>&#13;
<h4 class="h4" id="lev171"><strong><em>Try This</em></strong></h4>&#13;
<p class="noindent">Note that the bot implementation provided in the preceding section can’t generate smart responses to many different types of user input. The <code>wiki()</code> function we used can properly process only those requests for which <code>keyphrase()</code> returns a single word. It also works best if that keyword is a direct object. Also, the bot can only intelligently respond to images of food.</p>&#13;
<p class="indent">Enhance the <code>wiki()</code> function so it can process phrases instead of only one word, such as “dolphins sleep.” Finding an appropriate sentence for such a phrase requires using dependency labels, because you’ll need to find a subject/verb pair. In addition, you’ll need to reduce the words to their lemmas. For example, “dolphins sleep” and “dolphin sleeps” should satisfy the search criteria.</p>&#13;
<p class="indent">You might also want to enhance the functionality of the <code>photo_tags()</code> function so it can process not only food photos, but also those that show something else—for example, apparel.</p>&#13;
<h3 class="h3" id="lev172"><span epub:type="pagebreak" id="page_183"/><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you saw examples of how to use spaCy along with other libraries in Python’s AI ecosystem to build an AI-powered application that can process data of different types. By using the Wikipedia and Clarifai Python APIs, we designed a chatbot that could react to images and pull text from Wikipedia, techniques that make the bot a smarter interlocutor.</p>&#13;
<p class="indent">After reading this book, you might want to expand and improve on what you’ve learned. The most natural way to enhance your knowledge is to continue to experiment with chatbots. Start by building a Telegram script with Python using the instructions provided in <a href="../Text/ch11.xhtml#ch11">Chapter 11</a>; next, enhance its functionality using instructions provided in this chapter. Then work on improving the algorithms you learned in this book to make them more suitable for your use cases.<span epub:type="pagebreak" id="page_184"/></p>&#13;
</div>&#13;
</body></html>