- en: Otherwise, it sets self.playing to True to indicate that the animation is now
  prefs: []
  type: TYPE_NORMAL
- en: running.
  prefs: []
  type: TYPE_NORMAL
- en: When a SimpleAnimation is created, the caller specifies the amount of time
  prefs: []
  type: TYPE_NORMAL
- en: that each image should be shown, and this is saved in self.durationPerImage.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we must keep track of time as a SimpleAnimation runs to know when
  prefs: []
  type: TYPE_NORMAL
- en: to switch to the next image. We call time.time() to get the current time (in
    mil-
  prefs: []
  type: TYPE_NORMAL
- en: liseconds) and save that in an instance variable. Making the class time based
  prefs: []
  type: TYPE_NORMAL
- en: means that any SimpleAnimation object built from this class will work correctly,
  prefs: []
  type: TYPE_NORMAL
- en: independent of the frame rate used for the main loop. Finally, we set the vari-
  prefs: []
  type: TYPE_NORMAL
- en: able self.index to 0 to indicate that we should be showing the first image.
  prefs: []
  type: TYPE_NORMAL
- en: The update() method 4 needs to be called in every frame of the
  prefs: []
  type: TYPE_NORMAL
- en: main loop. If the animation is not playing, update() does nothing and just
  prefs: []
  type: TYPE_NORMAL
- en: returns. Otherwise, update() calculates how much time has elapsed since
  prefs: []
  type: TYPE_NORMAL
- en: the current image started showing by getting the current time using the
  prefs: []
  type: TYPE_NORMAL
- en: system time.time() function and subtracting that from the time at which
  prefs: []
  type: TYPE_NORMAL
- en: the current image started showing.
  prefs: []
  type: TYPE_NORMAL
- en: If the elapsed time is greater than the amount of time that each image
  prefs: []
  type: TYPE_NORMAL
- en: should be showing, it’s time move to the next image. In this case, we incre-
  prefs: []
  type: TYPE_NORMAL
- en: ment self.index so that the upcoming call to the draw() method will draw
  prefs: []
  type: TYPE_NORMAL
- en: the appropriate image. We then check whether the animation has finished.
  prefs: []
  type: TYPE_NORMAL
- en: If not, we save the start time for the new image. If the animation is done,
    we
  prefs: []
  type: TYPE_NORMAL
- en: set self.playing back to False (to indicate that we are no longer playing the
  prefs: []
  type: TYPE_NORMAL
- en: animation), and we reset self.index to 0 so that the draw() method will show
  prefs: []
  type: TYPE_NORMAL
- en: the first image again.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call draw() in every frame 5 to draw the current image of
  prefs: []
  type: TYPE_NORMAL
- en: the animation. The draw() method assumes that self.index has been set cor-
  prefs: []
  type: TYPE_NORMAL
- en: rectly by a previous method, and uses it to index into the list of images. It
  prefs: []
  type: TYPE_NORMAL
- en: then draws that image in the window at the specified location.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example Main Program**'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 14-2 shows a main program that creates and uses a SimpleAnimation
  prefs: []
  type: TYPE_NORMAL
- en: object. This will animate a dinosaur riding a bicycle.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: SimpleAnimation/Main_SimpleAnimation.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Animation example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shows example of SimpleAnimation object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 - Import library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: import pygwidgets
  prefs: []
  type: TYPE_NORMAL
- en: from SimpleAnimation import *
  prefs: []
  type: TYPE_NORMAL
- en: 2 Define constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SCREEN_WIDTH = 640
  prefs: []
  type: TYPE_NORMAL
- en: '**298** Chapter 14'
  prefs: []
  type: TYPE_NORMAL
- en: SCREEN_HEIGHT = 480
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  prefs: []
  type: TYPE_NORMAL
- en: BGCOLOR = (0, 128, 128)
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode([SCREEN_WIDTH, SCREEN_HEIGHT])
  prefs: []
  type: TYPE_NORMAL
- en: clock = pygame.time.Clock()
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: images(s), sound(s), etc.'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 dinosaurAnimTuple = ('images/Dinobike/f1.gif',
  prefs: []
  type: TYPE_NORMAL
- en: '''images/Dinobike/f2.gif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''images/Dinobike/f3.gif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''images/Dinobike/f4.gif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''images/Dinobike/f5.gif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''images/Dinobike/f6.gif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''images/Dinobike/f7.gif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''images/Dinobike/f8.gif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''images/Dinobike/f9.gif'','
  prefs: []
  type: TYPE_NORMAL
- en: '''images/Dinobike/f10.gif'')'
  prefs: []
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oDinosaurAnimation = SimpleAnimation(window, (22, 140),
  prefs: []
  type: TYPE_NORMAL
- en: dinosaurAnimTuple, .1)
  prefs: []
  type: TYPE_NORMAL
- en: oPlayButton = pygwidgets.TextButton(window, (20, 240), "Play")
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == QUIT:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: '2 if oPlayButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: oDinosaurAnimation.play()
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 oDinosaurAnimation.update()
  prefs: []
  type: TYPE_NORMAL
- en: 9 - Clear the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(BGCOLOR)
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw all window elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4 oDinosaurAnimation.draw()
  prefs: []
  type: TYPE_NORMAL
- en: oPlayButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-2: The main program that instantiates and plays a SimpleAnimation*'
  prefs: []
  type: TYPE_NORMAL
- en: Animation **299**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 38](index-329_1.png)'
  prefs: []
  type: TYPE_IMG
- en: All the images for the animated dinosaur are in the folder *images/*
  prefs: []
  type: TYPE_NORMAL
- en: '*DinoBike/*. We first build a tuple of the images 1\. Then, using that tuple,'
  prefs: []
  type: TYPE_NORMAL
- en: we create a SimpleAnimation object and specify that each image should be
  prefs: []
  type: TYPE_NORMAL
- en: shown for a tenth of a second. We also instantiate a Play button.
  prefs: []
  type: TYPE_NORMAL
- en: In the main loop, we call the update() and draw() methods of the
  prefs: []
  type: TYPE_NORMAL
- en: oDinosaurAnimation object. The program loops while continuously drawing
  prefs: []
  type: TYPE_NORMAL
- en: the current image of the animation and the Play button. When the anima-
  prefs: []
  type: TYPE_NORMAL
- en: tion is not running, the user just sees the first image.
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks the Play button 2, the program calls the play()
  prefs: []
  type: TYPE_NORMAL
- en: method of oDinosaurAnimation to start the animation running.
  prefs: []
  type: TYPE_NORMAL
- en: In the main loop, we call the update() method of oDinosaur Animation 3,
  prefs: []
  type: TYPE_NORMAL
- en: which determines whether enough time has elapsed for the animation to
  prefs: []
  type: TYPE_NORMAL
- en: move on to the next image.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call draw() 4, and the object draws the appropriate image.
  prefs: []
  type: TYPE_NORMAL
- en: '***SimpleSpriteSheetAnimation Class***'
  prefs: []
  type: TYPE_NORMAL
- en: The second type of animation is implemented in the SimpleSpriteSheetAnimation
  prefs: []
  type: TYPE_NORMAL
- en: class. A *sprite sheet* is a single image made up of a number of equally sized
    smaller images, intended to appear in order to create an animation. From a
  prefs: []
  type: TYPE_NORMAL
- en: developer’s point of view, there are three advantages to a sprite sheet. First,
  prefs: []
  type: TYPE_NORMAL
- en: all the images are in a single file, so there is no need to worry about building
  prefs: []
  type: TYPE_NORMAL
- en: a name for each separate file. Second, it’s possible to see the progression
    of
  prefs: []
  type: TYPE_NORMAL
- en: an animation in a single file, rather than having to flip through a sequence
  prefs: []
  type: TYPE_NORMAL
- en: of images. Finally, loading a single file is faster than loading a list of files
    that make up an animation.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14-1 shows an example of a sprite sheet.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14-1: A sprite sheet image made up of*'
  prefs: []
  type: TYPE_NORMAL
- en: '*18 smal er images*'
  prefs: []
  type: TYPE_NORMAL
- en: This example is designed to show the numbers from 0 to 17\. The origi-
  prefs: []
  type: TYPE_NORMAL
- en: nal file contains an image that is 384×192 pixels. A quick division shows that
  prefs: []
  type: TYPE_NORMAL
- en: each individual number image is 64×64 pixels. The key idea here is that we
  prefs: []
  type: TYPE_NORMAL
- en: use pygame to create *subimages* of a larger image to give us a set of 18 new
    64×64 pixel images. The smaller images can then be displayed using the
  prefs: []
  type: TYPE_NORMAL
- en: same technique as we used in the SimpleAnimation class.
  prefs: []
  type: TYPE_NORMAL
- en: '**300** Chapter 14'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating the Class**'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 14-3 contains the SimpleSpriteSheetAnimation class to handle sprite
  prefs: []
  type: TYPE_NORMAL
- en: sheet–based animations. During initialization, the contents of the single
  prefs: []
  type: TYPE_NORMAL
- en: sprite sheet image are split up into a list of smaller images, which are then
  prefs: []
  type: TYPE_NORMAL
- en: displayed by the other methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: SimpleSpriteSheetAnimation/SimpleSpriteSheetAnimation.py**'
  prefs: []
  type: TYPE_NORMAL
- en: SimpleSpriteSheetAnimation class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: import time
  prefs: []
  type: TYPE_NORMAL
- en: 'class SimpleSpriteSheetAnimation():'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window, loc, imagePath, nImages, width, height, durationPerImage):
    1'
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  prefs: []
  type: TYPE_NORMAL
- en: self.loc = loc
  prefs: []
  type: TYPE_NORMAL
- en: self.nImages = nImages
  prefs: []
  type: TYPE_NORMAL
- en: self.imagesList = []
  prefs: []
  type: TYPE_NORMAL
- en: Load the sprite sheet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: spriteSheetImage = pygame.image.load(imagePath)
  prefs: []
  type: TYPE_NORMAL
- en: Optimize blitting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: spriteSheetImage = pygame.Surface.convert_alpha(spriteSheetImage)
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the number of columns in the starting image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: nCols = spriteSheetImage.get_width() // width
  prefs: []
  type: TYPE_NORMAL
- en: Break up the starting image into subimages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: row = 0
  prefs: []
  type: TYPE_NORMAL
- en: col = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'for imageNumber in range(nImages):'
  prefs: []
  type: TYPE_NORMAL
- en: x = col * height
  prefs: []
  type: TYPE_NORMAL
- en: y = row * width
  prefs: []
  type: TYPE_NORMAL
- en: Create a subsurface from the bigger spriteSheet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: subsurfaceRect = pygame.Rect(x, y, width, height)
  prefs: []
  type: TYPE_NORMAL
- en: image = spriteSheetImage.subsurface(subsurfaceRect)
  prefs: []
  type: TYPE_NORMAL
- en: self.imagesList.append(image)
  prefs: []
  type: TYPE_NORMAL
- en: col = col + 1
  prefs: []
  type: TYPE_NORMAL
- en: 'if col == nCols:'
  prefs: []
  type: TYPE_NORMAL
- en: col = 0
  prefs: []
  type: TYPE_NORMAL
- en: row = row + 1
  prefs: []
  type: TYPE_NORMAL
- en: self.durationPerImage = durationPerImage
  prefs: []
  type: TYPE_NORMAL
- en: self.playing = False
  prefs: []
  type: TYPE_NORMAL
- en: self.index = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'def play(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.playing:'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: self.playing = True
  prefs: []
  type: TYPE_NORMAL
- en: Animation **301**
  prefs: []
  type: TYPE_NORMAL
- en: self.imageStartTime = time.time()
  prefs: []
  type: TYPE_NORMAL
- en: self.index = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'def update(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if not self.playing:'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: How much time has elapsed since we started showing this image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.elapsed = time.time() - self.imageStartTime
  prefs: []
  type: TYPE_NORMAL
- en: If enough time has elapsed, move on to the next image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if self.elapsed > self.durationPerImage:'
  prefs: []
  type: TYPE_NORMAL
- en: self.index = self.index + 1
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.index < self.nImages: # move on to next image'
  prefs: []
  type: TYPE_NORMAL
- en: self.imageStartTime = time.time()
  prefs: []
  type: TYPE_NORMAL
- en: 'else: # animation is finished'
  prefs: []
  type: TYPE_NORMAL
- en: self.playing = False
  prefs: []
  type: TYPE_NORMAL
- en: 'self.index = 0 # reset to the beginning'
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw(self):'
  prefs: []
  type: TYPE_NORMAL
- en: Assumes that self.index has been set earlier - in the update() method.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is used as the index into the imagesList to find the current image.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'theImage = self.imagesList[self.index] # choose the image to show'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.window.blit(theImage, self.loc) # show it'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-3: The SimpleSpriteSheetAnimation class*'
  prefs: []
  type: TYPE_NORMAL
- en: This class is very similar to SimpleAnimation, but because this animation
  prefs: []
  type: TYPE_NORMAL
- en: is based on a sprite sheet, the __init__() method must be passed different
  prefs: []
  type: TYPE_NORMAL
- en: information 1\. The method requires the standard window and loc param-
  prefs: []
  type: TYPE_NORMAL
- en: 'eters, as well as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**imagePath** A path to a sprite sheet image (single file)'
  prefs: []
  type: TYPE_NORMAL
- en: '**nImages** The number of images in the sprite sheet'
  prefs: []
  type: TYPE_NORMAL
- en: '**width** The width of each subimage'
  prefs: []
  type: TYPE_NORMAL
- en: '**height** The height of each subimage'
  prefs: []
  type: TYPE_NORMAL
- en: '**durationPerImage** How long (in seconds) to show each image'
  prefs: []
  type: TYPE_NORMAL
- en: Given these values, the __init__() method loads the sprite sheet file, and
  prefs: []
  type: TYPE_NORMAL
- en: it uses a loop to split up the larger image into a list of smaller subimages
  prefs: []
  type: TYPE_NORMAL
- en: through a call to the pygame subsurface() method. The smaller images are
  prefs: []
  type: TYPE_NORMAL
- en: then appended into the self.imagesList list for use by the other methods.
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() method uses a counter to count the number of subimages,
  prefs: []
  type: TYPE_NORMAL
- en: up to the number specified by the caller; therefore, the last row of images
  prefs: []
  type: TYPE_NORMAL
- en: does not need to be a full row. For example, we could have used a sprite
  prefs: []
  type: TYPE_NORMAL
- en: sheet image that only had the numbers 0 through 14, rather than needing
  prefs: []
  type: TYPE_NORMAL
- en: to fill the row to 17\. The nImages parameter is the key to making this work.
  prefs: []
  type: TYPE_NORMAL
- en: This rest of this class has the exact same methods as the previous
  prefs: []
  type: TYPE_NORMAL
- en: 'SimpleAnimation class: play(), update(), and draw().'
  prefs: []
  type: TYPE_NORMAL
- en: '**302** Chapter 14'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example Main Program**'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 14-4 provides a sample main program that creates and shows
  prefs: []
  type: TYPE_NORMAL
- en: a SimpleSpriteSheetAnimation object that shows an animated drop of
  prefs: []
  type: TYPE_NORMAL
- en: water landing and spreading out. If you download everything in the
  prefs: []
  type: TYPE_NORMAL
- en: '*SpriteSheetAnimation* folder of this book’s resources, you will get the'
  prefs: []
  type: TYPE_NORMAL
- en: code and the appropriate artwork.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: SimpleSpriteSheetAnimation/Main_SimpleSpriteSheetAnimation.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Shows example of SimpleSpriteSheetAnimation object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 - Import library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: import pygwidgets
  prefs: []
  type: TYPE_NORMAL
- en: from SimpleSpriteSheetAnimation import *
  prefs: []
  type: TYPE_NORMAL
- en: 2 Define constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SCREEN_WIDTH = 640
  prefs: []
  type: TYPE_NORMAL
- en: SCREEN_HEIGHT = 480
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  prefs: []
  type: TYPE_NORMAL
- en: BGCOLOR = (0, 128, 128)
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode([SCREEN_WIDTH, SCREEN_HEIGHT])
  prefs: []
  type: TYPE_NORMAL
- en: clock = pygame.time.Clock()
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: images(s), sound(s), etc.'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 oWaterAnimation = SimpleSpriteSheetAnimation(window, (22, 140),
  prefs: []
  type: TYPE_NORMAL
- en: '''images/water_003.png'','
  prefs: []
  type: TYPE_NORMAL
- en: 5, 50, 192, 192, .05)
  prefs: []
  type: TYPE_NORMAL
- en: oPlayButton = pygwidgets.TextButton(window, (60, 320), "Play")
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == QUIT:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: 'if oPlayButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: oWaterAnimation.play()
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oWaterAnimation.update()
  prefs: []
  type: TYPE_NORMAL
- en: Animation **303**
  prefs: []
  type: TYPE_NORMAL
- en: 9 - Clear the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(BGCOLOR)
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw all window elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oWaterAnimation.draw()
  prefs: []
  type: TYPE_NORMAL
- en: oPlayButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-4: A sample main program that creates and uses a SimpleSpriteSheetAnimation*
    *object*'
  prefs: []
  type: TYPE_NORMAL
- en: The only significant difference with this example is that it instantiates a
  prefs: []
  type: TYPE_NORMAL
- en: SimpleSpriteSheetAnimation object 1 instead of a SimpleAnimation object.
  prefs: []
  type: TYPE_NORMAL
- en: '***Merging Two Classes***'
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() methods in SimpleAnimation and SimpleSpriteSheetAnimation
  prefs: []
  type: TYPE_NORMAL
- en: have different parameters, but the other three methods (start(), update(),
  prefs: []
  type: TYPE_NORMAL
- en: and draw()) are identical. Once you instantiate either of these classes, the
  prefs: []
  type: TYPE_NORMAL
- en: way that you access the resulting objects is exactly the same. The “Don’t
  prefs: []
  type: TYPE_NORMAL
- en: Repeat Yourself” (DRY) principle says that having these duplicated meth-
  prefs: []
  type: TYPE_NORMAL
- en: ods is a bad idea, because any bug fixes and/or enhancements would have
  prefs: []
  type: TYPE_NORMAL
- en: to be applied in both copies of the methods.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, this is a good opportunity to merge classes. We can create
  prefs: []
  type: TYPE_NORMAL
- en: a common abstract base class for these classes to inherit from. The base
  prefs: []
  type: TYPE_NORMAL
- en: class will have its own __init__() method that includes any common code
  prefs: []
  type: TYPE_NORMAL
- en: from the __init__() methods of both original classes, and it will contain the
  prefs: []
  type: TYPE_NORMAL
- en: play(), update(), and draw() methods.
  prefs: []
  type: TYPE_NORMAL
- en: Each original class will inherit from the new base class and implement
  prefs: []
  type: TYPE_NORMAL
- en: its own __init__() method using the appropriate parameters. Each will do
  prefs: []
  type: TYPE_NORMAL
- en: its own work to create self.imagesList, which is then used in the other three
  prefs: []
  type: TYPE_NORMAL
- en: methods in the new base class.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than showing the result of merging these two “simple” classes,
  prefs: []
  type: TYPE_NORMAL
- en: I’ll show the result of this merge in the “professional strength” Animation
    and
  prefs: []
  type: TYPE_NORMAL
- en: SpriteSheetAnimation classes that are part of the pygwidgets package.
  prefs: []
  type: TYPE_NORMAL
- en: '**Animation Classes in pygwidgets**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The pygwidgets module contains the following three animation classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PygAnimation** An abstract base class for the Animation and'
  prefs: []
  type: TYPE_NORMAL
- en: SpriteSheetAnimation classes
  prefs: []
  type: TYPE_NORMAL
- en: '**Animation** A class for image-based animations (separate image files)'
  prefs: []
  type: TYPE_NORMAL
- en: '**SpriteSheetAnimation** A class for sprite sheet–based animations (a'
  prefs: []
  type: TYPE_NORMAL
- en: single large image)
  prefs: []
  type: TYPE_NORMAL
- en: '**304** Chapter 14'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at each class in turn. The Animation and SpriteSheetAnimation classes
    use the same basic concepts discussed, but also have more options
  prefs: []
  type: TYPE_NORMAL
- en: available via initialization parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '***Animation Class***'
  prefs: []
  type: TYPE_NORMAL
- en: You use pygwidget’s Animation class to create an animation from many differ-
  prefs: []
  type: TYPE_NORMAL
- en: 'ent image files. Here is the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Animation(window, loc, animTuplesList, autoStart=False,
  prefs: []
  type: TYPE_NORMAL
- en: 'loop=False, nickname=None, callBack=None, nIterations=1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'The required parameters are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**window**'
  prefs: []
  type: TYPE_NORMAL
- en: The window to draw in.
  prefs: []
  type: TYPE_NORMAL
- en: '**loc**'
  prefs: []
  type: TYPE_NORMAL
- en: The upper-left corner where images should be drawn.
  prefs: []
  type: TYPE_NORMAL
- en: '**animTuplesList**'
  prefs: []
  type: TYPE_NORMAL
- en: A list (or tuple) of tuples describing the sequence of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each inner tuple contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '**pathToImage** The relative path to an image file.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Duration** The duration this image should be shown (in seconds, float-'
  prefs: []
  type: TYPE_NORMAL
- en: ing point).
  prefs: []
  type: TYPE_NORMAL
- en: '**offset (optional)** If present, an (x, y) tuple used as an offset from the'
  prefs: []
  type: TYPE_NORMAL
- en: main loc to show this image.
  prefs: []
  type: TYPE_NORMAL
- en: 'These parameters are all optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '**autoStart**'
  prefs: []
  type: TYPE_NORMAL
- en: True if you want the animation to start right away; defaults to False.
  prefs: []
  type: TYPE_NORMAL
- en: '**loop**'
  prefs: []
  type: TYPE_NORMAL
- en: True if you want the animation to loop continuously; defaults to False.
  prefs: []
  type: TYPE_NORMAL
- en: '**showFirstImageAtEnd**'
  prefs: []
  type: TYPE_NORMAL
- en: When an animation ends, show the first image again; defaults to True.
  prefs: []
  type: TYPE_NORMAL
- en: '**nickname**'
  prefs: []
  type: TYPE_NORMAL
- en: An internal name to assign to this animation, used as an argument
  prefs: []
  type: TYPE_NORMAL
- en: when a callBack is specified.
  prefs: []
  type: TYPE_NORMAL
- en: '**callBack**'
  prefs: []
  type: TYPE_NORMAL
- en: The function or object method to call when the animation is done.
  prefs: []
  type: TYPE_NORMAL
- en: '**nIterations**'
  prefs: []
  type: TYPE_NORMAL
- en: The number of times to loop through the animation; defaults to 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike SimpleAnimation, which uses a single duration for all images,
  prefs: []
  type: TYPE_NORMAL
- en: the Animation class lets you specify a duration for *each* image, allowing for
    Animation **305**
  prefs: []
  type: TYPE_NORMAL
- en: greater flexibility in the timing of how the images are displayed. You can also
    specify an x, y offset when drawing each image, but in general this
  prefs: []
  type: TYPE_NORMAL
- en: isn’t needed. Here is some sample code that creates an Animation object that
  prefs: []
  type: TYPE_NORMAL
- en: 'shows a running T-rex dinosaur:'
  prefs: []
  type: TYPE_NORMAL
- en: TRexAnimationList = [('images/TRex/f1.gif', .1),
  prefs: []
  type: TYPE_NORMAL
- en: ('images/TRex/f2.gif', .1),
  prefs: []
  type: TYPE_NORMAL
- en: ('images/TRex/f3.gif', .1),
  prefs: []
  type: TYPE_NORMAL
- en: ('images/TRex/f4.gif', .1),
  prefs: []
  type: TYPE_NORMAL
- en: ('images/TRex/f5.gif', .1),
  prefs: []
  type: TYPE_NORMAL
- en: ('images/TRex/f6.gif', .1),
  prefs: []
  type: TYPE_NORMAL
- en: ('images/TRex/f7.gif', .1),
  prefs: []
  type: TYPE_NORMAL
- en: ('images/TRex/f8.gif', .1),
  prefs: []
  type: TYPE_NORMAL
- en: ('images/TRex/f9.gif', .1),
  prefs: []
  type: TYPE_NORMAL
- en: ('images/TRex/f10.gif', .4)]
  prefs: []
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oDinosaurAnimation = pygwidgets.Animation(window, (22, 145),
  prefs: []
  type: TYPE_NORMAL
- en: TRexAnimationList, callBack=myFunction, nickname='Dinosaur')
  prefs: []
  type: TYPE_NORMAL
- en: This creates an Animation object that will show 10 different images. The
  prefs: []
  type: TYPE_NORMAL
- en: first nine images each show for one-tenth of a second, but the last image
  prefs: []
  type: TYPE_NORMAL
- en: shows for four-tenths of a second. The animation will only play once and
  prefs: []
  type: TYPE_NORMAL
- en: will not automatically start playing. When the animation is finished,
  prefs: []
  type: TYPE_NORMAL
- en: myFunction() will be called with the argument 'Dinosaur'.
  prefs: []
  type: TYPE_NORMAL
- en: '***SpriteSheetAnimation Class***'
  prefs: []
  type: TYPE_NORMAL
- en: For SpriteSheetAnimation, you pass in a path to the single sprite sheet file.
    In
  prefs: []
  type: TYPE_NORMAL
- en: order for SpriteSheetAnimation to break up the large animation into many
  prefs: []
  type: TYPE_NORMAL
- en: smaller images, you must specify the width and height of all subimages. For
  prefs: []
  type: TYPE_NORMAL
- en: 'durations, you have two choices: you can specify a single value to say that
    all'
  prefs: []
  type: TYPE_NORMAL
- en: images should be shown for the same amount of time, or you can specify a
  prefs: []
  type: TYPE_NORMAL
- en: 'list or tuple of durations, one for each image. Here’s the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: SpriteSheetAnimation(window, loc, imagePath, nImages,
  prefs: []
  type: TYPE_NORMAL
- en: width, height, durationOrDurationsList,
  prefs: []
  type: TYPE_NORMAL
- en: autoStart=False, loop=False, nickname=None,
  prefs: []
  type: TYPE_NORMAL
- en: 'callBack=None, nIterations=1):'
  prefs: []
  type: TYPE_NORMAL
- en: 'The required parameters are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**window** The window to draw in'
  prefs: []
  type: TYPE_NORMAL
- en: '**loc** The upper-left corner where images should be drawn'
  prefs: []
  type: TYPE_NORMAL
- en: '**imagePath** The relative path to the sprite sheet image file'
  prefs: []
  type: TYPE_NORMAL
- en: '**nImages** The total number of subimages in the sprite sheet subimage'
  prefs: []
  type: TYPE_NORMAL
- en: '**width** The width of each single resulting subimage'
  prefs: []
  type: TYPE_NORMAL
- en: '**height** The height of each single resulting subimage'
  prefs: []
  type: TYPE_NORMAL
- en: '**durationOrDurationsList** The amount of time for which each subim-'
  prefs: []
  type: TYPE_NORMAL
- en: age should be shown during animation or a list of durations, one per
  prefs: []
  type: TYPE_NORMAL
- en: subimage (the length must be nImages)
  prefs: []
  type: TYPE_NORMAL
- en: '**306** Chapter 14'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the optional parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**autoStart**'
  prefs: []
  type: TYPE_NORMAL
- en: True if you want the animation to start right away; defaults to False.
  prefs: []
  type: TYPE_NORMAL
- en: '**loop**'
  prefs: []
  type: TYPE_NORMAL
- en: True if you want to animation to loop continuously; defaults to False.
  prefs: []
  type: TYPE_NORMAL
- en: '**showFirstImageAtEnd**'
  prefs: []
  type: TYPE_NORMAL
- en: When an animation ends, show the first image again; defaults to True.
  prefs: []
  type: TYPE_NORMAL
- en: '**nickname**'
  prefs: []
  type: TYPE_NORMAL
- en: An internal name to assign to this animation, used as an argument
  prefs: []
  type: TYPE_NORMAL
- en: when a callBack is specified.
  prefs: []
  type: TYPE_NORMAL
- en: '**callBack**'
  prefs: []
  type: TYPE_NORMAL
- en: The function or object method to call when the animation is done.
  prefs: []
  type: TYPE_NORMAL
- en: '**nIterations**'
  prefs: []
  type: TYPE_NORMAL
- en: The number of times to loop through the animation; defaults to 1\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a typical statement to create a SpriteSheetAnimation object:'
  prefs: []
  type: TYPE_NORMAL
- en: oEffectAnimation = pygwidgets.SpriteSheetAnimation(window, (400, 150),
  prefs: []
  type: TYPE_NORMAL
- en: '''images/effect.png'', 35, 192, 192, .1,'
  prefs: []
  type: TYPE_NORMAL
- en: autoStart=True, loop=True)
  prefs: []
  type: TYPE_NORMAL
- en: This creates a SpriteSheetAnimation object using a single image file found
  prefs: []
  type: TYPE_NORMAL
- en: at the given path. The original image contains 35 subimages. Each smaller
  prefs: []
  type: TYPE_NORMAL
- en: image is 192×192 pixels, and each subimage will be shown for one-tenth of a
  prefs: []
  type: TYPE_NORMAL
- en: second. The animation will start automatically and loop continuously.
  prefs: []
  type: TYPE_NORMAL
- en: '***Common Base Class: PygAnimation***'
  prefs: []
  type: TYPE_NORMAL
- en: The Animation and SpriteSheetAnimation classes each consist only of an
  prefs: []
  type: TYPE_NORMAL
- en: __init__() method and inherit from a common abstract base class,
  prefs: []
  type: TYPE_NORMAL
- en: PygAnimation. The __init__() methods of both classes call the inherited
  prefs: []
  type: TYPE_NORMAL
- en: __init__() method of the PygAnimation base class. Therefore, the __init__()
  prefs: []
  type: TYPE_NORMAL
- en: methods of the Animation and SpriteSheetAnimation classes only initialize
  prefs: []
  type: TYPE_NORMAL
- en: the unique data in their classes.
  prefs: []
  type: TYPE_NORMAL
- en: After creating an Animation or SpriteSheetAnimation object, client code
  prefs: []
  type: TYPE_NORMAL
- en: needs to include calls to update() and draw() in every frame. The following
    is
  prefs: []
  type: TYPE_NORMAL
- en: 'a list of the methods available to both classes through the base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**handleEvent( *event*****)**'
  prefs: []
  type: TYPE_NORMAL
- en: Must be called in every frame if you want to check if the user has clicked
  prefs: []
  type: TYPE_NORMAL
- en: on the animation. If so, you pass in the event supplied by pygame. This
  prefs: []
  type: TYPE_NORMAL
- en: method returns False most of the time, but returns True when the user
  prefs: []
  type: TYPE_NORMAL
- en: clicks down on the image, in which case you would typically call play().
  prefs: []
  type: TYPE_NORMAL
- en: '**play()**'
  prefs: []
  type: TYPE_NORMAL
- en: Starts the animation playing.
  prefs: []
  type: TYPE_NORMAL
- en: Animation **307**
  prefs: []
  type: TYPE_NORMAL
- en: '**stop()**'
  prefs: []
  type: TYPE_NORMAL
- en: Stops the animation wherever it is, and resets to showing only the first
  prefs: []
  type: TYPE_NORMAL
- en: image.
  prefs: []
  type: TYPE_NORMAL
- en: '**pause()**'
  prefs: []
  type: TYPE_NORMAL
- en: Causes the animation to temporarily stop on the current image. You
  prefs: []
  type: TYPE_NORMAL
- en: can continue playing with a call to play().
  prefs: []
  type: TYPE_NORMAL
- en: '**update()**'
  prefs: []
  type: TYPE_NORMAL
- en: Should be called in every frame. When the animation is running, this
  prefs: []
  type: TYPE_NORMAL
- en: method takes care of calculating the proper time to advance to the
  prefs: []
  type: TYPE_NORMAL
- en: next image. It typically returns False, but returns True when the anima-
  prefs: []
  type: TYPE_NORMAL
- en: tion ends (and it is not set to loop).
  prefs: []
  type: TYPE_NORMAL
- en: '**draw()**'
  prefs: []
  type: TYPE_NORMAL
- en: Should be called in every frame. This method draws the current image
  prefs: []
  type: TYPE_NORMAL
- en: of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: '**setLoop( *trueOrFalse*****)**'
  prefs: []
  type: TYPE_NORMAL
- en: Pass in True or False to indicate whether the animation should loop or
  prefs: []
  type: TYPE_NORMAL
- en: not.
  prefs: []
  type: TYPE_NORMAL
- en: '**getLoop()**'
  prefs: []
  type: TYPE_NORMAL
- en: Returns True if the animation is set to loop or False if it is not.
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The location of an animation in the window is determined by the original value
    of* *loc that’s passed to __init__(). Both Animation and SpriteSheetAnimation
    inherit* *from the common PygAnimation class, and that class inherits from PygWidget.
    Since* *all the methods available in PygWidget are therefore available in both
    animation* *classes, you could easily construct an animation that also changes
    its location while* *it is playing. You can make any animation move by calling
    setLoc(), inherited from* *PygWidget, and supplying any x and y location you like
    for each image.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Example Animation Program***'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14-2 shows a screenshot of a sample program that demonstrates mul-
  prefs: []
  type: TYPE_NORMAL
- en: tiple animations built from the Animation and SpriteSheetAnimation classes.
  prefs: []
  type: TYPE_NORMAL
- en: The little dinosaur on the left is an Animation object. It’s set to autoStart
    so
  prefs: []
  type: TYPE_NORMAL
- en: the animation plays when the program begins, but only once. Clicking the
  prefs: []
  type: TYPE_NORMAL
- en: buttons below the small dinosaur makes appropriate calls to the Animation
  prefs: []
  type: TYPE_NORMAL
- en: object. If you click Play, the animation plays again. While the animation is
  prefs: []
  type: TYPE_NORMAL
- en: playing, clicking Pause will freeze the animation until you click Play again.
  prefs: []
  type: TYPE_NORMAL
- en: If you play the animation and then click Stop, the animation will stop and
  prefs: []
  type: TYPE_NORMAL
- en: show the first image. Below those buttons are two checkboxes. By default, this
  prefs: []
  type: TYPE_NORMAL
- en: animation will not loop. If you check Loop, then press Play, the animation
  prefs: []
  type: TYPE_NORMAL
- en: repeats until you uncheck Loop. The Show checkbox makes the animation
  prefs: []
  type: TYPE_NORMAL
- en: visible or invisible.
  prefs: []
  type: TYPE_NORMAL
- en: '**308** Chapter 14'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 39](index-338_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: An example animation program using the Animation and*'
  prefs: []
  type: TYPE_NORMAL
- en: '*SpriteSheetAnimation classes*'
  prefs: []
  type: TYPE_NORMAL
- en: The second (T-rex) Animation object is not set to autoStart, so you only
  prefs: []
  type: TYPE_NORMAL
- en: see the first image of the animation. If you click this image, the anima-
  prefs: []
  type: TYPE_NORMAL
- en: tion is set to iterate through all its images three times (three loops) before
  prefs: []
  type: TYPE_NORMAL
- en: stopping.
  prefs: []
  type: TYPE_NORMAL
- en: At the top right is a firework SpriteSheetAnimation object, which comes
  prefs: []
  type: TYPE_NORMAL
- en: from a single image containing 35 subimages. This animation is set to loop,
  prefs: []
  type: TYPE_NORMAL
- en: so you see it run continuously.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom right is a walking SpriteSheetAnimation from a single image
  prefs: []
  type: TYPE_NORMAL
- en: with 36 subimages. When you click Start, the animation plays through all
  prefs: []
  type: TYPE_NORMAL
- en: the images once.
  prefs: []
  type: TYPE_NORMAL
- en: The full source code of this program is available in the *AnimationExample/*
  prefs: []
  type: TYPE_NORMAL
- en: '*Main_AnimationExample.py* file along with the rest of the book’s resources.'
  prefs: []
  type: TYPE_NORMAL
- en: The program instantiates two Animation objects (the small dinosaur and
  prefs: []
  type: TYPE_NORMAL
- en: the T-rex) and two SpriteSheetAnimation objects (the firework and the walk-
  prefs: []
  type: TYPE_NORMAL
- en: ing person). When a button below the little dinosaur is clicked, we call the
  prefs: []
  type: TYPE_NORMAL
- en: appropriate method of the dinosaur animation object. A click on the little
  prefs: []
  type: TYPE_NORMAL
- en: dinosaur or T-rex results in a call to the start() method of that animation.
  prefs: []
  type: TYPE_NORMAL
- en: The program shows that multiple animations can run at the same
  prefs: []
  type: TYPE_NORMAL
- en: time. This works because the main loop calls the update() and draw() meth-
  prefs: []
  type: TYPE_NORMAL
- en: ods of *each* animation in every frame in the main loop, and each animation
  prefs: []
  type: TYPE_NORMAL
- en: makes its own decision about keeping the current image or showing the
  prefs: []
  type: TYPE_NORMAL
- en: next image.
  prefs: []
  type: TYPE_NORMAL
- en: Animation **309**
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explored the mechanisms required in an animation class
  prefs: []
  type: TYPE_NORMAL
- en: by building our own SimpleAnimation and SimpleSpriteSheetAnimation classes.
  prefs: []
  type: TYPE_NORMAL
- en: The former is made up of multiple images, whereas the latter uses a single
  prefs: []
  type: TYPE_NORMAL
- en: larger image that contains multiple subimages.
  prefs: []
  type: TYPE_NORMAL
- en: These two classes have different initializations, but the remaining meth-
  prefs: []
  type: TYPE_NORMAL
- en: ods of the classes are identical. I explained the process of merging the two
  prefs: []
  type: TYPE_NORMAL
- en: classes by building a common abstract base class.
  prefs: []
  type: TYPE_NORMAL
- en: I then introduced the Animation class and the SpriteSheetAnimation class
  prefs: []
  type: TYPE_NORMAL
- en: in pygwidgets. I explained that these two classes only implement their own
  prefs: []
  type: TYPE_NORMAL
- en: versions of the __init__() method, inheriting their other methods from the
  prefs: []
  type: TYPE_NORMAL
- en: common base class, PygAnimation. I concluded by showing a demonstration
  prefs: []
  type: TYPE_NORMAL
- en: program that provides examples of animations and sprite sheet animations.
  prefs: []
  type: TYPE_NORMAL
- en: '**15**'
  prefs: []
  type: TYPE_NORMAL
- en: '**S C E N E S**'
  prefs: []
  type: TYPE_NORMAL
- en: Games and programs will often need to
  prefs: []
  type: TYPE_NORMAL
- en: present different scenes to the user. For the
  prefs: []
  type: TYPE_NORMAL
- en: purpose of this discussion, I’ll define a *scene*
  prefs: []
  type: TYPE_NORMAL
- en: as any window layout and related user interac-
  prefs: []
  type: TYPE_NORMAL
- en: tions that are significantly different from any other. For
  prefs: []
  type: TYPE_NORMAL
- en: example, a game like *Space Invaders* may have a starting
  prefs: []
  type: TYPE_NORMAL
- en: or *splash* scene, a main game play scene, a high scores
  prefs: []
  type: TYPE_NORMAL
- en: scene, and perhaps an ending or goodbye scene.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter I will discuss two different approaches to writing a pro-
  prefs: []
  type: TYPE_NORMAL
- en: gram that has multiple scenes. First, I’ll introduce the state machine tech-
  prefs: []
  type: TYPE_NORMAL
- en: nique, which works well for relatively small programs. Then I’ll show a fully
  prefs: []
  type: TYPE_NORMAL
- en: object-oriented approach where each scene is implemented as an object,
  prefs: []
  type: TYPE_NORMAL
- en: under the control of a scene manager. The latter is much more scalable for
  prefs: []
  type: TYPE_NORMAL
- en: larger programs.
  prefs: []
  type: TYPE_NORMAL
- en: '**The State Machine Approach**'
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this book, we developed a software simulation of a
  prefs: []
  type: TYPE_NORMAL
- en: light switch. I[n Chapter 1, w](index_split_000.html#p32)e first implemented
    a light switch using procedural code, and then we rewrote it using a class. In
    both cases, the position
  prefs: []
  type: TYPE_NORMAL
- en: (or state) of the switch was represented by a single Boolean variable; True
  prefs: []
  type: TYPE_NORMAL
- en: represented on and False represented off.
  prefs: []
  type: TYPE_NORMAL
- en: There are many situations where a program or an object can be in
  prefs: []
  type: TYPE_NORMAL
- en: one of a number of different states, and different code needs to run based
  prefs: []
  type: TYPE_NORMAL
- en: on the current state. For example, consider the series of steps involved in
  prefs: []
  type: TYPE_NORMAL
- en: using an ATM. There is a starting (greeting) state, then you need to put in
  prefs: []
  type: TYPE_NORMAL
- en: your ATM card; after this you’re prompted to enter your PIN, choose which
  prefs: []
  type: TYPE_NORMAL
- en: action you want to do, and so on. At any point, you may need to go back a
  prefs: []
  type: TYPE_NORMAL
- en: step or even start over. The general implementation approach is to use a
  prefs: []
  type: TYPE_NORMAL
- en: '*state machine*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**state machine**'
  prefs: []
  type: TYPE_NORMAL
- en: A model that represents and controls the flow of execution through a series
    of states .
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of a state machine consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: • A collection of predefined states, typically expressed as constants whose
  prefs: []
  type: TYPE_NORMAL
- en: values are strings comprised of a word or short phrase that describes
  prefs: []
  type: TYPE_NORMAL
- en: what happens in the state
  prefs: []
  type: TYPE_NORMAL
- en: • A single variable to track the current state
  prefs: []
  type: TYPE_NORMAL
- en: • A starting state (from the set of predefined states)
  prefs: []
  type: TYPE_NORMAL
- en: • A set of clearly defined transitions between states
  prefs: []
  type: TYPE_NORMAL
- en: A state machine can only be in one state at any given time, but can
  prefs: []
  type: TYPE_NORMAL
- en: move to a new state, typically based on specific input from the user.
  prefs: []
  type: TYPE_NORMAL
- en: I[n Chapter 7 w](index_split_003.html#p172)e discussed the GUI button classes
    in the pygwidgets package. When rolling over and clicking a button, a user sees
    three different images—up, over, and down—which correspond to different states
    of
  prefs: []
  type: TYPE_NORMAL
- en: the button. The image switching is done in the handleEvent() method (which
  prefs: []
  type: TYPE_NORMAL
- en: is called whenever an event occurs). Let’s take a closer look at how this is
  prefs: []
  type: TYPE_NORMAL
- en: implemented.
  prefs: []
  type: TYPE_NORMAL
- en: The handleEvent() method is built as a state machine. The state is kept
  prefs: []
  type: TYPE_NORMAL
- en: in an instance variable, self.state. Each button starts in the up state, show-
  prefs: []
  type: TYPE_NORMAL
- en: ing the “up” image. When the user moves the cursor over a button, we
  prefs: []
  type: TYPE_NORMAL
- en: show the “over” image and the code transitions to the over state. When the
  prefs: []
  type: TYPE_NORMAL
- en: user clicks down on the button, we show the “down” image and the code
  prefs: []
  type: TYPE_NORMAL
- en: moves into the down state (internally called the *armed* state). When the user
    releases the mouse button (clicks up), we again show the “over” image, and
  prefs: []
  type: TYPE_NORMAL
- en: the code transitions back to the over state (and handleEvent() returns True
    to
  prefs: []
  type: TYPE_NORMAL
- en: indicate that a click has happened). If the user then moves the cursor off the
  prefs: []
  type: TYPE_NORMAL
- en: button, we show the “up” image again and transition back to the up state.
  prefs: []
  type: TYPE_NORMAL
- en: '**312** Chapter 15'
  prefs: []
  type: TYPE_NORMAL
- en: Next, I’ll show you how we can use a state machine to represent different scenes
    that a user can encounter in a larger program. As a generic
  prefs: []
  type: TYPE_NORMAL
- en: 'example, we’ll have the following scenes: *Splash* (starting), *Play*, and
    *End*.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create a set of constants that represent the different states, create
    a
  prefs: []
  type: TYPE_NORMAL
- en: 'variable called state, and assign it the value of the starting state:'
  prefs: []
  type: TYPE_NORMAL
- en: STATE_SPLASH = 'splash'
  prefs: []
  type: TYPE_NORMAL
- en: STATE_PLAY = 'play'
  prefs: []
  type: TYPE_NORMAL
- en: STATE_END = 'end'
  prefs: []
  type: TYPE_NORMAL
- en: 'state = STATE_SPLASH # initialize to starting state'
  prefs: []
  type: TYPE_NORMAL
- en: In order to perform different actions in the different states, in the pro-
  prefs: []
  type: TYPE_NORMAL
- en: gram’s main loop we use an if/elif/elif/.../else construct that branches
  prefs: []
  type: TYPE_NORMAL
- en: 'based on the current value of the state variable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if state == STATE_SPLASH:'
  prefs: []
  type: TYPE_NORMAL
- en: Do whatever you want to do in the Splash state here
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'elif state == STATE_PLAY:'
  prefs: []
  type: TYPE_NORMAL
- en: Do whatever you want to do in the Play state here
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'elif state == STATE_END:'
  prefs: []
  type: TYPE_NORMAL
- en: Do whatever you want to do in the End state here
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: 'raise ValueError(''Unknown value for state: '' + state)'
  prefs: []
  type: TYPE_NORMAL
- en: Since state is initially set to STATE_SPLASH, only the first branch of the if
  prefs: []
  type: TYPE_NORMAL
- en: statement will run.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of a state machine is that under certain circumstances, typi-
  prefs: []
  type: TYPE_NORMAL
- en: cally triggered by some event, the program changes its state by assigning a
  prefs: []
  type: TYPE_NORMAL
- en: different value to the state variable. For example, the starting Splash scene
  prefs: []
  type: TYPE_NORMAL
- en: could just show a game introduction with a Start button. When the user
  prefs: []
  type: TYPE_NORMAL
- en: clicks the Start button, the game will execute an assignment statement that
  prefs: []
  type: TYPE_NORMAL
- en: 'changes the value of the state variable to transition into the Play state:'
  prefs: []
  type: TYPE_NORMAL
- en: state = STATE_PLAY
  prefs: []
  type: TYPE_NORMAL
- en: Once that line runs, only the code in the first elif runs and completely
  prefs: []
  type: TYPE_NORMAL
- en: different code will execute—the code to show and react to the Play state.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, whenever and however the program reaches the ending con-
  prefs: []
  type: TYPE_NORMAL
- en: dition for the game, it will execute the following line to transition to the
  prefs: []
  type: TYPE_NORMAL
- en: 'End state:'
  prefs: []
  type: TYPE_NORMAL
- en: state = STATE_END
  prefs: []
  type: TYPE_NORMAL
- en: From then on, every time the program goes around the while loop, the
  prefs: []
  type: TYPE_NORMAL
- en: code of the second elif branch will run.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, a state machine has a set of states, one variable to keep
  prefs: []
  type: TYPE_NORMAL
- en: track of which state the program is in, and a set of events that cause the pro-
  prefs: []
  type: TYPE_NORMAL
- en: gram to transition from one state to another. Since there is a single variable
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **313**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 40](index-343_1.png)'
  prefs: []
  type: TYPE_IMG
- en: that keeps track of the state, the program can be in only one of the states
    at
  prefs: []
  type: TYPE_NORMAL
- en: any time. Different actions that the user takes (clicking a button, pressing
  prefs: []
  type: TYPE_NORMAL
- en: a key, dragging an item, and so on) or other events (such as a timer run-
  prefs: []
  type: TYPE_NORMAL
- en: ning out) can cause the program to transition from one state to another.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on which state it is in, the program may listen for different
  prefs: []
  type: TYPE_NORMAL
- en: events and will typically execute different code.
  prefs: []
  type: TYPE_NORMAL
- en: '**A pygame Example with a State Machine**'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll build a Rock, Paper, Scissors game that uses a state machine.
  prefs: []
  type: TYPE_NORMAL
- en: The user chooses rock, paper, or scissors; then the computer randomly
  prefs: []
  type: TYPE_NORMAL
- en: chooses among the three. If the person and computer choose the same
  prefs: []
  type: TYPE_NORMAL
- en: item, it’s a tie. Otherwise, one point is awarded to the player or the com-
  prefs: []
  type: TYPE_NORMAL
- en: 'puter, according to the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: • Rock crushes scissors.
  prefs: []
  type: TYPE_NORMAL
- en: • Scissors cuts paper.
  prefs: []
  type: TYPE_NORMAL
- en: • Paper covers rock.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user will see the game as three scenes: an opening or Splash scene'
  prefs: []
  type: TYPE_NORMAL
- en: (Figure 15-1), a Play scene (Figure 15-2), and a Results scene (Figure 15-3).
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-1: The Rock, Paper, Scissors Splash scene*'
  prefs: []
  type: TYPE_NORMAL
- en: The Splash scene waits for the user to click the Start button.
  prefs: []
  type: TYPE_NORMAL
- en: '**314** Chapter 15'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 41](index-344_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 42](index-344_2.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: The Rock, Paper, Scissors Play scene*'
  prefs: []
  type: TYPE_NORMAL
- en: The Play scene is where the user makes a choice. After the user clicks
  prefs: []
  type: TYPE_NORMAL
- en: an icon to indicate their choice, the computer makes a randomized choice.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-3: The Rock, Paper, Scissors Results scene*'
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **315**
  prefs: []
  type: TYPE_NORMAL
- en: The Results scene shows the outcome of the round and the score. It waits for
    the user to click Restart to play another round.
  prefs: []
  type: TYPE_NORMAL
- en: In this game, each value of state corresponds to a different scene.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15-4 is a *state diagram* that shows the states and transitions (the
  prefs: []
  type: TYPE_NORMAL
- en: actions or events that cause the program to move from one state to
  prefs: []
  type: TYPE_NORMAL
- en: another).
  prefs: []
  type: TYPE_NORMAL
- en: Choose rock, paper, or scissors
  prefs: []
  type: TYPE_NORMAL
- en: Press Start button
  prefs: []
  type: TYPE_NORMAL
- en: Splash
  prefs: []
  type: TYPE_NORMAL
- en: Play
  prefs: []
  type: TYPE_NORMAL
- en: Results
  prefs: []
  type: TYPE_NORMAL
- en: Press Restart button
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-4: Rock, Paper, Scissors state diagram*'
  prefs: []
  type: TYPE_NORMAL
- en: When sitting idle (waiting for the user), the current scene will typically
  prefs: []
  type: TYPE_NORMAL
- en: remain unchanged. That is, inside the main event loop, the program will
  prefs: []
  type: TYPE_NORMAL
- en: usually not change the value of the state variable. (The state might change
  prefs: []
  type: TYPE_NORMAL
- en: when a timer ends, but this will be rare.) This game starts in the Splash
  prefs: []
  type: TYPE_NORMAL
- en: scene, and when the user presses the Start button, the game moves to the
  prefs: []
  type: TYPE_NORMAL
- en: Play scene. The play of the game then alternates between the Play and
  prefs: []
  type: TYPE_NORMAL
- en: Results scenes. Though this is a simple example, a state diagram can be very
  prefs: []
  type: TYPE_NORMAL
- en: useful in understanding the flow of more complicated programs.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 15-1 provides the code of the Rock, Paper, Scissors program,
  prefs: []
  type: TYPE_NORMAL
- en: with the boilerplate code omitted to save space.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: RockPaperScissorsStateMachine/RockPaperScissors.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Rock, Paper, Scissors in pygame
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Demonstration of a state machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  prefs: []
  type: TYPE_NORMAL
- en: ROCK = 'Rock'
  prefs: []
  type: TYPE_NORMAL
- en: PAPER = 'Paper'
  prefs: []
  type: TYPE_NORMAL
- en: SCISSORS = 'Scissors'
  prefs: []
  type: TYPE_NORMAL
- en: Set constants for each of the three states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: STATE_SPLASH = 'Splash' 1
  prefs: []
  type: TYPE_NORMAL
- en: STATE_PLAYER_CHOICE = 'PlayerChoice'
  prefs: []
  type: TYPE_NORMAL
- en: STATE_SHOW_RESULTS = 'ShowResults'
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  prefs: []
  type: TYPE_NORMAL
- en: '**316** Chapter 15'
  prefs: []
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: playerScore = 0
  prefs: []
  type: TYPE_NORMAL
- en: computerScore = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'state = STATE_SPLASH 2 # the starting state'
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: 'if state == STATE_SPLASH: 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'if startButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: state = STATE_PLAYER_CHOICE
  prefs: []
  type: TYPE_NORMAL
- en: 'elif state == STATE_PLAYER_CHOICE: 4 # let the user choose'
  prefs: []
  type: TYPE_NORMAL
- en: 'playerChoice = '''' # indicates no choice yet'
  prefs: []
  type: TYPE_NORMAL
- en: 'if rockButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: playerChoice = ROCK
  prefs: []
  type: TYPE_NORMAL
- en: rpsCollectionPlayer.replace(ROCK)
  prefs: []
  type: TYPE_NORMAL
- en: 'elif paperButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: playerChoice = PAPER
  prefs: []
  type: TYPE_NORMAL
- en: rpsCollectionPlayer.replace(PAPER)
  prefs: []
  type: TYPE_NORMAL
- en: 'elif scissorButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: playerChoice = SCISSORS
  prefs: []
  type: TYPE_NORMAL
- en: rpsCollectionPlayer.replace(SCISSORS)
  prefs: []
  type: TYPE_NORMAL
- en: 'if playerChoice != '''': # player has made a choice, make computer choice'
  prefs: []
  type: TYPE_NORMAL
- en: Computer chooses from tuple of moves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: rps = (ROCK, PAPER, SCISSORS)
  prefs: []
  type: TYPE_NORMAL
- en: 'computerChoice = random.choice(rps) # computer chooses'
  prefs: []
  type: TYPE_NORMAL
- en: rpsCollectionComputer.replace(computerChoice)
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if playerChoice == computerChoice: # tie'
  prefs: []
  type: TYPE_NORMAL
- en: resultsField.setValue('It is a tie!')
  prefs: []
  type: TYPE_NORMAL
- en: tieSound.play()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif playerChoice == ROCK and computerChoice == SCISSORS:'
  prefs: []
  type: TYPE_NORMAL
- en: resultsField.setValue('Rock breaks Scissors. You win!')
  prefs: []
  type: TYPE_NORMAL
- en: playerScore = playerScore + 1
  prefs: []
  type: TYPE_NORMAL
- en: winnerSound.play()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif playerChoice == ROCK and computerChoice == PAPER:'
  prefs: []
  type: TYPE_NORMAL
- en: resultsField.setValue('Rock is covered by Paper. You lose.')
  prefs: []
  type: TYPE_NORMAL
- en: computerScore = computerScore + 1
  prefs: []
  type: TYPE_NORMAL
- en: loserSound.play()
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **317**
  prefs: []
  type: TYPE_NORMAL
- en: 'elif playerChoice == SCISSORS and computerChoice == PAPER: resultsField.setValue(''Scissors
    cuts Paper. You win!'')'
  prefs: []
  type: TYPE_NORMAL
- en: playerScore = playerScore + 1
  prefs: []
  type: TYPE_NORMAL
- en: winnerSound.play()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif playerChoice == SCISSORS and computerChoice == ROCK:'
  prefs: []
  type: TYPE_NORMAL
- en: resultsField.setValue('Scissors crushed by Rock. You lose.')
  prefs: []
  type: TYPE_NORMAL
- en: computerScore = computerScore + 1
  prefs: []
  type: TYPE_NORMAL
- en: loserSound.play()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif playerChoice == PAPER and computerChoice == ROCK:'
  prefs: []
  type: TYPE_NORMAL
- en: resultsField.setValue('Paper covers Rock. You win!')
  prefs: []
  type: TYPE_NORMAL
- en: playerScore = playerScore + 1
  prefs: []
  type: TYPE_NORMAL
- en: winnerSound.play()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif playerChoice == PAPER and computerChoice == SCISSORS:'
  prefs: []
  type: TYPE_NORMAL
- en: resultsField.setValue('Paper is cut by Scissors. You lose.')
  prefs: []
  type: TYPE_NORMAL
- en: computerScore = computerScore + 1
  prefs: []
  type: TYPE_NORMAL
- en: loserSound.play()
  prefs: []
  type: TYPE_NORMAL
- en: Show the player's score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'playerScoreCounter.setValue(''Your Score: ''+ str(playerScore))'
  prefs: []
  type: TYPE_NORMAL
- en: Show the computer's score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'computerScoreCounter.setValue(''Computer Score: ''+ str(computerScore))'
  prefs: []
  type: TYPE_NORMAL
- en: 'state = STATE_SHOW_RESULTS # change state'
  prefs: []
  type: TYPE_NORMAL
- en: 'elif state == STATE_SHOW_RESULTS: 5'
  prefs: []
  type: TYPE_NORMAL
- en: 'if restartButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: 'state = STATE_PLAYER_CHOICE # change state'
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: raise ValueError('Unknown value for state:', state)
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if state == STATE_PLAYER_CHOICE:'
  prefs: []
  type: TYPE_NORMAL
- en: messageField.setValue(' Rock Paper Scissors')
  prefs: []
  type: TYPE_NORMAL
- en: 'elif state == STATE_SHOW_RESULTS:'
  prefs: []
  type: TYPE_NORMAL
- en: messageField.setValue('You Computer')
  prefs: []
  type: TYPE_NORMAL
- en: 9 - Clear the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(GRAY)
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw all window elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: messageField.draw()
  prefs: []
  type: TYPE_NORMAL
- en: 'if state == STATE_SPLASH: 6'
  prefs: []
  type: TYPE_NORMAL
- en: rockImage.draw()
  prefs: []
  type: TYPE_NORMAL
- en: paperImage.draw()
  prefs: []
  type: TYPE_NORMAL
- en: scissorsImage.draw()
  prefs: []
  type: TYPE_NORMAL
- en: startButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: Draw player choices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'elif state == STATE_PLAYER_CHOICE: 7'
  prefs: []
  type: TYPE_NORMAL
- en: rockButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: '**318** Chapter 15'
  prefs: []
  type: TYPE_NORMAL
- en: paperButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: scissorButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: chooseText.draw()
  prefs: []
  type: TYPE_NORMAL
- en: Draw the results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'elif state == STATE_SHOW_RESULTS: 8'
  prefs: []
  type: TYPE_NORMAL
- en: resultsField.draw()
  prefs: []
  type: TYPE_NORMAL
- en: rpsCollectionPlayer.draw()
  prefs: []
  type: TYPE_NORMAL
- en: rpsCollectionComputer.draw()
  prefs: []
  type: TYPE_NORMAL
- en: playerScoreCounter.draw()
  prefs: []
  type: TYPE_NORMAL
- en: computerScoreCounter.draw()
  prefs: []
  type: TYPE_NORMAL
- en: restartButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-1: The Rock, Paper, Scissors game*'
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, I have snipped the code that creates images, buttons, and
  prefs: []
  type: TYPE_NORMAL
- en: text fields for the Splash, Play, and Results scenes. The downloadable files
  prefs: []
  type: TYPE_NORMAL
- en: for the book contain the full source code and all the associated art.
  prefs: []
  type: TYPE_NORMAL
- en: Before the program goes into the main loop, we define all three states 1,
  prefs: []
  type: TYPE_NORMAL
- en: instantiate and load all the screen elements, and set the starting state 2\.
  prefs: []
  type: TYPE_NORMAL
- en: We do different event checks depending on which state the program is
  prefs: []
  type: TYPE_NORMAL
- en: in. In the Splash state, we only check for clicking the Start button 3\. In
    the
  prefs: []
  type: TYPE_NORMAL
- en: Play state, we check for a click on the Rock, Paper, or Scissors icon buttons
    4\.
  prefs: []
  type: TYPE_NORMAL
- en: In the Results state, we only check for a click on the Restart button 5\.
  prefs: []
  type: TYPE_NORMAL
- en: Pressing a button or making a selection in one scene changes the value
  prefs: []
  type: TYPE_NORMAL
- en: of the state variable and therefore moves the game into a different scene.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the main loop 6 7 8, we draw different screen elements
  prefs: []
  type: TYPE_NORMAL
- en: depending on which state the program is currently in.
  prefs: []
  type: TYPE_NORMAL
- en: This technique works well for a small number of states/scenes. However,
  prefs: []
  type: TYPE_NORMAL
- en: in a program with more complicated rules or one that has many scenes and/
  prefs: []
  type: TYPE_NORMAL
- en: or states, keeping track of what should be done where can become very dif-
  prefs: []
  type: TYPE_NORMAL
- en: ficult. Instead, we can take advantage of many of the object-oriented pro-
  prefs: []
  type: TYPE_NORMAL
- en: gramming techniques introduced earlier in this book and build a different
  prefs: []
  type: TYPE_NORMAL
- en: architecture based on independent scenes, all controlled by an object man-
  prefs: []
  type: TYPE_NORMAL
- en: ager object.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Scene Manager for Managing Many Scenes**'
  prefs: []
  type: TYPE_NORMAL
- en: The second approach to building a program with multiple scenes is to use
  prefs: []
  type: TYPE_NORMAL
- en: 'a *scene manager*: an object that centralizes the handling of different scenes.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create a SceneMgr class and instantiate a single oSceneMgr object from
  prefs: []
  type: TYPE_NORMAL
- en: it. In the following discussion, I’ll refer to the oSceneMgr object as the scene
  prefs: []
  type: TYPE_NORMAL
- en: manager, since we only instantiate one. As you’ll see, the scene manager
  prefs: []
  type: TYPE_NORMAL
- en: and the related scenes take advantage of encapsulation, inheritance, and
  prefs: []
  type: TYPE_NORMAL
- en: polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **319**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 43](index-349_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the scene manager can be a little tricky, but the resulting pro-
  prefs: []
  type: TYPE_NORMAL
- en: gram architecture results in a highly modular, easy-to-modify program. A
  prefs: []
  type: TYPE_NORMAL
- en: 'program that uses the scene manager will be made up of the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Main program** The small main program (that you write) must first'
  prefs: []
  type: TYPE_NORMAL
- en: create an instance of every scene identified in your program, then cre-
  prefs: []
  type: TYPE_NORMAL
- en: ate an instance of the scene manager, passing a list of the scenes and
  prefs: []
  type: TYPE_NORMAL
- en: a frame rate. To start your program, you call the run() method of the
  prefs: []
  type: TYPE_NORMAL
- en: scene manager. For each new project you build, you must write a new
  prefs: []
  type: TYPE_NORMAL
- en: main program.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scene manager** The scene manager is written for you and is avail-'
  prefs: []
  type: TYPE_NORMAL
- en: able as the SceneMgr class in the *pyghelpers.py* file. It keeps track of all
    the different scenes, remembers which one is current, calls methods in the
  prefs: []
  type: TYPE_NORMAL
- en: current scene, allows for switching between scenes, and handles com-
  prefs: []
  type: TYPE_NORMAL
- en: munication between scenes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenes** Your program can have as many scenes as you want or need.'
  prefs: []
  type: TYPE_NORMAL
- en: Each scene is typically developed as a separate Python file. Each scene
  prefs: []
  type: TYPE_NORMAL
- en: class must inherit from the prewritten Scene base class and have a set of
  prefs: []
  type: TYPE_NORMAL
- en: methods whose names are predefined. The scene manager uses poly-
  prefs: []
  type: TYPE_NORMAL
- en: morphism to call these methods in the current scene. I have provided a
  prefs: []
  type: TYPE_NORMAL
- en: template *ExampleScene.py* file to show you how to build a scene.
  prefs: []
  type: TYPE_NORMAL
- en: The code for the SceneMgr class and the code for the Scene base class live
  prefs: []
  type: TYPE_NORMAL
- en: in the pyghelpers package. The scene manager is an object manager object
  prefs: []
  type: TYPE_NORMAL
- en: that manages any number of Scene objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**A Demo Program Using a Scene Manager**'
  prefs: []
  type: TYPE_NORMAL
- en: As a demonstration, we’ll build a Scene Demo program that contains three
  prefs: []
  type: TYPE_NORMAL
- en: 'simple scenes: Scene A, Scene B, and Scene C. The idea is that from any'
  prefs: []
  type: TYPE_NORMAL
- en: scene, you can click a button to get to any other scene. Figures 15-5 through
  prefs: []
  type: TYPE_NORMAL
- en: 15-7 show screenshots of the three scenes.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-5: What the user sees in Scene A*'
  prefs: []
  type: TYPE_NORMAL
- en: From Scene A, you can get to Scene B or Scene C.
  prefs: []
  type: TYPE_NORMAL
- en: '**320** Chapter 15'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 44](index-350_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 45](index-350_2.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 46](index-350_3.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: What the user sees in Scene B*'
  prefs: []
  type: TYPE_NORMAL
- en: From Scene B, you can get to Scene A or Scene C.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-7: What the user sees in Scene C*'
  prefs: []
  type: TYPE_NORMAL
- en: From Scene C, you can get to Scene A or Scene B.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the project folder is shown in Figure 15-8\. Note that
  prefs: []
  type: TYPE_NORMAL
- en: this assumes that you have already installed the pygwidgets and pyghelpers
  prefs: []
  type: TYPE_NORMAL
- en: modules in the proper *site-packages* folder.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-8: The project folder showing the main program and the different
    scene files* *Main_SceneDemo.py* is the main program. *Constants.py* contains
    a few'
  prefs: []
  type: TYPE_NORMAL
- en: constants shared by the main program and all the scenes. *SceneA.py*, *SceneB.py*,
    and *SceneC.py* are the actual scenes, each containing a related scene class.
  prefs: []
  type: TYPE_NORMAL
- en: '*SceneExample.py* is a sample file that shows what a typical scene file might
    Scenes **321**'
  prefs: []
  type: TYPE_NORMAL
- en: look like. It’s not used in this program, but you can refer to it to get an
    understanding of the basics of writing a typical scene.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15-9 shows how the objects in the program relate to each other.
  prefs: []
  type: TYPE_NORMAL
- en: '**Main**'
  prefs: []
  type: TYPE_NORMAL
- en: '*(Instantiates all scenes*'
  prefs: []
  type: TYPE_NORMAL
- en: '*and the scene manager)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Starts the*'
  prefs: []
  type: TYPE_NORMAL
- en: '*scene manager*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scene manager**'
  prefs: []
  type: TYPE_NORMAL
- en: '*(Manages navigation and*'
  prefs: []
  type: TYPE_NORMAL
- en: '*communication between scenes)*'
  prefs: []
  type: TYPE_NORMAL
- en: Scene 1
  prefs: []
  type: TYPE_NORMAL
- en: Scene 2
  prefs: []
  type: TYPE_NORMAL
- en: Scene 3
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: Scene N
  prefs: []
  type: TYPE_NORMAL
- en: '*All scenes inherit from the Scene base class*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-9: The hierarchy of objects in a project*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how the different parts of a program using the scene manager
  prefs: []
  type: TYPE_NORMAL
- en: work together, starting with the main program.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Main Program***'
  prefs: []
  type: TYPE_NORMAL
- en: The main program will be unique for every project. Its purpose is to initial-
  prefs: []
  type: TYPE_NORMAL
- en: ize the pygame environment, instantiate all the scenes, create an instance
  prefs: []
  type: TYPE_NORMAL
- en: of the SceneMgr, then transfer control to the scene manager, oSceneMgr.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 15-2 presents the code of the demo main program.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: SceneDemo/Main_SceneDemo.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Scene Demo main program with three scenes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  prefs: []
  type: TYPE_NORMAL
- en: 1 - Import packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: 1 import pyghelpers
  prefs: []
  type: TYPE_NORMAL
- en: from SceneA import *
  prefs: []
  type: TYPE_NORMAL
- en: from SceneB import *
  prefs: []
  type: TYPE_NORMAL
- en: from SceneC import *
  prefs: []
  type: TYPE_NORMAL
- en: 2 - Define constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2 WINDOW_WIDTH = 640
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_HEIGHT = 180
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  prefs: []
  type: TYPE_NORMAL
- en: '**322** Chapter 15'
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instantiate all scenes and store them into a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 scenesList = [SceneA(window),
  prefs: []
  type: TYPE_NORMAL
- en: SceneB(window),
  prefs: []
  type: TYPE_NORMAL
- en: SceneC(window)]
  prefs: []
  type: TYPE_NORMAL
- en: Create the scene manager, passing in the scenes list and the FPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4 oSceneMgr = pyghelpers.SceneMgr(scenesList, FRAMES_PER_SECOND)
  prefs: []
  type: TYPE_NORMAL
- en: Tell the scene manager to start running
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 5 oSceneMgr.run()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-2: A sample main program using the scene manager*'
  prefs: []
  type: TYPE_NORMAL
- en: The code of the main program is relatively short. We start by import-
  prefs: []
  type: TYPE_NORMAL
- en: ing pyghelpers, then all the scenes (in this case, Scene A, Scene B, and
  prefs: []
  type: TYPE_NORMAL
- en: Scene C) 1\. We then define a few more constants, initialize pygame, and
  prefs: []
  type: TYPE_NORMAL
- en: create the window 2\. Next, we create an instance of each scene and store
  prefs: []
  type: TYPE_NORMAL
- en: all the scenes in a list 3\. After this line executes, we have an initialized
  prefs: []
  type: TYPE_NORMAL
- en: object for each scene.
  prefs: []
  type: TYPE_NORMAL
- en: We then instantiate the scene manager object (oSceneMgr) 4 from the
  prefs: []
  type: TYPE_NORMAL
- en: 'SceneMgr class. When we create this object, we need to pass in two values:'
  prefs: []
  type: TYPE_NORMAL
- en: • The list of scenes, so the scene manager can be aware of all the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: The first scene in the list of scenes is used as the starting scene for the
  prefs: []
  type: TYPE_NORMAL
- en: program.
  prefs: []
  type: TYPE_NORMAL
- en: • The frames per second (frame rate) that the program should maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we tell the scene manager to start running by calling its run()
  prefs: []
  type: TYPE_NORMAL
- en: method 5\. The scene manager always maintains a single scene as the cur-
  prefs: []
  type: TYPE_NORMAL
- en: rent scene—the one that the user sees and interacts with.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that with this approach, the main program implements the ini-
  prefs: []
  type: TYPE_NORMAL
- en: tialization of a typical pygame program but does *not* build the main loop.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the main loop is built into the scene manager itself.
  prefs: []
  type: TYPE_NORMAL
- en: '***Building the Scenes***'
  prefs: []
  type: TYPE_NORMAL
- en: To understand the interaction between the scene manager and any indi-
  prefs: []
  type: TYPE_NORMAL
- en: vidual scene, I’ll explain how a typical scene is built.
  prefs: []
  type: TYPE_NORMAL
- en: Each time through its loop, the scene manager calls a predefined set
  prefs: []
  type: TYPE_NORMAL
- en: of methods in the current scene that are intended to handle events, do any
  prefs: []
  type: TYPE_NORMAL
- en: per-frame actions, and draw anything that needs to be drawn in that scene.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the code of each scene must be split up into these methods. The
  prefs: []
  type: TYPE_NORMAL
- en: 'approach makes use of polymorphism: each scene needs to implement a'
  prefs: []
  type: TYPE_NORMAL
- en: common set of methods.
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **323**
  prefs: []
  type: TYPE_NORMAL
- en: '**Methods to Implement in Each Scene**'
  prefs: []
  type: TYPE_NORMAL
- en: Each scene is implemented as a class that inherits from the Scene base
  prefs: []
  type: TYPE_NORMAL
- en: class defined in the *pyghelpers.py* file. Therefore, each scene must import
  prefs: []
  type: TYPE_NORMAL
- en: pyghelpers. At a minimum, a scene needs to contain an __init__() method
  prefs: []
  type: TYPE_NORMAL
- en: and must override the getSceneKey(), handleInputs(), and draw() methods
  prefs: []
  type: TYPE_NORMAL
- en: from the base class.
  prefs: []
  type: TYPE_NORMAL
- en: Every scene must have a unique *scene key*—a string used by the scene
  prefs: []
  type: TYPE_NORMAL
- en: manager to identify each scene. I recommend that you build a file with a
  prefs: []
  type: TYPE_NORMAL
- en: 'name like *Constants.py* that contains the keys for all the scenes and import
    this file into each scene file. For example, the *Constants.py* file for the sample
    program contains:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scene keys (any unique values):'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SCENE_A = 'scene A'
  prefs: []
  type: TYPE_NORMAL
- en: SCENE_B = 'scene B'
  prefs: []
  type: TYPE_NORMAL
- en: SCENE_C = 'scene C'
  prefs: []
  type: TYPE_NORMAL
- en: During its initialization, the scene manager calls the getSceneKey()
  prefs: []
  type: TYPE_NORMAL
- en: method of each scene, which simply returns its unique scene key. The
  prefs: []
  type: TYPE_NORMAL
- en: scene manager then builds an internal dictionary of scene keys and scene
  prefs: []
  type: TYPE_NORMAL
- en: objects. When any scene in the program wants to switch to a different
  prefs: []
  type: TYPE_NORMAL
- en: scene, it will call self.goToScene() (described in the following section) and
  prefs: []
  type: TYPE_NORMAL
- en: pass in the scene key of the target scene. The scene manager uses this key
  prefs: []
  type: TYPE_NORMAL
- en: in the dictionary to find the associated scene object; it then sets the new
  prefs: []
  type: TYPE_NORMAL
- en: scene object as the current scene and calls its methods.
  prefs: []
  type: TYPE_NORMAL
- en: Each scene must contain its own version of handleInputs() to handle any
  prefs: []
  type: TYPE_NORMAL
- en: events that would typically be handled in the main loop and its own version
  prefs: []
  type: TYPE_NORMAL
- en: of draw() to draw anything the scene wants to draw in the window. If your
  prefs: []
  type: TYPE_NORMAL
- en: scene does not override these two methods, it will not be able to respond to
  prefs: []
  type: TYPE_NORMAL
- en: any events and will not draw anything in the window.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at the four methods you need to implement for
  prefs: []
  type: TYPE_NORMAL
- en: 'each scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '**def __init__(self, window):**'
  prefs: []
  type: TYPE_NORMAL
- en: Each scene should begin with its own __init__() method. The window
  prefs: []
  type: TYPE_NORMAL
- en: parameter is the window into which your program draws. You should
  prefs: []
  type: TYPE_NORMAL
- en: start your method with this statement to save the window parameter for
  prefs: []
  type: TYPE_NORMAL
- en: 'use in the draw() method:'
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  prefs: []
  type: TYPE_NORMAL
- en: After that, you can include any other initialization code you want or
  prefs: []
  type: TYPE_NORMAL
- en: need, such as code for instantiating buttons and text fields, loading
  prefs: []
  type: TYPE_NORMAL
- en: images and sounds, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**def getSceneKey(self):**'
  prefs: []
  type: TYPE_NORMAL
- en: This method must be implemented in every scene that you write. Your
  prefs: []
  type: TYPE_NORMAL
- en: method must return the unique scene key associated with this scene.
  prefs: []
  type: TYPE_NORMAL
- en: '**324** Chapter 15'
  prefs: []
  type: TYPE_NORMAL
- en: '**def handleInputs(self, events, keyPressedList):**'
  prefs: []
  type: TYPE_NORMAL
- en: This method must be implemented in every scene that you write. It
  prefs: []
  type: TYPE_NORMAL
- en: should do everything needed to deal with events or keys. The events
  prefs: []
  type: TYPE_NORMAL
- en: parameter is a list of events that happened since the last frame, and
  prefs: []
  type: TYPE_NORMAL
- en: keyPressedList is a list of Booleans representing the state of all keyboard
  prefs: []
  type: TYPE_NORMAL
- en: keys (True means down). To find whether a particular key is up or down,
  prefs: []
  type: TYPE_NORMAL
- en: you should use a constant rather than an integer index. The constants
  prefs: []
  type: TYPE_NORMAL
- en: representing all keys of the keyboard are available in the pygame docu-
  prefs: []
  type: TYPE_NORMAL
- en: mentation [( *https://www.pygame.org/docs/ref/key.html*).](https://www.pygame.org/docs/ref/key.html)
  prefs: []
  type: TYPE_NORMAL
- en: Your implementation of this method should contain a for loop that
  prefs: []
  type: TYPE_NORMAL
- en: loops through all events in the list that is passed in. If you want, it can
  prefs: []
  type: TYPE_NORMAL
- en: also contain code to implement the continuous mode of handling the
  prefs: []
  type: TYPE_NORMAL
- en: keyboard, as described i[n Chapter 5\.](index_split_002.html#p118)
  prefs: []
  type: TYPE_NORMAL
- en: '**def draw(self):**'
  prefs: []
  type: TYPE_NORMAL
- en: This method must be implemented in every scene that you write. It
  prefs: []
  type: TYPE_NORMAL
- en: should draw everything that needs to be drawn in the current scene.
  prefs: []
  type: TYPE_NORMAL
- en: The scene manager also calls the following methods in each scene. In
  prefs: []
  type: TYPE_NORMAL
- en: the Scene base class, these methods each contain a simple pass statement, so
  prefs: []
  type: TYPE_NORMAL
- en: they don’t do anything. You can override any or all of them to execute any
  prefs: []
  type: TYPE_NORMAL
- en: 'code you want for a particular scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '**def enter(self, data):**'
  prefs: []
  type: TYPE_NORMAL
- en: This method is called after the scene manager has made the transi-
  prefs: []
  type: TYPE_NORMAL
- en: tion into this scene. There is a single data parameter, with None as a
  prefs: []
  type: TYPE_NORMAL
- en: default. If data is not None, then the information it contains was sent
  prefs: []
  type: TYPE_NORMAL
- en: from the previous scene when it called goToScene() (described in the
  prefs: []
  type: TYPE_NORMAL
- en: next section). The value of data can take any form—from a single
  prefs: []
  type: TYPE_NORMAL
- en: string or numeric value to a list or dictionary to an object—as long
  prefs: []
  type: TYPE_NORMAL
- en: as the leaving scene and the entering scene agree on the type of data
  prefs: []
  type: TYPE_NORMAL
- en: being passed. The enter() method should do whatever it needs to do
  prefs: []
  type: TYPE_NORMAL
- en: when this scene is about to be given control.
  prefs: []
  type: TYPE_NORMAL
- en: '**def update(self):**'
  prefs: []
  type: TYPE_NORMAL
- en: This method is called in every frame. Here, you can perform any
  prefs: []
  type: TYPE_NORMAL
- en: actions you would have done in step 8 of the original 12-step template
  prefs: []
  type: TYPE_NORMAL
- en: introduced in [Chapter 5\. F](index_split_002.html#p118)or example, you might
    want this method to move images on the screen, check for collisions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**def leave(self):**'
  prefs: []
  type: TYPE_NORMAL
- en: This method is called by the scene manager whenever the program
  prefs: []
  type: TYPE_NORMAL
- en: is about to transition to a different scene. It should do any cleanup
  prefs: []
  type: TYPE_NORMAL
- en: that needs to be done before leaving, such as writing information to
  prefs: []
  type: TYPE_NORMAL
- en: a file.
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **325**
  prefs: []
  type: TYPE_NORMAL
- en: '**Navigating Between Scenes**'
  prefs: []
  type: TYPE_NORMAL
- en: The scene manager and the Scene base class provide a simple way to navi-
  prefs: []
  type: TYPE_NORMAL
- en: gate between scenes. When the program wants to transition to another
  prefs: []
  type: TYPE_NORMAL
- en: scene, the current scene should call its own goToScene() method, which is in
  prefs: []
  type: TYPE_NORMAL
- en: 'the inherited Scene base class, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: self.goToScene(nextSceneKey, data)
  prefs: []
  type: TYPE_NORMAL
- en: The goToScene() method communicates to the scene manager that you
  prefs: []
  type: TYPE_NORMAL
- en: want to transition to a different scene, whose scene key is nextSceneKey. You
  prefs: []
  type: TYPE_NORMAL
- en: should make all scene keys available via a file such as *Constants.py*. The
    data parameter is any optional information that you want to pass on to the next
  prefs: []
  type: TYPE_NORMAL
- en: scene. If no data needs to be transferred, you can eliminate this argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typical calls would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.goToScene( *SOME_SCENE_KEY*) # no data to be passed'
  prefs: []
  type: TYPE_NORMAL
- en: Or
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'self.goToScene( *ANOTHER_SCENE_KEY*, data= *someValueOrValues*) # go to a scene
    and pass data The value of data can take any form, as long as the scenes being
    left and'
  prefs: []
  type: TYPE_NORMAL
- en: entered both understand the format. In response to this call, before leav-
  prefs: []
  type: TYPE_NORMAL
- en: ing the current scene, the scene manager calls that scene’s leave() method.
  prefs: []
  type: TYPE_NORMAL
- en: When the next scene is about to be activated, the scene manager calls that
  prefs: []
  type: TYPE_NORMAL
- en: scene’s enter() method and passes the value of data to the new scene.
  prefs: []
  type: TYPE_NORMAL
- en: '**Quitting the Program**'
  prefs: []
  type: TYPE_NORMAL
- en: The scene manager takes care of three different ways that the user can quit
  prefs: []
  type: TYPE_NORMAL
- en: 'the currently running program:'
  prefs: []
  type: TYPE_NORMAL
- en: • By clicking the close button at the top of the window.
  prefs: []
  type: TYPE_NORMAL
- en: • By pressing the ESCAPE key.
  prefs: []
  type: TYPE_NORMAL
- en: • Through any additional mechanism such as a Quit button. In this case,
  prefs: []
  type: TYPE_NORMAL
- en: 'make the following call (which is also built into the Scene base class):'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.quit() # quits the program'
  prefs: []
  type: TYPE_NORMAL
- en: '***A Typical Scene***'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 15-3 shows an example of a typical scene—this is the *SceneA.py* file
    that implements Scene A in the demo program, shown in Figure 15-5\. Remember
  prefs: []
  type: TYPE_NORMAL
- en: that the main loop is implemented by the scene manager. Inside its main loop,
  prefs: []
  type: TYPE_NORMAL
- en: the scene manager calls the handleInputs(), update(), and draw() methods for
  prefs: []
  type: TYPE_NORMAL
- en: the current scene.
  prefs: []
  type: TYPE_NORMAL
- en: '**326** Chapter 15'
  prefs: []
  type: TYPE_NORMAL
- en: '**File: SceneDemo/SceneA.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Scene A
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygwidgets
  prefs: []
  type: TYPE_NORMAL
- en: import pyghelpers
  prefs: []
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  prefs: []
  type: TYPE_NORMAL
- en: from Constants import *
  prefs: []
  type: TYPE_NORMAL
- en: 'class SceneA(pyghelpers.Scene):'
  prefs: []
  type: TYPE_NORMAL
- en: '1 def __init__(self, window):'
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  prefs: []
  type: TYPE_NORMAL
- en: self.messageField = pygwidgets.DisplayText(self.window,
  prefs: []
  type: TYPE_NORMAL
- en: (15, 25), 'This is Scene A', fontSize=50,
  prefs: []
  type: TYPE_NORMAL
- en: textColor=WHITE, width=610, justified='center')
  prefs: []
  type: TYPE_NORMAL
- en: self.gotoAButton = pygwidgets.TextButton(self.window,
  prefs: []
  type: TYPE_NORMAL
- en: (250, 100), 'Go to Scene A')
  prefs: []
  type: TYPE_NORMAL
- en: self.gotoBButton = pygwidgets.TextButton(self.window,
  prefs: []
  type: TYPE_NORMAL
- en: (250, 100), 'Go to Scene B')
  prefs: []
  type: TYPE_NORMAL
- en: self.gotoCButton = pygwidgets.TextButton(self.window,
  prefs: []
  type: TYPE_NORMAL
- en: (400, 100), 'Go to Scene C')
  prefs: []
  type: TYPE_NORMAL
- en: self.gotoAButton.disable()
  prefs: []
  type: TYPE_NORMAL
- en: '2 def getSceneKey(self):'
  prefs: []
  type: TYPE_NORMAL
- en: return SCENE_A
  prefs: []
  type: TYPE_NORMAL
- en: '3 def handleInputs(self, eventsList, keyPressedList):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for event in eventsList:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.gotoBButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: 4 self.goToScene(SCENE_B)
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.gotoCButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: 5 self.goToScene(SCENE_C)
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip (testing code to send messages) ---'
  prefs: []
  type: TYPE_NORMAL
- en: '6 def draw(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.window.fill(GRAYA)
  prefs: []
  type: TYPE_NORMAL
- en: self.messageField.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.gotoAButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.gotoBButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.gotoCButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip (testing code to respond to messages) ---'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-3: A typical scene (Scene A in the Scene Demo program)*'
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **327**
  prefs: []
  type: TYPE_NORMAL
- en: In the __init__() method 1, we save away the window parameter in an instance
    variable. We then create an instance of a DisplayText field to show a
  prefs: []
  type: TYPE_NORMAL
- en: title and create some TextButtons to allow for navigation to the other scenes.
  prefs: []
  type: TYPE_NORMAL
- en: The getSceneKey() method 2 just returns the unique scene key (found
  prefs: []
  type: TYPE_NORMAL
- en: in *Constants.py*) for this scene. In the handleInputs() method 3, if the user
    has clicked the button for a different scene, we call the self.goToScene()
  prefs: []
  type: TYPE_NORMAL
- en: navigation method 4 5 to transfer control to the new scene. In the draw()
  prefs: []
  type: TYPE_NORMAL
- en: method 6, we fill the background, draw the message field, and draw the
  prefs: []
  type: TYPE_NORMAL
- en: buttons. This example scene does very little, so we don’t need to write our
  prefs: []
  type: TYPE_NORMAL
- en: own enter(), update(), and leave() methods. Calls to these methods will be
  prefs: []
  type: TYPE_NORMAL
- en: handled by methods of the same names in the Scene base class, and those
  prefs: []
  type: TYPE_NORMAL
- en: methods don’t do anything—they simply execute a pass statement.
  prefs: []
  type: TYPE_NORMAL
- en: The two other scene files are *SceneB.py* and *SceneC.py*. The only differences
    are the titles shown, the buttons drawn, and the effects of clicking the
  prefs: []
  type: TYPE_NORMAL
- en: buttons to transfer to the appropriate new scene.
  prefs: []
  type: TYPE_NORMAL
- en: '**Rock, Paper, Scissors Using Scenes**'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s build an alternate implementation of the Rock, Paper, Scissors game
  prefs: []
  type: TYPE_NORMAL
- en: using the scene manager. To the user, the game will work exactly the same
  prefs: []
  type: TYPE_NORMAL
- en: way as the earlier state machine version. We’ll build a Splash scene, a Play
  prefs: []
  type: TYPE_NORMAL
- en: scene, and a Results scene.
  prefs: []
  type: TYPE_NORMAL
- en: All of the source code is available, so I won’t go through every Python
  prefs: []
  type: TYPE_NORMAL
- en: file. The Splash scene is just a background picture with a Start button. When
  prefs: []
  type: TYPE_NORMAL
- en: the user presses the Start button, the code executes goToScene(SCENE_PLAY) to
  prefs: []
  type: TYPE_NORMAL
- en: transfer to the Play scene. In the Play scene, the user is presented with a
    set
  prefs: []
  type: TYPE_NORMAL
- en: of images (rock, paper, and scissors) and asked to choose one. Clicking an
  prefs: []
  type: TYPE_NORMAL
- en: image transfers control to the Results scene. Listing 15-4 contains the code
  prefs: []
  type: TYPE_NORMAL
- en: of the Play scene.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: RockPaperScissorsWithScenes/ScenePlay.py**'
  prefs: []
  type: TYPE_NORMAL
- en: The Play scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The player chooses among rock, paper, or scissors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygwidgets
  prefs: []
  type: TYPE_NORMAL
- en: import pyghelpers
  prefs: []
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: from Constants import *
  prefs: []
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: 'class ScenePlay(pyghelpers.Scene):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window):'
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  prefs: []
  type: TYPE_NORMAL
- en: self.RPSTuple = (ROCK, PAPER, SCISSORS)
  prefs: []
  type: TYPE_NORMAL
- en: '**328** Chapter 15'
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  prefs: []
  type: TYPE_NORMAL
- en: 'def getSceneKey(self): 1'
  prefs: []
  type: TYPE_NORMAL
- en: return SCENE_PLAY
  prefs: []
  type: TYPE_NORMAL
- en: 'def handleInputs(self, eventsList, keyPressedList): 2'
  prefs: []
  type: TYPE_NORMAL
- en: playerChoice = None
  prefs: []
  type: TYPE_NORMAL
- en: 'for event in eventsList:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.rockButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: playerChoice = ROCK
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.paperButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: playerChoice = PAPER
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.scissorButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: playerChoice = SCISSORS
  prefs: []
  type: TYPE_NORMAL
- en: 'if playerChoice is not None: 3 # user has made a choice'
  prefs: []
  type: TYPE_NORMAL
- en: 'computerChoice = random.choice(self.RPSTuple) # computer chooses'
  prefs: []
  type: TYPE_NORMAL
- en: 'dataDict = {''player'': playerChoice, ''computer'': computerChoice} 4'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.goToScene(SCENE_RESULTS, dataDict) 5 # go to Results scene'
  prefs: []
  type: TYPE_NORMAL
- en: No need to include update method, defaults to inherited one which does nothing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def draw(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.window.fill(GRAY)
  prefs: []
  type: TYPE_NORMAL
- en: self.titleField.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.rockButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.paperButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.scissorButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.messageField.draw()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-4: The Play scene in Rock, Paper, Scissors*'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve snipped the code to create text fields and the rock, paper, and scis-
  prefs: []
  type: TYPE_NORMAL
- en: sors buttons. The getSceneKey() method 1 simply returns the scene key for
  prefs: []
  type: TYPE_NORMAL
- en: this scene.
  prefs: []
  type: TYPE_NORMAL
- en: The most important method is handleInputs() 2, which is called in every
  prefs: []
  type: TYPE_NORMAL
- en: frame. If any button is clicked, we set a variable named playerChoice to an
  prefs: []
  type: TYPE_NORMAL
- en: appropriate constant 3, and we make a random choice for the computer.
  prefs: []
  type: TYPE_NORMAL
- en: We then take the player’s choice and the computer’s choice and build a
  prefs: []
  type: TYPE_NORMAL
- en: simple dictionary 4 incorporating both, so we can pass this information
  prefs: []
  type: TYPE_NORMAL
- en: as data to the Results scene. Finally, to transfer to the Results scene, we
    call
  prefs: []
  type: TYPE_NORMAL
- en: goToScene() and pass the dictionary 5\.
  prefs: []
  type: TYPE_NORMAL
- en: The scene manager receives this call, calls leave() for the current scene
  prefs: []
  type: TYPE_NORMAL
- en: (Play), changes the current scene to the new scene (Results), and calls enter()
  prefs: []
  type: TYPE_NORMAL
- en: for the new scene (Results). It passes the data from the leaving scene into
    the
  prefs: []
  type: TYPE_NORMAL
- en: enter() method of the new scene.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 15-5 contains the code of the Results scene. There’s a lot of code
  prefs: []
  type: TYPE_NORMAL
- en: here, but most of it deals with showing the appropriate icons and the evalu-
  prefs: []
  type: TYPE_NORMAL
- en: ation of the results of the round.
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **329**
  prefs: []
  type: TYPE_NORMAL
- en: '**File: RockPaperScissorsWithScenes/SceneResults.py**'
  prefs: []
  type: TYPE_NORMAL
- en: The Results scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The player is shown the results of the current round
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygwidgets
  prefs: []
  type: TYPE_NORMAL
- en: import pyghelpers
  prefs: []
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: from Constants import *
  prefs: []
  type: TYPE_NORMAL
- en: 'class SceneResults(pyghelpers.Scene):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window, sceneKey):'
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  prefs: []
  type: TYPE_NORMAL
- en: self.playerScore = 0
  prefs: []
  type: TYPE_NORMAL
- en: self.computerScore = 0
  prefs: []
  type: TYPE_NORMAL
- en: 1 self.rpsCollectionPlayer = pygwidgets.ImageCollection(
  prefs: []
  type: TYPE_NORMAL
- en: window, (50, 62),
  prefs: []
  type: TYPE_NORMAL
- en: '{ROCK: ''images/Rock.png'','
  prefs: []
  type: TYPE_NORMAL
- en: 'PAPER: ''images/Paper.png'','
  prefs: []
  type: TYPE_NORMAL
- en: 'SCISSORS: ''images/Scissors.png''}, '''')'
  prefs: []
  type: TYPE_NORMAL
- en: self.rpsCollectionComputer = pygwidgets.ImageCollection(
  prefs: []
  type: TYPE_NORMAL
- en: window, (350, 62),
  prefs: []
  type: TYPE_NORMAL
- en: '{ROCK: ''images/Rock.png'','
  prefs: []
  type: TYPE_NORMAL
- en: 'PAPER: ''images/Paper.png'','
  prefs: []
  type: TYPE_NORMAL
- en: 'SCISSORS: ''images/Scissors.png''}, '''')'
  prefs: []
  type: TYPE_NORMAL
- en: self.youComputerField = pygwidgets.DisplayText(
  prefs: []
  type: TYPE_NORMAL
- en: window, (22, 25),
  prefs: []
  type: TYPE_NORMAL
- en: '''You Computer'','
  prefs: []
  type: TYPE_NORMAL
- en: fontSize=50, textColor=WHITE,
  prefs: []
  type: TYPE_NORMAL
- en: width=610, justified='center')
  prefs: []
  type: TYPE_NORMAL
- en: self.resultsField = pygwidgets.DisplayText(
  prefs: []
  type: TYPE_NORMAL
- en: self.window, (20, 275), '',
  prefs: []
  type: TYPE_NORMAL
- en: fontSize=50, textColor=WHITE,
  prefs: []
  type: TYPE_NORMAL
- en: width=610, justified='center')
  prefs: []
  type: TYPE_NORMAL
- en: self.restartButton = pygwidgets.CustomButton(
  prefs: []
  type: TYPE_NORMAL
- en: self.window, (220, 310),
  prefs: []
  type: TYPE_NORMAL
- en: up='images/restartButtonUp.png',
  prefs: []
  type: TYPE_NORMAL
- en: down='images/restartButtonDown.png'
  prefs: []
  type: TYPE_NORMAL
- en: over='images/restartButtonHighlight.png')
  prefs: []
  type: TYPE_NORMAL
- en: self.playerScoreCounter = pygwidgets.DisplayText(
  prefs: []
  type: TYPE_NORMAL
- en: self.window, (86, 315), 'Score:',
  prefs: []
  type: TYPE_NORMAL
- en: fontSize=50, textColor=WHITE)
  prefs: []
  type: TYPE_NORMAL
- en: self.computerScoreCounter = pygwidgets.DisplayText(
  prefs: []
  type: TYPE_NORMAL
- en: self.window, (384, 315), 'Score:',
  prefs: []
  type: TYPE_NORMAL
- en: fontSize=50, textColor=WHITE)
  prefs: []
  type: TYPE_NORMAL
- en: '**330** Chapter 15'
  prefs: []
  type: TYPE_NORMAL
- en: Sounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.winnerSound = pygame.mixer.Sound("sounds/ding.wav")
  prefs: []
  type: TYPE_NORMAL
- en: self.tieSound = pygame.mixer.Sound("sounds/push.wav")
  prefs: []
  type: TYPE_NORMAL
- en: self.loserSound = pygame.mixer.Sound("sounds/buzz.wav")
  prefs: []
  type: TYPE_NORMAL
- en: '2 def enter(self, data):'
  prefs: []
  type: TYPE_NORMAL
- en: 'data is a dictionary (comes from the Play scene) that looks like:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '{''player'': playerChoice, ''computer'': computerChoice}'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: playerChoice = data['player']
  prefs: []
  type: TYPE_NORMAL
- en: computerChoice = data['computer']
  prefs: []
  type: TYPE_NORMAL
- en: Set the player and computer images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 self.rpsCollectionPlayer.replace(playerChoice)
  prefs: []
  type: TYPE_NORMAL
- en: self.rpsCollectionComputer.replace(computerChoice)
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate the game's win/lose/tie conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '4 if playerChoice == computerChoice:'
  prefs: []
  type: TYPE_NORMAL
- en: self.resultsField.setValue("It's a tie!")
  prefs: []
  type: TYPE_NORMAL
- en: self.tieSound.play()
  prefs: []
  type: TYPE_NORMAL
- en: 'elif playerChoice == ROCK and computerChoice == SCISSORS:'
  prefs: []
  type: TYPE_NORMAL
- en: self.resultsField.setValue("Rock breaks Scissors. You win!")
  prefs: []
  type: TYPE_NORMAL
- en: self.playerScore = self.playerScore + 1
  prefs: []
  type: TYPE_NORMAL
- en: self.winnerSound.play()
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  prefs: []
  type: TYPE_NORMAL
- en: Show the player's and computer's scores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.playerScoreCounter.setValue(
  prefs: []
  type: TYPE_NORMAL
- en: '''Score: '' + str(self.playerScore))'
  prefs: []
  type: TYPE_NORMAL
- en: self.computerScoreCounter.setValue(
  prefs: []
  type: TYPE_NORMAL
- en: '''Score: '' + str(self.computerScore))'
  prefs: []
  type: TYPE_NORMAL
- en: '5 def handleInputs(self, eventsList, keyPressedList):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for event in eventsList:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.restartButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: self.goToScene(SCENE_PLAY)
  prefs: []
  type: TYPE_NORMAL
- en: No need to include update method,
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: defaults to inherited one which does nothing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6 def draw(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.window.fill(OTHER_GRAY)
  prefs: []
  type: TYPE_NORMAL
- en: self.youComputerField.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.resultsField.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.rpsCollectionPlayer.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.rpsCollectionComputer.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.playerScoreCounter.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.computerScoreCounter.draw()
  prefs: []
  type: TYPE_NORMAL
- en: self.restartButton.draw()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-5: The Results scene in Rock, Paper, Scissors*'
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **331**
  prefs: []
  type: TYPE_NORMAL
- en: Here, I’ve snipped some of the game evaluation logic. The enter()
  prefs: []
  type: TYPE_NORMAL
- en: method 2 is the most important method in this class. When the player
  prefs: []
  type: TYPE_NORMAL
- en: makes a choice in the previous Play scene, the program transitions to this
  prefs: []
  type: TYPE_NORMAL
- en: Results scene. First, we extract the player’s and computer’s choices that were
  prefs: []
  type: TYPE_NORMAL
- en: 'passed in from the Play scene as a dictionary, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '{''player'': playerChoice, ''computer'': computerChoice}'
  prefs: []
  type: TYPE_NORMAL
- en: In the __init__() method 1, we create ImageCollection objects for the
  prefs: []
  type: TYPE_NORMAL
- en: player and computer, each containing the rock, paper, and scissors images.
  prefs: []
  type: TYPE_NORMAL
- en: In the enter() method 2, we use the replace() method of ImageCollection 3
  prefs: []
  type: TYPE_NORMAL
- en: to show the images that represent the player’s and the computer’s choices.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the evaluation is quite simple 4\. If the computer and the player
  prefs: []
  type: TYPE_NORMAL
- en: made the same choice, we have a tie, and we play an appropriate tie sound.
  prefs: []
  type: TYPE_NORMAL
- en: If the player wins, we increment the player’s score and play a happy sound.
  prefs: []
  type: TYPE_NORMAL
- en: If the computer wins, we increment the computer’s score and play a sad
  prefs: []
  type: TYPE_NORMAL
- en: sound. We update the player’s or the computer’s score and show the scores
  prefs: []
  type: TYPE_NORMAL
- en: in the matching text display fields.
  prefs: []
  type: TYPE_NORMAL
- en: After the enter() method runs (one time for each round), the
  prefs: []
  type: TYPE_NORMAL
- en: handleInputs() method 5 is called in every frame by the scene manager.
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks Restart, we call the inherited goToScene() method
  prefs: []
  type: TYPE_NORMAL
- en: to transfer back to the Play scene.
  prefs: []
  type: TYPE_NORMAL
- en: The draw() method 6 draws everything in the window for this scene.
  prefs: []
  type: TYPE_NORMAL
- en: In this scene, we don’t do any additional work in each frame, so we don’t
  prefs: []
  type: TYPE_NORMAL
- en: need to write an update() method. When the scene manager calls update(),
  prefs: []
  type: TYPE_NORMAL
- en: the inherited method in the Scene base class runs and just executes a pass
  prefs: []
  type: TYPE_NORMAL
- en: statement.
  prefs: []
  type: TYPE_NORMAL
- en: '**Communication Between Scenes**'
  prefs: []
  type: TYPE_NORMAL
- en: The scene manager provides a set of methods that allow scenes to com-
  prefs: []
  type: TYPE_NORMAL
- en: municate with each other by sending or requesting information. This com-
  prefs: []
  type: TYPE_NORMAL
- en: munication won’t be needed by all programs but can be highly useful. The
  prefs: []
  type: TYPE_NORMAL
- en: 'scene manager allows any scene to:'
  prefs: []
  type: TYPE_NORMAL
- en: • Request information from another scene
  prefs: []
  type: TYPE_NORMAL
- en: • Send information to another scene
  prefs: []
  type: TYPE_NORMAL
- en: • Send information to all other scenes
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, I’ll call the scene the user is seeing the *cur-*
  prefs: []
  type: TYPE_NORMAL
- en: '*rent* scene. The scene that the current scene is sending information to or'
  prefs: []
  type: TYPE_NORMAL
- en: requesting information from is the *target* scene. The methods used to trans-
  prefs: []
  type: TYPE_NORMAL
- en: fer information are all implemented in the Scene base class. Therefore, all
  prefs: []
  type: TYPE_NORMAL
- en: scenes (which must inherit from the Scene base class) have access to these
  prefs: []
  type: TYPE_NORMAL
- en: methods using self. *<method>* ().
  prefs: []
  type: TYPE_NORMAL
- en: '**332** Chapter 15'
  prefs: []
  type: TYPE_NORMAL
- en: '***Requesting Information from a Target Scene***'
  prefs: []
  type: TYPE_NORMAL
- en: To request information from any other scene, a scene makes a call to the
  prefs: []
  type: TYPE_NORMAL
- en: 'inherited request() method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: self.request(targetSceneKey, requestID)
  prefs: []
  type: TYPE_NORMAL
- en: This call allows the current scene to ask for information from a target
  prefs: []
  type: TYPE_NORMAL
- en: scene, identified by its scene key (targetSceneKey). The requestID uniquely
  prefs: []
  type: TYPE_NORMAL
- en: identifies the information you are asking for. The value used for a requestID
  prefs: []
  type: TYPE_NORMAL
- en: would normally be a constant defined in a file like *Constants.py*. The call
  prefs: []
  type: TYPE_NORMAL
- en: 'returns the requested information. A typical call would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: someData = self.request( *SOME_SCENE_KEY*, *SOME_INFO_CONSTANT*)
  prefs: []
  type: TYPE_NORMAL
- en: This effectively says, “Issue a request to the *SOME_SCENE_KEY* scene asking
  prefs: []
  type: TYPE_NORMAL
- en: for information identified by *SOME_INFO_CONSTANT*.” The data is returned and
    assigned to the someData variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scene manager acts as an intermediary: it receives the call to'
  prefs: []
  type: TYPE_NORMAL
- en: request() and turns it into a call to respond() in the target scene. To make
  prefs: []
  type: TYPE_NORMAL
- en: a target scene able to give information, you must implement a respond()
  prefs: []
  type: TYPE_NORMAL
- en: 'method in that scene’s class. The method should start like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def respond(self, requestID):'
  prefs: []
  type: TYPE_NORMAL
- en: The typical code of a respond() method checks the value of the requestID
  prefs: []
  type: TYPE_NORMAL
- en: parameter and returns the appropriate data. The data returned can be for-
  prefs: []
  type: TYPE_NORMAL
- en: matted in any way that the current scene and the target scene agree on.
  prefs: []
  type: TYPE_NORMAL
- en: '***Sending Information to a Target Scene***'
  prefs: []
  type: TYPE_NORMAL
- en: To send information to a target scene, the current scene makes a call to the
  prefs: []
  type: TYPE_NORMAL
- en: 'inherited send() method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: self.send(targetSceneKey, sendID, info)
  prefs: []
  type: TYPE_NORMAL
- en: This call allows the current scene to send information to a target scene,
  prefs: []
  type: TYPE_NORMAL
- en: identified by its scene key (targetSceneKey). The sendID uniquely identifies
    the
  prefs: []
  type: TYPE_NORMAL
- en: information you are sending. The info parameter is the information you
  prefs: []
  type: TYPE_NORMAL
- en: want to send to the target scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical call would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: self.send( *SOME_SCENE_KEY*, *SOME_INFO_CONSTANT*, data)
  prefs: []
  type: TYPE_NORMAL
- en: This effectively says, “Send information to the *SOME_SCENE_KEY* scene. The
  prefs: []
  type: TYPE_NORMAL
- en: information is identified by *SOME_INFO_CONSTANT*, and the information is in
    the value of the variable data.”
  prefs: []
  type: TYPE_NORMAL
- en: The scene manager receives the call to send() and turns it into a call
  prefs: []
  type: TYPE_NORMAL
- en: to receive() in the target scene. To allow a scene to send information to
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **333**
  prefs: []
  type: TYPE_NORMAL
- en: 'another scene, you must implement a receive() method in your target scene class,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def receive(self, receiveID, info):'
  prefs: []
  type: TYPE_NORMAL
- en: The receive() method can contain an if/elif/else construct if it needs
  prefs: []
  type: TYPE_NORMAL
- en: to handle different values for receiveID. The transmitted information can be
  prefs: []
  type: TYPE_NORMAL
- en: formatted in any way that the current scene and the target scene agree on.
  prefs: []
  type: TYPE_NORMAL
- en: '***Sending Information to All Scenes***'
  prefs: []
  type: TYPE_NORMAL
- en: As an additional convenience, a scene can send information to all other
  prefs: []
  type: TYPE_NORMAL
- en: 'scenes using the single method sendAll():'
  prefs: []
  type: TYPE_NORMAL
- en: self.sendAll(sendID, info)
  prefs: []
  type: TYPE_NORMAL
- en: This call allows the current scene to send information to all the other
  prefs: []
  type: TYPE_NORMAL
- en: scenes. The sendID uniquely identifies the information you are sending. The
  prefs: []
  type: TYPE_NORMAL
- en: info parameter is the information you want to send to all scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical call would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: self.sendAll( *SOME_INFO_CONSTANT*, data)
  prefs: []
  type: TYPE_NORMAL
- en: This effectively says, “Send information to all scenes. The information
  prefs: []
  type: TYPE_NORMAL
- en: is identified by *SOME_INFO_CONSTANT*, and the information is in the value of
    the variable data.”
  prefs: []
  type: TYPE_NORMAL
- en: For this to work, all scenes other than the current scene must implement
  prefs: []
  type: TYPE_NORMAL
- en: the receive() method, as described in the previous section. The scene manager
  prefs: []
  type: TYPE_NORMAL
- en: sends the message to all scenes (other than the current scene). The current
  prefs: []
  type: TYPE_NORMAL
- en: scene may contain a receive() method for information sent by other scenes.
  prefs: []
  type: TYPE_NORMAL
- en: '***Testing Communications Among Scenes***'
  prefs: []
  type: TYPE_NORMAL
- en: The Scene Demo program (with Scene A, Scene B, and Scene C), discussed
  prefs: []
  type: TYPE_NORMAL
- en: earlier with Listings 15-2 and 15-3, contains code in each scene that demon-
  prefs: []
  type: TYPE_NORMAL
- en: strates calls to send(), request(), and sendAll(). In addition, the scenes each
  prefs: []
  type: TYPE_NORMAL
- en: implement simple versions of the receive() and respond() methods. In the demo
  prefs: []
  type: TYPE_NORMAL
- en: program, you can send a message to another scene by pressing A, B, or C.
  prefs: []
  type: TYPE_NORMAL
- en: Pressing X sends a message to all scenes. Pressing 1, 2, or 3 sends a request
  prefs: []
  type: TYPE_NORMAL
- en: to get data from a target scene. The target scene responds with a string.
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation of the Scene Manager**'
  prefs: []
  type: TYPE_NORMAL
- en: Here we’ll look at how the scene manager is implemented. However, one
  prefs: []
  type: TYPE_NORMAL
- en: important lesson of OOP is that the developer of client code doesn’t need to
  prefs: []
  type: TYPE_NORMAL
- en: understand the implementation of a class, only the interface. With respect to
  prefs: []
  type: TYPE_NORMAL
- en: the scene manager, you don’t need to know how it works, only what methods
  prefs: []
  type: TYPE_NORMAL
- en: you must implement in your scenes, when they are called, and what methods
  prefs: []
  type: TYPE_NORMAL
- en: you can call. Therefore, if you’re not interested in the internals, you can
    go
  prefs: []
  type: TYPE_NORMAL
- en: right to the Summary. If you are interested, this section goes through the
  prefs: []
  type: TYPE_NORMAL
- en: '**334** Chapter 15'
  prefs: []
  type: TYPE_NORMAL
- en: implementation details, and along the way you’ll learn an interesting technique
    to allow for two-way communication between objects.
  prefs: []
  type: TYPE_NORMAL
- en: The scene manager is implemented in a class named SceneMgr in the
  prefs: []
  type: TYPE_NORMAL
- en: pyghelpers module. As explained previously, in your main program, you cre-
  prefs: []
  type: TYPE_NORMAL
- en: 'ate a single instance of the scene manager like this:'
  prefs: []
  type: TYPE_NORMAL
- en: oSceneMgr = SceneMgr(scenesList, FRAMES_PER_SECOND)
  prefs: []
  type: TYPE_NORMAL
- en: 'The last line of your main program needs to be:'
  prefs: []
  type: TYPE_NORMAL
- en: oSceneMgr.run()
  prefs: []
  type: TYPE_NORMAL
- en: Listing 15-6 contains the code of the __init__() method of the SceneMgr
  prefs: []
  type: TYPE_NORMAL
- en: class.
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, scenesList, fps):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Build a dictionary, each entry of which is a sceneKey : scene object'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 self.scenesDict = {}
  prefs: []
  type: TYPE_NORMAL
- en: '2 for oScene in scenesList:'
  prefs: []
  type: TYPE_NORMAL
- en: key = oScene.getSceneKey()
  prefs: []
  type: TYPE_NORMAL
- en: self.scenesDict[key] = oScene
  prefs: []
  type: TYPE_NORMAL
- en: The first element in the list is used as the starting scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 self.oCurrentScene = scenesList[0]
  prefs: []
  type: TYPE_NORMAL
- en: self.framesPerSecond = fps
  prefs: []
  type: TYPE_NORMAL
- en: Give each scene a reference back to the SceneMgr.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This allows any scene to do a goToScene, request, send,
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: or sendAll, which gets forwarded to the scene manager.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '4 for key, oScene in self.scenesDict.items():'
  prefs: []
  type: TYPE_NORMAL
- en: oScene._setRefToSceneMgr(self)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-6: The __init__() method of the SceneMgr class*'
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() method keeps track of all scenes in a dictionary 1\. It
  prefs: []
  type: TYPE_NORMAL
- en: iterates through the list of scenes, asking each scene for its scene key, and
  prefs: []
  type: TYPE_NORMAL
- en: builds a dictionary 2\. The first scene object in the list of scenes is used
    as
  prefs: []
  type: TYPE_NORMAL
- en: the starting scene 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the __init__() method does some interesting work. The
  prefs: []
  type: TYPE_NORMAL
- en: scene manager holds a reference to every scene, so it can send messages to
  prefs: []
  type: TYPE_NORMAL
- en: any and every scene. But every scene also needs to be able to send messages
  prefs: []
  type: TYPE_NORMAL
- en: to the scene manager. To allow each scene to do that, the last for loop in
  prefs: []
  type: TYPE_NORMAL
- en: the __init__() method calls the special method _setRefToSceneMgr() 4 that
  prefs: []
  type: TYPE_NORMAL
- en: lives in the base class of every scene, and it passes self, which is a reference
  prefs: []
  type: TYPE_NORMAL
- en: 'to the scene manager. The entire code of this method consists of a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def _setRefToSceneMgr(self, oSceneMgr):'
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  prefs: []
  type: TYPE_NORMAL
- en: self.oSceneMgr = oSceneMgr
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **335**
  prefs: []
  type: TYPE_NORMAL
- en: This method just stores this reference back to the scene manager in an instance
    variable, self.oSceneMgr. Each scene can use this variable to make
  prefs: []
  type: TYPE_NORMAL
- en: calls to the scene manager. I’ll show how scenes use this a little later in
    this
  prefs: []
  type: TYPE_NORMAL
- en: section.
  prefs: []
  type: TYPE_NORMAL
- en: '***run() Method***'
  prefs: []
  type: TYPE_NORMAL
- en: For every project you build, you have to write a small main program that
  prefs: []
  type: TYPE_NORMAL
- en: instantiates the scene manager. The last step in your main program is a call
  prefs: []
  type: TYPE_NORMAL
- en: to the run() method of the scene manager. This is where the main loop of
  prefs: []
  type: TYPE_NORMAL
- en: the whole program lives. Listing 15-7 contains the code of that method.
  prefs: []
  type: TYPE_NORMAL
- en: 'def run(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  prefs: []
  type: TYPE_NORMAL
- en: clock = pygame.time.Clock()
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 keysDownList = pygame.key.get_pressed()
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2 eventsList = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  prefs: []
  type: TYPE_NORMAL
- en: if (event.type == pygame.QUIT) or \
  prefs: []
  type: TYPE_NORMAL
- en: ((event.type == pygame.KEYDOWN) and
  prefs: []
  type: TYPE_NORMAL
- en: '(event.key == pygame.K_ESCAPE)):'
  prefs: []
  type: TYPE_NORMAL
- en: Tell the current scene we're leaving
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.oCurrentScene.leave()
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: eventsList.append(event)
  prefs: []
  type: TYPE_NORMAL
- en: Here, we let the current scene process all events,
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: do any "per frame" actions in its update method,
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: and draw everything that needs to be drawn.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 self.oCurrentScene.handleInputs(eventsList, keysDownList)
  prefs: []
  type: TYPE_NORMAL
- en: 4 self.oCurrentScene.update()
  prefs: []
  type: TYPE_NORMAL
- en: 5 self.oCurrentScene.draw()
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 6 pygame.display.update()
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: clock.tick(self.framesPerSecond)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-7: The run() method of the SceneMgr class*'
  prefs: []
  type: TYPE_NORMAL
- en: '**336** Chapter 15'
  prefs: []
  type: TYPE_NORMAL
- en: The run() method is the key to how the scene manager works. Remember that all
    scenes must be polymorphic—at a minimum, each must implement
  prefs: []
  type: TYPE_NORMAL
- en: a handleInputs() and a draw() method. Each time through the loop, the run()
  prefs: []
  type: TYPE_NORMAL
- en: 'method does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • Gets a list of all keyboard keys 1 (False means up, True means down).
  prefs: []
  type: TYPE_NORMAL
- en: • Builds a list of events 2 that have happened since the last time through
  prefs: []
  type: TYPE_NORMAL
- en: the loop.
  prefs: []
  type: TYPE_NORMAL
- en: • Makes calls to the polymorphic methods 3 of the current scene. The cur-
  prefs: []
  type: TYPE_NORMAL
- en: rent scene is always kept in an instance variable named self.oCurrentScene.
  prefs: []
  type: TYPE_NORMAL
- en: In the call to the scene’s handleInputs() method, the scene manager
  prefs: []
  type: TYPE_NORMAL
- en: passes in the list of events that have happened and the list of keys. Each
  prefs: []
  type: TYPE_NORMAL
- en: scene is responsible for handling the events and for dealing with the
  prefs: []
  type: TYPE_NORMAL
- en: state of the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: • Calls the update() method 4 to allow the scene to do any per-frame
  prefs: []
  type: TYPE_NORMAL
- en: actions. The Scene base class implements an update() method that just
  prefs: []
  type: TYPE_NORMAL
- en: contains a pass statement, but a scene can override this method with
  prefs: []
  type: TYPE_NORMAL
- en: any code it wants to execute.
  prefs: []
  type: TYPE_NORMAL
- en: • Calls the draw() method 5 to allow the scene to draw anything it needs
  prefs: []
  type: TYPE_NORMAL
- en: to draw in the window.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the loop (identical to the standard main loop with-
  prefs: []
  type: TYPE_NORMAL
- en: out a scene manager), the method updates the window 6 and waits for an
  prefs: []
  type: TYPE_NORMAL
- en: appropriate amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: '***Main Methods***'
  prefs: []
  type: TYPE_NORMAL
- en: The remaining methods of the SceneMgr class implement the navigation and
  prefs: []
  type: TYPE_NORMAL
- en: 'communication between scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**_goToScene()** Called to transfer to a different scene'
  prefs: []
  type: TYPE_NORMAL
- en: '**_request_respond()** Called to query data in another scene'
  prefs: []
  type: TYPE_NORMAL
- en: '**_send_receive()** Called to send information from one scene to another'
  prefs: []
  type: TYPE_NORMAL
- en: '**_sendAll_receive()** Called to send information from one scene to all'
  prefs: []
  type: TYPE_NORMAL
- en: other scenes
  prefs: []
  type: TYPE_NORMAL
- en: The code of any scenes that you write should not call these methods
  prefs: []
  type: TYPE_NORMAL
- en: directly, and they should not be overwritten. The underscore in front of
  prefs: []
  type: TYPE_NORMAL
- en: their names implies that these are private (internal) methods. While they
  prefs: []
  type: TYPE_NORMAL
- en: are not called directly within the scene manager itself, they are called by
  prefs: []
  type: TYPE_NORMAL
- en: the Scene base class.
  prefs: []
  type: TYPE_NORMAL
- en: To explain how these methods work, I’ll start by giving an overview
  prefs: []
  type: TYPE_NORMAL
- en: of the steps involved when a scene wants to navigate to another scene. To
  prefs: []
  type: TYPE_NORMAL
- en: 'make a transition to a target scene, the current scene calls:'
  prefs: []
  type: TYPE_NORMAL
- en: self.goToScene( *SOME_SCENE_KEY*)
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **337**
  prefs: []
  type: TYPE_NORMAL
- en: When a scene makes this call, the call goes to the goToScene() method in the
    inherited Scene base class. The code of the inherited method consists of
  prefs: []
  type: TYPE_NORMAL
- en: 'a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def goToScene(self, nextSceneKey, data=None):'
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  prefs: []
  type: TYPE_NORMAL
- en: self.oSceneMgr._goToScene(nextSceneKey, data)
  prefs: []
  type: TYPE_NORMAL
- en: This makes a call to the private _goToScene() method in the scene man-
  prefs: []
  type: TYPE_NORMAL
- en: ager. Within the scene manager’s method, we need to give the current
  prefs: []
  type: TYPE_NORMAL
- en: scene an opportunity to do any cleanup that might be needed, then trans-
  prefs: []
  type: TYPE_NORMAL
- en: fer control to the new scene. Here is the code of the _goToScene() method of
  prefs: []
  type: TYPE_NORMAL
- en: 'the scene manager:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def _goToScene(self, nextSceneKey, dataForNextScene):'
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  prefs: []
  type: TYPE_NORMAL
- en: 'if nextSceneKey is None: # meaning, exit'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: Call the leave method of the old scene to allow it to clean up.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Set the new scene (based on the key) and
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: call the enter method of the new scene.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 self.oCurrentScene.leave()
  prefs: []
  type: TYPE_NORMAL
- en: 'pygame.key.set_repeat(0) # turn off repeating characters'
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  prefs: []
  type: TYPE_NORMAL
- en: 2 self.oCurrentScene = self.scenesDict[nextSceneKey]
  prefs: []
  type: TYPE_NORMAL
- en: 'except KeyError:'
  prefs: []
  type: TYPE_NORMAL
- en: raise KeyError("Trying to go to scene '" + nextSceneKey +
  prefs: []
  type: TYPE_NORMAL
- en: '"'' but that key is not in the dictionary of scenes.")'
  prefs: []
  type: TYPE_NORMAL
- en: 3 self.oCurrentScene.enter(dataForNextScene)
  prefs: []
  type: TYPE_NORMAL
- en: The _goToScene() method performs a number of steps to transition
  prefs: []
  type: TYPE_NORMAL
- en: from the current scene to the target scene. First, it calls leave() in the cur-
  prefs: []
  type: TYPE_NORMAL
- en: rent scene 1 so the current scene can do any necessary cleanup. Then,
  prefs: []
  type: TYPE_NORMAL
- en: using the target scene key that was passed in, it finds the object for the target
  prefs: []
  type: TYPE_NORMAL
- en: scene 2 and sets that as the current scene. Finally, it calls enter() for the
    new
  prefs: []
  type: TYPE_NORMAL
- en: current scene 3 to allow the new current scene to do any required setup.
  prefs: []
  type: TYPE_NORMAL
- en: From this point on, the run() method of the scene manager loops and
  prefs: []
  type: TYPE_NORMAL
- en: calls the handleInputs(), update(), and draw() methods of the current scene.
  prefs: []
  type: TYPE_NORMAL
- en: These methods will be called in the current scene until the program exe-
  prefs: []
  type: TYPE_NORMAL
- en: cutes another call to self.goToScene() to transition to yet another scene or
  prefs: []
  type: TYPE_NORMAL
- en: the user quits the program.
  prefs: []
  type: TYPE_NORMAL
- en: '***Communication Between Scenes***'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s discuss how one scene communicates with another scene. To
  prefs: []
  type: TYPE_NORMAL
- en: request information from another scene, a scene only needs to make a call
  prefs: []
  type: TYPE_NORMAL
- en: 'to self.request(), which lives in the Scene base class, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: dataRequested = self.request( *SOME_SCENE_KEY*, *SOME_DATA_IDENTIFIER*)
  prefs: []
  type: TYPE_NORMAL
- en: '**338** Chapter 15'
  prefs: []
  type: TYPE_NORMAL
- en: 'The target scene must have a respond() method. That method needs to be defined
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'def respond(self, requestID):'
  prefs: []
  type: TYPE_NORMAL
- en: It uses the value of requestID to uniquely identify what data to retrieve
  prefs: []
  type: TYPE_NORMAL
- en: and returns that data. Again, the requesting scene and the target scene
  prefs: []
  type: TYPE_NORMAL
- en: must agree on the value of any identifier(s). The full process is shown in
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15-10\.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scene manager**'
  prefs: []
  type: TYPE_NORMAL
- en: self._request_respond()
  prefs: []
  type: TYPE_NORMAL
- en: Return data
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scene**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scene**'
  prefs: []
  type: TYPE_NORMAL
- en: '*(Base class)*'
  prefs: []
  type: TYPE_NORMAL
- en: '*(Base class)*'
  prefs: []
  type: TYPE_NORMAL
- en: arget.respond()
  prefs: []
  type: TYPE_NORMAL
- en: Return data
  prefs: []
  type: TYPE_NORMAL
- en: oT
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: self.request()
  prefs: []
  type: TYPE_NORMAL
- en: Return data
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '**Current**'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '**Current**'
  prefs: []
  type: TYPE_NORMAL
- en: '**scene**'
  prefs: []
  type: TYPE_NORMAL
- en: '**scene**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-10: The communication path of one scene asking for information from*'
  prefs: []
  type: TYPE_NORMAL
- en: '*another scene*'
  prefs: []
  type: TYPE_NORMAL
- en: The current scene cannot get information from another scene directly,
  prefs: []
  type: TYPE_NORMAL
- en: since the current scene does not have a reference to any other scene.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, it uses the scene manager as an intermediary. Here is how it all
  prefs: []
  type: TYPE_NORMAL
- en: 'works:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The current scene makes a call to self.request(), which lives in the
  prefs: []
  type: TYPE_NORMAL
- en: inherited Scene base class.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. The
  prefs: []
  type: TYPE_NORMAL
- en: Scene base class has a reference to the scene manager in its
  prefs: []
  type: TYPE_NORMAL
- en: instance variable self.oSceneMgr, to allow its methods to call methods
  prefs: []
  type: TYPE_NORMAL
- en: of the scene manager. The self.request() method calls the scene
  prefs: []
  type: TYPE_NORMAL
- en: manager’s _request_respond() method to request information from a
  prefs: []
  type: TYPE_NORMAL
- en: target scene.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. The scene manager has a dictionary of all scene keys and related
  prefs: []
  type: TYPE_NORMAL
- en: objects, and it uses the parameter that’s passed in to find the object
  prefs: []
  type: TYPE_NORMAL
- en: associated with the target scene. It then calls the respond() method in
  prefs: []
  type: TYPE_NORMAL
- en: the target scene.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. The
  prefs: []
  type: TYPE_NORMAL
- en: respond() method in the target scene (which you must write) does
  prefs: []
  type: TYPE_NORMAL
- en: whatever it needs to do to generate the data that was asked for, then
  prefs: []
  type: TYPE_NORMAL
- en: returns the data to the scene manager.
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **339**
  prefs: []
  type: TYPE_NORMAL
- en: 5\. The scene manager returns the data to the request() method in the Scene
    base class inherited by the current scene.
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Finally, the request() method in the Scene base class returns the data to
  prefs: []
  type: TYPE_NORMAL
- en: the original caller.
  prefs: []
  type: TYPE_NORMAL
- en: The same mechanism is used to implement send() and sendAll(). The
  prefs: []
  type: TYPE_NORMAL
- en: only difference is that when sending a message to a scene or to all scenes,
  prefs: []
  type: TYPE_NORMAL
- en: there is no data to be returned to the original caller.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I introduced two different ways to implement a program
  prefs: []
  type: TYPE_NORMAL
- en: that incorporates multiple scenes. A state machine is a technique for rep-
  prefs: []
  type: TYPE_NORMAL
- en: resenting and controlling the flow of execution through a series of states;
  prefs: []
  type: TYPE_NORMAL
- en: you can use it to implement a program with a small number of scenes. The
  prefs: []
  type: TYPE_NORMAL
- en: scene manager is designed to help you build larger multi-scene applications
  prefs: []
  type: TYPE_NORMAL
- en: by providing navigation and a general way for scenes to communicate with
  prefs: []
  type: TYPE_NORMAL
- en: each other. I also explained how the scene manager implements all this
  prefs: []
  type: TYPE_NORMAL
- en: functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The scene manager and the Scene base class provide clear examples of
  prefs: []
  type: TYPE_NORMAL
- en: 'the three main tenets of object-oriented programming: encapsulation, poly-'
  prefs: []
  type: TYPE_NORMAL
- en: morphism, and inheritance. Each scene is a good example of encapsulation
  prefs: []
  type: TYPE_NORMAL
- en: because all the code and data of a scene is written as a class. Each scene class
  prefs: []
  type: TYPE_NORMAL
- en: must be polymorphic, in that it must implement a common set of methods
  prefs: []
  type: TYPE_NORMAL
- en: in order for it to work with calls from the scene manager. Finally, each scene
  prefs: []
  type: TYPE_NORMAL
- en: inherits from a common Scene base class. Two-way communication between
  prefs: []
  type: TYPE_NORMAL
- en: the scene manager and the Scene base class is implemented by every scene
  prefs: []
  type: TYPE_NORMAL
- en: using the inherited methods and instance variables in the base class.
  prefs: []
  type: TYPE_NORMAL
- en: '**340** Chapter 15'
  prefs: []
  type: TYPE_NORMAL
- en: '**16**'
  prefs: []
  type: TYPE_NORMAL
- en: '**F U L L G A M E : D O D G E R**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll build a full game called
  prefs: []
  type: TYPE_NORMAL
- en: Dodger that uses many of the techniques
  prefs: []
  type: TYPE_NORMAL
- en: and concepts that have been explained
  prefs: []
  type: TYPE_NORMAL
- en: in this book. This is a fully object-oriented
  prefs: []
  type: TYPE_NORMAL
- en: extended version of a game originally developed by
  prefs: []
  type: TYPE_NORMAL
- en: Al Sweigart in his book *Invent Your Own Computer Games*
  prefs: []
  type: TYPE_NORMAL
- en: '*with Python* (No Starch, 2016; the basic game concept,'
  prefs: []
  type: TYPE_NORMAL
- en: graphics, and sounds are used by permission).
  prefs: []
  type: TYPE_NORMAL
- en: Before I get into the game itself, I’ll introduce a set of functions that
  prefs: []
  type: TYPE_NORMAL
- en: present modal dialogs that we’ll use in the game. A *modal dialog* is one
  prefs: []
  type: TYPE_NORMAL
- en: that forces the user to interact with it—choosing an option, for example—
  prefs: []
  type: TYPE_NORMAL
- en: before they can continue using the underlying program. These dialogs
  prefs: []
  type: TYPE_NORMAL
- en: stop the program from running until an option is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: '**Modal Dialogs**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The pyghelpers module has two types of modal dialogs:'
  prefs: []
  type: TYPE_NORMAL
- en: • *Yes/No dialogs* present a question and wait for the user to click one of
  prefs: []
  type: TYPE_NORMAL
- en: two buttons. The text of these buttons defaults to Yes and No, though
  prefs: []
  type: TYPE_NORMAL
- en: you can use any text you like (for example, OK and Cancel). If no text
  prefs: []
  type: TYPE_NORMAL
- en: is specified for the No button, this dialog can be used as an alert, with
  prefs: []
  type: TYPE_NORMAL
- en: only a Yes (or typically, OK) button.
  prefs: []
  type: TYPE_NORMAL
- en: • *Answer dialogs* present a question, a text field for the user to type in,
    and a set of buttons with text defaulting to OK and Cancel. The user can
  prefs: []
  type: TYPE_NORMAL
- en: answer the question and click OK or cancel (close) the dialog by click-
  prefs: []
  type: TYPE_NORMAL
- en: ing Cancel.
  prefs: []
  type: TYPE_NORMAL
- en: You present each type of dialog to the user by calling a particular func-
  prefs: []
  type: TYPE_NORMAL
- en: 'tion in the pyghelpers module. Each dialog comes in two flavors: a simple'
  prefs: []
  type: TYPE_NORMAL
- en: TextButton-based version and a more complicated custom version. The sim-
  prefs: []
  type: TYPE_NORMAL
- en: ple text version uses a default layout with two TextButton objects that’s great
  prefs: []
  type: TYPE_NORMAL
- en: for quick prototyping. In the custom version, you can provide a background
  prefs: []
  type: TYPE_NORMAL
- en: for the dialog, customize the question text, customize the answer text (with
  prefs: []
  type: TYPE_NORMAL
- en: an Answer dialog), and provide customized artwork for the buttons.
  prefs: []
  type: TYPE_NORMAL
- en: '***Yes/No and Alert Dialogs***'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll first look at the Yes/No dialog, starting with the text version.
  prefs: []
  type: TYPE_NORMAL
- en: '**Text Version**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the interface of the textYesNoDialog() function:'
  prefs: []
  type: TYPE_NORMAL
- en: textYesNoDialog(theWindow, theRect, prompt, yesButtonText='Yes',
  prefs: []
  type: TYPE_NORMAL
- en: noButtonText='No',
  prefs: []
  type: TYPE_NORMAL
- en: backgroundColor=DIALOG_BACKGROUND_COLOR,
  prefs: []
  type: TYPE_NORMAL
- en: textColor=DIALOG_BLACK)
  prefs: []
  type: TYPE_NORMAL
- en: When you call this function, you need to pass in the window to draw
  prefs: []
  type: TYPE_NORMAL
- en: into, a rectangle object or tuple representing the location and size of the
  prefs: []
  type: TYPE_NORMAL
- en: dialog to create, and a text prompt to be shown. You can also optionally
  prefs: []
  type: TYPE_NORMAL
- en: specify the text of the two buttons, a background color, and the color of the
  prefs: []
  type: TYPE_NORMAL
- en: prompt text. If not specified, the button text defaults to Yes and No.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a typical call to this function:'
  prefs: []
  type: TYPE_NORMAL
- en: returnedValue = pyghelpers.textYesNoDialog(window,
  prefs: []
  type: TYPE_NORMAL
- en: (75, 100, 500, 150),
  prefs: []
  type: TYPE_NORMAL
- en: '''Do you want fries with that?'')'
  prefs: []
  type: TYPE_NORMAL
- en: This call shows the dialog in Figure 16-1\.
  prefs: []
  type: TYPE_NORMAL
- en: '**342** Chapter 16'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 47](index-372_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Image 48](index-372_2.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: A typical textYesNoDialog dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: The Yes and No buttons are instances of the TextButton class in pygwidgets.
  prefs: []
  type: TYPE_NORMAL
- en: The main program stops while the dialog shows. When the user clicks a
  prefs: []
  type: TYPE_NORMAL
- en: button, the function returns True for Yes or False for No. Your code does
  prefs: []
  type: TYPE_NORMAL
- en: whatever needs to be done based on the returned Boolean value; then the
  prefs: []
  type: TYPE_NORMAL
- en: main program continues running where it left off.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use this function to create a simple Alert dialog with only
  prefs: []
  type: TYPE_NORMAL
- en: one button. If the value passed in for noButtonText is None, that button will
    not
  prefs: []
  type: TYPE_NORMAL
- en: 'be shown. For example, you can make a call like this to show only one button:'
  prefs: []
  type: TYPE_NORMAL
- en: ignore = pyghelpers.textYesNoDialog(window, (75, 80, 500, 150),
  prefs: []
  type: TYPE_NORMAL
- en: '''This is an alert!'', ''OK'', None)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16-2 shows the resulting Alert dialog.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16-2: A textYesNoDialog used as an Alert dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom Version**'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a custom Yes/No dialog is more complicated but allows for much
  prefs: []
  type: TYPE_NORMAL
- en: 'more control. Here is the interface of the customYesNoDialog() function:'
  prefs: []
  type: TYPE_NORMAL
- en: customYesNoDialog(theWindow, oDialogImage, oPromptText, oYesButton,
  prefs: []
  type: TYPE_NORMAL
- en: oNoButton)
  prefs: []
  type: TYPE_NORMAL
- en: Before you can call this function, you need to create objects for the
  prefs: []
  type: TYPE_NORMAL
- en: background of the dialog, the prompt text, and the Yes and No buttons. You
  prefs: []
  type: TYPE_NORMAL
- en: would typically use Image, DisplayText, and CustomButton (or TextButton) objects
  prefs: []
  type: TYPE_NORMAL
- en: created from pygwidgets classes for this purpose. The customYesNoDialog()
  prefs: []
  type: TYPE_NORMAL
- en: code demonstrates polymorphism by calling the handleEvent() method of the
  prefs: []
  type: TYPE_NORMAL
- en: buttons, so it doesn’t matter whether you use CustomButtons or TextButtons,
    and
  prefs: []
  type: TYPE_NORMAL
- en: by calling the draw() method of all objects that make up the dialog. Because
  prefs: []
  type: TYPE_NORMAL
- en: you create all these objects, you can customize the look of any or all of them.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to supply your own artwork for any Image and CustomButton
  prefs: []
  type: TYPE_NORMAL
- en: objects and customarily place them in the *images* folder of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Full Game: Dodger **343**'
  prefs: []
  type: TYPE_NORMAL
- en: When implementing a custom Yes/No dialog, typically you would write an intermediate
    function like showCustomYesNoDialog(), shown in Listing 16-1\.
  prefs: []
  type: TYPE_NORMAL
- en: Then, at the place in your code where you want to show the dialog, rather
  prefs: []
  type: TYPE_NORMAL
- en: than calling customYesNoDialog() directly, you instead call the intermediate
  prefs: []
  type: TYPE_NORMAL
- en: function, which both instantiates the widgets and makes the actual call.
  prefs: []
  type: TYPE_NORMAL
- en: 'def showCustomYesNoDialog(theWindow, theText):'
  prefs: []
  type: TYPE_NORMAL
- en: 1 oDialogBackground = pygwidgets.Image(theWindow, (60, 120),
  prefs: []
  type: TYPE_NORMAL
- en: '''images/dialog.png'')'
  prefs: []
  type: TYPE_NORMAL
- en: 2 oPromptDisplayText = pygwidgets.DisplayText(theWindow, (0, 170),
  prefs: []
  type: TYPE_NORMAL
- en: theText, width=WINDOW_WIDTH,
  prefs: []
  type: TYPE_NORMAL
- en: justified='center', fontSize=36)
  prefs: []
  type: TYPE_NORMAL
- en: 3 oNoButton = pygwidgets.CustomButton(theWindow, (95, 265),
  prefs: []
  type: TYPE_NORMAL
- en: '''images/noNormal.png'','
  prefs: []
  type: TYPE_NORMAL
- en: over='images/noOver.png',
  prefs: []
  type: TYPE_NORMAL
- en: down='images/noDown.png',
  prefs: []
  type: TYPE_NORMAL
- en: disabled='images/noDisabled.png')
  prefs: []
  type: TYPE_NORMAL
- en: oYesButton = pygwidgets.CustomButton(theWindow, (355, 265),
  prefs: []
  type: TYPE_NORMAL
- en: '''images/yesNormal.png'','
  prefs: []
  type: TYPE_NORMAL
- en: over='images/yesOver.png',
  prefs: []
  type: TYPE_NORMAL
- en: down='images/yesDown.png',
  prefs: []
  type: TYPE_NORMAL
- en: disabled='images/yesDisabled.png')
  prefs: []
  type: TYPE_NORMAL
- en: 4 userAnswer = pyghelpers.customYesNoDialog(theWindow,
  prefs: []
  type: TYPE_NORMAL
- en: oDialogBackground,
  prefs: []
  type: TYPE_NORMAL
- en: oPromptDisplayText,
  prefs: []
  type: TYPE_NORMAL
- en: oYesButton, oNoButton)
  prefs: []
  type: TYPE_NORMAL
- en: 5 return userAnswer
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-1: An intermediate function to create a custom Yes/No dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the function you write code to create an Image object for the
  prefs: []
  type: TYPE_NORMAL
- en: background using an image you specify 1\. You also create a DisplayText
  prefs: []
  type: TYPE_NORMAL
- en: object for the prompt 2, in which you specify the placement, text size,
  prefs: []
  type: TYPE_NORMAL
- en: font, and so on. Then you create buttons as either TextButton objects or,
  prefs: []
  type: TYPE_NORMAL
- en: more likely, CustomButton objects so you can show custom images 3\. Finally,
  prefs: []
  type: TYPE_NORMAL
- en: this function calls customYesNoDialog(), passing in all the objects you just
  prefs: []
  type: TYPE_NORMAL
- en: created 4\. The call to customYesNoDialog() returns the user’s choice to this
  prefs: []
  type: TYPE_NORMAL
- en: intermediate function, and the intermediate function returns the user’s
  prefs: []
  type: TYPE_NORMAL
- en: choice to the original caller 5\. This approach works well because the wid-
  prefs: []
  type: TYPE_NORMAL
- en: get objects (oDialogBackground, oPromptDisplayText, oYesButton, and oNoButton)
  prefs: []
  type: TYPE_NORMAL
- en: created inside this function are all local variables and therefore will all
    go
  prefs: []
  type: TYPE_NORMAL
- en: away when the intermediate function ends.
  prefs: []
  type: TYPE_NORMAL
- en: When you call this function, you only need to pass in the window and
  prefs: []
  type: TYPE_NORMAL
- en: 'the text prompt to be displayed. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: returnedValue = showCustomYesNoDialog(window,
  prefs: []
  type: TYPE_NORMAL
- en: '''Do you want fries with that?'')'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16-3 shows the resulting dialog. This is just one example; you
  prefs: []
  type: TYPE_NORMAL
- en: can design any layout you like.
  prefs: []
  type: TYPE_NORMAL
- en: '**344** Chapter 16'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 49](index-374_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-3: A typical customYesNoDialog dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: As with the simple text version, if the value passed in for oNoButton is
  prefs: []
  type: TYPE_NORMAL
- en: None, that button will not be shown, which is useful for building and display-
  prefs: []
  type: TYPE_NORMAL
- en: ing an Alert dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, the textYesNoDialog() and customYesNoDialog() functions each
  prefs: []
  type: TYPE_NORMAL
- en: run their own while loop that handles events and updates and draws the
  prefs: []
  type: TYPE_NORMAL
- en: dialog. That way, the calling program is suspended (its main loop does
  prefs: []
  type: TYPE_NORMAL
- en: not run) until the user clicks a button and the modal dialog returns the
  prefs: []
  type: TYPE_NORMAL
- en: selected answer. (The source code of both functions is available in the
  prefs: []
  type: TYPE_NORMAL
- en: pyghelpers module.)
  prefs: []
  type: TYPE_NORMAL
- en: '***Answer Dialogs***'
  prefs: []
  type: TYPE_NORMAL
- en: An Answer dialog adds an input text field where the user can type a
  prefs: []
  type: TYPE_NORMAL
- en: response. The pyghelpers module also contains functions textAnswerDialog()
  prefs: []
  type: TYPE_NORMAL
- en: and customAnswerDialog() to handle these dialogs, which work similarly to
  prefs: []
  type: TYPE_NORMAL
- en: their Yes/No counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Text Version**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the interface of the textAnswerDialog() function:'
  prefs: []
  type: TYPE_NORMAL
- en: textAnswerDialog(theWindow, theRect, prompt, okButtonText='OK'
  prefs: []
  type: TYPE_NORMAL
- en: cancelButtonText='Cancel',
  prefs: []
  type: TYPE_NORMAL
- en: backgroundColor=DIALOG_BACKGROUND_COLOR,
  prefs: []
  type: TYPE_NORMAL
- en: promptTextColor=DIALOG_BLACK,
  prefs: []
  type: TYPE_NORMAL
- en: inputTextColor=DIALOG_BLACK)
  prefs: []
  type: TYPE_NORMAL
- en: If the user clicks the OK button, the function returns whatever text the
  prefs: []
  type: TYPE_NORMAL
- en: user entered. If the user clicks the Cancel button, the function returns None.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a typical call:'
  prefs: []
  type: TYPE_NORMAL
- en: userAnswer = pyghelpers.textAnswerDialog(window, (75, 100, 500, 200),
  prefs: []
  type: TYPE_NORMAL
- en: '''What is your favorite flavor of ice cream?'')'
  prefs: []
  type: TYPE_NORMAL
- en: 'if userAnswer is not None:'
  prefs: []
  type: TYPE_NORMAL
- en: User pressed OK, do whatever you want with the variable userAnswer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: Here do whatever you want knowing that the user pressed Cancel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Full Game: Dodger **345**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 50](index-375_1.png)'
  prefs: []
  type: TYPE_IMG
- en: This will display the dialog in Figure 16-4\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16-4: A typical textAnswerDialog dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom Version**'
  prefs: []
  type: TYPE_NORMAL
- en: To implement a custom Answer dialog, you should write an intermediate
  prefs: []
  type: TYPE_NORMAL
- en: function, similar to the approach shown with customYesNoDialog(). Your main
  prefs: []
  type: TYPE_NORMAL
- en: code calls the intermediate function, which in turn calls customAnswerDialog().
  prefs: []
  type: TYPE_NORMAL
- en: Listing 16-2 shows the code of a typical intermediate function.
  prefs: []
  type: TYPE_NORMAL
- en: 'def showCustomAnswerDialog(theWindow, theText):'
  prefs: []
  type: TYPE_NORMAL
- en: oDialogBackground = pygwidgets.Image(theWindow, (60, 80),
  prefs: []
  type: TYPE_NORMAL
- en: '''images/dialog.png'')'
  prefs: []
  type: TYPE_NORMAL
- en: oPromptDisplayText = pygwidgets.DisplayText(theWindow, (0, 120),
  prefs: []
  type: TYPE_NORMAL
- en: theText, width=WINDOW_WIDTH,
  prefs: []
  type: TYPE_NORMAL
- en: justified='center', fontSize=36)
  prefs: []
  type: TYPE_NORMAL
- en: oUserInputText = pygwidgets.InputText(theWindow, (225, 165), '',
  prefs: []
  type: TYPE_NORMAL
- en: fontSize=36, initialFocus=True)
  prefs: []
  type: TYPE_NORMAL
- en: oNoButton = pygwidgets.CustomButton(theWindow, (105, 235),
  prefs: []
  type: TYPE_NORMAL
- en: '''images/cancelNormal.png'','
  prefs: []
  type: TYPE_NORMAL
- en: over='images/cancelOver.png',
  prefs: []
  type: TYPE_NORMAL
- en: down='images/cancelDown.png',
  prefs: []
  type: TYPE_NORMAL
- en: isabled='images/cancelDisabled.png')
  prefs: []
  type: TYPE_NORMAL
- en: oYesButton = pygwidgets.CustomButton(theWindow, (375, 235),
  prefs: []
  type: TYPE_NORMAL
- en: '''images/okNormal.png'','
  prefs: []
  type: TYPE_NORMAL
- en: over='images/okOver.png',
  prefs: []
  type: TYPE_NORMAL
- en: down='images/okDown.png',
  prefs: []
  type: TYPE_NORMAL
- en: disabled='images/okDisabled.png')
  prefs: []
  type: TYPE_NORMAL
- en: response = pyghelpers.customAnswerDialog(theWindow,
  prefs: []
  type: TYPE_NORMAL
- en: oDialogBackground, oPromptDisplayText,
  prefs: []
  type: TYPE_NORMAL
- en: oUserInputText,
  prefs: []
  type: TYPE_NORMAL
- en: oYesButton, oNoButton)
  prefs: []
  type: TYPE_NORMAL
- en: return response
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-2: An intermediate function to create a custom Answer dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can customize the entire appearance of the dialog: background'
  prefs: []
  type: TYPE_NORMAL
- en: image, fonts, and sizes and placement of the display and input text fields
  prefs: []
  type: TYPE_NORMAL
- en: '**346** Chapter 16'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 51](index-376_1.png)'
  prefs: []
  type: TYPE_IMG
- en: and the two buttons. To show a custom dialog, your main code would call
  prefs: []
  type: TYPE_NORMAL
- en: 'the intermediate function and pass in the prompt text, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: userAnswer = showCustomAnswerDialog(window,
  prefs: []
  type: TYPE_NORMAL
- en: '''What is your favorite flavor of ice cream?'')'
  prefs: []
  type: TYPE_NORMAL
- en: That call displays a custom Answer dialog like the one shown in
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16-5\.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16-5: A typical customAnswerDialog dialog*'
  prefs: []
  type: TYPE_NORMAL
- en: If user clicks OK, the function returns the text the user entered. If the
  prefs: []
  type: TYPE_NORMAL
- en: user clicks the Cancel button, the function returns None.
  prefs: []
  type: TYPE_NORMAL
- en: A demo program that demonstrates all the types of dialogs, *DialogTester/*
  prefs: []
  type: TYPE_NORMAL
- en: '*Main_DialogTester.py*, is available with the downloadable resources for the'
  prefs: []
  type: TYPE_NORMAL
- en: book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Building a Full Game: Dodger**'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll put all the material from this part of the book together
  prefs: []
  type: TYPE_NORMAL
- en: in the context of a game called Dodger. From the user’s point of view, the
  prefs: []
  type: TYPE_NORMAL
- en: 'game is extremely simple: get as many points as you can by dodging the red'
  prefs: []
  type: TYPE_NORMAL
- en: Baddies and making contact with the green Goodies.
  prefs: []
  type: TYPE_NORMAL
- en: '***Game Overview***'
  prefs: []
  type: TYPE_NORMAL
- en: Red Baddies will drop from the top of the window, and the user must avoid
  prefs: []
  type: TYPE_NORMAL
- en: them. Any Baddie that makes it all the way down to the bottom of the game
  prefs: []
  type: TYPE_NORMAL
- en: area is removed, and the user gains one point. The user moves the mouse to
  prefs: []
  type: TYPE_NORMAL
- en: control a Player icon. If the Player touches any Baddie, the game is over. A
  prefs: []
  type: TYPE_NORMAL
- en: small number of green Goodies show up randomly and move horizontally,
  prefs: []
  type: TYPE_NORMAL
- en: and the user gets 25 points for any Goodie they touch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The game has three scenes: a starting or Splash scene with instructions,'
  prefs: []
  type: TYPE_NORMAL
- en: a Play scene where you play the game, and a High Scores scene where you
  prefs: []
  type: TYPE_NORMAL
- en: can view the top 10 high scores. If you score within the top 10, you’re given
  prefs: []
  type: TYPE_NORMAL
- en: the option of entering your name and score into the high scores table.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16-6 shows the three scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Full Game: Dodger **347**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 52](index-377_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-6: The Splash, Play, and High Score scenes (left to right)*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Implementation***'
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of the *Dodger* project folder are as follows (filenames are in
    italic):'
  prefs: []
  type: TYPE_NORMAL
- en: '***__init__.py***Empty file that indicates that this is a Python package'
  prefs: []
  type: TYPE_NORMAL
- en: '***Baddies.py***Contains the Baddie and BaddieMgr classes'
  prefs: []
  type: TYPE_NORMAL
- en: '***Constants.py***Contains constants used by multiple scenes'
  prefs: []
  type: TYPE_NORMAL
- en: '***Goodies.py***Contains the Goodie and GoodieMgr classes'
  prefs: []
  type: TYPE_NORMAL
- en: '***HighScoresData.py***Contains the HighScoresData class'
  prefs: []
  type: TYPE_NORMAL
- en: '**images** Folder that contains all the artwork for the game'
  prefs: []
  type: TYPE_NORMAL
- en: '***Main_Dodger.py***The main program'
  prefs: []
  type: TYPE_NORMAL
- en: '***Player.py***Contains the Player class'
  prefs: []
  type: TYPE_NORMAL
- en: '***SceneHighScores.py***The scene that shows and records high scores'
  prefs: []
  type: TYPE_NORMAL
- en: '***ScenePlay.py***The main Play scene'
  prefs: []
  type: TYPE_NORMAL
- en: '***Scene.Splash.py***The Splash scene'
  prefs: []
  type: TYPE_NORMAL
- en: '**sounds** Folder that contains all the sound files for the game'
  prefs: []
  type: TYPE_NORMAL
- en: The project folder is included with the book’s resources. I won’t talk
  prefs: []
  type: TYPE_NORMAL
- en: through the entirety of the code, but I’ll go through the source files and
  prefs: []
  type: TYPE_NORMAL
- en: explain how the key parts work.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Dodger/Constants.py**'
  prefs: []
  type: TYPE_NORMAL
- en: This file contains constants that can be used by more than one source file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important constants are the scene keys:'
  prefs: []
  type: TYPE_NORMAL
- en: Scene keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SCENE_SPLASH = 'scene splash'
  prefs: []
  type: TYPE_NORMAL
- en: SCENE_PLAY = 'scene play'
  prefs: []
  type: TYPE_NORMAL
- en: SCENE_HIGH_SCORES = 'scene high scores'
  prefs: []
  type: TYPE_NORMAL
- en: '**348** Chapter 16'
  prefs: []
  type: TYPE_NORMAL
- en: The values of these constants are unique strings that identify the different
    scenes.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Main_Dodger.py**'
  prefs: []
  type: TYPE_NORMAL
- en: The main file performs the necessary initialization, then passes control to
  prefs: []
  type: TYPE_NORMAL
- en: 'the scene manager. The most important code in the file is this:'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiate all scenes and store them in a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: scenesList = [SceneSplash(window)
  prefs: []
  type: TYPE_NORMAL
- en: SceneHighScores(window)
  prefs: []
  type: TYPE_NORMAL
- en: ScenePlay(window)]
  prefs: []
  type: TYPE_NORMAL
- en: Create the scene manager, passing in the scenes list and the FPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oSceneMgr = pyghelpers.SceneMgr(scenesList, FRAMES_PER_SECOND)
  prefs: []
  type: TYPE_NORMAL
- en: Tell the scene manager to start running
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oSceneMgr.run()
  prefs: []
  type: TYPE_NORMAL
- en: Here we create an instance of each scene, instantiate the scene man-
  prefs: []
  type: TYPE_NORMAL
- en: ager, then turn over control to the scene manager. The scene manager’s
  prefs: []
  type: TYPE_NORMAL
- en: run() method gives control to the first scene in the list. In this game, it
    gives
  prefs: []
  type: TYPE_NORMAL
- en: control to the Splash scene.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in the previous chapter, each scene class inherits from the
  prefs: []
  type: TYPE_NORMAL
- en: Scene base class. In addition to providing its own __init__() method, each
  prefs: []
  type: TYPE_NORMAL
- en: of these classes is required to override the getSceneKey(), handleInputs(),
    and
  prefs: []
  type: TYPE_NORMAL
- en: draw() methods from the base class.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Dodger/SceneSplash.py**'
  prefs: []
  type: TYPE_NORMAL
- en: The Splash scene shows the user a graphic with the rules of the game and
  prefs: []
  type: TYPE_NORMAL
- en: 'three buttons: Start, Quit, and Go to High Scores. The code for this scene’s'
  prefs: []
  type: TYPE_NORMAL
- en: class only contains the required methods; all other methods default to the
  prefs: []
  type: TYPE_NORMAL
- en: ones in the Scene base class.
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() method creates an Image object for the background
  prefs: []
  type: TYPE_NORMAL
- en: image and three CustomButton objects for the user’s options.
  prefs: []
  type: TYPE_NORMAL
- en: The getSceneKey() method must be implemented in all scenes; it just
  prefs: []
  type: TYPE_NORMAL
- en: returns a unique key for the scene.
  prefs: []
  type: TYPE_NORMAL
- en: The handleInputs() method checks for the user clicking any of the but-
  prefs: []
  type: TYPE_NORMAL
- en: tons. If the user clicks Start, we call the inherited self.goToScene() method
  prefs: []
  type: TYPE_NORMAL
- en: to ask the scene manager to transfer control to the Play scene. Similarly,
  prefs: []
  type: TYPE_NORMAL
- en: clicking the Go to High Scores button takes the user to the High Scores
  prefs: []
  type: TYPE_NORMAL
- en: scene. If the user clicks Quit, we call the scene’s inherited self.quit()
  prefs: []
  type: TYPE_NORMAL
- en: method, which quits the program.
  prefs: []
  type: TYPE_NORMAL
- en: In the draw() method, the program draws the background and all three
  prefs: []
  type: TYPE_NORMAL
- en: buttons.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Dodger/ScenePlay.py**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Play scene manages the actual playing of the game: the user moving'
  prefs: []
  type: TYPE_NORMAL
- en: the Player icon, generation and movement of the Baddies and Goodies,
  prefs: []
  type: TYPE_NORMAL
- en: 'Full Game: Dodger **349**'
  prefs: []
  type: TYPE_NORMAL
- en: and collision detection. It also manages the display elements at the bottom
    of the window, including the current game score and high score, and
  prefs: []
  type: TYPE_NORMAL
- en: responds to clicks on the Quit, Go to High Scores, and Start buttons and
  prefs: []
  type: TYPE_NORMAL
- en: the Background Music checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: There is quite a bit of code for the Play scene, so I’ll break it up into
  prefs: []
  type: TYPE_NORMAL
- en: smaller chunks (Listings 16-3 through 16-7) to explain the methods. The
  prefs: []
  type: TYPE_NORMAL
- en: scene adheres to the design rules established i[n Chapter 15 by i](#p340)mplementing
    the __init__(), handleInputs(), update(), and draw() methods. It also implements
  prefs: []
  type: TYPE_NORMAL
- en: an enter() method to handle what the scene should do when it becomes the
  prefs: []
  type: TYPE_NORMAL
- en: active scene and a leave() method for what the scene should do when the user
  prefs: []
  type: TYPE_NORMAL
- en: navigates away. Finally, it has a reset() method for resetting the state before
  prefs: []
  type: TYPE_NORMAL
- en: starting a new round. Listing 16-3 shows the initialization code.
  prefs: []
  type: TYPE_NORMAL
- en: Play scene - the main game play scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip imports and showCustomYesNoDialog ---'
  prefs: []
  type: TYPE_NORMAL
- en: BOTTOM_RECT = (0, GAME_HEIGHT + 1, WINDOW_WIDTH,
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_HEIGHT - GAME_HEIGHT)
  prefs: []
  type: TYPE_NORMAL
- en: STATE_WAITING = 'waiting'
  prefs: []
  type: TYPE_NORMAL
- en: STATE_PLAYING = 'playing'
  prefs: []
  type: TYPE_NORMAL
- en: STATE_GAME_OVER = 'game over'
  prefs: []
  type: TYPE_NORMAL
- en: 'class ScenePlay(pyghelpers.Scene):'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window):'
  prefs: []
  type: TYPE_NORMAL
- en: 1 self.window = window
  prefs: []
  type: TYPE_NORMAL
- en: self.controlsBackground = pygwidgets.Image(self.window,
  prefs: []
  type: TYPE_NORMAL
- en: (0, GAME_HEIGHT),
  prefs: []
  type: TYPE_NORMAL
- en: '''images/controlsBackground.jpg'')'
  prefs: []
  type: TYPE_NORMAL
- en: self.quitButton = pygwidgets.CustomButton(self.window,
  prefs: []
  type: TYPE_NORMAL
- en: (30, GAME_HEIGHT + 90),
  prefs: []
  type: TYPE_NORMAL
- en: up='images/quitNormal.png',
  prefs: []
  type: TYPE_NORMAL
- en: down='images/quitDown.png',
  prefs: []
  type: TYPE_NORMAL
- en: over='images/quitOver.png',
  prefs: []
  type: TYPE_NORMAL
- en: disabled='images/quitDisabled.png')
  prefs: []
  type: TYPE_NORMAL
- en: self.highScoresButton = pygwidgets.CustomButton(self.window,
  prefs: []
  type: TYPE_NORMAL
- en: (190, GAME_HEIGHT + 90),
  prefs: []
  type: TYPE_NORMAL
- en: up='images/gotoHighScoresNormal.png',
  prefs: []
  type: TYPE_NORMAL
- en: down='images/gotoHighScoresDown.png',
  prefs: []
  type: TYPE_NORMAL
- en: over='images/gotoHighScoresOver.png',
  prefs: []
  type: TYPE_NORMAL
- en: disabled='images/gotoHighScoresDisabled.png')
  prefs: []
  type: TYPE_NORMAL
- en: self.startButton = pygwidgets.CustomButton(self.window,
  prefs: []
  type: TYPE_NORMAL
- en: (450, GAME_HEIGHT + 90),
  prefs: []
  type: TYPE_NORMAL
- en: up='images/startNewNormal.png',
  prefs: []
  type: TYPE_NORMAL
- en: down='images/startNewDown.png',
  prefs: []
  type: TYPE_NORMAL
- en: over='images/startNewOver.png',
  prefs: []
  type: TYPE_NORMAL
- en: disabled='images/startNewDisabled.png',
  prefs: []
  type: TYPE_NORMAL
- en: enterToActivate=True)
  prefs: []
  type: TYPE_NORMAL
- en: '**350** Chapter 16'
  prefs: []
  type: TYPE_NORMAL
- en: self.soundCheckBox = pygwidgets.TextCheckBox(self.window,
  prefs: []
  type: TYPE_NORMAL
- en: (430, GAME_HEIGHT + 17),
  prefs: []
  type: TYPE_NORMAL
- en: '''Background music'','
  prefs: []
  type: TYPE_NORMAL
- en: True, textColor=WHITE)
  prefs: []
  type: TYPE_NORMAL
