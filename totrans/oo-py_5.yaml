- en: Otherwise, it sets self.playing to True to indicate that the animation is now
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: running.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: When a SimpleAnimation is created, the caller specifies the amount of time
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: that each image should be shown, and this is saved in self.durationPerImage.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we must keep track of time as a SimpleAnimation runs to know when
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: to switch to the next image. We call time.time() to get the current time (in
    mil-
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: liseconds) and save that in an instance variable. Making the class time based
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: means that any SimpleAnimation object built from this class will work correctly,
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: independent of the frame rate used for the main loop. Finally, we set the vari-
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: able self.index to 0 to indicate that we should be showing the first image.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The update() method 4 needs to be called in every frame of the
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: main loop. If the animation is not playing, update() does nothing and just
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: returns. Otherwise, update() calculates how much time has elapsed since
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: the current image started showing by getting the current time using the
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: system time.time() function and subtracting that from the time at which
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: the current image started showing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: If the elapsed time is greater than the amount of time that each image
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: should be showing, it’s time move to the next image. In this case, we incre-
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: ment self.index so that the upcoming call to the draw() method will draw
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: the appropriate image. We then check whether the animation has finished.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: If not, we save the start time for the new image. If the animation is done,
    we
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: set self.playing back to False (to indicate that we are no longer playing the
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: animation), and we reset self.index to 0 so that the draw() method will show
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: the first image again.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call draw() in every frame 5 to draw the current image of
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: the animation. The draw() method assumes that self.index has been set cor-
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: rectly by a previous method, and uses it to index into the list of images. It
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: then draws that image in the window at the specified location.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**Example Main Program**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Listing 14-2 shows a main program that creates and uses a SimpleAnimation
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: object. This will animate a dinosaur riding a bicycle.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '**File: SimpleAnimation/Main_SimpleAnimation.py**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Animation example
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shows example of SimpleAnimation object
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 - Import library
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: import pygwidgets
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: from SimpleAnimation import *
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 2 Define constants
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SCREEN_WIDTH = 640
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '**298** Chapter 14'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: SCREEN_HEIGHT = 480
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: BGCOLOR = (0, 128, 128)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode([SCREEN_WIDTH, SCREEN_HEIGHT])
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: clock = pygame.time.Clock()
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: images(s), sound(s), etc.'
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 dinosaurAnimTuple = ('images/Dinobike/f1.gif',
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '''images/Dinobike/f2.gif'','
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '''images/Dinobike/f3.gif'','
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '''images/Dinobike/f4.gif'','
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '''images/Dinobike/f5.gif'','
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '''images/Dinobike/f6.gif'','
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '''images/Dinobike/f7.gif'','
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '''images/Dinobike/f8.gif'','
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '''images/Dinobike/f9.gif'','
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '''images/Dinobike/f10.gif'')'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oDinosaurAnimation = SimpleAnimation(window, (22, 140),
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: dinosaurAnimTuple, .1)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: oPlayButton = pygwidgets.TextButton(window, (20, 240), "Play")
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == QUIT:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '2 if oPlayButton.handleEvent(event):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: oDinosaurAnimation.play()
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 oDinosaurAnimation.update()
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 9 - Clear the window
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(BGCOLOR)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw all window elements
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4 oDinosaurAnimation.draw()
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: oPlayButton.draw()
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-2: The main program that instantiates and plays a SimpleAnimation*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Animation **299**
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 38](index-329_1.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: All the images for the animated dinosaur are in the folder *images/*
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '*DinoBike/*. We first build a tuple of the images 1\. Then, using that tuple,'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: we create a SimpleAnimation object and specify that each image should be
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: shown for a tenth of a second. We also instantiate a Play button.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: In the main loop, we call the update() and draw() methods of the
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: oDinosaurAnimation object. The program loops while continuously drawing
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: the current image of the animation and the Play button. When the anima-
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: tion is not running, the user just sees the first image.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks the Play button 2, the program calls the play()
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: method of oDinosaurAnimation to start the animation running.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: In the main loop, we call the update() method of oDinosaur Animation 3,
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: which determines whether enough time has elapsed for the animation to
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: move on to the next image.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call draw() 4, and the object draws the appropriate image.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '***SimpleSpriteSheetAnimation Class***'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The second type of animation is implemented in the SimpleSpriteSheetAnimation
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: class. A *sprite sheet* is a single image made up of a number of equally sized
    smaller images, intended to appear in order to create an animation. From a
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: developer’s point of view, there are three advantages to a sprite sheet. First,
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: all the images are in a single file, so there is no need to worry about building
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: a name for each separate file. Second, it’s possible to see the progression
    of
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: an animation in a single file, rather than having to flip through a sequence
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: of images. Finally, loading a single file is faster than loading a list of files
    that make up an animation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14-1 shows an example of a sprite sheet.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 14-1: A sprite sheet image made up of*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '*18 smal er images*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: This example is designed to show the numbers from 0 to 17\. The origi-
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: nal file contains an image that is 384×192 pixels. A quick division shows that
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: each individual number image is 64×64 pixels. The key idea here is that we
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: use pygame to create *subimages* of a larger image to give us a set of 18 new
    64×64 pixel images. The smaller images can then be displayed using the
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: same technique as we used in the SimpleAnimation class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '**300** Chapter 14'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating the Class**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Listing 14-3 contains the SimpleSpriteSheetAnimation class to handle sprite
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: sheet–based animations. During initialization, the contents of the single
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 基于精灵图的动画。在初始化时，单个精灵图的内容会
- en: sprite sheet image are split up into a list of smaller images, which are then
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵图像被拆分为较小的图像，并将其添加到
- en: displayed by the other methods.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由其他方法显示。
- en: '**File: SimpleSpriteSheetAnimation/SimpleSpriteSheetAnimation.py**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：SimpleSpriteSheetAnimation/SimpleSpriteSheetAnimation.py**'
- en: SimpleSpriteSheetAnimation class
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SimpleSpriteSheetAnimation 类
- en: import pygame
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 pygame
- en: import time
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 time
- en: 'class SimpleSpriteSheetAnimation():'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 'class SimpleSpriteSheetAnimation():'
- en: 'def __init__(self, window, loc, imagePath, nImages, width, height, durationPerImage):
    1'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, window, loc, imagePath, nImages, width, height, durationPerImage):
    1'
- en: self.window = window
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: self.window = window
- en: self.loc = loc
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: self.loc = loc
- en: self.nImages = nImages
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: self.nImages = nImages
- en: self.imagesList = []
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: self.imagesList = []
- en: Load the sprite sheet
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载精灵图
- en: spriteSheetImage = pygame.image.load(imagePath)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: spriteSheetImage = pygame.image.load(imagePath)
- en: Optimize blitting
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化 blitting
- en: spriteSheetImage = pygame.Surface.convert_alpha(spriteSheetImage)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: spriteSheetImage = pygame.Surface.convert_alpha(spriteSheetImage)
- en: Calculate the number of columns in the starting image
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算起始图像中的列数
- en: nCols = spriteSheetImage.get_width() // width
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: nCols = spriteSheetImage.get_width() // width
- en: Break up the starting image into subimages
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将起始图像拆分为子图像
- en: row = 0
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: row = 0
- en: col = 0
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: col = 0
- en: 'for imageNumber in range(nImages):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 imageNumber 在范围 nImages 内:'
- en: x = col * height
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: x = col * height
- en: y = row * width
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: y = row * width
- en: Create a subsurface from the bigger spriteSheet
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从大的精灵图中创建子图像
- en: subsurfaceRect = pygame.Rect(x, y, width, height)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: subsurfaceRect = pygame.Rect(x, y, width, height)
- en: image = spriteSheetImage.subsurface(subsurfaceRect)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: image = spriteSheetImage.subsurface(subsurfaceRect)
- en: self.imagesList.append(image)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: self.imagesList.append(image)
- en: col = col + 1
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: col = col + 1
- en: 'if col == nCols:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 col == nCols:'
- en: col = 0
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: col = 0
- en: row = row + 1
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: row = row + 1
- en: self.durationPerImage = durationPerImage
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: self.durationPerImage = durationPerImage
- en: self.playing = False
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: self.playing = False
- en: self.index = 0
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: self.index = 0
- en: 'def play(self):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 'def play(self):'
- en: 'if self.playing:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 self.playing:'
- en: return
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: self.playing = True
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: self.playing = True
- en: Animation **301**
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 动画 **301**
- en: self.imageStartTime = time.time()
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: self.imageStartTime = time.time()
- en: self.index = 0
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: self.index = 0
- en: 'def update(self):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update(self):'
- en: 'if not self.playing:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 self.playing 为 False:'
- en: return
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: How much time has elapsed since we started showing this image
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自开始显示此图像以来，已过的时间
- en: self.elapsed = time.time() - self.imageStartTime
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: self.elapsed = time.time() - self.imageStartTime
- en: If enough time has elapsed, move on to the next image
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果已经过足够的时间，转到下一张图像
- en: 'if self.elapsed > self.durationPerImage:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 self.elapsed > self.durationPerImage:'
- en: self.index = self.index + 1
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: self.index = self.index + 1
- en: 'if self.index < self.nImages: # move on to next image'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 self.index < self.nImages:  # 转到下一张图像'
- en: self.imageStartTime = time.time()
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: self.imageStartTime = time.time()
- en: 'else: # animation is finished'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:  # 动画结束'
- en: self.playing = False
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: self.playing = False
- en: 'self.index = 0 # reset to the beginning'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.index = 0  # 重置为起始位置'
- en: 'def draw(self):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw(self):'
- en: Assumes that self.index has been set earlier - in the update() method.
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 假设 self.index 已在 update() 方法中设置。
- en: It is used as the index into the imagesList to find the current image.
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它用作索引，以便在 imagesList 中查找当前图像。
- en: 'theImage = self.imagesList[self.index] # choose the image to show'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 'theImage = self.imagesList[self.index]  # 选择要显示的图像'
- en: 'self.window.blit(theImage, self.loc) # show it'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.window.blit(theImage, self.loc)  # 显示图像'
- en: '*Listing 14-3: The SimpleSpriteSheetAnimation class*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-3：SimpleSpriteSheetAnimation 类*'
- en: This class is very similar to SimpleAnimation, but because this animation
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类与 SimpleAnimation 类非常相似，但因为这个动画
- en: is based on a sprite sheet, the __init__() method must be passed different
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 基于精灵图的动画，__init__() 方法必须传入不同的参数
- en: information 1\. The method requires the standard window and loc param-
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 信息 1. 该方法需要标准窗口和 loc 参数-
- en: 'eters, as well as:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 参数，另外还有：
- en: '**imagePath** A path to a sprite sheet image (single file)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**imagePath** 精灵图像路径（单个文件）'
- en: '**nImages** The number of images in the sprite sheet'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**nImages** 精灵图中的图像数量'
- en: '**width** The width of each subimage'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**width** 每个子图像的宽度'
- en: '**height** The height of each subimage'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**height** 每个子图像的高度'
- en: '**durationPerImage** How long (in seconds) to show each image'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**durationPerImage** 每张图像显示的时间（秒）'
- en: Given these values, the __init__() method loads the sprite sheet file, and
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些值，__init__() 方法加载精灵图文件，并
- en: it uses a loop to split up the larger image into a list of smaller subimages
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用一个循环将较大的图像拆分为一个较小的子图像列表
- en: through a call to the pygame subsurface() method. The smaller images are
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 pygame 的 subsurface() 方法来实现。较小的图像随后
- en: then appended into the self.imagesList list for use by the other methods.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其添加到 self.imagesList 列表中，以供其他方法使用。
- en: The __init__() method uses a counter to count the number of subimages,
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: __init__() 方法使用计数器来计算子图像的数量，
- en: up to the number specified by the caller; therefore, the last row of images
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: does not need to be a full row. For example, we could have used a sprite
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: sheet image that only had the numbers 0 through 14, rather than needing
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: to fill the row to 17\. The nImages parameter is the key to making this work.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: This rest of this class has the exact same methods as the previous
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'SimpleAnimation class: play(), update(), and draw().'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '**302** Chapter 14'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '**Example Main Program**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Listing 14-4 provides a sample main program that creates and shows
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: a SimpleSpriteSheetAnimation object that shows an animated drop of
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: water landing and spreading out. If you download everything in the
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '*SpriteSheetAnimation* folder of this book’s resources, you will get the'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: code and the appropriate artwork.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '**File: SimpleSpriteSheetAnimation/Main_SimpleSpriteSheetAnimation.py**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Shows example of SimpleSpriteSheetAnimation object
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 - Import library
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: import pygwidgets
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: from SimpleSpriteSheetAnimation import *
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 2 Define constants
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SCREEN_WIDTH = 640
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: SCREEN_HEIGHT = 480
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: BGCOLOR = (0, 128, 128)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode([SCREEN_WIDTH, SCREEN_HEIGHT])
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: clock = pygame.time.Clock()
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: images(s), sound(s), etc.'
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 oWaterAnimation = SimpleSpriteSheetAnimation(window, (22, 140),
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '''images/water_003.png'','
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 5, 50, 192, 192, .05)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: oPlayButton = pygwidgets.TextButton(window, (60, 320), "Play")
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == QUIT:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'if oPlayButton.handleEvent(event):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: oWaterAnimation.play()
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oWaterAnimation.update()
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Animation **303**
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 9 - Clear the window
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(BGCOLOR)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw all window elements
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oWaterAnimation.draw()
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: oPlayButton.draw()
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 14-4: A sample main program that creates and uses a SimpleSpriteSheetAnimation*
    *object*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The only significant difference with this example is that it instantiates a
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: SimpleSpriteSheetAnimation object 1 instead of a SimpleAnimation object.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '***Merging Two Classes***'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() methods in SimpleAnimation and SimpleSpriteSheetAnimation
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: have different parameters, but the other three methods (start(), update(),
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: and draw()) are identical. Once you instantiate either of these classes, the
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: way that you access the resulting objects is exactly the same. The “Don’t
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Repeat Yourself” (DRY) principle says that having these duplicated meth-
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: ods is a bad idea, because any bug fixes and/or enhancements would have
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: to be applied in both copies of the methods.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Instead, this is a good opportunity to merge classes. We can create
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: a common abstract base class for these classes to inherit from. The base
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: class will have its own __init__() method that includes any common code
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: from the __init__() methods of both original classes, and it will contain the
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: play(), update(), and draw() methods.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Each original class will inherit from the new base class and implement
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: its own __init__() method using the appropriate parameters. Each will do
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: its own work to create self.imagesList, which is then used in the other three
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: methods in the new base class.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Rather than showing the result of merging these two “simple” classes,
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: I’ll show the result of this merge in the “professional strength” Animation
    and
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: SpriteSheetAnimation classes that are part of the pygwidgets package.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '**Animation Classes in pygwidgets**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'The pygwidgets module contains the following three animation classes:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '**PygAnimation** An abstract base class for the Animation and'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: SpriteSheetAnimation classes
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '**Animation** A class for image-based animations (separate image files)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '**SpriteSheetAnimation** A class for sprite sheet–based animations (a'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: single large image)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '**304** Chapter 14'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at each class in turn. The Animation and SpriteSheetAnimation classes
    use the same basic concepts discussed, but also have more options
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: available via initialization parameters.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '***Animation Class***'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: You use pygwidget’s Animation class to create an animation from many differ-
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'ent image files. Here is the interface:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Animation(window, loc, animTuplesList, autoStart=False,
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'loop=False, nickname=None, callBack=None, nIterations=1):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'The required parameters are:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '**window**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: The window to draw in.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '**loc**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The upper-left corner where images should be drawn.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '**animTuplesList**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: A list (or tuple) of tuples describing the sequence of the animation.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Each inner tuple contains:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '**pathToImage** The relative path to an image file.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '**Duration** The duration this image should be shown (in seconds, float-'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: ing point).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '**offset (optional)** If present, an (x, y) tuple used as an offset from the'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: main loc to show this image.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'These parameters are all optional:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '**autoStart**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: True if you want the animation to start right away; defaults to False.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '**loop**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: True if you want the animation to loop continuously; defaults to False.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '**showFirstImageAtEnd**'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: When an animation ends, show the first image again; defaults to True.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '**nickname**'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: An internal name to assign to this animation, used as an argument
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: when a callBack is specified.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '**callBack**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: The function or object method to call when the animation is done.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '**nIterations**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: The number of times to loop through the animation; defaults to 1\.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Unlike SimpleAnimation, which uses a single duration for all images,
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: the Animation class lets you specify a duration for *each* image, allowing for
    Animation **305**
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: greater flexibility in the timing of how the images are displayed. You can also
    specify an x, y offset when drawing each image, but in general this
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: isn’t needed. Here is some sample code that creates an Animation object that
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'shows a running T-rex dinosaur:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: TRexAnimationList = [('images/TRex/f1.gif', .1),
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: ('images/TRex/f2.gif', .1),
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: ('images/TRex/f3.gif', .1),
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: ('images/TRex/f4.gif', .1),
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: ('images/TRex/f4.gif', .1),
- en: ('images/TRex/f5.gif', .1),
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ('images/TRex/f5.gif', .1),
- en: ('images/TRex/f6.gif', .1),
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ('images/TRex/f6.gif', .1),
- en: ('images/TRex/f7.gif', .1),
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ('images/TRex/f7.gif', .1),
- en: ('images/TRex/f8.gif', .1),
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ('images/TRex/f8.gif', .1),
- en: ('images/TRex/f9.gif', .1),
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ('images/TRex/f9.gif', .1),
- en: ('images/TRex/f10.gif', .4)]
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ('images/TRex/f10.gif', .4)]
- en: 5 - Initialize variables
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 - 初始化变量
- en: oDinosaurAnimation = pygwidgets.Animation(window, (22, 145),
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: oDinosaurAnimation = pygwidgets.Animation(window, (22, 145),
- en: TRexAnimationList, callBack=myFunction, nickname='Dinosaur')
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: TRexAnimationList, 回调函数=myFunction, 昵称='Dinosaur')
- en: This creates an Animation object that will show 10 different images. The
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个动画对象，显示10张不同的图像。该
- en: first nine images each show for one-tenth of a second, but the last image
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 前九张图像每张显示十分之一秒，但最后一张图像
- en: shows for four-tenths of a second. The animation will only play once and
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 显示四分之一秒的图像。动画将只播放一次并
- en: will not automatically start playing. When the animation is finished,
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 不会自动开始播放。动画完成时，
- en: myFunction() will be called with the argument 'Dinosaur'.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: myFunction() 将会以参数'Dinosaur'被调用。
- en: '***SpriteSheetAnimation Class***'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '***SpriteSheetAnimation 类***'
- en: For SpriteSheetAnimation, you pass in a path to the single sprite sheet file.
    In
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SpriteSheetAnimation，您需要传入单个精灵图集文件的路径。
- en: order for SpriteSheetAnimation to break up the large animation into many
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这是SpriteSheetAnimation将大型动画分解为多个子动画的顺序
- en: smaller images, you must specify the width and height of all subimages. For
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较小的图像，您必须指定所有子图像的宽度和高度。对于
- en: 'durations, you have two choices: you can specify a single value to say that
    all'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 持续时间，您有两个选择：您可以指定单一值，表示所有图像
- en: images should be shown for the same amount of time, or you can specify a
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图像应该显示相同的时间，或者您可以指定一个
- en: 'list or tuple of durations, one for each image. Here’s the interface:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 持续时间列表或元组，每个图像对应一个持续时间。以下是接口：
- en: SpriteSheetAnimation(window, loc, imagePath, nImages,
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteSheetAnimation(window, loc, imagePath, nImages,
- en: width, height, durationOrDurationsList,
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度、高度、持续时间或持续时间列表，
- en: autoStart=False, loop=False, nickname=None,
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: autoStart=False, loop=False, nickname=None,
- en: 'callBack=None, nIterations=1):'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '回调函数=None, 迭代次数=1):'
- en: 'The required parameters are:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 必需的参数为：
- en: '**window** The window to draw in'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**窗口** 用于绘制的窗口'
- en: '**loc** The upper-left corner where images should be drawn'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**位置** 图像绘制的左上角'
- en: '**imagePath** The relative path to the sprite sheet image file'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**图像路径** 精灵图集图像文件的相对路径'
- en: '**nImages** The total number of subimages in the sprite sheet subimage'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**nImages** 精灵图集中的子图像总数'
- en: '**width** The width of each single resulting subimage'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**宽度** 每个生成的单一子图像的宽度'
- en: '**height** The height of each single resulting subimage'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**高度** 每个生成的单一子图像的高度'
- en: '**durationOrDurationsList** The amount of time for which each subim-'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续时间或持续时间列表** 每个子图像显示的时间，'
- en: age should be shown during animation or a list of durations, one per
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子图像应在动画期间显示，或指定一个持续时间列表，每个子图像对应一个
- en: subimage (the length must be nImages)
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 子图像（长度必须是nImages）
- en: '**306** Chapter 14'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**306** 第14章'
- en: 'These are the optional parameters:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可选参数：
- en: '**autoStart**'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动开始**'
- en: True if you want the animation to start right away; defaults to False.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望动画立即开始，可以设置为True；默认为False。
- en: '**loop**'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**循环**'
- en: True if you want to animation to loop continuously; defaults to False.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望动画循环播放，可以设置为True；默认为False。
- en: '**showFirstImageAtEnd**'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '**结束时显示第一张图像**'
- en: When an animation ends, show the first image again; defaults to True.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画结束时，重新显示第一张图像；默认为True。
- en: '**nickname**'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**昵称**'
- en: An internal name to assign to this animation, used as an argument
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 为此动画分配的内部名称，用作参数
- en: when a callBack is specified.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定回调函数时。
- en: '**callBack**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**回调函数**'
- en: The function or object method to call when the animation is done.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 动画完成时要调用的函数或对象方法。
- en: '**nIterations**'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '**迭代次数**'
- en: The number of times to loop through the animation; defaults to 1\.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 循环播放的次数；默认为1\。
- en: 'Here is a typical statement to create a SpriteSheetAnimation object:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是创建SpriteSheetAnimation对象的一个典型语句：
- en: oEffectAnimation = pygwidgets.SpriteSheetAnimation(window, (400, 150),
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: oEffectAnimation = pygwidgets.SpriteSheetAnimation(window, (400, 150),
- en: '''images/effect.png'', 35, 192, 192, .1,'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/effect.png'', 35, 192, 192, .1,'
- en: autoStart=True, loop=True)
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: autoStart=True, loop=True)
- en: This creates a SpriteSheetAnimation object using a single image file found
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用在给定路径中找到的单个图像文件创建一个SpriteSheetAnimation对象。
- en: at the given path. The original image contains 35 subimages. Each smaller
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定路径下的原始图像包含35个子图像。每个较小的
- en: image is 192×192 pixels, and each subimage will be shown for one-tenth of a
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图像大小为192×192像素，每个子图像将显示十分之一秒，
- en: second. The animation will start automatically and loop continuously.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 每张图像显示的时间为一秒。动画将自动开始并持续循环。
- en: '***Common Base Class: PygAnimation***'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: The Animation and SpriteSheetAnimation classes each consist only of an
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: __init__() method and inherit from a common abstract base class,
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: PygAnimation. The __init__() methods of both classes call the inherited
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: __init__() method of the PygAnimation base class. Therefore, the __init__()
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: methods of the Animation and SpriteSheetAnimation classes only initialize
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: the unique data in their classes.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: After creating an Animation or SpriteSheetAnimation object, client code
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: needs to include calls to update() and draw() in every frame. The following
    is
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'a list of the methods available to both classes through the base class:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '**handleEvent( *event*****)**'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Must be called in every frame if you want to check if the user has clicked
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: on the animation. If so, you pass in the event supplied by pygame. This
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: method returns False most of the time, but returns True when the user
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: clicks down on the image, in which case you would typically call play().
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '**play()**'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Starts the animation playing.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Animation **307**
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '**stop()**'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Stops the animation wherever it is, and resets to showing only the first
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: image.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '**pause()**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Causes the animation to temporarily stop on the current image. You
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: can continue playing with a call to play().
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '**update()**'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Should be called in every frame. When the animation is running, this
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: method takes care of calculating the proper time to advance to the
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: next image. It typically returns False, but returns True when the anima-
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: tion ends (and it is not set to loop).
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '**draw()**'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Should be called in every frame. This method draws the current image
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: of the animation.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '**setLoop( *trueOrFalse*****)**'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Pass in True or False to indicate whether the animation should loop or
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: not.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '**getLoop()**'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Returns True if the animation is set to loop or False if it is not.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '*The location of an animation in the window is determined by the original value
    of* *loc that’s passed to __init__(). Both Animation and SpriteSheetAnimation
    inherit* *from the common PygAnimation class, and that class inherits from PygWidget.
    Since* *all the methods available in PygWidget are therefore available in both
    animation* *classes, you could easily construct an animation that also changes
    its location while* *it is playing. You can make any animation move by calling
    setLoc(), inherited from* *PygWidget, and supplying any x and y location you like
    for each image.*'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '***Example Animation Program***'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14-2 shows a screenshot of a sample program that demonstrates mul-
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: tiple animations built from the Animation and SpriteSheetAnimation classes.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: The little dinosaur on the left is an Animation object. It’s set to autoStart
    so
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: the animation plays when the program begins, but only once. Clicking the
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: buttons below the small dinosaur makes appropriate calls to the Animation
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: object. If you click Play, the animation plays again. While the animation is
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: playing, clicking Pause will freeze the animation until you click Play again.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: If you play the animation and then click Stop, the animation will stop and
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: show the first image. Below those buttons are two checkboxes. By default, this
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: animation will not loop. If you check Loop, then press Play, the animation
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: repeats until you uncheck Loop. The Show checkbox makes the animation
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: visible or invisible.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '**308** Chapter 14'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 39](index-338_1.png)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: An example animation program using the Animation and*'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '*SpriteSheetAnimation classes*'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: The second (T-rex) Animation object is not set to autoStart, so you only
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: see the first image of the animation. If you click this image, the anima-
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: tion is set to iterate through all its images three times (three loops) before
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: stopping.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: At the top right is a firework SpriteSheetAnimation object, which comes
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: from a single image containing 35 subimages. This animation is set to loop,
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: so you see it run continuously.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom right is a walking SpriteSheetAnimation from a single image
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: with 36 subimages. When you click Start, the animation plays through all
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: the images once.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: The full source code of this program is available in the *AnimationExample/*
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '*Main_AnimationExample.py* file along with the rest of the book’s resources.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: The program instantiates two Animation objects (the small dinosaur and
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: the T-rex) and two SpriteSheetAnimation objects (the firework and the walk-
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: ing person). When a button below the little dinosaur is clicked, we call the
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: appropriate method of the dinosaur animation object. A click on the little
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: dinosaur or T-rex results in a call to the start() method of that animation.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: The program shows that multiple animations can run at the same
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: time. This works because the main loop calls the update() and draw() meth-
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: ods of *each* animation in every frame in the main loop, and each animation
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: makes its own decision about keeping the current image or showing the
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: next image.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: Animation **309**
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explored the mechanisms required in an animation class
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: by building our own SimpleAnimation and SimpleSpriteSheetAnimation classes.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: The former is made up of multiple images, whereas the latter uses a single
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: larger image that contains multiple subimages.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: These two classes have different initializations, but the remaining meth-
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: ods of the classes are identical. I explained the process of merging the two
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: classes by building a common abstract base class.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: I then introduced the Animation class and the SpriteSheetAnimation class
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: in pygwidgets. I explained that these two classes only implement their own
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: versions of the __init__() method, inheriting their other methods from the
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: common base class, PygAnimation. I concluded by showing a demonstration
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: program that provides examples of animations and sprite sheet animations.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '**15**'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '**S C E N E S**'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Games and programs will often need to
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: present different scenes to the user. For the
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: purpose of this discussion, I’ll define a *scene*
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: as any window layout and related user interac-
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: tions that are significantly different from any other. For
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: example, a game like *Space Invaders* may have a starting
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: or *splash* scene, a main game play scene, a high scores
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: scene, and perhaps an ending or goodbye scene.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter I will discuss two different approaches to writing a pro-
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: gram that has multiple scenes. First, I’ll introduce the state machine tech-
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: nique, which works well for relatively small programs. Then I’ll show a fully
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: object-oriented approach where each scene is implemented as an object,
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: under the control of a scene manager. The latter is much more scalable for
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: larger programs.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '**The State Machine Approach**'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of this book, we developed a software simulation of a
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: light switch. I[n Chapter 1, w](index_split_000.html#p32)e first implemented
    a light switch using procedural code, and then we rewrote it using a class. In
    both cases, the position
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: (or state) of the switch was represented by a single Boolean variable; True
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: represented on and False represented off.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: There are many situations where a program or an object can be in
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: one of a number of different states, and different code needs to run based
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: on the current state. For example, consider the series of steps involved in
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: using an ATM. There is a starting (greeting) state, then you need to put in
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: your ATM card; after this you’re prompted to enter your PIN, choose which
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: action you want to do, and so on. At any point, you may need to go back a
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: step or even start over. The general implementation approach is to use a
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '*state machine*.'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '**state machine**'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: A model that represents and controls the flow of execution through a series
    of states .
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of a state machine consists of:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: • A collection of predefined states, typically expressed as constants whose
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: values are strings comprised of a word or short phrase that describes
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: what happens in the state
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: • A single variable to track the current state
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: • A starting state (from the set of predefined states)
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: • A set of clearly defined transitions between states
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: A state machine can only be in one state at any given time, but can
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: move to a new state, typically based on specific input from the user.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: I[n Chapter 7 w](index_split_003.html#p172)e discussed the GUI button classes
    in the pygwidgets package. When rolling over and clicking a button, a user sees
    three different images—up, over, and down—which correspond to different states
    of
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: the button. The image switching is done in the handleEvent() method (which
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: is called whenever an event occurs). Let’s take a closer look at how this is
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: implemented.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: The handleEvent() method is built as a state machine. The state is kept
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: in an instance variable, self.state. Each button starts in the up state, show-
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: ing the “up” image. When the user moves the cursor over a button, we
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: show the “over” image and the code transitions to the over state. When the
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: user clicks down on the button, we show the “down” image and the code
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: moves into the down state (internally called the *armed* state). When the user
    releases the mouse button (clicks up), we again show the “over” image, and
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: the code transitions back to the over state (and handleEvent() returns True
    to
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: indicate that a click has happened). If the user then moves the cursor off the
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: button, we show the “up” image again and transition back to the up state.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '**312** Chapter 15'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: Next, I’ll show you how we can use a state machine to represent different scenes
    that a user can encounter in a larger program. As a generic
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: 'example, we’ll have the following scenes: *Splash* (starting), *Play*, and
    *End*.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create a set of constants that represent the different states, create
    a
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: 'variable called state, and assign it the value of the starting state:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: STATE_SPLASH = 'splash'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: STATE_PLAY = 'play'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: STATE_END = 'end'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: 'state = STATE_SPLASH # initialize to starting state'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: In order to perform different actions in the different states, in the pro-
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: gram’s main loop we use an if/elif/elif/.../else construct that branches
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: 'based on the current value of the state variable:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: 'if state == STATE_SPLASH:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: Do whatever you want to do in the Splash state here
  id: totrans-545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'elif state == STATE_PLAY:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: Do whatever you want to do in the Play state here
  id: totrans-547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'elif state == STATE_END:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: Do whatever you want to do in the End state here
  id: totrans-549
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: 'raise ValueError(''Unknown value for state: '' + state)'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: Since state is initially set to STATE_SPLASH, only the first branch of the if
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: statement will run.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: The idea of a state machine is that under certain circumstances, typi-
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: cally triggered by some event, the program changes its state by assigning a
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: different value to the state variable. For example, the starting Splash scene
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: could just show a game introduction with a Start button. When the user
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: clicks the Start button, the game will execute an assignment statement that
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: 'changes the value of the state variable to transition into the Play state:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: state = STATE_PLAY
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: Once that line runs, only the code in the first elif runs and completely
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: different code will execute—the code to show and react to the Play state.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, whenever and however the program reaches the ending con-
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: dition for the game, it will execute the following line to transition to the
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: 'End state:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: state = STATE_END
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: From then on, every time the program goes around the while loop, the
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: code of the second elif branch will run.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: In summary, a state machine has a set of states, one variable to keep
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: track of which state the program is in, and a set of events that cause the pro-
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: gram to transition from one state to another. Since there is a single variable
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **313**
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 40](index-343_1.png)'
  id: totrans-573
  prefs: []
  type: TYPE_IMG
- en: that keeps track of the state, the program can be in only one of the states
    at
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: any time. Different actions that the user takes (clicking a button, pressing
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: a key, dragging an item, and so on) or other events (such as a timer run-
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: ning out) can cause the program to transition from one state to another.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: Depending on which state it is in, the program may listen for different
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: events and will typically execute different code.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '**A pygame Example with a State Machine**'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll build a Rock, Paper, Scissors game that uses a state machine.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: The user chooses rock, paper, or scissors; then the computer randomly
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: chooses among the three. If the person and computer choose the same
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: item, it’s a tie. Otherwise, one point is awarded to the player or the com-
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: 'puter, according to the following rules:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: • Rock crushes scissors.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: • Scissors cuts paper.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: • Paper covers rock.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: 'The user will see the game as three scenes: an opening or Splash scene'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: (Figure 15-1), a Play scene (Figure 15-2), and a Results scene (Figure 15-3).
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-1: The Rock, Paper, Scissors Splash scene*'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: The Splash scene waits for the user to click the Start button.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '**314** Chapter 15'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 41](index-344_1.png)'
  id: totrans-594
  prefs: []
  type: TYPE_IMG
- en: '![Image 42](index-344_2.png)'
  id: totrans-595
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-2: The Rock, Paper, Scissors Play scene*'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: The Play scene is where the user makes a choice. After the user clicks
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: an icon to indicate their choice, the computer makes a randomized choice.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-3: The Rock, Paper, Scissors Results scene*'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **315**
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: The Results scene shows the outcome of the round and the score. It waits for
    the user to click Restart to play another round.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: In this game, each value of state corresponds to a different scene.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15-4 is a *state diagram* that shows the states and transitions (the
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: actions or events that cause the program to move from one state to
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: another).
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: Choose rock, paper, or scissors
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: Press Start button
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: Splash
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: Play
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: Results
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: Press Restart button
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-4: Rock, Paper, Scissors state diagram*'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: When sitting idle (waiting for the user), the current scene will typically
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: remain unchanged. That is, inside the main event loop, the program will
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: usually not change the value of the state variable. (The state might change
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: when a timer ends, but this will be rare.) This game starts in the Splash
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: scene, and when the user presses the Start button, the game moves to the
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: Play scene. The play of the game then alternates between the Play and
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: Results scenes. Though this is a simple example, a state diagram can be very
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: useful in understanding the flow of more complicated programs.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: Listing 15-1 provides the code of the Rock, Paper, Scissors program,
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: with the boilerplate code omitted to save space.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: '**File: RockPaperScissorsStateMachine/RockPaperScissors.py**'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: Rock, Paper, Scissors in pygame
  id: totrans-624
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Demonstration of a state machine
  id: totrans-625
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: ROCK = 'Rock'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: PAPER = 'Paper'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: SCISSORS = 'Scissors'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: Set constants for each of the three states
  id: totrans-630
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: STATE_SPLASH = 'Splash' 1
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: STATE_PLAYER_CHOICE = 'PlayerChoice'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: STATE_SHOW_RESULTS = 'ShowResults'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  id: totrans-634
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-636
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: '**316** Chapter 15'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  id: totrans-639
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: playerScore = 0
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: computerScore = 0
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: 'state = STATE_SPLASH 2 # the starting state'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  id: totrans-643
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  id: totrans-645
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: 'if state == STATE_SPLASH: 3'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: 'if startButton.handleEvent(event):'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: state = STATE_PLAYER_CHOICE
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: 'elif state == STATE_PLAYER_CHOICE: 4 # let the user choose'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: 'playerChoice = '''' # indicates no choice yet'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: 'if rockButton.handleEvent(event):'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: playerChoice = ROCK
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: rpsCollectionPlayer.replace(ROCK)
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: 'elif paperButton.handleEvent(event):'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: playerChoice = PAPER
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: rpsCollectionPlayer.replace(PAPER)
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: 'elif scissorButton.handleEvent(event):'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: playerChoice = SCISSORS
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: rpsCollectionPlayer.replace(SCISSORS)
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: 'if playerChoice != '''': # player has made a choice, make computer choice'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: Computer chooses from tuple of moves
  id: totrans-665
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: rps = (ROCK, PAPER, SCISSORS)
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: 'computerChoice = random.choice(rps) # computer chooses'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: rpsCollectionComputer.replace(computerChoice)
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate the game
  id: totrans-669
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if playerChoice == computerChoice: # tie'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: resultsField.setValue('It is a tie!')
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: tieSound.play()
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: 'elif playerChoice == ROCK and computerChoice == SCISSORS:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: resultsField.setValue('Rock breaks Scissors. You win!')
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: playerScore = playerScore + 1
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: winnerSound.play()
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: 'elif playerChoice == ROCK and computerChoice == PAPER:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: resultsField.setValue('Rock is covered by Paper. You lose.')
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: computerScore = computerScore + 1
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: loserSound.play()
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **317**
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: 'elif playerChoice == SCISSORS and computerChoice == PAPER: resultsField.setValue(''Scissors
    cuts Paper. You win!'')'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: playerScore = playerScore + 1
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: winnerSound.play()
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: 'elif playerChoice == SCISSORS and computerChoice == ROCK:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: resultsField.setValue('Scissors crushed by Rock. You lose.')
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: computerScore = computerScore + 1
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: loserSound.play()
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: 'elif playerChoice == PAPER and computerChoice == ROCK:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: resultsField.setValue('Paper covers Rock. You win!')
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: playerScore = playerScore + 1
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: winnerSound.play()
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: 'elif playerChoice == PAPER and computerChoice == SCISSORS:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: resultsField.setValue('Paper is cut by Scissors. You lose.')
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: computerScore = computerScore + 1
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: loserSound.play()
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: Show the player's score
  id: totrans-697
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'playerScoreCounter.setValue(''Your Score: ''+ str(playerScore))'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: Show the computer's score
  id: totrans-699
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'computerScoreCounter.setValue(''Computer Score: ''+ str(computerScore))'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: 'state = STATE_SHOW_RESULTS # change state'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: 'elif state == STATE_SHOW_RESULTS: 5'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: 'if restartButton.handleEvent(event):'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: 'state = STATE_PLAYER_CHOICE # change state'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: raise ValueError('Unknown value for state:', state)
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  id: totrans-707
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if state == STATE_PLAYER_CHOICE:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: messageField.setValue(' Rock Paper Scissors')
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: 'elif state == STATE_SHOW_RESULTS:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: messageField.setValue('You Computer')
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: 9 - Clear the window
  id: totrans-712
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(GRAY)
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw all window elements
  id: totrans-714
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: messageField.draw()
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: 'if state == STATE_SPLASH: 6'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: rockImage.draw()
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: paperImage.draw()
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: scissorsImage.draw()
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: startButton.draw()
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: Draw player choices
  id: totrans-721
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'elif state == STATE_PLAYER_CHOICE: 7'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: rockButton.draw()
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: '**318** Chapter 15'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: paperButton.draw()
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: scissorButton.draw()
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: chooseText.draw()
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: Draw the results
  id: totrans-728
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'elif state == STATE_SHOW_RESULTS: 8'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: resultsField.draw()
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: rpsCollectionPlayer.draw()
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: rpsCollectionComputer.draw()
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: playerScoreCounter.draw()
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: computerScoreCounter.draw()
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: restartButton.draw()
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  id: totrans-736
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  id: totrans-738
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-1: The Rock, Paper, Scissors game*'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, I have snipped the code that creates images, buttons, and
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: text fields for the Splash, Play, and Results scenes. The downloadable files
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: for the book contain the full source code and all the associated art.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: Before the program goes into the main loop, we define all three states 1,
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: instantiate and load all the screen elements, and set the starting state 2\.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: We do different event checks depending on which state the program is
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: in. In the Splash state, we only check for clicking the Start button 3\. In
    the
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: Play state, we check for a click on the Rock, Paper, or Scissors icon buttons
    4\.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: In the Results state, we only check for a click on the Restart button 5\.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: Pressing a button or making a selection in one scene changes the value
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: of the state variable and therefore moves the game into a different scene.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the main loop 6 7 8, we draw different screen elements
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: depending on which state the program is currently in.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: This technique works well for a small number of states/scenes. However,
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: in a program with more complicated rules or one that has many scenes and/
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: or states, keeping track of what should be done where can become very dif-
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: ficult. Instead, we can take advantage of many of the object-oriented pro-
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: gramming techniques introduced earlier in this book and build a different
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: architecture based on independent scenes, all controlled by an object man-
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: ager object.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: '**A Scene Manager for Managing Many Scenes**'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: The second approach to building a program with multiple scenes is to use
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: 'a *scene manager*: an object that centralizes the handling of different scenes.'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create a SceneMgr class and instantiate a single oSceneMgr object from
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: it. In the following discussion, I’ll refer to the oSceneMgr object as the scene
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: manager, since we only instantiate one. As you’ll see, the scene manager
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: and the related scenes take advantage of encapsulation, inheritance, and
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: polymorphism.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **319**
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 43](index-349_1.png)'
  id: totrans-770
  prefs: []
  type: TYPE_IMG
- en: Using the scene manager can be a little tricky, but the resulting pro-
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: gram architecture results in a highly modular, easy-to-modify program. A
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: 'program that uses the scene manager will be made up of the following files:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: '**Main program** The small main program (that you write) must first'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: create an instance of every scene identified in your program, then cre-
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: ate an instance of the scene manager, passing a list of the scenes and
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: a frame rate. To start your program, you call the run() method of the
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: scene manager. For each new project you build, you must write a new
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: main program.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: '**Scene manager** The scene manager is written for you and is avail-'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: able as the SceneMgr class in the *pyghelpers.py* file. It keeps track of all
    the different scenes, remembers which one is current, calls methods in the
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: current scene, allows for switching between scenes, and handles com-
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: munication between scenes.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenes** Your program can have as many scenes as you want or need.'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: Each scene is typically developed as a separate Python file. Each scene
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: class must inherit from the prewritten Scene base class and have a set of
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: methods whose names are predefined. The scene manager uses poly-
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: morphism to call these methods in the current scene. I have provided a
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: template *ExampleScene.py* file to show you how to build a scene.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: The code for the SceneMgr class and the code for the Scene base class live
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: in the pyghelpers package. The scene manager is an object manager object
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: that manages any number of Scene objects.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: '**A Demo Program Using a Scene Manager**'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: As a demonstration, we’ll build a Scene Demo program that contains three
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: 'simple scenes: Scene A, Scene B, and Scene C. The idea is that from any'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: scene, you can click a button to get to any other scene. Figures 15-5 through
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: 15-7 show screenshots of the three scenes.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-5: What the user sees in Scene A*'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: From Scene A, you can get to Scene B or Scene C.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: '**320** Chapter 15'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 44](index-350_1.png)'
  id: totrans-801
  prefs: []
  type: TYPE_IMG
- en: '![Image 45](index-350_2.png)'
  id: totrans-802
  prefs: []
  type: TYPE_IMG
- en: '![Image 46](index-350_3.png)'
  id: totrans-803
  prefs: []
  type: TYPE_IMG
- en: '*Figure 15-6: What the user sees in Scene B*'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: From Scene B, you can get to Scene A or Scene C.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-7: What the user sees in Scene C*'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: From Scene C, you can get to Scene A or Scene B.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the project folder is shown in Figure 15-8\. Note that
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: this assumes that you have already installed the pygwidgets and pyghelpers
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: modules in the proper *site-packages* folder.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-8: The project folder showing the main program and the different
    scene files* *Main_SceneDemo.py* is the main program. *Constants.py* contains
    a few'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: constants shared by the main program and all the scenes. *SceneA.py*, *SceneB.py*,
    and *SceneC.py* are the actual scenes, each containing a related scene class.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: '*SceneExample.py* is a sample file that shows what a typical scene file might
    Scenes **321**'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: look like. It’s not used in this program, but you can refer to it to get an
    understanding of the basics of writing a typical scene.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15-9 shows how the objects in the program relate to each other.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: '**Main**'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: '*(Instantiates all scenes*'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: '*and the scene manager)*'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: '*Starts the*'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: '*scene manager*'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: '**Scene manager**'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: '*(Manages navigation and*'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: '*communication between scenes)*'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: Scene 1
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: Scene 2
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: Scene 3
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: …
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: Scene N
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: '*All scenes inherit from the Scene base class*'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-9: The hierarchy of objects in a project*'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how the different parts of a program using the scene manager
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: work together, starting with the main program.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: '***The Main Program***'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: The main program will be unique for every project. Its purpose is to initial-
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: ize the pygame environment, instantiate all the scenes, create an instance
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: of the SceneMgr, then transfer control to the scene manager, oSceneMgr.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: Listing 15-2 presents the code of the demo main program.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: '**File: SceneDemo/Main_SceneDemo.py**'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: Scene Demo main program with three scenes
  id: totrans-839
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: 1 - Import packages
  id: totrans-841
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: 1 import pyghelpers
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: from SceneA import *
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: from SceneB import *
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: from SceneC import *
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: 2 - Define constants
  id: totrans-847
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2 WINDOW_WIDTH = 640
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_HEIGHT = 180
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: '**322** Chapter 15'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  id: totrans-852
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-855
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  id: totrans-856
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instantiate all scenes and store them into a list
  id: totrans-857
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 scenesList = [SceneA(window),
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: SceneB(window),
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: SceneC(window)]
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: Create the scene manager, passing in the scenes list and the FPS
  id: totrans-861
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4 oSceneMgr = pyghelpers.SceneMgr(scenesList, FRAMES_PER_SECOND)
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: Tell the scene manager to start running
  id: totrans-863
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 5 oSceneMgr.run()
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-2: A sample main program using the scene manager*'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: The code of the main program is relatively short. We start by import-
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: ing pyghelpers, then all the scenes (in this case, Scene A, Scene B, and
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: Scene C) 1\. We then define a few more constants, initialize pygame, and
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: create the window 2\. Next, we create an instance of each scene and store
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: all the scenes in a list 3\. After this line executes, we have an initialized
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: object for each scene.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: We then instantiate the scene manager object (oSceneMgr) 4 from the
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: 'SceneMgr class. When we create this object, we need to pass in two values:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: • The list of scenes, so the scene manager can be aware of all the scenes.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: The first scene in the list of scenes is used as the starting scene for the
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: program.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: • The frames per second (frame rate) that the program should maintain.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we tell the scene manager to start running by calling its run()
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: method 5\. The scene manager always maintains a single scene as the cur-
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: rent scene—the one that the user sees and interacts with.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: Notice that with this approach, the main program implements the ini-
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: tialization of a typical pygame program but does *not* build the main loop.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the main loop is built into the scene manager itself.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: '***Building the Scenes***'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: To understand the interaction between the scene manager and any indi-
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: vidual scene, I’ll explain how a typical scene is built.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: Each time through its loop, the scene manager calls a predefined set
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: of methods in the current scene that are intended to handle events, do any
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: per-frame actions, and draw anything that needs to be drawn in that scene.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the code of each scene must be split up into these methods. The
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: 'approach makes use of polymorphism: each scene needs to implement a'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: common set of methods.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **323**
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: '**Methods to Implement in Each Scene**'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: Each scene is implemented as a class that inherits from the Scene base
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: class defined in the *pyghelpers.py* file. Therefore, each scene must import
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: pyghelpers. At a minimum, a scene needs to contain an __init__() method
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: and must override the getSceneKey(), handleInputs(), and draw() methods
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: from the base class.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: Every scene must have a unique *scene key*—a string used by the scene
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: manager to identify each scene. I recommend that you build a file with a
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: 'name like *Constants.py* that contains the keys for all the scenes and import
    this file into each scene file. For example, the *Constants.py* file for the sample
    program contains:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: 'Scene keys (any unique values):'
  id: totrans-903
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SCENE_A = 'scene A'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: SCENE_B = 'scene B'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: SCENE_C = 'scene C'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: During its initialization, the scene manager calls the getSceneKey()
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: method of each scene, which simply returns its unique scene key. The
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: scene manager then builds an internal dictionary of scene keys and scene
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: objects. When any scene in the program wants to switch to a different
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: scene, it will call self.goToScene() (described in the following section) and
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: pass in the scene key of the target scene. The scene manager uses this key
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: in the dictionary to find the associated scene object; it then sets the new
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: scene object as the current scene and calls its methods.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: Each scene must contain its own version of handleInputs() to handle any
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: events that would typically be handled in the main loop and its own version
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: of draw() to draw anything the scene wants to draw in the window. If your
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: scene does not override these two methods, it will not be able to respond to
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: any events and will not draw anything in the window.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at the four methods you need to implement for
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: 'each scene:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: '**def __init__(self, window):**'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: Each scene should begin with its own __init__() method. The window
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: parameter is the window into which your program draws. You should
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: start your method with this statement to save the window parameter for
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: 'use in the draw() method:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: After that, you can include any other initialization code you want or
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: need, such as code for instantiating buttons and text fields, loading
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: images and sounds, and so on.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: '**def getSceneKey(self):**'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: This method must be implemented in every scene that you write. Your
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: method must return the unique scene key associated with this scene.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: '**324** Chapter 15'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: '**def handleInputs(self, events, keyPressedList):**'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: This method must be implemented in every scene that you write. It
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: should do everything needed to deal with events or keys. The events
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: parameter is a list of events that happened since the last frame, and
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: keyPressedList is a list of Booleans representing the state of all keyboard
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: keys (True means down). To find whether a particular key is up or down,
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: you should use a constant rather than an integer index. The constants
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: representing all keys of the keyboard are available in the pygame docu-
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: mentation [( *https://www.pygame.org/docs/ref/key.html*).](https://www.pygame.org/docs/ref/key.html)
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: Your implementation of this method should contain a for loop that
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: loops through all events in the list that is passed in. If you want, it can
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: also contain code to implement the continuous mode of handling the
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: keyboard, as described i[n Chapter 5\.](index_split_002.html#p118)
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: '**def draw(self):**'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: This method must be implemented in every scene that you write. It
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: should draw everything that needs to be drawn in the current scene.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: The scene manager also calls the following methods in each scene. In
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: the Scene base class, these methods each contain a simple pass statement, so
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: they don’t do anything. You can override any or all of them to execute any
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: 'code you want for a particular scene:'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: '**def enter(self, data):**'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: This method is called after the scene manager has made the transi-
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: tion into this scene. There is a single data parameter, with None as a
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: default. If data is not None, then the information it contains was sent
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: from the previous scene when it called goToScene() (described in the
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: next section). The value of data can take any form—from a single
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: string or numeric value to a list or dictionary to an object—as long
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: as the leaving scene and the entering scene agree on the type of data
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: being passed. The enter() method should do whatever it needs to do
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: when this scene is about to be given control.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: '**def update(self):**'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: This method is called in every frame. Here, you can perform any
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: actions you would have done in step 8 of the original 12-step template
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: introduced in [Chapter 5\. F](index_split_002.html#p118)or example, you might
    want this method to move images on the screen, check for collisions, and so on.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: '**def leave(self):**'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: This method is called by the scene manager whenever the program
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: is about to transition to a different scene. It should do any cleanup
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: that needs to be done before leaving, such as writing information to
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: a file.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **325**
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: '**Navigating Between Scenes**'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: The scene manager and the Scene base class provide a simple way to navi-
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: gate between scenes. When the program wants to transition to another
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: scene, the current scene should call its own goToScene() method, which is in
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: 'the inherited Scene base class, like this:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: self.goToScene(nextSceneKey, data)
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: The goToScene() method communicates to the scene manager that you
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: want to transition to a different scene, whose scene key is nextSceneKey. You
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: should make all scene keys available via a file such as *Constants.py*. The
    data parameter is any optional information that you want to pass on to the next
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: scene. If no data needs to be transferred, you can eliminate this argument.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: 'Typical calls would look like this:'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: 'self.goToScene( *SOME_SCENE_KEY*) # no data to be passed'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: Or
  id: totrans-987
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'self.goToScene( *ANOTHER_SCENE_KEY*, data= *someValueOrValues*) # go to a scene
    and pass data The value of data can take any form, as long as the scenes being
    left and'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: entered both understand the format. In response to this call, before leav-
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: ing the current scene, the scene manager calls that scene’s leave() method.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: When the next scene is about to be activated, the scene manager calls that
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: scene’s enter() method and passes the value of data to the new scene.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: '**Quitting the Program**'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: The scene manager takes care of three different ways that the user can quit
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: 'the currently running program:'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: • By clicking the close button at the top of the window.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: • By pressing the ESCAPE key.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: • Through any additional mechanism such as a Quit button. In this case,
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: 'make the following call (which is also built into the Scene base class):'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: 'self.quit() # quits the program'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: '***A Typical Scene***'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: Listing 15-3 shows an example of a typical scene—this is the *SceneA.py* file
    that implements Scene A in the demo program, shown in Figure 15-5\. Remember
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: that the main loop is implemented by the scene manager. Inside its main loop,
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: the scene manager calls the handleInputs(), update(), and draw() methods for
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
- en: the current scene.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
- en: '**326** Chapter 15'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: '**File: SceneDemo/SceneA.py**'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: Scene A
  id: totrans-1008
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygwidgets
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: import pyghelpers
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: import pygame
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: from Constants import *
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: 'class SceneA(pyghelpers.Scene):'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: '1 def __init__(self, window):'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: self.messageField = pygwidgets.DisplayText(self.window,
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: (15, 25), 'This is Scene A', fontSize=50,
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: textColor=WHITE, width=610, justified='center')
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: self.gotoAButton = pygwidgets.TextButton(self.window,
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: (250, 100), 'Go to Scene A')
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: self.gotoBButton = pygwidgets.TextButton(self.window,
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: (250, 100), 'Go to Scene B')
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: self.gotoCButton = pygwidgets.TextButton(self.window,
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: (400, 100), 'Go to Scene C')
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: self.gotoAButton.disable()
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: '2 def getSceneKey(self):'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: return SCENE_A
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: '3 def handleInputs(self, eventsList, keyPressedList):'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: 'for event in eventsList:'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.gotoBButton.handleEvent(event):'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: 4 self.goToScene(SCENE_B)
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.gotoCButton.handleEvent(event):'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: 5 self.goToScene(SCENE_C)
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip (testing code to send messages) ---'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: '6 def draw(self):'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: self.window.fill(GRAYA)
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: self.messageField.draw()
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: self.gotoAButton.draw()
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: self.gotoBButton.draw()
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: self.gotoCButton.draw()
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip (testing code to respond to messages) ---'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-3: A typical scene (Scene A in the Scene Demo program)*'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **327**
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: In the __init__() method 1, we save away the window parameter in an instance
    variable. We then create an instance of a DisplayText field to show a
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: title and create some TextButtons to allow for navigation to the other scenes.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: The getSceneKey() method 2 just returns the unique scene key (found
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: in *Constants.py*) for this scene. In the handleInputs() method 3, if the user
    has clicked the button for a different scene, we call the self.goToScene()
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: navigation method 4 5 to transfer control to the new scene. In the draw()
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: method 6, we fill the background, draw the message field, and draw the
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: buttons. This example scene does very little, so we don’t need to write our
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: own enter(), update(), and leave() methods. Calls to these methods will be
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: handled by methods of the same names in the Scene base class, and those
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: methods don’t do anything—they simply execute a pass statement.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: The two other scene files are *SceneB.py* and *SceneC.py*. The only differences
    are the titles shown, the buttons drawn, and the effects of clicking the
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: buttons to transfer to the appropriate new scene.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: '**Rock, Paper, Scissors Using Scenes**'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: Let’s build an alternate implementation of the Rock, Paper, Scissors game
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: using the scene manager. To the user, the game will work exactly the same
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: way as the earlier state machine version. We’ll build a Splash scene, a Play
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
- en: scene, and a Results scene.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: All of the source code is available, so I won’t go through every Python
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: file. The Splash scene is just a background picture with a Start button. When
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: the user presses the Start button, the code executes goToScene(SCENE_PLAY) to
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
- en: transfer to the Play scene. In the Play scene, the user is presented with a
    set
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: of images (rock, paper, and scissors) and asked to choose one. Clicking an
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: image transfers control to the Results scene. Listing 15-4 contains the code
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: of the Play scene.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: '**File: RockPaperScissorsWithScenes/ScenePlay.py**'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: The Play scene
  id: totrans-1070
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The player chooses among rock, paper, or scissors
  id: totrans-1071
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygwidgets
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: import pyghelpers
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: import pygame
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: from Constants import *
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: import random
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: 'class ScenePlay(pyghelpers.Scene):'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window):'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: self.RPSTuple = (ROCK, PAPER, SCISSORS)
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: '**328** Chapter 15'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: 'def getSceneKey(self): 1'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: return SCENE_PLAY
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: 'def handleInputs(self, eventsList, keyPressedList): 2'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: playerChoice = None
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: 'for event in eventsList:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.rockButton.handleEvent(event):'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: playerChoice = ROCK
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.paperButton.handleEvent(event):'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: playerChoice = PAPER
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.scissorButton.handleEvent(event):'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: playerChoice = SCISSORS
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
- en: 'if playerChoice is not None: 3 # user has made a choice'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: 'computerChoice = random.choice(self.RPSTuple) # computer chooses'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: 'dataDict = {''player'': playerChoice, ''computer'': computerChoice} 4'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: 'self.goToScene(SCENE_RESULTS, dataDict) 5 # go to Results scene'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: No need to include update method, defaults to inherited one which does nothing
  id: totrans-1098
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def draw(self):'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
- en: self.window.fill(GRAY)
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: self.titleField.draw()
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
- en: self.rockButton.draw()
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: self.paperButton.draw()
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: self.scissorButton.draw()
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
- en: self.messageField.draw()
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-4: The Play scene in Rock, Paper, Scissors*'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: I’ve snipped the code to create text fields and the rock, paper, and scis-
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
- en: sors buttons. The getSceneKey() method 1 simply returns the scene key for
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: this scene.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
- en: The most important method is handleInputs() 2, which is called in every
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: frame. If any button is clicked, we set a variable named playerChoice to an
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
- en: appropriate constant 3, and we make a random choice for the computer.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: We then take the player’s choice and the computer’s choice and build a
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: simple dictionary 4 incorporating both, so we can pass this information
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: as data to the Results scene. Finally, to transfer to the Results scene, we
    call
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: goToScene() and pass the dictionary 5\.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: The scene manager receives this call, calls leave() for the current scene
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: (Play), changes the current scene to the new scene (Results), and calls enter()
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: for the new scene (Results). It passes the data from the leaving scene into
    the
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: enter() method of the new scene.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: Listing 15-5 contains the code of the Results scene. There’s a lot of code
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
- en: here, but most of it deals with showing the appropriate icons and the evalu-
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: ation of the results of the round.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **329**
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
- en: '**File: RockPaperScissorsWithScenes/SceneResults.py**'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: The Results scene
  id: totrans-1126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The player is shown the results of the current round
  id: totrans-1127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygwidgets
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
- en: import pyghelpers
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: import pygame
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: from Constants import *
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: 'class SceneResults(pyghelpers.Scene):'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window, sceneKey):'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: self.playerScore = 0
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: self.computerScore = 0
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: 1 self.rpsCollectionPlayer = pygwidgets.ImageCollection(
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: window, (50, 62),
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: '{ROCK: ''images/Rock.png'','
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: 'PAPER: ''images/Paper.png'','
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: 'SCISSORS: ''images/Scissors.png''}, '''')'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: self.rpsCollectionComputer = pygwidgets.ImageCollection(
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: window, (350, 62),
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: '{ROCK: ''images/Rock.png'','
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: 'PAPER: ''images/Paper.png'','
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: 'SCISSORS: ''images/Scissors.png''}, '''')'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: self.youComputerField = pygwidgets.DisplayText(
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: window, (22, 25),
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: '''You Computer'','
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
- en: fontSize=50, textColor=WHITE,
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: width=610, justified='center')
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: self.resultsField = pygwidgets.DisplayText(
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
- en: self.window, (20, 275), '',
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: fontSize=50, textColor=WHITE,
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: width=610, justified='center')
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: self.restartButton = pygwidgets.CustomButton(
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: self.window, (220, 310),
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: up='images/restartButtonUp.png',
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: down='images/restartButtonDown.png'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: over='images/restartButtonHighlight.png')
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: self.playerScoreCounter = pygwidgets.DisplayText(
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: self.window, (86, 315), 'Score:',
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: fontSize=50, textColor=WHITE)
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: self.computerScoreCounter = pygwidgets.DisplayText(
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: self.window, (384, 315), 'Score:',
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: fontSize=50, textColor=WHITE)
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: '**330** Chapter 15'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: Sounds
  id: totrans-1168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.winnerSound = pygame.mixer.Sound("sounds/ding.wav")
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: self.tieSound = pygame.mixer.Sound("sounds/push.wav")
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: self.loserSound = pygame.mixer.Sound("sounds/buzz.wav")
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: '2 def enter(self, data):'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: 'data is a dictionary (comes from the Play scene) that looks like:'
  id: totrans-1173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '{''player'': playerChoice, ''computer'': computerChoice}'
  id: totrans-1174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: playerChoice = data['player']
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: computerChoice = data['computer']
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: Set the player and computer images
  id: totrans-1177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 self.rpsCollectionPlayer.replace(playerChoice)
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: self.rpsCollectionComputer.replace(computerChoice)
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate the game's win/lose/tie conditions
  id: totrans-1180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '4 if playerChoice == computerChoice:'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: self.resultsField.setValue("It's a tie!")
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: self.tieSound.play()
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: 'elif playerChoice == ROCK and computerChoice == SCISSORS:'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: self.resultsField.setValue("Rock breaks Scissors. You win!")
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: self.playerScore = self.playerScore + 1
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: self.winnerSound.play()
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: Show the player's and computer's scores
  id: totrans-1189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.playerScoreCounter.setValue(
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: '''Score: '' + str(self.playerScore))'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: self.computerScoreCounter.setValue(
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: '''Score: '' + str(self.computerScore))'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: '5 def handleInputs(self, eventsList, keyPressedList):'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: 'for event in eventsList:'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.restartButton.handleEvent(event):'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: self.goToScene(SCENE_PLAY)
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: No need to include update method,
  id: totrans-1198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: defaults to inherited one which does nothing
  id: totrans-1199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6 def draw(self):'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: self.window.fill(OTHER_GRAY)
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: self.youComputerField.draw()
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: self.resultsField.draw()
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: self.rpsCollectionPlayer.draw()
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
- en: self.rpsCollectionComputer.draw()
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: self.playerScoreCounter.draw()
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: self.computerScoreCounter.draw()
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: self.restartButton.draw()
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-5: The Results scene in Rock, Paper, Scissors*'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **331**
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: Here, I’ve snipped some of the game evaluation logic. The enter()
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: method 2 is the most important method in this class. When the player
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: makes a choice in the previous Play scene, the program transitions to this
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: Results scene. First, we extract the player’s and computer’s choices that were
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: 'passed in from the Play scene as a dictionary, which looks like this:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: '{''player'': playerChoice, ''computer'': computerChoice}'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: In the __init__() method 1, we create ImageCollection objects for the
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: player and computer, each containing the rock, paper, and scissors images.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: In the enter() method 2, we use the replace() method of ImageCollection 3
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: to show the images that represent the player’s and the computer’s choices.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: Then, the evaluation is quite simple 4\. If the computer and the player
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
- en: made the same choice, we have a tie, and we play an appropriate tie sound.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: If the player wins, we increment the player’s score and play a happy sound.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
- en: If the computer wins, we increment the computer’s score and play a sad
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: sound. We update the player’s or the computer’s score and show the scores
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
- en: in the matching text display fields.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: After the enter() method runs (one time for each round), the
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
- en: handleInputs() method 5 is called in every frame by the scene manager.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks Restart, we call the inherited goToScene() method
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: to transfer back to the Play scene.
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: The draw() method 6 draws everything in the window for this scene.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: In this scene, we don’t do any additional work in each frame, so we don’t
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: need to write an update() method. When the scene manager calls update(),
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
- en: the inherited method in the Scene base class runs and just executes a pass
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: statement.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: '**Communication Between Scenes**'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
- en: The scene manager provides a set of methods that allow scenes to com-
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: municate with each other by sending or requesting information. This com-
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: munication won’t be needed by all programs but can be highly useful. The
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: 'scene manager allows any scene to:'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: • Request information from another scene
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
- en: • Send information to another scene
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
- en: • Send information to all other scenes
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, I’ll call the scene the user is seeing the *cur-*
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
- en: '*rent* scene. The scene that the current scene is sending information to or'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: requesting information from is the *target* scene. The methods used to trans-
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: fer information are all implemented in the Scene base class. Therefore, all
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
- en: scenes (which must inherit from the Scene base class) have access to these
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: methods using self. *<method>* ().
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: '**332** Chapter 15'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
- en: '***Requesting Information from a Target Scene***'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: To request information from any other scene, a scene makes a call to the
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: 'inherited request() method, like this:'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: self.request(targetSceneKey, requestID)
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
- en: This call allows the current scene to ask for information from a target
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: scene, identified by its scene key (targetSceneKey). The requestID uniquely
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
- en: identifies the information you are asking for. The value used for a requestID
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
- en: would normally be a constant defined in a file like *Constants.py*. The call
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: 'returns the requested information. A typical call would look like this:'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: someData = self.request( *SOME_SCENE_KEY*, *SOME_INFO_CONSTANT*)
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: This effectively says, “Issue a request to the *SOME_SCENE_KEY* scene asking
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: for information identified by *SOME_INFO_CONSTANT*.” The data is returned and
    assigned to the someData variable.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: 'The scene manager acts as an intermediary: it receives the call to'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: request() and turns it into a call to respond() in the target scene. To make
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
- en: a target scene able to give information, you must implement a respond()
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: 'method in that scene’s class. The method should start like this:'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: 'def respond(self, requestID):'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: The typical code of a respond() method checks the value of the requestID
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: parameter and returns the appropriate data. The data returned can be for-
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: matted in any way that the current scene and the target scene agree on.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: '***Sending Information to a Target Scene***'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: To send information to a target scene, the current scene makes a call to the
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: 'inherited send() method, like this:'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: self.send(targetSceneKey, sendID, info)
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: This call allows the current scene to send information to a target scene,
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: identified by its scene key (targetSceneKey). The sendID uniquely identifies
    the
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: information you are sending. The info parameter is the information you
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: want to send to the target scene.
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical call would look like this:'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: self.send( *SOME_SCENE_KEY*, *SOME_INFO_CONSTANT*, data)
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
- en: This effectively says, “Send information to the *SOME_SCENE_KEY* scene. The
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: information is identified by *SOME_INFO_CONSTANT*, and the information is in
    the value of the variable data.”
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
- en: The scene manager receives the call to send() and turns it into a call
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: to receive() in the target scene. To allow a scene to send information to
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **333**
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
- en: 'another scene, you must implement a receive() method in your target scene class,
    like this:'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: 'def receive(self, receiveID, info):'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
- en: The receive() method can contain an if/elif/else construct if it needs
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
- en: to handle different values for receiveID. The transmitted information can be
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
- en: formatted in any way that the current scene and the target scene agree on.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
- en: '***Sending Information to All Scenes***'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
- en: As an additional convenience, a scene can send information to all other
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
- en: 'scenes using the single method sendAll():'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
- en: self.sendAll(sendID, info)
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
- en: This call allows the current scene to send information to all the other
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
- en: scenes. The sendID uniquely identifies the information you are sending. The
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: info parameter is the information you want to send to all scenes.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical call would look like this:'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: self.sendAll( *SOME_INFO_CONSTANT*, data)
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: This effectively says, “Send information to all scenes. The information
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
- en: is identified by *SOME_INFO_CONSTANT*, and the information is in the value of
    the variable data.”
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: For this to work, all scenes other than the current scene must implement
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: the receive() method, as described in the previous section. The scene manager
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
- en: sends the message to all scenes (other than the current scene). The current
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: scene may contain a receive() method for information sent by other scenes.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: '***Testing Communications Among Scenes***'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: The Scene Demo program (with Scene A, Scene B, and Scene C), discussed
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
- en: earlier with Listings 15-2 and 15-3, contains code in each scene that demon-
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
- en: strates calls to send(), request(), and sendAll(). In addition, the scenes each
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
- en: implement simple versions of the receive() and respond() methods. In the demo
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
- en: program, you can send a message to another scene by pressing A, B, or C.
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
- en: Pressing X sends a message to all scenes. Pressing 1, 2, or 3 sends a request
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
- en: to get data from a target scene. The target scene responds with a string.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation of the Scene Manager**'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
- en: Here we’ll look at how the scene manager is implemented. However, one
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
- en: important lesson of OOP is that the developer of client code doesn’t need to
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
- en: understand the implementation of a class, only the interface. With respect to
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
- en: the scene manager, you don’t need to know how it works, only what methods
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
- en: you must implement in your scenes, when they are called, and what methods
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
- en: you can call. Therefore, if you’re not interested in the internals, you can
    go
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
- en: right to the Summary. If you are interested, this section goes through the
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
- en: '**334** Chapter 15'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
- en: implementation details, and along the way you’ll learn an interesting technique
    to allow for two-way communication between objects.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
- en: The scene manager is implemented in a class named SceneMgr in the
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
- en: pyghelpers module. As explained previously, in your main program, you cre-
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
- en: 'ate a single instance of the scene manager like this:'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
- en: oSceneMgr = SceneMgr(scenesList, FRAMES_PER_SECOND)
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
- en: 'The last line of your main program needs to be:'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
- en: oSceneMgr.run()
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
- en: Listing 15-6 contains the code of the __init__() method of the SceneMgr
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
- en: class.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, scenesList, fps):'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
- en: 'Build a dictionary, each entry of which is a sceneKey : scene object'
  id: totrans-1334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 self.scenesDict = {}
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
- en: '2 for oScene in scenesList:'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
- en: key = oScene.getSceneKey()
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
- en: self.scenesDict[key] = oScene
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
- en: The first element in the list is used as the starting scene
  id: totrans-1339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 self.oCurrentScene = scenesList[0]
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
- en: self.framesPerSecond = fps
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
- en: Give each scene a reference back to the SceneMgr.
  id: totrans-1342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This allows any scene to do a goToScene, request, send,
  id: totrans-1343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: or sendAll, which gets forwarded to the scene manager.
  id: totrans-1344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '4 for key, oScene in self.scenesDict.items():'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
- en: oScene._setRefToSceneMgr(self)
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-6: The __init__() method of the SceneMgr class*'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() method keeps track of all scenes in a dictionary 1\. It
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
- en: iterates through the list of scenes, asking each scene for its scene key, and
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
- en: builds a dictionary 2\. The first scene object in the list of scenes is used
    as
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
- en: the starting scene 3\.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the __init__() method does some interesting work. The
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
- en: scene manager holds a reference to every scene, so it can send messages to
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
- en: any and every scene. But every scene also needs to be able to send messages
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
- en: to the scene manager. To allow each scene to do that, the last for loop in
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
- en: the __init__() method calls the special method _setRefToSceneMgr() 4 that
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
- en: lives in the base class of every scene, and it passes self, which is a reference
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
- en: 'to the scene manager. The entire code of this method consists of a single line:'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
- en: 'def _setRefToSceneMgr(self, oSceneMgr):'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
- en: self.oSceneMgr = oSceneMgr
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **335**
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
- en: This method just stores this reference back to the scene manager in an instance
    variable, self.oSceneMgr. Each scene can use this variable to make
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
- en: calls to the scene manager. I’ll show how scenes use this a little later in
    this
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
- en: section.
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
- en: '***run() Method***'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
- en: For every project you build, you have to write a small main program that
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
- en: instantiates the scene manager. The last step in your main program is a call
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
- en: to the run() method of the scene manager. This is where the main loop of
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
- en: the whole program lives. Listing 15-7 contains the code of that method.
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
- en: 'def run(self):'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
- en: clock = pygame.time.Clock()
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  id: totrans-1374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
- en: 1 keysDownList = pygame.key.get_pressed()
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  id: totrans-1377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2 eventsList = []
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
- en: if (event.type == pygame.QUIT) or \
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
- en: ((event.type == pygame.KEYDOWN) and
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
- en: '(event.key == pygame.K_ESCAPE)):'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
- en: Tell the current scene we're leaving
  id: totrans-1383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.oCurrentScene.leave()
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
- en: eventsList.append(event)
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: Here, we let the current scene process all events,
  id: totrans-1388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: do any "per frame" actions in its update method,
  id: totrans-1389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: and draw everything that needs to be drawn.
  id: totrans-1390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 self.oCurrentScene.handleInputs(eventsList, keysDownList)
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
- en: 4 self.oCurrentScene.update()
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
- en: 5 self.oCurrentScene.draw()
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  id: totrans-1394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 6 pygame.display.update()
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  id: totrans-1396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: clock.tick(self.framesPerSecond)
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-7: The run() method of the SceneMgr class*'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
- en: '**336** Chapter 15'
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
- en: The run() method is the key to how the scene manager works. Remember that all
    scenes must be polymorphic—at a minimum, each must implement
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: a handleInputs() and a draw() method. Each time through the loop, the run()
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
- en: 'method does the following:'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
- en: • Gets a list of all keyboard keys 1 (False means up, True means down).
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
- en: • Builds a list of events 2 that have happened since the last time through
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
- en: the loop.
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
- en: • Makes calls to the polymorphic methods 3 of the current scene. The cur-
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
- en: rent scene is always kept in an instance variable named self.oCurrentScene.
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
- en: In the call to the scene’s handleInputs() method, the scene manager
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
- en: passes in the list of events that have happened and the list of keys. Each
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
- en: scene is responsible for handling the events and for dealing with the
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: state of the keyboard.
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
- en: • Calls the update() method 4 to allow the scene to do any per-frame
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
- en: actions. The Scene base class implements an update() method that just
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
- en: contains a pass statement, but a scene can override this method with
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
- en: any code it wants to execute.
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
- en: • Calls the draw() method 5 to allow the scene to draw anything it needs
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
- en: to draw in the window.
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the loop (identical to the standard main loop with-
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: out a scene manager), the method updates the window 6 and waits for an
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
- en: appropriate amount of time.
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
- en: '***Main Methods***'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
- en: The remaining methods of the SceneMgr class implement the navigation and
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
- en: 'communication between scenes:'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
- en: '**_goToScene()** Called to transfer to a different scene'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
- en: '**_request_respond()** Called to query data in another scene'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
- en: '**_send_receive()** Called to send information from one scene to another'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
- en: '**_sendAll_receive()** Called to send information from one scene to all'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
- en: other scenes
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: The code of any scenes that you write should not call these methods
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
- en: directly, and they should not be overwritten. The underscore in front of
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
- en: their names implies that these are private (internal) methods. While they
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
- en: are not called directly within the scene manager itself, they are called by
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
- en: the Scene base class.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
- en: To explain how these methods work, I’ll start by giving an overview
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
- en: of the steps involved when a scene wants to navigate to another scene. To
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
- en: 'make a transition to a target scene, the current scene calls:'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
- en: self.goToScene( *SOME_SCENE_KEY*)
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **337**
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
- en: When a scene makes this call, the call goes to the goToScene() method in the
    inherited Scene base class. The code of the inherited method consists of
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
- en: 'a single line:'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
- en: 'def goToScene(self, nextSceneKey, data=None):'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
- en: self.oSceneMgr._goToScene(nextSceneKey, data)
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
- en: This makes a call to the private _goToScene() method in the scene man-
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
- en: ager. Within the scene manager’s method, we need to give the current
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
- en: scene an opportunity to do any cleanup that might be needed, then trans-
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
- en: fer control to the new scene. Here is the code of the _goToScene() method of
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
- en: 'the scene manager:'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: 'def _goToScene(self, nextSceneKey, dataForNextScene):'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
- en: 'if nextSceneKey is None: # meaning, exit'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
- en: Call the leave method of the old scene to allow it to clean up.
  id: totrans-1454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Set the new scene (based on the key) and
  id: totrans-1455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: call the enter method of the new scene.
  id: totrans-1456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 self.oCurrentScene.leave()
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
- en: 'pygame.key.set_repeat(0) # turn off repeating characters'
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
- en: 2 self.oCurrentScene = self.scenesDict[nextSceneKey]
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
- en: 'except KeyError:'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
- en: raise KeyError("Trying to go to scene '" + nextSceneKey +
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
- en: '"'' but that key is not in the dictionary of scenes.")'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
- en: 3 self.oCurrentScene.enter(dataForNextScene)
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
- en: The _goToScene() method performs a number of steps to transition
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: from the current scene to the target scene. First, it calls leave() in the cur-
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
- en: rent scene 1 so the current scene can do any necessary cleanup. Then,
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
- en: using the target scene key that was passed in, it finds the object for the target
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
- en: scene 2 and sets that as the current scene. Finally, it calls enter() for the
    new
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
- en: current scene 3 to allow the new current scene to do any required setup.
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: From this point on, the run() method of the scene manager loops and
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
- en: calls the handleInputs(), update(), and draw() methods of the current scene.
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
- en: These methods will be called in the current scene until the program exe-
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: cutes another call to self.goToScene() to transition to yet another scene or
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
- en: the user quits the program.
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
- en: '***Communication Between Scenes***'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s discuss how one scene communicates with another scene. To
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: request information from another scene, a scene only needs to make a call
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: 'to self.request(), which lives in the Scene base class, like this:'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
- en: dataRequested = self.request( *SOME_SCENE_KEY*, *SOME_DATA_IDENTIFIER*)
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
- en: '**338** Chapter 15'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: 'The target scene must have a respond() method. That method needs to be defined
    like this:'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
- en: 'def respond(self, requestID):'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
- en: It uses the value of requestID to uniquely identify what data to retrieve
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
- en: and returns that data. Again, the requesting scene and the target scene
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: must agree on the value of any identifier(s). The full process is shown in
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15-10\.
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
- en: '**Scene manager**'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
- en: self._request_respond()
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: Return data
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: '**Scene**'
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
- en: '**Scene**'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: '*(Base class)*'
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
- en: '*(Base class)*'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
- en: arget.respond()
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
- en: Return data
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
- en: oT
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
- en: self.request()
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
- en: Return data
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
- en: '**Current**'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
- en: '**Current**'
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
- en: '**scene**'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
- en: '**scene**'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-10: The communication path of one scene asking for information from*'
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
- en: '*another scene*'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
- en: The current scene cannot get information from another scene directly,
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: since the current scene does not have a reference to any other scene.
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
- en: Instead, it uses the scene manager as an intermediary. Here is how it all
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
- en: 'works:'
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The current scene makes a call to self.request(), which lives in the
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
- en: inherited Scene base class.
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
- en: 2\. The
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: Scene base class has a reference to the scene manager in its
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
- en: instance variable self.oSceneMgr, to allow its methods to call methods
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
- en: of the scene manager. The self.request() method calls the scene
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
- en: manager’s _request_respond() method to request information from a
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
- en: target scene.
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
- en: 3\. The scene manager has a dictionary of all scene keys and related
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
- en: objects, and it uses the parameter that’s passed in to find the object
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
- en: associated with the target scene. It then calls the respond() method in
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
- en: the target scene.
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
- en: 4\. The
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: respond() method in the target scene (which you must write) does
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
- en: whatever it needs to do to generate the data that was asked for, then
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
- en: returns the data to the scene manager.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **339**
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
- en: 5\. The scene manager returns the data to the request() method in the Scene
    base class inherited by the current scene.
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Finally, the request() method in the Scene base class returns the data to
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
- en: the original caller.
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
- en: The same mechanism is used to implement send() and sendAll(). The
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
- en: only difference is that when sending a message to a scene or to all scenes,
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
- en: there is no data to be returned to the original caller.
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I introduced two different ways to implement a program
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
- en: that incorporates multiple scenes. A state machine is a technique for rep-
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
- en: resenting and controlling the flow of execution through a series of states;
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
- en: you can use it to implement a program with a small number of scenes. The
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
- en: scene manager is designed to help you build larger multi-scene applications
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
- en: by providing navigation and a general way for scenes to communicate with
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
- en: each other. I also explained how the scene manager implements all this
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
- en: functionality.
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
- en: The scene manager and the Scene base class provide clear examples of
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: 'the three main tenets of object-oriented programming: encapsulation, poly-'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
- en: morphism, and inheritance. Each scene is a good example of encapsulation
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
- en: because all the code and data of a scene is written as a class. Each scene class
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
- en: must be polymorphic, in that it must implement a common set of methods
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
- en: in order for it to work with calls from the scene manager. Finally, each scene
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: inherits from a common Scene base class. Two-way communication between
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
- en: the scene manager and the Scene base class is implemented by every scene
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
- en: using the inherited methods and instance variables in the base class.
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
- en: '**340** Chapter 15'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
- en: '**16**'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: '**F U L L G A M E : D O D G E R**'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll build a full game called
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
- en: Dodger that uses many of the techniques
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
- en: and concepts that have been explained
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: in this book. This is a fully object-oriented
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
- en: extended version of a game originally developed by
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
- en: Al Sweigart in his book *Invent Your Own Computer Games*
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
- en: '*with Python* (No Starch, 2016; the basic game concept,'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
- en: graphics, and sounds are used by permission).
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
- en: Before I get into the game itself, I’ll introduce a set of functions that
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: present modal dialogs that we’ll use in the game. A *modal dialog* is one
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: that forces the user to interact with it—choosing an option, for example—
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
- en: before they can continue using the underlying program. These dialogs
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
- en: stop the program from running until an option is clicked.
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
- en: '**Modal Dialogs**'
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
- en: 'The pyghelpers module has two types of modal dialogs:'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
- en: • *Yes/No dialogs* present a question and wait for the user to click one of
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: two buttons. The text of these buttons defaults to Yes and No, though
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
- en: you can use any text you like (for example, OK and Cancel). If no text
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: is specified for the No button, this dialog can be used as an alert, with
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
- en: only a Yes (or typically, OK) button.
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: • *Answer dialogs* present a question, a text field for the user to type in,
    and a set of buttons with text defaulting to OK and Cancel. The user can
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
- en: answer the question and click OK or cancel (close) the dialog by click-
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
- en: ing Cancel.
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
- en: You present each type of dialog to the user by calling a particular func-
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: 'tion in the pyghelpers module. Each dialog comes in two flavors: a simple'
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
- en: TextButton-based version and a more complicated custom version. The sim-
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: ple text version uses a default layout with two TextButton objects that’s great
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
- en: for quick prototyping. In the custom version, you can provide a background
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: for the dialog, customize the question text, customize the answer text (with
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
- en: an Answer dialog), and provide customized artwork for the buttons.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
- en: '***Yes/No and Alert Dialogs***'
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: We’ll first look at the Yes/No dialog, starting with the text version.
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: '**Text Version**'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the interface of the textYesNoDialog() function:'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
- en: textYesNoDialog(theWindow, theRect, prompt, yesButtonText='Yes',
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
- en: noButtonText='No',
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
- en: backgroundColor=DIALOG_BACKGROUND_COLOR,
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
- en: textColor=DIALOG_BLACK)
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: When you call this function, you need to pass in the window to draw
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: into, a rectangle object or tuple representing the location and size of the
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
- en: dialog to create, and a text prompt to be shown. You can also optionally
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
- en: specify the text of the two buttons, a background color, and the color of the
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
- en: prompt text. If not specified, the button text defaults to Yes and No.
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a typical call to this function:'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
- en: returnedValue = pyghelpers.textYesNoDialog(window,
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
- en: (75, 100, 500, 150),
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
- en: '''Do you want fries with that?'')'
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
- en: This call shows the dialog in Figure 16-1\.
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
- en: '**342** Chapter 16'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 47](index-372_1.png)'
  id: totrans-1609
  prefs: []
  type: TYPE_IMG
- en: '![Image 48](index-372_2.png)'
  id: totrans-1610
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: A typical textYesNoDialog dialog*'
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
- en: The Yes and No buttons are instances of the TextButton class in pygwidgets.
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
- en: The main program stops while the dialog shows. When the user clicks a
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
- en: button, the function returns True for Yes or False for No. Your code does
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
- en: whatever needs to be done based on the returned Boolean value; then the
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
- en: main program continues running where it left off.
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
- en: You can also use this function to create a simple Alert dialog with only
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
- en: one button. If the value passed in for noButtonText is None, that button will
    not
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: 'be shown. For example, you can make a call like this to show only one button:'
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
- en: ignore = pyghelpers.textYesNoDialog(window, (75, 80, 500, 150),
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
- en: '''This is an alert!'', ''OK'', None)'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16-2 shows the resulting Alert dialog.
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16-2: A textYesNoDialog used as an Alert dialog*'
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom Version**'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a custom Yes/No dialog is more complicated but allows for much
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
- en: 'more control. Here is the interface of the customYesNoDialog() function:'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
- en: customYesNoDialog(theWindow, oDialogImage, oPromptText, oYesButton,
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
- en: oNoButton)
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
- en: Before you can call this function, you need to create objects for the
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
- en: background of the dialog, the prompt text, and the Yes and No buttons. You
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
- en: would typically use Image, DisplayText, and CustomButton (or TextButton) objects
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
- en: created from pygwidgets classes for this purpose. The customYesNoDialog()
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
- en: code demonstrates polymorphism by calling the handleEvent() method of the
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
- en: buttons, so it doesn’t matter whether you use CustomButtons or TextButtons,
    and
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
- en: by calling the draw() method of all objects that make up the dialog. Because
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
- en: you create all these objects, you can customize the look of any or all of them.
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
- en: You will need to supply your own artwork for any Image and CustomButton
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
- en: objects and customarily place them in the *images* folder of the project.
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
- en: 'Full Game: Dodger **343**'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
- en: When implementing a custom Yes/No dialog, typically you would write an intermediate
    function like showCustomYesNoDialog(), shown in Listing 16-1\.
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
- en: Then, at the place in your code where you want to show the dialog, rather
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
- en: than calling customYesNoDialog() directly, you instead call the intermediate
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
- en: function, which both instantiates the widgets and makes the actual call.
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
- en: 'def showCustomYesNoDialog(theWindow, theText):'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
- en: 1 oDialogBackground = pygwidgets.Image(theWindow, (60, 120),
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
- en: '''images/dialog.png'')'
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
- en: 2 oPromptDisplayText = pygwidgets.DisplayText(theWindow, (0, 170),
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
- en: theText, width=WINDOW_WIDTH,
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
- en: justified='center', fontSize=36)
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
- en: 3 oNoButton = pygwidgets.CustomButton(theWindow, (95, 265),
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
- en: '''images/noNormal.png'','
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
- en: over='images/noOver.png',
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
- en: down='images/noDown.png',
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
- en: disabled='images/noDisabled.png')
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
- en: oYesButton = pygwidgets.CustomButton(theWindow, (355, 265),
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
- en: '''images/yesNormal.png'','
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
- en: over='images/yesOver.png',
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
- en: down='images/yesDown.png',
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
- en: disabled='images/yesDisabled.png')
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
- en: 4 userAnswer = pyghelpers.customYesNoDialog(theWindow,
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
- en: oDialogBackground,
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
- en: oPromptDisplayText,
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
- en: oYesButton, oNoButton)
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: 5 return userAnswer
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-1: An intermediate function to create a custom Yes/No dialog*'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
- en: Inside the function you write code to create an Image object for the
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
- en: background using an image you specify 1\. You also create a DisplayText
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
- en: object for the prompt 2, in which you specify the placement, text size,
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
- en: font, and so on. Then you create buttons as either TextButton objects or,
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: more likely, CustomButton objects so you can show custom images 3\. Finally,
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
- en: this function calls customYesNoDialog(), passing in all the objects you just
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
- en: created 4\. The call to customYesNoDialog() returns the user’s choice to this
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
- en: intermediate function, and the intermediate function returns the user’s
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: choice to the original caller 5\. This approach works well because the wid-
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: get objects (oDialogBackground, oPromptDisplayText, oYesButton, and oNoButton)
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
- en: created inside this function are all local variables and therefore will all
    go
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: away when the intermediate function ends.
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
- en: When you call this function, you only need to pass in the window and
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: 'the text prompt to be displayed. For example:'
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
- en: returnedValue = showCustomYesNoDialog(window,
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
- en: '''Do you want fries with that?'')'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16-3 shows the resulting dialog. This is just one example; you
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
- en: can design any layout you like.
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
- en: '**344** Chapter 16'
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 49](index-374_1.png)'
  id: totrans-1685
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-3: A typical customYesNoDialog dialog*'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
- en: As with the simple text version, if the value passed in for oNoButton is
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
- en: None, that button will not be shown, which is useful for building and display-
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
- en: ing an Alert dialog.
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
- en: Internally, the textYesNoDialog() and customYesNoDialog() functions each
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
- en: run their own while loop that handles events and updates and draws the
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
- en: dialog. That way, the calling program is suspended (its main loop does
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
- en: not run) until the user clicks a button and the modal dialog returns the
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: selected answer. (The source code of both functions is available in the
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
- en: pyghelpers module.)
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
- en: '***Answer Dialogs***'
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
- en: An Answer dialog adds an input text field where the user can type a
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: response. The pyghelpers module also contains functions textAnswerDialog()
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
- en: and customAnswerDialog() to handle these dialogs, which work similarly to
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
- en: their Yes/No counterparts.
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
- en: '**Text Version**'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the interface of the textAnswerDialog() function:'
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
- en: textAnswerDialog(theWindow, theRect, prompt, okButtonText='OK'
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
- en: cancelButtonText='Cancel',
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
- en: backgroundColor=DIALOG_BACKGROUND_COLOR,
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
- en: promptTextColor=DIALOG_BLACK,
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
- en: inputTextColor=DIALOG_BLACK)
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
- en: If the user clicks the OK button, the function returns whatever text the
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
- en: user entered. If the user clicks the Cancel button, the function returns None.
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a typical call:'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
- en: userAnswer = pyghelpers.textAnswerDialog(window, (75, 100, 500, 200),
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
- en: '''What is your favorite flavor of ice cream?'')'
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
- en: 'if userAnswer is not None:'
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
- en: User pressed OK, do whatever you want with the variable userAnswer
  id: totrans-1714
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
- en: Here do whatever you want knowing that the user pressed Cancel
  id: totrans-1716
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Full Game: Dodger **345**'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 50](index-375_1.png)'
  id: totrans-1718
  prefs: []
  type: TYPE_IMG
- en: This will display the dialog in Figure 16-4\.
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16-4: A typical textAnswerDialog dialog*'
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom Version**'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: To implement a custom Answer dialog, you should write an intermediate
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
- en: function, similar to the approach shown with customYesNoDialog(). Your main
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
- en: code calls the intermediate function, which in turn calls customAnswerDialog().
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
- en: Listing 16-2 shows the code of a typical intermediate function.
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
- en: 'def showCustomAnswerDialog(theWindow, theText):'
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
- en: oDialogBackground = pygwidgets.Image(theWindow, (60, 80),
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
- en: '''images/dialog.png'')'
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
- en: oPromptDisplayText = pygwidgets.DisplayText(theWindow, (0, 120),
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
- en: theText, width=WINDOW_WIDTH,
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
- en: justified='center', fontSize=36)
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
- en: oUserInputText = pygwidgets.InputText(theWindow, (225, 165), '',
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
- en: fontSize=36, initialFocus=True)
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
- en: oNoButton = pygwidgets.CustomButton(theWindow, (105, 235),
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
- en: '''images/cancelNormal.png'','
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
- en: over='images/cancelOver.png',
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
- en: down='images/cancelDown.png',
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
- en: isabled='images/cancelDisabled.png')
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
- en: oYesButton = pygwidgets.CustomButton(theWindow, (375, 235),
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
- en: '''images/okNormal.png'','
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
- en: over='images/okOver.png',
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
- en: down='images/okDown.png',
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
- en: disabled='images/okDisabled.png')
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
- en: response = pyghelpers.customAnswerDialog(theWindow,
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
- en: oDialogBackground, oPromptDisplayText,
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
- en: oUserInputText,
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
- en: oYesButton, oNoButton)
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
- en: return response
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-2: An intermediate function to create a custom Answer dialog*'
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
- en: 'You can customize the entire appearance of the dialog: background'
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
- en: image, fonts, and sizes and placement of the display and input text fields
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
- en: '**346** Chapter 16'
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 51](index-376_1.png)'
  id: totrans-1753
  prefs: []
  type: TYPE_IMG
- en: and the two buttons. To show a custom dialog, your main code would call
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
- en: 'the intermediate function and pass in the prompt text, like this:'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
- en: userAnswer = showCustomAnswerDialog(window,
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
- en: '''What is your favorite flavor of ice cream?'')'
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
- en: That call displays a custom Answer dialog like the one shown in
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16-5\.
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16-5: A typical customAnswerDialog dialog*'
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
- en: If user clicks OK, the function returns the text the user entered. If the
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
- en: user clicks the Cancel button, the function returns None.
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
- en: A demo program that demonstrates all the types of dialogs, *DialogTester/*
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
- en: '*Main_DialogTester.py*, is available with the downloadable resources for the'
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
- en: book.
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
- en: '**Building a Full Game: Dodger**'
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll put all the material from this part of the book together
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
- en: in the context of a game called Dodger. From the user’s point of view, the
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
- en: 'game is extremely simple: get as many points as you can by dodging the red'
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
- en: Baddies and making contact with the green Goodies.
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
- en: '***Game Overview***'
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
- en: Red Baddies will drop from the top of the window, and the user must avoid
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
- en: them. Any Baddie that makes it all the way down to the bottom of the game
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
- en: area is removed, and the user gains one point. The user moves the mouse to
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
- en: control a Player icon. If the Player touches any Baddie, the game is over. A
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
- en: small number of green Goodies show up randomly and move horizontally,
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
- en: and the user gets 25 points for any Goodie they touch.
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
- en: 'The game has three scenes: a starting or Splash scene with instructions,'
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
- en: a Play scene where you play the game, and a High Scores scene where you
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
- en: can view the top 10 high scores. If you score within the top 10, you’re given
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
- en: the option of entering your name and score into the high scores table.
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16-6 shows the three scenes.
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
- en: 'Full Game: Dodger **347**'
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 52](index-377_1.png)'
  id: totrans-1784
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-6: The Splash, Play, and High Score scenes (left to right)*'
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
- en: '***Implementation***'
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of the *Dodger* project folder are as follows (filenames are in
    italic):'
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
- en: '***__init__.py***Empty file that indicates that this is a Python package'
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
- en: '***Baddies.py***Contains the Baddie and BaddieMgr classes'
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
- en: '***Constants.py***Contains constants used by multiple scenes'
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
- en: '***Goodies.py***Contains the Goodie and GoodieMgr classes'
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
- en: '***HighScoresData.py***Contains the HighScoresData class'
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
- en: '**images** Folder that contains all the artwork for the game'
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
- en: '***Main_Dodger.py***The main program'
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
- en: '***Player.py***Contains the Player class'
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
- en: '***SceneHighScores.py***The scene that shows and records high scores'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
- en: '***ScenePlay.py***The main Play scene'
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
- en: '***Scene.Splash.py***The Splash scene'
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
- en: '**sounds** Folder that contains all the sound files for the game'
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
- en: The project folder is included with the book’s resources. I won’t talk
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
- en: through the entirety of the code, but I’ll go through the source files and
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
- en: explain how the key parts work.
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Dodger/Constants.py**'
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
- en: This file contains constants that can be used by more than one source file.
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important constants are the scene keys:'
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
- en: Scene keys
  id: totrans-1806
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SCENE_SPLASH = 'scene splash'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
- en: SCENE_PLAY = 'scene play'
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
- en: SCENE_HIGH_SCORES = 'scene high scores'
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
- en: '**348** Chapter 16'
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
- en: The values of these constants are unique strings that identify the different
    scenes.
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Main_Dodger.py**'
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
- en: The main file performs the necessary initialization, then passes control to
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
- en: 'the scene manager. The most important code in the file is this:'
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
- en: Instantiate all scenes and store them in a list
  id: totrans-1815
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: scenesList = [SceneSplash(window)
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
- en: SceneHighScores(window)
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
- en: ScenePlay(window)]
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
- en: Create the scene manager, passing in the scenes list and the FPS
  id: totrans-1819
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oSceneMgr = pyghelpers.SceneMgr(scenesList, FRAMES_PER_SECOND)
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
- en: Tell the scene manager to start running
  id: totrans-1821
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oSceneMgr.run()
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
- en: Here we create an instance of each scene, instantiate the scene man-
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
- en: ager, then turn over control to the scene manager. The scene manager’s
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
- en: run() method gives control to the first scene in the list. In this game, it
    gives
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
- en: control to the Splash scene.
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in the previous chapter, each scene class inherits from the
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
- en: Scene base class. In addition to providing its own __init__() method, each
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
- en: of these classes is required to override the getSceneKey(), handleInputs(),
    and
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
- en: draw() methods from the base class.
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Dodger/SceneSplash.py**'
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
- en: The Splash scene shows the user a graphic with the rules of the game and
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
- en: 'three buttons: Start, Quit, and Go to High Scores. The code for this scene’s'
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
- en: class only contains the required methods; all other methods default to the
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
- en: ones in the Scene base class.
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() method creates an Image object for the background
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
- en: image and three CustomButton objects for the user’s options.
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
- en: The getSceneKey() method must be implemented in all scenes; it just
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
- en: returns a unique key for the scene.
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
- en: The handleInputs() method checks for the user clicking any of the but-
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
- en: tons. If the user clicks Start, we call the inherited self.goToScene() method
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
- en: to ask the scene manager to transfer control to the Play scene. Similarly,
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
- en: clicking the Go to High Scores button takes the user to the High Scores
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
- en: scene. If the user clicks Quit, we call the scene’s inherited self.quit()
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
- en: method, which quits the program.
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
- en: In the draw() method, the program draws the background and all three
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
- en: buttons.
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Dodger/ScenePlay.py**'
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
- en: 'The Play scene manages the actual playing of the game: the user moving'
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
- en: the Player icon, generation and movement of the Baddies and Goodies,
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
- en: 'Full Game: Dodger **349**'
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
- en: and collision detection. It also manages the display elements at the bottom
    of the window, including the current game score and high score, and
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
- en: responds to clicks on the Quit, Go to High Scores, and Start buttons and
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
- en: the Background Music checkbox.
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
- en: There is quite a bit of code for the Play scene, so I’ll break it up into
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
- en: smaller chunks (Listings 16-3 through 16-7) to explain the methods. The
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
- en: scene adheres to the design rules established i[n Chapter 15 by i](#p340)mplementing
    the __init__(), handleInputs(), update(), and draw() methods. It also implements
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
- en: an enter() method to handle what the scene should do when it becomes the
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
- en: active scene and a leave() method for what the scene should do when the user
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
- en: navigates away. Finally, it has a reset() method for resetting the state before
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
- en: starting a new round. Listing 16-3 shows the initialization code.
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
- en: Play scene - the main game play scene
  id: totrans-1862
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip imports and showCustomYesNoDialog ---'
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
- en: BOTTOM_RECT = (0, GAME_HEIGHT + 1, WINDOW_WIDTH,
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_HEIGHT - GAME_HEIGHT)
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
- en: STATE_WAITING = 'waiting'
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
- en: STATE_PLAYING = 'playing'
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
- en: STATE_GAME_OVER = 'game over'
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
- en: 'class ScenePlay(pyghelpers.Scene):'
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window):'
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
- en: 1 self.window = window
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
- en: self.controlsBackground = pygwidgets.Image(self.window,
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
- en: (0, GAME_HEIGHT),
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
- en: '''images/controlsBackground.jpg'')'
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
- en: self.quitButton = pygwidgets.CustomButton(self.window,
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
- en: (30, GAME_HEIGHT + 90),
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
- en: up='images/quitNormal.png',
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
- en: down='images/quitDown.png',
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
- en: over='images/quitOver.png',
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
- en: disabled='images/quitDisabled.png')
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
- en: self.highScoresButton = pygwidgets.CustomButton(self.window,
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
- en: (190, GAME_HEIGHT + 90),
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
- en: up='images/gotoHighScoresNormal.png',
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
- en: down='images/gotoHighScoresDown.png',
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
- en: over='images/gotoHighScoresOver.png',
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
- en: disabled='images/gotoHighScoresDisabled.png')
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
- en: self.startButton = pygwidgets.CustomButton(self.window,
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
- en: (450, GAME_HEIGHT + 90),
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
- en: up='images/startNewNormal.png',
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
- en: down='images/startNewDown.png',
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
- en: over='images/startNewOver.png',
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
- en: disabled='images/startNewDisabled.png',
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
- en: enterToActivate=True)
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
- en: '**350** Chapter 16'
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
- en: self.soundCheckBox = pygwidgets.TextCheckBox(self.window,
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
- en: (430, GAME_HEIGHT + 17),
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
- en: '''Background music'','
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
- en: True, textColor=WHITE)
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
