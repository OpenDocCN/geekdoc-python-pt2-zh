- en: Otherwise, it sets self.playing to True to indicate that the animation is now
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，它将 self.playing 设置为 True，表示动画现在正在播放，
- en: running.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正在运行。
- en: When a SimpleAnimation is created, the caller specifies the amount of time
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建 SimpleAnimation 时，调用者指定每个图像显示的时间长度
- en: that each image should be shown, and this is saved in self.durationPerImage.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每个图像应该显示的时间长度，这保存在 self.durationPerImage 中。
- en: Therefore, we must keep track of time as a SimpleAnimation runs to know when
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须在 SimpleAnimation 运行时跟踪时间，以知道何时
- en: to switch to the next image. We call time.time() to get the current time (in
    mil-
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以切换到下一个图像。我们调用 time.time() 来获取当前时间（以毫秒为单位），
- en: liseconds) and save that in an instance variable. Making the class time based
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 毫秒）并将其保存到一个实例变量中。使类基于时间
- en: means that any SimpleAnimation object built from this class will work correctly,
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着由此类构建的任何 SimpleAnimation 对象都将正常工作，
- en: independent of the frame rate used for the main loop. Finally, we set the vari-
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 独立于主循环使用的帧率。最后，我们设置变量
- en: able self.index to 0 to indicate that we should be showing the first image.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 将 self.index 设为 0，表示我们应该显示第一张图像。
- en: The update() method 4 needs to be called in every frame of the
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: update() 方法需要在每一帧中调用
- en: main loop. If the animation is not playing, update() does nothing and just
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环。如果动画没有播放，update() 什么也不做，直接返回。
- en: returns. Otherwise, update() calculates how much time has elapsed since
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 返回。否则，update() 会计算自从当前图像开始显示以来经过的时间。
- en: the current image started showing by getting the current time using the
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当前图像开始显示的时间，通过获取当前时间来实现
- en: system time.time() function and subtracting that from the time at which
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的 time.time() 函数返回的当前时间，并将其与
- en: the current image started showing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当前图像开始显示的时间。
- en: If the elapsed time is greater than the amount of time that each image
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果经过的时间大于每张图像应该显示的时间长度，
- en: should be showing, it’s time move to the next image. In this case, we incre-
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应显示该图像，是时候切换到下一个图像了。在这种情况下，我们增加了
- en: ment self.index so that the upcoming call to the draw() method will draw
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 self.index 以便即将调用的 draw() 方法绘制
- en: the appropriate image. We then check whether the animation has finished.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 合适的图像。然后我们检查动画是否已经完成。
- en: If not, we save the start time for the new image. If the animation is done,
    we
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是，我们保存新图像的开始时间。如果动画完成，我们
- en: set self.playing back to False (to indicate that we are no longer playing the
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将 self.playing 设置回 False（表示我们不再播放动画）
- en: animation), and we reset self.index to 0 so that the draw() method will show
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 动画），并将 self.index 重置为 0，这样 draw() 方法就会显示
- en: the first image again.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 再次显示第一张图像。
- en: Finally, we call draw() in every frame 5 to draw the current image of
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在每一帧调用 draw() 来绘制当前图像
- en: the animation. The draw() method assumes that self.index has been set cor-
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 动画。draw() 方法假定 self.index 已经正确设置。
- en: rectly by a previous method, and uses it to index into the list of images. It
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由之前的方法直接计算，并用来索引图像列表。
- en: then draws that image in the window at the specified location.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在指定的位置的窗口中绘制该图像。
- en: '**Example Main Program**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例主程序**'
- en: Listing 14-2 shows a main program that creates and uses a SimpleAnimation
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 14-2 展示了一个创建并使用 SimpleAnimation 的主程序
- en: object. This will animate a dinosaur riding a bicycle.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对象。这将动画化一个骑自行车的恐龙。
- en: '**File: SimpleAnimation/Main_SimpleAnimation.py**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：SimpleAnimation/Main_SimpleAnimation.py**'
- en: Animation example
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画示例
- en: Shows example of SimpleAnimation object
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示了 SimpleAnimation 对象的示例
- en: 1 - Import library
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 - 导入库
- en: import pygame
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from pygame.locals import *
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: from pygame.locals import *
- en: import sys
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: import pygwidgets
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: import pygwidgets
- en: from SimpleAnimation import *
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: from SimpleAnimation import *
- en: 2 Define constants
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 定义常量
- en: SCREEN_WIDTH = 640
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: SCREEN_WIDTH = 640
- en: '**298** Chapter 14'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**298** 第14章'
- en: SCREEN_HEIGHT = 480
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: SCREEN_HEIGHT = 480
- en: FRAMES_PER_SECOND = 30
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: FRAMES_PER_SECOND = 30
- en: BGCOLOR = (0, 128, 128)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: BGCOLOR = (0, 128, 128)
- en: 3 - Initialize the world
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 - 初始化世界
- en: pygame.init()
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.init()
- en: window = pygame.display.set_mode([SCREEN_WIDTH, SCREEN_HEIGHT])
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: window = pygame.display.set_mode([SCREEN_WIDTH, SCREEN_HEIGHT])
- en: clock = pygame.time.Clock()
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: clock = pygame.time.Clock()
- en: '4 - Load assets: images(s), sound(s), etc.'
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 - 加载资源：图像、声音等。
- en: 1 dinosaurAnimTuple = ('images/Dinobike/f1.gif',
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 1 dinosaurAnimTuple = ('images/Dinobike/f1.gif',
- en: '''images/Dinobike/f2.gif'','
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/Dinobike/f2.gif'','
- en: '''images/Dinobike/f3.gif'','
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/Dinobike/f3.gif'','
- en: '''images/Dinobike/f4.gif'','
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/Dinobike/f4.gif'','
- en: '''images/Dinobike/f5.gif'','
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/Dinobike/f5.gif'','
- en: '''images/Dinobike/f6.gif'','
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/Dinobike/f6.gif'','
- en: '''images/Dinobike/f7.gif'','
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/Dinobike/f7.gif'','
- en: '''images/Dinobike/f8.gif'','
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/Dinobike/f8.gif'','
- en: '''images/Dinobike/f9.gif'','
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/Dinobike/f9.gif'','
- en: '''images/Dinobike/f10.gif'')'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/Dinobike/f10.gif'')'
- en: 5 - Initialize variables
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 - 初始化变量
- en: oDinosaurAnimation = SimpleAnimation(window, (22, 140),
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: oDinosaurAnimation = SimpleAnimation(window, (22, 140),
- en: dinosaurAnimTuple, .1)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: dinosaurAnimTuple，.1)
- en: oPlayButton = pygwidgets.TextButton(window, (20, 240), "Play")
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: oPlayButton = pygwidgets.TextButton(window, (20, 240), "Play")
- en: 6 - Loop forever
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 - 永远循环
- en: 'while True:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 7 - Check for and handle events
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 - 检查并处理事件
- en: 'for event in pygame.event.get():'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: 'if event.type == QUIT:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 'if event.type == QUIT:'
- en: pygame.quit()
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: '2 if oPlayButton.handleEvent(event):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '2 如果 oPlayButton.handleEvent(event):'
- en: oDinosaurAnimation.play()
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: oDinosaurAnimation.play()
- en: 8 - Do any "per frame" actions
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 - 执行任何“每帧”操作
- en: 3 oDinosaurAnimation.update()
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 3 oDinosaurAnimation.update()
- en: 9 - Clear the window
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 - 清空窗口
- en: window.fill(BGCOLOR)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: window.fill(BGCOLOR)
- en: 10 - Draw all window elements
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 - 绘制所有窗口元素
- en: 4 oDinosaurAnimation.draw()
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 4 oDinosaurAnimation.draw()
- en: oPlayButton.draw()
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: oPlayButton.draw()
- en: 11 - Update the window
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 - 更新窗口
- en: pygame.display.update()
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.update()
- en: 12 - Slow things down a bit
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 - 稍微减慢速度
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 'clock.tick(FRAMES_PER_SECOND) # 让 pygame 等待'
- en: '*Listing 14-2: The main program that instantiates and plays a SimpleAnimation*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-2: 实例化并播放 SimpleAnimation 的主程序*'
- en: Animation **299**
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 动画 **299**
- en: '![Image 38](index-329_1.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![Image 38](index-329_1.png)'
- en: All the images for the animated dinosaur are in the folder *images/*
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的动画图像都在文件夹 *images/* 中
- en: '*DinoBike/*. We first build a tuple of the images 1\. Then, using that tuple,'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*DinoBike/*。我们首先构建一个包含图像的元组 1。然后，使用该元组，'
- en: we create a SimpleAnimation object and specify that each image should be
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个 SimpleAnimation 对象，并指定每个图像应该是
- en: shown for a tenth of a second. We also instantiate a Play button.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的时间为十分之一秒。我们还实例化了一个播放按钮。
- en: In the main loop, we call the update() and draw() methods of the
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环中，我们调用 oDinosaurAnimation 的 update() 和 draw() 方法，
- en: oDinosaurAnimation object. The program loops while continuously drawing
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: oDinosaurAnimation 对象。程序会不断循环，持续绘制
- en: the current image of the animation and the Play button. When the anima-
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的动画图像和播放按钮。当动画-
- en: tion is not running, the user just sees the first image.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果动画没有运行，用户只会看到第一张图像。
- en: When the user clicks the Play button 2, the program calls the play()
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击播放按钮 2 时，程序会调用 play()
- en: method of oDinosaurAnimation to start the animation running.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: oDinosaurAnimation 方法来启动动画。
- en: In the main loop, we call the update() method of oDinosaur Animation 3,
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环中，我们调用 oDinosaur Animation 3 的 update() 方法，
- en: which determines whether enough time has elapsed for the animation to
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它决定是否已经过了足够的时间来播放动画
- en: move on to the next image.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 移动到下一张图像。
- en: Finally, we call draw() 4, and the object draws the appropriate image.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用 draw() 4，并且对象绘制相应的图像。
- en: '***SimpleSpriteSheetAnimation Class***'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '***SimpleSpriteSheetAnimation 类***'
- en: The second type of animation is implemented in the SimpleSpriteSheetAnimation
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种类型的动画在 SimpleSpriteSheetAnimation 类中实现
- en: class. A *sprite sheet* is a single image made up of a number of equally sized
    smaller images, intended to appear in order to create an animation. From a
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 类。*精灵表*是一个由多个相同大小的较小图像组成的单一图像，目的是按顺序显示以创建动画。从
- en: developer’s point of view, there are three advantages to a sprite sheet. First,
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发者的角度来看，精灵表有三个优势。首先，
- en: all the images are in a single file, so there is no need to worry about building
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所有图像都在一个文件中，因此无需担心构建问题。
- en: a name for each separate file. Second, it’s possible to see the progression
    of
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个单独的文件命名。其次，可以看到
- en: an animation in a single file, rather than having to flip through a sequence
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个动画包含在一个文件中，而不是必须翻阅一系列
- en: of images. Finally, loading a single file is faster than loading a list of files
    that make up an animation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的数量。最后，加载单个文件比加载由多个文件组成的动画要快。
- en: Figure 14-1 shows an example of a sprite sheet.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-1 显示了一个精灵表的示例。
- en: '*Figure 14-1: A sprite sheet image made up of*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-1: 由多个小图像组成的精灵表*'
- en: '*18 smal er images*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*18 张较小的图像*'
- en: This example is designed to show the numbers from 0 to 17\. The origi-
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本例旨在展示从 0 到 17 的数字。原始-
- en: nal file contains an image that is 384×192 pixels. A quick division shows that
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 原始文件包含一个 384×192 像素的图像。简单的除法可以得出
- en: each individual number image is 64×64 pixels. The key idea here is that we
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单独的数字图像是 64×64 像素。这里的关键思想是我们
- en: use pygame to create *subimages* of a larger image to give us a set of 18 new
    64×64 pixel images. The smaller images can then be displayed using the
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pygame 创建*子图像*，将一个较大的图像分割成一组 18 张新的 64×64 像素图像。然后可以使用
- en: same technique as we used in the SimpleAnimation class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 SimpleAnimation 类中使用的技术相同。
- en: '**300** Chapter 14'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**300** 第14章'
- en: '**Creating the Class**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建类**'
- en: Listing 14-3 contains the SimpleSpriteSheetAnimation class to handle sprite
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 14-3 包含了处理精灵图像的 SimpleSpriteSheetAnimation 类
- en: sheet–based animations. During initialization, the contents of the single
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 基于精灵图的动画。在初始化时，单个精灵图的内容会
- en: sprite sheet image are split up into a list of smaller images, which are then
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵图像被拆分为较小的图像，并将其添加到
- en: displayed by the other methods.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由其他方法显示。
- en: '**File: SimpleSpriteSheetAnimation/SimpleSpriteSheetAnimation.py**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：SimpleSpriteSheetAnimation/SimpleSpriteSheetAnimation.py**'
- en: SimpleSpriteSheetAnimation class
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SimpleSpriteSheetAnimation 类
- en: import pygame
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 pygame
- en: import time
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 time
- en: 'class SimpleSpriteSheetAnimation():'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 'class SimpleSpriteSheetAnimation():'
- en: 'def __init__(self, window, loc, imagePath, nImages, width, height, durationPerImage):
    1'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, window, loc, imagePath, nImages, width, height, durationPerImage):
    1'
- en: self.window = window
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: self.window = window
- en: self.loc = loc
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: self.loc = loc
- en: self.nImages = nImages
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: self.nImages = nImages
- en: self.imagesList = []
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: self.imagesList = []
- en: Load the sprite sheet
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载精灵图
- en: spriteSheetImage = pygame.image.load(imagePath)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: spriteSheetImage = pygame.image.load(imagePath)
- en: Optimize blitting
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化 blitting
- en: spriteSheetImage = pygame.Surface.convert_alpha(spriteSheetImage)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: spriteSheetImage = pygame.Surface.convert_alpha(spriteSheetImage)
- en: Calculate the number of columns in the starting image
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算起始图像中的列数
- en: nCols = spriteSheetImage.get_width() // width
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: nCols = spriteSheetImage.get_width() // width
- en: Break up the starting image into subimages
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将起始图像拆分为子图像
- en: row = 0
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: row = 0
- en: col = 0
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: col = 0
- en: 'for imageNumber in range(nImages):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 imageNumber 在范围 nImages 内:'
- en: x = col * height
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: x = col * height
- en: y = row * width
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: y = row * width
- en: Create a subsurface from the bigger spriteSheet
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从大的精灵图中创建子图像
- en: subsurfaceRect = pygame.Rect(x, y, width, height)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: subsurfaceRect = pygame.Rect(x, y, width, height)
- en: image = spriteSheetImage.subsurface(subsurfaceRect)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: image = spriteSheetImage.subsurface(subsurfaceRect)
- en: self.imagesList.append(image)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: self.imagesList.append(image)
- en: col = col + 1
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: col = col + 1
- en: 'if col == nCols:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 col == nCols:'
- en: col = 0
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: col = 0
- en: row = row + 1
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: row = row + 1
- en: self.durationPerImage = durationPerImage
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: self.durationPerImage = durationPerImage
- en: self.playing = False
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: self.playing = False
- en: self.index = 0
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: self.index = 0
- en: 'def play(self):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 'def play(self):'
- en: 'if self.playing:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 self.playing:'
- en: return
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: self.playing = True
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: self.playing = True
- en: Animation **301**
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 动画 **301**
- en: self.imageStartTime = time.time()
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: self.imageStartTime = time.time()
- en: self.index = 0
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: self.index = 0
- en: 'def update(self):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update(self):'
- en: 'if not self.playing:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 self.playing 为 False:'
- en: return
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 返回
- en: How much time has elapsed since we started showing this image
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自开始显示此图像以来，已过的时间
- en: self.elapsed = time.time() - self.imageStartTime
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: self.elapsed = time.time() - self.imageStartTime
- en: If enough time has elapsed, move on to the next image
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果已经过足够的时间，转到下一张图像
- en: 'if self.elapsed > self.durationPerImage:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 self.elapsed > self.durationPerImage:'
- en: self.index = self.index + 1
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: self.index = self.index + 1
- en: 'if self.index < self.nImages: # move on to next image'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 self.index < self.nImages:  # 转到下一张图像'
- en: self.imageStartTime = time.time()
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: self.imageStartTime = time.time()
- en: 'else: # animation is finished'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:  # 动画结束'
- en: self.playing = False
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: self.playing = False
- en: 'self.index = 0 # reset to the beginning'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.index = 0  # 重置为起始位置'
- en: 'def draw(self):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw(self):'
- en: Assumes that self.index has been set earlier - in the update() method.
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 假设 self.index 已在 update() 方法中设置。
- en: It is used as the index into the imagesList to find the current image.
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它用作索引，以便在 imagesList 中查找当前图像。
- en: 'theImage = self.imagesList[self.index] # choose the image to show'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 'theImage = self.imagesList[self.index]  # 选择要显示的图像'
- en: 'self.window.blit(theImage, self.loc) # show it'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.window.blit(theImage, self.loc)  # 显示图像'
- en: '*Listing 14-3: The SimpleSpriteSheetAnimation class*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14-3：SimpleSpriteSheetAnimation 类*'
- en: This class is very similar to SimpleAnimation, but because this animation
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类与 SimpleAnimation 类非常相似，但因为这个动画
- en: is based on a sprite sheet, the __init__() method must be passed different
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 基于精灵图的动画，__init__() 方法必须传入不同的参数
- en: information 1\. The method requires the standard window and loc param-
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 信息 1. 该方法需要标准窗口和 loc 参数-
- en: 'eters, as well as:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 参数，另外还有：
- en: '**imagePath** A path to a sprite sheet image (single file)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**imagePath** 精灵图像路径（单个文件）'
- en: '**nImages** The number of images in the sprite sheet'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**nImages** 精灵图中的图像数量'
- en: '**width** The width of each subimage'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**width** 每个子图像的宽度'
- en: '**height** The height of each subimage'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**height** 每个子图像的高度'
- en: '**durationPerImage** How long (in seconds) to show each image'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**durationPerImage** 每张图像显示的时间（秒）'
- en: Given these values, the __init__() method loads the sprite sheet file, and
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些值，__init__() 方法加载精灵图文件，并
- en: it uses a loop to split up the larger image into a list of smaller subimages
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用一个循环将较大的图像拆分为一个较小的子图像列表
- en: through a call to the pygame subsurface() method. The smaller images are
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 pygame 的 subsurface() 方法来实现。较小的图像随后
- en: then appended into the self.imagesList list for use by the other methods.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其添加到 self.imagesList 列表中，以供其他方法使用。
- en: The __init__() method uses a counter to count the number of subimages,
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: __init__() 方法使用计数器来计算子图像的数量，
- en: up to the number specified by the caller; therefore, the last row of images
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 直到达到调用者指定的数量；因此，最后一行图片
- en: does not need to be a full row. For example, we could have used a sprite
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要是完整的一行。例如，我们可以使用一个精灵
- en: sheet image that only had the numbers 0 through 14, rather than needing
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 仅包含数字 0 到 14 的图像贴图，而不是需要
- en: to fill the row to 17\. The nImages parameter is the key to making this work.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 直到填充到 17 行。nImages 参数是使其工作的关键。
- en: This rest of this class has the exact same methods as the previous
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这一类的其他部分具有与之前完全相同的方法
- en: 'SimpleAnimation class: play(), update(), and draw().'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleAnimation 类：play()、update() 和 draw()。
- en: '**302** Chapter 14'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**302** 第14章'
- en: '**Example Main Program**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例主程序**'
- en: Listing 14-4 provides a sample main program that creates and shows
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 14-4 提供了一个示例主程序，创建并显示
- en: a SimpleSpriteSheetAnimation object that shows an animated drop of
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显示动画水滴的 SimpleSpriteSheetAnimation 对象
- en: water landing and spreading out. If you download everything in the
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 水滴着陆并扩散开来。如果你下载了所有内容
- en: '*SpriteSheetAnimation* folder of this book’s resources, you will get the'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*SpriteSheetAnimation* 文件夹中的资源，你将得到'
- en: code and the appropriate artwork.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 代码和相应的艺术资源。
- en: '**File: SimpleSpriteSheetAnimation/Main_SimpleSpriteSheetAnimation.py**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：SimpleSpriteSheetAnimation/Main_SimpleSpriteSheetAnimation.py**'
- en: Shows example of SimpleSpriteSheetAnimation object
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示 SimpleSpriteSheetAnimation 对象的示例
- en: 1 - Import library
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 - 导入库
- en: import pygame
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from pygame.locals import *
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: from pygame.locals import *
- en: import sys
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: import pygwidgets
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: import pygwidgets
- en: from SimpleSpriteSheetAnimation import *
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: from SimpleSpriteSheetAnimation import *
- en: 2 Define constants
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 定义常量
- en: SCREEN_WIDTH = 640
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: SCREEN_WIDTH = 640
- en: SCREEN_HEIGHT = 480
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: SCREEN_HEIGHT = 480
- en: FRAMES_PER_SECOND = 30
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: FRAMES_PER_SECOND = 30
- en: BGCOLOR = (0, 128, 128)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: BGCOLOR = (0, 128, 128)
- en: 3 - Initialize the world
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 - 初始化世界
- en: pygame.init()
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.init()
- en: window = pygame.display.set_mode([SCREEN_WIDTH, SCREEN_HEIGHT])
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: window = pygame.display.set_mode([SCREEN_WIDTH, SCREEN_HEIGHT])
- en: clock = pygame.time.Clock()
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: clock = pygame.time.Clock()
- en: '4 - Load assets: images(s), sound(s), etc.'
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 - 加载资源：图片、声音等
- en: 5 - Initialize variables
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 - 初始化变量
- en: 1 oWaterAnimation = SimpleSpriteSheetAnimation(window, (22, 140),
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 1 oWaterAnimation = SimpleSpriteSheetAnimation(window, (22, 140),
- en: '''images/water_003.png'','
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/water_003.png'','
- en: 5, 50, 192, 192, .05)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 5, 50, 192, 192, .05)
- en: oPlayButton = pygwidgets.TextButton(window, (60, 320), "Play")
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: oPlayButton = pygwidgets.TextButton(window, (60, 320), "Play")
- en: 6 - Loop forever
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 - 永久循环
- en: 'while True:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 7 - Check for and handle events
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 - 检查并处理事件
- en: 'for event in pygame.event.get():'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: 'if event.type == QUIT:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件类型是 QUIT：
- en: pygame.quit()
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: 'if oPlayButton.handleEvent(event):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 oPlayButton.handleEvent(event)：
- en: oWaterAnimation.play()
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: oWaterAnimation.play()
- en: 8 - Do any "per frame" actions
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 - 执行任何“每帧”动作
- en: oWaterAnimation.update()
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: oWaterAnimation.update()
- en: Animation **303**
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 动画 **303**
- en: 9 - Clear the window
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 - 清空窗口
- en: window.fill(BGCOLOR)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: window.fill(BGCOLOR)
- en: 10 - Draw all window elements
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 - 绘制所有窗口元素
- en: oWaterAnimation.draw()
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: oWaterAnimation.draw()
- en: oPlayButton.draw()
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: oPlayButton.draw()
- en: 11 - Update the window
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 - 更新窗口
- en: pygame.display.update()
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.update()
- en: 12 - Slow things down a bit
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 - 稍微减慢速度
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 'clock.tick(FRAMES_PER_SECOND) # 让 pygame 等待'
- en: '*Listing 14-4: A sample main program that creates and uses a SimpleSpriteSheetAnimation*
    *object*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 14-4: 一个示例主程序，创建并使用 SimpleSpriteSheetAnimation* *对象*'
- en: The only significant difference with this example is that it instantiates a
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的唯一显著区别是它实例化了一个
- en: SimpleSpriteSheetAnimation object 1 instead of a SimpleAnimation object.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleSpriteSheetAnimation 对象 1，而不是 SimpleAnimation 对象。
- en: '***Merging Two Classes***'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '***合并两个类***'
- en: The __init__() methods in SimpleAnimation and SimpleSpriteSheetAnimation
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleAnimation 和 SimpleSpriteSheetAnimation 中的 __init__() 方法
- en: have different parameters, but the other three methods (start(), update(),
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有不同的参数，但另外三个方法（start()、update()、draw()）
- en: and draw()) are identical. Once you instantiate either of these classes, the
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 draw() 方法是相同的。一旦你实例化了其中任何一个类，
- en: way that you access the resulting objects is exactly the same. The “Don’t
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 访问生成对象的方式完全相同。 “不要重复自己” (DRY) 原则指出，拥有这些重复的方法
- en: Repeat Yourself” (DRY) principle says that having these duplicated meth-
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: “不要重复自己” (DRY) 原则说明了这些重复的方法是不必要的
- en: ods is a bad idea, because any bug fixes and/or enhancements would have
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是不好的，因为任何 bug 修复和/或增强将
- en: to be applied in both copies of the methods.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个方法的副本中应用。
- en: Instead, this is a good opportunity to merge classes. We can create
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，这是一个很好的机会来合并类。我们可以创建
- en: a common abstract base class for these classes to inherit from. The base
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通用的抽象基类，供这些类继承。基类
- en: class will have its own __init__() method that includes any common code
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 类将拥有自己的 __init__() 方法，其中包括任何公共代码
- en: from the __init__() methods of both original classes, and it will contain the
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 来自两个原始类的__init__()方法，它将包含
- en: play(), update(), and draw() methods.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: play()、update()和draw()方法。
- en: Each original class will inherit from the new base class and implement
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 每个原始类将继承自新的基类，并实现
- en: its own __init__() method using the appropriate parameters. Each will do
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 它自己的__init__()方法，使用适当的参数。每个类都将执行
- en: its own work to create self.imagesList, which is then used in the other three
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 它自己的工作是创建self.imagesList，接着在其他三个
- en: methods in the new base class.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 新基类中的方法。
- en: Rather than showing the result of merging these two “simple” classes,
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 与展示这两个“简单”类合并后的结果相比，
- en: I’ll show the result of this merge in the “professional strength” Animation
    and
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我将展示这个合并结果，在“专业级”动画中
- en: SpriteSheetAnimation classes that are part of the pygwidgets package.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteSheetAnimation类使用，它们是pygwidgets包的一部分。
- en: '**Animation Classes in pygwidgets**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**pygwidgets中的动画类**'
- en: 'The pygwidgets module contains the following three animation classes:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: pygwidgets模块包含以下三个动画类：
- en: '**PygAnimation** An abstract base class for the Animation and'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**PygAnimation** 一个抽象基类，供动画类和'
- en: SpriteSheetAnimation classes
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteSheetAnimation类
- en: '**Animation** A class for image-based animations (separate image files)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**Animation** 一个基于图像的动画类（单独的图像文件）'
- en: '**SpriteSheetAnimation** A class for sprite sheet–based animations (a'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**SpriteSheetAnimation** 一个基于精灵图的动画类（一个'
- en: single large image)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 单个大图像）
- en: '**304** Chapter 14'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**304** 第14章'
- en: We’ll look at each class in turn. The Animation and SpriteSheetAnimation classes
    use the same basic concepts discussed, but also have more options
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个查看每个类。动画类和SpriteSheetAnimation类使用相同的基本概念，但也提供更多选项。
- en: available via initialization parameters.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 通过初始化参数提供。
- en: '***Animation Class***'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '***动画类***'
- en: You use pygwidget’s Animation class to create an animation from many differ-
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用pygwidget的Animation类创建一个由许多不同图像组成的动画。
- en: 'ent image files. Here is the interface:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 相关图像文件。以下是接口：
- en: Animation(window, loc, animTuplesList, autoStart=False,
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Animation(window, loc, animTuplesList, autoStart=False,
- en: 'loop=False, nickname=None, callBack=None, nIterations=1):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 'loop=False, nickname=None, callBack=None, nIterations=1):'
- en: 'The required parameters are:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 必需的参数是：
- en: '**window**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**window**'
- en: The window to draw in.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口绘制区域。
- en: '**loc**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**loc**'
- en: The upper-left corner where images should be drawn.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图像应该绘制的左上角。
- en: '**animTuplesList**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**animTuplesList**'
- en: A list (or tuple) of tuples describing the sequence of the animation.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 描述动画序列的元组列表（或元组）。
- en: 'Each inner tuple contains:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 每个内层元组包含：
- en: '**pathToImage** The relative path to an image file.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**pathToImage** 图像文件的相对路径。'
- en: '**Duration** The duration this image should be shown (in seconds, float-'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**Duration** 显示此图像的持续时间（单位：秒，浮动类型）'
- en: ing point).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 结束时显示的起始点。
- en: '**offset (optional)** If present, an (x, y) tuple used as an offset from the'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**offset (可选)** 如果存在，则是一个(x, y)元组，作为相对于'
- en: main loc to show this image.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 显示此图像的主要位置。
- en: 'These parameters are all optional:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数都是可选的：
- en: '**autoStart**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**autoStart**'
- en: True if you want the animation to start right away; defaults to False.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望动画立即开始，设置为True；默认为False。
- en: '**loop**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**loop**'
- en: True if you want the animation to loop continuously; defaults to False.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望动画持续循环，设置为True；默认为False。
- en: '**showFirstImageAtEnd**'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**showFirstImageAtEnd**'
- en: When an animation ends, show the first image again; defaults to True.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画结束时，重新显示第一张图片；默认为True。
- en: '**nickname**'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**nickname**'
- en: An internal name to assign to this animation, used as an argument
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给此动画的内部名称，用作参数。
- en: when a callBack is specified.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定callBack时。
- en: '**callBack**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**callBack**'
- en: The function or object method to call when the animation is done.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 动画完成时要调用的函数或对象方法。
- en: '**nIterations**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**nIterations**'
- en: The number of times to loop through the animation; defaults to 1\.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 动画循环的次数；默认为1。
- en: Unlike SimpleAnimation, which uses a single duration for all images,
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 与SimpleAnimation不同，后者对所有图像使用相同的持续时间，
- en: the Animation class lets you specify a duration for *each* image, allowing for
    Animation **305**
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Animation类允许你为*每个*图像指定持续时间，从而允许动画**305**
- en: greater flexibility in the timing of how the images are displayed. You can also
    specify an x, y offset when drawing each image, but in general this
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示图像的时序方面提供更大的灵活性。你还可以在绘制每个图像时指定x、y偏移量，但通常来说，这
- en: isn’t needed. Here is some sample code that creates an Animation object that
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要。这里是一些示例代码，创建一个Animation对象
- en: 'shows a running T-rex dinosaur:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 显示一个奔跑的霸王龙：
- en: TRexAnimationList = [('images/TRex/f1.gif', .1),
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: TRexAnimationList = [('images/TRex/f1.gif', .1),
- en: ('images/TRex/f2.gif', .1),
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ('images/TRex/f2.gif', .1),
- en: ('images/TRex/f3.gif', .1),
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ('images/TRex/f3.gif', .1),
- en: ('images/TRex/f4.gif', .1),
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: ('images/TRex/f4.gif', .1),
- en: ('images/TRex/f5.gif', .1),
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ('images/TRex/f5.gif', .1),
- en: ('images/TRex/f6.gif', .1),
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ('images/TRex/f6.gif', .1),
- en: ('images/TRex/f7.gif', .1),
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ('images/TRex/f7.gif', .1),
- en: ('images/TRex/f8.gif', .1),
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ('images/TRex/f8.gif', .1),
- en: ('images/TRex/f9.gif', .1),
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ('images/TRex/f9.gif', .1),
- en: ('images/TRex/f10.gif', .4)]
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ('images/TRex/f10.gif', .4)]
- en: 5 - Initialize variables
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 - 初始化变量
- en: oDinosaurAnimation = pygwidgets.Animation(window, (22, 145),
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: oDinosaurAnimation = pygwidgets.Animation(window, (22, 145),
- en: TRexAnimationList, callBack=myFunction, nickname='Dinosaur')
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: TRexAnimationList, 回调函数=myFunction, 昵称='Dinosaur')
- en: This creates an Animation object that will show 10 different images. The
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个动画对象，显示10张不同的图像。该
- en: first nine images each show for one-tenth of a second, but the last image
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 前九张图像每张显示十分之一秒，但最后一张图像
- en: shows for four-tenths of a second. The animation will only play once and
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 显示四分之一秒的图像。动画将只播放一次并
- en: will not automatically start playing. When the animation is finished,
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 不会自动开始播放。动画完成时，
- en: myFunction() will be called with the argument 'Dinosaur'.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: myFunction() 将会以参数'Dinosaur'被调用。
- en: '***SpriteSheetAnimation Class***'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '***SpriteSheetAnimation 类***'
- en: For SpriteSheetAnimation, you pass in a path to the single sprite sheet file.
    In
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SpriteSheetAnimation，您需要传入单个精灵图集文件的路径。
- en: order for SpriteSheetAnimation to break up the large animation into many
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这是SpriteSheetAnimation将大型动画分解为多个子动画的顺序
- en: smaller images, you must specify the width and height of all subimages. For
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较小的图像，您必须指定所有子图像的宽度和高度。对于
- en: 'durations, you have two choices: you can specify a single value to say that
    all'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 持续时间，您有两个选择：您可以指定单一值，表示所有图像
- en: images should be shown for the same amount of time, or you can specify a
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图像应该显示相同的时间，或者您可以指定一个
- en: 'list or tuple of durations, one for each image. Here’s the interface:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 持续时间列表或元组，每个图像对应一个持续时间。以下是接口：
- en: SpriteSheetAnimation(window, loc, imagePath, nImages,
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteSheetAnimation(window, loc, imagePath, nImages,
- en: width, height, durationOrDurationsList,
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度、高度、持续时间或持续时间列表，
- en: autoStart=False, loop=False, nickname=None,
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: autoStart=False, loop=False, nickname=None,
- en: 'callBack=None, nIterations=1):'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '回调函数=None, 迭代次数=1):'
- en: 'The required parameters are:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 必需的参数为：
- en: '**window** The window to draw in'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**窗口** 用于绘制的窗口'
- en: '**loc** The upper-left corner where images should be drawn'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**位置** 图像绘制的左上角'
- en: '**imagePath** The relative path to the sprite sheet image file'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**图像路径** 精灵图集图像文件的相对路径'
- en: '**nImages** The total number of subimages in the sprite sheet subimage'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**nImages** 精灵图集中的子图像总数'
- en: '**width** The width of each single resulting subimage'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**宽度** 每个生成的单一子图像的宽度'
- en: '**height** The height of each single resulting subimage'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**高度** 每个生成的单一子图像的高度'
- en: '**durationOrDurationsList** The amount of time for which each subim-'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续时间或持续时间列表** 每个子图像显示的时间，'
- en: age should be shown during animation or a list of durations, one per
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子图像应在动画期间显示，或指定一个持续时间列表，每个子图像对应一个
- en: subimage (the length must be nImages)
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 子图像（长度必须是nImages）
- en: '**306** Chapter 14'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**306** 第14章'
- en: 'These are the optional parameters:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可选参数：
- en: '**autoStart**'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动开始**'
- en: True if you want the animation to start right away; defaults to False.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望动画立即开始，可以设置为True；默认为False。
- en: '**loop**'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**循环**'
- en: True if you want to animation to loop continuously; defaults to False.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望动画循环播放，可以设置为True；默认为False。
- en: '**showFirstImageAtEnd**'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '**结束时显示第一张图像**'
- en: When an animation ends, show the first image again; defaults to True.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画结束时，重新显示第一张图像；默认为True。
- en: '**nickname**'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**昵称**'
- en: An internal name to assign to this animation, used as an argument
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 为此动画分配的内部名称，用作参数
- en: when a callBack is specified.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定回调函数时。
- en: '**callBack**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**回调函数**'
- en: The function or object method to call when the animation is done.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 动画完成时要调用的函数或对象方法。
- en: '**nIterations**'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '**迭代次数**'
- en: The number of times to loop through the animation; defaults to 1\.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 循环播放的次数；默认为1\。
- en: 'Here is a typical statement to create a SpriteSheetAnimation object:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是创建SpriteSheetAnimation对象的一个典型语句：
- en: oEffectAnimation = pygwidgets.SpriteSheetAnimation(window, (400, 150),
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: oEffectAnimation = pygwidgets.SpriteSheetAnimation(window, (400, 150),
- en: '''images/effect.png'', 35, 192, 192, .1,'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/effect.png'', 35, 192, 192, .1,'
- en: autoStart=True, loop=True)
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: autoStart=True, loop=True)
- en: This creates a SpriteSheetAnimation object using a single image file found
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用在给定路径中找到的单个图像文件创建一个SpriteSheetAnimation对象。
- en: at the given path. The original image contains 35 subimages. Each smaller
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定路径下的原始图像包含35个子图像。每个较小的
- en: image is 192×192 pixels, and each subimage will be shown for one-tenth of a
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图像大小为192×192像素，每个子图像将显示十分之一秒，
- en: second. The animation will start automatically and loop continuously.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 每张图像显示的时间为一秒。动画将自动开始并持续循环。
- en: '***Common Base Class: PygAnimation***'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '***公共基类：PygAnimation***'
- en: The Animation and SpriteSheetAnimation classes each consist only of an
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: Animation 和 SpriteSheetAnimation 类每个仅包含一个
- en: __init__() method and inherit from a common abstract base class,
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: __init__() 方法并从一个公共抽象基类继承，
- en: PygAnimation. The __init__() methods of both classes call the inherited
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: PygAnimation。两个类的 __init__() 方法调用了继承的
- en: __init__() method of the PygAnimation base class. Therefore, the __init__()
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: PygAnimation 基类的 __init__() 方法。因此，__init__()
- en: methods of the Animation and SpriteSheetAnimation classes only initialize
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: Animation 和 SpriteSheetAnimation 类的方法仅初始化
- en: the unique data in their classes.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 它们类中的独特数据。
- en: After creating an Animation or SpriteSheetAnimation object, client code
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 Animation 或 SpriteSheetAnimation 对象后，客户端代码
- en: needs to include calls to update() and draw() in every frame. The following
    is
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 需要在每一帧中包含对 update() 和 draw() 的调用。以下是
- en: 'a list of the methods available to both classes through the base class:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 列出通过基类可供两个类使用的方法：
- en: '**handleEvent( *event*****)**'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '**handleEvent( *event*****)**'
- en: Must be called in every frame if you want to check if the user has clicked
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想检查用户是否点击了
- en: on the animation. If so, you pass in the event supplied by pygame. This
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在动画上。如果是这样，你传递 pygame 提供的事件。此
- en: method returns False most of the time, but returns True when the user
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 方法大多数时候返回 False，但当用户
- en: clicks down on the image, in which case you would typically call play().
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 点击图像时，通常会调用 play()。
- en: '**play()**'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**play()**'
- en: Starts the animation playing.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 启动动画播放。
- en: Animation **307**
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 动画 **307**
- en: '**stop()**'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '**stop()**'
- en: Stops the animation wherever it is, and resets to showing only the first
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 停止动画并将其重置为仅显示第一帧
- en: image.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 图像。
- en: '**pause()**'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**pause()**'
- en: Causes the animation to temporarily stop on the current image. You
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 导致动画在当前图像上暂时停止。你
- en: can continue playing with a call to play().
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用 play() 继续播放。
- en: '**update()**'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '**update()**'
- en: Should be called in every frame. When the animation is running, this
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在每一帧中调用。当动画运行时，显示此
- en: method takes care of calculating the proper time to advance to the
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 方法负责计算正确的时间以推进到下一个
- en: next image. It typically returns False, but returns True when the anima-
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图像。它通常返回 False，但当动画
- en: tion ends (and it is not set to loop).
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 当动画结束时（并且没有设置为循环）。
- en: '**draw()**'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '**draw()**'
- en: Should be called in every frame. This method draws the current image
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在每一帧中调用。该方法绘制当前图像
- en: of the animation.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 动画的内容。
- en: '**setLoop( *trueOrFalse*****)**'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '**setLoop( *trueOrFalse*****)**'
- en: Pass in True or False to indicate whether the animation should loop or
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 传入 True 或 False 来指示动画是否应循环或
- en: not.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 否。
- en: '**getLoop()**'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '**getLoop()**'
- en: Returns True if the animation is set to loop or False if it is not.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果动画设置为循环，则返回 True；如果没有，则返回 False。
- en: '**N O T E**'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '**注**'
- en: '*The location of an animation in the window is determined by the original value
    of* *loc that’s passed to __init__(). Both Animation and SpriteSheetAnimation
    inherit* *from the common PygAnimation class, and that class inherits from PygWidget.
    Since* *all the methods available in PygWidget are therefore available in both
    animation* *classes, you could easily construct an animation that also changes
    its location while* *it is playing. You can make any animation move by calling
    setLoc(), inherited from* *PygWidget, and supplying any x and y location you like
    for each image.*'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '*动画在窗口中的位置由传递给 __init__() 的原始 loc 值决定。Animation 和 SpriteSheetAnimation 都继承自*
    *公共的 PygAnimation 类，而该类又继承自 PygWidget。由于* *所有在 PygWidget 中可用的方法在两个动画类中都可用，* *你可以轻松构建一个在播放时改变位置的动画。你可以通过调用从*
    *PygWidget 继承的 setLoc() 方法，并为每个图像提供任何 x 和 y 位置来使动画移动。*'
- en: '***Example Animation Program***'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '***示例动画程序***'
- en: Figure 14-2 shows a screenshot of a sample program that demonstrates mul-
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-2 显示了一个示例程序的截图，演示了多重
- en: tiple animations built from the Animation and SpriteSheetAnimation classes.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Animation 和 SpriteSheetAnimation 类构建的多重动画。
- en: The little dinosaur on the left is an Animation object. It’s set to autoStart
    so
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的小恐龙是一个 Animation 对象。它被设置为 autoStart，因此
- en: the animation plays when the program begins, but only once. Clicking the
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 动画在程序开始时播放，但只播放一次。点击
- en: buttons below the small dinosaur makes appropriate calls to the Animation
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 小恐龙下面的按钮会对 Animation 进行适当的调用
- en: object. If you click Play, the animation plays again. While the animation is
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 对象。如果你点击播放，动画会再次播放。当动画正在
- en: playing, clicking Pause will freeze the animation until you click Play again.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 正在播放时，点击暂停会冻结动画，直到你再次点击播放。
- en: If you play the animation and then click Stop, the animation will stop and
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果播放动画然后点击停止，动画将停止并
- en: show the first image. Below those buttons are two checkboxes. By default, this
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 显示第一张图像。下面是两个复选框。默认情况下，
- en: animation will not loop. If you check Loop, then press Play, the animation
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 动画将不会循环。如果你勾选了循环（Loop），然后按下播放（Play），动画
- en: repeats until you uncheck Loop. The Show checkbox makes the animation
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 重复，直到你取消勾选循环（Loop）。显示复选框使动画
- en: visible or invisible.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 可见或不可见。
- en: '**308** Chapter 14'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**308** 第14章'
- en: '![Image 39](index-338_1.png)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![图片 39](index-338_1.png)'
- en: '*Figure 14-2: An example animation program using the Animation and*'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '*图14-2：使用Animation和*类的一个示例动画程序。'
- en: '*SpriteSheetAnimation classes*'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '*SpriteSheetAnimation类*'
- en: The second (T-rex) Animation object is not set to autoStart, so you only
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个（T-rex）Animation对象没有设置为自动启动（autoStart），因此只有
- en: see the first image of the animation. If you click this image, the anima-
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 看看动画的第一张图像。如果点击这张图像，动画-
- en: tion is set to iterate through all its images three times (three loops) before
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 动画设置为迭代其所有图像三次（循环三次）后
- en: stopping.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 停止。
- en: At the top right is a firework SpriteSheetAnimation object, which comes
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 右上角是一个烟花SpriteSheetAnimation对象，来自
- en: from a single image containing 35 subimages. This animation is set to loop,
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 来自一个包含35个子图像的单一图像。此动画设置为循环，
- en: so you see it run continuously.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 因此你会看到它持续运行。
- en: At the bottom right is a walking SpriteSheetAnimation from a single image
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 右下角是一个由单一图像组成的行走SpriteSheetAnimation。
- en: with 36 subimages. When you click Start, the animation plays through all
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 带有36个子图像。当你点击开始（Start）时，动画会播放完所有
- en: the images once.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 只显示一次图像。
- en: The full source code of this program is available in the *AnimationExample/*
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的完整源代码可在*AnimationExample/*
- en: '*Main_AnimationExample.py* file along with the rest of the book’s resources.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '*Main_AnimationExample.py*文件与本书的其余资源一起提供。'
- en: The program instantiates two Animation objects (the small dinosaur and
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 程序实例化了两个Animation对象（小恐龙和
- en: the T-rex) and two SpriteSheetAnimation objects (the firework and the walk-
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: T-rex）和两个SpriteSheetAnimation对象（烟花和行走-
- en: ing person). When a button below the little dinosaur is clicked, we call the
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击小恐龙下方的按钮时，我们调用
- en: appropriate method of the dinosaur animation object. A click on the little
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 合适的恐龙动画对象方法。点击小
- en: dinosaur or T-rex results in a call to the start() method of that animation.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 恐龙或T-rex的点击会调用该动画的start()方法。
- en: The program shows that multiple animations can run at the same
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 程序显示多个动画可以同时运行
- en: time. This works because the main loop calls the update() and draw() meth-
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 时间。这是因为主循环调用了update()和draw()方法-
- en: ods of *each* animation in every frame in the main loop, and each animation
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 每一帧中的*每个*动画都遵循主循环中的方法，每个动画
- en: makes its own decision about keeping the current image or showing the
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 根据当前图像或显示下一个图像做出自己的决定。
- en: next image.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 显示下一个图像。
- en: Animation **309**
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: Animation **309**
- en: '**Summary**'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we explored the mechanisms required in an animation class
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了动画类中所需的机制。
- en: by building our own SimpleAnimation and SimpleSpriteSheetAnimation classes.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建我们自己的SimpleAnimation和SimpleSpriteSheetAnimation类。
- en: The former is made up of multiple images, whereas the latter uses a single
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 前者由多个图像组成，而后者使用单一的
- en: larger image that contains multiple subimages.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 包含多个子图像的较大图像。
- en: These two classes have different initializations, but the remaining meth-
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类有不同的初始化方法，但其余的方法-
- en: ods of the classes are identical. I explained the process of merging the two
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 类的结构是相同的。我解释了合并这两个
- en: classes by building a common abstract base class.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建一个公共抽象基类来组织类。
- en: I then introduced the Animation class and the SpriteSheetAnimation class
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我介绍了Animation类和SpriteSheetAnimation类
- en: in pygwidgets. I explained that these two classes only implement their own
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在pygwidgets中。我解释了这两个类只实现了它们自己的
- en: versions of the __init__() method, inheriting their other methods from the
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: __init__()方法的不同版本，继承它们的其他方法来自
- en: common base class, PygAnimation. I concluded by showing a demonstration
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 通用基类PygAnimation。我最后展示了一个示范
- en: program that provides examples of animations and sprite sheet animations.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 提供示例动画和精灵图集动画的程序。
- en: '**15**'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '**15**'
- en: '**S C E N E S**'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景**'
- en: Games and programs will often need to
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏和程序通常需要
- en: present different scenes to the user. For the
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 向用户展示不同的场景。对于
- en: purpose of this discussion, I’ll define a *scene*
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 本讨论的目的，我将定义一个*场景*
- en: as any window layout and related user interac-
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 以及任何窗口布局和相关的用户交互-
- en: tions that are significantly different from any other. For
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 状态与任何其他状态有显著不同。例如
- en: example, a game like *Space Invaders* may have a starting
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个像 *Space Invaders* 这样的游戏可能有一个开始
- en: or *splash* scene, a main game play scene, a high scores
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 或 *欢迎* 场景，主要游戏场景，最高得分
- en: scene, and perhaps an ending or goodbye scene.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 场景，也许还有一个结束或告别场景。
- en: In this chapter I will discuss two different approaches to writing a pro-
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将讨论两种不同的编写程序的方法
- en: gram that has multiple scenes. First, I’ll introduce the state machine tech-
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有多个场景的程序更加可扩展。首先，我将介绍状态机技术
- en: nique, which works well for relatively small programs. Then I’ll show a fully
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 技术，它适用于相对较小的程序。然后，我将展示一个完整的
- en: object-oriented approach where each scene is implemented as an object,
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的方法，每个场景都作为一个对象来实现，
- en: under the control of a scene manager. The latter is much more scalable for
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 由场景管理器控制。后者对于
- en: larger programs.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 更大的程序。
- en: '**The State Machine Approach**'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态机方法**'
- en: At the beginning of this book, we developed a software simulation of a
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的开头，我们开发了一个软件模拟器
- en: light switch. I[n Chapter 1, w](index_split_000.html#p32)e first implemented
    a light switch using procedural code, and then we rewrote it using a class. In
    both cases, the position
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 开关。在第1章，我们首先使用过程代码实现了一个灯光开关，然后我们用类重新编写了它。在这两种情况下，位置
- en: (or state) of the switch was represented by a single Boolean variable; True
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: （或开关的状态）由一个布尔变量表示；True
- en: represented on and False represented off.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 表示打开的为 True，表示关闭的为 False。
- en: There are many situations where a program or an object can be in
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下，一个程序或对象可能处于
- en: one of a number of different states, and different code needs to run based
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个不同状态之一运行的，且根据
- en: on the current state. For example, consider the series of steps involved in
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 基于当前状态。例如，考虑以下步骤的序列：
- en: using an ATM. There is a starting (greeting) state, then you need to put in
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ATM 时。有一个初始（问候）状态，然后你需要输入
- en: your ATM card; after this you’re prompted to enter your PIN, choose which
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 ATM 卡；然后你需要输入 PIN 码，选择想要
- en: action you want to do, and so on. At any point, you may need to go back a
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要执行的操作，等等。任何时候，你可能需要返回到之前的状态。
- en: step or even start over. The general implementation approach is to use a
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤或甚至重新开始。一般的实现方法是使用一个
- en: '*state machine*.'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '*状态机*。'
- en: '**state machine**'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态机**'
- en: A model that represents and controls the flow of execution through a series
    of states .
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模型，表示并控制通过一系列状态的执行流程。
- en: 'The implementation of a state machine consists of:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机的实现包括：
- en: • A collection of predefined states, typically expressed as constants whose
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: • 一组预定义状态，通常表示为常量，这些常量
- en: values are strings comprised of a word or short phrase that describes
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 值是由一个单词或简短短语组成的字符串，用于描述
- en: what happens in the state
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 状态中会发生什么
- en: • A single variable to track the current state
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: • 一个单一的变量来跟踪当前状态
- en: • A starting state (from the set of predefined states)
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: • 一个初始状态（来自预定义状态集）
- en: • A set of clearly defined transitions between states
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: • 一组清晰定义的状态转换
- en: A state machine can only be in one state at any given time, but can
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 一个状态机在任何给定时刻只能处于一个状态，但可以
- en: move to a new state, typically based on specific input from the user.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 移动到一个新状态，通常基于用户的特定输入。
- en: I[n Chapter 7 w](index_split_003.html#p172)e discussed the GUI button classes
    in the pygwidgets package. When rolling over and clicking a button, a user sees
    three different images—up, over, and down—which correspond to different states
    of
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章，我讨论了 pygwidgets 包中的 GUI 按钮类。当滚动并点击按钮时，用户会看到三种不同的图像——上升、悬停和按下——这些图像对应于按钮的不同状态。
- en: the button. The image switching is done in the handleEvent() method (which
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮。图像切换是在 handleEvent() 方法中完成的（该方法
- en: is called whenever an event occurs). Let’s take a closer look at how this is
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 每当事件发生时都会调用此方法。让我们仔细看看这是如何
- en: implemented.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 已实现。
- en: The handleEvent() method is built as a state machine. The state is kept
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: handleEvent() 方法被构建为一个状态机。状态被保持在
- en: in an instance variable, self.state. Each button starts in the up state, show-
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例变量 self.state 中保持状态。每个按钮从上升状态开始，显示
- en: ing the “up” image. When the user moves the cursor over a button, we
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 显示“向上”图像。当用户将光标移动到按钮上时，我们
- en: show the “over” image and the code transitions to the over state. When the
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 显示“悬停”图像，并且代码过渡到悬停状态。当
- en: user clicks down on the button, we show the “down” image and the code
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击按钮时，我们显示“按下”图像，并且代码
- en: moves into the down state (internally called the *armed* state). When the user
    releases the mouse button (clicks up), we again show the “over” image, and
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 移动到“down”状态（内部称为*armed*状态）。当用户释放鼠标按钮（点击“up”）时，我们再次显示“over”图像，并
- en: the code transitions back to the over state (and handleEvent() returns True
    to
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将过渡回“over”状态（并且handleEvent()返回True以
- en: indicate that a click has happened). If the user then moves the cursor off the
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 表示点击已发生）。如果用户随后将光标移出
- en: button, we show the “up” image again and transition back to the up state.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮时，我们再次显示“up”图像并过渡回“up”状态。
- en: '**312** Chapter 15'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '**312** 第15章'
- en: Next, I’ll show you how we can use a state machine to represent different scenes
    that a user can encounter in a larger program. As a generic
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将向你展示如何使用状态机来表示用户在一个较大程序中可能遇到的不同场景。作为一种通用
- en: 'example, we’ll have the following scenes: *Splash* (starting), *Play*, and
    *End*.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将有以下场景：*Splash*（起始）、*Play*和*End*。
- en: We’ll create a set of constants that represent the different states, create
    a
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一组常量，表示不同的状态，并创建一个
- en: 'variable called state, and assign it the value of the starting state:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 变量称为 state，并将其赋值为起始状态：
- en: STATE_SPLASH = 'splash'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: STATE_SPLASH = 'splash'
- en: STATE_PLAY = 'play'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: STATE_PLAY = 'play'
- en: STATE_END = 'end'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: STATE_END = 'end'
- en: 'state = STATE_SPLASH # initialize to starting state'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 'state = STATE_SPLASH # 初始化为起始状态'
- en: In order to perform different actions in the different states, in the pro-
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不同的状态下执行不同的操作，在程序中
- en: gram’s main loop we use an if/elif/elif/.../else construct that branches
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的主循环中使用了if/elif/elif/.../else结构进行分支
- en: 'based on the current value of the state variable:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 根据状态变量的当前值：
- en: 'while True:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'if state == STATE_SPLASH:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 'if state == STATE_SPLASH:'
- en: Do whatever you want to do in the Splash state here
  id: totrans-545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在此处执行你想在Splash状态中做的任何事情
- en: 'elif state == STATE_PLAY:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif state == STATE_PLAY:'
- en: Do whatever you want to do in the Play state here
  id: totrans-547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在此处执行你想在Play状态中做的任何事情
- en: 'elif state == STATE_END:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif state == STATE_END:'
- en: Do whatever you want to do in the End state here
  id: totrans-549
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在此处执行你想在结束状态中做的任何事情
- en: 'else:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: 'raise ValueError(''Unknown value for state: '' + state)'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: raise ValueError('状态值未知：' + state)
- en: Since state is initially set to STATE_SPLASH, only the first branch of the if
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 由于状态初始设置为STATE_SPLASH，只有第一个分支会执行
- en: statement will run.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 语句将运行。
- en: The idea of a state machine is that under certain circumstances, typi-
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机的思想是，在某些情况下，通常
- en: cally triggered by some event, the program changes its state by assigning a
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 通常由某个事件触发，程序通过为状态变量赋值来改变其状态
- en: different value to the state variable. For example, the starting Splash scene
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的值给状态变量。例如，起始的Splash场景
- en: could just show a game introduction with a Start button. When the user
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 可能只会显示一个带有开始按钮的游戏介绍。当用户
- en: clicks the Start button, the game will execute an assignment statement that
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 点击开始按钮时，游戏将执行一个赋值语句，表示
- en: 'changes the value of the state variable to transition into the Play state:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 更改状态变量的值，以便过渡到“Play”状态：
- en: state = STATE_PLAY
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: state = STATE_PLAY
- en: Once that line runs, only the code in the first elif runs and completely
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行该行，只有第一个elif中的代码会执行，并完全
- en: different code will execute—the code to show and react to the Play state.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 会执行不同的代码——即显示并响应“Play”状态的代码。
- en: Similarly, whenever and however the program reaches the ending con-
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，无论程序如何或何时到达游戏结束条件，它都会执行以下代码以过渡到
- en: dition for the game, it will execute the following line to transition to the
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的结束条件触发时，它将执行以下代码以过渡到
- en: 'End state:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 结束状态：
- en: state = STATE_END
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: state = STATE_END
- en: From then on, every time the program goes around the while loop, the
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，每次程序执行while循环时，
- en: code of the second elif branch will run.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个elif分支的代码将执行。
- en: In summary, a state machine has a set of states, one variable to keep
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，状态机有一组状态，一个变量用于保持
- en: track of which state the program is in, and a set of events that cause the pro-
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪程序当前处于哪个状态，并有一组事件会导致程序
- en: gram to transition from one state to another. Since there is a single variable
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 程序从一个状态过渡到另一个状态。由于只有一个变量
- en: Scenes **313**
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 场景 **313**
- en: '![Image 40](index-343_1.png)'
  id: totrans-573
  prefs: []
  type: TYPE_IMG
  zh: '![Image 40](index-343_1.png)'
- en: that keeps track of the state, the program can be in only one of the states
    at
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 用来跟踪状态的变量，程序只能处于一个状态
- en: any time. Different actions that the user takes (clicking a button, pressing
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 随时发生。用户采取的不同动作（点击按钮、按下
- en: a key, dragging an item, and so on) or other events (such as a timer run-
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 按键、拖动物品等事件（如计时器倒计时）
- en: ning out) can cause the program to transition from one state to another.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器倒计时）等其他事件也可以导致程序从一个状态过渡到另一个状态。
- en: Depending on which state it is in, the program may listen for different
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 根据所处的状态，程序可能会监听不同的事件
- en: events and will typically execute different code.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 事件将通常执行不同的代码。
- en: '**A pygame Example with a State Machine**'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个带有状态机的 pygame 示例**'
- en: Next, we’ll build a Rock, Paper, Scissors game that uses a state machine.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建一个使用状态机的石头、纸、剪刀游戏。
- en: The user chooses rock, paper, or scissors; then the computer randomly
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 用户选择石头、纸或剪刀；然后计算机会随机
- en: chooses among the three. If the person and computer choose the same
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 在三者中做出选择。如果玩家和计算机选择相同
- en: item, it’s a tie. Otherwise, one point is awarded to the player or the com-
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是平局，分数不变。否则，玩家或计算机得一分。
- en: 'puter, according to the following rules:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机根据以下规则做出选择：
- en: • Rock crushes scissors.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: • 石头压碎剪刀。
- en: • Scissors cuts paper.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: • 剪刀剪纸。
- en: • Paper covers rock.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: • 纸覆盖石头。
- en: 'The user will see the game as three scenes: an opening or Splash scene'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将看到三个场景：一个开场或 Splash 场景
- en: (Figure 15-1), a Play scene (Figure 15-2), and a Results scene (Figure 15-3).
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: （图 15-1），一个游戏场景（图 15-2），以及一个结果场景（图 15-3）。
- en: '*Figure 15-1: The Rock, Paper, Scissors Splash scene*'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-1：石头、纸、剪刀 Splash 场景*'
- en: The Splash scene waits for the user to click the Start button.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: Splash 场景等待用户点击“开始”按钮。
- en: '**314** Chapter 15'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '**314** 第 15 章'
- en: '![Image 41](index-344_1.png)'
  id: totrans-594
  prefs: []
  type: TYPE_IMG
  zh: '![图片 41](index-344_1.png)'
- en: '![Image 42](index-344_2.png)'
  id: totrans-595
  prefs: []
  type: TYPE_IMG
  zh: '![图片 42](index-344_2.png)'
- en: '*Figure 15-2: The Rock, Paper, Scissors Play scene*'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-2：石头、纸、剪刀游戏场景*'
- en: The Play scene is where the user makes a choice. After the user clicks
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏进行场景是用户做出选择的地方。用户点击后
- en: an icon to indicate their choice, the computer makes a randomized choice.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 用户选择图标来表示他们的选择，计算机做出随机选择。
- en: '*Figure 15-3: The Rock, Paper, Scissors Results scene*'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-3：石头、纸、剪刀结果场景*'
- en: Scenes **315**
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 场景 **315**
- en: The Results scene shows the outcome of the round and the score. It waits for
    the user to click Restart to play another round.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 结果场景显示回合的结果和得分。它等待用户点击“重启”按钮以开始另一个回合。
- en: In this game, each value of state corresponds to a different scene.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，每个状态值对应一个不同的场景。
- en: Figure 15-4 is a *state diagram* that shows the states and transitions (the
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-4 是一个*状态图*，展示了状态及其转换（
- en: actions or events that cause the program to move from one state to
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 动作或事件导致程序从一个状态转移到
- en: another).
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个）。
- en: Choose rock, paper, or scissors
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 选择石头、纸或剪刀
- en: Press Start button
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 按下开始按钮
- en: Splash
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: Splash
- en: Play
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏进行
- en: Results
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 结果
- en: Press Restart button
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 按下重启按钮
- en: '*Figure 15-4: Rock, Paper, Scissors state diagram*'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-4：石头、纸、剪刀状态图*'
- en: When sitting idle (waiting for the user), the current scene will typically
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序处于空闲状态（等待用户时），当前场景通常
- en: remain unchanged. That is, inside the main event loop, the program will
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 保持不变。也就是说，在主事件循环中，程序将
- en: usually not change the value of the state variable. (The state might change
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不会改变状态变量的值。（状态可能会变化
- en: when a timer ends, but this will be rare.) This game starts in the Splash
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 当定时器结束时，但这种情况很少发生。）这个游戏从 Splash
- en: scene, and when the user presses the Start button, the game moves to the
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 场景，当用户按下“开始”按钮时，游戏转移到
- en: Play scene. The play of the game then alternates between the Play and
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏场景。游戏的进行在“游戏”场景与
- en: Results scenes. Though this is a simple example, a state diagram can be very
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 结果场景。虽然这是一个简单的示例，但状态图可以非常
- en: useful in understanding the flow of more complicated programs.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解更复杂程序的流程时非常有用。
- en: Listing 15-1 provides the code of the Rock, Paper, Scissors program,
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 15-1 提供了石头、纸、剪刀程序的代码，
- en: with the boilerplate code omitted to save space.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 省略了样板代码以节省空间。
- en: '**File: RockPaperScissorsStateMachine/RockPaperScissors.py**'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：RockPaperScissorsStateMachine/RockPaperScissors.py**'
- en: Rock, Paper, Scissors in pygame
  id: totrans-624
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 pygame 中的石头、纸、剪刀
- en: Demonstration of a state machine
  id: totrans-625
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态机演示
- en: '--- snip ---'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '--- snip ---'
- en: ROCK = 'Rock'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: ROCK = 'Rock'
- en: PAPER = 'Paper'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: PAPER = 'Paper'
- en: SCISSORS = 'Scissors'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: SCISSORS = 'Scissors'
- en: Set constants for each of the three states
  id: totrans-630
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为每个状态设置常量
- en: STATE_SPLASH = 'Splash' 1
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: STATE_SPLASH = 'Splash' 1
- en: STATE_PLAYER_CHOICE = 'PlayerChoice'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: STATE_PLAYER_CHOICE = 'PlayerChoice'
- en: STATE_SHOW_RESULTS = 'ShowResults'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: STATE_SHOW_RESULTS = 'ShowResults'
- en: 3 - Initialize the world
  id: totrans-634
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 - 初始化世界
- en: '--- snip ---'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '--- snip ---'
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-636
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 - 加载资源：图像、声音等。
- en: '--- snip ---'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '--- snip ---'
- en: '**316** Chapter 15'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '**316** 第 15 章'
- en: 5 - Initialize variables
  id: totrans-639
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 - 初始化变量
- en: playerScore = 0
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: playerScore = 0
- en: computerScore = 0
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: computerScore = 0
- en: 'state = STATE_SPLASH 2 # the starting state'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 'state = STATE_SPLASH 2 # 初始状态'
- en: 6 - Loop forever
  id: totrans-643
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 - 永久循环
- en: 'while True:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 7 - Check for and handle events
  id: totrans-645
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 - 检查并处理事件
- en: 'for event in pygame.event.get():'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: 'if event.type == pygame.QUIT:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 event.type == pygame.QUIT:'
- en: pygame.quit()
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: 'if state == STATE_SPLASH: 3'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 state == STATE_SPLASH: 3'
- en: 'if startButton.handleEvent(event):'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 startButton.handleEvent(event):'
- en: state = STATE_PLAYER_CHOICE
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: state = STATE_PLAYER_CHOICE
- en: 'elif state == STATE_PLAYER_CHOICE: 4 # let the user choose'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif state == STATE_PLAYER_CHOICE: 4 # 让用户选择'
- en: 'playerChoice = '''' # indicates no choice yet'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 'playerChoice = '''' # 表示尚未做出选择'
- en: 'if rockButton.handleEvent(event):'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 rockButton.handleEvent(event):'
- en: playerChoice = ROCK
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: playerChoice = ROCK
- en: rpsCollectionPlayer.replace(ROCK)
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: rpsCollectionPlayer.replace(ROCK)
- en: 'elif paperButton.handleEvent(event):'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif paperButton.handleEvent(event):'
- en: playerChoice = PAPER
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: playerChoice = PAPER
- en: rpsCollectionPlayer.replace(PAPER)
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: rpsCollectionPlayer.replace(PAPER)
- en: 'elif scissorButton.handleEvent(event):'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif scissorButton.handleEvent(event):'
- en: playerChoice = SCISSORS
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: playerChoice = SCISSORS
- en: rpsCollectionPlayer.replace(SCISSORS)
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: rpsCollectionPlayer.replace(SCISSORS)
- en: 'if playerChoice != '''': # player has made a choice, make computer choice'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 playerChoice != '''': # 玩家已做出选择，开始电脑选择'
- en: Computer chooses from tuple of moves
  id: totrans-665
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电脑从动作元组中选择
- en: rps = (ROCK, PAPER, SCISSORS)
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: rps = (ROCK, PAPER, SCISSORS)
- en: 'computerChoice = random.choice(rps) # computer chooses'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 'computerChoice = random.choice(rps) # 电脑选择'
- en: rpsCollectionComputer.replace(computerChoice)
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: rpsCollectionComputer.replace(computerChoice)
- en: Evaluate the game
  id: totrans-669
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估游戏
- en: 'if playerChoice == computerChoice: # tie'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 playerChoice == computerChoice: # 平局'
- en: resultsField.setValue('It is a tie!')
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: resultsField.setValue('平局！')
- en: tieSound.play()
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: tieSound.play()
- en: 'elif playerChoice == ROCK and computerChoice == SCISSORS:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif playerChoice == ROCK and computerChoice == SCISSORS:'
- en: resultsField.setValue('Rock breaks Scissors. You win!')
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: resultsField.setValue('石头压碎剪刀。你赢了！')
- en: playerScore = playerScore + 1
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: playerScore = playerScore + 1
- en: winnerSound.play()
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: winnerSound.play()
- en: 'elif playerChoice == ROCK and computerChoice == PAPER:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif playerChoice == ROCK and computerChoice == PAPER:'
- en: resultsField.setValue('Rock is covered by Paper. You lose.')
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: resultsField.setValue('石头被纸覆盖。你输了。')
- en: computerScore = computerScore + 1
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: computerScore = computerScore + 1
- en: loserSound.play()
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: loserSound.play()
- en: Scenes **317**
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 场景 **317**
- en: 'elif playerChoice == SCISSORS and computerChoice == PAPER: resultsField.setValue(''Scissors
    cuts Paper. You win!'')'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif playerChoice == SCISSORS and computerChoice == PAPER: resultsField.setValue(''剪刀剪断纸。你赢了！'')'
- en: playerScore = playerScore + 1
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: playerScore = playerScore + 1
- en: winnerSound.play()
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: winnerSound.play()
- en: 'elif playerChoice == SCISSORS and computerChoice == ROCK:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif playerChoice == SCISSORS and computerChoice == ROCK:'
- en: resultsField.setValue('Scissors crushed by Rock. You lose.')
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: resultsField.setValue('剪刀被石头压碎。你输了。')
- en: computerScore = computerScore + 1
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: computerScore = computerScore + 1
- en: loserSound.play()
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: loserSound.play()
- en: 'elif playerChoice == PAPER and computerChoice == ROCK:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif playerChoice == PAPER and computerChoice == ROCK:'
- en: resultsField.setValue('Paper covers Rock. You win!')
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: resultsField.setValue('纸覆盖石头。你赢了！')
- en: playerScore = playerScore + 1
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: playerScore = playerScore + 1
- en: winnerSound.play()
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: winnerSound.play()
- en: 'elif playerChoice == PAPER and computerChoice == SCISSORS:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif playerChoice == PAPER and computerChoice == SCISSORS:'
- en: resultsField.setValue('Paper is cut by Scissors. You lose.')
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: resultsField.setValue('纸被剪刀剪断。你输了。')
- en: computerScore = computerScore + 1
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: computerScore = computerScore + 1
- en: loserSound.play()
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: loserSound.play()
- en: Show the player's score
  id: totrans-697
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示玩家得分
- en: 'playerScoreCounter.setValue(''Your Score: ''+ str(playerScore))'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 'playerScoreCounter.setValue(''你的得分: '' + str(playerScore))'
- en: Show the computer's score
  id: totrans-699
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示电脑得分
- en: 'computerScoreCounter.setValue(''Computer Score: ''+ str(computerScore))'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 'computerScoreCounter.setValue(''电脑得分: '' + str(computerScore))'
- en: 'state = STATE_SHOW_RESULTS # change state'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 'state = STATE_SHOW_RESULTS # 改变状态'
- en: 'elif state == STATE_SHOW_RESULTS: 5'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif state == STATE_SHOW_RESULTS: 5'
- en: 'if restartButton.handleEvent(event):'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 restartButton.handleEvent(event):'
- en: 'state = STATE_PLAYER_CHOICE # change state'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 'state = STATE_PLAYER_CHOICE # 改变状态'
- en: 'else:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '否则:'
- en: raise ValueError('Unknown value for state:', state)
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: raise ValueError('状态值未知:', state)
- en: 8 - Do any "per frame" actions
  id: totrans-707
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 - 执行每帧动作
- en: 'if state == STATE_PLAYER_CHOICE:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 state == STATE_PLAYER_CHOICE:'
- en: messageField.setValue(' Rock Paper Scissors')
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: messageField.setValue(' 剪刀石头布')
- en: 'elif state == STATE_SHOW_RESULTS:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif state == STATE_SHOW_RESULTS:'
- en: messageField.setValue('You Computer')
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: messageField.setValue('你 电脑')
- en: 9 - Clear the window
  id: totrans-712
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 - 清空窗口
- en: window.fill(GRAY)
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: window.fill(GRAY)
- en: 10 - Draw all window elements
  id: totrans-714
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 - 绘制所有窗口元素
- en: messageField.draw()
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: messageField.draw()
- en: 'if state == STATE_SPLASH: 6'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 state == STATE_SPLASH: 6'
- en: rockImage.draw()
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: rockImage.draw()
- en: paperImage.draw()
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: paperImage.draw()
- en: scissorsImage.draw()
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: scissorsImage.draw()
- en: startButton.draw()
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: startButton.draw()
- en: Draw player choices
  id: totrans-721
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制玩家选择
- en: 'elif state == STATE_PLAYER_CHOICE: 7'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif state == STATE_PLAYER_CHOICE: 7'
- en: rockButton.draw()
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: rockButton.draw()
- en: '**318** Chapter 15'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: '**318** 第15章'
- en: paperButton.draw()
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: paperButton.draw()
- en: scissorButton.draw()
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: scissorButton.draw()
- en: chooseText.draw()
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: chooseText.draw()
- en: Draw the results
  id: totrans-728
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制结果
- en: 'elif state == STATE_SHOW_RESULTS: 8'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif state == STATE_SHOW_RESULTS: 8'
- en: resultsField.draw()
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: resultsField.draw()
- en: rpsCollectionPlayer.draw()
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: rpsCollectionPlayer.draw()
- en: rpsCollectionComputer.draw()
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: rpsCollectionComputer.draw()
- en: playerScoreCounter.draw()
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: playerScoreCounter.draw()
- en: computerScoreCounter.draw()
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: computerScoreCounter.draw()
- en: restartButton.draw()
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '`restartButton.draw()`'
- en: 11 - Update the window
  id: totrans-736
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 - 更新窗口
- en: pygame.display.update()
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '`pygame.display.update()`'
- en: 12 - Slow things down a bit
  id: totrans-738
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 - 稍微减慢一些
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '`clock.tick(FRAMES_PER_SECOND)` # 使 pygame 等待'
- en: '*Listing 15-1: The Rock, Paper, Scissors game*'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 15-1: 石头、剪子、布游戏*'
- en: In this listing, I have snipped the code that creates images, buttons, and
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 在此列表中，我省略了创建图像、按钮和
- en: text fields for the Splash, Play, and Results scenes. The downloadable files
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 用于 Splash、Play 和 Results 场景的文本字段。可下载文件
- en: for the book contain the full source code and all the associated art.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 书中包含完整的源代码和所有相关艺术资源。
- en: Before the program goes into the main loop, we define all three states 1,
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序进入主循环之前，我们定义所有三个状态 1，
- en: instantiate and load all the screen elements, and set the starting state 2\.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化并加载所有屏幕元素，并设置初始状态 2\。
- en: We do different event checks depending on which state the program is
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据程序当前的状态进行不同的事件检查
- en: in. In the Splash state, we only check for clicking the Start button 3\. In
    the
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 在“Splash”状态中，我们只检查是否点击了开始按钮 3\。在
- en: Play state, we check for a click on the Rock, Paper, or Scissors icon buttons
    4\.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 在“Play”状态中，我们检查是否点击了“石头、剪子、布”图标按钮 4\。
- en: In the Results state, we only check for a click on the Restart button 5\.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Results 状态中，我们只检查是否点击了重启按钮 5\。
- en: Pressing a button or making a selection in one scene changes the value
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮点击或在一个场景中做出选择会更改状态变量的值
- en: of the state variable and therefore moves the game into a different scene.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 状态变量的变化，因此将游戏移动到不同的场景。
- en: At the bottom of the main loop 6 7 8, we draw different screen elements
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环的底部 6 7 8，我们绘制不同的屏幕元素
- en: depending on which state the program is currently in.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 取决于程序当前所处的状态。
- en: This technique works well for a small number of states/scenes. However,
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术适用于少量状态/场景。然而，
- en: in a program with more complicated rules or one that has many scenes and/
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个规则更复杂或有多个场景的程序中，/
- en: or states, keeping track of what should be done where can become very dif-
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 或状态，跟踪应该在何处做什么可能变得非常困难，
- en: ficult. Instead, we can take advantage of many of the object-oriented pro-
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 困难。相反，我们可以利用许多面向对象的编程技术
- en: gramming techniques introduced earlier in this book and build a different
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 本书前面介绍的面向对象编程技术可以帮助构建一个不同的
- en: architecture based on independent scenes, all controlled by an object man-
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 基于独立场景的架构中，所有场景由一个对象管理，程序架构
- en: ager object.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 管理器对象。
- en: '**A Scene Manager for Managing Many Scenes**'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个用于管理多个场景的场景管理器**'
- en: The second approach to building a program with multiple scenes is to use
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个包含多个场景的程序的第二种方法是使用
- en: 'a *scene manager*: an object that centralizes the handling of different scenes.'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *场景管理器*：一个集中处理不同场景的对象。
- en: We’ll create a SceneMgr class and instantiate a single oSceneMgr object from
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 `SceneMgr` 类，并实例化一个 oSceneMgr 对象
- en: it. In the following discussion, I’ll refer to the oSceneMgr object as the scene
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 它。在接下来的讨论中，我将把 oSceneMgr 对象称为场景
- en: manager, since we only instantiate one. As you’ll see, the scene manager
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 管理器，因为我们只实例化一个。如您所见，场景管理器
- en: and the related scenes take advantage of encapsulation, inheritance, and
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 相关场景利用了封装、继承和
- en: polymorphism.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性。
- en: Scenes **319**
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 场景 **319**
- en: '![Image 43](index-349_1.png)'
  id: totrans-770
  prefs: []
  type: TYPE_IMG
  zh: '![图片 43](index-349_1.png)'
- en: Using the scene manager can be a little tricky, but the resulting pro-
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 使用场景管理器可能有点棘手，但最终的程序
- en: gram architecture results in a highly modular, easy-to-modify program. A
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个高度模块化、易于修改的程序。一种
- en: 'program that uses the scene manager will be made up of the following files:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 使用场景管理器的程序将由以下文件组成：
- en: '**Main program** The small main program (that you write) must first'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '**主程序** 您编写的小型主程序必须首先'
- en: create an instance of every scene identified in your program, then cre-
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 创建程序中每个场景的实例，然后创建
- en: ate an instance of the scene manager, passing a list of the scenes and
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 获取场景管理器的实例，传递场景列表并
- en: a frame rate. To start your program, you call the run() method of the
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 帧率。要启动程序，您需要调用 `run()` 方法
- en: scene manager. For each new project you build, you must write a new
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 场景管理器。对于每个新的项目，您必须编写一个新的
- en: main program.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序。
- en: '**Scene manager** The scene manager is written for you and is avail-'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景管理器** 场景管理器是为您编写的，并且可用，'
- en: able as the SceneMgr class in the *pyghelpers.py* file. It keeps track of all
    the different scenes, remembers which one is current, calls methods in the
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 *pyghelpers.py* 文件中类似于 SceneMgr 类的对象。它跟踪所有不同的场景，记住当前的场景，调用
- en: current scene, allows for switching between scenes, and handles com-
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 当前场景，允许场景之间的切换，并处理场景之间的通信。
- en: munication between scenes.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 场景之间的通信。
- en: '**Scenes** Your program can have as many scenes as you want or need.'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景** 你的程序可以根据需要有任意数量的场景。'
- en: Each scene is typically developed as a separate Python file. Each scene
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 每个场景通常作为一个独立的 Python 文件进行开发。每个场景
- en: class must inherit from the prewritten Scene base class and have a set of
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 类必须继承自预编写的 Scene 基类，并拥有一组
- en: methods whose names are predefined. The scene manager uses poly-
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 预定义名称的那些方法。场景管理器使用多态性来调用这些方法。
- en: morphism to call these methods in the current scene. I have provided a
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多态性来调用当前场景中的这些方法。我已经提供了一个
- en: template *ExampleScene.py* file to show you how to build a scene.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 模板 *ExampleScene.py* 文件展示了如何构建一个场景。
- en: The code for the SceneMgr class and the code for the Scene base class live
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: SceneMgr 类的代码和 Scene 基类的代码位于
- en: in the pyghelpers package. The scene manager is an object manager object
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pyghelpers 包中。场景管理器是一个对象管理器对象
- en: that manages any number of Scene objects.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 它管理任意数量的场景对象。
- en: '**A Demo Program Using a Scene Manager**'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用场景管理器的演示程序**'
- en: As a demonstration, we’ll build a Scene Demo program that contains three
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 作为演示，我们将构建一个包含三个场景的场景演示程序。
- en: 'simple scenes: Scene A, Scene B, and Scene C. The idea is that from any'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 简单场景：场景 A、场景 B 和场景 C。其概念是从任何
- en: scene, you can click a button to get to any other scene. Figures 15-5 through
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中，你可以点击一个按钮进入任何其他场景。图 15-5 到
- en: 15-7 show screenshots of the three scenes.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-7 展示了三种场景的截图。
- en: '*Figure 15-5: What the user sees in Scene A*'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-5：用户在场景 A 中看到的内容*'
- en: From Scene A, you can get to Scene B or Scene C.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 从场景 A，你可以进入场景 B 或场景 C。
- en: '**320** Chapter 15'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '**320** 第 15 章'
- en: '![Image 44](index-350_1.png)'
  id: totrans-801
  prefs: []
  type: TYPE_IMG
  zh: '![图片 44](index-350_1.png)'
- en: '![Image 45](index-350_2.png)'
  id: totrans-802
  prefs: []
  type: TYPE_IMG
  zh: '![图片 45](index-350_2.png)'
- en: '![Image 46](index-350_3.png)'
  id: totrans-803
  prefs: []
  type: TYPE_IMG
  zh: '![图片 46](index-350_3.png)'
- en: '*Figure 15-6: What the user sees in Scene B*'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-6：用户在场景 B 中看到的内容*'
- en: From Scene B, you can get to Scene A or Scene C.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 从场景 B，你可以进入场景 A 或场景 C。
- en: '*Figure 15-7: What the user sees in Scene C*'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-7：用户在场景 C 中看到的内容*'
- en: From Scene C, you can get to Scene A or Scene B.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 从场景 C，你可以进入场景 A 或场景 B。
- en: The structure of the project folder is shown in Figure 15-8\. Note that
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 项目文件夹的结构如图 15-8 所示。请注意
- en: this assumes that you have already installed the pygwidgets and pyghelpers
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设你已经安装了 pygwidgets 和 pyghelpers
- en: modules in the proper *site-packages* folder.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 模块位于正确的 *site-packages* 文件夹中。
- en: '*Figure 15-8: The project folder showing the main program and the different
    scene files* *Main_SceneDemo.py* is the main program. *Constants.py* contains
    a few'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-8：展示主程序和不同场景文件的项目文件夹* *Main_SceneDemo.py* 是主程序。*Constants.py* 包含一些'
- en: constants shared by the main program and all the scenes. *SceneA.py*, *SceneB.py*,
    and *SceneC.py* are the actual scenes, each containing a related scene class.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 由主程序和所有场景共享的常量。*SceneA.py*、*SceneB.py* 和 *SceneC.py* 是实际的场景，每个场景文件都包含一个相关的场景类。
- en: '*SceneExample.py* is a sample file that shows what a typical scene file might
    Scenes **321**'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '*SceneExample.py* 是一个示例文件，展示了一个典型场景文件的样子。场景 **321**'
- en: look like. It’s not used in this program, but you can refer to it to get an
    understanding of the basics of writing a typical scene.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来会是什么样子。它在本程序中没有使用，但你可以参考它，了解如何编写一个典型场景的基本知识。
- en: Figure 15-9 shows how the objects in the program relate to each other.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-9 展示了程序中各个对象之间的关系。
- en: '**Main**'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '**主**'
- en: '*(Instantiates all scenes*'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '*(实例化所有场景*'
- en: '*and the scene manager)*'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '*以及场景管理器)*'
- en: '*Starts the*'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '*启动*'
- en: '*scene manager*'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '*场景管理器*'
- en: '**Scene manager**'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景管理器**'
- en: '*(Manages navigation and*'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '*(管理导航和*'
- en: '*communication between scenes)*'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '*场景之间的通信)*'
- en: Scene 1
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 场景 1
- en: Scene 2
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 场景 2
- en: Scene 3
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 场景 3
- en: …
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: Scene N
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 场景 N
- en: '*All scenes inherit from the Scene base class*'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有场景都继承自 Scene 基类*'
- en: '*Figure 15-9: The hierarchy of objects in a project*'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 15-9：项目中对象的层次结构*'
- en: Let’s see how the different parts of a program using the scene manager
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用场景管理器的程序不同部分是如何工作的。
- en: work together, starting with the main program.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 共同工作，从主程序开始。
- en: '***The Main Program***'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '***主程序***'
- en: The main program will be unique for every project. Its purpose is to initial-
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序对于每个项目来说都是独一无二的。它的目的是初始化
- en: ize the pygame environment, instantiate all the scenes, create an instance
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化 pygame 环境，实例化所有场景，创建一个实例
- en: of the SceneMgr, then transfer control to the scene manager, oSceneMgr.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SceneMgr 的代码，然后将控制权转移到场景管理器 oSceneMgr。
- en: Listing 15-2 presents the code of the demo main program.
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15-2 展示了演示主程序的代码。
- en: '**File: SceneDemo/Main_SceneDemo.py**'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：SceneDemo/Main_SceneDemo.py**'
- en: Scene Demo main program with three scenes
  id: totrans-839
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: 1 - Import packages
  id: totrans-841
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: 1 import pyghelpers
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: from SceneA import *
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: from SceneB import *
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: from SceneC import *
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: 2 - Define constants
  id: totrans-847
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2 WINDOW_WIDTH = 640
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_HEIGHT = 180
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: '**322** Chapter 15'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  id: totrans-852
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-855
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  id: totrans-856
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instantiate all scenes and store them into a list
  id: totrans-857
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 scenesList = [SceneA(window),
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: SceneB(window),
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: SceneC(window)]
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: Create the scene manager, passing in the scenes list and the FPS
  id: totrans-861
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4 oSceneMgr = pyghelpers.SceneMgr(scenesList, FRAMES_PER_SECOND)
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: Tell the scene manager to start running
  id: totrans-863
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 5 oSceneMgr.run()
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 15-2: A sample main program using the scene manager*'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: The code of the main program is relatively short. We start by import-
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: ing pyghelpers, then all the scenes (in this case, Scene A, Scene B, and
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: Scene C) 1\. We then define a few more constants, initialize pygame, and
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: create the window 2\. Next, we create an instance of each scene and store
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: all the scenes in a list 3\. After this line executes, we have an initialized
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: object for each scene.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: We then instantiate the scene manager object (oSceneMgr) 4 from the
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: 'SceneMgr class. When we create this object, we need to pass in two values:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: • The list of scenes, so the scene manager can be aware of all the scenes.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: The first scene in the list of scenes is used as the starting scene for the
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: program.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: • The frames per second (frame rate) that the program should maintain.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we tell the scene manager to start running by calling its run()
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: method 5\. The scene manager always maintains a single scene as the cur-
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: rent scene—the one that the user sees and interacts with.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: Notice that with this approach, the main program implements the ini-
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: tialization of a typical pygame program but does *not* build the main loop.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the main loop is built into the scene manager itself.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: '***Building the Scenes***'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: To understand the interaction between the scene manager and any indi-
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: vidual scene, I’ll explain how a typical scene is built.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: Each time through its loop, the scene manager calls a predefined set
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: of methods in the current scene that are intended to handle events, do any
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: per-frame actions, and draw anything that needs to be drawn in that scene.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the code of each scene must be split up into these methods. The
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: 'approach makes use of polymorphism: each scene needs to implement a'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: common set of methods.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **323**
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: '**Methods to Implement in Each Scene**'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: Each scene is implemented as a class that inherits from the Scene base
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: class defined in the *pyghelpers.py* file. Therefore, each scene must import
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: pyghelpers. At a minimum, a scene needs to contain an __init__() method
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: and must override the getSceneKey(), handleInputs(), and draw() methods
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: from the base class.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: Every scene must have a unique *scene key*—a string used by the scene
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: manager to identify each scene. I recommend that you build a file with a
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 管理器用来识别每个场景。我建议你创建一个文件，里面包含
- en: 'name like *Constants.py* that contains the keys for all the scenes and import
    this file into each scene file. For example, the *Constants.py* file for the sample
    program contains:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 名称像*Constants.py*这样的文件，包含所有场景的键，并将此文件导入到每个场景文件中。例如，示例程序的*Constants.py*文件包含：
- en: 'Scene keys (any unique values):'
  id: totrans-903
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景键（任何唯一的值）：
- en: SCENE_A = 'scene A'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: SCENE_A = 'scene A'
- en: SCENE_B = 'scene B'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: SCENE_B = 'scene B'
- en: SCENE_C = 'scene C'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: SCENE_C = 'scene C'
- en: During its initialization, the scene manager calls the getSceneKey()
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化过程中，场景管理器调用getSceneKey()
- en: method of each scene, which simply returns its unique scene key. The
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 每个场景的方法，它简单地返回其唯一的场景键。该
- en: scene manager then builds an internal dictionary of scene keys and scene
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 场景管理器会构建一个场景键和场景的内部字典，
- en: objects. When any scene in the program wants to switch to a different
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 对象。当程序中的任何场景想要切换到不同的
- en: scene, it will call self.goToScene() (described in the following section) and
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 场景时，它会调用self.goToScene()（在下面的章节中描述），然后
- en: pass in the scene key of the target scene. The scene manager uses this key
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 传入目标场景的场景键。场景管理器使用这个键
- en: in the dictionary to find the associated scene object; it then sets the new
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 在字典中查找关联的场景对象；然后它设置新的
- en: scene object as the current scene and calls its methods.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 场景对象作为当前场景并调用它的方法。
- en: Each scene must contain its own version of handleInputs() to handle any
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 每个场景必须包含自己版本的handleInputs()来处理任何
- en: events that would typically be handled in the main loop and its own version
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 事件通常会在主循环中处理，并且每个场景有自己的版本。
- en: of draw() to draw anything the scene wants to draw in the window. If your
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: draw()的作用是绘制场景想要在窗口中绘制的任何内容。如果你的
- en: scene does not override these two methods, it will not be able to respond to
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 场景没有覆盖这两个方法，它将无法响应
- en: any events and will not draw anything in the window.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 任何事件，并且不会在窗口中绘制任何内容。
- en: Let’s take a closer look at the four methods you need to implement for
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看你需要为每个场景实现的四个方法。
- en: 'each scene:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 每个场景：
- en: '**def __init__(self, window):**'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '**def __init__(self, window):**'
- en: Each scene should begin with its own __init__() method. The window
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 每个场景应该以其自己的__init__()方法开始。窗口
- en: parameter is the window into which your program draws. You should
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是程序绘制的窗口。你应该
- en: start your method with this statement to save the window parameter for
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此语句开始你的方法，以保存窗口参数供
- en: 'use in the draw() method:'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 用于draw()方法：
- en: self.window = window
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: self.window = window
- en: After that, you can include any other initialization code you want or
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你可以包含任何你想要的其他初始化代码，或者
- en: need, such as code for instantiating buttons and text fields, loading
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 需要的代码，例如实例化按钮和文本字段、加载
- en: images and sounds, and so on.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 图像和声音等等。
- en: '**def getSceneKey(self):**'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: '**def getSceneKey(self):**'
- en: This method must be implemented in every scene that you write. Your
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法必须在你编写的每个场景中实现。你的
- en: method must return the unique scene key associated with this scene.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 方法必须返回与此场景关联的唯一场景键。
- en: '**324** Chapter 15'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '**324** 第15章'
- en: '**def handleInputs(self, events, keyPressedList):**'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: '**def handleInputs(self, events, keyPressedList):**'
- en: This method must be implemented in every scene that you write. It
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法必须在你编写的每个场景中实现。它
- en: should do everything needed to deal with events or keys. The events
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 应该处理所有处理事件或键所需的操作。事件
- en: parameter is a list of events that happened since the last frame, and
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是自上次帧以来发生的事件列表，
- en: keyPressedList is a list of Booleans representing the state of all keyboard
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: keyPressedList是一个布尔值列表，表示键盘上所有键的状态。
- en: keys (True means down). To find whether a particular key is up or down,
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 键（True表示按下）。要找出某个特定键是处于按下还是松开状态，
- en: you should use a constant rather than an integer index. The constants
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用常量，而不是整数索引。常量
- en: representing all keys of the keyboard are available in the pygame docu-
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 代表所有键的键盘在pygame文档中都可以找到。
- en: mentation [( *https://www.pygame.org/docs/ref/key.html*).](https://www.pygame.org/docs/ref/key.html)
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 实现文档[( *https://www.pygame.org/docs/ref/key.html*).](https://www.pygame.org/docs/ref/key.html)
- en: Your implementation of this method should contain a for loop that
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 你对这个方法的实现应该包含一个for循环，该循环
- en: loops through all events in the list that is passed in. If you want, it can
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历传入的事件列表中的所有事件。如果你愿意，它可以
- en: also contain code to implement the continuous mode of handling the
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以包含实现处理事件的连续模式的代码。
- en: keyboard, as described i[n Chapter 5\.](index_split_002.html#p118)
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘，如第5章所述[i](index_split_002.html#p118)
- en: '**def draw(self):**'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: '**def draw(self):**'
- en: This method must be implemented in every scene that you write. It
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法必须在你编写的每个场景中实现。它
- en: should draw everything that needs to be drawn in the current scene.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 应该绘制当前场景中需要绘制的所有内容。
- en: The scene manager also calls the following methods in each scene. In
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 场景管理器还会在每个场景中调用以下方法。在
- en: the Scene base class, these methods each contain a simple pass statement, so
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 场景基类（Scene base class），这些方法每个都包含一个简单的 pass 语句，因此
- en: they don’t do anything. You can override any or all of them to execute any
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 他们什么也不做。您可以重写其中的任何一个或全部，来执行任何
- en: 'code you want for a particular scene:'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要为特定场景定义的代码：
- en: '**def enter(self, data):**'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '**def enter(self, data):**'
- en: This method is called after the scene manager has made the transi-
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法在场景管理器完成过渡后被调用
- en: tion into this scene. There is a single data parameter, with None as a
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 进入此场景的操作。此方法有一个数据参数，默认为 None。
- en: default. If data is not None, then the information it contains was sent
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下。如果数据不为 None，则它包含的信息是由
- en: from the previous scene when it called goToScene() (described in the
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 从前一个场景当它调用 goToScene() 时（在
- en: next section). The value of data can take any form—from a single
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分）。数据的值可以是任何形式——从单一的
- en: string or numeric value to a list or dictionary to an object—as long
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串或数字值到列表或字典，再到对象——只要
- en: as the leaving scene and the entering scene agree on the type of data
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 离开场景和进入场景都同意数据类型
- en: being passed. The enter() method should do whatever it needs to do
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 正在传递的数据。enter() 方法应执行它需要执行的任何操作
- en: when this scene is about to be given control.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 当场景即将交出控制权时。
- en: '**def update(self):**'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: '**def update(self):**'
- en: This method is called in every frame. Here, you can perform any
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法在每一帧中调用。在这里，您可以执行任何
- en: actions you would have done in step 8 of the original 12-step template
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在原始 12 步模板的第 8 步中执行的操作
- en: introduced in [Chapter 5\. F](index_split_002.html#p118)or example, you might
    want this method to move images on the screen, check for collisions, and so on.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 5 章](index_split_002.html#p118)中介绍过。例如，您可能希望这个方法来移动屏幕上的图像，检查碰撞等等。'
- en: '**def leave(self):**'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: '**def leave(self):**'
- en: This method is called by the scene manager whenever the program
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 每当程序
- en: is about to transition to a different scene. It should do any cleanup
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 程序即将切换到不同的场景。它应执行任何清理
- en: that needs to be done before leaving, such as writing information to
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 离开之前需要完成的工作，例如将信息写入
- en: a file.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 一个文件。
- en: Scenes **325**
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 场景 **325**
- en: '**Navigating Between Scenes**'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景之间的导航**'
- en: The scene manager and the Scene base class provide a simple way to navi-
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 场景时，场景管理器和场景基类提供了一种简单的方式来导航
- en: gate between scenes. When the program wants to transition to another
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 场景之间的连接。当程序想要切换到另一个
- en: scene, the current scene should call its own goToScene() method, which is in
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 场景时，当前场景应该调用自己的 goToScene() 方法，这在
- en: 'the inherited Scene base class, like this:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的场景基类，像这样：
- en: self.goToScene(nextSceneKey, data)
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: self.goToScene(nextSceneKey, data)
- en: The goToScene() method communicates to the scene manager that you
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: goToScene() 方法通知场景管理器您
- en: want to transition to a different scene, whose scene key is nextSceneKey. You
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 想要切换到不同场景的程序，其场景键是 nextSceneKey。您
- en: should make all scene keys available via a file such as *Constants.py*. The
    data parameter is any optional information that you want to pass on to the next
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 应该通过一个文件（例如 *Constants.py*）使所有场景键可用。数据参数是您想传递给下一个场景的任何可选信息。
- en: scene. If no data needs to be transferred, you can eliminate this argument.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 场景。如果不需要传输数据，可以省略这个参数。
- en: 'Typical calls would look like this:'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的调用方式如下：
- en: 'self.goToScene( *SOME_SCENE_KEY*) # no data to be passed'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.goToScene( *SOME_SCENE_KEY*) # 无需传递数据'
- en: Or
  id: totrans-987
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 或
- en: 'self.goToScene( *ANOTHER_SCENE_KEY*, data= *someValueOrValues*) # go to a scene
    and pass data The value of data can take any form, as long as the scenes being
    left and'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.goToScene( *ANOTHER_SCENE_KEY*, data= *someValueOrValues*) # 跳转到一个场景并传递数据
    数据的值可以是任何形式，只要离开和进入的场景都能理解该格式。在响应这个调用时，在离开'
- en: entered both understand the format. In response to this call, before leav-
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 当前场景之前，场景管理器会调用该场景的 leave() 方法。
- en: ing the current scene, the scene manager calls that scene’s leave() method.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 离开当前场景时，场景管理器会调用该场景的 leave() 方法。
- en: When the next scene is about to be activated, the scene manager calls that
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 当下一个场景即将激活时，场景管理器会调用该
- en: scene’s enter() method and passes the value of data to the new scene.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 场景的 enter() 方法并将数据值传递给新场景。
- en: '**Quitting the Program**'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: '**退出程序**'
- en: The scene manager takes care of three different ways that the user can quit
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 场景管理器负责处理用户退出程序的三种不同方式
- en: 'the currently running program:'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 当前正在运行的程序：
- en: • By clicking the close button at the top of the window.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: • 通过点击窗口顶部的关闭按钮。
- en: • By pressing the ESCAPE key.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: • 通过按下 ESCAPE 键。
- en: • Through any additional mechanism such as a Quit button. In this case,
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: • 通过任何附加机制，例如退出按钮。在这种情况下，
- en: 'make the following call (which is also built into the Scene base class):'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 调用以下方法（该方法也内置于场景基类中）：
- en: 'self.quit() # quits the program'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.quit()  # 退出程序'
- en: '***A Typical Scene***'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: '***一个典型场景***'
- en: Listing 15-3 shows an example of a typical scene—this is the *SceneA.py* file
    that implements Scene A in the demo program, shown in Figure 15-5\. Remember
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15-3 显示了典型场景的示例——这是 *SceneA.py* 文件，展示了演示程序中实现场景 A，如图 15-5 所示。记住
- en: that the main loop is implemented by the scene manager. Inside its main loop,
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，主循环由场景管理器实现。在其主循环中，
- en: the scene manager calls the handleInputs(), update(), and draw() methods for
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 场景管理器调用 handleInputs()、update() 和 draw() 方法以
- en: the current scene.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 当前场景。
- en: '**326** Chapter 15'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: '**326** 第15章'
- en: '**File: SceneDemo/SceneA.py**'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：SceneDemo/SceneA.py**'
- en: Scene A
  id: totrans-1008
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景 A
- en: import pygwidgets
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: import pygwidgets
- en: import pyghelpers
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: import pyghelpers
- en: import pygame
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from pygame.locals import *
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: from pygame.locals import *
- en: from Constants import *
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: from Constants import *
- en: 'class SceneA(pyghelpers.Scene):'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 'class SceneA(pyghelpers.Scene):'
- en: '1 def __init__(self, window):'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '1 def __init__(self, window):'
- en: self.window = window
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: self.window = window
- en: self.messageField = pygwidgets.DisplayText(self.window,
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: self.messageField = pygwidgets.DisplayText(self.window,
- en: (15, 25), 'This is Scene A', fontSize=50,
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: (15, 25)，'这是场景 A'，字体大小=50，
- en: textColor=WHITE, width=610, justified='center')
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: textColor=WHITE, width=610, justified='center')
- en: self.gotoAButton = pygwidgets.TextButton(self.window,
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: self.gotoAButton = pygwidgets.TextButton(self.window,
- en: (250, 100), 'Go to Scene A')
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: (250, 100)，'转到场景 A')
- en: self.gotoBButton = pygwidgets.TextButton(self.window,
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: self.gotoBButton = pygwidgets.TextButton(self.window,
- en: (250, 100), 'Go to Scene B')
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: (250, 100)，'转到场景 B')
- en: self.gotoCButton = pygwidgets.TextButton(self.window,
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: self.gotoCButton = pygwidgets.TextButton(self.window,
- en: (400, 100), 'Go to Scene C')
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: (400, 100)，'转到场景 C')
- en: self.gotoAButton.disable()
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: self.gotoAButton.disable()
- en: '2 def getSceneKey(self):'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: '2 def getSceneKey(self):'
- en: return SCENE_A
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 SCENE_A
- en: '3 def handleInputs(self, eventsList, keyPressedList):'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: '3 def handleInputs(self, eventsList, keyPressedList):'
- en: 'for event in eventsList:'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 对于事件列表中的每个事件：
- en: 'if self.gotoBButton.handleEvent(event):'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 self.gotoBButton.handleEvent(event):'
- en: 4 self.goToScene(SCENE_B)
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 4 self.goToScene(SCENE_B)
- en: 'if self.gotoCButton.handleEvent(event):'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 self.gotoCButton.handleEvent(event):'
- en: 5 self.goToScene(SCENE_C)
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 5 self.goToScene(SCENE_C)
- en: '--- snip (testing code to send messages) ---'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: '--- snip（测试代码以发送消息） ---'
- en: '6 def draw(self):'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: '6 def draw(self):'
- en: self.window.fill(GRAYA)
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: self.window.fill(GRAYA)
- en: self.messageField.draw()
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: self.messageField.draw()
- en: self.gotoAButton.draw()
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: self.gotoAButton.draw()
- en: self.gotoBButton.draw()
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: self.gotoBButton.draw()
- en: self.gotoCButton.draw()
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: self.gotoCButton.draw()
- en: '--- snip (testing code to respond to messages) ---'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: '--- snip（测试代码以响应消息） ---'
- en: '*Listing 15-3: A typical scene (Scene A in the Scene Demo program)*'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-3：一个典型的场景（场景 A，在 Scene Demo 程序中）*'
- en: Scenes **327**
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 场景 **327**
- en: In the __init__() method 1, we save away the window parameter in an instance
    variable. We then create an instance of a DisplayText field to show a
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 在 __init__() 方法 1 中，我们将 window 参数保存在实例变量中。然后我们创建一个 DisplayText 字段的实例，用来显示
- en: title and create some TextButtons to allow for navigation to the other scenes.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 标题并创建一些 TextButton 按钮，以便导航到其他场景。
- en: The getSceneKey() method 2 just returns the unique scene key (found
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: getSceneKey() 方法 2 只是返回唯一的场景键（在
- en: in *Constants.py*) for this scene. In the handleInputs() method 3, if the user
    has clicked the button for a different scene, we call the self.goToScene()
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Constants.py* 中（适用于此场景）。在 handleInputs() 方法 3 中，如果用户点击了不同场景的按钮，我们调用 self.goToScene()
- en: navigation method 4 5 to transfer control to the new scene. In the draw()
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 导航方法 4 5 将控制转移到新场景。在 draw() 方法中
- en: method 6, we fill the background, draw the message field, and draw the
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法 6 中，我们填充背景，绘制消息区域，并绘制
- en: buttons. This example scene does very little, so we don’t need to write our
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮。这个示例场景做的很少，因此我们不需要编写自己的
- en: own enter(), update(), and leave() methods. Calls to these methods will be
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 具有自己的 enter()、update() 和 leave() 方法。对这些方法的调用将
- en: handled by methods of the same names in the Scene base class, and those
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 由场景基类中的同名方法处理，这些方法
- en: methods don’t do anything—they simply execute a pass statement.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 方法什么都不做——它们只是执行一个 pass 语句。
- en: The two other scene files are *SceneB.py* and *SceneC.py*. The only differences
    are the titles shown, the buttons drawn, and the effects of clicking the
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个场景文件是 *SceneB.py* 和 *SceneC.py*。唯一的不同是显示的标题、绘制的按钮，以及点击按钮时的效果
- en: buttons to transfer to the appropriate new scene.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮用于转移到适当的新场景。
- en: '**Rock, Paper, Scissors Using Scenes**'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用场景的石头、剪刀、布**'
- en: Let’s build an alternate implementation of the Rock, Paper, Scissors game
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个交替实现的石头、剪刀、布游戏
- en: using the scene manager. To the user, the game will work exactly the same
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 使用场景管理器。对用户来说，游戏将完全一样
- en: way as the earlier state machine version. We’ll build a Splash scene, a Play
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 与早期的状态机版本以相同的方式工作。我们将构建一个 Splash 场景、一个游戏
- en: scene, and a Results scene.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 场景，以及一个结果场景。
- en: All of the source code is available, so I won’t go through every Python
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 所有源代码都可以获得，因此我不会逐行讲解每个 Python
- en: file. The Splash scene is just a background picture with a Start button. When
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 文件。Splash 场景只是一个背景图像和一个开始按钮。当
- en: the user presses the Start button, the code executes goToScene(SCENE_PLAY) to
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户按下开始按钮时，代码执行 goToScene(SCENE_PLAY) 切换到
- en: transfer to the Play scene. In the Play scene, the user is presented with a
    set
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到游戏场景。在游戏场景中，用户会看到一组
- en: of images (rock, paper, and scissors) and asked to choose one. Clicking an
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 图像（石头、纸和剪刀），并要求选择其中一个。点击一个
- en: image transfers control to the Results scene. Listing 15-4 contains the code
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 图像将控制权转移到结果场景。清单 15-4 包含了代码
- en: of the Play scene.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: “游戏”场景的代码。
- en: '**File: RockPaperScissorsWithScenes/ScenePlay.py**'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：RockPaperScissorsWithScenes/ScenePlay.py**'
- en: The Play scene
  id: totrans-1070
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏场景
- en: The player chooses among rock, paper, or scissors
  id: totrans-1071
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家从石头、纸或剪刀中选择
- en: import pygwidgets
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: import pygwidgets
- en: import pyghelpers
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: import pyghelpers
- en: import pygame
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from Constants import *
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: from Constants import *
- en: import random
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: 'class ScenePlay(pyghelpers.Scene):'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 'class ScenePlay(pyghelpers.Scene):'
- en: 'def __init__(self, window):'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, window):'
- en: self.window = window
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: self.window = window
- en: self.RPSTuple = (ROCK, PAPER, SCISSORS)
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: self.RPSTuple = (ROCK, PAPER, SCISSORS)
- en: '**328** Chapter 15'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: '**328** 第 15 章'
- en: '--- snip ---'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: '--- snip ---'
- en: 'def getSceneKey(self): 1'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getSceneKey(self): 1'
- en: return SCENE_PLAY
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: return SCENE_PLAY
- en: 'def handleInputs(self, eventsList, keyPressedList): 2'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 'def handleInputs(self, eventsList, keyPressedList): 2'
- en: playerChoice = None
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: playerChoice = None
- en: 'for event in eventsList:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in eventsList:'
- en: 'if self.rockButton.handleEvent(event):'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 'if self.rockButton.handleEvent(event):'
- en: playerChoice = ROCK
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: playerChoice = ROCK
- en: 'if self.paperButton.handleEvent(event):'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 'if self.paperButton.handleEvent(event):'
- en: playerChoice = PAPER
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: playerChoice = PAPER
- en: 'if self.scissorButton.handleEvent(event):'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 'if self.scissorButton.handleEvent(event):'
- en: playerChoice = SCISSORS
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: playerChoice = SCISSORS
- en: 'if playerChoice is not None: 3 # user has made a choice'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 'if playerChoice is not None: 3 # 用户已经做出了选择'
- en: 'computerChoice = random.choice(self.RPSTuple) # computer chooses'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 'computerChoice = random.choice(self.RPSTuple) # 计算机选择'
- en: 'dataDict = {''player'': playerChoice, ''computer'': computerChoice} 4'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 'dataDict = {''player'': playerChoice, ''computer'': computerChoice} 4'
- en: 'self.goToScene(SCENE_RESULTS, dataDict) 5 # go to Results scene'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.goToScene(SCENE_RESULTS, dataDict) 5 # 切换到结果场景'
- en: No need to include update method, defaults to inherited one which does nothing
  id: totrans-1098
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无需包含 update 方法，默认为继承的方法，它什么都不做
- en: 'def draw(self):'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 'def draw(self):'
- en: self.window.fill(GRAY)
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: self.window.fill(GRAY)
- en: self.titleField.draw()
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: self.titleField.draw()
- en: self.rockButton.draw()
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: self.rockButton.draw()
- en: self.paperButton.draw()
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: self.paperButton.draw()
- en: self.scissorButton.draw()
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: self.scissorButton.draw()
- en: self.messageField.draw()
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: self.messageField.draw()
- en: '*Listing 15-4: The Play scene in Rock, Paper, Scissors*'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15-4：石头、剪子、布游戏的“游戏”场景*'
- en: I’ve snipped the code to create text fields and the rock, paper, and scis-
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经略去了创建文本字段以及石头、纸和剪刀的代码
- en: sors buttons. The getSceneKey() method 1 simply returns the scene key for
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: sors 按钮。getSceneKey() 方法 1 仅返回场景的键
- en: this scene.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景。
- en: The most important method is handleInputs() 2, which is called in every
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的方法是 handleInputs() 2，它在每个
- en: frame. If any button is clicked, we set a variable named playerChoice to an
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 框架。如果任何按钮被点击，我们将设置一个名为 playerChoice 的变量
- en: appropriate constant 3, and we make a random choice for the computer.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 适当的常量 3，然后我们为计算机做一个随机选择。
- en: We then take the player’s choice and the computer’s choice and build a
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们获取玩家的选择和计算机的选择并构建一个
- en: simple dictionary 4 incorporating both, so we can pass this information
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的字典 4 包含了两者信息，以便我们可以传递这些信息
- en: as data to the Results scene. Finally, to transfer to the Results scene, we
    call
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 作为数据传递到结果场景。最后，为了切换到结果场景，我们调用
- en: goToScene() and pass the dictionary 5\.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: goToScene() 并传递字典 5\。
- en: The scene manager receives this call, calls leave() for the current scene
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 场景管理器接收到此调用后，会调用当前场景的 leave()
- en: (Play), changes the current scene to the new scene (Results), and calls enter()
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: (游戏)，将当前场景更改为新场景（结果），并调用 enter()
- en: for the new scene (Results). It passes the data from the leaving scene into
    the
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 用于新场景（结果场景）。它将离开场景的数据传递到
- en: enter() method of the new scene.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 新场景（结果场景）的 enter() 方法。
- en: Listing 15-5 contains the code of the Results scene. There’s a lot of code
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 15-5 包含了结果场景的代码。这里有很多代码
- en: here, but most of it deals with showing the appropriate icons and the evalu-
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代码大部分涉及显示适当的图标和评估结果。
- en: ation of the results of the round.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 回合结果的操作。
- en: Scenes **329**
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 场景 **329**
- en: '**File: RockPaperScissorsWithScenes/SceneResults.py**'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：RockPaperScissorsWithScenes/SceneResults.py**'
- en: The Results scene
  id: totrans-1126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结果场景
- en: The player is shown the results of the current round
  id: totrans-1127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家看到当前回合的结果
- en: import pygwidgets
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: import pygwidgets
- en: import pyghelpers
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: import pyghelpers
- en: import pygame
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from Constants import *
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: from Constants import *
- en: 'class SceneResults(pyghelpers.Scene):'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 'class SceneResults(pyghelpers.Scene):'
- en: 'def __init__(self, window, sceneKey):'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, window, sceneKey):'
- en: self.window = window
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: self.window = window
- en: self.playerScore = 0
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: self.playerScore = 0
- en: self.computerScore = 0
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: self.computerScore = 0
- en: 1 self.rpsCollectionPlayer = pygwidgets.ImageCollection(
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 1 self.rpsCollectionPlayer = pygwidgets.ImageCollection(
- en: window, (50, 62),
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: window, (50, 62),
- en: '{ROCK: ''images/Rock.png'','
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: '{ROCK: ''images/Rock.png'','
- en: 'PAPER: ''images/Paper.png'','
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 'PAPER: ''images/Paper.png'','
- en: 'SCISSORS: ''images/Scissors.png''}, '''')'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 'SCISSORS: ''images/Scissors.png''}, '''')'
- en: self.rpsCollectionComputer = pygwidgets.ImageCollection(
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: self.rpsCollectionComputer = pygwidgets.ImageCollection(
- en: window, (350, 62),
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: window, (350, 62),
- en: '{ROCK: ''images/Rock.png'','
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: '{ROCK: ''images/Rock.png'','
- en: 'PAPER: ''images/Paper.png'','
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: 'PAPER: ''images/Paper.png'','
- en: 'SCISSORS: ''images/Scissors.png''}, '''')'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 'SCISSORS: ''images/Scissors.png''}, '''')'
- en: self.youComputerField = pygwidgets.DisplayText(
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: self.youComputerField = pygwidgets.DisplayText(
- en: window, (22, 25),
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: window, (22, 25),
- en: '''You Computer'','
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: '''你 计算机'','
- en: fontSize=50, textColor=WHITE,
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: fontSize=50, textColor=WHITE,
- en: width=610, justified='center')
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: width=610, justified='center')
- en: self.resultsField = pygwidgets.DisplayText(
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: self.resultsField = pygwidgets.DisplayText(
- en: self.window, (20, 275), '',
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: self.window, (20, 275), '',
- en: fontSize=50, textColor=WHITE,
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: fontSize=50, textColor=WHITE,
- en: width=610, justified='center')
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: width=610, justified='center')
- en: self.restartButton = pygwidgets.CustomButton(
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: self.restartButton = pygwidgets.CustomButton(
- en: self.window, (220, 310),
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: self.window, (220, 310),
- en: up='images/restartButtonUp.png',
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: up='images/restartButtonUp.png',
- en: down='images/restartButtonDown.png'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: down='images/restartButtonDown.png'
- en: over='images/restartButtonHighlight.png')
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: over='images/restartButtonHighlight.png')
- en: self.playerScoreCounter = pygwidgets.DisplayText(
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: self.playerScoreCounter = pygwidgets.DisplayText(
- en: self.window, (86, 315), 'Score:',
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: self.window, (86, 315), '得分:',
- en: fontSize=50, textColor=WHITE)
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: fontSize=50, textColor=WHITE)
- en: self.computerScoreCounter = pygwidgets.DisplayText(
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: self.computerScoreCounter = pygwidgets.DisplayText(
- en: self.window, (384, 315), 'Score:',
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: self.window, (384, 315), '得分:',
- en: fontSize=50, textColor=WHITE)
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: fontSize=50, textColor=WHITE)
- en: '**330** Chapter 15'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: '**330** 第15章'
- en: Sounds
  id: totrans-1168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声音
- en: self.winnerSound = pygame.mixer.Sound("sounds/ding.wav")
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: self.winnerSound = pygame.mixer.Sound("sounds/ding.wav")
- en: self.tieSound = pygame.mixer.Sound("sounds/push.wav")
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: self.tieSound = pygame.mixer.Sound("sounds/push.wav")
- en: self.loserSound = pygame.mixer.Sound("sounds/buzz.wav")
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: self.loserSound = pygame.mixer.Sound("sounds/buzz.wav")
- en: '2 def enter(self, data):'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: '2 def enter(self, data):'
- en: 'data is a dictionary (comes from the Play scene) that looks like:'
  id: totrans-1173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: data 是一个字典（来自 Play 场景），其格式如下：
- en: '{''player'': playerChoice, ''computer'': computerChoice}'
  id: totrans-1174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '{''player'': playerChoice, ''computer'': computerChoice}'
- en: playerChoice = data['player']
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: playerChoice = data['player']
- en: computerChoice = data['computer']
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: computerChoice = data['computer']
- en: Set the player and computer images
  id: totrans-1177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置玩家和计算机的图片
- en: 3 self.rpsCollectionPlayer.replace(playerChoice)
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 3 self.rpsCollectionPlayer.replace(playerChoice)
- en: self.rpsCollectionComputer.replace(computerChoice)
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: self.rpsCollectionComputer.replace(computerChoice)
- en: Evaluate the game's win/lose/tie conditions
  id: totrans-1180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估游戏的胜/负/平局条件
- en: '4 if playerChoice == computerChoice:'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: '4 如果 playerChoice == computerChoice:'
- en: self.resultsField.setValue("It's a tie!")
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: self.resultsField.setValue("平局！")
- en: self.tieSound.play()
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: self.tieSound.play()
- en: 'elif playerChoice == ROCK and computerChoice == SCISSORS:'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif playerChoice == ROCK and computerChoice == SCISSORS:'
- en: self.resultsField.setValue("Rock breaks Scissors. You win!")
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: self.resultsField.setValue("石头打破剪刀。你赢了！")
- en: self.playerScore = self.playerScore + 1
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: self.playerScore = self.playerScore + 1
- en: self.winnerSound.play()
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: self.winnerSound.play()
- en: '--- snip ---'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '--- snip ---'
- en: Show the player's and computer's scores
  id: totrans-1189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示玩家和计算机的得分
- en: self.playerScoreCounter.setValue(
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: self.playerScoreCounter.setValue(
- en: '''Score: '' + str(self.playerScore))'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: '''得分: '' + str(self.playerScore))'
- en: self.computerScoreCounter.setValue(
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: self.computerScoreCounter.setValue(
- en: '''Score: '' + str(self.computerScore))'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: '''得分: '' + str(self.computerScore))'
- en: '5 def handleInputs(self, eventsList, keyPressedList):'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: '5 def handleInputs(self, eventsList, keyPressedList):'
- en: 'for event in eventsList:'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in eventsList:'
- en: 'if self.restartButton.handleEvent(event):'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 self.restartButton.handleEvent(event):'
- en: self.goToScene(SCENE_PLAY)
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: self.goToScene(SCENE_PLAY)
- en: No need to include update method,
  id: totrans-1198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无需包含更新方法，
- en: defaults to inherited one which does nothing
  id: totrans-1199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认为继承的方法，不做任何操作
- en: '6 def draw(self):'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: '6 def draw(self):'
- en: self.window.fill(OTHER_GRAY)
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: self.window.fill(OTHER_GRAY)
- en: self.youComputerField.draw()
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: self.youComputerField.draw()
- en: self.resultsField.draw()
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: self.resultsField.draw()
- en: self.rpsCollectionPlayer.draw()
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: self.rpsCollectionPlayer.draw()
- en: self.rpsCollectionComputer.draw()
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: self.rpsCollectionComputer.draw()
- en: self.playerScoreCounter.draw()
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: self.playerScoreCounter.draw()
- en: self.computerScoreCounter.draw()
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: self.computerScoreCounter.draw()
- en: self.restartButton.draw()
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: self.restartButton.draw()
- en: '*Listing 15-5: The Results scene in Rock, Paper, Scissors*'
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 15-5: 石头、剪刀、布游戏的结果场景*'
- en: Scenes **331**
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 场景 **331**
- en: Here, I’ve snipped some of the game evaluation logic. The enter()
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我截取了部分游戏评估逻辑。enter()
- en: method 2 is the most important method in this class. When the player
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 2 是此类中最重要的方法。当玩家
- en: makes a choice in the previous Play scene, the program transitions to this
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个游戏场景做出选择后，程序会切换到这个场景
- en: Results scene. First, we extract the player’s and computer’s choices that were
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 结果场景。首先，我们提取玩家和计算机的选择，这些选择
- en: 'passed in from the Play scene as a dictionary, which looks like this:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 作为字典从游戏场景传入的数据，格式如下：
- en: '{''player'': playerChoice, ''computer'': computerChoice}'
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: '{''player'': playerChoice, ''computer'': computerChoice}'
- en: In the __init__() method 1, we create ImageCollection objects for the
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 __init__() 方法 1 中，我们为
- en: player and computer, each containing the rock, paper, and scissors images.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家和计算机，各自包含岩石、纸张和剪刀的图像。
- en: In the enter() method 2, we use the replace() method of ImageCollection 3
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 enter() 方法 2 中，我们使用 ImageCollection 3 的 replace() 方法
- en: to show the images that represent the player’s and the computer’s choices.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 显示玩家和计算机选择的图像。
- en: Then, the evaluation is quite simple 4\. If the computer and the player
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，评估过程非常简单 4。如果计算机和玩家
- en: made the same choice, we have a tie, and we play an appropriate tie sound.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果双方做出了相同的选择，我们平局，并播放相应的平局声音。
- en: If the player wins, we increment the player’s score and play a happy sound.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家获胜，我们增加玩家的分数并播放一段快乐的声音。
- en: If the computer wins, we increment the computer’s score and play a sad
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计算机获胜，我们增加计算机的分数并播放一段悲伤的
- en: sound. We update the player’s or the computer’s score and show the scores
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 声音。我们更新玩家或计算机的分数，并显示分数
- en: in the matching text display fields.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 在匹配的文本显示区域中。
- en: After the enter() method runs (one time for each round), the
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 enter() 方法执行后（每回合执行一次），
- en: handleInputs() method 5 is called in every frame by the scene manager.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: handleInputs() 方法 5 会在每一帧由场景管理器调用。
- en: When the user clicks Restart, we call the inherited goToScene() method
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击重启时，我们会调用继承的 goToScene() 方法
- en: to transfer back to the Play scene.
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 用于返回到游戏场景。
- en: The draw() method 6 draws everything in the window for this scene.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: draw() 方法 6 会绘制当前场景中的所有内容。
- en: In this scene, we don’t do any additional work in each frame, so we don’t
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们每帧没有做任何额外的工作，所以我们不
- en: need to write an update() method. When the scene manager calls update(),
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 需要编写一个 update() 方法。当场景管理器调用 update() 时，
- en: the inherited method in the Scene base class runs and just executes a pass
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 场景基类中的继承方法会运行，并执行一个 pass
- en: statement.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 语句。
- en: '**Communication Between Scenes**'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景间通信**'
- en: The scene manager provides a set of methods that allow scenes to com-
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 场景管理器提供了一组方法，允许场景之间进行通信：
- en: municate with each other by sending or requesting information. This com-
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 场景之间通过发送或请求信息来进行通信。这种通信
- en: munication won’t be needed by all programs but can be highly useful. The
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通信并不是所有程序都需要的，但它非常有用。该
- en: 'scene manager allows any scene to:'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 场景管理器允许任何场景：
- en: • Request information from another scene
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: • 从其他场景请求信息
- en: • Send information to another scene
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: • 向另一个场景发送信息
- en: • Send information to all other scenes
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: • 向所有其他场景发送信息
- en: In the following sections, I’ll call the scene the user is seeing the *cur-*
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我将把用户当前看到的场景称为 *cur-*
- en: '*rent* scene. The scene that the current scene is sending information to or'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: '*current* 场景。当前场景向其发送信息的目标场景或'
- en: requesting information from is the *target* scene. The methods used to trans-
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 请求信息的场景是 *目标* 场景。用于传输的方式
- en: fer information are all implemented in the Scene base class. Therefore, all
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 传递信息的操作都在 Scene 基类中实现。因此，所有
- en: scenes (which must inherit from the Scene base class) have access to these
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 场景（必须继承自 Scene 基类）可以访问这些
- en: methods using self. *<method>* ().
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 方法使用 self.*<method>* ()。
- en: '**332** Chapter 15'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: '**332** 第15章'
- en: '***Requesting Information from a Target Scene***'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: '***从目标场景请求信息***'
- en: To request information from any other scene, a scene makes a call to the
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 要从任何其他场景请求信息，一个场景会调用
- en: 'inherited request() method, like this:'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的 request() 方法，像这样：
- en: self.request(targetSceneKey, requestID)
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: self.request(targetSceneKey, requestID)
- en: This call allows the current scene to ask for information from a target
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用允许当前场景从目标场景请求信息
- en: scene, identified by its scene key (targetSceneKey). The requestID uniquely
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 场景，通过其场景键（targetSceneKey）标识。requestID 唯一
- en: identifies the information you are asking for. The value used for a requestID
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 确定了你请求的信息。用于请求的 requestID 的值
- en: would normally be a constant defined in a file like *Constants.py*. The call
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会在像 *Constants.py* 这样的文件中定义为常量。调用
- en: 'returns the requested information. A typical call would look like this:'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 返回请求的信息。一个典型的调用看起来像这样：
- en: someData = self.request( *SOME_SCENE_KEY*, *SOME_INFO_CONSTANT*)
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: someData = self.request( *SOME_SCENE_KEY*, *SOME_INFO_CONSTANT*)
- en: This effectively says, “Issue a request to the *SOME_SCENE_KEY* scene asking
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上表示，“向*SOME_SCENE_KEY*场景发出请求，要求
- en: for information identified by *SOME_INFO_CONSTANT*.” The data is returned and
    assigned to the someData variable.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 以*SOME_INFO_CONSTANT*标识的信息。”返回的数据并分配给someData变量。
- en: 'The scene manager acts as an intermediary: it receives the call to'
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 场景管理器充当中介：它接收到调用并将其转换为
- en: request() and turns it into a call to respond() in the target scene. To make
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: request()方法并将其转换为对目标场景中respond()的调用。为了使
- en: a target scene able to give information, you must implement a respond()
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标场景能够提供信息，则必须实现一个respond()方法。
- en: 'method in that scene’s class. The method should start like this:'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 该场景类中的方法应像这样开始：
- en: 'def respond(self, requestID):'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 'def respond(self, requestID):'
- en: The typical code of a respond() method checks the value of the requestID
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: respond()方法的典型代码检查requestID的值。
- en: parameter and returns the appropriate data. The data returned can be for-
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 参数并返回适当的数据。返回的数据可以是格式化的。
- en: matted in any way that the current scene and the target scene agree on.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 以当前场景和目标场景一致的任何格式进行格式化。
- en: '***Sending Information to a Target Scene***'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: '***将信息发送到目标场景***'
- en: To send information to a target scene, the current scene makes a call to the
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 要将信息发送到目标场景，当前场景需要调用
- en: 'inherited send() method, like this:'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的send()方法，如下所示：
- en: self.send(targetSceneKey, sendID, info)
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: self.send(targetSceneKey, sendID, info)
- en: This call allows the current scene to send information to a target scene,
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 此调用允许当前场景将信息发送到目标场景，
- en: identified by its scene key (targetSceneKey). The sendID uniquely identifies
    the
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 通过其场景键(targetSceneKey)标识。sendID唯一标识
- en: information you are sending. The info parameter is the information you
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在发送的信息。info参数是你
- en: want to send to the target scene.
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 想要发送到目标场景的信息。
- en: 'A typical call would look like this:'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的调用看起来像这样：
- en: self.send( *SOME_SCENE_KEY*, *SOME_INFO_CONSTANT*, data)
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: self.send( *SOME_SCENE_KEY*, *SOME_INFO_CONSTANT*, data)
- en: This effectively says, “Send information to the *SOME_SCENE_KEY* scene. The
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上表示，“将信息发送到*SOME_SCENE_KEY*场景。该信息
- en: information is identified by *SOME_INFO_CONSTANT*, and the information is in
    the value of the variable data.”
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 信息由*SOME_INFO_CONSTANT*标识，信息存储在变量data的值中。”
- en: The scene manager receives the call to send() and turns it into a call
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 场景管理器接收到send()调用并将其转换为调用
- en: to receive() in the target scene. To allow a scene to send information to
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 收到的信息。为了允许场景将信息发送到
- en: Scenes **333**
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 场景 **333**
- en: 'another scene, you must implement a receive() method in your target scene class,
    like this:'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是另一个场景，你必须在目标场景类中实现一个receive()方法，如下所示：
- en: 'def receive(self, receiveID, info):'
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 'def receive(self, receiveID, info):'
- en: The receive() method can contain an if/elif/else construct if it needs
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，receive()方法可以包含if/elif/else结构。
- en: to handle different values for receiveID. The transmitted information can be
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 以处理receiveID的不同值。传输的信息可以是
- en: formatted in any way that the current scene and the target scene agree on.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 信息可以以当前场景和目标场景一致的任何格式进行格式化。
- en: '***Sending Information to All Scenes***'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: '***将信息发送到所有场景***'
- en: As an additional convenience, a scene can send information to all other
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的便利，场景可以将信息发送到所有其他场景。
- en: 'scenes using the single method sendAll():'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单一方法sendAll()发送信息到所有场景：
- en: self.sendAll(sendID, info)
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: self.sendAll(sendID, info)
- en: This call allows the current scene to send information to all the other
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 此调用允许当前场景将信息发送到所有其他场景。
- en: scenes. The sendID uniquely identifies the information you are sending. The
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 场景。sendID唯一标识你正在发送的信息。该
- en: info parameter is the information you want to send to all scenes.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: info参数是你想发送到所有场景的信息。
- en: 'A typical call would look like this:'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的调用看起来像这样：
- en: self.sendAll( *SOME_INFO_CONSTANT*, data)
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: self.sendAll( *SOME_INFO_CONSTANT*, data)
- en: This effectively says, “Send information to all scenes. The information
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上表示，“将信息发送到所有场景。信息
- en: is identified by *SOME_INFO_CONSTANT*, and the information is in the value of
    the variable data.”
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 由*SOME_INFO_CONSTANT*标识，信息存储在变量data的值中。”
- en: For this to work, all scenes other than the current scene must implement
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，所有除当前场景外的场景必须实现
- en: the receive() method, as described in the previous section. The scene manager
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所述，receive()方法。场景管理器
- en: sends the message to all scenes (other than the current scene). The current
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 将消息发送到所有场景（除了当前场景）。当前
- en: scene may contain a receive() method for information sent by other scenes.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 场景可能包含一个 receive() 方法，用于接收其他场景发送的信息。
- en: '***Testing Communications Among Scenes***'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: '***测试场景间的通信***'
- en: The Scene Demo program (with Scene A, Scene B, and Scene C), discussed
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 场景演示程序（包含场景 A、场景 B 和场景 C）中讨论了
- en: earlier with Listings 15-2 and 15-3, contains code in each scene that demon-
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 如之前在清单 15-2 和 15-3 中所展示的，每个场景中都包含演示
- en: strates calls to send(), request(), and sendAll(). In addition, the scenes each
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: send()、request() 和 sendAll() 方法调用的代码。此外，场景每个
- en: implement simple versions of the receive() and respond() methods. In the demo
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 receive() 和 respond() 方法的简单版本。在演示中
- en: program, you can send a message to another scene by pressing A, B, or C.
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，你可以通过按下 A、B 或 C 向其他场景发送信息。
- en: Pressing X sends a message to all scenes. Pressing 1, 2, or 3 sends a request
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 X 会向所有场景发送一条信息。按下 1、2 或 3 会发送一个请求
- en: to get data from a target scene. The target scene responds with a string.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 从目标场景获取数据。目标场景用字符串作回应。
- en: '**Implementation of the Scene Manager**'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景管理器的实现**'
- en: Here we’ll look at how the scene manager is implemented. However, one
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们将看看场景管理器是如何实现的。然而，有一点
- en: important lesson of OOP is that the developer of client code doesn’t need to
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: OOP 的一个重要教训是，客户端代码的开发者不需要了解
- en: understand the implementation of a class, only the interface. With respect to
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 了解一个类的实现，仅仅是接口。至于
- en: the scene manager, you don’t need to know how it works, only what methods
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 对于场景管理器，你不需要知道它是如何工作的，只需要知道它有哪些方法
- en: you must implement in your scenes, when they are called, and what methods
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须在场景中实现的内容，当它们被调用时，以及它们有哪些方法
- en: you can call. Therefore, if you’re not interested in the internals, you can
    go
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以调用的。因此，如果你对内部实现不感兴趣，可以直接跳
- en: right to the Summary. If you are interested, this section goes through the
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 直接跳到总结部分。如果你感兴趣，本节将详细讲解
- en: '**334** Chapter 15'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: '**334** 第15章'
- en: implementation details, and along the way you’ll learn an interesting technique
    to allow for two-way communication between objects.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 实现细节，顺便你会学到一种有趣的技术，可以实现对象之间的双向通信。
- en: The scene manager is implemented in a class named SceneMgr in the
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 场景管理器在名为 SceneMgr 的类中实现
- en: pyghelpers module. As explained previously, in your main program, you cre-
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: pyghelpers 模块。如前所述，在你的主程序中，你创建—
- en: 'ate a single instance of the scene manager like this:'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 创建场景管理器的单一实例，像这样：
- en: oSceneMgr = SceneMgr(scenesList, FRAMES_PER_SECOND)
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: oSceneMgr = SceneMgr(scenesList, FRAMES_PER_SECOND)
- en: 'The last line of your main program needs to be:'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 你的主程序的最后一行需要是：
- en: oSceneMgr.run()
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: oSceneMgr.run()
- en: Listing 15-6 contains the code of the __init__() method of the SceneMgr
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 清单15-6包含SceneMgr类的__init__()方法的代码
- en: class.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 类。
- en: '--- snip ---'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 截取 ---'
- en: 'def __init__(self, scenesList, fps):'
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, scenesList, fps):'
- en: 'Build a dictionary, each entry of which is a sceneKey : scene object'
  id: totrans-1334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '构建一个字典，每个条目是 sceneKey : 场景对象'
- en: 1 self.scenesDict = {}
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 1 self.scenesDict = {}
- en: '2 for oScene in scenesList:'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 2 对于 oScene 在 scenesList 中：
- en: key = oScene.getSceneKey()
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: key = oScene.getSceneKey()
- en: self.scenesDict[key] = oScene
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: self.scenesDict[key] = oScene
- en: The first element in the list is used as the starting scene
  id: totrans-1339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表中的第一个元素被用作起始场景
- en: 3 self.oCurrentScene = scenesList[0]
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 3 self.oCurrentScene = scenesList[0]
- en: self.framesPerSecond = fps
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: self.framesPerSecond = fps
- en: Give each scene a reference back to the SceneMgr.
  id: totrans-1342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给每个场景一个返回 SceneMgr 的引用。
- en: This allows any scene to do a goToScene, request, send,
  id: totrans-1343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这样可以让任何场景执行 goToScene、request、send 操作，
- en: or sendAll, which gets forwarded to the scene manager.
  id: totrans-1344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 或 sendAll，它们会被转发到场景管理器。
- en: '4 for key, oScene in self.scenesDict.items():'
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 4 对于键值对 key, oScene 在 self.scenesDict.items() 中：
- en: oScene._setRefToSceneMgr(self)
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: oScene._setRefToSceneMgr(self)
- en: '*Listing 15-6: The __init__() method of the SceneMgr class*'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单15-6：SceneMgr类的__init__()方法*'
- en: The __init__() method keeps track of all scenes in a dictionary 1\. It
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: __init__() 方法通过一个字典 1 跟踪所有场景。它
- en: iterates through the list of scenes, asking each scene for its scene key, and
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历场景列表，要求每个场景提供它的场景键，并
- en: builds a dictionary 2\. The first scene object in the list of scenes is used
    as
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个字典 2\. 列表中的第一个场景对象被用作
- en: the starting scene 3\.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 起始场景 3\.
- en: The last part of the __init__() method does some interesting work. The
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: __init__() 方法的最后一部分做了一些有趣的工作。该部分
- en: scene manager holds a reference to every scene, so it can send messages to
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 场景管理器持有对每个场景的引用，因此它可以向
- en: any and every scene. But every scene also needs to be able to send messages
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 任何和每个场景。但是每个场景也需要能够发送信息
- en: to the scene manager. To allow each scene to do that, the last for loop in
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 场景管理器。为了让每个场景都能做到这一点，最后一个 for 循环在
- en: the __init__() method calls the special method _setRefToSceneMgr() 4 that
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: __init__() 方法调用了特殊方法 _setRefToSceneMgr() 4，来
- en: lives in the base class of every scene, and it passes self, which is a reference
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 它存在于每个场景的基类中，并传递 self，这是一个引用
- en: 'to the scene manager. The entire code of this method consists of a single line:'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 到场景管理器。该方法的完整代码只有一行：
- en: 'def _setRefToSceneMgr(self, oSceneMgr):'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _setRefToSceneMgr(self, oSceneMgr):'
- en: '--- snip ---'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 剪切 ---'
- en: self.oSceneMgr = oSceneMgr
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: self.oSceneMgr = oSceneMgr
- en: Scenes **335**
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 场景 **335**
- en: This method just stores this reference back to the scene manager in an instance
    variable, self.oSceneMgr. Each scene can use this variable to make
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法只是将这个引用存回场景管理器的实例变量 self.oSceneMgr。每个场景可以使用这个变量来执行
- en: calls to the scene manager. I’ll show how scenes use this a little later in
    this
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 调用场景管理器的方法。我稍后会展示场景如何使用这个方法。
- en: section.
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 小节。
- en: '***run() Method***'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: '***run() 方法***'
- en: For every project you build, you have to write a small main program that
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你构建的每一个项目，你都必须编写一个小的主程序，它
- en: instantiates the scene manager. The last step in your main program is a call
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化场景管理器。你的主程序的最后一步是调用
- en: to the run() method of the scene manager. This is where the main loop of
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 到场景管理器的 run() 方法。这是主循环所在的位置。
- en: the whole program lives. Listing 15-7 contains the code of that method.
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 整个程序都在运行。列表 15-7 包含了该方法的代码。
- en: 'def run(self):'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 'def run(self):'
- en: '--- snip ---'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 剪切 ---'
- en: clock = pygame.time.Clock()
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: clock = pygame.time.Clock()
- en: 6 - Loop forever
  id: totrans-1374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 - 无限循环
- en: 'while True:'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 1 keysDownList = pygame.key.get_pressed()
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 1 keysDownList = pygame.key.get_pressed()
- en: 7 - Check for and handle events
  id: totrans-1377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 - 检查并处理事件
- en: 2 eventsList = []
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 2 eventsList = []
- en: 'for event in pygame.event.get():'
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: if (event.type == pygame.QUIT) or \
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 (event.type == pygame.QUIT) 或 \
- en: ((event.type == pygame.KEYDOWN) and
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: ((event.type == pygame.KEYDOWN) 和
- en: '(event.key == pygame.K_ESCAPE)):'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: '(event.key == pygame.K_ESCAPE)):'
- en: Tell the current scene we're leaving
  id: totrans-1383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 告诉当前场景我们要离开它了。
- en: self.oCurrentScene.leave()
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: self.oCurrentScene.leave()
- en: pygame.quit()
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: eventsList.append(event)
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: eventsList.append(event)
- en: Here, we let the current scene process all events,
  id: totrans-1388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在这里，我们让当前场景处理所有事件，
- en: do any "per frame" actions in its update method,
  id: totrans-1389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 update 方法中执行任何“每帧”动作，
- en: and draw everything that needs to be drawn.
  id: totrans-1390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并绘制所有需要绘制的内容。
- en: 3 self.oCurrentScene.handleInputs(eventsList, keysDownList)
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 3 self.oCurrentScene.handleInputs(eventsList, keysDownList)
- en: 4 self.oCurrentScene.update()
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 4 self.oCurrentScene.update()
- en: 5 self.oCurrentScene.draw()
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 5 self.oCurrentScene.draw()
- en: 11 - Update the window
  id: totrans-1394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 - 更新窗口
- en: 6 pygame.display.update()
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 6 pygame.display.update()
- en: 12 - Slow things down a bit
  id: totrans-1396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 - 稍微减慢一些
- en: clock.tick(self.framesPerSecond)
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: clock.tick(self.framesPerSecond)
- en: '*Listing 15-7: The run() method of the SceneMgr class*'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 15-7：SceneMgr 类的 run() 方法*'
- en: '**336** Chapter 15'
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: '**336** 第 15 章'
- en: The run() method is the key to how the scene manager works. Remember that all
    scenes must be polymorphic—at a minimum, each must implement
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: run() 方法是场景管理器工作原理的关键。记住，所有场景必须是多态的——至少每个场景必须实现
- en: a handleInputs() and a draw() method. Each time through the loop, the run()
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 handleInputs() 和 draw() 方法。每次循环时，run()
- en: 'method does the following:'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法执行以下操作：
- en: • Gets a list of all keyboard keys 1 (False means up, True means down).
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: • 获取所有键盘键的列表 1（False 表示按键抬起，True 表示按键按下）。
- en: • Builds a list of events 2 that have happened since the last time through
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: • 构建事件列表 2，记录自上次循环以来发生的事件。
- en: the loop.
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 循环。
- en: • Makes calls to the polymorphic methods 3 of the current scene. The cur-
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: • 调用当前场景的多态方法 3。当前场景
- en: rent scene is always kept in an instance variable named self.oCurrentScene.
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 当前场景始终保存在名为 self.oCurrentScene 的实例变量中。
- en: In the call to the scene’s handleInputs() method, the scene manager
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用场景的 handleInputs() 方法时，场景管理器
- en: passes in the list of events that have happened and the list of keys. Each
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 传入已发生的事件列表和按键列表。每个
- en: scene is responsible for handling the events and for dealing with the
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 场景负责处理事件并处理
- en: state of the keyboard.
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘的状态。
- en: • Calls the update() method 4 to allow the scene to do any per-frame
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: • 调用 update() 方法 4，允许场景执行任何每帧操作。
- en: actions. The Scene base class implements an update() method that just
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 操作覆盖此方法。Scene 基类实现了一个 update() 方法，该方法只是
- en: contains a pass statement, but a scene can override this method with
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 pass 语句，但场景可以通过
- en: any code it wants to execute.
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以执行任何它想要的代码。
- en: • Calls the draw() method 5 to allow the scene to draw anything it needs
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: • 调用 draw() 方法 5，允许场景绘制它需要绘制的任何内容。
- en: to draw in the window.
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口中绘制。
- en: At the bottom of the loop (identical to the standard main loop with-
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的底部（与标准的主循环完全相同）：
- en: out a scene manager), the method updates the window 6 and waits for an
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 场景管理器更新窗口6并等待适当的时间。
- en: appropriate amount of time.
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 适当的时间。
- en: '***Main Methods***'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: '***主要方法***'
- en: The remaining methods of the SceneMgr class implement the navigation and
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: SceneMgr类的其余方法实现了导航和
- en: 'communication between scenes:'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 场景之间的通信：
- en: '**_goToScene()** Called to transfer to a different scene'
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: '**_goToScene()** 调用，用于切换到另一个场景'
- en: '**_request_respond()** Called to query data in another scene'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: '**_request_respond()** 调用，用于查询另一个场景中的数据'
- en: '**_send_receive()** Called to send information from one scene to another'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: '**_send_receive()** 调用，用于将信息从一个场景发送到另一个场景'
- en: '**_sendAll_receive()** Called to send information from one scene to all'
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: '**_sendAll_receive()** 调用，用于将信息从一个场景发送到所有'
- en: other scenes
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 其他场景
- en: The code of any scenes that you write should not call these methods
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 你编写的任何场景代码都不应直接调用这些方法
- en: directly, and they should not be overwritten. The underscore in front of
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 直接调用，并且不应被重写。前面的下划线
- en: their names implies that these are private (internal) methods. While they
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 其名称暗示这些是私有（内部）方法。虽然它们
- en: are not called directly within the scene manager itself, they are called by
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法并非在场景管理器本身内直接调用，而是由
- en: the Scene base class.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 场景基类。
- en: To explain how these methods work, I’ll start by giving an overview
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这些方法是如何工作的，我将首先给出一个概览
- en: of the steps involved when a scene wants to navigate to another scene. To
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤的过程，当场景想要跳转到另一个场景时。为
- en: 'make a transition to a target scene, the current scene calls:'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行场景跳转，当前场景调用：
- en: self.goToScene( *SOME_SCENE_KEY*)
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: self.goToScene( *某场景键*)
- en: Scenes **337**
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 场景 **337**
- en: When a scene makes this call, the call goes to the goToScene() method in the
    inherited Scene base class. The code of the inherited method consists of
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: 当场景发起此调用时，该调用会进入继承的Scene基类中的goToScene()方法。继承方法的代码由以下内容组成
- en: 'a single line:'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 一行代码：
- en: 'def goToScene(self, nextSceneKey, data=None):'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 'def goToScene(self, nextSceneKey, data=None):'
- en: '--- snip ---'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 截取部分 ---'
- en: self.oSceneMgr._goToScene(nextSceneKey, data)
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: self.oSceneMgr._goToScene(nextSceneKey, data)
- en: This makes a call to the private _goToScene() method in the scene man-
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 这会调用场景管理器中的私有方法_goToScene()。
- en: ager. Within the scene manager’s method, we need to give the current
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 管理器。在场景管理器的方法中，我们需要给当前
- en: scene an opportunity to do any cleanup that might be needed, then trans-
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 给场景提供机会进行必要的清理工作，然后转移到
- en: fer control to the new scene. Here is the code of the _goToScene() method of
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 将控制权交给新场景。以下是场景管理器中_goToScene()方法的代码
- en: 'the scene manager:'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: 场景管理器：
- en: 'def _goToScene(self, nextSceneKey, dataForNextScene):'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 'def _goToScene(self, nextSceneKey, dataForNextScene):'
- en: '--- snip ---'
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 截取部分 ---'
- en: 'if nextSceneKey is None: # meaning, exit'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 如果nextSceneKey为None：# 表示退出
- en: pygame.quit()
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: Call the leave method of the old scene to allow it to clean up.
  id: totrans-1454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用旧场景的leave方法，以便它进行清理。
- en: Set the new scene (based on the key) and
  id: totrans-1455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置新场景（基于场景键）并
- en: call the enter method of the new scene.
  id: totrans-1456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用新场景的enter方法。
- en: 1 self.oCurrentScene.leave()
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 1 self.oCurrentScene.leave()
- en: 'pygame.key.set_repeat(0) # turn off repeating characters'
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: 'pygame.key.set_repeat(0) # 关闭字符重复'
- en: 'try:'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试：
- en: 2 self.oCurrentScene = self.scenesDict[nextSceneKey]
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 2 self.oCurrentScene = self.scenesDict[nextSceneKey]
- en: 'except KeyError:'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 除了KeyError：
- en: raise KeyError("Trying to go to scene '" + nextSceneKey +
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: raise KeyError("尝试跳转到场景 '" + nextSceneKey +
- en: '"'' but that key is not in the dictionary of scenes.")'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: '"'' 但是那个键不在场景字典中。")'
- en: 3 self.oCurrentScene.enter(dataForNextScene)
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 3 self.oCurrentScene.enter(dataForNextScene)
- en: The _goToScene() method performs a number of steps to transition
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: _goToScene()方法执行一系列步骤以实现场景过渡
- en: from the current scene to the target scene. First, it calls leave() in the cur-
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: 从当前场景切换到目标场景。首先，它在当前场景中调用leave()，
- en: rent scene 1 so the current scene can do any necessary cleanup. Then,
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 当前场景1，以便当前场景进行必要的清理。然后，
- en: using the target scene key that was passed in, it finds the object for the target
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传入的目标场景键，找到目标场景的对象
- en: scene 2 and sets that as the current scene. Finally, it calls enter() for the
    new
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 场景2，并将其设置为当前场景。最后，它调用新场景的enter()方法。
- en: current scene 3 to allow the new current scene to do any required setup.
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 当前场景3，允许新当前场景进行必要的设置。
- en: From this point on, the run() method of the scene manager loops and
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 从此时起，场景管理器的run()方法开始循环
- en: calls the handleInputs(), update(), and draw() methods of the current scene.
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 调用当前场景的handleInputs()、update()和draw()方法。
- en: These methods will be called in the current scene until the program exe-
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法将在当前场景中被调用，直到程序执行完毕
- en: cutes another call to self.goToScene() to transition to yet another scene or
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 发起另一次对self.goToScene()的调用，以切换到另一个场景或
- en: the user quits the program.
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
- en: '***Communication Between Scenes***'
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s discuss how one scene communicates with another scene. To
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: request information from another scene, a scene only needs to make a call
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: 'to self.request(), which lives in the Scene base class, like this:'
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
- en: dataRequested = self.request( *SOME_SCENE_KEY*, *SOME_DATA_IDENTIFIER*)
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
- en: '**338** Chapter 15'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: 'The target scene must have a respond() method. That method needs to be defined
    like this:'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
- en: 'def respond(self, requestID):'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
- en: It uses the value of requestID to uniquely identify what data to retrieve
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
- en: and returns that data. Again, the requesting scene and the target scene
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: must agree on the value of any identifier(s). The full process is shown in
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
- en: Figure 15-10\.
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
- en: '**Scene manager**'
  id: totrans-1488
  prefs: []
  type: TYPE_NORMAL
- en: self._request_respond()
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: Return data
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: '**Scene**'
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
- en: '**Scene**'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: '*(Base class)*'
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
- en: '*(Base class)*'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
- en: arget.respond()
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
- en: Return data
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
- en: oT
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
- en: self.request()
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
- en: Return data
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
- en: '**Current**'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
- en: '**Current**'
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
- en: '**scene**'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
- en: '**scene**'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 15-10: The communication path of one scene asking for information from*'
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
- en: '*another scene*'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
- en: The current scene cannot get information from another scene directly,
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: since the current scene does not have a reference to any other scene.
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
- en: Instead, it uses the scene manager as an intermediary. Here is how it all
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
- en: 'works:'
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The current scene makes a call to self.request(), which lives in the
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
- en: inherited Scene base class.
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
- en: 2\. The
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: Scene base class has a reference to the scene manager in its
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
- en: instance variable self.oSceneMgr, to allow its methods to call methods
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
- en: of the scene manager. The self.request() method calls the scene
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
- en: manager’s _request_respond() method to request information from a
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
- en: target scene.
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
- en: 3\. The scene manager has a dictionary of all scene keys and related
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
- en: objects, and it uses the parameter that’s passed in to find the object
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
- en: associated with the target scene. It then calls the respond() method in
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
- en: the target scene.
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
- en: 4\. The
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: respond() method in the target scene (which you must write) does
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
- en: whatever it needs to do to generate the data that was asked for, then
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
- en: returns the data to the scene manager.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
- en: Scenes **339**
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
- en: 5\. The scene manager returns the data to the request() method in the Scene
    base class inherited by the current scene.
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Finally, the request() method in the Scene base class returns the data to
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
- en: the original caller.
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
- en: The same mechanism is used to implement send() and sendAll(). The
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
- en: only difference is that when sending a message to a scene or to all scenes,
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
- en: there is no data to be returned to the original caller.
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I introduced two different ways to implement a program
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
- en: that incorporates multiple scenes. A state machine is a technique for rep-
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
- en: resenting and controlling the flow of execution through a series of states;
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
- en: you can use it to implement a program with a small number of scenes. The
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
- en: scene manager is designed to help you build larger multi-scene applications
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
- en: by providing navigation and a general way for scenes to communicate with
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
- en: each other. I also explained how the scene manager implements all this
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
- en: functionality.
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
- en: The scene manager and the Scene base class provide clear examples of
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
- en: 'the three main tenets of object-oriented programming: encapsulation, poly-'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
- en: morphism, and inheritance. Each scene is a good example of encapsulation
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
- en: because all the code and data of a scene is written as a class. Each scene class
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
- en: must be polymorphic, in that it must implement a common set of methods
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
- en: in order for it to work with calls from the scene manager. Finally, each scene
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: inherits from a common Scene base class. Two-way communication between
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
- en: the scene manager and the Scene base class is implemented by every scene
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
- en: using the inherited methods and instance variables in the base class.
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
- en: '**340** Chapter 15'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
- en: '**16**'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: '**F U L L G A M E : D O D G E R**'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll build a full game called
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
- en: Dodger that uses many of the techniques
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
- en: and concepts that have been explained
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: in this book. This is a fully object-oriented
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
- en: extended version of a game originally developed by
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
- en: Al Sweigart in his book *Invent Your Own Computer Games*
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
- en: '*with Python* (No Starch, 2016; the basic game concept,'
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
- en: graphics, and sounds are used by permission).
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
- en: Before I get into the game itself, I’ll introduce a set of functions that
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: present modal dialogs that we’ll use in the game. A *modal dialog* is one
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: that forces the user to interact with it—choosing an option, for example—
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
- en: before they can continue using the underlying program. These dialogs
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
- en: stop the program from running until an option is clicked.
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
- en: '**Modal Dialogs**'
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
- en: 'The pyghelpers module has two types of modal dialogs:'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
- en: • *Yes/No dialogs* present a question and wait for the user to click one of
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: two buttons. The text of these buttons defaults to Yes and No, though
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
- en: you can use any text you like (for example, OK and Cancel). If no text
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: is specified for the No button, this dialog can be used as an alert, with
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
- en: only a Yes (or typically, OK) button.
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: • *Answer dialogs* present a question, a text field for the user to type in,
    and a set of buttons with text defaulting to OK and Cancel. The user can
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
- en: answer the question and click OK or cancel (close) the dialog by click-
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
- en: ing Cancel.
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
- en: You present each type of dialog to the user by calling a particular func-
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: 'tion in the pyghelpers module. Each dialog comes in two flavors: a simple'
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
- en: TextButton-based version and a more complicated custom version. The sim-
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: ple text version uses a default layout with two TextButton objects that’s great
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
- en: for quick prototyping. In the custom version, you can provide a background
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: for the dialog, customize the question text, customize the answer text (with
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
- en: an Answer dialog), and provide customized artwork for the buttons.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
- en: '***Yes/No and Alert Dialogs***'
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: We’ll first look at the Yes/No dialog, starting with the text version.
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: '**Text Version**'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the interface of the textYesNoDialog() function:'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
- en: textYesNoDialog(theWindow, theRect, prompt, yesButtonText='Yes',
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
- en: noButtonText='No',
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
- en: backgroundColor=DIALOG_BACKGROUND_COLOR,
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
- en: textColor=DIALOG_BLACK)
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: When you call this function, you need to pass in the window to draw
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: into, a rectangle object or tuple representing the location and size of the
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
- en: dialog to create, and a text prompt to be shown. You can also optionally
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
- en: specify the text of the two buttons, a background color, and the color of the
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
- en: prompt text. If not specified, the button text defaults to Yes and No.
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a typical call to this function:'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
- en: returnedValue = pyghelpers.textYesNoDialog(window,
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
- en: (75, 100, 500, 150),
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
- en: '''Do you want fries with that?'')'
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
- en: This call shows the dialog in Figure 16-1\.
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
- en: '**342** Chapter 16'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 47](index-372_1.png)'
  id: totrans-1609
  prefs: []
  type: TYPE_IMG
- en: '![Image 48](index-372_2.png)'
  id: totrans-1610
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-1: A typical textYesNoDialog dialog*'
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
- en: The Yes and No buttons are instances of the TextButton class in pygwidgets.
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
- en: The main program stops while the dialog shows. When the user clicks a
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
- en: button, the function returns True for Yes or False for No. Your code does
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
- en: whatever needs to be done based on the returned Boolean value; then the
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
- en: main program continues running where it left off.
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
- en: You can also use this function to create a simple Alert dialog with only
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
- en: one button. If the value passed in for noButtonText is None, that button will
    not
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: 'be shown. For example, you can make a call like this to show only one button:'
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
- en: ignore = pyghelpers.textYesNoDialog(window, (75, 80, 500, 150),
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
- en: '''This is an alert!'', ''OK'', None)'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16-2 shows the resulting Alert dialog.
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16-2: A textYesNoDialog used as an Alert dialog*'
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom Version**'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a custom Yes/No dialog is more complicated but allows for much
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
- en: 'more control. Here is the interface of the customYesNoDialog() function:'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
- en: customYesNoDialog(theWindow, oDialogImage, oPromptText, oYesButton,
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
- en: oNoButton)
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
- en: Before you can call this function, you need to create objects for the
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
- en: background of the dialog, the prompt text, and the Yes and No buttons. You
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
- en: would typically use Image, DisplayText, and CustomButton (or TextButton) objects
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
- en: created from pygwidgets classes for this purpose. The customYesNoDialog()
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
- en: code demonstrates polymorphism by calling the handleEvent() method of the
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
- en: buttons, so it doesn’t matter whether you use CustomButtons or TextButtons,
    and
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
- en: by calling the draw() method of all objects that make up the dialog. Because
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
- en: you create all these objects, you can customize the look of any or all of them.
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
- en: You will need to supply your own artwork for any Image and CustomButton
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
- en: objects and customarily place them in the *images* folder of the project.
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
- en: 'Full Game: Dodger **343**'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
- en: When implementing a custom Yes/No dialog, typically you would write an intermediate
    function like showCustomYesNoDialog(), shown in Listing 16-1\.
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
- en: Then, at the place in your code where you want to show the dialog, rather
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
- en: than calling customYesNoDialog() directly, you instead call the intermediate
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
- en: function, which both instantiates the widgets and makes the actual call.
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
- en: 'def showCustomYesNoDialog(theWindow, theText):'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
- en: 1 oDialogBackground = pygwidgets.Image(theWindow, (60, 120),
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
- en: '''images/dialog.png'')'
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
- en: 2 oPromptDisplayText = pygwidgets.DisplayText(theWindow, (0, 170),
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
- en: theText, width=WINDOW_WIDTH,
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
- en: justified='center', fontSize=36)
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
- en: 3 oNoButton = pygwidgets.CustomButton(theWindow, (95, 265),
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
- en: '''images/noNormal.png'','
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
- en: over='images/noOver.png',
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
- en: down='images/noDown.png',
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
- en: disabled='images/noDisabled.png')
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
- en: oYesButton = pygwidgets.CustomButton(theWindow, (355, 265),
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
- en: '''images/yesNormal.png'','
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
- en: over='images/yesOver.png',
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
- en: down='images/yesDown.png',
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
- en: disabled='images/yesDisabled.png')
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
- en: 4 userAnswer = pyghelpers.customYesNoDialog(theWindow,
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
- en: oDialogBackground,
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
- en: oPromptDisplayText,
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
- en: oYesButton, oNoButton)
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: 5 return userAnswer
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-1: An intermediate function to create a custom Yes/No dialog*'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
- en: Inside the function you write code to create an Image object for the
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
- en: background using an image you specify 1\. You also create a DisplayText
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
- en: object for the prompt 2, in which you specify the placement, text size,
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
- en: font, and so on. Then you create buttons as either TextButton objects or,
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: more likely, CustomButton objects so you can show custom images 3\. Finally,
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
- en: this function calls customYesNoDialog(), passing in all the objects you just
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
- en: created 4\. The call to customYesNoDialog() returns the user’s choice to this
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
- en: intermediate function, and the intermediate function returns the user’s
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: choice to the original caller 5\. This approach works well because the wid-
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: get objects (oDialogBackground, oPromptDisplayText, oYesButton, and oNoButton)
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
- en: created inside this function are all local variables and therefore will all
    go
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: away when the intermediate function ends.
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
- en: When you call this function, you only need to pass in the window and
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: 'the text prompt to be displayed. For example:'
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
- en: returnedValue = showCustomYesNoDialog(window,
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
- en: '''Do you want fries with that?'')'
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16-3 shows the resulting dialog. This is just one example; you
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
- en: can design any layout you like.
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
- en: '**344** Chapter 16'
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 49](index-374_1.png)'
  id: totrans-1685
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-3: A typical customYesNoDialog dialog*'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
- en: As with the simple text version, if the value passed in for oNoButton is
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
- en: None, that button will not be shown, which is useful for building and display-
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
- en: ing an Alert dialog.
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
- en: Internally, the textYesNoDialog() and customYesNoDialog() functions each
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
- en: run their own while loop that handles events and updates and draws the
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
- en: dialog. That way, the calling program is suspended (its main loop does
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
- en: not run) until the user clicks a button and the modal dialog returns the
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: selected answer. (The source code of both functions is available in the
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
- en: pyghelpers module.)
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
- en: '***Answer Dialogs***'
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
- en: An Answer dialog adds an input text field where the user can type a
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: response. The pyghelpers module also contains functions textAnswerDialog()
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
- en: and customAnswerDialog() to handle these dialogs, which work similarly to
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
- en: their Yes/No counterparts.
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
- en: '**Text Version**'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the interface of the textAnswerDialog() function:'
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
- en: textAnswerDialog(theWindow, theRect, prompt, okButtonText='OK'
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
- en: cancelButtonText='Cancel',
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
- en: backgroundColor=DIALOG_BACKGROUND_COLOR,
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
- en: promptTextColor=DIALOG_BLACK,
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
- en: inputTextColor=DIALOG_BLACK)
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
- en: If the user clicks the OK button, the function returns whatever text the
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
- en: user entered. If the user clicks the Cancel button, the function returns None.
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a typical call:'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
- en: userAnswer = pyghelpers.textAnswerDialog(window, (75, 100, 500, 200),
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
- en: '''What is your favorite flavor of ice cream?'')'
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
- en: 'if userAnswer is not None:'
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
- en: User pressed OK, do whatever you want with the variable userAnswer
  id: totrans-1714
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
- en: Here do whatever you want knowing that the user pressed Cancel
  id: totrans-1716
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Full Game: Dodger **345**'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 50](index-375_1.png)'
  id: totrans-1718
  prefs: []
  type: TYPE_IMG
- en: This will display the dialog in Figure 16-4\.
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16-4: A typical textAnswerDialog dialog*'
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom Version**'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: To implement a custom Answer dialog, you should write an intermediate
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
- en: function, similar to the approach shown with customYesNoDialog(). Your main
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
- en: code calls the intermediate function, which in turn calls customAnswerDialog().
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
- en: Listing 16-2 shows the code of a typical intermediate function.
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
- en: 'def showCustomAnswerDialog(theWindow, theText):'
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
- en: oDialogBackground = pygwidgets.Image(theWindow, (60, 80),
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
- en: '''images/dialog.png'')'
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
- en: oPromptDisplayText = pygwidgets.DisplayText(theWindow, (0, 120),
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
- en: theText, width=WINDOW_WIDTH,
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
- en: justified='center', fontSize=36)
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
- en: oUserInputText = pygwidgets.InputText(theWindow, (225, 165), '',
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
- en: fontSize=36, initialFocus=True)
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
- en: oNoButton = pygwidgets.CustomButton(theWindow, (105, 235),
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
- en: '''images/cancelNormal.png'','
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
- en: over='images/cancelOver.png',
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
- en: down='images/cancelDown.png',
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
- en: isabled='images/cancelDisabled.png')
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
- en: oYesButton = pygwidgets.CustomButton(theWindow, (375, 235),
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
- en: '''images/okNormal.png'','
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
- en: over='images/okOver.png',
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
- en: down='images/okDown.png',
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
- en: disabled='images/okDisabled.png')
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
- en: response = pyghelpers.customAnswerDialog(theWindow,
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
- en: oDialogBackground, oPromptDisplayText,
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
- en: oUserInputText,
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
- en: oYesButton, oNoButton)
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
- en: return response
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16-2: An intermediate function to create a custom Answer dialog*'
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
- en: 'You can customize the entire appearance of the dialog: background'
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
- en: image, fonts, and sizes and placement of the display and input text fields
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
- en: '**346** Chapter 16'
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 51](index-376_1.png)'
  id: totrans-1753
  prefs: []
  type: TYPE_IMG
- en: and the two buttons. To show a custom dialog, your main code would call
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
- en: 'the intermediate function and pass in the prompt text, like this:'
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
- en: userAnswer = showCustomAnswerDialog(window,
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
- en: '''What is your favorite flavor of ice cream?'')'
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
- en: That call displays a custom Answer dialog like the one shown in
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16-5\.
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 16-5: A typical customAnswerDialog dialog*'
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
- en: If user clicks OK, the function returns the text the user entered. If the
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
- en: user clicks the Cancel button, the function returns None.
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
- en: A demo program that demonstrates all the types of dialogs, *DialogTester/*
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
- en: '*Main_DialogTester.py*, is available with the downloadable resources for the'
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
- en: book.
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
- en: '**Building a Full Game: Dodger**'
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll put all the material from this part of the book together
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
- en: in the context of a game called Dodger. From the user’s point of view, the
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
- en: 'game is extremely simple: get as many points as you can by dodging the red'
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
- en: Baddies and making contact with the green Goodies.
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
- en: '***Game Overview***'
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
- en: Red Baddies will drop from the top of the window, and the user must avoid
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
- en: them. Any Baddie that makes it all the way down to the bottom of the game
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
- en: area is removed, and the user gains one point. The user moves the mouse to
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
- en: control a Player icon. If the Player touches any Baddie, the game is over. A
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
- en: small number of green Goodies show up randomly and move horizontally,
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
- en: and the user gets 25 points for any Goodie they touch.
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
- en: 'The game has three scenes: a starting or Splash scene with instructions,'
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
- en: a Play scene where you play the game, and a High Scores scene where you
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
- en: can view the top 10 high scores. If you score within the top 10, you’re given
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
- en: the option of entering your name and score into the high scores table.
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16-6 shows the three scenes.
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
- en: 'Full Game: Dodger **347**'
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 52](index-377_1.png)'
  id: totrans-1784
  prefs: []
  type: TYPE_IMG
- en: '*Figure 16-6: The Splash, Play, and High Score scenes (left to right)*'
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
- en: '***Implementation***'
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of the *Dodger* project folder are as follows (filenames are in
    italic):'
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
- en: '***__init__.py***Empty file that indicates that this is a Python package'
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
- en: '***Baddies.py***Contains the Baddie and BaddieMgr classes'
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
- en: '***Constants.py***Contains constants used by multiple scenes'
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
- en: '***Goodies.py***Contains the Goodie and GoodieMgr classes'
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
- en: '***HighScoresData.py***Contains the HighScoresData class'
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
- en: '**images** Folder that contains all the artwork for the game'
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
- en: '***Main_Dodger.py***The main program'
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
- en: '***Player.py***Contains the Player class'
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
- en: '***SceneHighScores.py***The scene that shows and records high scores'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
- en: '***ScenePlay.py***The main Play scene'
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
- en: '***Scene.Splash.py***The Splash scene'
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
- en: '**sounds** Folder that contains all the sound files for the game'
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
- en: The project folder is included with the book’s resources. I won’t talk
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
- en: through the entirety of the code, but I’ll go through the source files and
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
- en: explain how the key parts work.
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Dodger/Constants.py**'
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
- en: This file contains constants that can be used by more than one source file.
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important constants are the scene keys:'
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
- en: Scene keys
  id: totrans-1806
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SCENE_SPLASH = 'scene splash'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
- en: SCENE_PLAY = 'scene play'
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
- en: SCENE_HIGH_SCORES = 'scene high scores'
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
- en: '**348** Chapter 16'
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
- en: The values of these constants are unique strings that identify the different
    scenes.
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Main_Dodger.py**'
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
- en: The main file performs the necessary initialization, then passes control to
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
- en: 'the scene manager. The most important code in the file is this:'
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
- en: Instantiate all scenes and store them in a list
  id: totrans-1815
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: scenesList = [SceneSplash(window)
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
- en: SceneHighScores(window)
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
- en: ScenePlay(window)]
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
- en: Create the scene manager, passing in the scenes list and the FPS
  id: totrans-1819
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oSceneMgr = pyghelpers.SceneMgr(scenesList, FRAMES_PER_SECOND)
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
- en: Tell the scene manager to start running
  id: totrans-1821
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oSceneMgr.run()
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
- en: Here we create an instance of each scene, instantiate the scene man-
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
- en: ager, then turn over control to the scene manager. The scene manager’s
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
- en: run() method gives control to the first scene in the list. In this game, it
    gives
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
- en: control to the Splash scene.
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in the previous chapter, each scene class inherits from the
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
- en: Scene base class. In addition to providing its own __init__() method, each
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
- en: of these classes is required to override the getSceneKey(), handleInputs(),
    and
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
- en: draw() methods from the base class.
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Dodger/SceneSplash.py**'
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
- en: The Splash scene shows the user a graphic with the rules of the game and
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
- en: 'three buttons: Start, Quit, and Go to High Scores. The code for this scene’s'
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
- en: class only contains the required methods; all other methods default to the
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
- en: ones in the Scene base class.
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() method creates an Image object for the background
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
- en: image and three CustomButton objects for the user’s options.
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
- en: The getSceneKey() method must be implemented in all scenes; it just
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
- en: returns a unique key for the scene.
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
- en: The handleInputs() method checks for the user clicking any of the but-
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
- en: tons. If the user clicks Start, we call the inherited self.goToScene() method
  id: totrans-1841
  prefs: []
  type: TYPE_NORMAL
- en: to ask the scene manager to transfer control to the Play scene. Similarly,
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
- en: clicking the Go to High Scores button takes the user to the High Scores
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
- en: scene. If the user clicks Quit, we call the scene’s inherited self.quit()
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
- en: method, which quits the program.
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
- en: In the draw() method, the program draws the background and all three
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
- en: buttons.
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
- en: '**File: Dodger/ScenePlay.py**'
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
- en: 'The Play scene manages the actual playing of the game: the user moving'
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
- en: the Player icon, generation and movement of the Baddies and Goodies,
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
- en: 'Full Game: Dodger **349**'
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
- en: and collision detection. It also manages the display elements at the bottom
    of the window, including the current game score and high score, and
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
- en: responds to clicks on the Quit, Go to High Scores, and Start buttons and
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
- en: the Background Music checkbox.
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
- en: There is quite a bit of code for the Play scene, so I’ll break it up into
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
- en: smaller chunks (Listings 16-3 through 16-7) to explain the methods. The
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
- en: scene adheres to the design rules established i[n Chapter 15 by i](#p340)mplementing
    the __init__(), handleInputs(), update(), and draw() methods. It also implements
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
- en: an enter() method to handle what the scene should do when it becomes the
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
- en: active scene and a leave() method for what the scene should do when the user
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
- en: navigates away. Finally, it has a reset() method for resetting the state before
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
- en: starting a new round. Listing 16-3 shows the initialization code.
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
- en: Play scene - the main game play scene
  id: totrans-1862
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip imports and showCustomYesNoDialog ---'
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
- en: BOTTOM_RECT = (0, GAME_HEIGHT + 1, WINDOW_WIDTH,
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_HEIGHT - GAME_HEIGHT)
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
- en: STATE_WAITING = 'waiting'
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
- en: STATE_PLAYING = 'playing'
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
- en: STATE_GAME_OVER = 'game over'
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
- en: 'class ScenePlay(pyghelpers.Scene):'
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window):'
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
- en: 1 self.window = window
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
- en: self.controlsBackground = pygwidgets.Image(self.window,
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
- en: (0, GAME_HEIGHT),
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
- en: '''images/controlsBackground.jpg'')'
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
- en: self.quitButton = pygwidgets.CustomButton(self.window,
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
- en: (30, GAME_HEIGHT + 90),
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
- en: up='images/quitNormal.png',
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
- en: down='images/quitDown.png',
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
- en: over='images/quitOver.png',
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
- en: disabled='images/quitDisabled.png')
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
- en: self.highScoresButton = pygwidgets.CustomButton(self.window,
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
- en: (190, GAME_HEIGHT + 90),
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
- en: up='images/gotoHighScoresNormal.png',
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
- en: down='images/gotoHighScoresDown.png',
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
- en: over='images/gotoHighScoresOver.png',
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
- en: disabled='images/gotoHighScoresDisabled.png')
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
- en: self.startButton = pygwidgets.CustomButton(self.window,
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
- en: (450, GAME_HEIGHT + 90),
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
- en: up='images/startNewNormal.png',
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
- en: down='images/startNewDown.png',
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
- en: over='images/startNewOver.png',
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
- en: disabled='images/startNewDisabled.png',
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
- en: enterToActivate=True)
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
- en: '**350** Chapter 16'
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
- en: self.soundCheckBox = pygwidgets.TextCheckBox(self.window,
  id: totrans-1895
  prefs: []
  type: TYPE_NORMAL
- en: (430, GAME_HEIGHT + 17),
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
- en: '''Background music'','
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
- en: True, textColor=WHITE)
  id: totrans-1898
  prefs: []
  type: TYPE_NORMAL
