<html><head></head><body>
<h2 class="h2" id="ch06"><span epub:type="pagebreak" id="page_122"/><span epub:type="pagebreak" id="page_123"/><span class="big">6</span><br/>WINNING THE MOON RACE WITH APOLLO 8</h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">In the summer of 1968, America was losing the space race. The Soviet Zond spacecraft appeared moon-ready, the Central Intelligence Agency had photographed a giant Soviet N-1 rocket sitting on its launch pad, and the Americans’ troubled Apollo program still needed three more test flights. But in August, NASA manager George Low had an audacious idea. Let’s go to the moon <em>now</em>. Instead of more tests in the earth’s orbit, let’s circle the moon in December and let <em>that</em> be the test. In that moment, the space race was essentially over. Less than a year later, the Soviets had capitulated, and Neil Armstrong had taken his great leap for all mankind.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_124"/>The decision to take the Apollo 8 spacecraft to the moon was hardly trivial. In 1967, three men had died in the Apollo 1 capsule, and multiple unmanned missions had blown up or otherwise failed. Against this backdrop and with so much at stake, everything hinged on the concept of the <em>free return</em>. The mission was designed so that if the service module engine failed to fire, the ship would simply swing around the moon and return to the earth like a boomerang (<a href="ch06.xhtml#ch06fig1">Figure 6-1</a>).</p>&#13;
<div class="image"><img src="../images/fig06_01.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch06fig1"/>Figure 6-1: The Apollo 8 insignia, with the circumlunar free return trajectory serving as the mission number</p>&#13;
<p class="indent">In this chapter, you’ll write a Python program that uses a drawing board module called <span class="literal">turtle</span> to simulate Apollo 8’s free return trajectory. You’ll also work with one of the classic conundrums in physics: the three-body problem.</p>&#13;
<h3 class="h3" id="ch00lev1sec41"><strong>Understanding the Apollo 8 Mission</strong></h3>&#13;
<p class="noindent">The goal of the Apollo 8 mission was merely to circle the moon, so there was no need to take a lunar lander component. The astronauts traveled in the command and service modules, collectively known as the <em>CSM</em> (<a href="ch06.xhtml#ch06fig2">Figure 6-2</a>).</p>&#13;
<div class="image"><img src="../images/fig06_02.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch06fig2"/>Figure 6-2: Apollo command and service modules</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_125"/>In the fall of 1968, the CSM engine had been tested in the earth’s orbit only, and there were legitimate concerns about its reliability. To orbit the moon, the engine would have to fire twice, once to slow the spacecraft to enter lunar orbit and then again to leave orbit. With the free return trajectory, if the first maneuver failed, the astronauts could still coast home. As it turned out, the engine fired perfectly both times, and Apollo 8 orbited the moon 10 times. (The ill-fated Apollo 13, however, made great use of its free return trajectory!)</p>&#13;
<h4 class="h4" id="ch00lev2sec31"><strong><em>The Free Return Trajectory</em></strong></h4>&#13;
<p class="noindent">Plotting a free return trajectory requires a lot of intense mathematics. It <em>is</em> rocket science, after all! Fortunately, you can simulate the trajectory in a two-dimensional graph with a few simplified parameters (<a href="ch06.xhtml#ch06fig3">Figure 6-3</a>).</p>&#13;
<div class="image"><img src="../images/fig06_03.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch06fig3"/>Figure 6-3: The free return trajectory (not to scale)</p>&#13;
<p class="indent">This 2D simulation of the free return uses a few key values: the starting position of the CSM (R<sub>0</sub>), the velocity and orientation of the CSM (V<sub>0</sub>), and the phase angle between the CSM and the moon (γ<sub>0</sub>). The <em>phase angle</em>, also called the <em>lead angle</em>, is the change in the orbital time position of the CSM required to get from a starting position to a final position. The <em>translunar injection velocity</em> (V<sub>0</sub>) is a propulsive maneuver used to set the CSM on a trajectory to the moon. It’s achieved from a <em>parking orbit</em> around the earth, where the spacecraft performs internal checks and waits until the phase angle with the moon is optimal. At this point, the third stage of the <em>Saturn V</em> rocket fires and falls away, leaving the CSM to coast to the moon.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_126"/>Because the moon is moving, before you perform the translunar injection, you have to predict its future position, or <em>lead</em> it, like when you’re shooting skeet with a shotgun. This requires knowing the phase angle (γ<sub>0</sub>) at the time of translunar injection. Leading the moon is a little different from shooting a shotgun, however, as space is curved and you need to factor in the gravity of the earth and the moon. The tug of these two bodies on the spacecraft creates perturbations that are difficult to calculate—so difficult, in fact, that the calculation has earned its own special name in the field of physics: the three-body problem.</p>&#13;
<h4 class="h4" id="ch00lev2sec32"><strong><em>The Three-Body Problem</em></strong></h4>&#13;
<p class="noindent">The <em>three-body problem</em> is the challenge of predicting the behavior of three interacting bodies. Isaac Newton’s gravity equations work great for predicting the behavior of two orbiting bodies, such as the earth and the moon, but add one more body to the mix, whether a spacecraft, comet, moon, or so on, and things get complicated. Newton was never able to encapsulate the behavior of three or more bodies into a simple equation. For 275 years— even with kings offering prizes for a solution—the world’s greatest mathematicians worked the problem in vain.</p>&#13;
<p class="indent">The issue is that the three-body problem can’t be solved using simple algebraic expressions or integrals. Calculating the impact of multiple gravitational fields requires numerical iteration on a scale that’s impractical without a high-speed computer, such as your laptop.</p>&#13;
<p class="indent">In 1961, Michael Minovitch, a summer intern at the Jet Propulsion Laboratory, found the first numerical solution using an IBM 7090 mainframe, at the time the fastest computer in the world. He discovered that mathematicians could reduce the number of computations needed to solve a restricted three-body problem, like our earth-moon-CSM problem, by using a patched conic method.</p>&#13;
<p class="indent">The <em>patched conic method</em> is an analytical approximation that assumes you’re working with a simple two-body problem while the spacecraft is in the earth’s gravitational sphere of influence and another when you’re within the moon’s sphere of influence. It’s a rough, “back-of-the-envelope” calculation that provides reasonable estimates of departure and arrival conditions, reducing the number of choices for initial velocity and position vectors. All that’s left is to refine the flight path with repeated computer simulations.</p>&#13;
<p class="indent">Because researchers have already found and documented the Apollo 8 mission’s patched conic solution, you won’t need to calculate it. I’ve already adapted it to the 2D scenario you’ll be doing here. You can experiment with alternative solutions later, however, by varying parameters such as R<sub>0</sub> and V<sub>0</sub> and rerunning the simulation.</p>&#13;
<h3 class="h3ab" id="ch00lev1sec42"><span epub:type="pagebreak" id="page_127"/><strong>Project #9: To the Moon with Apollo 8!</strong></h3>&#13;
<p class="noindent">As a summer intern at NASA, you’ve been asked to create a simple simulation of the Apollo 8 free return trajectory for consumption by the press and general public. As NASA is always strapped for cash, you’ll need to use open source software and complete the project quickly and cheaply.</p>&#13;
<div class="sidebar96">&#13;
<p class="Problem-Head">THE OBJECTIVE</p>&#13;
<p class="Body-Problem">Write a Python program that graphically simulates the free return trajectory proposed for the Apollo 8 mission.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev2sec33"><strong><em>Using the turtle Module</em></strong></h4>&#13;
<p class="noindent">To simulate the flight of Apollo 8, you’ll need a way to draw and move images on the screen. There are a lot of third-party modules that can help you do this, but we’ll keep things simple by using the preinstalled <span class="literal">turtle</span> module. Although originally invented to help kids learn programming, <span class="literal">turtle</span> can easily be adapted to more sophisticated uses.</p>&#13;
<p class="indent">The <span class="literal">turtle</span> module lets you use Python commands to move a small image, called a <em>turtle</em>, around a screen. The image can be invisible, an actual image, a custom shape, or one of the predefined shapes shown in <a href="ch06.xhtml#ch06fig4">Figure 6-4</a>.</p>&#13;
<div class="image"><img src="../images/fig06_04.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch06fig4"/>Figure 6-4: Standard turtle shapes provided with the <span class="literal">turtle</span> module</p>&#13;
<p class="indent">As the turtle moves, you can choose to draw a line behind it to trace its movement (<a href="ch06.xhtml#ch06fig5">Figure 6-5</a>).</p>&#13;
<div class="image"><img src="../images/fig06_05.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch06fig5"/>Figure 6-5: Moving the turtle around the Turtle Graphics window</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_128"/>This simple drawing was made with the following script:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">import turtle</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">steve = turtle.Turtle('turtle'</span>) # Creates a turtle object with turtle shape.&#13;
&gt;&gt;&gt; <span class="codestrong1">steve.fd(50)</span> # Moves turtle forward 50 pixels.&#13;
&gt;&gt;&gt; <span class="codestrong1">steve.left(90)</span> # Rotates turtle left 90 degrees.&#13;
&gt;&gt;&gt; <span class="codestrong1">steve.fd(50)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">steve.left(90)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">steve.fd(50)</span></pre>&#13;
<p class="indent">You can use Python functionality with <span class="literal">turtle</span> to write more concise code. For example, you can use a <span class="literal">for</span> loop to create the same pattern.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">for i in range(3):</span>&#13;
       <span class="codestrong1">steve.fd(50)</span>&#13;
       <span class="codestrong1">steve.left(90)</span></pre>&#13;
<p class="indent">Here, <span class="literal">steve</span> moves forward 50 pixels and then turns to the left at a right angle. These steps are repeated three times by the <span class="literal">for</span> loop.</p>&#13;
<p class="indent">Other turtle methods let you change the shape of the turtle, change its color, lift the pen so no path is drawn, “stamp” its current position on the screen, set the heading of the turtle, and get its position on the screen. <a href="ch06.xhtml#ch06fig6">Figure 6-6</a> shows this functionality, which is described in the script that follows.<span epub:type="pagebreak" id="page_129"/></p>&#13;
<div class="image"><img src="../images/fig06_06.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch06fig6"/>Figure 6-6: More examples of turtle behaviors. Numbers refer to script annotations.</p>&#13;
<pre>&#13;
   &gt;&gt;&gt; import turtle&#13;
   &gt;&gt;&gt; steve = turtle.Turtle('turtle')&#13;
<span class="ent">➊</span> &gt;&gt;&gt; a_stamp = steve.stamp()&#13;
<span class="ent">➋</span> &gt;&gt;&gt; steve.position()&#13;
   <span class="ent">➌</span> (0.00,0.00)&#13;
   &gt;&gt;&gt; steve.fd(150)&#13;
<span class="ent">➍</span> &gt;&gt;&gt; steve.color('gray')&#13;
   &gt;&gt;&gt; a_stamp = steve.stamp()&#13;
   &gt;&gt;&gt; steve.left(45)&#13;
<span class="ent">➎</span> &gt;&gt;&gt; steve.bk(75)&#13;
   &gt;&gt;&gt; a_stamp = steve.stamp()&#13;
<span class="ent">➏</span> &gt;&gt;&gt; steve.penup()&#13;
   &gt;&gt;&gt; steve.bk(75)&#13;
   &gt;&gt;&gt; steve.color('black')&#13;
<span class="ent">➐</span> &gt;&gt;&gt; steve.setheading(180)&#13;
   &gt;&gt;&gt; a_stamp = steve.stamp()&#13;
<span class="ent">➑</span> &gt;&gt;&gt; steve.pendown()&#13;
   &gt;&gt;&gt; steve.fd(50)&#13;
<span class="ent">➒</span> &gt;&gt;&gt; steve.shape('triangle')</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_130"/>After importing the <span class="literal">turtle</span> module and instantiating a turtle object named <span class="literal">steve</span>, leave behind an image of <span class="literal">steve</span> using the <span class="literal">stamp()</span> method <span class="ent">➊</span>. Then use the <span class="literal">position()</span> method <span class="ent">➋</span> to get the turtle’s current (<em>x</em>, <em>y</em>) coordinates as a tuple <span class="ent">➌</span>. This will come in handy when calculating the distance between objects for the gravity equation.</p>&#13;
<p class="indent">Move the turtle forward 150 spaces and change its color to gray <span class="ent">➍</span>. Then leave a stamp behind, rotate the turtle 45 degrees, and move it backward 75 spaces using the <span class="literal">bk()</span> (backward) method <span class="ent">➎</span>.</p>&#13;
<p class="indent">Leave another stamp and then stop drawing the turtle’s path by using the <span class="literal">penup()</span> method <span class="ent">➏</span>. Move <span class="literal">steve</span> backward another 75 spaces and color him black. Now use an alternative to <span class="literal">rotate()</span>, which is to directly set the heading of the turtle <span class="ent">➐</span>. The heading is simply the direction the turtle is traveling. Note that the default “standard mode” directions are referenced to the east, not the north (<a href="ch06.xhtml#ch06table1">Table 6-1</a>).</p>&#13;
<p class="tabcap"><a id="ch06table1"/><strong>Table 6-1:</strong> Common Directions in Degrees for the <span class="literal">turtle</span> Module in Standard Mode</p>&#13;
<table class="topbot-d">&#13;
<tbody>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba">Degrees</p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba">Direction</p></th>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">East</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">90</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">North</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">180</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">West</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">270</p></td>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">South</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Leave another stamp and then put the pen down to once more draw a path behind the turtle <span class="ent">➑</span>. Move <span class="literal">steve</span> forward 50 spaces and then change his shape to a triangle <span class="ent">➒</span>. That completes the drawing.</p>&#13;
<p class="indent">Don’t be fooled by the simplicity of what we’ve done so far. With the right commands, you can draw intricate designs, such as the Penrose tiling in <a href="ch06.xhtml#ch06fig7">Figure 6-7</a>.</p>&#13;
<div class="image"><img src="../images/fig06_07.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch06fig7"/>Figure 6-7: A Penrose tiling produced by the <span class="literal">turtle</span> module demo, <span class="normal">penrose.py</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_131"/>The <span class="literal">turtle</span> module is part of the Python Standard Library, and you can find the official documentation at <em><a href="https://docs.python.org/3/library/turtle.html?highlight=turtle#module-turtle/">https://docs.python.org/3/library/turtle.html?highlight=turtle#module-turtle/</a></em>. For a quick tutorial, do an online search for Al Sweigart’s <em>Simple Turtle Tutorial for Python</em>.</p>&#13;
<h4 class="h4" id="ch00lev2sec34"><strong><em>The Strategy</em></strong></h4>&#13;
<p class="noindent">We’ve now made a strategic decision to use <span class="literal">turtle</span> to draw the simulation, but how should the simulation look? For convenience, I’d suggest basing it on <a href="ch06.xhtml#ch06fig3">Figure 6-3</a>. You’ll start with the CSM in the same parking orbit position around the earth (R<sub>0</sub>) and the moon at the same approximate phase angle (γ<sub>0</sub>). You can use images to represent the earth and the moon and custom <span class="literal">turtle</span> shapes to build the CSM.</p>&#13;
<p class="indent">Another big decision at this point is whether to use procedural or object-oriented programming (OOP). When you plan to generate multiple objects that behave similarly and interact with each other, OOP is a good choice. You can use an OOP class as a blueprint for the earth, the moon, and the CSM objects and automatically update the object attributes as the simulation runs.</p>&#13;
<p class="indent">You can run the simulation using <em>time steps</em>. Basically, each program loop will represent one unit of dimensionless time. With each loop, you’ll need to calculate each object’s position and update (redraw) it on the screen. This requires solving the three-body problem. Fortunately, not only has someone done this already, they’ve done it using <span class="literal">turtle</span>.</p>&#13;
<p class="indent">Python modules often include example scripts to show you how to use the product. For instance, the <span class="literal">matplotlib</span> gallery includes code snippets and tutorials for making a huge number of charts and plots. Likewise, the <span class="literal">turtle</span> module comes with <em>turtle-example-suite</em>, which includes demonstrations of <span class="literal">turtle</span> applications.</p>&#13;
<p class="indent">One of the demos, <em>planet_and_moon.py</em>, provides a nice “recipe” for handling a three-body problem in <span class="literal">turtle</span> (<a href="ch06.xhtml#ch06fig8">Figure 6-8</a>). To see the demos, open a PowerShell or terminal window and enter <span class="codestrong">python –m turtledemo</span>. Depending on your platform and how many versions of Python you have installed, you may need to use <span class="literal">python3 -m turtledemo</span>.</p>&#13;
<div class="image"><img src="../images/fig06_08.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch06fig8"/>Figure 6-8: Screen capture of the <span class="normal">planet_and_moon.py</span> <span class="literal">turtle</span> demo</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_132"/>This demo addresses the sun-earth-moon three-body problem, but it can be easily adapted to handle an earth-moon-CSM problem. Again, for the specific Apollo 8 situation, you’ll use <a href="ch06.xhtml#ch06fig3">Figure 6-3</a> to guide development of the program.</p>&#13;
<h4 class="h4" id="ch00lev2sec35"><strong><em>The Apollo 8 Free Return Code</em></strong></h4>&#13;
<p class="noindent">The <em>apollo_8_free_return.py</em> program uses <span class="literal">turtle</span> graphics to generate a top-down view of the Apollo 8 CSM leaving the earth’s orbit, circling the moon, and returning to the earth. The core of the program is based on the <em>planet_and_moon.py</em> demo discussed in the previous section.</p>&#13;
<p class="indent">You can find the program in the <em>Chapter_6</em> folder, downloadable from the book’s website at <em><a href="https://nostarch.com/real-world-python/">https://nostarch.com/real-world-python/</a></em>. You’ll also need the earth and moon images found there (<a href="ch06.xhtml#ch06fig9">Figure 6-9</a>). Be sure to keep them in the same folder as the code and don’t rename them.</p>&#13;
<div class="image"><img src="../images/fig06_09.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch06fig9"/>Figure 6-9: <span class="normal">earth_100x100.gif</span> and <span class="normal">moon_27x27.gif</span> images used in the simulation</p>&#13;
<h5 class="h5"><strong>Importing turtle and Assigning Constants</strong></h5>&#13;
<p class="noindent"><a href="ch06.xhtml#ch06list1">Listing 6-1</a> imports the <span class="literal">turtle</span> module and assigns constants that represent key parameters: the gravitational constant, the number of times to run the main loop, and the <em>x</em> and <em>y</em> values for R<sub>0</sub> and V<sub>0</sub> (see <a href="ch06.xhtml#ch06fig3">Figure 6-3</a>). Listing these values near the top of the program makes them easy to find and alter later.</p>&#13;
<pre><span class="codeitalic1">apollo_8_free_return.py</span>, part 1 &#13;
from turtle import Shape, Screen, Turtle, Vec2D as Vec&#13;
&#13;
# User input:&#13;
G = 8 &#13;
NUM_LOOPS = 4100 &#13;
Ro_X = 0 &#13;
Ro_Y = -85 &#13;
Vo_X = 485 &#13;
Vo_Y = 0</pre>&#13;
<p class="listing"><a id="ch06list1"/>Listing 6-1: Importing <span class="literal">turtle</span> and assigning constants</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_133"/>You’ll need to import four helper classes from <span class="literal">turtle</span>. You’ll use the <span class="literal">Shape</span> class to make a custom turtle that looks like the CSM. The <span class="literal">Screen</span> subclass makes the screen, called a <em>drawing board</em> in <span class="literal">turtle</span> parlance. The <span class="literal">Turtle</span> subclass creates the turtle objects. The <span class="literal">Vec2D</span> import is a two-dimensional vector class. It will help you define velocity as a vector of magnitude and direction.</p>&#13;
<p class="indent">Next, assign some variables that the user may want to tweak later. Start with the gravitational constant, used in Newton’s gravity equations to ensure the units come out right. Assign it <span class="literal">8</span>, the value used in the <span class="literal">turtle</span> demo. Think of this as a <em>scaled</em> gravitational constant. You can’t use the true constant, as the simulation doesn’t use real-world units.</p>&#13;
<p class="indent">You’ll run the simulation in a loop, and each iteration will represent a time step. With each step, the program will recalculate the position of the CSM as it moves through the gravity fields of the earth and the moon. The value of <span class="literal">4100</span>, arrived at by trial and error, will stop the simulation just after the spacecraft arrives back on the earth.</p>&#13;
<p class="indent">In 1968, a round-trip to the moon took about six days. Since you’re incrementing the time unit by 0.001 with each loop and running 4,100 loops, this means a time step in the simulation represents about two minutes of time in the real world. The longer the time step, the faster the simulation but the less accurate the results, as small errors compound over time. In actual fight path simulations, you can optimize the time step by first running a small step, for maximum accuracy, and then using the results to find the largest time step that yields a similar result.</p>&#13;
<p class="indent">The next two variables, <span class="literal">Ro_X</span> and <span class="literal">Ro_Y</span>, represent the (<em>x</em>, <em>y</em>) coordinates of the CSM at the time of the translunar injection (see <a href="ch06.xhtml#ch06fig3">Figure 6-3</a>). Likewise, <span class="literal">Vo_X</span> and <span class="literal">Vo_Y</span> represent the <em>x</em>- and <em>y</em>-direction components of the translunar injection velocity, which is applied by the third stage of the <em>Saturn V</em> rocket. These values started out as best guesses and were refined with repeated simulations.</p>&#13;
<h5 class="h5"><strong>Creating a Gravity System</strong></h5>&#13;
<p class="noindent">Because the earth, the moon, and CSM form a continuously interacting gravity system, you’ll want a convenient way to represent them and their respective forces. For this, you’ll need two classes, one to create a gravity system and one to create the bodies within it. <a href="ch06.xhtml#ch06list2">Listing 6-2</a> defines the <span class="literal">GravSys</span> class that helps you create a mini solar system. This class will use a list to keep track of all the bodies in motion and loop them through a series of time steps. It’s based on the <em>planet_and_moon.py</em> demo in the <span class="literal">turtle</span> library.</p>&#13;
<pre><span class="codeitalic1">apollo_8_free_return.py</span>, part 2&#13;
class GravSys():&#13;
    """Runs a gravity simulation on n-bodies."""&#13;
  &#13;
    def __init__(self):&#13;
        self.bodies = []&#13;
        self.t = 0&#13;
        self.dt = 0.001    &#13;
      &#13;
 <span epub:type="pagebreak" id="page_134"/><span class="ent">➊</span> def sim_loop(self):&#13;
        """Loop bodies in a list through time steps."""&#13;
        for _ in range(NUM_LOOPS):&#13;
            self.t += self.dt&#13;
            for body in self.bodies:&#13;
                body.step()</pre>&#13;
<p class="listing"><a id="ch06list2"/>Listing 6-2: Defining a class to manage the bodies in the gravity system</p>&#13;
<p class="indent">The <span class="literal">GravSys</span> class defines how long the simulation will run, how much time will pass between time steps (loops), and what bodies will be involved. It also calls the <span class="literal">step()</span> method of the <span class="literal">Body</span> class you’ll define in <a href="ch06.xhtml#ch06list3">Listing 6-3</a>. This method will update each body’s position as a result of gravitational acceleration.</p>&#13;
<p class="indent">Define the initialization method and, as per convention, pass it <span class="literal">self</span> as a parameter. The <span class="literal">self</span> parameter represents the <span class="literal">GravSys</span> object you’ll create later in the <span class="literal">main()</span> function.</p>&#13;
<p class="indent">Create an empty list named <span class="literal">bodies</span> to hold the earth, the moon, and the CSM objects. Then assign attributes for when the simulation starts and the amount to increment time with each loop, known as <em>delta time</em> or <span class="literal">dt</span>. Set the starting time to <span class="literal">0</span> and set the <span class="literal">dt</span> time step to <span class="literal">0.001</span>. As discussed in the previous section, this time step will correspond to about two minutes in the real world and will produce a smooth, accurate, and fast simulation.</p>&#13;
<p class="indent">The last method controls the time steps in the simulation <span class="ent">➊</span>. It uses a <span class="literal">for</span> loop with the range set to the <span class="literal">NUM_LOOPS</span> variable. Use a single underscore (<span class="literal">_</span>) rather than <span class="literal">i</span> to indicate the use of an insignificant variable (see <a href="ch05.xhtml#ch05list3">Listing 5-3</a> in <a href="ch05.xhtml">Chapter 5</a> for details).</p>&#13;
<p class="indent">With each loop, increment the gravity system’s time variable by <span class="literal">dt</span>. Then, apply the time shift to each body by looping through the list of bodies and calling the <span class="literal">body.step()</span> method, which you’ll define later within the <span class="literal">Body</span> class. This method updates the position and velocity of the bodies due to gravitational attraction.</p>&#13;
<h5 class="h5"><strong>Creating Celestial Bodies</strong></h5>&#13;
<p class="noindent"><a href="ch06.xhtml#ch06list3">Listing 6-3</a> defines the <span class="literal">Body</span> class used to build the earth, the moon, and the CSM <span class="literal">Body</span> objects. Although no one would ever mistake a planet for a small spacecraft, they’re not that different from a gravitational standpoint, and you can stamp them both out of the same mold.</p>&#13;
<pre><span class="codeitalic1">apollo_8_free_return.py</span>, part 3&#13;
class Body(Turtle): &#13;
    """Celestial object that orbits and projects gravity field.""" &#13;
    def __init__(self, mass, start_loc, vel, gravsys, shape):&#13;
        super().__init__(shape=shape)&#13;
        self.gravsys = gravsys&#13;
        self.penup()&#13;
        self.mass = mass&#13;
        self.setpos(start_loc)&#13;
        self.vel = vel&#13;
        <span epub:type="pagebreak" id="page_135"/>gravsys.bodies.append(self)&#13;
        #self.resizemode("user")&#13;
        #self.pendown()  # Uncomment to draw path behind object.</pre>&#13;
<p class="listing"><a id="ch06list3"/>Listing 6-3: Defining a class to create objects for the earth, the moon, and the CSM</p>&#13;
<p class="indent">Define a new class by using the <span class="literal">Turtle</span> class as its <em>ancestor</em>. This means the <span class="literal">Body</span> class will conveniently inherit all the <span class="literal">Turtle</span> class’s methods and attributes.</p>&#13;
<p class="indent">Next, define an initializer method for the body object. You’ll use this to create new <span class="literal">Body</span> objects in the simulation, a process called <em>instantiation</em> in OOP. As parameters, the initialize method takes itself, a mass attribute, a starting location, a starting velocity, the gravity system object, and a shape.</p>&#13;
<p class="indent">The <span class="literal">super()</span> function lets you invoke the method of a superclass to gain access to inherited methods from the ancestor class. This allows your <span class="literal">Body</span> objects to use attributes from the prebuilt <span class="literal">Turtle</span> class. Pass it the <span class="literal">shape</span> attribute, which will allow you to pass a custom shape or image to your bodies when you build them in the <span class="literal">main()</span> function.</p>&#13;
<p class="indent">Next, assign an instance attribute for the <span class="literal">gravsys</span> object. This will allow the gravity system and body to interact. Note that it’s best to initialize attributes through the <span class="literal">__init__()</span> method, as we do in this case, since it’s the first method called after the object is created. This way, these attributes will be immediately available to any other methods in the class, and other developers can see a list of all the attributes in one place.</p>&#13;
<p class="indent">The following <span class="literal">penup()</span> method of the <span class="literal">Turtle</span> class will remove the drawing pen so the object doesn’t leave a path behind it as it moves. This gives you the option of running the simulation with and without visible orbital paths.</p>&#13;
<p class="indent">Initialize a <span class="literal">mass</span> attribute for the body. You’ll need this to calculate the force of gravity. Next, assign the body’s starting position using the <span class="literal">setpos()</span> method of the <span class="literal">Turtle</span> class. The starting position of each body will be an (<em>x</em>, <em>y</em>) tuple. The origin point (0, 0) will be at the center of the screen. The <em>x</em>-coordinate increases to the right, and the <em>y</em>-coordinate increases upward.</p>&#13;
<p class="indent">Assign an initialization attribute for velocity. This will hold the starting velocity for each object. For the CSM, this value will change throughout the simulation as the ship moves through the gravity fields of the earth and the moon.</p>&#13;
<p class="indent">As each body is instantiated, use dot notation to append it to the list of bodies in the gravity system. You’ll create the <span class="literal">gravsys</span> object from the <span class="literal">GravSys()</span> class in the <span class="literal">main()</span> function.</p>&#13;
<p class="indent">The final two lines, commented out, allow the user to change the simulation window size and choose to draw a path behind each object. Start out with a full-screen display and keep the pen in the up position to let the simulation run quickly.</p>&#13;
<h5 class="h5"><strong>Calculating Acceleration Due to Gravity</strong></h5>&#13;
<p class="noindent">The Apollo 8 simulation will begin immediately after the translunar injection. At this point, the third stage of the <em>Saturn V</em>   has fired and fallen away, and the CSM is beginning its coast to the moon. All changes in velocity or direction will be entirely due to changes in gravitational force.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_136"/>The method in <a href="ch06.xhtml#ch06list4">Listing 6-4</a> loops through the bodies in the bodies list, calculates acceleration due to gravity for each body, and returns a vector representing the body’s acceleration in the <em>x</em> and <em>y</em> directions.</p>&#13;
<pre><span class="codeitalic1">apollo_8_free_return.py</span>, part 4&#13;
    def acc(self):&#13;
        """Calculate combined force on body and return vector components."""&#13;
        a = Vec(0, 0)&#13;
        for body in self.gravsys.bodies:&#13;
            if body != self:&#13;
                r = body.pos() - self.pos()&#13;
                a += (G * body.mass / abs(r)**3) * r&#13;
        return a</pre>&#13;
<p class="listing"><a id="ch06list4"/>Listing 6-4: Calculating acceleration due to gravity</p>&#13;
<p class="indent">Still within the <span class="literal">Body</span> class, define the acceleration method, called <span class="literal">acc()</span>, and pass it <span class="literal">self</span>. Within the method, name a local variable <span class="literal">a</span>, again for acceleration, and assign it to a vector tuple using the <span class="literal">Vec2D</span> helper class. A 2D vector is a pair of real numbers (<em>a</em>, <em>b</em>), which in this case represent <em>x</em> and <em>y</em> components, respectively. The <span class="literal">Vec2D</span> helper class enforces rules that permit easy mathematical operations using vectors, as follows:</p>&#13;
<ul>&#13;
<li class="noindent">(<em>a</em>, <em>b</em>) + (<em>c</em>, <em>d</em>) = (<em>a</em> + <em>c</em>, <em>b</em> + <em>d</em>)</li>&#13;
<li class="noindent">(<em>a</em>, <em>b</em>) – (<em>c</em>, <em>d</em>) = (<em>a</em> – <em>c</em>, <em>b</em> – <em>d</em>)</li>&#13;
<li class="noindent">(<em>a</em>, <em>b</em>) × (<em>c</em>, <em>d</em>) = <em>ac</em> + <em>bd</em></li>&#13;
</ul>&#13;
<p class="indent">Next, start looping through the items in the <span class="literal">bodies</span> list, which contains the earth, the moon, and the CSM. You’ll use the gravitational force of each body to determine the acceleration of the object for which you’re calling the <span class="literal">acc()</span> method. It doesn’t make sense for a body to accelerate itself, so exclude the body if it’s the same as <span class="literal">self</span>.</p>&#13;
<p class="indent">To calculate gravitational acceleration (stored in the <span class="literal">g</span> variable) at a point in space, you’ll use the following formula:</p>&#13;
<div class="image1"><img src="../images/equ_page_136_01.jpg" alt="Image"/></div>&#13;
<p class="noindent">where <em>M</em> is the mass of the attracting body, <em>r</em> is the distance (radius) between bodies, <em>G</em> is the gravitational constant you defined earlier, and <em>r</em>  is the unit vector from the center of mass of the attracting body to the center of mass of the body being accelerated. The <em>unit vector</em>, also known as the <em>direction vector</em> or <em>normalized vector</em>, can be described as <em>r/|r|</em>, or:</p>&#13;
<div class="image1"><img src="../images/equ_page_136_02.jpg" alt="Image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_137"/>The unit vector allows you to capture the direction of acceleration, which will be either positive or negative. To calculate the unit vector, you’ll have to calculate the distance between bodies by using the <span class="literal">turtle</span> <span class="literal">pos()</span> method to get each body’s current position as a <span class="literal">Vec2D</span> vector. As described previously, this is a tuple of the (<em>x</em>, <em>y</em>) coordinates.</p>&#13;
<p class="indent">You’ll then input that tuple into the acceleration equation. Each time you loop through a new body, you’ll change the <span class="literal">a</span> variable based on the gravitational pull of the body being examined. For example, while the earth’s gravity may slow the CSM, the moon’s gravity may pull in the opposite direction and cause it to speed up. The <span class="literal">a</span> variable will capture the net effect at the end of the loop. Complete the method by returning <span class="literal">a</span>.</p>&#13;
<h5 class="h5"><strong>Stepping Through the Simulation</strong></h5>&#13;
<p class="noindent"><a href="ch06.xhtml#ch06list5">Listing 6-5</a>, still in the <span class="literal">Body</span> class, defines a method to solve the three-body problem. It updates the position, orientation, and velocity of bodies in the gravity system with each time step. The shorter the time steps, the more accurate the solution, though at the cost of computational efficiency.</p>&#13;
<pre><span class="codeitalic1">apollo_8_free_return.py</span>, part 5&#13;
def step(self):&#13;
    """Calculate position, orientation, and velocity of a body."""&#13;
    dt = self.gravsys.dt&#13;
    a = self.acc()&#13;
    self.vel = self.vel + dt * a&#13;
    self.setpos(self.pos() + dt * self.vel)&#13;
 <span class="ent">➊</span> if self.gravsys.bodies.index(self) == 2:  # Index 2 = CSM.&#13;
        rotate_factor = 0.0006&#13;
        self.setheading((self.heading() - rotate_factor * self.xcor()))&#13;
     <span class="ent">➋</span> if self.xcor() &lt; -20: &#13;
            self.shape('arrow')&#13;
            self.shapesize(0.5)&#13;
            self.setheading(105)</pre>&#13;
<p class="listing"><a id="ch06list5"/>Listing 6-5: Applying the time step and rotating the CSM</p>&#13;
<p class="indent">Define a <span class="literal">step()</span> method to calculate position, orientation, and velocity of a body. Assign it <span class="literal">self</span> as an argument.</p>&#13;
<p class="indent">Within the method definition, set a local variable, <span class="literal">dt</span>, to the <span class="literal">gravsys</span> object of the same name. This variable has no link to any real-time system; it’s just a floating-point number that you’ll use to increment velocity with each time step. The larger the <span class="literal">dt</span> variable is, the faster the simulation will run.</p>&#13;
<p class="indent">Now call the <span class="literal">self.acc()</span> method to calculate the acceleration that the current body experiences due to the combined gravitational fields of the other bodies. This method returns a vector tuple of (<em>x</em>, <em>y</em>) coordinates. Multiply it by <span class="literal">dt</span> and add the results to <span class="literal">self.vel()</span>, which is also a vector, to update the body’s velocity for the current time step. Recall that, behind the scenes, the <span class="literal">Vec2D</span> class will manage the vector arithmetic.</p>&#13;
<p class="indent">To update the body’s position in the <span class="literal">turtle</span> graphics window, multiply the body’s velocity by the time step and add the result to the body’s position attribute. Now each body will move according to the gravitational pull of the other bodies. You just solved the three-body problem!</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_138"/>Next, add some code to refine the CSM’s behavior. Thrust comes out of the back of the CSM, so in real missions, the rear of the spacecraft is oriented toward its target. This way, the engine can fire and slow the ship enough to enter lunar orbit or the earth’s atmosphere. Orienting the ship this way isn’t necessary with a free return trajectory, but since Apollo 8 planned to fire its engines and enter lunar orbit (and did), you should orient the ship properly throughout its journey.</p>&#13;
<p class="indent">Start by selecting the CSM from the list of bodies <span class="ent">➊</span>. In the <span class="literal">main()</span> function, you’ll create the bodies in order of size, so the CSM will be the third item in the list, at index <span class="literal">2</span>.</p>&#13;
<p class="indent">To get the CSM to rotate as it coasts through space, assign a small number to a local variable named <span class="literal">rotate_factor</span>. I arrived at this number through trial and error. Next, set the heading of the CSM turtle object using its <span class="literal">selfheading</span> attribute. Instead of passing it (<em>x</em>, <em>y</em>) coordinates, call the <span class="literal">self.heading()</span> method, which returns the object’s current heading in degrees, and subtract from it the <span class="literal">rotate_factor</span> variable multiplied by the body’s current <em>x</em> location, obtained by calling the <span class="literal">self.xcor()</span> method. This will cause the CSM to rotate faster as it approaches the moon to keep its tail pointed in the direction of travel.</p>&#13;
<p class="indent">You’ll need to eject the service module before the spacecraft enters the earth’s atmosphere. To do this at a position similar to that in real Apollo missions, use another conditional to check the spacecraft’s <em>x</em>-coordinate <span class="ent">➋</span>. The simulation expects the earth to be near the center of the screen, at coordinates (0, 0). In <span class="literal">turtle</span>, the <em>x</em>-coordinate will decrease as you move left of the center and increase as you move to the right. If the CSM’s <em>x</em>-coordinate is less than –20 pixels, you can assume that it’s returning home and that it’s time to part company with the service module.</p>&#13;
<p class="indent">You’ll model this event by changing the shape of the <span class="literal">turtle</span> representing the CSM. Since <span class="literal">turtle</span> includes a standard shape—called <span class="literal">arrow</span>—that looks similar to the command module, all you need to do now is call the <span class="literal">self.shape()</span> method and pass it the name of the shape. Then call the <span class="literal">self.shapesize()</span> method and halve the size of the arrow to make it match the command module in the CSM custom shape, which you’ll make later. When the CSM passes the –20 <em>x</em>-position, the service module will magically disappear, leaving the command module to complete the voyage home.</p>&#13;
<p class="indent">Finally, you’ll want to orient the base of the command module, with its heat-resistant shielding, toward the earth. Do this by setting the arrow shape’s heading to 105 degrees.</p>&#13;
<h5 class="h5"><strong>Defining main(), Setting Up the Screen, and Instantiating the Gravity System</strong></h5>&#13;
<p class="noindent">You used object-oriented programming to build the gravity system and the bodies within it. To run the simulation, you’ll return to procedural programming and use a <span class="literal">main()</span> function. This function sets up the <span class="literal">turtle</span> graphics screen, instantiates objects for the gravity system and the three bodies, builds a custom shape for the CSM, and calls the gravity system’s <span class="literal">sim_loop()</span> method to walk through the time steps.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_139"/><a href="ch06.xhtml#ch06list6">Listing 6-6</a> defines <span class="literal">main()</span> and sets up the screen. It also creates a gravity system object to manage your mini solar system.</p>&#13;
<pre><span class="codeitalic1">apollo_8_free_return.py</span>, part 6&#13;
def main():  &#13;
    screen = Screen()&#13;
    screen.setup(width=1.0, height=1.0) # For fullscreen.&#13;
    screen.bgcolor('black')&#13;
    screen.title("Apollo 8 Free Return Simulation")&#13;
    &#13;
    gravsys = GravSys()</pre>&#13;
<p class="listing"><a id="ch06list6"/>Listing 6-6: Setting up the screen and making a <span class="literal">gravsys</span> object in <span class="literal">main()</span></p>&#13;
<p class="indent">Define <span class="literal">main()</span> and then instantiate a <span class="literal">screen</span> object (a drawing window) based on the <span class="literal">TurtleScreen</span> subclass. Then invoke the <span class="literal">screen</span> object’s <span class="literal">setup()</span> method to set the size of <span class="literal">screen</span> to full. Do this by passing <span class="literal">width</span> and <span class="literal">height</span> arguments of <span class="literal">1</span>.</p>&#13;
<p class="indent">If you don’t want the drawing window to take up the full screen, pass <span class="literal">setup()</span> the pixel arguments shown in the following snippet:</p>&#13;
<pre>screen.setup(width=800, height=900, startx=100, starty=0)</pre>&#13;
<p class="indent">Note that a negative <span class="literal">startx</span> value uses right justification, a negative <span class="literal">starty</span> uses bottom alignment, and the default settings create a centered window. Feel free to experiment with these parameters to get the best fit to your monitor.</p>&#13;
<p class="indent">Complete setting up the screen by setting its background color to black and giving it a title. Next, instantiate a gravity system object, <span class="literal">gravsys</span>, using the <span class="literal">GravSys</span> class. This object will give you access to the attributes and methods in the <span class="literal">GravSys</span> class. You’ll pass it to each body when you instantiate them shortly.</p>&#13;
<h5 class="h5"><strong>Creating the Earth and Moon</strong></h5>&#13;
<p class="noindent"><a href="ch06.xhtml#ch06list7">Listing 6-7</a>, still in the <span class="literal">main()</span> function, creates turtle objects for the earth and the moon using the <span class="literal">Body</span> class you defined earlier. The earth will remain stationary at the center of the screen, while the moon will revolve around the earth.</p>&#13;
<p class="indent">When you create these objects, you’ll set their starting coordinates. The starting position of the earth is near the center of the screen, biased downward a bit to give the moon and CSM room to interact near the top of the window.</p>&#13;
<p class="indent">The starting position of the moon and CSM should reflect what you see in <a href="ch06.xhtml#ch06fig3">Figure 6-3</a>, with the CSM vertically beneath the center of the earth. This way, you only need to thrust in the <em>x</em> direction, rather than calculate a vector component velocity that includes some movement in the <em>x</em> direction and some in the <em>y</em> direction.</p>&#13;
<pre><span class="codeitalic1">apollo_8_free_return.py</span>, part 7&#13;
   image_earth = 'earth_100x100.gif'&#13;
   screen.register_shape(image_earth)&#13;
   earth = Body(1000000, (0, -25), Vec(0, -2.5), gravsys, image_earth)&#13;
   earth.pencolor('white')&#13;
   earth.getscreen().tracer(n=0, delay=0) &#13;
&#13;
<span class="ent">➊</span> image_moon = 'moon_27x27.gif'&#13;
   screen.register_shape(image_moon)&#13;
   moon = Body(32000, (344, 42), Vec(-27, 147), gravsys, image_moon)&#13;
   moon.pencolor('gray')</pre>&#13;
<p class="listing"><a id="ch06list7"/>Listing 6-7: Instantiating turtles for the earth and moon</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_140"/>Start by assigning the image of the earth, which is included in the folder for this project, to a variable. Note that images should be <em>gif</em> files and cannot be rotated to show the turtle’s heading. So that <span class="literal">turtle</span> recognizes the new shape, add it to the <span class="literal">TurtleScreen</span> <span class="literal">shapelist</span> using the <span class="literal">screen.register_shape()</span> method. Pass it the variable that references the earth image.</p>&#13;
<p class="indent">Now it’s time to instantiate the turtle object for the earth. You call the <span class="literal">Body</span> class and pass it the arguments for mass, starting position, starting velocity, gravity system, and turtle shape—in this case, the image. Let’s talk about each of these arguments in more detail.</p>&#13;
<p class="indent">You’re not using real-world units here, so mass is an arbitrary number. I started with the value used for the sun in the <span class="literal">turtle</span> demo <em>planet_and_moon.py</em>, on which this program is based.</p>&#13;
<p class="indent">The starting position is an (<em>x</em>, <em>y</em>) tuple that places the earth near the center of the screen. It’s biased downward 25 pixels, however, as most of the action will take place in the upper quadrant of the screen. This placement will provide a little more room in that region.</p>&#13;
<p class="indent">The starting velocity is a simple (<em>x</em>, <em>y</em>) tuple provided as an argument to the <span class="literal">Vec2D</span> helper class. As discussed previously, this will allow later methods to alter the velocity attribute using vector arithmetic. Note that the earth’s velocity is not <span class="literal">(0, 0)</span>, but <span class="literal">(0, -2.5)</span>. In real life and in the simulation, the moon is massive enough to affect the earth so that the center of gravity between the two is not at the center of the earth, but farther out. This will cause the earth turtle to wobble and shift positions in a distracting manner during the simulation. Because the moon will be in the upper part of the screen during simulation, shifting the earth downward a small amount each time step will dampen the wobbling.</p>&#13;
<p class="indent">The last two arguments are the <span class="literal">gravsys</span> object you instantiated in the previous listing and the image variable for the earth. Passing <span class="literal">gravsys</span> means the earth turtle will be added to the list of bodies and included in the <span class="literal">sim_loop()</span> class method.</p>&#13;
<p class="indent">Note that if you don’t want to use a lot of arguments when instantiating an object, you can change an object’s attributes after it’s created. For example, when defining the <span class="literal">Body</span> class, you could’ve set <span class="literal">self.mass = 0</span>, rather than using an argument for mass. Then, after instantiating the earth body, you could reset the mass value using <span class="literal">earth.mass = 1000000</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_141"/>Because the earth wobbles a little, its orbital path will form a tight circle at the top of the planet. To hide it in the polar cap, use the <span class="literal">turtle</span> <span class="literal">pencolor()</span> method and set the line color to <span class="literal">white</span>.</p>&#13;
<p class="indent">Finish the earth turtle with code that delays the start of the simulation and prevents the various turtles from flashing on the screen as the program first draws and resizes them. The <span class="literal">getscreen()</span> method returns the <span class="literal">TurtleScreen</span> object the turtle is drawing on. <span class="literal">TurtleScreen</span> methods can then be called for that object. In the same line, call the <span class="literal">tracer()</span> method that turns the turtle animation on or off and sets a delay for drawing updates. The <em>n</em> parameter determines the number of times the screen updates. A value of 0 means the screen updates with every loop; larger values progressively repress the updates. This can be used to accelerate the drawing of complex graphics, but at the cost of image quality. The second argument sets a delay value, in milliseconds, between screen updates. Increasing the delay slows the animation.</p>&#13;
<p class="indent">You’ll build the moon turtle in a similar fashion to the one for the earth. Start by assigning a new variable to hold the moon image <span class="ent">➊</span>. The moon’s mass is only a few percent of the earth’s mass, so use a much smaller value for the moon. I started out with a mass of around 16,000 and tweaked the value until the CSM’s flight path produced a visually pleasing loop around the moon.</p>&#13;
<p class="indent">The moon’s starting position is controlled by the phase angle shown in <a href="ch06.xhtml#ch06fig3">Figure 6-3</a>. Like this figure, the simulation you’re creating here is not to scale. Although the earth and moon images will have the correct relative sizes, the distance between the two is smaller than the actual distance, so the phase angle will need to be adjusted accordingly. I’ve reduced the distance in the model because space is big. Really big. If you want to show the simulation to scale and fit it all on your computer monitor, then you must settle for a ridiculously tiny earth and moon (<a href="ch06.xhtml#ch06fig10">Figure 6-10</a>).</p>&#13;
<div class="image"><img src="../images/fig06_10.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch06fig10"/>Figure 6-10: Earth and moon system at closest approach, or <span class="normal">perigee</span>, shown to scale</p>&#13;
<p class="indent">To keep the two bodies recognizable, you’ll instead use larger, properly scaled images but reduce the distance between them (<a href="ch06.xhtml#ch06fig11">Figure 6-11</a>). This configuration will be more relatable to the viewer and still allow you to replicate the free return trajectory.</p>&#13;
<p class="indent">Because the earth and the moon are closer together in the simulation, the moon’s orbital velocity will be faster than in real life, as per Kepler’s second law of planetary motion. To compensate for this, the moon’s starting position is designed to reduce the phase angle compared to that shown in <a href="ch06.xhtml#ch06fig3">Figure 6-3</a>.</p>&#13;
<div class="image"><img src="../images/fig06_11.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch06fig11"/>Figure 6-11: The earth and moon system in the simulation, with only the body sizes at the correct scale</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_142"/>Finally, you’ll want the option to draw a line behind the moon to trace its orbit. Use the <span class="literal">turtle</span> <span class="literal">pencolor()</span> method and set the line color to <span class="literal">gray</span>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Parameters such as mass, initial position, and initial velocity are good candidates for global constants. Despite this, I chose to enter them as method arguments to avoid overloading the user with too many input variables at the start of the program.</em></p>&#13;
</div>&#13;
<h5 class="h5"><strong>Building a Custom Shape for the CSM</strong></h5>&#13;
<p class="noindent">Now it’s time to instantiate a turtle object to represent the CSM. This requires a little more work than the last two objects.</p>&#13;
<p class="indent">First, there’s no way to show the CSM at the same scale as the earth and the moon. To do that, you’d need <em>less than</em> a pixel, which is impossible. Plus, where’s the fun in that? So, once again, you’ll take liberties with scale and make the CSM large enough to be recognizable as an Apollo spacecraft.</p>&#13;
<p class="indent">Second, you won’t use an image for the CSM, as you did with the other two bodies. Because image shapes don’t automatically rotate when a turtle turns and you want to orient the CSM tail-first through most of its journey, you must instead customize your own shape.</p>&#13;
<p class="indent"><a href="ch06.xhtml#ch06list8">Listing 6-8</a>, still in <span class="literal">main()</span>, builds a representation of the CSM by drawing basic shapes, such as rectangles and triangles. You then combine these individual primitives into a final compound shape.</p>&#13;
<pre><span class="codeitalic1">apollo_8_free_return.py</span>, part 8&#13;
csm = Shape('compound')&#13;
cm = ((0, 30), (0, -30), (30, 0))&#13;
csm.addcomponent(cm, 'white', 'white')&#13;
sm = ((-60, 30), (0, 30), (0, -30), (-60, -30))&#13;
csm.addcomponent(sm, 'white', 'black')  &#13;
nozzle = ((-55, 0), (-90, 20), (-90, -20))&#13;
csm.addcomponent(nozzle, 'white', 'white')&#13;
screen.register_shape('csm', csm)</pre>&#13;
<p class="listing"><a id="ch06list8"/>Listing 6-8: Building a custom shape for the CSM turtle</p>&#13;
<p class="indent">Name a variable <span class="literal">csm</span> and call the <span class="literal">turtle</span> <span class="literal">Shape</span> class. Pass it <span class="literal">'compound'</span>, indicating you want to build the shape using multiple components.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_143"/>The first component will be the command module. Name a variable <span class="literal">cm</span> and assign it to a tuple of coordinate pairs, known as a <em>polygon type</em> in <span class="literal">turtle</span>. These coordinates build a triangle, as shown in <a href="ch06.xhtml#ch06fig12">Figure 6-12</a>.</p>&#13;
<div class="image"><img src="../images/fig06_12.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch06fig12"/>Figure 6-12: CSM compound shape with coordinates for nozzle, service module, and command module</p>&#13;
<p class="indent">Add this triangle component to the <span class="literal">csm</span> shape using the <span class="literal">addcomponent()</span> method, called with dot notation. Pass it the <span class="literal">cm</span> variable, a fill color, and an outline color. Good fill colors are white, silver, gray, or red.</p>&#13;
<p class="indent">Repeat this general process for the service module rectangle. Set the outline color to <span class="literal">black</span> when you add the component to delineate the service and command modules (see <a href="ch06.xhtml#ch06fig12">Figure 6-12</a>).</p>&#13;
<p class="indent">Use another triangle for the nozzle, also called the <em>engine bell</em>. Add the component and then register the new <span class="literal">csm</span> compound shape to the screen. Pass the method a name for the shape and then the variable referencing the shape.</p>&#13;
<h5 class="h5"><strong>Creating the CSM, Starting the Simulation, and Calling main()</strong></h5>&#13;
<p class="noindent"><a href="ch06.xhtml#ch06list9">Listing 6-9</a> completes the <span class="literal">main()</span> function by instantiating a turtle for the CSM and calling the simulation loop that runs the time steps. It then calls <span class="literal">main()</span> if the program is run in stand-alone mode.</p>&#13;
<pre><span class="codeitalic1">apollo_8_free_return.py</span>, part 9&#13;
    ship = Body(1, (Ro_X, Ro_Y), Vec(Vo_X, Vo_Y), gravsys, 'csm')&#13;
    ship.shapesize(0.2)&#13;
    ship.color('white')&#13;
    ship.getscreen().tracer(1, 0)&#13;
    ship.setheading(90)&#13;
&#13;
    gravsys.sim_loop()&#13;
&#13;
if __name__ == '__main__':&#13;
    main()</pre>&#13;
<p class="listing"><a id="ch06list9"/>Listing 6-9: Instantiating a CSM turtle, calling the simulation loop and <span class="literal">main()</span></p>&#13;
<p class="indent">Create a turtle named <span class="literal">ship</span> to represent the CSM. The starting position is an (<em>x</em>, <em>y</em>) tuple that places the CSM in a parking orbit directly below the earth on the screen. I first approximated the proper height for the parking orbit (R<sub>0</sub> in <a href="ch06.xhtml#ch06fig3">Figure 6-3</a>) and then fine-tuned it by repeatedly running the simulation. <span epub:type="pagebreak" id="page_144"/>Note that you use the constants assigned at the start of the program, rather than actual values. This is to make it easier for you to experiment with these values later.</p>&#13;
<p class="indent">The velocity argument (<span class="literal">Vo_X</span>, <span class="literal">Vo_Y</span>) represents the speed of the CSM at the moment the Saturn third stage stops firing during translunar injection. All the thrust is in the <em>x</em> direction, but the earth’s gravity will cause the flight path to immediately curve upward. Like the R<sub>0</sub> parameter, a best-guess velocity was input and refined through simulation. Note that the velocity is a tuple input using the <span class="literal">Vec2D</span> helper class, which allows later methods to alter the velocity using vector arithmetic.</p>&#13;
<p class="indent">Next, set the size of the <span class="literal">ship</span> turtle using the <span class="literal">shapesize()</span> method. Then set its path color to <span class="literal">white</span> so it will match the <span class="literal">ship</span> color. Other attractive colors are silver, gray, and red.</p>&#13;
<p class="indent">Control the screen updates with the <span class="literal">getscreen()</span> and <span class="literal">tracer()</span> methods, described in <a href="ch06.xhtml#ch06list7">Listing 6-7</a>, and then set the ship’s heading to 90 degrees, which will point it due east on the screen.</p>&#13;
<p class="indent">That completes the body objects. Now all that’s left is to launch the simulation loop, using the <span class="literal">gravsys</span> object’s <span class="literal">sim_loop()</span> method. Back in the global space, finish the program with the code to run the program as an imported module or in stand-alone mode.</p>&#13;
<p class="indent">As the program is currently written, you’ll have to manually close the Turtle Graphics window. If you want the window to close automatically, add the following command as the last line in <span class="literal">main()</span>:</p>&#13;
<pre>screen.bye()</pre>&#13;
<h4 class="h4" id="ch00lev2sec36"><strong><em>Running the Simulation</em></strong></h4>&#13;
<p class="noindent">When you first run the simulation, the pen will be up, and none of the bodies will draw their orbital path (<a href="ch06.xhtml#ch06fig13">Figure 6-13</a>). The CSM will smoothly rotate and reorient itself as it approaches the moon and then the earth.</p>&#13;
<div class="image"><img src="../images/fig06_13.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch06fig13"/>Figure 6-13: The simulation run with the pen up and the CSM approaching the moon</p>&#13;
<p class="indent">To trace the journey of the <span epub:type="pagebreak" id="page_145"/>CSM, go to the definition of the <span class="literal">Body</span> class and uncomment this line:</p>&#13;
<pre>    self.pendown() # uncomment to draw path behind object</pre>&#13;
<p class="indent">You should now see the figure-eight shape of the free return trajectory (<a href="ch06.xhtml#ch06fig14">Figure 6-14</a>).</p>&#13;
<div class="image"><img src="../images/fig06_14.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch06fig14"/>Figure 6-14: The simulation run with the pen down and the CM at splashdown in the Pacific</p>&#13;
<p class="indent">You can also simulate <em>gravity propulsion</em>—otherwise known as a <em>slingshot maneuver</em>—by setting the <span class="literal">Vo_X</span> velocity variable to a value between 520 and 540 and rerunning the simulation. This will cause the CSM to pass behind the moon and steal some of its momentum, increasing the ship’s velocity and deflecting its flight path (<a href="ch06.xhtml#ch06fig15">Figure 6-15</a>). Bye-bye Apollo 8!</p>&#13;
<div class="image"><img src="../images/fig06_15.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch06fig15"/>Figure 6-15: The gravitational slingshot maneuver achieved with <span class="literal">Vo_X = 520</span></p>&#13;
<p class="indent">This <span epub:type="pagebreak" id="page_146"/>project should teach you that space travel is a game of seconds and centimeters. If you continue to experiment with value of the <span class="literal">Vo_X</span> variable, you’ll find that even small changes can doom the mission. If you don’t crash into the moon, you’ll reenter the earth’s atmosphere too steeply or miss it entirely!</p>&#13;
<p class="indent">The nice thing about simulations is that, if you fail, you can live to try again. NASA runs countless simulations for all its proposed missions. The results help NASA choose between competing flight plans, find the most efficient routes, decide what to do if things go wrong, and much more.</p>&#13;
<p class="indent">Simulations are especially important for outer solar system exploration, where great distances make real-time communications impossible. The timing of key events, such as firing thrusters, taking photographs, or dropping probes, are all preprogrammed based on meticulous simulations.</p>&#13;
<h3 class="h3" id="ch00lev1sec43"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you learned how to use the <span class="literal">turtle</span> drawing program, including how to make customized turtle shapes. You also learned how to use Python to simulate gravity and solve the famous three-body problem.</p>&#13;
<h3 class="h3" id="ch00lev1sec44"><strong>Further Reading</strong></h3>&#13;
<p class="noindent"><em>Apollo 8: The Thrilling Story of the First Mission to the Moon</em> (Henry Holt and Co., 2017), by Jeffrey Kluger, covers the historic Apollo 8 mission from its unlikely beginning to its “unimaginable triumph.”</p>&#13;
<p class="indent">An online search for <em>PBS Nova How Apollo 8 Left Earth Orbit</em> should return a short video clip on the Apollo 8 translunar injection maneuver, marking the first time humans left the earth’s orbit and traveled to another celestial body.</p>&#13;
<p class="indent"><em>NASA Voyager 1 &amp; 2 Owner’s Workshop Manual</em> (Haynes, 2015), by Christopher Riley, Richard Corfield, and Philip Dolling, provides interesting background on the three-body problem and Michael Minovitch’s many contributions to space travel.</p>&#13;
<p class="indent">The Wikipedia <em>Gravity assist</em> page contains lots of interesting animations of various gravity-assist maneuvers and historic planetary flybys that you can reproduce with your Apollo 8 simulation.</p>&#13;
<p class="indent"><em>Chasing New Horizons: Inside the Epic First Mission to Pluto</em> (Picador, 2018), by Alan Stern and David Grinspoon, documents the importance—and ubiquity—of simulations in NASA missions.</p>&#13;
<h3 class="h3" id="ch00lev1sec45"><strong>Practice Project: Simulating a Search Pattern</strong></h3>&#13;
<p class="noindent">In <a href="ch01.xhtml">Chapter 1</a>, you used Bayes’ rule to help the Coast Guard search for a sailor lost at sea. Now, use <span class="literal">turtle</span> to design a helicopter search pattern to find the missing sailor. Assume the spotters can see for 20 pixels and make the spacing between long tracks 40 pixels (see <a href="ch06.xhtml#ch06fig16">Figure 6-16</a>).</p>&#13;
<div class="image"><img src="../images/fig06_16.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch06fig16"/>Figure 6-16: Two screenshots from <span class="normal">practice_search_pattern.py</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_147"/>For fun, add a helicopter turtle and orient it properly for each pass. Also add a randomly positioned sailor turtle, stop the simulation when the sailor is found, and post the joyous news to the screen (<a href="ch06.xhtml#ch06fig17">Figure 6-17</a>).</p>&#13;
<div class="image"><img src="../images/fig06_17.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch06fig17"/>Figure 6-17: The sailor is spotted in <span class="normal">practice_search_pattern.py</span>.</p>&#13;
<p class="indent">You can find a solution, <em>practice_search_pattern.py</em>, in the appendix. I’ve included a digital version, along with helicopter and sailor images, in the <em>Chapter_6</em> folder, downloadable from the book’s website.</p>&#13;
<h3 class="h3" id="ch00lev1sec46"><strong>Practice Project: Start Me Up!</strong></h3>&#13;
<p class="noindent">Rewrite <em>apollo_8_free_return.py</em>  so that a moving moon approaches a stationary CSM, causes the CSM to start moving, and then swings it up and away. For fun, orient the CSM turtle so that it always points in the direction of travel, as if under its own propulsion (see <a href="ch06.xhtml#ch06fig18">Figure 6-18</a>).</p>&#13;
<div class="image"><img src="../images/fig06_18.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch06fig18"/>Figure 6-18: The moon approaches a stationary CSM (left) and then flings it to the stars (right).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_148"/>For a solution, see <em>practice_grav_assist_stationary.py</em> in the appendix or download it from <em><a href="https://nostarch.com/real-world-python/">https://nostarch.com/real-world-python/</a></em>.</p>&#13;
<h3 class="h3" id="ch00lev1sec47"><strong>Practice Project: Shut Me Down!</strong></h3>&#13;
<p class="noindent">Rewrite <em>apollo_8_free_return.py</em> so that the CSM and moon have crossing orbits, the CSM passes before the moon, and the moon’s gravity slows the CSM’s progress to a crawl while changing its direction by about 90 degrees. As in the previous practice project, have the CSM point in the direction of travel (see <a href="ch06.xhtml#ch06fig19">Figure 6-19</a>).</p>&#13;
<div class="image"><img src="../images/fig06_19.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch06fig19"/>Figure 6-19: The moon and CSM cross orbits, and the moon slows and turns the CSM.</p>&#13;
<p class="indent">For a solution, see <em>practice_grav_assist_intersecting.py</em> in the appendix or download it from <em><a href="https://nostarch.com/real-world-python/">https://nostarch.com/real-world-python/</a></em>.</p>&#13;
<h3 class="h3" id="ch00lev1sec48"><strong>Challenge Project: True-Scale Simulation</strong></h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_149"/>Rewrite <em>apollo_8_free_return.py</em> so that the earth, the moon, and the distance between them are all accurately scaled, as shown in <a href="ch06.xhtml#ch06fig10">Figure 6-10</a>. Use colored circles, rather than images, for the earth and the moon and make the CSM invisible (just draw a line behind it). Use <a href="ch06.xhtml#ch06table2">Table 6-2</a> to help determine the relative sizes and distances to use.</p>&#13;
<p class="tabcap"><a id="ch06table2"/><strong>Table 6-2:</strong> Length Parameters for the Earth-Moon System</p>&#13;
<table class="topbot-d_5">&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h1aa_ch06"><p class="taba">Earth radius</p></td>&#13;
<td style="vertical-align: top;" class="table-h1aa_ch06"><p class="taba">6,371 km</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba">Moon radius</p></td>&#13;
<td style="vertical-align: top;"><p class="taba">1,737 km</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">Earth-moon distance</p></td>&#13;
<td style="vertical-align: top;" class="table-h1aa"><p class="taba">356,700 km*</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="tfoot">*Closest approach during Apollo 8 mission in December 1968</p>&#13;
<h3 class="h3" id="ch00lev1sec49"><strong>Challenge Project: The Real Apollo 8</strong></h3>&#13;
<p class="noindent">Rewrite <em>apollo_8_free_return.py</em> so that it simulates the entire Apollo 8 mission, not just the free return component. The CSM should orbit the moon 10 times before returning to the earth.</p>&#13;
</body></html>