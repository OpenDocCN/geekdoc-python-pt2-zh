- en: '2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MAKING DECISIONS
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Most programs that we use on a daily basis behave differently depending on
    what happens during their execution. For example, when a word processor asks us
    whether we want to save our work, it makes a decision based on our response: saving
    our work if we answer “yes” and not saving our work if we answer “no.” In this
    chapter, we’ll learn about `if` statements, which let our programs make decisions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll solve two problems: determining the result of a basketball game and determining
    whether a phone number belongs to a telemarketer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #3: Winning Team'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this problem, we’ll need to output a message that depends on the outcome
    of a basketball game. To do that, we’ll learn all about `if` statements. We’ll
    also learn how we can store and manipulate true and false values in our programs.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `ccc19j1`.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In basketball, three plays score points: a three-point shot, a two-point shot,
    and a one-point free throw.'
  prefs: []
  type: TYPE_NORMAL
- en: You just watched a basketball game between the Apples and Bananas and recorded
    the number of successful three-point, two-point, and one-point plays for each
    team. Indicate whether the game was won by the Apples, the game was won by the
    Bananas, or the game was a tie.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are six lines of input. The first three give the scoring for the Apples,
    and the latter three give the scoring for the Bananas.
  prefs: []
  type: TYPE_NORMAL
- en: The first line gives the number of successful three-point shots for the Apples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second line gives the number of successful two-point shots for the Apples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third line gives the number of successful one-point free throws for the
    Apples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth line gives the number of successful three-point shots for the Bananas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fifth line gives the number of successful two-point shots for the Bananas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sixth line gives the number of successful one-point free throws for the
    Bananas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each number is an integer between 0 and 100.
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The output is a single character.
  prefs: []
  type: TYPE_NORMAL
- en: If the Apples scored more points than the Bananas, output `A` (*A* for Apples).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the Bananas scored more points than the Apples, output `B` (*B* for Bananas).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the Apples and Bananas scored the same number of points, output `T` (*T*
    for Tie).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional Execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can make a lot of headway here by using what we learned in [Chapter 1](ch01.xhtml#ch01).
    We can use `input` and `int` to read each of the six integers from the input.
    We can use variables to hang on to those values. We can multiply the number of
    successful three-point shots by 3 and the number of successful two-point shots
    by 2\. We can use `print` to output an `A`, `B`, or `T`.
  prefs: []
  type: TYPE_NORMAL
- en: What we haven’t learned yet is how our programs can make a decision about the
    outcome of the game. I can demonstrate why we need this through two test cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, consider this test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The Apples scored 5 * 3 + 1 * 2 + 3 = 20 points, and the Bananas scored 1 *
    3 + 1 * 2 + 1 = 6 points. The Apples won the game, so this is the correct output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, consider this test case, where the Apples’ and Bananas’ scores have
    been swapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the Bananas won the game, so this is the correct output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Our program must be able to compare the total points scored by the Apples and
    the total points scored by the Bananas and use the result of that comparison to
    choose whether to output `A`, `B`, or `T`.
  prefs: []
  type: TYPE_NORMAL
- en: We can use Python’s `if` statement to make these kinds of decisions. A *condition*
    is an expression that’s true or false, and an `if` statement uses conditions to
    determine what to do. `if` statements lead to *conditional execution*, so named
    because the execution of our program is influenced by conditions.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll first learn about a new type that lets us represent true or false values,
    and how we can build expressions of this type. Then, we’ll use such expressions
    to write `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: The Boolean Type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pass an expression to Python’s `type` function, and it’ll tell you the type
    of the expression’s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'One Python type we haven’t met yet is the Boolean (`bool`) type. Unlike integers,
    strings, and floats, which have billions of possible values, there are only two
    Boolean values: `True` and `False`. These are exactly the values we need to represent
    the result of a condition.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What can we do with these values? With numbers, we had mathematical operators
    like `+` and `-` that let us combine values into more complex expressions. We’ll
    need a new set of operators that work with Boolean values.
  prefs: []
  type: TYPE_NORMAL
- en: Relational Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Is `5` greater than `2`? Is `4` less than `1`? We can make such comparisons
    using Python’s *relational operators*. They produce `True` or `False` and are
    therefore used to write *Boolean expressions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `>` operator takes two operands and returns `True` if the first is greater
    than the second, and `False` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we have the `<` operator for less-than:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s `>=` for greater-than-or-equal-to, and `<=` for less-than-or-equal-to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To determine equality, we use the `==` operator. That’s two equal signs, not
    one. Remember that one equal sign (`=`) is used in an assignment statement; it
    has nothing to do with checking equality.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For inequality, we use the `!=` operator. It returns `True` if the operands
    are not equal and `False` if they are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Real programs wouldn’t evaluate expressions whose values we already know. We
    don’t need Python to tell us that `15` doesn’t equal `10`. More typically, we’d
    use variables in these kinds of expressions. For example, `number != 10` is an
    expression whose value depends on what `number` refers to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relational operators also work on strings. When checking equality, case
    matters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'One string is less than another if it comes first in alphabetical order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'But things can be surprising when lowercase and uppercase characters are both
    involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Weird, right? It has to do with the way that characters are stored internally
    in a computer. Generally, uppercase characters come alphabetically before lowercase
    characters. And check this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If these were numbers, then the result would be `False`. But strings are compared
    character by character from left to right. Python compares the `'1'` and `'4'`,
    and because `'1'` is smaller, the `<` operator returns `True`. Be sure that your
    values have the types you think they have!
  prefs: []
  type: TYPE_NORMAL
- en: 'One relational operator that works on strings but not numbers is `in`. It returns
    `True` if the first string occurs at least once in the second, and `False` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of the following code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A. `True`
  prefs: []
  type: TYPE_NORMAL
- en: B. `False`
  prefs: []
  type: TYPE_NORMAL
- en: C. `3`
  prefs: []
  type: TYPE_NORMAL
- en: D. This code produces a syntax error
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: B. The expression `a != 3` evaluates to `False`; `b` is then made to
    refer to this `False` value.'
  prefs: []
  type: TYPE_NORMAL
- en: The if Statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll now explore several variations of Python’s `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: if by Itself
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Suppose we have our final scores in two variables, `apple_total` and `banana_total`,
    and we want to output `A` if `apple_total` is greater than `banana_total`. Here’s
    how we can do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Python outputs `A`, as we’d expect.
  prefs: []
  type: TYPE_NORMAL
- en: An `if` statement starts with the keyword `if`. A *keyword* is a word that has
    special meaning to Python and cannot be used as a variable name. The keyword `if`
    is followed by a Boolean expression, followed by a colon, followed by one or more
    indented statements. The indented statements are often referred to as the *block*
    of the `if` statement. The block executes if the Boolean expression is `True`
    and is skipped if the Boolean expression is `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the prompt changes from `>>>` to `...`. That’s a reminder that we’re
    inside the block of the `if` statement and must indent the code. I’ve chosen to
    indent by four spaces, so to indent the code, press the spacebar four times. Some
    Python programmers press the TAB key to indent, but we’ll exclusively use spaces
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Once you type `print('A')` and hit ENTER, you should see another `...` prompt.
    Since we don’t have anything else to put in this `if` statement, press ENTER again
    to dismiss this prompt and return to the `>>>` prompt. This extra press of ENTER
    is a quirk of the Python shell; such blank lines are not required when we write
    a Python program in a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of putting two statements in the block of an `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Both `print` calls execute, producing two lines of output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try another `if` statement, this one with a Boolean expression that’s
    `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `print` function is *not* called this time: `apple_total > banana_total`
    is `False`, so the block of the `if` statement is skipped.'
  prefs: []
  type: TYPE_NORMAL
- en: if with elif
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s use three successive `if` statements to print `A` if the Apples win,
    `B` if the Bananas win, and `T` if it’s a tie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The blocks of the first two `if` statements are skipped, because their Boolean
    expressions are `False`. But the block of the third `if` statement executes, producing
    the `T`.
  prefs: []
  type: TYPE_NORMAL
- en: When you put one `if` statement after another, they’re independent. Each Boolean
    expression is evaluated, regardless of whether the previous Boolean expressions
    were `True` or `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For any given values of `apple_total` and `banana_total`, only one of our `if`
    statements can run. For example, if `apple_total > banana_total` is `True`, then
    the first `if` statement will run, but the other two will not. It’s possible to
    write the code to highlight that only one block of code is allowed to run. Here’s
    how we can do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is now a single `if` statement, not three separate `if` statements. For
    this reason, don’t press ENTER at the `...` prompt; instead, type the `elif` line.
  prefs: []
  type: TYPE_NORMAL
- en: To execute this `if` statement, Python begins by evaluating the first Boolean
    expression ❶. If it’s `True`, then `A` is output, and the rest of the `elif`s
    are skipped. If it’s `False`, Python continues, evaluating the second Boolean
    expression ❷. If it’s `True`, then `B` is output, and the remaining `elif` is
    skipped. If it’s `False`, Python continues, evaluating the third Boolean expression
    ❸. If it’s `True`, then `T` is output.
  prefs: []
  type: TYPE_NORMAL
- en: The keyword `elif` stands for “else-if.” Use this as a reminder that an `elif`
    expression is checked only if nothing “else” before it in the `if` statement was
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: This version of the code is equivalent to the previous code where we used three
    separate `if` statements. Had we wanted to allow the possibility of executing
    more than one block, we’d have to use three separate `if` statements, not a single
    `if` statement with `elif` blocks.
  prefs: []
  type: TYPE_NORMAL
- en: if with else
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can use the `else` keyword to run code if all the Boolean expressions in
    the `if` statement are `False`. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Python evaluates the Boolean expressions from top to bottom. If any of them
    is `True`, Python runs the associated block and skips the rest of the `if` statement.
    If all the Boolean expressions are `False`, Python executes the `else` block.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that there is no longer a test for `apple_total == banana_total`. The
    only way to get to the `else` part of the `if` statement is if `apple_total >
    banana_total` is `False` and `banana_total > apple_total` is `False`, that is,
    if the values are equal.
  prefs: []
  type: TYPE_NORMAL
- en: Should you use separate `if` statements? An `if` statement with `elif`s? An
    `if` statement with an `else`? It often comes down to preference. Use a chain
    of `elif`s if you want at most one block of code to execute. An `else` can help
    make the code clearer and removes the need to write a catchall Boolean expression.
    What’s far more important than the precise styling of an `if` statement is writing
    correct logic!
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: What is the value of `x` after the following code runs?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: A. `-3`
  prefs: []
  type: TYPE_NORMAL
- en: B. `1`
  prefs: []
  type: TYPE_NORMAL
- en: C. `2`
  prefs: []
  type: TYPE_NORMAL
- en: D. `3`
  prefs: []
  type: TYPE_NORMAL
- en: E. `5`
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: D. Because `x > 2` is `True`, the block of the first `if` statement
    executes. The assignment `x = -3` makes `x` refer to `-3`. Now for the second
    `if` statement. Here, `x > 1` is `False`, so the `else` block runs, and `x = 3`
    makes `x` refer to `3`. I’d suggest changing `if x > 1` to `elif x > 1` and observing
    how the behavior of the program changes!'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: Do the following two snippets of code do exactly the same thing? Assume that
    `temperature` already refers to a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Snippet 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A. Yes
  prefs: []
  type: TYPE_NORMAL
- en: B. No
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: B. Snippet 2 *always* prints `cold` as its final line of output, because
    `print(''cold'')` is not indented! It is not associated with any `if` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to solve Winning Team. In this book, I’ll generally present the full
    code and then discuss it. But as our solution here is longer than those in [Chapter
    1](ch01.xhtml#ch01), I’ve decided in this case to present the code in three pieces
    before presenting it as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to read the input. This requires six calls of `input`, because
    we have two teams and three pieces of information for each team. We also need
    to convert each piece of input to an integer. Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we need to determine the number of points scored by the Apples and
    the Bananas. For each team, we add the points from three-point, two-point, and
    one-point plays. We can do that as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Third, we produce the output. If the Apples win, we output `A`; if the Bananas
    win, we output `B`; otherwise, we know that the game is a tie, so we output `T`.
    We use an `if` statement to do this, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: That’s all the code we need. See [Listing 2-1](ch02.xhtml#ch02ex01) for the
    complete solution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-1: Solving Winning Team*'
  prefs: []
  type: TYPE_NORMAL
- en: If you submit our code to the judge, you should see that all test cases pass.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: Does the following version of the code correctly solve the problem?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: A. Yes
  prefs: []
  type: TYPE_NORMAL
- en: B. No
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: A. The operators and order of the code are different, but the code
    is still correct. If the Apples lose, we output `B` (because the Bananas win);
    if the Apples win, we output `A`; otherwise, we know that the game is a tie, so
    we output `T`.'
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing, you might like to try solving exercise 1 from “Chapter Exercises”
    on [page 45](ch02.xhtml#ch02lev1sec13).
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #4: Telemarketers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes we need to encode more complex Boolean expressions than those that
    we have seen so far. In this problem, we’ll learn about Boolean operators that
    help us do this.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `ccc18j1`.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this problem, we’ll assume that phone numbers are four digits. A phone number
    belongs to a telemarketer if its four digits satisfy all three of the following
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: The first digit is `8` or `9`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth digit is `8` or `9`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second and third digits are the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, a phone number whose four digits are `8119` belongs to a telemarketer.
  prefs: []
  type: TYPE_NORMAL
- en: Determine whether a phone number belongs to a telemarketer, and indicate whether
    we should answer the phone or ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are four lines of input. These lines give the first, second, third, and
    fourth digits of the phone number, respectively. Each digit is an integer between
    0 and 9.
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the phone number belongs to a telemarketer, output `ignore`; otherwise, output
    `answer`.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What has to be true about a phone number that belongs to a telemarketer? Its
    first digit has to be `8` *or* `9`. *And*, its fourth digit has to be `8` *or*
    `9`. *And*, the second and third digits have to be the same. We can encode this
    “or” and “and” logic using Python’s *Boolean operators*.
  prefs: []
  type: TYPE_NORMAL
- en: or Operator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `or` operator takes two Boolean expressions as its operands. It returns
    `True` if at least one operand is `True`, and `False` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The only way to get `False` out of the `or` operator is if both of its operands
    are `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `or` to tell us whether a digit is an `8` or a `9`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Remember from “Integer and Floating-Point Numbers” in [Chapter 1](ch01.xhtml#ch01)
    that Python uses operator precedence to determine the order that operators are
    applied. The precedence of `or` is lower than the precedence of relational operators,
    which means that we don’t often need parentheses around operands. For example,
    in `digit == 8 or digit == 9`, the two operands to `or` are `digit == 8` and `digit
    == 9`. It’s the same as if we’d written it as `(digit == 8) or (digit == 9)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In English, it makes sense if someone says “if the digit is 8 or 9.” But writing
    that won’t work in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Notice that I’ve (incorrectly!) written the second operand as `9` instead of
    `digit == 9`. Python responds by outputting `yes!`, which is certainly not what
    we’d want given that `digit` refers to `3`. The reason is that Python considers
    nonzero numbers to be `True`. Since `9` is considered `True`, this makes the whole
    `or` expression `True`. Carefully double-check your Boolean expressions to avoid
    these kinds of mistakes when translating from natural language to Python.
  prefs: []
  type: TYPE_NORMAL
- en: and Operator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `and` operator returns `True` if both of its operands are `True`, and returns
    `False` otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The only way to get `True` out of the `And` operator is if both of its operands
    are `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The precedence of `and` is higher than `or`. Here’s an example of why this
    matters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Python interprets that expression like this, with the `and` happening first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The result is `True` because the first operand of `or` is `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can force the `or` to happen first by including parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The result is `False` because the second operand of `and` is `False`.
  prefs: []
  type: TYPE_NORMAL
- en: not Operator
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another important Boolean operator is `not`. Unlike `or` and `and`, `not` takes
    only one operand (not two). If its operand is `True`, not returns `False`, and
    vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The precedence of `not` is higher than `or` and `and`.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an expression and versions of that expression with parentheses. Which
    of them evaluates to `True`?
  prefs: []
  type: TYPE_NORMAL
- en: A. `not True and False`
  prefs: []
  type: TYPE_NORMAL
- en: B. `(not True) and False`
  prefs: []
  type: TYPE_NORMAL
- en: C. `not (True and False)`
  prefs: []
  type: TYPE_NORMAL
- en: D. None of the above
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: C. The expression `(True and False)` evaluates to `False`; the `not`
    therefore makes the full expression `True`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the expression `not a or b`.
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following makes the expression `False`?
  prefs: []
  type: TYPE_NORMAL
- en: A. `a False`, `b False`
  prefs: []
  type: TYPE_NORMAL
- en: B. `a False`, `b True`
  prefs: []
  type: TYPE_NORMAL
- en: C. `a True`, `b False`
  prefs: []
  type: TYPE_NORMAL
- en: D. `a True`, `b True`
  prefs: []
  type: TYPE_NORMAL
- en: E. More than one of the above
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: C. If `a` is `True`, then `not a` is `False`. Since `b` is `False`,
    too, both operands to `or` are `False`, so the whole expression evaluates to `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With Boolean operators at the ready, we can tackle the Telemarketers problem.
    Our solution is in [Listing 2-2](ch02.xhtml#ch02ex02).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-2: Solving Telemarketers*'
  prefs: []
  type: TYPE_NORMAL
- en: As in Winning Team, we start by reading the input and converting it to integers.
  prefs: []
  type: TYPE_NORMAL
- en: The high-level structure of our `if` statement ❶ is three expressions connected
    by `and` operators; each of them must be `True` for the entire expression to be
    `True`. We require that the first number be `8` or `9`, that the fourth number
    be `8` or `9`, and that the second and third numbers be equal. If all three of
    these conditions hold, then we know that the phone number belongs to a telemarketer,
    and we output `ignore`. Otherwise, the phone number does not belong to a telemarketer,
    and we output `answer`.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve split the Boolean expression over three lines. This requires wrapping the
    entire expression in an additional pair of parentheses, as I have done. (Without
    those parentheses, you’ll get a syntax error, because there’s no indication to
    Python that the expression is continuing on the next line.)
  prefs: []
  type: TYPE_NORMAL
- en: Python style guides suggest that a line be no longer than 79 characters. A line
    with the full Boolean expression would squeak in there at 76 characters. But I
    think the three-line version is clearer, highlighting each condition that must
    be `True` on its own line.
  prefs: []
  type: TYPE_NORMAL
- en: We have a good solution here. To explore a little further, let’s discuss some
    alternate approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Our code uses a Boolean expression to detect when a phone number belongs to
    a telemarketer. We could have also chosen to write code that detects when a phone
    number does *not* belong to a telemarketer. If the phone number doesn’t belong
    to a telemarketer, we should output `answer`; otherwise, we should output `ignore`.
  prefs: []
  type: TYPE_NORMAL
- en: If the first digit isn’t `8` and isn’t `9`, then the phone number doesn’t belong
    to a telemarketer. Or, if the fourth digit isn’t `8` and isn’t `9`, then the phone
    number doesn’t belong to a telemarketer. Or, if the second and third digits aren’t
    equal, then the phone number doesn’t belong to a telemarketer. If even one of
    these expressions is `True`, then the phone number doesn’t belong to a telemarketer.
  prefs: []
  type: TYPE_NORMAL
- en: See [Listing 2-3](ch02.xhtml#ch02ex03) for a version of the code that captures
    this logic.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-3: Solving Telemarketers, alternate approach*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s not easy getting all of those `!=`, `or`, and `and` operators correct!
    Notice, for example, that we’ve had to change all `==` operators to `!=`, all
    `or` operators to `and`, and all `and` operators to `or`.
  prefs: []
  type: TYPE_NORMAL
- en: An alternate approach is to use the `not` operator to negate the “is a telemarketer”
    expression in one shot. See [Listing 2-4](ch02.xhtml#ch02ex04) for that code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-4: Solving Telemarketers, not operator*'
  prefs: []
  type: TYPE_NORMAL
- en: Which of these solutions do you find most intuitive? There’s often more than
    one way to structure the logic of an `if` statement, and we should use the one
    that’s easiest to get right. To me, [Listing 2-2](ch02.xhtml#ch02ex02) is the
    most natural, but you may feel otherwise!
  prefs: []
  type: TYPE_NORMAL
- en: Choose your favorite version and submit it to the judge. You should see that
    all test cases pass.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We should always strive to make our programs as clear as possible. This helps
    to avoid introducing errors when programming and makes it easier to fix our code
    when errors do slip in. Meaningful variable names, spaces around operators, blank
    lines to segment the program into its logical pieces, simple `if` statement logic:
    all of these practices can improve the quality of the code we write. Another good
    habit is adding *comments* to our code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A comment is introduced by the `#` character and continues until the end of
    the line. Python ignores comments, so they have no impact on what our program
    does. We add comments to remind ourselves, or others, about design decisions that
    we’ve made. Assume that the person reading the code knows Python, so avoid comments
    that simply restate what the code is doing. Here’s code with an unnecessary comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: That comment adds nothing beyond what we already know about assignment statements.
  prefs: []
  type: TYPE_NORMAL
- en: See [Listing 2-5](ch02.xhtml#ch02ex05) for a version of [Listing 2-2](ch02.xhtml#ch02ex02)
    with comments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2-5: Solving Telemarketers, comments added*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve added three comment lines: the one at the top ❶ reminds us of the problem
    code and name, and the two before the `if` statement ❷ remind us of the rules
    for detecting a telemarketer phone number.'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t go overboard with comments. Whenever possible, write code that doesn’t
    require comments in the first place. But for tricky code or to document why you
    chose to do something in a particular way, a well-placed comment now can save
    time and frustration later.
  prefs: []
  type: TYPE_NORMAL
- en: Input and Output Redirection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you submit Python code to the judge, it runs many test cases to determine
    whether your code is correct. Is someone there, dutifully waiting for new code
    and then frantically hammering test cases at it from the keyboard?
  prefs: []
  type: TYPE_NORMAL
- en: No way! It’s all automated. There’s no one typing test cases at the keyboard.
    How does the judge test our code, then, if we satisfy a call to `input` by typing
    something from the keyboard?
  prefs: []
  type: TYPE_NORMAL
- en: The truth is that `input` isn’t necessarily reading input from the keyboard.
    It’s reading from a source of input called *standard input*, which, by default,
    is the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to change standard input so that it refers to a file rather than
    the keyboard. The technique is called *input redirection*, and it’s what the judge
    uses to provide input.
  prefs: []
  type: TYPE_NORMAL
- en: We can also try input redirection ourselves. For programs whose input is small—just
    a line of text or a couple of integers—input redirection may not save us much.
    But for programs whose test cases can be tens or hundreds of lines long, input
    redirection makes it much easier to test our work. Rather than typing the same
    test case over and over, we can store it in a file and then run our program on
    it as many times as we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try input redirection on Telemarketers. Navigate to your *programming*
    folder and create a new file called *telemarketers_input.txt*. In that file, type
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The problem specifies that we should provide one integer per line, so we’ve
    written them one per line here.
  prefs: []
  type: TYPE_NORMAL
- en: Save the file. Now enter python telemarketers.py < telemarketers_input.txt to
    run your program using input redirection. Your program should output `ignore`,
    just as it would if you’d typed the test case from the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: The `<` symbol instructs your operating system to use a file rather than the
    keyboard to provide input. After the `<` symbol comes the name of the file that
    contains the input.
  prefs: []
  type: TYPE_NORMAL
- en: To try your program on different test cases, just modify the *telemarketers_input.txt*
    file and run your program again.
  prefs: []
  type: TYPE_NORMAL
- en: We can also change where our output goes, though we won’t need to for this book.
    The `print` function outputs to *standard output*, which, by default, is the screen.
    We can change standard output so that it instead refers to a file. We do so using
    *output redirection*, which is written as a `>` symbol followed by a filename.
  prefs: []
  type: TYPE_NORMAL
- en: Enter python telemarketers.py > telemarketers_output.txt to run your program
    using output redirection. Provide four integers of input, and you should be back
    to your operating system prompt. But you shouldn’t see any output from your Telemarketers
    program! That’s because we’ve redirected the output to file `telemarketers_output.txt`.
    If you open `telemarketers_output.txt` in your text editor, you should see the
    output there.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful with output redirection. If you use a filename that already exists,
    your old file will be overwritten! Always double-check that you’re using the filename
    you intended.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use `if` statements to direct what our programs
    do. The key ingredient of an `if` statement is a Boolean expression, which is
    an expression with a `True` or `False` value. To build up Boolean expressions,
    we use relational operators such as `==` and `>=`, and we use Boolean operators
    such as `and` and `or`.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding what to do based on what is `True` and `False` makes our programs more
    flexible, able to adapt to the situation at hand. But our programs are still limited
    to handling small amounts of input and output—whatever we can do with individual
    calls to `input` and `print`. In the next chapter, we’ll start learning about
    loops, which let us repeat code so that we can process as much input and output
    as we like.
  prefs: []
  type: TYPE_NORMAL
- en: Want to work with 100 values? How about 1,000? And with just a small amount
    of Python code? It is a little early for me to be provoking you, I know, because
    you still have the following exercises to do. But when you’re ready, read on!
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are some exercises for you to try.
  prefs: []
  type: TYPE_NORMAL
- en: DMOJ problem `ccc06j1`, Canadian Calorie Counting
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `ccc15j1`, Special Day
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `ccc15j2`, Happy or Sad
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `dmopc16c1p0`, C.C. and Cheese-kun
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `ccc07j1`, Who is in the Middle
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Winning Team is originally from the 2019 Canadian Computing Competition, Junior
    Level. Telemarketers is originally from the 2018 Canadian Computing Competition,
    Junior Level.
  prefs: []
  type: TYPE_NORMAL
