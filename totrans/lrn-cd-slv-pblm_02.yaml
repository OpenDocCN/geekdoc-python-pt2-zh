- en: '2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '2'
- en: MAKING DECISIONS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 做出决策
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: 'Most programs that we use on a daily basis behave differently depending on
    what happens during their execution. For example, when a word processor asks us
    whether we want to save our work, it makes a decision based on our response: saving
    our work if we answer “yes” and not saving our work if we answer “no.” In this
    chapter, we’ll learn about if statements, which let our programs make decisions.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们日常使用的大多数程序会根据执行过程中的不同情况做出不同的反应。例如，当文字处理软件询问我们是否保存工作时，它会根据我们的回答做出决策：如果回答“是”，则保存工作；如果回答“否”，则不保存工作。在本章中，我们将学习if语句，它能让我们的程序做出决策。
- en: 'We’ll solve two problems: determining the result of a basketball game and determining
    whether a phone number belongs to a telemarketer.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解决两个问题：确定篮球比赛的结果，以及判断一个电话号码是否属于推销员。
- en: 'Problem #3: Winning Team'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #3：获胜队伍'
- en: In this problem, we’ll need to output a message that depends on the outcome
    of a basketball game. To do that, we’ll learn all about if statements. We’ll also
    learn how we can store and manipulate true and false values in our programs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们需要输出一条依赖于篮球比赛结果的消息。为此，我们将学习所有关于if语句的知识。我们还将学习如何在程序中存储和处理真假值。
- en: This is DMOJ problem ccc19j1.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题ccc19j1。
- en: The Challenge
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: 'In basketball, three plays score points: a three-point shot, a two-point shot,
    and a one-point free throw.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在篮球比赛中，有三种方式得分：三分投篮、两分投篮和单分罚球。
- en: You just watched a basketball game between the Apples and Bananas and recorded
    the number of successful three-point, two-point, and one-point plays for each
    team. Indicate whether the game was won by the Apples, the game was won by the
    Bananas, or the game was a tie.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚观看了一场苹果队与香蕉队的篮球比赛，并记录了每个队伍成功的三分、两分和单分罚球次数。请判断是苹果队获胜、香蕉队获胜，还是比赛平局。
- en: Input
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: There are six lines of input. The first three give the scoring for the Apples,
    and the latter three give the scoring for the Bananas.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 输入有六行。前面三行给出了苹果队的得分，后面三行给出了香蕉队的得分。
- en: The first line gives the number of successful three-point shots for the Apples.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行给出苹果队成功的三分投篮次数。
- en: The second line gives the number of successful two-point shots for the Apples.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行给出苹果队成功的两分投篮次数。
- en: The third line gives the number of successful one-point free throws for the
    Apples.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行给出苹果队成功的单分罚球次数。
- en: The fourth line gives the number of successful three-point shots for the Bananas.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四行给出香蕉队成功的三分投篮次数。
- en: The fifth line gives the number of successful two-point shots for the Bananas.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五行给出香蕉队成功的两分投篮次数。
- en: The sixth line gives the number of successful one-point free throws for the
    Bananas.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第六行给出香蕉队成功的单分罚球次数。
- en: Each number is an integer between 0 and 100.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数字是0到100之间的整数。
- en: Output
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: The output is a single character.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个单一的字符。
- en: If the Apples scored more points than the Bananas, output A (*A* for Apples).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果苹果队得分超过香蕉队，输出A（*A*表示苹果队）。
- en: If the Bananas scored more points than the Apples, output B (*B* for Bananas).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果香蕉队得分超过苹果队，输出B（*B*表示香蕉队）。
- en: If the Apples and Bananas scored the same number of points, output T (*T* for
    Tie).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果苹果队和香蕉队得分相同，输出T（*T*表示平局）。
- en: Conditional Execution
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件执行
- en: We can make a lot of headway here by using what we learned in [Chapter 1](ch01.xhtml#ch01).
    We can use input and int to read each of the six integers from the input. We can
    use variables to hang on to those values. We can multiply the number of successful
    three-point shots by 3 and the number of successful two-point shots by 2\. We
    can use print to output an A, B, or T.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在[第1章](ch01.xhtml#ch01)中学到的内容来取得很大进展。我们可以使用input和int来读取输入的六个整数。我们可以使用变量来保存这些值。我们可以将成功的三分投篮次数乘以3，将成功的两分投篮次数乘以2。我们可以使用print输出A、B或T。
- en: What we haven’t learned yet is how our programs can make a decision about the
    outcome of the game. I can demonstrate why we need this through two test cases.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有学到的是，如何让我们的程序根据比赛结果做出决策。我可以通过两个测试用例来演示为什么我们需要这个。
- en: 'First, consider this test case:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑这个测试用例：
- en: '5'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '1'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '3'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '1'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '1'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '1'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 'The Apples scored 5 * 3 + 1 * 2 + 3 = 20 points, and the Bananas scored 1 *
    3 + 1 * 2 + 1 = 6 points. The Apples won the game, so this is the correct output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果队得了5 * 3 + 1 * 2 + 3 = 20分，香蕉队得了1 * 3 + 1 * 2 + 1 = 6分。苹果队赢得了比赛，因此这是正确的输出：
- en: A
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: A
- en: 'Second, consider this test case, where the Apples’ and Bananas’ scores have
    been swapped:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，考虑这个测试案例，其中苹果队和香蕉队的分数被交换了：
- en: '1'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '1'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '1'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '5'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '1'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '3'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: 'This time, the Bananas won the game, so this is the correct output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，香蕉队赢得了比赛，所以这是正确的输出：
- en: B
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: B
- en: Our program must be able to compare the total points scored by the Apples and
    the total points scored by the Bananas and use the result of that comparison to
    choose whether to output A, B, or T.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序必须能够比较苹果队和香蕉队的总得分，并根据这个比较结果选择输出 A、B 或 T。
- en: We can use Python’s if statement to make these kinds of decisions. A *condition*
    is an expression that’s true or false, and an if statement uses conditions to
    determine what to do. if statements lead to *conditional execution*, so named
    because the execution of our program is influenced by conditions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Python 的 if 语句来做出这些决策。*条件*是一个真假值的表达式，if 语句使用条件来决定该做什么。if 语句导致 *条件执行*，其名称来源于程序的执行受到条件的影响。
- en: We’ll first learn about a new type that lets us represent true or false values,
    and how we can build expressions of this type. Then, we’ll use such expressions
    to write if statements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要学习一个新的类型，它让我们能够表示真假值，以及如何构建这种类型的表达式。然后，我们将使用这些表达式来编写 if 语句。
- en: The Boolean Type
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔类型
- en: 'Pass an expression to Python’s type function, and it’ll tell you the type of
    the expression’s value:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将表达式传递给 Python 的 type 函数，它会告诉你该表达式值的类型：
- en: '>>> type(14)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(14)'
- en: <class 'int'>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'int'>
- en: '>>> type(9.5)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(9.5)'
- en: <class 'float'>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'float'>
- en: '>>> type(''hello'')'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(''hello'')'
- en: <class 'str'>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'str'>
- en: '>>> type(12 + 15)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(12 + 15)'
- en: <class 'int'>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'int'>
- en: 'One Python type we haven’t met yet is the Boolean (bool) type. Unlike integers,
    strings, and floats, which have billions of possible values, there are only two
    Boolean values: True and False. These are exactly the values we need to represent
    the result of a condition.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有遇到过的 Python 类型是布尔（bool）类型。与整数、字符串和浮点数不同，布尔类型只有两个可能的值：True 和 False。这正是我们用来表示条件结果的值。
- en: '>>> True'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> True'
- en: 'True'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> False'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> False'
- en: 'False'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: '>>> type(True)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(True)'
- en: <class 'bool'>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'bool'>
- en: '>>> type(False)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(False)'
- en: <class 'bool'>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'bool'>
- en: What can we do with these values? With numbers, we had mathematical operators
    like + and - that let us combine values into more complex expressions. We’ll need
    a new set of operators that work with Boolean values.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能用这些值做什么呢？对于数字，我们有加法和减法等数学运算符，它们允许我们将值组合成更复杂的表达式。我们将需要一组新的操作符来处理布尔值。
- en: Relational Operators
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关系操作符
- en: Is 5 greater than 2? Is 4 less than 1? We can make such comparisons using Python’s
    *relational operators*. They produce True or False and are therefore used to write
    *Boolean expressions*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 5 大于 2 吗？4 小于 1 吗？我们可以使用 Python 的 *关系操作符* 来进行这样的比较。它们返回 True 或 False，因此用于编写
    *布尔表达式*。
- en: 'The > operator takes two operands and returns True if the first is greater
    than the second, and False otherwise:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '> 操作符接受两个操作数，如果第一个操作数大于第二个操作数，则返回 True，否则返回 False：'
- en: '>>> 5 > 2'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 5 > 2'
- en: 'True'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> 9 > 10'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 9 > 10'
- en: 'False'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: 'Similarly, we have the < operator for less-than:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们有 < 操作符用于小于：
- en: '>>> 4 < 1'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 4 < 1'
- en: 'False'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: '>>> -2 < 0'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> -2 < 0'
- en: 'True'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: 'There’s >= for greater-than-or-equal-to, and <= for less-than-or-equal-to:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有 >= 用于大于或等于，<= 用于小于或等于：
- en: '>>> 4 >= 2'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 4 >= 2'
- en: 'True'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> 4 >= 4'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 4 >= 4'
- en: 'True'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> 4 >= 5'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 4 >= 5'
- en: 'False'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: '>>> 8 <= 6'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 8 <= 6'
- en: 'False'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: To determine equality, we use the == operator. That’s two equal signs, not one.
    Remember that one equal sign (=) is used in an assignment statement; it has nothing
    to do with checking equality.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了判断相等性，我们使用 == 操作符。那是两个等号，而不是一个。记住，一个等号（=）用于赋值语句；它与检查相等性无关。
- en: '>>> 5 == 5'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 5 == 5'
- en: 'True'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> 15 == 10'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 15 == 10'
- en: 'False'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: 'For inequality, we use the != operator. It returns True if the operands are
    not equal and False if they are equal:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不等式，我们使用 != 操作符。如果操作数不相等，则返回 True，如果相等，则返回 False：
- en: '>>> 5 != 5'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 5 != 5'
- en: 'False'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: '>>> 15 != 10'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 15 != 10'
- en: 'True'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: Real programs wouldn’t evaluate expressions whose values we already know. We
    don’t need Python to tell us that 15 doesn’t equal 10. More typically, we’d use
    variables in these kinds of expressions. For example, number != 10 is an expression
    whose value depends on what number refers to.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的程序不会评估那些我们已经知道其值的表达式。我们不需要 Python 告诉我们 15 不等于 10。更常见的是，我们会在这些表达式中使用变量。例如，number
    != 10 是一个依赖于 number 所指向的值的表达式。
- en: 'The relational operators also work on strings. When checking equality, case
    matters:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 关系操作符也可以作用于字符串。在检查相等性时，大小写是重要的：
- en: '>>> ''hello'' == ''hello'''
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''hello'' == ''hello'''
- en: 'True'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 真
- en: '>>> ''Hello'' == ''hello'''
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''Hello'' == ''hello'''
- en: 'False'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: 'One string is less than another if it comes first in alphabetical order:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个字符串按字母顺序排在另一个字符串之前，则前者小于后者：
- en: '>>> ''brave'' < ''cave'''
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''brave'' < ''cave'''
- en: 'True'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 真
- en: '>>> ''cave'' < ''cavern'''
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''cave'' < ''cavern'''
- en: 'True'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 真
- en: '>>> ''orange'' < ''apple'''
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''orange'' < ''apple'''
- en: 'False'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: 'But things can be surprising when lowercase and uppercase characters are both
    involved:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当同时涉及小写字母和大写字母时，结果可能会让人惊讶：
- en: '>>> ''apple'' < ''Banana'''
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''apple'' < ''Banana'''
- en: 'False'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: 'Weird, right? It has to do with the way that characters are stored internally
    in a computer. Generally, uppercase characters come alphabetically before lowercase
    characters. And check this out:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪，对吧？这与字符在计算机内部的存储方式有关。通常，大写字母按字母顺序排在小写字母前面。看看这个：
- en: '>>> ''10'' < ''4'''
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''10'' < ''4'''
- en: 'True'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 真
- en: If these were numbers, then the result would be False. But strings are compared
    character by character from left to right. Python compares the '1' and '4', and
    because '1' is smaller, the < operator returns True. Be sure that your values
    have the types you think they have!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些是数字，结果会是 False。但字符串是按字符从左到右逐一比较的。Python 比较 '1' 和 '4'，因为 '1' 比 '4' 小，所以 <
    操作符返回 True。确保你的值类型符合你的预期！
- en: 'One relational operator that works on strings but not numbers is in. It returns
    True if the first string occurs at least once in the second, and False otherwise:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对字符串有效但对数字无效的关系操作符是 in。它会返回 True，如果第一个字符串至少在第二个字符串中出现一次，否则返回 False：
- en: '>>> ''ppl'' in ''apple'''
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''ppl'' in ''apple'''
- en: 'True'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 真
- en: '>>> ''ale'' in ''apple'''
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''ale'' in ''apple'''
- en: 'False'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: '**CONCEPT CHECK**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the output of the following code?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: a = 3
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: a = 3
- en: b = (a != 3)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: b = (a != 3)
- en: print(b)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: print(b)
- en: A. True
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: A. 真
- en: B. False
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: B. 假
- en: C. 3
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: C. 3
- en: D. This code produces a syntax error
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: D. 这段代码会产生语法错误
- en: 'Answer: B. The expression a != 3 evaluates to False; b is then made to refer
    to this False value.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B. 表达式 a != 3 结果为 False；b 被赋值为这个 False 值。
- en: The if Statement
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if 语句
- en: We’ll now explore several variations of Python’s if statement.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探索 Python 中 if 语句的几种变体。
- en: if by Itself
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单独的 if
- en: 'Suppose we have our final scores in two variables, apple_total and banana_total,
    and we want to output A if apple_total is greater than banana_total. Here’s how
    we can do that:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的最终得分分别存储在两个变量中，apple_total 和 banana_total，并且我们希望当 apple_total 大于 banana_total
    时输出 A。我们可以这样做：
- en: '>>> apple_total = 20'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> apple_total = 20'
- en: '>>> banana_total = 6'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> banana_total = 6'
- en: '>>> if apple_total > banana_total:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 如果 apple_total > banana_total:'
- en: '...     print(''A'')'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''A'')'
- en: '...'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: A
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: A
- en: Python outputs A, as we’d expect.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Python 输出 A，正如我们所预期的。
- en: An if statement starts with the keyword if. A *keyword* is a word that has special
    meaning to Python and cannot be used as a variable name. The keyword if is followed
    by a Boolean expression, followed by a colon, followed by one or more indented
    statements. The indented statements are often referred to as the *block* of the
    if statement. The block executes if the Boolean expression is True and is skipped
    if the Boolean expression is False.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: if 语句以关键字 if 开头。*关键字*是 Python 中有特殊意义的单词，不能用作变量名。关键字 if 后面跟着一个布尔表达式，接着是冒号，再后面是一个或多个缩进的语句。这些缩进的语句通常称为
    if 语句的 *块*。如果布尔表达式为 True，则执行该块；如果布尔表达式为 False，则跳过该块。
- en: Notice that the prompt changes from >>> to .... That’s a reminder that we’re
    inside the block of the if statement and must indent the code. I’ve chosen to
    indent by four spaces, so to indent the code, press the spacebar four times. Some
    Python programmers press the TAB key to indent, but we’ll exclusively use spaces
    in this book.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，提示符从 >>> 变成了 .... 这是一个提醒，表示我们在 if 语句的块内，必须对代码进行缩进。我选择使用四个空格进行缩进，因此要缩进代码，请按四次空格键。某些
    Python 程序员按 TAB 键进行缩进，但我们在本书中将只使用空格。
- en: Once you type print('A') and hit ENTER, you should see another ... prompt. Since
    we don’t have anything else to put in this if statement, press ENTER again to
    dismiss this prompt and return to the >>> prompt. This extra press of ENTER is
    a quirk of the Python shell; such blank lines are not required when we write a
    Python program in a file.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你输入 print('A') 并按下 ENTER，应该会看到另一个 ... 提示符。由于我们没有其他内容要放在这个 if 语句中，再按一次 ENTER
    以关闭这个提示符并返回 >>> 提示符。这个额外的 ENTER 是 Python shell 的一个特点；当我们在文件中编写 Python 程序时，这种空白行是不用的。
- en: 'Let’s see an example of putting two statements in the block of an if statement:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，演示如何将两个语句放在 if 语句的块中：
- en: '>>> apple_total = 20'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> apple_total = 20'
- en: '>>> banana_total = 6'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> banana_total = 6'
- en: '>>> if apple_total > banana_total:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 如果 apple_total > banana_total:'
- en: '...     print(''A'')'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''A'')'
- en: '...     print(''Apples win!'')'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''Apples win!'')'
- en: '...'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: A
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: A
- en: Apples win!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果胜利！
- en: Both print calls execute, producing two lines of output.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 print 调用都会执行，输出两行。
- en: 'Let’s try another if statement, this one with a Boolean expression that’s False:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试另一个 if 语句，这个语句包含一个值为 False 的布尔表达式：
- en: '>>> apple_total = 6'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> apple_total = 6'
- en: '>>> banana_total = 20'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> banana_total = 20'
- en: '>>> if apple_total > banana_total:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> if apple_total > banana_total:'
- en: '...     print(''A'')'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''A'')'
- en: '...'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'The print function is *not* called this time: apple_total > banana_total is
    False, so the block of the if statement is skipped.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这次没有调用 print 函数：因为 apple_total > banana_total 为 False，所以 if 语句的代码块被跳过。
- en: if with elif
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 elif
- en: 'Let’s use three successive if statements to print A if the Apples win, B if
    the Bananas win, and T if it’s a tie:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用三个连续的 if 语句，如果苹果胜利就打印 A，如果香蕉胜利就打印 B，如果平局就打印 T：
- en: '>>> apple_total = 6'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> apple_total = 6'
- en: '>>> banana_total = 6'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> banana_total = 6'
- en: '>>> if apple_total > banana_total:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> if apple_total > banana_total:'
- en: '...     print(''A'')'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''A'')'
- en: '...'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> if banana_total > apple_total:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> if banana_total > apple_total:'
- en: '...     print(''B'')'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''B'')'
- en: '...'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '>>> if apple_total == banana_total:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> if apple_total == banana_total:'
- en: '...     print(''T'')'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''T'')'
- en: '...'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: T
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: T
- en: The blocks of the first two if statements are skipped, because their Boolean
    expressions are False. But the block of the third if statement executes, producing
    the T.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个 if 语句的代码块被跳过，因为它们的布尔表达式为 False。但第三个 if 语句的代码块会执行，输出 T。
- en: When you put one if statement after another, they’re independent. Each Boolean
    expression is evaluated, regardless of whether the previous Boolean expressions
    were True or False.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当你把一个 if 语句放在另一个后面时，它们是独立的。每个布尔表达式都会被评估，无论前面的布尔表达式是否为 True 或 False。
- en: 'For any given values of apple_total and banana_total, only one of our if statements
    can run. For example, if apple_total > banana_total is True, then the first if
    statement will run, but the other two will not. It’s possible to write the code
    to highlight that only one block of code is allowed to run. Here’s how we can
    do that:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的 apple_total 和 banana_total 值，只有一个 if 语句会被执行。例如，如果 apple_total > banana_total
    为 True，那么第一个 if 语句会被执行，其他两个将不会。我们可以通过编写代码来突出显示只有一个代码块被允许执行。下面是实现方法：
- en: '❶ >>> if apple_total > banana_total:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ >>> if apple_total > banana_total:'
- en: '...     print(''A'')'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''A'')'
- en: '❷ ... elif banana_total > apple_total:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ ... elif banana_total > apple_total:'
- en: '...     print(''B'')'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''B'')'
- en: '... elif apple_total == banana_total:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '... elif apple_total == banana_total:'
- en: '...     print(''T'')'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''T'')'
- en: '...'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: T
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: T
- en: This is now a single if statement, not three separate if statements. For this
    reason, don’t press ENTER at the ... prompt; instead, type the elif line.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这是一个单独的 if 语句，而不是三个独立的 if 语句。因此，不要在 ... 提示符下按 ENTER；而是直接输入 elif 行。
- en: To execute this if statement, Python begins by evaluating the first Boolean
    expression ❶. If it’s True, then A is output, and the rest of the elifs are skipped.
    If it’s False, Python continues, evaluating the second Boolean expression ❷. If
    it’s True, then B is output, and the remaining elif is skipped. If it’s False,
    Python continues, evaluating the third Boolean expression ❸. If it’s True, then
    T is output.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行这个 if 语句，Python 会首先评估第一个布尔表达式 ❶。如果它为 True，则输出 A，其他的 elif 会被跳过。如果它为 False，Python
    会继续评估第二个布尔表达式 ❷。如果它为 True，则输出 B，剩下的 elif 会被跳过。如果它为 False，Python 会继续评估第三个布尔表达式
    ❸。如果它为 True，则输出 T。
- en: The keyword elif stands for “else-if.” Use this as a reminder that an elif expression
    is checked only if nothing “else” before it in the if statement was executed.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字 elif 代表“else-if”（否则如果）。它提醒我们，只有在前面的 if 语句中的“else”部分没有被执行时，才会检查 elif 表达式。
- en: This version of the code is equivalent to the previous code where we used three
    separate if statements. Had we wanted to allow the possibility of executing more
    than one block, we’d have to use three separate if statements, not a single if
    statement with elif blocks.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这版本的代码等同于我们之前使用三个独立 if 语句的代码。如果我们希望允许执行多个代码块，我们应该使用三个独立的 if 语句，而不是一个包含 elif
    块的单一 if 语句。
- en: if with else
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 if 和 else
- en: 'We can use the else keyword to run code if all the Boolean expressions in the
    if statement are False. Here’s an example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 else 关键字在所有 if 语句的布尔表达式为 False 时执行代码。下面是一个示例：
- en: '>>> if apple_total > banana_total:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> if apple_total > banana_total:'
- en: '...     print(''A'')'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''A'')'
- en: '... elif banana_total > apple_total:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '... elif banana_total > apple_total:'
- en: '...     print(''B'')'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''B'')'
- en: '... else:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '... else:'
- en: '...     print(''T'')'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''T'')'
- en: '...'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: T
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: T
- en: Python evaluates the Boolean expressions from top to bottom. If any of them
    is True, Python runs the associated block and skips the rest of the if statement.
    If all the Boolean expressions are False, Python executes the else block.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Python 从上到下评估布尔表达式。如果其中任何一个为 True，Python 将执行相关的代码块并跳过剩下的 if 语句。如果所有布尔表达式都为 False，Python
    将执行 else 代码块。
- en: Notice that there is no longer a test for apple_total == banana_total. The only
    way to get to the else part of the if statement is if apple_total > banana_total
    is False and banana_total > apple_total is False, that is, if the values are equal.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不再测试 apple_total == banana_total。只有在 apple_total > banana_total 为 False
    且 banana_total > apple_total 为 False 时，也就是当值相等时，才会执行 else 部分。
- en: Should you use separate if statements? An if statement with elifs? An if statement
    with an else? It often comes down to preference. Use a chain of elifs if you want
    at most one block of code to execute. An else can help make the code clearer and
    removes the need to write a catchall Boolean expression. What’s far more important
    than the precise styling of an if statement is writing correct logic!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用独立的 if 语句吗？使用带有 elif 的 if 语句？还是使用带有 else 的 if 语句？这通常取决于个人偏好。如果你希望最多只有一个代码块被执行，可以使用一系列的
    elif 语句。else 语句可以帮助代码更清晰，并且避免需要写一个捕捉所有情况的布尔表达式。比起 if 语句的精确格式，更重要的是编写正确的逻辑！
- en: '**CONCEPT CHECK**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the value of x after the following code runs?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码执行后，x 的值是多少？
- en: x = 5
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: x = 5
- en: 'if x > 2:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x > 2:'
- en: x = -3
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: x = -3
- en: 'if x > 1:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x > 1:'
- en: x = 1
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: x = 1
- en: 'else:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: x = 3
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: x = 3
- en: A. -3
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: A. -3
- en: B. 1
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: B. 1
- en: C. 2
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: C. 2
- en: D. 3
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: D. 3
- en: E. 5
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: E. 5
- en: 'Answer: D. Because x > 2 is True, the block of the first if statement executes.
    The assignment x = -3 makes x refer to -3. Now for the second if statement. Here,
    x > 1 is False, so the else block runs, and x = 3 makes x refer to 3. I’d suggest
    changing if x > 1 to elif x > 1 and observing how the behavior of the program
    changes!'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：D。因为 x > 2 为 True，第一个 if 语句的代码块被执行。赋值语句 x = -3 使 x 的值变为 -3。接下来是第二个 if 语句，这里
    x > 1 为 False，因此执行 else 代码块，x = 3 使得 x 的值变为 3。我建议将 if x > 1 改为 elif x > 1，看看程序的行为如何变化！
- en: '**CONCEPT CHECK**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Do the following two snippets of code do exactly the same thing? Assume that
    temperature already refers to a number.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两段代码完全做相同的事情吗？假设 temperature 已经是一个数字。
- en: 'Snippet 1:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '片段 1:'
- en: 'if temperature > 0:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 'if temperature > 0:'
- en: print('warm')
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: print('warm')
- en: 'elif temperature == 0:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif temperature == 0:'
- en: print('zero')
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: print('zero')
- en: 'else:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print('cold')
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: print('cold')
- en: 'Snippet 2:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '片段 2:'
- en: 'if temperature > 0:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 'if temperature > 0:'
- en: print('warm')
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: print('warm')
- en: 'elif temperature == 0:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif temperature == 0:'
- en: print('zero')
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: print('zero')
- en: print('cold')
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: print('cold')
- en: A. Yes
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: A. 是的
- en: B. No
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: B. 否
- en: 'Answer: B. Snippet 2 *always* prints cold as its final line of output, because
    print(''cold'') is not indented! It is not associated with any if statement.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B。片段 2 *总是*将 cold 打印为最后一行输出，因为 print('cold') 没有缩进！它不属于任何 if 语句。
- en: Solving the Problem
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解题过程
- en: It’s time to solve Winning Team. In this book, I’ll generally present the full
    code and then discuss it. But as our solution here is longer than those in [Chapter
    1](ch01.xhtml#ch01), I’ve decided in this case to present the code in three pieces
    before presenting it as a whole.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候解决“胜利团队”问题了。在本书中，我通常会先展示完整的代码，然后进行讨论。但由于我们的解决方案比[第1章](ch01.xhtml#ch01)中的那些长，我决定在此先将代码分为三部分展示，再将其作为整体展示。
- en: 'First, we need to read the input. This requires six calls of input, because
    we have two teams and three pieces of information for each team. We also need
    to convert each piece of input to an integer. Here’s the code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要读取输入。这需要六次调用 input，因为我们有两个团队，每个团队有三项信息。我们还需要将每一项输入转换为整数。以下是代码：
- en: apple_three = int(input())
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: apple_three = int(input())
- en: apple_two = int(input())
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: apple_two = int(input())
- en: apple_one = int(input())
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: apple_one = int(input())
- en: banana_three = int(input())
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: banana_three = int(input())
- en: banana_two = int(input())
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: banana_two = int(input())
- en: banana_one = int(input())
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: banana_one = int(input())
- en: 'Second, we need to determine the number of points scored by the Apples and
    the Bananas. For each team, we add the points from three-point, two-point, and
    one-point plays. We can do that as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们需要确定 Apples 和 Bananas 得分的总数。对于每个团队，我们将三分球、两分球和一分球的得分加起来。我们可以这样做：
- en: apple_total = apple_three * 3 + apple_two * 2 + apple_one
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: apple_total = apple_three * 3 + apple_two * 2 + apple_one
- en: banana_total = banana_three * 3 + banana_two * 2 + banana_one
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: banana_total = banana_three * 3 + banana_two * 2 + banana_one
- en: 'Third, we produce the output. If the Apples win, we output A; if the Bananas
    win, we output B; otherwise, we know that the game is a tie, so we output T. We
    use an if statement to do this, as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步，我们生成输出。如果苹果队获胜，我们输出A；如果香蕉队获胜，我们输出B；否则，我们知道比赛是平局，因此输出T。我们使用if语句来实现这一点，如下所示：
- en: 'if apple_total > banana_total:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 'if apple_total > banana_total:'
- en: print('A')
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: print('A')
- en: 'elif banana_total > apple_total:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif banana_total > apple_total:'
- en: print('B')
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: print('B')
- en: 'else:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print('T')
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: print('T')
- en: That’s all the code we need. See [Listing 2-1](ch02.xhtml#ch02ex01) for the
    complete solution.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的所有代码。查看[列表 2-1](ch02.xhtml#ch02ex01)以获取完整的解决方案。
- en: apple_three = int(input())
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: apple_three = int(input())
- en: apple_two = int(input())
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: apple_two = int(input())
- en: apple_one = int(input())
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: apple_one = int(input())
- en: banana_three = int(input())
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: banana_three = int(input())
- en: banana_two = int(input())
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: banana_two = int(input())
- en: banana_one = int(input())
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: banana_one = int(input())
- en: apple_total = apple_three * 3 + apple_two * 2 + apple_one
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: apple_total = apple_three * 3 + apple_two * 2 + apple_one
- en: banana_total = banana_three * 3 + banana_two * 2 + banana_one
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: banana_total = banana_three * 3 + banana_two * 2 + banana_one
- en: 'if apple_total > banana_total:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 'if apple_total > banana_total:'
- en: print('A')
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: print('A')
- en: 'elif banana_total > apple_total:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif banana_total > apple_total:'
- en: print('B')
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: print('B')
- en: 'else:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print('T')
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: print('T')
- en: '*Listing 2-1: Solving Winning Team*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-1：解决获胜团队*'
- en: If you submit our code to the judge, you should see that all test cases pass.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将我们的代码提交给评测系统，你应该看到所有测试用例通过。
- en: '**CONCEPT CHECK**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Does the following version of the code correctly solve the problem?
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下版本的代码是否正确解决了问题？
- en: apple_three = int(input())
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: apple_three = int(input())
- en: apple_two = int(input())
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: apple_two = int(input())
- en: apple_one = int(input())
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: apple_one = int(input())
- en: banana_three = int(input())
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: banana_three = int(input())
- en: banana_two = int(input())
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: banana_two = int(input())
- en: banana_one = int(input())
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: banana_one = int(input())
- en: apple_total = apple_three * 3 + apple_two * 2 + apple_one
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: apple_total = apple_three * 3 + apple_two * 2 + apple_one
- en: banana_total = banana_three * 3 + banana_two * 2 + banana_one
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: banana_total = banana_three * 3 + banana_two * 2 + banana_one
- en: 'if apple_total < banana_total:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 'if apple_total < banana_total:'
- en: print('B')
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: print('B')
- en: 'elif apple_total > banana_total:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif apple_total > banana_total:'
- en: print('A')
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: print('A')
- en: 'else:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print('T')
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: print('T')
- en: A. Yes
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: A. 是
- en: B. No
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: B. 否
- en: 'Answer: A. The operators and order of the code are different, but the code
    is still correct. If the Apples lose, we output B (because the Bananas win); if
    the Apples win, we output A; otherwise, we know that the game is a tie, so we
    output T.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A。运算符和代码顺序不同，但代码仍然正确。如果苹果队失败，我们输出B（因为香蕉队获胜）；如果苹果队获胜，我们输出A；否则，我们知道比赛是平局，因此输出T。
- en: Before continuing, you might like to try solving exercise 1 from “Chapter Exercises”
    on [page 45](ch02.xhtml#ch02lev1sec13).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您可能想尝试解决《章节练习》中的第1题，详见[第45页](ch02.xhtml#ch02lev1sec13)。
- en: 'Problem #4: Telemarketers'
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #4：电话推销员'
- en: Sometimes we need to encode more complex Boolean expressions than those that
    we have seen so far. In this problem, we’ll learn about Boolean operators that
    help us do this.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要编码比目前所见更复杂的布尔表达式。在这个问题中，我们将学习帮助我们完成这项工作的布尔运算符。
- en: This is DMOJ problem ccc18j1.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题ccc18j1。
- en: The Challenge
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: 'In this problem, we’ll assume that phone numbers are four digits. A phone number
    belongs to a telemarketer if its four digits satisfy all three of the following
    properties:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们假设电话号码是四位数字。如果电话号码的四个数字满足以下三个条件中的所有条件，则属于电话推销员：
- en: The first digit is 8 or 9.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一位数字是8或9。
- en: The fourth digit is 8 or 9.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四位数字是8或9。
- en: The second and third digits are the same.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二位和第三位数字相同。
- en: For example, a phone number whose four digits are 8119 belongs to a telemarketer.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，电话号码的四个数字是8119，属于电话推销员。
- en: Determine whether a phone number belongs to a telemarketer, and indicate whether
    we should answer the phone or ignore it.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 确定电话号码是否属于电话推销员，并指示我们是否应该接电话或忽略它。
- en: Input
  id: totrans-307
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: There are four lines of input. These lines give the first, second, third, and
    fourth digits of the phone number, respectively. Each digit is an integer between
    0 and 9.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 输入有四行。这些行分别给出电话号码的第一、第二、第三和第四位数字。每位数字都是0到9之间的整数。
- en: Output
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: If the phone number belongs to a telemarketer, output ignore; otherwise, output
    answer.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果电话号码属于电话推销员，输出ignore；否则，输出answer。
- en: Boolean Operators
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔运算符
- en: What has to be true about a phone number that belongs to a telemarketer? Its
    first digit has to be 8 *or* 9. *And*, its fourth digit has to be 8 *or* 9. *And*,
    the second and third digits have to be the same. We can encode this “or” and “and”
    logic using Python’s *Boolean operators*.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 关于属于推销员的电话号码，必须满足什么条件？它的首位数字必须是 8 *或* 9。*并且*，它的第四位数字必须是 8 *或* 9。*并且*，第二位和第三位数字必须相同。我们可以使用
    Python 的 *布尔操作符* 来编码这种 “or” 和 “and” 逻辑。
- en: or Operator
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: or 操作符
- en: 'The or operator takes two Boolean expressions as its operands. It returns True
    if at least one operand is True, and False otherwise:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: or 操作符将两个布尔表达式作为操作数。如果至少有一个操作数为 True，则返回 True，否则返回 False：
- en: '>>> True or True'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> True or True'
- en: 'True'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> True or False'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> True or False'
- en: 'True'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> False or True'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> False or True'
- en: 'True'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> False or False'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> False or False'
- en: 'False'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: The only way to get False out of the or operator is if both of its operands
    are False.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 or 操作符返回 False，唯一的方法是两个操作数都为 False。
- en: 'We can use or to tell us whether a digit is an 8 or a 9:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 or 来判断一个数字是否为 8 或 9：
- en: '>>> digit = 8'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> digit = 8'
- en: '>>> digit == 8 or digit == 9'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> digit == 8 or digit == 9'
- en: 'True'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> digit = 3'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> digit = 3'
- en: '>>> digit == 8 or digit == 9'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> digit == 8 or digit == 9'
- en: 'False'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: Remember from “Integer and Floating-Point Numbers” in [Chapter 1](ch01.xhtml#ch01)
    that Python uses operator precedence to determine the order that operators are
    applied. The precedence of or is lower than the precedence of relational operators,
    which means that we don’t often need parentheses around operands. For example,
    in digit == 8 or digit == 9, the two operands to or are digit == 8 and digit ==
    9. It’s the same as if we’d written it as (digit == 8) or (digit == 9).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 请记得在 [第 1 章](ch01.xhtml#ch01) 的“整数和浮点数”中提到，Python 使用操作符优先级来决定操作符的应用顺序。or 的优先级低于关系操作符的优先级，这意味着我们通常不需要在操作数周围加括号。例如，在
    digit == 8 or digit == 9 中，or 的两个操作数是 digit == 8 和 digit == 9。这与我们写成 (digit ==
    8) or (digit == 9) 是一样的。
- en: 'In English, it makes sense if someone says “if the digit is 8 or 9.” But writing
    that won’t work in Python:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，如果有人说“如果数字是 8 或 9”，这很合理。但在 Python 中直接这么写是不行的：
- en: '>>> digit = 3'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> digit = 3'
- en: '>>> if digit == 8 or 9:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> if digit == 8 or 9:'
- en: '...     print(''yes!'')'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''yes!'')'
- en: '...'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: yes!
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: yes!
- en: Notice that I’ve (incorrectly!) written the second operand as 9 instead of digit
    == 9. Python responds by outputting yes!, which is certainly not what we’d want
    given that digit refers to 3. The reason is that Python considers nonzero numbers
    to be True. Since 9 is considered True, this makes the whole or expression True.
    Carefully double-check your Boolean expressions to avoid these kinds of mistakes
    when translating from natural language to Python.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我错误地将第二个操作数写成了 9，而不是 digit == 9。Python 输出了 yes!，这显然不是我们想要的结果，因为 digit 的值是
    3。原因是 Python 将非零数字视为 True。由于 9 被视为 True，这使得整个 or 表达式为 True。在将自然语言转为 Python 时，务必仔细检查布尔表达式，避免这类错误。
- en: and Operator
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: and 操作符
- en: 'The and operator returns True if both of its operands are True, and returns
    False otherwise:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: and 操作符在两个操作数都为 True 时返回 True，否则返回 False：
- en: '>>> True and True'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> True and True'
- en: 'True'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> True and False'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> True and False'
- en: 'False'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: '>>> False and True'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> False and True'
- en: 'False'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: '>>> False and False'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> False and False'
- en: 'False'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: The only way to get True out of the And operator is if both of its operands
    are True.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 And 操作符返回 True，唯一的方法是两个操作数都为 True。
- en: 'The precedence of and is higher than or. Here’s an example of why this matters:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: and 的优先级高于 or。下面是一个说明这点的例子：
- en: '>>> True or True and False'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> True or True and False'
- en: 'True'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: 'Python interprets that expression like this, with the and happening first:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Python 这样解析该表达式，首先执行 and 操作：
- en: '>>> True or (True and False)'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> True or (True and False)'
- en: 'True'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: The result is True because the first operand of or is True.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 结果为 True，因为 or 的第一个操作数为 True。
- en: 'We can force the or to happen first by including parentheses:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过加括号强制先执行 or 操作：
- en: '>>> (True or True) and False'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> (True or True) and False'
- en: 'False'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: The result is False because the second operand of and is False.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 结果为 False，因为 and 的第二个操作数为 False。
- en: not Operator
  id: totrans-361
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: not 操作符
- en: 'Another important Boolean operator is not. Unlike or and and, not takes only
    one operand (not two). If its operand is True, not returns False, and vice versa:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的布尔操作符是 not。与 or 和 and 不同，not 只有一个操作数。如果该操作数为 True，则 not 返回 False，反之亦然：
- en: '>>> not True'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> not True'
- en: 'False'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: '>>> not False'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> not False'
- en: 'True'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: The precedence of not is higher than or and and.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: not 的优先级高于 or 和 and。
- en: '**CONCEPT CHECK**'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Here’s an expression and versions of that expression with parentheses. Which
    of them evaluates to True?
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个表达式，以及该表达式的带括号版本。哪一个会返回 True？
- en: A. not True and False
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: A. not True and False
- en: B. (not True) and False
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: B. (not True) and False
- en: C. not (True and False)
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: C. not (True and False)
- en: D. None of the above
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: D. 以上都不是
- en: 'Answer: C. The expression (True and False) evaluates to False; the not therefore
    makes the full expression True.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：C. 表达式 (True and False) 结果为 False；因此 not 会使整个表达式为 True。
- en: '**CONCEPT CHECK**'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Consider the expression not a or b.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑表达式 not a or b。
- en: Which of the following makes the expression False?
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 以下哪个使得该表达式为 False？
- en: A. a False, b False
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: A. a 为 False, b 为 False
- en: B. a False, b True
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: B. a 为 False, b 为 True
- en: C. a True, b False
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: C. a 为 True, b 为 False
- en: D. a True, b True
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: D. a 为 True, b 为 True
- en: E. More than one of the above
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: E. 上述多个条件
- en: 'Answer: C. If a is True, then not a is False. Since b is False, too, both operands
    to or are False, so the whole expression evaluates to False.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：C. 如果 a 为 True，则 not a 为 False。由于 b 也是 False，两个 or 运算符的操作数都为 False，因此整个表达式的结果为
    False。
- en: Solving the Problem
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: With Boolean operators at the ready, we can tackle the Telemarketers problem.
    Our solution is in [Listing 2-2](ch02.xhtml#ch02ex02).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备好布尔运算符后，我们可以解决推销员问题。我们的解决方案见[清单 2-2](ch02.xhtml#ch02ex02)。
- en: num1 = int(input())
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: num1 = int(input())
- en: num2 = int(input())
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: num2 = int(input())
- en: num3 = int(input())
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: num3 = int(input())
- en: num4 = int(input())
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: num4 = int(input())
- en: ❶ if ((num1 == 8 or num1 == 9) and
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ if ((num1 == 8 or num1 == 9) and
- en: (num4 == 8 or num4 == 9) and
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: (num4 == 8 or num4 == 9) and
- en: '(num2 == num3)):'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '(num2 == num3)):'
- en: print('ignore')
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: print('ignore')
- en: 'else:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print('answer')
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: print('answer')
- en: '*Listing 2-2: Solving Telemarketers*'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-2：解决推销员问题*'
- en: As in Winning Team, we start by reading the input and converting it to integers.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 与《胜利团队》一样，我们首先读取输入并将其转换为整数。
- en: The high-level structure of our if statement ❶ is three expressions connected
    by and operators; each of them must be True for the entire expression to be True.
    We require that the first number be 8 or 9, that the fourth number be 8 or 9,
    and that the second and third numbers be equal. If all three of these conditions
    hold, then we know that the phone number belongs to a telemarketer, and we output
    ignore. Otherwise, the phone number does not belong to a telemarketer, and we
    output answer.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 if 语句的高级结构 ❶ 是三个通过 and 运算符连接的表达式；每个表达式必须为 True，整个表达式才为 True。我们要求第一个数字为 8
    或 9，第四个数字为 8 或 9，第二和第三个数字相等。如果这三种条件都成立，那么我们知道该电话号码属于推销员，我们输出 ignore。否则，该电话号码不属于推销员，我们输出
    answer。
- en: I’ve split the Boolean expression over three lines. This requires wrapping the
    entire expression in an additional pair of parentheses, as I have done. (Without
    those parentheses, you’ll get a syntax error, because there’s no indication to
    Python that the expression is continuing on the next line.)
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我将布尔表达式分成了三行。这需要将整个表达式包裹在一个额外的括号中，正如我所做的那样。（如果没有这些括号，您将会得到语法错误，因为 Python 无法判断该表达式将在下一行继续。）
- en: Python style guides suggest that a line be no longer than 79 characters. A line
    with the full Boolean expression would squeak in there at 76 characters. But I
    think the three-line version is clearer, highlighting each condition that must
    be True on its own line.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: Python 风格指南建议一行代码不超过 79 个字符。一行完整的布尔表达式会达到 76 个字符，但我认为三行版本更清晰，突出了每个条件必须为 True
    的要求。
- en: We have a good solution here. To explore a little further, let’s discuss some
    alternate approaches.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有一个很好的解决方案。为了进一步探索，我们来讨论一些替代方法。
- en: Our code uses a Boolean expression to detect when a phone number belongs to
    a telemarketer. We could have also chosen to write code that detects when a phone
    number does *not* belong to a telemarketer. If the phone number doesn’t belong
    to a telemarketer, we should output answer; otherwise, we should output ignore.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码使用布尔表达式来检测电话号码是否属于推销员。我们也可以选择编写代码来检测电话号码是否*不*属于推销员。如果电话号码不属于推销员，我们应该输出
    answer；否则，我们应该输出 ignore。
- en: If the first digit isn’t 8 and isn’t 9, then the phone number doesn’t belong
    to a telemarketer. Or, if the fourth digit isn’t 8 and isn’t 9, then the phone
    number doesn’t belong to a telemarketer. Or, if the second and third digits aren’t
    equal, then the phone number doesn’t belong to a telemarketer. If even one of
    these expressions is True, then the phone number doesn’t belong to a telemarketer.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个数字既不是 8 也不是 9，那么该电话号码不属于推销员。或者，如果第四个数字既不是 8 也不是 9，那么该电话号码不属于推销员。或者，如果第二和第三个数字不相等，那么该电话号码不属于推销员。如果这些表达式中有任何一个为
    True，那么该电话号码不属于推销员。
- en: See [Listing 2-3](ch02.xhtml#ch02ex03) for a version of the code that captures
    this logic.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[清单 2-3](ch02.xhtml#ch02ex03)，其中包含了捕捉此逻辑的代码版本。
- en: num1 = int(input())
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: num1 = int(input())
- en: num2 = int(input())
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: num2 = int(input())
- en: num3 = int(input())
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: num3 = int(input())
- en: num4 = int(input())
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: num4 = int(input())
- en: if ((num1 != 8 and num1 != 9) or
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ((num1 != 8 并且 num1 != 9) 或
- en: (num4 != 8 and num4 != 9) or
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: (num4 != 8 和 num4 != 9) 或
- en: '(num2 != num3)):'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '(num2 != num3)):'
- en: print('answer')
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: print('answer')
- en: 'else:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: print('ignore')
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: print('ignore')
- en: '*Listing 2-3: Solving Telemarketers, alternate approach*'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-3：解决电话推销员问题，替代方法*'
- en: It’s not easy getting all of those !=, or, and and operators correct! Notice,
    for example, that we’ve had to change all == operators to !=, all or operators
    to and, and all and operators to or.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 正确处理所有这些 !=、or 和 and 运算符可不容易！例如，注意我们不得不将所有 == 运算符改为 !=，所有 or 运算符改为 and，所有 and
    运算符改为 or。
- en: An alternate approach is to use the not operator to negate the “is a telemarketer”
    expression in one shot. See [Listing 2-4](ch02.xhtml#ch02ex04) for that code.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 not 运算符来一次性否定“是电话推销员”的表达式。请参阅 [列表 2-4](ch02.xhtml#ch02ex04) 查看该代码。
- en: num1 = int(input())
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: num1 = int(input())
- en: num2 = int(input())
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: num2 = int(input())
- en: num3 = int(input())
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: num3 = int(input())
- en: num4 = int(input())
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: num4 = int(input())
- en: if not ((num1 == 8 or num1 == 9) and
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是 ((num1 == 8 或 num1 == 9) 并且
- en: (num4 == 8 or num4 == 9) and
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: (num4 == 8 或 num4 == 9) 并且
- en: '(num2 == num3)):'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '(num2 == num3)):'
- en: print('answer')
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: print('answer')
- en: 'else:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: print('ignore')
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: print('ignore')
- en: '*Listing 2-4: Solving Telemarketers, not operator*'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-4：解决电话推销员问题，not 运算符*'
- en: Which of these solutions do you find most intuitive? There’s often more than
    one way to structure the logic of an if statement, and we should use the one that’s
    easiest to get right. To me, [Listing 2-2](ch02.xhtml#ch02ex02) is the most natural,
    but you may feel otherwise!
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 你觉得这些解决方案哪种最直观？if 语句的逻辑结构通常有多种方式，我们应该选择最容易正确的方式。对我而言，[列表 2-2](ch02.xhtml#ch02ex02)
    是最自然的，但你可能有不同的看法！
- en: Choose your favorite version and submit it to the judge. You should see that
    all test cases pass.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 选择你最喜欢的版本并提交给评审员。你应该会看到所有测试用例都通过了。
- en: Comments
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: 'We should always strive to make our programs as clear as possible. This helps
    to avoid introducing errors when programming and makes it easier to fix our code
    when errors do slip in. Meaningful variable names, spaces around operators, blank
    lines to segment the program into its logical pieces, simple if statement logic:
    all of these practices can improve the quality of the code we write. Another good
    habit is adding *comments* to our code.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终努力使我们的程序尽可能清晰。这有助于避免编程时引入错误，并且在错误出现时更容易修复代码。具有意义的变量名、运算符周围的空格、用空行将程序分段、简洁的
    if 语句逻辑：这些做法都能提高我们编写代码的质量。另一个好习惯是给代码添加*注释*。
- en: 'A comment is introduced by the # character and continues until the end of the
    line. Python ignores comments, so they have no impact on what our program does.
    We add comments to remind ourselves, or others, about design decisions that we’ve
    made. Assume that the person reading the code knows Python, so avoid comments
    that simply restate what the code is doing. Here’s code with an unnecessary comment:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '注释由 # 字符引入，并持续到行末。Python 会忽略注释，因此它们不会对程序的执行产生任何影响。我们添加注释是为了提醒自己或他人我们所做的设计决策。假设读代码的人已经了解
    Python，因此避免添加仅仅重复代码功能的注释。以下是一个带有不必要注释的代码：'
- en: '>>> x = 5'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = 5'
- en: '>>> x = x + 1  # Increase x by 1'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = x + 1  # 将 x 增加 1'
- en: That comment adds nothing beyond what we already know about assignment statements.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 该注释没有添加任何超出我们已知的关于赋值语句的信息。
- en: See [Listing 2-5](ch02.xhtml#ch02ex05) for a version of [Listing 2-2](ch02.xhtml#ch02ex02)
    with comments.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [列表 2-5](ch02.xhtml#ch02ex05) 查看带有注释的 [列表 2-2](ch02.xhtml#ch02ex02) 的版本。
- en: '❶ # ccc18j1, Telemarketers'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ # ccc18j1，电话推销员'
- en: num1 = int(input())
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: num1 = int(input())
- en: num2 = int(input())
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: num2 = int(input())
- en: num3 = int(input())
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: num3 = int(input())
- en: num4 = int(input())
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: num4 = int(input())
- en: '❷ # Telemarketer number: first digit 8 or 9, fourth digit 8 or 9,'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ # 电话推销员号码：首位数字为 8 或 9，第四位数字为 8 或 9，'
- en: '# second digit and third digit are same'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '# 第二位和第三位相同'
- en: if ((num1 == 8 or num1 == 9) and
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 ((num1 == 8 或 num1 == 9) 并且
- en: (num4 == 8 or num4 == 9) and
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: (num4 == 8 或 num4 == 9) 并且
- en: '(num2 == num3)):'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '(num2 == num3)):'
- en: print('ignore')
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: print('ignore')
- en: 'else:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: print('answer')
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: print('answer')
- en: '*Listing 2-5: Solving Telemarketers, comments added*'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-5：解决电话推销员问题，已添加注释*'
- en: 'I’ve added three comment lines: the one at the top ❶ reminds us of the problem
    code and name, and the two before the if statement ❷ remind us of the rules for
    detecting a telemarketer phone number.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我已添加了三行注释：顶部的 ❶ 提醒我们问题代码和名称，if 语句之前的两行 ❷ 提醒我们检测电话推销员电话号码的规则。
- en: Don’t go overboard with comments. Whenever possible, write code that doesn’t
    require comments in the first place. But for tricky code or to document why you
    chose to do something in a particular way, a well-placed comment now can save
    time and frustration later.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过度使用注释。尽可能编写不需要注释的代码。但对于复杂的代码，或者解释你为什么要以某种特定方式做事情，一个合适的注释可以在以后节省时间并避免挫折。
- en: Input and Output Redirection
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入和输出重定向
- en: When you submit Python code to the judge, it runs many test cases to determine
    whether your code is correct. Is someone there, dutifully waiting for new code
    and then frantically hammering test cases at it from the keyboard?
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将Python代码提交给裁判时，它会运行多个测试用例来判断代码是否正确。是不是有人在那里，尽职尽责地等待新的代码，并疯狂地从键盘输入测试用例？
- en: No way! It’s all automated. There’s no one typing test cases at the keyboard.
    How does the judge test our code, then, if we satisfy a call to input by typing
    something from the keyboard?
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能！这一切都是自动化的。没有人会在键盘上输入测试用例。那么，如果我们通过键盘输入某些内容来满足输入要求，裁判是如何测试我们的代码的呢？
- en: The truth is that input isn’t necessarily reading input from the keyboard. It’s
    reading from a source of input called *standard input*, which, by default, is
    the keyboard.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，输入不一定是从键盘读取的。它是从一个叫做*标准输入*的输入源读取的，默认情况下就是从键盘读取。
- en: It’s possible to change standard input so that it refers to a file rather than
    the keyboard. The technique is called *input redirection*, and it’s what the judge
    uses to provide input.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以改变标准输入，使其指向一个文件而不是键盘。这种技术叫做*输入重定向*，也是裁判用来提供输入的方式。
- en: We can also try input redirection ourselves. For programs whose input is small—just
    a line of text or a couple of integers—input redirection may not save us much.
    But for programs whose test cases can be tens or hundreds of lines long, input
    redirection makes it much easier to test our work. Rather than typing the same
    test case over and over, we can store it in a file and then run our program on
    it as many times as we want.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以尝试自己进行输入重定向。对于那些输入较小的程序——比如一行文本或者几个整数——输入重定向可能不会给我们节省太多时间。但对于那些测试用例有数十行或数百行长的程序，输入重定向可以让我们更轻松地测试我们的工作。我们不必一次次输入相同的测试用例，而是可以把它们存储在文件中，然后按需运行程序。
- en: 'Let’s try input redirection on Telemarketers. Navigate to your *programming*
    folder and create a new file called *telemarketers_input.txt*. In that file, type
    the following:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Telemarketers上尝试输入重定向。进入你的*programming*文件夹，创建一个名为*telemarketers_input.txt*的新文件。在该文件中输入以下内容：
- en: '8'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '1'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '1'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '9'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: The problem specifies that we should provide one integer per line, so we’ve
    written them one per line here.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 题目要求我们每行提供一个整数，所以我们在这里也把它们写成每行一个。
- en: Save the file. Now enter python telemarketers.py < telemarketers_input.txt to
    run your program using input redirection. Your program should output ignore, just
    as it would if you’d typed the test case from the keyboard.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件。现在输入 `python telemarketers.py < telemarketers_input.txt` 来使用输入重定向运行你的程序。程序应该输出忽略，就像你直接从键盘输入测试用例一样。
- en: The < symbol instructs your operating system to use a file rather than the keyboard
    to provide input. After the < symbol comes the name of the file that contains
    the input.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '`<` 符号指示你的操作系统使用文件而不是键盘提供输入。在 `<` 符号后面是包含输入的文件名。'
- en: To try your program on different test cases, just modify the *telemarketers_input.txt*
    file and run your program again.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不同的测试用例上测试你的程序，只需修改*telemarketers_input.txt*文件，然后再次运行你的程序。
- en: We can also change where our output goes, though we won’t need to for this book.
    The print function outputs to *standard output*, which, by default, is the screen.
    We can change standard output so that it instead refers to a file. We do so using
    *output redirection*, which is written as a > symbol followed by a filename.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以改变输出的去向，尽管在本书中不需要这么做。`print`函数默认输出到*标准输出*，通常是屏幕。我们可以改变标准输出，让它指向一个文件。我们通过*输出重定向*来实现这一点，写法是一个
    > 符号后面跟着文件名。
- en: Enter python telemarketers.py > telemarketers_output.txt to run your program
    using output redirection. Provide four integers of input, and you should be back
    to your operating system prompt. But you shouldn’t see any output from your Telemarketers
    program! That’s because we’ve redirected the output to file telemarketers_output.txt.
    If you open telemarketers_output.txt in your text editor, you should see the output
    there.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `python telemarketers.py > telemarketers_output.txt` 来使用输出重定向运行你的程序。提供四个整数的输入后，你应该会返回到操作系统提示符。但你不应该看到来自电话推销员程序的任何输出！这是因为我们已将输出重定向到文件telemarketers_output.txt。如果你在文本编辑器中打开telemarketers_output.txt，你应该能看到里面的输出。
- en: Be careful with output redirection. If you use a filename that already exists,
    your old file will be overwritten! Always double-check that you’re using the filename
    you intended.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 小心使用输出重定向。如果你使用了一个已存在的文件名，旧文件会被覆盖！始终再次检查你是否使用了正确的文件名。
- en: Summary
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to use if statements to direct what our programs
    do. The key ingredient of an if statement is a Boolean expression, which is an
    expression with a True or False value. To build up Boolean expressions, we use
    relational operators such as == and >=, and we use Boolean operators such as and
    and or.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，我们学习了如何使用if语句来控制程序的执行。if语句的关键成分是布尔表达式，它是一个值为True或False的表达式。为了构建布尔表达式，我们使用关系运算符，比如==和>=，还使用布尔运算符，如and和or。
- en: Deciding what to do based on what is True and False makes our programs more
    flexible, able to adapt to the situation at hand. But our programs are still limited
    to handling small amounts of input and output—whatever we can do with individual
    calls to input and print. In the next chapter, we’ll start learning about loops,
    which let us repeat code so that we can process as much input and output as we
    like.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 根据True和False决定做什么，使得我们的程序更灵活，能够适应当前的情况。但是我们的程序仍然局限于处理小量的输入和输出——无论是通过单独的input和print调用能做到什么。在下一章，我们将开始学习循环结构，它允许我们重复代码，从而处理任意数量的输入和输出。
- en: Want to work with 100 values? How about 1,000? And with just a small amount
    of Python code? It is a little early for me to be provoking you, I know, because
    you still have the following exercises to do. But when you’re ready, read on!
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 想处理100个值吗？那1,000个呢？而且只需要少量的Python代码？我知道现在挑衅你有点早，因为你还有以下的练习要做。但当你准备好了，继续往下读吧！
- en: Chapter Exercises
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章练习
- en: Here are some exercises for you to try.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些练习供你尝试。
- en: DMOJ problem ccc06j1, Canadian Calorie Counting
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ题目 ccc06j1, 加拿大卡路里计算
- en: DMOJ problem ccc15j1, Special Day
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ题目 ccc15j1, 特别的日子
- en: DMOJ problem ccc15j2, Happy or Sad
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ题目 ccc15j2, 开心还是难过
- en: DMOJ problem dmopc16c1p0, C.C. and Cheese-kun
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ题目 dmopc16c1p0, C.C. 和奶酪君
- en: DMOJ problem ccc07j1, Who is in the Middle
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ题目 ccc07j1, 谁在中间
- en: Notes
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Winning Team is originally from the 2019 Canadian Computing Competition, Junior
    Level. Telemarketers is originally from the 2018 Canadian Computing Competition,
    Junior Level.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 《获胜队伍》最初来源于2019年加拿大计算机竞赛，初级组。《电话推销员》最初来源于2018年加拿大计算机竞赛，初级组。
