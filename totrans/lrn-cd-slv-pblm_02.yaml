- en: '2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '2'
- en: MAKING DECISIONS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 做出决策
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: 'Most programs that we use on a daily basis behave differently depending on
    what happens during their execution. For example, when a word processor asks us
    whether we want to save our work, it makes a decision based on our response: saving
    our work if we answer “yes” and not saving our work if we answer “no.” In this
    chapter, we’ll learn about if statements, which let our programs make decisions.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们日常使用的大多数程序会根据执行过程中的不同情况做出不同的反应。例如，当文字处理软件询问我们是否保存工作时，它会根据我们的回答做出决策：如果回答“是”，则保存工作；如果回答“否”，则不保存工作。在本章中，我们将学习if语句，它能让我们的程序做出决策。
- en: 'We’ll solve two problems: determining the result of a basketball game and determining
    whether a phone number belongs to a telemarketer.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解决两个问题：确定篮球比赛的结果，以及判断一个电话号码是否属于推销员。
- en: 'Problem #3: Winning Team'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #3：获胜队伍'
- en: In this problem, we’ll need to output a message that depends on the outcome
    of a basketball game. To do that, we’ll learn all about if statements. We’ll also
    learn how we can store and manipulate true and false values in our programs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们需要输出一条依赖于篮球比赛结果的消息。为此，我们将学习所有关于if语句的知识。我们还将学习如何在程序中存储和处理真假值。
- en: This is DMOJ problem ccc19j1.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题ccc19j1。
- en: The Challenge
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: 'In basketball, three plays score points: a three-point shot, a two-point shot,
    and a one-point free throw.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在篮球比赛中，有三种方式得分：三分投篮、两分投篮和单分罚球。
- en: You just watched a basketball game between the Apples and Bananas and recorded
    the number of successful three-point, two-point, and one-point plays for each
    team. Indicate whether the game was won by the Apples, the game was won by the
    Bananas, or the game was a tie.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚观看了一场苹果队与香蕉队的篮球比赛，并记录了每个队伍成功的三分、两分和单分罚球次数。请判断是苹果队获胜、香蕉队获胜，还是比赛平局。
- en: Input
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: There are six lines of input. The first three give the scoring for the Apples,
    and the latter three give the scoring for the Bananas.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 输入有六行。前面三行给出了苹果队的得分，后面三行给出了香蕉队的得分。
- en: The first line gives the number of successful three-point shots for the Apples.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行给出苹果队成功的三分投篮次数。
- en: The second line gives the number of successful two-point shots for the Apples.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行给出苹果队成功的两分投篮次数。
- en: The third line gives the number of successful one-point free throws for the
    Apples.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行给出苹果队成功的单分罚球次数。
- en: The fourth line gives the number of successful three-point shots for the Bananas.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四行给出香蕉队成功的三分投篮次数。
- en: The fifth line gives the number of successful two-point shots for the Bananas.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五行给出香蕉队成功的两分投篮次数。
- en: The sixth line gives the number of successful one-point free throws for the
    Bananas.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第六行给出香蕉队成功的单分罚球次数。
- en: Each number is an integer between 0 and 100.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数字是0到100之间的整数。
- en: Output
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: The output is a single character.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是一个单一的字符。
- en: If the Apples scored more points than the Bananas, output A (*A* for Apples).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果苹果队得分超过香蕉队，输出A（*A*表示苹果队）。
- en: If the Bananas scored more points than the Apples, output B (*B* for Bananas).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果香蕉队得分超过苹果队，输出B（*B*表示香蕉队）。
- en: If the Apples and Bananas scored the same number of points, output T (*T* for
    Tie).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果苹果队和香蕉队得分相同，输出T（*T*表示平局）。
- en: Conditional Execution
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件执行
- en: We can make a lot of headway here by using what we learned in [Chapter 1](ch01.xhtml#ch01).
    We can use input and int to read each of the six integers from the input. We can
    use variables to hang on to those values. We can multiply the number of successful
    three-point shots by 3 and the number of successful two-point shots by 2\. We
    can use print to output an A, B, or T.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在[第1章](ch01.xhtml#ch01)中学到的内容来取得很大进展。我们可以使用input和int来读取输入的六个整数。我们可以使用变量来保存这些值。我们可以将成功的三分投篮次数乘以3，将成功的两分投篮次数乘以2。我们可以使用print输出A、B或T。
- en: What we haven’t learned yet is how our programs can make a decision about the
    outcome of the game. I can demonstrate why we need this through two test cases.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有学到的是，如何让我们的程序根据比赛结果做出决策。我可以通过两个测试用例来演示为什么我们需要这个。
- en: 'First, consider this test case:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑这个测试用例：
- en: '5'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '1'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '3'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '1'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '1'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '1'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: 'The Apples scored 5 * 3 + 1 * 2 + 3 = 20 points, and the Bananas scored 1 *
    3 + 1 * 2 + 1 = 6 points. The Apples won the game, so this is the correct output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果队得了5 * 3 + 1 * 2 + 3 = 20分，香蕉队得了1 * 3 + 1 * 2 + 1 = 6分。苹果队赢得了比赛，因此这是正确的输出：
- en: A
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: A
- en: 'Second, consider this test case, where the Apples’ and Bananas’ scores have
    been swapped:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，考虑这个测试案例，其中苹果队和香蕉队的分数被交换了：
- en: '1'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '1'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '1'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '5'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '1'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '3'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: 'This time, the Bananas won the game, so this is the correct output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，香蕉队赢得了比赛，所以这是正确的输出：
- en: B
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: B
- en: Our program must be able to compare the total points scored by the Apples and
    the total points scored by the Bananas and use the result of that comparison to
    choose whether to output A, B, or T.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序必须能够比较苹果队和香蕉队的总得分，并根据这个比较结果选择输出 A、B 或 T。
- en: We can use Python’s if statement to make these kinds of decisions. A *condition*
    is an expression that’s true or false, and an if statement uses conditions to
    determine what to do. if statements lead to *conditional execution*, so named
    because the execution of our program is influenced by conditions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Python 的 if 语句来做出这些决策。*条件*是一个真假值的表达式，if 语句使用条件来决定该做什么。if 语句导致 *条件执行*，其名称来源于程序的执行受到条件的影响。
- en: We’ll first learn about a new type that lets us represent true or false values,
    and how we can build expressions of this type. Then, we’ll use such expressions
    to write if statements.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要学习一个新的类型，它让我们能够表示真假值，以及如何构建这种类型的表达式。然后，我们将使用这些表达式来编写 if 语句。
- en: The Boolean Type
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔类型
- en: 'Pass an expression to Python’s type function, and it’ll tell you the type of
    the expression’s value:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 将表达式传递给 Python 的 type 函数，它会告诉你该表达式值的类型：
- en: '>>> type(14)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(14)'
- en: <class 'int'>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'int'>
- en: '>>> type(9.5)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(9.5)'
- en: <class 'float'>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'float'>
- en: '>>> type(''hello'')'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(''hello'')'
- en: <class 'str'>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'str'>
- en: '>>> type(12 + 15)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(12 + 15)'
- en: <class 'int'>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'int'>
- en: 'One Python type we haven’t met yet is the Boolean (bool) type. Unlike integers,
    strings, and floats, which have billions of possible values, there are only two
    Boolean values: True and False. These are exactly the values we need to represent
    the result of a condition.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有遇到过的 Python 类型是布尔（bool）类型。与整数、字符串和浮点数不同，布尔类型只有两个可能的值：True 和 False。这正是我们用来表示条件结果的值。
- en: '>>> True'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> True'
- en: 'True'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> False'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> False'
- en: 'False'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: '>>> type(True)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(True)'
- en: <class 'bool'>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'bool'>
- en: '>>> type(False)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> type(False)'
- en: <class 'bool'>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <class 'bool'>
- en: What can we do with these values? With numbers, we had mathematical operators
    like + and - that let us combine values into more complex expressions. We’ll need
    a new set of operators that work with Boolean values.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能用这些值做什么呢？对于数字，我们有加法和减法等数学运算符，它们允许我们将值组合成更复杂的表达式。我们将需要一组新的操作符来处理布尔值。
- en: Relational Operators
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关系操作符
- en: Is 5 greater than 2? Is 4 less than 1? We can make such comparisons using Python’s
    *relational operators*. They produce True or False and are therefore used to write
    *Boolean expressions*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 5 大于 2 吗？4 小于 1 吗？我们可以使用 Python 的 *关系操作符* 来进行这样的比较。它们返回 True 或 False，因此用于编写
    *布尔表达式*。
- en: 'The > operator takes two operands and returns True if the first is greater
    than the second, and False otherwise:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '> 操作符接受两个操作数，如果第一个操作数大于第二个操作数，则返回 True，否则返回 False：'
- en: '>>> 5 > 2'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 5 > 2'
- en: 'True'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> 9 > 10'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 9 > 10'
- en: 'False'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: 'Similarly, we have the < operator for less-than:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们有 < 操作符用于小于：
- en: '>>> 4 < 1'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 4 < 1'
- en: 'False'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: '>>> -2 < 0'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> -2 < 0'
- en: 'True'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: 'There’s >= for greater-than-or-equal-to, and <= for less-than-or-equal-to:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有 >= 用于大于或等于，<= 用于小于或等于：
- en: '>>> 4 >= 2'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 4 >= 2'
- en: 'True'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> 4 >= 4'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 4 >= 4'
- en: 'True'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> 4 >= 5'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 4 >= 5'
- en: 'False'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: '>>> 8 <= 6'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 8 <= 6'
- en: 'False'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: To determine equality, we use the == operator. That’s two equal signs, not one.
    Remember that one equal sign (=) is used in an assignment statement; it has nothing
    to do with checking equality.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了判断相等性，我们使用 == 操作符。那是两个等号，而不是一个。记住，一个等号（=）用于赋值语句；它与检查相等性无关。
- en: '>>> 5 == 5'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 5 == 5'
- en: 'True'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> 15 == 10'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 15 == 10'
- en: 'False'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: 'For inequality, we use the != operator. It returns True if the operands are
    not equal and False if they are equal:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不等式，我们使用 != 操作符。如果操作数不相等，则返回 True，如果相等，则返回 False：
- en: '>>> 5 != 5'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 5 != 5'
- en: 'False'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: '>>> 15 != 10'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 15 != 10'
- en: 'True'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: Real programs wouldn’t evaluate expressions whose values we already know. We
    don’t need Python to tell us that 15 doesn’t equal 10. More typically, we’d use
    variables in these kinds of expressions. For example, number != 10 is an expression
    whose value depends on what number refers to.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的程序不会评估那些我们已经知道其值的表达式。我们不需要 Python 告诉我们 15 不等于 10。更常见的是，我们会在这些表达式中使用变量。例如，number
    != 10 是一个依赖于 number 所指向的值的表达式。
- en: 'The relational operators also work on strings. When checking equality, case
    matters:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 关系操作符也可以作用于字符串。在检查相等性时，大小写是重要的：
- en: '>>> ''hello'' == ''hello'''
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''Hello'' == ''hello'''
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'One string is less than another if it comes first in alphabetical order:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''brave'' < ''cave'''
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''cave'' < ''cavern'''
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''orange'' < ''apple'''
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'But things can be surprising when lowercase and uppercase characters are both
    involved:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''apple'' < ''Banana'''
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Weird, right? It has to do with the way that characters are stored internally
    in a computer. Generally, uppercase characters come alphabetically before lowercase
    characters. And check this out:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''10'' < ''4'''
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: If these were numbers, then the result would be False. But strings are compared
    character by character from left to right. Python compares the '1' and '4', and
    because '1' is smaller, the < operator returns True. Be sure that your values
    have the types you think they have!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'One relational operator that works on strings but not numbers is in. It returns
    True if the first string occurs at least once in the second, and False otherwise:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''ppl'' in ''apple'''
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ''ale'' in ''apple'''
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: a = 3
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: b = (a != 3)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: print(b)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: A. True
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: B. False
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: C. 3
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: D. This code produces a syntax error
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: B. The expression a != 3 evaluates to False; b is then made to refer
    to this False value.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The if Statement
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll now explore several variations of Python’s if statement.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: if by Itself
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Suppose we have our final scores in two variables, apple_total and banana_total,
    and we want to output A if apple_total is greater than banana_total. Here’s how
    we can do that:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '>>> apple_total = 20'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '>>> banana_total = 6'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '>>> if apple_total > banana_total:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''A'')'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: A
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Python outputs A, as we’d expect.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: An if statement starts with the keyword if. A *keyword* is a word that has special
    meaning to Python and cannot be used as a variable name. The keyword if is followed
    by a Boolean expression, followed by a colon, followed by one or more indented
    statements. The indented statements are often referred to as the *block* of the
    if statement. The block executes if the Boolean expression is True and is skipped
    if the Boolean expression is False.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the prompt changes from >>> to .... That’s a reminder that we’re
    inside the block of the if statement and must indent the code. I’ve chosen to
    indent by four spaces, so to indent the code, press the spacebar four times. Some
    Python programmers press the TAB key to indent, but we’ll exclusively use spaces
    in this book.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Once you type print('A') and hit ENTER, you should see another ... prompt. Since
    we don’t have anything else to put in this if statement, press ENTER again to
    dismiss this prompt and return to the >>> prompt. This extra press of ENTER is
    a quirk of the Python shell; such blank lines are not required when we write a
    Python program in a file.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example of putting two statements in the block of an if statement:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '>>> apple_total = 20'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '>>> banana_total = 6'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '>>> if apple_total > banana_total:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''A'')'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''Apples win!'')'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: A
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Apples win!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Both print calls execute, producing two lines of output.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try another if statement, this one with a Boolean expression that’s False:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '>>> apple_total = 6'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '>>> banana_total = 20'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '>>> if apple_total > banana_total:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''A'')'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'The print function is *not* called this time: apple_total > banana_total is
    False, so the block of the if statement is skipped.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: if with elif
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s use three successive if statements to print A if the Apples win, B if
    the Bananas win, and T if it’s a tie:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '>>> apple_total = 6'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '>>> banana_total = 6'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '>>> if apple_total > banana_total:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''A'')'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '>>> if banana_total > apple_total:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''B'')'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '>>> if apple_total == banana_total:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''T'')'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: T
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The blocks of the first two if statements are skipped, because their Boolean
    expressions are False. But the block of the third if statement executes, producing
    the T.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: When you put one if statement after another, they’re independent. Each Boolean
    expression is evaluated, regardless of whether the previous Boolean expressions
    were True or False.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'For any given values of apple_total and banana_total, only one of our if statements
    can run. For example, if apple_total > banana_total is True, then the first if
    statement will run, but the other two will not. It’s possible to write the code
    to highlight that only one block of code is allowed to run. Here’s how we can
    do that:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '❶ >>> if apple_total > banana_total:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''A'')'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '❷ ... elif banana_total > apple_total:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''B'')'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '... elif apple_total == banana_total:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''T'')'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: T
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: This is now a single if statement, not three separate if statements. For this
    reason, don’t press ENTER at the ... prompt; instead, type the elif line.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: To execute this if statement, Python begins by evaluating the first Boolean
    expression ❶. If it’s True, then A is output, and the rest of the elifs are skipped.
    If it’s False, Python continues, evaluating the second Boolean expression ❷. If
    it’s True, then B is output, and the remaining elif is skipped. If it’s False,
    Python continues, evaluating the third Boolean expression ❸. If it’s True, then
    T is output.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The keyword elif stands for “else-if.” Use this as a reminder that an elif expression
    is checked only if nothing “else” before it in the if statement was executed.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: This version of the code is equivalent to the previous code where we used three
    separate if statements. Had we wanted to allow the possibility of executing more
    than one block, we’d have to use three separate if statements, not a single if
    statement with elif blocks.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: if with else
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can use the else keyword to run code if all the Boolean expressions in the
    if statement are False. Here’s an example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '>>> if apple_total > banana_total:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''A'')'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '... elif banana_total > apple_total:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''B'')'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '... else:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''T'')'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: T
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Python evaluates the Boolean expressions from top to bottom. If any of them
    is True, Python runs the associated block and skips the rest of the if statement.
    If all the Boolean expressions are False, Python executes the else block.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Python 从上到下评估布尔表达式。如果其中任何一个为 True，Python 将执行相关的代码块并跳过剩下的 if 语句。如果所有布尔表达式都为 False，Python
    将执行 else 代码块。
- en: Notice that there is no longer a test for apple_total == banana_total. The only
    way to get to the else part of the if statement is if apple_total > banana_total
    is False and banana_total > apple_total is False, that is, if the values are equal.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不再测试 apple_total == banana_total。只有在 apple_total > banana_total 为 False
    且 banana_total > apple_total 为 False 时，也就是当值相等时，才会执行 else 部分。
- en: Should you use separate if statements? An if statement with elifs? An if statement
    with an else? It often comes down to preference. Use a chain of elifs if you want
    at most one block of code to execute. An else can help make the code clearer and
    removes the need to write a catchall Boolean expression. What’s far more important
    than the precise styling of an if statement is writing correct logic!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用独立的 if 语句吗？使用带有 elif 的 if 语句？还是使用带有 else 的 if 语句？这通常取决于个人偏好。如果你希望最多只有一个代码块被执行，可以使用一系列的
    elif 语句。else 语句可以帮助代码更清晰，并且避免需要写一个捕捉所有情况的布尔表达式。比起 if 语句的精确格式，更重要的是编写正确的逻辑！
- en: '**CONCEPT CHECK**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the value of x after the following code runs?
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码执行后，x 的值是多少？
- en: x = 5
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: x = 5
- en: 'if x > 2:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x > 2:'
- en: x = -3
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: x = -3
- en: 'if x > 1:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 'if x > 1:'
- en: x = 1
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: x = 1
- en: 'else:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: x = 3
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: x = 3
- en: A. -3
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: A. -3
- en: B. 1
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: B. 1
- en: C. 2
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: C. 2
- en: D. 3
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: D. 3
- en: E. 5
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: E. 5
- en: 'Answer: D. Because x > 2 is True, the block of the first if statement executes.
    The assignment x = -3 makes x refer to -3. Now for the second if statement. Here,
    x > 1 is False, so the else block runs, and x = 3 makes x refer to 3. I’d suggest
    changing if x > 1 to elif x > 1 and observing how the behavior of the program
    changes!'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：D。因为 x > 2 为 True，第一个 if 语句的代码块被执行。赋值语句 x = -3 使 x 的值变为 -3。接下来是第二个 if 语句，这里
    x > 1 为 False，因此执行 else 代码块，x = 3 使得 x 的值变为 3。我建议将 if x > 1 改为 elif x > 1，看看程序的行为如何变化！
- en: '**CONCEPT CHECK**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: Do the following two snippets of code do exactly the same thing? Assume that
    temperature already refers to a number.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两段代码完全做相同的事情吗？假设 temperature 已经是一个数字。
- en: 'Snippet 1:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '片段 1:'
- en: 'if temperature > 0:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 'if temperature > 0:'
- en: print('warm')
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: print('warm')
- en: 'elif temperature == 0:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif temperature == 0:'
- en: print('zero')
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: print('zero')
- en: 'else:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print('cold')
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: print('cold')
- en: 'Snippet 2:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '片段 2:'
- en: 'if temperature > 0:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 'if temperature > 0:'
- en: print('warm')
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: print('warm')
- en: 'elif temperature == 0:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif temperature == 0:'
- en: print('zero')
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: print('zero')
- en: print('cold')
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: print('cold')
- en: A. Yes
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: A. 是的
- en: B. No
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: B. 否
- en: 'Answer: B. Snippet 2 *always* prints cold as its final line of output, because
    print(''cold'') is not indented! It is not associated with any if statement.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B。片段 2 *总是*将 cold 打印为最后一行输出，因为 print('cold') 没有缩进！它不属于任何 if 语句。
- en: Solving the Problem
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解题过程
- en: It’s time to solve Winning Team. In this book, I’ll generally present the full
    code and then discuss it. But as our solution here is longer than those in [Chapter
    1](ch01.xhtml#ch01), I’ve decided in this case to present the code in three pieces
    before presenting it as a whole.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候解决“胜利团队”问题了。在本书中，我通常会先展示完整的代码，然后进行讨论。但由于我们的解决方案比[第1章](ch01.xhtml#ch01)中的那些长，我决定在此先将代码分为三部分展示，再将其作为整体展示。
- en: 'First, we need to read the input. This requires six calls of input, because
    we have two teams and three pieces of information for each team. We also need
    to convert each piece of input to an integer. Here’s the code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要读取输入。这需要六次调用 input，因为我们有两个团队，每个团队有三项信息。我们还需要将每一项输入转换为整数。以下是代码：
- en: apple_three = int(input())
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: apple_three = int(input())
- en: apple_two = int(input())
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: apple_two = int(input())
- en: apple_one = int(input())
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: apple_one = int(input())
- en: banana_three = int(input())
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: banana_three = int(input())
- en: banana_two = int(input())
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: banana_two = int(input())
- en: banana_one = int(input())
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: banana_one = int(input())
- en: 'Second, we need to determine the number of points scored by the Apples and
    the Bananas. For each team, we add the points from three-point, two-point, and
    one-point plays. We can do that as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们需要确定 Apples 和 Bananas 得分的总数。对于每个团队，我们将三分球、两分球和一分球的得分加起来。我们可以这样做：
- en: apple_total = apple_three * 3 + apple_two * 2 + apple_one
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: apple_total = apple_three * 3 + apple_two * 2 + apple_one
- en: banana_total = banana_three * 3 + banana_two * 2 + banana_one
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: banana_total = banana_three * 3 + banana_two * 2 + banana_one
- en: 'Third, we produce the output. If the Apples win, we output A; if the Bananas
    win, we output B; otherwise, we know that the game is a tie, so we output T. We
    use an if statement to do this, as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'if apple_total > banana_total:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: print('A')
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'elif banana_total > apple_total:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: print('B')
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: print('T')
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: That’s all the code we need. See [Listing 2-1](ch02.xhtml#ch02ex01) for the
    complete solution.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: apple_three = int(input())
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: apple_two = int(input())
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: apple_one = int(input())
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: banana_three = int(input())
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: banana_two = int(input())
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: banana_one = int(input())
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: apple_total = apple_three * 3 + apple_two * 2 + apple_one
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: banana_total = banana_three * 3 + banana_two * 2 + banana_one
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'if apple_total > banana_total:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: print('A')
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'elif banana_total > apple_total:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: print('B')
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: print('T')
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 2-1: Solving Winning Team*'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: If you submit our code to the judge, you should see that all test cases pass.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Does the following version of the code correctly solve the problem?
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: apple_three = int(input())
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: apple_two = int(input())
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: apple_one = int(input())
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: banana_three = int(input())
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: banana_two = int(input())
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: banana_one = int(input())
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: apple_total = apple_three * 3 + apple_two * 2 + apple_one
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: banana_total = banana_three * 3 + banana_two * 2 + banana_one
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'if apple_total < banana_total:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: print('B')
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'elif apple_total > banana_total:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: print('A')
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: print('T')
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: A. Yes
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: B. No
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: A. The operators and order of the code are different, but the code
    is still correct. If the Apples lose, we output B (because the Bananas win); if
    the Apples win, we output A; otherwise, we know that the game is a tie, so we
    output T.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing, you might like to try solving exercise 1 from “Chapter Exercises”
    on [page 45](ch02.xhtml#ch02lev1sec13).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #4: Telemarketers'
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes we need to encode more complex Boolean expressions than those that
    we have seen so far. In this problem, we’ll learn about Boolean operators that
    help us do this.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem ccc18j1.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this problem, we’ll assume that phone numbers are four digits. A phone number
    belongs to a telemarketer if its four digits satisfy all three of the following
    properties:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: The first digit is 8 or 9.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth digit is 8 or 9.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second and third digits are the same.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, a phone number whose four digits are 8119 belongs to a telemarketer.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Determine whether a phone number belongs to a telemarketer, and indicate whether
    we should answer the phone or ignore it.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-307
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are four lines of input. These lines give the first, second, third, and
    fourth digits of the phone number, respectively. Each digit is an integer between
    0 and 9.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Output
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If the phone number belongs to a telemarketer, output ignore; otherwise, output
    answer.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Boolean Operators
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What has to be true about a phone number that belongs to a telemarketer? Its
    first digit has to be 8 *or* 9. *And*, its fourth digit has to be 8 *or* 9. *And*,
    the second and third digits have to be the same. We can encode this “or” and “and”
    logic using Python’s *Boolean operators*.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: or Operator
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The or operator takes two Boolean expressions as its operands. It returns True
    if at least one operand is True, and False otherwise:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '>>> True or True'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '>>> True or False'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '>>> False or True'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '>>> False or False'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: The only way to get False out of the or operator is if both of its operands
    are False.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use or to tell us whether a digit is an 8 or a 9:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '>>> digit = 8'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '>>> digit == 8 or digit == 9'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '>>> digit = 3'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '>>> digit == 8 or digit == 9'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Remember from “Integer and Floating-Point Numbers” in [Chapter 1](ch01.xhtml#ch01)
    that Python uses operator precedence to determine the order that operators are
    applied. The precedence of or is lower than the precedence of relational operators,
    which means that we don’t often need parentheses around operands. For example,
    in digit == 8 or digit == 9, the two operands to or are digit == 8 and digit ==
    9. It’s the same as if we’d written it as (digit == 8) or (digit == 9).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'In English, it makes sense if someone says “if the digit is 8 or 9.” But writing
    that won’t work in Python:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '>>> digit = 3'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '>>> if digit == 8 or 9:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''yes!'')'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: yes!
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I’ve (incorrectly!) written the second operand as 9 instead of digit
    == 9. Python responds by outputting yes!, which is certainly not what we’d want
    given that digit refers to 3. The reason is that Python considers nonzero numbers
    to be True. Since 9 is considered True, this makes the whole or expression True.
    Carefully double-check your Boolean expressions to avoid these kinds of mistakes
    when translating from natural language to Python.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: and Operator
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The and operator returns True if both of its operands are True, and returns
    False otherwise:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '>>> True and True'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '>>> True and False'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '>>> False and True'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '>>> False and False'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: The only way to get True out of the And operator is if both of its operands
    are True.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'The precedence of and is higher than or. Here’s an example of why this matters:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '>>> True or True and False'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'Python interprets that expression like this, with the and happening first:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '>>> True or (True and False)'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: The result is True because the first operand of or is True.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'We can force the or to happen first by including parentheses:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '>>> (True or True) and False'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: The result is False because the second operand of and is False.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: not Operator
  id: totrans-361
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another important Boolean operator is not. Unlike or and and, not takes only
    one operand (not two). If its operand is True, not returns False, and vice versa:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '>>> not True'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '>>> not False'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: The precedence of not is higher than or and and.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an expression and versions of that expression with parentheses. Which
    of them evaluates to True?
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: A. not True and False
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: B. (not True) and False
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: C. not (True and False)
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: D. None of the above
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: C. The expression (True and False) evaluates to False; the not therefore
    makes the full expression True.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Consider the expression not a or b.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following makes the expression False?
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: A. a False, b False
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: B. a False, b True
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: C. a True, b False
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: D. a True, b True
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: E. More than one of the above
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: C. If a is True, then not a is False. Since b is False, too, both operands
    to or are False, so the whole expression evaluates to False.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With Boolean operators at the ready, we can tackle the Telemarketers problem.
    Our solution is in [Listing 2-2](ch02.xhtml#ch02ex02).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: num1 = int(input())
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: num2 = int(input())
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: num3 = int(input())
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: num4 = int(input())
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: ❶ if ((num1 == 8 or num1 == 9) and
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: (num4 == 8 or num4 == 9) and
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '(num2 == num3)):'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: print('ignore')
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: print('answer')
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 2-2: Solving Telemarketers*'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: As in Winning Team, we start by reading the input and converting it to integers.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: The high-level structure of our if statement ❶ is three expressions connected
    by and operators; each of them must be True for the entire expression to be True.
    We require that the first number be 8 or 9, that the fourth number be 8 or 9,
    and that the second and third numbers be equal. If all three of these conditions
    hold, then we know that the phone number belongs to a telemarketer, and we output
    ignore. Otherwise, the phone number does not belong to a telemarketer, and we
    output answer.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: I’ve split the Boolean expression over three lines. This requires wrapping the
    entire expression in an additional pair of parentheses, as I have done. (Without
    those parentheses, you’ll get a syntax error, because there’s no indication to
    Python that the expression is continuing on the next line.)
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Python style guides suggest that a line be no longer than 79 characters. A line
    with the full Boolean expression would squeak in there at 76 characters. But I
    think the three-line version is clearer, highlighting each condition that must
    be True on its own line.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: We have a good solution here. To explore a little further, let’s discuss some
    alternate approaches.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Our code uses a Boolean expression to detect when a phone number belongs to
    a telemarketer. We could have also chosen to write code that detects when a phone
    number does *not* belong to a telemarketer. If the phone number doesn’t belong
    to a telemarketer, we should output answer; otherwise, we should output ignore.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: If the first digit isn’t 8 and isn’t 9, then the phone number doesn’t belong
    to a telemarketer. Or, if the fourth digit isn’t 8 and isn’t 9, then the phone
    number doesn’t belong to a telemarketer. Or, if the second and third digits aren’t
    equal, then the phone number doesn’t belong to a telemarketer. If even one of
    these expressions is True, then the phone number doesn’t belong to a telemarketer.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: See [Listing 2-3](ch02.xhtml#ch02ex03) for a version of the code that captures
    this logic.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: num1 = int(input())
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: num2 = int(input())
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: num3 = int(input())
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: num4 = int(input())
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: if ((num1 != 8 and num1 != 9) or
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: (num4 != 8 and num4 != 9) or
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '(num2 != num3)):'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: print('answer')
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: print('ignore')
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 2-3: Solving Telemarketers, alternate approach*'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: It’s not easy getting all of those !=, or, and and operators correct! Notice,
    for example, that we’ve had to change all == operators to !=, all or operators
    to and, and all and operators to or.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: An alternate approach is to use the not operator to negate the “is a telemarketer”
    expression in one shot. See [Listing 2-4](ch02.xhtml#ch02ex04) for that code.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: num1 = int(input())
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: num2 = int(input())
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: num3 = int(input())
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: num4 = int(input())
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: if not ((num1 == 8 or num1 == 9) and
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: (num4 == 8 or num4 == 9) and
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '(num2 == num3)):'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: print('answer')
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: print('ignore')
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 2-4: Solving Telemarketers, not operator*'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Which of these solutions do you find most intuitive? There’s often more than
    one way to structure the logic of an if statement, and we should use the one that’s
    easiest to get right. To me, [Listing 2-2](ch02.xhtml#ch02ex02) is the most natural,
    but you may feel otherwise!
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Choose your favorite version and submit it to the judge. You should see that
    all test cases pass.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We should always strive to make our programs as clear as possible. This helps
    to avoid introducing errors when programming and makes it easier to fix our code
    when errors do slip in. Meaningful variable names, spaces around operators, blank
    lines to segment the program into its logical pieces, simple if statement logic:
    all of these practices can improve the quality of the code we write. Another good
    habit is adding *comments* to our code.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'A comment is introduced by the # character and continues until the end of the
    line. Python ignores comments, so they have no impact on what our program does.
    We add comments to remind ourselves, or others, about design decisions that we’ve
    made. Assume that the person reading the code knows Python, so avoid comments
    that simply restate what the code is doing. Here’s code with an unnecessary comment:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x = 5'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x = x + 1  # Increase x by 1'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: That comment adds nothing beyond what we already know about assignment statements.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: See [Listing 2-5](ch02.xhtml#ch02ex05) for a version of [Listing 2-2](ch02.xhtml#ch02ex02)
    with comments.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '❶ # ccc18j1, Telemarketers'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: num1 = int(input())
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: num2 = int(input())
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: num3 = int(input())
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: num4 = int(input())
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '❷ # Telemarketer number: first digit 8 or 9, fourth digit 8 or 9,'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '# second digit and third digit are same'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: if ((num1 == 8 or num1 == 9) and
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: (num4 == 8 or num4 == 9) and
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '(num2 == num3)):'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: print('ignore')
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: print('answer')
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 2-5: Solving Telemarketers, comments added*'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve added three comment lines: the one at the top ❶ reminds us of the problem
    code and name, and the two before the if statement ❷ remind us of the rules for
    detecting a telemarketer phone number.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Don’t go overboard with comments. Whenever possible, write code that doesn’t
    require comments in the first place. But for tricky code or to document why you
    chose to do something in a particular way, a well-placed comment now can save
    time and frustration later.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Input and Output Redirection
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you submit Python code to the judge, it runs many test cases to determine
    whether your code is correct. Is someone there, dutifully waiting for new code
    and then frantically hammering test cases at it from the keyboard?
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: No way! It’s all automated. There’s no one typing test cases at the keyboard.
    How does the judge test our code, then, if we satisfy a call to input by typing
    something from the keyboard?
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: The truth is that input isn’t necessarily reading input from the keyboard. It’s
    reading from a source of input called *standard input*, which, by default, is
    the keyboard.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to change standard input so that it refers to a file rather than
    the keyboard. The technique is called *input redirection*, and it’s what the judge
    uses to provide input.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: We can also try input redirection ourselves. For programs whose input is small—just
    a line of text or a couple of integers—input redirection may not save us much.
    But for programs whose test cases can be tens or hundreds of lines long, input
    redirection makes it much easier to test our work. Rather than typing the same
    test case over and over, we can store it in a file and then run our program on
    it as many times as we want.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try input redirection on Telemarketers. Navigate to your *programming*
    folder and create a new file called *telemarketers_input.txt*. In that file, type
    the following:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: The problem specifies that we should provide one integer per line, so we’ve
    written them one per line here.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Save the file. Now enter python telemarketers.py < telemarketers_input.txt to
    run your program using input redirection. Your program should output ignore, just
    as it would if you’d typed the test case from the keyboard.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: The < symbol instructs your operating system to use a file rather than the keyboard
    to provide input. After the < symbol comes the name of the file that contains
    the input.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: To try your program on different test cases, just modify the *telemarketers_input.txt*
    file and run your program again.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: We can also change where our output goes, though we won’t need to for this book.
    The print function outputs to *standard output*, which, by default, is the screen.
    We can change standard output so that it instead refers to a file. We do so using
    *output redirection*, which is written as a > symbol followed by a filename.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: Enter python telemarketers.py > telemarketers_output.txt to run your program
    using output redirection. Provide four integers of input, and you should be back
    to your operating system prompt. But you shouldn’t see any output from your Telemarketers
    program! That’s because we’ve redirected the output to file telemarketers_output.txt.
    If you open telemarketers_output.txt in your text editor, you should see the output
    there.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `python telemarketers.py > telemarketers_output.txt` 来使用输出重定向运行你的程序。提供四个整数的输入后，你应该会返回到操作系统提示符。但你不应该看到来自电话推销员程序的任何输出！这是因为我们已将输出重定向到文件telemarketers_output.txt。如果你在文本编辑器中打开telemarketers_output.txt，你应该能看到里面的输出。
- en: Be careful with output redirection. If you use a filename that already exists,
    your old file will be overwritten! Always double-check that you’re using the filename
    you intended.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 小心使用输出重定向。如果你使用了一个已存在的文件名，旧文件会被覆盖！始终再次检查你是否使用了正确的文件名。
- en: Summary
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to use if statements to direct what our programs
    do. The key ingredient of an if statement is a Boolean expression, which is an
    expression with a True or False value. To build up Boolean expressions, we use
    relational operators such as == and >=, and we use Boolean operators such as and
    and or.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，我们学习了如何使用if语句来控制程序的执行。if语句的关键成分是布尔表达式，它是一个值为True或False的表达式。为了构建布尔表达式，我们使用关系运算符，比如==和>=，还使用布尔运算符，如and和or。
- en: Deciding what to do based on what is True and False makes our programs more
    flexible, able to adapt to the situation at hand. But our programs are still limited
    to handling small amounts of input and output—whatever we can do with individual
    calls to input and print. In the next chapter, we’ll start learning about loops,
    which let us repeat code so that we can process as much input and output as we
    like.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 根据True和False决定做什么，使得我们的程序更灵活，能够适应当前的情况。但是我们的程序仍然局限于处理小量的输入和输出——无论是通过单独的input和print调用能做到什么。在下一章，我们将开始学习循环结构，它允许我们重复代码，从而处理任意数量的输入和输出。
- en: Want to work with 100 values? How about 1,000? And with just a small amount
    of Python code? It is a little early for me to be provoking you, I know, because
    you still have the following exercises to do. But when you’re ready, read on!
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 想处理100个值吗？那1,000个呢？而且只需要少量的Python代码？我知道现在挑衅你有点早，因为你还有以下的练习要做。但当你准备好了，继续往下读吧！
- en: Chapter Exercises
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章练习
- en: Here are some exercises for you to try.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些练习供你尝试。
- en: DMOJ problem ccc06j1, Canadian Calorie Counting
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ题目 ccc06j1, 加拿大卡路里计算
- en: DMOJ problem ccc15j1, Special Day
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ题目 ccc15j1, 特别的日子
- en: DMOJ problem ccc15j2, Happy or Sad
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ题目 ccc15j2, 开心还是难过
- en: DMOJ problem dmopc16c1p0, C.C. and Cheese-kun
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ题目 dmopc16c1p0, C.C. 和奶酪君
- en: DMOJ problem ccc07j1, Who is in the Middle
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ题目 ccc07j1, 谁在中间
- en: Notes
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Winning Team is originally from the 2019 Canadian Computing Competition, Junior
    Level. Telemarketers is originally from the 2018 Canadian Computing Competition,
    Junior Level.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 《获胜队伍》最初来源于2019年加拿大计算机竞赛，初级组。《电话推销员》最初来源于2018年加拿大计算机竞赛，初级组。
