<html><head></head><body>
<h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_119"/><strong><span class="big">8</span></strong><br/><strong>FUNCTIONAL PROGRAMMING</strong></h2>&#13;
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>&#13;
<p class="noindent">Many Python developers are unaware of the extent to which you can use functional programming in Python, which is a shame: with few exceptions, functional programming allows you to write more concise and efficient code. Moreover, Python’s support for functional programming is extensive.</p>&#13;
<p class="indent">This chapter will cover some of the functional programming aspects of Python, including creating and using generators. You’ll learn about the most useful functional packages and functions available and how to use them in combination to get the most efficient code.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_120"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you want to get serious about functional programming, here’s my advice: take a break from Python and learn a hugely functional programming language, such as Lisp. I know it might sound strange to talk about Lisp in a Python book, but playing with Lisp for several years taught me how to “think functional.” You may not develop the thought processes necessary to make full use of functional programming if all your experience comes from imperative and object-oriented programming. Lisp isn’t purely functional itself, but it has more focus on functional programming than you’ll find in Python.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="lev1sec41"><strong>Creating Pure Functions</strong></h3>&#13;
<p class="noindent">When you write code using a functional style, your functions are designed to have no side effects: instead, they take an input and produce an output without keeping state or modifying anything not reflected in the return value. Functions that follow this ideal are referred to as <em>purely functional</em>.</p>&#13;
<p class="indent">Let’s start with an example of a regular, non-pure function that removes the last item in a list:</p>&#13;
<p class="programs">def remove_last_item(mylist):<br/>    """Removes the last item from a list."""<br/>    mylist.pop(-1)  # This modifies mylist</p>&#13;
<p class="indent">The following is a pure version of the same function:</p>&#13;
<p class="programs">def butlast(mylist):<br/><br/>    return mylist[:-1]  # This returns a copy of mylist</p>&#13;
<p class="indent">We define a <span class="literal">butlast()</span> function to work like <span class="literal">butlast</span> in Lisp, in that it returns the list without the last element <em>without</em> modifying the original list. Instead, it returns a copy of the list that has the modifications in place, allowing us to keep the original.</p>&#13;
<p class="indent">The practical advantages of functional programming include the following:</p>&#13;
<p class="noindent1"><strong>Modularity</strong> Writing with a functional style forces a certain degree of separation in solving your individual problems and makes sections of code easier to reuse in other contexts. Since the function does not depend on any external variable or state, calling it from a different piece of code is straightforward.</p>&#13;
<p class="noindent1"><strong>Brevity</strong> Functional programming is often less verbose than other paradigms.</p>&#13;
<p class="noindent1"><strong>Concurrency</strong> Purely functional functions are thread-safe and can run concurrently. Some functional languages do this automatically, which can be a big help if you ever need to scale your application, though this is not quite the case yet in Python.</p>&#13;
<p class="noindent1"><span epub:type="pagebreak" id="page_121"/><strong>Testability</strong> Testing a functional program is incredibly easy: all you need is a set of inputs and an expected set of outputs. They are <em>idempotent</em>, meaning that calling the same function over and over with the same arguments will always return the same result.</p>&#13;
<h3 class="h3" id="lev1sec42"><strong>Generators</strong></h3>&#13;
<p class="noindent">A <em>generator</em> is an object that behaves like an iterator, in that it generates and returns a value on each call of its <span class="literal">next()</span> method until a <span class="literal">StopIteration</span> is raised. Generators, first introduced in PEP 255, offer an easy way to create objects that implement the <em>iterator protocol</em>. While writing generators in a functional style is not strictly necessary, doing so makes them easier to write and debug and is a common practice.</p>&#13;
<p class="indent">To create a generator, just write a regular Python function that contains a <span class="literal">yield</span> statement. Python will detect the use of <span class="literal">yield</span> and tag the function as a generator. When execution reaches the <span class="literal">yield</span> statement, the function returns a value as with a <span class="literal">return</span> statement, but with one notable difference: the interpreter will save a stack reference, and this will be used to resume the function’s execution when the <span class="literal">next()</span> function is called again.</p>&#13;
<p class="indent">When functions are executed, the chaining of their execution produces a <em>stack</em>—function calls are said to be stacked on each other. When a function returns, it’s removed from the stack, and the value it returns is passed to the calling function. In the case of a generator, the function does not really return but <em>yields</em> instead. Python therefore saves the state of the function as a stack reference, resuming the execution of the generator at the point it saved when the next iteration of the generator is needed.</p>&#13;
<h4 class="h4" id="lev2sec40"><strong><em>Creating a Generator</em></strong></h4>&#13;
<p class="noindent">As mentioned, you create a generator by writing a normal function and including <span class="literal">yield</span> in the function’s body. <a href="ch08.xhtml#ch8list1">Listing 8-1</a> creates a generator called <span class="literal">mygenerator()</span> that includes three yields, meaning it will iterate with the next three calls to <span class="literal">next()</span>.</p>&#13;
<p class="programs">&gt;&gt; <span class="codestrong1">def mygenerator():</span><br/>...     <span class="codestrong1">yield 1</span><br/>...     <span class="codestrong1">yield 2</span><br/>...     <span class="codestrong1">yield 'a'</span><br/>...<br/>&gt;&gt;&gt; <span class="codestrong1">mygenerator()</span><br/>&lt;generator object mygenerator at 0x10d77fa50&gt;<br/>&gt;&gt;&gt; <span class="codestrong1">g = mygenerator()</span><br/>&gt;&gt;&gt; <span class="codestrong1">next(g)</span><br/>1<br/>&gt;&gt;&gt; <span class="codestrong1">next(g)</span><br/>2<br/>&gt;&gt;&gt; <span class="codestrong1">next(g)</span><br/>'a'<span epub:type="pagebreak" id="page_122"/><br/>&gt;&gt;&gt; <span class="codestrong1">next(g)</span><br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>StopIteration</p>&#13;
<p class="listing1"><a id="ch8list1"/><em>Listing 8-1: Creating a generator with three iterations</em></p>&#13;
<p class="indent">When it runs out of <span class="literal">yield</span> statements, <span class="literal">StopIteration</span> is raised at the next call to <span class="literal">next()</span>.</p>&#13;
<p class="indent">In Python, generators keep a reference to the stack when a function yields something, and they resume this stack when a call to <span class="literal">next()</span> is executed again.</p>&#13;
<p class="indent">The naive approach when iterating over any data without using generators is to build the entire list first, which often consumes memory wastefully.</p>&#13;
<p class="indent">Say we want to find the first number between 1 and 10,000,000 that’s equal to 50,000. Sounds easy, doesn’t it? Let’s make this a challenge. We’ll run Python with a memory constraint of 128MB and try the naive approach of first building the entire list:</p>&#13;
<p class="programs">$ <span class="codestrong1">ulimit -v 131072</span><br/>$ <span class="codestrong1">python3</span><br/>&gt;&gt;&gt; <span class="codestrong1">a = list(range(10000000))</span></p>&#13;
<p class="indent">This naive method first tries to build the list, but if we run the program so far:</p>&#13;
<p class="programs">Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>MemoryError</p>&#13;
<p class="noindent">Uh-oh. Turns out we can’t build a list of 10 million items with only 128MB of memory!</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>&#13;
<p class="notep"><em>In Python 3, <span class="codeitalic">range()</span> returns a generator when iterated. To get a generator in Python 2, you have to use <span class="codeitalic">xrange()</span> instead. This function doesn’t exist in Python 3 anymore, since it’s redundant.</em></p>&#13;
</div>&#13;
<p class="indent">Let’s try using a generator instead, with the same 128MB restriction:</p>&#13;
<p class="programs">$ <span class="codestrong1">ulimit -v 131072</span><br/>$ <span class="codestrong1">python3</span><br/>&gt;&gt;&gt; <span class="codestrong1">for value in range(10000000):</span><br/>...     <span class="codestrong1">if value == 50000:</span><br/>...             <span class="codestrong1">print("Found it")</span><br/>...             <span class="codestrong1">break</span><br/>...<br/>Found it</p>&#13;
<p class="indent">This time, our program executes without issue. When it is iterated over, the <span class="literal">range()</span> class returns a generator that dynamically generates our list of <span epub:type="pagebreak" id="page_123"/>integers. Better still, since we are only interested in the 50,000th number, instead of building the full list, the generator only had to generate 50,000 numbers before it stopped.</p>&#13;
<p class="indent">By generating values on the fly, generators allow you to handle large data sets with minimal consumption of memory and processing cycles. Whenever you need to work with a huge number of values, generators can help you handle them efficiently.</p>&#13;
<h4 class="h4" id="lev2sec41"><strong><em>Returning and Passing Values with yield</em></strong></h4>&#13;
<p class="noindent">A <span class="literal">yield</span> statement also has a less commonly used feature: it can return a value in the same way as a function call. This allows us to pass a value to a generator by calling its <span class="literal">send()</span> method. As an example of using <span class="literal">send()</span>, we’ll write a function called <span class="literal">shorten()</span> that takes a list of strings and returns a list consisting of those same strings, only truncated (<a href="ch08.xhtml#ch8list2">Listing 8-2</a>).</p>&#13;
<p class="programs">def shorten(string_list):<br/>    length = len(string_list[0])<br/>    for s in string_list:<br/>        length = yield s[:length]<br/><br/>mystringlist = ['loremipsum', 'dolorsit', 'ametfoobar']<br/>shortstringlist = shorten(mystringlist)<br/>result = []<br/>try:<br/>    s = next(shortstringlist)<br/>    result.append(s)<br/>    while True:<br/>        number_of_vowels = len(filter(lambda letter: letter in 'aeiou', s))<br/>        # Truncate the next string depending<br/>        # on the number of vowels in the previous one<br/>        s = shortstringlist.send(number_of_vowels)<br/>        result.append(s)<br/>except StopIteration:<br/>    pass</p>&#13;
<p class="listing1"><a id="ch8list2"/><em>Listing 8-2: Returning and using a value with <span class="codeitalic">send()</span></em></p>&#13;
<p class="indent">In this example, we’ve written a function called <span class="literal">shorten()</span> that takes a list of strings and returns a list consisting of those same strings, only truncated. The length of each truncated string is equal to the number of vowels in the previous string: <em>loremipsum</em> has four vowels, so the second value returned by the generator will be the first four letters of <em>dolorsit</em>; <em>dolo</em> has only two vowels, so <em>ametfoobar</em> will be truncated to its first two letters <em>am</em>. The generator then stops and raises <span class="literal">StopIteration</span>. Our generator thus returns:</p>&#13;
<p class="programs">['loremipsum', 'dolo', 'am']</p>&#13;
<p class="indent">Using <span class="literal">yield</span> and <span class="literal">send()</span> in this fashion allows Python generators to function like <em>coroutines</em> seen in Lua and other languages.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_124"/>PEP 289 introduced generator expressions, making it possible to build one-line generators using a syntax similar to list comprehension:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">(x.upper() for x in ['hello', 'world'])</span><br/>&lt;generator object &lt;genexpr&gt; at 0x7ffab3832fa0&gt;<br/>&gt;&gt;&gt; <span class="codestrong1">gen = (x.upper() for x in ['hello', 'world'])</span><br/>&gt;&gt;&gt; <span class="codestrong1">list(gen)</span><br/>['HELLO', 'WORLD']</p>&#13;
<p class="indent">In this example, <span class="literal">gen</span> is a generator, just as if we had used the <span class="literal">yield</span> statement. The <span class="literal">yield</span> in this case is implicit.</p>&#13;
<h4 class="h4" id="lev2sec42"><strong><em>Inspecting Generators</em></strong></h4>&#13;
<p class="noindent">To determine whether a function is considered a generator, use <span class="literal">inspect.isgeneratorfunction()</span>. In <a href="ch08.xhtml#ch8list3">Listing 8-3</a>, we create a simple generator and inspect it.</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">import inspect</span><br/>&gt;&gt;&gt; <span class="codestrong1">def mygenerator():</span><br/>...     yield 1<br/>...<br/>&gt;&gt;&gt; <span class="codestrong1">inspect.isgeneratorfunction(mygenerator)</span><br/>True<br/>&gt;&gt;&gt; <span class="codestrong1">inspect.isgeneratorfunction(sum)</span><br/>False</p>&#13;
<p class="listing1"><a id="ch8list3"/><em>Listing 8-3: Checking whether a function is a generator</em></p>&#13;
<p class="indent">Import the <span class="literal">inspect</span> package to use <span class="literal">isgeneratorfunction()</span> and then just pass it the name of the function to inspect. Reading the source code of <span class="literal">inspect.isgeneratorfunction()</span> gives us some insight into how Python marks functions as being generators (see <a href="ch08.xhtml#ch8list4">Listing 8-4</a>).</p>&#13;
<p class="programs">def isgeneratorfunction(object):<br/>    """Return true if the object is a user-defined generator function.<br/><br/>    Generator function objects provides same attributes as functions.<br/><br/>    See help(isfunction) for attributes listing."""<br/><br/>  return bool((isfunction(object) or ismethod(object)) and<br/>                object.func_code.co_flags &amp; CO_GENERATOR)</p>&#13;
<p class="listing1"><a id="ch8list4"/><em>Listing 8-4: Source code of <span class="codeitalic">inspect.isgeneratorfunction()</span></em></p>&#13;
<p class="indent">The <span class="literal">isgeneratorfunction()</span> function checks that the object is a function or a method and that its code has the <span class="literal">CO_GENERATOR</span> flag set. This example shows how easy it is to understand how Python works under the hood.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_125"/>The <span class="literal">inspect</span> package provides the <span class="literal">inspect.getgeneratorstate()</span> function, which gives the current state of the generator. We’ll use it on <span class="literal">mygenerator()</span> here at different points of execution:</p>&#13;
<p class="programs">   &gt;&gt;&gt; <span class="codestrong1">import inspect</span><br/>   &gt;&gt;&gt; <span class="codestrong1">def mygenerator():</span><br/>   ...     <span class="codestrong1">yield 1</span><br/>   ...<br/>   &gt;&gt;&gt; <span class="codestrong1">gen = mygenerator()</span><br/>   &gt;&gt;&gt; <span class="codestrong1">gen</span><br/>   &lt;generator object mygenerator at 0x7f94b44fec30&gt;<br/>   &gt;&gt;&gt; <span class="codestrong1">inspect.getgeneratorstate(gen)</span><br/><span class="ent">➊</span> 'GEN_CREATED'<br/>   &gt;&gt;&gt; <span class="codestrong1">next(gen)</span><br/>   1<br/>   &gt;&gt;&gt; <span class="codestrong1">inspect.getgeneratorstate(gen)</span><br/><span class="ent">➋</span> 'GEN_SUSPENDED'<br/>   &gt;&gt;&gt; next(gen)<br/>   Traceback (most recent call last):<br/>     File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>   StopIteration<br/>   &gt;&gt;&gt; <span class="codestrong1">inspect.getgeneratorstate(gen)</span><br/><span class="ent">➌</span> 'GEN_CLOSED'</p>&#13;
<p class="indent">This allows us to determine whether the generator is waiting to be run for the first time (<span class="literal">GEN_CREATED</span>) <span class="ent">➊</span>, waiting to be resumed by a call to <span class="literal">next()</span> (<span class="literal">GEN_SUSPENDED</span>) <span class="ent">➋</span>, or finished running (<span class="literal">GEN_CLOSED</span>) <span class="ent">➌</span>. This might come in handy to debug your generators.</p>&#13;
<h3 class="h3" id="lev1sec43"><strong>List Comprehensions</strong></h3>&#13;
<p class="noindent">List comprehension, or <em>listcomp</em> for short, allows you to define a list’s contents inline with its declaration. To make a list into a listcomp, you must wrap it in square brackets as usual, but also include an expression that will generate the items in the list and a <span class="literal">for</span> loop to loop through them.</p>&#13;
<p class="indent">The following example creates a list without using list comprehension:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">x = []</span><br/>&gt;&gt;&gt; <span class="codestrong1">for i in (1, 2, 3):</span><br/>...     <span class="codestrong1">x.append(i)</span><br/>...<br/>&gt;&gt;&gt; <span class="codestrong1">x</span><br/>[1, 2, 3]</p>&#13;
<p class="indent">And this next example uses list comprehension to make the same list with a single line:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">x = [i for i in (1, 2, 3)]</span><br/>&gt;&gt;&gt; <span class="codestrong1">x</span><br/>[1, 2, 3]</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_126"/>Using a list comprehension presents two advantages: code written using listcomps is usually shorter and therefore compiles down to fewer operations for Python to perform. Rather than creating a list and calling <span class="literal">append</span> over and over, Python can just create the list of items and move them into a new list in a single operation.</p>&#13;
<p class="indent">You can use multiple <span class="literal">for</span> statements together and use <span class="literal">if</span> statements to filter out items. Here we create a list of words and use list comprehension to capitalize each item, split up items with multiple words into single words, and delete the extraneous <em>or</em> :</p>&#13;
<p class="programs">x = [word.capitalize()<br/>     for line in ("hello world?", "world!", "or not")<br/>     for word in line.split()<br/>     if not word.startswith("or")]<br/>&gt;&gt;&gt; <span class="codestrong1">x</span><br/>['Hello', 'World?', 'World!', 'Not']</p>&#13;
<p class="indent">This code has two <span class="literal">for</span> loops: the first iterates over the text lines, while the second iterates over words in each of those lines. The final <span class="literal">if</span> statement filters out words that start with <em>or</em> to exclude them from the final list.</p>&#13;
<p class="indent">Using list comprehension rather than <span class="literal">for</span> loops is a neat way to define lists quickly. Since we’re still talking about functional programming, it’s worth noting that lists built through list comprehension shouldn’t rely on changing the program’s state: you are not expected to modify any variable while building the list. This usually makes the lists more concise and easier to read than lists made without listcomp.</p>&#13;
<p class="indent">Note that there’s also syntax for building dictionaries or sets in the same fashion, like so:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">{x:x.upper() for x in ['hello', 'world']}</span><br/>{'world': 'WORLD', 'hello': 'HELLO'}<br/>&gt;&gt;&gt; <span class="codestrong1">{x.upper() for x in ['hello', 'world']}</span><br/>set(['WORLD', 'HELLO'])</p>&#13;
<h3 class="h3" id="lev1sec44"><strong>Functional Functions Functioning</strong></h3>&#13;
<p class="noindent">You might repeatedly encounter the same set of problems when manipulating data using functional programming. To help you deal with this situation efficiently, Python includes a number of functions for functional programming. This section will give you a quick overview of some of these built-in functions that allow you to build fully functional programs. Once you have an idea of what’s available, I encourage you to research further and try out functions where they might apply in your own code.</p>&#13;
<h4 class="h4" id="lev2sec43"><span epub:type="pagebreak" id="page_127"/><strong><em>Applying Functions to Items with map()</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">map()</span> function takes the form <span class="literal">map(<span class="codeitalic">function</span>, <span class="codeitalic">iterable</span>)</span> and applies <span class="literal">function</span> to each item in <span class="literal">iterable</span> to return a list in Python 2 or an iterable <span class="literal">map</span> object in Python 3, as shown in <a href="ch08.xhtml#ch8list5">Listing 8-5</a>.</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">map(lambda x: x + "bzz!", ["I think", "I'm good"])</span><br/>&lt;map object at 0x7fe7101abdd0&gt;<br/>&gt;&gt;&gt; <span class="codestrong1">list(map(lambda x: x + "bzz!", ["I think", "I'm good"]))</span><br/>['I thinkbzz!', "I'm goodbzz!"]</p>&#13;
<p class="listing1"><a id="ch8list5"/><em>Listing 8-5: Using <span class="codeitalic">map()</span> in Python 3</em></p>&#13;
<p class="indent">You could write an equivalent of <span class="literal">map()</span> using list comprehension, like this:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">(x + "bzz!" for x in ["I think", "I'm good"])</span><br/>&lt;generator object &lt;genexpr&gt; at 0x7f9a0d697dc0&gt;<br/>&gt;&gt;&gt; <span class="codestrong1">[x + "bzz!" for x in ["I think", "I'm good"]]</span><br/>['I thinkbzz!', "I'm goodbzz!"]</p>&#13;
<h4 class="h4" id="lev2sec44"><strong><em>Filtering Lists with filter()</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">filter()</span> function takes the form <span class="literal">filter(<span class="codeitalic">function or None</span>, <span class="codeitalic">iterable</span>)</span> and filters the items in <span class="literal">iterable</span> based on the result returned by <span class="literal">function</span>. This will return a list in Python 2 or an iterable <span class="literal">filter</span> object in Python 3:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">filter(lambda x: x.startswith("I "), ["I think", "I'm good"])</span><br/>&lt;filter object at 0x7f9a0d636dd0&gt;<br/>&gt;&gt;&gt; <span class="codestrong1">list(filter(lambda x: x.startswith("I "), ["I think", "I'm good"]))</span><br/>['I think']</p>&#13;
<p class="indent">You could also write an equivalent of <span class="literal">filter()</span> using list comprehension, like so:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">(x for x in ["I think", "I'm good"] if x.startswith("I "))</span><br/>&lt;generator object &lt;genexpr&gt; at 0x7f9a0d697dc0&gt;<br/>&gt;&gt;&gt; <span class="codestrong1">[x for x in ["I think", "I'm good"] if x.startswith("I ")]</span><br/>['I think']</p>&#13;
<h4 class="h4" id="lev2sec45"><strong><em>Getting Indexes with enumerate()</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">enumerate()</span> function takes the form <span class="literal">enumerate(<span class="codeitalic">iterable</span>[, <span class="codeitalic">start</span>])</span> and returns an iterable object that provides a sequence of tuples, each consisting of an integer index (starting with <span class="literal">start</span>, if provided) and the corresponding item in <span class="literal">iterable</span>. This function is useful when you need to write code that refers to array indexes. For example, instead of writing this:</p>&#13;
<p class="programs">i = 0<br/>while i &lt; len(mylist):<span epub:type="pagebreak" id="page_128"/><br/>    print("Item %d: %s" % (i, mylist[i]))<br/>    i += 1</p>&#13;
<p class="noindent">you could accomplish the same thing more efficiently with <span class="literal">enumerate()</span>, like so:</p>&#13;
<p class="programs">for i, item in enumerate(mylist):<br/>    print("Item %d: %s" % (i, item))</p>&#13;
<h4 class="h4" id="lev2sec46"><strong><em>Sorting a List with sorted()</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">sorted()</span> function takes the form <span class="literal">sorted(<span class="codeitalic">iterable</span>, key=None, reverse=False)</span> and returns a sorted version of <span class="literal">iterable</span>. The <span class="literal">key</span> argument allows you to provide a function that returns the value to sort on, as shown here:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">sorted([("a", 2), ("c", 1), ("d", 4)])</span><br/>[('a', 2), ('c', 1), ('d', 4)]<br/>&gt;&gt;&gt; <span class="codestrong1">sorted([("a", 2), ("c", 1), ("d", 4)], key=lambda x: x[1])</span><br/>[('c', 1), ('a', 2), ('d', 4)]</p>&#13;
<h4 class="h4" id="lev2sec47"><strong><em>Finding Items That Satisfy Conditions with any() and all()</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">any(<span class="codeitalic">iterable</span>)</span> and <span class="literal">all(<span class="codeitalic">iterable</span>)</span> functions return a Boolean depending on the values returned by <span class="literal">iterable</span>. These simple functions are equivalent to the following full Python code:</p>&#13;
<p class="programs">def all(iterable):<br/>    for x in iterable:<br/>        if not x:<br/>            return False<br/>    return True<br/><br/>def any(iterable):<br/>    for x in iterable:<br/>        if x:<br/>            return True<br/>    return False</p>&#13;
<p class="indent">These functions are useful for checking whether any or all of the values in an iterable satisfy a given condition. For example, the following checks a list for two conditions:</p>&#13;
<p class="programs">mylist = [0, 1, 3, -1]<br/>if all(map(lambda x: x &gt; 0, mylist)):<br/>    print("All items are greater than 0")<br/>if any(map(lambda x: x &gt; 0, mylist)):<br/>    print("At least one item is greater than 0")</p>&#13;
<p class="indent">The difference here is that <span class="literal">any()</span> returns <span class="literal">True</span> when at least one element meets the condition, while <span class="literal">all()</span> returns <span class="literal">True</span> only if every element meets the condition. The <span class="literal">all()</span> function will also return <span class="literal">True</span> for an empty iterable, since none of the elements is <span class="literal">False</span>.</p>&#13;
<h4 class="h4" id="lev2sec48"><span epub:type="pagebreak" id="page_129"/><strong><em>Combining Lists with zip()</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">zip()</span> function takes the form <span class="literal">zip(<span class="codeitalic">iter1</span> [,<span class="codeitalic">iter2</span> [...]])</span>. It takes multiple sequences and combines them into tuples. This is useful when you need to combine a list of keys and a list of values into a dict. As with the other functions described here, <span class="literal">zip()</span> returns a list in Python 2 and an iterable in Python 3. Here we map a list of keys to a list of values to create a dictionary:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">keys = ["foobar", "barzz", "ba!"]</span><br/>&gt;&gt;&gt; <span class="codestrong1">map(len, keys)</span><br/>&lt;map object at 0x7fc1686100d0&gt;<br/>&gt;&gt;&gt; <span class="codestrong1">zip(keys, map(len, keys))</span><br/>&lt;zip object at 0x7fc16860d440&gt;<br/>&gt;&gt;&gt; <span class="codestrong1">list(zip(keys, map(len, keys)))</span><br/>[('foobar', 6), ('barzz', 5), ('ba!', 3)]<br/>&gt;&gt;&gt; <span class="codestrong1">dict(zip(keys, map(len, keys)))</span><br/>{'foobar': 6, 'barzz': 5, 'ba!': 3}</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><strong>FUNCTIONAL FUNCTIONS IN PYTHON 2 AND 3</strong></p>&#13;
<p class="noindent">You might have noticed by now how the return types differ between Python 2 and Python 3. Most of Python’s purely functional built-in functions return a list rather than an iterable in Python 2, making them less memory efficient than their Python 3.<em>x</em> equivalents. If you’re planning to write code using these functions, keep in mind that you’ll get the most benefit out of them in Python 3. If you’re stuck with Python 2, don’t despair: the <span class="literal">itertools</span> module from the Standard Library provides an iterator-based version of many of these functions (<span class="literal">itertools.izip()</span>, <span class="literal">itertools.imap()</span>, <span class="literal">itertools.ifilter()</span>, and so on).</p>&#13;
</div>&#13;
<h4 class="h4" id="lev2sec49"><strong><em>A Common Problem Solved</em></strong></h4>&#13;
<p class="noindent">There’s one important tool still to cover. Often when working with lists we want to find the first item that satisfies a specific condition. We’ll look at the many ways to accomplish this and then see the most efficient way: the <span class="literal">first</span> package.</p>&#13;
<h5 class="h5"><strong>Finding the Item with Simple Code</strong></h5>&#13;
<p class="noindent">We might be able to find the first item to satisfy a condition with a function like this:</p>&#13;
<p class="programs">def first_positive_number(numbers):<br/>    for n in numbers:<br/>        if n &gt; 0:<br/>            return n</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_130"/>We could rewrite the <span class="literal">first_positive_number()</span> function in functional style like this:</p>&#13;
<p class="programs">def first(predicate, items):<br/>    for item in items:<br/>        if predicate(item):<br/>            return item<br/><br/>first(lambda x: x &gt; 0, [-1, 0, 1, 2])</p>&#13;
<p class="indent">By using a functional approach where the predicate is passed as argument, the function becomes easily reusable. We could even write it more concisely, like so:</p>&#13;
<p class="programs"># Less efficient<br/>list(filter(lambda x: x &gt; 0, [-1, 0, 1, 2]))[0]<br/># Efficient<br/>next(filter(lambda x: x &gt; 0, [-1, 0, 1, 2]))</p>&#13;
<p class="indent">Note that this may raise an <span class="literal">IndexError</span> if no items satisfy the condition, causing <span class="literal">list(filter())</span> to return an empty list.</p>&#13;
<p class="indent">For simple cases, you can rely on <span class="literal">next()</span> to prevent <span class="literal">IndexError</span> from occurring, like so:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">a = range(10)</span><br/>&gt;&gt;&gt; <span class="codestrong1">next(x for x in a if x &gt; 3)</span><br/>4</p>&#13;
<p class="indent"><a href="ch08.xhtml#ch8list6">Listing 8-6</a> will raise <span class="literal">StopIteration</span> if a condition can never be satisfied. This too can be solved by adding a second argument of <span class="literal">next()</span>, like so.</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">a = range(10)</span><br/>&gt;&gt;&gt; <span class="codestrong1">next((x for x in a if x &gt; 10), 'default')</span><br/>'default'</p>&#13;
<p class="listing1"><a id="ch8list6"/><em>Listing 8-6: Returning a default value when the condition is not met</em></p>&#13;
<p class="indent">This will return a default value rather than an error when a condition cannot be met. Lucky for us, Python provides a package to handle all of this for us.</p>&#13;
<h5 class="h5"><strong>Finding the Item Using first()</strong></h5>&#13;
<p class="noindent">Rather than writing out the function from <a href="ch08.xhtml#ch8list6">Listing 8-6</a> in all of your programs, you can include the small Python package <span class="literal">first</span>. <a href="ch08.xhtml#ch8list7">Listing 8-7</a> shows how this package lets you find the first element of an iterable matching a condition.</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_131"/>&gt;&gt;&gt; <span class="codestrong1">from first import first</span><br/>&gt;&gt;&gt; <span class="codestrong1">first([0, False, None, [], (), 42])</span><br/>42<br/>&gt;&gt;&gt; <span class="codestrong1">first([-1, 0, 1, 2])</span><br/>-1<br/>&gt;&gt;&gt; <span class="codestrong1">first([-1, 0, 1, 2], key=lambda x: x &gt; 0)</span><br/>1</p>&#13;
<p class="listing1"><a id="ch8list7"/><em>Listing 8-7: Finding the first item in a list that satisfies a condition</em></p>&#13;
<p class="indent">You see that the <span class="literal">first()</span> function returns the first valid, non-empty item in a list.</p>&#13;
<h5 class="h5"><strong>Using lambda() with functools</strong></h5>&#13;
<p class="noindent">You’ll notice that we’ve used <span class="literal">lambda()</span> in a good portion of the examples so far in this chapter. The <span class="literal">lambda()</span> function was added to Python to facilitate functional programming functions such as <span class="literal">map()</span> and <span class="literal">filter()</span>, which otherwise would have required writing an entirely new function every time you wanted to check a different condition. <a href="ch08.xhtml#ch8list8">Listing 8-8</a> is equivalent to <a href="ch08.xhtml#ch8list7">Listing 8-7</a> but is written without using <span class="literal">lambda()</span>.</p>&#13;
<p class="programs">import operator<br/>from first import first<br/><br/>def greater_than_zero(number):<br/>    return number &gt; 0<br/><br/>first([-1, 0, 1, 2], key=greater_than_zero)</p>&#13;
<p class="listing1"><a id="ch8list8"/><em>Listing 8-8: Finding the first item to meet the condition, without using <span class="codeitalic">lambda()</span></em></p>&#13;
<p class="indent">This code works identically to that in <a href="ch08.xhtml#ch8list7">Listing 8-7</a>, returning the first non-empty value in a list to meet the condition, but it’s a good deal more cumbersome: if we wanted to get the first number in the sequence that’s longer than, say, 42 items, we’d need to define an appropriate function via <span class="literal">def</span> rather than defining it inline with our call to <span class="literal">first()</span>.</p>&#13;
<p class="indent">But despite its usefulness in helping us avoid situations like this, <span class="literal">lambda</span> still has its problems. The <span class="literal">first</span> module contains a <span class="literal">key</span> argument that can be used to provide a function that receives each item as an argument and returns a Boolean indicating whether it satisfies the condition. However, we can’t pass a <span class="literal">key</span> function, as it would require more than a single line of code: a <span class="literal">lambda</span> statement cannot be written on more than one line. That is a significant limitation of <span class="literal">lambda</span>.</p>&#13;
<p class="indent">Instead, we would have to go back to the cumbersome pattern of writing new function definitions for each <span class="literal">key</span> we need. Or would we?</p>&#13;
<p class="indent">The <span class="literal">functools</span> package comes to the rescue with its <span class="literal">partial()</span> method, which provides us with a more flexible alternative to <span class="literal">lambda</span>. The <span class="literal">functools.partial()</span> method allows us to create a wrapper function with a twist: rather <span epub:type="pagebreak" id="page_132"/>than changing the behavior of a function, it instead changes the <em>arguments</em> it receives, like so:</p>&#13;
<p class="programs">   from functools import partial<br/>   from first import first<br/><br/><span class="ent">➊</span> def greater_than(number, min=0):<br/>       return number &gt; min<br/><br/><span class="ent">➋</span> first([-1, 0, 1, 2], key=partial(greater_than, min=42))</p>&#13;
<p class="indent">Here we create a new <span class="literal">greater_than()</span> function that works just like the old <span class="literal">greater_than_zero()</span> from <a href="ch08.xhtml#ch8list8">Listing 8-8</a> by default, but this version allows us to specify the value we want to compare our numbers to, whereas before it was hardcoded. Here, we pass <span class="literal">functools.partial()</span> to our function and the value we want for <span class="literal">min</span> <span class="ent">➊</span>, and we get back a new function that has <span class="literal">min</span> set to 42, just as we want <span class="ent">➋</span>. In other words, we can write a function and use <span class="literal">functools.partial()</span> to customize the behavior of our new functions to suit our needs in any given situation.</p>&#13;
<p class="indent">Even this version can be pared down. All we’re doing in this example is comparing two numbers, and as it turns out, the <span class="literal">operator</span> module has built-in functions for exactly that:</p>&#13;
<p class="programs">import operator<br/>from functools import partial<br/>from first import first<br/><br/>first([-1, 0, 1, 2], key=partial(operator.le, 0))</p>&#13;
<p class="indent">This is a good example of <span class="literal">functools.partial()</span> working with positional arguments. In this case, the function <span class="literal">operator.le(a, b)</span>, which takes two numbers and returns a Boolean that tells us whether the first number is less than or equal to the second, is passed to <span class="literal">functools.partial()</span>. The 0 we pass to <span class="literal">functools.partial()</span> gets assigned to <span class="literal">a</span>, and the argument passed to the function returned by <span class="literal">functools.partial()</span> gets assigned to <span class="literal">b</span>. So this works identically to <a href="ch08.xhtml#ch8list8">Listing 8-8</a> but without using <span class="literal">lambda</span> or defining any additional functions.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The <span class="codeitalic">functools.partial()</span> method is typically useful in place of <span class="codeitalic">lambda</span> and should be considered a superior alternative. The <span class="codeitalic">lambda</span> function is something of an anomaly in the Python language, and dropping it altogether was considered for Python 3 due to the function’s limited body size of a single line.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="lev2sec50"><strong><em>Useful itertools Functions</em></strong></h4>&#13;
<p class="noindent">Finally, we’ll look at some useful functions in the <span class="literal">itertools</span> module in the Python Standard Library that you should be aware of. Too many programmers end up writing their own versions of these functions simply because they aren’t aware that Python provides them out of the box. They <span epub:type="pagebreak" id="page_133"/>are all designed to help you manipulate <span class="literal">iterator</span> (that’s why the module is called <em>iter-tools</em>) and therefore are all purely functional. Here I’ll list a few of them and give a brief overview of what they do, and I encourage you to look into them further if they seem of use.</p>&#13;
<ul>&#13;
<li><p class="noindent"><span class="literal">accumulate(<span class="codeitalic">iterable</span>[, <span class="codeitalic">func</span>])</span> returns a series of accumulated sums of items from iterables.</p></li>&#13;
<li><p class="noindent"><span class="literal">chain(*<span class="codeitalic">iterables</span>)</span> iterates over multiple iterables, one after another, without building an intermediate list of all items.</p></li>&#13;
<li><p class="noindent"><span class="literal">combinations(<span class="codeitalic">iterable</span>, <span class="codeitalic">r</span>)</span> generates all combinations of length <span class="codeitalic">r</span> from the given <span class="literal">iterable</span>.</p></li>&#13;
<li><p class="noindent"><span class="literal">compress(<span class="codeitalic">data</span>, <span class="codeitalic">selectors</span>)</span> applies a Boolean mask from <span class="codeitalic">selectors</span> to <span class="codeitalic">data</span> and returns only the values from <span class="literal">data</span> where the corresponding element of <span class="codeitalic">selectors</span> is <span class="literal">True</span>.</p></li>&#13;
<li><p class="noindent"><span class="literal">count(<span class="codeitalic">start</span>, <span class="codeitalic">step</span>)</span> generates an endless sequence of values, starting with <span class="codeitalic">start</span> and incrementing <span class="codeitalic">step</span> at a time with each call.</p></li>&#13;
<li><p class="noindent"><span class="literal">cycle(<span class="codeitalic">iterable</span>)</span> loops repeatedly over the values in <span class="codeitalic">iterable</span>.</p></li>&#13;
<li><p class="noindent"><span class="literal">repeat(<span class="codeitalic">elem</span>[, <span class="codeitalic">n</span>])</span> repeats an element <span class="codeitalic">n</span> times.</p></li>&#13;
<li><p class="noindent"><span class="literal">dropwhile(<span class="codeitalic">predicate</span>, <span class="codeitalic">iterable</span>)</span> filters elements of an iterable starting from the beginning until <span class="codeitalic">predicate</span> is <span class="literal">False</span>.</p></li>&#13;
<li><p class="noindent"><span class="literal">groupby(<span class="codeitalic">iterable</span>, <span class="codeitalic">keyfunc</span>)</span> creates an iterator that groups items by the result returned by the <span class="literal">keyfunc()</span> function.</p></li>&#13;
<li><p class="noindent"><span class="literal">permutations(<span class="codeitalic">iterable</span>[, <span class="codeitalic">r</span>])</span> returns successive <span class="codeitalic">r</span>-length permutations of the items in <span class="codeitalic">iterable</span>.</p></li>&#13;
<li><p class="noindent"><span class="literal">product(*<span class="codeitalic">iterables</span>)</span> returns an iterable of the Cartesian product of <span class="codeitalic">iterables</span> without using a nested <span class="literal">for</span> loop.</p></li>&#13;
<li><p class="noindent"><span class="literal">takewhile(<span class="codeitalic">predicate</span>, <span class="codeitalic">iterable</span>)</span> returns elements of an iterable starting from the beginning until <span class="codeitalic">predicate</span> is <span class="literal">False</span>.</p></li>&#13;
</ul>&#13;
<p class="indent">These functions are particularly useful in conjunction with the <span class="literal">operator</span> module. When used together, <span class="literal">itertools</span> and <span class="literal">operator</span> can handle most situations that programmers typically rely on <span class="literal">lambda</span> for. Here’s an example of using <span class="literal">operator.itemgetter()</span> instead of writing <span class="literal">lambda x: x['foo']</span>:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">import itertools</span><br/>&gt;&gt;&gt; <span class="codestrong1">a = [{'foo': 'bar'}, {'foo': 'bar', 'x': 42}, {'foo': 'baz', 'y': 43}]</span><br/>&gt;&gt;&gt; <span class="codestrong1">import operator</span><br/>&gt;&gt;&gt; <span class="codestrong1">list(itertools.groupby(a, operator.itemgetter('foo')))</span><br/>[('bar', &lt;itertools._grouper object at 0xb000d0&gt;), ('baz', &lt;itertools._grouper object at<br/>0xb00110&gt;)]<br/>&gt;&gt;&gt; <span class="codestrong1">[(key, list(group)) for key, group in itertools.groupby(a, operator.itemgetter('foo'))]</span><br/>[('bar', [{'foo': 'bar'}, {'x': 42, 'foo': 'bar'}]), ('baz', [{'y': 43, 'foo': 'baz'}])]</p>&#13;
<p class="indent">In this case, we could have also written <span class="literal">lambda x: x['foo']</span>, but using <span class="literal">operator</span> lets us avoid having to use <span class="literal">lambda</span> at all.</p>&#13;
<h3 class="h3" id="lev1sec45"><span epub:type="pagebreak" id="page_134"/><strong>Summary</strong></h3>&#13;
<p class="noindent">While Python is often advertised as being object oriented, it can be used in a very functional manner. A lot of its built-in concepts, such as generators and list comprehension, are functionally oriented and don’t conflict with an object-oriented approach. They also limit the reliance on a program’s global state, for your own good.</p>&#13;
<p class="indent">Using functional programming as a paradigm in Python can help you make your program more reusable and easier to test and debug, supporting the Don’t Repeat Yourself (DRY) mantra. In this spirit, the standard Python modules <span class="literal">itertools</span> and <span class="literal">operator</span> are good tools to improve the readability of your functional code.</p>&#13;
</body></html>