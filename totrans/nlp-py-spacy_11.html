<html><head></head><body>
<div id="sbo-rt-content"><h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_155"/><strong><span class="big">11</span><br/>DEPLOYING YOUR OWN CHATBOT</strong></h2>&#13;
<div class="image1"><img src="../Images/comm1.jpg" alt="Image" width="191" height="191"/></div>&#13;
<p class="noindents">In previous chapters, you hardcoded all the input to your NLP scripts by manually assigning text to a doc object. But when you build chatbots for tasks like taking orders, things get more complicated. You’ll need to deploy your app to a <em>bot channel</em>, such as Telegram, which facilitates communication between a bot and a user.</p>&#13;
<p class="indent">This chapter begins with an overview of how to organize a chatbot app. You’ll be guided through the process of preparing a platform for your chatbot with Telegram and then deploying the bot to that platform. You’ll learn how to process multiple kinds of user input with the Telegram API and hold the state of a conversation to keep track of which questions have already been asked.</p>&#13;
<h3 class="h3" id="lev146"><span epub:type="pagebreak" id="page_156"/><strong>How Implementing and Deploying a Chatbot Works</strong></h3>&#13;
<p class="noindent">This section looks closely at how information is transmitted between a typical chatbot and a user, as well as at the structure this transmission needs.</p>&#13;
<p class="indent">A typical chatbot app consists of multiple tiers. After you’ve implemented the logic for processing user input on your machine, you’ll need a messenger app that allows you to create accounts that programs operate. Users won’t interact with the bot implementation on your machine directly; instead, they’ll chat with the bot through the messenger. Apart from a messenger, your chatbot might require some additional services, such as a database or other storage.</p>&#13;
<p class="indent">The diagram in <a href="../Text/ch11.xhtml#ch11fig01">Figure 11-1</a> represents how a typical chatbot application combines these tiers.</p>&#13;
<div class="image"><a id="ch11fig01"/><img src="../Images/fig11-1.jpg" alt="image" width="482" height="454"/></div>&#13;
<p class="figcap"><em>Figure 11-1: Typical interactions between a user and a bot integrated to a messenger</em></p>&#13;
<p class="indent">The bot application first sends requests to the messenger in an infinite loop, checking whether a user has started a conversation. These requests include an authentication token generated when the developer created the bot in the messenger. An <em>authentication token</em> (also called an access token or API key) is unique to the bot that allows the messenger to recognize requests coming from this particular bot.</p>&#13;
<p class="indent">When a user sends a message to the bot, the messenger processes it and then forwards it to the addressee. The bot chooses an appropriate <em>handler—</em>a routine that generates responses to a certain type of user messages—and sends the generated reply to the user.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_157"/>The intermediary program that the chatbot uses to interact with users is often a bot platform provided by a messenger app, such as Skype, Facebook Messenger, or Telegram. From the messenger’s standpoint, the bot is a third-party application that runs inside the messenger.</p>&#13;
<p class="indent">The next section guides you through the process of deploying a chatbot implemented in Python to the Telegram’s bot platform. You’ll see some bot implementation details that are specific to the Telegram’s bot platform and will learn to use its features to make bot development easy.</p>&#13;
<p class="indent">I chose the Telegram bot platform for this example because it provides comprehensive resources for Python developers, including the Python Telegram Bot documentation, guides and tutorials, and examples on GitHub. That is, Telegram provides everything you need to build a chatbot in Python. In other messaging apps, like Facebook Messenger for example, you’d need to use third-party tools, such as Flask or Ngrok, complicating a bot’s implementation and not strictly focusing on NLP tasks.</p>&#13;
<h3 class="h3" id="lev147"><strong>Using Telegram as a Platform for Your Bot</strong></h3>&#13;
<p class="noindent">Telegram is a cloud-based messenger and one of the top messenger apps in the world. Among other features, it provides a platform for creating bots along with a Python library that offers an easy-to-use interface. You can use Telegram on Android, iOS, Windows, Linux, and macOS platforms. But it’s primarily designed for smartphones.</p>&#13;
<h4 class="h4" id="lev148"><strong><em>Creating a Telegram Account and Authorizing Your Bot</em></strong></h4>&#13;
<p class="noindent">Before you can create a bot in Telegram, you must sign up for a Telegram account. To do so, you’ll need a smartphone or tablet that runs either iOS or Android. A PC version of Telegram won’t work for this operation. However, once you create a Telegram account, you can use it on a PC.</p>&#13;
<p class="indent">You’ll find steps that guide you through the process of creating a Telegram account at <em><a href="https://telegramguide.com/create-a-telegram-account/">https://telegramguide.com/create-a-telegram-account/</a></em>. Once you have a Telegram account, you can create a bot. You can do this from either a smartphone or a PC, as described in the following steps:</p>&#13;
<ol>&#13;
<li class="noindent">In the Telegram app, perform a search for @BotFather or open the URL <em><a href="https://telegram.me/botfather/">https://telegram.me/botfather/</a></em>. BotFather is a Telegram bot that manages all the other bots in your account.</li>&#13;
<li class="noindent">On the BotFather page, click the <strong>Start</strong> button to see the list of commands that you can use to set up your Telegram bots.</li>&#13;
<li class="noindent">To create a new bot, enter the <code>/newbot</code> command in the <strong>Write a message</strong> box. You’ll be prompted for a name and a username for your bot. Then you’ll be given an authorization token for the new bot. <a href="../Text/ch11.xhtml#ch11fig02">Figure 11-2</a> shows a screenshot of this process on a smartphone.</li>&#13;
</ol>&#13;
<div class="image"><span epub:type="pagebreak" id="page_158"/><a id="ch11fig02"/><img src="../Images/fig11-2.jpg" alt="image" width="511" height="389"/></div>&#13;
<p class="figcap"><em>Figure 11-2: Creating a new bot in Telegram using a smartphone</em></p>&#13;
<p class="indent">Now you can integrate the bot functionality implemented on your machine in a Python file with the bot you just created in Telegram, as discussed in the next section.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>It’s important to know that a bot you just created in Telegram doesn’t implement the logic for handling user input. In fact, it’s just a wrapper for the actual bot you need to implement on your own.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="lev149"><strong><em>Getting Started with the python-telegram-bot Library</em></strong></h4>&#13;
<p class="noindent">To connect chatbot functionality implemented in Python, you’ll need the <code>python-telegram-bot</code> library, which is built on top of the Telegram Bot API. The library provides an easy-to-use interface for bot programmers developing apps for Telegram. It allows you to focus on coding the bot rather than on the details related to the interactions between the messenger and the bot implementation.</p>&#13;
<p class="indent">The <code>python-telegram-bot</code> library is free software distributed under an LGPLv3 license. You can install or upgrade it via <code>pip</code> using the following command:</p>&#13;
<pre>$ pip install python-telegram-bot --upgrade</pre>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The examples provided throughout the rest of this chapter assume that you’re using <code>python-telegram-bot</code> version 12.0 or later.</em></p>&#13;
</div>&#13;
<p class="indent">Once you’ve installed the library, use the following lines of code to perform a quick test to verify that you can access your Telegram bot from Python. You must have an internet connection for this test to work.</p>&#13;
<span epub:type="pagebreak" id="page_159"/><pre>import telegram<br/>&#13;
bot = telegram.Bot(token='XXXXXX...')</pre>&#13;
<p class="indent">In place of <code>'XXXXX'</code>, include the token you were given when creating the bot. Then check your credentials using this line:</p>&#13;
<pre>print(bot.get_me())</pre>&#13;
<p class="indent">If the <code>bot.get_me()</code> function returns your credentials, the bot’s authentication token you specified previously is valid.</p>&#13;
<h4 class="h4" id="lev150"><strong><em>Using the telegram.ext Objects</em></strong></h4>&#13;
<p class="noindent">To build a real bot, you’ll need to use the<code> telegram.ext</code> objects, including <code>telegram.ext.Updater</code> and <code>telegram.ext.Dispatcher</code>. These are two of the most important objects in the library, because they’re required in every implementation. In a nutshell, an <code>Updater</code> object receives the messages from Telegram and delivers them to a <code>Dispatcher</code>. In turn, the <code>Dispatcher</code> passes the data to an appropriate handler for processing. The following code illustrates how to use these objects in a simple echo bot that replies to each message with a message that has the same text:</p>&#13;
<pre>   from telegram.ext import Updater, MessageHandler, Filters<br/>&#13;
   #function that implements the message handler <br/>&#13;
<span class="ent">➊</span> def echo(update, context):<br/>&#13;
     update.message.reply_text(update.message.text)<br/>&#13;
   #creating an Updater instance<br/>&#13;
<span class="ent">➋</span> updater = Updater('TOKEN', use_context=True)<br/>&#13;
   #registering a handler to handle input text messages<br/>&#13;
   updater.dispatcher.add_handler(MessageHandler(Filters.text, echo))<br/>&#13;
   #starting polling updates from the messenger <br/>&#13;
   updater.start_polling()<br/>&#13;
   updater.idle()</pre>&#13;
<p class="indent">We start by importing the <code>Updater</code> and <code>MessageHandler</code> modules from the <code>telegram.ext</code> package. Then we define the <code>echo()</code> function, which takes two objects as parameters: <code>update</code> and <code>context</code> <span class="ent">➊</span>. The <code>update</code> object represents an incoming message, which can be text, a photo, a sticker, and so on. The <code>context</code> object contains attributes that can hold data from the same chat and user. Both <code>update</code> and <code>context</code> are generated for you behind the scenes and passed to the <em>callback</em>—a message processing function assigned to a certain handler. In this example, the text message handler’s callback function is <code>echo()</code>; it contains a single line of code that instructs Telegram to return a user’s text message without any change.</p>&#13;
<p class="indent">Next, we create an <code>Updater</code> object <span class="ent">➋</span>, which we’ll use to orchestrate the bot execution process throughout the script. When we create an <code>Updater</code> object, a <code>Dispatcher</code> object is created automatically for us, allowing us to register handlers for different types of input data, such as text and photo. In this example, we register a single handler designed to handle only text <span epub:type="pagebreak" id="page_160"/>messages, passing it the callback function implemented earlier in this script. Now the chatbot will call the callback function every time it receives a Telegram message that contains text.</p>&#13;
<p class="indent">Then we start the bot by invoking the <code>start_polling()</code> method of the<code> Updater</code>, which launches the process of polling new messages from the messenger. Because <code>start_polling()</code> is a non-blocking method, we also have to call the <code>idle()</code> method of the<code> Updater</code>, which blocks our script until a message is received or a user enters an exit shortcut (<span class="smallcaps">CTRL</span>-C). For further details on the classes and methods available in the <code>python-telegram-bot</code> library, read the Python Telegram Bot’s documentation.</p>&#13;
<p class="indent">To test the script, run it on an internet-connected machine. Once it’s running, any Telegram user can start a conversation with your chatbot. In the Telegram app, search for @<em>&lt;username&gt;</em>, entering the username you gave your bot when you created it; then select it. To start a conversation, click the <strong>/start</strong> button or enter the <code>/start</code> command. You can then start sending messages to your bot. Because you’ve implemented an echo bot, any reply message from the bot should contain the same text you sent it.</p>&#13;
<h4 class="h4" id="lev151"><strong><em>Creating a Telegram Chatbot That Uses spaCy</em></strong></h4>&#13;
<p class="noindent">In the preceding section, we used the <code>python-telegram-bot</code> library and built a simple script integrated into Telegram. Let’s now enhance our implementation and add spaCy to make sure the bot created in Telegram is fully operational.</p>&#13;
<p class="indent">The following code creates a simple bot that processes a user’s utterance and determines whether or not it contains a direct object. Based on that information, it generates a reply message for the user. This code isn’t very useful on its own, but it should show you how to connect text-processing code implemented with spaCy to the code implemented with the <code>python-</code><code>telegram-bot</code> library.</p>&#13;
<pre>   import spacy<br/>&#13;
   from telegram.ext import Updater, MessageHandler, Filters<br/>&#13;
   #the callback function that uses spaCy<br/>&#13;
<span class="ent">➊</span> def utterance(update, context):<br/>&#13;
     msg = update.message.text<br/>&#13;
     nlp = spacy.load('en')<br/>&#13;
     doc = nlp(msg)<br/>&#13;
     for token in doc:<br/>&#13;
       if token.dep_ == 'dobj':<br/>&#13;
         update.message.reply_text('We are processing your request...') <br/>&#13;
         return<br/>&#13;
     update.message.reply_text('Please rephrase your request. Be as specific as<br/>&#13;
     possible!')     <br/>&#13;
   #the code responsible for interactions with Telegram<br/>&#13;
   updater = Updater('TOKEN', use_context=True)<br/>&#13;
   updater.dispatcher.add_handler(MessageHandler(Filters.text, utterance))<br/>&#13;
   updater.start_polling()<br/>&#13;
   updater.idle()</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_161"/>Notice that the code responsible for interactions with Telegram is the same as in the preceding script. The only difference here is the implementation of the callback function <span class="ent">➊</span>. In this case, the <code>utterance()</code> function uses spaCy to process a user’s input.</p>&#13;
<p class="indent">In that function, we first extract the message text from the <code>update</code> object passed to the function. Next, we convert it into a spaCy Doc object and then check whether the utterance in the doc includes a direct object. If the utterance doesn’t include a direct object, we ask the user to be more specific. For example, a user might say “I am hungry,” which implies they want to order some food. But to place an order, we need them to be more specific; for example, “I want a pizza.”</p>&#13;
<p class="indent">Perhaps the most interesting aspect of this example is that it illustrates where utterances that spaCy will process can come from in a bot application. In the examples in previous chapters, we used utterances hardcoded in scripts. This is the first time you can see how real chatbots obtain their input.</p>&#13;
<h4 class="h4" id="lev152"><strong><em>Expanding the Chatbot</em></strong></h4>&#13;
<p class="noindent">Now that you generally know how to integrate a chatbot that uses spaCy into Telegram, let’s create a more interesting bot. For example, you might enhance the bot’s functionality in the previous section so it extracts the intent from a user’s message rather than just printing a message that the request is being processed. To accomplish this, you could recycle a script from one of the previous chapters.</p>&#13;
<p class="indent">Go back to the script in “<a href="../Text/ch08.xhtml#lev110">Recognizing Synonyms Using Predefined Lists</a>” on <a href="../Text/ch08.xhtml#page_117">page 117</a> in <a href="../Text/ch08.xhtml#ch08">Chapter 8</a>, which uses lists of synonyms to extract the intent from a submitted utterance. Put the code from this script into a separate function, say, <code>extract_intent()</code>, which should take a single parameter—the text of a user’s message as a Doc object (be sure to exclude the line of code with the hardcoded utterance at the beginning of the script as well as the line that prints the intent at the end). Additionally, the function you’re creating must return a recognized intent as a string. In the script you’re creating, place the new function above the callback function and revise the callback so it looks as follows:</p>&#13;
<pre>...<br/>&#13;
def extract_intent(doc):<br/>&#13;
  #Put the code from <a href="../Text/ch08.xhtml#ch08">Chapter 8</a> here <br/>&#13;
<br/>&#13;
def utterance(update, context):<br/>&#13;
  msg = update.message.text<br/>&#13;
  nlp = spacy.load('en')<br/>&#13;
  doc = nlp(msg)<br/>&#13;
  for token in doc:<br/>&#13;
    if token.dep_ == 'dobj':<br/>&#13;
   <span class="ent">➊</span> intent = extract_intent(doc) <br/>&#13;
   <span class="ent">➋</span> if intent == 'orderPizza': <br/>&#13;
        update.message.reply_text('We need some more information to place your<br/>&#13;
        order.')<br/>&#13;
      elif intent == 'showPizza': <br/>&#13;
<span epub:type="pagebreak" id="page_162"/>        update.message.reply_text('Would you like to look at our menu?')<br/>&#13;
      else:<br/>&#13;
        update.message.reply_text('Your intent is not recognized.')<br/>&#13;
      return<br/>&#13;
  update.message.reply_text('Please rephrase your request. Be as specific as<br/>&#13;
  possible!')     <br/>&#13;
...</pre>&#13;
<p class="indent">We call the newly created <code>extract_intent()</code> function from within the utterance callback to obtain the user’s intent <span class="ent">➊</span>. Then we take an appropriate action, depending on the intent obtained. In this example, we simply send the user a relevant message <span class="ent">➋</span>.</p>&#13;
<p class="indent">Although we could put the code from <a href="../Text/ch08.xhtml#ch08">Chapter 8</a> into the callback function directly, doing so would decrease the overall readability of the code, so it’s considered bad practice.</p>&#13;
<h4 class="h4" id="lev153"><strong><em>Holding the State of the Current Chat</em></strong></h4>&#13;
<p class="noindent">The bot you have now does more than simply evaluate a user’s message; it can recognize a user’s intent. Still, this isn’t enough to take orders from users. The primary flaw is that the chatbot will use the same utterance callback function for each user input, even when the intent has been recognized and it’s time to ask the user additional questions.</p>&#13;
<p class="indent">To address this problem, you need to <em>hold the state</em> of the current chat so your bot knows what questions have already been answered and what it still has to ask. Then you’ll need to modify the callback so it can process user messages according to the chat’s current state.</p>&#13;
<p class="indent">This bot could work as follows: if the chatbot hasn’t yet discovered an intent, it should ask the user to express it. After finding the intent, the bot should switch to another question that is relevant to the conversation’s current state.</p>&#13;
<p class="indent">To help you simplify this kind of implementation, the <code>python-telegram-bot</code> library includes the <code>ConversationHandler</code> object; it allows you to define entry points and states of the conversation by tying them to a handler.</p>&#13;
<p class="indent">An entry point—for example, a Telegram command like <code>/start</code>—is attached to a handler that can trigger the start of a chat. The handler’s callback must return the initial state of conversation; this action determines what handler to use for the user message that follows. To change the state of conversation, the handler’s callback returns a new state after replying to the user.</p>&#13;
<p class="indent">The following code includes fragments of a script that illustrates how to change the conversation’s state between a chatbot and a user using <code>ConversationHandler</code>:</p>&#13;
<pre>def start(update, context):<br/>&#13;
...<br/>&#13;
  <span class="ent">➊</span> return 'ORDERING'<br/>&#13;
def intent_ext(update, context):<br/>&#13;
...<br/>&#13;
  <span class="ent">➋</span> if context.user_data.has_key('intent'):<br/>&#13;
        return 'ADD_INFO'<br/>&#13;
<span epub:type="pagebreak" id="page_163"/>    else:<br/>&#13;
        update.message.reply_text('Please rephrase your request.')<br/>&#13;
        return 'ORDERING'<br/>&#13;
def add_info(update, context):<br/>&#13;
...<br/>&#13;
    return ConversationHandler.END<br/>&#13;
def cancel(update, context):<br/>&#13;
...<br/>&#13;
    return ConversationHandler.END<br/>&#13;
...<br/>&#13;
def main():<br/>&#13;
...<br/>&#13;
    disp = updater.dispatcher<br/>&#13;
    conv_handler = ConversationHandler(<br/>&#13;
        entry_points=[CommandHandler('start', start)],<br/>&#13;
        states={<br/>&#13;
            <span class="ent">➌</span> 'ORDERING': [MessageHandler(Filters.text,<br/>&#13;
                                        intent_ext)<br/>&#13;
                        ],<br/>&#13;
            'ADD_INFO': [MessageHandler(Filters.text,<br/>&#13;
                                        add_info)<br/>&#13;
                        ],<br/>&#13;
        },<br/>&#13;
        fallbacks=[CommandHandler('cancel', cancel)]<br/>&#13;
    )<br/>&#13;
    disp.add_handler(conv_handler)<br/>&#13;
...</pre>&#13;
<p class="indent">Using <code>ConversationHandler</code> lets us define several callback functions and the order in which they should be called. A callback processes the user’s message, and depending on the processing results, might change the state of the conversation flow.</p>&#13;
<p class="indent">In this example, the callback for the <code>/start</code> command switches the conversation to the <code>ORDERING</code> state <span class="ent">➊</span>, which means that the next message coming in from the user will be processed by the<code> intent_ext()</code> function. The reason is that the <code>intent_ext()</code> function is the callback that belongs to the <code>ORDERING</code> state’s handler <span class="ent">➌</span>, as defined in the <code>ConversationHandler</code> object’s <code>states</code> dictionary.</p>&#13;
<p class="indent">Note that the chatbot can switch between states based on a conditional logic, as illustrated in the <code>intent_ext()</code> function: there, the conversation’s state will change to <code>ADD_INFO</code> (the state in which you collect additional information) only if the intent has been recognized <span class="ent">➋</span>.</p>&#13;
<h4 class="h4" id="lev154"><strong><em>Putting All the Pieces Together</em></strong></h4>&#13;
<p class="noindent">Now that you have a cursory understanding of how to structure a Telegram bot that follows a predefined conversation flow, let’s look at what a full implementation of such a script might look like. This bot needs to ask the user a series of questions, one after another, to complete an order form. Because this is a simplified example, the chatbot can process only one intent, <code>orderPizza</code>, and ask a user to specify only the type of pizza when completing the order form.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_164"/>The following script is broken into chunks representing each function definition:</p>&#13;
<pre>import logging<br/>&#13;
import sys<br/>&#13;
import spacy<br/>&#13;
from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, ConversationHandler<br/>&#13;
#allows you to obtain generic debug info<br/>&#13;
logger = logging.getLogger(__name__)<br/>&#13;
logging.basicConfig(stream=sys.stdout, level=logging.DEBUG)<br/>&#13;
<br/>&#13;
def extract_intent(doc):<br/>&#13;
  #Here should be the code created as suggested in the Expanding the Chatbot section earlier<br/>&#13;
  ...<br/>&#13;
  return intent</pre>&#13;
<p class="indent">The <code>extract_intent()</code> function extracts the intent from a submitted utterance. We’ll call this function from within the <code>intent_ext()</code> callback function defined next. The code for <code>extract_intent()</code> isn’t provided here, but you can use the code described earlier in “<a href="../Text/ch11.xhtml#lev152">Expanding the Chatbot</a>” on <a href="../Text/ch11.xhtml#page_161">page 161</a>.</p>&#13;
<pre>def details_to_str(user_data):<br/>&#13;
    details = list()<br/>&#13;
    for key, value in user_data.items():<br/>&#13;
        details.append('{} - {}'.format(key, value))<br/>&#13;
    return "\n".join(details).join(['\n', '\n'])</pre>&#13;
<p class="indent">The <code>details_to_str()</code> function simply converts the content of the <code>user_data</code> dictionary to a string. The <code>user_data</code> dictionary contains information that the chatbot will extract from the conversation, such as the kind of pizza and number of pizzas the user wants. The bot includes this information in the final message sent to the user.</p>&#13;
<p class="indent">So far, we have defined the helper functions that will be invoked—either directly or indirectly—from within the bot’s callback functions. Let’s now define the callback functions.</p>&#13;
<pre>def start(update, context):<br/>&#13;
    update.message.reply_text('Hi! This is a pizza ordering app. Do you want to order something?')<br/>&#13;
    return 'ORDERING'</pre>&#13;
<p class="indent">The <code>start()</code> function is the callback for the <code>/start</code> Telegram command. In other words, the chatbot calls this function upon starting a chat. The function returns the <code>ORDERING</code> state, which means that the next message received will be processed by the callback attached to the <code>ORDERING</code> state’s handler (the <code>intent_ext()</code> function in this example).</p>&#13;
<pre>def intent_ext(update, context):<br/>&#13;
  msg = update.message.text<br/>&#13;
  nlp = spacy.load('en')<br/>&#13;
  doc = nlp(msg)<br/>&#13;
  for token in doc:<br/>&#13;
<span epub:type="pagebreak" id="page_165"/>    if token.dep_ == 'dobj':<br/>&#13;
      intent = extract_intent(doc) <br/>&#13;
      if intent == 'orderPizza': <br/>&#13;
        context.user_data['product'] = 'pizza'<br/>&#13;
        update.message.reply_text('We need some more information to place your order. What type<br/>&#13;
        of pizza do you want?')<br/>&#13;
        return 'ADD_INFO'<br/>&#13;
      else:<br/>&#13;
        update.message.reply_text('Your intent is not recognized. Please rephrase your request.')<br/>&#13;
        return 'ORDERING'<br/>&#13;
      return<br/>&#13;
  update.message.reply_text('Please rephrase your request. Be as specific as possible!')</pre>&#13;
<p class="indent">For simplicity, the <code>intent_ext()</code> function used here can recognize only one intent: <code>orderPizza</code>. If it detects this intent, it returns the <code>ADD_INFO</code> state. Otherwise, it returns the <code>ORDERING</code> state, which will cause the <code>intent_ext()</code> function to be invoked again to process the next user message. The <code>ADD_INFO</code> state’s handler can be implemented as follows:</p>&#13;
<pre>def add_info(update, context):<br/>&#13;
  msg = update.message.text<br/>&#13;
  nlp = spacy.load('en')<br/>&#13;
  doc = nlp(msg)<br/>&#13;
  for token in doc:<br/>&#13;
    if token.dep_ == 'dobj':<br/>&#13;
      dobj = token<br/>&#13;
      for child in dobj.lefts:<br/>&#13;
        if child.dep_ == 'amod' or child.dep_ == 'compound': <br/>&#13;
          context.user_data['type'] = child.text<br/>&#13;
          user_data = context.user_data<br/>&#13;
          update.message.reply_text("Your order has been placed."<br/>&#13;
                                    "{}"<br/>&#13;
                                    "Have a nice day!".format(details_to_str(user_data)))<br/>&#13;
          return ConversationHandler.END<br/>&#13;
    update.message.reply_text("Cannot extract necessary info. Please try again.")<br/>&#13;
    return 'ADD_INFO'</pre>&#13;
<p class="indent">The <code>add_info()</code> function is the callback for the <code>ADD_INFO</code> state handler. In this implementation, it expects that a user ordering pizza will specify the type of pizza they want, then switches the state to <code>ConversationHandler.END</code>, the last state, as follows:</p>&#13;
<pre>def cancel(update, context):<br/>&#13;
    update.message.reply_text("Have a nice day!")<br/>&#13;
    return ConversationHandler.END</pre>&#13;
<p class="indent">The <code>cancel()</code> function used here simply sends a goodbye message to the user and switches the state to <code>ConversationHandler.END</code>.</p>&#13;
<p class="indent">Finally, the <code>main()</code> function should look like this:</p>&#13;
<pre>def main():<br/>&#13;
    #Replace TOKEN with a real token <br/>&#13;
<span epub:type="pagebreak" id="page_166"/>    updater = Updater("TOKEN", use_context=True)<br/>&#13;
    disp = updater.dispatcher<br/>&#13;
    conv_handler = ConversationHandler(<br/>&#13;
        entry_points=[CommandHandler('start', start)],<br/>&#13;
        states={<br/>&#13;
            'ORDERING': [MessageHandler(Filters.text,<br/>&#13;
                                        intent_ext)<br/>&#13;
                        ],<br/>&#13;
            'ADD_INFO': [MessageHandler(Filters.text,<br/>&#13;
                                        add_info)<br/>&#13;
                        ],<br/>&#13;
        },<br/>&#13;
        fallbacks=[CommandHandler('cancel', cancel)]<br/>&#13;
    )<br/>&#13;
    disp.add_handler(conv_handler)<br/>&#13;
    updater.start_polling()<br/>&#13;
    updater.idle()<br/>&#13;
if __name__ == '__main__':<br/>&#13;
    main()</pre>&#13;
<p class="indent">As usual, a bot script’s <code>main()</code> function orchestrates the bot execution process.</p>&#13;
<p class="indent">You can test the script using either the Telegram web app on a computer or the Telegram app on a smartphone. <a href="../Text/ch11.xhtml#ch11fig03">Figure 11-3</a> shows a screenshot from the Telegram web app when it’s running the script.</p>&#13;
<div class="image"><a id="ch11fig03"/><img src="../Images/fig11-3.jpg" alt="image" width="694" height="550"/></div>&#13;
<p class="figcap"><em>Figure 11-3: Testing your bot using the Telegram web app</em></p>&#13;
<h4 class="h4" id="lev155"><span epub:type="pagebreak" id="page_167"/><strong><em>Try This</em></strong></h4>&#13;
<p class="noindent">Modify the script in the preceding section so it can recognize and process more intents than just <code>orderPizza</code>. Another relevant intent could be <code>showPizza</code>, meaning the user wants to look at the menu. To implement this, you’ll need to modify the <code>intent_ext()</code> function, adding an <code>if intent ==</code> <code>'showPizza'</code> condition in the doc processing loop. Also, you’ll need to add a new state to the <code>states</code> dictionary in the <code>ConversationHandler</code> object—say, <code>SHOW_MENU</code>—and implement the callback for it.</p>&#13;
<h3 class="h3" id="lev156"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you learned how to implement and deploy a simple chatbot app using the Telegram bot platform, a popular messenger app. You learned how to define and hold states in a conversation. Notably, you also saw an example of where the user messages that you’d process with spaCy might actually come from.<span epub:type="pagebreak" id="page_168"/></p>&#13;
</div>&#13;
</body></html>