<html><head></head><body>
<h2 class="h2" id="ch13"><span epub:type="pagebreak" id="page_201"/><strong><span class="big">13</span></strong><br/><strong>WRITE LESS, CODE MORE</strong></h2>&#13;
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>&#13;
<p class="noindent">In this final chapter, I’ve compiled a few of Python’s more advanced features that I use to write better code. These are not limited to the Python Standard Library. We’ll cover how to make your code compatible with both Python 2 and 3, how to create a Lisp-like method dispatcher, how to use context managers, and how to create a boilerplate for classes with the <code>attr</code> module.</p>&#13;
<h3 class="h3" id="lev1sec72"><strong>Using six for Python 2 and 3 Support</strong></h3>&#13;
<p class="noindent">As you likely know, Python 3 breaks compatibility with Python 2 and shifts things around. However, the basics of the language haven’t changed between versions, which makes it possible to implement forward and backward compatibility, creating a bridge between Python 2 and Python 3.</p>&#13;
<p class="indent">Lucky for us, this module already exists! It’s called <code>six</code>—because 2 × 3 = 6.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_202"/>The <code>six</code> module provides the useful <code>six.PY3</code> variable, which is a Boolean that indicates whether you are running Python 3 or not. This is the pivot variable for any of your codebase that has two versions: one for Python 2 and one for Python 3. However, be careful not to abuse it; scattering your codebase with <code>if six.PY3</code> is going to make it difficult for people to read and understand.</p>&#13;
<p class="indent">When we discussed generators in “<a href="ch08.xhtml#lev1sec42">Generators</a>” on <a href="ch08.xhtml#page_121">page 121</a>, we saw that Python 3 has a great property whereby iterable objects are returned instead of lists in various built-in functions, such as <code>map()</code> or <code>filter()</code>. Python 3 therefore got rid of methods like <code>dict.iteritems()</code>, which was the iterable version of <code>dict.items()</code> in Python 2, in favor of making <code>dict.items()</code> return an iterator rather than a list. This change in methods and their return types can break your Python 2 code.</p>&#13;
<p class="indent">The <code>six</code> module provides <code>six.iteritems()</code> for such cases, which can be used to replace Python 2–specific code like this:</p>&#13;
<pre>for k, v in mydict.iteritems():<br/>    print(k, v)</pre>&#13;
<p class="indent">Using <code>six</code>, you would replace the <code>mydict.iteritems()</code> code with Python 2- and 3-compliant code like so:</p>&#13;
<pre>import six<br/><br/>for k, v in six.iteritems(mydict):<br/>    print(k, v)</pre>&#13;
<p class="indent">And <em>voilà</em>, both Python 2 and Python 3 compliance achieved in a snap! The <code>six.iteritems()</code> function will use either <code>dict.iteritems()</code> or <code>dict.items()</code> to return a generator, depending on the version of Python you’re using. The <code>six</code> module provides a lot of similar helper functions that can make it easy to support multiple Python versions.</p>&#13;
<p class="indent">Another example would be the <code>six</code> solution to the <code>raise</code> keyword, whose syntax is different between Python 2 and Python 3. In Python 2, <code>raise</code> will accept multiple arguments, but in Python 3, <code>raise</code> accepts an exception as its only argument and nothing else. Writing a <code>raise</code> statement with two or three arguments in Python 3 would result in a <code>SyntaxError</code>.</p>&#13;
<p class="indent">The <code>six</code> module provides a workaround here in the form of the function <code>six.reraise()</code>, which allows you to reraise an exception in whichever version of Python you use.</p>&#13;
<h4 class="h4" id="lev2sec62"><strong><em>Strings and Unicode</em></strong></h4>&#13;
<p class="noindent">Python 3’s enhanced ability to handle advanced encodings solved the string and unicode issues of Python 2. In Python 2, the basic string type is <code>str</code>, which can only handle basic ASCII strings. The type <code>unicode</code>, added later in Python 2.5, handles real strings of text.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_203"/>In Python 3, the basic string type is still <code>str</code>, but it shares the properties of the Python 2 <code>unicode</code> class and can handle advanced encodings. The <code>bytes</code> type replaces the <code>str</code> type for handling basic character streams.</p>&#13;
<p class="indent">The <code>six</code> module again provides functions and constants, such as <code>six.u</code> and <code>six.string_types</code>, to handle the transition. The same compatibility is provided for integers, with <code>six.integer_types</code> that will handle the <code>long</code> type that has been removed from Python 3.</p>&#13;
<h4 class="h4" id="lev2sec63"><strong><em>Handling Python Modules Moves</em></strong></h4>&#13;
<p class="noindent">In the Python Standard Library, some modules have moved or have been renamed between Python 2 and 3. The <code>six</code> module provides a module called <code>six.moves</code> that handles a lot of these moves transparently.</p>&#13;
<p class="indent">For example, the <code>ConfigParser</code> module from Python 2 has been renamed to <code>configparser</code> in Python 3. <a href="ch13.xhtml#ch13list1">Listing 13-1</a> shows how code can be ported and made compatible with both major Python versions using <code>six.moves</code>:</p>&#13;
<pre>from six.moves.configparser import ConfigParser<br/><br/>conf = ConfigParser()</pre>&#13;
<p class="listing1"><a id="ch13list1"/><em>Listing 13-1: Using <span class="codeitalic">six.moves</span> to use <span class="codeitalic">ConfigParser()</span> with Python 2 and Python 3</em></p>&#13;
<p class="indent">You can also add your own moves via <code>six.add_move</code> to handle code transitions that <code>six</code> doesn’t handle natively.</p>&#13;
<p class="indent">In the event that the <code>six</code> library doesn’t cover all your use cases, it may be worth building a compatibility module encapsulating <code>six</code> itself, thereby ensuring that you will be able to enhance the module to fit future versions of Python or dispose of (part of) it when you want to stop supporting a particular version of the language. Also note that <code>six</code> is open source and that you can contribute to it rather than maintain your own hacks!</p>&#13;
<h4 class="h4" id="lev2sec64"><strong><em>The modernize Module</em></strong></h4>&#13;
<p class="noindent">Lastly, there is a tool named <code>modernize</code> that uses the <code>six</code> module to “modernize” your code by porting it to Python 3, rather than simply converting Python 2 syntax to Python 3 syntax. This provides support for both Python 2 and Python 3. The <code>modernize</code> tool helps to get your port off to a strong start by doing most of the grunt work for you, making this tool a better choice than the standard <code>2to3</code> tool.</p>&#13;
<h3 class="h3" id="lev1sec73"><strong>Using Python Like Lisp to Make a Single Dispatcher</strong></h3>&#13;
<p class="noindent">I like to say that Python is a good subset of the Lisp programming language, and as time passes, I find that this is more and more true. The PEP 443 proves that point: it describes a way to dispatch generic functions in a similar manner to what the Common Lisp Object System (CLOS) provides.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_204"/>If you’re familiar with Lisp, this won’t be news to you. The Lisp object system, which is one of the basic components of Common Lisp, provides a simple, efficient way to define and handle method dispatching. I’ll show you how generic methods work in Lisp first.</p>&#13;
<h4 class="h4" id="lev2sec65"><strong><em>Creating Generic Methods in Lisp</em></strong></h4>&#13;
<p class="noindent">To begin with, let’s define a few very simple classes, without any parent classes or attributes, in Lisp:</p>&#13;
<pre>(defclass snare-drum ()<br/>  ())<br/><br/>(defclass cymbal ()<br/>  ())<br/><br/>(defclass stick ()<br/>  ())<br/><br/>(defclass brushes ()<br/>  ())</pre>&#13;
<p class="indent">This defines the classes <code>snare-drum</code>, <code>cymbal</code>, <code>stick</code>, and <code>brushes</code> without any parent class or attributes. These classes compose a drum kit, and we can combine them to play sound. For this, we define a <code>play()</code> method that takes two arguments and returns a sound as a string:</p>&#13;
<pre>(defgeneric play (instrument accessory)<br/>  (:documentation "Play sound with instrument and accessory."))</pre>&#13;
<p class="indent">This only defines a generic method that isn’t attached to any class and so cannot yet be called. At this stage, we’ve only informed the object system that the method is generic and might be called with two arguments named <code>instrument</code> and <code>accessory</code>. In <a href="ch13.xhtml#ch13list2">Listing 13-2</a>, we’ll implement versions of this method that simulate playing our snare drum.</p>&#13;
<pre>(defmethod play ((instrument snare-drum) (accessory stick))<br/>  "POC!")<br/><br/>(defmethod play ((instrument snare-drum) (accessory brushes))<br/>  "SHHHH!")<br/><br/>(defmethod play ((instrument cymbal) (accessory brushes))<br/>  "FRCCCHHT!")</pre>&#13;
<p class="listing1"><a id="ch13list2"/><em>Listing 13-2: Defining generic methods in Lisp, independent of classes</em></p>&#13;
<p class="indent">Now we’ve defined concrete methods in code. Each method takes two arguments: <code>instrument</code>, which is an instance of <code>snare-drum</code> or <code>cymbal</code>, and <code>accessory</code>, which is an instance of <code>stick</code> or <code>brushes</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_205"/>At this stage, you should see the first major difference between this system and the Python (or similar) object systems: the method isn’t tied to any particular class. The methods are <em>generic</em>, and they can be implemented for any class.</p>&#13;
<p class="indent">Let’s try it. We can call our <code>play()</code> method with some objects:</p>&#13;
<pre>* (play (make-instance 'snare-drum) (make-instance 'stick))<br/>"POC!"<br/><br/>* (play (make-instance 'snare-drum) (make-instance 'brushes))<br/>"SHHHH!"</pre>&#13;
<p class="indent">As you can see, which function is called depends on the class of the arguments—the object system <em>dispatches</em> the function calls to the right function for us, based on the type of the arguments we pass. If we call <code>play()</code> with an object whose classes do not have a method defined, an error will be thrown.</p>&#13;
<p class="indent">In <a href="ch13.xhtml#ch13list3">Listing 13-3</a>, the <code>play()</code> method is called with a <code>cymbal</code> and a <code>stick</code> instance; however, the <code>play()</code> method has never been defined for those arguments, so it raises an error.</p>&#13;
<pre>* (play (make-instance 'cymbal) (make-instance 'stick))<br/>debugger invoked on a SIMPLE-ERROR in thread<br/>#&lt;THREAD "main thread" RUNNING {1002ADAF23}&gt;:<br/>  There is no applicable method for the generic function<br/>    #&lt;STANDARD-GENERIC-FUNCTION PLAY (2)&gt;<br/>  when called with arguments<br/>    (#&lt;CYMBAL {1002B801D3}&gt; #&lt;STICK {1002B82763}&gt;).<br/><br/>Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL.<br/><br/>restarts (invokable by number or by possibly abbreviated name):<br/>  0: [RETRY] Retry calling the generic function.<br/>  1: [ABORT] Exit debugger, returning to top level.<br/><br/>((:METHOD NO-APPLICABLE-METHOD (T)) #&lt;STANDARD-GENERIC-FUNCTION PLAY (2)&gt;<br/>#&lt;CYMBAL {1002B801D3}&gt; #&lt;STICK {1002B82763}&gt;) [fast-method]</pre>&#13;
<p class="listing1"><a id="ch13list3"/><em>Listing 13-3: Calling a method with an unavailable signature</em></p>&#13;
<p class="indent">CLOS provides even more features, such as method inheritance or object-based dispatching, rather than using classes. If you’re really curious about the many features CLOS provides, I suggest reading “A Brief Guide to CLOS” by Jeff Dalton (<em><a href="http://www.aiai.ed.ac.uk/~jeff/clos-guide.html">http://www.aiai.ed.ac.uk/~jeff/clos-guide.html</a></em>) as a starting point.</p>&#13;
<h4 class="h4" id="lev2sec66"><strong><em>Generic Methods with Python</em></strong></h4>&#13;
<p class="noindent">Python implements a simpler version of this workflow with the <code>singledispatch()</code> function, which has been distributed as part of the <code>functools</code> module since <span epub:type="pagebreak" id="page_206"/>Python 3.4. In versions 2.6 to 3.3, the <code>singledispatch()</code> function is provided through the Python Package Index; for those eager to try it out, just run <code>pip install singledispatch</code>.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13list4">Listing 13-4</a> shows a rough equivalent of the Lisp program we built in <a href="ch13.xhtml#ch13list2">Listing 13-2</a>.</p>&#13;
<pre>   import functools<br/><br/>   class SnareDrum(object): pass<br/>   class Cymbal(object): pass<br/>   class Stick(object): pass<br/>   class Brushes(object): pass<br/><br/>   @functools.singledispatch<br/>   def play(instrument, accessory):<br/>       raise NotImplementedError("Cannot play these")<br/><br/><span class="ent">➊</span> @play.register(SnareDrum)<br/>   def _(instrument, accessory):<br/>       if isinstance(accessory, Stick):<br/>           return "POC!"<br/>       if isinstance(accessory, Brushes):<br/>           return "SHHHH!"<br/>       raise NotImplementedError("Cannot play these")<br/><br/>   @play.register(Cymbal)<br/>   def _(instrument, accessory):<br/>       if isinstance(accessory, Brushes):<br/>           return "FRCCCHHT!"<br/>       raise NotImplementedError("Cannot play these")</pre>&#13;
<p class="listing1"><a id="ch13list4"/><em>Listing 13-4: Using <span class="codeitalic">singledispatch</span> to dispatch method calls</em></p>&#13;
<p class="indent">This listing defines our four classes and a base <code>play()</code> function that raises <code>NotImplementedError</code>, indicating that by default we don’t know what to do.</p>&#13;
<p class="indent">We then write a specialized version of the <code>play()</code> function for a specific instrument, the <code>SnareDrum</code> <span class="ent">➊</span>. This function checks which accessory type has been passed and returns the appropriate sound or raises <code>NotImplementedError</code> again if the accessory isn’t recognized.</p>&#13;
<p class="indent">If we run the program, it works as follows:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">play(SnareDrum(), Stick())</span><br/>'POC!'<br/>&gt;&gt;&gt; <span class="codestrong1">play(SnareDrum(), Brushes())</span><br/>'SHHHH!'<br/>&gt;&gt;&gt; <span class="codestrong1">play(Cymbal(), Stick())</span><br/>Traceback (most recent call last):<br/>NotImplementedError: Cannot play these<br/>&gt;&gt;&gt; <span class="codestrong1">play(SnareDrum(), Cymbal())</span><br/>NotImplementedError: Cannot play these</pre>&#13;
<p class="indent">The <code>singledispatch</code> module checks the class of the first argument passed and calls the appropriate version of the <code>play()</code> function. For the <span epub:type="pagebreak" id="page_207"/><code>object</code> class, the first defined version of the function is always the one that is run. Therefore, if our instrument is an instance of a class that we did not register, this base function will be called.</p>&#13;
<p class="indent">As we saw in the Lisp version of the code, CLOS provides a multiple dispatcher that can dispatch based on the type of <em>any of the arguments</em> defined in the method prototype, not just the first one. The Python dispatcher is named <code>singledispatch</code> for a good reason: it only knows how to dispatch based on the first argument.</p>&#13;
<p class="indent">In addition, <code>singledispatch</code> offers no way to call the parent function directly. There is no equivalent of the Python <code>super()</code> function; you’ll have to use various tricks to bypass this limitation.</p>&#13;
<p class="indent">While Python is improving its object system and dispatch mechanism, it still lacks a lot of the more advanced features that something like CLOS provides out of the box. That makes encountering <code>singledispatch</code> in the wild pretty rare. It’s still interesting to know it exists, as you may end up implementing such a mechanism yourself at some point.</p>&#13;
<h3 class="h3" id="lev1sec74"><strong>Context Managers</strong></h3>&#13;
<p class="noindent">The <code>with</code> statement introduced in Python 2.6 is likely to remind old-time Lispers of the various <code>with-*</code> macros that are often used in that language. Python provides a similar-looking mechanism with the use of objects that implement the <em>context management protocol</em>.</p>&#13;
<p class="indent">If you’ve never used the context management protocol, here’s how it works. The code block contained inside the <code>with</code> statement is surrounded by two function calls. The object being used in the <code>with</code> statement determines the two calls. Those objects are said to implement the context management protocol.</p>&#13;
<p class="indent">Objects like those returned by <code>open()</code> support this protocol; that’s why you can write code along these lines:</p>&#13;
<pre>with open("myfile", "r") as f:<br/>   line = f.readline()</pre>&#13;
<p class="indent">The object returned by <code>open()</code> has two methods: one called <code>__enter__</code> and one called <code>__exit__</code>. These methods are called at the start of the <code>with</code> block and at the end of it, respectively.</p>&#13;
<p class="indent">A simple implementation of a context object is shown in <a href="ch13.xhtml#ch13list5">Listing 13-5</a>.</p>&#13;
<pre>class MyContext(object):<br/>    def __enter__(self):<br/>        pass<br/><br/>    def __exit__(self, exc_type, exc_value, traceback):<br/>        pass</pre>&#13;
<p class="listing1"><a id="ch13list5"/><em>Listing 13-5: A simple implementation of a context object</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_208"/>This implementation does not do anything, but it is valid and shows the signature of the methods that need to be defined to provide a class following the context protocol.</p>&#13;
<p class="indent">The context management protocol might be appropriate to use when you identify the following pattern in your code, where it is expected that a call to method <code>B</code> must <em>always</em> be done after a call to <code>A</code>:</p>&#13;
<ol>&#13;
<li><p class="noindent">Call method <code>A</code>.</p></li>&#13;
<li><p class="noindent">Execute some code.</p></li>&#13;
<li><p class="noindent">Call method <code>B</code>.</p></li>&#13;
</ol>&#13;
<p class="indent">The <code>open()</code> function illustrates this pattern well: the constructor that opens the file and allocates a file descriptor internally is method <code>A</code>. The <code>close()</code> method that releases the file descriptor corresponds to method <code>B</code>. Obviously, the <code>close()</code> function is always meant to be called <em>after</em> you instantiate the file object.</p>&#13;
<p class="indent">It can be tedious to implement this protocol manually, so the <code>contextlib</code> standard library provides the <code>contextmanager</code> decorator to make implementation easier. The <code>contextmanager</code> decorator should be used on a generator function. The <code>__enter__</code> and <code>__exit__</code> methods will be dynamically implemented for you based on the code that wraps the <code>yield</code> statement of the generator.</p>&#13;
<p class="indent">In <a href="ch13.xhtml#ch13list6">Listing 13-6</a>, <code>MyContext</code> is defined as a context manager.</p>&#13;
<pre>import contextlib<br/><br/>@contextlib.contextmanager<br/>def MyContext():<br/>    print("do something first")<br/>    yield<br/>    print("do something else")<br/><br/><br/>with MyContext():<br/>    print("hello world")</pre>&#13;
<p class="listing1"><a id="ch13list6"/><em>Listing 13-6: Using <span class="codeitalic">contextlib.contextmanager</span></em></p>&#13;
<p class="indent">The code before the <code>yield</code> statement will be executed before the <code>with</code> statement body is run; the code after the <code>yield</code> statement will be executed once the body of the <code>with</code> statement is over. When run, this program outputs the following:</p>&#13;
<pre>do something first<br/>hello world<br/>do something else</pre>&#13;
<p class="indent">There are a couple of things to handle here though. First, it’s possible to yield something inside our generator that can be used as part of the <code>with</code> block.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_209"/><a href="ch13.xhtml#ch13list7">Listing 13-7</a> shows how to yield a value to the caller. The keyword <code>as</code> is used to store this value in a variable.</p>&#13;
<pre>import contextlib<br/><br/>@contextlib.contextmanager<br/>def MyContext():<br/>    print("do something first")<br/>    yield 42<br/>    print("do something else")<br/><br/><br/>with MyContext() as value:<br/>    print(value)</pre>&#13;
<p class="listing1"><a id="ch13list7"/><em>Listing 13-7: Defining a context manager yielding a value</em></p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13list7">Listing 13-7</a> shows how to yield a value to the caller. The keyword <code>as</code> is used to store this value in a variable. When executed, the code outputs the following:</p>&#13;
<pre>do something first<br/>42<br/>do something else</pre>&#13;
<p class="indent">When using a context manager, you might need to handle exceptions that can be raised within the <code>with</code> code block. This can be done by surrounding the <code>yield</code> statement with a <code>try...except</code> block, as shown in <a href="ch13.xhtml#ch13list8">Listing 13-8</a>.</p>&#13;
<pre>   import contextlib<br/><br/>   @contextlib.contextmanager<br/>   def MyContext():<br/>       print("do something first")<br/>       try:<br/>           yield 42<br/>       finally:<br/>           print("do something else")<br/><br/><br/>   with MyContext() as value:<br/>       print("about to raise")<br/><span class="ent">➊</span>     raise ValueError("let's try it")<br/>       print(value)</pre>&#13;
<p class="listing1"><a id="ch13list8"/><em>Listing 13-8: Handling exceptions in a context manager</em></p>&#13;
<p class="indent">Here, a <code>ValueError</code> is raised at the beginning of the <code>with</code> code block <span class="ent">➊</span>; Python will propagate this error back to the context manager, and the <code>yield</code> statement will appear to raise the exception itself. We enclose the <code>yield</code> statement in <code>try</code> and <code>finally</code> to make sure the final <code>print()</code> is run.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_210"/>When executed, <a href="ch13.xhtml#ch13list8">Listing 13-8</a> outputs the following:</p>&#13;
<pre>do something first<br/>about to raise<br/>do something else<br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 3, in &lt;module&gt;<br/>ValueError: let's try it</pre>&#13;
<p class="indent">As you can see, the error is raised back to the context manager, and the program resumes and finishes execution because it ignored the exception using a <code>try...finally</code> block.</p>&#13;
<p class="indent">In some contexts, it can be useful to use several context managers at the same time, for example, when opening two files at the same time to copy their content, as shown in <a href="ch13.xhtml#ch13list9">Listing 13-9</a>.</p>&#13;
<pre>with open("file1", "r") as source:<br/>    with open("file2", "w") as destination:<br/>        destination.write(source.read())</pre>&#13;
<p class="listing1"><a id="ch13list9"/><em>Listing 13-9: Opening two files at the same time to copy content</em></p>&#13;
<p class="indent">That being said, since the <code>with</code> statement supports multiple arguments, it’s actually more efficient to write a version using a single <code>with</code>, as shown in <a href="ch13.xhtml#ch13list10">Listing 13-10</a>.</p>&#13;
<pre>with open("file1", "r") as source, open("file2", "w") as destination:<br/>    destination.write(source.read())</pre>&#13;
<p class="listing1"><a id="ch13list10"/><em>Listing 13-10: Opening two files at the same time using only one <span class="codeitalic">with</span> statement</em></p>&#13;
<p class="indent">Context managers are extremely powerful design patterns that help to ensure your code flow is always correct, no matter what exception might occur. They can help to provide a consistent and clean programming interface in many situations in which code should be wrapped by other code and <code>contextlib.contextmanager</code>.</p>&#13;
<h3 class="h3" id="lev1sec75"><strong>Less Boilerplate with attr</strong></h3>&#13;
<p class="noindent">Writing Python classes can be cumbersome. You’ll often find yourself repeating just a few patterns because there are no other options. One of the most common examples, as illustrated in <a href="ch13.xhtml#ch13list11">Listing 13-11</a>, is when initializing an object with a few attributes passed to the constructor.</p>&#13;
<pre>class Car(object):<br/>    def __init__(self, color, speed=0):<br/>        self.color = color<br/>        self.speed = speed</pre>&#13;
<p class="listing1"><a id="ch13list11"/><em>Listing 13-11: Common class initialization boilerplate</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_211"/>The process is always the same: you copy the value of the argument passed to the <code>__init__</code> function to a few attributes stored in the object. Sometimes you’ll also have to check the value that is passed, compute a default, and so on.</p>&#13;
<p class="indent">Obviously, you also want your object to be represented correctly if printed, so you’ll have to implement a <code>__repr__</code> method. There’s a chance some of your classes are simple enough to be converted to dictionaries for serialization. Things become even more complicated when talking about comparison and hashability (the ability to use <code>hash</code> on an object and store it in a <code>set</code>).</p>&#13;
<p class="indent">In reality, most Python programmers do none of this, because the burden of writing all those checks and methods is too heavy, especially when you’re not always sure you’ll need them. For example, you might find that <code>__repr__</code> is useful in your program only that one time you’re trying to debug or trace it and decide to print objects in the standard output—and no other times.</p>&#13;
<p class="indent">The <code>attr</code> library aims for a straightforward solution by providing a generic boilerplate for all your classes and generating much of the code for you. You can install <code>attr</code> using <code>pip</code> with the command <code>pip install attr</code>. Get ready to enjoy!</p>&#13;
<p class="indent">Once installed, the <code>attr.s</code> decorator is your entry point into the wonderful world of <code>attr</code>. Use it above a class declaration and then use the function <code>attr.ib()</code> to declare attributes in your classes. <a href="ch13.xhtml#ch13list12">Listing 13-12</a> shows a way to rewrite <a href="ch13.xhtml#ch13list11">Listing 13-11</a> using <code>attr</code>.</p>&#13;
<pre>import attr<br/><br/>@attr.s<br/>class Car(object):<br/>    color = attr.ib()<br/>    speed = attr.ib(default=0)</pre>&#13;
<p class="listing1"><a id="ch13list12"/><em>Listing 13-12: Using <span class="codeitalic">attr.ib()</span> to declare attributes</em></p>&#13;
<p class="indent">When declared this way, the class automatically gains a few useful methods for free, such as <code>__repr__</code>, which is called to represent objects when they are printed on <code>stdout</code> in the Python interpreter:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">Car("blue")</span><br/>Car(color='blue', speed=0)</pre>&#13;
<p class="indent">This output is cleaner than the default that <code>__repr__</code> would have printed:</p>&#13;
<pre>&lt;__main__.Car object at 0x104ba4cf8&gt;.</pre>&#13;
<p class="indent">You can also add more validation on your attributes by using the <code>validator</code> and <code>converter</code> keyword arguments.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_212"/><a href="ch13.xhtml#ch13list13">Listing 13-13</a> shows how the <code>attr.ib()</code> function can be used to declare an attribute with some constraints.</p>&#13;
<pre>import attr<br/><br/>@attr.s<br/>class Car(object):<br/>    color = attr.ib(converter=str)<br/>    speed = attr.ib(default=0)<br/><br/>    @speed.validator<br/>    def speed_validator(self, attribute, value):<br/>        if value &lt; 0:<br/>            raise ValueError("Value cannot be negative")</pre>&#13;
<p class="listing1"><a id="ch13list13"/><em>Listing 13-13: Using <span class="codeitalic">attr.ib()</span> with its <span class="codeitalic">converter</span> argument</em></p>&#13;
<p class="indent">The <code>converter</code> argument manages the conversion of whatever is passed to the constructor. The <code>validator()</code> function can be passed as an argument to <code>attr.ib()</code> or used as a decorator, as shown in <a href="ch13.xhtml#ch13list13">Listing 13-13</a>.</p>&#13;
<p class="indent">The <code>attr</code> module provides a few validators of its own (for example, <code>attr.validators.instance_of()</code> to check the type of the attribute), so be sure to check them out before wasting your time building your own.</p>&#13;
<p class="indent">The <code>attr</code> module also provides tweaks to make your object hashable so it can be used in a set or a dictionary key: just pass <code>frozen=True</code> to <code>attr.s()</code> to make the class instances immutable.</p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13list14">Listing 13-14</a> shows how using the <code>frozen</code> parameter changes the behavior of the class.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">import attr</span><br/>&gt;&gt;&gt; <span class="codestrong1">@attr.s(frozen=True)</span><br/>... class Car(object):<br/>...     color = attr.ib()<br/>...<br/>&gt;&gt;&gt; <span class="codestrong1">{Car("blue"), Car("blue"), Car("red")}</span><br/>{Car(color='red'), Car(color='blue')}<br/>&gt;&gt;&gt; <span class="codestrong1">Car("blue").color = "red"</span><br/>attr.exceptions.FrozenInstanceError</pre>&#13;
<p class="listing1"><a id="ch13list14"/><em>Listing 13-14: Using <span class="codeitalic">frozen=True</span></em></p>&#13;
<p class="indent"><a href="ch13.xhtml#ch13list14">Listing 13-14</a> shows how using the <code>frozen</code> parameter changes the behavior of the <code>Car</code> class: it can be hashed and therefore stored in a set, but objects cannot be modified anymore.</p>&#13;
<p class="indent">In summary, <code>attr</code> provides the implementation for a ton of useful methods, thereby saving you from writing them yourself. I highly recommend leveraging <code>attr</code> for its efficiency when building your classes and modeling your software.</p>&#13;
<h3 class="h3" id="lev1sec76"><span epub:type="pagebreak" id="page_213"/><strong>Summary</strong></h3>&#13;
<p class="noindent">Congratulations! You made it to the end of the book. You’ve just upped your Python game and have a better idea of how to write efficient and productive Python code. I hope you enjoyed reading this book as much as I enjoyed writing it.</p>&#13;
<p class="indent">Python is a wonderful language and can be used in many different fields, and there are many more areas of Python that we did not touch on in this book. But every book needs an ending, right?</p>&#13;
<p class="indent">I highly recommend profiting from open source projects by reading the available source code out there and contributing to it. Having your code reviewed and discussed by other developers is often a great way to learn.</p>&#13;
<p class="indent">Happy hacking!</p>&#13;
</body></html>