["```py\ncabinet = [1,2,3,3,4,6,8,12]\n```", "```py\nto_insert = 5\n```", "```py\ncheck_location = len(cabinet) - 1\n```", "```py\ninsert_location = 0\n```", "```py\nif to_insert > cabinet[check_location]:\n    insert_location = check_location + 1\n```", "```py\ncabinet.insert(insert_location,to_insert)\n```", "```py\ndef insert_cabinet(cabinet,to_insert):\n  check_location = len(cabinet) - 1\n  insert_location = 0\n  while(check_location >= 0):\n    if to_insert > cabinet[check_location]:\n        insert_location = check_location + 1\n        check_location = - 1\n    check_location = check_location - 1\n  cabinet.insert(insert_location,to_insert)\n  return(cabinet)\n\ncabinet = [1,2,3,3,4,6,8,12]\nnewcabinet = insert_cabinet(cabinet,5)\nprint(newcabinet)\n```", "```py\ncabinet = [8,4,6,1,2,5,3,7]\nnewcabinet = []\n```", "```py\nto_insert = cabinet.pop(0)\nnewcabinet = insert_cabinet(newcabinet, to_insert)\n```", "```py\ncabinet = [8,4,6,1,2,5,3,7]\ndef insertion_sort(cabinet):\n  newcabinet = []\n  while len(cabinet) > 0:\n    to_insert = cabinet.pop(0)\n    newcabinet = insert_cabinet(newcabinet, to_insert)\n  return(newcabinet)\n\nsortedcabinet = insertion_sort(cabinet)\nprint(sortedcabinet)\n```", "```py\nfrom timeit import default_timer as timer\n\nstart = timer()\ncabinet = [8,4,6,1,2,5,3,7]\nsortedcabinet = insertion_sort(cabinet)\nend = timer()\nprint(end - start)\n```", "```py\ndef insert_cabinet(cabinet,to_insert):\n  check_location = len(cabinet) - 1\n  insert_location = 0\n  global stepcounter\n  while(check_location >= 0):\n    stepcounter += 1\n    if to_insert > cabinet[check_location]:\n        insert_location = check_location + 1\n        check_location = - 1\n    check_location = check_location - 1\n  stepcounter += 1\n  cabinet.insert(insert_location,to_insert)\n  return(cabinet)\n\ndef insertion_sort(cabinet):\n  newcabinet = []\n  global stepcounter\n  while len(cabinet) > 0:\n    stepcounter += 1\n    to_insert = cabinet.pop(0)\n    newcabinet = insert_cabinet(newcabinet,to_insert)\n  return(newcabinet)\n\ncabinet = [8,4,6,1,2,5,3,7]\nstepcounter = 0\nsortedcabinet = insertion_sort(cabinet)\nprint(stepcounter)\n```", "```py\nimport random\nsize_of_cabinet = 10\ncabinet = [int(1000 * random.random()) for i in range(size_of_cabinet)]\n```", "```py\ndef check_steps(size_of_cabinet):\n  cabinet = [int(1000 * random.random()) for i in range(size_of_cabinet)]\n  global stepcounter\n  stepcounter = 0\n  sortedcabinet = insertion_sort(cabinet)\n  return(stepcounter)\n```", "```py\nrandom.seed(5040)\nxs = list(range(1,100))\nys = [check_steps(x) for x in xs]\nprint(ys)\n```", "```py\nimport matplotlib.pyplot as plt\nplt.plot(xs,ys)\nplt.title('Steps Required for Insertion Sort for Random Cabinets')\nplt.xlabel('Number of Files in Random Cabinet')\nplt.ylabel('Steps Required to Sort Cabinet by Insertion Sort')\nplt.show()\n```", "```py\nimport math\nimport numpy as np\nrandom.seed(5040)\nxs = list(range(1,100))\nys = [check_steps(x) for x in xs]\nys_exp = [math.exp(x) for x in xs]\nplt.plot(xs,ys)\naxes = plt.gca()\naxes.set_ylim([np.min(ys),np.max(ys) + 140])\nplt.plot(xs,ys_exp)\nplt.title('Comparing Insertion Sort to the Exponential Function')\nplt.xlabel('Number of Files in Random Cabinet')\nplt.ylabel('Steps Required to Sort Cabinet')\nplt.show()\n```", "```py\nrandom.seed(5040)\nxs = list(range(1,100))\nys = [check_steps(x) for x in xs]\nxs_exp = [math.exp(x) for x in xs]\nxs_squared = [x**2 for x in xs]\nxs_threehalves = [x**1.5 for x in xs]\nxs_cubed = [x**3 for x in xs]\nplt.plot(xs,ys)\naxes = plt.gca()\naxes.set_ylim([np.min(ys),np.max(ys) + 140])\nplt.plot(xs,xs_exp)\nplt.plot(xs,xs)\nplt.plot(xs,xs_squared)\nplt.plot(xs,xs_cubed)\nplt.plot(xs,xs_threehalves)\nplt.title('Comparing Insertion Sort to Other Growth Rates')\nplt.xlabel('Number of Files in Random Cabinet')\nplt.ylabel('Steps Required to Sort Cabinet')\nplt.show()\n```", "```py\nnewcabinet = []\n```", "```py\nleft = [1,3,4,4,5,7,8,9]\nright = [2,4,6,7,8,8,10,12,13,14]\n```", "```py\n if left[0] > right[0]:\n    `--snip--`\n   elif left[0] <= right[0]:\n    *--snip--*\n```", "```py\nif left[0] > right[0]:\n    to_insert = right.pop(0)\n    newcabinet.append(to_insert)\nelif left[0] <= right[0]:\n    to_insert = left.pop(0)\n    newcabinet.append(to_insert)\n```", "```py\nwhile(min(len(left),len(right)) > 0):\n    if left[0] > right[0]:\n        to_insert = right.pop(0)\n        newcabinet.append(to_insert)\n    elif left[0] <= right[0]:\n        to_insert = left.pop(0)\n        newcabinet.append(to_insert)\n```", "```py\nif(len(left) > 0):\n    for i in left:\n        newcabinet.append(i)\n\nif(len(right) > 0):\n    for i in right:\n        newcabinet.append(i)\n```", "```py\ndef merging(left,right):\n    newcabinet = []\n    while(min(len(left),len(right)) > 0):\n        if left[0] > right[0]:\n            to_insert = right.pop(0)\n            newcabinet.append(to_insert)\n        elif left[0] <= right[0]:\n            to_insert = left.pop(0)\n            newcabinet.append(to_insert)\n    if(len(left) > 0):\n        for i in left:\n            newcabinet.append(i)\n    if(len(right)>0):\n        for i in right:\n            newcabinet.append(i)\n    return(newcabinet)\n\nleft = [1,3,4,4,5,7,8,9]\nright = [2,4,6,7,8,8,10,12,13,14]\n\nnewcab=merging(left,right)\n```", "```py\nimport math\n\ndef mergesort_two_elements(cabinet):\n    newcabinet = []\n    if(len(cabinet) == 1):\n        newcabinet = cabinet\n    else:\n        left = cabinet[:math.floor(len(cabinet)/2)]\n        right = cabinet[math.floor(len(cabinet)/2):]\n        newcabinet = merging(left,right)\n    return(newcabinet)\n```", "```py\ndef mergesort_four_elements(cabinet):\n    newcabinet = []\n    if(len(cabinet) == 1):\n        newcabinet = cabinet\n else:\n        left = mergesort_two_elements(cabinet[:math.floor(len(cabinet)/2)])\n        right = mergesort_two_elements(cabinet[math.floor(len(cabinet)/2):])\n        newcabinet = merging(left,right)\n    return(newcabinet)\n\ncabinet = [2,6,4,1]\nnewcabinet = mergesort_four_elements(cabinet)\n```", "```py\ndef mergesort(cabinet):\n    newcabinet = []\n    if(len(cabinet) == 1):\n        newcabinet = cabinet\n    else:\n   1 left = mergesort(cabinet[:math.floor(len(cabinet)/2)])\n   2 right = mergesort(cabinet[math.floor(len(cabinet)/2):])\n        newcabinet = merging(left,right)\n    return(newcabinet)\n```", "```py\ncabinet = [4,1,3,2,6,3,18,2,9,7,3,1,2.5,-9]\nnewcabinet = mergesort(cabinet)\nprint(newcabinet)\n```", "```py\ndef merging(left,right):\n    newcabinet = []\n    while(min(len(left),len(right)) > 0):\n        if left[0] > right[0]:\n            to_insert = right.pop(0)\n            newcabinet.append(to_insert)\n        elif left[0] <= right[0]:\n            to_insert = left.pop(0)\n            newcabinet.append(to_insert)\n    if(len(left) > 0):\n        for i in left:\n            newcabinet.append(i)\n if(len(right) > 0):\n        for i in right:\n            newcabinet.append(i)\n    return(newcabinet)\n\nimport math\n\ndef mergesort(cabinet):\n    newcabinet = []\n    if(len(cabinet) == 1):\n        newcabinet=cabinet\n    else:\n        left = mergesort(cabinet[:math.floor(len(cabinet)/2)])\n        right = mergesort(cabinet[math.floor(len(cabinet)/2):])\n        newcabinet = merging(left,right)\n    return(newcabinet)\n\ncabinet = [4,1,3,2,6,3,18,2,9,7,3,1,2.5,-9]\nnewcabinet=mergesort(cabinet)\n```", "```py\nprint(sorted(cabinet))\n```", "```py\nimport threading\nfrom time import sleep\n\ndef sleep_sort(i):\n    sleep(i)\n    global sortedlist\n    sortedlist.append(i)\n    return(i)\n\nitems = [2, 4, 5, 2, 1, 7]\nsortedlist = []\nignore_result = [threading.Thread(target = sleep_sort, args = (i,)).start() \\for i in items]\n```", "```py\nsorted_cabinet = [1,2,3,4,5]\nupperbound = len(sorted_cabinet)\nlowerbound = 0\n```", "```py\nimport math\nguess = math.floor(len(sorted_cabinet)/2)\n```", "```py\nif(sorted_cabinet[guess] > looking_for):\n    `--snip--`\nif(sorted_cabinet[guess] < looking_for):\n    `--snip--`\n```", "```py\nlooking_for = 3\nif(sorted_cabinet[guess] > looking_for):\n    upperbound = guess\n    guess = math.floor((guess + lowerbound)/2)\n```", "```py\nif(sorted_cabinet[guess] < looking_for):\n    lowerbound = guess\n    guess = math.floor((guess + upperbound)/2)\n```", "```py\nimport math\nsortedcabinet = [1,2,3,4,5,6,7,8,9,10]\n\ndef binarysearch(sorted_cabinet,looking_for):\n    guess = math.floor(len(sorted_cabinet)/2)\n    upperbound = len(sorted_cabinet)\n    lowerbound = 0\n    while(abs(sorted_cabinet[guess] - looking_for) > 0.0001):\n        if(sorted_cabinet[guess] > looking_for):\n            upperbound = guess\n            guess = math.floor((guess + lowerbound)/2)\n        if(sorted_cabinet[guess] < looking_for):\n            lowerbound = guess\n            guess = math.floor((guess + upperbound)/2)\n    return(guess)\n\nprint(binarysearch(sortedcabinet,8))\n```", "```py\ndef inverse_sin(number):\n    domain = [x * math.pi/10000 - math.pi/2 for x in list(range(0,10000))]\n    the_range = [math.sin(x) for x in domain]\n    result = domain[binarysearch(the_range,number)]\n    return(result)\n```"]