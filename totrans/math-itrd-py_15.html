<html><head></head><body>
<h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_247"/><span class="big">12</span><br/>SOLVING PROBLEMS USING GENETIC ALGORITHMS</h2>&#13;
<p class="epigraph"><em>Steve: We’re lost.<br/>Mike: How lost are we?</em></p>&#13;
<div class="image"><img alt="image" src="../images/fintro-01.jpg"/></div>&#13;
<p class="intro">When many people think of math, they think of equations and operations that are “set in stone” and answers that are either right or wrong. They might be surprised to learn how much guessing and checking we’ve done in our algebra explorations already.</p>&#13;
<p class="indent">In this chapter, you learn to crack passwords and hidden messages in an indirect fashion. It’s kind of like the “guess-and-check” method of <a href="ch04.xhtml#ch04">Chapter 4</a>, where we just plugged a bunch of integers into an equation and if any made the equation true, we printed them out. This time, we’ll guess a bunch of values, not just one. It’s not the most elegant way of solving a problem, but with a computer at our disposal, sometimes brute force works best.</p>&#13;
<p class="indent">To figure out our secret phrase, we generate guesses and then rate them on how well they match the target. But here’s where we depart from a guess-and-check method: we keep the best guesses and mutate them, randomly, again and again until we uncover the message. The program <span epub:type="pagebreak" id="page_248"/>won’t know which letters are right and which letters are wrong, but we get closer and closer by mutating the best guess we’ve made so far. Although this method might not seem promising right now, you’ll see that it helps crack the code surprisingly quickly. This method is called a <em>genetic algorithm</em>, which computer scientists use to find solutions to problems based on the theory of natural selection and evolutionary biology. It was inspired by biological organisms that adapt and mutate, and the way they build on tiny advantages, as we saw in the Sheep model in <a href="ch09.xhtml#ch09">Chapter 9</a>, on Classes.</p>&#13;
<p class="indent">For more complicated problems, however, random mutating won’t be enough to solve our problem. In those cases, we add <em>crossover</em>, which we use to combine the most fit organisms (or best guesses) to improve their likelihood of cracking the code, just like how the fittest organisms are more likely to pass down a combination of their genetic material. All this activity, other than the scoring, will be fairly random, so it might be surprising that our genetic algorithms work so well.</p>&#13;
<h3 class="h3" id="ch12_1">USING A GENETIC ALGORITHM TO GUESS PHRASES</h3>&#13;
<p class="noindent">Open IDLE and create a new file called <em>geneticQuote.py</em>. Instead of guessing a number like in <a href="ch04.xhtml#ch04">Chapter 4</a>, this program tries to guess a secret phrase. All we have to tell the program is the number of characters it guessed correctly—not where or which characters, just how many.</p>&#13;
<p class="indent">Our program is going to be able to do much better than guess short passwords.</p>&#13;
<h4 class="h4" id="ch12_1_1">WRITING THE MAKELIST() FUNCTION</h4>&#13;
<p class="noindent">To see how this works, let’s create a target phrase. Here’s a long sentence that my son came up with from the comic book <em>Naruto</em>:</p>&#13;
<pre>target = <span class="pd_green">"I never go back on my word, because that is my Ninja way."</span></pre>&#13;
<p class="indent">In English, we have a bunch of characters we can choose from: lowercase letters, uppercase letters, a space, and some punctuation.</p>&#13;
<pre>characters = <span class="pd_green">" abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.',?!"</span></pre>&#13;
<p class="indent">Let’s create a function called <code>makeList()</code> that will randomly create a list of characters that’s the same length as <code>target</code>. Later, when we try to guess what the target phrase is, we’ll score the guess by comparing it character by character with the target. A higher score means a guess is closer to the target. Then, we’ll randomly change one of the characters in that guess to see if that increases its score. It seems surprising that such a random method will ever get us to the exact target phrase, but it will.</p>&#13;
<p class="indent">First, import the <code>random</code> module and write the <code>makeList()</code> function, as shown in <a href="ch12.xhtml#ch12list1">Listing 12-1</a>.</p>&#13;
<pre><span class="pd_g1"><em>genetic<br/>Quote.py</em></span><br/><span class="pd_orange">import</span> random<br/><br/>target = <span class="pd_green">"I never go back on my word, because that is my Ninja way."</span><br/>characters = <span class="pd_green">" abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.',?!"</span><br/><br/><span class="pd_orange">def</span> <span class="pd_blue">makeList</span>():<br/><span class="pd_green">    '''Returns a list of characters the same length</span><br/><span class="pd_green">    as the target'''</span><br/>    charList = [] <span class="pd_red">#empty list to fill with random characters</span><br/>    <span class="pd_orange">for</span> i <span class="pd_orange">in</span> <span class="pd_purple">range</span>(<span class="pd_purple">len</span>(target)):<br/>        charList.append(random.choice(characters))<br/>    <span class="pd_orange">return</span> charList</pre>&#13;
<p class="listing" id="ch12list1"><em>Listing 12-1: Writing the <code>makeList()</code> function to create a list of random characters that’s the same length as the target</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_249"/>Here, we create an empty list called <code>charList</code> and loop over the list the same number of times as there are characters in the target. On each loop,the program puts a random character from <code>characters</code> into <code>charList</code>. Once the loop is done, it returns <code>charList</code>. Let’s test it to make sure it works.</p>&#13;
<h4 class="h4" id="ch12_1_2">TESTING THE MAKELIST() FUNCTION</h4>&#13;
<p class="noindent">First, let’s find out what the length of the target is, and check that our random list is the same length:</p>&#13;
<pre>&gt;&gt;&gt; <span class="pd_purple">len</span>(target)<br/><span class="pd_blue2">57</span><br/>&gt;&gt;&gt; newList = makeList()<br/>&gt;&gt;&gt; newList<br/><span class="pd_blue">['p', 'H', 'Z', '!', 'R', 'i', 'e', 'j', 'c', 'F', 'a', 'u', 'F', 'y', '.',</span><br/><span class="pd_blue">'w', 'u', '.', 'H', 'W', 'w', 'P', 'Z', 'D', 'D', 'E', 'H', 'N', 'f', ' ',</span><br/><span class="pd_blue">'W', 'S', 'A', 'B', ',', 'w', '?', 'K', 'b', 'N', 'f', 'k', 'g', 'Q', 'T',</span><br/><span class="pd_blue">'n', 'Q', 'H', 'o', 'r', 'G', 'h', 'w', 'l', 'l', 'W', 'd']</span><br/>&gt;&gt;&gt; <span class="pd_purple">len</span>(newList)<br/><span class="pd_blue">57</span></pre>&#13;
<p class="indent">We measured the length of the <code>target</code> list, and it’s 57 characters long. Our new list is the same length, 57 characters. Why make a list instead of a string? We make a list because lists are sometimes easier to work with than strings. For example, you can’t simply replace a character in a string with another character. But in a list you can, as you can see here:</p>&#13;
<pre>&gt;&gt;&gt; a = <span class="pd_green">"Hello"</span><br/>&gt;&gt;&gt; a[0] = <span class="pd_green">"J"</span><br/><span class="pd_red">Traceback (most recent call last):</span><br/><span class="pd_red">  File "&lt;pyshell#16&gt;", line 1, in &lt;module&gt;</span><br/><span class="pd_red">    a[0] = "J"</span><br/><span class="pd_red">TypeError: 'str' object does not support item assignment</span><br/>&gt;&gt;&gt; b = [<span class="pd_green">"H"</span>,<span class="pd_green">"e"</span>,<span class="pd_green">"l"</span>,<span class="pd_green">"l"</span>,<span class="pd_green">"o"</span>]<br/>&gt;&gt;&gt; b[0] = <span class="pd_green">"J"</span><br/>&gt;&gt;&gt; b<br/><span class="pd_blue">['J', 'e', 'l', 'l', 'o']</span></pre>&#13;
<span epub:type="pagebreak" id="page_250"/>&#13;
<p class="indent">In this example, when we try to replace the first item in the <code>"Hello"</code> string with <code>"J"</code>, Python doesn’t let us, and we get an error. Doing the same thing using a list, however, is no problem.</p>&#13;
<p class="indent">In the case of our <em>geneticQuote.py</em> program, we want to see the random quote as a string because that’s easier to read. Here’s how to print out a list as a string, using Python’s <code>join()</code> function:</p>&#13;
<pre>&gt;&gt;&gt; <span class="pd_purple">print</span>(<span class="pd_green">''</span>.join(newList))<br/><span class="pd_blue">pHZ!RiejcFauFy.wu.HWwPZDDEHNf WSAB,w?KbNfkgQTnQHorGhwllWd</span></pre>&#13;
<p class="indent">Those are all the characters in <code>newList</code>, but in string form. It doesn’t look like a very promising start!</p>&#13;
<h4 class="h4" id="ch12_1_3">WRITING THE SCORE() FUNCTION</h4>&#13;
<p class="noindent">Now let’s write a function called <code>score()</code> to score each guess by comparing it character by character with the target, like in <a href="ch12.xhtml#ch12list2">Listing 12-2</a>.</p>&#13;
<pre><span class="pd_g1"><em>genetic<br/>Quote.py</em></span><br/><span class="pd_orange">def</span> <span class="pd_blue">score</span>(mylist):<br/><span class="pd_green">    '''Returns one integer: the number of matches with target'''</span><br/>    matches = 0<br/>    <span class="pd_orange">for</span> i <span class="pd_orange">in</span> <span class="pd_purple">range</span>(<span class="pd_purple">len</span>(target)):<br/>        <span class="pd_orange">if</span> mylist[i] == target[i]:<br/>            matches += 1<br/>    <span class="pd_orange">return</span> matches</pre>&#13;
<p class="listing" id="ch12list2"><em>Listing 12-2: Writing the <code>score()</code> function for scoring a guess</em></p>&#13;
<p class="indent">The <code>score()</code> function takes each item in a list we feed it (<code>mylist</code>) and checks if the first character of <code>mylist</code> matches the first character of the <code>target</code> list. Then the function checks whether the second characters match, and so on. For each character matched, we increment <code>matches</code> by 1. In the end, this function returns a single number, not which ones are right, so we don’t actually know <em>which</em> characters we got right!</p>&#13;
<p class="indent">What’s our score?</p>&#13;
<pre>&gt;&gt;&gt; newList = makeList()<br/>&gt;&gt;&gt; score(newList)<br/><span class="pd_blue">0</span></pre>&#13;
<p class="indent">Our first guess was a total strikeout. Not a single match!</p>&#13;
<h4 class="h4" id="ch12_1_4">WRITING THE MUTATE() FUNCTION</h4>&#13;
<p class="noindent">Now we’ll write a function to mutate a list by randomly changing one character. This will allow our program to “make guesses” until we get closer to the target phrase we’re trying to guess. The code is in <a href="ch12.xhtml#ch12list3">Listing 12-3</a>.</p>&#13;
<pre><span class="pd_g1"><em>genetic<br/>Quote.py</em></span><br/><span class="pd_orange">def</span> <span class="pd_blue">mutate</span>(mylist):<br/>    <span class="pd_green">'''Returns mylist with one letter changed'''</span><br/>    newlist = <span class="pd_purple">list</span>(mylist)<br/><span epub:type="pagebreak" id="page_251"/>&#13;
    new_letter = random.choice(characters)<br/>    index = random.randint(0,<span class="pd_purple">len</span>(target)-1)<br/>    newlist[index] = new_letter<br/>    <span class="pd_orange">return</span> newlist</pre>&#13;
<p class="listing" id="ch12list3"><em>Listing 12-3: Writing the <code>mutate()</code> function for changing one character in a list</em></p>&#13;
<p class="indent">First, we copy the elements of the list to a variable called <code>newlist</code>. We then randomly choose a character from the <code>characters</code> list to be the new letter that will replace one of the existing characters. We randomly choose a number between 0 and the length of the target to be the index of the letter we replace. Then we set the character in <code>newlist</code> at that index to be the new letter. This process repeats over and over again in a loop. If the new list has a higher score, it’ll become the “best” list, and the best list will keep getting mutated in the hope of improving its score even more.</p>&#13;
<h4 class="h4" id="ch12_1_5">GENERATING A RANDOM NUMBER</h4>&#13;
<p class="noindent">Starting off the program after all the function definitions, we make sure of our randomness by calling <code>random.seed()</code>. Calling <code>random.seed()</code> resets the random number generator to the present time. Then we make a list of characters and, since the first list is the best one so far, declare it the best list. Its score will be the best score.</p>&#13;
<pre><span class="pd_g1"><em>genetic<br/>Quote.py</em></span><br/>random.seed()<br/>bestList = makeList()<br/>bestScore = score(bestList)</pre>&#13;
<p class="indent">We keep track of how many guesses we’ve made:</p>&#13;
<pre>guesses = 0</pre>&#13;
<p class="indent">Now we start an infinite loop that will mutate <code>bestList</code> to make a new guess. We calculate its score and increment the <code>guesses</code> variable:</p>&#13;
<pre><span class="pd_orange">while True</span>:<br/>    guess = mutate(bestList)<br/>    guessScore = score(guess)<br/>    guesses += 1</pre>&#13;
<p class="indent">If the score of the new guess is less than or equal to the best score so far, the program can “continue,” as shown next. That means it will go back to the beginning of the loop, since it wasn’t a good guess, and we don’t need to do anything else with it.</p>&#13;
<pre>    <span class="pd_orange">if</span> guessScore &lt;= bestScore:<br/>        <span class="pd_orange">continue</span></pre>&#13;
<p class="indent">If we’re still in the loop, that means the guess is good enough to print out. We print its score, too. We can print the list (as a string), the score, and <span epub:type="pagebreak" id="page_252"/>how many total guesses were made. If the score of the new guess is the same as the length of the target, then we’ve solved the quote and we can break out of the loop:</p>&#13;
<pre>    <span class="pd_purple">print</span>(<span class="pd_green">''</span>.join(guess),guessScore,guesses)<br/>    <span class="pd_orange">if</span> guessScore == <span class="pd_purple">len</span>(target):<br/>        <span class="pd_orange">break</span></pre>&#13;
<p class="indent">Otherwise, the new guess must be better than the best list so far, but not perfect yet, so we can declare it the best list and save its score as the best score:</p>&#13;
<pre>    bestList = <span class="pd_purple">list</span>(guess)<br/>    bestScore = guessScore</pre>&#13;
<p class="indent">Listing 12-4 shows the entire code for the <em>geneticQuote.py</em> program.</p>&#13;
<pre><span class="pd_g1"><em>genetic Quote.py</em></span><br/><span class="pd_orange">import</span> random<br/><br/>target = <span class="pd_green">"I never go back on my word, because that is my Ninja way."</span><br/>characters = <span class="pd_green">" abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.',?!"</span><br/><br/><span class="pd_red">#function to create a "guess" list of characters the same length as target</span><br/><span class="pd_orange">def</span> <span class="pd_blue">makeList</span>():<br/>    <span class="pd_green">'''Returns a list of characters the same length</span><br/><span class="pd_green">    as the target'''</span><br/>    charList = [] <span class="pd_red">#empty list to fill with random characters</span><br/>    <span class="pd_orange">for</span> i <span class="pd_orange">in</span> <span class="pd_purple">range</span>(<span class="pd_purple">len</span>(target)):<br/>        charList.append(random.choice(characters))<br/>    <span class="pd_orange">return</span> charList<br/><br/><span class="pd_red">#function to "score" the guess list by comparing it to target</span><br/><span class="pd_orange">def</span> <span class="pd_blue">score</span>(mylist):<br/>    <span class="pd_green">'''Returns one integer: the number of matches with target'''</span><br/>    matches = 0<br/>    <span class="pd_orange">for</span> i <span class="pd_orange">in</span> <span class="pd_purple">range</span>(<span class="pd_purple">len</span>(target)):<br/>        <span class="pd_orange">if</span> mylist[i] == target[i]:<br/>            matches += 1<br/>    <span class="pd_orange">return</span> matches<br/><br/><span class="pd_red">#function to "mutate" a list by randomly changing one letter</span><br/><span class="pd_orange">def</span> <span class="pd_blue">mutate</span>(mylist):<br/>    <span class="pd_green">'''Returns mylist with one letter changed'''</span><br/>    newlist = <span class="pd_purple">list</span>(mylist)<br/>    new_letter = random.choice(characters)<br/>    index = random.randint(0,<span class="pd_purple">len</span>(target)-1)<br/>    newlist[index] = new_letter<br/>    <span class="pd_orange">return</span> newlist<br/><br/><span class="pd_red">#create a list, set the list to be the bestList</span><br/><span class="pd_red">#set the score of bestList to be the bestScore</span><br/><span epub:type="pagebreak" id="page_253"/>&#13;
random.seed()<br/>bestList = makeList()<br/>bestScore = score(bestList)<br/><br/>guesses = 0<br/><br/><span class="pd_red">#make an infinite loop that will create a mutation</span><br/><span class="pd_red">#of the bestList, score it</span><br/><span class="pd_orange">while True</span>:<br/>    guess = mutate(bestList)<br/>    guessScore = score(guess)<br/>    guesses += 1<br/><br/><span class="pd_red">#if the score of the newList is lower than the bestList,</span><br/><span class="pd_red">#"continue" on to the next iteration of the loop</span><br/>    <span class="pd_orange">if</span> guessScore &lt;= bestScore:<br/>        <span class="pd_orange">continue</span><br/><br/><span class="pd_red">#if the score of the newlist is the optimal score,</span><br/><span class="pd_red">#print the list and break out of the loop</span><br/>    <span class="pd_purple">print</span>(<span class="pd_green">''</span>.join(guess),guessScore,guesses)<br/>    <span class="pd_orange">if</span> guessScore == <span class="pd_purple">len</span>(target):<br/>        <span class="pd_orange">break</span><br/><br/><span class="pd_red">#otherwise, set the bestList to the value of the newList</span><br/><span class="pd_red">#and the bestScore to be the value of the score of the newList</span><br/>    bestList = <span class="pd_purple">list</span>(guess)<br/>    bestScore = guessScore</pre>&#13;
<p class="listing" id="ch12list4"><em>Listing 12-4: The complete code for the</em> geneticQuote.py <em>program</em></p>&#13;
<p class="indent">Now when we run this, we get a very fast solution, with all the guesses that improved the score printed out.</p>&#13;
<pre><span class="pd_blue">i.fpzgPG.'kHT!NW WXxM?rCcdsRCiRGe.LWVZzhJe zSzuWKV.FfaCAV 1 178</span><br/><span class="pd_blue">i.fpzgPG.'kHT!N  WXxM?rCcdsRCiRGe.LWVZzhJe zSzuWKV.FfaCAV 2 237</span><br/><span class="pd_blue">i.fpzgPG.'kHT!N  WXxM?rCcdsRCiRGe.LWVZzhJe zSzuWKV.FfwCAV 3 266</span><br/><span class="pd_blue">i fpzgPG.'kHT!N  WXxM?rCcdsRCiRGe.LWVZzhJe zSzuWKV.FfwCAV 4 324</span><br/>--<span class="codeitalic1">snip</span>--<br/><span class="pd_blue">I nevgP go back on my word, because that is my Ninja way. 55 8936</span><br/><span class="pd_blue">I neveP go back on my word, because that is my Ninja way. 56 10019</span><br/><span class="pd_blue">I never go back on my word, because that is my Ninja way. 57 16028</span></pre>&#13;
<p class="indent">This output shows that the final score was 57, and it took 16,028 total guesses to match the quote exactly. Notice on the first line of output that 178 guesses were needed to get a score of 1! There are more efficient ways of guessing a quote, but I wanted to introduce the idea of genetic algorithms using an easy example. The point was to show how a method of scoring guesses and randomly mutating the “best guess so far” could produce accurate results in a surprisingly short amount of time.</p>&#13;
<p class="indent">Now, you can use this idea of scoring and mutating thousands of random guesses to solve other problems, too.</p>&#13;
<span epub:type="pagebreak" id="page_254"/>&#13;
<h3 class="h3" id="ch12_2">SOLVING THE TRAVELING SALESPERSON PROBLEM (TSP)</h3>&#13;
<p class="noindent">One of my students was unimpressed with the quote-guessing program because “we already know what the quote is.” So let’s use a genetic algorithm to solve a problem we don’t already know the solution for. <em>The Traveling Salesperson Problem</em>, or <em>TSP</em> for short, is an age-old brainteaser that is easy to understand but can become very difficult to solve. A salesperson has to travel to a given number of cities, and the goal is to find the route with the shortest distance. Sounds easy? And with a computer, we should simply be able to run all the possible routes through a program and measure their distances, right?</p>&#13;
<p class="indent">It turns out, above a certain number of cities, the computational complexity gets too much even for today’s supercomputers. Let’s see how many possible routes there are when you have six cities, as shown in <a href="ch12.xhtml#ch12fig1">Figure 12-1</a>.</p>&#13;
<div class="image"><a id="ch12fig1"/><img alt="image" src="../images/f254-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 12-1: The number of paths between</em> <code>n</code> <em>cities for</em> <code>n</code> <em>between 2 and 6</em></p>&#13;
<p class="indent">When there are two or three cities, there’s only one possible route. Add a fourth city, and it could be visited between any of the previous three, so multiply the previous number of routes by 3. So between four cities there are three possible routes. Add a fifth city, and it could be visited between any of the previous four, so there are four times as many as the previous step, so 12 possible routes. See the pattern? Between <em>n</em> cities, there are</p>&#13;
<div class="image"><img alt="image" src="../images/e254-01.jpg"/></div>&#13;
<p class="noindent">possible routes. So between 10 cities there are 181,440 possible routes. Between 20 cities, there are 60,822,550,204,416,000 routes. What’s after a trillion? Even if a computer can check a million routes per second, it would still take almost 2,000 years to calculate. That’s too slow for our purposes. There must be a better way.</p>&#13;
<h4 class="h4" id="ch12_1_6">USING GENETIC ALGORITHMS</h4>&#13;
<p class="noindent">Similar to our quote-guessing program, we’re going to create an object with a route in its “genes” and then score its route by how short it is. <span epub:type="pagebreak" id="page_255"/>The best route will then be mutated randomly, and we’ll score its mutation. We could take a bunch of “best routes,” splice together their lists, and score their “offspring.” The best part of this exploration is we <em>don’t</em> know the answer already. We could give the program a set of cities and their locations, or just have it randomly draw cities and try to optimize the route.</p>&#13;
<p class="indent">Open a new Processing sketch and call it <em>travelingSalesperson.pyde</em>. The first thing we should create is a <code>City</code> object. Each city will have its own x- and y-coordinate and a number we use to identify it. That way, we can define a route using a list of city numbers. For example, [5,3,0,2,4,1] means you start at city 5 and go to city 3, then city 0, and so on. The rules are the salesperson has to finally return to the first city. <a href="ch12.xhtml#ch12list5">Listing 12-5</a> shows the <code>City</code> class.</p>&#13;
<pre><span class="pd_g1"><em>travelingSales person.pyde</em></span><br/><span class="pd_g2">class</span> City:<br/>    <span class="pd_g2">def</span> <span class="pd_blue2">__init__</span>(<span class="pd_g2">self</span>,x,y,num):<br/>        <span class="pd_g2">self</span>.x = x<br/>        <span class="pd_g2">self</span>.y = y<br/>        <span class="pd_g2">self</span>.number = num <span class="pd_gray">#identifying number</span><br/><br/>    <span class="pd_g2">def</span> display(<span class="pd_g2">self</span>):<br/>        <span class="pd_blue2">fill</span>(0,255,255) <span class="pd_gray">#sky blue</span><br/>        <span class="pd_blue2">ellipse</span>(<span class="pd_g2">self</span>.x,<span class="pd_g2">self</span>.y,10,10)<br/>        <span class="pd_blue2">noFill</span>()</pre>&#13;
<p class="listing" id="ch12list5"><em>Listing 12-5: Writing the <code>City</code> class for the</em> <code>travelingSalesperson.pyde</code> <em>program</em></p>&#13;
<p class="indent">When initializing <code>City</code>, we get an x- and y-coordinate and give each <code>City</code> its own (<code>self</code>) x- and y-component. We also get a number that’s the city’s identifying number. In the <code>display()</code> method, we choose a color (sky blue, in this case) and create an ellipse at that location. We turn off the fill after drawing the city with the <code>noFill()</code> function, since no other shapes need to be filled in with color.</p>&#13;
<p class="indent">Let’s make sure that works. Let’s create the <code>setup()</code> function, declaring a size for the display window and creating an instance of our <code>City</code> class. Remember, we have to give it a location of two coordinates and an identifying number as in <a href="ch12.xhtml#ch12list6">Listing 12-6</a>.</p>&#13;
<pre><span class="pd_g2">def</span> <span class="codestrong1"><span class="pd_blue2">setup</span></span>():<br/>    <span class="pd_blue2">size</span>(600,600)<br/>    <span class="pd_blue2">background</span>(0)<br/>    city0 = City(100,200,0)<br/>    city0.display()</pre>&#13;
<p class="listing" id="ch12list6"><em>Listing 12-6: Writing the <code>setup()</code> function for creating one city</em></p>&#13;
<p class="indent">Run this, and you’ll see your first city (see <a href="ch12.xhtml#ch12fig2">Figure 12-2</a>)!</p>&#13;
<div class="image"><a id="ch12fig2"/><img alt="image" src="../images/f256-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 12-2: The first city</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_256"/>It might help to have the city display its number above it. To do that, add this to the city’s <code>display()</code> method, just before <code>noFill()</code>:</p>&#13;
<pre>        <span class="pd_blue2">textSize</span>(20)<br/>        <span class="pd_blue2">text</span>(<span class="pd_g2">self</span>.number,<span class="pd_g2">self</span>.x-10,<span class="pd_g2">self</span>.y-10)</pre>&#13;
<p class="indent">We declare the size of the text using Processing’s built-in <code>textSize()</code> function. Then we use the <code>text()</code> function to tell the program what to print (the number of the city) and where to print it (10 pixels to the left and above the city). While we’re creating cities, let’s start a <code>cities</code> list and put a few more cities on the screen in random locations. To use methods from the <code>random</code> module, we have to import <code>random</code> at the top of the file:</p>&#13;
<pre><span class="pd_g2">import</span> <span class="pd_blue2">random</span></pre>&#13;
<p class="indent">Now we can update our <code>setup()</code> function like in <a href="ch12.xhtml#ch12list7">Listing 12-7</a>.</p>&#13;
<pre><span class="pd_g1"><em>travelingSalesperson.pyde</em></span><br/>cities = []<br/><br/><span class="pd_gray">def setup():</span><br/><span class="pd_gray">    size(600,600)</span><br/><span class="pd_gray">    background(0)</span><br/>    <span class="pd_lime">for</span> i <span class="pd_g2">in</span> <span class="pd_lime">range</span>(6):<br/>        cities.<span class="pd_blue2">append</span>(City(<span class="pd_blue2">random</span>.randint(50,<span class="pd_raspberry">width</span>-50),<br/><span class="pd_blue2">                           random</span>.randint(50,<span class="pd_raspberry">height</span>-50),i))<br/><br/>    <span class="pd_lime">for</span> city <span class="pd_g2">in</span> cities:<br/>        city.display()</pre>&#13;
<p class="listing" id="ch12list7"><em>Listing 12-7: Writing the <code>setup()</code> function for creating six random cities</em></p>&#13;
<span epub:type="pagebreak" id="page_257"/>&#13;
<p class="indent">In the <code>setup()</code> function, we’ve added a loop to run six times. It adds a <code>City</code> object at a random location on the screen 50 units from the edges. The next loop iterates over all the elements in the <code>cities</code> list and displays each one. Run this, and you’ll see six cities in random locations, labeled with their ID numbers, as in <a href="ch12.xhtml#ch12fig3">Figure 12-3</a>.</p>&#13;
<div class="image"><a id="ch12fig3"/><img alt="image" src="../images/f257-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 12-3: Six cities, labeled with their numbers</em></p>&#13;
<p class="indent">Now let’s think about the route between the cities. We put the <code>City</code> objects (containing their locations and numbers) into the <code>cities</code> list, and eventually that list of numbers (our “genetic material”) will consist of the city numbers in a certain order. So the <code>Route</code> object needs a random list of numbers, too: a random sequence of all the city numbers. Of course, the numbers will be range from 0 to 1 less than the number of cities. We don’t want to keep changing numbers here and there in our code whenever we want to change the number of cities, so we’ll create a variable for the number of cities. Put this line at the beginning of the file, before the <code>City</code> class:</p>&#13;
<pre>N_CITIES = 10</pre>&#13;
<p class="indent">Why is <code>N_CITIES</code> in all capital letters? Throughout all the code, we won’t be changing the number of cities. So it’s not really a variable; instead, it’s a constant. It’s customary in Python to capitalize constant names to set them apart from variables. This doesn’t change the way Python deals with them at all; variables with capitalized names can still be changed. So be careful.</p>&#13;
<p class="indent">We’ll use <code>N_CITIES</code> wherever we would be using the total number of cities, and we’ll only need to change the value once! Place the code shown in <a href="ch12.xhtml#ch12list8">Listing 12-8</a> after the <code>City</code> class.</p>&#13;
<span epub:type="pagebreak" id="page_258"/>&#13;
<pre><span class="pd_g2">class</span> Route:<br/>    <span class="pd_g2">def</span> <span class="pd_blue2">__init__</span>(<span class="pd_g2">self</span>):<br/>        <span class="pd_g2">self</span>.distance = 0<br/>        <span class="pd_gray">#put cities in a list in order:</span><br/>        <span class="pd_g2">self</span>.cityNums = <span class="pd_blue2">random</span>.sample(<span class="pd_blue2">list</span>(<span class="pd_lime">range</span>(N_CITIES)),N_CITIES)</pre>&#13;
<p class="listing" id="ch12list8"><em>Listing 12-8: The <code>Route</code> class</em></p>&#13;
<p class="indent">First, we set the route’s distance (or length, but <code>length</code> is a keyword in Processing) to zero, and then we create a <code>cityNums</code> list that puts the numbers of the cities in a random order for that route.</p>&#13;
<p class="indent">You can use the <code>random</code> module’s <code>sample()</code> function to give Python a list and then sample a number of items from that list by telling it how many items to choose randomly. It’s like <code>choice()</code>, but it won’t select an item more than once. In probability, it’s called “sampling without replacement.” Enter the following in IDLE to see how sampling works:</p>&#13;
<pre>&gt;&gt;&gt; n = <span class="pd_purple">list</span>(<span class="pd_purple">range</span>(10))<br/>&gt;&gt;&gt; n<br/><span class="pd_blue">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br/>&gt;&gt;&gt; <span class="pd_orange">import</span> random<br/>&gt;&gt;&gt; x = random.sample(n,5)<br/>&gt;&gt;&gt; x<br/><span class="pd_blue">[2, 0, 5, 3, 8]</span></pre>&#13;
<p class="indent">Here, we create a list called <code>n</code> of the numbers between 0 and 9 by calling <code>range(10)</code> and converting it (it’s a “generator”) into a list. We then import the <code>random</code> module and ask Python to use the <code>sample()</code> function to pick a sample of five items from list <code>n</code> and save them to list <code>x</code>. In our <code>Route</code> code in <a href="ch12.xhtml#ch12list8">Listing 12-8</a>, since the variable <code>N_CITIES</code>, representing the number of cities, is 10, we’re choosing 10 numbers at random using <code>range(10)</code>, the numbers 0 to 9, and assigning them to the <code>Route</code>’s <code>cityNums</code> property.</p>&#13;
<p class="indent">And how will this display? Let’s draw purple lines between the cities. You can use any color you’d prefer.</p>&#13;
<p class="indent">Drawing lines between cities like this should remind you of drawing lines between the points on a graph in algebra or trigonometry lessons. The only difference is now at the end of the graph we have to return to the starting point. Remember using <code>beginShape</code>, <code>vertex</code>, and <code>endShape</code> in Chapter 6? Just like we used lines to draw a shape, we’ll draw the <code>Route</code> object as the outline of a shape, except this time we just won’t fill it in. Using <code>endshape(CLOSE)</code> will automatically close the loop! Add the code in <a href="ch12.xhtml#ch12list9">Listing 12-9</a> to the <code>Route</code> class.</p>&#13;
<pre>    <span class="pd_g2">def</span> display(<span class="pd_g2">self</span>):<br/>        <span class="pd_blue2">strokeWeight</span>(3)<br/>        <span class="pd_blue2">stroke</span>(255,0,255) <span class="pd_gray">#purple</span><br/>        <span class="pd_blue2">beginShape</span>()<br/>        <span class="pd_lime">for</span> i <span class="pd_g2">in</span> <span class="pd_g2">self</span>.cityNums:<br/>            vertex(cities[i].x,cities[i].y)<br/>            <span class="pd_gray">#then display the cities and their numbers</span><br/><span epub:type="pagebreak" id="page_259"/>&#13;
            cities[i].display()<br/>        <span class="pd_blue2">endShape</span>(<span class="pd_olive">CLOSE</span>)</pre>&#13;
<p class="listing" id="ch12list9"><em>Listing 12-9: Writing the <code>display</code> method of the <code>Route</code> class</em></p>&#13;
<p class="indent">The loop makes every city in the <code>Route</code>’s <code>cityNums</code> list a vertex of a polygon. The route is the outline of the polygon. Notice that inside the <code>Route</code>’s <code>display()</code> method we call the city’s <code>display()</code> method. That way, we don’t have to manually command the cities to display separately.</p>&#13;
<p class="indent">In the <code>setup()</code> function, we’ll create a <code>Route</code> object with the <code>cities</code> list and a list of numbers as arguments. Then we’ll display it. The last two lines of code at the bottom of <a href="ch12.xhtml#ch12list10">Listing 12-10</a> do this.</p>&#13;
<pre><span class="pd_gray">def setup():</span><br/><span class="pd_gray">    size(600,600)</span><br/><span class="pd_gray">    background(0)</span><br/>    <span class="pd_lime">for</span> i <span class="pd_g2">in</span> <span class="pd_lime">range</span>(N_CITIES):<br/><span class="pd_gray">        cities.append(City(random.randint(50,</span><span class="pd_gray">width-50),</span><br/><span class="pd_gray">                           random.randint(50,height-50),i))</span><br/>    route1 = Route()<br/>    route1.display()</pre>&#13;
<p class="listing" id="ch12list10"><em>Listing 12-10: Displaying a route</em></p>&#13;
<p class="indent">Run this, and you’ll see a path between the cities, in random order, as shown in <a href="ch12.xhtml#ch12fig4">Figure 12-4</a>.</p>&#13;
<div class="image"><a id="ch12fig4"/><img alt="image" src="../images/f259-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 12-4: A random route order</em></p>&#13;
<p class="indent">To change the number of cities, simply change the first line, where we declare <code>N_CITIES</code>, to a different number and then run the program. <a href="ch12.xhtml#ch12fig5">Figure 12-5</a> shows my output for <code>N_CITIES = 7</code>.</p>&#13;
<span epub:type="pagebreak" id="page_260"/>&#13;
<div class="image"><a id="ch12fig5"/><img alt="image" src="../images/f260-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 12-5: A route with seven cities</em></p>&#13;
<p class="indent">Now that you can create and display routes, let’s write a function to measure the distance of each route.</p>&#13;
<h4 class="h4" id="ch12_1_7">WRITING THE CALCLENGTH() METHOD</h4>&#13;
<p class="noindent">The <code>Route</code> object has a <code>distance</code> property that’s set to zero when it’s created. Each <code>Route</code> object also has a list of cities, in order, called <code>cityNums</code>. We just have to loop through the <code>cityNums</code> list and keep a running total of the distances between each pair of cities. No problem for cities 0 to 4, but we also need to calculate the distance from the last city back to the first one.</p>&#13;
<p class="indent"><a href="ch12.xhtml#ch12list11">Listing 12-11</a> shows the code for the <code>calcLength()</code> method, which goes inside the <code>Route</code> object.</p>&#13;
<pre>    <span class="pd_g2">def</span> calcLength(<span class="pd_g2">self</span>):<br/>        <span class="pd_g2">self</span>.distance = 0<br/>        <span class="pd_lime">for</span> i,num <span class="pd_g2">in</span> enumerate(<span class="pd_g2">self</span>.cityNums):<br/>        <span class="pd_gray"># find the distance from the current city to the previous city</span><br/>            <span class="pd_g2">self</span>.distance += <span class="pd_blue2">dist</span>(cities[num].x,<br/>                                cities[num].y,<br/>                                cities[<span class="pd_g2">self</span>.cityNums[i-1]].x,<br/>                                cities[<span class="pd_g2">self</span>.cityNums[i-1]].y)<br/>        <span class="pd_lime">return</span> <span class="pd_g2">self</span>.distance</pre>&#13;
<p class="listing" id="ch12list11"><em>Listing 12-11: Calculating a <code>Route</code>’s length</em></p>&#13;
<p class="indent">First, we zero out the <code>distance</code> property of the <code>Route</code> so every time we call this method it’ll start at zero. We use the <code>enumerate()</code> function so we can get <span epub:type="pagebreak" id="page_261"/>not just the number in the <code>cityNums</code> list but also its index. We then increment the <code>distance</code> property by the distance from the current city (<code>num</code>) to the previous city (<code>self.cityNums[i-1]</code>). Next, let’s add this line of code to the end of our <code>setup()</code> function:</p>&#13;
<pre>    <span class="pd_blue2">println</span>(route1.calcLength())</pre>&#13;
<p class="indent">We can now see the total distance covered by the salesperson in the console, like in <a href="ch12.xhtml#ch12fig6">Figure 12-6</a>.</p>&#13;
<div class="image"><a id="ch12fig6"/><img alt="image" src="../images/f261-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 12-6: We’ve calculated the distance . . . I think</em>.</p>&#13;
<p class="indent">Is this really the distance? Let’s make sure.</p>&#13;
<h4 class="h4" id="ch12_1_8">TESTING THE CALCLENGTH() METHOD</h4>&#13;
<p class="noindent">Let’s give the program an easy route that’s a square of sidelength 200 and check the distance. First, we change our constant for the number of cities to 4:</p>&#13;
<pre>N_CITIES = 4</pre>&#13;
<p class="indent">Next, we change the <code>setup()</code> function to what’s shown in <a href="ch12.xhtml#ch12list12">Listing 12-12</a>.</p>&#13;
<pre>cities = [City(100,100,0), City(300,100,1),<br/>                  City(300,300,2), City(100,300,3)]<br/><br/><span class="pd_gray">def setup():</span><br/><span class="pd_gray">    size(600,600)</span><br/><span class="pd_gray">    background(0)</span><br/><span class="pd_purple">    '''for i in range(N_CITIES):</span><br/><span class="pd_purple">        cities.append(City(random.randint(0,width),</span><br/><span class="pd_purple">                           random.randint(0,height),i))'''</span><br/>    route1 = Route()<br/><span class="pd_gray">    route1.cityNums = [0,1,2,3]</span><br/><span class="pd_gray">    route1.display()</span><br/>    <span class="pd_blue2">println</span>(route1.calcLength())</pre>&#13;
<p class="listing" id="ch12list12"><em>Listing 12-12: Creating a <code>Route</code> manually to test the <code>calcLength()</code> method</em></p>&#13;
<span epub:type="pagebreak" id="page_262"/>&#13;
<p class="indent">We comment out the loop to create cities at random, because we’ll go back to it after checking the <code>calcLength()</code> method. We create a new <code>cities</code> list containing the vertices of a square of sidelength 200. We also declare the <code>cityNums</code> list for <code>route1</code>; otherwise, it would randomly mix the cities. We expect the length of this <code>Route</code> to be 800.</p>&#13;
<p class="indent">When we run the code, we see what’s in <a href="ch12.xhtml#ch12fig7">Figure 12-7</a>.</p>&#13;
<div class="image"><a id="ch12fig7"/><img alt="image" src="../images/f262-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 12-7: The <code>calcLength()</code> method works!</em></p>&#13;
<p class="indent">It’s 800 units, as predicted! You can try some rectangles or some other easy-to-verify routes.</p>&#13;
<h4 class="h4" id="ch12_1_9">RANDOM ROUTES</h4>&#13;
<p class="noindent">In order to find the shortest possible route to a destination, we need to find all the possible routes. To do this, we need our infinite loop and Processing’s built-in <code>draw()</code> function. We’ll move the route code from <code>setup()</code> to the <code>draw()</code> function. We’ll also create a bunch of random routes and display them and their length. The entire code is shown in <a href="ch12.xhtml#ch12list13">Listing 12-13</a>.</p>&#13;
<pre><span class="pd_g1"><em>travelingSales person.pyde</em></span><br/><span class="pd_g2">import</span> <span class="pd_b1">random</span><br/><br/>N_CITIES = 10<br/><br/><span class="pd_g2">class</span> City:<br/>    <span class="pd_g2">def</span> <span class="pd_b1">__init__</span>(<span class="pd_g2">self</span>,x,y,num):<br/>        <span class="pd_g2">self</span>.x = x<br/>        <span class="pd_g2">self</span>.y = y<br/>        <span class="pd_g2">self</span>.number = num <span class="pd_gray">#identifying number</span><br/><br/>    <span class="pd_g2">def</span> display(<span class="pd_g2">self</span>):<br/>        <span class="pd_b1">fill</span>(0,255,255) <span class="pd_gray">#sky blue</span><br/><span epub:type="pagebreak" id="page_263"/>&#13;
        <span class="pd_b1">ellipse</span>(<span class="pd_g2">self</span>.x,<span class="pd_g2">self</span>.y,10,10)<br/>        <span class="pd_b1">textSize</span>(20)<br/>        <span class="pd_b1">text</span>(<span class="pd_g2">self</span>.number,<span class="pd_g2">self</span>.x-10,<span class="pd_g2">self</span>.y-10)<br/>        <span class="pd_b1">noFill</span>()<br/><br/><span class="pd_g2">class</span> Route:<br/>    <span class="pd_g2">def</span> <span class="pd_b1">__init__</span>(<span class="pd_g2">self</span>):<br/>        <span class="pd_g2">self</span>.distance = 0<br/>        <span class="pd_gray">#put cities in a list in numList order:</span><br/>        <span class="pd_g2">self</span>.cityNums = <span class="pd_b1">random</span>.sample(<span class="pd_b1">list</span>(<span class="pd_lime1">range</span>(N_CITIES)),N_CITIES)<br/><br/>    <span class="pd_g2">def</span> display(<span class="pd_g2">self</span>):<br/>        <span class="pd_b1">strokeWeight</span>(3)<br/>        <span class="pd_b1">stroke</span>(255,0,255) <span class="pd_gray">#purple</span><br/>        <span class="pd_b1">beginShape</span>()<br/>        <span class="pd_lime1">for</span> i <span class="pd_g2">in</span> <span class="pd_g2">self</span>.cityNums:<br/>            <span class="pd_b1">vertex</span>(cities[i].x,cities[i].y)<br/>            <span class="pd_gray">#then display the cities and their numbers</span><br/>            cities[i].display()<br/>        <span class="pd_b1">endShape</span>(<span class="pd_olive">CLOSE</span>)<br/><br/>    <span class="pd_g2">def</span> calcLength(<span class="pd_g2">self</span>):<br/>        <span class="pd_g2">self</span>.distance = 0<br/>        <span class="pd_lime1">for</span> i,num <span class="pd_g2">in</span> enumerate(<span class="pd_g2">self</span>.cityNums):<br/>        <span class="pd_gray"># find the distance to the previous city</span><br/>            <span class="pd_g2">self</span>.distance += <span class="pd_b1">dist</span>(cities[num].x,<br/>                                cities[num].y,<br/>                                cities[<span class="pd_g2">self</span>.cityNums[i-1]].x,<br/>                                cities[<span class="pd_g2">self</span>.cityNums[i-1]].y)<br/>        <span class="pd_lime1">return</span> <span class="pd_g2">self</span>.distance<br/><br/>cities = []<br/><br/><span class="pd_g2">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_b1">size</span>(600,600)<br/>    <span class="pd_lime1">for</span> i <span class="pd_g2">in</span> <span class="pd_lime1">range</span>(N_CITIES):<br/>        cities.<span class="pd_b1">append</span>(City(<span class="pd_b1">random</span>.randint(50,<span class="pd_raspberry">width</span>-50),<br/>                           <span class="pd_b1">random</span>.randint(50,<span class="pd_raspberry">height</span>-50),i))<br/><br/><span class="pd_g2">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_b1">background</span>(0)<br/>    route1 = Route()<br/>    route1.display()<br/>    <span class="pd_b1">println</span>(route1.calcLength())</pre>&#13;
<p class="listing" id="ch12list13"><em>Listing 12-13: Creating and displaying random routes</em></p>&#13;
<p class="indent">When you run this, you should see a bunch of routes being displayed and a bunch of numbers being printed to the console.</p>&#13;
<p class="indent">But we’re really only interested in keeping the best (shortest) route, so we’ll add some code to save the “<code>bestRoute</code>” and check the new random routes. Change <code>setup()</code> and <code>draw()</code> to what’s shown in <a href="ch12.xhtml#ch12list14">Listing 12-14</a>.</p>&#13;
<span epub:type="pagebreak" id="page_264"/>&#13;
<pre>cities = []<br/>random_improvements = 0<br/>mutated_improvements = 0<br/><br/><span class="pd_g2">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_g2">global</span> best, record_distance<br/>    <span class="pd_b1">size</span>(600,600)<br/>    <span class="pd_lime1">for</span> i <span class="pd_g2">in</span> <span class="pd_lime1">range</span>(N_CITIES):<br/>        cities.<span class="pd_b1">append</span>(City(<span class="pd_b1">random</span>.randint(50,<span class="pd_raspberry">width</span>-50),<br/>                           <span class="pd_b1">random</span>.randint(50,<span class="pd_raspberry">height</span>-50),i))<br/>    best = Route()<br/>    record_distance = best.calcLength()<br/><br/><span class="pd_g2">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_g2">global</span> best, record_distance, random_improvements<br/>    <span class="pd_b1">background</span>(0)<br/>    best.display()<br/><span class="pd_b1">    println</span>(record_distance)<br/>    <span class="pd_b1">println</span>(<span class="pd_purple">"random: "</span>+<span class="pd_b1">str</span>(random_improvements))<br/>    route1 = Route()<br/>    length1 = route1.calcLength()<br/>    <span class="pd_lime1">if</span> length1 &lt; record_distance:<br/>        record_distance = length1<br/>        best = route1<br/><br/>        random_improvements += 1</pre>&#13;
<p class="listing" id="ch12list14"><em>Listing 12-14: Keeping track of random improvements</em></p>&#13;
<p class="indent">Before the <code>setup()</code> function, we create a variable to count the number of random improvements that are made by the program. At the same time, we create a variable we’ll use in a few steps to count the mutated improvements.</p>&#13;
<p class="indent">In <code>setup()</code>, we created <code>route1</code> to be the first <code>Route</code>, we named it the “best route,” and we named its distance the <code>record_distance</code>. Since we want to share these variables with other functions, we declare them to be global variables at the beginning of the function.</p>&#13;
<p class="indent">In <code>draw()</code>, we keep generating new random routes and checking if they’re better than the one we think is the best route so far. Since we’re using only 10 cities, this could pay off with an optimal solution, if we leave it running a while. You’ll see that it only requires around a dozen random improvements. But, remember, there are only 181,440 unique routes through 10 cities. One 10-city route is shown in <a href="ch12.xhtml#ch12fig8">Figure 12-8</a>.</p>&#13;
<p class="indent">If you change the number of cities to 20, however, your program will just keep running, for days if you let it, and will probably not get close to an optimal solution. We need to start using the idea from the phrase-guessing program at the beginning of the chapter of scoring our guesses and mutating the best ones. Unlike before, we’ll create a “mating pool” of the best routes and combine their number lists as if they were genes.</p>&#13;
<span epub:type="pagebreak" id="page_265"/>&#13;
<div class="image"><a id="ch12fig8"/><img alt="image" src="../images/f265-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 12-8: Finding an optimal route randomly—if you can wait a few minutes</em></p>&#13;
<h4 class="h4" id="ch12_1_10">APPLYING THE PHRASE-GUESSING MUTATION IDEA</h4>&#13;
<p class="noindent">The list of numbers (the cities the salesperson will visit in order) will be the genetic material of the <code>Route</code>. First, we see how well some randomly mutated routes solve the Traveling Salesman Problem (just like with our phrase-guessing programs) and then we mutate and “mate” the better routes with each other to (hopefully) create a more optimal route.</p>&#13;
<h4 class="h4" id="ch12_1_11">MUTATING TWO NUMBERS IN A LIST</h4>&#13;
<p class="noindent">Let’s write a method to randomly mutate two of the numbers in a <code>Route</code> object’s <code>cityNums</code> list. It’s really just a swap. You can probably guess how we’ll randomly choose two numbers and make the city numbers that have those indices in the list trade places.</p>&#13;
<p class="indent">Python has a unique notation for swapping the values of two numbers. You can swap two numbers without creating a temporary variable. For example, if you enter the code in <a href="ch12.xhtml#ch12list15">Listing 12-15</a> in IDLE, it wouldn’t work.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">x = 2</span><br/>&gt;&gt;&gt; <span class="codestrong1">y = 3</span><br/>&gt;&gt;&gt; <span class="codestrong1">x = y</span><br/>&gt;&gt;&gt; <span class="codestrong1">y = x</span><br/>&gt;&gt;&gt; <span class="codestrong1">x</span><br/><span class="pd_blue">3</span><br/>&gt;&gt;&gt; <span class="codestrong1">y</span><br/><span class="pd_blue">3</span></pre>&#13;
<p class="listing" id="ch12list15"><em>Listing 12-15: The wrong way to swap the values of variables</em></p>&#13;
<span epub:type="pagebreak" id="page_266"/>&#13;
<p class="indent">When you change the value of <code>x</code> to be the same as <code>y</code> by entering <code>x = y</code>, they both become 3. Now when you try to set <code>y</code> to be the same as <code>x</code>, it’s not set to the original value of <code>x</code> (2), but the current value of <code>x</code>, which is 3. So both variables ended up as 3.</p>&#13;
<p class="indent">But you <em>can</em> swap the values on the same line, like this:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">x = 2</span><br/>&gt;&gt;&gt; <span class="codestrong1">y = 3</span><br/>&gt;&gt;&gt; <span class="codestrong1">x,y = y,x</span><br/>&gt;&gt;&gt; <span class="codestrong1">x</span><br/><span class="pd_blue">3</span><br/>&gt;&gt;&gt; <span class="codestrong1">y</span><br/><span class="pd_blue">2</span></pre>&#13;
<p class="indent">Swapping the values of two variables like this is very useful for the mutating we’re about to do. Instead of limiting the swapping to only two numbers, we can mutate more cities. We can put the swapping in a loop so the program will choose any number of cities and swap the first two numbers, then the next pair, and so on. The code for the <code>mutateN()</code> method is shown in <a href="ch12.xhtml#ch12list16">Listing 12-16</a>.</p>&#13;
<pre><span class="pd_g2">def</span> mutateN(<span class="pd_g2">self</span>,num):<br/>    indices = <span class="pd_b1">random</span>.sample(<span class="pd_b1">list</span>(<span class="pd_lime1">range</span>(N_CITIES)),num)<br/>    child = Route()<br/>    child.cityNums = <span class="pd_g2">self</span>.cityNums[::]<br/>    <span class="pd_lime1">for</span> i <span class="pd_g2">in</span> <span class="pd_lime1">range</span>(num-1):<br/>        child.cityNums[indices[i]],child.cityNums[indices[(i+1)%num]] = \<br/>        child.cityNums[indices[(i+1)%num]],child.cityNums[indices[i]]<br/>    <span class="pd_lime1">return</span> child</pre>&#13;
<p class="listing" id="ch12list16"><em>Listing 12-16: Writing the <code>mutateN()</code> method, for mutating any number of cities</em></p>&#13;
<p class="indent">We give the <code>mutateN()</code> method <code>num</code>, a number of cities to swap. Then the method makes a list of indices to swap by taking a random sample from the range of city numbers. It creates a “child” <code>Route</code> and copies its own city number list to the child. Then it swaps <code>num-1</code> times. If it swapped the full <code>num</code> times, the first city swapped would simply get swapped with all the other indices and end up where it started.</p>&#13;
<p class="indent">That long line of code is simply the <code>a,b = b,a</code> syntax we saw before, only with the two <code>cityNums</code> being swapped. The mod (<code>%</code>) operator makes sure your indices don’t exceed <code>num</code>, the number of cities in your sample. So if you’re swapping four cities, for example, when <code>i</code> is <code>4</code>, it changes <code>i + 1</code> from <code>5</code> to <code>5 % 4</code>, which is 1.</p>&#13;
<p class="indent">Next, we add a section to the end of the <code>draw()</code> function to mutate the best <code>Route</code>’s list of numbers and test the mutated <code>Route</code>’s length, as shown in <a href="ch12.xhtml#ch12list17">Listing 12-17</a>.</p>&#13;
<pre><span class="pd_g2">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_g2">global</span> best,record_distance,random_improvements<br/>    <span class="pd_g2">global</span> mutated_improvements<br/>    <span class="pd_b1">background</span>(0)<br/><span epub:type="pagebreak" id="page_267"/>&#13;
    best.display()<br/>    <span class="pd_b1">println</span>(record_distance)<br/>    <span class="pd_b1">println</span>(<span class="pd_purple">"random: "</span>+<span class="pd_b1">str</span>(random_improvements))<br/>    <span class="pd_b1">println</span>(<span class="pd_purple">"mutated: "</span>+<span class="pd_b1">str</span>(mutated_improvements))<br/>    route1 = Route()<br/>    length1 = route1.calcLength()<br/>    <span class="pd_lime1">if</span> length1 &lt; record_distance:<br/>        record_distance = length1<br/>        best = route1<br/>        random_improvements += 1<br/>    <span class="pd_lime1">for</span> i <span class="pd_g2">in</span> <span class="pd_lime1">range</span>(2,6):<br/>        <span class="pd_gray">#create a new Route</span><br/>        mutated = Route()<br/>        <span class="pd_gray">#set its number list to the best one</span><br/>        mutated.cityNums = best.cityNums[::]<br/>        mutated = mutated.mutateN(i) <span class="pd_gray">#mutate it</span><br/>        length2 = mutated.calcLength()<br/>        <span class="pd_lime1">if</span> length2 &lt; record_distance:<br/>            record_distance = length2<br/>            best = mutated<br/>            mutated_improvements += 1</pre>&#13;
<p class="listing" id="ch12list17"><em>Listing 12-17: Mutating the best “organism”</em></p>&#13;
<p class="indent">In the <code>for i in range(2,6):</code> loop, we’re telling the program to mutate 2, 3, 4, and 5 numbers in the <code>number</code> list and check the results. Now the program often does pretty well on a 20-city route in a few seconds, like in <a href="ch12.xhtml#ch12fig9">Figure 12-9</a>.</p>&#13;
<div class="image"><a id="ch12fig9"/><img alt="image" src="../images/f267-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 12-9: A 20-city route</em></p>&#13;
<p class="indent">The mutated “organisms” are improving the distance much better than the random ones! <a href="ch12.xhtml#ch12fig10">Figure 12-10</a> shows the printout.</p>&#13;
<span epub:type="pagebreak" id="page_268"/>&#13;
<div class="image"><a id="ch12fig10"/><img alt="image" src="../images/f268-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 12-10: The mutations are doing much better than the random improvements!</em></p>&#13;
<p class="indent"><a href="ch12.xhtml#ch12fig10">Figure 12-10</a> categorizes all the improvements, and here 29 of them were due to mutations and only one was due to a randomly generated <code>Route</code>. This shows that mutating lists is better at finding the optimal route than creating new random ones. I stepped up the mutating to swap anywhere from 2 to 10 cities by changing this line:</p>&#13;
<pre><span class="pd_lime1">for</span> i <span class="pd_g2">in</span> <span class="pd_lime1">range</span>(2,11):</pre>&#13;
<p class="indent">Although this improves its performance for 20-city problems and even for some 30-city problems, the program often gets stuck in a non-optimal rut, like in <a href="ch12.xhtml#ch12fig11">Figure 12-11</a>.</p>&#13;
<div class="image"><a id="ch12fig11"/><img alt="image" src="../images/f268-02.jpg"/></div>&#13;
<p class="caption"><em>Figure 12-11: A 30-city problem stuck in a non-optimal rut</em></p>&#13;
<p class="indent">We’re going to take the final step and go fully genetic. Now we won’t be restricting ourselves to what we think is the best route so far. Instead, we’ll have an enormous population to choose from.</p>&#13;
<p class="indent">We’ll make a <code>population</code> list for any number of routes we want, we’ll take the “fittest” ones, cross their number lists, and hopefully make an even better route! Just before the <code>setup()</code> function, after the <code>cities</code> list, add the <code>population</code> list and the constant for the number of routes, as shown in <a href="ch12.xhtml#ch12list18">Listing 12-18</a>.</p>&#13;
<span epub:type="pagebreak" id="page_269"/>&#13;
<pre>cities = []<br/>random_improvements = 0<br/>mutated_improvements = 0<br/>population = []<br/>POP_N = 1000 <span class="pd_gray">#number of routes</span></pre>&#13;
<p class="listing" id="ch12list18"><em>Listing 12-18: Starting a <code>population</code> list and a variable for population size</em></p>&#13;
<p class="indent">We just created an empty list to put our population of routes into, and a variable for the total number of routes. In the <code>setup()</code> function, we fill the <code>population</code> list with <code>POP_N</code> routes, as shown in <a href="ch12.xhtml#ch12list19">Listing 12-19</a>.</p>&#13;
<pre><span class="pd_gray">def setup():</span><br/>    <span class="pd_g2">global</span> best,record_distance,first,population<br/><span class="pd_gray">    size(600,600)</span><br/><span class="pd_gray">    for i in range(N_CITIES):</span><br/><span class="pd_gray">        cities.append(City(random.randint(50,width-50),</span><br/><span class="pd_gray">                           random.randint(50,height-50),i))</span><br/>    <span class="pd_gray">#put organisms in population list</span><br/>    <span class="pd_lime1">for</span> i <span class="pd_g2">in</span> <span class="pd_lime1">range</span>(POP_N):<br/>        population.<span class="pd_b1">append</span>(Route<span class="pd_gray">())</span><br/>    best = <span class="pd_b1">random</span>.choice(population)<br/>    <span class="pd_gray">record_distance = best.calcLength()</span><br/>    first = record_distance</pre>&#13;
<p class="listing" id="ch12list19"><em>Listing 12-19: Creating a population of routes</em></p>&#13;
<p class="indent">Notice we had to declare the <code>population</code> list to be a global variable. We put <code>POP_N</code> routes in the <code>population</code> list by using <code>for i in range(POP_N)</code>, and then we made a randomly chosen route the best one so far.</p>&#13;
<h4 class="h4" id="ch12_1_12">CROSSING OVER TO IMPROVE ROUTES</h4>&#13;
<p class="noindent">In the <code>draw()</code> function, we’re going to sort the <code>population</code> list so the <code>Route</code> objects with the lowest lengths are at the beginning. We’ll create a method called <code>crossover()</code> to splice the <code>cityNums</code> lists together at random. Here’s what it’ll do:</p>&#13;
<pre>a: [6, 0, 7, 8, 2, 1, 3, 9, 4, 5]<br/>b: [1, 0, 4, 9, 6, 2, 5, 8, 7, 3]<br/>index: 3<br/>c: [6, 0, 7, 1, 4, 9, 2, 5, 8, 3]</pre>&#13;
<p class="indent">The “parents” are lists <code>a</code> and <code>b</code>. The index is chosen randomly: index 3. Then <code>a</code> list is sliced off between index 2 (<code>7</code>) and index 3 (<code>8</code>), so the child list starts <code>[6,0,7]</code>. The remaining numbers that aren’t in that slice are added to the child list in the order they occur in list <code>b</code>: <code>[1,4,9,2,5,8,3]</code>. We concatenate those two lists, and that’s the child list. The code for the <code>crossover()</code> method is shown in <a href="ch12.xhtml#ch12list20">Listing 12-20</a>.</p>&#13;
<span epub:type="pagebreak" id="page_270"/>&#13;
<pre>    <span class="pd_g2">def</span> crossover(<span class="pd_g2">self</span>,partner):<br/>        <span class="pd_purple">'''Splice together genes with partner's genes'''</span><br/>        child = Route()<br/>        <span class="pd_gray">#randomly choose slice point</span><br/>        index = <span class="pd_b1">random</span>.randint(1,N_CITIES - 2)<br/>        <span class="pd_gray">#add numbers up to slice point</span><br/>        child.cityNums = <span class="pd_g2">self</span>.cityNums[:index]<br/>        <span class="pd_gray">#half the time reverse them</span><br/>        <span class="pd_lime1">if</span> <span class="pd_b1">random</span>.<span class="pd_b1">random</span>()&lt;0.5:<br/>            child.cityNums = child.cityNums[::-1]<br/>        <span class="pd_gray">#list of numbers not in the slice</span><br/>        notinslice = [x <span class="pd_lime1">for</span> x <span class="pd_g2">in</span> partner.cityNums <span class="pd_lime1">if</span> x <span class="pd_g2">not</span> <span class="pd_g2">in</span> child.cityNums]<br/>        <span class="pd_gray">#add the numbers not in the slice</span><br/>        child.cityNums += notinslice<br/>        <span class="pd_lime1">return</span> child</pre>&#13;
<p class="listing" id="ch12list20"><em>Listing 12-20: Writing the <code>crossover()</code> method of the <code>Route</code> class</em></p>&#13;
<p class="indent">The <code>crossover()</code> method requires we specify the <code>partner</code>, the other parent. The <code>child</code> route is created, and an index where the slicing will take place is chosen randomly. The child list gets the numbers in the first slice, and then half the time we reverse those numbers, for genetic diversity. We create a list of the numbers that aren’t in the slice and add each one as it occurs in the other parent’s (or partner’s) list. Finally, concatenate those slices and return the <code>child</code> route.</p>&#13;
<p class="indent">In the <code>draw()</code> function, we need to check the routes in the <code>population</code> list for the shortest one. Do we need to check each one like before? Luckily, Python provides a handy <code>sort()</code> function we can use to sort the <code>population</code> list by <code>calcLength()</code>. So the first <code>Route</code> in the list will be the shortest one. The final code for the <code>draw()</code> function is shown in <a href="ch12.xhtml#ch12list21">Listing 12-21</a>.</p>&#13;
<pre><span class="pd_g2">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_g2">global</span> best,record_distance,population<br/>    <span class="pd_b1">background</span>(0)<br/>    best.display()<br/>    <span class="pd_b1">println</span>(record_distance)<br/>    <span class="pd_gray">#println(best.cityNums) #If you need the exact Route through the cities!</span><br/> <span class="ent">➊</span> population.<span class="pd_b1">sort</span>(<span class="pd_raspberry">key</span>=Route.calcLength)<br/>    population = population[:POP_N] <span class="pd_gray">#limit size of population</span><br/>    length1 = population[0].calcLength()<br/>    <span class="pd_lime1">if</span> length1 &lt; record_distance:<br/>        record_distance = length1<br/>        best = population[0]<br/><br/>    <span class="pd_gray">#do crossover on population</span><br/> <span class="ent">➋</span> <span class="pd_lime1">for</span> i <span class="pd_g2">in</span> <span class="pd_lime1">range</span>(POP_N):<br/>        parentA,parentB = <span class="pd_b1">random</span>.sample(population,2)<br/>        <span class="pd_gray">#reproduce:</span><br/>        child = parentA.crossover(parentB)<br/>        population.<span class="pd_b1">append</span>(child)<br/><br/>    <span class="pd_gray">#mutateN the best in the population</span><br/> <span class="ent">➌</span> <span class="pd_lime1">for</span> i <span class="pd_g2">in</span> <span class="pd_lime1">range</span>(3,25):<br/>        <span class="pd_lime1">if</span> i &lt; N_CITIES:<br/>            new = best.mutateN(i)<br/>            population.<span class="pd_b1">append</span>(new)<br/><span epub:type="pagebreak" id="page_271"/>&#13;
<br/>    <span class="pd_gray">#mutateN random Routes in the population</span><br/> <span class="ent">➍</span> <span class="pd_lime1">for</span> i <span class="pd_g2">in</span> <span class="pd_lime1">range</span>(3,25):<br/>        <span class="pd_lime1">if</span> i &lt; N_CITIES:<br/>            new = <span class="pd_b1">random</span>.choice(population)<br/>            new = new.mutateN(i)<br/>            population.<span class="pd_b1">append</span>(new)</pre>&#13;
<p class="listing" id="ch12list21"><em>Listing 12-21: Writing the final <code>draw()</code> function</em></p>&#13;
<p class="indent">We use the <code>sort()</code> function at <span class="ent">➊</span>, and then trim the end of the <code>population</code> list (the longest routes) so the list remains <code>POP_N</code> routes long. Then we check the first item in the <code>population</code> list to see if it’s shorter than the best route. If so, we make it the best, like before. Next, we randomly sample two routes from the population and perform a crossover on their <code>cityNums</code> lists and add the resulting <code>child</code> route to the population <span class="ent">➋</span>. At <span class="ent">➌</span>, we mutate the <code>best</code> route, swapping 3, 4, and 5 numbers, all the way up to 24 numbers (if that’s less than the number of cities in the sketch). Finally, we randomly choose routes from the population and mutate them to try to improve our distance <span class="ent">➍</span>.</p>&#13;
<p class="indent">Now, using a population of 10,000 routes, our program can make a pretty good approximation of the optimal route through 100 cities. <a href="ch12.xhtml#ch12fig12">Figure 12-12</a> shows the program improving a route from an initial length of 26,000 units to under 4,000 units.</p>&#13;
<div class="image"><a id="ch12fig12"/><img alt="image" src="../images/f271-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 12-12: Improvements of the route through 100 cities</em></p>&#13;
<p class="indent">This took “only” a half an hour to crank through!</p>&#13;
<h3 class="h3" id="ch12_3">SUMMARY</h3>&#13;
<p class="noindent">In this chapter, we didn’t just use Python to answer the types of questions you get in math class whose answers are already known. Instead, we used indirect methods (scoring a string of characters or a route through a bunch of cities) to find solutions to questions without an answer key!</p>&#13;
<span epub:type="pagebreak" id="page_272"/>&#13;
<p class="indent">To do this, we mimicked the behavior of organisms whose genes mutate, taking advantage of the fact that some mutations are more useful than others for solving the problem at hand. We knew our target phrase at the beginning of the chapter, but to figure out whether our final route was the optimal one, we had to save the city locations and run the program a few more times. This is because genetic algorithms, just like real organisms, can only work with what they start out with, and they often end up in a non-optimal rut, as you saw.</p>&#13;
<p class="indent">But these indirect methods are surprisingly effective and are used extensively in machine learning and industrial processes. Equations are good for expressing a very simple relationship, but many situations are not that simple. Now you have plenty of useful tools, like our “sheep and grass” model, fractals, cellular automata, and, finally, genetic algorithms, for studying and modeling very complicated systems.</p>&#13;
</body></html>