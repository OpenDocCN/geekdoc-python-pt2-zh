- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Priority Queues and Heaps
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列和堆
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: '*Priority queues* are a class of data structures that retrieve items ordered
    by given scores for each item. Whereas both stacks and queues from Chapter 4 depended
    solely on the order in which data was inserted, priority queues use an additional
    piece of information to determine the retrieval order—the item’s priority. As
    we will see, this new information allows us to further adapt to the data and,
    among other useful applications, allows us to process urgent requests first.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*优先队列*是一类数据结构，用于根据每个项目的得分顺序检索项目。与第4章中的栈和队列仅依赖于数据插入顺序不同，优先队列使用一个额外的信息来确定检索顺序——即项目的优先级。正如我们将看到的，这一新信息使得我们能够进一步适应数据，并且在许多其他有用的应用中，允许我们首先处理紧急请求。'
- en: For example, imagine a new coffee shop, Dynamic Selection Coffee, has opened
    in your neighborhood. Bursting with excitement, you venture into the store and
    see 10 types of coffee beans you’ve never sampled. Before diving in and trying
    them, you spend the next hour carefully charting the relative merits of each new
    brand based on their woefully inadequate menu descriptions, leaving you with a
    ranked list of coffees to try. You select the most promising brand from the top
    of the list, purchase it, and go home to savor the experience.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你所在的社区开了一家新的咖啡店，名为动态选择咖啡。你充满兴奋地走进店里，看到有10种你从未尝试过的咖啡豆。在尝试之前，你花了一个小时仔细分析每个新品牌的相对优缺点，依据他们那不太充足的菜单描述，最终列出了一份咖啡的排名清单。你从排名最前的咖啡中挑选了最有前景的一个品牌，购买后带回家享受体验。
- en: The next day, you return to Dynamic Selection Coffee to try the second item
    on your list, only to find they’ve added another two coffees to the menu. When
    you ask the barista why they’ve made this change, they point to the shop’s sign,
    which explains that Dynamic Selection Coffee serves a constantly expanding selection
    of coffees. Their goal is to eventually serve over a thousand varieties. You are
    at once thrilled and terrified. Every day you will need to prioritize the new
    coffees and insert them into your list so that you know which coffee to try next.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第二天，你再次回到动态选择咖啡店，准备尝试你清单上的第二项，结果发现他们在菜单上又新增了两款咖啡。当你问咖啡师为什么做出这个改变时，他们指向店铺的标牌，上面解释道，动态选择咖啡提供的咖啡种类会不断扩展，他们的目标是最终提供超过一千种咖啡品种。你既感到兴奋又有些害怕。每天你都需要优先排列这些新咖啡，并将它们插入到你的清单中，以便知道接下来该尝试哪一款。
- en: 'The task of retrieving items from a prioritized list is one that pops up regularly
    in computer programs: given a list of items and associated priorities, how can
    we efficiently retrieve the next item in priority order? Often, we need to do
    this retrieval in a dynamic context where new items arrive all the time. We might
    need to choose which network packet to process based on priority, offer the best
    suggestion in spellcheck based on common spelling errors, or choose the next option
    in a best-first search. In the real world, we might use our own mental priority
    queues to decide which urgent task to perform next, which movie to watch, or which
    patient to see first in a crowded emergency room. Once you start looking, prioritized
    retrievals are everywhere.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从优先级列表中检索项目的任务在计算机程序中经常出现：给定一个项目列表和相关的优先级，我们如何高效地按优先级顺序检索下一个项目？通常，我们需要在一个动态的环境中进行此类检索，因为新项目会不断出现。我们可能需要根据优先级选择处理哪个网络数据包，在拼写检查中根据常见的拼写错误提供最佳建议，或者在最佳优先搜索中选择下一个选项。在现实生活中，我们可能会使用自己的心理优先队列来决定接下来要执行的紧急任务、要观看的电影，或是在拥挤的急诊室中首先看哪个病人。一旦开始留意，优先级检索无处不在。
- en: 'In this chapter, we introduce the priority queue, a class of data structures
    for retrieving prioritized items from a set, and then discuss the most common
    data structure for implementing this useful tool: the heap. Heaps make the central
    operations for a priority queue extremely efficient.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们介绍了优先队列，它是一类用于从一组数据中检索按优先级排序的项目的数据结构，接着讨论了实现这一实用工具的最常见数据结构：堆。堆使得优先队列的核心操作变得极为高效。
- en: Priority Queues
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先队列
- en: Priority queues store a set of items and enable the user to easily retrieve
    the item with the highest priority. They are dynamic, allowing insertions and
    retrievals to be intermixed. We need to be able to add and remove items from our
    prioritized task list. If we were stuck using a fixed data structure, the author
    might spend the day consulting his static list and repeatedly performing the highest-priority
    task of “Get morning coffee.” Without the ability to remove that task after it
    was accomplished, it would stay at the top of the author’s list. While this might
    make for an enjoyable day, it is unlikely to be a productive one.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列存储一组项，并允许用户轻松检索优先级最高的项。它们是动态的，允许插入和检索交替进行。我们需要能够从优先级任务列表中添加和移除项目。如果我们被迫使用固定数据结构，作者可能会花费一天的时间在他的静态列表上反复执行最高优先级任务“获取早晨咖啡”。如果在完成任务后无法移除该任务，它将一直停留在作者的列表顶部。虽然这样可能会使一天过得愉快，但不太可能会富有成效。
- en: 'In their most basic form, priority queues support a few primary operations:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的形式中，优先队列支持一些主要操作：
- en: Add an item and its associated priority score.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个项及其关联的优先级分数。
- en: Look up the item with the highest priority (or null if the queue is empty).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找优先级最高的项（如果队列为空则返回 null）。
- en: Remove the item with the highest priority (or null if the queue is empty).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除优先级最高的项（如果队列为空则返回 null）。
- en: We can also add other useful functions that allow us to check whether a priority
    queue is empty or to return the number of items currently stored.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加其他有用的功能，允许我们检查优先队列是否为空，或者返回当前存储的项数。
- en: We set the items’ priorities according to the problem at hand. In some cases,
    the priority values might be obvious or determined by the algorithm. When processing
    network requests, for example, each packet might come with an explicit priority,
    or we might choose to process the oldest request first. Deciding what to prioritize
    isn’t always a simple endeavor, however. When prioritizing which brand of coffee
    to try next, we might want to create a priority based on price, availability,
    or caffeine content—it depends on how we plan to use our priority queue.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据手头的问题设置项的优先级。在某些情况下，优先级值可能很明显，或者由算法决定。例如，在处理网络请求时，每个数据包可能附带一个明确的优先级，或者我们可能选择先处理最旧的请求。然而，决定优先处理什么并不是一件简单的事情。当决定优先尝试哪种品牌的咖啡时，我们可能想根据价格、可得性或咖啡因含量来设定优先级——这取决于我们打算如何使用我们的优先队列。
- en: It’s possible, but not ideal, to implement priority queues with primitive data
    structures like sorted linked lists or sorted arrays, adding new items into the
    list according to their priority. [Figure 7-1](#figure7-1) shows an example of
    adding the value 21 into a sorted linked list.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像排序链表或排序数组这样的原始数据结构实现优先队列是可行的，但并不理想，我们会根据优先级将新项添加到列表中。[图 7-1](#figure7-1)
    展示了将值 21 添加到排序链表中的示例。
- en: '![A linked list before and after the addition of an eighth element into the
    middle of the list where values are in decreasing order. The head of the list
    has the value 50, and the end of the list has value 9\. Value 21 is inserted between
    value 28 and value 15.](image_fi/502604c07/f07001.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![排序链表在添加第八个元素后，元素按递减顺序排列。链表头部的值为 50，尾部的值为 9。值 21 被插入在值 28 和值 15 之间。](image_fi/502604c07/f07001.png)'
- en: 'Figure 7-1: Adding an element (21) into a sorted linked list representing a
    priority queue'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1：将元素（21）添加到表示优先队列的排序链表中
- en: A sorted linked list keeps the highest-priority item at the front of the list
    for easy lookup. In fact, in this case, a lookup takes constant time regardless
    of the length of the priority queue—we just look at the first element. Unfortunately,
    adding new elements can be expensive. We might need to traverse the entire list
    each time we add a new item, costing us time proportional to the length of the
    priority queue.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 排序链表将最高优先级的项放在列表的前面，便于查找。实际上，在这种情况下，无论优先队列的长度如何，查找都需要常数时间——我们只需查看第一个元素。不幸的是，添加新元素可能会很昂贵。每次添加新项时，我们可能需要遍历整个列表，这样的操作需要的时间与优先队列的长度成正比。
- en: 'The author uses a real-world version of this sorted-list approach to organize
    his refrigerator, storing items front-to-back in order of increasing expiration
    date. The closest item is always the highest priority, the one that will expire
    the soonest. Retrieving the correct item is easy—just grab whatever is in front.
    This scheme is particularly beneficial when storing milk or cream for morning
    coffee: no one wants to spend the first few bleary moments of the morning reading
    expiration dates. However, inserting new items behind old ones can take time and
    require an annoying amount of shifting.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 作者使用了一个现实世界的排序列表方法来整理他的冰箱，按照从前到后的顺序存放物品，顺序依据的是过期日期的升序。最接近过期的物品总是优先级最高的。获取正确的物品很容易——只需拿起最前面的那一件。这个方案特别适用于存放牛奶或咖啡用的奶油：没有人愿意在早晨朦胧的时刻花时间查看过期日期。然而，将新物品插入到旧物品后面可能需要时间，并且需要进行麻烦的移位操作。
- en: Similarly, we could maintain the priority queue in an *unsorted* linked list
    or array. New additions are trivial—just tag the element onto the back of the
    list, as illustrated in [Figure 7-2](#figure7-2).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们也可以将优先队列维护在一个 *未排序* 的链表或数组中。新添加的元素非常简单——只需将元素附加到列表的末尾，如[图 7-2](#figure7-2)所示。
- en: '![An unsorted array before and after the addition of the eighth element. The
    value 21 is added to the end of the unsorted array after the value 39.](image_fi/502604c07/f07002.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![未排序的数组，在添加第八个元素之前和之后的对比。值 21 在值 39 后添加到未排序数组的末尾。](image_fi/502604c07/f07002.png)'
- en: 'Figure 7-2: Adding an element (21) into an unsorted array representing a priority
    queue'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-2：将一个元素（21）添加到表示优先队列的未排序数组中
- en: Unfortunately, we now pay a high cost in looking up the next element. We must
    scan the entire list in order to determine which element has the highest priority.
    If we are removing it, we also shift everything over to fill in the gap. This
    approach corresponds to scanning the full set of items in the author’s fridge
    to find whichever is closest to expiring. This might work for a fridge with just
    a few milk cartons, but imagine the overhead of picking through every single item
    of food or drink in a large grocery store.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们现在在查找下一个元素时需要付出较高的代价。我们必须扫描整个列表，以确定哪个元素的优先级最高。如果我们要移除它，还需要将所有元素移位以填补空缺。这种方法就像扫描作者冰箱中的所有食物，找出哪个快要过期。对于冰箱里只有几盒牛奶来说，这可能能奏效，但想象一下在一个大型超市中挑选每一件食品或饮料的开销。
- en: Implementing priority queues as sorted lists may work better than using unsorted
    lists or vice versa, depending on how we plan to use the priority queue. If additions
    are more common than lookups, we prefer the unsorted list. If lookups are more
    common, we should pay the cost of keeping the elements sorted. In the case of
    refrigerators, lookups are much more common—we pick up a single carton of milk
    to use it more often than we buy a new carton, so it pays to keep the milk in
    sorted order. The challenge arises when both additions and lookups are common;
    prioritizing one operation over the other will lead to overall inefficiency, so
    we need a method that balances their costs. A clever data structure, the heap,
    helps us solve this problem.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将优先队列实现为排序列表，可能比使用未排序列表更有效，或者反之，这取决于我们计划如何使用优先队列。如果添加操作比查找操作更常见，我们倾向于使用未排序列表。如果查找操作更常见，我们应该承担保持元素排序的代价。在冰箱的例子中，查找操作要更常见——我们使用一盒牛奶的频率远高于购买新的一盒，因此保持牛奶的排序是值得的。挑战出现在添加操作和查找操作都很常见的情况；优先执行某一操作将导致整体效率低下，因此我们需要一种平衡两者开销的方法。一个巧妙的数据结构，堆，帮助我们解决了这个问题。
- en: Max Heaps
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最大堆
- en: A *max heap* is a variant of the binary tree that maintains a special ordered
    relationship between a node and its children. Specifically, a max heap stores
    the elements according to the *max heap property*, which states that the value
    at any node in the tree is larger than or equal to the values of its child nodes.
    For simplicity’s sake, we will often use the more general terms *heaps* and *heap
    property* to refer to max heaps and the max heap property throughout the remainder
    of the chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*最大堆* 是一种二叉树的变体，它在节点和其子节点之间保持特殊的顺序关系。具体来说，最大堆根据 *最大堆属性* 存储元素，该属性规定树中任意节点的值都大于或等于其子节点的值。为了简便起见，我们在本章接下来的部分中会常常使用更通用的术语
    *堆* 和 *堆属性* 来指代最大堆和最大堆属性。'
- en: '[Figure 7-3](#figure7-3) shows a representation of a binary tree organized
    according to the max heap property.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-3](#figure7-3)展示了一个按照最大堆属性组织的二叉树的表示。'
- en: '![The binary tree for a heap starts with the largest element (99) at the root
    with two children 67 and 97\. For any node, the values of both the left and right
    children are less than or equal to the value of the node itself.](image_fi/502604c07/f07003.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![堆的二叉树以最大元素（99）为根节点，根节点有两个子节点67和97。对于任何节点，左子节点和右子节点的值都小于或等于该节点的值。](image_fi/502604c07/f07003.png)'
- en: 'Figure 7-3: A heap represented as a binary tree'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-3：堆的二叉树表示
- en: There’s no special preference or ordering between the left and right children,
    aside from their being lower priority than their parent. For comparison, imagine
    an elite coffee lover’s mentorship program, the Society for the Improvement of
    Coffee-Related Knowledge. Each member (node) agrees to mentor up to two other
    coffee lovers (child nodes). The only condition is that each of the mentees must
    not know more about coffee than their mentor does—otherwise, the mentorship would
    be a waste.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了子节点的优先级低于父节点之外，左子节点和右子节点之间没有特别的偏好或排序。为了进行比较，可以想象一个精英咖啡爱好者的指导计划——“咖啡知识提升协会”。每个会员（节点）同意指导最多两个其他咖啡爱好者（子节点）。唯一的条件是每个被指导者的咖啡知识不能超过导师——否则，指导关系就毫无意义。
- en: 'Computer scientist J. W. J. Williams originally invented heaps as a component
    of a new sorting algorithm, heapsort, which we’ll discuss later in the chapter.
    However, he recognized that heaps are useful data structures for other tasks.
    The max heap’s simple structure allows it to efficiently support the operations
    required for priority queues: (1) allowing a user to efficiently look up the largest
    element, (2) removing the largest element, and (3) adding an arbitrary element.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家J. W. J. Williams最初发明了堆作为新排序算法——堆排序的一个组成部分，我们将在本章稍后讨论它。然而，他意识到堆是一种对于其他任务也非常有用的数据结构。最大堆的简单结构使其能够高效地支持优先队列所需的操作：（1）允许用户高效查找最大元素，（2）删除最大元素，以及（3）添加任意元素。
- en: Heaps are often visualized as trees but are often implemented with arrays for
    efficiency. In this chapter, we present these two representations in parallel
    to allow the reader to make mental connections between them. However, it is not
    required that we use arrays for implementation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 堆通常被形象化为树，但通常为了效率起见使用数组来实现。在本章中，我们并行展示这两种表示方式，以帮助读者在它们之间建立心理联系。然而，使用数组进行实现并不是必需的。
- en: In the array-based implementation, each element in the array corresponds to
    a node in the tree with the root node at index 1 (we skip index 0 to stay consistent
    with common convention for heaps). Child node indexes are defined relative to
    the indexes of their parents, so a node at index *i* has children at indexes 2*i*
    and 2*i* + 1\. For example, the node at index 2 has a child at index 2 × 2 = 4
    and index 2 × 2 + 1 = 5, as shown in [Figure 7-4](#figure7-4).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于数组的实现中，数组中的每个元素对应树中的一个节点，根节点位于索引1（我们跳过索引0，以便与堆的常见约定保持一致）。子节点的索引是相对于父节点的索引定义的，因此位于索引*i*的节点，其子节点位于索引2*i*和2*i*
    + 1。例如，位于索引2的节点，其子节点位于索引2 × 2 = 4和索引2 × 2 + 1 = 5，如[图7-4](#figure7-4)所示。
- en: '![A heap represented both as an array and as a tree with arrows indicating
    where each node sits in the array. The root node 98 corresponds to the first element
    in the array. The node’s two children, 95 and 50, are the second and third elements
    of the array.](image_fi/502604c07/f07004.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![堆同时作为数组和树表示，箭头指示每个节点在数组中的位置。根节点98对应数组中的第一个元素，节点的两个子节点95和50分别是数组中的第二和第三个元素。](image_fi/502604c07/f07004.png)'
- en: 'Figure 7-4: The heap’s position corresponds to index locations.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-4：堆的位置对应索引位置。
- en: Similarly, we compute the index of a node’s parent as `Floor(i/2)`. The indexing
    scheme allows the algorithm to trivially compute the index of a child based on
    that of the parent, and the index of a parent based on its child.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们计算一个节点父节点的索引为`Floor(i/2)`。这种索引方式使得算法可以轻松地根据父节点的索引计算子节点的索引，反之亦然。
- en: The root node always corresponds to the maximum value in a max heap. Since we
    store the root node in a fixed spot in the array (index = 1), we can always find
    this maximum value in constant time. It’s just an array lookup. The layout of
    the data itself thus addresses one of the necessary priority queue operations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 根节点总是对应于最大堆中的最大值。由于我们将根节点存储在数组中的固定位置（索引=1），因此我们可以始终在常数时间内找到这个最大值。它只是一个数组查找操作。因此，数据本身的布局就解决了优先队列所需的一个操作。
- en: Since we’ll be adding and removing arbitrary elements in our priority queue,
    in order to avoid constantly resizing the array, we want to preallocate an array
    that is large enough to accommodate the number of items we expect to add. Remember
    from Chapter 3 that dynamically resizing an array can be expensive, forcing us
    to create a new array and copy over the values, and in this case wasting the precious
    efficiency of the heap. Instead, we can initially allocate a large array, track
    the index of the last filled element of the array, and call that index the virtual
    end of the array. This allows us to append new elements by simply updating the
    index for the last element.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在优先队列中添加和移除任意元素，为了避免不断地调整数组大小，我们希望预先分配一个足够大的数组，以容纳我们预期添加的元素数量。还记得第3章中提到的，动态调整数组大小可能非常昂贵，需要我们创建一个新数组并复制值，这样会浪费堆的宝贵效率。相反，我们可以最初分配一个较大的数组，跟踪数组中最后一个填充元素的索引，并将该索引称为数组的虚拟末尾。这样，我们只需通过更新最后一个元素的索引，就可以轻松地追加新元素。
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Of course, the cost of this overallocation is a chunk of potentially unused
    memory if our heap doesn’t grow as large as expected.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，整体分配的代价是可能未使用的内存块，如果我们的堆没有像预期那样增长。
- en: Using an array to represent a tree-based data structure is an interesting step
    in its own right. We can use packed arrays and a mathematical mapping to represent
    a heap instead of relying on pointers, allowing us to store the heap with less
    memory. By maintaining a mapping from a node’s index to its children’s, we can
    re-create a tree-based data structure without the pointers. As we will see below,
    this array-based representation is feasible for heaps because the data structure
    always maintains a nearly complete and balanced tree. This results in a packed
    array with no gaps. While we could use the same array representation for other
    trees, such as binary search trees, those data structures often have gaps throughout
    and would require very large (and possibly mostly empty) arrays to store trees
    with deep branches.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组表示基于树的数据结构本身就是一个有趣的步骤。我们可以使用紧凑数组和数学映射来表示堆，而不依赖指针，从而使得堆的存储占用更少的内存。通过维护一个从节点索引到其子节点的映射，我们可以在没有指针的情况下重新创建一个基于树的数据结构。正如我们下面所看到的，基于数组的表示对于堆是可行的，因为该数据结构始终保持一个几乎完整和平衡的树。这导致了一个没有空隙的紧凑数组。虽然我们也可以使用相同的数组表示其他树，如二叉搜索树，但这些数据结构通常会有空隙，并且需要非常大的（可能大部分是空的）数组来存储具有深度分支的树。
- en: Adding Elements to a Heap
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向堆中添加元素
- en: When adding a new element to a heap, we must ensure that the structure retains
    the heap property. Just as you would not assign a decorated general to report
    to a fresh lieutenant, you wouldn’t put a heap node with high priority under a
    low priority node. We must add the element to the heap’s tree structure such that
    all elements below the addition have a priority less than or equal to that of
    the new node. Similarly, all nodes above the new addition should have priorities
    that are greater than or equal to that of the new node.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当向堆中添加新元素时，我们必须确保结构保持堆的属性。就像你不会让一位装饰性的将军向一名新任中尉报告一样，你也不会把一个优先级高的堆节点放在一个优先级低的节点下。我们必须将元素添加到堆的树结构中，确保所有在新节点下的元素的优先级小于或等于新节点的优先级。同样，新添加的节点上方的所有节点优先级应该大于或等于新节点的优先级。
- en: Part of the brilliance of the array implementation of a heap is that it retains
    this property while storing the nodes as a packed array. In previous chapters,
    adding nodes to the middle of an array was expensive, requiring us to shift later
    entries down. Fortunately, we don’t need to pay this linear cost each time we
    add a new element to a heap. Instead, we add elements by first breaking the heap
    property and then swapping elements along a single branch of the tree to restore
    it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 堆的数组实现的部分巧妙之处在于，它在以紧凑数组存储节点的同时，保持了这一属性。在之前的章节中，将节点添加到数组的中间是很昂贵的，需要我们将后面的条目向下移动。幸运的是，我们不需要每次添加新元素到堆时支付这个线性成本。相反，我们通过首先打破堆的属性，然后沿着树的单个分支交换元素来恢复堆的属性。
- en: In other words, to add a new element to the heap, we add it to the first empty
    space in the bottom level of the tree. If this new value is larger than the value
    of its parent node, we bubble it up the tree until it is smaller than or equal
    to its parent, restoring the heap property. The structure of the heap itself allows
    us to do this efficiently. In the array implementation of a heap, this corresponds
    to appending the new element to the back of the array and swapping it forward.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，为了将新元素添加到堆中，我们将它添加到树底层的第一个空位。如果这个新值大于其父节点的值，我们就将它冒泡到树的上层，直到它小于或等于其父节点，恢复堆的性质。堆本身的结构使我们能够高效地完成这一操作。在堆的数组实现中，这对应于将新元素添加到数组的末尾并将其向前交换。
- en: 'Consider the example in [Figure 7-5](#figure7-5), which shows the structure
    of the heap as both an array and a tree at each step. [Figure 7-5](#figure7-5)(a)
    shows the heap before the new element is added. In [Figure 7-5](#figure7-5)(b),
    we append the new element, 85, to the back of the array, effectively inserting
    it in the bottom of the tree. After the first comparison in [Figure 7-5](#figure7-5)(c),
    we swap the new element with its parent node, since 85 is greater than 50\. The
    swap is shown in [Figure 7-5](#figure7-5)(d). The second comparison, in [Figure
    7-5](#figure7-5)(e), reveals that the new node is now in the correct place in
    the hierarchy: 98 is greater than 85, so there is no need for the new node to
    switch with its parent a second time. [Figure 7-5](#figure7-5)(f) shows the heap
    after the addition is complete.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[图7-5](#figure7-5)，它展示了堆在每一步中作为数组和树的结构。[图7-5](#figure7-5)(a)显示了新元素添加之前的堆。在[图7-5](#figure7-5)(b)中，我们将新元素85添加到数组的末尾，实际上将它插入到树的底部。在[图7-5](#figure7-5)(c)中的第一次比较后，我们将新元素与其父节点交换，因为85大于50。交换操作如[图7-5](#figure7-5)(d)所示。在第二次比较中，如[图7-5](#figure7-5)(e)所示，发现新节点已经处于正确的位置：98大于85，因此不需要将新节点与其父节点再次交换。[图7-5](#figure7-5)(f)显示了添加完成后的堆。
- en: '![We start with the array from Figure 7‐4\. Node 85 is added to the end of
    the array and then bubbled up to the correct position. We first compare 85 with
    its parent 50 and swap them. In the next step, we compare 85 with its new parent
    98 and keep the ordering.](image_fi/502604c07/f07005.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![我们从图7-4中的数组开始。节点85被添加到数组的末尾，然后被冒泡到正确的位置。我们首先将85与它的父节点50进行比较，并交换它们。在下一步，我们将85与它的新父节点98进行比较，并保持顺序。](image_fi/502604c07/f07005.png)'
- en: 'Figure 7-5: Adding an element (85) to a heap'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-5：向堆中添加元素（85）
- en: 'The code for implementing this addition uses a single `WHILE` loop to progress
    up the levels of the heap until it has reached the root or found a parent larger
    than or equal to the new node’s value:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这个加法的代码使用一个单一的`WHILE`循环来逐层向上遍历堆，直到它到达根节点或找到一个比新节点值大或相等的父节点：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since we are using an array to store the heap, the code starts by checking that
    it still has room in the array to add a new element ❶. If not, it increases the
    size of the heap, perhaps by applying the array-doubling technique described in
    Chapter 3. Next, the code appends the new element to the end of the array and
    updates the position of the last element ❷. The `WHILE` loop starts at the freshly
    added element ❸, progresses up each layer of the heap by comparing the current
    value to that of its parent ❹, and switching if necessary ❺. The loop terminates
    when we either reach the top of the heap (`parent == 0`) or find a parent greater
    than or equal to the child.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用数组来存储堆，代码首先检查数组中是否还有足够的空间来添加新元素❶。如果没有，它会增加堆的大小，可能会采用第3章中描述的数组扩展技术。接下来，代码将新元素附加到数组的末尾，并更新最后一个元素的位置❷。`WHILE`循环从刚刚添加的元素❸开始，通过将当前值与其父节点的值进行比较❹，逐层向上遍历堆，并在必要时进行交换❺。循环在以下两种情况之一终止：我们要么到达堆的顶部（`parent
    == 0`），要么找到了一个大于或等于子节点的父节点。
- en: 'We might compare this process to an oddly designed, yet efficient, package
    distribution center as shown in [Figure 7-6](#figure7-6). The employees organize
    packages in neat rows on the floor using the heap property: in the front row is
    a single package with the highest priority, the next to be shipped. Behind that
    package sit two lower-priority packages. Behind each of these are two more packages
    (for a total of four in that row) such that each pair has priorities less than
    or equal to the corresponding package in front of them. With each new row, the
    number of packages doubles so that the arrangement spreads out wider and wider
    as you move toward the back of the warehouse. Each package has at most two lower-
    or equal-priority packages sitting behind it and at most one higher- or equal-priority
    package in front. Painted rectangles on the warehouse floor helpfully indicate
    the possible locations for packages in each of the rows.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个过程比作一个设计奇特但高效的包裹分发中心，如[图 7-6](#figure7-6)所示。员工们使用堆的性质，将包裹整齐地排列在地面上：在最前面的排里，有一个优先级最高的包裹，它是下一个要发货的包裹。其后有两个优先级较低的包裹。再往后，每个包裹后面都有两个包裹（这一排总共有四个包裹），确保每对包裹的优先级都小于或等于它们前面的包裹。随着每一新排的增加，包裹的数量翻倍，排列从仓库前部向后扩展。每个包裹最多有两个优先级较低或相同的包裹坐在它后面，且最多只有一个优先级更高或相同的包裹在它前面。仓库地面上画有矩形框，帮助指示每一排可能放置包裹的位置。
- en: '![A diagram showing rows of packages on a warehouse floor, with one package
    in the top row, two in the second row, four in the third, and eight in the fourth.
    The fifth and last row is not completely filled.](image_fi/502604c07/f07006.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![展示仓库地面上排列的包裹图示，第一排一个包裹，第二排两个包裹，第三排四个包裹，第四排八个包裹。第五排是最后一排，未完全填满。](image_fi/502604c07/f07006.png)'
- en: 'Figure 7-6: A warehouse floor organized as a heap'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-6：作为堆结构组织的仓库地面
- en: New packages are brought in from the back of the warehouse. Each delivery person
    mumbles something about the weird sorting scheme, relieved that at least they
    don’t have to carry their package to the very front, drops the package in the
    frontmost available spot, and leaves as quickly as possible. The warehouse employees
    then spring into action, comparing the priority of the new package with the one
    immediately in front of it (ignoring the rest of the packages in that row). If
    they find an inversion, they switch the packages. Otherwise, they leave the package
    where it is. This continues until the new package occupies the appropriate place
    in the hierarchy, with the package in front of it having a higher or an equal
    priority. Since the packages are heavy and spread out, the employees minimize
    their work with at most one comparison and switch per row. They never shuffle
    packages within a row. After all, nobody wants to move boxes unnecessarily.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 新包裹从仓库后部搬进来。每个送货员都会嘟囔着一些关于奇怪排序方案的话，松了口气，因为至少他们不需要将包裹搬到最前面，然后将包裹放到最前面空闲的位置，迅速离开。随后，仓库员工迅速开始行动，将新包裹的优先级与其前面紧挨着的包裹进行比较（忽略该排其他的包裹）。如果他们发现优先级倒置，就交换这两个包裹。否则，他们将包裹保持在原地。这一过程会持续进行，直到新包裹占据了合适的优先级位置，且其前面的包裹优先级更高或相同。由于包裹很重并且分布较广，员工们通过在每排最多只进行一次比较和交换来减少工作量。他们从不在同一排内重新排列包裹。毕竟，没人愿意不必要地移动箱子。
- en: 'Intuitively, we can see that heap additions are not terribly expensive. In
    the worst case, we would have to swap the new node all the way to the root of
    the tree, but this only means swapping a small fraction of the array’s values.
    By design, heaps are *balanced* binary trees: we fill out a complete level of
    the tree before inserting a node into the next level. Since the number of nodes
    in a full binary tree doubles with each level, the addition operation requires,
    in the worst case, log[2](*N*) swaps. This is significantly better than the worst
    case of *N* swaps required to maintain a sorted list.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地看，我们可以发现堆的添加操作并不特别昂贵。在最坏的情况下，我们可能需要将新节点交换到树的根部，但这仅意味着交换数组中一小部分的值。按照设计，堆是*平衡*二叉树：我们在插入节点到下一级之前，先填满树的完整一层。由于完全二叉树中每一层的节点数是前一层的两倍，因此添加操作在最坏情况下需要
    log[2](*N*) 次交换。这比维持一个已排序列表所需的最坏情况 *N* 次交换要好得多。
- en: Removing the Highest-Priority Elements from Heaps
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从堆中移除最高优先级的元素
- en: Looking up and removing the highest-priority element from a priority queue is
    a core operation that allows us to process items in order of their priority. Perhaps
    we are storing a list of pending network requests and want to process the highest-priority
    one. Or we could be running an emergency room and looking to see the most urgent
    patient. In both cases, we want to remove this element from our priority queue
    so that we can go on to extract the next highest priority element.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在优先队列中查找并移除最高优先级元素是一个核心操作，它允许我们按优先级顺序处理项目。也许我们在存储一系列待处理的网络请求，并希望处理最高优先级的请求。或者我们可能在运营一个急诊室，想要优先处理最紧急的病人。在这两种情况下，我们都希望从优先队列中移除该元素，以便接着提取下一个最高优先级的元素。
- en: To remove the highest-priority node, we must first break, then restore, the
    heap property. Consider the example in [Figure 7-7](#figure7-7). We start by swapping
    the highest-priority node with the last node in the lowest level of the tree ([Figure
    7-7](#figure7-7)(b)), effectively making the last element the new root node. However,
    this epic promotion for the new root node is almost guaranteed not to stand up
    to scrutiny. In the array implementation, this corresponds to swapping the first
    and last elements in the array. This swap plugs the gap at the front of the array
    that would be created by removing the first element and thus maintains a packed
    array.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了移除最高优先级的节点，我们必须先打破，然后恢复堆的性质。请参考[图 7-7](#figure7-7)中的示例。我们首先通过与树中最低层的最后一个节点交换位置来移除最高优先级的节点（[图
    7-7](#figure7-7)(b)），有效地将最后一个元素作为新的根节点。然而，这种将新根节点“晋升”到最高位置的操作几乎注定会经不起考验。在数组实现中，这相当于交换数组中的第一个元素和最后一个元素。这一交换填补了删除第一个元素后，数组前端产生的空缺，从而保持了数组的紧凑性。
- en: Next, the original max value of 98, which is currently the last element in the
    tree, is deleted as in [Figure 7-7](#figure7-7)(c). We have now deleted the correct
    node, but likely broken the heap property in the process. We may have moved a
    low-urgency package all the way to the front of the warehouse.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，原本的最大值98（目前是树中的最后一个元素）按照[图 7-7](#figure7-7)(c)所示被删除。我们现在已经删除了正确的节点，但在此过程中可能破坏了堆的性质。我们可能将一个低优先级的包裹移动到了仓库的最前面。
- en: '![Node 98 is removed from the heap by first swapping it with the last element
    (23). The new root bubbles down the heap by swapping with the larger of its two
    children. In the first step, node 23 is compared with 95 and 50 and then swapped
    with 95.](image_fi/502604c07/f07007.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![节点98通过先与最后一个元素（23）交换位置被移除。新根节点通过与其两个子节点中的较大者交换，逐步向下沉降。在第一步中，节点23与95和50进行比较，然后与95交换位置。](image_fi/502604c07/f07007.png)'
- en: 'Figure 7-7: Removing the highest-priority element from a heap'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-7：从堆中移除最高优先级元素
- en: To fix the heap property, we start at the new (incorrect) root node of 23 and
    walk down the tree, restoring the heap property at every level. The incorrectly
    placed package is shifted one row at a time toward the back of the warehouse,
    the opposite of an added package’s shifting forward row by row. Admittedly, this
    traversal isn’t as exciting as moving an urgent package to the front of the line,
    but it’s for the good of the heap structure. At each level, we compare our moving
    package’s priority to that of both its children, the two packages in the next
    row ([Figure 7-7](#figure7-7)(d)). If it’s smaller than either of its children,
    we move the new root node backward to restore the heap property by swapping places
    with the larger of its two children ([Figure 7-7](#figure7-7)(e)). This represents
    the package’s higher-priority successor moving forward to take its place.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复堆的性质，我们从新的（错误的）根节点23开始，沿着树向下走，在每一层恢复堆的性质。错误放置的包裹被一层一层地移动到仓库的后面，正好与新增包裹一层一层向前移动相反。诚然，这一遍历过程没有将紧急包裹推到队首那样令人兴奋，但这是为了堆结构的完整性。在每一层，我们将正在移动的包裹的优先级与其两个子节点的优先级进行比较（即下一行中的两个包裹，[图
    7-7](#figure7-7)(d)）。如果它比任何一个子节点都小，我们就将新的根节点向后移动，通过与其两个子节点中较大的那个交换位置来恢复堆的性质（[图
    7-7](#figure7-7)(e)）。这表示包裹的更高优先级的继任者向前移动，取代它的位置。
- en: The downward swaps terminate when there are no larger children. [Figure 7-7](#figure7-7)(f)
    shows a comparison made when the current node is in the correct position. The
    heap property has been restored, and all the nodes are satisfied with their relative
    position. [Figure 7-7](#figure7-7)(g) shows the final heap, once the removal is
    complete.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 向下交换在没有更大的子节点时终止。[图7-7](#figure7-7)(f)展示了当前节点处于正确位置时的比较。堆属性已恢复，所有节点都满足它们相对的位置。[图7-7](#figure7-7)(g)展示了移除完成后的最终堆。
- en: While fixing the location for the root node, we follow a single path down the
    tree, checking and restoring the heap property for only the descendant branch
    where we made the swap. There is no need to check the other branch. It is already
    guaranteed to maintain the heap property since we haven’t done anything to break
    it. Again, this means that, in the worst case, we need to make log[2](*N*) swaps.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在固定根节点的位置时，我们沿着树向下遍历，检查并恢复仅在我们进行交换的后代分支上的堆属性。无需检查另一分支，因为我们没有做任何破坏堆属性的操作。再次说明，这意味着在最坏的情况下，我们需要进行log[2](*N*)次交换。
- en: 'Here’s the code for removing the max element:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是移除最大元素的代码：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code starts by checking that the heap is not empty ❶. If it is, there is
    nothing to return. The code then swaps the first element (`index == 1`) with the
    last element (`index == heap.last_index`), breaking the heap property to prepare
    the max element for removal ❷. The code then uses a `WHILE` loop to traverse down
    the heap in a series of comparisons, repairing the heap property ❸. During each
    iteration, it compares the current value to both children and swaps with the larger
    one if necessary ❻. We must add additional checks ❹ ❺ to ensure that the code
    is only comparing the current value to an existing child. We don’t want it to
    try to compare against an entry that is past the array’s last valid index. The
    loop terminates when it has hit the bottom of the heap or has gone an iteration
    without a swap (via the `break` statement).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先检查堆是否为空❶。如果为空，则没有元素可返回。然后，代码将第一个元素（`index == 1`）与最后一个元素（`index == heap.last_index`）交换，破坏堆属性以准备移除最大元素❷。接着，代码使用`WHILE`循环，通过一系列比较向下遍历堆，修复堆属性❸。在每次迭代中，代码将当前值与两个子节点进行比较，必要时与较大的子节点交换❻。我们需要添加额外的检查❹❺，以确保代码仅将当前值与现有子节点进行比较。我们不希望它尝试与数组的最后有效索引之后的条目进行比较。当遍历到底部或没有发生交换时（通过`break`语句），循环终止。
- en: Storing Auxiliary Information
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储辅助信息
- en: Much of the time, we need our heap to store additional information for each
    entry. In our task list, for example, we need to store information about the tasks
    to be done, not just their priority. It doesn’t help us to know that we need to
    do the priority = 99 task next, if we don’t know what that task is. We might as
    well just scan through the original list manually.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，我们需要堆为每个条目存储额外的信息。例如，在我们的任务列表中，我们需要存储关于任务的信息，而不仅仅是它们的优先级。如果我们不知道任务的具体内容，仅仅知道优先级=99的任务下一个需要做，也没有帮助。我们还不如手动扫描原始列表。
- en: 'Augmenting the heap to store composite data structures or objects, such as
    a `TaskRecord`, is simple:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展堆以存储复合数据结构或对象（如`TaskRecord`）很简单：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We modify the previous code to handle comparisons based on the priority field
    of this composite record. We could do this by directly modifying the code (such
    in the `HeapInsert` function):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改了之前的代码，以根据这个复合记录的优先级字段进行比较。我们可以通过直接修改代码来实现这一点（例如在`HeapInsert`函数中）：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, this requires us to potentially specialize the heap implementation
    to the particular composite data structure. A cleaner approach is to add a composite
    data structure specific helper function, such as:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这要求我们可能需要将堆实现专门化为特定的复合数据结构。一个更清晰的方法是添加一个特定于复合数据结构的辅助函数，例如：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We’d use this function instead of the mathematical less-than sign in the code
    for `HeapInsert`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会在`HeapInsert`代码中使用这个函数，而不是使用数学的小于号：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Similarly, we would modify the comparisons in the `HeapRemoveMax` function to
    use the helper function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将修改`HeapRemoveMax`函数中的比较，使其使用辅助函数。
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These small changes allow us to build heaps from composite data structures.
    As long as we can define an `IsLessThan` function to order the elements, we can
    build an efficient priority queue for them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些小的变化使我们能够从复合数据结构构建堆。只要我们能够定义一个`IsLessThan`函数来排序元素，就可以为它们构建一个高效的优先队列。
- en: Updating Priorities
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新优先级
- en: 'Some use cases might demand another mode of dynamic behavior: allowing the
    algorithm to update the priorities of elements within the priority queue. Consider
    a bookstore database that prioritizes which books to restock by the number of
    patrons who have requested each title. The system builds the heap over an initial
    list of books and uses that to determine which title to order next. But, after
    a popular blog article points out the vital importance of data structures in computational
    thinking, the store suddenly sees a dramatic—though entirely understandable—increase
    in patrons requesting books about data structures. Its priority queue must be
    equipped to handle this sudden influx.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一些使用场景可能要求动态行为的另一种模式：允许算法更新优先队列中元素的优先级。考虑一个书店数据库，通过每本书被顾客请求的数量来确定优先补货的书籍。系统首先构建一个堆，并利用它来确定下一步要订购的书籍。然而，在一篇流行的博客文章指出数据结构在计算思维中的重要性之后，书店突然看到顾客请求有关数据结构的书籍的数量激增。它的优先队列必须能够应对这一突如其来的变化。
- en: To meet this need, we use the same approaches we applied to addition and removal.
    When we change an item’s value, we check whether we are increasing or decreasing
    the priority. If we are increasing the item’s value, we need to bubble the item
    up the max heap in order to restore the heap property. Similarly, if we are decreasing
    the item’s value, we let it sink down the max heap into its rightful position.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这一需求，我们采用与添加和移除时相同的方法。当我们更改某个元素的值时，我们需要检查是提高优先级还是降低优先级。如果我们是在增加元素的值，则需要将该元素“冒泡”到最大堆中，以恢复堆的性质。同样地，如果我们是在降低元素的值，则让它“下沉”到最大堆中，直到到达正确的位置。
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can even break out the code for letting elements bubble up or sink down so
    that the exact same code can be used for updating as for addition and removing
    the max.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以将代码提取出来，使得“冒泡”或“下沉”的操作能够复用，以便在更新时与添加或移除最大值时使用相同的代码。
- en: How do we find the element we want to update in the first place? As mentioned,
    heaps aren’t optimized for finding specific elements. If we have no information
    on our element of interest other than its value, we might need to search through
    a substantial portion of the array to find it. Often, we can solve this problem
    by using a secondary data structure, such as a hash table (discussed in Chapter
    10), to map from the item’s key to its element in the heap. In the example in
    this section, we assume that the program already has the item’s current index.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何找到我们要更新的元素呢？如前所述，堆并不是为了查找特定元素而优化的。如果我们除了元素的值外对其没有其他信息，我们可能需要搜索数组的相当一部分才能找到它。通常，我们可以通过使用一个辅助数据结构，例如哈希表（第10章讨论），来解决这个问题，将元素的键映射到堆中的元素。在本节的示例中，我们假设程序已经有该元素的当前索引。
- en: Min Heaps
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小堆
- en: So far, we have focused on the max heap, which uses the property that the value
    at any node in the tree is larger than (or equal to) the values of its children.
    The *min heap* is a version of the heap that facilitates finding the item with
    the lowest value. With a min heap, the root of the tree is the smallest value,
    allowing us to easily find the item with the lowest score. For example, instead
    of ordering network packets by priority, we might want to sort them by arrival
    time, processing packets with an earlier time of arrival before packets received
    more recently. More importantly, if we run out of space on our coffee shelf, we’ll
    need to remove our least favorite brand. After a gut-wrenching internal debate
    on whether it would be better to increase the size of our coffee storage by discarding
    a shelf’s worth of plates or bowls rather than part with any of our precious coffee
    grounds, we instead decide to discard the lowest-ranked coffee. We consult our
    list of enjoyability scores for each coffee and select the one with the lowest
    value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直关注的是最大堆，它利用树中任何节点的值都大于（或等于）其子节点的值这一特性。*最小堆*是堆的一种变体，便于找到值最小的元素。在最小堆中，树的根节点是最小值，从而使我们能够轻松找到最低得分的元素。例如，我们可能不仅仅按照优先级对网络数据包进行排序，而是希望按到达时间进行排序，先处理到达时间较早的包，再处理较晚接收的包。更重要的是，如果我们咖啡架上的空间用完了，我们就需要移除我们最不喜欢的品牌。在一番内心深处的痛苦辩论后，我们决定不通过丢弃一架盘子或碗来扩展咖啡存储空间，而是选择丢掉排名最低的咖啡。我们查阅每种咖啡的可享受评分，并选择其中分数最低的。
- en: We could, in theory, continue to use a max heap by just negating the values.
    However, a cleaner strategy is to make a minor tweak to our heap property and
    solve the problem outright. The *min heap property* is that the value at any node
    in the tree is smaller than (or equal to) the values of its children. An example
    min heap is shown in [Figure 7-8](#figure7-8). When we insert new elements, the
    ones with the lowest score bubble up the hierarchy. Similarly, we always extract
    and return the element with the lowest score.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![A min heap represented both as an array and as a tree with arrows indicating
    where each node sits in the array. The root node 10 corresponds to the first element
    in the array. The node’s two children, 23 and 17, are the second and third elements
    of the array.](image_fi/502604c07/f07008.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-8: The min heap’s position corresponds to index locations.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the algorithms for adding and removing elements in the min heap
    need to be modified accordingly. For insertion, we change the comparison function
    in the `WHILE` loop to check whether the parent value is greater than the current
    value:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The majority of the code is identical to that for insertion into a max heap.
    The only change is to replace `<` with `>` when comparing a node to its parent
    ❶.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'We make a similar change for the two comparisons during the removal operation:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, the only changes are replacing `<` with `>` when determining whether to
    swap nodes ❶ ❷.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Heapsort
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Heaps are powerful data structures across a range of computer science tasks,
    not limited to implementing priority queues and efficiently returning the next
    item in a prioritized list. Another exciting lens through which to view heaps,
    and data structures in general, is in terms of the novel algorithms that they
    enable. J. W. J. Williams initially proposed heaps themselves in the context of
    a new algorithm to sort arrays: *heapsort*.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'As its name implies, heapsort is an algorithm for sorting a list of items using
    the heap data structure. The input is an unsorted array. The output is an array
    containing those same elements, but in *decreasing* sorted order (for a max heap).
    At its core, heapsort consists of two phases:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Building a max heap from all the items
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extracting all the items from the heap in decreasing sorted order and storing
    them in an array
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s that simple.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the heapsort code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code consists of two `WHILE` loops. The first one inserts each item into
    a temporary heap ❶. The second loop removes the largest element using the `HeapRemoveMax`
    function and adds it to the next position in the array ❷. Alternatively, we can
    implement heapsort to produce an answer in *increasing* sorted order by using
    a min heap and `HeapRemoveMin`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to sort the following array: `[46, 35, 9, 28, 61, 8, 38, 40]`
    in decreasing order. We start by inserting each of these values into our heap.
    [Figure 7-9](#figure7-9) shows the final arrangement of the array (and its equivalent
    tree representation) after the insertion. Remember that we always begin by inserting
    new items at the back of the array, then swap them forward until the heap property
    is restored. In [Figure 7-9](#figure7-9), arrows represent the new element’s path
    through the array to its final position. The tree representation is also shown,
    with shading indicating the nodes that have been modified.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要按递减顺序排序以下数组：`[46, 35, 9, 28, 61, 8, 38, 40]`。我们首先将这些值逐个插入到堆中。[图 7-9](#figure7-9)展示了插入后的最终数组排列（以及相应的树形表示）。请记住，我们总是从数组的末尾开始插入新元素，然后将它们交换到前面，直到堆的性质被恢复。在[图
    7-9](#figure7-9)中，箭头表示新元素通过数组的路径，直到它达到最终位置。树形表示也有展示，阴影表示已被修改的节点。
- en: '![An illustration showing each of the eight insertions during the first stage
    of heapsort, both in an array and in a tree. The numbers 46, 35, 9, and 28 are
    all inserted without swaps. When 61 is inserted at the top of the tree and front
    of the array, it swaps position first with 35 and then 46 to become the new root
    node.](image_fi/502604c07/f07009.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![一张插图展示了堆排序第一阶段中的八次插入过程，包括数组和树的表示。46、35、9和28在没有交换的情况下被插入。当61插入到树的顶部和数组的前端时，它首先与35交换位置，然后与46交换，成为新的根节点。](image_fi/502604c07/f07009.png)'
- en: 'Figure 7-9: The first stage of heapsort where elements in the unsorted array
    are added to the heap one at a time'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-9：堆排序的第一阶段，其中未排序的数组中的元素一个一个地被添加到堆中
- en: We bound the runtime of creating the heap using the worst-case runtime of a
    single insertion. As we saw earlier in the chapter, in the worst case, inserting
    a new item into a heap containing *N* items can scale proportional to log[2](*N*).
    Thus, to construct a heap out of *N* items, we bound the worst-case runtime as
    proportional to *N*log[2](*N*).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过单次插入的最坏情况运行时间来界定创建堆的运行时间。正如我们在本章早些时候看到的那样，在最坏情况下，将一个新元素插入到包含*N*个元素的堆中，所需时间与log[2](*N*)成比例。因此，构建一个包含*N*个元素的堆时，最坏情况的运行时间是与*N*log[2](*N*)成比例的。
- en: Now that we’ve built our heap, we proceed to the second stage and extract each
    item, as shown in [Figure 7-10](#figure7-10).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了堆，接下来进入第二阶段，逐个提取每个元素，如[图 7-10](#figure7-10)所示。
- en: '![An illustration showing each of the removals during the second stage of heapsort,
    both in an array and in a tree. During the first removal, the node 61 is removed,
    46 is swapped into its place, 40 is swapped into 46’s former place, and 28 is
    promoted into 40’s former place.](image_fi/502604c07/f07010.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![一张插图展示了堆排序第二阶段中每次移除元素的过程，包括数组和树的表示。在第一次移除中，节点61被移除，46被交换到它的位置，40被交换到46原来的位置，28被提升到40原来的位置。](image_fi/502604c07/f07010.png)'
- en: 'Figure 7-10: The second stage of heapsort, where the maximal element is repeatedly
    removed from the heap with each iteration'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-10：堆排序的第二阶段，其中最大元素在每次迭代中被重复从堆中移除
- en: We remove the items from the heap one by one in order of decreasing priority.
    This is what produces the decreasing sorted order. At each step, the root is extracted,
    the last item in the heap is swapped to the root’s position, and then the new
    root sinks back down into a position that restores the heap property. The figure
    shows the state of the array (and the equivalent tree representation) at the end
    of each iteration. The arrows in the diagrams and the shaded nodes illustrate
    the overpromoted node’s journey down though the heap. As we extract the items,
    we add them directly to the array storing our result. Once we have emptied the
    heap, we throw it away. It has served its purpose.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照优先级递减的顺序逐个从堆中移除元素。这就是产生递减排序顺序的原因。在每一步中，根节点被提取出来，堆中的最后一个元素被交换到根节点的位置，然后新的根节点下沉，直到恢复堆的性质。图中展示了每次迭代结束时数组（以及相应的树形表示）的状态。图中的箭头和阴影节点表示过度提升的节点在堆中的下降过程。当我们提取元素时，会直接将它们添加到存储结果的数组中。一旦堆被清空，我们就丢弃它，它已经完成了它的任务。
- en: As with the insertions, we can bound the worst-case runtime as proportional
    to *N*log[2](*N*). Each extraction requires at most log[2](*N*) to restore the
    heap property, and we need to extract all *N* items for our sorted list. Thus,
    the total worst-case runtime of the heapsort algorithm is proportional to *N*log[2](*N*).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与插入操作类似，我们可以将最坏情况下的运行时间界定为与*N*log[2](*N*)成正比。每次提取最多需要log[2](*N*)的时间来恢复堆的性质，而我们需要提取所有*N*个元素以得到排序后的列表。因此，堆排序算法的总最坏情况下的运行时间与*N*log[2](*N*)成正比。
- en: Why This Matters
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么这很重要
- en: Heaps are a simple variation of binary trees that allow a different set of computationally
    efficient operations. By changing the binary search tree property into the heap
    property, we can change the behavior of the data structure and support a different
    set of operations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是一种简单的二叉树变种，它允许一组不同的高效计算操作。通过将二叉查找树的性质改为堆的性质，我们可以改变数据结构的行为，并支持一组不同的操作。
- en: Both addition of new elements and deletion of the maximum element require us
    to walk at most one path between the top and bottom of the tree. Since we can
    approximately double the number of nodes in a heap while adding only a single
    level of new nodes to the bottom, even large heaps allow speedy operations. Doubling
    the number of nodes in this way adds only one additional iteration to insertion
    and deletion! Furthermore, both operations guarantee that the tree remains balanced
    so that future operations will be efficient.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 新元素的添加和最大元素的删除都要求我们最多遍历树的顶部和底部之间的路径。由于我们可以通过仅在底部添加一层新节点来大致翻倍堆中的节点数量，甚至大型堆也能保证操作迅速。以这种方式翻倍节点数量只会使插入和删除操作增加一个额外的迭代！此外，这两个操作还保证了树保持平衡，从而使得未来的操作保持高效。
- en: 'However, there’s always a tradeoff: by moving from the binary search tree property
    to the heap property, we can no longer efficiently search for a specific value.
    Optimizing for one set of operations often prevents us from optimizing from others.
    We need to think carefully about how we will use the data and design its structure
    accordingly.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，总是存在权衡：从二叉查找树的性质转变为堆的性质后，我们将无法高效地查找特定的值。优化一种操作集常常会妨碍我们优化其他操作。我们需要仔细考虑如何使用数据，并相应地设计其结构。
