- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Priority Queues and Heaps
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列与堆
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: '*Priority queues* are a class of data structures that retrieve items ordered
    by given scores for each item. Whereas both stacks and queues from Chapter 4 depended
    solely on the order in which data was inserted, priority queues use an additional
    piece of information to determine the retrieval order—the item’s priority. As
    we will see, this new information allows us to further adapt to the data and,
    among other useful applications, allows us to process urgent requests first.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*优先队列*是一类根据每个项的给定分数来检索排序项的数据结构。而在第4章中，栈和队列仅依赖于数据插入的顺序，优先队列则使用额外的信息来确定检索顺序——项的优先级。正如我们将看到的，这一新信息使我们能够进一步适应数据，并且在许多有用的应用中，比如优先处理紧急请求，发挥重要作用。'
- en: For example, imagine a new coffee shop, Dynamic Selection Coffee, has opened
    in your neighborhood. Bursting with excitement, you venture into the store and
    see 10 types of coffee beans you’ve never sampled. Before diving in and trying
    them, you spend the next hour carefully charting the relative merits of each new
    brand based on their woefully inadequate menu descriptions, leaving you with a
    ranked list of coffees to try. You select the most promising brand from the top
    of the list, purchase it, and go home to savor the experience.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你所在的社区开了一家新的咖啡店——动态选择咖啡店。兴奋不已的你走进店里，看到有10款你从未尝试过的咖啡豆。在投入尝试之前，你花了一个小时仔细研究每个新品牌的相对优缺点，根据它们那份极其简陋的菜单描述，列出了一份排名咖啡清单。你从榜单顶部选择了最有前景的品牌，购买了它，并带回家享受这次体验。
- en: The next day, you return to Dynamic Selection Coffee to try the second item
    on your list, only to find they’ve added another two coffees to the menu. When
    you ask the barista why they’ve made this change, they point to the shop’s sign,
    which explains that Dynamic Selection Coffee serves a constantly expanding selection
    of coffees. Their goal is to eventually serve over a thousand varieties. You are
    at once thrilled and terrified. Every day you will need to prioritize the new
    coffees and insert them into your list so that you know which coffee to try next.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第二天，你又回到动态选择咖啡店，准备尝试你列表中的第二款咖啡，却发现他们在菜单上又新增了两款咖啡。当你问咖啡师为什么做出这个改变时，他们指向店里的招牌，解释说动态选择咖啡店提供的是一个不断扩展的咖啡选择，目标是最终提供超过一千种咖啡。你既兴奋又害怕，每天你都需要优先排序这些新咖啡，并将它们插入到你的列表中，这样你就知道下一次该尝试哪款咖啡。
- en: 'The task of retrieving items from a prioritized list is one that pops up regularly
    in computer programs: given a list of items and associated priorities, how can
    we efficiently retrieve the next item in priority order? Often, we need to do
    this retrieval in a dynamic context where new items arrive all the time. We might
    need to choose which network packet to process based on priority, offer the best
    suggestion in spellcheck based on common spelling errors, or choose the next option
    in a best-first search. In the real world, we might use our own mental priority
    queues to decide which urgent task to perform next, which movie to watch, or which
    patient to see first in a crowded emergency room. Once you start looking, prioritized
    retrievals are everywhere.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从优先列表中检索项的任务在计算机程序中经常出现：给定一个项列表及其相关的优先级，如何高效地按优先顺序检索下一个项？通常，我们需要在一个动态的环境中进行检索，因为新的项不断加入。我们可能需要根据优先级选择处理哪个网络数据包，基于常见拼写错误提供拼写检查的最佳建议，或者在最佳优先搜索中选择下一个选项。在现实生活中，我们可能会使用自己的心理优先队列来决定下一个要执行的紧急任务、观看哪部电影，或者在拥挤的急诊室中首先看哪位病人。一旦你开始留意，优先检索随处可见。
- en: 'In this chapter, we introduce the priority queue, a class of data structures
    for retrieving prioritized items from a set, and then discuss the most common
    data structure for implementing this useful tool: the heap. Heaps make the central
    operations for a priority queue extremely efficient.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了优先队列，这是一类用于从集合中检索优先项的数据结构，然后讨论了实现这一有用工具的最常见数据结构：堆。堆使得优先队列的核心操作变得非常高效。
- en: Priority Queues
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先队列
- en: Priority queues store a set of items and enable the user to easily retrieve
    the item with the highest priority. They are dynamic, allowing insertions and
    retrievals to be intermixed. We need to be able to add and remove items from our
    prioritized task list. If we were stuck using a fixed data structure, the author
    might spend the day consulting his static list and repeatedly performing the highest-priority
    task of “Get morning coffee.” Without the ability to remove that task after it
    was accomplished, it would stay at the top of the author’s list. While this might
    make for an enjoyable day, it is unlikely to be a productive one.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级队列存储一组项目，并使用户能够轻松检索具有最高优先级的项目。它们是动态的，允许插入和检索操作交替进行。我们需要能够从我们的优先任务列表中添加和删除项目。如果我们被迫使用固定的数据结构，作者可能会花一整天查看他那静态的列表，并一遍又一遍地执行“去拿早晨的咖啡”这一最高优先级任务。如果在完成任务后无法将其移除，它将一直留在作者的列表顶部。虽然这可能让人享受一天的时光，但不太可能是高效的一天。
- en: 'In their most basic form, priority queues support a few primary operations:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的形式下，优先级队列支持几个主要操作：
- en: Add an item and its associated priority score.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个项目及其相关的优先级分数。
- en: Look up the item with the highest priority (or null if the queue is empty).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找具有最高优先级的项目（如果队列为空，则为null）。
- en: Remove the item with the highest priority (or null if the queue is empty).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除具有最高优先级的项目（如果队列为空，则为null）。
- en: We can also add other useful functions that allow us to check whether a priority
    queue is empty or to return the number of items currently stored.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加其他有用的功能，允许我们检查优先级队列是否为空，或者返回当前存储的项目数量。
- en: We set the items’ priorities according to the problem at hand. In some cases,
    the priority values might be obvious or determined by the algorithm. When processing
    network requests, for example, each packet might come with an explicit priority,
    or we might choose to process the oldest request first. Deciding what to prioritize
    isn’t always a simple endeavor, however. When prioritizing which brand of coffee
    to try next, we might want to create a priority based on price, availability,
    or caffeine content—it depends on how we plan to use our priority queue.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据当前的问题设定项目的优先级。在某些情况下，优先级值可能很明显，或者由算法决定。例如，在处理网络请求时，每个数据包可能带有显式的优先级，或者我们可能选择首先处理最旧的请求。然而，决定优先处理什么并不总是一个简单的任务。当我们优先考虑尝试哪种品牌的咖啡时，我们可能想根据价格、可用性或咖啡因含量来创建优先级——这取决于我们打算如何使用我们的优先级队列。
- en: It’s possible, but not ideal, to implement priority queues with primitive data
    structures like sorted linked lists or sorted arrays, adding new items into the
    list according to their priority. [Figure 7-1](#figure7-1) shows an example of
    adding the value 21 into a sorted linked list.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像排序链表或排序数组这样的原始数据结构实现优先级队列是可能的，但并不理想，我们需要根据优先级将新项目添加到列表中。[图 7-1](#figure7-1)展示了将值21添加到排序链表中的示例。
- en: '![A linked list before and after the addition of an eighth element into the
    middle of the list where values are in decreasing order. The head of the list
    has the value 50, and the end of the list has value 9\. Value 21 is inserted between
    value 28 and value 15.](image_fi/502604c07/f07001.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![一个链表，在向列表中间添加第八个元素后，列表的值按降序排列。列表的头部值为50，列表的尾部值为9。值21插入在值28和值15之间。](image_fi/502604c07/f07001.png)'
- en: 'Figure 7-1: Adding an element (21) into a sorted linked list representing a
    priority queue'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1：将元素（21）添加到表示优先级队列的排序链表中
- en: A sorted linked list keeps the highest-priority item at the front of the list
    for easy lookup. In fact, in this case, a lookup takes constant time regardless
    of the length of the priority queue—we just look at the first element. Unfortunately,
    adding new elements can be expensive. We might need to traverse the entire list
    each time we add a new item, costing us time proportional to the length of the
    priority queue.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 排序链表将最高优先级的项目保持在列表的前端，以便于查找。实际上，在这种情况下，查找只需要常数时间，无论优先级队列的长度如何——我们只需查看第一个元素。不幸的是，添加新元素可能是昂贵的。每次我们添加一个新项目时，可能需要遍历整个列表，这会花费与优先级队列长度成正比的时间。
- en: 'The author uses a real-world version of this sorted-list approach to organize
    his refrigerator, storing items front-to-back in order of increasing expiration
    date. The closest item is always the highest priority, the one that will expire
    the soonest. Retrieving the correct item is easy—just grab whatever is in front.
    This scheme is particularly beneficial when storing milk or cream for morning
    coffee: no one wants to spend the first few bleary moments of the morning reading
    expiration dates. However, inserting new items behind old ones can take time and
    require an annoying amount of shifting.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 作者使用这种排序列表的方法来整理冰箱，将物品按过期日期从前到后存储。最靠近的物品始终具有最高的优先级，即将要最先过期的物品。取出正确的物品非常简单——只需拿出最前面的那个。这种方案对于存储牛奶或咖啡用的奶油特别有利：没有人愿意在早晨昏昏欲睡时查看过期日期。然而，将新物品放在旧物品后面可能需要时间，并且需要烦人的移动。
- en: Similarly, we could maintain the priority queue in an *unsorted* linked list
    or array. New additions are trivial—just tag the element onto the back of the
    list, as illustrated in [Figure 7-2](#figure7-2).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以在 *未排序* 的链表或数组中维护优先队列。新的元素添加非常简单——只需将元素标记到列表的末尾，如[图 7-2](#figure7-2)所示。
- en: '![An unsorted array before and after the addition of the eighth element. The
    value 21 is added to the end of the unsorted array after the value 39.](image_fi/502604c07/f07002.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![未排序数组在添加第八个元素之前和之后的状态。值 21 被添加到值 39 后面，成为未排序数组的末尾。](image_fi/502604c07/f07002.png)'
- en: 'Figure 7-2: Adding an element (21) into an unsorted array representing a priority
    queue'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-2：将元素（21）添加到表示优先队列的未排序数组中
- en: Unfortunately, we now pay a high cost in looking up the next element. We must
    scan the entire list in order to determine which element has the highest priority.
    If we are removing it, we also shift everything over to fill in the gap. This
    approach corresponds to scanning the full set of items in the author’s fridge
    to find whichever is closest to expiring. This might work for a fridge with just
    a few milk cartons, but imagine the overhead of picking through every single item
    of food or drink in a large grocery store.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们现在在查找下一个元素时需要付出很高的代价。我们必须扫描整个列表，以确定哪个元素具有最高的优先级。如果我们要删除该元素，还需要将其他元素移动，以填补空缺。这种方法就像作者在冰箱里扫描所有物品，以找到哪个最接近过期。这对于冰箱里只有几盒牛奶的情况或许有效，但想象一下在大型超市里逐一检查每个食物或饮料的成本。
- en: Implementing priority queues as sorted lists may work better than using unsorted
    lists or vice versa, depending on how we plan to use the priority queue. If additions
    are more common than lookups, we prefer the unsorted list. If lookups are more
    common, we should pay the cost of keeping the elements sorted. In the case of
    refrigerators, lookups are much more common—we pick up a single carton of milk
    to use it more often than we buy a new carton, so it pays to keep the milk in
    sorted order. The challenge arises when both additions and lookups are common;
    prioritizing one operation over the other will lead to overall inefficiency, so
    we need a method that balances their costs. A clever data structure, the heap,
    helps us solve this problem.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将优先队列实现为排序列表可能比使用未排序列表更有效，反之亦然，这取决于我们打算如何使用优先队列。如果添加操作比查找操作更常见，我们会偏好使用未排序列表。如果查找操作更常见，我们则需要承受保持元素排序的成本。在冰箱的例子中，查找操作要常见得多——我们取出一盒牛奶使用的频率远高于购买新盒牛奶的频率，因此保持牛奶的排序是有益的。问题出现在当添加操作和查找操作都很常见时；优先处理一个操作会导致整体效率低下，因此我们需要一种平衡两者成本的方法。一个巧妙的数据结构——堆，可以帮助我们解决这个问题。
- en: Max Heaps
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最大堆
- en: A *max heap* is a variant of the binary tree that maintains a special ordered
    relationship between a node and its children. Specifically, a max heap stores
    the elements according to the *max heap property*, which states that the value
    at any node in the tree is larger than or equal to the values of its child nodes.
    For simplicity’s sake, we will often use the more general terms *heaps* and *heap
    property* to refer to max heaps and the max heap property throughout the remainder
    of the chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*最大堆* 是二叉树的一种变体，它在节点和其子节点之间保持一种特殊的有序关系。具体来说，最大堆根据 *最大堆性质* 存储元素，该性质规定树中任何节点的值都大于或等于其子节点的值。为了简便起见，接下来的章节中我们将经常使用更一般的术语
    *堆* 和 *堆性质* 来指代最大堆和最大堆性质。'
- en: '[Figure 7-3](#figure7-3) shows a representation of a binary tree organized
    according to the max heap property.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-3](#figure7-3) 显示了一个按照最大堆性质组织的二叉树的表示。'
- en: '![The binary tree for a heap starts with the largest element (99) at the root
    with two children 67 and 97\. For any node, the values of both the left and right
    children are less than or equal to the value of the node itself.](image_fi/502604c07/f07003.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![堆的二叉树从根节点（99）开始，根节点有两个子节点67和97。对于任何节点，左右子节点的值都小于或等于节点本身的值。](image_fi/502604c07/f07003.png)'
- en: 'Figure 7-3: A heap represented as a binary tree'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-3：堆作为二叉树的表示
- en: There’s no special preference or ordering between the left and right children,
    aside from their being lower priority than their parent. For comparison, imagine
    an elite coffee lover’s mentorship program, the Society for the Improvement of
    Coffee-Related Knowledge. Each member (node) agrees to mentor up to two other
    coffee lovers (child nodes). The only condition is that each of the mentees must
    not know more about coffee than their mentor does—otherwise, the mentorship would
    be a waste.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 左右子节点之间没有特殊的优先级或顺序，除了它们的优先级低于父节点。为了做个比较，想象一个精英咖啡爱好者的导师计划——咖啡相关知识提升协会。每个成员（节点）同意指导最多两个其他咖啡爱好者（子节点）。唯一的条件是，每个受导师指导的人必须比导师了解的咖啡知识少——否则，导师计划将毫无意义。
- en: 'Computer scientist J. W. J. Williams originally invented heaps as a component
    of a new sorting algorithm, heapsort, which we’ll discuss later in the chapter.
    However, he recognized that heaps are useful data structures for other tasks.
    The max heap’s simple structure allows it to efficiently support the operations
    required for priority queues: (1) allowing a user to efficiently look up the largest
    element, (2) removing the largest element, and (3) adding an arbitrary element.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家J. W. J. Williams最初发明堆作为新排序算法堆排序的一部分，我们将在本章后面讨论。然而，他意识到堆作为数据结构在其他任务中也很有用。最大堆的简单结构使得它能够高效地支持优先队列所需的操作：（1）允许用户高效查找最大元素，（2）删除最大元素，以及（3）添加任意元素。
- en: Heaps are often visualized as trees but are often implemented with arrays for
    efficiency. In this chapter, we present these two representations in parallel
    to allow the reader to make mental connections between them. However, it is not
    required that we use arrays for implementation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 堆通常被可视化为树形结构，但为了提高效率，它们通常使用数组实现。在本章中，我们并行展示这两种表示方法，以帮助读者在它们之间建立心理联系。然而，使用数组进行实现并不是必须的。
- en: In the array-based implementation, each element in the array corresponds to
    a node in the tree with the root node at index 1 (we skip index 0 to stay consistent
    with common convention for heaps). Child node indexes are defined relative to
    the indexes of their parents, so a node at index *i* has children at indexes 2*i*
    and 2*i* + 1\. For example, the node at index 2 has a child at index 2 × 2 = 4
    and index 2 × 2 + 1 = 5, as shown in [Figure 7-4](#figure7-4).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于数组的实现中，数组中的每个元素对应树中的一个节点，根节点位于索引1（我们跳过索引0，以保持与堆的常见约定一致）。子节点的索引相对于其父节点的索引定义，因此位于索引*i*的节点的子节点位于索引2*i*和2*i*
    + 1。例如，索引为2的节点有两个子节点，分别位于索引2 × 2 = 4和索引2 × 2 + 1 = 5，如[图7-4](#figure7-4)所示。
- en: '![A heap represented both as an array and as a tree with arrows indicating
    where each node sits in the array. The root node 98 corresponds to the first element
    in the array. The node’s two children, 95 and 50, are the second and third elements
    of the array.](image_fi/502604c07/f07004.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![堆同时以数组和树的形式表示，箭头指示每个节点在数组中的位置。根节点98对应数组中的第一个元素。节点的两个子节点，95和50，是数组中的第二个和第三个元素。](image_fi/502604c07/f07004.png)'
- en: 'Figure 7-4: The heap’s position corresponds to index locations.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-4：堆的位置对应于索引位置。
- en: Similarly, we compute the index of a node’s parent as `Floor(i/2)`. The indexing
    scheme allows the algorithm to trivially compute the index of a child based on
    that of the parent, and the index of a parent based on its child.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们将一个节点的父节点的索引计算为`Floor(i/2)`。这种索引方案使得算法可以轻松地根据父节点的索引计算子节点的索引，反之亦然。
- en: The root node always corresponds to the maximum value in a max heap. Since we
    store the root node in a fixed spot in the array (index = 1), we can always find
    this maximum value in constant time. It’s just an array lookup. The layout of
    the data itself thus addresses one of the necessary priority queue operations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 根节点始终对应最大堆中的最大值。由于我们将根节点存储在数组中的固定位置（索引 = 1），我们可以始终在常数时间内找到这个最大值。这只是一个数组查找。数据本身的布局因此解决了优先队列所需的一个操作。
- en: Since we’ll be adding and removing arbitrary elements in our priority queue,
    in order to avoid constantly resizing the array, we want to preallocate an array
    that is large enough to accommodate the number of items we expect to add. Remember
    from Chapter 3 that dynamically resizing an array can be expensive, forcing us
    to create a new array and copy over the values, and in this case wasting the precious
    efficiency of the heap. Instead, we can initially allocate a large array, track
    the index of the last filled element of the array, and call that index the virtual
    end of the array. This allows us to append new elements by simply updating the
    index for the last element.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在优先队列中添加和移除任意元素，为了避免不断调整数组大小，我们希望预先分配一个足够大的数组来容纳我们预计要添加的元素数量。记住在第三章中提到的，动态调整数组大小可能非常昂贵，它迫使我们创建一个新的数组并复制数据，这样做会浪费堆的宝贵效率。相反，我们可以最初分配一个较大的数组，跟踪数组中最后一个填充元素的索引，并将该索引称为数组的虚拟末尾。这使得我们只需要通过更新最后一个元素的索引来添加新元素。
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Of course, the cost of this overallocation is a chunk of potentially unused
    memory if our heap doesn’t grow as large as expected.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种整体分配的代价是，如果我们的堆没有像预期那样增长，就可能会有一部分未使用的内存。
- en: Using an array to represent a tree-based data structure is an interesting step
    in its own right. We can use packed arrays and a mathematical mapping to represent
    a heap instead of relying on pointers, allowing us to store the heap with less
    memory. By maintaining a mapping from a node’s index to its children’s, we can
    re-create a tree-based data structure without the pointers. As we will see below,
    this array-based representation is feasible for heaps because the data structure
    always maintains a nearly complete and balanced tree. This results in a packed
    array with no gaps. While we could use the same array representation for other
    trees, such as binary search trees, those data structures often have gaps throughout
    and would require very large (and possibly mostly empty) arrays to store trees
    with deep branches.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组来表示基于树的数据结构本身就是一个有趣的步骤。我们可以使用打包数组和数学映射来表示堆，而不是依赖指针，这样可以减少堆的内存占用。通过维护节点索引与其子节点之间的映射关系，我们可以在不使用指针的情况下重建树形数据结构。正如我们下面将看到的那样，基于数组的表示对于堆来说是可行的，因为数据结构始终保持着几乎完整和平衡的树结构。这就产生了一个没有空隙的打包数组。虽然我们也可以使用相同的数组表示其他类型的树，如二叉搜索树，但这些数据结构通常会在整个结构中产生空隙，因此需要非常大的（并且可能大部分是空的）数组来存储深分支的树。
- en: Adding Elements to a Heap
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向堆中添加元素
- en: When adding a new element to a heap, we must ensure that the structure retains
    the heap property. Just as you would not assign a decorated general to report
    to a fresh lieutenant, you wouldn’t put a heap node with high priority under a
    low priority node. We must add the element to the heap’s tree structure such that
    all elements below the addition have a priority less than or equal to that of
    the new node. Similarly, all nodes above the new addition should have priorities
    that are greater than or equal to that of the new node.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当向堆中添加新元素时，我们必须确保结构保持堆的性质。就像你不会让一位装饰性的将军去报告给一位新任的中尉一样，你也不会把一个高优先级的堆节点放在低优先级的节点下方。我们必须将新元素添加到堆的树结构中，以确保所有新增元素下方的节点优先级都小于或等于新节点的优先级。同样，所有新节点上方的节点应当具有大于或等于新节点优先级的优先级。
- en: Part of the brilliance of the array implementation of a heap is that it retains
    this property while storing the nodes as a packed array. In previous chapters,
    adding nodes to the middle of an array was expensive, requiring us to shift later
    entries down. Fortunately, we don’t need to pay this linear cost each time we
    add a new element to a heap. Instead, we add elements by first breaking the heap
    property and then swapping elements along a single branch of the tree to restore
    it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 堆的数组实现的亮点之一是，它在以打包数组存储节点的同时保持了这个特性。在之前的章节中，将节点添加到数组的中间是昂贵的，需要我们将后面的元素向后移动。幸运的是，每次向堆中添加新元素时，我们不需要付出这种线性代价。相反，我们通过首先破坏堆的性质，再沿着树的单一路径交换元素来恢复堆的性质。
- en: In other words, to add a new element to the heap, we add it to the first empty
    space in the bottom level of the tree. If this new value is larger than the value
    of its parent node, we bubble it up the tree until it is smaller than or equal
    to its parent, restoring the heap property. The structure of the heap itself allows
    us to do this efficiently. In the array implementation of a heap, this corresponds
    to appending the new element to the back of the array and swapping it forward.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，向堆中添加一个新元素时，我们将它添加到树底层的第一个空位置。如果这个新值大于其父节点的值，我们就将其上浮，直到它小于或等于其父节点，从而恢复堆的性质。堆本身的结构使我们能够高效地完成这个操作。在堆的数组实现中，这对应于将新元素添加到数组的末尾，并将其向前交换。
- en: 'Consider the example in [Figure 7-5](#figure7-5), which shows the structure
    of the heap as both an array and a tree at each step. [Figure 7-5](#figure7-5)(a)
    shows the heap before the new element is added. In [Figure 7-5](#figure7-5)(b),
    we append the new element, 85, to the back of the array, effectively inserting
    it in the bottom of the tree. After the first comparison in [Figure 7-5](#figure7-5)(c),
    we swap the new element with its parent node, since 85 is greater than 50\. The
    swap is shown in [Figure 7-5](#figure7-5)(d). The second comparison, in [Figure
    7-5](#figure7-5)(e), reveals that the new node is now in the correct place in
    the hierarchy: 98 is greater than 85, so there is no need for the new node to
    switch with its parent a second time. [Figure 7-5](#figure7-5)(f) shows the heap
    after the addition is complete.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 [图 7-5](#figure7-5) 中的示例，该图展示了堆的结构，分别以数组和树的形式展示了每个步骤。 [图 7-5](#figure7-5)(a)
    显示了新元素添加之前的堆结构。在 [图 7-5](#figure7-5)(b) 中，我们将新元素 85 添加到数组的末尾，相当于将其插入到树的底部。在 [图
    7-5](#figure7-5)(c) 中的第一次比较之后，由于 85 大于 50，我们交换了新元素与其父节点的位置。交换操作如 [图 7-5](#figure7-5)(d)
    所示。第二次比较发生在 [图 7-5](#figure7-5)(e) 中，此时新节点已处于正确的位置：98 大于 85，因此不需要再与父节点交换。 [图 7-5](#figure7-5)(f)
    显示了添加操作完成后的堆结构。
- en: '![We start with the array from Figure 7‐4\. Node 85 is added to the end of
    the array and then bubbled up to the correct position. We first compare 85 with
    its parent 50 and swap them. In the next step, we compare 85 with its new parent
    98 and keep the ordering.](image_fi/502604c07/f07005.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![我们从图 7-4 中的数组开始。节点 85 被添加到数组的末尾，然后上浮到正确的位置。我们首先将 85 与它的父节点 50 进行比较，并交换它们。在下一步中，我们将
    85 与它的新父节点 98 进行比较，并保持顺序。](image_fi/502604c07/f07005.png)'
- en: 'Figure 7-5: Adding an element (85) to a heap'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-5：向堆中添加一个元素（85）
- en: 'The code for implementing this addition uses a single `WHILE` loop to progress
    up the levels of the heap until it has reached the root or found a parent larger
    than or equal to the new node’s value:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此添加操作的代码使用了一个单一的`WHILE`循环，逐层向上遍历堆，直到到达根节点或找到一个父节点的值大于或等于新节点的值：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since we are using an array to store the heap, the code starts by checking that
    it still has room in the array to add a new element ❶. If not, it increases the
    size of the heap, perhaps by applying the array-doubling technique described in
    Chapter 3. Next, the code appends the new element to the end of the array and
    updates the position of the last element ❷. The `WHILE` loop starts at the freshly
    added element ❸, progresses up each layer of the heap by comparing the current
    value to that of its parent ❹, and switching if necessary ❺. The loop terminates
    when we either reach the top of the heap (`parent == 0`) or find a parent greater
    than or equal to the child.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用数组来存储堆，代码首先会检查数组中是否还有空间来添加新元素 ❶。如果没有空间，它会增加堆的大小，可能通过应用第 3 章中描述的数组扩展技术。接下来，代码将新元素添加到数组的末尾，并更新最后一个元素的位置
    ❷。`WHILE` 循环从新添加的元素 ❸ 开始，逐层向上遍历堆，通过将当前值与其父节点的值进行比较 ❹，并在必要时交换 ❺。当我们到达堆的顶部（`parent
    == 0`）或找到一个大于或等于子节点的父节点时，循环终止。
- en: 'We might compare this process to an oddly designed, yet efficient, package
    distribution center as shown in [Figure 7-6](#figure7-6). The employees organize
    packages in neat rows on the floor using the heap property: in the front row is
    a single package with the highest priority, the next to be shipped. Behind that
    package sit two lower-priority packages. Behind each of these are two more packages
    (for a total of four in that row) such that each pair has priorities less than
    or equal to the corresponding package in front of them. With each new row, the
    number of packages doubles so that the arrangement spreads out wider and wider
    as you move toward the back of the warehouse. Each package has at most two lower-
    or equal-priority packages sitting behind it and at most one higher- or equal-priority
    package in front. Painted rectangles on the warehouse floor helpfully indicate
    the possible locations for packages in each of the rows.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这一过程比作一个奇特设计但高效的包裹分配中心，如[图 7-6](#figure7-6)所示。员工们将包裹按照堆的属性整齐地排列在地板上：最前排是一个具有最高优先级的包裹，即下一个要发货的包裹。在它后面坐着两个优先级较低的包裹。在这两个包裹后面分别是两个更多的包裹（这一排总共四个），每一对包裹的优先级都小于或等于其前面的包裹。每增加一排，包裹的数量就翻倍，因此，随着你向仓库后部移动，排列越来越宽广。每个包裹最多有两个优先级较低或相等的包裹坐在它的后面，最多有一个优先级较高或相等的包裹在它前面。仓库地板上的矩形标记帮助指示每一排中包裹的可能位置。
- en: '![A diagram showing rows of packages on a warehouse floor, with one package
    in the top row, two in the second row, four in the third, and eight in the fourth.
    The fifth and last row is not completely filled.](image_fi/502604c07/f07006.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![一张图显示了仓库地板上的一排排包裹，第一排一个包裹，第二排两个，第三排四个，第四排八个。第五排是最后一排，但没有完全填满。](image_fi/502604c07/f07006.png)'
- en: 'Figure 7-6: A warehouse floor organized as a heap'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-6：一个组织成堆的仓库地板
- en: New packages are brought in from the back of the warehouse. Each delivery person
    mumbles something about the weird sorting scheme, relieved that at least they
    don’t have to carry their package to the very front, drops the package in the
    frontmost available spot, and leaves as quickly as possible. The warehouse employees
    then spring into action, comparing the priority of the new package with the one
    immediately in front of it (ignoring the rest of the packages in that row). If
    they find an inversion, they switch the packages. Otherwise, they leave the package
    where it is. This continues until the new package occupies the appropriate place
    in the hierarchy, with the package in front of it having a higher or an equal
    priority. Since the packages are heavy and spread out, the employees minimize
    their work with at most one comparison and switch per row. They never shuffle
    packages within a row. After all, nobody wants to move boxes unnecessarily.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 新的包裹从仓库后部运入。每个送货员都会嘀咕一些关于奇怪排序方案的话，松了一口气，因为至少他们不用将包裹搬到最前面，便将包裹放在最前面可用的位置，然后尽可能快地离开。随后，仓库员工开始行动，将新包裹与前面紧挨着的包裹进行优先级比较（忽略这一排中的其他包裹）。如果他们发现优先级倒置，就交换这两个包裹。否则，包裹就保持原位。这一过程持续进行，直到新包裹占据了正确的层级位置，而其前方的包裹具有更高或相等的优先级。由于包裹又重又分散，员工们通过每排最多进行一次比较和交换来最小化工作量。他们绝不会在一排内重新排列包裹。毕竟，没人愿意不必要地搬运箱子。
- en: 'Intuitively, we can see that heap additions are not terribly expensive. In
    the worst case, we would have to swap the new node all the way to the root of
    the tree, but this only means swapping a small fraction of the array’s values.
    By design, heaps are *balanced* binary trees: we fill out a complete level of
    the tree before inserting a node into the next level. Since the number of nodes
    in a full binary tree doubles with each level, the addition operation requires,
    in the worst case, log[2](*N*) swaps. This is significantly better than the worst
    case of *N* swaps required to maintain a sorted list.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地，我们可以看到堆的新增操作并不非常昂贵。在最坏的情况下，我们可能需要将新节点交换到树的根部，但这只意味着交换数组中一小部分的值。根据设计，堆是*平衡的*二叉树：我们在插入下一个节点之前，会先填满树的每一层。由于满二叉树中每一层的节点数都是上一层的两倍，因此，新增操作在最坏情况下需要
    log[2](*N*) 次交换。这比维护一个排序列表所需的最坏情况的 *N* 次交换要好得多。
- en: Removing the Highest-Priority Elements from Heaps
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从堆中移除最高优先级的元素
- en: Looking up and removing the highest-priority element from a priority queue is
    a core operation that allows us to process items in order of their priority. Perhaps
    we are storing a list of pending network requests and want to process the highest-priority
    one. Or we could be running an emergency room and looking to see the most urgent
    patient. In both cases, we want to remove this element from our priority queue
    so that we can go on to extract the next highest priority element.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从优先队列中查找并移除最高优先级元素是一个核心操作，它允许我们按优先级顺序处理项目。也许我们正在存储一组待处理的网络请求，想要处理其中优先级最高的一个。或者我们可能在急诊室工作，想查看最紧急的病人。在这两种情况下，我们都希望从优先队列中移除该元素，以便提取下一个最高优先级的元素。
- en: To remove the highest-priority node, we must first break, then restore, the
    heap property. Consider the example in [Figure 7-7](#figure7-7). We start by swapping
    the highest-priority node with the last node in the lowest level of the tree ([Figure
    7-7](#figure7-7)(b)), effectively making the last element the new root node. However,
    this epic promotion for the new root node is almost guaranteed not to stand up
    to scrutiny. In the array implementation, this corresponds to swapping the first
    and last elements in the array. This swap plugs the gap at the front of the array
    that would be created by removing the first element and thus maintains a packed
    array.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除最高优先级节点，我们必须首先打破，然后恢复堆的性质。请参阅[图7-7](#figure7-7)中的示例。我们首先将最高优先级节点与树的最低层最后一个节点交换位置（见[图7-7](#figure7-7)(b)），有效地将最后一个元素作为新的根节点。然而，这种对新根节点的“史诗般的提升”几乎可以保证无法经得起检验。在数组实现中，这对应于交换数组中的第一个和最后一个元素。这次交换填补了通过移除第一个元素而在数组前部创建的空缺，从而保持了数组的紧凑结构。
- en: Next, the original max value of 98, which is currently the last element in the
    tree, is deleted as in [Figure 7-7](#figure7-7)(c). We have now deleted the correct
    node, but likely broken the heap property in the process. We may have moved a
    low-urgency package all the way to the front of the warehouse.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，原始的最大值98（当前是树中的最后一个元素）被删除，如[图7-7](#figure7-7)(c)所示。我们现在已删除正确的节点，但在此过程中可能已经破坏了堆的性质。我们可能将一个低优先级的包裹移到了仓库的前端。
- en: '![Node 98 is removed from the heap by first swapping it with the last element
    (23). The new root bubbles down the heap by swapping with the larger of its two
    children. In the first step, node 23 is compared with 95 and 50 and then swapped
    with 95.](image_fi/502604c07/f07007.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![节点98通过先与最后一个元素（23）交换位置被从堆中移除。新的根节点通过与其两个子节点中较大的一个交换位置，向下冒泡。第一步中，节点23与95和50进行比较，然后与95交换位置。](image_fi/502604c07/f07007.png)'
- en: 'Figure 7-7: Removing the highest-priority element from a heap'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-7：从堆中移除最高优先级元素
- en: To fix the heap property, we start at the new (incorrect) root node of 23 and
    walk down the tree, restoring the heap property at every level. The incorrectly
    placed package is shifted one row at a time toward the back of the warehouse,
    the opposite of an added package’s shifting forward row by row. Admittedly, this
    traversal isn’t as exciting as moving an urgent package to the front of the line,
    but it’s for the good of the heap structure. At each level, we compare our moving
    package’s priority to that of both its children, the two packages in the next
    row ([Figure 7-7](#figure7-7)(d)). If it’s smaller than either of its children,
    we move the new root node backward to restore the heap property by swapping places
    with the larger of its two children ([Figure 7-7](#figure7-7)(e)). This represents
    the package’s higher-priority successor moving forward to take its place.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复堆的性质，我们从新的（不正确的）根节点23开始，沿着树向下走，恢复每一层的堆性质。被错误放置的包裹会逐层向仓库后端移动，与新包裹逐层向前移动的过程相反。诚然，这个遍历过程没有像将紧急包裹移到队列前端那么令人激动，但这是为了堆结构的健康。在每一层，我们将正在移动的包裹的优先级与其两个子节点（即下一层的两个包裹）进行比较（见[图7-7](#figure7-7)(d)）。如果它的优先级小于其中任何一个子节点的优先级，我们就将新的根节点向后移动，通过与两个子节点中较大的一个交换位置来恢复堆的性质（见[图7-7](#figure7-7)(e)）。这代表着包裹的高优先级继任者向前移动，取而代之。
- en: The downward swaps terminate when there are no larger children. [Figure 7-7](#figure7-7)(f)
    shows a comparison made when the current node is in the correct position. The
    heap property has been restored, and all the nodes are satisfied with their relative
    position. [Figure 7-7](#figure7-7)(g) shows the final heap, once the removal is
    complete.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: While fixing the location for the root node, we follow a single path down the
    tree, checking and restoring the heap property for only the descendant branch
    where we made the swap. There is no need to check the other branch. It is already
    guaranteed to maintain the heap property since we haven’t done anything to break
    it. Again, this means that, in the worst case, we need to make log[2](*N*) swaps.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code for removing the max element:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code starts by checking that the heap is not empty ❶. If it is, there is
    nothing to return. The code then swaps the first element (`index == 1`) with the
    last element (`index == heap.last_index`), breaking the heap property to prepare
    the max element for removal ❷. The code then uses a `WHILE` loop to traverse down
    the heap in a series of comparisons, repairing the heap property ❸. During each
    iteration, it compares the current value to both children and swaps with the larger
    one if necessary ❻. We must add additional checks ❹ ❺ to ensure that the code
    is only comparing the current value to an existing child. We don’t want it to
    try to compare against an entry that is past the array’s last valid index. The
    loop terminates when it has hit the bottom of the heap or has gone an iteration
    without a swap (via the `break` statement).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Storing Auxiliary Information
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Much of the time, we need our heap to store additional information for each
    entry. In our task list, for example, we need to store information about the tasks
    to be done, not just their priority. It doesn’t help us to know that we need to
    do the priority = 99 task next, if we don’t know what that task is. We might as
    well just scan through the original list manually.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Augmenting the heap to store composite data structures or objects, such as
    a `TaskRecord`, is simple:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We modify the previous code to handle comparisons based on the priority field
    of this composite record. We could do this by directly modifying the code (such
    in the `HeapInsert` function):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'However, this requires us to potentially specialize the heap implementation
    to the particular composite data structure. A cleaner approach is to add a composite
    data structure specific helper function, such as:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We’d use this function instead of the mathematical less-than sign in the code
    for `HeapInsert`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Similarly, we would modify the comparisons in the `HeapRemoveMax` function to
    use the helper function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These small changes allow us to build heaps from composite data structures.
    As long as we can define an `IsLessThan` function to order the elements, we can
    build an efficient priority queue for them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Updating Priorities
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some use cases might demand another mode of dynamic behavior: allowing the
    algorithm to update the priorities of elements within the priority queue. Consider
    a bookstore database that prioritizes which books to restock by the number of
    patrons who have requested each title. The system builds the heap over an initial
    list of books and uses that to determine which title to order next. But, after
    a popular blog article points out the vital importance of data structures in computational
    thinking, the store suddenly sees a dramatic—though entirely understandable—increase
    in patrons requesting books about data structures. Its priority queue must be
    equipped to handle this sudden influx.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有些使用场景可能需要另一种动态行为模式：允许算法更新优先队列中元素的优先级。考虑一个书店数据库，根据每本书的请求人数来确定哪些书籍应该补货。系统首先根据初始的书单构建堆，并用它来确定接下来应该订购哪本书。但在一篇热门博客文章指出数据结构在计算思维中的重要性后，书店突然迎来了急剧—虽然完全可以理解—的增长，更多顾客请求有关数据结构的书籍。它的优先队列必须能够处理这种突如其来的流量。
- en: To meet this need, we use the same approaches we applied to addition and removal.
    When we change an item’s value, we check whether we are increasing or decreasing
    the priority. If we are increasing the item’s value, we need to bubble the item
    up the max heap in order to restore the heap property. Similarly, if we are decreasing
    the item’s value, we let it sink down the max heap into its rightful position.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这个需求，我们使用了与添加和删除相同的方法。当我们改变一项的值时，我们会检查是提高还是降低优先级。如果我们提高了该项的值，我们需要将该项“冒泡”到最大堆中，以恢复堆的性质。类似地，如果我们降低了该项的值，我们让它下沉到最大堆中，直到到达正确的位置。
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can even break out the code for letting elements bubble up or sink down so
    that the exact same code can be used for updating as for addition and removing
    the max.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以将让元素“冒泡”或“下沉”的代码提取出来，这样相同的代码可以用于更新、添加以及删除最大值操作。
- en: How do we find the element we want to update in the first place? As mentioned,
    heaps aren’t optimized for finding specific elements. If we have no information
    on our element of interest other than its value, we might need to search through
    a substantial portion of the array to find it. Often, we can solve this problem
    by using a secondary data structure, such as a hash table (discussed in Chapter
    10), to map from the item’s key to its element in the heap. In the example in
    this section, we assume that the program already has the item’s current index.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何找到我们想要更新的元素呢？如前所述，堆并不适合查找特定的元素。如果我们对目标元素只有它的值而没有其他信息，我们可能需要遍历数组的大部分内容来找到它。通常，我们可以通过使用二级数据结构来解决这个问题，例如哈希表（第10章讨论过），将项的键映射到堆中的元素。在本节的示例中，我们假设程序已经有了该项的当前索引。
- en: Min Heaps
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小堆
- en: So far, we have focused on the max heap, which uses the property that the value
    at any node in the tree is larger than (or equal to) the values of its children.
    The *min heap* is a version of the heap that facilitates finding the item with
    the lowest value. With a min heap, the root of the tree is the smallest value,
    allowing us to easily find the item with the lowest score. For example, instead
    of ordering network packets by priority, we might want to sort them by arrival
    time, processing packets with an earlier time of arrival before packets received
    more recently. More importantly, if we run out of space on our coffee shelf, we’ll
    need to remove our least favorite brand. After a gut-wrenching internal debate
    on whether it would be better to increase the size of our coffee storage by discarding
    a shelf’s worth of plates or bowls rather than part with any of our precious coffee
    grounds, we instead decide to discard the lowest-ranked coffee. We consult our
    list of enjoyability scores for each coffee and select the one with the lowest
    value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们专注于最大堆，它利用树中任何节点的值都大于（或等于）其子节点的值的性质。*最小堆*是堆的一种版本，它有助于找到值最小的元素。对于最小堆，树的根节点是最小值，从而使我们可以轻松找到得分最低的元素。例如，我们可能不仅仅根据优先级来排序网络数据包，而是根据到达时间来排序，先处理到达时间较早的包，而不是最近到达的包。更重要的是，如果我们的咖啡架空间用完了，我们需要移除最不喜欢的品牌。经过一番令人心痛的内心挣扎，我们决定放弃一架架子的盘子或碗，而不是舍弃我们珍贵的咖啡粉，最终我们决定丢掉得分最低的咖啡。我们查阅了每种咖啡的享受度评分，并选择了得分最低的那一款。
- en: We could, in theory, continue to use a max heap by just negating the values.
    However, a cleaner strategy is to make a minor tweak to our heap property and
    solve the problem outright. The *min heap property* is that the value at any node
    in the tree is smaller than (or equal to) the values of its children. An example
    min heap is shown in [Figure 7-8](#figure7-8). When we insert new elements, the
    ones with the lowest score bubble up the hierarchy. Similarly, we always extract
    and return the element with the lowest score.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![A min heap represented both as an array and as a tree with arrows indicating
    where each node sits in the array. The root node 10 corresponds to the first element
    in the array. The node’s two children, 23 and 17, are the second and third elements
    of the array.](image_fi/502604c07/f07008.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-8: The min heap’s position corresponds to index locations.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the algorithms for adding and removing elements in the min heap
    need to be modified accordingly. For insertion, we change the comparison function
    in the `WHILE` loop to check whether the parent value is greater than the current
    value:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The majority of the code is identical to that for insertion into a max heap.
    The only change is to replace `<` with `>` when comparing a node to its parent
    ❶.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'We make a similar change for the two comparisons during the removal operation:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, the only changes are replacing `<` with `>` when determining whether to
    swap nodes ❶ ❷.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Heapsort
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Heaps are powerful data structures across a range of computer science tasks,
    not limited to implementing priority queues and efficiently returning the next
    item in a prioritized list. Another exciting lens through which to view heaps,
    and data structures in general, is in terms of the novel algorithms that they
    enable. J. W. J. Williams initially proposed heaps themselves in the context of
    a new algorithm to sort arrays: *heapsort*.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'As its name implies, heapsort is an algorithm for sorting a list of items using
    the heap data structure. The input is an unsorted array. The output is an array
    containing those same elements, but in *decreasing* sorted order (for a max heap).
    At its core, heapsort consists of two phases:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Building a max heap from all the items
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extracting all the items from the heap in decreasing sorted order and storing
    them in an array
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s that simple.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the heapsort code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code consists of two `WHILE` loops. The first one inserts each item into
    a temporary heap ❶. The second loop removes the largest element using the `HeapRemoveMax`
    function and adds it to the next position in the array ❷. Alternatively, we can
    implement heapsort to produce an answer in *increasing* sorted order by using
    a min heap and `HeapRemoveMin`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to sort the following array: `[46, 35, 9, 28, 61, 8, 38, 40]`
    in decreasing order. We start by inserting each of these values into our heap.
    [Figure 7-9](#figure7-9) shows the final arrangement of the array (and its equivalent
    tree representation) after the insertion. Remember that we always begin by inserting
    new items at the back of the array, then swap them forward until the heap property
    is restored. In [Figure 7-9](#figure7-9), arrows represent the new element’s path
    through the array to its final position. The tree representation is also shown,
    with shading indicating the nodes that have been modified.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![An illustration showing each of the eight insertions during the first stage
    of heapsort, both in an array and in a tree. The numbers 46, 35, 9, and 28 are
    all inserted without swaps. When 61 is inserted at the top of the tree and front
    of the array, it swaps position first with 35 and then 46 to become the new root
    node.](image_fi/502604c07/f07009.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-9: The first stage of heapsort where elements in the unsorted array
    are added to the heap one at a time'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: We bound the runtime of creating the heap using the worst-case runtime of a
    single insertion. As we saw earlier in the chapter, in the worst case, inserting
    a new item into a heap containing *N* items can scale proportional to log[2](*N*).
    Thus, to construct a heap out of *N* items, we bound the worst-case runtime as
    proportional to *N*log[2](*N*).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve built our heap, we proceed to the second stage and extract each
    item, as shown in [Figure 7-10](#figure7-10).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![An illustration showing each of the removals during the second stage of heapsort,
    both in an array and in a tree. During the first removal, the node 61 is removed,
    46 is swapped into its place, 40 is swapped into 46’s former place, and 28 is
    promoted into 40’s former place.](image_fi/502604c07/f07010.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-10: The second stage of heapsort, where the maximal element is repeatedly
    removed from the heap with each iteration'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: We remove the items from the heap one by one in order of decreasing priority.
    This is what produces the decreasing sorted order. At each step, the root is extracted,
    the last item in the heap is swapped to the root’s position, and then the new
    root sinks back down into a position that restores the heap property. The figure
    shows the state of the array (and the equivalent tree representation) at the end
    of each iteration. The arrows in the diagrams and the shaded nodes illustrate
    the overpromoted node’s journey down though the heap. As we extract the items,
    we add them directly to the array storing our result. Once we have emptied the
    heap, we throw it away. It has served its purpose.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: As with the insertions, we can bound the worst-case runtime as proportional
    to *N*log[2](*N*). Each extraction requires at most log[2](*N*) to restore the
    heap property, and we need to extract all *N* items for our sorted list. Thus,
    the total worst-case runtime of the heapsort algorithm is proportional to *N*log[2](*N*).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Why This Matters
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Heaps are a simple variation of binary trees that allow a different set of computationally
    efficient operations. By changing the binary search tree property into the heap
    property, we can change the behavior of the data structure and support a different
    set of operations.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Both addition of new elements and deletion of the maximum element require us
    to walk at most one path between the top and bottom of the tree. Since we can
    approximately double the number of nodes in a heap while adding only a single
    level of new nodes to the bottom, even large heaps allow speedy operations. Doubling
    the number of nodes in this way adds only one additional iteration to insertion
    and deletion! Furthermore, both operations guarantee that the tree remains balanced
    so that future operations will be efficient.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there’s always a tradeoff: by moving from the binary search tree property
    to the heap property, we can no longer efficiently search for a specific value.
    Optimizing for one set of operations often prevents us from optimizing from others.
    We need to think carefully about how we will use the data and design its structure
    accordingly.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
