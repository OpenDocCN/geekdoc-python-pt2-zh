["```py\nif __name__ == \"__main__\":\n    main()\n```", "```py\nfrom pathlib import Path\n\npath = Path(__file__) / Path(\"../resources/about.txt\")\nwith path.open() as file:\n    about = file.read()\n```", "```py\nclass Quadruped:\n    leg_count = 4\n\n    def __init__(self, species):\n        self.species = species\n\nclass Llama(Quadruped):\n    \"\"\"A quadruped that lives in large rivers.\"\"\"\n    dangerous = True\n\n    def __init__(self):\n        self.swimming = False\n        super().__init__(\"llama\")\n\n    def warn(self):\n        if self.swimming:\n            print(\"Cuidado, llamas!\")\n\n    @classmethod\n    def feed(cls):\n        print(\"Eats honey with beak.\")\n```", "```py\nllama = Llama()\n\nfrom pprint import pprint\n\nprint(\"Instance __dict__:\")\npprint(llama.__dict__)\n\nprint(\"\\nLlama class __dict__:\")\npprint(Llama.__dict__)\n\nprint(\"\\nQuadruped class __dict__\")\npprint(Quadruped.__dict__)\n```", "```py\nInstance __dict__:\n{ ❶ 'species': 'llama', 'swimming': False}\n\nLlama class __dict__:\nmappingproxy({'__doc__': 'A quadruped that lives in large rivers.',\n              '__init__': <function Llama.__init__ at 0x7f191b6170d0>,\n              '__module__': '__main__',\n              'dangerous': True,\n              'feed': <classmethod object at 0x7f191b619d60>,\n              2 'warn': <function Llama.warn at 0x7f191b617160>})\n\nQuadruped class __dict__\nmappingproxy({'__dict__': <attribute '__dict__' of 'Quadruped' objects>,\n              '__doc__': None,\n              '__init__': <function Quadruped.__init__ at 0x7f191b617040>,\n              '__module__': '__main__',\n              '__weakref__': <attribute '__weakref__' of 'Quadruped' objects>,\n\n              ❸ 'leg_count': 4})\n```", "```py\nllama = Llama()\n\nfrom pprint import pprint\n\nprint(\"Instance __dict__:\")\npprint(**vars(llama)**)\n\nprint(\"\\nLlama class __dict__:\")\npprint(**vars(Llama)**)\n\nprint(\"\\nQuadruped class __dict__\")\npprint(**vars(Quadruped)**)\n```", "```py\nprint(llama.swimming)   # prints 'False'\nprint(Llama.leg_count)  # prints '4'\n```", "```py\nprint(**getattr(llama, 'swimming')**)   # prints 'False'\nprint(**getattr(Llama, 'leg_count')**)  # prints '4'\n```", "```py\nprint(**object.__getattribute__(llama, 'swimming')**)  # prints 'False'\nprint(**type.__getattribute__(Llama, 'leg_count')**)   # prints '4'\n```", "```py\nllama = Llama()\n\n**try:**\n    print(object.__getattribute__(llama, 'swimming'))\n**except AttributeError as e:**\n **try:**\n **__getattr__ = object.__getattribute__(llama, '__getattr__')**\n **except AttributeError:**\n **raise e**\n **else:**\n **print(__getattr__(llama, 'swimming'))**\n\n**try:**\n    print(type.__getattribute__(Llama, 'leg_count'))\n**except AttributeError as e:**\n **try:**\n **__getattr__ = type.__getattribute__(Llama, '__getattr__')**\n **except AttributeError:**\n **raise e**\n **print(__getattr__(Llama, 'leg_count'))**\n```", "```py\n# Either of these works!\nprint(llama.swimming)              # prints 'False'\nprint(getattr(Llama, 'leg_count')  # prints '4'\n```", "```py\nif hasattr(llama, 'larger_than_frogs'):\n    print(\"¡Las llamas son más grandes que las ranas!\")\n```", "```py\ntry:\n    getattr(llama, 'larger_than_frogs')\nexcept AttributeError:\n    pass\nelse:\n    print(\"¡Las llamas son más grandes que las ranas!\")\n```", "```py\nsetattr(llama, 'larger_than_frogs', True)\nprint(llama.larger_than_frogs)  # prints 'True'\n\nsetattr(Llama, 'leg_count', 3)\nprint(Llama.leg_count)          # prints '3'\n```", "```py\n**object.__setattr__(**llama, 'larger_than_frogs', True**)**\nprint(llama.larger_than_frogs)    # prints 'True'\n\n**type.__setattr__(**Llama, 'leg_count', 3**)**\nprint(Llama.leg_count)            # prints '3'\n```", "```py\nsetattr(llama, 'dangerous', False)  # uh oh, shadowing!\nprint(llama.dangerous)              # prints 'False', looks OK?\nprint(Llama.dangerous)              # prints 'True', still dangerous!!\n```", "```py\n**llama.dangerous = False  # same problem**\nprint(llama.dangerous)   # prints 'False', looks OK?\nprint(Llama.dangerous)   # prints 'True', still dangerous!!\n```", "```py\n**Llama.dangerous = False  # this is better**\nprint(llama.dangerous)   # prints 'False', looks OK?\nprint(Llama.dangerous)   # prints 'False', we are safe now\n```", "```py\nprint(llama.larger_than_frogs)  # prints 'True'\ndel llama.larger_than_frogs\nprint(llama.larger_than_frogs)  # raises AttributeError\n```", "```py\nprint(llama.larger_than_frogs)  # prints 'True'\ndelattr(llama, 'larger_than_frogs')\nprint(llama.larger_than_frogs)  # raises AttributeError\n```", "```py\ndef multiplier(n):\n    factor = 0\n    print(n * factor)\n\n❶ multiplier.factor = 3\n❷ multiplier(2)             # prints 0\nprint(multiplier.factor)  # prints 3\n```", "```py\ndef multiplier(n):\n    factor = 0\n    print(n * factor)\n\n**print(multiplier.__dict__)  # prints {}**\nmultiplier.factor = 3\n**print(multiplier.__dict__)  # prints {'factor': 3}**\n```", "```py\ndef multiplier(n):\n    print(n * **multiplier.factor**)\n\nprint(multiplier.__dict__)  # prints {}\nmultiplier.factor = 3\nprint(multiplier.__dict__)  # prints {'factor': 3}\n**multiplier(2)               # prints 6**\n```", "```py\ndef multiplier(n):\n **if not hasattr(multiplier, 'factor'):**\n **multiplier.factor = 0**\n    print(n * multiplier.factor)\n\n**multiplier(2)               # prints 0**\nprint(multiplier.__dict__)  # prints {**'factor': 0**}\n❶ multiplier.factor = 3\nprint(multiplier.__dict__)  # prints {'factor': 3}\nmultiplier(2)               # prints 6\n```", "```py`In other words, *function attributes are attributes on a mutable object*. This is a logic error waiting to bite you! Consider the following simplistic example, where I try to change a function attribute on one function and it changes elsewhere, too:    ```", "```py    Listing 15-22: *bad_function_attribute.py*    When I assign `sketch` to `skit`, I’m binding `sketch` to the same mutable function object as `skit`. When I then assign a new value to the function attribute `sketch.actor`, it is the same as assigning it to the function attribute `skit.actor`; it’s an attribute on the same function object. If you’re familiar with the troubles with mutable objects, such as lists passed as arguments, that behavior may not look surprising, especially packed into a dozen-line example. However, imagine this being scattered into a production code base of thousands of lines. This could be a horrible bug to attempt to locate and resolve.    As to my `multiplier()` function ([Listing 15-21](#listing15-21)), if I really needed to be able to provide a `factor` in some manner other than as an argument, I’d write that function as a closure instead. That way, each callable would be, itself, stateless. (See Chapter 6 for more on that topic.)    If you do need to use function attributes, you should be careful to only modify them in ways that are clear, predictable, and easy to debug. One possible usage is to employ a decorator to provide a default value up front to a callable, and to never change that value at any point during the execution of the program. While a similar outcome can be achieved with a closure, using a decorator places the extension immediately before the definition of the function. This leaves the attribute open to inspection, something that is squarely impossible with a parameter in a closure.    ## Descriptors    *Descriptors* are objects with *binding behavior*, meaning that they control how the objects are used as attributes. You can think of a descriptor as a property, whose getter, setter, and deleter methods are encapsulated in a class with the data those methods work with.    For example, you could have a `Book` descriptor that contains a book’s title, author, publisher, and publication year. When the descriptor is used as an attribute, all this information could be assigned directly via a string, and the descriptor could parse the information out of that string.    All methods, including static and class methods, as well as the `super()` function (discussed in Chapter 13), are actually descriptor objects. Properties are descriptors behind the scenes, too. Properties are only defined in the context of the class using them, while descriptors can be defined outside of the class and reused. This is similar to the difference between lambdas, which are defined where they’re used, and functions, which are defined separately from their usage.    ### The Descriptor Protocol    An object is a descriptor if it implements at least one of the three special methods in the *descriptor protocol*: `__get__()`, `__set__()`, or `__delete__()`. If the object only implements `__get__()`, it is a *non-data descriptor*, which is typically used for methods behind the scenes. If it also implements `__set__()` and/or `__delete__()`, it’s a *data descriptor*, which is what properties are an example of.    This matters to the *lookup chain* used by `object.__getattribute__()` and `type.__getattribute__()`. The lookup chain determines where Python searches for an attribute, and in what order. Data descriptors get first priority, followed by ordinary attributes stored on the object’s `__dict__`, then non-data descriptors, and finally any attributes on the class and its base classes. This means that a data descriptor named `foo` will shadow, or even prevent the creation of, an attribute by the same name. Similarly, an attribute named `update` will shadow a method (non-data descriptor) named `update()`.    A *read-only data descriptor* would still have `__set__()` defined, but that method would only raise an `AttributeError`. This is important for the descriptor to be considered a data descriptor in the lookup chain.    Descriptors also have a `__set_name__()` method, which is called when the descriptor is bound to a name. I’ll demonstrate this later in this section.    ### Writing a Descriptor Class (the Slightly Wrong Way)    While it is possible to write a descriptor class as a property on a class, you’d normally write a separate descriptor class to reduce code repetition. This can be useful if you want to use the descriptor in multiple unrelated classes, or if you want several instances of the same descriptor in the same instance.    As an example, I’ll write a descriptor class that stores details about a book. I want to parse these details out of a string following the APA 7 citation format. Here’s the first part of that descriptor class. Be advised, there is a logical error in this code, which I’ll cover shortly:    ```", "```py    Listing 15-23: *book_club.py:1a*    This class is a data descriptor (instead of a non-data descriptor) because it defines `__set__()`. (I’ll define `__get__()` in [Listing 15-24](#listing15-24).) When the descriptor is an attribute of another class, a value can be assigned directly to that attribute, and the `__set__()` method is called. This method accepts exactly three arguments: `self`, the object to access on (`instance`), and the value being assigned to the descriptor (`value`).    Within `__set__()`, I use a regular expression that I precompiled and stored in the class attribute pattern to extract the author, title, year, and publisher from the string passed to the value parameter. These extracted values are stored in instance attributes. If value is not a string that matches the expectations of the regular expression, a `ValueError` is raised.    For this to be a descriptor, I must also provide a `__get__()` method in the `Book` descriptor class:    ```", "```py    Listing 15-24: *book_club.py:2a*    When the descriptor is accessed as an attribute, this `__get__()` method is called, returning a new string containing the book’s title and author. If the expected attributes haven’t been defined, I return a string `\"nothing right now\"` instead of re-raising the `AttributeError`.    The `__get__()` method must accept the arguments `self` and `instance`, just like `__set__()` does, as well as the optional argument `owner`, which specifies which class the descriptor belongs to. When `owner` is set to the default value of `None`, the owning class is considered to be the same as `type(instance)`.    You’ll notice that the `Book` class has no `__init__()` method. Although a descriptor class *may* have an initializer if desired, you should not use it to initialize instance attributes as you would with an ordinary class. This is because only one instance of the descriptor is shared between all classes that use it, so all instance attributes will be shared, too. In fact, this unexpected behavior has already set me up for a problem in the example I’m crafting. Stay tuned.    ### Using a Descriptor    A descriptor only exhibits its binding behavior when used as an attribute in another class. To demonstrate this, I’ll define a `BookClub` class, which will use the `Book` descriptor class to keep track of what book the club is currently reading:    ```", "```py    Listing 15-25: *book_club.py:3a*    I put the `Book` descriptor to work by binding an instance of `Book` to the class attribute `reading`. I also defined a `new_member()` method for adding new members to the book club and welcoming them with information about the book the club is currently reading.    There’s one important detail here: *the descriptor must be a class attribute!* Otherwise, all of the descriptor behavior will be ignored, and assignment will merely rebind the attribute to the value being assigned. This isn’t too surprising if you think of where else descriptors show up: all methods and properties are declared at class scope, rather than as names on `self` (instance attributes).    Given that the descriptor is a class attribute with attributes of its own, a problem emerges when using the `BookClub` class. I’ll demonstrate by creating two new book clubs: `mystery_lovers` and `lattes_and_lit`:    ```", "```py    Listing 15-26: *book_club.py:4*    The first club is reading a mystery novel from some weird programmer guy, so I assign a string containing the appropriately formatted book information to the `reading` attribute of `mystery_lovers`. This assignment is invoking the `__set__()` method on the `Book` data descriptor object bound to `reading`.    Meanwhile, the folks in the `lattes_and_lit` club are reading a classic Agatha Christie novel, so I assign the appropriate book information to `lattes_and_lit.reading`.    However, since `reading` is a class attribute, this second assignment changes what both clubs are reading, as you can see from the `print()` statements. How do I fix that?    ### Writing a Descriptor Class the Right Way    While the `reading` descriptor must be a class attribute on `BookClub`, I can modify the descriptor class by storing attributes on the class instance it exists on:    ```", "```py    Listing 15-27: *book_club.py:1b*    Instead of having the `Book` descriptor store its own attributes, it should store them on the instance it is a member of, accessed via the `instance` argument.    Since I’m defining attributes on the instance, I provide a `__delete__()` method as well, so deleting the `Book` descriptor via the `reading` attribute on a `BookClub` instance will work appropriately:    ```", "```py    Listing 15-28: *book_club.py:2b*    If I hadn’t defined this, calling `del` on the reading attribute would have raised an exception.    With the descriptor’s data safely stored on the appropriate owning instances, I find that the usage from earlier now works as expected:    ```", "```py    Listing 15-29: *book_club.py:4*    Here’s a little more usage of this `BookClub` class, demonstrating calling `del` on the descriptor and adding a new member:    ```", "```py    Listing 15-30: *book_club.py:5*    I clear the current book so that the Lattes and Lit book club isn’t reading anything right now. This calls the `reading.__del__()` method. Then, I add a new member, Jaime; the `new_member()` method will print out a welcome message announcing what the club is reading, which is currently nothing.    Next, I choose a book to be read by the club by assigning a string to the `reading` attribute; this calls `reading.__set__()`.    Finally, I add one more member via `new_member()`, which once again prints out a welcome message and the current book.    Here’s the complete output of that usage:    ```", "```py    ### Using Multiple Descriptors in the Same Class    There’s one remaining problem with my design: the descriptor looks for the attributes `title`, `author`, and the like on the instance, so multiple `Book` descriptors on the same `BookClub` instance would mutate these same values repeatedly.    Consider if a book club wanted to track both their current selection and the book they’re reading next:    ```", "```py    Listing 15-31: *book_club.py:3b*    To demonstrate, I’ll assign different books to the `reading` and `reading_next` descriptors. Logically, those two descriptors should behave separately, but that’s not what happens:    ```", "```py    Listing 15-32: *book_club.py:6*    This code outputs the following:    ```", "```py    That’s wrong: the club is supposed to be reading *Noah Clue, P.I.* right now and *The Innocence of Father Brown* later. The trouble is, both the `reading` and `reading_later` descriptors are storing their data in the same instance attributes on `mystery_lovers`.    To get around that, I should instead store the desired attributes with the namespace of the descriptor it relates to, creating names like `reading.author` and `reading_later.title`. That requires a couple of additional methods on the descriptor, for a start:    ```", "```py    Listing 15-33: *book_club.py:1c*    The `__set_name__()` special method is called when the descriptor is first bound to a name on the owning class. In this case, I’m using it to store the name the descriptor is bound to.    I define another method that I’ve chosen to name `attr()`, where I attach the namespace of the descriptor’s name to the beginning of the requested name. As a result, calling `attr('title')` on a descriptor bound to `reading` would return `reading.title`.    I implement this behavior throughout the `__set__()` method by using the `setattr()` function, to assign a value to the given attribute on `instance`.    I must similarly modify `__get__()` and `__delete__()`:    ```", "```py    Listing 15-34: *book_club.py:2c*    Here, I’m using `getattr()` and `delattr()` to respectively access and delete the given attributes, as composed by `self.attr()`, on `instance`.    Rerunning the usage in [Listing 15-32](#listing15-32), I get the following:    ```", "```py    The two descriptors are storing their attributes separately. This can be confirmed by printing out the names of all the attributes on the `mystery_lovers` object:    ```", "```py    Listing 15-35: *book_club.py:7*    This produces the following:    ```", "```py    ## Slots    There’s one downside to the fact that all attributes are stored and accessed on a dictionary: a dictionary collection has significant performance and memory overhead. Ordinarily, this is a reasonable tradeoff, given all the versatility that this approach makes possible.    If you need to improve performance of your class, you can use *slots* to predeclare the attributes you want. Accessing an attribute on a slot is faster than accessing one on a dictionary, and it reduces the memory taken up by the attributes.    Switching your class to use slots instead of an instance `__dict__` is as simple as adding the `__slots__` class attribute, which is a tuple of valid attribute names. This list should contain names of instance attributes, not methods or class attributes (which are stored on the class `__dict__`).    For example, here’s a class for storing data about chemical elements:    ```", "```py    Listing 15-36: *element.py:1a*    The `__slots__` tuple contains five names. These will be the only valid instance attribute names on an `Element` instance, and working with these attributes will be faster than when using `__dict__`. Notice that none of the methods have to be listed in `__slots__`; only the instance attribute names do. What’s more, the slots must never conflict with any names elsewhere on the class (with two exceptions, mentioned shortly).    ### Binding Attribute Names to Values    Although the attribute names are declared in `__slots__`, they don’t have a value (not even `None`) until they’re bound to values in the usual manner, such as within `__init__()`:    ```", "```py    Listing 15-37: *element.py:2*    Here, I’ve added my initializer, as well as a function for converting the instance to a string.    From the outside, the class seems to behave the same as a typical class, although if I were to measure the performance, it would be improved:    ```", "```py    Listing 15-38: *element.py:3a*    ### Using Arbitrary Attributes with Slots    The `__slots__` attribute completely takes over attribute storage from the instance `__dict__`, preventing `__dict__` from even being created for the instance, as you can see here:    ```", "```py    Listing 15-39: *element.py:4a*    However, if I want the benefits of `__slots__` for the primary attributes, while still allowing additional attributes to be defined later, I only need to add `__dict__` to `__slots__`, like this:    ```", "```py    Listing 15-40: *element.py:1b*    The `__dict__` special attribute is one of the two exceptions to the rule that slots must not conflict with class attribute names. The other exception is _`_weakref__`, which you would add to `__slots__` if you wanted your slotted class to support weak references or references to a value that don’t increase the reference count or block garbage collection during their lifetime. I want both arbitrary attributes and weak references for `Element` instances, so I add the names to `__slots__`.    With this one change, the code in [Listing 15-39](#listing15-39) works correctly, instead of raising an `AttributeError`. This technique will diminish the space savings normally afforded by slots, but you will still have the performance gains on all slotted names.    ### Slots and Inheritance    Slots have some important effects on inheritance. First, you should only declare any given slot once in an inheritance tree. If I were to derive a class from `Element`, I should not redeclare any of the slots. Doing so would bloat the size of the derived class because all the slots are declared on each instance, even if some of the base class’s slots are shadowed by the derived class’s slots.    Second, you cannot inherit from multiple parents classes with non-empty slots. If you need to use slots in multiple inheritance scenarios, the best approach is to ensure that the base classes have only an empty tuple assigned to `__slots__`. That way, you can make the derived class use `__dict__`, `__slots__`, or both.    ## Immutable Classes    Technically, there’s no formal mechanism for creating an immutable class. This fact can make it unfortunately tricky to implement a hashable class, since the `__hash__()` method must produce a hash value that never changes during the instance’s lifetime, according to the documentation.    Although you cannot create a truly immutable class, you can get close enough that the fact it’s technically mutable doesn’t matter. Consider the core trait of an immutable object: once its attributes have been initially set, those attributes can never be modified by any means, nor can additional attributes be added. This is why all immutable objects are hashable. The most obvious way to emulate an immutable class (at least in my view), and the one that gives you the most control, is implemented using slots.    I want to make the `Element` class from earlier into an immutable class, and a hashable one at that. To accomplish that, I need to do the following:    *   Implement all attributes as `__slots__`. *   Restrict adding further attributes by omitting `__dict__` from `__slots__`. *   Allow the creation of weak references by including `__weakref__` in `__slots__` (not strictly necessary, but helpful enough in some use cases to be good practice). *   Implement `__setattr__()` and `__delattr__()` to prevent modifying or deleting existing attributes. *   Implement `__hash__()` to make instances hashable. *   Implement `__eq__()` and `__gt__()` to make instances comparable.    I’ll start by defining the `__slots__`, as before:    ```", "```py    Listing 15-41: *element_immutable.py:1*    If I wanted to store additional attributes about elements, I could use a dictionary to associate `Element` keys with instances of some other mutable object as values that contain the rest of the data. For brevity, I won’t do that here.    I’ll add the special methods for converting to string, for hashing, and for comparing between `Element` instances:    ```", "```py    Listing 15-42: *element_immutable.py:2*    In all these cases, I’m using `self.symbol` as the key attribute. Remember that `__eq__()`, `__lt__()`, and `__le__()` correspond to the equals (`==`), less-than (`<`), and less-than-or-equals (`<=`) operators, respectively. Not equals (`!=`), greater than (`>`), and greater than or equals (`>=`) are mirrors of these three, respectively, so I typically only need to implement one special method in each pair.    For objects of this class to be immutable, I have to prevent any modification of its attributes. However, I can’t just make `__setattr__()` do nothing, as it’s needed for initial assignment of values as well. Instead, I write this method to only allow assignment to uninitialized attributes:    ```", "```py    Listing 15-43: *element_immutable.py:3*    If the attribute already exists on the instance, I raise an `AttributeError`. The message here is designed to exactly match the one raised by modifying an attribute on any true immutable class.    Because I’m using slots, I don’t need to worry about new attributes being added, so long as `__dict__` is not specified on `__slots__`.    If the attribute doesn’t already exist, I use `object.__setattr__()` to assign the value to that attribute. I cannot just call the `setattr()` function, or I’ll get infinite recursion.    I also must define `__delattr__()` to prevent deletion of an attribute:    ```", "```py    Listing 15-44: *element_immutable.py:4*    The `__delattr__()` method is simpler to implement, as I don’t ever want to allow deleting an attribute from an immutable instance. Thus, any use of `del` on an attribute of this class raises an `AttributeError`.    This class now behaves as immutable, as you can see from the usage:    ```", "```py    Listing 15-45: *element_immutable.py:5*    Some Python developers will happily point out that one can bypass the simulated immutability of the `Element` class by calling `__setattr__()` on the object directly:    ```", "```py    While this indeed modifies the `iron.symbol` attribute, this nasty hack is a straw man argument against the pattern. No code outside of the class itself should ever call `__setattr__()`; Python and its standard library certainly never will.    *Python does not pretend to be Java!* While it’s possible to bypass safety barriers—as is possible with most things in the Python language—if someone employs such an irrational and dirty hack, they deserve whatever bugs they’ve got coming to them. The hope of preventing such deliberate abuses does not justify the complexity and fragility of other immutability techniques, like inheriting from tuple, simulating objects with `namedtuple`, and so forth. If you want an immutable object, use `__slots__` and `__setattr__()`.    Alternatively, you can achieve something functionally similar with the `@dataclasses.dataclass(frozen=True)` class decorator, which is provided by the *dataclasses* module in the standard library. Dataclasses have some differences from normal classes, so if you want to use them, see the documentation at [https://docs.python.org/3/library/dataclasses.xhtml](https://docs.python.org/3/library/dataclasses.xhtml).    ## Single-Dispatch Generic Functions    By now, you’re probably used to the idea of duck typing and its implications for function design. However, every now and then, you’ll need a function to behave differently for parameters of different types. In Python, as in most languages, you can write *generic functions* to adapt to parameter types.    Generic functions in Python are made possible by two decorators from the *functools* standard library module: `@singledispatch` and `@singledispatchmethod`. Both of these decorators create a *single-dispatch generic function*, which can switch between multiple function implementations, based on the type of the first parameter (when using `@singledispatch`) or the first parameter that isn’t `self` or `cls` (when using `@singledispatchmethod`). This is the only difference between the two decorators.    As an example, I’ll expand on my `Element` class from earlier. I want to be able to compare `Element` instances to each other, as well as to a string containing an element symbol or an integer representing an element number. Instead of writing one big function with an `if` statement that checks the argument against `isinstance()`, I can use single-dispatch generic functions.    I’ll begin by adding two `import` statements before the `Element` class definition to get the `@singledispatchmethod` and `@overload` decorators:    ```", "```py    Listing 15-46: *element_generic.py:1*    There are three slightly different ways to write a single-dispatch generic function, which I’ll cover in a moment. These techniques all work regardless of whether you’re using `@singledispatch` or `@singledispatchmethod`, except that the second decorator allows you to have `self` or `cls` as the first argument, which is why I use it here.    Regardless of which technique is used, the `__eq__()` method must be declared first. This first version of the method should be the most type-dynamic version, since it’ll be used as the fallback.    ```", "```py    Listing 15-47: *element_generic.py:2*    This method is declared with the `@singledispatchmethod` decorator, but it is otherwise the same as if it were an ordinary implementation of the `__eq__()` instance method.    The `@singledispatchmethod` decorator must be the outermost (first) decorator for it to work with other decorators, such as `@classmethod`. The `@singledispatch` decorator can typically exist anywhere in the stack of decorators, although you’re best off ensuring it’s first, to avoid surprises and because consistency is helpful.    ### Registering Single-Dispatch Functions with Type Hints    My single-dispatch `__eq__()` method above still accepts any type. I want to add versions based on the type of the first argument. One way to do that is by registering them with the automatically created `@__eq__.register` decorator. In this case, I’ll create two more versions of the function: one that works with a string argument and another that works with either an integer or a floating-point number argument:    ```", "```py    Listing 15-48: *element_generic.py:3*    The first of these methods accepts a string argument. The first parameter, the one being switched on, is annotated with a type hint for the expected type, which is a string (`str`) in this first case.    The second method here accepts either an integer or a float, and it is made possible with the `@typing.overload` decorator. When type hinting, you can mark one or more function headings with `@overload`, to indicate that they overload an upcoming function or method with the same name. The *Ellipsis* (`...`) is used in place of the suite of the overloaded method, so it can instead share the suite of the method below it. The function or method not decorated with `@overload` must come immediately after all the overloaded versions thereof.    Every single dispatch method conventionally has an underscore (`_`) as a name, to avoid undesired shadowing. The fact that they shadow each other won’t matter, since they’re being wrapped and registered, and thus, they won’t need to be bound to names themselves.    When the `__eq__()` method is called, the type of the first parameter is checked. If it matches the type annotation for any of the registered methods, that method is used. Otherwise, the fallback method, the one marked with the `@singledispatchmethod` decorator, is called instead.    ### Registering Single-Dispatch Functions with Explicit Type    You can also achieve the same result without type annotations. In this case, instead of type hinting, I pass the expected type of the first non-`self` parameter to the `register()` decorator. I’ll use this technique to define my `__lt__()` method:    ```", "```py    Listing 15-49: *element_generic.py:4*    As before, the first version is the most dynamic, the second accepts a string, and the third accepts either an integer or a floating-point number.    Although it’s not seen in this example, your single-dispatch function can accept as many arguments as you need and even different arguments on the different functions, but you can only switch method definitions on the data type of the first parameter.    ### Registering Single-Dispatch Functions with the register() Method    The third way to register to a single-dispatch function is to call `register()` as a method, rather than as a decorator, and directly pass any callable to it. I’ll use this technique with the `__le__()` method.    ```", "```py    Listing 15-50: *element_generic.py:5*    In this case, I define the generic single-dispatch method first, and then I directly register lambdas for handling strings, integers, and floating-point numbers. I could pass *any* callable in place of that lambda, whether it be a previously defined function, a callable, or anything else that accepts the appropriate argument.    Of these three techniques, I like the lambdas the best for these basic operator special methods, since they have less boilerplate. Otherwise, for more involved functions, I prefer to work with type annotations instead.    ## Using the Element Class    I’ve put a lot of work into this `Element` class, making it immutable and allowing the comparison of instances to strings and numbers. The benefits of all this work are apparent in the usage of the class, which I’ll demonstrate by writing a `Compound` class to represent chemical compounds:    ```", "```py    Listing 15-51: *element_generic.py:6*    I’ll wager you could read through that code and understand everything going on. In short, this class allows me to instantiate a chemical compound with a name and add elements to the compound. Because `Element` is hashable and immutable, I can safely use `Element` instances as dictionary keys.    Because I can compare `Element` instances, either to strings representing element symbols or to integers representing element numbers, I can fairly easily implement the Hill system for outputting an empirical chemical formula for the compound.    Here’s the `Compound` class in use:    ```", "```py    Listing 15-52: *element_generic.py:7*    I define four `Element` objects: `hydrogen`, `carbon`, `oxygen`, and `iron`. Then I use these to construct three `Compound` instances: `rust`, `aspirin`, and `water`. I print each `Compound` using the canonical string representation (from `__repr__()`) via the `!r` formatting flag.    As you can see, the `Compound` class and its usage are quite simple and clean, all because I designed `Element` with slots, `__setattr__()`, and single-dispatch generic functions.    ## Arbitrary Execution    Introspection also enables *arbitrary execution*, whereby strings can be directly executed as Python code. To this end, there are some built-in functions that you will encounter sooner or later and that may appeal to your inner hacker: `eval()`, `compile()`, and `exec()`. Yet hidden dangers lurk.    Here’s a contrived little version of how this can go very wrong:    ```", "```py    Listing 15-53: *arbitrary.py*    I read all the lines in from a file, *input.dat*, which I naively assume will contain only mathematical expressions.    For each line I read from *input.dat*, I compose a string containing a Python expression, which I bind to `expression`. Then I pass that string to the `eval()` built-in function, which evaluates it as a Python expression and converts it to a value that I bind to `answer`.    For the sake of demonstration, I compose a string containing a line of Python code, bound to `code`. I could execute it immediately as Python code by passing the string to the `exec()` built-in function. Instead, I compile it into a Python code object using `compile()`, and then I run that code object using `exec()`. This approach is slower for a single use but faster for code being called repeatedly. Again, I only have it here to demonstrate the technique.    The problem here is that arbitrary execution is a major security risk, especially as soon as it involves data provided from an external source, such as a file or user input. I’m expecting my *input.dat* to look something like this:    ```", "```py    Listing 15-54: *input.dat:1a*    These values produce some neat, safe-looking output:    ```", "```py    The danger here is a potential security threat. What would happen if an attacker somehow modified *input.dat* to look like this?    ```", "```py    Listing 15-55: *input.dat:1b*    What would happen if I ran that code on a POSIX system, such as Linux?    ```", "```py    That `jason is DOOMED` message should make your blood run cold, as that was *not* from a print statement; it was produced by a shell command executed directly on the operating system. This is known as a *code injection attack*, and it can lead to some pretty horrific security issues. (I’ll revisit security in Chapter 19.)    There are many clever and esoteric ways to inject code into a string being passed to `eval()`, `compile()`, or `exec()`. As a result, although these functions may look like the key to some truly brilliant Python code, they’re almost always best left alone. If you really, really need something like `eval()`, you should almost certainly use `ast.literal_eval()` instead, although it is unable to evaluate with operators (and thus, it cannot work with my *input.dat*). There are rare, advanced techniques that use `eval()`, `compile()`, or `exec()` safely, but that involve ensuring those functions can only ever receive *trusted* data, as opposed to external data, which is *untrusted*.    To learn more about how dangerous `eval()` (and `exec()`, by extension) is, check out Ned Batchelder’s article, *Eval really is dangerous:* [https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.xhtml.](https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.xhtml) The discussion in the comments is also insightful.    Some of my cleverness-loving readers will have noticed `os.system()` can be used to execute shell commands. This, too, should seldom (if ever) be employed. Use the `subprocess` module instead: [https://docs.python.org/3/library/subprocess.xhtml](https://docs.python.org/3/library/subprocess.xhtml).    ## Wrapping Up    Classes and class instances store their attributes inside of special dictionaries, and this one detail empowers Python to know a lot about the internal composition of objects during runtime.    Descriptors—the magic behind properties, methods, and many other tricks—can be used to make your code easier to maintain. Slots unlock performance and enable you to write effectively immutable classes. Single-dispatch generic functions bring the versatility of overloaded functions to dynamic typing.    Python certainly looks magical at first blush, but it freely unlocks the backstage door and lets us in on all its illusions and secrets. By knowing how the tricks work, you, too, can write elegant classes and libraries that feel, well, dead simple to use.```"]