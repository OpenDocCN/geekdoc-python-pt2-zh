<html><head></head><body>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_13" title="13"/>2</span><br/>
<span class="ChapterTitle">Binary Search</span></h1>
</header>
<figure class="opener">
<img alt="" height="99" src="image_fi/book_art/chapterart.png" width="98"/>
</figure>
<p class="ChapterIntro"><em>Binary search</em> is an algorithm for efficiently searching a sorted list. It checks the sorted list for a target value by repeatedly dividing the list in half, determining which of the two halves could contain the target value, and discarding the other half. This algorithm’s simplicity of logic and implementation make it a perfect introductory topic for computer science, so binary search algorithms are nearly universal throughout computer science courses and textbooks. </p>
<p>The skeptical reader might wonder, “How often will I really need to search a sorted list?” or, more accurately, “How often will I need to implement a function to search my sorted list? Haven’t a few million people done this? Isn’t it in a library somewhere?” While you shouldn’t reject the possibility of one day needing to implement your own binary search, its true importance goes well beyond its implementation. </p>
<p>Binary search illustrates how clever algorithms can use the structure in which data is stored to achieve significant computational savings, even when this structure is as simple as sorted data. Binary search is easily analyzed for correctness and efficiency, provides guarantees of both speed and <span epub:type="pagebreak" id="Page_14" title="14"/>correctness, and demonstrates the fundamental interaction between data and algorithms. It’s an excellent lens with which to examine difference in data storage techniques, such as the difference between linked lists and arrays, or the motivation behind many tree-based algorithms. It can even be used to create a better cup of coffee.<em> </em></p>
<h2 id="h1-502604c02-0001">The Problem</h2>
<p class="BodyFirst">Before defining any new algorithm, we must define the problem the algorithm will try to solve. In this chapter, our aim is to find a single item in a list that matches the given target value; we need an algorithm that can efficiently perform such a search. Formally we can define this search as: </p>
<blockquote class="review">
<p class="Blockquote">Given a set of <em>N</em> data points <em>X</em> = {<em>x</em><sub><em>1</em></sub><em>, x</em><sub><em>2</em></sub><em>, </em>. . . <em>, x</em><sub><em>N</em></sub>} and a target value <em>x</em>', find a point <em>x</em><sub><em>i</em></sub><em> </em><span class="NSSymbol">∈</span> <em>X </em>such that <em>x</em>'<em> </em>= <em>x</em><sub><em>i</em></sub>, or indicate that no such point exists. </p></blockquote>
<p>In our everyday lives, we would likely describe the task as “Find me this particular thing.” This search problem is one that we all face numerous times a day. We might be hunting for a word in a dictionary, a name in our contacts list, a specific date in a list of historical of events, or our preferred brand of coffee in a densely packed supermarket shelf. All we need is a list of candidates and a way to check whether we’ve found a match. </p>
<h2 id="h1-502604c02-0002">Linear Scan</h2>
<p class="BodyFirst">To appreciate the advantages of binary search, we start with a simpler algorithm, <em>linear scan</em>, to provide a baseline for comparison. Linear scan searches for a target value by testing each value in our list, one after the other, against the target value, until the target is found or we reach the end of our list. This is how the author normally searches supermarket shelves—running his finger along the brightly colored packages of coffee, one by one, while mumbling to himself about the need for better indexing schemes.</p>
<p>Imagine that we are looking to find the target value in an array <code>A</code> of numbers. In this case, let’s use <code>target = 21</code>. We iterate through each bin in the array and check whether that value equals 21, as illustrated in <a href="#figure2-1" id="figureanchor2-1">Figure 2-1</a>.</p>
<p><a href="#listing2-1" id="listinganchor2-1">Listing 2-1</a> shows the code for linear scan. The code returns the index of the matching element if one is found and returns an index of <code>-1</code> if the search fails and the item is not in our array.</p>
<pre><code>LinearScan(Array: A, Integer: target):
    Integer: i = 0
    WHILE i &lt; length(A):
        IF A[i] == target:
            return i
        i = i + 1
    return -1</code></pre>
<p class="CodeListingCaption"><a id="listing2-1">Listing 2-1</a>: The code for linear scan</p>
<span epub:type="pagebreak" id="Page_15" title="15"/><figure>
<img alt="A diagram showing how to perform a linear scan on an array of 11 unsorted bins containing numbers. We check whether the value of the first bin is 21; it isn’t, so we check the next bin and so on until we find a match." class="" height="649" src="image_fi/502604c02/f02001.png" width="350"/>
<figcaption><p><a id="figure2-1">Figure 2-1</a>: A linear scan over an array of integers</p></figcaption>
</figure>
<p class="BodyContinued">A single <code>WHILE</code> loop iterates over each element of the array, and the internal <code>IF</code> statement compares that element to the target. As soon as we come across an element matching the target, we return the corresponding index. If we make it to the end of the array, we return <code>-1</code>.</p>
<p>Linear scan isn’t fancy or clever. It’s a <em>brute-force</em> test guaranteed to find the item of interest (if the item is in the data) because it checks every possible item until it finds a match or confirms the item is missing. This is thorough but inefficient, especially for large lists. If we know nothing about the structure of the data in <code>A</code>, there is nothing we can do to streamline the process. The target value could be in any bin, so we may need to check them all.</p>
<p>To illustrate linear scan’s limitations, imagine performing such a scan on a physical row of items, like a line of introductory computer science students standing outside a classroom. The teacher, looking to return a specific student’s assignment, walks down the line asking each student “Is your name Jeremy?” before potentially moving onto the next. The search stops when the teacher finds the correct student or makes it to the end of the line. The students (correctly) roll their eyes and mutter about their inefficient instructor.</p>
<p><span epub:type="pagebreak" id="Page_16" title="16"/>Sometimes there are ways to make linear search faster <em>per comparison</em>. For example, we might optimize the comparison time for more complex data by stopping at the first mismatched letter when comparing strings, as described in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>. Likewise, in the supermarket case, we could consume massive amounts of coffee ahead of time, so our shaky finger zips faster along the shelf. However, this only helps to a point. We are still limited to checking every item, one by one. </p>
<p>In the next section, we’ll see how a small amount of structure in the data changes everything. </p>
<h2 id="h1-502604c02-0003">Binary Search Algorithm</h2>
<p class="BodyFirst">Binary search is an algorithm to find a target value <em>v</em> in a <em>sorted</em> list and only works on sorted data. The algorithm can be written to work with data sorted in either increasing or decreasing order, but, for now, let’s consider the case of data sorted in increasing order—lowest to highest. The algorithm operates by partitioning the list in half and determining in which half <em>v</em> must reside. It then discards the half that <em>v</em> is not in and repeats the process with only the half that can possibly still contain <em>v</em> until only one value remains. For example, if we were searching the sorted list in <a href="#figure2-2" id="figureanchor2-2">Figure 2-2</a> for the value 7, we would find 5 at the midpoint and could rule out the first half of the list. Anything before the middle element cannot be greater than 5, and, since 5 is less than 7, everything before 5 is also less than 7.</p>
<figure>
<img alt="A sorted list of integers from 1 to 9. An arrow points to the midpoint with value 5." class="" height="81" src="image_fi/502604c02/f02002.png" width="376"/>
<figcaption><p><a id="figure2-2">Figure 2-2</a>: A sorted list of integers from 1 to 9, where 5 is the midpoint</p></figcaption>
</figure>
<p>The key to efficient algorithms is using information or structure within the data. In the case of binary search, we use the fact that the array is sorted in increasing order. More formally, consider a sorted array <code>A</code>: </p>
<p class="Equation"><em>A</em>[<em>i</em>] ≤<em> A</em>[<em>j</em>] for any pair of indexes <em>i</em> and <em>j</em> such that <em>i</em> &lt; <em>j</em></p>
<p class="BodyContinued">While this might not seem like a lot of information, it’s enough to allow us to rule out entire sections of the array. It’s similar to the logic we use to avoid the ice cream aisle when searching for coffee. Once we know an item won’t be in a given area, we can rule out that entire set of items in that area without individually checking them.</p>
<p>Binary search tracks the current search space with two bounds: the upper bound <code>IndexHigh</code> marks the highest index of the array that is part of the active search space, and the lower bound <code>IndexLow</code> marks the lowest. Throughout the algorithm, if the target value is in the array, we guarantee the following: </p>
<pre><code>A[IndexLow] ≤ v ≤ A[IndexHigh]</code></pre>
<p><span epub:type="pagebreak" id="Page_17" title="17"/>Binary search starts each iteration by choosing the midpoint of the current search space:</p>
<pre><code>IndexMid = Floor((IndexHigh + IndexLow) / 2)</code></pre>
<p class="BodyContinued">where <code>Floor</code> is a mathematical function that rounds a number down to an integer. We then compare the value at the middle location, <code>A[IndexMid]</code>, with the target value <code>v</code>. If the middle point is less than the target value, <code>A[IndexMid] &lt; v</code>, we know the target value must lie after the middle index. This allows us to chop the search space in half by making <code>IndexLow = IndexMid + 1</code>. Alternately, if the middle point is greater than the target value, <code>A[IndexMid] &gt; v</code>, we know the target value must lie before the middle index, which allows us to chop the search space in half by making <code>IndexHigh = IndexMid – 1</code>. Of course, if we find <code>A[IndexMid] == v</code>, we immediately conclude the search: we’ve found the target. Boisterous celebration is optional.</p>
<p>Each row in <a href="#figure2-3" id="figureanchor2-3">Figure 2-3</a> represents a step in the binary search process on a sorted array. We’re searching the array at row (a) for the value <code>15</code>. At the start, our search bounds include the entire array: <code>IndexLow = 0</code> and <code>IndexHigh = 11</code>. </p>
<p>In row (b), we compute the midpoint (rounding down) to be <code>IndexMid = 5</code>. Comparing the midpoint’s value to the target value, we see that <code>A[5] = 11</code>, which is less than our target value of 15. Therefore, in row (c), we rule out every element in the array up to and including index <code>5</code>—that is, all the shaded elements—by adjusting the lower bounds: <code>IndexLow = 6</code>. We’ve eliminated almost half our search space with a single comparison! The algorithm repeats this process on the remaining range, computing the new midpoint as <code>IndexMid = 8</code>, comparing to the target value (<code>A[8] = 30</code>, which is greater than <code>v = 15</code>), and refining our bounds to <code>IndexHigh = 7</code>. In row (d), we once again eliminate half of the remaining search in the same way. In row (e), we again compute the midpoint as <code>IndexMid = 6</code> and compare it to the target value (<code>A[6] == v</code>). We’ve found the target!</p>
<p>Note that even though the lower bound’s index pointed to the target value (<code>v = 15</code>) for several iterations, we continued the search until the <em>midpoint</em> pointed to the target value. This is because our search checks only the value at the midpoint against the target and not the values at the lower or upper indexes. </p>
<p>Returning to our line of introductory computer science students, we can imagine that by the end of the semester, the teacher asks the students to line up in alphabetical order. The teacher then starts a binary search by asking the middle student “What is your name?” and uses the responses to prune out half the line. The professor then mentally revises the bounds, moves to the new midpoint, and repeats the process. Thus, the professor can turn the exercise of returning an assignment into a demonstration of binary search—while also covering up the fact that they never managed to learn the students’ names.</p>
<span epub:type="pagebreak" id="Page_18" title="18"/><figure>
<img alt="A diagram that represents performing a binary search for value 15 in a sorted array, where the lowest value is negative 5 and highest value is 54. Each of five rows, (a) through (e), shows the same array in different stages of the search. Portions of the array that have been eliminated are shaded gray; the rest are shaded white. " class="" height="829" src="image_fi/502604c02/f02003.png" width="681"/>
<figcaption><p><a id="figure2-3">Figure 2-3</a>: A binary search for the value 15 over a sorted array</p></figcaption>
</figure>
<h3 id="h2-502604c02-0001">Absent Values</h3>
<p class="BodyFirst">Next, we need to consider what happens if the target value is not in the list and how the binary search confirms the value’s absence. In the linear scan case, we know that an element is not in the list as soon as we hit the end of the list. For binary search, we can conclude that our target item does not exist by testing the bounds themselves. As the search progresses, the upper and lower bounds move closer and closer until there are no unexplored values between them. Since we are always moving one of the bounds <em>past</em> the midpoint index, we can stop the search when <code>IndexHigh &lt; IndexLow</code>. At that point, we can guarantee the target value is not in the list. <a href="#figure2-4" id="figureanchor2-4">Figure 2-4</a> shows an example search for <code>v = 10</code> on a sorted array, where <code>10</code> does not appear in the array.</p>
<span epub:type="pagebreak" id="Page_19" title="19"/><figure>
<img alt="A diagram that represents performing a binary search for absent value 10 in a sorted array where the lowest value is negative 5 and highest value is 54. Each of six rows, (a) through (f), shows the same array in different stages of the search." class="" height="1000" src="image_fi/502604c02/f02004.png" width="686"/>
<figcaption><p><a id="figure2-4">Figure 2-4</a>: A binary search for a value (10) that isn’t in the array</p></figcaption>
</figure>
<p>We could theoretically have stopped the search earlier than row (f): once the value at our high bound is less than the target value (<code>IndexHigh = 4</code>) we know that the target can’t be in the array. However, as with our search in <a href="#figure2-3">Figure 2-3</a>, the algorithm only checks the value at the midpoint against the target. It tracks the indices of the high and low bounds, but does not check the <span epub:type="pagebreak" id="Page_20" title="20"/>values at these locations explicitly. While we could add logic to capture this case, as well as the corresponding case of the lower bound being greater than the target value, we will keep the logic simple for now.</p>
<h3 id="h2-502604c02-0002">Implementing Binary Search</h3>
<p class="BodyFirst">We can implement a binary search in code with a single <code>WHILE</code> loop, as shown in <a href="#listing2-2" id="listinganchor2-2">Listing 2-2</a>.  Like the code for linear search in <a href="#listing2-1">Listing 2-1</a>, the binary search algorithm returns the index of the target element if it is in the array. If there is no matching element in the array, the algorithm returns <code>−1</code>.</p>
<pre><code>BinarySearch(Array: A, Integer: target):
    Integer: IndexHigh = length(A) - 1
    Integer: IndexLow = 0
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> WHILE IndexLow &lt;= IndexHigh:
      <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> Integer: IndexMid = Floor((IndexHigh+IndexLow) / 2)

        IF A[IndexMid] == target:
            return IndexMid
        IF A[IndexMid] &lt; target:
          <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> IndexLow = IndexMid + 1
        ELSE:
          <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> IndexHigh = IndexMid - 1
    return -1</code></pre>
<p class="CodeListingCaption"><a id="listing2-2">Listing 2-2</a>: Implementing binary search with a single loop</p>
<p>While the high and low indices have not crossed, we continue the search <span aria-label="annotation1" class="CodeAnnotation">❶</span>. During each iteration, we compute a new midpoint <span aria-label="annotation2" class="CodeAnnotation">❷</span> and check the midpoint value against the target. If it’s an exact match, we’ve found our target and can directly return the corresponding index. If the value at the midpoint is too small, we adjust the lower bounds <span aria-label="annotation3" class="CodeAnnotation">❸</span>. If the value is too high, we adjust the upper bounds <span aria-label="annotation4" class="CodeAnnotation">❹</span>. If <code>IndexHigh &lt; IndexLow</code>, the element is not in the array, so we return <code>-1</code>. </p>
<p>Depending on the programming language, we could use approaches other than returning <code>-1</code> to indicate failure, such as throwing an exception. Regardless of the actual mechanism, your code and documentation should always be absolutely clear about what happens if the element is not in the array so that callers of the function can use it correctly.</p>
<h2 id="h1-502604c02-0004">Adapting Binary Search</h2>
<p class="BodyFirst">So far, we have considered binary search in the context of lists and arrays—fixed sets of discrete items. It is easy to see how we could bring this algorithm into the real world by applying it to a shelf of sorted books, names in a telephone book, or a clothing rack ordered by size. But we can adapt this same approach to continuous data, where we don’t start with a set of individual items or indices, as well. Instead, we use high and low bounds on the values themselves.</p>
<p><span epub:type="pagebreak" id="Page_21" title="21"/>Imagine you aim to craft the perfect cup of coffee. After months of laborious research, you’ve confirmed the optimal temperature and quantity of water. Yet one mystery remains: What quantity of coffee grounds should you use? Here the sources diverge. The Strong Coffee camp recommends a tremendous 5 tablespoons of coffee grounds, while the Watery Coffee camp recommends a paltry 0.5 tablespoons. </p>
<p>The problem of determining your own optimal scoop of coffee grounds lends itself perfectly to a binary search, as shown in <a href="#figure2-5" id="figureanchor2-5">Figure 2-5</a>. We start with reasonable upper and lower bounds as illustrated in <a href="#figure2-5">Figure 2-5</a>(a).</p>
<ol class="none">
<li><span class="RunInHead">LowerBound = 0 tablespoons</span>  The “coffee” was a cup of warm water.</li>
<li><span class="RunInHead">UpperBound = 5 tablespoons</span>  The coffee was too strong.</li>
</ol>
<p class="BodyContinued">The true value must be somewhere in between. Note that our bounds are now the values themselves instead of item indices.</p>
<figure>
<img alt="A diagram showing a binary search of between 0 and 5 tablespoons of coffee. At each step (a) through (d), we define a new midpoint between a new upper and lower bound until we’ve found the optimal midpoint value, 2." class="" height="592" src="image_fi/502604c02/f02005.png" width="321"/>
<figcaption><p><a id="figure2-5">Figure 2-5</a>: An adapted binary search can be used to search a range of real numbers.</p></figcaption>
</figure>
<p>As with a binary search on an array of values, we can define the midpoint at 2.5 tablespoons and test that (<a href="#figure2-5">Figure 2-5</a>(b)). Again, 2.5 tablespoons is just a value. It doesn’t correspond to an element in an array or item on the shelf. We do not have an array of predetermined values, but rather the infinite range of all real numbers between 0.0 and 5.0, and any individual measurement effectively corresponds to an index into that range.</p>
<p><span epub:type="pagebreak" id="Page_22" title="22"/>We find the coffee made from 2.5 tablespoons is a little too strong for our taste, allowing us to refine the bounds. Our optimal amount of coffee is now constrained to lie between 0 tablespoons and 2.5 tablespoons (c). Our search continues with a new midpoint of 1.25 tablespoons, an amount that produces a weak brew. We need to refine our lower bound (d). </p>
<p>The search for morning bliss continues this way until we’ve sufficiently narrowed down our range. Unlike with a discrete array of values, we may never find the exact point that satisfies our search. After all, there is an infinite number of real values. If our optimal amount of coffee is 2.0 tablespoons, we might try values of 2.50, 1.25, 1.875, 2.1875, and 2.03125 before concluding that we are close enough. Therefore, we terminate the search when our range is sufficiently small:</p>
<pre><code>UpperBound – LowerBound &lt; threshold</code></pre>
<p>Contrast this search with a linear scan through the options. In the name of science, we may resolve to try every possible increment of 0.05 tablespoons until we find the optimal brew. After all, this is coffee, and we must be thorough. Starting at our low index (0.0 tablespoons—alternately known as a cup of warm water), we continually increment the amount by 0.05 and retest. We run through 0.05, 0.10, 0.15, . . . , 1.00 before we start to get to a reasonable strength. We would need many trials to get to the correct point, at least 20 of which would be too weak to even to count as coffee. That’s a lot of wasted effort and coffee beans. </p>
<p>The use of binary search also allows for better precision. By sampling only 0.05 increments during our linear scan, we are limited to how close to the target value we can get. Binary search keeps homing in on a smaller range until we stop. We choose what value of <code>UpperBound – LowerBound</code> is sufficient to halt the search, allowing us to narrow it down to within 0.0001 tablespoons or closer. </p>
<p>This adaptation of the binary search approach forms the basis of important mathematical techniques, such as bisection search. <em>Bisection search</em> uses it to find the zero of a function, or the value of <em>x</em> such that <em>f</em>(<em>x</em>) = 0. Instead of evaluating whether coffee is too strong or too weak, bisection search tracks bounds where the function is above zero and below zero. By repeatedly dividing the interval in half at the midpoint, the algorithm zooms in on the value of <em>x</em> where the function is exactly zero. </p>
<h2 id="h1-502604c02-0005">Runtime</h2>
<p class="BodyFirst">Intuitively, we can see that binary search is often faster than a linear scan of the data. Let’s find out how much faster binary search can be to determine whether it’s worth the additional code complexity. </p>
<p>Of course, the relative speed of the two algorithms depends on the data itself. If we are searching for values that always occur at the start of the list, linear scan will win. Similarly, binary search might be unnecessary for tiny lists. We don’t need to partition a list in half if it has only two elements. We can just look at those elements directly.</p>
<p><span epub:type="pagebreak" id="Page_23" title="23"/>We often analyze the runtime of an algorithm in terms of its average and worst-case performance as the size of the data <em>N</em> grows. Computer scientists often use measures such as Big-O notation to more formally capture those concepts. We won’t formally analyze algorithms in this book or use Big-O notation, but we will consider the same two aspects throughout for each algorithm: </p>
<ul>
<li>The average-case runtime of an algorithm as the size of the data grows</li>
<li>The worst-case runtime of an algorithm as the size of the data grows</li>
</ul>
<p>For now, let’s compare worst-case performance for linear scan and binary search. For linear scan, the worst case occurs when the target value is at the end of the list or not in the list at all. In these cases, the algorithm has to check every single value. If the array has <em>N</em> values, it will require <em>N</em> comparisons. Its worst-case running time is <em>linear</em> with the size of the data. </p>
<p>In contrast, even the worst-case binary search will discard half the data at each step, so the number of comparisons is <em>logarithmic</em> with the size of the data set. It scales proportional to log<sub>2</sub><em>N</em>, which is the base-2 logarithm of <em>N</em>. Admittedly there is more work per step: instead of checking a single value, we have to move our bounds and compute a new midpoint. However, for large enough lists, the benefit of needing only a logarithmic number of comparisons will far outweigh additional per-step costs.</p>
<h2 id="h1-502604c02-0006">Why This Matters</h2>
<p class="BodyFirst">This fixation on binary search in introductory computer science classes isn’t the result of binary-search advocacy campaigns, fan clubs, or secret societies (although those would all be understandable). Rather, it’s binary search’s simplicity that makes it a perfect introductory topic. It is a clean and effective example of one of the most fundamental concepts of computational thinking: that designing algorithms by using the structure in the problems themselves helps us construct efficient solutions. By taking advantage of the sorted nature of the data, we are able to cut the worst-case runtime from linear with the number of values to logarithmic—a difference that becomes more significant as the data grows. </p>
<p>Throughout the rest of the book, we will continue to look at the tight relationship between problem structure (including within the data) and how we can create efficient solutions.</p>
</section>
</div></body></html>