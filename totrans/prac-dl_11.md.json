["```py\ndef predict(x):\n\n    return 0\n```", "```py\nold = np.load(\"mnist_train_labels.npy\")\n\nnew = np.zeros(len(old), dtype=\"uint8\")\n\nnew[np.where((old % 2) == 0)] = 0\n\nnew[np.where((old % 2) == 1)] = 1\n\nnp.save(\"mnist_train_even_odd_labels.npy\", new)\n\nold = np.load(\"mnist_test_labels.npy\")\n\nnew = np.zeros(len(old), dtype=\"uint8\")\n\nnew[np.where((old % 2) == 0)] = 0\n\nnew[np.where((old % 2) == 1)] = 1\n\nnp.save(\"mnist_test_even_odd_labels.npy\", new)\n```", "```py\nimport numpy as np\n\nfrom sklearn.neural_network import MLPClassifier\n\ndef run(x_train, y_train, x_test, y_test, clf):\n\n    clf.fit(x_train, y_train)\n\n    return clf.predict_proba(x_test)\n\ndef nn(layers):\n\n    return MLPClassifier(solver=\"sgd\", verbose=False, tol=1e-8,\n\n            nesterovs_momentum=False, early_stopping=False, batch_size=64,\n\n            learning_rate_init=0.001, momentum=0.9, max_iter=200,\n\n            hidden_layer_sizes=layers, activation=\"relu\")\n\ndef main():\n\n    x_train = np.load(\"mnist_train_vectors.npy\").astype(\"float64\")/256.0\n\n    y_train = np.load(\"mnist_train_even_odd_labels.npy\")\n\n    x_test = np.load(\"mnist_test_vectors.npy\").astype(\"float64\")/256.0\n\n    y_test = np.load(\"mnist_test_even_odd_labels.npy\")\n\n    x_train = x_train[:1000]\n\n    y_train = y_train[:1000]\n\n    layers = [(2,), (100,), (100,50), (500,250)]\n\n    mlayers = [\"2\", \"100\", \"100x50\", \"500x250\"]\n\n    for i,layer in enumerate(layers):\n\n        prob = run(x_train, y_train, x_test, y_test, nn(layer))\n\n        np.save(\"mnist_even_odd_probs_%s.npy\" % mlayers[i], prob)\n```", "```py\nimport os\n\nimport sys\n\nimport numpy as np\n\nimport matplotlib.pylab as plt\n\nfrom sklearn.metrics import roc_auc_score, roc_curve\n\ndef main():\n\n    labels = np.load(sys.argv[1])\n\n    probs = np.load(sys.argv[2])\n\n    pname = sys.argv[3]\n\n    auc = roc_auc_score(labels, probs[:,1])\n\n    roc = roc_curve(labels, probs[:,1])\n\n    print(\"AUC = %0.6f\" % auc)\n\n    plt.plot(roc[0], roc[1], color='r')\n\n    plt.plot([0,1],[0,1], color='k', linestyle=':')\n\n    plt.xlabel(\"FPR\")\n\n    plt.ylabel(\"TPR\")\n\n    plt.tight_layout(pad=0, w_pad=0, h_pad=0)\n\n    plt.savefig(pname, dpi=300)\n\n    plt.show()\n```", "```py\ndef table(labels, probs, t):\n\n    tp = tn = fp = fn = 0\n\n    for i,l in enumerate(labels):\n\n        c = 1 if (probs[i,1] >= t) else 0\n\n        if (l == 0) and (c == 0):\n\n            tn += 1\n\n        if (l == 0) and (c == 1):\n\n            fp += 1\n\n        if (l == 1) and (c == 0):\n\n            fn += 1\n\n        if (l == 1) and (c == 1):\n\n            tp += 1\n\n    return [tp, tn, fp, fn]\n\ndef main():\n\n    labels = np.load(sys.argv[1])\n\n    probs = np.load(sys.argv[2])\n\n    pname = sys.argv[3]\n\n    th = [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1]\n\n    roc = []\n\n    for t in th:\n\n        tp, tn, fp, fn = table(labels, probs, t)\n\n        tpr = tp / (tp + fn)\n\n        fpr = fp / (tn + fp)\n\n        roc.append([fpr, tpr])\n\n    roc = np.array(roc)\n\n    xy = np.zeros((roc.shape[0]+2, roc.shape[1]))\n\n    xy[1:-1,:] = roc\n\n    xy[0,:] = [0,0]\n\n    xy[-1,:] = [1,1]\n\n    plt.plot(xy[:,0], xy[:,1], color='r', marker='o')\n\n    plt.plot([0,1],[0,1], color='k', linestyle=':')\n\n    plt.xlabel(\"FPR\")\n\n    plt.ylabel(\"TPR\")\n\n    plt.savefig(pname)\n\n    plt.show()\n```", "```py\ndef confusion_matrix(y_test, y_predict, n=10):\n\n    cmat = np.zeros((n,n), dtype=\"uint32\")\n\n    for i,y in enumerate(y_test):\n\n        cmat[y, y_predict[i]] += 1\n\n    return cmat\n```", "```py\nacc = 100.0*(cmat / cmat.sum(axis=1))\n```", "```py\ndef weighted_mean_acc(cmat):\n\n    N = cmat.sum()\n\n    C = cmat.sum(axis=1)\n\n    return ((C/N)*(100*np.diag(cmat)/C)).sum()\n```"]