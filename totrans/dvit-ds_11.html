<html><head></head><body>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_231" title="231"/>11</span><br/>
<span class="ChapterTitle">Data Science in Other Languages</span></h1>
</header>
<figure class="opener">
<img alt="" height="200" src="image_fi/book_art/chapterart.png" width="200"/>
</figure>
<p class="ChapterIntro">All of our business solutions so far have had one thing in common: they’ve used only Python. Python is standard in the world of data science, but it’s not the only language out there. The best data scientists are versatile and capable of writing code in multiple languages. This chapter contains a short introduction to both Structured Query Language (SQL) and R, two common languages that every good data scientist should know. This chapter isn’t a comprehensive overview of either language. It’s only a basic introduction that will enable you to recognize and write a few lines of SQL or R code.</p>
<p><span epub:type="pagebreak" id="Page_232" title="232"/>We’ll start the chapter by introducing a business scenario. Then we’ll go over some simple SQL code to set up a database and manipulate data within it. We’ll go on to discuss R and how to use it to perform simple operations and linear regressions. Instead of spending a lot of effort setting up environments for running SQL and R commands, you’ll learn how to run SQL and R commands from within a Python session.</p>
<h2 id="h1-502888c11-0001">Winning Soccer Games with SQL</h2>
<p class="BodyFirst">Imagine that you receive a job offer to be the manager of a European soccer team. This may seem like more of a sports scenario than a business scenario, but remember that sports is a business, one with billions of dollars of revenues worldwide every year. Teams hire managers to maximize their revenues and profits and make sure everything runs well.</p>
<p>One of the most important things every team needs to do from a business perspective is win games—teams that win often earn higher profits than teams that tend to lose. As a good data scientist, you know exactly what to do first to set yourself up for success in your new job: you start diving into and exploring data, and trying to learn what it takes to win soccer games.</p>
<h3 id="h2-502888c11-0001">Reading and Analyzing Data</h3>
<p class="BodyFirst">You can download several files that contain data related to European soccer from the following URLs: <a class="LinkURL" href="https://bradfordtuckfield.com/players.csv">https://bradfordtuckfield.com/players.csv</a>, <a class="LinkURL" href="https://bradfordtuckfield.com/games.csv">https://bradfordtuckfield.com/games.csv</a>, and <a class="LinkURL" href="https://bradfordtuckfield.com/shots.csv">https://bradfordtuckfield.com/shots.csv</a>. The first file, <em>players.csv</em>, contains a list of professional soccer players, including their names and unique ID numbers. The next file, <em>games.csv</em>, contains detailed statistics related to thousands of individual soccer games, including which teams played, the number of goals scored, and much more. The third file, <em>shots.csv</em>, is the largest. It contains information about hundreds of thousands of individual shots taken during games, including who took the shot, which foot the player used, where the shot was taken, and the result of the shot (whether it was blocked, missed, or a goal).</p>
<p>If you can do rigorous analysis of this data, you can get a deep understanding of European soccer and have much of the most important knowledge you’ll need to succeed as a manager. (The original sources of this public domain data include <a class="LinkURL" href="https://www.kaggle.com/technika148/football-database">https://www.kaggle.com/technika148/football-database</a>, <a class="LinkURL" href="https://understat.com">https://understat.com</a>, and <a class="LinkURL" href="https://www.football-data.co.uk">https://www.football-data.co.uk</a>.)</p>
<p>Let’s start by reading these files. We’ll use Python here, but don’t worry, we’ll be using SQL soon:</p>
<pre><code>import pandas as pd
players=pd.read_csv('players.csv', encoding = 'ISO-8859-1')
games=pd.read_csv('games.csv', encoding = 'ISO-8859-1')
shots=pd.read_csv('shots.csv', encoding = 'ISO-8859-1')</code></pre>
<p><span epub:type="pagebreak" id="Page_233" title="233"/>So far, this should look familiar. It’s standard Python code for reading <em>.csv</em> files. After importing pandas, we read in datasets that have information about European soccer. You can see that we read all three datasets that we’ll be working with here: <code>players</code>, which contains data about individual players; <code>games</code>, which contains data about individual games; and <code>shots</code>, which contains data about shots that players took during games.</p>
<p>Let’s look at the first few rows of each of these datasets:</p>
<pre><code>print(players.head())
print(games.head())
print(shots.head())</code></pre>
<p>The <code>players</code> table has only two columns, and when you run <code>print(players.head())</code>, you should see the top five rows of both of them:</p>
<pre><code>   playerID            name
0       560   Sergio Romero
1       557  Matteo Darmian
2       548     Daley Blind
3       628  Chris Smalling
4      1006       Luke Shaw</code></pre>
<p>The <code>shots</code> data is more detailed. When you run <code>print(shots.head())</code>, you should see its top five rows:</p>
<pre><code>   gameID  shooterID  assisterID  ...     xGoal positionX positionY
0      81        554         NaN  ...  0.104347     0.794     0.421
1      81        555       631.0  ...  0.064342     0.860     0.627
2      81        554       629.0  ...  0.057157     0.843     0.333
3      81        554         NaN  ...  0.092141     0.848     0.533
4      81        555       654.0  ...  0.035742     0.812     0.707</code></pre>
<p>You can see that by default, the pandas package has omitted some columns that don’t fit in the output console. You can see a list of all the columns in the dataset by running <code>print(shots.columns)</code>, which will show you the following list:</p>
<pre><code>Index(['gameID', 'shooterID', 'assisterID', 'minute', 'situation',
       'lastAction', 'shotType', 'shotResult', 'xGoal', 'positionX',
       'positionY'],
       dtype='object')</code></pre>
<p>We have detailed data about each shot. We know the foot that was used to shoot (in the <code>shotType</code> column), the results of the shot (in the <code>shotResult</code> column), and the position at which it was taken (in the <code>positionX</code> and <code>positionY</code> columns). But one thing that’s not stated explicitly in this data is the name of the player who took the shot. All we have is the <code>shooterID</code>, a number. If we want to find out the name of the person who took the shot, we have to look it up: find the <code>shooterID</code> number in the <code>shots</code> data, then look at the <code>players</code> dataset to find the name of the player whose ID matches that <code>shooterID</code> number.</p>
<p><span epub:type="pagebreak" id="Page_234" title="234"/>The first shot, for example, was taken by the player with <code>shooterID</code> 554. If we want to know the name of that player, we need to look at the <code>players</code> dataset. If you scroll through the <code>players</code> data, or if you run <code>print(players.loc[7,'name'])</code> in Python, you can see that this player is Juan Mata.</p>
<h3 id="h2-502888c11-0002">Getting Familiar with SQL</h3>
<p class="BodyFirst">Let’s go over some SQL code that will enable you to do these kinds of lookups. We’ll start by looking at SQL code, and we’ll discuss how to run the code later. Individual SQL commands are usually called SQL <em>queries</em>. The following code is a SQL query that will show you the entire <code>players</code> dataset:</p>
<pre><code>SELECT * FROM playertable;</code></pre>
<p>Often, short SQL queries are simple to interpret as long as you know English. In this snippet, <code>SELECT</code> tells us that we’re selecting data. The <code>FROM</code> <code>playertable</code> text at the end of the query means that we’ll be selecting data from the table called <code>playertable</code>. Between <code>SELECT</code> and <code>FROM playertable</code> is where we’re supposed to specify the columns we want to select from the <code>playertable</code> data. The asterisk (<code>*</code>) is a shortcut that means that we want to select all the columns of the <code>playertable</code> table. The semicolon (<code>;</code>) tells SQL that we’ve finished this particular query.</p>
<p>So, this SQL query selects our entire <code>players</code> table. If you don’t want to select all the columns of the data, you can replace the <code>*</code> with the names of one or more columns. For example, both of the following are also valid SQL queries:</p>
<pre><code>SELECT playerID FROM playertable
SELECT playerID, name FROM playertable</code></pre>
<p>The first query will select only the <code>playerID</code> column from the <code>playertable</code>. The second will select both the <code>playerID</code> and the <code>name</code> columns from the <code>playertable</code> table—the output we get from specifying that we want both columns by name is the same as the output we get from writing an asterisk.</p>
<p>You may have noticed that our SQL queries use all caps for their keywords. This is a common practice when writing SQL queries, though it’s not technically required in most environments. We’ll do it to follow convention.</p>
<h3 id="h2-502888c11-0003">Setting Up a SQL Database</h3>
<p class="BodyFirst">If you paste the preceding SQL queries directly into a Python session, they won’t run correctly; they’re not Python code. If you’re running SQL frequently, you will probably want to set up an environment that’s designed for editing and running SQL queries. However, this is a Python book, and we don’t want to get you bogged down in the details of setting up a SQL <span epub:type="pagebreak" id="Page_235" title="235"/>environment. Instead, let’s go over a few steps that will allow you to run SQL queries directly in Python. You can start by running the following commands in Python:</p>
<pre><code>import sqlite3
conn = sqlite3.connect("soccer.db")
curr = conn.cursor()</code></pre>
<p>Here, we import the SQLite3 package, which allows us to run SQL queries in Python. SQL is a language that’s designed to work with databases, so we need to use SQLite3 to connect to a database. On the second line, we tell SQLite3 to connect to a database called <code>soccer.db</code>. You probably don’t have a database on your computer called <code>soccer.db</code>, so there may be nothing for SQLite3 to connect to. That’s all right, because the SQLite3 module is very helpful: when we specify a database we want to connect to, it will connect to the database if it exists, and if we try to connect to a database that doesn’t exist, it will create the database for us and then connect to it.</p>
<p>Now that we’re connected to our database, we need to define a <em>cursor</em> to access this database. You can think of this cursor as similar to the cursor you use on your computer; it helps you select and manipulate objects. If that’s not clear to you now, don’t worry. The way we use this cursor will become clearer later.</p>
<p>Now that we have a database, we want to fill it up. Usually, a database contains a collection of tables, but our <code>soccer.db</code> database is currently empty. The three pandas dataframes we’ve worked with so far can all be saved to our database as tables. We can add the <code>players</code> dataframe to our database with one line:</p>
<pre><code>players.to_sql('playertable', conn, if_exists='replace', index = False)</code></pre>
<p>Here, we use the <code>to_sql()</code> method to push our <code>players</code> dataframe to the database’s <code>playertable</code> table. We use the connection we created before, called <code>conn</code>, which ensures that the table gets pushed to our <code>soccer.db</code> database. Now the players data is stored in our database instead of being accessible only as a pandas dataframe in our Python session.</p>
<h3 id="h2-502888c11-0004">Running SQL Queries</h3>
<p class="BodyFirst">We’re finally ready to run our SQL query on our data. This is Python code that will run our SQL query:</p>
<pre><code>curr.execute('''
SELECT * FROM playertable
          ''')</code></pre>
<p>You can see that the cursor we created, <code>curr</code>, is finally useful. The cursor is the object we’ll use to execute SQL queries on our data. In this case, we execute a simple query that selects the entire table called <code>playertable</code>. It’s <span epub:type="pagebreak" id="Page_236" title="236"/>important to note that this has selected the data, but it hasn’t displayed it. If we want to actually see the data that we selected, we need to print it to our console:</p>
<pre><code>for row in curr.fetchall():
    print(row)</code></pre>
<p>The cursor has selected the data and pushed it to your Python session’s memory, but we need to use the <code>fetchall()</code> method to access this data. When you run <code>fetchall()</code>, it selects a list of rows. That’s why we print each row individually in a <code>for</code> loop. The <code>playertable</code> table has thousands of rows, and you may not want to print all of them to your screen at once. You can limit the number of rows returned by your query by adding a <code>LIMIT</code> clause:</p>
<pre><code>curr.execute('''
SELECT * FROM playertable <b>LIMIT 5</b>
          ''')
for row in curr.fetchall():
    print (row)</code></pre>
<p>Here, we run the same code as before, adding only seven characters: <code>LIMIT 5</code>. By adding <code>LIMIT 5</code> to the SQL query, we limit the rows that are returned to only the first five. Since we get only the top five rows in the table, printing them to the screen becomes easier. This shows us the same data as we see when we run <code>print(players.head())</code> when we’re using pandas in Python. But be careful: in this case, <code>LIMIT 5</code> will give us the top five rows, but in other database environments, it will give you a random five rows. You can depend on getting five rows from the <code>LIMIT 5</code> clause, but you can’t always be sure which five you’ll get.</p>
<p>We often want only particular subsets of our data. For example, what if we want to find the player with a particular ID:</p>
<pre><code>curr.execute('''
SELECT * FROM playertable WHERE playerID=554
          ''')
for row in curr.fetchall():
    print (row)</code></pre>
<p>Here, we run much of the same code, but we add a <code>WHERE</code> clause. Instead of selecting the whole table, we select only rows for which a particular condition is true. The condition we’re interested in is <code>playerID=554</code>. The output shows us one row, and that row tells us that the player with <code>playerID</code> equal to 554 is named Juan Mata. This tells us what we wanted to know, that Juan Mata is the person who took the first shot recorded in the data. You should be starting to notice a pattern here: when creating SQL queries, we start with a short query that selects a whole table, and then we add <em>clauses</em> to the query (like the <code>LIMIT</code> clause or <code>WHERE</code> clause we added here) to refine the results we <span epub:type="pagebreak" id="Page_237" title="237"/>get. SQL queries consist of many clauses, each of which has an effect on the data the query selects.</p>
<p>We can use <code>WHERE</code> clauses to select all sorts of conditions. For example, we can use a <code>WHERE</code> clause to select the ID of a player with a particular name:</p>
<pre><code>curr.execute('''
SELECT playerID FROM playertable WHERE name="Juan Mata"
          ''')
for row in curr.fetchall():
    print (row)</code></pre>
<p>We can also use the <code>AND</code> operator to specify multiple conditions:</p>
<pre><code>curr.execute('''
SELECT * FROM playertable WHERE playerID&gt;100 AND playerID&lt;200
          ''')
for row in curr.fetchall():
    print (row)</code></pre>
<p>In this case, we select the rows of the <code>playertable</code> that satisfy two conditions simultaneously: both <code>playerID&gt;100</code> and <code>playerID &lt;200</code>.</p>
<p>You may want to look up a name in a table, but feel uncertain about the spelling. In that case, you can use the <code>LIKE</code> operator:</p>
<pre><code>curr.execute('''
SELECT * FROM playertable WHERE name LIKE "Juan M%"
          ''')
for row in curr.fetchall():
    print (row)</code></pre>
<p>In this case, we’re using the percent character (<code>%</code>) as a <em>wildcard</em>, meaning that it stands for any collection of characters. You may notice that this is similar to the way we used the asterisk earlier in the query (<code>SELECT *</code>). We use <code>*</code> to mean all columns and <code>%</code> to mean any possible character. But though these uses are similar (both representing unknown values), they’re not interchangeable, and there are two important differences. First, the <code>*</code> can be used as part of a query itself, while the <code>%</code> can be used only as part of a string of characters. Second, the <code>*</code> is used to refer to columns, and the <code>%</code> is used to refer to other characters.</p>
<p>When you look at the results of this code, you can see that we’ve found several players whose names start with <em>Juan M</em>:</p>
<pre><code>(554, 'Juan Mata')
(2067, 'Juan Muñoz')
(4820, 'Juan Manuel Falcón')
(7095, 'Juan Musso')
(2585, 'Juan Muñiz')
(5009, 'Juan Manuel Valencia')
(7286, 'Juan Miranda')</code></pre>
<p><span epub:type="pagebreak" id="Page_238" title="238"/>If what we’ve done so far feels familiar, it should. The string we searched for, <code>Juan M%</code>, is a regular expression, just like the regular expressions we covered in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>. You can see that every programming language has its own rules and syntax, but huge overlaps occur across these languages. Most languages allow the use of regular expressions to search for text. Many languages allow you to create tables and select their top five rows. Often, when you learn a new programming language, you’re not learning totally new capabilities, but rather learning to do things you’ve already done in new ways. </p>
<p>You can create and work with tables by using Python and pandas, as well as SQL. The advantage of using SQL is that in many cases, SQL can be faster, more reliable, and more secure than pandas. It also may have compatibility with some programs that do not allow you to use Python and pandas.</p>
<h3 id="h2-502888c11-0005">Combining Data by Joining Tables</h3>
<p class="BodyFirst">So far, we’ve worked with our players table. But we can also work with our other tables. Let’s read in our <code>games</code> table, push it to our soccer database, and then select its top five rows:</p>
<pre><code>games=pd.read_csv('games.csv', encoding = 'ISO-8859-1')

games.to_sql('gamestable', conn, if_exists='replace', index = False)

curr.execute('''
SELECT * FROM gamestable limit 5
          ''')

for row in curr.fetchall():
    print (row)</code></pre>
<p>This snippet does everything we did previously with the <code>players</code> table: reads it, converts it to a SQL database table, and selects rows from it. We can do the same thing yet again, for our <code>shots</code> table:</p>
<pre><code>shots=pd.read_csv('shots.csv', encoding = 'ISO-8859-1')

shots.to_sql('shotstable', conn, if_exists='replace', index = False)

curr.execute('''
SELECT * FROM shotstable limit 5
          ''')

for row in curr.fetchall():
    print (row)</code></pre>
<p>Now, our database has three tables: one for players, one for shots, and one for games. This situation is a little new to us. Throughout most of this book, we’ve had data conveniently gathered into a single table in each of our chapters. However, the data you’re interested in could be spread across <span epub:type="pagebreak" id="Page_239" title="239"/>several tables. In this case, we already noticed that our <code>shots</code> table has detailed information about individual shots, but it doesn’t have the name of the player who took each shot. To find out the name of the player who took a shot, we have to find the <code>shooterID</code> in the <code>shots</code> table and then look up this ID number in the <code>players</code> table.</p>
<p>We have to do matching and lookups across multiple tables. If we have to do this only once or twice, manually scrolling through tables is probably not a big deal. But if we have to get the names of players who took thousands of shots, using manual lookups over and over again will become extremely time-consuming.</p>
<p>Instead, imagine if we could automatically combine the information in these two tables. This is a natural specialty of SQL. We can see what we need to do in <a href="#figure11-1" id="figureanchor11-1">Figure 11-1</a>.</p>
<figure>
<img alt="" class="" height="255" src="image_fi/502888c11/f11001.png" width="441"/>
<figcaption><p><a id="figure11-1">Figure 11-1</a>: Joining two tables together, so lookups become easier and faster</p></figcaption>
</figure>
<p>You can see that if we join two tables together, we no longer have to look at multiple tables to find all the information we need. Each row contains not only the information from the <code>shots</code> table but also the shooter name from the <code>players</code> table. We’re going to accomplish the joining illustrated in <a href="#figure11-1">Figure 11-1</a> by using a SQL query:</p>
<pre><code>SELECT * FROM shotstable JOIN playertable ON
shotstable.shooterID=playertable.playerID limit 5</code></pre>
<p>Let’s look at this snippet, one piece at a time. We start with <code>SELECT *</code>, just like our previous SQL queries. Next, we have <code>FROM shotstable</code>, indicating that we’ll be selecting from the table called <code>shotstable</code>. However, that’s where the difference starts. We see <code>shotstable JOIN</code> <code>playertable</code>, indicating that we’re not going to select only from the <code>shotstable</code>, but instead want to join these two tables and select from the combined table.</p>
<p>But how should they be joined? We need to specify the way to join these two tables. Specifically, we’re going to join these tables by looking up where the IDs match. Every place where the <code>shotstable</code> column called <code>shooterID</code> is the same as the <code>playertable</code> column called <code>playerID</code>, we know that our rows match, and we can join them together. Finally, we add <code>LIMIT 5</code>, <span epub:type="pagebreak" id="Page_240" title="240"/>indicating that we want to see only the top five rows so the quantity of output rows isn’t overwhelming.</p>
<p>We can run this SQL query in Python as follows:</p>
<pre><code>curr.execute('''
SELECT * FROM shotstable JOIN playertable ON shotstable.shooterID=playertable.playerID limit 5
          ''')

for row in curr.fetchall():
    print(row)</code></pre>
<p>Here, we run the SQL query explained previously on the tables in our database. Our SQL query joins our tables together in the way shown in <a href="#figure11-1">Figure 11-1</a>. In that figure, you can see that for every shooter ID, we found the player with a matching player ID and added that player’s name to the matching row of the joined table. Our query does the same thing: since we specify <code>WHERE shotstable.shooterID=playertable.playerID</code>, it will find all matches between <code>shooterID</code> values (from the <code>shotstable</code>) and <code>playerID</code> values (from the <code>playertable</code>). After finding those matches, it will combine information from rows that match, and the final result will be a joined table with more complete information.</p>
<p>After we run our query, we print out the rows that the query has returned. Overall, we’ve followed the same process we followed before: executing a query with the cursor, then fetching what we selected and printing it to the console.</p>
<p>The output looks like this:</p>
<pre><code>(81, 554, None, 27, 'DirectFreekick', 'Standard', 'LeftFoot', 'BlockedShot', 0.104346722364426, 0.794000015258789, 0.420999984741211, 554, 'Juan Mata')
(81, 555, 631.0, 27, 'SetPiece', 'Pass', 'RightFoot', 'BlockedShot', 0.064342200756073, 0.86, 0.627000007629395, 555, 'Memphis Depay')
(81, 554, 629.0, 35, 'OpenPlay', 'Pass', 'LeftFoot', 'BlockedShot', 0.0571568161249161, 0.843000030517578, 0.332999992370605, 554, 'Juan Mata')
(81, 554, None, 35, 'OpenPlay', 'Tackle', 'LeftFoot', 'MissedShots', 0.0921413898468018, 0.848000030517578, 0.532999992370605, 554, 'Juan Mata')
(81, 555, 654.0, 40, 'OpenPlay', 'BallRecovery', 'RightFoot', 'BlockedShot', 0.0357420146465302, 0.811999969482422, 0.706999969482422, 555, 'Memphis Depay')</code></pre>
<p>You can see that this output shows the data we want: shots, combined with information about the players who made the shots (their names are the last element of each row). Joining tables in this way can be valuable to enable advanced analyses like the ones we’ve done in previous chapters.</p>
<p>Joining tables may seem simple, but the process has many subtleties that you should learn about if you want to become great at SQL. For example, what happens if you have a shot with an ID that doesn’t appear in the <code>players</code> table? Or, what if two players have the same ID—how will we know which player took a shot that had their ID assigned to it? By default, <span epub:type="pagebreak" id="Page_241" title="241"/>SQL performs joining with <code>INNER JOIN</code>. An inner join will return nothing if no player ID matches a particular shooter ID; it will give you only rows where it knows exactly which player took a shot. But SQL provides other types of joins, and each uses different logic and follows different rules.</p>
<p>This is not a SQL book, so we won’t go into every detail of the language and every type of join. When you study SQL more deeply, you’ll learn that advanced SQL capabilities usually consist of more and more sophisticated ways to select data and join tables. For now, you can feel proud that you’re able to do basic SQL queries. You’re able to put data in a database, select data from tables, and even join tables together.</p>
<h2 id="h1-502888c11-0002">Winning Soccer Games with R</h2>
<p class="BodyFirst">R is another language that can be useful for a data science career. Let’s go over how to run R commands that will help you with your soccer management career. Just as we did with SQL, we can run our R commands from within a Python session instead of worrying about setting up an R environment. In many ways, R is similar to Python, so after gaining Python skills for data science, you may find that picking up R skills is less challenging.</p>
<h3 id="h2-502888c11-0006">Getting Familiar with R</h3>
<p class="BodyFirst">Let’s start by looking at some R code. Just as we did with SQL queries, we’ll start by looking at the R code before running it:</p>
<pre><code>my_variable&lt;-512
print(my_variable+12)</code></pre>
<p>The first line defines a variable called <code>my_variable</code>. If we were writing Python, the equivalent statement would be <code>my_variable=512</code>. In R, we use <code>&lt;-</code> instead of <code>=</code>, because in R, <code>&lt;-</code> is the <em>assignment operator</em>—the collection of characters used to define the values of variables. The <code>&lt;-</code> characters are meant to resemble an arrow pointing from right to left, indicating that the number 512 is being pushed from the right to be assigned as the value of <code>my_variable</code>. After we assign the variable, we can add to it, or print it out, or do anything else we want with it. In our snippet, we print out the value of our variable plus 12 by writing <code>print(my_variable+12)</code>.</p>
<p>Just like when we were running SQL queries, you may wonder: How can we run this R code? If you’d like, you can download R and set up an R environment where this code can be run. But instead, we can run it from within the comfort of our Python session, after some straightforward preparation. Let’s start by importing a module we need:</p>
<pre><code>from rpy2 import robjects</code></pre>
<p><span epub:type="pagebreak" id="Page_242" title="242"/>In this case, the rpy2 package will be helpful for running R commands within a Python session. Now that we’ve imported our package, running R code is a breeze:</p>
<pre><code>robjects.r('''
my_variable&lt;-512
print(my_variable+12)
''')</code></pre>
<p>This is similar to what we did to run SQL code. We can use the <code>robjects.r()</code> function to run any R code within a Python session. You can see that the output shows 524, the result of the addition we did in the code.</p>
<p>So far, we’ve run simple R code, but nothing related to your soccer management job. Let’s run R code related to our soccer data, as follows:</p>
<pre><code>robjects.r('''
players&lt;-read.csv('players.csv')
print(head(players))
''')</code></pre>
<p>Here, the first line reads our <em>players.csv</em> file, using the <code>read.csv()</code> command. We store the data in the <code>players</code> variable by using the same assignment operator as before (<code>&lt;-</code>). In the second line, we print the top few rows of the data.</p>
<p>By looking at this R code, you can see some differences between R and Python. In Python, we use <code>pd.read_csv()</code>, and in R, we use <code>read.csv()</code>. Both are functions for reading <em>.csv</em> files, but there are small differences in the way they’re written. Similarly, in Python, we need to use <code>players.head()</code> to get the top rows of the data. In R, we use <code>head(players)</code>. When we’re working with pandas datasets, the <code>head()</code> method gives us the top five rows. But in R, the <code>head()</code> function gives the top six rows. R and Python have many similarities, but they are not identical.</p>
<p>We can read our other tables in the same way:</p>
<pre><code>robjects.r('''
shots&lt;-read.csv('shots.csv')
print(head(shots))
''')</code></pre>
<p>This time, we read and print the top few rows of the <code>shots</code> data. We can also print out the top few elements of particular columns of our data:</p>
<pre><code>robjects.r('''
print(head(shots$minute))
print(head(shots$positionX))
''')</code></pre>
<p>In R, the dollar sign (<code>$</code>) is used to refer to columns by name. This snippet prints out the head (top six elements) of the <code>minute</code> and <code>positionX</code> <span epub:type="pagebreak" id="Page_243" title="243"/>columns in our <code>shots</code> data. The <code>minute</code> column has the following top six elements:</p>
<pre><code>[1] 27 27 35 35 40 49</code></pre>
<p>These are the minutes at which the first six shots (in our data) were taken. The first six elements of <code>positionX</code> are these:</p>
<pre><code>[1] 0.794 0.860 0.843 0.848 0.812 0.725</code></pre>
<p>These are the x-positions at which these first six shots (in our data) were taken. Here, we use the term <em>x-position</em> to mean how far “down the field” each shot was taken. One team’s goal has an x-position of 0, and the other team’s goal has an x-position of 1, so the x-position tells us how close to the opposing team’s goal a particular shot was taken.</p>
<h3 id="h2-502888c11-0007">Applying Linear Regression in R</h3>
<p class="BodyFirst">Whenever we look at data, we can try to learn from it. One thing we might want to learn is how shots from the beginning of the game are different from shots at the end of the game. How does the time during the game influence the position from which shots are being taken? Several hypotheses could be true:</p>
<ul class="disc">
<li>Offensive players could get more tired and desperate as a game progresses, so they start to take shots from farther away from the goal (a lower x-position).</li>
<li>Defensive players could get more tired and careless as a game progresses, so players are able to take shots from closer to the goal (a higher x-position).</li>
<li>Maybe neither of the first two hypotheses is true, or another pattern exists in the relationship between the minutes of a game and the x-position of shots.</li>
</ul>
<p>To decide which of these hypotheses is true, we can try linear regression in R:</p>
<pre><code>robjects.r('''
shot_location_model &lt;- lm(positionX~minute,data=shots)
print(summary(shot_location_model))
''')</code></pre>
<p>Here, we use the <code>lm()</code> command to run a linear regression. This regression attempts to find the relationship between the <code>minute</code> variable and the <code>positionX</code> variable in our <code>shots</code> data. Just as we did in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>, we want to look at the coefficients that are part of the output of every linear regression. Remember that the coefficient can be interpreted as the slope of a line. If we find a positive coefficient from this regression, we interpret that to mean <span epub:type="pagebreak" id="Page_244" title="244"/>that people take shots that are closer to the goal later in the game. If we find a negative coefficient, we interpret that to mean that people take shots that are farther from the goal later in the game. When we look at the output of our linear regression code, we see that it looks like this:</p>
<pre><code>Call:
lm(formula = positionX ~ minute, data = shots)

Residuals:
     Min       1Q   Median       3Q      Max
-0.84262 -0.06312  0.01885  0.06443  0.15716

Coefficients:
             Estimate Std. Error  t value Pr(&gt;|t|)
(Intercept) 8.414e-01  3.291e-04 2556.513   &lt;2e-16 ***
minute      5.251e-05  5.944e-06    8.835   &lt;2e-16 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 0.09 on 324541 degrees of freedom
Multiple R-squared:  0.0002404,	Adjusted R-squared:  0.0002374 
F-statistic: 78.05 on 1 and 324541 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>If you look in the <code>Estimate</code> column of this output, you can see that the estimated coefficient for the <code>minute</code> variable is <code>5.251e-05</code>. This is a positive coefficient, so as games progress through time, we expect to see shots that are (slightly) closer to the goal.</p>
<h3 id="h2-502888c11-0008">Using R to Plot Data</h3>
<p class="BodyFirst">Now that we’ve performed our regression, we can draw a plot of our data, together with the regression results:</p>
<pre><code>robjects.r('''
png(filename='the_plot_chapter11.png')
plot(shots$minute,shots$positionX)
abline(shot_location_model)
dev.off()
''')</code></pre>
<p>In the first line, we use the <code>png()</code> command. This tells R to open a file to draw a plot on. We also have to specify a filename where we’ll write the file. Next, we use the <code>plot()</code> command. We specify what we’ll put on the x-axis first, and then we specify the y-axis. The <code>abline()</code> command is used to draw a line for our regression output. Finally, we run <code>dev.off()</code>. This command turns off the graphics device, meaning it tells R that we’ve finished the plotting, and the file should be written to your computer’s memory. After you run this snippet, you should be able to see the file saved to your laptop; it should look like <a href="#figure11-2" id="figureanchor11-2">Figure 11-2</a>.</p>
<span epub:type="pagebreak" id="Page_245" title="245"/><figure>
<img alt="" class="" height="431" src="image_fi/502888c11/f11002.png" width="458"/>
<figcaption><p><a id="figure11-2">Figure 11-2</a>: The x-position of shots at each minute of thousands of soccer games, with a regression line</p></figcaption>
</figure>
<p>If you have trouble finding the output file on your laptop, you can change the filename argument in the preceding snippet. For example, you can write <code>png(filename='</code><var>/home/Yossarian/Documents</var><code>/plotoutput.png')</code> to save it to any specific location on your computer.</p>
<p>You can see a huge number of shots on this plot, and many are being plotted right on top of one another. The regression line is barely visible—you can see it poking out at the left and right of the plot close to where <em>y</em> is about 0.85. It has a positive slope, but it’s only slightly positive; very little pattern can be discerned in the shot locations by minute of soccer games. This is something that you could have done with Python, using the code and ideas from <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>, but now you’re able to do it in another language as well.</p>
<p>This one plot and one regression won’t make you a perfect soccer manager yet, but it will give you information and context that will be helpful as you study what it takes to win soccer games and help your team succeed. Instead of relying on theories or hearsay, you have the skills of a data scientist, so you can determine what works well in soccer games by examining the data directly. After reading this chapter, you can examine data and learn from it not only with Python but also with SQL and R.</p>
<p>We can do so much more with R; anything we’ve done with Python in this book can also be done with R. In addition to plots and linear regression, you could do supervised learning, k-means clustering, and much more. But already, you know how to do a lot: you can read data, calculate a regression, and draw a plot.</p>
<h2 id="h1-502888c11-0003"><span epub:type="pagebreak" id="Page_246" title="246"/>Gaining Other Valuable Skills</h2>
<p class="BodyFirst">After you finish this book and close it, you’ll have some strong data science skills. But you can always learn more. One thing you should consider is gaining proficiency in even more programming languages. In addition to Python, SQL, and R, there are many other programming languages that you might want to learn, at least at a beginner or intermediate level. Here are some other languages that you might consider learning:</p>
<p class="ListHead"><b>C++</b></p>
<ol class="none">
<li>C++ is a high-performance language; code written in C++ is powerful and fast. It tends to be harder to work with than Python.</li>
</ol>
<p class="ListHead"><b>Scala</b></p>
<ol class="none">
<li>Scala is used for working with big data—that is, datasets that have millions or billions of rows.</li>
</ol>
<p class="ListHead"><b>Julia</b></p>
<ol class="none">
<li>Julia has been growing in popularity in recent years, gaining a reputation for efficiency and the speed of mathematical calculations.</li>
</ol>
<p class="ListHead"><b>JavaScript</b></p>
<ol class="none">
<li>JavaScript is extremely common in web programming. It enables you to create dynamic, interactive websites.</li>
</ol>
<p class="ListHead"><b>MATLAB</b></p>
<ol class="none">
<li>Short for <em>matrix laboratory</em>, MATLAB was designed for precision in mathematical calculations, including matrix manipulation. It’s often used for scientific computing, but only by people or institutions that can afford its hefty price tag.</li>
</ol>
<p class="ListHead"><b>SAS, Stata, SPSS</b></p>
<ol class="none">
<li>These are proprietary statistics packages. Stata is in common use among professional economists. SPSS, owned by IBM, is commonly used by some social scientists. SAS is used by some businesses. Just like MATLAB, all of these languages also have hefty price tags that often persuade people to use free alternatives like Python, SQL, and R.</li>
</ol>
<p>Besides these, many others exist. Some data scientists say that a data scientist should be a better programmer than any statistician, and a better statistician than any programmer. Speaking of statistics, you may want to study the following topics in advanced statistics further:</p>
<p class="ListHead"><b>Linear algebra</b></p>
<ol class="none">
<li>Many statistical methods like linear regression are, at heart, linear algebra methods. When you read textbooks related to advanced data science or advanced machine learning, you will see notation from <span epub:type="pagebreak" id="Page_247" title="247"/>linear algebra, and linear algebra ideas like matrix inversion. If you can gain deep knowledge of linear algebra, you’ll be better able to master these advanced topics.</li>
</ol>
<p class="ListHead"><b>Bayesian statistics</b></p>
<ol class="none">
<li>In recent decades, a set of statistical techniques known as <em>Bayesian statistics</em> have become popular. Bayesian techniques allow us to reason effectively about our levels of confidence about different ideas and how we update our beliefs in the face of new information. They also allow us to use our prior beliefs in our statistical inferences and reason carefully about the uncertainty we have about statistical models.</li>
</ol>
<p class="ListHead"><b>Nonparametric statistics</b></p>
<ol class="none">
<li>Like Bayesian statistics, nonparametric methods allow us to reason about data in new ways. Nonparametric methods are powerful because they require us to make very few assumptions about data, so they’re robust and applicable to all kinds of data, even data that isn’t “well behaved.”</li>
</ol>
<p>Data science is about more than statistical theory. It’s also about deploying technology. Here are some technical skills related to technology deployment you will want to gain:</p>
<p class="ListHead"><b>Data engineering</b></p>
<ol class="none">
<li>In most of the chapters of this book, we provided you clean data for analysis. However, in many real-life scenarios, you’ll receive data that’s messy, incomplete, badly labeled, constantly changing, or otherwise in need of careful management. Data engineering is a set of skills for working with big, unruly datasets in a careful and effective way. You may find yourself working at a company that has data engineers on staff to clean and prepare data for you, but you’ll likely find yourself in many situations where you need to do these tasks yourself.</li>
</ol>
<p class="ListHead"><b>DevOps</b></p>
<ol class="none">
<li>After a data scientist performs some analysis, more steps are often required before the analysis is useful. For example, if you use linear regression to do forecasting, you may want to install the regression on a server and have it performed regularly. How and where will you install it? Do you need to update it regularly? How will you monitor it? How and when will you redeploy it? These kinds of questions are related to machine learning DevOps, also called <em>MLOps</em>, and if you can gain some DevOps and MLOps skills, you can have more success in your data science career.</li>
</ol>
<p class="ListHead"><b>Advanced/fluent/efficient programming</b></p>
<ol class="none">
<li>A beginner data scientist can write code that works. A talented data scientist, by contrast, can write code that’s efficient. It will run fast, and will be readable and concise.</li>
</ol>
<p><span epub:type="pagebreak" id="Page_248" title="248"/>Besides these skills, you will want to gain expertise in applied fields related to the work you do (or the work you want to do). If you’re interested in working as a data scientist in the world of finance, you should study mathematical finance and the types of quantitative models that top finance companies use. If you’re interested in working for a pharmaceutical or medical company, you should consider biostatistics or even just pure biology as fields to dive into. The more you know, the more effective you’ll be in your data science career.</p>
<h2 id="h1-502888c11-0004">Summary</h2>
<p class="BodyFirst">In this chapter, we discussed other languages besides Python that can be useful for data scientists. We started with SQL, a powerful language used to work with tables. We used SQL to select data from tables as well as to join tables together. We continued with a discussion of R, a language designed by statisticians that can be used for many powerful data analyses. Now you’ve completed the book, and you have excellent data science skills. Congratulations, good luck, and all the best!</p>
</section>
</div></body></html>