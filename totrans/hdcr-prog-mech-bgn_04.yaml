- en: '3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: THE COMMAND LINE
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Command line interfaces* let us give direct instructions to our computer.
    From the command line, we can run programs, search files, create and delete directories,
    connect to the internet, and do much more. With two exceptions, the applications
    that we’ll create in this book are all designed to be executed from the command
    line. In this chapter, we’ll briefly cover the basics of command line interfaces.
    Feel free to skip this chapter if you already know how to use them.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unix and Windows**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every operating system comes with a different flavor of a command line interface,
    but they all have a similar purpose: issuing commands directly to the operating
    system. Linux and macOS are both based on Unix, so they share a common syntax
    and use similar *command line processors*, which are programs that interpret your
    commands, issued in the form of plaintext, and translate them into a language
    the machine can execute. Several Unix command line processors exist; bash, bourne,
    and zsh are a few examples.'
  prefs: []
  type: TYPE_NORMAL
- en: The command line application in these systems is often called a *shell*, *terminal*,
    or *prompt*. Apple had macOS come bundled with a bash shell, but recently, it
    replaced bash with zsh, which is, arguably, more modern and feature rich. We won’t
    be worrying too much about the differences of these shell flavors; for our purposes,
    we can think of them as interchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: Windows has its own command line system, and it uses a different syntax than
    macOS or Linux. Fortunately enough, since most developers are more familiar with
    Unix-like shells, Windows decided to allow its users to install a Linux subsystem.
    In the next section, we’ll look at how to install this Windows Subsystem for Linux
    (WSL) support in case you’re following this book with a Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding Your Shell**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are a Linux or macOS user, you don’t need to install any additional
    software: your system comes with a shell. You can find it inside your applications
    directory.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re a Windows user, your system also has a command line, but we won’t
    be using that one; we’ll install the WSL instead. This system will give you access
    to a shell you can use to follow along with this book. Let’s look at how to get
    it installed on your machine. If you aren’t a Windows user, feel free to skip
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: '***Installing the Windows Subsystem for Linux***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *Windows Subsystem for Linux*, WSL for short, is an installation of a Linux
    operating system inside your Windows operating system. The WSL will let you access
    Linux’s main tools, including the shell.
  prefs: []
  type: TYPE_NORMAL
- en: Since installation instructions tend to evolve with time, please refer to the
    official documentation if you find any issue with the following steps. You can
    find the official documentation at [*https://docs.microsoft.com/windows/wsl*](https://docs.microsoft.com/windows/wsl),
    where you’ll also find detailed information and a step-by-step installation guide.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of the time of this writing, to install a Linux subsystem you first need
    to enable the WSL optional feature in your machine. To do this, open the PowerShell
    application as Administrator and then execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that you should write this command on a single line; I had to break the
    line because it didn’t fit in the print version of the book. It may take a few
    seconds to finish. Once the command has run, restart your machine.
  prefs: []
  type: TYPE_NORMAL
- en: When your machine is fully restarted, you can proceed to install any Linux distribution
    (also known as *distro*) of your choice. If you have no favorite Linux distro,
    I suggest you install Ubuntu; it’s reliable and developer-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: To install a Linux subsystem, open the Microsoft Store and search for *Ubuntu*
    (or your distro of choice). For this book, I’ll be using Ubuntu’s 20 LTS version.
    Run the installer for the Linux subsystem; once the installation process finishes,
    open it.
  prefs: []
  type: TYPE_NORMAL
- en: When you open your Linux subsystem for the first time, it’ll need to perform
    some installations, which may take a few minutes. As you will see, this installation
    includes the Linux operating system and a shell to communicate with it, but not
    the graphical interface. The shell will prompt you to create a new username and
    password. Don’t hesitate to read the documentation if you find yourself stuck
    at any point during the installation and configuration of the system.
  prefs: []
  type: TYPE_NORMAL
- en: '***Taking a First Look at the Shell***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you open your shell, it shows something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You may see some different characters toward the end, but the first part is
    the logged-in user and the name of the machine separated by an at sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For the remainder of the book, we’ll use the dollar sign ($) to signify the
    shell, and we won’t show the user and machine names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know how to open a shell, let’s look at some useful commands.
  prefs: []
  type: TYPE_NORMAL
- en: '**Files and Directories**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s try our first command: pwd (short for *print working directory*). Type
    pwd in the shell and press ENTER or RETURN . This command shows the path of the
    current directory, that is, the directory the shell is currently in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the shell is telling us the current working directory is *angel*,
    which is inside the *Users* directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the whoami command, we can also ask the shell to tell us the currently
    logged-in user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then list the contents inside the current directory using the ls command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '***Moving Around***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can change directories using cd followed by the name of the directory we
    want to go to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To go back one directory, to the parent directory, we use two dots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In these two examples of the cd command, we’ve changed directories using relative
    paths. A *relative path* is a path that starts from the current location. For
    example, if we want to change directories using a relative path, we simply provide
    the route like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use one dot (.) to signify the current directory. So, the following
    is an alternative way of switching to the *Documents/Video* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We may also change directories using an *absolute path*, which is a path relative
    to the root directory. The root directory’s name is simply a slash character (/).
    Let’s try to change directories to the root directory using an absolute path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s move back to our home directory. The home directory also has a special
    shortcut name, a tilde (~):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '***Creating Files and Directories***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can create new directories using the mkdir command followed by the name
    of the directory we want to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here we’ve just created a new directory named *tmp* inside the working directory,
    which has another new directory inside it named *mechanics*. We could have done
    the same thing in two steps, first creating the *tmp* directory,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: and then changing directories to *tmp* (cd tmp) and creating the *mechanics*
    directory,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The result is the same in both cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s cd into that new directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a new file, we can use the touch command followed by the filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write some text to the file using input redirection, which we’ll explain
    a bit more in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This command is a bit more complex than the ones we’ve seen so far, and it
    has two parts. The first part, on the left side of the > symbol, uses the echo
    command to output write me to the file. We can run this command separately to
    see what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the echo command simply prints what we pass it. With the > symbol,
    we can redirect the output target from the standard output (the shell) to a file
    so that the message is written to the file instead of the shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prove that we did this, let’s read the contents of the file using the cat
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The cat command prints the contents of the file. The command is short for *concatenate*
    and it concatenates the contents of the file passed to it. In fact, we can pass
    cat to the same file twice to see the concatenated result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now delete the file and directories we just created.
  prefs: []
  type: TYPE_NORMAL
- en: '***Deleting Files and Directories***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To remove a file, we use the rm command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The file is now gone forever: there’s no trash bin or any other safety mechanism
    when working with the command line. We need to be extra careful when deleting
    files or directories.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go back two directories to get out of the *tmp/mechanics* folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If a directory is empty, we can remove it using the -d command line option.
    A *command line option* is an argument that we can pass to the command to modify
    its behavior. Command line options appear in two forms: as a single dash followed
    by one or more lowercase letters, as in -f, or as a double dash followed by a
    single or compound word, as in --file or --file-name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing an empty directory is done like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the shell returned an error message because our *tmp* directory
    is not empty (it has a subdirectory). If we want to remove a directory and all
    its subdirectories, we can use the -r option instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If the directory or any subdirectory had files inside, the previous command
    would fail. This command is useful when we want to remove directories that contain
    no files, because if a file is encountered, the command won’t remove anything
    as a safety measure. To remove directories with files inside, we can use the -rf
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You want to be *extremely careful* with the rm -rf command. You can do some
    nasty, unrecoverable harm with this one.
  prefs: []
  type: TYPE_NORMAL
- en: '***Commands Summary***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Table 3-1](ch03.xhtml#ch3tab1) summarizes the commands we’ve explored in this
    section.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Shell Commands for Files and Directories'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| whoami | Displays the effective user ID |'
  prefs: []
  type: TYPE_TB
- en: '| pwd | Returns the working directory name |'
  prefs: []
  type: TYPE_TB
- en: '| ls | Lists the directory’s contents |'
  prefs: []
  type: TYPE_TB
- en: '| cd | Changes the directory |'
  prefs: []
  type: TYPE_TB
- en: '| mkdir | Creates a new directory |'
  prefs: []
  type: TYPE_TB
- en: '| echo | Writes arguments to the standard output |'
  prefs: []
  type: TYPE_TB
- en: '| cat | Concatenates and prints files |'
  prefs: []
  type: TYPE_TB
- en: '| rm | Removes a file |'
  prefs: []
  type: TYPE_TB
- en: '| rm -d | Removes an empty directory |'
  prefs: []
  type: TYPE_TB
- en: '| rm -r | Removes a directory with other directories inside |'
  prefs: []
  type: TYPE_TB
- en: '| rm -rf | Removes directories and files (recursively) |'
  prefs: []
  type: TYPE_TB
- en: '***Using Windows Subsystem for Linux***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we know the basic commands we need to move around the directories of
    a machine, let’s take a look at some specifics when working with the Windows Subsystem
    for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding Your C: Drive**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Every time you open your Linux subsystem, the shell’s working directory will
    be set to the Linux subsystem’s home directory. You can reveal this current directory
    using the pwd command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The WSL has its own directory structure disconnected from your computer’s.
    But, since you’ll be writing the code for this book on your Windows machine, you’ll
    need a way of accessing your C: drive. WSL offers a simple way of accessing the
    C: drive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your local drives are mounted inside a directory in your Linux subsystem called
    */mnt*. Let’s cd into */mnt* and then list its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s important to use the absolute path (starting with /) to navigate to /mnt.
    The ls command listed my two drives: C: and D:. To open one of them, simply change
    directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now your WSL’s working directory is your C: drive. You can find your *Users*
    home directory or whatever folder you’ll be using to write your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Ensuring Python’s Installation (Ubuntu)**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Ubuntu comes already packed with Python version 3 installed. You can check
    the installed version from the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can update Python to its latest version using Ubuntu’s apt command line
    tool. First you’ll need to update the apt package lists so that they are up-to-date
    with the latest versions of the available software. You need to run this command
    as *superuser*. You can do this by prefixing the command you want to run with
    sudo, short for *superuser* do. You’ll need to provide your password for any command
    you run as superuser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When you write your password, you won’t see anything written in the shell.
    As you type, the prompt will remain blank, mainly for security reasons. Once the
    package lists are up-to-date, you can upgrade Python’s version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now you can be sure you have the latest stable release for Python’s version
    3 available for Ubuntu. You are now ready to learn how to run Python scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Running Python Scripts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Running a Python file using the command line is a straightforward process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It’s important that we use Python’s version 3 interpreter because we’ll use
    some features available only in this version. As Python versions 2 and 3 can both
    be installed on the same machine, the version 3 interpreter is named with a 3
    at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a Python file and execute it. In your shell, use the following
    command to create a new Python file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new file, *script.py*, in the shell’s working directory.
    Open the file in PyCharm, or your editor of choice, and enter a print statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure to save the file. Let’s check that our *script.py* file was correctly
    written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let’s execute our Python script from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As expected, our program gives us a hello, World! greeting.
  prefs: []
  type: TYPE_NORMAL
- en: '**Passing Arguments to the Script**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Command line programs can accept arguments. Let’s try this and accept an argument
    in our Python script to personalize the greeting. Open the *script.py* file and
    modify it so that it now contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Python’s sys.argv is a list of the arguments passed in to the executing script.
    This first item of the list is always the name of the executing program, in this
    case, *script.py*. For this reason, we first need to check whether the list of
    arguments contains more than one item to know whether the name was passed to the
    program as an argument. If we detect that the user passed an argument, we use
    it as the name of the person we want to greet, but if no argument is passed, we
    default the name to unknown.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run our program without arguments to get an impersonal greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also pass the script a name to get a more personalized greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '**Standard Input and Output**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Programs executed in the shell can read and write data. When a program, like
    our *script.py* from earlier, prints something, it appears as output in the shell.
    Our earlier program outputted a string like Hello, Jenny! that was then displayed
    in the shell. The shell’s screen is generally referred to as the *standard output*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Redirecting the Output to a File***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Earlier, we wrote the result of an echo command to a file by redirecting the
    output with the > character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try this in your shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This time, the result of the *script.py* program wasn’t printed to the shell’s
    screen, but instead it was written to a new file, *greeting.txt*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the > character, we can redirect the output of a program to a new file.
    If the target file already exists, it gets overwritten. We can also use the >>
    characters to append something to an existing file instead of creating a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This is a useful technique, and we’ll use it throughout the book to write the
    result of our programs to an external file.
  prefs: []
  type: TYPE_NORMAL
- en: '***Redirecting the Input from a File***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Much like we can redirect the shell’s standard output, we can redirect the
    shell’s input. Let’s create a new script. Instead of reading a name from the program’s
    argument, it prompts the user to write their name. First, create a new empty file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the file and enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run our new script now, it’ll prompt us to write our name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This program reads the name from the *standard input*, that is, the shell. We
    had to write the name in the shell and press RETURN for our program to read it.
    We can redirect the input from a file to our program, this time using the < character.
    In this case, the program reads the contents of the file instead of reading from
    the shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write a name inside a new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s redirect the input to be read from this file to our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This time, instead of having to write anything ourselves when the program prompts
    for a name, the shell read in the contents of the *name.txt* file.
  prefs: []
  type: TYPE_NORMAL
- en: The applications we’ll write in this book will use input redirecting to read
    the contents of an input file into our Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using PyCharm’s Python Console**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we saw in the introduction of the book, PyCharm comes with two consoles:
    a Python console and your system’s shell. The former is especially interesting
    as it allows us to run Python code directly as well as inspect all the loaded
    symbols. You can open your PyCharm’s Python console by clicking the Python Console
    button in the lower bar or by selecting View ▸ Tool Windows ▸ Python Console in
    the menu.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python console, as you can see in [Figure 3-1](ch03.xhtml#ch3fig1), is
    divided into two panes: the left pane is the console where you write Python code,
    and the right pane includes a list of all the variables you’ve defined. Let’s
    do a practical exercise to learn how this works.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: PyCharm Python console*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Python prompt, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now the right pane includes a list of symbols that you can explore (see [Figure
    3-2](ch03.xhtml#ch3fig2)). You can expand the names symbol to inspect the items
    inside the list.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-2: Declaring a list of names*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now write a function to filter a list of strings, keeping only those
    that are shorter than a given length. Write the following in the console (note
    the three dots marking the indentation when writing code in the console):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to keep a reference of the filtered list, you can save the result
    to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now you can use the Python console’s right pane to explore the result list.
  prefs: []
  type: TYPE_NORMAL
- en: You can also import Python modules from the console. You can import modules
    from your own project or from the standard library. For instance, if you have
    the *Mechanics* project you downloaded earlier open in PyCharm, you can import
    the Point class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Importing a module from the standard library is equally simple. For instance,
    to import the JSONDecoder class from the json module, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: From time to time we may want to reload the console so that all the imported
    modules and defined variables are cleared. This is a good idea, because the modules
    you import and the variables you define might interact with the new code you write.
    We can reload the Python’s console by clicking the reload button located at the
    top left of the console (see [Figure 3-3](ch03.xhtml#ch3fig3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-3: Reloading the console*'
  prefs: []
  type: TYPE_NORMAL
- en: Take your time exploring PyCharm’s Python console, as you’ll find it useful
    throughout the book; we’ll often test our code by running quick experiments in
    it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this short chapter, we covered the basics of using the bash/zsh command line.
    From this shell we can issue commands to the computer, and we’ll execute our Python
    scripts from here. We also explored the standard input and output redirection,
    a technique we’ll use extensively throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Without further ado, let’s start creating our *Mechanics* project. Let the fun
    begin!
  prefs: []
  type: TYPE_NORMAL
