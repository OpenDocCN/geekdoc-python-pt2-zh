<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="header1101" class="chapter" epub:type="chapter" id="ch11" role="doc-chapter">
<header id="header1101">
<h1 class="cn"><span aria-label=" Page 215. " class="page" epub:type="pagebreak" id="p215" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rch11">11</a></h1>
<h1 class="ct">Volume Rendering</h1>
</header>
<figure class="figure">
<p class="fig"><img alt="" height="100" src="images/nsp-venkitachalam503045-circle-image.jpg" width="100"/></p>
</figure>
<p class="pf">Magnetic resonance imaging (<span class="idx" data-term="MRI"/>MRI) and computed tomography (<span class="idx" data-term="CT scan"/>CT) scans are diagnostic processes that create <span class="idx" data-term="volumetric data"/><i>volumetric data</i>, data that consists of a set of 2D images showing cross sections through a 3D volume. <span class="idx" data-term="volume rendering"/><i>Volume rendering</i> is a computer graphics technique used to construct 3D images from this type of volumetric data. Although volume rendering is commonly used to analyze medical scans, it can also be used to create 3D scientific visualizations in academic disciplines such as geology, archaeology, and molecular biology.</p>
<p>The data captured by MRI and CT scans typically follows the form of a 3D grid of dimensions <i>N</i><sub class="i">x</sub>×<i>N</i><sub class="i">y</sub>×<i>N</i><sub class="i">z</sub>. In other words, there are <i>N</i><sub class="i">z</sub> 2D “slices,” where each slice is an image of size <i>N</i><sub class="i">x</sub>×<i>N</i><sub class="i">y</sub>. Volume rendering algorithms are <span aria-label=" Page 216. " class="page" epub:type="pagebreak" id="p216" role="doc-pagebreak"/>used to display the collected slice data with some type of transparency, and various techniques are used to accentuate the parts of the rendered volume that are of interest.</p>
<p>In this project, you’ll look at a volume rendering called <i>volume ray casting</i>, which takes full advantage of the graphics processing unit (<span class="idx" data-term="GPU"/>GPU) to perform computations using OpenGL Shading Language (<span class="idx" data-term="GLSL"/>GLSL) shaders. Your code executes for every pixel onscreen and leverages the GPU, which is designed to do parallel computations efficiently. You’ll use a folder of 2D images consisting of slices from a 3D data set to construct a volume-rendered image using the volume ray casting algorithm. You’ll also implement a method to show <span class="idx" data-term="2D slice"/>2D slices of the data in the x-, y-, and z-directions so users can scroll through the slices using the arrow keys. Keyboard commands will let the user toggle between the 3D rendering and the 2D slices.</p>
<p>Here are some of the topics covered in this project:</p>
<ul style="list-style-type:none">
<li class="blf">• Using GLSL for GPU computations</li>
<li class="bl">• Creating vertex and fragment shaders</li>
<li class="bl">• Representing 3D volumetric data and using the volume ray casting algorithm</li>
<li class="bl">• Using <code>numpy</code> arrays for 3D transformation matrices</li>
</ul>
<section>
<h2 class="ah" id="ah1301"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1301">How It Works</a></h2>
<p class="paft">There are various ways to render a 3D data set. In this project, you’ll use the volume ray casting method, which is an <span class="idx" data-term="image-based rendering"/><i>image</i>-<i>based</i> rendering technique used to generate the final image from the 2D slices, pixel by pixel. In contrast, typical 3D rendering methods are <i>object based</i>: they begin with a 3D object representation and then apply transformations to generate the pixels in the projected 2D image.</p>
<p>In the volume ray casting method that you’ll use in this project, for each pixel in the output image, a <span class="idx" data-term="ray"/>ray is shot into the discrete 3D volumetric data set, which is typically represented as a cuboid. As the ray passes through the volume, the data is sampled at regular intervals, and the samples are combined, or <i>composited</i>, to compute the color value or intensity of the final image. (You might think of this process as similar to stacking a bunch of transparencies on top of each other and holding them up against a bright light to see a <span class="idx" data-term="blend"/>blend of all the sheets.)</p>
<p>While volume ray casting rendering implementations typically use techniques such as applying gradients to improve the appearance of the final render, filtering to isolate 3D features, and using spatial optimization techniques to improve speed, you’ll just implement the basic ray casting algorithm and composite the final image by X-ray casting. (My implementation is largely based on the seminal paper on this topic by Kruger and Westermann, published in 2003.<a class="fnref" epub:type="noteref" href="nsp-venkitachalam503045-0025.xhtml#fn4" id="fn4r" role="doc-noteref">1</a>)</p>
<section>
<h3 class="bh" id="bh1301"><span aria-label=" Page 217. " class="page" epub:type="pagebreak" id="p217" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1301">The Data Format</a></h3>
<p class="paft">For this project, you’ll use medical data from 3D scans from the Stanford Volume Data Archive.<a class="fnref" epub:type="noteref" href="nsp-venkitachalam503045-0025.xhtml#fn5" id="fn5r" role="doc-noteref">2</a> This archive offers a few excellent 3D <span class="idx" data-term="medical data"/>medical data sets (both CT and MRI) of TIFF images, one for each 2D cross section of the volume. You’ll read a folder of these images into an OpenGL 3D texture; this is sort of like stacking a set of 2D images to form a cuboid, as shown in <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#fig11-1">Figure 11-1</a>.</p>
<figure class="figure" id="fig11-1">
<p class="fig"><img alt="" height="620" src="images/nsp-venkitachalam503045-f11001.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 11-1:</span> Building 3D volumetric data from 2D slices</p>
</figcaption>
</figure>
<p>Recall from <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#ch09">Chapter 9</a> that a 2D texture in OpenGL is addressed with a 2D coordinate (<i>s</i>, <i>t</i>). Similarly, a <span class="idx" data-term="3D texture"/>3D texture is addressed using a <span class="idx" data-level1="GL_CCW" data-term="OpenGL"/><span class="idx" data-level1="3D texture coordinate" data-term="volume rendering"/>3D texture coordinate of the form (<i>s</i>, <i>t</i>, <i>p</i>). As you’ll see, storing the volumetric data as a 3D texture allows you to access the data quickly and provides you with interpolated values required by your ray casting scheme.</p>
</section>
<section>
<h3 class="bh" id="bh1302"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1302">Ray Generation</a></h3>
<p class="paft">Your goal in this project is to generate a perspective projection of the 3D volumetric data, as shown in <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#fig11-2">Figure 11-2</a>. The figure shows the OpenGL view frustum, as discussed in <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#ch09">Chapter 9</a>. Specifically, it shows how a ray from the eye enters this frustum at the near plane, passes through the cubic volume (which contains the volumetric data), and exits from the rear at the far plane.</p>
<figure class="figure" id="fig11-2">
<p class="fig"><span aria-label=" Page 218. " class="page" epub:type="pagebreak" id="p218" role="doc-pagebreak"/><img alt="" height="1085" src="images/nsp-venkitachalam503045-f11002.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 11-2:</span> A perspective projection of 3D volumetric data</p>
</figcaption>
</figure>
<p>To implement ray casting, you need to generate rays that go into the volume. For each pixel in the output window shown in <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#fig11-2">Figure 11-2</a>, you generate a vector <i>R</i> that goes into the volume you consider a unit cube (which I’ll refer to as the <span class="idx" data-level1="color cube" data-term="volume rendering"/><span class="idx" data-term="color cube"/><i>color cube</i>) defined between the coordinates (0, 0, 0) and (1, 1, 1). You color each point inside this cube with the RGB values equal to the 3D coordinates of the cube. The origin is colored (0, 0, 0), or black; the (1, 0, 0) corner is red; and the point on the cube diagonally opposite the origin is colored (1, 1, 1), or white. <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#fig11-3">Figure 11-3</a> shows this cube.</p>
<figure class="figure" id="fig11-3">
<p class="fig"><span aria-label=" Page 219. " class="page" epub:type="pagebreak" id="p219" role="doc-pagebreak"/><img alt="" height="728" src="images/nsp-venkitachalam503045-f11003.jpg" style="width:95%; height:auto;" width="728"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 11-3:</span> A color cube</p>
</figcaption>
</figure>
<p class="pcust1"><span class="ccust3">NOTE</span> In OpenGL, a color can be represented as a strip of 8-bit unsigned values (<i>r</i>, <i>g</i>, <i>b</i>), where <i>r</i>, <i>g</i>, and <i>b</i> are in the range [0, 255]. It can also be represented as a triplet of 32-bit floating-point values (<i>r</i>, <i>g</i>, <i>b</i>), where <i>r</i>, <i>g</i>, and <i>b</i> are in the range [0.0, 1.0]. These representations are equivalent. For example, the red color (255, 0, 0) in the former is the same as (1.0, 0.0, 0.0) in the latter.</p>
<p><span class="idx" data-level1="color representation" data-term="OpenGL"/><span class="idx" data-term="color representation"/>To draw the cube, first draw its six faces using the OpenGL primitive <span class="idx" data-level1="GL_TRIANGLES" data-term="OpenGL"/><span class="idx" data-term="GL_TRIANGLES"/><code>GL_TRIANGLES</code>. Then color each vertex and use the interpolation provided by OpenGL when it rasterizes polygons to take care of the colors between each vertex. For example, <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#fig11-4">Figure 11-4(a)</a> shows the three front-faces of the cube. The back-faces of the cube are drawn in <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#fig11-4">Figure 11-4(b)</a> by setting OpenGL to <span class="idx" data-term="face culling"/><span class="idx" data-level1="face culling" data-term="OpenGL"/>cull front-faces.</p>
<figure class="figure" id="fig11-4">
<p class="fig"><img alt="" height="397" src="images/nsp-venkitachalam503045-f11004.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 11-4:</span> The color cube used to compute rays</p>
</figcaption>
</figure>
<p><span aria-label=" Page 220. " class="page" epub:type="pagebreak" id="p220" role="doc-pagebreak"/>If you <span class="idx" data-level1="color cube" data-term="volume rendering"/>subtract the colors in <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#fig11-4">Figure 11-4(a)</a> from <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#fig11-4">Figure 11-4(b)</a> by subtracting (<i>r</i>, <i>g</i>, <i>b</i>)<sub>front</sub> from (<i>r</i>, <i>g</i>, <i>b</i>)<sub>back</sub>, you actually compute a set of vectors that go from the front to the back of the cube because each color (<i>r</i>, <i>g</i>, <i>b</i>) on this cube is the same as the 3D coordinate at that color’s location. <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#fig11-4">Figure 11-4(c)</a> shows the result. (Negative values have been flipped to positive for the purposes of this illustration because negative numbers cannot be displayed as colors directly.) Reading the color value (<i>r</i>, <i>g</i>, <i>b</i>) of a pixel, as shown in <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#fig11-4">Figure 11-4(c)</a>, gives the (<i>r</i><sub class="i">x</sub>, <i>r</i><sub class="i">y</sub>, <i>r</i><sub class="i">z</sub>) coordinates for the ray passing into the volume at that point.</p>
<p>Once you have the casting rays, you render them into an image or 2D texture for later use with OpenGL’s <span class="idx" data-term="frame buffer objects. See FBO"/>frame buffer object (<span class="idx" data-term="FBO"/>FBO) feature. After this texture is generated, you can access it inside the shaders that you’ll use to implement the ray casting algorithm.</p>
<section>
<h4 class="ch" id="ch1301">Ray Casting in the GPU</h4>
<p class="paft">To implement the <span class="idx" data-level1="ray casting (begin)" data-term="volume rendering"/><span class="idx" data-term="ray casting (begin)"/>ray casting algorithm, you first draw the back-faces of the color cube into an FBO. Next, the front-faces are drawn on the screen. The bulk of the ray casting algorithm happens in the fragment shader for this second rendering, which runs for each pixel in the output. The ray is computed by subtracting the front-face color of the incoming fragment from the back-face color of the color cube, which is read in from a texture. The computed ray is then used to accumulate and compute the final pixel value using the 3D volumetric texture data, available within the shader.<span class="idx" data-level1="ray casting (end)" data-term="volume rendering"/><span class="idx" data-term="ray casting (end)"/></p>
</section>
<section>
<h4 class="ch" id="ch1302">Showing 2D Slices</h4>
<p class="paft">In addition to the 3D rendering, you show <span class="idx" data-term="2D slice"/><span class="idx" data-level1="2D slice" data-term="volume rendering"/>2D slices of the data by extracting the 2D cross section from the 3D data perpendicular to the x-, y-, or z-axis and applying that as a texture on a quad. Because you store the volume as a 3D texture, you can easily get the required data by specifying the texture coordinates (<i>s</i>, <i>t</i>, <i>p</i>). OpenGL’s built-in texture interpolation gives you the texture values anywhere inside the 3D texture.</p>
</section>
</section>
<section>
<h3 class="bh" id="bh1303"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1303">The OpenGL Window</a></h3>
<p class="paft">As in your other OpenGL projects, this project uses the <span class="idx" data-term="GLFW"/>GLFW library to display the OpenGL window. You’ll use handlers for drawing, for resizing the window, and for keyboard events. You’ll use keyboard events to toggle between volume and slice rendering, as well as for rotating and slicing through the 3D data.</p>
</section>
</section>
<section>
<h2 class="ah" id="ah1302"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1302">Requirements</a></h2>
<p class="paft">You’ll use <span class="idx" data-term="PyOpenGL module"/><code>PyOpenGL</code>, a popular Python binding for OpenGL, for rendering. You’ll also use the Python Imaging Library (PIL) to load the 2D images from the volumetric data set, and you’ll use <code>numpy</code> arrays to represent 3D coordinates and transformation matrices.</p>
</section>
<section>
<h2 class="ah" id="ah1303"><span aria-label=" Page 221. " class="page" epub:type="pagebreak" id="p221" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1303">The Code</a></h2>
<p class="paft">You’ll begin by generating a 3D texture from the volumetric data read in from the image files. Next, you’ll look at a color cube technique for generating rays from the eye that point into the volume, which is a key concept in implementing the volume ray casting algorithm. You’ll look at how to define the cube geometry as well as how to draw the back- and front-faces of this cube. You’ll then explore the volume ray casting algorithm and the associated vertex and fragment shaders. Finally, you’ll learn how to implement 2D slicing of the volumetric data.</p>
<p>This project has seven Python files:</p>
<p class="pcust2"><span class="bi">glutils.py</span> Contains the utility methods for OpenGL shaders, transformations, and so on</p>
<p class="pcust2"><span class="bi">makedata.py</span> Contains utility methods for creating volumetric data for testing</p>
<p class="pcust2"><span class="bi">raycast.py</span> Implements the <code>RayCastRender</code> class for ray casting</p>
<p class="pcust2"><span class="bi">raycube.py</span> Implements the <code>RayCube</code> class for use in <code>RayCastRender</code></p>
<p class="pcust2"><span class="bi">slicerender.py</span> Implements the <code>SliceRender</code> class for 2D slicing of volumetric data</p>
<p class="pcust2"><span class="bi">volreader.py</span> Contains the utility method to read volumetric data into the OpenGL 3D texture</p>
<p class="pcust2"><span class="bi">volrender.py</span> Contains the main methods that create the GLFW window and the renderers</p>
<p>We’ll cover all but two of these files in this chapter. The <i>makedata.py</i> file lives with the other project files for this chapter at <a class="url-i" href="https://github.com/mkvenkit/pp2e/tree/main/volrender">https://github.com/mkvenkit/pp2e/tree/main/volrender</a>. The <i>glutils.py</i> file can be downloaded from <a class="url-i" href="https://github.com/mkvenkit/pp2e/tree/main/common">https://github.com/mkvenkit/pp2e/tree/main/common</a>.</p>
<section>
<h3 class="bh" id="bh1304"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1304">Generating a 3D Texture</a></h3>
<p class="paft">The first step is to <span class="idx" data-level1="reading data (begin)" data-term="volume rendering"/>read the volumetric data from a folder containing images, as shown in the following code. To see the complete <i>volreader.py</i> code, skip ahead to <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#ah1307">“The Complete 3D Texture Code”</a> on <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#p241">page 241</a>. You can also find the <i>volreader.py</i> file at <a class="url-i" href="https://github.com/mkvenkit/pp2e/tree/main/volrender">https://github.com/mkvenkit/pp2e/tree/main/volrender</a>. Note that the <code>loadTexture()</code> function in this file is used to open an image file, read the contents, and create an OpenGL texture object out of it, which is subsequently used in rendering.</p>
<div class="codeline">
<p class="clf">def loadVolume(dirName):</p>
<p class="cl">    """read volume from directory as a 3D texture"""</p>
<p class="cl">    # list images in directory</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ files = sorted(os.<span class="idx" data-level1="listdir" data-term="os module"/>listdir(dirName))</p>
<p class="cl">    print('loading images from: %s' % dirName)</p>
<p class="cl">    imgDataList = []</p>
<p class="cl">    count = 0</p>
<p class="cl">    width, height = 0, 0</p>
<p class="cl"><span aria-label=" Page 222. " class="page" epub:type="pagebreak" id="p222" role="doc-pagebreak"/>    for file in files:</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ file_path = os.path.<span class="idx" data-level1="path" data-term="os module"/>abspath(os.path.<span class="idx" data-level1="path" data-term="os module"/>join(dirName, file))</p>
<p class="cl">        try:</p>
<p class="cl">            # read image</p>
<p class="cl">          <!--<ccust1>3</ccust1>-->❸ img = Image.<span class="idx" data-level1="Image" data-term="Python Imaging Library"/>open(file_path)</p>
<p class="cl">            imgData = np.array(img.getdata(), np.uint8)</p>
<p class="clf">            # check if all images are of the same size</p>
<p class="cl">          <!--<ccust1>4</ccust1>-->❹ if count is 0:</p>
<p class="cl">                width, height = img.size[0], img.size[1]</p>
<p class="cl">                imgDataList.append(imgData)</p>
<p class="cl">            else:</p>
<p class="cl">              <!--<ccust1>5</ccust1>-->❺ if (width, height) == (img.size[0], img.size[1]):</p>
<p class="cl">                    imgDataList.append(imgData)</p>
<p class="cl">            else:</p>
<p class="cl">                print('mismatch')</p>
<p class="cl">                raise RunTimeError("image size mismatch")</p>
<p class="cl">            count += 1</p>
<p class="cl">            # print img.size</p>
<p class="cl">      <!--<ccust1>6</ccust1>-->❻ except:</p>
<p class="cl">            # skip</p>
<p class="cl">            print('Invalid image: %s' % file_path)</p>
<p class="clf">    # load image data into single array</p>
<p class="cl">    depth = count</p>
<p class="cl">  <!--<ccust1>7</ccust1>-->❼ data = np.<span class="idx" data-level1="array" data-term="numpy module"/>concatenate(imgDataList)</p>
<p class="cll">    print('volume data dims: %d %d %d' % (width, height, depth))</p>
</div>
<p>The <code>loadVolume()</code> method first lists the files in the given directory using the <code>listdir()</code> method from the <code>os</code> module <!--<ccust1>1</ccust1>-->❶. Then you iterate through the image files themselves, loading them one at a time. To do this, you append the current filename to the directory using <code>os.path.abspath()</code> and <code>os.path.join()</code> <!--<ccust1>2</ccust1>-->❷, eliminating the need to deal with relative filepaths and operating system–specific path conventions. (You often see this useful idiom in Python code that traverses files and directories.) Next, you use the <code>Image</code> class from the PIL to load the current image into an 8-bit <code>numpy</code> array <!--<ccust1>3</ccust1>-->❸. If the file specified isn’t an image or if the image fails to load, an exception is thrown, which you catch by printing an error <!--<ccust1>6</ccust1>-->❻.</p>
<p>Because you’re loading these image slices into a 3D texture, you need to ensure they all have the same dimensions (width × height), which you confirm at <!--<ccust1>4</ccust1>-->❹ and <!--<ccust1>5</ccust1>-->❺. You store the dimensions for the first image and compare them against new incoming images. Once all the images are loaded into individual arrays, you create the final array containing the 3D data by joining these arrays using the <code>concatenate()</code> method from <code>numpy</code> <!--<ccust1>7</ccust1>-->❼.</p>
<p>The <code>loadVolume()</code> function continues by loading the array of 3D image data into an OpenGL texture:</p>
<div class="codeline">
<p class="clf">    # load data into 3D texture</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ texture = <span class="idx" data-level1="glGenTextures" data-term="OpenGL"/>glGenTextures(1)</p>
<p class="cl">    <span class="idx" data-level1="glPixelStorei" data-term="OpenGL"/>glPixelStorei(GL_UNPACK_ALIGNMENT, 1)</p>
<p class="cl">    <span class="idx" data-level1="glBindTexture" data-term="OpenGL"/>glBindTexture(GL_TEXTURE_3D, texture)</p>
<p class="cl">    <span class="idx" data-level1="glTexParameterf" data-term="OpenGL"/>glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)</p>
<p class="cl"><span aria-label=" Page 223. " class="page" epub:type="pagebreak" id="p223" role="doc-pagebreak"/>    glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)</p>
<p class="cl">    glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE)</p>
<p class="cl">    glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)</p>
<p class="cl">    glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ <span class="idx" data-term="glTexImage3D"/><span class="idx" data-level1="glTexImage3D" data-term="OpenGL"/>glTexImage3D(GL_TEXTURE_3D, 0, GL_RED,</p>
<p class="cl">                 width, height, depth, 0,</p>
<p class="cl">                 GL_RED, GL_UNSIGNED_BYTE, data)</p>
<p class="cl">    # return texture</p>
<p class="cll">  <!--<ccust1>3</ccust1>-->❸ return (texture, width, height, depth)</p>
</div>
<p>Here you create an OpenGL texture <!--<ccust1>1</ccust1>-->❶ and set parameters for filtering and unpacking. Then you load the 3D data array into the OpenGL texture <!--<ccust1>2</ccust1>-->❷. The format used here is <code>GL_RED</code>, and the data format is <code>GL_UNSIGNED_BYTE</code> because you have only one 8-bit value associated with each pixel in the data. Finally, you return the OpenGL texture ID and the dimensions of the 3D texture <!--<ccust1>3</ccust1>-->❸.<span class="idx" data-level1="reading data (end)" data-term="volume rendering"/></p>
</section>
<section>
<h3 class="bh" id="bh1305"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1305">Generating Rays</a></h3>
<p class="paft">The code for generating the rays is encapsulated in a class called <code>RayCube</code>. This class is responsible for drawing the color cube and has methods to draw the back-faces of the cube to an FBO or texture and to draw the front-faces of the cube to the screen. To see the complete <i>raycube.py</i> code, skip ahead to <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#ah1308">“The Complete Ray Generation Code”</a> on <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#p242">page 242</a>. You can also find the <i>raycube.py</i> file at <a class="url-i" href="https://github.com/mkvenkit/pp2e/tree/main/volrender">https://github.com/mkvenkit/pp2e/tree/main/volrender</a>.</p>
<p>First, let’s define the shaders used by this class. The shaders will be compiled as part of the <code>RayCube</code> class’s constructor:</p>
<div class="codeline">
<p class="cl2f"><!--<ccust1>1</ccust1>-->❶ strVS = """</p>
<p class="cl"># version 410 core</p>
<p class="clf">layout(location = 1) in vec3 cubePos;</p>
<p class="cl">layout(location = 2) in vec3 cubeCol;</p>
<p class="clf"><span class="idx" data-level1="GLSL" data-term="OpenGL"/>uniform <span class="idx" data-level1="GLSL" data-term="OpenGL"/>mat4 uMVMatrix;</p>
<p class="cl">uniform mat4 uPMatrix;</p>
<p class="cl">out <span class="idx" data-level1="GLSL" data-term="OpenGL"/>vec4 vColor;</p>
<p class="clf">void main()</p>
<p class="cl">{</p>
<p class="cl">    // set back-face color</p>
<p class="cl">    vColor = vec4(cubeCol.rgb, 1.0);</p>
<p class="clf">    // transformed position</p>
<p class="cl">    vec4 newPos = vec4(cubePos.xyz, 1.0);</p>
<p class="clf">    // set position</p>
<p class="cl">    <span class="idx" data-level1="GLSL" data-term="OpenGL"/>gl_Position = uPMatrix * uMVMatrix * newPos;</p>
<p class="clf">}</p>
<p class="cl">"""</p>
<p class="cl2"><!--<ccust1>2</ccust1>-->❷ strFS = """</p>
<p class="cl"># version 410 core</p>
<p class="clf"><span aria-label=" Page 224. " class="page" epub:type="pagebreak" id="p224" role="doc-pagebreak"/>in vec4 vColor;</p>
<p class="cl">out vec4 fragColor;</p>
<p class="clf">void main()</p>
<p class="cl">{</p>
<p class="cl">    <span class="idx" data-level1="GLSL" data-term="OpenGL"/>fragColor = vColor;</p>
<p class="cl">}</p>
<p class="cll">"""</p>
</div>
<p>You define the vertex shader used by the <code>RayCube</code> class <!--<ccust1>1</ccust1>-->❶. This shader has two input attributes, <code>cubePos</code> and <code>cubeCol</code>, which are used to access the position and color values of the vertices, respectively. The <span class="idx" data-term="modelview matrix"/>modelview and <span class="idx" data-term="projection matrix"/>projection matrices are passed in with the uniform variables <code>uMVMatrix</code> and <code>uPMatrix</code>, respectively. The <code>vColor</code> variable is declared as output because it needs to be passed on to the fragment shader, where it will be interpolated. The fragment shader <!--<ccust1>2</ccust1>-->❷ sets the fragment color to the (interpolated) value of the incoming <code>vColor</code> set in the vertex shader.</p>
<section>
<h4 class="ch" id="ch1303">Defining the Color Cube Geometry</h4>
<p class="paft">Now let’s look at the <span class="idx" data-level1="geometry definition" data-term="volume rendering"/>geometry of the color cube, defined in the <code>RayCube</code> class’s constructor:</p>
<div class="codeline">
<p class="clf">class RayCube:</p>
<p class="cl">    def __init__(self, width, height):</p>
<p class="cl">    --<code class="i">snip</code>--</p>
<p class="cl">        # cube vertices</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ vertices = numpy.array([</p>
<p class="cl">                0.0, 0.0, 0.0,</p>
<p class="cl">                1.0, 0.0, 0.0,</p>
<p class="cl">                1.0, 1.0, 0.0,</p>
<p class="cl">                0.0, 1.0, 0.0,</p>
<p class="cl">                0.0, 0.0, 1.0,</p>
<p class="cl">                1.0, 0.0, 1.0,</p>
<p class="cl">                1.0, 1.0, 1.0,</p>
<p class="cl">                0.0, 1.0, 1.0</p>
<p class="cl">                ], numpy.float32)</p>
<p class="cl">        # cube colors</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ colors = numpy.array([</p>
<p class="cl">                0.0, 0.0, 0.0,</p>
<p class="cl">                1.0, 0.0, 0.0,</p>
<p class="cl">                1.0, 1.0, 0.0,</p>
<p class="cl">                0.0, 1.0, 0.0,</p>
<p class="cl">                0.0, 0.0, 1.0,</p>
<p class="cl">                1.0, 0.0, 1.0,</p>
<p class="cl">                1.0, 1.0, 1.0,</p>
<p class="cl">                0.0, 1.0, 1.0</p>
<p class="cl">                ], numpy.float32)</p>
<p class="clf">        # individual triangles</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ indices = numpy.array([</p>
<p class="cl">                4, 5, 7,</p>
<p class="cl">                7, 5, 6,</p>
<p class="cl"><span aria-label=" Page 225. " class="page" epub:type="pagebreak" id="p225" role="doc-pagebreak"/>                5, 1, 6,</p>
<p class="cl">                6, 1, 2,</p>
<p class="cl">                1, 0, 2,</p>
<p class="cl">                2, 0, 3,</p>
<p class="cl">                0, 4, 3,</p>
<p class="cl">                3, 4, 7,</p>
<p class="cl">                6, 2, 7,</p>
<p class="cl">                7, 2, 3,</p>
<p class="cl">                4, 0, 5,</p>
<p class="cl">                5, 0, 1</p>
<p class="cll">                ], numpy.int16)</p>
</div>
<p>You define the cube geometry <!--<ccust1>1</ccust1>-->❶ and the colors <!--<ccust1>2</ccust1>-->❷ as <code>numpy</code> arrays. Notice that the values in these two definitions are the same. As we discussed earlier, the color of each pixel in the color cube corresponds to that pixel’s 3D coordinates. The color cube has six faces, each of which can be drawn as <span class="idx" data-level1="color cube" data-term="volume rendering"/>two triangles, for a total of 6×6, or 36, vertices. But rather than specify all 36 vertices, you specify just the cube’s eight corners <!--<ccust1>1</ccust1>-->❶ and then define the triangles formed with those corners using an <code>indices</code> array <!--<ccust1>3</ccust1>-->❸, as illustrated in <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#fig11-5">Figure 11-5</a>. The first two sets of three indices, for example, (4, 5, 7) and (7, 5, 6), define the triangles on the top face of the cube.</p>
<figure class="figure" id="fig11-5">
<p class="fig"><img alt="" height="605" src="images/nsp-venkitachalam503045-f11005.jpg" style="width:95%; height:auto;" width="599"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 11-5:</span> Using indexing, a cube can be represented as a collection of triangles, with each face composed of two triangles.</p>
</figcaption>
</figure>
<p>Next, still within the <code>RayCube</code> class constructor, you need to put the vertex information into buffers:</p>
<div class="codeline1">
<p class="cl1f">        # set up vertex array object (VAO)</p>
<p class="cl1">        self.vao = <span class="idx" data-level1="glGenVertexArrays" data-term="OpenGL"/>glGenVertexArrays(1)</p>
<p class="cl1">        <span class="idx" data-level1="glBindVertexArray" data-term="OpenGL"/>glBindVertexArray(self.vao)</p>
<p class="cl1f">        # vertex buffer</p>
<p class="cl1">        self.vertexBuffer = <span class="idx" data-level1="glGenBuffers" data-term="OpenGL"/>glGenBuffers(1)</p>
<p class="cl1">        <span class="idx" data-level1="glBindBuffer" data-term="OpenGL"/>glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)</p>
<p class="cl1">        <span class="idx" data-level1="glBufferData" data-term="OpenGL"/>glBufferData(GL_ARRAY_BUFFER, 4*len(vertices), vertices, GL_STATIC_DRAW)</p>
<p class="cl1f"><span aria-label=" Page 226. " class="page" epub:type="pagebreak" id="p226" role="doc-pagebreak"/>        # vertex buffer – cube vertex colors</p>
<p class="cl1">        self.colorBuffer = glGenBuffers(1)</p>
<p class="cl1">        glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)</p>
<p class="cl1">        glBufferData(GL_ARRAY_BUFFER, 4*len(colors), colors, GL_STATIC_DRAW)</p>
<p class="cl1f">        # index buffer</p>
<p class="cl1">        self.indexBuffer = glGenBuffers(1)</p>
<p class="cl1">        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.indexBuffer); <!--<ccust1>1</ccust1>-->❶</p>
<p class="cl1">        glBufferData(GL_ELEMENT_ARRAY_BUFFER, 2*len(indices), indices,</p>
<p class="cl1l">                     GL_STATIC_DRAW)</p>
</div>
<p>As with previous projects, you create and bind to a vertex array object (VAO) and then define the buffers it manages. One difference here is that the <code>indices</code> array is given the designation <span class="idx" data-level1="GL_ELEMENT_ARRAY_BUFFER" data-term="OpenGL"/><code>GL_ELEMENT_ARRAY_BUFFER</code> <!--<ccust1>1</ccust1>-->❶, which means the elements in its buffer will be used to index and access the data in the color and vertex buffers.</p>
</section>
<section>
<h4 class="ch" id="ch1304">Creating the Frame Buffer Object</h4>
<p class="paft">Now let’s jump to the <code>RayCube</code> class method that creates the frame buffer object, where you’ll direct your rendering:</p>
<div class="codeline">
<p class="clf">def <span class="idx" data-level1="color cube" data-term="volume rendering"/>initFBO(self):</p>
<p class="cl">    # create frame buffer object</p>
<p class="cl">    self.fboHandle = <span class="idx" data-level1="glGenFramebuffers" data-term="OpenGL"/>glGenFramebuffers(1)</p>
<p class="cl">    # create texture</p>
<p class="cl">    self.texHandle = <span class="idx" data-level1="glGenTextures" data-term="OpenGL"/>glGenTextures(1)</p>
<p class="cl">    # create depth buffer</p>
<p class="cl">    self.depthHandle = <span class="idx" data-level1="glGenRenderbuffers" data-term="OpenGL"/>glGenRenderbuffers(1)</p>
<p class="clf">    # bind</p>
<p class="cl">    <span class="idx" data-level1="glBindFramebuffer" data-term="OpenGL"/>glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)</p>
<p class="clf">    <span class="idx" data-level1="glActiveTexture" data-term="OpenGL"/>glActiveTexture(GL_TEXTURE0)</p>
<p class="cl">    <span class="idx" data-level1="glBindTexture" data-term="OpenGL"/>glBindTexture(GL_TEXTURE_2D, self.texHandle)</p>
<p class="clf">    # set parameters to draw the image at different sizes</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ <span class="idx" data-level1="glTexParameteri" data-term="OpenGL"/>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)</p>
<p class="cl">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)</p>
<p class="cl">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)</p>
<p class="cl">    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)</p>
<p class="clf">    # set up texture</p>
<p class="cl">    <span class="idx" data-level1="glTexImage2D" data-term="OpenGL"/>glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, self.width, self.height,</p>
<p class="cl">                 0, GL_RGBA, GL_UNSIGNED_BYTE, None)</p>
<p class="clf">    # bind texture to FBO</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ <span class="idx" data-level1="glFramebufferTexture2D" data-term="OpenGL"/>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</p>
<p class="cl">                           GL_TEXTURE_2D, self.texHandle, 0)</p>
<p class="clf">    # bind</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ <span class="idx" data-level1="glBindRenderbuffer" data-term="OpenGL"/>glBindRenderbuffer(GL_RENDERBUFFER, self.depthHandle)</p>
<p class="cl">    <span class="idx" data-level1="glRenderbufferStorage" data-term="OpenGL"/>glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24,</p>
<p class="cl">                          self.width, self.height)</p>
<p class="clf"><span aria-label=" Page 227. " class="page" epub:type="pagebreak" id="p227" role="doc-pagebreak"/>    # bind depth buffer to FBO</p>
<p class="cl">    <span class="idx" data-level1="glFramebufferRenderbuffer" data-term="OpenGL"/>glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,</p>
<p class="cl">                              GL_RENDERBUFFER, self.depthHandle)</p>
<p class="clf">    # check status</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ status = <span class="idx" data-level1="glCheckFramebufferStatus" data-term="OpenGL"/>glCheckFramebufferStatus(GL_FRAMEBUFFER)</p>
<p class="cl">    if status == GL_FRAMEBUFFER_COMPLETE:</p>
<p class="cl">        pass</p>
<p class="cl">        # print "fbo %d complete" % self.fboHandle</p>
<p class="cl">    elif status == GL_FRAMEBUFFER_UNSUPPORTED:</p>
<p class="cl">        print "fbo %d unsupported" % self.fboHandle</p>
<p class="cl">    else:</p>
<p class="cll">        print "fbo %d Error" % self.fboHandle</p>
</div>
<p>Here you create a frame buffer object, a 2D texture, and a render buffer object; then you set up the texture parameters <!--<ccust1>1</ccust1>-->❶. The texture is bound to the frame buffer <!--<ccust1>2</ccust1>-->❷, and at <!--<ccust1>3</ccust1>-->❸ and in the lines that follow, the render buffer sets up a 24-bit depth buffer and is attached to the frame buffer. Next, you check the status of the frame buffers <!--<ccust1>4</ccust1>-->❹ and print a status message if something goes wrong. Now, as long as the frame buffer and render buffer are bound correctly, all of your rendering will go into the texture.</p>
</section>
<section>
<h4 class="ch" id="ch1305">Rendering the Back-Faces of the Cube</h4>
<p class="paft">Here is the code for rendering the back-faces of the color cube:</p>
<div class="codeline">
<p class="clf">def <span class="idx" data-level1="color cube" data-term="volume rendering"/>renderBackFace(self, pMatrix, mvMatrix):</p>
<p class="cl">    """renders back-face of ray-cube to a texture and returns it"""</p>
<p class="cl">    # render to FBO</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)</p>
<p class="cl">    # set active texture</p>
<p class="cl">    glActiveTexture(GL_TEXTURE0)</p>
<p class="cl">    # bind to FBO texture</p>
<p class="cl">    glBindTexture(GL_TEXTURE_2D, self.texHandle)</p>
<p class="clf">    # render cube with face culling enabled</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ self.renderCube(pMatrix, mvMatrix, self.program, True)</p>
<p class="clf">    # unbind texture</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ glBindTexture(GL_TEXTURE_2D, 0)</p>
<p class="cl">    glBindFramebuffer(GL_FRAMEBUFFER, 0)</p>
<p class="cl">    glBindRenderbuffer(GL_RENDERBUFFER, 0)</p>
<p class="clf">    # return texture ID</p>
<p class="cll">  <!--<ccust1>4</ccust1>-->❹ return self.texHandle</p>
</div>
<p>First you bind the FBO <!--<ccust1>1</ccust1>-->❶, set the active texture unit, and bind to the texture handle so that you can render to the FBO. Then you call the <code>RayCube</code> class’s <code>renderCube()</code> method <!--<ccust1>2</ccust1>-->❷, which we’ll look at soon. It has a face-culling flag as an argument, allowing you to draw either the front-face or the back-face of the cube using the same code. You set the flag to <code>True</code> to make the back-faces appear in the FBO texture.</p>
<p><span aria-label=" Page 228. " class="page" epub:type="pagebreak" id="p228" role="doc-pagebreak"/>Next, you make the necessary calls to unbind from the FBO so that other rendering code is unaffected <!--<ccust1>3</ccust1>-->❸. Finally, you return the FBO texture ID <!--<ccust1>4</ccust1>-->❹ for use in the next stage of the algorithm.</p>
</section>
<section>
<h4 class="ch" id="ch1306">Rendering the Front-Faces of the Cube</h4>
<p class="paft">The following code is used to <span class="idx" data-level1="color cube" data-term="volume rendering"/>draw the front-faces of the color cube during the second rendering pass of the ray casting algorithm:</p>
<div class="codeline">
<p class="clf">def renderFrontFace(self, pMatrix, mvMatrix, program):</p>
<p class="cl">    """render front-face of ray-cube"""</p>
<p class="cl">    # no face culling</p>
<p class="cll">    self.renderCube(pMatrix, mvMatrix, program, False)</p>
</div>
<p>This method simply calls <code>renderCube()</code>, with the face-culling flag set to <code>False</code> so the front-faces will appear.</p>
</section>
<section>
<h4 class="ch" id="ch1307">Rendering the Whole Cube</h4>
<p class="paft">Now let’s look at the <code>renderCube()</code> method, which draws the color cube discussed previously:</p>
<div class="codeline">
<p class="clf">def <span class="idx" data-level1="color cube" data-term="volume rendering"/>renderCube(self, pMatrix, mvMatrix, program, cullFace):</p>
<p class="cl">    """renderCube uses face culling if flag set"""</p>
<p class="clf">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)</p>
<p class="clf">    # set shader program</p>
<p class="cl">    glUseProgram(program)</p>
<p class="clf">    # set projection matrix</p>
<p class="cl">    <span class="idx" data-level1="glUniformMatrix4fv" data-term="OpenGL"/>glUniformMatrix4fv(glGetUniformLocation(program, b'uPMatrix'),</p>
<p class="cl">                       1, GL_FALSE, pMatrix)</p>
<p class="clf">    # set modelview matrix</p>
<p class="cl">    glUniformMatrix4fv(glGetUniformLocation(program, b'uMVMatrix'),</p>
<p class="cl">                       1, GL_FALSE, mvMatrix)</p>
<p class="clf">    # enable face culling</p>
<p class="cl">    glDisable(<span class="idx" data-level1="GL_CULL_FACE" data-term="OpenGL"/>GL_CULL_FACE)</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ if cullFace:</p>
<p class="cl">        glFrontFace(GL_CCW)</p>
<p class="cl">        glCullFace(GL_FRONT)</p>
<p class="cl">        glEnable(GL_CULL_FACE)</p>
<p class="clf">    # bind VAO</p>
<p class="cl">    <span class="idx" data-level1="glBindVertexArray" data-term="OpenGL"/>glBindVertexArray(self.vao)</p>
<p class="clf">    # animated slice</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ <span class="idx" data-level1="glDrawElements" data-term="OpenGL"/>glDrawElements(GL_TRIANGLES, self.nIndices, GL_UNSIGNED_SHORT, None)</p>
<p class="clf">    # unbind VAO</p>
<p class="cl">    glBindVertexArray(0)</p>
<p class="clf"><span aria-label=" Page 229. " class="page" epub:type="pagebreak" id="p229" role="doc-pagebreak"/>    # reset cull face</p>
<p class="cl">    if cullFace:</p>
<p class="cl">        # disable face culling</p>
<p class="cll">        glDisable(GL_CULL_FACE)</p>
</div>
<p>You clear the color and depth buffers, select the shader program, and set the transformation matrices. Then you set a flag to control face culling <!--<ccust1>1</ccust1>-->❶, which determines whether the cube’s front-face or back-face is drawn. Notice that you use <code>glDrawElements()</code> <!--<ccust1>2</ccust1>-->❷ because you’re using an index array to render the cube, rather than a vertex array.</p>
</section>
<section>
<h4 class="ch" id="ch1308">Resizing the Window</h4>
<p class="paft">Because the FBO is created for a particular window size, you need to re-create it when the window size changes. To do that, you create a resize handler for the <code>RayCube</code> class, as shown here:</p>
<div class="codeline">
<p class="clf">def reshape(self, width, height):</p>
<p class="cl">    self.width = width</p>
<p class="cl">    self.height = height</p>
<p class="cl">    self.aspect = width/float(height)</p>
<p class="cl">    # re-create FBO</p>
<p class="cl">    self.clearFBO()</p>
<p class="cll">    self.initFBO()</p>
</div>
<p>The <code>reshape()</code> method is called when the OpenGL window is resized. It checks the new window dimensions and then clears and re-creates the FBO.</p>
</section>
</section>
<section>
<h3 class="bh" id="bh1306"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1306">Implementing the Ray Casting Algorithm</a></h3>
<p class="paft">Next, you’ll implement the <span class="idx" data-level1="ray casting algorithm" data-term="volume rendering"/>ray casting algorithm in the <code>RayCastRender</code> class. The core of the algorithm happens inside the fragment shader used by this class, which also uses the <code>RayCube</code> class to help generate the rays. To see the complete <i>raycast.py</i> code, skip ahead to <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#ah1309">“The Complete Volume Ray Casting Code”</a> on <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#p248">page 248</a>. You can also find this file at <a class="url-i" href="https://github.com/mkvenkit/pp2e/tree/main/volrender">https://github.com/mkvenkit/pp2e/tree/main/volrender</a>.</p>
<p>Begin in the <code>RayCastRender</code> constructor by creating a <code>RayCube</code> object and loading the shaders:</p>
<div class="codeline">
<p class="clf">class RayCastRender:</p>
<p class="cl">    def __<span class="idx" data-level1="ray casting" data-term="volume rendering"/>init__(self, width, height, volume):</p>
<p class="cl">        """RayCastRender construction"""</p>
<p class="clf">        # create RayCube object</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ self.raycube = raycube.RayCube(width, height)</p>
<p class="clf">        # set dimensions</p>
<p class="cl">        self.width = width</p>
<p class="cl">        self.height = height</p>
<p class="cl">        self.aspect = width/float(height)</p>
<p class="clf"><span aria-label=" Page 230. " class="page" epub:type="pagebreak" id="p230" role="doc-pagebreak"/>        # create shader</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ self.program = glutils.loadShaders(strVS, strFS)</p>
<p class="cl">        # texture</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ self.texVolume, self.Nx, self.Ny, self.Nz = volume</p>
<p class="clf">        # initialize camera</p>
<p class="cll">      <!--<ccust1>4</ccust1>-->❹ self.camera = Camera()</p>
</div>
<p>The constructor creates an object of type <code>RayCube</code> <!--<ccust1>1</ccust1>-->❶, which is used to generate rays. You load the shaders used by the ray casting <!--<ccust1>2</ccust1>-->❷ and then set the OpenGL 3D texture and dimensions <!--<ccust1>3</ccust1>-->❸, which were passed into the constructor as the tuple <code>volume</code>. Next, you create a <code>Camera</code> object <!--<ccust1>4</ccust1>-->❹, which you’ll use to set up the OpenGL perspective transformation for the 3D rendering.</p>
<p class="pcust1"><span class="ccust3">NOTE</span> The <code>Camera</code> class, also declared in <i>raycast.py</i>, is basically the same as the one used in <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#ch10">Chapter 10</a>. You’ll see it in the complete code listing on <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#p248">page 248</a>.</p>
<p>Here is the rendering method for <code>RayCastRender</code>:</p>
<div class="codeline">
<p class="clf">def <span class="idx" data-level1="ray casting" data-term="volume rendering"/>draw(self):</p>
<p class="clf">    # build projection matrix</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ pMatrix = glutils.perspective(45.0, self.aspect, 0.1, 100.0)</p>
<p class="clf">    # modelview matrix</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ mvMatrix = glutils.lookAt(self.camera.eye, self.camera.center,</p>
<p class="cl">                              self.camera.up)</p>
<p class="clf">    # render</p>
<p class="clf">    # generate ray-cube back-face texture</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ texture = self.raycube.renderBackFace(pMatrix, mvMatrix)</p>
<p class="clf">    # set shader program</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ glUseProgram(self.program)</p>
<p class="clf">    # set window dimensions</p>
<p class="cl">    glUniform2f(glGetUniformLocation(self.program, b"uWinDims"),</p>
<p class="cl">                float(self.width), float(self.height))</p>
<p class="clf">    # bind to texture unit 0, which represents back-faces of cube</p>
<p class="cl">  <!--<ccust1>5</ccust1>-->❺ glActiveTexture(GL_TEXTURE0)</p>
<p class="cl">    glBindTexture(GL_TEXTURE_2D, texture)</p>
<p class="cl">    glUniform1i(glGetUniformLocation(self.program, b"texBackFaces"), 0)</p>
<p class="clf">    # texture unit 1: 3D volume texture</p>
<p class="cl">  <!--<ccust1>6</ccust1>-->❻ glActiveTexture(GL_TEXTURE1)</p>
<p class="cl">    glBindTexture(GL_TEXTURE_3D, self.texVolume)</p>
<p class="cl">    glUniform1i(glGetUniformLocation(self.program, b"texVolume"), 1)</p>
<p class="clf">    # draw front-face of cubes</p>
<p class="cll">  <!--<ccust1>7</ccust1>-->❼ self.raycube.renderFrontFace(pMatrix, mvMatrix, self.program)</p>
</div>
<p><span aria-label=" Page 231. " class="page" epub:type="pagebreak" id="p231" role="doc-pagebreak"/>First you set up a perspective projection matrix for the rendering, using the <code>glutils.perspective()</code> utility method <!--<ccust1>1</ccust1>-->❶. Then you set the current camera parameters into the <code>glutils.lookAt()</code> method <!--<ccust1>2</ccust1>-->❷. Next, the first pass of the rendering is done <!--<ccust1>3</ccust1>-->❸, using the <code>renderBackFace()</code> method in <code>RayCube</code> to draw the back-faces of the color cube into a texture. (This method also returns the ID of the generated texture.)</p>
<p>You continue by enabling the shaders for the ray casting algorithm <!--<ccust1>4</ccust1>-->❹. Then you set up the textures for use in the shader program. The texture returned at <!--<ccust1>3</ccust1>-->❸ is set up as texture unit 0 <!--<ccust1>5</ccust1>-->❺, and the 3D texture created from the volumetric data you read in is set up as texture unit 1 <!--<ccust1>6</ccust1>-->❻. Finally, you render the front-faces of the cube using the <code>renderFrontFace()</code> method in <code>RayCube</code> <!--<ccust1>7</ccust1>-->❼. When this code is executed, the shaders for <code>RayCastRender</code> will act on the vertices and fragments.</p>
<section>
<h4 class="ch" id="ch1309">The Vertex Shader</h4>
<p class="paft">Now you come to the shaders used by <code>RayCastRender</code>. Let’s look at the <span class="idx" data-level1="ray casting" data-term="volume rendering"/>vertex shader first:</p>
<div class="codeline">
<p class="clf">strVS = """</p>
<p class="cl"># version 410 core</p>
<p class="cl2f"><!--<ccust1>1</ccust1>-->❶ layout(location = 1) in vec3 cubePos;</p>
<p class="cl">layout(location = 2) in vec3 cubeCol;</p>
<p class="cl2f"><!--<ccust1>2</ccust1>-->❷ <span class="idx" data-level1="GLSL" data-term="OpenGL"/>uniform <span class="idx" data-level1="GLSL" data-term="OpenGL"/>mat4 uMVMatrix;</p>
<p class="cl">uniform mat4 uPMatrix;</p>
<p class="cl2f"><!--<ccust1>3</ccust1>-->❸ out <span class="idx" data-level1="GLSL" data-term="OpenGL"/>vec4 vColor;</p>
<p class="clf">void main()</p>
<p class="cl">{</p>
<p class="cl">    // set position</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ <span class="idx" data-level1="GLSL" data-term="OpenGL"/>gl_Position = uPMatrix * uMVMatrix * vec4(cubePos.xyz, 1.0);</p>
<p class="clf">    // set color</p>
<p class="cl">  <!--<ccust1>5</ccust1>-->❺ vColor = vec4(cubeCol.rgb, 1.0);</p>
<p class="cl">}</p>
<p class="cll">"""</p>
</div>
<p>First you set the input variables of position and color <!--<ccust1>1</ccust1>-->❶. The layout uses the same indices as defined in the <code>RayCube</code> vertex shader because <code>RayCastRender</code> uses the VBO defined in that class to draw the geometry, and the locations in the shaders have to match. Then you define the input transformation matrices <!--<ccust1>2</ccust1>-->❷ and set a color value as the shader output <!--<ccust1>3</ccust1>-->❸. The usual transformation computes the built-in <code>gl_Position</code> output <!--<ccust1>4</ccust1>-->❹, before you set the output as the current color of the cube vertex <!--<ccust1>5</ccust1>-->❺. The latter will be interpolated across vertices to give you the correct color in the fragment shader.</p>
</section>
<section>
<h4 class="ch" id="ch1310"><span aria-label=" Page 232. " class="page" epub:type="pagebreak" id="p232" role="doc-pagebreak"/>The Fragment Shader</h4>
<p class="paft">The <span class="idx" data-level1="ray casting" data-term="volume rendering"/>fragment shader is the star of the show. It implements the core of the ray casting algorithm.</p>
<div class="codeline">
<p class="clf">strFS = """</p>
<p class="cl"># version 410 core</p>
<p class="clf">in vec4 vColor;</p>
<p class="clf"><span class="idx" data-level1="GLSL" data-term="OpenGL"/>uniform <span class="idx" data-level1="GLSL" data-term="OpenGL"/>sampler2D texBackFaces;</p>
<p class="cl">uniform <span class="idx" data-level1="GLSL" data-term="OpenGL"/>sampler3D texVolume;</p>
<p class="cl">uniform <span class="idx" data-level1="GLSL" data-term="OpenGL"/>vec2 uWinDims;</p>
<p class="clf">out <span class="idx" data-level1="GLSL" data-term="OpenGL"/>vec4 fragColor;</p>
<p class="clf">void main()</p>
<p class="cl">{</p>
<p class="cl">    // start of ray</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ vec3 start = vColor.rgb;</p>
<p class="clf">    // calculate texture coordinates at fragment,</p>
<p class="cl">    // which is a fraction of window coordinates</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ vec2 texc = <span class="idx" data-level1="GLSL" data-term="OpenGL"/>gl_FragCoord.xy/uWinDims.xy;</p>
<p class="clf">    // get end of ray by looking up back-face color</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ vec3 end = <span class="idx" data-level1="GLSL" data-term="OpenGL"/>texture(texBackFaces, texc).rgb;</p>
<p class="clf">    // calculate ray direction</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ vec3 dir = end – start;</p>
<p class="clf">    // normalized ray direction</p>
<p class="cl">    vec3 norm_dir = <span class="idx" data-level1="GLSL" data-term="OpenGL"/>normalize(dir);</p>
<p class="clf">    // the length from front to back is calculated and</p>
<p class="cl">    // used to terminate the ray</p>
<p class="cl">    float len = <span class="idx" data-level1="GLSL" data-term="OpenGL"/>length(dir.xyz);</p>
<p class="clf">    // ray step size</p>
<p class="cl">    float stepSize = 0.01;</p>
<p class="clf">    // X-ray projection</p>
<p class="cl">    vec4 dst = vec4(0.0);</p>
<p class="clf">    // step through the ray</p>
<p class="cl">  <!--<ccust1>5</ccust1>-->❺ for(float t = 0.0; t &lt; len; t += stepSize) {</p>
<p class="clf">        // set position to endpoint of ray</p>
<p class="cl">      <!--<ccust1>6</ccust1>-->❻ vec3 samplePos = start + t*norm_dir;</p>
<p class="clf">        // get texture value at position</p>
<p class="cl">      <!--<ccust1>7</ccust1>-->❼ float val = texture(texVolume, samplePos).r;</p>
<p class="cl">        vec4 src = vec4(val);</p>
<p class="clf"><span aria-label=" Page 233. " class="page" epub:type="pagebreak" id="p233" role="doc-pagebreak"/>        // set opacity</p>
<p class="cl">      <!--<ccust1>8</ccust1>-->❽ src.a *= 0.1;</p>
<p class="cl">        src.rgb *= src.a;</p>
<p class="clf">        // blend with previous value</p>
<p class="cl">      <!--<ccust1>9</ccust1>-->❾ dst = (1.0 - dst.a)*src + dst;</p>
<p class="clf">        // exit loop when alpha exceeds threshold</p>
<p class="cl">      <!--<ccust1>10</ccust1>-->❿ if(dst.a &gt;= 0.95)</p>
<p class="cl">            break;</p>
<p class="cl">    }</p>
<p class="clf">    // set fragment color</p>
<p class="cl">    fragColor = dst;</p>
<p class="cl">}</p>
<p class="cll">"""</p>
</div>
<p>The input to the fragment shader is the cube vertex color. The fragment shader also has access to the 2D texture generated by rendering the color cube, the 3D texture containing the volumetric data, and the dimensions of the OpenGL window.</p>
<p>While the fragment shader executes, you send in the front-faces of the cube, so by looking up the incoming color value <!--<ccust1>1</ccust1>-->❶, you get the starting point of the ray that goes into this cube. (Recall the discussion in <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#bh1302">“Ray Generation”</a> on <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#p217">page 217</a> about the connection between the colors in the cube and the ray directions.)</p>
<p>You calculate the texture coordinate of the incoming fragment on the screen <!--<ccust1>2</ccust1>-->❷. Here, dividing the location of the fragment in window coordinates by the window dimensions maps the location to the range [0, 1]. The ending point of the ray is obtained by looking up the back-face color of the cube using this texture coordinate <!--<ccust1>3</ccust1>-->❸.</p>
<p>You next calculate the ray direction <!--<ccust1>4</ccust1>-->❹ and then calculate the normalized direction and length of this ray, which will be useful in the <span class="idx" data-level1="ray casting" data-term="volume rendering"/>ray casting computation. Then you loop through the volume using the ray’s starting point and direction until it hits the ray’s endpoint <!--<ccust1>5</ccust1>-->❺. In this loop, you compute the ray’s current position inside the data volume <!--<ccust1>6</ccust1>-->❻ and look up the data value at this point <!--<ccust1>7</ccust1>-->❼. You then perform the <span class="idx" data-level1="ray casting" data-term="volume rendering"/>blending equation at <!--<ccust1>8</ccust1>-->❽ and <!--<ccust1>9</ccust1>-->❾, which gives you the X-ray effect. You combine the <code>dst</code> value with the current value of the intensity (which is attenuated using the alpha value), and the process continues along the ray. The alpha value keeps increasing until it equals the maximum threshold of 0.95 <!--<ccust1>10</ccust1>-->❿, at which point you exit the loop. The end result is a sort of average opacity through the volume at each pixel, which produces a “see-through” or X-ray effect. (Try varying the threshold and alpha attenuation to produce different effects.)</p>
</section>
</section>
<section>
<h3 class="bh" id="bh1307"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1307">Showing 2D Slices</a></h3>
<p class="paft">In addition to showing the 3D view of the volumetric data, you want to show <span class="idx" data-level1="2D slices" data-term="volume rendering"/>2D slices of the data in the x-, y-, and z-directions onscreen. The code for this is encapsulated in a class called <code>SliceRender</code>, which creates 2D <span aria-label=" Page 234. " class="page" epub:type="pagebreak" id="p234" role="doc-pagebreak"/>volumetric slices. To see the complete <i>slicerender.py</i> code, skip ahead to <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#ah1310">“The Complete 2D Slicing Code”</a> on <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#p251">page 251</a>. You can also find the <i>slicerender.py</i> file at <a class="url-i" href="https://github.com/mkvenkit/pp2e/tree/main/volrender">https://github.com/mkvenkit/pp2e/tree/main/volrender</a>.</p>
<p>Here’s the initialization code in the <code>SliceRender</code> class constructor that sets up the geometry for the slices:</p>
<div class="codeline">
<p class="clf">class SliceRender:</p>
<p class="cl">    def __init__(self, width, height, volume):</p>
<p class="cl">    --<code class="i">snip</code>--</p>
<p class="cl">        # set up vertex array object (VAO)</p>
<p class="cl">        self.vao = <span class="idx" data-level1="glGenVertexArrays" data-term="OpenGL"/>glGenVertexArrays(1)</p>
<p class="cl">        <span class="idx" data-level1="glBindVertexArray" data-term="OpenGL"/>glBindVertexArray(self.vao)</p>
<p class="clf">        # define quad vertices</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ vertexData = numpy.array([0.0, 1.0, 0.0,</p>
<p class="cl">                                  0.0, 0.0, 0.0,</p>
<p class="cl">                                  1.0, 1.0, 0.0,</p>
<p class="cl">                                  1.0, 0.0, 0.0], numpy.float32)</p>
<p class="clf">        # vertex buffer</p>
<p class="cl">        self.vertexBuffer = <span class="idx" data-level1="glGenBuffers" data-term="OpenGL"/>glGenBuffers(1)</p>
<p class="cl">        <span class="idx" data-level1="glBindBuffer" data-term="OpenGL"/>glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)</p>
<p class="cl">        <span class="idx" data-level1="glBufferData" data-term="OpenGL"/>glBufferData(GL_ARRAY_BUFFER, 4*len(vertexData), vertexData,</p>
<p class="cl">                     GL_STATIC_DRAW)</p>
<p class="cl">        # enable arrays</p>
<p class="cl">        <span class="idx" data-level1="glEnableVertexAttribArray" data-term="OpenGL"/>glEnableVertexAttribArray(self.vertIndex)</p>
<p class="cl">        # set buffers</p>
<p class="cl">        glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)</p>
<p class="cl">        <span class="idx" data-level1="glVertexAttribPointer" data-term="OpenGL"/>glVertexAttribPointer(self.vertIndex, 3, GL_FLOAT, GL_FALSE, 0, None)</p>
<p class="clf">        # unbind VAO</p>
<p class="cll">        glBindVertexArray(0)</p>
</div>
<p>This code sets up a VAO to manage the VBO, as in earlier examples. You define the geometry of a square in the XY plane <!--<ccust1>1</ccust1>-->❶. (The vertex order is that of the <code>GL_TRIANGLE_STRIP</code>, introduced in <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#ch09">Chapter 9</a>.) You’ll use this same geometry regardless of whether you’re showing slices perpendicular to <i>x</i>, <i>y</i>, or <i>z</i>. All that changes between these cases is the data plane that you pick to display from within the 3D texture. We’ll return to this idea when we look at the vertex shader.</p>
<p>Here’s a method to render the <span class="idx" data-level1="2D slices" data-term="volume rendering"/>2D slices:</p>
<div class="codeline">
<p class="clf">def draw(self):</p>
<p class="cl">    # clear buffers</p>
<p class="cl">    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)</p>
<p class="cl">    # build projection matrix</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ pMatrix = glutils.ortho(-0.6, 0.6, -0.6, 0.6, 0.1, 100.0)</p>
<p class="cl">    # modelview matrix</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ mvMatrix = numpy.array([1.0, 0.0, 0.0, 0.0,</p>
<p class="cl">                            0.0, 1.0, 0.0, 0.0,</p>
<p class="cl">                            0.0, 0.0, 1.0, 0.0,</p>
<p class="cl">                            -0.5, -0.5, -1.0, 1.0], numpy.float32)</p>
<p class="cl"><span aria-label=" Page 235. " class="page" epub:type="pagebreak" id="p235" role="doc-pagebreak"/>    # use shader</p>
<p class="cl">    glUseProgram(self.program)</p>
<p class="clf">    # set projection matrix</p>
<p class="cl">    glUniformMatrix4fv(self.pMatrixUniform, 1, GL_FALSE, pMatrix)</p>
<p class="clf">    # set modelview matrix</p>
<p class="cl">    glUniformMatrix4fv(self.mvMatrixUniform, 1, GL_FALSE, mvMatrix)</p>
<p class="clf">    # set current slice fraction</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ glUniform1f(glGetUniformLocation(self.program, b"uSliceFrac"),</p>
<p class="cl">                float(self.currSliceIndex)/float(self.currSliceMax))</p>
<p class="cl">    # set current slice mode</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ glUniform1i(glGetUniformLocation(self.program, b"uSliceMode"),</p>
<p class="cl">                self.mode)</p>
<p class="clf">    # enable texture</p>
<p class="cl">    glActiveTexture(GL_TEXTURE0)</p>
<p class="cl">    glBindTexture(GL_TEXTURE_3D, self.texture)</p>
<p class="cl">    glUniform1i(glGetUniformLocation(self.program, b"tex"), 0)</p>
<p class="clf">    # bind VAO</p>
<p class="cl">    glBindVertexArray(self.vao)</p>
<p class="cl">    # draw</p>
<p class="cl">    glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)</p>
<p class="cl">    # unbind VAO</p>
<p class="cll">    glBindVertexArray(0)</p>
</div>
<p>Each 2D slice is a square, which you build up using an OpenGL triangle strip primitive. This code goes through the render setup for the triangle strip. Note that you implement the orthographic projection using the <code>glutils.ortho()</code> method at <!--<ccust1>1</ccust1>-->❶. You set up a projection that adds a 0.1 buffer around the unit square representing the slice.</p>
<p>When you draw something with OpenGL, the default view (without any transformation applied) puts the eye at (0, 0, 0) looking down the z-axis with the y-axis pointing up. Applying the translation (−0.5, −0.5, −1.0) to your geometry centers it on the z-axis <!--<ccust1>2</ccust1>-->❷. You set the current slice fraction <!--<ccust1>3</ccust1>-->❸ (where, for example, the 10th slice out of 100 would be 0.1), set the slice mode <!--<ccust1>4</ccust1>-->❹ (to view the slices in the x-, y-, or z-direction, as represented by the integers 0, 1, and 2, respectively), and set both values to the shaders.</p>
<section>
<h4 class="ch" id="ch1311">The Vertex Shader</h4>
<p class="paft">Now let’s look at the <span class="idx" data-level1="2D slices" data-term="volume rendering"/>vertex shader for <code>SliceRender</code>:</p>
<div class="codeline">
<p class="clf">strVS = """</p>
<p class="cl"># version 410 core</p>
<p class="clf">in vec3 aVert;</p>
<p class="clf">uniform mat4 uMVMatrix;</p>
<p class="cl">uniform mat4 uPMatrix;</p>
<p class="clf"><span aria-label=" Page 236. " class="page" epub:type="pagebreak" id="p236" role="doc-pagebreak"/>uniform float uSliceFrac;</p>
<p class="cl">uniform int uSliceMode;</p>
<p class="clf">out vec3 texcoord;</p>
<p class="clf">void main() {</p>
<p class="clf">    // x slice</p>
<p class="cl">    if (uSliceMode == 0) {</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ texcoord = vec3(uSliceFrac, aVert.x, 1.0-aVert.y);</p>
<p class="cl">    }</p>
<p class="cl">    // y slice</p>
<p class="cl">    else if (uSliceMode == 1) {</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ texcoord = vec3(aVert.x, uSliceFrac, 1.0-aVert.y);</p>
<p class="cl">    }</p>
<p class="cl">    // z slice</p>
<p class="cl">    else {</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ texcoord = vec3(aVert.x, 1.0-aVert.y, uSliceFrac);</p>
<p class="cl">    }</p>
<p class="clf">    // calculate transformed vertex</p>
<p class="cl">    gl_Position = uPMatrix * uMVMatrix * vec4(aVert, 1.0);</p>
<p class="cl">}</p>
<p class="cll">"""</p>
</div>
<p>The vertex shader takes the triangle strip vertex array as input and sets a texture coordinate as output. The current slice fraction and slice mode are passed in as uniform variables <code>uSliceFrac</code> and <code>uSliceMode</code>.</p>
<p>The shader has three branches, depending on the slice mode. For example, if <code>uSliceMode</code> is <code>0</code>, you calculate the texture coordinates for an <i>x</i> slice <!--<ccust1>1</ccust1>-->❶. Because you’re slicing perpendicular to the x-direction, you want a slice parallel to the YZ plane. The 3D vertices coming in to the vertex shader also double as the 3D texture coordinates because they are in the range [0, 1], so the <span class="idx" data-level1="2D slices" data-term="volume rendering"/>texture coordinates are given as (<i>f</i>, <i>V</i><sub class="i">x</sub>, <i>V</i><sub class="i">y</sub>), where <i>f</i> is the fraction of the slice number in the direction of the x-axis and where <i>V</i><sub class="i">x</sub> and <i>V</i><sub class="i">y</sub> are the vertex coordinates. Unfortunately, the resulting image will appear upside down because the OpenGL coordinate system has its origin at the bottom left, with the y-direction pointing up; this is the reverse of what you want. To resolve this problem, you change the texture coordinate <i>t</i> to (1 − <i>t</i>) and use (<i>f</i>, <i>V</i><sub class="i">x</sub>, 1 − <i>V</i><sub class="i">y</sub>) <!--<ccust1>1</ccust1>-->❶. You use similar logic to compute the texture coordinates for y- <!--<ccust1>2</ccust1>-->❷ and z- <!--<ccust1>3</ccust1>-->❸ direction slices if the <code>uSliceMode</code> value is <code>1</code> or <code>2</code>, respectively.</p>
</section>
<section>
<h4 class="ch" id="ch1312">The Fragment Shader</h4>
<p class="paft">Here is the <span class="idx" data-level1="2D slices" data-term="volume rendering"/><span class="idx" data-level1="2D slices" data-term="volume rendering"/>fragment shader:</p>
<div class="codeline">
<p class="clf">strFS = """</p>
<p class="cl"># version 410 core</p>
<p class="cl2f"><!--<ccust1>1</ccust1>-->❶ in vec3 texcoord;</p>
<p class="cl2f"><span aria-label=" Page 237. " class="page" epub:type="pagebreak" id="p237" role="doc-pagebreak"/><!--<ccust1>2</ccust1>-->❷ uniform sampler3D texture;</p>
<p class="clf">out vec4 fragColor;</p>
<p class="clf">void main() {</p>
<p class="cl">    // look up color in texture</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ vec4 col = texture(tex, texcoord);</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ fragColor = col.rrra;</p>
<p class="cl">}</p>
<p class="cll">"""</p>
</div>
<p>The fragment shader declares <code>texcoord</code> as input <!--<ccust1>1</ccust1>-->❶, which was set as output in the vertex shader. The texture sampler is declared as <code>uniform</code> <!--<ccust1>2</ccust1>-->❷. You look up the texture color using <code>texcoord</code> <!--<ccust1>3</ccust1>-->❸ and set <code>fragColor</code> as the output <!--<ccust1>4</ccust1>-->❹. (Because you read in your texture only as the red channel, you use <code>col.rrra</code>.)</p>
</section>
<section>
<h4 class="ch" id="ch1313">A User Interface for 2D Slicing</h4>
<p class="paft">Now you need a way for the user to slice through the data. Do this using a <span class="idx" data-level1="2D slices" data-term="volume rendering"/>keyboard handling method on the <code>SliceRender</code> class:</p>
<div class="codeline">
<p class="clf">def keyPressed(self, key):</p>
<p class="cl">    """keypress handler"""</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ if key == 'x':</p>
<p class="cl">        self.mode = SliceRender.XSLICE</p>
<p class="cl">        # reset slice index</p>
<p class="cl">        self.currSliceIndex = int(self.Nx/2)</p>
<p class="cl">        self.currSliceMax = self.Nx</p>
<p class="cl">    elif key == 'y':</p>
<p class="cl">        self.mode = SliceRender.YSLICE</p>
<p class="cl">        # reset slice index</p>
<p class="cl">        self.currSliceIndex = int(self.Ny/2)</p>
<p class="cl">        self.currSliceMax = self.Ny</p>
<p class="cl">    elif key == 'z':</p>
<p class="cl">        self.mode = SliceRender.ZSLICE</p>
<p class="cl">        # reset slice index</p>
<p class="cl">        self.currSliceIndex = int(self.Nz/2)</p>
<p class="cl">        self.currSliceMax = self.Nz</p>
<p class="cl">    elif key == 'l':</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ self.currSliceIndex = (self.currSliceIndex + 1) % self.currSliceMax</p>
<p class="cl">    elif key == 'r':</p>
<p class="cll">        self.currSliceIndex = (self.currSliceIndex - 1) % self.currSliceMax</p>
</div>
<p>When the X, Y, or Z key on the keyboard is pressed, <code>SliceRender</code> switches to the <i>x</i>, <i>y</i>, or <i>z</i> slice mode. You can see this in action for the <i>x</i> slice, for example <!--<ccust1>1</ccust1>-->❶, where you set the appropriate mode, set the current slice index to the middle of the data, and update the maximum slice number.</p>
<p>When the left or right arrow key on the keyboard is pressed, you page through the slices. For instance, the slice index is incremented <!--<ccust1>2</ccust1>-->❷ when the left arrow key is pressed. The modulo operator (<code>%</code>) ensures that the index “rolls over” to 0 when you exceed the maximum value.</p>
</section>
</section>
<section>
<h3 class="bh" id="bh1308"><span aria-label=" Page 238. " class="page" epub:type="pagebreak" id="p238" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1308">Putting the Code Together</a></h3>
<p class="paft">Let’s take a quick look at the main file in the project, <i>volrender.py</i>. This file uses a class <code>RenderWin</code>, which creates and manages the <span class="idx" data-term="GLFW"/>GLFW OpenGL window. (I won’t cover this class in detail because it’s similar to the class used in <a class="xref" href="nsp-venkitachalam503045-0023.xhtml#ch09">Chapters 9</a> and <a class="xref" href="nsp-venkitachalam503045-0024.xhtml#ch10">10</a>.) To see the complete <i>volrender.py</i> code, skip ahead to <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#ah1311">“The Complete Main File Code”</a> on <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#p254">page 254</a>. You can also find the <i>volrender.py</i> file at <a class="url-i" href="https://github.com/mkvenkit/pp2e/tree/main/volrender">https://github.com/mkvenkit/pp2e/tree/main/volrender</a>.</p>
<p>In the initialization code for this class, you create the renderer as follows:</p>
<div class="codeline">
<p class="clf">class RenderWin:</p>
<p class="cl">    def __init__(self, imageDir):</p>
<p class="cl">    --<code class="i">snip</code>--</p>
<p class="cl">        # load volume data</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ self.volume = volreader.loadVolume(imageDir)</p>
<p class="cl">        # create renderer</p>
<p class="cll">      <!--<ccust1>2</ccust1>-->❷ self.renderer = RayCastRender(self.width, self.height, self.volume)</p>
</div>
<p>Here you read the 3D data into an OpenGL texture using the <code>loadVolume()</code> function we discussed earlier <!--<ccust1>1</ccust1>-->❶. Then you create an object of type <code>RayCastRender</code> to display the data <!--<ccust1>2</ccust1>-->❷.</p>
<section>
<h4 class="ch" id="ch1314">The Keypress Handler</h4>
<p class="paft">The <code>RenderWindow</code> class needs its own keyboard handler method for toggling between volume and slice rendering and for closing the window. This method also passes along keypresses to the <code>RayCastRender</code> and <code>SliceRender</code> classes’ keyboard handlers, to either rotate the camera or navigate through the 2D slices.</p>
<div class="codeline">
<p class="clf">def onKeyboard(self, win, key, scancode, action, mods):</p>
<p class="cl">    # print 'keyboard: ', win, key, scancode, action, mods</p>
<p class="cl">    # ESC to quit</p>
<p class="cl">    if key is glfw.GLFW_KEY_ESCAPE:</p>
<p class="cl">        self.renderer.close()</p>
<p class="cl">        self.exitNow = True</p>
<p class="cl">    else:</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ if action is glfw.GLFW_PRESS or action is glfw.GLFW_REPEAT:</p>
<p class="cl">            if key == glfw.GLFW_KEY_V:</p>
<p class="cl">                # toggle render mode</p>
<p class="cl">              <!--<ccust1>2</ccust1>-->❷ if isinstance(self.renderer, RayCastRender):</p>
<p class="cl">                    self.renderer = SliceRender(self.width, self.height,</p>
<p class="cl">                                                self.volume)</p>
<p class="cl">                else:</p>
<p class="cl">                    self.renderer = RayCastRender(self.width, self.height,</p>
<p class="cl">                                                  self.volume)</p>
<p class="cl">                # call reshape on renderer</p>
<p class="cl">                self.renderer.reshape(self.width, self.height)</p>
<p class="cl">            else:</p>
<p class="cl">                # send keypress to renderer</p>
<p class="cl">              <!--<ccust1>3</ccust1>-->❸ keyDict = {glfw.GLFW_KEY_X: 'x', glfw.GLFW_KEY_Y: 'y',</p>
<p class="cl">                           glfw.GLFW_KEY_Z: 'z', glfw.GLFW_KEY_LEFT: 'l',</p>
<p class="cl"><span aria-label=" Page 239. " class="page" epub:type="pagebreak" id="p239" role="doc-pagebreak"/>                           glfw.GLFW_KEY_RIGHT: 'r'}</p>
<p class="cl">                try:</p>
<p class="cl">                    self.renderer.keyPressed(keyDict[key])</p>
<p class="cl">                except:</p>
<p class="cll">                    pass</p>
</div>
<p>Pressing <span class="sm">ESC</span> quits the program. You set other keypresses to work whether you have just pressed the key down or you are keeping it pressed <!--<ccust1>1</ccust1>-->❶. If the V key is pressed, you toggle the renderer between volume and slice <!--<ccust1>2</ccust1>-->❷, using Python’s <code>isinstance()</code> method to identify the current class type. To handle any other keypress events (X, Y, Z, or the left and right arrows), you use a dictionary <!--<ccust1>3</ccust1>-->❸ and pass the keypress to the current renderer’s <code>keyPressed()</code> handler method. We looked at the slice renderer’s <code>keyPressed()</code> method in <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#ch1313">“A User Interface for 2D Slicing”</a> on <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#p237">page 237</a>, for example.</p>
<p class="pcust1"><span class="ccust3">NOTE</span> I’m choosing not to pass in the <code>glfw.KEY</code> values directly and using a dictionary to convert these to character values instead, because it’s a good practice to reduce dependencies in source files. Currently, the only file in this project that depends on GLFW is <i>volrender.py</i>. If you were to pass GLFW-specific types into other code, they would need to import and depend on the GLFW library too. Then, if you were to switch to a different OpenGL windowing toolkit, the code would become messy.</p>
</section>
</section>
</section>
<section>
<h2 class="ah" id="ah1304"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1304">Running the Program</a></h2>
<p class="paft">Here is a sample run of the application using data from the Stanford Volume Data Archive:</p>
<div class="codeline">
<p class="cls">$ <code class="b">python volrender.py --dir mrbrain-8bit/</code></p>
</div>
<p>You should see something like <a class="xref" href="nsp-venkitachalam503045-0025.xhtml#fig11-6">Figure 11-6</a>.</p>
<figure class="figure" id="fig11-6">
<p class="fig"><img alt="" height="534" src="images/nsp-venkitachalam503045-f11006.jpg" style="width:95%; height:auto;" width="1044"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 11-6:</span> A sample run of <i>volrender.py</i>. The image on the left is the volumetric rendering, and the image on the right is a 2D slice.</p>
</figcaption>
</figure>
<p><span aria-label=" Page 240. " class="page" epub:type="pagebreak" id="p240" role="doc-pagebreak"/>As the application runs, use the V key to toggle between volume and slice rendering. In slice mode, use the X, Y, and Z keys to change the slicing axis, and use the arrow keys to change the slicing location.</p>
</section>
<section>
<h2 class="ah" id="ah1305"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1305">Summary</a></h2>
<p class="paft">In this chapter, you implemented the volume ray casting algorithm using Python and OpenGL. You learned how to use GLSL shaders to implement this algorithm efficiently, as well as how to create 2D slices from the volumetric data.</p>
</section>
<section>
<h2 class="ah" id="ah1306"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1306">Experiments!</a></h2>
<p class="paft">Here are a few ways you could keep tinkering with the volume ray casting program:</p>
<ol style="list-style-type:none">
<li class="nlf">1. Currently, it’s hard to see the boundary of the volumetric data “cube” in the ray casting mode. Implement a class <code>WireFrame</code> that draws a box around this cube. Color the x-, y-, and z-axes red, green, and blue, respectively, and give each its own shaders. You’ll use <code>WireFrame</code> from within the <code>RayCastRender</code> class.</li>
<li class="nl">2. Implement <span class="idx" data-level1="scaling" data-term="volume rendering"/>data scaling. In the current implementation, you’re drawing a cube for the volume and a square for 2D slices, which assumes you have a symmetric data set (that the number of slices are the same in each direction), but most real data has a varying number of slices. Medical data, in particular, often has fewer slices in the z-direction, with dimensions such as 256×256×99, for example. To display this data correctly, you have to introduce a scale into your computations. One way to do so is to apply the scale to the cube vertices (3D volume) and square vertices (2D slice). The user can then input the scaling parameters as command line arguments.</li>
<li class="nl">3. Our volume ray casting implementation uses X-ray casting to calculate the final color or intensity of a pixel. Another popular way to do this is to use <span class="idx" data-level1="maximum intensity projection " data-term="volume rendering"/><i>maximum intensity projection (MIP)</i> to set the maximum intensity at each pixel. Implement this in your code. (Hint: in the fragment shader of <code>RayCastRender</code>, modify the code that steps through the ray to check and set the maximum value along the ray, instead of blending values.)</li>
<li class="nl">4. Currently, the only UI you have implemented is rotation around the x-, y-, and z-axes. Implement a zoom feature so pressing I/O will zoom in/out of the volume-rendered image. You could do this by setting the appropriate camera parameters in the <code>glutils.lookAt()</code> method, with one caveat: if you move your view inside the data cube, the ray casting will fail because OpenGL will clip the front-faces of the cube; the ray computation needed for ray casting requires both the front- and back-faces of the color cube to be rendered correctly. Instead, zoom by adjusting the field of view in the <code>glutils.projecton()</code> method.</li>
</ol>
</section>
<section>
<h2 class="ah" id="ah1307"><span aria-label=" Page 241. " class="page" epub:type="pagebreak" id="p241" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1307">The Complete 3D Texture Code</a></h2>
<p class="paft">Here’s the full <i>volreader.py</i> code listing.</p>
<div class="codeline">
<p class="clf">import os</p>
<p class="cl">import numpy as np</p>
<p class="cl">from PIL import Image</p>
<p class="clf">import OpenGL</p>
<p class="cl">from OpenGL.GL import *</p>
<p class="clf">from scipy import misc</p>
<p class="clf">def loadVolume(dirName):</p>
<p class="cl">    """read volume from directory as a 3D texture"""</p>
<p class="cl">    # list images in directory</p>
<p class="cl">    files = sorted(os.listdir(dirName))</p>
<p class="cl">    print('loading images from: %s' % dirName)</p>
<p class="cl">    imgDataList = []</p>
<p class="cl">    count = 0</p>
<p class="cl">    width, height = 0, 0</p>
<p class="cl">    for file in files:</p>
<p class="cl">        file_path = os.path.abspath(os.path.join(dirName, file))</p>
<p class="cl">        try:</p>
<p class="cl">            # read image</p>
<p class="cl">            img = Image.open(file_path)</p>
<p class="cl">            imgData = np.array(img.getdata(), np.uint8)</p>
<p class="clf">            # check if all are of the same size</p>
<p class="cl">            if count is 0:</p>
<p class="cl">                width, height = img.size[0], img.size[1]</p>
<p class="cl">                imgDataList.append(imgData)</p>
<p class="cl">            else:</p>
<p class="cl">                if (width, height) == (img.size[0], img.size[1]):</p>
<p class="cl">                    imgDataList.append(imgData)</p>
<p class="cl">                else:</p>
<p class="cl">                    print('mismatch')</p>
<p class="cl">                    raise RunTimeError("image size mismatch")</p>
<p class="cl">            count += 1</p>
<p class="cl">            # print img.size</p>
<p class="cl">        except:</p>
<p class="cl">            # skip</p>
<p class="cl">            print('Invalid image: %s' % file_path)</p>
<p class="clf">    # load image data into single array</p>
<p class="cl">    depth = count</p>
<p class="cl">    data = np.concatenate(imgDataList)</p>
<p class="cl">    print('volume data dims: %d %d %d' % (width, height, depth))</p>
<p class="clf">    # load data into 3D texture</p>
<p class="cl">    texture = glGenTextures(1)</p>
<p class="cl">    glPixelStorei(GL_UNPACK_ALIGNMENT, 1)</p>
<p class="cl">    glBindTexture(GL_TEXTURE_3D, texture)</p>
<p class="cl">    glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)</p>
<p class="cl">    glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)</p>
<p class="cl"><span aria-label=" Page 242. " class="page" epub:type="pagebreak" id="p242" role="doc-pagebreak"/>    glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE)</p>
<p class="cl">    glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)</p>
<p class="cl">    glTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)</p>
<p class="cl">    glTexImage3D(GL_TEXTURE_3D, 0, GL_RED,</p>
<p class="cl">                 width, height, depth, 0,</p>
<p class="cl">                 GL_RED, GL_UNSIGNED_BYTE, data)</p>
<p class="cl">    # return texture</p>
<p class="cl">    return (texture, width, height, depth)</p>
<p class="clf"># load texture</p>
<p class="cl">def loadTexture(filename):</p>
<p class="cl">    img = Image.open(filename)</p>
<p class="cl">    img_data = np.array(list(img.getdata()), 'B')</p>
<p class="cl">    texture = glGenTextures(1)</p>
<p class="cl">    glPixelStorei(GL_UNPACK_ALIGNMENT,1)</p>
<p class="cl">    glBindTexture(GL_TEXTURE_2D, texture)</p>
<p class="cl">    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)</p>
<p class="cl">    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)</p>
<p class="cl">    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)</p>
<p class="cl">    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)</p>
<p class="cl">    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, img.size[0], img.size[1],</p>
<p class="cl">                 0, GL_RGBA, GL_UNSIGNED_BYTE, img_data)</p>
<p class="cl">    return texture</p>
</div>
</section>
<section>
<h2 class="ah" id="ah1308"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1308">The Complete Ray Generation Code</a></h2>
<p class="paft">Here’s the full code listing for the <code>RayCube</code> class.</p>
<div class="codeline1">
<p class="cl1f">import OpenGL</p>
<p class="cl1">from OpenGL.GL import *</p>
<p class="cl1">from OpenGL.GL.shaders import *</p>
<p class="cl1f">import numpy, math, sys</p>
<p class="cl1">import volreader, glutils</p>
<p class="cl1f">strVS = """</p>
<p class="cl1"># version 330 core</p>
<p class="cl1f">layout(location = 1) in vec3 cubePos;</p>
<p class="cl1">layout(location = 2) in vec3 cubeCol;</p>
<p class="cl1f">uniform mat4 uMVMatrix;</p>
<p class="cl1">uniform mat4 uPMatrix;</p>
<p class="cl1">out vec4 vColor;</p>
<p class="cl1f">void main()</p>
<p class="cl1">{</p>
<p class="cl1">    // set back-face color</p>
<p class="cl1">    vColor = vec4(cubeCol.rgb, 1.0);</p>
<p class="cl1f">    // transformed position</p>
<p class="cl1">    vec4 newPos = vec4(cubePos.xyz, 1.0);</p>
<p class="cl1f"><span aria-label=" Page 243. " class="page" epub:type="pagebreak" id="p243" role="doc-pagebreak"/>    // set position</p>
<p class="cl1">    gl_Position = uPMatrix * uMVMatrix * newPos;</p>
<p class="cl1f">}</p>
<p class="cl1">"""</p>
<p class="cl1">strFS = """</p>
<p class="cl1"># version 330 core</p>
<p class="cl1f">in vec4 vColor;</p>
<p class="cl1">out vec4 fragColor;</p>
<p class="cl1f">void main()</p>
<p class="cl1">{</p>
<p class="cl1">    fragColor = vColor;</p>
<p class="cl1">}</p>
<p class="cl1">"""</p>
<p class="cl1f">class RayCube:</p>
<p class="cl1">    """class used to generate rays used in ray casting"""</p>
<p class="cl1f">    def __init__(self, width, height):</p>
<p class="cl1">        """RayCube constructor"""</p>
<p class="cl1f">        # set dims</p>
<p class="cl1">        self.width, self.height = width, height</p>
<p class="cl1f">        # create shader</p>
<p class="cl1">        self.program = glutils.loadShaders(strVS, strFS)</p>
<p class="cl1f">        # cube vertices</p>
<p class="cl1">        vertices = numpy.array([</p>
<p class="cl1">                0.0, 0.0, 0.0,</p>
<p class="cl1">                1.0, 0.0, 0.0,</p>
<p class="cl1">                1.0, 1.0, 0.0,</p>
<p class="cl1">                0.0, 1.0, 0.0,</p>
<p class="cl1">                0.0, 0.0, 1.0,</p>
<p class="cl1">                1.0, 0.0, 1.0,</p>
<p class="cl1">                1.0, 1.0, 1.0,</p>
<p class="cl1">                0.0, 1.0, 1.0</p>
<p class="cl1">                ], numpy.float32)</p>
<p class="cl1f">        # cube colors</p>
<p class="cl1">        colors = numpy.array([</p>
<p class="cl1">                0.0, 0.0, 0.0,</p>
<p class="cl1">                1.0, 0.0, 0.0,</p>
<p class="cl1">                1.0, 1.0, 0.0,</p>
<p class="cl1">                0.0, 1.0, 0.0,</p>
<p class="cl1">                0.0, 0.0, 1.0,</p>
<p class="cl1">                1.0, 0.0, 1.0,</p>
<p class="cl1">                1.0, 1.0, 1.0,</p>
<p class="cl1">                0.0, 1.0, 1.0</p>
<p class="cl1">                ], numpy.float32)</p>
<p class="cl1f">        # individual triangles</p>
<p class="cl1">        indices = numpy.array([</p>
<p class="cl1"><span aria-label=" Page 244. " class="page" epub:type="pagebreak" id="p244" role="doc-pagebreak"/>                4, 5, 7,</p>
<p class="cl1">                7, 5, 6,</p>
<p class="cl1">                5, 1, 6,</p>
<p class="cl1">                6, 1, 2,</p>
<p class="cl1">                1, 0, 2,</p>
<p class="cl1">                2, 0, 3,</p>
<p class="cl1">                0, 4, 3,</p>
<p class="cl1">                3, 4, 7,</p>
<p class="cl1">                6, 2, 7,</p>
<p class="cl1">                7, 2, 3,</p>
<p class="cl1">                4, 0, 5,</p>
<p class="cl1">                5, 0, 1</p>
<p class="cl1">                ], numpy.int16)</p>
<p class="cl1f">        self.nIndices = indices.size</p>
<p class="cl1f">        # set up vertex array object (VAO)</p>
<p class="cl1">        self.vao = glGenVertexArrays(1)</p>
<p class="cl1">        glBindVertexArray(self.vao)</p>
<p class="cl1f">        # vertex buffer</p>
<p class="cl1">        self.vertexBuffer = glGenBuffers(1)</p>
<p class="cl1">        glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)</p>
<p class="cl1">        glBufferData(GL_ARRAY_BUFFER, 4*len(vertices), vertices, GL_STATIC_DRAW)</p>
<p class="cl1f">        # vertex buffer - cube vertex colors</p>
<p class="cl1">        self.colorBuffer = glGenBuffers(1)</p>
<p class="cl1">        glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)</p>
<p class="cl1">        glBufferData(GL_ARRAY_BUFFER, 4*len(colors), colors, GL_STATIC_DRAW);</p>
<p class="cl1f">        # index buffer</p>
<p class="cl1">        self.indexBuffer = glGenBuffers(1)</p>
<p class="cl1">        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.indexBuffer);</p>
<p class="cl1">        glBufferData(GL_ELEMENT_ARRAY_BUFFER, 2*len(indices), indices,</p>
<p class="cl1">                     GL_STATIC_DRAW)</p>
<p class="cl1f">        # enable attrs using the layout indices in shader</p>
<p class="cl1">        aPosLoc = 1</p>
<p class="cl1">        aColorLoc = 2</p>
<p class="cl1f">        # bind buffers</p>
<p class="cl1">        glEnableVertexAttribArray(1)</p>
<p class="cl1">        glEnableVertexAttribArray(2)</p>
<p class="cl1f">        # vertex</p>
<p class="cl1">        glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)</p>
<p class="cl1">        glVertexAttribPointer(aPosLoc, 3, GL_FLOAT, GL_FALSE, 0, None)</p>
<p class="cl1f">        # color</p>
<p class="cl1">        glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)</p>
<p class="cl1">        glVertexAttribPointer(aColorLoc, 3, GL_FLOAT, GL_FALSE, 0, None)</p>
<p class="cl1">        # index</p>
<p class="cl1">        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self.indexBuffer)</p>
<p class="cl1f"><span aria-label=" Page 245. " class="page" epub:type="pagebreak" id="p245" role="doc-pagebreak"/>        # unbind VAO</p>
<p class="cl1">        glBindVertexArray(0)</p>
<p class="cl1f">        # FBO</p>
<p class="cl1">        self.initFBO()</p>
<p class="cl1f">    def renderBackFace(self, pMatrix, mvMatrix):</p>
<p class="cl1">        """renders back-face of ray-cube to a texture and returns it"""</p>
<p class="cl1">        # render to FBO</p>
<p class="cl1">        glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)</p>
<p class="cl1">        # set active texture</p>
<p class="cl1">        glActiveTexture(GL_TEXTURE0)</p>
<p class="cl1">        # bind to FBO texture</p>
<p class="cl1">        glBindTexture(GL_TEXTURE_2D, self.texHandle)</p>
<p class="cl1f">        # render cube with face culling enabled</p>
<p class="cl1">        self.renderCube(pMatrix, mvMatrix, self.program, True)</p>
<p class="cl1f">        # unbind texture</p>
<p class="cl1">        glBindTexture(GL_TEXTURE_2D, 0)</p>
<p class="cl1">        glBindFramebuffer(GL_FRAMEBUFFER, 0)</p>
<p class="cl1">        glBindRenderbuffer(GL_RENDERBUFFER, 0)</p>
<p class="cl1f">        # return texture ID</p>
<p class="cl1">        return self.texHandle</p>
<p class="cl1f">    def renderFrontFace(self, pMatrix, mvMatrix, program):</p>
<p class="cl1">        """render front-face of ray-cube"""</p>
<p class="cl1">        # no face culling</p>
<p class="cl1">        self.renderCube(pMatrix, mvMatrix, program, False)</p>
<p class="cl1f">    def renderCube(self, pMatrix, mvMatrix, program, cullFace):</p>
<p class="cl1">        """render cube using face culling if flag set"""</p>
<p class="cl1f">        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)</p>
<p class="cl1f">        # set shader program</p>
<p class="cl1">        glUseProgram(program)</p>
<p class="cl1f">        # set projection matrix</p>
<p class="cl1">        glUniformMatrix4fv(glGetUniformLocation(program, b'uPMatrix'),</p>
<p class="cl1">                           1, GL_FALSE, pMatrix)</p>
<p class="cl1f">        # set modelview matrix</p>
<p class="cl1">        glUniformMatrix4fv(glGetUniformLocation(program, b'uMVMatrix'),</p>
<p class="cl1">                           1, GL_FALSE, mvMatrix)</p>
<p class="cl1f">        # enable face culling</p>
<p class="cl1">        glDisable(GL_CULL_FACE)</p>
<p class="cl1">        if cullFace:</p>
<p class="cl1">            glFrontFace(GL_CCW)</p>
<p class="cl1">            glCullFace(GL_FRONT)</p>
<p class="cl1">            glEnable(GL_CULL_FACE)</p>
<p class="cl1f"><span aria-label=" Page 246. " class="page" epub:type="pagebreak" id="p246" role="doc-pagebreak"/>        # bind VAO</p>
<p class="cl1">        glBindVertexArray(self.vao)</p>
<p class="cl1f">        # animated slice</p>
<p class="cl1">        glDrawElements(GL_TRIANGLES, self.nIndices, GL_UNSIGNED_SHORT, None)</p>
<p class="cl1f">        # unbind VAO</p>
<p class="cl1">        glBindVertexArray(0)</p>
<p class="cl1f">        # reset cull face</p>
<p class="cl1">        if cullFace:</p>
<p class="cl1">            # disable face culling</p>
<p class="cl1">            glDisable(GL_CULL_FACE)</p>
<p class="cl1f">    def reshape(self, width, height):</p>
<p class="cl1">        self.width = width</p>
<p class="cl1">        self.height = height</p>
<p class="cl1">        self.aspect = width/float(height)</p>
<p class="cl1">        # re-create FBO</p>
<p class="cl1">        self.clearFBO()</p>
<p class="cl1">        self.initFBO()</p>
<p class="cl1f">    def initFBO(self):</p>
<p class="cl1">        # create frame buffer object</p>
<p class="cl1">        self.fboHandle = glGenFramebuffers(1)</p>
<p class="cl1">        # create texture</p>
<p class="cl1">        self.texHandle = glGenTextures(1)</p>
<p class="cl1">        # create depth buffer</p>
<p class="cl1">        self.depthHandle = glGenRenderbuffers(1)</p>
<p class="cl1f">        # bind</p>
<p class="cl1">        glBindFramebuffer(GL_FRAMEBUFFER, self.fboHandle)</p>
<p class="cl1f">        glActiveTexture(GL_TEXTURE0)</p>
<p class="cl1">        glBindTexture(GL_TEXTURE_2D, self.texHandle)</p>
<p class="cl1f">        # set parameters to draw the image at different sizes</p>
<p class="cl1">        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)</p>
<p class="cl1">        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)</p>
<p class="cl1">        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)</p>
<p class="cl1">        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)</p>
<p class="cl1f">        # set up texture</p>
<p class="cl1">        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, self.width, self.height,</p>
<p class="cl1">                     0, GL_RGBA, GL_UNSIGNED_BYTE, None)</p>
<p class="cl1f">        # bind texture to FBO</p>
<p class="cl1">        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</p>
<p class="cl1">                               GL_TEXTURE_2D, self.texHandle, 0)</p>
<p class="cl1f">        # bind</p>
<p class="cl1">        glBindRenderbuffer(GL_RENDERBUFFER, self.depthHandle)</p>
<p class="cl1">        glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24,</p>
<p class="cl1">                              self.width, self.height)</p>
<p class="cl1f"><span aria-label=" Page 247. " class="page" epub:type="pagebreak" id="p247" role="doc-pagebreak"/>        # bind depth buffer to FBO</p>
<p class="cl1">        glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT,</p>
<p class="cl1">                                  GL_RENDERBUFFER, self.depthHandle)</p>
<p class="cl1f">        # check status</p>
<p class="cl1">        status = glCheckFramebufferStatus(GL_FRAMEBUFFER)</p>
<p class="cl1">        if status == GL_FRAMEBUFFER_COMPLETE:</p>
<p class="cl1">            pass</p>
<p class="cl1">            # print "fbo %d complete" % self.fboHandle</p>
<p class="cl1">        elif status == GL_FRAMEBUFFER_UNSUPPORTED:</p>
<p class="cl1">            print("fbo %d unsupported" % self.fboHandle)</p>
<p class="cl1">        else:</p>
<p class="cl1">            print("fbo %d Error" % self.fboHandle)</p>
<p class="cl1f">        glBindTexture(GL_TEXTURE_2D, 0)</p>
<p class="cl1">        glBindFramebuffer(GL_FRAMEBUFFER, 0)</p>
<p class="cl1">        glBindRenderbuffer(GL_RENDERBUFFER, 0)</p>
<p class="cl1">        return</p>
<p class="cl1f">    def clearFBO(self):</p>
<p class="cl1">        """clears old FBO"""</p>
<p class="cl1">        # delete FBO</p>
<p class="cl1">        if glIsFramebuffer(self.fboHandle):</p>
<p class="cl1">            glDeleteFramebuffers(1, int(self.fboHandle))</p>
<p class="cl1f">        # delete texture</p>
<p class="cl1">        if glIsTexture(self.texHandle):</p>
<p class="cl1">            glDeleteTextures(int(self.texHandle))</p>
<p class="cl1f">    def close(self):</p>
<p class="cl1">        """call this to free up OpenGL resources"""</p>
<p class="cl1">        glBindTexture(GL_TEXTURE_2D, 0)</p>
<p class="cl1">        glBindFramebuffer(GL_FRAMEBUFFER, 0)</p>
<p class="cl1">        glBindRenderbuffer(GL_RENDERBUFFER, 0)</p>
<p class="cl1f">        # delete FBO</p>
<p class="cl1">        if glIsFramebuffer(self.fboHandle):</p>
<p class="cl1">            glDeleteFramebuffers(1, int(self.fboHandle))</p>
<p class="cl1f">        # delete texture</p>
<p class="cl1">        if glIsTexture(self.texHandle):</p>
<p class="cl1">            glDeleteTextures(int(self.texHandle))</p>
<p class="cl1f">        # delete render buffer</p>
<p class="cl1">        """</p>
<p class="cl1">        if glIsRenderbuffer(self.depthHandle):</p>
<p class="cl1">            glDeleteRenderbuffers(1, int(self.depthHandle))</p>
<p class="cl1">            """</p>
<p class="cl1">        # delete buffers</p>
<p class="cl1">        """</p>
<p class="cl1">        glDeleteBuffers(1, self._vertexBuffer)</p>
<p class="cl1">        glDeleteBuffers(1, &amp;_indexBuffer)</p>
<p class="cl1">        glDeleteBuffers(1, &amp;_colorBuffer)</p>
<p class="cl1">        """</p>
</div>
</section>
<section>
<h2 class="ah" id="ah1309"><span aria-label=" Page 248. " class="page" epub:type="pagebreak" id="p248" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1309">The Complete Volume Ray Casting Code</a></h2>
<p class="paft">Here’s the full <i>raycast.py</i> code listing.</p>
<div class="codeline">
<p class="clf">import OpenGL</p>
<p class="cl">from OpenGL.GL import *</p>
<p class="cl">from OpenGL.GL.shaders import *</p>
<p class="clf">import numpy as np</p>
<p class="cl">import math, sys</p>
<p class="clf">import raycube, glutils, volreader</p>
<p class="clf">strVS = """</p>
<p class="cl"># version 330 core</p>
<p class="clf">layout(location = 1) in vec3 cubePos;</p>
<p class="cl">layout(location = 2) in vec3 cubeCol;</p>
<p class="clf">uniform mat4 uMVMatrix;</p>
<p class="cl">uniform mat4 uPMatrix;</p>
<p class="clf">out vec4 vColor;</p>
<p class="clf">void main()</p>
<p class="cl">{</p>
<p class="cl">    // set position</p>
<p class="cl">    gl_Position = uPMatrix * uMVMatrix * vec4(cubePos.xyz, 1.0);</p>
<p class="clf">    // set color</p>
<p class="cl">    vColor = vec4(cubeCol.rgb, 1.0);</p>
<p class="cl">}</p>
<p class="cl">"""</p>
<p class="cl">strFS = """</p>
<p class="cl"># version 330 core</p>
<p class="clf">in vec4 vColor;</p>
<p class="clf">uniform sampler2D texBackFaces;</p>
<p class="cl">uniform sampler3D texVolume;</p>
<p class="cl">uniform vec2 uWinDims;</p>
<p class="clf">out vec4 fragColor;</p>
<p class="clf">void main()</p>
<p class="cl">{</p>
<p class="cl">    // start of ray</p>
<p class="cl">    vec3 start = vColor.rgb;</p>
<p class="clf">    // calculate texture coords at fragment,</p>
<p class="cl">    // which is a fraction of window coords</p>
<p class="cl">    vec2 texc = gl_FragCoord.xy/uWinDims.xy;</p>
<p class="clf">    // get end of ray by looking up back-face color</p>
<p class="cl">    vec3 end = texture(texBackFaces, texc).rgb;</p>
<p class="clf"><span aria-label=" Page 249. " class="page" epub:type="pagebreak" id="p249" role="doc-pagebreak"/>    // calculate ray direction</p>
<p class="cl">    vec3 dir = end - start;</p>
<p class="clf">    // normalized ray direction</p>
<p class="cl">    vec3 norm_dir = normalize(dir);</p>
<p class="clf">    // the length from front to back is calculated and</p>
<p class="cl">    // used to terminate the ray</p>
<p class="cl">    float len = length(dir.xyz);</p>
<p class="clf">    // ray step size</p>
<p class="cl">    float stepSize = 0.01;</p>
<p class="clf">    // X-ray projection</p>
<p class="cl">    vec4 dst = vec4(0.0);</p>
<p class="clf">    // step through the ray</p>
<p class="cl">    for(float t = 0.0; t &lt; len; t += stepSize) {</p>
<p class="clf">        // set position to endpoint of ray</p>
<p class="cl">        vec3 samplePos = start + t*norm_dir;</p>
<p class="clf">        // get texture value at position</p>
<p class="cl">        float val = texture(texVolume, samplePos).r;</p>
<p class="cl">        vec4 src = vec4(val);</p>
<p class="clf">        // set opacity</p>
<p class="cl">        src.a *= 0.1;</p>
<p class="cl">        src.rgb *= src.a;</p>
<p class="clf">        // blend with previous value</p>
<p class="cl">        dst = (1.0 - dst.a)*src + dst;</p>
<p class="clf">        // exit loop when alpha exceeds threshold</p>
<p class="cl">        if(dst.a &gt;= 0.95)</p>
<p class="cl">           break;</p>
<p class="cl">    }</p>
<p class="clf">    // set fragment color</p>
<p class="cl">    fragColor =  dst;</p>
<p class="cl">}</p>
<p class="cl">"""</p>
<p class="clf">class Camera:</p>
<p class="cl">    """helper class for viewing"""</p>
<p class="cl">    def __init__(self):</p>
<p class="cl">        self.r = 1.5</p>
<p class="cl">        self.theta = 0</p>
<p class="cl">        self.center = [0.5, 0.5, 0.5]</p>
<p class="cl">        self.eye = [0.5 + self.r, 0.5, 0.5]</p>
<p class="cl">        self.up = [0.0, 0.0, 1.0]</p>
<p class="clf">    def rotate(self, clockWise):</p>
<p class="cl">        """rotate eye by one step"""</p>
<p class="cl">        if clockWise:</p>
<p class="cl"><span aria-label=" Page 250. " class="page" epub:type="pagebreak" id="p250" role="doc-pagebreak"/>            self.theta = (self.theta + 5) % 360</p>
<p class="cl">        else:</p>
<p class="cl">            self.theta = (self.theta - 5) % 360</p>
<p class="cl">        # recalculate eye</p>
<p class="cl">        self.eye = [0.5 + self.r*math.cos(math.radians(self.theta)),</p>
<p class="cl">                    0.5 + self.r*math.sin(math.radians(self.theta)),</p>
<p class="cl">                    0.5]</p>
<p class="clf">class RayCastRender:</p>
<p class="cl">    """class that does Ray Casting"""</p>
<p class="clf">    def __init__(self, width, height, volume):</p>
<p class="cl">        """RayCastRender constr"""</p>
<p class="clf">        # create RayCube object</p>
<p class="cl">        self.raycube = raycube.RayCube(width, height)</p>
<p class="clf">        # set dimensions</p>
<p class="cl">        self.width = width</p>
<p class="cl">        self.height = height</p>
<p class="cl">        self.aspect = width/float(height)</p>
<p class="clf">        # create shader</p>
<p class="cl">        self.program = glutils.loadShaders(strVS, strFS)</p>
<p class="cl">        # texture</p>
<p class="cl">        self.texVolume, self.Nx, self.Ny, self.Nz = volume</p>
<p class="clf">        # initialize camera</p>
<p class="cl">        self.camera = Camera()</p>
<p class="clf">    def draw(self):</p>
<p class="clf">        # build projection matrix</p>
<p class="cl">        pMatrix = glutils.perspective(45.0, self.aspect, 0.1, 100.0)</p>
<p class="clf">        # modelview matrix</p>
<p class="cl">        mvMatrix = glutils.lookAt(self.camera.eye, self.camera.center,</p>
<p class="cl">                                  self.camera.up)</p>
<p class="cl">        # render</p>
<p class="clf">        # generate ray-cube back-face texture</p>
<p class="cl">        texture = self.raycube.renderBackFace(pMatrix, mvMatrix)</p>
<p class="clf">        # set shader program</p>
<p class="cl">        glUseProgram(self.program)</p>
<p class="clf">        # set window dimensions</p>
<p class="cl">        glUniform2f(glGetUniformLocation(self.program, b"uWinDims"),</p>
<p class="cl">                    float(self.width), float(self.height))</p>
<p class="clf">        # texture unit 0, which represents back-faces of cube</p>
<p class="cl">        glActiveTexture(GL_TEXTURE0)</p>
<p class="cl">        glBindTexture(GL_TEXTURE_2D, texture)</p>
<p class="cl">        glUniform1i(glGetUniformLocation(self.program, b"texBackFaces"), 0)</p>
<p class="clf"><span aria-label=" Page 251. " class="page" epub:type="pagebreak" id="p251" role="doc-pagebreak"/>        # texture unit 1: 3D volume texture</p>
<p class="cl">        glActiveTexture(GL_TEXTURE1)</p>
<p class="cl">        glBindTexture(GL_TEXTURE_3D, self.texVolume)</p>
<p class="cl">        glUniform1i(glGetUniformLocation(self.program, b"texVolume"), 1)</p>
<p class="clf">        # draw front-face of cubes</p>
<p class="cl">        self.raycube.renderFrontFace(pMatrix, mvMatrix, self.program)</p>
<p class="clf">        #self.render(pMatrix, mvMatrix)</p>
<p class="clf">    def keyPressed(self, key):</p>
<p class="cl">        if key == 'l':</p>
<p class="cl">            self.camera.rotate(True)</p>
<p class="cl">        elif key == 'r':</p>
<p class="cl">            self.camera.rotate(False)</p>
<p class="clf">    def reshape(self, width, height):</p>
<p class="cl">        self.width = width</p>
<p class="cl">        self.height = height</p>
<p class="cl">        self.aspect = width/float(height)</p>
<p class="cl">        self.raycube.reshape(width, height)</p>
<p class="clf">    def close(self):</p>
<p class="cl">        self.raycube.close()</p>
</div>
</section>
<section>
<h2 class="ah" id="ah1310"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1310">The Complete 2D Slicing Code</a></h2>
<p class="paft">Here is the full 2D slicing code listing.</p>
<div class="codeline1">
<p class="cl1f">import OpenGL</p>
<p class="cl1">from OpenGL.GL import *</p>
<p class="cl1">from OpenGL.GL.shaders import *</p>
<p class="cl1">import numpy, math, sys</p>
<p class="cl1f">import volreader, glutils</p>
<p class="cl1f">strVS = """</p>
<p class="cl1"># version 330 core</p>
<p class="cl1f">in vec3 aVert;</p>
<p class="cl1f">uniform mat4 uMVMatrix;</p>
<p class="cl1">uniform mat4 uPMatrix;</p>
<p class="cl1f">uniform float uSliceFrac;</p>
<p class="cl1">uniform int uSliceMode;</p>
<p class="cl1f">out vec3 texcoord;</p>
<p class="cl1f">void main() {</p>
<p class="cl1f">    // x slice</p>
<p class="cl1">    if (uSliceMode == 0) {</p>
<p class="cl1">        texcoord = vec3(uSliceFrac, aVert.x, 1.0-aVert.y);</p>
<p class="cl1"><span aria-label=" Page 252. " class="page" epub:type="pagebreak" id="p252" role="doc-pagebreak"/>    }</p>
<p class="cl1">    // y slice</p>
<p class="cl1">    else if (uSliceMode == 1) {</p>
<p class="cl1">        texcoord = vec3(aVert.x, uSliceFrac, 1.0-aVert.y);</p>
<p class="cl1">    }</p>
<p class="cl1">    // z slice</p>
<p class="cl1">    else {</p>
<p class="cl1">        texcoord = vec3(aVert.x, 1.0-aVert.y, uSliceFrac);</p>
<p class="cl1">    }</p>
<p class="cl1f">    // calculate transformed vertex</p>
<p class="cl1">    gl_Position = uPMatrix * uMVMatrix * vec4(aVert, 1.0);</p>
<p class="cl1">}</p>
<p class="cl1">"""</p>
<p class="cl1f">strFS = """</p>
<p class="cl1"># version 330 core</p>
<p class="cl1f">in vec3 texcoord;</p>
<p class="cl1f">uniform sampler3D tex;</p>
<p class="cl1f">out vec4 fragColor;</p>
<p class="cl1f">void main() {</p>
<p class="cl1">    // look up color in texture</p>
<p class="cl1">    vec4 col = texture(tex, texcoord);</p>
<p class="cl1">    fragColor = col.rrra;</p>
<p class="cl1">}</p>
<p class="cl1f">"""</p>
<p class="cl1f">class SliceRender:</p>
<p class="cl1">    # slice modes</p>
<p class="cl1">    XSLICE, YSLICE, ZSLICE = 0, 1, 2</p>
<p class="cl1f">    def __init__(self, width, height, volume):</p>
<p class="cl1">        """SliceRender constructor"""</p>
<p class="cl1">        self.width = width</p>
<p class="cl1">        self.height = height</p>
<p class="cl1">        self.aspect = width/float(height)</p>
<p class="cl1f">        # slice mode</p>
<p class="cl1">        self.mode = SliceRender.ZSLICE</p>
<p class="cl1f">        # create shader</p>
<p class="cl1">        self.program = glutils.loadShaders(strVS, strFS)</p>
<p class="cl1f">        glUseProgram(self.program)</p>
<p class="cl1f">        self.pMatrixUniform = glGetUniformLocation(self.program, b'uPMatrix')</p>
<p class="cl1">        self.mvMatrixUniform = glGetUniformLocation(self.program, b"uMVMatrix")</p>
<p class="cl1f">        # attributes</p>
<p class="cl1">        self.vertIndex = glGetAttribLocation(self.program, b"aVert")</p>
<p class="cl1f"><span aria-label=" Page 253. " class="page" epub:type="pagebreak" id="p253" role="doc-pagebreak"/>        # set up vertex array object (VAO)</p>
<p class="cl1">        self.vao = glGenVertexArrays(1)</p>
<p class="cl1">        glBindVertexArray(self.vao)</p>
<p class="cl1f">        # define quad vertices</p>
<p class="cl1">        vertexData = numpy.array([0.0, 1.0, 0.0,</p>
<p class="cl1">                                  0.0, 0.0, 0.0,</p>
<p class="cl1">                                  1.0, 1.0, 0.0,</p>
<p class="cl1">                                  1.0, 0.0, 0.0], numpy.float32)</p>
<p class="cl1">        # vertex buffer</p>
<p class="cl1">        self.vertexBuffer = glGenBuffers(1)</p>
<p class="cl1">        glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)</p>
<p class="cl1">        glBufferData(GL_ARRAY_BUFFER, 4*len(vertexData), vertexData,</p>
<p class="cl1">                     GL_STATIC_DRAW)</p>
<p class="cl1">        # enable arrays</p>
<p class="cl1">        glEnableVertexAttribArray(self.vertIndex)</p>
<p class="cl1">        # set buffers</p>
<p class="cl1">        glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)</p>
<p class="cl1">        glVertexAttribPointer(self.vertIndex, 3, GL_FLOAT, GL_FALSE, 0, None)</p>
<p class="cl1f">        # unbind VAO</p>
<p class="cl1">        glBindVertexArray(0)</p>
<p class="cl1f">        # load texture</p>
<p class="cl1">        self.texture, self.Nx, self.Ny, self.Nz = volume</p>
<p class="cl1f">        # current slice index</p>
<p class="cl1">        self.currSliceIndex = int(self.Nz/2);</p>
<p class="cl1">        self.currSliceMax = self.Nz;</p>
<p class="cl1f">    def reshape(self, width, height):</p>
<p class="cl1">        self.width = width</p>
<p class="cl1">        self.height = height</p>
<p class="cl1">        self.aspect = width/float(height)</p>
<p class="cl1f">    def draw(self):</p>
<p class="cl1">        # clear buffers</p>
<p class="cl1">        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)</p>
<p class="cl1">        # build projection matrix</p>
<p class="cl1">        pMatrix = glutils.ortho(-0.6, 0.6, -0.6, 0.6, 0.1, 100.0)</p>
<p class="cl1">        # modelview matrix</p>
<p class="cl1">        mvMatrix = numpy.array([1.0, 0.0, 0.0, 0.0,</p>
<p class="cl1">                                0.0, 1.0, 0.0, 0.0,</p>
<p class="cl1">                                0.0, 0.0, 1.0, 0.0,</p>
<p class="cl1">                                -0.5, -0.5, -1.0, 1.0], numpy.float32)</p>
<p class="cl1">        # use shader</p>
<p class="cl1">        glUseProgram(self.program)</p>
<p class="cl1f">        # set projection matrix</p>
<p class="cl1">        glUniformMatrix4fv(self.pMatrixUniform, 1, GL_FALSE, pMatrix)</p>
<p class="cl1f">        # set modelview matrix</p>
<p class="cl1">        glUniformMatrix4fv(self.mvMatrixUniform, 1, GL_FALSE, mvMatrix)</p>
<p class="cl1f">        # set current slice fraction</p>
<p class="cl1">        glUniform1f(glGetUniformLocation(self.program, b"uSliceFrac"),</p>
<p class="cl1"><span aria-label=" Page 254. " class="page" epub:type="pagebreak" id="p254" role="doc-pagebreak"/>                    float(self.currSliceIndex)/float(self.currSliceMax))</p>
<p class="cl1">        # set current slice mode</p>
<p class="cl1">        glUniform1i(glGetUniformLocation(self.program, b"uSliceMode"),</p>
<p class="cl1">                    self.mode)</p>
<p class="cl1f">        # enable texture</p>
<p class="cl1">        glActiveTexture(GL_TEXTURE0)</p>
<p class="cl1">        glBindTexture(GL_TEXTURE_3D, self.texture)</p>
<p class="cl1">        glUniform1i(glGetUniformLocation(self.program, b"tex"), 0)</p>
<p class="cl1f">        # bind VAO</p>
<p class="cl1">        glBindVertexArray(self.vao)</p>
<p class="cl1">        # draw</p>
<p class="cl1">        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)</p>
<p class="cl1">        # unbind VAO</p>
<p class="cl1">        glBindVertexArray(0)</p>
<p class="cl1f">    def keyPressed(self, key):</p>
<p class="cl1">        """keypress handler"""</p>
<p class="cl1">        if key == 'x':</p>
<p class="cl1">            self.mode = SliceRender.XSLICE</p>
<p class="cl1">            # reset slice index</p>
<p class="cl1">            self.currSliceIndex = int(self.Nx/2)</p>
<p class="cl1">            self.currSliceMax = self.Nx</p>
<p class="cl1">        elif key == 'y':</p>
<p class="cl1">            self.mode = SliceRender.YSLICE</p>
<p class="cl1">            # reset slice index</p>
<p class="cl1">            self.currSliceIndex = int(self.Ny/2)</p>
<p class="cl1">            self.currSliceMax = self.Ny</p>
<p class="cl1">        elif key == 'z':</p>
<p class="cl1">            self.mode = SliceRender.ZSLICE</p>
<p class="cl1">            # reset slice index</p>
<p class="cl1">            self.currSliceIndex = int(self.Nz/2)</p>
<p class="cl1">            self.currSliceMax = self.Nz</p>
<p class="cl1">        elif key == 'l':</p>
<p class="cl1">            self.currSliceIndex = (self.currSliceIndex + 1) % self.currSliceMax</p>
<p class="cl1">        elif key == 'r':</p>
<p class="cl1">            self.currSliceIndex = (self.currSliceIndex - 1) % self.currSliceMax</p>
<p class="cl1f">    def close(self):</p>
<p class="cl1">        pass</p>
</div>
</section>
<section>
<h2 class="ah" id="ah1311"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1311">The Complete Main File Code</a></h2>
<p class="paft">Here is the full code listing for the main file.</p>
<div class="codeline1">
<p class="cl1f">import sys, argparse, os</p>
<p class="cl1">from slicerender import *</p>
<p class="cl1">from raycast import *</p>
<p class="cl1">import glfw</p>
<p class="cl1f">class RenderWin:</p>
<p class="cl1">    """GLFW Rendering window class"""</p>
<p class="cl1">    def __init__(self, imageDir):</p>
<p class="cl1f"><span aria-label=" Page 255. " class="page" epub:type="pagebreak" id="p255" role="doc-pagebreak"/>        # save current working directory</p>
<p class="cl1">        cwd = os.getcwd()</p>
<p class="cl1f">        # initialize glfw; this changes cwd</p>
<p class="cl1">        glfw.glfwInit()</p>
<p class="cl1f">        # restore cwd</p>
<p class="cl1">        os.chdir(cwd)</p>
<p class="cl1f">        # version hints</p>
<p class="cl1">        glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MAJOR, 3)</p>
<p class="cl1">        glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MINOR, 3)</p>
<p class="cl1">        glfw.glfwWindowHint(glfw.GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE)</p>
<p class="cl1">        glfw.glfwWindowHint(glfw.GLFW_OPENGL_PROFILE,</p>
<p class="cl1">                            glfw.GLFW_OPENGL_CORE_PROFILE)</p>
<p class="cl1f">        # make a window</p>
<p class="cl1">        self.width, self.height = 512, 512</p>
<p class="cl1">        self.aspect = self.width/float(self.height)</p>
<p class="cl1">        self.win = glfw.glfwCreateWindow(self.width, self.height, b"volrender")</p>
<p class="cl1">        # make context current</p>
<p class="cl1">        glfw.glfwMakeContextCurrent(self.win)</p>
<p class="cl1f">        # initialize GL</p>
<p class="cl1">        glViewport(0, 0, self.width, self.height)</p>
<p class="cl1">        glEnable(GL_DEPTH_TEST)</p>
<p class="cl1">        glClearColor(0.0, 0.0, 0.0, 0.0)</p>
<p class="cl1f">        # set window callbacks</p>
<p class="cl1">        glfw.glfwSetMouseButtonCallback(self.win, self.onMouseButton)</p>
<p class="cl1">        glfw.glfwSetKeyCallback(self.win, self.onKeyboard)</p>
<p class="cl1">        glfw.glfwSetWindowSizeCallback(self.win, self.onSize)</p>
<p class="cl1f">        # load volume data</p>
<p class="cl1">        self.volume =  volreader.loadVolume(imageDir)</p>
<p class="cl1">        # create renderer</p>
<p class="cl1">        self.renderer = RayCastRender(self.width, self.height, self.volume)</p>
<p class="cl1f">        # exit flag</p>
<p class="cl1">        self.exitNow = False</p>
<p class="cl1f">    def onMouseButton(self, win, button, action, mods):</p>
<p class="cl1">        # print 'mouse button: ', win, button, action, mods</p>
<p class="cl1">        pass</p>
<p class="cl1f">    def onKeyboard(self, win, key, scancode, action, mods):</p>
<p class="cl1">        # print 'keyboard: ', win, key, scancode, action, mods</p>
<p class="cl1">        # ESC to quit</p>
<p class="cl1">        if key is glfw.GLFW_KEY_ESCAPE:</p>
<p class="cl1">            self.renderer.close()</p>
<p class="cl1">            self.exitNow = True</p>
<p class="cl1">        else:</p>
<p class="cl1">            if action is glfw.GLFW_PRESS or action is glfw.GLFW_REPEAT:</p>
<p class="cl1">                if key == glfw.GLFW_KEY_V:</p>
<p class="cl1">                    # toggle render mode</p>
<p class="cl1"><span aria-label=" Page 256. " class="page" epub:type="pagebreak" id="p256" role="doc-pagebreak"/>                    if isinstance(self.renderer, RayCastRender):</p>
<p class="cl1">                        self.renderer = SliceRender(self.width, self.height,</p>
<p class="cl1">                                                    self.volume)</p>
<p class="cl1">                    else:</p>
<p class="cl1">                        self.renderer = RayCastRender(self.width, self.height,</p>
<p class="cl1">                                                      self.volume)</p>
<p class="cl1">                    # call reshape on renderer</p>
<p class="cl1">                    self.renderer.reshape(self.width, self.height)</p>
<p class="cl1">                else:</p>
<p class="cl1">                    # send keypress to renderer</p>
<p class="cl1">                    keyDict = {glfw.GLFW_KEY_X: 'x', glfw.GLFW_KEY_Y: 'y',</p>
<p class="cl1">                               glfw.GLFW_KEY_Z: 'z', glfw.GLFW_KEY_LEFT: 'l',</p>
<p class="cl1">                               glfw.GLFW_KEY_RIGHT: 'r'}</p>
<p class="cl1">                    try:</p>
<p class="cl1">                        self.renderer.keyPressed(keyDict[key])</p>
<p class="cl1">                    except:</p>
<p class="cl1">                        pass</p>
<p class="cl1f">    def onSize(self, win, width, height):</p>
<p class="cl1">        # print 'onsize: ', win, width, height</p>
<p class="cl1">        self.width = width</p>
<p class="cl1">        self.height = height</p>
<p class="cl1">        self.aspect = width/float(height)</p>
<p class="cl1">        glViewport(0, 0, self.width, self.height)</p>
<p class="cl1">        self.renderer.reshape(width, height)</p>
<p class="cl1f">    def run(self):</p>
<p class="cl1">        # start loop</p>
<p class="cl1">        while not glfw.glfwWindowShouldClose(self.win) and not self.exitNow:</p>
<p class="cl1">            # render</p>
<p class="cl1">            self.renderer.draw()</p>
<p class="cl1">            # swap buffers</p>
<p class="cl1">            glfw.glfwSwapBuffers(self.win)</p>
<p class="cl1">            # wait for events</p>
<p class="cl1">            glfw.glfwWaitEvents()</p>
<p class="cl1">        # end</p>
<p class="cl1">        glfw.glfwTerminate()</p>
<p class="cl1f"># main() function</p>
<p class="cl1">def main():</p>
<p class="cl1">    print('starting volrender...')</p>
<p class="cl1">    # create parser</p>
<p class="cl1">    parser = argparse.ArgumentParser(description="Volume Rendering...")</p>
<p class="cl1">    # add expected arguments</p>
<p class="cl1">    parser.add_argument('--dir', dest='imageDir', required=True)</p>
<p class="cl1">    # parse args</p>
<p class="cl1">    args = parser.parse_args()</p>
<p class="cl1f">    # create render window</p>
<p class="cl1">    rwin = RenderWin(args.imageDir)</p>
<p class="cl1">    rwin.run()</p>
<p class="cl1f"># call main</p>
<p class="cl1">if __name__ == '__main__':</p>
<p class="cl1">    main()</p>
</div>
<div class="notes">
<div class="footnote" role="doc-footnote">
<p class="fn"><a class="fnnum" href="nsp-venkitachalam503045-0025.xhtml#fn4r" id="fn4" role="doc-backlink">1</a> J. Kruger and R. Westermann, “Acceleration Techniques for GPU-based Volume Rendering,” IEEE Visualization, 2003.</p>
</div>
<div class="footnote" role="doc-footnote">
<p class="fn"><a class="fnnum" href="nsp-venkitachalam503045-0025.xhtml#fn5r" id="fn5" role="doc-backlink">2</a> <a class="url-i" href="https://graphics.stanford.edu/data/voldata/">https://graphics.stanford.edu/data/voldata/</a></p>
</div>
</div>
</section>
</section>
</div></body></html>