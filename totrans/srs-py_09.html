<html><head></head><body>
<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_135"/><strong><span class="big">9</span></strong><br/><strong>THE ABSTRACT SYNTAX TREE, HY, AND LISP-LIKE ATTRIBUTES</strong></h2>&#13;
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>&#13;
<p class="noindent">The <em>abstract syntax tree (AST)</em> is a representation of the structure of the source code of any programming language. Every language, including Python, has a specific AST; Python’s AST is built by parsing a Python source file. Like any tree, this one is made of nodes linked together. A node can represent an operation, a statement, an expression, or even a module. Each node can contain references to other nodes that make up the tree.</p>&#13;
<p class="indent">Python’s AST is not heavily documented and is thus hard to deal with at first glance, but understanding some deeper aspects of how Python is constructed can help you master its usage.</p>&#13;
<p class="indent">This chapter will examine the AST of some simple Python commands to get you familiar with the structure and how it’s used. Once you’re familiar <span epub:type="pagebreak" id="page_136"/>with the AST, we’ll build a program that can check for wrongly declared methods using <span class="literal">flake8</span> and the AST. Finally, we’ll look at Hy, a Python-Lisp hybrid language built on the Python AST.</p>&#13;
<h3 class="h3" id="lev1sec46"><strong>Looking at the AST</strong></h3>&#13;
<p class="noindent">The easiest way to view the Python AST is to parse some Python code and dump the generated AST. For that, the Python <span class="literal">ast</span> module provides everything you need, as shown in <a href="ch09.xhtml#ch9list1">Listing 9-1</a>.</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">import ast</span><br/>&gt;&gt;&gt; <span class="codestrong1">ast.parse</span><br/>&lt;function parse at 0x7f062731d950&gt;<br/>&gt;&gt;&gt; <span class="codestrong1">ast.parse("x = 42")</span><br/>&lt;_ast.Module object at 0x7f0628a5ad10&gt;<br/>&gt;&gt;&gt; <span class="codestrong1">ast.dump(ast.parse("x = 42"))</span><br/>"Module(body=[Assign(targets=[Name(id='x', ctx=Store())], value=Num(n=42))])"</p>&#13;
<p class="listing1"><a id="ch9list1"/><em>Listing 9-1: Using the <span class="codeitalic">ast</span> module to dump the AST generated by parsing code</em></p>&#13;
<p class="indent">The <span class="literal">ast.parse()</span> function parses any string that contains Python code and returns an <span class="literal">_ast.Module</span> object. That object is actually the root of the tree: you can browse it to discover every node making up the tree. To visualize what the tree looks like, you can use the <span class="literal">ast.dump()</span> function, which will return a string representation of the whole tree.</p>&#13;
<p class="indent">In <a href="ch09.xhtml#ch9list1">Listing 9-1</a>, the code <span class="literal">x = 42</span> is parsed with <span class="literal">ast.parse()</span>, and the result is printed using <span class="literal">ast.dump()</span>. This abstract syntax tree can be rendered as shown in <a href="ch09.xhtml#ch9fig1">Figure 9-1</a>, which shows the structure of the Python <span class="literal">assign</span> command.</p>&#13;
<div class="image"><a id="ch9fig1"/><img alt="image" src="../images/f09-01.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-1: The AST of the <span class="codeitalic">assign</span> command in Python</em></p>&#13;
<p class="indent">The AST always starts with a root element, which is usually an _<span class="literal">ast.Module</span> object. This module object contains a list of statements or expressions to evaluate in its <em>body</em> attribute and usually represents the content of a file.</p>&#13;
<p class="indent">As you can probably guess, the <span class="literal">ast.Assign</span> object shown in <a href="ch09.xhtml#ch9fig1">Figure 9-1</a> represents an <em>assignment</em>, which is mapped to the <span class="literal">=</span> sign in the Python syntax. An <span class="literal">ast.Assign</span> object has a list of <em>targets</em> and a <em>value</em> to set the targets to. <span epub:type="pagebreak" id="page_137"/>The list of targets in this case consists of one object, <span class="literal">ast.Name</span>, which represents a variable whose ID is <em>x</em>. The value is a number <em>n</em> with a value (in this case) 42. The ctx attribute stores a <em>context</em>, either <span class="literal">ast.Store</span> or <span class="literal">ast.Load</span>, depending on whether the variable is being used for reading or writing. In this case, the variable is being assigned a value, so an <span class="literal">ast.Store</span> context is used.</p>&#13;
<p class="indent">We could pass this AST to Python to be compiled and evaluated via the built-in <span class="literal">compile()</span> function. This function takes an AST as argument, the source filename, and a mode (either <span class="literal">'exec'</span>, <span class="literal">'eval'</span>, or <span class="literal">'single'</span>). The source filename can be any name that you want your AST to appear to be from; it is common to use the string <span class="literal">&lt;input&gt;</span> as the source filename if the data does not come from a stored file, as shown in <a href="ch09.xhtml#ch9list2">Listing 9-2</a>.</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">compile(ast.parse("x = 42"), '&lt;input&gt;', 'exec')</span><br/>&lt;code object &lt;module&gt; at 0x111b3b0, file "&lt;input&gt;", line 1&gt;<br/>&gt;&gt;&gt; <span class="codestrong1">eval(compile(ast.parse("x = 42"), '&lt;input&gt;', 'exec'))</span><br/>&gt;&gt;&gt; <span class="codestrong1">x</span><br/>42</p>&#13;
<p class="listing1"><a id="ch9list2"/><em>Listing 9-2: Using the <span class="codeitalic">compile()</span> function to compile data that is not from a stored file</em></p>&#13;
<p class="indent">The modes stand for execute (<span class="literal">exec</span>), evaluate (<span class="literal">eval</span>), and single statement (<span class="literal">single</span>). The mode should match what has been given to <span class="literal">ast.parse()</span>, whose default is <span class="literal">exec</span>.</p>&#13;
<ul>&#13;
<li><p class="noindent">The <span class="literal">exec</span> mode is the normal Python mode, used when an _<span class="literal">ast.Module</span> is the root of the tree.</p></li>&#13;
<li><p class="noindent">The <span class="literal">eval</span> mode is a special mode that expects a single <span class="literal">ast.Expression</span> as the tree.</p></li>&#13;
<li><p class="noindent">Finally, <span class="literal">single</span> is another special mode that expects a single statement or expression. If it gets an expression, <span class="literal">sys.displayhook()</span> will be called with the result, as when code is run in the interactive shell.</p></li>&#13;
</ul>&#13;
<p class="indent">The root of the AST is <span class="literal">ast.Interactive</span>, and its <span class="literal">body</span> attribute is a list of nodes.</p>&#13;
<p class="indent">We could build an AST manually using the classes provided in the <span class="literal">ast</span> module. Obviously, this is a very long way to write Python code and not a method I would recommend! Nonetheless, it’s fun to do and helpful for learning about the AST. Let’s see what programming with the AST would look like.</p>&#13;
<h4 class="h4" id="lev2sec51"><strong><em>Writing a Program Using the AST</em></strong></h4>&#13;
<p class="noindent">Let’s write a good old <span class="literal">"Hello world!"</span> program in Python by building an abstract syntax tree manually.</p>&#13;
<p class="programs"><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong1">hello_world = ast.Str(s='hello world!', lineno=1, col_offset=1)</span><br/><span class="ent">➋</span> &gt;&gt;&gt; <span class="codestrong1">print_name = ast.Name(id='print', ctx=ast.Load(), lineno=1, col_offset=1)</span><br/><span class="ent">➌</span> &gt;&gt;&gt; <span class="codestrong1">print_call = ast.Call(func=print_name, ctx=ast.Load(),</span><br/>   <span class="codestrong1">... args=[hello_world], keywords=[], lineno=1, col_offset=1)</span><br/><span class="ent">➍</span> &gt;&gt;&gt; <span class="codestrong1">module = ast.Module(body=[ast.Expr(print_call,</span><span epub:type="pagebreak" id="page_138"/><br/>   <span class="codestrong1">... lineno=1, col_offset=1)], lineno=1, col_offset=1)</span><br/><span class="ent">➎</span> &gt;&gt;&gt; <span class="codestrong1">code = compile(module, '', 'exec')</span><br/>   &gt;&gt;&gt; <span class="codestrong1">eval(code)</span><br/>   hello world!</p>&#13;
<p class="listing1"><a id="ch9list3"/><em>Listing 9-3: Writing <span class="codeitalic">hello world!</span> using the AST</em></p>&#13;
<p class="indent">In <a href="ch09.xhtml#ch9list3">Listing 9-3</a>, we build the tree one leaf at a time, where each leaf is an element (whether a value or an instruction) of the program.</p>&#13;
<p class="indent">The first leaf is a simple string <span class="ent">➊</span>: the <span class="literal">ast.Str</span> represents a literal string, which here contains the <span class="literal">hello world!</span> text. The <span class="literal">print_name</span> variable <span class="ent">➋</span> contains an <span class="literal">ast.Name</span> object, which refers to a variable—in this case, the <span class="literal">print</span> variable that points to the <span class="literal">print()</span> function.</p>&#13;
<p class="indent">The <span class="literal">print_call</span> variable <span class="ent">➌</span> contains a function call. It refers to the function name to call, the regular arguments to pass to the function call, and the keyword arguments. Which arguments are used depend on the functions being called. In this case, since it’s the <span class="literal">print()</span> function, we’ll pass the string we made and stored in <span class="literal">hello_world</span>.</p>&#13;
<p class="indent">At last, we create an _<span class="literal">ast.Module</span> object <span class="ent">➍</span> to contain all this code as a list of one expression. We can compile _<span class="literal">ast.Module</span> objects using the <span class="literal">compile()</span> function <span class="ent">➎</span>, which parses the tree and generates a native <span class="literal">code</span> object. These <span class="literal">code</span> objects are compiled Python code and can finally be executed by a Python virtual machine using <span class="literal">eval</span>!</p>&#13;
<p class="indent">This whole process is exactly what happens when you run Python on a <em>.py</em> file: once the text tokens are parsed, they are converted into a tree of <span class="literal">ast</span> objects, compiled, and evaluated.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The arguments <span class="codeitalic">lineno</span> and <span class="codeitalic">col_offset</span> represent the line number and column offset, respectively, of the source code that has been used to generate the AST. It doesn’t make much sense to set these values in this context since we are not parsing a source file, but it can be useful to be able to find the position of the code that generated the AST. For example, Python uses this information when generating backtraces. Indeed, Python refuses to compile an AST object that doesn’t provide this information, so we pass fake values to these. You could also use the <span class="codeitalic">ast.fix_missing_locations()</span> function to set the missing values to the ones set on the parent node.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="lev2sec52"><strong><em>The AST Objects</em></strong></h4>&#13;
<p class="noindent">You can view the whole list of objects available in the AST by reading the <span class="literal">_ast</span> module documentation (note the underscore).</p>&#13;
<p class="indent">The objects are organized into two main categories: statements and expressions. <em>Statements</em> include types such as <span class="literal">assert</span>, assignment (<span class="literal">=</span>), augmented assignment (<span class="literal">+=</span>, <span class="literal">/=</span>, etc.), <span class="literal">global</span>, <span class="literal">def</span>, <span class="literal">if</span>, <span class="literal">return</span>, <span class="literal">for</span>, <span class="literal">class</span>, <span class="literal">pass</span>, <span class="literal">import</span>, <span class="literal">raise</span>, and so forth. Statements inherit from <span class="literal">ast.stmt</span>; they influence the control flow of a program and are often composed of expressions.</p>&#13;
<p class="indent"><em>Expressions</em> include types such as <span class="literal">lambda</span>, <span class="literal">number</span>, <span class="literal">yield</span>, <span class="literal">name</span> (variable), <span class="literal">compare</span>, and <span class="literal">call</span>. Expressions inherit from <span class="literal">ast.expr</span>; they differ from statements in that they usually produce a value and have no impact on the program flow.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_139"/>There are also a few smaller categories, such as the <span class="literal">ast.operator</span> class, which defines standard operators such as <em>add</em> (<span class="literal">+</span>), <em>div</em> (<span class="literal">/</span>), and <em>right shift</em> (<span class="literal">&gt;&gt;</span>), and the <span class="literal">ast.cmpop</span> module, which defines comparisons operators.</p>&#13;
<p class="indent">The simple example here should give you an idea of how to build an AST from scratch. It’s easy to then imagine how you might leverage this AST to construct a compiler that would parse strings and generate code, allowing you to implement your own syntax to Python! This is exactly what led to the development of the Hy project, which we’ll discuss later in this chapter.</p>&#13;
<h4 class="h4" id="lev2sec53"><strong><em>Walking Through an AST</em></strong></h4>&#13;
<p class="noindent">To follow how a tree is built or access particular nodes, you sometimes need to walk through your tree, browsing it and iterating over the nodes. You can do this with the <span class="literal">ast.walk()</span> function. Alternatively, the <span class="literal">ast</span> module also provides <span class="literal">NodeTransformer</span>, a class that you can subclass to walk through an AST and modify particular nodes. Using <span class="literal">NodeTransformer</span> makes it easy to change code dynamically, as shown in <a href="ch09.xhtml#ch9list4">Listing 9-4</a>.</p>&#13;
<p class="programs">   import ast<br/><br/>   class ReplaceBinOp(ast.NodeTransformer):<br/>       """Replace operation by addition in binary operation"""<br/>       def visit_BinOp(self, node):<br/>           return ast.BinOp(left=node.left,<br/>                            op=ast.Add(),<br/>                            right=node.right)<br/><br/><span class="ent">➊</span> tree = ast.parse("x = 1/3")<br/>   ast.fix_missing_locations(tree)<br/>   eval(compile(tree, '', 'exec'))<br/>   print(ast.dump(tree))<br/><span class="ent">➋</span> print(x)<br/><br/><span class="ent">➌</span> tree = ReplaceBinOp().visit(tree)<br/>   ast.fix_missing_locations(tree)<br/>   print(ast.dump(tree))<br/>   eval(compile(tree, '', 'exec'))<br/><span class="ent">➍</span> print(x)</p>&#13;
<p class="listing1"><a id="ch9list4"/><em>Listing 9-4: Walking a tree with <span class="codeitalic">NodeTransformer</span> to alter a node</em></p>&#13;
<p class="indent">The first <span class="literal">tree</span> object built <span class="ent">➊</span> is an AST that represents the expression <span class="literal">x = 1/3</span>. Once this is compiled and evaluated, the result of printing <span class="literal">x</span> at the end of the function <span class="ent">➋</span> is <span class="literal">0.33333</span>, the expected result of <span class="literal">1/3</span>.</p>&#13;
<p class="indent">The second <span class="literal">tree</span> object <span class="ent">➌</span> is an instance of <span class="literal">ReplaceBinOp</span>, which inherits from <span class="literal">ast.NodeTransformer</span>. It implements its own version of the <span class="literal">ast.NodeTransformer.visit()</span> method and changes any <span class="literal">ast.BinOp</span> operation to an <span class="literal">ast.BinOp</span> that executes <span class="literal">ast.Add</span>. Concretely, this changes any binary operator (<span class="literal">+</span>, <span class="literal">-</span>, <span class="literal">/</span>, and so on) to the <span class="literal">+</span> operator. When this second tree is compiled and evaluated <span class="ent">➍</span>, the result is now <span class="literal">4</span>, which is the result of <span class="literal">1 + 3</span>, because the <span class="literal">/</span> in the first object is replaced with <span class="literal">+</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_140"/>You can see the execution of the program here:</p>&#13;
<p class="programs">Module(body=[Assign(targets=[Name(id='x', ctx=Store())],<br/>                    value=BinOp(left=Num(n=1), op=Div(), right=Num(n=3)))])<br/>0.3333333333333333<br/>Module(body=[Assign(targets=[Name(id='x', ctx=Store())],<br/>                    value=BinOp(left=Num(n=1), op=Add(), right=Num(n=3)))])<br/>4</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you need to evaluate a string that should return a simple data type, you can use <span class="codeitalic">ast.literal_eval</span>. As a safer alternative to <span class="codeitalic">eval</span>, it prevents the input string from executing any code.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="lev1sec47"><strong>Extending flake8 with AST Checks</strong></h3>&#13;
<p class="noindent">In <a href="ch07.xhtml#ch07">Chapter 7</a>, you learned that methods that do not rely on the object state should be declared static with the <span class="literal">@staticmethod</span> decorator. The problem is that a lot of developers simply forget to do so. I’ve personally spent too much time reviewing code and asking people to fix this problem.</p>&#13;
<p class="indent">We’ve seen how to use <span class="literal">flake8</span> to do some automatic checking in the code. In fact, <span class="literal">flake8</span> is extensible and can provide even more checks. We’ll write a <span class="literal">flake8</span> extension that checks for static method declaration omission by analyzing the AST.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch9list5">Listing 9-5</a> shows an example of one class that omits the static declaration and one that correctly includes it. Write this program out and save it as <em>ast_ext.py</em>; we’ll use it in a moment to write our extension.</p>&#13;
<p class="programs">class Bad(object):<br/>    # self is not used, the method does not need<br/>    # to be bound, it should be declared static<br/>    def foo(self, a, b, c):<br/>        return a + b - c<br/><br/>class OK(object):<br/>    # This is correct<br/>    @staticmethod<br/>    def foo(a, b, c):<br/>        return a + b - c</p>&#13;
<p class="listing1"><a id="ch9list5"/><em>Listing 9-5: Omitting and including <span class="codeitalic">@staticmethod</span></em></p>&#13;
<p class="indent">Though the <span class="literal">Bad.foo</span> method works fine, strictly speaking it is more correct to write it as <span class="literal">OK.foo</span> (turn back to <a href="ch07.xhtml#ch07">Chapter 7</a> for more detail on why). To check whether all the methods in a Python file are correctly declared, we need to do the following:</p>&#13;
<ul>&#13;
<li><p class="noindent">Iterate over all the statement nodes of the AST.</p></li>&#13;
<li><p class="noindent">Check that the statement is a class definition (<span class="literal">ast.ClassDef</span>).</p></li>&#13;
<li><p class="noindent"><span epub:type="pagebreak" id="page_141"/>Iterate over all the function definitions (<span class="literal">ast.FunctionDef</span>) of that class statement to check whether it is already declared with <span class="literal">@staticmethod</span>.</p></li>&#13;
<li><p class="noindent">If the method is not declared static, check whether the first argument (<span class="literal">self</span>) is used somewhere in the method. If <span class="literal">self</span> is not used, the method can be tagged as potentially miswritten.</p></li>&#13;
</ul>&#13;
<p class="indent">The name of our project will be <span class="literal">ast_ext</span>. To register a new plugin in <span class="literal">flake8</span>, we need to create a packaged project with the usual <em>setup.py</em> and <em>setup.cfg</em> files. Then, we just need to add an entry point in the <em>setup.cfg</em> of our <span class="literal">ast_ext</span> project.</p>&#13;
<p class="programs">[entry_points]<br/>flake8.extension =<br/>    --<span class="codeitalic1">snip</span>--<br/>    H904 = ast_ext:StaticmethodChecker<br/>    H905 = ast_ext:StaticmethodChecker</p>&#13;
<p class="listing1"><a id="ch9list6"/><em>Listing 9-6: Allowing <span class="codeitalic">flake8</span> plugins for our chapter</em></p>&#13;
<p class="indent">In <a href="ch09.xhtml#ch9list6">Listing 9-6</a>, we also register two <span class="literal">flake8</span> error codes. As you’ll notice later, we are actually going to add an extra check to our code while we’re at it!</p>&#13;
<p class="indent">The next step is to write the plugin.</p>&#13;
<h4 class="h4" id="lev2sec54"><strong><em>Writing the Class</em></strong></h4>&#13;
<p class="noindent">Since we are writing a <span class="literal">flake8</span> check of the AST, the plugin needs to be a class following a certain signature, as shown in <a href="ch09.xhtml#ch9list7">Listing 9-7</a>.</p>&#13;
<p class="programs">class StaticmethodChecker(object):<br/>    def __init__(self, tree, filename):<br/>        self.tree = tree<br/><br/>    def run(self):<br/>        pass</p>&#13;
<p class="listing1"><a id="ch9list7"/><em>Listing 9-7: The class for checking the AST</em></p>&#13;
<p class="indent">The default template is easy to understand: it stores the tree locally for use in the <span class="literal">run()</span> method, which will <em>yield</em> the problems that are discovered. The value that will be yielded must follow the expected PEP 8 signature: a tuple of the form <span class="literal">(<span class="codeitalic">lineno</span>, <span class="codeitalic">col_offset</span>, <span class="codeitalic">error_string</span>, <span class="codeitalic">code</span>)</span>.</p>&#13;
<h4 class="h4" id="lev2sec55"><strong><em>Ignoring Irrelevant Code</em></strong></h4>&#13;
<p class="noindent">As indicated earlier, the <span class="literal">ast</span> module provides the <span class="literal">walk()</span> function, which allows you to iterate easily on a tree. We’ll use that to walk through the AST and find out what to check and what not to check.</p>&#13;
<p class="indent">First, let’s write a loop that ignores the statements that are not class definitions. Add this to your <span class="literal">ast_ext</span> project, as shown in <a href="ch09.xhtml#ch9list8">Listing 9-8</a>; code that should stay the same is grayed out.</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_142"/><span class="ash">class StaticmethodChecker(object):</span><br/>    <span class="ash">def __init__(self, tree, filename):</span><br/>        <span class="ash">self.tree = tree</span><br/><br/>    <span class="ash">def run(self):</span><br/>        for stmt in ast.walk(self.tree):<br/>            # Ignore non-class<br/>            if not isinstance(stmt, ast.ClassDef):<br/>                continue</p>&#13;
<p class="listing1"><a id="ch9list8"/><em>Listing 9-8: Ignoring statements that are not class definitions</em></p>&#13;
<p class="indent">The code in <a href="ch09.xhtml#ch9list8">Listing 9-8</a> is still not checking for anything, but now it knows how to ignore statements that are not class definitions. The next step is to set our checker to ignore anything that is not a function definition.</p>&#13;
<p class="programs"><span class="ash">for stmt in ast.walk(self.tree):</span><br/>    <span class="ash"># Ignore non-class</span><br/>    <span class="ash">if not isinstance(stmt, ast.ClassDef):</span><br/>        <span class="ash">continue</span><br/>    # If it's a class, iterate over its body member to find methods<br/>    for body_item in stmt.body:<br/>        # Not a method, skip<br/>        if not isinstance(body_item, ast.FunctionDef):<br/>            continue</p>&#13;
<p class="listing1"><a id="ch9list9"/><em>Listing 9-9: Ignoring statements that are not function definitions</em></p>&#13;
<p class="indent">In <a href="ch09.xhtml#ch9list9">Listing 9-9</a>, we ignore irrelevant statements by iterating over the attributes of the class definition.</p>&#13;
<h4 class="h4" id="lev2sec56"><strong><em>Checking for the Correct Decorator</em></strong></h4>&#13;
<p class="noindent">We’re all set to write the checking method, which is stored in the <span class="literal">body_item</span> attribute. First, we need to check whether the method that’s being checked is already declared as static. If it is, we don’t have to do any further checking and can bail out.</p>&#13;
<p class="programs"><span class="ash">for stmt in ast.walk(self.tree):</span><br/>    <span class="ash"># Ignore non-class</span><br/>    <span class="ash">if not isinstance(stmt, ast.ClassDef):</span><br/>        <span class="ash">continue</span><br/>    <span class="ash"># If it's a class, iterate over its body member to find methods</span><br/>    <span class="ash">for body_item in stmt.body:</span><br/>        <span class="ash"># Not a method, skip</span><br/>        <span class="ash">if not isinstance(body_item, ast.FunctionDef):</span><br/>            <span class="ash">continue</span><br/>        # Check that it has a decorator<br/>        for decorator in body_item.decorator_list:<br/>            if (isinstance(decorator, ast.Name)<br/>               and decorator.id == 'staticmethod'):<br/>                # It's a static function, it's OK<br/>                break<span epub:type="pagebreak" id="page_143"/><br/>        else:<br/>            # Function is not static, we do nothing for now<br/>            Pass</p>&#13;
<p class="listing1"><a id="ch9list10"/><em>Listing 9-10: Checking for the static decorator</em></p>&#13;
<p class="indent">Note that in <a href="ch09.xhtml#ch9list10">Listing 9-10</a>, we use the special <span class="literal">for/else</span> form of Python, where the <span class="literal">else</span> is evaluated unless we use <span class="literal">break</span> to exit the <span class="literal">for</span> loop. At this point, we’re able to detect whether a method is declared static.</p>&#13;
<h4 class="h4" id="lev2sec57"><strong><em>Looking for self</em></strong></h4>&#13;
<p class="noindent">The next step is to check whether the method that <em>isn’t</em> declared as static uses the <span class="literal">self</span> argument. First, check whether the method includes any arguments at all, as shown in <a href="ch09.xhtml#ch9list11">Listing 9-11</a>.</p>&#13;
<p class="programs"><span class="ash"><span class="codeitalic1">--snip--</span></span><br/>        <span class="ash"># Check that it has a decorator</span><br/>        <span class="ash">for decorator in body_item.decorator_list:</span><br/>            <span class="ash">if (isinstance(decorator, ast.Name)</span><br/>               <span class="ash">and decorator.id == 'staticmethod'):</span><br/>                <span class="ash"># It's a static function, it's OK</span><br/>                <span class="ash">break</span><br/>        <span class="ash">else:</span><br/>            try:<br/>                first_arg = body_item.args.args[0]<br/>            except IndexError:<br/>                yield (<br/>                    body_item.lineno,<br/>                    body_item.col_offset,<br/>                    "H905: method misses first argument",<br/>                    "H905",<br/>                )<br/>                # Check next method<br/>                Continue</p>&#13;
<p class="listing1"><a id="ch9list11"/><em>Listing 9-11: Checking the method for arguments</em></p>&#13;
<p class="indent">We finally added a check! This <span class="literal">try</span> statement in <a href="ch09.xhtml#ch9list11">Listing 9-11</a> grabs the first argument from the method signature. If the code fails to retrieve the first argument from the signature because a first argument doesn’t exist, we already know there’s a problem: you can’t have a bound method without the <span class="literal">self</span> argument. If the plugin detects that case, it raises the <span class="literal">H905</span> error code we set earlier, signaling a method that misses its first argument.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>PEP 8 codes follow a particular format for error codes (a letter followed by a number), but there are no rules as to which code to pick. You could come up with any other code for this error, as long as it’s not already used by PEP 8 or another extension.</em></p>&#13;
</div>&#13;
<p class="indent">Now you know why we registered two error codes in <em>setup.cfg</em>: we had a good opportunity to kill two birds with one stone.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_144"/>The next step is to check whether the <span class="literal">self</span> argument is used in the code of the method.</p>&#13;
<p class="programs"><span class="ash"><span class="codeitalic1">--snip--</span></span><br/>            <span class="ash">try:</span><br/>                <span class="ash">first_arg = body_item.args.args[0]</span><br/>            <span class="ash">except IndexError:</span><br/>                <span class="ash">yield (</span><br/>                    <span class="ash">body_item.lineno,</span><br/>                    <span class="ash">body_item.col_offset,</span><br/>                    <span class="ash">"H905: method misses first argument",</span><br/>                    <span class="ash">"H905",</span><br/>                <span class="ash">)</span><br/>                <span class="ash"># Check next method</span><br/>                <span class="ash">continue</span><br/>            for func_stmt in ast.walk(body_item):<br/>                # The checking method must differ between Python 2 and Python 3<br/>                if six.PY3:<br/>                    if (isinstance(func_stmt, ast.Name)<br/>                       and first_arg.arg == func_stmt.id):<br/>                        # The first argument is used, it's OK<br/>                        break<br/>                else:<br/>                    if (func_stmt != first_arg<br/>                       and isinstance(func_stmt, ast.Name)<br/>                       and func_stmt.id == first_arg.id):<br/>                        # The first argument is used, it's OK<br/>                        break<br/>            else:<br/>                yield (<br/>                    body_item.lineno,<br/>                    body_item.col_offset,<br/>                    "H904: method should be declared static",<br/>                    "H904",<br/>                )</p>&#13;
<p class="listing1"><a id="ch9list12"/><em>Listing 9-12: Checking the method for the <span class="codeitalic">self</span> argument</em></p>&#13;
<p class="indent">To check whether the <span class="literal">self</span> argument is used in the method’s body, the plugin in <a href="ch09.xhtml#ch9list12">Listing 9-12</a> iterates recursively, using <span class="literal">ast.walk</span> on the body and looking for the use of the variable named <span class="literal">self</span>. If the variable isn’t found, the program finally yields the <span class="literal">H904</span> error code. Otherwise, nothing happens, and the code is considered sane.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>As you may have noticed, the code walks over the module AST definition several times. There might be some degree of optimization to browsing the AST in only one pass, but I’m not sure it’s worth it, given how the tool is actually used. I’ll leave that exercise to you, dear reader.</em></p>&#13;
</div>&#13;
<p class="indent">Knowing the Python AST is not strictly necessary for using Python, but it does give powerful insight into how the language is built and how it works. It thus gives you a better understanding of how the code you write is being used under the hood.</p>&#13;
<h3 class="h3" id="lev1sec48"><span epub:type="pagebreak" id="page_145"/><strong>A Quick Introduction to Hy</strong></h3>&#13;
<p class="noindent">Now that you have a good understanding of how Python AST works, you can start dreaming of creating a new syntax for Python. You could parse this new syntax, build an AST out of it, and compile it down to Python code.</p>&#13;
<p class="indent">This is exactly what Hy does. <em>Hy</em> is a Lisp dialect that parses a Lisp-like language and converts it to regular Python AST, making it fully compatible with the Python ecosystem. You could compare it to what Clojure is to Java. Hy could fill a book by itself, so we will only skim over it. Hy uses the syntax and some features of the Lisp family of languages: it’s functionally oriented, provides macros, and is easily extensible.</p>&#13;
<p class="indent">If you’re not already familiar with Lisp—and you should be—the Hy syntax will look familiar. Once you install Hy (by running <span class="literal">pip install hy</span>), launching the <span class="literal">hy</span> interpreter will give you a standard REPL prompt from which you can start to interact with the interpreter, as shown in <a href="ch09.xhtml#ch9list13">Listing 9-13</a>.</p>&#13;
<p class="programs">% <span class="codestrong1">hy</span><br/>hy 0.9.10<br/>=&gt; <span class="codestrong1">(+ 1 2)</span><br/>3</p>&#13;
<p class="listing1"><a id="ch9list13"/><em>Listing 9-13: Interacting with the Hy interpreter</em></p>&#13;
<p class="indent">For those not familiar with the Lisp syntax, parentheses are used to construct lists. If a list is unquoted, it is evaluated: the first element must be a function, and the rest of the items from the list are passed as arguments. Here the code <span class="literal">(+ 1 2)</span> is equivalent to <span class="literal">1 + 2</span> in Python.</p>&#13;
<p class="indent">In Hy, most constructs, such as function definitions, are mapped from Python directly.</p>&#13;
<p class="programs">=&gt; <span class="codestrong1">(defn hello [name]</span><br/><span class="codestrong1">...  (print "Hello world!")</span><br/><span class="codestrong1">...  (print (% "Nice to meet you %s" name)))</span><br/>=&gt; <span class="codestrong1">(hello "jd")</span><br/>Hello world!<br/>Nice to meet you jd</p>&#13;
<p class="listing1"><a id="ch9list14"/><em>Listing 9-14: Mapping a function definition from Python</em></p>&#13;
<p class="indent">As shown in <a href="ch09.xhtml#ch9list14">Listing 9-14</a>, internally Hy parses the code provided, converts it to a Python AST, compiles it, and evaluates it. Fortunately, Lisp is an easy tree to parse: each pair of parentheses represents a node of the tree, meaning the conversion is actually easier than for the native Python syntax!</p>&#13;
<p class="indent">Class definition is supported through the <span class="literal">defclass</span> construct, which is inspired by the Common Lisp Object System (CLOS).</p>&#13;
<p class="programs">(defclass A [object]<br/>  [[x 42]<span epub:type="pagebreak" id="page_146"/><br/>   [y (fn [self value]<br/>        (+ self.x value))]])</p>&#13;
<p class="listing1"><a id="ch9list15"/><em>Listing 9-15: Defining a class with <span class="codeitalic">defclass</span></em></p>&#13;
<p class="indent"><a href="ch09.xhtml#ch9list15">Listing 9-15</a> defines a class named <span class="literal">A</span>, which inherits from <span class="literal">object</span>, with a class attribute <span class="literal">x</span> whose value is 42; then a method <span class="literal">y</span> returns the <span class="literal">x</span> attribute plus a value passed as argument.</p>&#13;
<p class="indent">What’s really wonderful is that you can import <em>any Python library</em> directly into Hy and use it with no penalty. Use the <span class="literal">import()</span> function to import a module, as shown in <a href="ch09.xhtml#ch9list16">Listing 9-16</a>, just as you would with regular Python.</p>&#13;
<p class="programs">=&gt; <span class="codestrong1">(import uuid)</span><br/>=&gt; <span class="codestrong1">(uuid.uuid4)</span><br/>UUID('f823a749-a65a-4a62-b853-2687c69d0e1e')<br/>=&gt; <span class="codestrong1">(str (uuid.uuid4))</span><br/>'4efa60f2-23a4-4fc1-8134-00f5c271f809'</p>&#13;
<p class="listing1"><a id="ch9list16"/><em>Listing 9-16: Importing regular Python modules</em></p>&#13;
<p class="indent">Hy also has more advanced constructs and macros. In <a href="ch09.xhtml#ch9list17">Listing 9-17</a>, admire what the <span class="literal">cond()</span> function can do for you instead of the classic but verbose <span class="literal">if</span>/<span class="literal">elif</span>/<span class="literal">else</span>.</p>&#13;
<p class="programs">(cond<br/> [(&gt; somevar 50)<br/>  (print "That variable is too big!")]<br/> [(&lt; somevar 10)<br/>  (print "That variable is too small!")]<br/> [true<br/>  (print "That variable is jusssst right!")])</p>&#13;
<p class="listing1"><a id="ch9list17"/><em>Listing 9-17: Using <span class="codeitalic">cond</span> instead of <span class="codeitalic">if</span>/<span class="codeitalic">elif</span>/<span class="codeitalic">else</span></em></p>&#13;
<p class="indent">The <span class="literal">cond</span> macro has the following signature: <span class="literal">(cond [<span class="codeitalic">condition_expression return_expression</span>] ...)</span>. Each condition expression is evaluated, starting with the first: as soon as one of the condition expressions returns a true value, the return expression is evaluated and returned. If no return expression is provided, then the value of the condition expression is returned. Thus, <span class="literal">cond</span> is equivalent to an <span class="literal">if</span>/<span class="literal">elif</span> construct, except that it can return the value of the condition expression without having to evaluate it twice or store it in a temporary variable!</p>&#13;
<p class="indent">Hy allows you to jump into the Lisp world without leaving your comfort zone too far behind you, since you’re still writing Python. The <span class="literal">hy2py</span> tool can even show you what your Hy code would look like once translated into Python. While Hy is not widely used, it is a great tool to show the potential of the Python language. If you’re interested in learning more, I suggest you check out the online documentation and join the community.</p>&#13;
<h3 class="h3" id="lev1sec49"><span epub:type="pagebreak" id="page_147"/><strong>Summary</strong></h3>&#13;
<p class="noindent">Just like any other programming language, Python source code can be represented using an abstract tree. You’ll rarely use the AST directly, but when you understand how it works, it can provide a helpful perspective.</p>&#13;
<h3 class="h3" id="lev1sec50"><strong>Paul Tagliamonte on the AST and Hy</strong></h3>&#13;
<p class="noindent">Paul created Hy in 2013, and, as a Lisp lover, I joined him in this fabulous adventure. Paul is currently a developer at Sunlight Foundation.</p>&#13;
<p class="noindentt"><strong>How did you learn to use the AST correctly, and do you have any advice for people looking at it?</strong></p>&#13;
<p class="noindent">The AST is extremely underdocumented, so most knowledge comes from generated ASTs that have been reverse engineered. By writing up simple Python scripts, one can use something similar to <span class="literal">import ast; ast.dump(ast.parse("print foo"))</span> to generate an equivalent AST to help with the task. With a bit of guesswork, and some persistence, it’s not untenable to build up a basic understanding this way.</p>&#13;
<p class="indent">At some point, I’ll take on the task of documenting my understanding of the AST module, but I find writing code is the best way to learn the AST.</p>&#13;
<p class="noindentt"><strong>How does Python’s AST differ between versions and uses?</strong></p>&#13;
<p class="noindent">Python’s AST is not private, but it’s not a public interface either. No stability is guaranteed from version to version—in fact, there are some rather annoying differences between Python 2 and 3 and even within different Python 3 releases. In addition, different implementations may interpret the AST differently or even have a unique AST. Nothing says Jython, PyPy, or CPython must deal with the Python AST in the same way.</p>&#13;
<p class="indent">For instance, CPython can handle slightly out-of-order AST entries (by the <span class="literal">lineno</span> and <span class="literal">col_offset</span>), whereas PyPy will throw an assertion error. Though sometimes annoying, the AST is generally sane. It’s not impossible to build an AST that works on a vast number of Python instances. With a conditional or two, it’s only mildly annoying to create an AST that works on CPython 2.6 through 3.3 and PyPy, making this tool quite handy.</p>&#13;
<p class="noindentt"><strong>What was your process in creating Hy?</strong></p>&#13;
<p class="noindent">I started on Hy following a conversation about how useful it would be to have a Lisp that compiles to Python rather than Java’s JVM (Clojure). A few short days later, and I had the first version of Hy. This version resembled a Lisp and even worked like a proper Lisp in some ways, but it was slow. I mean, really slow. It was about an order of magnitude slower than native Python, since the Lisp runtime itself was implemented in Python.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_148"/>Frustrated, I almost gave up, but then a coworker suggested using the AST to implement the runtime, rather than implementing the runtime in Python. This suggestion was the catalyst for the entire project. I spent my entire holiday break in 2012 hacking on Hy. A week or so later, I had something that resembled the current Hy codebase.</p>&#13;
<p class="indent">Just after getting enough of Hy working to implement a basic Flask app, I gave a talk at Boston Python about the project, and the reception was incredibly warm—so warm, in fact, that I start to view Hy as a good way to teach people about Python internals, such as how the REPL works, PEP 302 import hooks, and the Python AST. This was a good introduction to the concept of code that writes code.</p>&#13;
<p class="indent">I rewrote chunks of the compiler to fix some philosophical issues in the process, leading us to the current iteration of the codebase—which has stood up quite well!</p>&#13;
<p class="indent">Learning Hy is also a good way to begin understanding how to read Lisp. Users can get comfortable with s-expressions in an environment they know and even use libraries they’re already using, easing the transition to other Lisps, such as Common Lisp, Scheme, or Clojure.</p>&#13;
<p class="noindentt"><strong>How interoperable with Python is Hy?</strong></p>&#13;
<p class="noindent">Hy is amazingly interoperable. So much so that <span class="literal">pdb</span> can properly debug Hy without you having to make any changes at all. I’ve written Flask apps, Django apps, and modules of all sorts with Hy. Python can import Python, Hy can import Hy, Hy can import Python, and Python can import Hy. This is what really makes Hy unique; other Lisp variants like Clojure are purely unidirectional. Clojure can import Java, but Java has one hell of a time importing Clojure.</p>&#13;
<p class="indent">Hy works by translating Hy code (in s-expressions) into the Python AST almost directly. This compilation step means the generated bytecode is fairly sane stuff, which means Python has a very hard time of even telling the module isn’t written in Python at all.</p>&#13;
<p class="indent">Common Lisp-isms, such as <span class="literal">*earmuffs*</span> or <span class="literal">using-dashes</span> are fully supported by translating them into a Python equivalent (in this case, <span class="literal">*earmuffs*</span> becomes <span class="literal">EARMUFFS</span>, and <span class="literal">using-dashes</span> becomes <span class="literal">using_dashes</span>), which means Python doesn’t have a hard time using them at all.</p>&#13;
<p class="indent">Ensuring that we have really good interoperability is one of our highest priorities, so if you see any bugs—file them!</p>&#13;
<p class="noindentt"><strong>What are the advantages and disadvantages of choosing Hy?</strong></p>&#13;
<p class="noindent">One advantage of Hy is that it has a full macro system, which Python struggles with. Macros are special functions that alter the code during the compile step. This makes it easy to create new domain-specific languages, which are composed of the base language (in this case, Hy/Python) along with many macros that allow uniquely expressive and succinct code.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_149"/>As for downsides, Hy, by virtue of being a Lisp written in s-expressions, suffers from the stigma of being hard to learn, read, or maintain. People might be averse to working on projects using Hy for fear of its complexity.</p>&#13;
<p class="indent">Hy is the Lisp everyone loves to hate. Python folks may not enjoy its syntax, and Lispers may avoid it because Hy uses Python objects directly, meaning the behavior of fundamental objects can sometimes be surprising to the seasoned Lisper.</p>&#13;
<p class="indent">Hopefully people will look past its syntax and consider exploring parts of Python previously untouched.</p>&#13;
</body></html>