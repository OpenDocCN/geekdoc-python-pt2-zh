<html><head></head><body>
<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_135"/><strong><span class="big">9</span></strong><br/><strong>THE ABSTRACT SYNTAX TREE, HY, AND LISP-LIKE ATTRIBUTES</strong></h2>&#13;
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>&#13;
<p class="noindent">The <em>abstract syntax tree (AST)</em> is a representation of the structure of the source code of any programming language. Every language, including Python, has a specific AST; Python’s AST is built by parsing a Python source file. Like any tree, this one is made of nodes linked together. A node can represent an operation, a statement, an expression, or even a module. Each node can contain references to other nodes that make up the tree.</p>&#13;
<p class="indent">Python’s AST is not heavily documented and is thus hard to deal with at first glance, but understanding some deeper aspects of how Python is constructed can help you master its usage.</p>&#13;
<p class="indent">This chapter will examine the AST of some simple Python commands to get you familiar with the structure and how it’s used. Once you’re familiar <span epub:type="pagebreak" id="page_136"/>with the AST, we’ll build a program that can check for wrongly declared methods using <code>flake8</code> and the AST. Finally, we’ll look at Hy, a Python-Lisp hybrid language built on the Python AST.</p>&#13;
<h3 class="h3" id="lev1sec46"><strong>Looking at the AST</strong></h3>&#13;
<p class="noindent">The easiest way to view the Python AST is to parse some Python code and dump the generated AST. For that, the Python <code>ast</code> module provides everything you need, as shown in <a href="ch09.xhtml#ch9list1">Listing 9-1</a>.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">import ast</span><br/>&gt;&gt;&gt; <span class="codestrong1">ast.parse</span><br/>&lt;function parse at 0x7f062731d950&gt;<br/>&gt;&gt;&gt; <span class="codestrong1">ast.parse("x = 42")</span><br/>&lt;_ast.Module object at 0x7f0628a5ad10&gt;<br/>&gt;&gt;&gt; <span class="codestrong1">ast.dump(ast.parse("x = 42"))</span><br/>"Module(body=[Assign(targets=[Name(id='x', ctx=Store())], value=Num(n=42))])"</pre>&#13;
<p class="listing1"><a id="ch9list1"/><em>Listing 9-1: Using the <span class="codeitalic">ast</span> module to dump the AST generated by parsing code</em></p>&#13;
<p class="indent">The <code>ast.parse()</code> function parses any string that contains Python code and returns an <code>_ast.Module</code> object. That object is actually the root of the tree: you can browse it to discover every node making up the tree. To visualize what the tree looks like, you can use the <code>ast.dump()</code> function, which will return a string representation of the whole tree.</p>&#13;
<p class="indent">In <a href="ch09.xhtml#ch9list1">Listing 9-1</a>, the code <code>x = 42</code> is parsed with <code>ast.parse()</code>, and the result is printed using <code>ast.dump()</code>. This abstract syntax tree can be rendered as shown in <a href="ch09.xhtml#ch9fig1">Figure 9-1</a>, which shows the structure of the Python <code>assign</code> command.</p>&#13;
<div class="image"><a id="ch9fig1"/><img alt="image" src="../images/f09-01.jpg"/></div>&#13;
<p class="figcap"><em>Figure 9-1: The AST of the <span class="codeitalic">assign</span> command in Python</em></p>&#13;
<p class="indent">The AST always starts with a root element, which is usually an _<code>ast.Module</code> object. This module object contains a list of statements or expressions to evaluate in its <em>body</em> attribute and usually represents the content of a file.</p>&#13;
<p class="indent">As you can probably guess, the <code>ast.Assign</code> object shown in <a href="ch09.xhtml#ch9fig1">Figure 9-1</a> represents an <em>assignment</em>, which is mapped to the <code>=</code> sign in the Python syntax. An <code>ast.Assign</code> object has a list of <em>targets</em> and a <em>value</em> to set the targets to. <span epub:type="pagebreak" id="page_137"/>The list of targets in this case consists of one object, <code>ast.Name</code>, which represents a variable whose ID is <em>x</em>. The value is a number <em>n</em> with a value (in this case) 42. The ctx attribute stores a <em>context</em>, either <code>ast.Store</code> or <code>ast.Load</code>, depending on whether the variable is being used for reading or writing. In this case, the variable is being assigned a value, so an <code>ast.Store</code> context is used.</p>&#13;
<p class="indent">We could pass this AST to Python to be compiled and evaluated via the built-in <code>compile()</code> function. This function takes an AST as argument, the source filename, and a mode (either <code>'exec'</code>, <code>'eval'</code>, or <code>'single'</code>). The source filename can be any name that you want your AST to appear to be from; it is common to use the string <code>&lt;input&gt;</code> as the source filename if the data does not come from a stored file, as shown in <a href="ch09.xhtml#ch9list2">Listing 9-2</a>.</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">compile(ast.parse("x = 42"), '&lt;input&gt;', 'exec')</span><br/>&lt;code object &lt;module&gt; at 0x111b3b0, file "&lt;input&gt;", line 1&gt;<br/>&gt;&gt;&gt; <span class="codestrong1">eval(compile(ast.parse("x = 42"), '&lt;input&gt;', 'exec'))</span><br/>&gt;&gt;&gt; <span class="codestrong1">x</span><br/>42</pre>&#13;
<p class="listing1"><a id="ch9list2"/><em>Listing 9-2: Using the <span class="codeitalic">compile()</span> function to compile data that is not from a stored file</em></p>&#13;
<p class="indent">The modes stand for execute (<code>exec</code>), evaluate (<code>eval</code>), and single statement (<code>single</code>). The mode should match what has been given to <code>ast.parse()</code>, whose default is <code>exec</code>.</p>&#13;
<ul>&#13;
<li><p class="noindent">The <code>exec</code> mode is the normal Python mode, used when an _<code>ast.Module</code> is the root of the tree.</p></li>&#13;
<li><p class="noindent">The <code>eval</code> mode is a special mode that expects a single <code>ast.Expression</code> as the tree.</p></li>&#13;
<li><p class="noindent">Finally, <code>single</code> is another special mode that expects a single statement or expression. If it gets an expression, <code>sys.displayhook()</code> will be called with the result, as when code is run in the interactive shell.</p></li>&#13;
</ul>&#13;
<p class="indent">The root of the AST is <code>ast.Interactive</code>, and its <code>body</code> attribute is a list of nodes.</p>&#13;
<p class="indent">We could build an AST manually using the classes provided in the <code>ast</code> module. Obviously, this is a very long way to write Python code and not a method I would recommend! Nonetheless, it’s fun to do and helpful for learning about the AST. Let’s see what programming with the AST would look like.</p>&#13;
<h4 class="h4" id="lev2sec51"><strong><em>Writing a Program Using the AST</em></strong></h4>&#13;
<p class="noindent">Let’s write a good old <code>"Hello world!"</code> program in Python by building an abstract syntax tree manually.</p>&#13;
<pre><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong1">hello_world = ast.Str(s='hello world!', lineno=1, col_offset=1)</span><br/><span class="ent">➋</span> &gt;&gt;&gt; <span class="codestrong1">print_name = ast.Name(id='print', ctx=ast.Load(), lineno=1, col_offset=1)</span><br/><span class="ent">➌</span> &gt;&gt;&gt; <span class="codestrong1">print_call = ast.Call(func=print_name, ctx=ast.Load(),</span><br/>   <span class="codestrong1">... args=[hello_world], keywords=[], lineno=1, col_offset=1)</span><br/><span class="ent">➍</span> &gt;&gt;&gt; <span class="codestrong1">module = ast.Module(body=[ast.Expr(print_call,</span><span epub:type="pagebreak" id="page_138"/><br/>   <span class="codestrong1">... lineno=1, col_offset=1)], lineno=1, col_offset=1)</span><br/><span class="ent">➎</span> &gt;&gt;&gt; <span class="codestrong1">code = compile(module, '', 'exec')</span><br/>   &gt;&gt;&gt; <span class="codestrong1">eval(code)</span><br/>   hello world!</pre>&#13;
<p class="listing1"><a id="ch9list3"/><em>Listing 9-3: Writing <span class="codeitalic">hello world!</span> using the AST</em></p>&#13;
<p class="indent">In <a href="ch09.xhtml#ch9list3">Listing 9-3</a>, we build the tree one leaf at a time, where each leaf is an element (whether a value or an instruction) of the program.</p>&#13;
<p class="indent">The first leaf is a simple string <span class="ent">➊</span>: the <code>ast.Str</code> represents a literal string, which here contains the <code>hello world!</code> text. The <code>print_name</code> variable <span class="ent">➋</span> contains an <code>ast.Name</code> object, which refers to a variable—in this case, the <code>print</code> variable that points to the <code>print()</code> function.</p>&#13;
<p class="indent">The <code>print_call</code> variable <span class="ent">➌</span> contains a function call. It refers to the function name to call, the regular arguments to pass to the function call, and the keyword arguments. Which arguments are used depend on the functions being called. In this case, since it’s the <code>print()</code> function, we’ll pass the string we made and stored in <code>hello_world</code>.</p>&#13;
<p class="indent">At last, we create an _<code>ast.Module</code> object <span class="ent">➍</span> to contain all this code as a list of one expression. We can compile _<code>ast.Module</code> objects using the <code>compile()</code> function <span class="ent">➎</span>, which parses the tree and generates a native <code>code</code> object. These <code>code</code> objects are compiled Python code and can finally be executed by a Python virtual machine using <code>eval</code>!</p>&#13;
<p class="indent">This whole process is exactly what happens when you run Python on a <em>.py</em> file: once the text tokens are parsed, they are converted into a tree of <code>ast</code> objects, compiled, and evaluated.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The arguments <span class="codeitalic">lineno</span> and <span class="codeitalic">col_offset</span> represent the line number and column offset, respectively, of the source code that has been used to generate the AST. It doesn’t make much sense to set these values in this context since we are not parsing a source file, but it can be useful to be able to find the position of the code that generated the AST. For example, Python uses this information when generating backtraces. Indeed, Python refuses to compile an AST object that doesn’t provide this information, so we pass fake values to these. You could also use the <span class="codeitalic">ast.fix_missing_locations()</span> function to set the missing values to the ones set on the parent node.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="lev2sec52"><strong><em>The AST Objects</em></strong></h4>&#13;
<p class="noindent">You can view the whole list of objects available in the AST by reading the <code>_ast</code> module documentation (note the underscore).</p>&#13;
<p class="indent">The objects are organized into two main categories: statements and expressions. <em>Statements</em> include types such as <code>assert</code>, assignment (<code>=</code>), augmented assignment (<code>+=</code>, <code>/=</code>, etc.), <code>global</code>, <code>def</code>, <code>if</code>, <code>return</code>, <code>for</code>, <code>class</code>, <code>pass</code>, <code>import</code>, <code>raise</code>, and so forth. Statements inherit from <code>ast.stmt</code>; they influence the control flow of a program and are often composed of expressions.</p>&#13;
<p class="indent"><em>Expressions</em> include types such as <code>lambda</code>, <code>number</code>, <code>yield</code>, <code>name</code> (variable), <code>compare</code>, and <code>call</code>. Expressions inherit from <code>ast.expr</code>; they differ from statements in that they usually produce a value and have no impact on the program flow.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_139"/>There are also a few smaller categories, such as the <code>ast.operator</code> class, which defines standard operators such as <em>add</em> (<code>+</code>), <em>div</em> (<code>/</code>), and <em>right shift</em> (<code>&gt;&gt;</code>), and the <code>ast.cmpop</code> module, which defines comparisons operators.</p>&#13;
<p class="indent">The simple example here should give you an idea of how to build an AST from scratch. It’s easy to then imagine how you might leverage this AST to construct a compiler that would parse strings and generate code, allowing you to implement your own syntax to Python! This is exactly what led to the development of the Hy project, which we’ll discuss later in this chapter.</p>&#13;
<h4 class="h4" id="lev2sec53"><strong><em>Walking Through an AST</em></strong></h4>&#13;
<p class="noindent">To follow how a tree is built or access particular nodes, you sometimes need to walk through your tree, browsing it and iterating over the nodes. You can do this with the <code>ast.walk()</code> function. Alternatively, the <code>ast</code> module also provides <code>NodeTransformer</code>, a class that you can subclass to walk through an AST and modify particular nodes. Using <code>NodeTransformer</code> makes it easy to change code dynamically, as shown in <a href="ch09.xhtml#ch9list4">Listing 9-4</a>.</p>&#13;
<pre>   import ast<br/><br/>   class ReplaceBinOp(ast.NodeTransformer):<br/>       """Replace operation by addition in binary operation"""<br/>       def visit_BinOp(self, node):<br/>           return ast.BinOp(left=node.left,<br/>                            op=ast.Add(),<br/>                            right=node.right)<br/><br/><span class="ent">➊</span> tree = ast.parse("x = 1/3")<br/>   ast.fix_missing_locations(tree)<br/>   eval(compile(tree, '', 'exec'))<br/>   print(ast.dump(tree))<br/><span class="ent">➋</span> print(x)<br/><br/><span class="ent">➌</span> tree = ReplaceBinOp().visit(tree)<br/>   ast.fix_missing_locations(tree)<br/>   print(ast.dump(tree))<br/>   eval(compile(tree, '', 'exec'))<br/><span class="ent">➍</span> print(x)</pre>&#13;
<p class="listing1"><a id="ch9list4"/><em>Listing 9-4: Walking a tree with <span class="codeitalic">NodeTransformer</span> to alter a node</em></p>&#13;
<p class="indent">The first <code>tree</code> object built <span class="ent">➊</span> is an AST that represents the expression <code>x = 1/3</code>. Once this is compiled and evaluated, the result of printing <code>x</code> at the end of the function <span class="ent">➋</span> is <code>0.33333</code>, the expected result of <code>1/3</code>.</p>&#13;
<p class="indent">The second <code>tree</code> object <span class="ent">➌</span> is an instance of <code>ReplaceBinOp</code>, which inherits from <code>ast.NodeTransformer</code>. It implements its own version of the <code>ast.NodeTransformer.visit()</code> method and changes any <code>ast.BinOp</code> operation to an <code>ast.BinOp</code> that executes <code>ast.Add</code>. Concretely, this changes any binary operator (<code>+</code>, <code>-</code>, <code>/</code>, and so on) to the <code>+</code> operator. When this second tree is compiled and evaluated <span class="ent">➍</span>, the result is now <code>4</code>, which is the result of <code>1 + 3</code>, because the <code>/</code> in the first object is replaced with <code>+</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_140"/>You can see the execution of the program here:</p>&#13;
<pre>Module(body=[Assign(targets=[Name(id='x', ctx=Store())],<br/>                    value=BinOp(left=Num(n=1), op=Div(), right=Num(n=3)))])<br/>0.3333333333333333<br/>Module(body=[Assign(targets=[Name(id='x', ctx=Store())],<br/>                    value=BinOp(left=Num(n=1), op=Add(), right=Num(n=3)))])<br/>4</pre>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you need to evaluate a string that should return a simple data type, you can use <span class="codeitalic">ast.literal_eval</span>. As a safer alternative to <span class="codeitalic">eval</span>, it prevents the input string from executing any code.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="lev1sec47"><strong>Extending flake8 with AST Checks</strong></h3>&#13;
<p class="noindent">In <a href="ch07.xhtml#ch07">Chapter 7</a>, you learned that methods that do not rely on the object state should be declared static with the <code>@staticmethod</code> decorator. The problem is that a lot of developers simply forget to do so. I’ve personally spent too much time reviewing code and asking people to fix this problem.</p>&#13;
<p class="indent">We’ve seen how to use <code>flake8</code> to do some automatic checking in the code. In fact, <code>flake8</code> is extensible and can provide even more checks. We’ll write a <code>flake8</code> extension that checks for static method declaration omission by analyzing the AST.</p>&#13;
<p class="indent"><a href="ch09.xhtml#ch9list5">Listing 9-5</a> shows an example of one class that omits the static declaration and one that correctly includes it. Write this program out and save it as <em>ast_ext.py</em>; we’ll use it in a moment to write our extension.</p>&#13;
<pre>class Bad(object):<br/>    # self is not used, the method does not need<br/>    # to be bound, it should be declared static<br/>    def foo(self, a, b, c):<br/>        return a + b - c<br/><br/>class OK(object):<br/>    # This is correct<br/>    @staticmethod<br/>    def foo(a, b, c):<br/>        return a + b - c</pre>&#13;
<p class="listing1"><a id="ch9list5"/><em>Listing 9-5: Omitting and including <span class="codeitalic">@staticmethod</span></em></p>&#13;
<p class="indent">Though the <code>Bad.foo</code> method works fine, strictly speaking it is more correct to write it as <code>OK.foo</code> (turn back to <a href="ch07.xhtml#ch07">Chapter 7</a> for more detail on why). To check whether all the methods in a Python file are correctly declared, we need to do the following:</p>&#13;
<ul>&#13;
<li><p class="noindent">Iterate over all the statement nodes of the AST.</p></li>&#13;
<li><p class="noindent">Check that the statement is a class definition (<code>ast.ClassDef</code>).</p></li>&#13;
<li><p class="noindent"><span epub:type="pagebreak" id="page_141"/>Iterate over all the function definitions (<code>ast.FunctionDef</code>) of that class statement to check whether it is already declared with <code>@staticmethod</code>.</p></li>&#13;
<li><p class="noindent">If the method is not declared static, check whether the first argument (<code>self</code>) is used somewhere in the method. If <code>self</code> is not used, the method can be tagged as potentially miswritten.</p></li>&#13;
</ul>&#13;
<p class="indent">The name of our project will be <code>ast_ext</code>. To register a new plugin in <code>flake8</code>, we need to create a packaged project with the usual <em>setup.py</em> and <em>setup.cfg</em> files. Then, we just need to add an entry point in the <em>setup.cfg</em> of our <code>ast_ext</code> project.</p>&#13;
<pre>[entry_points]<br/>flake8.extension =<br/>    --<span class="codeitalic1">snip</span>--<br/>    H904 = ast_ext:StaticmethodChecker<br/>    H905 = ast_ext:StaticmethodChecker</pre>&#13;
<p class="listing1"><a id="ch9list6"/><em>Listing 9-6: Allowing <span class="codeitalic">flake8</span> plugins for our chapter</em></p>&#13;
<p class="indent">In <a href="ch09.xhtml#ch9list6">Listing 9-6</a>, we also register two <code>flake8</code> error codes. As you’ll notice later, we are actually going to add an extra check to our code while we’re at it!</p>&#13;
<p class="indent">The next step is to write the plugin.</p>&#13;
<h4 class="h4" id="lev2sec54"><strong><em>Writing the Class</em></strong></h4>&#13;
<p class="noindent">Since we are writing a <code>flake8</code> check of the AST, the plugin needs to be a class following a certain signature, as shown in <a href="ch09.xhtml#ch9list7">Listing 9-7</a>.</p>&#13;
<pre>class StaticmethodChecker(object):<br/>    def __init__(self, tree, filename):<br/>        self.tree = tree<br/><br/>    def run(self):<br/>        pass</pre>&#13;
<p class="listing1"><a id="ch9list7"/><em>Listing 9-7: The class for checking the AST</em></p>&#13;
<p class="indent">The default template is easy to understand: it stores the tree locally for use in the <code>run()</code> method, which will <em>yield</em> the problems that are discovered. The value that will be yielded must follow the expected PEP 8 signature: a tuple of the form <code>(<span class="codeitalic">lineno</code>, <span class="codeitalic">col_offset</span>, <span class="codeitalic">error_string</span>, <span class="codeitalic">code</span>)</span>.</p>&#13;
<h4 class="h4" id="lev2sec55"><strong><em>Ignoring Irrelevant Code</em></strong></h4>&#13;
<p class="noindent">As indicated earlier, the <code>ast</code> module provides the <code>walk()</code> function, which allows you to iterate easily on a tree. We’ll use that to walk through the AST and find out what to check and what not to check.</p>&#13;
<p class="indent">First, let’s write a loop that ignores the statements that are not class definitions. Add this to your <code>ast_ext</code> project, as shown in <a href="ch09.xhtml#ch9list8">Listing 9-8</a>; code that should stay the same is grayed out.</p>&#13;
<pre><span epub:type="pagebreak" id="page_142"/><span class="ash">class StaticmethodChecker(object):</span><br/>    <span class="ash">def __init__(self, tree, filename):</span><br/>        <span class="ash">self.tree = tree</span><br/><br/>    <span class="ash">def run(self):</span><br/>        for stmt in ast.walk(self.tree):<br/>            # Ignore non-class<br/>            if not isinstance(stmt, ast.ClassDef):<br/>                continue</pre>&#13;
<p class="listing1"><a id="ch9list8"/><em>Listing 9-8: Ignoring statements that are not class definitions</em></p>&#13;
<p class="indent">The code in <a href="ch09.xhtml#ch9list8">Listing 9-8</a> is still not checking for anything, but now it knows how to ignore statements that are not class definitions. The next step is to set our checker to ignore anything that is not a function definition.</p>&#13;
<pre><span class="ash">for stmt in ast.walk(self.tree):</span><br/>    <span class="ash"># Ignore non-class</span><br/>    <span class="ash">if not isinstance(stmt, ast.ClassDef):</span><br/>        <span class="ash">continue</span><br/>    # If it's a class, iterate over its body member to find methods<br/>    for body_item in stmt.body:<br/>        # Not a method, skip<br/>        if not isinstance(body_item, ast.FunctionDef):<br/>            continue</pre>&#13;
<p class="listing1"><a id="ch9list9"/><em>Listing 9-9: Ignoring statements that are not function definitions</em></p>&#13;
<p class="indent">In <a href="ch09.xhtml#ch9list9">Listing 9-9</a>, we ignore irrelevant statements by iterating over the attributes of the class definition.</p>&#13;
<h4 class="h4" id="lev2sec56"><strong><em>Checking for the Correct Decorator</em></strong></h4>&#13;
<p class="noindent">We’re all set to write the checking method, which is stored in the <code>body_item</code> attribute. First, we need to check whether the method that’s being checked is already declared as static. If it is, we don’t have to do any further checking and can bail out.</p>&#13;
<pre><span class="ash">for stmt in ast.walk(self.tree):</span><br/>    <span class="ash"># Ignore non-class</span><br/>    <span class="ash">if not isinstance(stmt, ast.ClassDef):</span><br/>        <span class="ash">continue</span><br/>    <span class="ash"># If it's a class, iterate over its body member to find methods</span><br/>    <span class="ash">for body_item in stmt.body:</span><br/>        <span class="ash"># Not a method, skip</span><br/>        <span class="ash">if not isinstance(body_item, ast.FunctionDef):</span><br/>            <span class="ash">continue</span><br/>        # Check that it has a decorator<br/>        for decorator in body_item.decorator_list:<br/>            if (isinstance(decorator, ast.Name)<br/>               and decorator.id == 'staticmethod'):<br/>                # It's a static function, it's OK<br/>                break<span epub:type="pagebreak" id="page_143"/><br/>        else:<br/>            # Function is not static, we do nothing for now<br/>            Pass</pre>&#13;
<p class="listing1"><a id="ch9list10"/><em>Listing 9-10: Checking for the static decorator</em></p>&#13;
<p class="indent">Note that in <a href="ch09.xhtml#ch9list10">Listing 9-10</a>, we use the special <code>for/else</code> form of Python, where the <code>else</code> is evaluated unless we use <code>break</code> to exit the <code>for</code> loop. At this point, we’re able to detect whether a method is declared static.</p>&#13;
<h4 class="h4" id="lev2sec57"><strong><em>Looking for self</em></strong></h4>&#13;
<p class="noindent">The next step is to check whether the method that <em>isn’t</em> declared as static uses the <code>self</code> argument. First, check whether the method includes any arguments at all, as shown in <a href="ch09.xhtml#ch9list11">Listing 9-11</a>.</p>&#13;
<pre><span class="ash"><span class="codeitalic1">--snip--</span></span><br/>        <span class="ash"># Check that it has a decorator</span><br/>        <span class="ash">for decorator in body_item.decorator_list:</span><br/>            <span class="ash">if (isinstance(decorator, ast.Name)</span><br/>               <span class="ash">and decorator.id == 'staticmethod'):</span><br/>                <span class="ash"># It's a static function, it's OK</span><br/>                <span class="ash">break</span><br/>        <span class="ash">else:</span><br/>            try:<br/>                first_arg = body_item.args.args[0]<br/>            except IndexError:<br/>                yield (<br/>                    body_item.lineno,<br/>                    body_item.col_offset,<br/>                    "H905: method misses first argument",<br/>                    "H905",<br/>                )<br/>                # Check next method<br/>                Continue</pre>&#13;
<p class="listing1"><a id="ch9list11"/><em>Listing 9-11: Checking the method for arguments</em></p>&#13;
<p class="indent">We finally added a check! This <code>try</code> statement in <a href="ch09.xhtml#ch9list11">Listing 9-11</a> grabs the first argument from the method signature. If the code fails to retrieve the first argument from the signature because a first argument doesn’t exist, we already know there’s a problem: you can’t have a bound method without the <code>self</code> argument. If the plugin detects that case, it raises the <code>H905</code> error code we set earlier, signaling a method that misses its first argument.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>PEP 8 codes follow a particular format for error codes (a letter followed by a number), but there are no rules as to which code to pick. You could come up with any other code for this error, as long as it’s not already used by PEP 8 or another extension.</em></p>&#13;
</div>&#13;
<p class="indent">Now you know why we registered two error codes in <em>setup.cfg</em>: we had a good opportunity to kill two birds with one stone.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_144"/>The next step is to check whether the <code>self</code> argument is used in the code of the method.</p>&#13;
<pre><span class="ash"><span class="codeitalic1">--snip--</span></span><br/>            <span class="ash">try:</span><br/>                <span class="ash">first_arg = body_item.args.args[0]</span><br/>            <span class="ash">except IndexError:</span><br/>                <span class="ash">yield (</span><br/>                    <span class="ash">body_item.lineno,</span><br/>                    <span class="ash">body_item.col_offset,</span><br/>                    <span class="ash">"H905: method misses first argument",</span><br/>                    <span class="ash">"H905",</span><br/>                <span class="ash">)</span><br/>                <span class="ash"># Check next method</span><br/>                <span class="ash">continue</span><br/>            for func_stmt in ast.walk(body_item):<br/>                # The checking method must differ between Python 2 and Python 3<br/>                if six.PY3:<br/>                    if (isinstance(func_stmt, ast.Name)<br/>                       and first_arg.arg == func_stmt.id):<br/>                        # The first argument is used, it's OK<br/>                        break<br/>                else:<br/>                    if (func_stmt != first_arg<br/>                       and isinstance(func_stmt, ast.Name)<br/>                       and func_stmt.id == first_arg.id):<br/>                        # The first argument is used, it's OK<br/>                        break<br/>            else:<br/>                yield (<br/>                    body_item.lineno,<br/>                    body_item.col_offset,<br/>                    "H904: method should be declared static",<br/>                    "H904",<br/>                )</pre>&#13;
<p class="listing1"><a id="ch9list12"/><em>Listing 9-12: Checking the method for the <span class="codeitalic">self</span> argument</em></p>&#13;
<p class="indent">To check whether the <code>self</code> argument is used in the method’s body, the plugin in <a href="ch09.xhtml#ch9list12">Listing 9-12</a> iterates recursively, using <code>ast.walk</code> on the body and looking for the use of the variable named <code>self</code>. If the variable isn’t found, the program finally yields the <code>H904</code> error code. Otherwise, nothing happens, and the code is considered sane.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>As you may have noticed, the code walks over the module AST definition several times. There might be some degree of optimization to browsing the AST in only one pass, but I’m not sure it’s worth it, given how the tool is actually used. I’ll leave that exercise to you, dear reader.</em></p>&#13;
</div>&#13;
<p class="indent">Knowing the Python AST is not strictly necessary for using Python, but it does give powerful insight into how the language is built and how it works. It thus gives you a better understanding of how the code you write is being used under the hood.</p>&#13;
<h3 class="h3" id="lev1sec48"><span epub:type="pagebreak" id="page_145"/><strong>A Quick Introduction to Hy</strong></h3>&#13;
<p class="noindent">Now that you have a good understanding of how Python AST works, you can start dreaming of creating a new syntax for Python. You could parse this new syntax, build an AST out of it, and compile it down to Python code.</p>&#13;
<p class="indent">This is exactly what Hy does. <em>Hy</em> is a Lisp dialect that parses a Lisp-like language and converts it to regular Python AST, making it fully compatible with the Python ecosystem. You could compare it to what Clojure is to Java. Hy could fill a book by itself, so we will only skim over it. Hy uses the syntax and some features of the Lisp family of languages: it’s functionally oriented, provides macros, and is easily extensible.</p>&#13;
<p class="indent">If you’re not already familiar with Lisp—and you should be—the Hy syntax will look familiar. Once you install Hy (by running <code>pip install hy</code>), launching the <code>hy</code> interpreter will give you a standard REPL prompt from which you can start to interact with the interpreter, as shown in <a href="ch09.xhtml#ch9list13">Listing 9-13</a>.</p>&#13;
<pre>% <span class="codestrong1">hy</span><br/>hy 0.9.10<br/>=&gt; <span class="codestrong1">(+ 1 2)</span><br/>3</pre>&#13;
<p class="listing1"><a id="ch9list13"/><em>Listing 9-13: Interacting with the Hy interpreter</em></p>&#13;
<p class="indent">For those not familiar with the Lisp syntax, parentheses are used to construct lists. If a list is unquoted, it is evaluated: the first element must be a function, and the rest of the items from the list are passed as arguments. Here the code <code>(+ 1 2)</code> is equivalent to <code>1 + 2</code> in Python.</p>&#13;
<p class="indent">In Hy, most constructs, such as function definitions, are mapped from Python directly.</p>&#13;
<pre>=&gt; <span class="codestrong1">(defn hello [name]</span><br/><span class="codestrong1">...  (print "Hello world!")</span><br/><span class="codestrong1">...  (print (% "Nice to meet you %s" name)))</span><br/>=&gt; <span class="codestrong1">(hello "jd")</span><br/>Hello world!<br/>Nice to meet you jd</pre>&#13;
<p class="listing1"><a id="ch9list14"/><em>Listing 9-14: Mapping a function definition from Python</em></p>&#13;
<p class="indent">As shown in <a href="ch09.xhtml#ch9list14">Listing 9-14</a>, internally Hy parses the code provided, converts it to a Python AST, compiles it, and evaluates it. Fortunately, Lisp is an easy tree to parse: each pair of parentheses represents a node of the tree, meaning the conversion is actually easier than for the native Python syntax!</p>&#13;
<p class="indent">Class definition is supported through the <code>defclass</code> construct, which is inspired by the Common Lisp Object System (CLOS).</p>&#13;
<pre>(defclass A [object]<br/>  [[x 42]<span epub:type="pagebreak" id="page_146"/><br/>   [y (fn [self value]<br/>        (+ self.x value))]])</pre>&#13;
<p class="listing1"><a id="ch9list15"/><em>Listing 9-15: Defining a class with <span class="codeitalic">defclass</span></em></p>&#13;
<p class="indent"><a href="ch09.xhtml#ch9list15">Listing 9-15</a> defines a class named <code>A</code>, which inherits from <code>object</code>, with a class attribute <code>x</code> whose value is 42; then a method <code>y</code> returns the <code>x</code> attribute plus a value passed as argument.</p>&#13;
<p class="indent">What’s really wonderful is that you can import <em>any Python library</em> directly into Hy and use it with no penalty. Use the <code>import()</code> function to import a module, as shown in <a href="ch09.xhtml#ch9list16">Listing 9-16</a>, just as you would with regular Python.</p>&#13;
<pre>=&gt; <span class="codestrong1">(import uuid)</span><br/>=&gt; <span class="codestrong1">(uuid.uuid4)</span><br/>UUID('f823a749-a65a-4a62-b853-2687c69d0e1e')<br/>=&gt; <span class="codestrong1">(str (uuid.uuid4))</span><br/>'4efa60f2-23a4-4fc1-8134-00f5c271f809'</pre>&#13;
<p class="listing1"><a id="ch9list16"/><em>Listing 9-16: Importing regular Python modules</em></p>&#13;
<p class="indent">Hy also has more advanced constructs and macros. In <a href="ch09.xhtml#ch9list17">Listing 9-17</a>, admire what the <code>cond()</code> function can do for you instead of the classic but verbose <code>if</code>/<code>elif</code>/<code>else</code>.</p>&#13;
<pre>(cond<br/> [(&gt; somevar 50)<br/>  (print "That variable is too big!")]<br/> [(&lt; somevar 10)<br/>  (print "That variable is too small!")]<br/> [true<br/>  (print "That variable is jusssst right!")])</pre>&#13;
<p class="listing1"><a id="ch9list17"/><em>Listing 9-17: Using <span class="codeitalic">cond</span> instead of <span class="codeitalic">if</span>/<span class="codeitalic">elif</span>/<span class="codeitalic">else</span></em></p>&#13;
<p class="indent">The <code>cond</code> macro has the following signature: <code>(cond [<span class="codeitalic">condition_expression return_expression</code>] ...)</span>. Each condition expression is evaluated, starting with the first: as soon as one of the condition expressions returns a true value, the return expression is evaluated and returned. If no return expression is provided, then the value of the condition expression is returned. Thus, <code>cond</code> is equivalent to an <code>if</code>/<code>elif</code> construct, except that it can return the value of the condition expression without having to evaluate it twice or store it in a temporary variable!</p>&#13;
<p class="indent">Hy allows you to jump into the Lisp world without leaving your comfort zone too far behind you, since you’re still writing Python. The <code>hy2py</code> tool can even show you what your Hy code would look like once translated into Python. While Hy is not widely used, it is a great tool to show the potential of the Python language. If you’re interested in learning more, I suggest you check out the online documentation and join the community.</p>&#13;
<h3 class="h3" id="lev1sec49"><span epub:type="pagebreak" id="page_147"/><strong>Summary</strong></h3>&#13;
<p class="noindent">Just like any other programming language, Python source code can be represented using an abstract tree. You’ll rarely use the AST directly, but when you understand how it works, it can provide a helpful perspective.</p>&#13;
<h3 class="h3" id="lev1sec50"><strong>Paul Tagliamonte on the AST and Hy</strong></h3>&#13;
<p class="noindent">Paul created Hy in 2013, and, as a Lisp lover, I joined him in this fabulous adventure. Paul is currently a developer at Sunlight Foundation.</p>&#13;
<p class="noindentt"><strong>How did you learn to use the AST correctly, and do you have any advice for people looking at it?</strong></p>&#13;
<p class="noindent">The AST is extremely underdocumented, so most knowledge comes from generated ASTs that have been reverse engineered. By writing up simple Python scripts, one can use something similar to <code>import ast; ast.dump(ast.parse("print foo"))</code> to generate an equivalent AST to help with the task. With a bit of guesswork, and some persistence, it’s not untenable to build up a basic understanding this way.</p>&#13;
<p class="indent">At some point, I’ll take on the task of documenting my understanding of the AST module, but I find writing code is the best way to learn the AST.</p>&#13;
<p class="noindentt"><strong>How does Python’s AST differ between versions and uses?</strong></p>&#13;
<p class="noindent">Python’s AST is not private, but it’s not a public interface either. No stability is guaranteed from version to version—in fact, there are some rather annoying differences between Python 2 and 3 and even within different Python 3 releases. In addition, different implementations may interpret the AST differently or even have a unique AST. Nothing says Jython, PyPy, or CPython must deal with the Python AST in the same way.</p>&#13;
<p class="indent">For instance, CPython can handle slightly out-of-order AST entries (by the <code>lineno</code> and <code>col_offset</code>), whereas PyPy will throw an assertion error. Though sometimes annoying, the AST is generally sane. It’s not impossible to build an AST that works on a vast number of Python instances. With a conditional or two, it’s only mildly annoying to create an AST that works on CPython 2.6 through 3.3 and PyPy, making this tool quite handy.</p>&#13;
<p class="noindentt"><strong>What was your process in creating Hy?</strong></p>&#13;
<p class="noindent">I started on Hy following a conversation about how useful it would be to have a Lisp that compiles to Python rather than Java’s JVM (Clojure). A few short days later, and I had the first version of Hy. This version resembled a Lisp and even worked like a proper Lisp in some ways, but it was slow. I mean, really slow. It was about an order of magnitude slower than native Python, since the Lisp runtime itself was implemented in Python.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_148"/>Frustrated, I almost gave up, but then a coworker suggested using the AST to implement the runtime, rather than implementing the runtime in Python. This suggestion was the catalyst for the entire project. I spent my entire holiday break in 2012 hacking on Hy. A week or so later, I had something that resembled the current Hy codebase.</p>&#13;
<p class="indent">Just after getting enough of Hy working to implement a basic Flask app, I gave a talk at Boston Python about the project, and the reception was incredibly warm—so warm, in fact, that I start to view Hy as a good way to teach people about Python internals, such as how the REPL works, PEP 302 import hooks, and the Python AST. This was a good introduction to the concept of code that writes code.</p>&#13;
<p class="indent">I rewrote chunks of the compiler to fix some philosophical issues in the process, leading us to the current iteration of the codebase—which has stood up quite well!</p>&#13;
<p class="indent">Learning Hy is also a good way to begin understanding how to read Lisp. Users can get comfortable with s-expressions in an environment they know and even use libraries they’re already using, easing the transition to other Lisps, such as Common Lisp, Scheme, or Clojure.</p>&#13;
<p class="noindentt"><strong>How interoperable with Python is Hy?</strong></p>&#13;
<p class="noindent">Hy is amazingly interoperable. So much so that <code>pdb</code> can properly debug Hy without you having to make any changes at all. I’ve written Flask apps, Django apps, and modules of all sorts with Hy. Python can import Python, Hy can import Hy, Hy can import Python, and Python can import Hy. This is what really makes Hy unique; other Lisp variants like Clojure are purely unidirectional. Clojure can import Java, but Java has one hell of a time importing Clojure.</p>&#13;
<p class="indent">Hy works by translating Hy code (in s-expressions) into the Python AST almost directly. This compilation step means the generated bytecode is fairly sane stuff, which means Python has a very hard time of even telling the module isn’t written in Python at all.</p>&#13;
<p class="indent">Common Lisp-isms, such as <code>*earmuffs*</code> or <code>using-dashes</code> are fully supported by translating them into a Python equivalent (in this case, <code>*earmuffs*</code> becomes <code>EARMUFFS</code>, and <code>using-dashes</code> becomes <code>using_dashes</code>), which means Python doesn’t have a hard time using them at all.</p>&#13;
<p class="indent">Ensuring that we have really good interoperability is one of our highest priorities, so if you see any bugs—file them!</p>&#13;
<p class="noindentt"><strong>What are the advantages and disadvantages of choosing Hy?</strong></p>&#13;
<p class="noindent">One advantage of Hy is that it has a full macro system, which Python struggles with. Macros are special functions that alter the code during the compile step. This makes it easy to create new domain-specific languages, which are composed of the base language (in this case, Hy/Python) along with many macros that allow uniquely expressive and succinct code.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_149"/>As for downsides, Hy, by virtue of being a Lisp written in s-expressions, suffers from the stigma of being hard to learn, read, or maintain. People might be averse to working on projects using Hy for fear of its complexity.</p>&#13;
<p class="indent">Hy is the Lisp everyone loves to hate. Python folks may not enjoy its syntax, and Lispers may avoid it because Hy uses Python objects directly, meaning the behavior of fundamental objects can sometimes be surprising to the seasoned Lisper.</p>&#13;
<p class="indent">Hopefully people will look past its syntax and consider exploring parts of Python previously untouched.</p>&#13;
</body></html>