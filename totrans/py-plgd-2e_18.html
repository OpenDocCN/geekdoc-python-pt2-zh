<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="header1301" class="chapter" epub:type="chapter" id="ch13" role="doc-chapter">
<header id="header1301">
<h1 class="cn"><span aria-label=" Page 279. " class="page" epub:type="pagebreak" id="p279" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rch13">13</a></h1>
<h1 class="ct">Laser Audio Display with a Raspberry Pi</h1>
</header>
<figure class="figure">
<p class="fig"><img alt="" height="100" src="images/nsp-venkitachalam503045-circle-image.jpg" width="100"/></p>
</figure>
<p class="pf">In <a class="xref" href="nsp-venkitachalam503045-0027.xhtml#ch12">Chapter 12</a>, you used a Pico, a tiny microcontroller, to generate musical tones. In this chapter, you’ll use a much more powerful embedded system, the Raspberry Pi, to produce interesting <span class="idx" data-term="laser"/>laser patterns based on audio signals.</p>
<p>The <a class="xref" href="nsp-venkitachalam503045-0027.xhtml#ch12">previous chapter’s</a> Pico had an RP2040 microcontroller with dual ARM Cortex-M0 processors running at speeds of up to 133 MHz, with 264KB of random access memory (RAM) and 2MB of nonvolatile storage on an external flash chip. The Raspberry Pi 3B+, in comparison, has a much more capable ARM Cortex-A53 processor operating at 1.4 GHz, with 1GB of RAM and storage of several gigabytes, depending on the SD card you use. While this still pales in comparison to a standard desktop or laptop computer, the Pi is nonetheless capable of running a Linux-based operating system and full-fledged Python, unlike the Pico.</p>
<p>In this chapter, you’ll use Python on the Raspberry Pi to read an audio file in the WAV format, perform computations based on the real-time audio data, and use that data to adjust the speed and direction of rotation of two <span aria-label=" Page 280. " class="page" epub:type="pagebreak" id="p280" role="doc-pagebreak"/>motors in a laser display rig. You’ll attach mirrors to the motors to reflect the beam from an inexpensive laser module, producing Spirograph-like patterns that change in response to the audio. You’ll also simultaneously stream the audio to a speaker so you can hear the WAV file playing as you watch your laser light show.</p>
<p>This project will push your knowledge of Python further as you learn to use the Raspberry Pi. Here are some of the topics we’ll cover:</p>
<ul style="list-style-type:none">
<li class="blf">• Generating interesting patterns with a laser and two rotating mirrors</li>
<li class="bl">• Getting frequency information from a signal using the fast Fourier transform (FFT)</li>
<li class="bl">• Computing FFTs using <code>numpy</code></li>
<li class="bl">• Reading audio from WAV files</li>
<li class="bl">• Outputting audio data using <code>pyaudio</code></li>
<li class="bl">• Driving motors with a Raspberry Pi</li>
<li class="bl">• Toggling a laser module on/off with a metal-oxide-semiconductor field-effect transistor (MOSFET)</li>
</ul>
<section>
<h2 class="ah" id="ah1501"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1501">How It Works</a></h2>
<p class="paft">You’ll use a Raspberry Pi to work with the audio data and control the hardware. <a class="xref" href="nsp-venkitachalam503045-0028.xhtml#fig13-1">Figure 13-1</a> shows a block diagram of what you’ll create in this project.</p>
<figure class="figure" id="fig13-1">
<p class="fig"><img alt="" height="821" src="images/nsp-venkitachalam503045-f13001.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 13-1:</span> <span class="idx" data-level1="block diagram" data-term="laser audio"/>A block diagram of the laser audio project</p>
</figcaption>
</figure>
<p>The Raspberry Pi will use a WAV file in two ways. It will play the file through an attached speaker by way of <code>pyaudio</code>, while also analyzing the <span aria-label=" Page 281. " class="page" epub:type="pagebreak" id="p281" role="doc-pagebreak"/>audio data in real time using a mathematical technique called a <i>fast Fourier transform (FFT)</i>. The Pi will use data from the FFT to drive the motors and laser via its general-purpose input/output (GPIO) pins, but to protect the Pi from damage, you won’t hook it up directly to these external components. Instead, you’ll connect it indirectly through a motor driver board and a MOSFET. Before you begin, let’s consider in more detail how some of these aspects of the project will work.</p>
<section>
<h3 class="bh" id="bh1501"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1501">Generating Patterns with a Laser</a></h3>
<p class="paft">To generate the laser patterns in this project, you’ll use a <span class="idx" data-term="laser pointer"/>laser module and two <span class="idx" data-term="mirror"/>mirrors attached to the <span class="idx" data-term="shaft"/>shafts of two small <span class="idx" data-term="DC motor"/>DC motors, as shown in <a class="xref" href="nsp-venkitachalam503045-0028.xhtml#fig13-2">Figure 13-2</a>. Think of the laser as an intense beam of light that remains focused on a tiny point, even when projected over a large distance. This focus is possible because the beam is organized so that its waves travel in one direction only and are in phase with each other. If you shine the laser at the surface of a flat mirror (mirror A in <a class="xref" href="nsp-venkitachalam503045-0028.xhtml#fig13-2">Figure 13-2</a>), the <span class="idx" data-term="reflection"/>reflection projected will remain a fixed point, even as the motor spins. Because the plane of reflection of the laser is perpendicular to the spinning axis of the motor, it’s as if the mirror isn’t rotating at all.</p>
<p>Now, say the mirror is attached at an angle relative to the motor shaft, as shown on the right of <a class="xref" href="nsp-venkitachalam503045-0028.xhtml#fig13-2">Figure 13-2</a> (mirror B). As the shaft rotates, the projected point will trace an ellipse, and if the motor is spinning fast enough, the viewer will perceive the moving dot as a continuous shape.</p>
<figure class="figure" id="fig13-2">
<p class="fig"><img alt="" height="582" src="images/nsp-venkitachalam503045-f13002.jpg" style="width:95%; height:auto;" width="782"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 13-2:</span> The flat mirror (mirror A) reflects a single dot. The reflection off the slanted mirror (mirror B) creates a circle as the motor spins.</p>
</figcaption>
</figure>
<p>What if both mirrors are slanted and you arrange them so that the point reflected off mirror A is projected onto mirror B? Now when motors A and B spin, the pattern created by the reflected point will be a combination of the two rotational movements of motors A and B, producing interesting <span class="idx" data-term="pattern"/>patterns, as shown in <a class="xref" href="nsp-venkitachalam503045-0028.xhtml#fig13-3">Figure 13-3</a>.</p>
<figure class="figure" id="fig13-3">
<p class="fig"><span aria-label=" Page 282. " class="page" epub:type="pagebreak" id="p282" role="doc-pagebreak"/><img alt="" height="1200" src="images/nsp-venkitachalam503045-f13003.jpg" style="width:95%; height:auto;" width="942"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 13-3:</span> <span class="idx" data-level1="laser and mirrors" data-term="laser audio"/>Reflecting laser light off two rotating, slanted mirrors produces interesting, complex patterns.</p>
</figcaption>
</figure>
<p>The exact patterns produced will depend on the speed and direction of rotation of the two motors, but they will be similar to the <span class="idx" data-term="hypotrochoid"/>hypotrochoids produced by the Spirograph you explored in <a class="xref" href="nsp-venkitachalam503045-0013.xhtml#ch02">Chapter 2</a>.</p>
<section>
<h4 class="ch" id="ch1501">Motor Control</h4>
<p class="paft">You’ll use the Raspberry Pi to control the speed and direction of your motors through a technique called <span class="idx" data-term="pulse width modulation"/><i>pulse width modulation (</i><span class="idx" data-term="PWM"/><i>PWM)</i>. This is a way to power a device (such as a motor) by sending digital pulses that switch on and off quickly, such that the device “sees” a continuous voltage. The signal sent to the device has a fixed frequency, but the fraction of time that the digital pulse is on, called the <i>duty cycle</i>, can vary. The duty cycle is expressed as a percentage. To illustrate, <a class="xref" href="nsp-venkitachalam503045-0028.xhtml#fig13-4">Figure 13-4</a> shows three signals with the same frequency but different duty cycles—25 percent, 50 percent, and 75 percent.</p>
<figure class="figure" id="fig13-4">
<p class="fig"><span aria-label=" Page 283. " class="page" epub:type="pagebreak" id="p283" role="doc-pagebreak"/><img alt="" height="760" src="images/nsp-venkitachalam503045-f13004.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 13-4:</span> PWM signals with different duty cycles</p>
</figcaption>
</figure>
<p>The higher the duty cycle percentage, the longer the pulse is on for each cycle of the signal. The motor receiving the signal will perceive those longer pulses as a higher continuous voltage. By manipulating the duty cycle, you can thus provide varying power levels to the motors in this project, which will result in variations in motor speed and changes in the laser pattern.</p>
<p class="pcust1"><span class="ccust3">NOTE</span> PWM has many applications beyond motor control. It could also be used, for example, to control the brightness of dimmable LEDs.</p>
<p>Motors operate at a relatively high voltage, but the Raspberry Pi can handle only so much current before it’s damaged. You’ll be using a <span class="idx" data-term="TB6612FNG"/>TB6612FNG motor driver breakout board, similar to the ones shown in <a class="xref" href="nsp-venkitachalam503045-0028.xhtml#fig13-5">Figure 13-5</a>, to act as an intermediary between the Pi and the motors, keeping the Pi safe. Many variants of this board are available, and you can choose any one of them, as long as you’re careful to wire it up correctly.</p>
<figure class="figure" id="fig13-5">
<p class="fig"><span aria-label=" Page 284. " class="page" epub:type="pagebreak" id="p284" role="doc-pagebreak"/><img alt="" height="900" src="images/nsp-venkitachalam503045-f13005.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 13-5:</span> TB6612FNG <span class="idx" data-term="motor driver"/>motor driver breakout printed circuit boards (PCBs)</p>
</figcaption>
</figure>
<p>The bottom of the breakout board should have pin information. It’s also a good idea to look at the TB6612FNG chip datasheet, which you can download from the internet. The <i>A</i> and <i>B</i> in the pin names denote the two motors. The IN pins control the direction of the motors, the 01 and 02 pins supply power to the motors, and the <span class="idx" data-term="PWM"/>PWM pins use pulse width modulation to control the motor speeds. By writing to these pins, you can control both the direction and speed of rotation for each motor, which is exactly what you need for this project. We won’t go into the details of how this board works, but if you’re curious, you can start by reading up on an <i>H-bridge</i>, a common circuit design that uses MOSFETs to control motors.</p>
<p class="pcust1"><span class="ccust3">NOTE</span> You could replace this breakout part with any motor control circuit you’re familiar with, as long as you modify the code appropriately.</p>
</section>
<section>
<h4 class="ch" id="ch1502"><span class="idx" data-term="laser module"/>Laser Module</h4>
<p class="paft">For the laser, you’ll use an inexpensive laser module breakout PCB similar to the one shown in <a class="xref" href="nsp-venkitachalam503045-0028.xhtml#fig13-6">Figure 13-6</a>.</p>
<figure class="figure" id="fig13-6">
<p class="fig"><img alt="" height="842" src="images/nsp-venkitachalam503045-f13006.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 13-6:</span> A laser module</p>
</figcaption>
</figure>
<p><span aria-label=" Page 285. " class="page" epub:type="pagebreak" id="p285" role="doc-pagebreak"/>Different variants of laser modules are available. You want one with a 650 nanometer (nm) red laser that operates at 5 volts (V). (The 650 nm refers to the laser’s wavelength.) Be sure you understand the polarity and connections of this board before you use it for the project. Test it separately using a 5 V power supply.</p>
</section>
<section>
<h4 class="ch" id="ch1503">MOSFET</h4>
<p class="paft">To turn the laser module on and off using the Raspberry Pi, you’ll use an <i>N-channel MOSFET</i>, which you can think of as an electrically controlled switch. You can use almost any N-channel MOSFET for the project, but the BS170 is cheap and readily available. <a class="xref" href="nsp-venkitachalam503045-0028.xhtml#fig13-7">Figure 13-7</a> shows the pin numbering for the MOSFET, as well as how to connect it to the laser module and the Raspberry Pi.</p>
<figure class="figure" id="fig13-7">
<p class="fig"><img alt="" height="1200" src="images/nsp-venkitachalam503045-f13007.jpg" style="width:95%; height:auto;" width="1050"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 13-7:</span> <span class="idx" data-term="BS170 MOSFET"/>BS170 MOSFET connections</p>
</figcaption>
</figure>
<p>The 10 kΩ resistor “pulls” the gate pin of the MOSFET to the ground, so it isn’t triggered when the Raspberry Pi GPIO pin is in a floating state (for example, after a GPIO cleanup). When you send a HIGH to the GPIO, the MOSFET switch turns on, effectively connecting the laser module to VM and GND and powering it on.</p>
<p>Why do you need a MOSFET? Can’t you just connect the laser module directly to a GPIO pin of the Raspberry Pi? That’s not a great idea, because the MOSFET can take a lot more current than your Raspberry Pi. Using <span aria-label=" Page 286. " class="page" epub:type="pagebreak" id="p286" role="doc-pagebreak"/>a MOSFET isolates your Pi from a situation that causes a current spike on the load. Better to burn your cheap MOSFET than your comparatively expensive Raspberry Pi! In general, the MOSFET trick is a good thing to remember whenever you want to control an external device with your Raspberry Pi.</p>
</section>
</section>
<section>
<h3 class="bh" id="bh1502"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1502">Analyzing Audio with the Fast Fourier Transform<span class="idx" data-term="FFT"/></a></h3>
<p class="paft">Because the ultimate goal in this project is to control motor speeds based on audio input, you need to be able to analyze the audio in real time. Recall from <a class="xref" href="nsp-venkitachalam503045-0016.xhtml#ch04">Chapter 4</a> that tones from an acoustic instrument are a mix of several frequencies, or overtones. In fact, any sound can be decomposed into its constituent frequencies using a <i>Fourier transform</i>. When the Fourier transform is applied to digital signals, the result is called the <span class="idx" data-term="discrete Fourier transform"/><i>discrete Fourier transform (</i><span class="idx" data-term="DFT"/><i>DFT)</i> because digital signals are composed of many discrete samples. In this project, you’ll use Python to implement a <i>fast Fourier transform (FFT)</i> algorithm to compute the DFT. (Throughout this chapter, I’ll use <i>FFT</i> to refer to both the algorithm and the result.)</p>
<p><a class="xref" href="nsp-venkitachalam503045-0028.xhtml#fig13-8">Figure 13-8</a> shows a simple example of an FFT. The top frame of the figure shows the waveform of a signal that combines just two sine waves. This plot is in the <i>time domain</i> because it’s showing how the signal’s amplitude varies over time. The bottom frame of the figure shows the FFT corresponding to that signal. The FFT is in the <i>frequency domain</i>; it’s showing what frequencies are present in the signal at a given moment in time.</p>
<figure class="figure" id="fig13-8">
<p class="fig"><img alt="" height="452" src="images/nsp-venkitachalam503045-f13008.jpg" style="width:95%; height:auto;" width="1071"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 13-8:</span> An audio <span class="idx" data-term="FFT example"/>signal containing multiple frequencies (top) and its corresponding FFT (bottom)</p>
</figcaption>
</figure>
<p>The wave in the top frame can be expressed by the following equation, which sums the two sine waves:</p>
<div class="equation">
<p class="eq"><i>y</i>(<i>t</i>) = 4sin(2π10<i>t</i>) + 2.5sin(2π30<i>t</i>)</p>
</div>
<p class="pcon">Notice the 4 and 10 in the expression for the first wave—4 is the <span class="idx" data-level1="amplitude" data-term="FFT"/>amplitude of the wave, and 10 is the frequency (in hertz). Meanwhile, the second wave has an amplitude of 2.5 and a frequency of 30 Hz. Take a look at the FFT in the bottom frame of the figure and you’ll see it has two peaks, at 10 Hz and <span aria-label=" Page 287. " class="page" epub:type="pagebreak" id="p287" role="doc-pagebreak"/>30 Hz. The FFT has revealed the signal’s component <span class="idx" data-level1="frequency" data-term="FFT"/>frequencies. The FFT also identifies the relative amplitude of each frequency; the intensity of the first peak is about twice that of the second peak.</p>
<p>Now let’s look at a more realistic example. <a class="xref" href="nsp-venkitachalam503045-0028.xhtml#fig13-9">Figure 13-9</a> shows a complex <span class="idx" data-term="audio signal"/>audio signal in the top frame and the corresponding <span class="idx" data-level1="example" data-term="FFT"/>FFT in the bottom frame. Notice that the FFT contains many more peaks at a variety of intensities, indicating that the signal contains many more frequencies.</p>
<figure class="figure" id="fig13-9">
<p class="fig"><img alt="" height="653" src="images/nsp-venkitachalam503045-f13009.jpg" style="width:95%; height:auto;" width="1101"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 13-9:</span> The FFT algorithm takes an amplitude signal (top) and computes its component frequencies (bottom).</p>
</figcaption>
</figure>
<p>To compute an FFT, you need a set of samples. The choice of the number of samples is a bit arbitrary, but a small sample size wouldn’t give you a good picture of the signal’s frequency content and might also mean a higher computational load because you would need to compute more FFTs per second. On the other hand, a sample size that’s too large would average out the changes in the signal, so you wouldn’t be getting a “real-time” frequency response for the signal. For the purposes of this project, a sample size of 2,048 will work. At a <span class="idx" data-level1="sampling rate" data-term="FFT"/>sampling rate of 44,100 Hz, 2,048 samples represent about 0.046 seconds of audio.</p>
<p>You’ll use <code>numpy</code> to compute an FFT to split the audio data into its constituent frequencies, and then you’ll use that information to control the motors. First you’ll split the range of frequencies (in Hz) into three bands: [0, 100], [100, 1000], and [1000, 2500]. You’ll compute an average amplitude level for each band, and each value will affect the motors and resulting laser pattern differently, as follows:</p>
<ul style="list-style-type:none">
<li class="blf">• Changes in the average amplitude of low frequencies will affect the speed of the first motor.</li>
<li class="bl">• Changes in the average amplitude of middle frequencies will affect the speed of the second motor.</li>
<li class="bll"><span aria-label=" Page 288. " class="page" epub:type="pagebreak" id="p288" role="doc-pagebreak"/>• When high frequencies peak above a certain threshold, the first motor will change direction.</li>
</ul>
<p>With these rules, the laser pattern will change in response to the audio signal.</p>
</section>
</section>
<section>
<h2 class="ah" id="ah1502"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1502">Requirements</a></h2>
<p class="paft"><span class="idx" data-level1="required software" data-term="laser audio"/>In this project, you’ll use the following Python modules:</p>
<ul style="list-style-type:none">
<li class="blf">• <code>RPi.GPIO</code> to set up PWM and control the output of the pins</li>
<li class="bl">• <code>time</code> for pausing between operations</li>
<li class="bl">• <code>wave</code> to read WAV files</li>
<li class="bl">• <code>pyaudio</code> to process and stream audio data</li>
<li class="bl">• <code>numpy</code> for FFT computations</li>
<li class="bll">• <code>argparse</code> to process command line arguments</li>
</ul>
<p><span class="idx" data-level1="required hardware" data-term="laser audio"/>You’ll also need the following items to build the project:</p>
<ul style="list-style-type:none">
<li class="blf">• One Raspberry Pi 3B+ or newer</li>
<li class="bl">• One 5 V adapter to power the Raspberry Pi</li>
<li class="bl">• One powered speaker with AUX (line-in) input (most Bluetooth speakers have an AUX input these days)</li>
<li class="bl">• One TB6612FNG motor breakout board</li>
<li class="bl">• One laser module breakout board</li>
<li class="bl">• One 10 kΩ resistor</li>
<li class="bl">• One BS170 N-channel MOSFET or equivalent</li>
<li class="bl">• Two DC motors like the ones used in a small toy, rated for 9 V</li>
<li class="bl">• Two small mirrors, approximately 1 inch or less in diameter</li>
<li class="bl">• One 3.7 V 18650 2000 mAh (3C) lithium-ion battery with holder (or use four AA batteries on a holder)</li>
<li class="bl">• Two 3D-printed parts to fix the mirrors onto the motor shafts (optional)</li>
<li class="bl">• One rectangular base, about 8 inches by 6 inches, to mount the hardware</li>
<li class="bl">• Some LEGO bricks to raise the motors and laser module off the base so the mirrors can spin freely</li>
<li class="bl">• A hot glue gun</li>
<li class="bl">• Superglue to fix the mirrors to the motor shafts</li>
<li class="bl">• A soldering iron</li>
<li class="bl">• A breadboard</li>
<li class="bl">• Wires to make connections (single-core hookup wires with male pins on both sides work nicely)</li>
</ul>
<section>
<h3 class="bh" id="bh1503"><span aria-label=" Page 289. " class="page" epub:type="pagebreak" id="p289" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1503">Setting Up the Raspberry Pi</a></h3>
<p class="paft"><span class="idx" data-level1="Raspberry Pi setup" data-term="laser audio"/>To set up your Raspberry Pi, see <a class="xref" href="nsp-venkitachalam503045-0032.xhtml#appb">Appendix B</a>. Follow the instructions in the appendix, and make sure you’ve installed the <code>numpy</code> and <code>pyaudio</code>Python packages required for this project. You’ll write code on the Raspberry Pi via a Secure Shell (SSH). You can set up Microsoft Visual Studio Code to work remotely on the Pi using an SSH from your laptop or desktop computer. This is also explained in <a class="xref" href="nsp-venkitachalam503045-0032.xhtml#appb">Appendix B</a>.</p>
</section>
<section>
<h3 class="bh" id="bh1504"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1504">Constructing the Laser Display</a></h3>
<p class="paft"><span class="idx" data-level1="constructing laser display" data-term="laser audio"/>Before you hook up all the hardware, you should prepare the motors and the laser module for the laser display. The first order of business is to attach the <span class="idx" data-term="mirrors, attaching"/>mirrors to the motors. Each mirror has to be at a slight angle relative to the motor shaft. One way to do this would be to use hot glue. To attach the mirror, place it face down on a flat surface and put a drop of <span class="idx" data-term="hot glue"/>hot glue in the center. Carefully dip the motor shaft in the glue, keeping it at a slight angle to the perpendicular with respect to the mirror, until the glue hardens.</p>
<p>A better way would be to use a motor flange with a slanted face to which you can easily stick the mirror. But where would you find such a part? You can make it yourself using 3D printing! <a class="xref" href="nsp-venkitachalam503045-0028.xhtml#fig13-10">Figure 13-10(a)</a> shows a 3D design I created using the free, open source program called <span class="idx" data-term="OpenSCAD"/>OpenSCAD. You can download the design from this book’s GitHub repository. <a class="xref" href="nsp-venkitachalam503045-0028.xhtml#fig13-10">Figure 13-10(b)</a> shows the <span class="idx" data-term="3D printing"/>3D printed parts. The mirror the laser strikes first will use the flange with the lesser tilt (5 degrees), and the second mirror will use the one with more tilt (10 degrees).</p>
<figure class="figure" id="fig13-10">
<p class="fig"><img alt="" height="750" src="images/nsp-venkitachalam503045-f13010a.jpg" style="width:95%; height:auto;" width="1200"/></p>
<p class="figh1">(a)</p>
<p class="fig"><img alt="" height="934" src="images/nsp-venkitachalam503045-f13010b.jpg" style="width:95%; height:auto;" width="1200"/></p>
<p class="figh1">(b)</p>
<p class="figh"><span class="fighn">Figure 13-10:</span> An OpenSCAD model (a) and 3D-printed flanges (b)</p>
</figure>
<p>Print the flanges yourself if you have a 3D printer, or get them printed from a 3D printing service. (Either way, it will be inexpensive.) Once you have the parts, use superglue to attach the flanges to the motor shafts and the mirrors to the flanges. <a class="xref" href="nsp-venkitachalam503045-0028.xhtml#fig13-11">Figure 13-11</a> shows the fully assembled parts.</p>
<figure class="figure" id="fig13-11">
<p class="fig"><span aria-label=" Page 290. " class="page" epub:type="pagebreak" id="p290" role="doc-pagebreak"/><img alt="" height="928" src="images/nsp-venkitachalam503045-f13011.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 13-11:</span> <span class="idx" data-level1="attaching mirror" data-term="laser audio"/>Attach the mirrors to each motor shaft at a slight angle.</p>
</figcaption>
</figure>
<p>To test the assembly, spin the mirror with your hand while shining the laser module at it. You should find the reflection of the laser dot moves in an ellipse when projected on a flat surface. Do the same for the second mirror. It should create a wider ellipse because of the larger angle with respect to the motor shaft.</p>
<section>
<h4 class="ch" id="ch1504">Aligning the Mirrors</h4>
<p class="paft"><span class="idx" data-level1="aligning mirror" data-term="laser audio"/>Next, align the laser module with the mirrors so that the laser reflects from mirror A to mirror B, as shown in <a class="xref" href="nsp-venkitachalam503045-0028.xhtml#fig13-12">Figure 13-12</a>. Be sure that the reflected laser light from mirror A stays within the circumference of mirror B for mirror A’s entire range of rotation. (This will take some trial and error.) To test the arrangement, manually rotate mirror A. Also, be sure to position mirror B so that the light reflected from its surface will fall on a flat surface (like a wall) for the full range of rotation of both mirrors.</p>
<figure class="figure" id="fig13-12">
<p class="fig"><img alt="" height="939" src="images/nsp-venkitachalam503045-f13012.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 13-12:</span> The alignment of the laser and the mirrors</p>
</figcaption>
</figure>
<p class="pcust1"><span aria-label=" Page 291. " class="page" epub:type="pagebreak" id="p291" role="doc-pagebreak"/><span class="ccust3">NOTE</span> As you tweak the alignment, you’ll need to keep the laser pointer on. You can do this by running the project code as follows: <code>python laser_audio.py --test_laser</code>. This command simply turns on the MOSFET controlling the laser module, as we’ll discuss later in the chapter.</p>
<p>Once you’re happy with the placement of the mirrors, hot-glue the laser module and the two motors with attached mirrors onto three identical blocks (LEGO blocks work great!) to raise them up so that the motors will be able to rotate freely. Next, place the blocks on the mounting board, and when you’re happy with their arrangement, mark the location of each by tracing their edge with a pencil. Then hot-glue the blocks onto the board. Or use a LEGO baseplate and simply attach the LEGO blocks to the baseplate.</p>
</section>
<section>
<h4 class="ch" id="ch1505">Powering the Motors</h4>
<p class="paft"><span class="idx" data-level1="powering motors" data-term="laser audio"/>If your motors didn’t come with wires attached to their terminals (most don’t), solder wires to both terminals, being sure to leave sufficient wire (say, 6 inches) so that you can attach the motors to the motor driver board. The motors can be powered by a 3.7 V lithium-ion battery, or a 4x AA battery pack.</p>
</section>
</section>
<section>
<h3 class="bh" id="bh1505"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1505">Hooking Up the Hardware</a></h3>
<p class="paft">Now to hook up the hardware. You need to connect the Raspberry Pi, the motor driver board, the MOSFET, the laser module board, and the motors. The Raspberry Pi has a collection of GPIO pins for connecting to other hardware. To understand the pin layout, I highly recommend you visit the website <span class="idx" data-term="Rapsberry Pi pinout"/><a class="url-i" href="https://pinout.xyz/">https://pinout.xyz</a>. It gives you a handy visual reference and explains the various pin functions.</p>
<p class="pcust1"><span class="ccust3">NOTE</span> There are a few different conventions for referring to pin numbers on a Raspberry Pi. For this project, we’ll use the <span class="idx" data-level1="BCM pin numbering" data-term="Raspberry Pi"/><i>BCM pin-numbering</i> convention.</p>
<p><a class="xref" href="nsp-venkitachalam503045-0028.xhtml#tab13-1">Table 13-1</a> lists the connections you need to make.</p>
<table id="tab13-1">
<caption>
<p class="th"><span class="thn">Table 13-1:</span> <span class="idx" data-level1="hardware connections" data-term="laser audio"/>Hardware Wiring Connections</p>
</caption>
<thead>
<tr>
<th scope="col">
<p class="tch">From</p>
</th>
<th scope="col">
<p class="tch">To</p>
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<p class="td">Raspberry Pi GPIO 12</p>
</td>
<td>
<p class="td"><span class="idx" data-term="TB6612FNG, connecting"/>TB6612FNG PWMA</p>
</td>
</tr>
<tr>
<td>
<p class="td">Raspberry Pi GPIO 13</p>
</td>
<td>
<p class="td">TB6612FNG PWMB</p>
</td>
</tr>
<tr>
<td>
<p class="td">Raspberry Pi GPIO 7</p>
</td>
<td>
<p class="td">TB6612FNG AIN1</p>
</td>
</tr>
<tr>
<td>
<p class="td">Raspberry Pi GPIO 8</p>
</td>
<td>
<p class="td">TB6612FNG AIN2</p>
</td>
</tr>
<tr>
<td>
<p class="td">Raspberry Pi GPIO 5</p>
</td>
<td>
<p class="td">TB6612FNG BIN1</p>
</td>
</tr>
<tr>
<td>
<p class="td">Raspberry Pi GPIO 6</p>
</td>
<td>
<p class="td">TB6612FNG BIN2</p>
</td>
</tr>
<tr>
<td>
<p class="td">Raspberry Pi GPIO 22</p>
</td>
<td>
<p class="td">TB6612FNG STBY</p>
</td>
</tr>
<tr>
<td>
<p class="td"><span aria-label=" Page 292. " class="page" epub:type="pagebreak" id="p292" role="doc-pagebreak"/>Raspberry Pi GND</p>
</td>
<td>
<p class="td">TB6612FNG GND</p>
</td>
</tr>
<tr>
<td>
<p class="td">Raspberry Pi 3V3</p>
</td>
<td>
<p class="td">TB6612FNG VCC</p>
</td>
</tr>
<tr>
<td>
<p class="td">Raspberry Pi GPIO 25</p>
</td>
<td>
<p class="td">BS170 GATE (also to GND via 10 kΩ resistor)</p>
</td>
</tr>
<tr>
<td>
<p class="td">Raspberry Pi GND</p>
</td>
<td>
<p class="td">BS170 SOURCE</p>
</td>
</tr>
<tr>
<td>
<p class="td">Laser module GND</p>
</td>
<td>
<p class="td">BS170 DRAIN</p>
</td>
</tr>
<tr>
<td>
<p class="td">Laser module VCC</p>
</td>
<td>
<p class="td">Battery pack VCC (+)</p>
</td>
</tr>
<tr>
<td>
<p class="td">Battery pack GND (−)</p>
</td>
<td>
<p class="td">TB6612FNG GND</p>
</td>
</tr>
<tr>
<td>
<p class="td">Battery pack VCC (+)</p>
</td>
<td>
<p class="td">TB6612FNG VM</p>
</td>
</tr>
<tr>
<td>
<p class="td">Motor #1 connector #1 (polarity doesn’t matter)</p>
</td>
<td>
<p class="td">TB6612FNG A01</p>
</td>
</tr>
<tr>
<td>
<p class="td">Motor #1 connector #2 (polarity doesn’t matter)</p>
</td>
<td>
<p class="td">TB6612FNG A02</p>
</td>
</tr>
<tr>
<td>
<p class="td">Motor #2 connector #1 (polarity doesn’t matter)</p>
</td>
<td>
<p class="td">TB6612FNG B01</p>
</td>
</tr>
<tr>
<td>
<p class="td">Motor #2 connector #2 (polarity doesn’t matter)</p>
</td>
<td>
<p class="td">TB6612FNG B02</p>
</td>
</tr>
<tr>
<td>
<p class="td">Raspberry Pi 3.5 mm audio jack</p>
</td>
<td>
<p class="td">AUX input of powered speaker</p>
</td>
</tr>
</tbody>
</table>
<p><a class="xref" href="nsp-venkitachalam503045-0028.xhtml#fig13-13">Figure 13-13</a> shows everything wired up.</p>
<figure class="figure" id="fig13-13">
<p class="fig"><img alt="" height="800" src="images/nsp-venkitachalam503045-f13013.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 13-13:</span> <span class="idx" data-level1="completed hardware" data-term="laser audio"/>The completely wired-up laser display</p>
</figcaption>
</figure>
<p>Now let’s look at the code.</p>
</section>
</section>
<section>
<h2 class="ah" id="ah1503"><span aria-label=" Page 293. " class="page" epub:type="pagebreak" id="p293" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1503">The <span class="idx" data-term="Arduino sketch"/>Code</a></h2>
<p class="paft"><span class="idx" data-level1="complete code" data-term="laser audio"/>The code for this project is in the file <i>laser_audio.py</i>. You’ll begin with some basic setup. Then you’ll define functions to operate and test the motors and laser, as well as a function to process audio data from a WAV file and control the motors based on that data. You’ll bring everything together and accept command line options through the <code>main()</code> function. To see the full program, skip ahead to <a class="xref" href="nsp-venkitachalam503045-0028.xhtml#ah1507">“The Complete Code”</a> on <a class="xref" href="nsp-venkitachalam503045-0028.xhtml#p305">page 305</a>. You can also download the code at <a class="url-i" href="https://github.com/mkvenkit/pp2e/tree/main/laser_audio">https://github.com/mkvenkit/pp2e/tree/main/laser_audio</a>.</p>
<section>
<h3 class="bh" id="bh1506"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1506"><span class="idx" data-level1="setting up" data-term="laser audio"/>Setting Up</a></h3>
<p class="paft">Start by importing the required modules:</p>
<div class="codeline">
<p class="clf">import RPi.<span class="idx" data-level1="GPIO" data-term="Rpi module"/>GPIO as GPIO</p>
<p class="cl">import time</p>
<p class="cl">import argparse</p>
<p class="cl">import pyaudio</p>
<p class="cl">import wave</p>
<p class="cll">import numpy as np</p>
</div>
<p>The <code>RPi.GPIO</code> module lets you use the pins of the Raspberry Pi. You’ll use the <code>time</code> module to put delays in your code, and you’ll use <code>argparse</code> to add command line arguments to the program. The <code>pyaudio</code> and <code>wave</code> modules will help you read data from WAV files and output an audio stream. Finally, you’ll use <code>numpy</code> to compute the FFT of the audio data.</p>
<p>Next, you initialize a few global variables:</p>
<div class="codeline">
<p class="clf"># define pin numbers</p>
<p class="cl"># uses TB6612FNG motor driver pin naming</p>
<p class="cl">PWMA = 12</p>
<p class="cl">PWMB = 13</p>
<p class="cl">AIN1 = 7</p>
<p class="cl">AIN2 = 8</p>
<p class="cl">BIN1 = 5</p>
<p class="cl">BIN2 = 6</p>
<p class="cl">STBY = 22</p>
<p class="cll">LASER = 25</p>
</div>
<p>This code stores the pin numbers for all the Raspberry Pi pins used in the project. <code>PWMA</code>, <code>PWMB</code>, <code>AIN1</code>, <code>AIN2</code>, <code>BIN1</code>, <code>BIN2</code>, and <code>STBY</code> are pins that connect to the TB6612FNG motor driver. The <code>LASER</code> pin will connect to the gate of the MOSFET, which can turn the laser module on and off. Note that you’re using the BCM pin-numbering convention here.</p>
<p>Continue with a few more global variables:</p>
<div class="codeline">
<p class="clf"># global PWM objects</p>
<p class="cl">pwm_a = None</p>
<p class="cl">pwm_b = None</p>
<p class="cl"># size of audio data read in</p>
<p class="cl">CHUNK = 2048</p>
<p class="cl"># FFT size</p>
<p class="cll">N = CHUNK</p>
</div>
<p><span aria-label=" Page 294. " class="page" epub:type="pagebreak" id="p294" role="doc-pagebreak"/>Here you initialize the variables <code>pwm_a</code> and <code>pwm_b</code> that will represent <code>PWM</code> objects, which you’ll use to control the motors. You set them to <code>None</code> here because it’s too early in the code to create the actual <code>PWM</code> objects. You also set <code>CHUNK</code>, the number of audio data samples you’ll read in from the WAV file at a time, and <code>N</code>, the number of samples you’ll use to compute the FFT.</p>
<p>You finish setting up by initializing the GPIO pins. This is necessary to use the pins. Define a function <code>init_pins()</code> for this purpose:</p>
<div class="codeline">
<p class="clf">def init_pins():</p>
<p class="cl">    """set up pins"""</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ global pwm_a, pwm_b</p>
<p class="cl">    # use BCM pin numbering</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ GPIO.<span class="idx" data-level1="GPIO" data-level2="setmode" data-term="Rpi module"/>setmode(GPIO.BCM)</p>
<p class="cl">    # put pins into a list</p>
<p class="cl">    pins = [PWMA, PWMB, AIN1, AIN2, BIN1, BIN2, STBY, LASER]</p>
<p class="cl">    # set up pins as outputs</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ GPIO.<span class="idx" data-level1="GPIO" data-level2="setup" data-term="Rpi module"/>setup(pins, GPIO.OUT)</p>
<p class="cl">    # set PWM</p>
<p class="cl">    pwm_a = GPIO.<span class="idx" data-level1="GPIO" data-level2="PWM" data-term="Rpi module"/>PWM(PWMA, 100)</p>
<p class="cll">    pwm_b = GPIO.PWM(PWMB, 100)</p>
</div>
<p>First you indicate that <code>pwm_a</code> and <code>pwm_b</code> are global variables <!--<ccust1>1</ccust1>-->❶, since you’ll be setting them inside this function. Then you set the pin mode to the BCM numbering convention <!--<ccust1>2</ccust1>-->❷. Next, you put the pin variables you set earlier into a <code>pins</code> list so you can declare them all to be output pins with one call <!--<ccust1>3</ccust1>-->❸. Finally, you create two <code>PWM</code> objects and assign them to your global <code>pwm_a</code> and <code>pwm_b</code> variables. The argument <code>100</code> is the frequency, in hertz, of the signal that will drive each motor. You’ll vary the duty cycles of those signals to control the motors’ speeds using pulse width modulation.</p>
</section>
<section>
<h3 class="bh" id="bh1507"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1507"><span class="idx" data-level1="hardware control" data-term="laser audio"/>Controlling the Hardware</a></h3>
<p class="paft">You need some helper functions to control the laser module and the motors. Let’s look first at the function that toggles the laser module:</p>
<div class="codeline">
<p class="clf">def laser_on(on):</p>
<p class="cl">    # pin 25 controls laser ctrl mosfet</p>
<p class="cll">    GPIO.<span class="idx" data-level1="GPIO" data-level2="output" data-term="Rpi module"/>output(LASER, on)</p>
</div>
<p>This function takes a parameter <code>on</code> that will be a Boolean <code>True/False</code> value. You pass that parameter to the <code>GPIO.output()</code> method to set the <code>LASER</code> pin on (<code>True</code>) or off (<code>False</code>). This will trigger the MOSFET to turn the laser module on or off.</p>
<p>Next, define a function <code>start_motors()</code> to turn the motors on at the start of the project:</p>
<div class="codeline">
<p class="clf">def start_motors():</p>
<p class="cl">    """start both motors"""</p>
<p class="cl">    # enable driver chip</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ GPIO.output(STBY, GPIO.HIGH)</p>
<p class="cl">    # set motor direction for channel A</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ GPIO.output(AIN1, GPIO.HIGH)</p>
<p class="cl"><span aria-label=" Page 295. " class="page" epub:type="pagebreak" id="p295" role="doc-pagebreak"/>  <!--<ccust1>3</ccust1>-->❸ GPIO.output(AIN2, GPIO.LOW)</p>
<p class="cl">    # set motor direction for channel B</p>
<p class="cl">    GPIO.output(BIN1, GPIO.HIGH)</p>
<p class="cl">    GPIO.output(BIN2, GPIO.LOW)</p>
<p class="cl">    # set PWM for channel A</p>
<p class="cl">    duty_cycle = 10</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ pwm_a.<span class="idx" data-level1="GPIO.PWM" data-level2="start" data-term="Rpi module"/>start(duty_cycle)</p>
<p class="cl">    # set PWM for channel B</p>
<p class="cll">    pwm_b.start(duty_cycle)</p>
</div>
<p>First you set the <code>STBY</code> (standby) pin to <code>HIGH</code> <!--<ccust1>1</ccust1>-->❶, which in effect turns on the motor driver. Then you set the <code>AIN1</code> and <code>AIN2</code> pins to <code>HIGH</code> <!--<ccust1>2</ccust1>-->❷ and <code>LOW</code> <!--<ccust1>3</ccust1>-->❸, respectively. This will cause motor A to spin in one direction. (Swapping the <code>HIGH/LOW</code> values between the two pins would cause the motor to spin in the opposite direction.) You do the same thing for motor B. Lastly, you use your <code>PWM</code> objects to set the speed of the motors <!--<ccust1>4</ccust1>-->❹. You set the duty cycle (which correlates to the motor speed) to 10 percent, a relatively low value, since this is just an initializing call.</p>
<p>You also need a function to stop the motors from spinning at the end of the project. Here’s the definition:</p>
<div class="codeline">
<p class="clf">def stop_motors():</p>
<p class="cl">    """stop both motors"""</p>
<p class="cl">    # stop PWM</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ pwm_a.<span class="idx" data-level1="GPIO.PWM" data-level2="stop" data-term="Rpi module"/>stop()</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ pwm_b.stop()</p>
<p class="cl">    # brake A</p>
<p class="cl">    GPIO.<span class="idx" data-level1="GPIO" data-level2="output" data-term="Rpi module"/>output(AIN1, GPIO.HIGH)</p>
<p class="cl">    GPIO.output(AIN2, GPIO.HIGH)</p>
<p class="cl">    # brake B</p>
<p class="cl">    GPIO.output(BIN1, GPIO.HIGH)</p>
<p class="cl">    GPIO.output(BIN2, GPIO.HIGH)</p>
<p class="cl">    # disable driver chip</p>
<p class="cll">  <!--<ccust1>3</ccust1>-->❸ GPIO.output(STBY, GPIO.LOW)</p>
</div>
<p>To stop the motors from spinning, you first stop the PWM signals going to the <code>PWMA</code> <!--<ccust1>1</ccust1>-->❶ and <code>PWMB</code> <!--<ccust1>2</ccust1>-->❷ pins. Then you set the <code>AIN1</code>, <code>AIN2</code>, <code>BIN1</code>, and <code>BIN2</code> pins all to <code>HIGH</code>, which has the effect of “braking” each motor to a stop. Finally, you disable the motor driver by setting the <code>STBY</code> pin to <code>LOW</code> <!--<ccust1>3</ccust1>-->❸. Standby mode saves power when the motors aren’t required to function.</p>
<p>You need one more helper function to set the speed and direction of both motors. You’ll use this function to adjust the motors based on your real-time audio analysis.</p>
<div class="codeline">
<p class="clf">def set_motor_speed_dir(dca, dcb, dira, dirb):</p>
<p class="cl">    """set speed and direction of motors"""</p>
<p class="cl">    # set duty cycle</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ pwm_a.<span class="idx" data-level1="GPIO.PWM" data-level2="changeDutyCycle" data-term="Rpi module"/>ChangeDutyCycle(dca)</p>
<p class="cl">    pwm_b.ChangeDutyCycle(dcb)</p>
<p class="cl">    # set direction A</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ if dira:</p>
<p class="cl">        GPIO.output(AIN1, GPIO.HIGH)</p>
<p class="cl"><span aria-label=" Page 296. " class="page" epub:type="pagebreak" id="p296" role="doc-pagebreak"/>        GPIO.output(AIN2, GPIO.LOW)</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ else:</p>
<p class="cl">        GPIO.output(AIN1, GPIO.LOW)</p>
<p class="cl">        GPIO.output(AIN2, GPIO.HIGH)</p>
<p class="cl">    if dirb:</p>
<p class="cl">        GPIO.output(BIN1, GPIO.HIGH)</p>
<p class="cl">        GPIO.output(BIN2, GPIO.LOW)</p>
<p class="cl">    else:</p>
<p class="cl">        GPIO.output(BIN1, GPIO.LOW)</p>
<p class="cll">        GPIO.output(BIN2, GPIO.HIGH)</p>
</div>
<p>The <code>set_motor_speed_dir()</code> function takes four parameters: <code>dca</code> and <code>dcb</code> determine the duty cycle for each motor, while <code>dira</code> and <code>dirb</code> are Booleans that set the motors’ direction of rotation. You use the <code>ChangeDutyCycle()</code> method to update the duty cycles (speeds) of the motors to the values passed into the function <!--<ccust1>1</ccust1>-->❶. Then you attend to the motors’ directions. If <code>dira</code> is <code>True</code> <!--<ccust1>2</ccust1>-->❷, you set pins <code>AIN1</code> and <code>AIN2</code> to <code>HIGH</code> and <code>LOW</code>, respectively, which will let motor A spin in one direction. However, if <code>dira</code> is <code>False</code> <!--<ccust1>3</ccust1>-->❸, you set the pins the opposite way, which will spin the motor in the other direction. You do the same thing for motor B using the <code>dirb</code> parameter.</p>
</section>
<section>
<h3 class="bh" id="bh1508"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1508"><span class="idx" data-level1="processing audio" data-term="laser audio"/>Processing the Audio</a></h3>
<p class="paft">The heart of this project is the <code>process_audio()</code> function, which reads audio data from a WAV file, outputs an audio stream with <code>pyaudio</code>, analyzes the audio data by computing an FFT, and uses the resulting analysis to control the motors. We’ll look at the function in sections.</p>
<div class="codeline">
<p class="clf">def process_audio(filename):</p>
<p class="cl">    print("opening {}...".format(filename))</p>
<p class="cl">    # open WAV file</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ wf = wave.<span class="idx" data-level1="open" data-term="wave module"/>open(filename, 'rb')</p>
<p class="cl">    # print audio details</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ print("SW = {}, NCh = {}, SR = {}".format(wf.<span class="idx" data-level1="getsampwidth" data-term="wave module"/>getsampwidth(),</p>
<p class="cl">        wf.<span class="idx" data-level1="getnchannels" data-term="wave module"/>getnchannels(), wf.<span class="idx" data-level1="getframerate" data-term="wave module"/>getframerate()))</p>
<p class="cl">    # check for supported format</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ if wf.<span class="idx" data-level1="getsampwidth" data-term="wave module"/>getsampwidth() != 2 or wf.<span class="idx" data-level1="getnchannels" data-term="wave module"/>getnchannels() != 1:</p>
<p class="cl">        print("Only single channel 16 bit WAV files are supported!")</p>
<p class="cl">        wf.close()</p>
<p class="cl">        return</p>
<p class="cl">    # create PyAudio object</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ p = pyaudio.<span class="idx" data-level1="create" data-term="PyAudio module"/>PyAudio()</p>
<p class="cl">    # open an output stream</p>
<p class="cl">  <!--<ccust1>5</ccust1>-->❺ stream = p.<span class="idx" data-level1="open" data-term="PyAudio module"/>open(format=p.get_format_from_width(wf.getsampwidth()),</p>
<p class="cl">                    channels=wf.getnchannels(),</p>
<p class="cl">                    rate=wf.getframerate(),</p>
<p class="cl">                    output=True)</p>
<p class="cll">    # read first frame</p>
</div>
<p>You start by using the <code>wave</code> module to open the audio file passed into the <code>process_audio()</code> function <!--<ccust1>1</ccust1>-->❶. The <code>wave.open()</code> function returns a <code>Wave_read</code> object, which you’ll use to read data from the WAV file. You print out some information about the WAV file read in <!--<ccust1>2</ccust1>-->❷: <code>SW</code> is the sample width in bytes, <span aria-label=" Page 297. " class="page" epub:type="pagebreak" id="p297" role="doc-pagebreak"/><code>NCh</code> is the number of channels in the audio, and <code>SR</code> is the sampling rate. To keep the project simple, you’ll support only single-channel, 16-bit WAV files as input. You check for these specs <!--<ccust1>3</ccust1>-->❸, and if the input doesn’t match, you return from the function.</p>
<p>Next, you create the <code>PyAudio</code> object that you’ll use to stream data from the WAV file to the output <!--<ccust1>4</ccust1>-->❹. Then you open a <code>pyaudio</code> output stream (as indicated by the <code>output=True</code> argument), configuring it to have the same sample width, number of channels, and sample rate as the WAV file <!--<ccust1>5</ccust1>-->❺. For the Raspberry Pi, the default sound output is the 3.5 mm audio jack on the board. As long as your speaker is plugged into this jack, you’ll hear the sound output.</p>
<p>Here’s the next part of the function:</p>
<div class="codeline">
<p class="clf">  <!--<ccust1>1</ccust1>-->❶ data = wf.<span class="idx" data-level1="readframes" data-term="wave module"/>readframes(CHUNK)</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ buf = np.<span class="idx" data-level1="frombuffer" data-term="numpy module"/>frombuffer(data, dtype=np.int16)</p>
<p class="cl">    # store sample rate</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ SR = wf.<span class="idx" data-level1="getframerate" data-term="wave module"/>getframerate()</p>
<p class="cl">    # start motors</p>
<p class="cl">    start_motors()</p>
<p class="cl">    # laser on</p>
<p class="cll">    laser_on(True)</p>
</div>
<p>Here you read <code>CHUNK</code> samples from the WAV file into variable <code>data</code> <!--<ccust1>1</ccust1>-->❶. Remember, you’ve set <code>CHUNK</code> to <code>2048</code>, and each sample is 2 bytes wide, so you’ll be reading a total of 2,048 16-bit values. You read only one chunk of data because of how the function’s main loop is structured, as you’ll see soon.</p>
<p>The <code>readframes()</code> method returns a <code>bytes</code> object, but you use the <code>numpy</code> library’s <code>frombuffer()</code> function to convert the <code>bytes</code> object into a <code>numpy</code> array of 16-bit integers called <code>buf</code> <!--<ccust1>2</ccust1>-->❷. You store the sampling rate (the <code>wave</code> module calls it the <i>frame rate</i>) in variable <code>SR</code> <!--<ccust1>3</ccust1>-->❸; you’ll need it later. Then you call the <code>start_motors()</code> and <code>laser_on()</code> functions, which we’ve already discussed, to get the motors and the laser module going.</p>
<p>Next, you enter the function’s main loop, which outputs the audio and performs the FFT. The loop works on one chunk of audio data at a time, which is why you read only a single chunk of data in the previous code listing. Notice that the loop occurs inside a <code>try</code> block. Later, you’ll write an <code>except</code> block to handle any problems that arise during the execution of the loop.</p>
<div class="codeline">
<p class="clf">    # read audio data from WAV file</p>
<p class="cl">    try:</p>
<p class="cl">        # loop till there is no data to be read</p>
<p class="cl">      <!--<ccust1>1</ccust1>-->❶ while len(data) &gt; 0:</p>
<p class="cl">            # write stream to output</p>
<p class="cl">          <!--<ccust1>2</ccust1>-->❷ stream.<span class="idx" data-level1="write" data-term="PyAudio module"/>write(data)</p>
<p class="cl">            # ensure enough samples for FFT</p>
<p class="cl">          <!--<ccust1>3</ccust1>-->❸ if len(buf) == N:</p>
<p class="cl">              <!--<ccust1>4</ccust1>-->❹ buf = np.<span class="idx" data-level1="frombuffer" data-term="numpy module"/>frombuffer(data, dtype=np.int16)</p>
<p class="cl">                # do FFT</p>
<p class="cl">              <!--<ccust1>5</ccust1>-->❺ fft = np.fft.<span class="idx" data-level1="fft" data-level2="rfft" data-term="numpy module"/>rfft(buf)</p>
<p class="cl">              <!--<ccust1>6</ccust1>-->❻ fft = np.<span class="idx" data-level1="abs" data-term="numpy module"/>abs(fft) * 2.0/N</p>
<p class="cl"><span aria-label=" Page 298. " class="page" epub:type="pagebreak" id="p298" role="doc-pagebreak"/>                # calc levels</p>
<p class="cl">                # get average of 3 frequency bands</p>
<p class="cl">                # 0-100 Hz, 100-1000 Hz, and 1000-2500 Hz</p>
<p class="cl">              <!--<ccust1>7</ccust1>-->❼ levels = [np.<span class="idx" data-level1="sum" data-term="numpy module"/>sum(fft[0:100])/100,</p>
<p class="cl">                            np.sum(fft[100:1000])/900,</p>
<p class="cll">                            np.sum(fft[1000:2500])/1500]</p>
</div>
<p>The main loop repeats until <code>data</code> is empty <!--<ccust1>1</ccust1>-->❶, meaning you’ve gotten to the end of the WAV file. In the loop, you write the current chunk of data to the <code>pyaudio</code> output stream <!--<ccust1>2</ccust1>-->❷. This will allow you to hear the WAV file you’re processing at the same time that you’re driving the motors. Then you check whether you have <code>N</code> samples in the current chunk of data to calculate the FFT <!--<ccust1>3</ccust1>-->❸ (you set <code>N</code> to <code>2048</code>, the same as the chunk size, at the start of the code). This check is required because the last chunk of data read in may not have the full number of samples needed for the FFT. In that case, you’ll simply skip calculating the FFT and updating the motors, since the audio file is basically over anyway.</p>
<p>Next, you load the audio data into a <code>numpy</code> array of 16-bit integers <!--<ccust1>4</ccust1>-->❹. With the data in this format, computing the FFT is quite straightforward: you simply use the <code>rfft()</code> method from the <code>numpy.fft</code> module <!--<ccust1>5</ccust1>-->❺. This method takes a signal composed of <i>real numbers</i> (like the audio data) and computes the FFT, which generally results in a set of <span class="idx" data-term="complex"/><i>complex numbers</i>. You want to keep working with real numbers, however, so you use the <code>abs()</code> method to get the magnitudes of these complex numbers, which are real <!--<ccust1>6</ccust1>-->❻. The <code>2.0/N</code> is a normalization factor you use to map the FFT values to the expected range.</p>
<p>Continuing the loop, you extract the relevant information from the FFT to control the motors. To analyze the audio signal, you split the frequency range into three bands: 0 to 100 Hz (bass), 100 to 1,000 Hz (midrange), and 1,000 to 2,500 Hz (treble). You’re especially interested in the bass and midrange frequency bands, which roughly correspond to the beat and the vocals in a song, respectively. You compute the average amplitude value of the frequencies in each band by using the <code>numpy.</code><span class="idx" data-level1="sum" data-term="numpy module"/><code>sum()</code> method and dividing the result by the number of frequencies in that band <!--<ccust1>7</ccust1>-->❼. You store the three averages in a Python list.</p>
<p>Notice that you’re doing two different things in the <code>while</code> loop: sending audio to the output and computing the FFT of the same audio. You’re able to do this and maintain the audio output because the <code>numpy</code> FFT computation is fast enough—it finishes before the current chunk of audio data has finished playing. Try an experiment: put a time delay right after FFT, and see what happens to the sound output!</p>
<p>Now you need to convert the average amplitudes from the FFT into motor speeds and directions, still within the <code>while</code> loop started in the previous listing. The speeds need to be percentages, while the directions need to be <code>True/False</code> values.</p>
<div class="codeline">
<p class="clf">                # speed1</p>
<p class="cl">              <!--<ccust1>1</ccust1>-->❶ dca = int(5*levels[0])  percent 60</p>
<p class="cl">                # speed2</p>
<p class="cl"><span aria-label=" Page 299. " class="page" epub:type="pagebreak" id="p299" role="doc-pagebreak"/>              <!--<ccust1>2</ccust1>-->❷ dcb = int(100 + levels[1])  percent 60</p>
<p class="cl">                # dir</p>
<p class="cl">                dira = False</p>
<p class="cl">                dirb = True</p>
<p class="cl">              <!--<ccust1>3</ccust1>-->❸ if levels[2] &gt; 0.1:</p>
<p class="cl">                    dira = True</p>
<p class="cl">                # set motor direction and speed</p>
<p class="cll">              <!--<ccust1>4</ccust1>-->❹ set_motor_speed_dir(dca, dcb, dira, dirb)</p>
</div>
<p>First you take the value from the lowest frequency band, scale it by a factor of <code>5</code>, convert it to an integer, and use the modulus operator (<code>percent</code>) to ensure that the value lies within the [0, 60] range <!--<ccust1>1</ccust1>-->❶. This value controls the speed of motor A. Then you add <code>100</code> to the value from the middle frequency band and again use the modulus operator to place it in the [0, 60] range <!--<ccust1>2</ccust1>-->❷. This value controls the speed of motor B.</p>
<p class="pcust1"><span class="ccust3">NOTE</span> It’s not a good idea to run the motors too fast at first, which is why this code limits the motors’ speeds to 60 percent. Once you’re confident the display is working, you can try increasing the speed threshold at <!--<ccust1>1</ccust1>-->❶ and <!--<ccust1>2</ccust1>-->❷.</p>
<p>By default, you set <code>dira</code> to <code>False</code> to run motor A in one direction, but you switch to the other direction if the value from the highest frequency band crosses above a threshold of <code>0.1</code> <!--<ccust1>3</ccust1>-->❸. Meanwhile, you keep motor B’s direction constant by setting <code>dirb</code> to <code>True</code>. Finally, you call your <code>set_motor_speed_dir()</code> function to run the motors at the speeds and directions you’ve calculated <!--<ccust1>4</ccust1>-->❹.</p>
<p class="pcust1"><span class="ccust3">NOTE</span> There’s no particularly elegant rule governing how you convert the FFT information to motor speeds and directions. The FFT values change constantly with the audio signal, so any method you come up with will change the laser pattern in response to the music. I arrived at the method described here through trial and error; I looked at FFT values while playing various types of music and chose calculations that produced a nice variety of patterns. I encourage you to play with the calculations and create your own conversions. There are no wrong answers here, as long as your method puts the motor speeds in the [0, 100] range (or less to avoid high speeds) and sets the directions to be <code>True</code> or <code>False</code>.</p>
<p>Here’s the remainder of the <code>process_audio()</code> function:</p>
<div class="codeline">
<p class="clf">            # read next</p>
<p class="cl">          <!--<ccust1>1</ccust1>-->❶ data = wf.readframes(CHUNK)</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ except BaseException as err:</p>
<p class="cl">        print("Unexpected {}, type={}".format(err, type(err)))</p>
<p class="cl">  <!--<ccust1>3</ccust1>-->❸ finally:</p>
<p class="cl">            print("Finally: Pyaudio clean up...")</p>
<p class="cl">            stream.<span class="idx" data-level1="stop_stream" data-term="PyAudio module"/>stop_stream()</p>
<p class="cl">            stream.<span class="idx" data-level1="close" data-term="PyAudio module"/>close()</p>
<p class="cl">            # stop motors</p>
<p class="cll">            stop_motors()</p>
</div>
<p><span aria-label=" Page 300. " class="page" epub:type="pagebreak" id="p300" role="doc-pagebreak"/>First you conclude the <code>while</code> loop by reading in the next chunk of audio data to be processed <!--<ccust1>1</ccust1>-->❶. Recall that the <code>while</code> loop unfolds inside a <code>try</code> block. The <code>except</code> block <!--<ccust1>2</ccust1>-->❷ catches any exceptions that may arise during the loop. For example, pressing <span class="sm">CTRL</span>-C while the program is running will throw an exception and halt the loop, as will any errors reading the data. You end by doing some cleanup in a <code>finally</code> block <!--<ccust1>3</ccust1>-->❸ that will execute whether or not any exceptions are thrown. In this block, you stop the <code>pyaudio</code> output stream and close it, and you call your <code>stop_motors()</code> function to stop the motors from spinning.</p>
</section>
<section>
<h3 class="bh" id="bh1509"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1509"><span class="idx" data-level1="testing the motors" data-term="laser audio"/>Testing the Motors</a></h3>
<p class="paft">For testing purposes, it would be useful to be able to manually set the speed and direction of the motors and view the resulting laser pattern. Here’s a <code>test_motors()</code> function that makes this possible:</p>
<div class="codeline">
<p class="clf">def test_motors():</p>
<p class="cl">    """test motors by manually setting speed and direction"""</p>
<p class="cl">    # turn laser on</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ laser_on(True)</p>
<p class="cl">    # start motors</p>
<p class="cl">  <!--<ccust1>2</ccust1>-->❷ start_motors()</p>
<p class="cl">    # read user input</p>
<p class="cl">    try:</p>
<p class="cl">        while True:</p>
<p class="cl">          <!--<ccust1>3</ccust1>-->❸ print("Enter dca dcb dira dirb (eg. 50 100 1 0):")</p>
<p class="cl">            # read input</p>
<p class="cl">            str_in = <span class="idx" data-term="input()"/>input()</p>
<p class="cl">            # parse values</p>
<p class="cl">          <!--<ccust1>4</ccust1>-->❹ vals = [int(val) for val in str_in.<span class="idx" data-level1="split" data-term="string module"/>split()]</p>
<p class="cl">            # sanity check</p>
<p class="cl">            if len(vals) == 4:</p>
<p class="cl">              <!--<ccust1>5</ccust1>-->❺ set_motor_speed_dir(vals[0], vals[1], vals[2], vals[3])</p>
<p class="cl">            else:</p>
<p class="cl">                print("Input error!")</p>
<p class="cl">    except:</p>
<p class="cl">        print("Exiting motor test!")</p>
<p class="cl">  <!--<ccust1>6</ccust1>-->❻ finally:</p>
<p class="cl">        # stop motors</p>
<p class="cl">        stop_motors()</p>
<p class="cl">        # turn laser off</p>
<p class="cll">        laser_on(False)</p>
</div>
<p>You begin by turning on the laser <!--<ccust1>1</ccust1>-->❶ and starting the motors <!--<ccust1>2</ccust1>-->❷. Then you enter a loop to get information from the user. The loop prompts the user to enter four integer values <!--<ccust1>3</ccust1>-->❸: <code>dca</code> and <code>dcb</code> are the duty cycles (speeds) for the motors (from 0 to 100), and <code>dira</code> and <code>dirb</code> are the motor directions (0 or 1). You wait for the input, and then parse it, using <code>split()</code> to divide the input string into separate strings based on whitespace and a list comprehension to convert each substring into an integer <!--<ccust1>4</ccust1>-->❹. After a sanity check to ensure that you did, in fact, get four numbers as input, you run the motors using the provided values <!--<ccust1>5</ccust1>-->❺.</p>
<p><span aria-label=" Page 301. " class="page" epub:type="pagebreak" id="p301" role="doc-pagebreak"/>This runs in a loop, so you can try inputting various speed and direction values to see the result. Since the <code>while</code> loop is placed inside a <code>try</code> block, pressing <span class="sm">CTRL</span>-C will throw an exception and exit from the test when you’re ready. Then, in the <code>finally</code> block <!--<ccust1>6</ccust1>-->❻, you stop the motors and turn the laser off.</p>
</section>
<section>
<h3 class="bh" id="bh1510"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh1510">Putting It All Together</a></h3>
<p class="paft">As usual, the <code>main()</code> function takes in command line arguments and sets the project in motion. Let’s look at the command line arguments first:</p>
<div class="codeline">
<p class="clf">def main():</p>
<p class="cl">    """main calling function"""</p>
<p class="cl">    # set up args parser</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ parser = argparse.<span class="idx" data-level1="ArgumentParser" data-term="argparse module"/>ArgumentParser(description="A laser audio display.")</p>
<p class="cl">    # add arguments</p>
<p class="cl">    parser.<span class="idx" data-level1="ArgumentParser" data-level2="add_argument" data-term="argparse module"/>add_argument('--test_laser', action='store_true', required=False)</p>
<p class="cl">    parser.add_argument('--test_motors', action='store_true', required=False)</p>
<p class="cl">    parser.add_argument('--wav_file', dest='wav_file', required=False)</p>
<p class="cll">    args = <code class="i">parser</code>.<span class="idx" data-level1="ArgumentParser" data-level2="parse_args" data-term="argparse module"/><code class="i">parse_args</code>()</p>
</div>
<p>Here you follow the familiar pattern of creating an <code>ArgumentParser</code> object to parse command line arguments for the program <!--<ccust1>1</ccust1>-->❶. The program will support three different command line arguments. The <code>--test_laser</code> option just turns the laser on and is useful when you’re building the motor and laser assembly. The <code>--test_motors</code> option is for testing the motors, and the <code>--wav_file</code> option lets you specify the WAV file to be read in for the laser audio display.</p>
<p>Here’s the rest of the <code>main()</code> function:</p>
<div class="codeline">
<p class="clf">    # initialize pins</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ init_pins()</p>
<p class="clf">    # main loop</p>
<p class="cl">    try:</p>
<p class="cl">      <!--<ccust1>2</ccust1>-->❷ if args.test_laser:</p>
<p class="cl">            print("laser on...")</p>
<p class="cl">            laser_on(True)</p>
<p class="cl">            try:</p>
<p class="cl">                # wait in a loop</p>
<p class="cl">                while True:</p>
<p class="cl">                    time.<span class="idx" data-level1="sleep" data-term="time module"/>sleep(0.1)</p>
<p class="cl">            except:</p>
<p class="cl">                # turn laser off</p>
<p class="cl">                laser_on(False)</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ elif args.test_motors:</p>
<p class="cl">            print("testing motors...")</p>
<p class="cl">            test_motors()</p>
<p class="cl">      <!--<ccust1>4</ccust1>-->❹ elif args.wav_file:</p>
<p class="cl">            print("starting laser audio display...")</p>
<p class="cl">            process_audio(args.wav_file)</p>
<p class="cl">    except (Exception) as e:</p>
<p class="cl"><span aria-label=" Page 302. " class="page" epub:type="pagebreak" id="p302" role="doc-pagebreak"/>        print("Exception: {}".format(e))</p>
<p class="cl">        print("Exiting.")</p>
<p class="clf">    # turn laser off</p>
<p class="cl">  <!--<ccust1>5</ccust1>-->❺ laser_on(False)</p>
<p class="cl">    # call at the end</p>
<p class="clf">  <!--<ccust1>6</ccust1>-->❻ GPIO.cleanup()</p>
<p class="cll">    print("Done.")</p>
</div>
<p>You call the <code>init_pins()</code> function you defined earlier to initialize the Raspberry Pi’s GPIO pins <!--<ccust1>1</ccust1>-->❶. Next, you go through and process the command line arguments. If the user typed in the <code>--test_laser</code> argument, <code>args.test_laser</code> will be set to <code>True</code>. You handle this case by turning on the laser and waiting for the user to press <span class="sm">CTRL</span>-C to terminate the loop <!--<ccust1>2</ccust1>-->❷. Similarly, you handle the <code>--test_motors</code> option by calling <code>test_motors()</code> <!--<ccust1>3</ccust1>-->❸. To start the laser audio display, the user needs to use the <code>--wav_file</code> command line argument. In this case <!--<ccust1>4</ccust1>-->❹, you call the <code>process_audio()</code> function. Once again, all this is embedded in a <code>try</code> block, so when the user presses <span class="sm">CTRL</span>-C, you break out of the loop for any of the three modes. To finish, you turn the laser off <!--<ccust1>5</ccust1>-->❺ and do a GPIO cleanup <!--<ccust1>6</ccust1>-->❻ before exiting the program.</p>
</section>
</section>
<section>
<h2 class="ah" id="ah1504"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1504">Running the Laser Display</a></h2>
<p class="paft"><span class="idx" data-level1="running the code" data-term="laser audio"/>To test the project, assemble the hardware, make sure the battery pack is connected, and position everything so the laser is projecting onto a flat surface such as a wall. Then use SSH to log in to your Raspberry Pi as discussed in <a class="xref" href="nsp-venkitachalam503045-0032.xhtml#appb">Appendix B</a> and run the program from a shell. I recommend testing the laser display part first by running the program in test mode.</p>
<p class="pcust1"><span class="ccust3">WARNING</span> The project has high-speed spinning mirrors. Please wear appropriate eye protection or cover the setup with a transparent box before running the program to avoid injuries.</p>
<p><span class="idx" data-level1="test run" data-term="laser audio"/>Here’s a sample run of the test mode:</p>
<div class="codeline">
<p class="clf">$ <code class="b">python laser_audio.py --test_motors</code></p>
<p class="cl">testing motors...</p>
<p class="cl">Enter dca dcb dira dirb (eg. 50 100 1 0):</p>
<p class="cl"><code class="b">30 40 0 1</code></p>
<p class="cl">Enter dca dcb dira dirb (eg. 50 100 1 0):</p>
<p class="cll"><code class="b">40 30 1 0</code></p>
</div>
<p>You can use this test to run both motors through various combinations of speeds and directions. You should see different laser patterns projected onto your wall as you change the values. To stop the program and the motors, press <span class="sm">CTRL</span>-C. Note that if you enter duty cycle (speed) values greater than 80, the motors will spin really fast. Be careful!</p>
<p>If the test succeeds, you’re ready to move on to the real show. Copy a WAV file of your favorite music to the Raspberry Pi. Remember that to keep <span aria-label=" Page 303. " class="page" epub:type="pagebreak" id="p303" role="doc-pagebreak"/>things simple, the program accepts only single-channel WAV files in 16-bit format. You can convert any audio file to this format using the free software Audacity. (A sample file is also available in the project’s GitHub repository.) When the audio file is in place, run the program as follows, substituting your desired filename after the <code>--wave_file</code> option:</p>
<div class="codeline">
<p class="cls"><span class="idx" data-level1="running" data-term="laser audio"/><code class="b">python3 laser_audio.py --wav_file bensound-allthat-16.wav</code></p>
</div>
<p>You should see the laser display produce lots of interesting patterns that change in time with the music, as shown in <a class="xref" href="nsp-venkitachalam503045-0028.xhtml#fig13-14">Figure 13-14</a>.</p>
<figure class="figure" id="fig13-14">
<p class="fig"><img alt="" height="822" src="images/nsp-venkitachalam503045-f13014.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 13-14:</span> <span class="idx" data-level1="display" data-term="laser audio"/>The complete wiring of the laser display and a pattern projected on the wall</p>
</figcaption>
</figure>
<p>Try experimenting with different WAV files, or with different calculations for converting the FFT information to motor settings, to see how the visualization responds.</p>
</section>
<section>
<h2 class="ah" id="ah1505"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1505">Summary</a></h2>
<p class="paft">In this chapter, you upped your Python and hardware skills by building a fairly complex project. You learned how to control motors with Python, a Raspberry Pi, and a motor driver. You used <code>numpy</code> to compute the FFT of audio data, and you used <code>pyaudio</code> to stream audio output in real time. You even learned to control a laser using a MOSFET!</p>
</section>
<section>
<h2 class="ah" id="ah1506"><span aria-label=" Page 304. " class="page" epub:type="pagebreak" id="p304" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1506">Experiments!</a></h2>
<p class="paft">Here are some ways you can modify this project:</p>
<ol style="list-style-type:none">
<li class="nlf">1. The program used an arbitrary scheme to convert the FFT values into motor speed and direction data. Try changing this scheme. For example, experiment with different frequency bands and criteria for changing motor directions.</li>
<li class="nl">2. In this project, you converted frequency information gathered from the audio signal into motor speed and direction settings. Try making the motors move according to the overall “pulse” or volume of the music instead. For this, you can compute the <span class="idx" data-term="root mean square"/><i>root</i><span class="idx" data-term="RMS"/> <i>mean square (RMS)</i> value of the amplitude of the signal. This computation is similar to the FFT calculation. Once you read in a chunk of audio data and put it into a <code>numpy</code> array <code>x</code>, you can compute the RMS value as follows:
            <div class="codeline">
<p class="cl3s">rms = np.sqrt(np.mean(x**2))</p>
</div>
<p class="nlp">Also, remember that the amplitude in your project was expressed as a 16-bit signed integer, which can have a maximum value of 32,768 (a useful number to keep in mind for normalization). Use this RMS amplitude in conjunction with the FFT to generate a greater variation of laser patterns.</p>
</li>
<li class="nl">3. You know now that the frequency content, and hence the FFT of the audio data, changes in sync with the audio. Can you create a real-time visualization like the one shown in <a class="xref" href="nsp-venkitachalam503045-0028.xhtml#fig13-15">Figure 13-15</a>, of both the audio data and the FFT as the audio plays through a speaker? This is intended to run on your computer, not your Raspberry Pi.
            <figure class="figure" id="fig13-15">
<p class="fig"><img alt="" height="564" src="images/nsp-venkitachalam503045-f13015.jpg" style="width:95%; height:auto;" width="989"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 13-15:</span> A real-time FFT visualization</p>
</figcaption>
</figure>
<p class="nlp"><span aria-label=" Page 305. " class="page" epub:type="pagebreak" id="p305" role="doc-pagebreak"/>Here are a few hints to solve this problem:</p>
<ul style="list-style-type:none">
<li class="bl1">◦ Use <code>matplotlib</code> for plotting.</li>
<li class="bl1">◦ Use Python’s <span class="idx" data-term="multiprocessing module"/><code>multiprocessing</code> package so your music streaming output and plotting can happen simultaneously.</li>
<li class="bl1l">◦ Use the <code>numpy.fft.</code><span class="idx" data-level1="fft" data-level2="rfftfreq" data-term="numpy module"/><code>rfftfreq()</code> method to get the frequencies corresponding to the FFT values, for ease of plotting.
              </li>
</ul>
<p class="nlp">(The solution code for this experiment is in the book’s GitHub repository, but give it a shot yourself first!)</p>
</li>
</ol>
</section>
<section>
<h2 class="ah" id="ah1507"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah1507">The Complete Code</a></h2>
<p class="paft"><span class="idx" data-level1="complete code" data-term="laser audio"/>Here’s the complete Python code for this project:</p>
<div class="codeline">
<p class="clf">"""</p>
<p class="cl">laser_audio.py</p>
<p class="clf">Creates a laser display that changes in time to music.</p>
<p class="cl">Uses Python on a Raspberry Pi.</p>
<p class="clf">Author: Mahesh Venkitachalam</p>
<p class="cl">"""</p>
<p class="clf">import RPi.GPIO as GPIO</p>
<p class="cl">import time</p>
<p class="cl">import argparse</p>
<p class="cl">import pyaudio</p>
<p class="cl">import wave</p>
<p class="cl">import numpy as np</p>
<p class="clf"># define pin numbers</p>
<p class="cl"># uses TB6612FNG motor driver pin naming</p>
<p class="cl">PWMA = 12</p>
<p class="cl">PWMB = 13</p>
<p class="cl">AIN1 = 7</p>
<p class="cl">AIN2 = 8</p>
<p class="cl">BIN1 = 5</p>
<p class="cl">BIN2 = 6</p>
<p class="cl">STBY = 22</p>
<p class="cl">LASER = 25</p>
<p class="clf"># global PWM objects</p>
<p class="cl">pwm_a = None</p>
<p class="cl">pwm_b = None</p>
<p class="clf"># size of audio data read in</p>
<p class="cl">CHUNK = 2048</p>
<p class="cl"># FFT size</p>
<p class="cl">N = CHUNK</p>
<p class="clf">def init_pins():</p>
<p class="cl">    """set up pins"""</p>
<p class="cl"><span aria-label=" Page 306. " class="page" epub:type="pagebreak" id="p306" role="doc-pagebreak"/>    global pwm_a, pwm_b</p>
<p class="clf">    # use BCM pin numbering</p>
<p class="cl">    GPIO.setmode(GPIO.BCM)</p>
<p class="clf">    # put pins into a list</p>
<p class="cl">    pins = [PWMA, PWMB, AIN1, AIN2, BIN1, BIN2, STBY, LASER]</p>
<p class="clf">    # set up pins as outputs</p>
<p class="cl">    GPIO.setup(pins, GPIO.OUT)</p>
<p class="clf">    # set PWM</p>
<p class="cl">    pwm_a = GPIO.PWM(PWMA, 100)</p>
<p class="cl">    pwm_b = GPIO.PWM(PWMB, 100)</p>
<p class="clf">def laser_on(on):</p>
<p class="cl">    """turn laser MOSFET on/off"""</p>
<p class="cl">    # pin 25 controls laser ctrl mosfet</p>
<p class="cl">    GPIO.output(LASER, on)</p>
<p class="clf">def test_motors():</p>
<p class="cl">    """test motors by manually setting speed and direction"""</p>
<p class="cl">    # turn laser on</p>
<p class="cl">    laser_on(True)</p>
<p class="clf">    # start motors</p>
<p class="cl">    start_motors()</p>
<p class="clf">    # read user input</p>
<p class="cl">    try:</p>
<p class="cl">        while True:</p>
<p class="cl">            print("Enter dca dcb dira dirb (eg. 50 100 1 0):")</p>
<p class="cl">            # read input</p>
<p class="cl">            str_in = input()</p>
<p class="cl">            # parse values</p>
<p class="cl">            vals = [int(val) for val in str_in.split()]</p>
<p class="cl">            # sanity check</p>
<p class="cl">            if len(vals) == 4:</p>
<p class="cl">                set_motor_speed_dir(vals[0], vals[1], vals[2], vals[3])</p>
<p class="cl">            else:</p>
<p class="cl">                print("Input error!")</p>
<p class="cl">    except:</p>
<p class="cl">        print("Exiting motor test!")</p>
<p class="cl">    finally:</p>
<p class="cl">        # stop motors</p>
<p class="cl">        stop_motors()</p>
<p class="cl">        # turn laser off</p>
<p class="cl">        laser_on(False)</p>
<p class="clf">def start_motors():</p>
<p class="cl">    """start both motors"""</p>
<p class="cl">    # enable driver chip</p>
<p class="cl">    GPIO.output(STBY, GPIO.HIGH)</p>
<p class="cl">    # set motor direction for channel A</p>
<p class="cl">    GPIO.output(AIN1, GPIO.HIGH)</p>
<p class="cl"><span aria-label=" Page 307. " class="page" epub:type="pagebreak" id="p307" role="doc-pagebreak"/>    GPIO.output(AIN2, GPIO.LOW)</p>
<p class="cl">    # set motor direction for channel B</p>
<p class="cl">    GPIO.output(BIN1, GPIO.HIGH)</p>
<p class="cl">    GPIO.output(BIN2, GPIO.LOW)</p>
<p class="cl">    # set PWM for channel A</p>
<p class="cl">    duty_cycle = 0</p>
<p class="cl">    pwm_a.start(duty_cycle)</p>
<p class="cl">    # set PWM for channel B</p>
<p class="cl">    pwm_b.start(duty_cycle)</p>
<p class="clf">def stop_motors():</p>
<p class="cl">    """stop both motors"""</p>
<p class="cl">    # stop PWM</p>
<p class="cl">    pwm_a.stop()</p>
<p class="cl">    pwm_b.stop()</p>
<p class="cl">    # brake A</p>
<p class="cl">    GPIO.output(AIN1, GPIO.HIGH)</p>
<p class="cl">    GPIO.output(AIN2, GPIO.HIGH)</p>
<p class="cl">    # brake B</p>
<p class="cl">    GPIO.output(BIN1, GPIO.HIGH)</p>
<p class="cl">    GPIO.output(BIN2, GPIO.HIGH)</p>
<p class="cl">    # disable driver chip</p>
<p class="cl">    GPIO.output(STBY, GPIO.LOW)</p>
<p class="clf">def set_motor_speed_dir(dca, dcb, dira, dirb):</p>
<p class="cl">    """set speed and direction of motors"""</p>
<p class="cl">    # set duty cycle</p>
<p class="cl">    pwm_a.ChangeDutyCycle(dca)</p>
<p class="cl">    pwm_b.ChangeDutyCycle(dcb)</p>
<p class="cl">    # set direction A</p>
<p class="cl">    if dira:</p>
<p class="cl">        GPIO.output(AIN1, GPIO.HIGH)</p>
<p class="cl">        GPIO.output(AIN2, GPIO.LOW)</p>
<p class="cl">    else:</p>
<p class="cl">        GPIO.output(AIN1, GPIO.LOW)</p>
<p class="cl">        GPIO.output(AIN2, GPIO.HIGH)</p>
<p class="cl">    if dirb:</p>
<p class="cl">        GPIO.output(BIN1, GPIO.HIGH)</p>
<p class="cl">        GPIO.output(BIN2, GPIO.LOW)</p>
<p class="cl">    else:</p>
<p class="cl">        GPIO.output(BIN1, GPIO.LOW)</p>
<p class="cl">        GPIO.output(BIN2, GPIO.HIGH)</p>
<p class="clf">def process_audio(filename):</p>
<p class="cl">    """reads WAV file, does FFT and controls motors"""</p>
<p class="clf">    print("opening {}...".format(filename))</p>
<p class="clf">    # open WAV file</p>
<p class="cl">    wf = wave.open(filename, 'rb')</p>
<p class="clf">    # print audio details</p>
<p class="cl">    print("SW = {}, NCh = {}, SR = {}".format(wf.getsampwidth(),</p>
<p class="cl">        wf.getnchannels(), wf.getframerate()))</p>
<p class="clf"><span aria-label=" Page 308. " class="page" epub:type="pagebreak" id="p308" role="doc-pagebreak"/>    # check for supported format</p>
<p class="cl">    if wf.getsampwidth() != 2 or wf.getnchannels() != 1:</p>
<p class="cl">        print("Only single channel 16 bit WAV files are supported!")</p>
<p class="cl">        wf.close()</p>
<p class="cl">        return</p>
<p class="clf">    # create PyAudio object</p>
<p class="cl">    p = pyaudio.PyAudio()</p>
<p class="clf">    # open an output stream</p>
<p class="cl">    stream = p.open(format=p.get_format_from_width(wf.getsampwidth()),</p>
<p class="cl">                    channels=wf.getnchannels(),</p>
<p class="cl">                    rate=wf.getframerate(),</p>
<p class="cl">                    output=True)</p>
<p class="clf">    # read first frame</p>
<p class="cl">    data = wf.readframes(CHUNK)</p>
<p class="cl">    buf = np.frombuffer(data, dtype=np.int16)</p>
<p class="clf">    # store sample rate</p>
<p class="cl">    SR = wf.getframerate()</p>
<p class="clf">    # start motors</p>
<p class="cl">    start_motors()</p>
<p class="clf">    # laser on</p>
<p class="cl">    laser_on(True)</p>
<p class="clf">    # read audio data from WAV file</p>
<p class="cl">    try:</p>
<p class="cl">        # loop till there is no data to be read</p>
<p class="cl">        while len(data) &gt; 0:</p>
<p class="cl">            # write stream to output</p>
<p class="cl">            stream.write(data)</p>
<p class="cl">            # ensure enough samples for FFT</p>
<p class="cl">            if len(buf) == N:</p>
<p class="cl">                buf = np.frombuffer(data, dtype=np.int16)</p>
<p class="cl">                # do FFT</p>
<p class="cl">                fft = np.fft.rfft(buf)</p>
<p class="cl">                fft = np.abs(fft) * 2.0/N</p>
<p class="cl">                # calc levels</p>
<p class="cl">                # get average of 3 frequency bands</p>
<p class="cl">                # 0-100 Hz, 100-1000 Hz, and 1000-2500 Hz</p>
<p class="cl">                levels = [np.sum(fft[0:100])/100,</p>
<p class="cl">                            np.sum(fft[100:1000])/900,</p>
<p class="cl">                            np.sum(fft[1000:2500])/1500]</p>
<p class="cl">                # speed1</p>
<p class="cl">                dca = int(5*levels[0])  percent 60</p>
<p class="cl">                # speed2</p>
<p class="cl">                dcb = int(100 + levels[1])  percent 60</p>
<p class="cl">                # dir</p>
<p class="cl">                dira = False</p>
<p class="cl">                dirb = True</p>
<p class="cl">                if levels[2] &gt; 0.1:</p>
<p class="cl">                    dira = True</p>
<p class="cl"><span aria-label=" Page 309. " class="page" epub:type="pagebreak" id="p309" role="doc-pagebreak"/>                # set motor direction and speed</p>
<p class="cl">                set_motor_speed_dir(dca, dcb, dira, dirb)</p>
<p class="cl">            # read next</p>
<p class="cl">            data = wf.readframes(CHUNK)</p>
<p class="clf">    except BaseException as err:</p>
<p class="cl">        print("Unexpected {}, type={}".format(err, type(err)))</p>
<p class="clf">    finally:</p>
<p class="cl">            print("Finally: Pyaudio clean up...")</p>
<p class="cl">            stream.stop_stream()</p>
<p class="cl">            stream.close()</p>
<p class="cl">            # stop motors</p>
<p class="cl">            stop_motors()</p>
<p class="cl">            # close WAV file</p>
<p class="cl">            wf.close()</p>
<p class="clf">def main():</p>
<p class="cl">    """main calling function"""</p>
<p class="clf">    # set up args parser</p>
<p class="cl">    parser = argparse.ArgumentParser(description="A laser audio display.")</p>
<p class="cl">    # add arguments</p>
<p class="cl">    parser.add_argument('--test_laser', action='store_true', required=False)</p>
<p class="cl">    parser.add_argument('--test_motors', action='store_true', required=False)</p>
<p class="cl">    parser.add_argument('--wav_file', dest='wav_file', required=False)</p>
<p class="cl">    args = parser.parse_args()</p>
<p class="clf">    # initialize pins</p>
<p class="cl">    init_pins()</p>
<p class="clf">    # main loop</p>
<p class="cl">    try:</p>
<p class="cl">        if args.test_laser:</p>
<p class="cl">            print("laser on...")</p>
<p class="cl">            laser_on(True)</p>
<p class="cl">            try:</p>
<p class="cl">                # wait in a loop</p>
<p class="cl">                while True:</p>
<p class="cl">                    time.sleep(1)</p>
<p class="cl">            except:</p>
<p class="cl">                # turn laser off</p>
<p class="cl">                laser_on(False)</p>
<p class="cl">        elif args.test_motors:</p>
<p class="cl">            print("testing motors...")</p>
<p class="cl">            test_motors()</p>
<p class="cl">        elif args.wav_file:</p>
<p class="cl">            print("starting laser audio display...")</p>
<p class="cl">            process_audio(args.wav_file)</p>
<p class="cl">    except (Exception) as e:</p>
<p class="cl">        print("Exception: {}".format(e))</p>
<p class="cl">        print("Exiting.")</p>
<p class="clf">    # turn laser off</p>
<p class="cl">    laser_on(False)</p>
<p class="clf"><span aria-label=" Page 310. " class="page" epub:type="pagebreak" id="p310" role="doc-pagebreak"/>    # call at the end</p>
<p class="cl">    GPIO.cleanup()</p>
<p class="cl">    print("Done.")</p>
<p class="clf"># call main</p>
<p class="cl">if __name__ == '__main__':</p>
<p class="cl">    main()</p>
</div>
</section>
</section>
</div></body></html>