- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Functions and Lambdas
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数与 Lambda
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Functions are one of the most elementary concepts in programming, yet Python
    packs a surprising amount of versatility into them. You’ll recall from Chapter
    3 that functions are first-class objects, so they are treated no differently from
    any other object. This fact, combined with the power of dynamic typing, opens
    up so many possibilities.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是编程中最基本的概念之一，但 Python 在其中融合了出人意料的多种功能。你还记得第三章中提到的函数是第一类对象，所以它们与其他任何对象没有区别。这个事实，再加上动态类型的强大功能，打开了无数的可能性。
- en: Python has full support for *functional programming*, a distinct paradigm from
    which we get those “lambdas,” or anonymous functions, you keep reading about online.
    If you’re used to languages like Haskell or Scala, a lot of the concepts in this
    chapter are going to seem familiar to you. However, if you’re more used to object-oriented
    programming, such as in Java or C++, this may be the first time you’ve encountered
    many of these concepts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Python 完全支持*函数式编程*，这是一种不同的编程范式，我们从中得到了你在线上经常看到的“lambda”或匿名函数。如果你习惯于像 Haskell
    或 Scala 这样的语言，本章中的许多概念对你来说应该会非常熟悉。然而，如果你更习惯于面向对象编程，比如 Java 或 C++，那么这可能是你第一次接触到这些概念。
- en: When learning Python, it makes sense to dive into functional programming early
    on. It is perfectly possible to write idiomatic Python code without ever creating
    a single class (see Chapter 7). By contrast, functions and functional programming
    concepts underpin much of the language’s most powerful features.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习 Python 时，尽早深入函数式编程是很有意义的。完全可以编写符合 Python 风格的代码，而不需要创建任何类（参见第七章）。相反，函数和函数式编程概念支撑了该语言许多强大特性的基础。
- en: Python Function Essentials
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 函数基础
- en: I briefly touched on functions in Chapter 3. Building on that knowledge, I’ll
    gradually construct a more complex example in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三章中，我简要介绍了函数。在本章中，我将在此基础上逐步构建一个更复杂的示例。
- en: 'I’ll start by creating a function that rolls a single die with a specified
    number of sides:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从创建一个掷单个骰子的函数开始，并指定骰子的面数：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 6-1: *dice_roll.py:1a*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-1: *dice_roll.py:1a*'
- en: I define a function named `roll_dice()`, which accepts a single parameter, `sides`.
    This function is considered pure, because it has no side effects; it accepts a
    value as an input and returns a new value as an output. I return a value from
    the function using the `return` keyword.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义了一个名为 `roll_dice()` 的函数，它接受一个参数 `sides`。这个函数被认为是纯粹的，因为它没有副作用；它接受一个输入值，并返回一个输出值。我使用
    `return` 关键字从函数返回一个值。
- en: The `random` module has a number of functions for producing random values. Here,
    I use its `random.randint()` function to generate a pseudorandom number in Python.
    I generate a random number between `1` and `20` (the value of `sides` in this
    example) inclusively, with `random.randint(1, 20)`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`random` 模块提供了多个用于生成随机值的函数。在这里，我使用它的 `random.randint()` 函数生成一个伪随机数。我生成一个介于
    `1` 和 `20` 之间的随机数（在这个示例中是 `sides` 的值），包括 `1` 和 `20`，使用 `random.randint(1, 20)`。'
- en: 'Here’s my usage for the function:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我对该函数的使用：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 6-2: *dice_roll.py:2a*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-2: *dice_roll.py:2a*'
- en: Later, I call the function and pass the value `20` as an argument ❶, so the
    function call is effectively the same as rolling a 20-sided die. The value that
    the first function call returns is bound to `player1`; the second call’s return
    is bound to `player2`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 后面，我调用这个函数并传递 `20` 作为参数 ❶，所以函数调用实际上等同于掷一个20面骰子。第一次函数调用返回的值绑定到 `player1`；第二次调用的返回值绑定到
    `player2`。
- en: Because I defined `roll_dice()` as a function, I can use it as many times as
    I want. If I want to change its behavior, I only need to modify the function in
    the one place where it is defined, and every usage of that function will be affected.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我将 `roll_dice()` 定义为函数，所以我可以根据需要多次调用它。如果我想改变它的行为，我只需在定义它的地方修改一次，该函数的每个调用都会受到影响。
- en: 'Say I wanted to roll multiple dice at once and return the results in a tuple.
    I can rewrite the `roll_dice()` function to do that:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我想同时掷多个骰子，并将结果以元组的形式返回。我可以重新编写 `roll_dice()` 函数来实现这一点：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Listing 6-3: *dice_roll.py:1b*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**Listing 6-3: *dice_roll.py:1b*'
- en: To allow rolling multiple dice, the function accepts a second parameter, `dice`,
    which represents the number of dice being rolled. The first parameter, `sides`,
    still represents the number of sides on any one of the dice.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持掷多个骰子，函数接受第二个参数 `dice`，表示掷骰子的数量。第一个参数 `sides` 仍然表示每个骰子的面数。
- en: The scary-looking line of code at the top of the function is a *generator expression*,
    which I’ll cover in Chapter 10. For now, you can take it for granted that I’m
    generating one random number for each die being rolled and packing the results
    in a tuple.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 函数顶部看起来可怕的那一行代码是一个*生成器表达式*，我将在第10章中讲解。现在，你可以放心地认为我正在为每个投掷的骰子生成一个随机数，并将结果打包成一个元组。
- en: 'Since my function now has a second parameter in the function call, I pass two
    arguments:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我的函数现在在函数调用中有第二个参数，我传递了两个参数：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 6-4: *dice_roll.py:2b*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-4：*dice_roll.py:2b*
- en: The returned tuple can be *unpacked*, meaning each item in the tuple is bound
    to a name I can use to access the value. The number of names listed on the left
    (separated by commas) and the number of values in the tuple *must* match for this
    to work, or else Python will raise an error. (See Chapter 9 for more on unpacking
    and tuples.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的元组可以*解包*，这意味着元组中的每个项都绑定到一个我可以用来访问值的名称。左侧列出的名称数量（由逗号分隔）和元组中的值数量*必须*匹配，才能正常工作，否则Python会引发错误。（有关解包和元组的更多内容，请参见第9章。）
- en: Recursion
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归
- en: '*Recursion* occurs when a function calls itself. This can be helpful when you
    need to repeat the entire logic of a function but a loop is unsuitable or feels
    too cluttered, as in the upcoming example.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*递归*发生在一个函数调用自身时。这在需要重复整个函数逻辑，但使用循环不合适或感觉过于杂乱时非常有用，如接下来的示例所示。'
- en: For example, returning to my dice-rolling function, I can accomplish the exact
    same result using recursion, instead of that generator expression I was using
    earlier (although in practice, the generator expression is usually considered
    more Pythonic).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，回到我的投骰子函数，我可以使用递归来实现完全相同的结果，而不是使用之前的生成器表达式（尽管在实际应用中，生成器表达式通常被认为是更符合Python风格的）。
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 6-5: *dice_roll_recursive.py:1a*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-5：*dice_roll_recursive.py:1a*
- en: I store the resulting roll for this function call in `roll`. Then, in the recursive
    call, I pass my `sides` parameter as is, while reducing the number of `dice` to
    roll by one, to account for the die I just rolled. Finally, I combine the tuple
    that is returned from that recursive function call with the result of the roll
    on this function call, and I return the resulting longer tuple.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这个函数调用的结果存储在`roll`中。然后，在递归调用中，我将`sides`参数按原样传递，同时将`dice`的数量减一，以考虑我刚刚投掷的骰子。最后，我将从递归函数调用返回的元组与此函数调用的投掷结果结合，并返回结果更长的元组。
- en: 'The usage is essentially the same as before:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法与之前基本相同：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 6-6: *dice_roll_recursive.py:2a*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-6：*dice_roll_recursive.py:2a*
- en: 'If you were to print out each value being returned, in order from deepest recursive
    call to outermost, here’s what you would see:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打印出每个返回的值，从最深的递归调用到最外层，你会看到以下内容：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 6-7: Returns from recursive calls to `roll_dice(6, 5)`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-7：来自递归调用`roll_dice(6, 5)`的返回值
- en: When the number of dice left is zero or negative, I return an empty tuple instead
    of recursively calling it again. If I don’t do that, the recursion will try to
    run forever. Thankfully, Python will pull the plug at some point and just crash
    the program, instead of letting it consume all your computer’s memory (as some
    other programming languages are apt to do). The *recursion depth* is how many
    recursive function calls have not returned yet, and Python caps it at approximately
    one thousand.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当剩余的骰子数量为零或负数时，我返回一个空元组，而不是再次递归调用。如果我不这么做，递归将试图无限运行。幸运的是，Python在某个时刻会切断程序并崩溃，而不是让它消耗掉计算机的所有内存（像某些其他编程语言那样容易发生）。*递归深度*是指还没有返回的递归函数调用的数量，Python将其限制在大约一千次。
- en: 'If the recursion depth goes any deeper than the limit, the entire program stops
    and raises an error:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果递归深度超过了限制，整个程序将停止并引发错误：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is why it’s so important that you build some means of stopping when you
    use recursion. In the `roll_dice` function, this stopping mechanism is at the
    very top of the function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在使用递归时，构建某种停止机制如此重要的原因。在`roll_dice`函数中，这个停止机制位于函数的最顶部：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since `dice` is getting decremented every time the function calls itself, sooner
    or later, it will reach zero. When it does, it returns an empty tuple, instead
    of producing another recursive call. Then, the rest of the recursive calls can
    finish running and return.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每次函数调用自身时，`dice`都会递减，迟早它会变为零。当它为零时，它将返回一个空元组，而不是产生另一个递归调用。然后，其他递归调用可以完成并返回。
- en: 'There may be cases in which a recursion depth of a thousand is not enough.
    If you need more, you can override the maximum:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有一些情况，递归深度达到一千次仍然不够。如果需要更多，可以覆盖最大深度：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `sys.setrecursionlimit()` function allows you to set a new maximum recursion
    depth. In this case, my new limit is `2000`. The benefit of this approach is that
    once you no longer need your limit, you can set it back to the default so it can
    keep *other* recursive calls from getting out of hand.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys.setrecursionlimit()` 函数允许你设置一个新的最大递归深度。在这种情况下，我的新限制是 `2000`。这种方法的好处在于，一旦你不再需要该限制，你可以将其恢复为默认值，以便*其他*递归调用不会失控。'
- en: Default Argument Values
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认参数值
- en: 'You might imagine that I would need to roll a single die far more often than
    any other option. As it stands right now, I would have to manually specify that
    I only want to roll one 20-sided die:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，我需要掷一个骰子的频率会远远高于任何其他选项。按现在的情况来看，我必须手动指定我只想掷一个20面骰子：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I have to manually pass a `1` as the second argument of `roll_dice` to specify
    that I’m rolling a single die.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须手动传递一个 `1` 作为 `roll_dice` 的第二个参数，以指定我只掷一个骰子。
- en: By the way, that trailing comma after `result` is how I unpack a single value
    from a single-item tuple, meaning the actual value of the only item in the tuple
    is now bound to `result`. (See Chapter 9 for more on unpacking.)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，`result` 后面的那个尾随逗号是用来从单项元组中解包单个值的，意思是元组中唯一项的实际值现在绑定到 `result` 上。（有关解包的更多信息，请参见第9章。）
- en: 'Since rolling a single die is likely the most common action I want to take
    with this function, I want to make it more convenient to use. I can use *default
    argument values* to accomplish this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于掷一个骰子可能是我使用这个函数时最常见的操作，我希望使它变得更加便捷。我可以使用*默认参数值*来实现这一点：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 6-8: *dice_roll.py:1c*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-8: *dice_roll.py:1c*'
- en: 'The `dice` parameter now has a default argument value of `1`. Thus, anytime
    I don’t specify the second argument, `dice` will use its default argument value.
    This makes it possible to use a simplified function call to roll a single six-sided
    die:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`dice` 参数现在有一个默认的参数值 `1`。因此，每当我没有指定第二个参数时，`dice` 将使用其默认参数值。这使得我能够使用简化的函数调用来掷一个六面骰子：'
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If I do want to roll multiple dice, I can still pass that second argument:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我确实想要掷多个骰子，我仍然可以传递第二个参数：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When you specify a default argument value for a parameter, you are defining
    an *optional parameter*. Conversely, a parameter with no default argument value
    is a *required parameter*. You can have as many of each as you like, but you must
    list all required parameters *before* your optional parameters. Otherwise, the
    code won’t run.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为一个参数指定默认参数值时，你是在定义一个*可选参数*。相反，没有默认参数值的参数是*必需参数*。你可以根据需要添加任意数量的每种类型的参数，但你必须在可选参数*之前*列出所有必需参数，否则代码将无法运行。
- en: 'When using optional parameters, there is one significant trap lurking in the
    dark: default argument values are only evaluated once, when the function is defined.
    One place where this gets treacherous is when you’re using any mutable data type,
    such as a list. Consider this code for generating values in a Fibonacci sequence,
    which doesn’t quite work as expected:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可选参数时，有一个显著的陷阱潜伏在黑暗中：默认参数值仅在函数定义时被评估一次。当你使用任何可变数据类型（例如列表）时，这个问题就会显现出来。考虑以下用于生成斐波那契数列的代码，但它并未按预期工作：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 6-9: *fibonacci.py:1a*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-9: *fibonacci.py:1a*'
- en: This is going to have a problem because the default argument value `[1, 1]`
    ❶ is evaluated when Python first processes the function definition, creating a
    single mutable list with the value `[1, 1]` in memory. That gets mutated on the
    first function call ❷ and then returned.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个会有问题，因为默认参数值 `[1, 1]` ❶ 会在 Python 首次处理函数定义时被评估，从而在内存中创建一个值为 `[1, 1]` 的单一可变列表。这个列表在第一次函数调用时会被修改
    ❷，然后返回。
- en: 'This usage of the function shows the problem:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的使用展示了问题：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 6-10: *fibonacci.py:2*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-10: *fibonacci.py:2*'
- en: Everything looks okay in the code, but it isn’t. `fib1` is now bound to the
    same mutable value as `series`, so any changes to `fib1` are reflected in the
    default argument value *for every function call*. The second function call mutates
    this list further.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来一切正常，但实际上并非如此。`fib1` 现在与 `series` 绑定到了相同的可变值，因此对 `fib1` 的任何修改都会反映到*每次函数调用*的默认参数值中。第二次函数调用会进一步修改这个列表。
- en: 'When I call `fibonacci_next()` a third time, I’m probably expecting to start
    with a clean slate, `[1, 1, 2]`, which would be the result of a single mutation
    on the original default argument value. Instead, I’m getting the value of that
    single mutable value I’ve been messing with this whole time: `fib2` is now a third
    alias to the list. Oops!'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第三次调用`fibonacci_next()`时，我可能期望从一个干净的起点`[1, 1, 2]`开始，这将是对原始默认参数值进行一次突变后的结果。相反，我得到了这个我一直在处理的单个可变值的值：`fib2`现在是该列表的第三个别名。哎呀！
- en: 'This becomes apparent when I examine the output. This is what I’d be expecting:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我检查输出时，这一点变得显而易见。这是我期望的结果：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'But this is what I actually get:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但这是我实际得到的结果：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In short, *never use mutable values for default argument values*. Instead,
    use `None` as a default value, as shown in the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，*绝不要使用可变值作为默认参数值*。相反，应使用`None`作为默认值，如下所示：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 6-11: *fibonacci.py:1b*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 6-11: *fibonacci.py:1b*'
- en: The proper way is to use `None` as the default argument value, and then to create
    a new mutable value if that default is being used.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的方法是使用`None`作为默认参数值，然后在使用该默认值时创建一个新的可变值。
- en: 'Running that same usage code as before ([Listing 6-9](#listing6-9)) now produces
    the expected output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 运行之前相同的使用代码（[示例 6-9](#listing6-9)）现在产生了预期的输出：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Keyword Arguments
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键字参数
- en: Readability matters. Unfortunately, function calls with multiple parameters
    aren’t always the most readable bits of code. *Keyword arguments* help resolve
    this by attaching labels to arguments in function calls.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性很重要。不幸的是，具有多个参数的函数调用并不总是最具可读性的代码部分。*关键字参数*通过为函数调用中的参数附加标签，帮助解决了这个问题。
- en: Arguments that are mapped to their parameters by the order you pass them in,
    like in all the prior examples, are called *positional arguments*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 按照你传递参数的顺序映射到参数的那些参数，像所有先前的示例一样，称为*位置参数*。
- en: If you knew nothing about the `roll_dice()` function from earlier and you encountered
    this line of code, what would you think it did?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对之前的`roll_dice()`函数一无所知，遇到这行代码时，你会认为它做了什么？
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 6-12: *dice_roll.py:3a*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 6-12: *dice_roll.py:3a*'
- en: You would probably guess that this is rolling multiple dice, and perhaps that
    it is specifying how many sides those dice have—but which is which? Is it rolling
    six five-sided dice or five six-sided dice? You can imagine how confusing this
    would be with even more arguments. This is the shortcoming of positional arguments.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会猜这是在投掷多个骰子，也许还会猜它在指定这些骰子有多少个面——但哪个是哪个呢？它是在投掷六个五面骰子，还是五个六面骰子？你可以想象，如果有更多的参数，情况会有多么令人困惑。这就是位置参数的缺点。
- en: 'As The Zen of Python says:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如《Python之禅》所说：
- en: In the face of ambiguity, refuse the temptation to guess.
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 面对歧义时，拒绝猜测的诱惑。
- en: 'It can’t be good, then, to force the reader to guess. I can eliminate the ambiguity
    by using *keyword arguments*. I don’t need to change the function definition at
    all to be able to use keyword arguments. I only need to change my function call:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，强迫读者猜测肯定不好。我可以通过使用*关键字参数*来消除歧义。我不需要更改函数定义就能使用关键字参数。我只需要更改我的函数调用：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 6-13: *dice_roll.py:3b*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 6-13: *dice_roll.py:3b*'
- en: 'Each of those names comes from the earlier function definition of `roll_dice`,
    where I specified it had two parameters: `sides` and `dice`. In my function call,
    I can assign values directly to those parameters by name. Now, there is no question
    about what each argument does. Specify the name of the parameter, matching what
    is in the function definition, and then assign the desired value directly to it.
    That’s all.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称都来自于之前`roll_dice`函数的定义，其中我指定了两个参数：`sides`和`dice`。在我的函数调用中，我可以通过名称直接为这些参数赋值。现在，每个参数的作用都没有疑问。指定参数的名称，与函数定义中的名称相匹配，然后直接将所需的值赋给它。就这样。
- en: 'When using keyword arguments, you don’t even have to list them in order, just
    as long as all the required parameters receive values:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关键字参数时，你甚至不需要按顺序列出它们，只要所有必需的参数都能获得值即可：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 6-14: *dice_roll.py:3c*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 6-14: *dice_roll.py:3c*'
- en: 'This can be even more helpful when you have multiple optional parameters on
    the function. Consider if I rewrote `roll_dice()` so that the dice being rolled
    were six sided, by default:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数有多个可选参数时，这尤其有帮助。考虑如果我重新编写`roll_dice()`，使得骰子的面数默认为六面：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 6-15: *dice_roll.py:1d*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 6-15: *dice_roll.py:1d*'
- en: 'Keyword arguments allow you to simplify your function calls even further:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数可以让你进一步简化函数调用：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 6-16: *dice_roll.py:3d*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 6-16: *dice_roll.py:3d*'
- en: You’re only passing a value to one of the optional arguments, `dice`. For the
    other one, `sides`, the default value is used. It no longer needs to matter whether
    `sides` or `dice` appears first in the function’s parameter list; you can just
    use the ones you want and leave the rest alone.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你只向一个可选参数 `dice` 传递了值。对于另一个参数 `sides`，将使用默认值。现在，不再需要关心 `sides` 或 `dice` 在函数参数列表中出现的顺序；你只需使用你想要的参数，剩下的保持默认即可。
- en: 'It is even possible to mix and match positional arguments and keyword arguments:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以将位置参数和关键字参数混合使用：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 6-17: *dice_roll.py:3e*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-17：*dice_roll.py:3e*
- en: Here, `6` is passed as a positional argument to the first parameter in the function
    definition, `sides`. Then, I pass `5` as a keyword argument to the parameter `dice`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`6` 作为位置参数传递给函数定义中的第一个参数 `sides`。然后，我将 `5` 作为关键字参数传递给 `dice` 参数。
- en: This can come in handy, particularly when you don’t want to bother with naming
    the positional arguments but you still want to use one of many possible optional
    parameters. The only rule here is that your keyword arguments must come after
    your positional arguments in the function call. (See also the section “Keyword-Only
    Parameters” later in the chapter.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式特别有用，尤其是在你不想麻烦地命名位置参数，但仍然想使用多个可能的可选参数时。唯一的规则是，在函数调用中，关键字参数必须放在位置参数之后。（请参阅本章稍后的“仅限关键字参数”部分。）
- en: On Overloaded Functions
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于重载函数
- en: If you’re coming from a strictly typed language such as Java or C++, you’re
    probably used to writing *overloaded functions*, wherein you can write multiple
    functions with the same name but different parameters. Typically, overloaded functions
    in languages that support them provide a consistent interface (function name),
    while supporting arguments of different types.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自像 Java 或 C++ 这样的强类型语言，你可能习惯于编写 *重载函数*，在其中你可以写多个具有相同名称但不同参数的函数。通常，支持重载的语言中的重载函数会提供一致的接口（函数名称），同时支持不同类型的参数。
- en: Python usually doesn’t need overloaded functions. Using dynamic typing, duck
    typing, and optional parameters, you can write single functions that handle all
    the input scenarios you need to throw at Python.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Python 通常不需要重载函数。通过使用动态类型、鸭子类型和可选参数，你可以编写单一函数，处理所有传递给 Python 的输入场景。
- en: If you really, really need overloaded functions—and you probably don’t—you actually
    can create them with *single-dispatch functions*. I’ll cover this in Chapter 15.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的非常需要重载函数——而你可能并不需要——你实际上可以通过 *单一分派函数* 来创建它们。我将在第 15 章详细介绍这一点。
- en: Variadic Arguments
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变参
- en: With the skills discussed so far, even while using optional parameters, you
    still have to anticipate how many arguments can potentially get passed to your
    function. This is fine in most cases, but sometimes, you’ll have no idea how many
    to expect.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止讨论的技巧，即使在使用可选参数时，你仍然需要预估有多少个参数可能会传递给你的函数。大多数情况下，这没问题，但有时你根本不知道应该预期多少个。
- en: To solve this, your first instinct might be to pack all the arguments into a
    single tuple or a list. That works in some situations, but other times, it can
    become an extra inconvenience when calling the function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你的第一个直觉可能是将所有的参数打包成一个元组或列表。这在某些情况下是可行的，但在其他时候，调用函数时这可能会变成一种额外的不便。
- en: 'A better solution is to use *arbitrary arguments lists*, also called *variadic
    arguments*, which automatically pack multiple arguments into a single *variadic
    parameter* or *variadic positional parameter*. In the dice-rolling function, I
    want to allow the rolling of multiple dice, where each die may have a different
    number of sides:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案是使用 *任意参数列表*，也称为 *变参*，它会自动将多个参数打包成一个 *变参参数* 或 *变位置参数*。在掷骰子函数中，我希望允许掷多个骰子，每个骰子可能有不同的面数：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 6-18: *dice_roll_variadic.py:1a*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-18：*dice_roll_variadic.py:1a*
- en: I turn the parameter `dice` into a variadic parameter by preceding it with a
    single asterisk (`*`). All the arguments passed to `roll_dice` will now be packed
    into a tuple, bound to the name `dice`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过在参数 `dice` 前加一个星号（`*`）将其变成一个变参。所有传递给 `roll_dice` 的参数现在都会被打包成一个元组，并绑定到 `dice`
    名字上。
- en: Within the function, I can use this tuple in the usual manner. In this case,
    I’m using a generator expression (see Chapter 10) to roll each die specified in
    `dice`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，我可以像往常一样使用这个元组。在这种情况下，我正在使用生成器表达式（见第 10 章）来掷 `dice` 中指定的每个骰子。
- en: 'The placement of the variadic parameter is important: it must come *after*
    any positional parameters in the function definition. Any parameters I list after
    it will only be usable as keyword arguments, because the variadic parameter consumes
    all the remaining positional arguments.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 变长参数的位置很重要：它必须出现在函数定义中的所有位置参数*之后*。我在它后面列出的任何参数都只能作为关键字参数使用，因为变长参数会消耗掉所有剩余的定位参数。
- en: 'Here’s my usage:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的用法：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 6-19: *dice_roll_variadic.py:2*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 6-19: *dice_roll_variadic.py:2*'
- en: 'In both function calls, I’m listing the dice I want to roll, with the number
    representing the number of sides of each die. In the first call, I’m rolling five
    six-sided dice. In the second call, I’m rolling four dice: a 20-sided die, a 6-sided
    die, an 8-sided die, and a 4-sided die.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个函数调用中，我列出了我要投掷的骰子，数字表示每个骰子的面数。在第一次调用中，我投掷了五个六面骰子。在第二次调用中，我投掷了四个骰子：一个20面骰子、一个6面骰子、一个8面骰子和一个4面骰子。
- en: 'If I wanted to use the recursive approach, I’d populate the argument list by
    automatically unpacking that tuple into the function call:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我想使用递归方法，我会通过自动解包元组来填充参数列表：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 6-20: *dice_roll_variadic.py:1b*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 6-20: *dice_roll_variadic.py:1b*'
- en: Most of this code is going to look similar to the earlier recursive version.
    The most significant change is in what I’m passing to the recursive function call.
    The asterisk (`*`) in front of the name unpacks the tuple `dice` into the argument
    list ❶. I already processed the first item in the list, so I use the slice notation
    `[1:]` to remove that first item ❷ (see Chapter 9), to ensure it isn’t processed
    again.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的大部分内容看起来与早期的递归版本相似。最显著的变化是在递归函数调用中传递的内容。名字前面的星号（`*`）将元组`dice`解包成参数列表 ❶。我已经处理了列表中的第一个项目，所以我使用切片表示法`[1:]`来去掉第一个项目
    ❷（见第9章），确保它不会再次被处理。
- en: Keyword Variadic Arguments
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键字变长参数
- en: To capture an unknown number of *keyword arguments*, precede the parameter name
    with *two* asterisks (`**`), making the parameter a *keyword variadic parameter*.
    The keyword arguments passed to the function are packed into a single dictionary
    object, so as to preserve the association between keyword and value. They are
    similarly unpacked by being preceded with two asterisks.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要捕获一个未知数量的*关键字参数*，需要在参数名前加*两个*星号（`**`），使该参数成为*关键字变长参数*。传递给函数的关键字参数会被打包成一个字典对象，从而保持关键字与值之间的关联。它们同样可以通过在参数名前加上两个星号来解包。
- en: This doesn’t show up very often in the wild. After all, if you didn’t know what
    the arguments were named, it would be hard to use them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这在实际应用中并不常见。毕竟，如果你不知道这些参数的名字，就很难使用它们。
- en: 'One case where keyword variadic arguments are commonly useful is in blindly
    relaying arguments to another function call:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字变长参数通常在将参数盲目传递给另一个函数调用时非常有用：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 6-21: *variadic_relay.py:1*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '示例 6-21: *variadic_relay.py:1*'
- en: The `call_something_else()` function has one positional argument, `func`, where
    I’ll pass a *callable* object, such as another function. The second parameter,
    `args`, is a variadic parameter for capturing all the remaining positional arguments.
    Last is the keyword variadic parameter, `kwargs`, for capturing any keyword arguments;
    sometimes, the name `kw` is used instead. Remember, either of these can be empty
    and this code will still work.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`call_something_else()`函数有一个位置参数`func`，我将传递一个*可调用*对象，比如另一个函数。第二个参数`args`是一个变长参数，用于捕获所有剩余的定位参数。最后是关键字变长参数`kwargs`，用于捕获任何关键字参数；有时也会使用`kw`作为名字。记住，这两个参数可以为空，代码仍然可以正常工作。'
- en: You can check whether an object is callable by passing it to the `callable()`
    function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将对象传递给`callable()`函数来检查它是否可以调用。
- en: The names `args` and `kwargs` are conventionally used for positional variadic
    and keyword variadic parameters, respectively. However, if you can think of names
    that better fit your particular situation, that’s certainly acceptable!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`args`和`kwargs`这两个名字分别是位置变长参数和关键字变长参数的惯用名称。然而，如果你能想到更适合你具体情况的名称，那当然是可以接受的！'
- en: When the function calls the callable object `func`, it first unpacks all the
    positional arguments that were captured, and then it unpacks all the keyword arguments.
    The function code doesn’t need any knowledge of the callable object’s parameter
    list; instead, any and every argument passed to `call_something_else()` after
    that first positional argument will get blindly passed on.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数调用可调用对象`func`时，它首先解包所有捕获的位置信息参数，然后解包所有关键字参数。函数代码不需要了解可调用对象的参数列表；相反，传递给`call_something_else()`的每个参数（除了第一个位置参数）都会被盲目地传递下去。
- en: 'You can see this in action here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到这一过程的实际操作：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 6-22: *variadic_relay.py:2*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-22：*variadic_relay.py:2*
- en: 'When I run that code, the `call_something_else()` function will call `say_hi()`,
    passing the argument `name="Bob"` to it. That produces the following output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当我运行那段代码时，`call_something_else()`函数会调用`say_hi()`，并将参数`name="Bob"`传递给它。这将输出如下内容：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This bit of magic will come back into play shortly in writing *decorators* (see
    the section “Decorators” later in this chapter).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这一魔法将很快在编写*装饰器*时再次发挥作用（参见本章后面的“装饰器”部分）。
- en: Keyword-Only Parameters
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅限关键字参数
- en: You can use variadic parameters to turn some of your keyword parameters into
    *keyword-only parameters*, which were introduced in PEP 3102\. These parameters
    cannot have values passed in as positional arguments, but rather only as keyword
    arguments. This can be especially useful in ensuring that particularly long or
    perilous parameter lists are used in the proper manner, instead of as nigh-on
    unreadable chains of positional arguments.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用可变参数将一些关键字参数转换为*仅限关键字参数*，这些参数在 PEP 3102 中被引入。此类参数不能通过位置参数传递值，而只能通过关键字参数传递。这对于确保特别长或危险的参数列表以正确的方式使用非常有用，而不是作为几乎无法读取的位置参数链。
- en: 'To demonstrate this, I’ll rewrite my `roll_dice()` function to have two keyword-only
    parameters:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我将重写我的`roll_dice()`函数，使其包含两个仅限关键字的参数：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 6-23: *dice_roll_keyword_only.py:1*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-23：*dice_roll_keyword_only.py:1*
- en: I use the unnamed variadic parameter `*`, which ensures every parameter that
    follows it in the list can only be accessed by name. If the caller passes in too
    many positional arguments (or in this case, *any* positional arguments), a `TypeError`
    is raised.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了未命名的可变参数`*`，确保列表中其后的每个参数只能通过名称访问。如果调用者传入过多的位置参数（或者在这个例子中，*任何*位置参数），则会引发`TypeError`。
- en: 'This affects the usage, such that I can only use keyword arguments now:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这影响了用法，因此现在我只能使用关键字参数：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 6-24: *dice_roll_keyword_only.py:2*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-24：*dice_roll_keyword_only.py:2*
- en: 'Attempting to use positional arguments raises an error:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用位置参数会引发错误：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 6-25: *dice_roll_keyword_only.py:3*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-25：*dice_roll_keyword_only.py:3*
- en: Positional-Only Parameters
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅限位置参数
- en: As of Python 3.8 (via PEP 570), it is also possible to define *positional-only
    parameters*. This is useful when the parameter name is either unhelpful or likely
    to be changed down the road, meaning any code using it as a keyword parameter
    would be likely to break in the future.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.8（通过 PEP 570）开始，还可以定义*仅限位置参数*。这在参数名称不太有用或可能会在将来发生变化时非常有用，因为任何将其作为关键字参数使用的代码都可能在未来中断。
- en: 'You’ll recall that positional parameters must always come first in the parameter
    list. Placing a forward slash (`/`) in the list designates all preceding parameters
    as positional-only:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该记得，位置参数必须始终排在参数列表的最前面。在列表中放置一个斜杠(`/`)可以将其前面的所有参数指定为仅限位置参数：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 6-26: *dice_roll_positional_only.py:1*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-26：*dice_roll_positional_only.py:1*
- en: 'In this example, the parameter `dice` still has a default value of `1`, but
    it is now positional-only. On the other hand, `sides` can be used as either a
    positional or a keyword parameter. Here’s that behavior in action:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，参数`dice`仍然有默认值`1`，但它现在是仅限位置的。另一方面，`sides`可以作为位置参数或关键字参数使用。以下是这一行为的实际操作：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 6-27: *dice_roll_positional_only.py:2*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-27：*dice_roll_positional_only.py:2*
- en: The first four examples all work, because the positional-only argument `dice`
    is either included as the first argument or omitted altogether. Any attempt to
    access `dice` by keyword fails with a `TypeError`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个示例都能正常工作，因为位置参数`dice`要么作为第一个参数包含在内，要么完全省略。任何尝试通过关键字访问`dice`都会导致`TypeError`。
- en: 'Argument Types: All Together Now!'
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数类型：我们一起看！
- en: 'To ensure everything is clear regarding positional parameters and keyword parameters,
    I’ll take a moment to review with this (admittedly contrived) example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保关于位置参数和关键字参数的一切都清楚，我将花点时间用这个（诚然有些牵强的）例子来复习一下：
- en: '[PRE37]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The parameter `pos_only` is positional-only, as it comes before the forward-slash
    (`/`) marker. If I have any positional-only parameters, they must appear first
    in the list. Because this parameter has a default value, it is optional. However,
    if I wanted to pass an argument to it, it would need to be the first positional
    argument passed to the function; otherwise, a `TypeError` would be raised.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`pos_only`是仅限位置的，因为它位于斜杠（`/`）标记之前。如果我有任何仅限位置的参数，它们必须首先出现在列表中。由于此参数具有默认值，因此是可选的。但是，如果我想要向其传递一个参数，它必须是传递给函数的第一个位置参数；否则，将引发`TypeError`。
- en: Next is the `pos_kw` parameter, which can be either positional or keyword. It
    comes after any positional-only parameters and after the forward-slash (`/`) marker,
    if there is one.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`pos_kw`参数，它可以是位置参数也可以是关键字参数。它位于任何仅限位置参数之后以及斜杠（`/`）标记之后（如果有的话）。
- en: Finally, after the asterisk (`*`) marker, I have `kw_only`, which is a keyword-only
    parameter. In this example, if my function receives more than two positional arguments,
    a `TypeError` will be raised.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在星号（`*`）标记之后，我有`kw_only`，这是一个仅限关键字参数。在这个例子中，如果我的函数接收到超过两个位置参数，将会引发`TypeError`。
- en: Nested Functions
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套函数
- en: From time to time, you may want to reuse a piece of logic *within* a function
    but not clutter up your code by making yet another function. In this situation,
    you can nest functions within other functions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您可能希望在函数*内部*重用某个逻辑，但又不想通过创建另一个函数来使代码变得混乱。在这种情况下，您可以在其他函数内部嵌套函数。
- en: 'I can use this to improve the recursive version of `roll_dice()`, making the
    logic for rolling a single die into something more reusable in the function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以使用这个来改进递归版本的`roll_dice()`，使得掷骰子的逻辑更可重用于函数中：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 6-28: *dice_roll_recursive.py:1b*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-28：*dice_roll_recursive.py:1b*
- en: In this example, I moved the logic for rolling a single die into a nested function
    `roll()`, which I can call from anywhere in the function `roll_dice()`. The direct
    benefit of abstracting out this logic is that it can be maintained more easily,
    without disrupting the rest of the code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我将掷单个骰子的逻辑移到了一个嵌套函数`roll()`中，我可以从函数`roll_dice()`的任何地方调用它。抽象出这个逻辑的直接好处是，可以更容易地维护它，而不会影响其余代码。
- en: 'Here’s the usage:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用法：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 6-29: *dice_roll_recursive.py:2b*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-29：*dice_roll_recursive.py:2b*
- en: That produces the usual random output.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生通常的随机输出。
- en: In production, I’d rarely use a nested function for something that trivial.
    Normally, I’d employ a nested function for more complex logic that sees frequent
    reuse, especially if it is used in multiple places in the outer function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际生产中，我很少为这种微不足道的事情使用嵌套函数。通常情况下，我会为更复杂的逻辑使用嵌套函数，这种逻辑经常被重复使用，特别是在外部函数的多个位置使用时。
- en: You’ll recall from Chapter 5 that the nested function can access the names of
    its enclosing scope. However, if I wanted to rebind or mutate any of those names
    from within the nested function, I’d need to use the `nonlocal` keyword.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 您会记得第 5 章提到的，嵌套函数可以访问其封闭范围的名称。但是，如果我想要从嵌套函数内部重新绑定或更改任何这些名称，我需要使用`nonlocal`关键字。
- en: Closures
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: You can create a function that builds and returns a kind of function called
    a *closure*, which encloses one or more nonlocal names. This pattern acts as a
    sort of “function factory.”
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建一个构建并返回一种名为*闭包*的函数的函数，它封装了一个或多个非本地名称。这种模式充当一种“函数工厂”。
- en: 'Building on the dice example, I’ll write a function that returns a *closure*
    for rolling a particular set of dice:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在骰子示例的基础上，我将编写一个返回用于掷特定骰子的*闭包*的函数：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Listing 6-30: *dice_cup_closure.py:1*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-30：*dice_cup_closure.py:1*
- en: I create the function `make_dice_cup()`, which accepts the arguments for `sides`
    and `dice`. Inside `make_dice_cup()`, I define a nested function `roll()`, which
    uses `sides` and `dice`. When that nested function is returned by the outer function
    (no parentheses!) ❶, it becomes a closure, because it encloses `sides` and `dice`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我创建了函数`make_dice_cup()`，它接受`sides`和`dice`作为参数。在`make_dice_cup()`内部，我定义了一个嵌套函数`roll()`，它使用`sides`和`dice`。当该嵌套函数被外部函数返回时（没有括号！）❶，它成为一个闭包，因为它封闭了`sides`和`dice`。
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 6-31: *dice_cup_closure.py:2*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-31：*dice_cup_closure.py:2*
- en: I bind the closure returned by `make_dice_cup()` to the name `roll_for_damage`,
    which I can now call as a function without any arguments. The closure continues
    to use `sides` and `dice` with the values I specified earlier to roll dice and
    return values; it is now a function in its own right.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`make_dice_cup()`返回的闭包绑定到名称`roll_for_damage`，现在我可以像调用函数一样调用它，而不需要任何参数。闭包继续使用我之前指定的`sides`和`dice`的值来掷骰子并返回值；它现在已经是一个独立的函数。
- en: Caution is necessary when using closures, as you can easily violate the rules
    of functional programming with them. If a closure has the ability to mutate the
    values it encloses, it becomes a sort of de facto object, and a difficult one
    to debug at that!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用闭包时需要小心，因为你很容易违反函数式编程的规则。如果闭包有能力修改它所闭包的值，它就变成了一种事实上的对象，并且是一个很难调试的对象！
- en: Recursion with Closures
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 闭包的递归
- en: The previous closure example didn’t use the recursive form of the dice-rolling
    code because, while it’s possible to implement such closure correctly, it’s even
    easier to do it wrong.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个闭包示例没有使用递归形式的掷骰子代码，因为尽管实现这种闭包是可能的，但错误的实现方式更容易出现。
- en: 'Here’s the most apparently obvious, yet wrong, way to make that closure recursive:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个最显而易见但错误的方式来让闭包递归：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 6-32: *dice_cup_closure_recursive.py:1a*'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-32: *dice_cup_closure_recursive.py:1a*'
- en: Using what you know about names and scope so far, can you anticipate what’s
    wrong with the above?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 结合你目前对名称和作用域的了解，你能预测出上面有什么问题吗？
- en: 'The giveaway that something is wrong with the closure is the keyword `nonlocal`,
    as it indicates I’m mutating or rebinding a nonlocal name: `dice`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 判断闭包有问题的标志是关键字`nonlocal`，它表明我正在修改或重新绑定一个非本地名称：`dice`。
- en: 'Attempting to use this closure will reveal the problem:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用这个闭包将暴露出问题：
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Listing 6-33: *dice_cup_closure_recursive.py:2*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-33: *dice_cup_closure_recursive.py:2*'
- en: 'That code produces the following output (for example):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会产生如下输出（例如）：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The first time the closure `roll_for_damage()` is used, everything is fine.
    However, `dice` isn’t reset when the function exits, so all subsequent calls to
    the closure find that `dice == 0`. Thus, they only return `()`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次使用闭包`roll_for_damage()`时，一切正常。然而，当函数退出时，`dice`并没有被重置，因此所有后续对闭包的调用都会发现`dice
    == 0`。因此，它们只会返回`()`。
- en: 'To write a recursive closure, you need to use an optional parameter on the
    closure:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个递归闭包，你需要在闭包中使用一个可选参数：
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Listing 6-34: *dice_cup_closure_recursive.py:1b*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-34: *dice_cup_closure_recursive.py:1b*'
- en: In this version, I use the nonlocal name `dice` as the default value of the
    new, local parameter `dice`. (Recall, this will only work with immutable types.)
    This behaves precisely as expected, as it still closes over `sides` and the nonlocal
    `dice`, but it rebinds neither.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我使用`nonlocal`名称`dice`作为新本地参数`dice`的默认值。（请记住，这仅对不可变类型有效。）它的行为完全符合预期，因为它仍然闭包了`sides`和`nonlocal
    dice`，但它并没有重新绑定它们。
- en: Stateful Closures
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有状态的闭包
- en: While it is generally best to write closures as pure functions, it is occasionally
    useful to create a *stateful closure*—that is, a closure that retains a little
    bit of state between calls that it can use. In general, you should avoid using
    stateful closures unless no other solution presents itself.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通常最好将闭包编写为纯函数，但偶尔也有必要创建一个*有状态的闭包*——即一个在调用之间保持一点状态并可以使用的闭包。一般来说，除非没有其他解决方案，否则你应该避免使用有状态的闭包。
- en: 'Just to demonstrate this, I’ll create a stateful closure that limits how many
    times a player can reroll a group of dice:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我将创建一个有状态的闭包，限制玩家重新掷骰子的次数：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Listing 6-35: *dice_roll_turns.py:1*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-35: *dice_roll_turns.py:1*'
- en: I write the closure `roll()` so that it only allows the caller to reroll the
    dice a maximum number of times, specified by `limit`, before the function starts
    returning `None`. By this design, after the limit is reached, a new closure must
    be created. The logic of tracking how many times a player can roll the dice has
    been abstracted out into the closure.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我编写闭包`roll()`，使其仅允许调用者在达到由`limit`指定的最大次数后重新掷骰子，之后函数开始返回`None`。通过这种设计，在达到限制后，必须创建一个新的闭包。追踪玩家可以掷骰子的次数的逻辑已经被抽象到闭包中。
- en: This closure is very limited and predictable in how it mutates and uses its
    state. It’s important to limit your closures in this way, since debugging a stateful
    closure can be difficult. There is no way to see the current value of `limit`
    from outside the closure; it’s simply not possible.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个闭包在如何变异和使用它的状态上非常有限和可预测。限制闭包的方式非常重要，因为调试有状态的闭包可能很困难。无法从闭包外部看到 `limit` 的当前值；这是不可能的。
- en: 'You can see this predictable behavior at work in the usage:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在使用过程中看到这种可预测的行为：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Listing 6-36: *dice_roll_turns.py:2*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-36：*dice_roll_turns.py:2*
- en: 'Running that code produces the following randomized output, wherein each turn
    gets three tosses of the dice; each toss is represented by a tuple:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该代码会产生以下随机输出，每个回合会投掷三次骰子；每次投掷由一个元组表示：
- en: '[PRE48]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: A stateful closure can be useful in situations where writing an entire class
    (see Chapter 7) brings in too much boilerplate. Since I only have one piece of
    state, `limit`, and I am using it predictably, this approach is acceptable. Anything
    more complicated, and debugging becomes impractically difficult.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在写一个完整的类（见第7章）会带来太多样板代码的情况下，有状态的闭包可能会有用。由于我只有一个状态片段 `limit`，并且我使用它是可预测的，所以这种方法是可以接受的。任何更复杂的情况下，调试变得不切实际。
- en: As I pointed out earlier, anytime you see `nonlocal` in a closure, you should
    be extra cautious, as it indicates the presence of state. This can be acceptable
    on occasion, but there is usually a better approach. Stateful closures are not
    pure functional programming!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前指出的，任何时候你在一个闭包中看到 `nonlocal`，你都应该特别小心，因为它表示存在状态。这在某些情况下是可以接受的，但通常有更好的方法。有状态的闭包并不符合纯函数式编程！
- en: Lambdas
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda 表达式
- en: 'A *lambda* is an anonymous (nameless) function made up of a single expression.
    The structure is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lambda* 是由单个表达式组成的匿名（无名称）函数。其结构如下：'
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: On the left side of the colon is the parameter list, which may be omitted if
    you don’t want to accept any arguments. On the right is the return expression,
    which is evaluated when the lambda is called and the result is implicitly returned.
    To use a lambda, you must bind it to a name, whether by assignment or by passing
    it as an argument to another function.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号的左侧是参数列表，如果你不想接受任何参数，可以省略。右侧是返回表达式，在调用 Lambda 时进行评估，结果会被隐式返回。要使用 Lambda，必须将其绑定到一个名称上，无论是通过赋值还是通过将其作为参数传递给另一个函数。
- en: 'For example, here’s a lambda that adds two numbers:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个将两个数字相加的 Lambda 表达式：
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Listing 6-37: *addition_lambda.py*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-37：*addition_lambda.py*
- en: I bind the `lambda` to the name `add` and then call it as a function. This particular
    lambda accepts two arguments and then returns their sum.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我将 `lambda` 绑定到名称 `add` 上，然后将其作为一个函数调用。这个特定的 lambda 接受两个参数，然后返回它们的和。
- en: Why Lambdas Are Useful
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么 Lambda 很有用
- en: Many programmers can’t imagine ever needing nameless functions. It would seem
    to make reuse completely impractical. After all, if you’re just going to bind
    a lambda to a name, shouldn’t you have just written a function?
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员无法想象什么时候会需要无名函数。这似乎使得重用完全不切实际。毕竟，如果你只是要将 lambda 绑定到一个名称上，你难道不应该直接写一个函数吗？
- en: 'To understand how lambdas can be useful, let’s take a look at an example *without*
    lambdas first. This code represents a player character in a basic text adventure
    game:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解 Lambda 如何有用，让我们首先看一个*没有*使用 Lambda 的例子。这段代码代表了一个基本文本冒险游戏中的玩家角色：
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Listing 6-38: *text_adventure_v1.py:1*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-38：*text_adventure_v1.py:1*
- en: 'I’m keeping track of my character’s stats in a couple of global names at the
    top, `health` and `xp`, which I’ll use throughout my program:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我在程序顶部使用了一些全局变量 `health` 和 `xp` 来追踪我的角色统计信息：
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Listing 6-39: *text_adventure_v1.py:2*'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-39：*text_adventure_v1.py:2*
- en: My `attempt()` function handles rolling the dice, using the outcome to decide
    whether the player’s action succeeded or failed, and then modifying the values
    of the global `health` and `xp` variables accordingly. It determines how those
    values should be changed, based on the value returned from calling the function
    passed to `outcome`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我的 `attempt()` 函数负责掷骰子，根据结果决定玩家的动作成功或失败，并相应地修改全局变量 `health` 和 `xp` 的值。它根据从传递给
    `outcome` 的函数调用返回的值来确定应如何更改这些值。
- en: The part to focus on is the parameter `outcome` ❶—which, by its usage in `attempt()`
    ❷, should be a function that accepts a boolean value and returns a tuple of two
    integers representing the desired changes to `health` and `xp`, respectively.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 需要关注的部分是参数`outcome` ❶——根据它在`attempt()` ❷中的使用，应该是一个接受布尔值并返回一个包含两个整数的元组，分别表示对`health`和`xp`的期望变化的函数。
- en: 'Expanding on that example, I’ll use what I’ve built so far:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子上进行扩展，我将使用到目前为止构建的内容：
- en: '[PRE53]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Listing 6-40: *text_adventure_v1.py:3a*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-40: *text_adventure_v1.py:3a*'
- en: 'There’s no real pattern to the outcomes of each possible action, so I have
    to write functions for each one: in this example, `eat_bread()` and `fight_ice_weasel()`.
    Even this example is a bit oversimplified, as the code determining the outcome
    might involve a bunch of mathematics and randomization. Regardless, since I need
    a separate outcome function for each action, this code is going to grow rapidly,
    leading to a maintainability nightmare.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 每个可能动作的结果并没有明确的模式，因此我必须为每个动作编写函数：在这个例子中是`eat_bread()`和`fight_ice_weasel()`。即使这个例子有点过于简化，因为决定结果的代码可能涉及大量的数学计算和随机化。不管怎样，由于每个动作需要一个单独的结果函数，这段代码将迅速增长，导致可维护性问题。
- en: (Be advised, the `if` statement above is not the most Pythonic way to write
    that code; I deliberately chose that structure to illustrate the logic.)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，上面的 `if` 语句不是最 Pythonic 的写法；我故意选择了这种结构来说明逻辑。）
- en: When I attempt an action ❶, I pass the string representing the action, the minimum
    dice roll necessary to succeed, and the function determining the outcome. When
    passing a function, remember not to include the trailing parentheses. Here, I
    want to pass the function itself, not the value it returns.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当我尝试一个动作 ❶时，我传递表示该动作的字符串、成功所需的最小骰子投掷结果以及决定结果的函数。在传递函数时，记得不要包括尾部的括号。在这里，我是想传递函数本身，而不是它返回的值。
- en: 'This sort of usage is where lambdas come in. I can replace the `eat_bread()`
    and `fight_ice_weasel()` functions, plus the two calls to `attempt()`, with just
    the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用法就是 lambda 的用途所在。我可以用以下代码替换掉`eat_bread()`和`fight_ice_weasel()`函数，以及两次对`attempt()`的调用：
- en: '[PRE54]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Listing 6-41: *text_adventure_v1.py:3b*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-41: *text_adventure_v1.py:3b*'
- en: 'The third argument of each is a lambda, which accepts a single parameter named
    `success` and returns a value depending on the value of `success`. Let’s isolate
    just that first lambda:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 每个参数的第三个参数是一个 lambda，它接受一个名为`success`的单一参数，并根据`success`的值返回一个值。我们先分离出第一个 lambda：
- en: '[PRE55]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: When the lambda is called, if the value of `success` is `True`, then `(1, 0)`
    will be returned. Otherwise, `(-1, 0)` is returned.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 lambda 时，如果`success`的值为`True`，则返回`(1, 0)`。否则，返回`(-1, 0)`。
- en: That lambda is being passed to (and thus bound to) the `outcome` parameter of
    the `attempt()` function, and it is subsequently called with a single boolean
    argument.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 该 lambda 被传递到（因此绑定到）`attempt()`函数的`outcome`参数，并随后以一个布尔值作为参数进行调用。
- en: By using lambdas in this manner, I can create many different possible outcomes
    in my code with only one line of code.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式使用 lambda，我可以在代码中仅用一行代码创建许多不同的可能结果。
- en: Remember that *a lambda may only consist of a single return expression*! This
    makes lambdas suitable for short, clear fragments of logic, especially when the
    code is made more readable by keeping that logic close to its usage within another
    function call. If you want anything more complex, you’ll need to write a proper
    function.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，*lambda 只能由一个返回表达式组成*！这使得 lambda 非常适合简短、清晰的逻辑片段，特别是当代码通过将逻辑紧跟在另一个函数调用附近时变得更具可读性。如果你需要更复杂的逻辑，则需要编写一个正式的函数。
- en: Lambdas as Sorting Keys
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用作排序键的 Lambda 表达式
- en: One of the most common situations where a lambda comes in handy is when specifying
    a *key function*, which is a callable that returns the part of a collection or
    object that should be used for sorting. A key function is typically passed to
    another function that is responsible for sorting data in some manner.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 最常见的用途之一是指定一个 *key 函数*，即一个返回集合或对象中应用于排序部分的可调用函数。key 函数通常被传递给另一个负责以某种方式排序数据的函数。
- en: 'For example, here I have a list of tuples containing first and last names,
    and I want to sort the list by last name:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里我有一个包含名字和姓氏的元组列表，我想按姓氏排序该列表：
- en: '[PRE56]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Listing 6-42: *sort_names.py*'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-42: *sort_names.py*'
- en: The `sorted()` function uses the `key` argument ❶, which is always a function
    or other callable, by passing each item to it and then using the value returned
    from that callable to determine the sorting order. Since I want the tuples sorted
    by last name, which is the second item of each tuple, I have the lambda return
    that item, which is `x[1]`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`sorted()`函数使用了`key`参数❶，该参数通常是一个函数或其他可调用对象，通过将每个项传递给它，并使用从该可调用对象返回的值来决定排序顺序。由于我希望按姓氏对元组进行排序，而姓氏是每个元组的第二项，因此我让lambda函数返回这个项，即`x[1]`。'
- en: The end result is that `by_last_name` contains the list, sorted by last name.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是，`by_last_name`包含了按姓氏排序的列表。
- en: Decorators
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器
- en: '*Decorators* allow you to modify the behavior of a function (or even multiple
    functions) by wrapping it in an additional layer of logic. This changes the function’s
    behavior without you having to rewrite the function itself.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*装饰器*允许你通过在函数外部增加一层逻辑来修改函数（甚至多个函数）的行为。这改变了函数的行为，而无需重写函数本身。'
- en: To demonstrate this, here’s another example with my text adventure game hero.
    I want to define multiple game events that affect the player character’s statistics
    in different ways, and I want those changes displayed as they happen. I’ll start
    with an implementation that doesn’t use decorators. This code only uses concepts
    I’ve already covered so far in this book, so I’ll mainly draw your attention to
    some inefficiencies.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，这里有另一个示例，使用我的文本冒险游戏英雄。我想定义多个游戏事件，这些事件会以不同的方式影响玩家角色的统计数据，并且我希望这些变化能够在发生时即时显示出来。我将从一个不使用装饰器的实现开始。这段代码仅使用了我在本书中到目前为止所讲解的概念，因此我将主要引起你对一些低效之处的注意。
- en: 'I’ll start by defining my global variables:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从定义我的全局变量开始：
- en: '[PRE57]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Listing 6-43: *text_adventure_v2.py:1a*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-43: *text_adventure_v2.py:1a*'
- en: 'Next, I’ll define functions for each action the player can take:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将为玩家可以采取的每个动作定义函数：
- en: '[PRE58]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Listing 6-44: *text_adventure_v2.py:2a*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-44: *text_adventure_v2.py:2a*'
- en: Each function represents an action the player can take, and some common code
    is shared between these functions. First, each function checks the character’s
    health to determine if the character is even able to perform the action ❶ ❸. If
    the character’s health is sufficient, the player performs the action, which alters
    the character’s statistics. When the action is completed (or if the character’s
    health is too low to take an action), the current stats are displayed ❷ ❹.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数代表玩家可以采取的一个动作，并且这些函数之间共享一些公共代码。首先，每个函数检查角色的健康状况，以确定角色是否有能力执行该动作❶ ❸。如果角色的健康足够，玩家便执行该动作，从而改变角色的统计数据。当动作完成后（或者如果角色的健康值太低以至于无法执行该动作），当前的统计数据将会显示出来❷
    ❹。
- en: 'And then, of course, I have the usage:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当然，我有这样的用法：
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Listing 6-45: *text_adventure_v2.py:3*'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-45: *text_adventure_v2.py:3*'
- en: That works, but as I said, the repeated code in [Listing 6-44](#listing6-44)
    is not very Pythonic. Your first instinct might be to move the common code—the
    code that checks the health and displays the statistics—out into their own functions.
    However, you would still need to remember to call each one within *every character
    action function*, and they’re easy to overlook. Furthermore, each function would
    still need that conditional statement at the top to ensure the code isn’t run
    when health is too low.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这行得通，但正如我所说，在[Listing 6-44](#listing6-44)中的重复代码并不是很符合Python的风格。你第一反应可能是将公共代码——检查健康状况并显示统计数据的代码——提取到各自的函数中。然而，你仍然需要记得在*每个角色动作函数*中调用它们，而且很容易忽略。此外，每个函数仍然需要在顶部包含那个条件语句，以确保在健康值过低时不会执行代码。
- en: This situation, where I want to run the same code before and after every function,
    can be perfectly solved with decorators.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况，我希望在每个函数前后都运行相同的代码，可以通过装饰器完美解决。
- en: 'Here, I’ll create a decorator toward the top of the text adventure game code:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将创建一个装饰器，位于文本冒险游戏代码的顶部：
- en: '[PRE60]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Listing 6-46: *text_adventure_v2.py:1b*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 6-46: *text_adventure_v2.py:1b*'
- en: A decorator is most often implemented as a closure, which closes over a function
    (or any other callable object) being modified. The decorator itself, `character_action()`,
    accepts a `func` parameter, which is the callable being modified.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器通常作为一个闭包实现，它封闭了一个被修改的函数（或任何其他可调用对象）。装饰器本身，`character_action()`，接受一个`func`参数，这个参数就是被修改的可调用对象。
- en: Within the decorator definition is the *wrapper*, which is the callable where
    the decorator’s logic lives ❸. As I said, most commonly, the closure pattern is
    used for this. However, the wrapper can be implemented with any callable, including
    a class. (Technically, I could even implement the wrapper as a noncallable, but
    this is seldom, if ever, useful.)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在装饰器定义内是*包装器*，它是装饰器逻辑所在的可调用函数❸。正如我所说，通常情况下，闭包模式用于此。但是，包装器可以通过任何可调用的方式实现，包括类。（从技术上讲，我甚至可以将包装器实现为非可调用，但这很少，几乎从不有用。）
- en: Because I don’t know how many arguments will be passed to any function I’ll
    apply the decorator to, I set up the wrapper to accept variadic arguments.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我不知道将会传递多少参数到我应用装饰器的任何函数，所以我设置了包装器以接受可变参数。
- en: The `@functools.wraps(func)` line ❷ prevents the callable being wrapped from
    having its identity concealed from the rest of the program. Without that line,
    wrapping the callable would mess up external access of such important function
    attributes as `__doc__` (the docstring) and `__name__`. This line is itself a
    decorator that ensures all the important attributes of the callable are retained
    by the now-wrapped function, thus making them accessible outside the function
    in all the usual ways. (To use that special decorator, I must import `functools`
    first ❶.)
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`@functools.wraps(func)`这一行❷防止被包装的可调用函数在程序中被隐藏其身份。如果没有这一行，包装可调用函数会导致外部无法访问如`__doc__`（文档字符串）和`__name__`等重要的函数属性。这一行本身就是一个装饰器，它确保所有可调用函数的重要属性都由现在被包装的函数保留，从而使它们可以以所有常规方式在函数外部访问。（要使用这个特殊的装饰器，我必须先导入`functools`❶。）'
- en: Inside the wrapper, I put all that logic I want to run before and after each
    function. After checking `health`, I call the function that is bound to `func`,
    unpacking all the variadic arguments into the call. I also bind the return value
    to `result`, so I can ensure that gets returned from the decorator after I print
    the stats.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在包装器内，我放入了所有希望在每个函数前后运行的逻辑。在检查`health`之后，我调用绑定到`func`的函数，将所有可变参数解包到调用中。我还将返回值绑定到`result`，这样在打印统计信息后，我可以确保该值从装饰器返回。
- en: As with any closure, it is supremely important that the outer function return
    the inner function ❹.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何闭包一样，外部函数返回内部函数❹是至关重要的。
- en: 'Now, I can use the decorator I wrote and refactor my other functions:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以使用我编写的装饰器，并重构我的其他函数：
- en: '[PRE61]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Listing 6-47: *text_adventure_v2.py:2b*'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 6-47: *text_adventure_v2.py:2b*'
- en: To apply decorators to a function, I list each decorator I want to apply directly
    above the function definition, one decorator per line. I precede each decorator
    name with an `@` symbol. In my example, I only apply a single decorator to each
    function, but you can use as many as you like. They will be applied in order,
    with each decorator wrapping whatever is immediately below it.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要将装饰器应用于函数，我将每个要应用的装饰器直接列在函数定义上方，每行一个装饰器。我在每个装饰器名称前加上`@`符号。在我的示例中，我只为每个函数应用一个装饰器，但你可以根据需要应用任意多个装饰器。它们将按顺序应用，每个装饰器包装在它下面的内容。
- en: Since I moved all the repetitive logic about checking health and displaying
    stats out of the individual functions and into the decorator, my code is cleaner
    and easier to maintain. If you run the code, it works the same as before.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我将检查健康和显示统计信息的所有重复逻辑从单个函数中移出并放入了装饰器中，我的代码变得更简洁，也更易于维护。如果你运行代码，它的表现和之前一样。
- en: Type Hints and Function Annotations
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型提示和函数注解
- en: 'Python 3.5 onward allows you to specify *type hints*, which are exactly that:
    *hints* about what data type should be passed in or returned. These are not strictly
    necessary, given Python’s robust dynamic type system, but they may have a few
    benefits.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Python 3.5 开始，允许你指定*类型提示*，它们正是那种：*关于应该传递或返回什么数据类型的提示*。鉴于 Python 强大的动态类型系统，这些提示并不是严格必要的，但它们可能带来一些好处。
- en: First, type hinting aids in documentation. The function definition now shows
    what type of information it wants, which is especially helpful when your IDE auto-magically
    shows hints as you type arguments in.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，类型提示有助于文档化。函数定义现在显示了它需要的是什么类型的信息，这在你的 IDE 在你输入参数时自动显示提示时尤其有帮助。
- en: Second, type hints help you catch potential bugs sooner. Static type checkers
    like *Mypy* are the primary tools for this (see Chapter 2). Some IDEs, like PyCharm,
    may warn you if you’re doing something weird, like passing a string to something
    type-hinted as an integer.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，类型提示帮助你更早发现潜在的错误。像*Mypy*这样的静态类型检查工具是主要工具（参见第 2 章）。一些 IDE，如 PyCharm，可能会警告你如果你做了些奇怪的事，例如将字符串传递给一个标明为整数的类型提示。
- en: If you’re familiar with statically typed languages like Java and C++, this might
    make you a little excited.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉像 Java 和 C++ 这样的静态类型语言，这可能会让你感到有点兴奋。
- en: However, understand that using type hints does not trade Python’s dynamic typing
    for static typing!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请理解，使用类型提示并不会将 Python 的动态类型变为静态类型！
- en: Python will not raise an error if you pass the wrong type.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你传入错误的类型，Python 不会抛出错误。
- en: Python will not try to convert data to the specified type.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 不会尝试将数据转换为指定的类型。
- en: Python will actually ignore these hints altogether!
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python 实际上会完全忽略这些提示！
- en: Type hints are specified with *annotations*, which are extra pieces of information
    that are permitted by the Python language but are not actually processed by the
    interpreter itself. There are two kinds of annotations.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示通过*注解*指定，它们是 Python 语言允许的附加信息，但并不会被解释器本身处理。注解有两种类型。
- en: '*Variable annotations* specify the expected type on a name, like this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量注解*指定了一个名称的预期类型，如下所示：'
- en: '[PRE62]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '*Function annotations* specify type hints on parameters and function returns.
    Here, I apply function annotations to the `roll_dice()` function from earlier:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数注解*在参数和函数返回值上指定类型提示。这里，我将函数注解应用于之前提到的`roll_dice()`函数：'
- en: '[PRE63]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Listing 6-48: *dice_roll.py:1e*'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-48：*dice_roll.py:1e*
- en: This notation allows me to denote what types I expect for the parameters and
    return. In this case, both parameters should receive an integer, so I follow each
    name with a colon and then `int` as the expected data type. If there’s a default
    value of the expected type, it is included after the type hint.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示法允许我指定我期望的参数和返回类型。在这种情况下，两个参数都应该接收一个整数，因此我在每个名称后面加上冒号，然后用`int`表示预期的数据类型。如果有预期类型的默认值，则在类型提示后面包括它。
- en: I denote the return type with an arrow (`->`) and the expected type. Collections
    like tuples and lists are a little trickier to specify with type hints. From the
    `typing` module, I can use the notation `Tuple[ ]`, which is a *generic type*.
    Every value of this particular tuple should be an `int`, but since I don’t really
    know how many will be returned, I specify a `...` to say, “There may be more.”
    Now, the function will be expected to return one or more integers, but no other
    types.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我用箭头（`->`）和预期类型来表示返回类型。像元组和列表这样的集合类型在使用类型提示时稍微复杂一些。在`typing`模块中，我可以使用`Tuple[
    ]`表示法，这是一种*泛型类型*。这个元组的每个值应该是一个`int`，但由于我不确定会返回多少个元素，我使用`...`来表示，“可能会有更多。”现在，函数将被期望返回一个或多个整数，但不包括其他类型。
- en: By the way, if you don’t know what or how many types will be returned in a tuple,
    you can use the notation `typing.Tuple[typing.Any, ...]`
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，如果你不知道元组中将返回什么类型或返回多少个类型，你可以使用`typing.Tuple[typing.Any, ...]`表示法。
- en: 'That return type hint in the preceding code example is pretty long. I could
    shorten it by defining a *type alias*, like this:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 上面代码示例中的返回类型提示相当长。我可以通过定义一个*类型别名*来缩短它，如下所示：
- en: '[PRE64]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Listing 6-49: *dice_roll.py:1f*'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-49：*dice_roll.py:1f*
- en: I define `TupleInts` as a type alias for `Tuple[int, ...]`, and I can use it
    the same way throughout my code.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我将`TupleInts`定义为`Tuple[int, ...]`的类型别名，并且可以在代码中像使用普通类型一样使用它。
- en: Again, Python itself won’t act on these type hints; it will only recognize the
    notation system as valid and store it in the `__annotations__` attribute of the
    function, nothing more.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，Python 本身不会对这些类型提示做任何处理；它只会将表示法识别为有效，并将其存储在函数的`__annotations__`属性中，仅此而已。
- en: 'I can now run this code through Mypy:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以通过 Mypy 来运行这段代码：
- en: '[PRE65]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If there are any mismatches between the type hints and the actual usage, Mypy
    will list these in detail, so they can be fixed.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型提示与实际使用之间存在任何不匹配，Mypy 会详细列出这些问题，以便修正。
- en: Duck Typing and Type Hints
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 鸭子类型与类型提示
- en: You might think that type hinting is incompatible with duck typing, but thanks
    to the `typing` module, the two generally play very well with one another.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为类型提示与鸭子类型（duck typing）不兼容，但多亏了`typing`模块，这两者通常可以很好地协同工作。
- en: For example, if you wanted a function that could accept a single parameter of
    any type that could be iterated over (see Chapter 9), such as a tuple or a list,
    you could use `typing.Iterable[]`, with the contained type in the brackets. For
    this example, I’ll presume that the iterable may contain any type.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你希望一个函数接受任何可以迭代的单一参数（参见第9章），比如元组或列表，你可以使用`typing.Iterable[]`，并在括号中指定包含的类型。对于这个示例，我假设该可迭代对象可以包含任何类型。
- en: '[PRE66]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The parameter `within` is type-hinted to be an iterable with `typing.Iterable[
    ]`. The hint `typing.Any` within the square brackets indicates that the `Iterable`
    can contain items of any data type.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`within`的类型提示是一个可迭代对象，使用了`typing.Iterable[ ]`。方括号内的`typing.Any`提示表明`Iterable`可以包含任何数据类型的项。
- en: 'The typing module contains many different such types, enough to fill up a separate
    chapter altogether. The best way to learn more about type hinting is to read the
    documentation: [https://docs.python.org/library/typing.xhtml](https://docs.python.org/library/typing.xhtml).
    I also recommend taking a look at PEP 484, which defined type hinting, and PEP
    3107, which defined function annotations.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`typing`模块包含了许多不同的类型，足够单独成章。学习类型提示的最佳方式是阅读文档：[https://docs.python.org/library/typing.xhtml](https://docs.python.org/library/typing.xhtml)。我还推荐你查看PEP
    484，它定义了类型提示，和PEP 3107，它定义了函数注解。'
- en: Should You Use Type Hinting?
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 是否应该使用类型提示？
- en: Type hinting is entirely optional, and there are cases for it and against it.
    Some argue that it clutters up the code, impairing the natural readability that
    Python attained through dynamic typing. Others see it as a much-needed tool for
    mitigating the bugs made possible through the lack of static typing.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 类型提示完全是可选的，使用与否都有各自的理由。有人认为它会使代码变得杂乱，破坏 Python 通过动态类型所获得的自然可读性。而另一些人则将其视为一种急需的工具，用于减少因为缺乏静态类型检查而可能导致的错误。
- en: In practice, you don’t need to make a wholesale “use or don’t use” decision.
    Because type hinting is optional, you can use it in cases where it improves the
    readability and stability of the code and skip it in cases where it doesn’t. Even
    within a function, you can define a type hint for one parameter and omit it for
    the next.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你无需做出“使用还是不使用”的全面决定。由于类型提示是可选的，你可以在那些能提高代码可读性和稳定性的地方使用它，而在那些不需要的地方跳过它。即便是在同一个函数中，你也可以为一个参数定义类型提示，而为下一个参数省略它。
- en: Ultimately, the decision is up to you and your team alone. Only you know if
    and when type hints will be helpful. In short, *know thine own project*.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，决定权在于你和你的团队。只有你们知道类型提示是否以及何时有用。简而言之，*了解你自己的项目*。
- en: Since this book focuses on idiomatic Python above all else, and since type hinting
    is entirely optional, I won’t use it in any future examples.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书重点介绍惯用的 Python 编程风格，并且类型提示完全是可选的，我在未来的示例中将不会使用它。
- en: Wrapping Up
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: I hope you come away from this chapter with a newfound appreciation for functional
    programming in the Python language. Even when the paradigm is not embraced wholesale,
    its concepts and guidelines inform Pythonic code.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你在阅读完这一章后，能对 Python 语言中的函数式编程有一种新的欣赏。即使这种范式未被完全接受，它的概念和指南依然能影响 Pythonic 代码的编写。
- en: I’ll still apply functional concepts as I move into object-oriented programming
    in the next chapter. I’ve found that, when combined correctly, these paradigms
    interact in surprisingly positive ways.**
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我仍会在转向面向对象编程时应用函数式编程的概念。我发现，当正确结合时，这些范式以令人惊讶的积极方式相互作用。**
