<html><head></head><body>
<div id="sbo-rt-content"><h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_127"/><strong><span class="big">9</span><br/>STORING USER INPUT IN A DATABASE</strong></h2>&#13;
<div class="image1"><img src="../Images/comm1.jpg" alt="Image" width="191" height="191"/></div>&#13;
<p class="noindents">Many applications designed for business need to transfer the data they work with to a database at some point. For example, a food-ordering chatbot might save an order form after filling it out using the information extracted from dialogue with a customer. Once the order appears in the database, it becomes available for further processing, and the product is eventually shipped to the customer.</p>&#13;
<p class="indent">This chapter discusses how you can turn information extracted from submitted text into a structured format so you can store and manipulate it within a <em>relational</em> (row-and-column) database. Through examples, you’ll learn how a chatbot can shred input text into pieces and compose a ready-for-database structure from it.</p>&#13;
<h3 class="h3" id="lev119"><span epub:type="pagebreak" id="page_128"/><strong>Converting Unstructured Data into Structured Data</strong></h3>&#13;
<p class="noindent"><em>Structured data</em> is organized using a predefined data schema in a formatted repository. If you’ve worked with relational databases before, you know you must first convert any data you’ll enter in the database into a structured format so it fits into a table or set of related tables.</p>&#13;
<p class="indent">The problem is that the natural language input that apps receive from users is <em>unstructured</em>, meaning it has no predefined organizational schema. Typical examples of unstructured data include text and multimedia content, such as emails, web pages, business documents, videos, photos, and so on. Although you can still store unstructured data in a database, usually you must perform some preprocessing when you insert it. For example, you might need to label photos so the database can classify them or assign IDs to text documents so the database can distinguish between them.</p>&#13;
<p class="indent">Sometimes, you might need to perform more radical transformations to unstructured text content, such as extracting pieces of information from it, before grouping those pieces into a formatted structure. For example, a business chatbot typically needs to parse a customer’s utterances to fill in a certain form. A different app might extract just certain elements from a web page, label those elements, and then convert the information into a table, as shown in <a href="../Text/ch09.xhtml#ch09fig01">Figure 9-1</a>.</p>&#13;
<div class="image"><a id="ch09fig01"/><img src="../Images/fig9-1.jpg" alt="image" width="467" height="393"/></div>&#13;
<p class="figcap"><em>Figure 9-1: An example of converting unstructured content into structured data</em></p>&#13;
<p class="indent">Tools like spaCy reveal a text’s internal structure by tagging each token in a sentence with linguistic annotations. This preprocessing enables you to extract specific elements from it, usually by checking the text’s syntactic dependency labels. <a href="../Text/ch09.xhtml#ch09fig02">Figure 9-2</a> describes how a food-ordering chatbot might recognize and extract necessary elements from a user’s utterance by relying on the syntactic dependency labels spaCy assigns to each token when you apply the text-processing pipeline to it.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_129"/><a id="ch09fig02"/><img src="../Images/fig9-2.jpg" alt="image" width="276" height="558"/></div>&#13;
<p class="figcap"><em>Figure 9-2: A high-level view of how raw text can be converted into row–column data.</em></p>&#13;
<p class="indent">Next, you’ll see how, once you’ve extracted these elements, you can structure and insert them into a database table as a row.</p>&#13;
<h4 class="h4" id="lev120"><strong><em>Extracting Data into Interchange Formats</em></strong></h4>&#13;
<p class="noindent">Many current relational databases natively support multiple common data interchange formats. For example, MySQL natively supports XML and JSON, the two most common data interchange formats on the web.</p>&#13;
<p class="indent">Your data format choice can affect the way in which you decide to collect data. For example, if the database you’re using supports JSON, you can extract data directly into a JSON object that you’ll then send to the database for further processing. A JSON object is a key-value data format surrounded by curly brackets. It looks like this:</p>&#13;
<pre>{"product": "pizza", "type": "Chicago", "qty": 1}</pre>&#13;
<p class="indent">Apart from basic values, such as strings and numbers, JSON supports complex values, such as arrays and other JSON objects. You’ll see how this works in “<a href="../Text/ch09.xhtml#lev122">Building a Database-Powered Chatbot</a>” on <a href="../Text/ch09.xhtml#page_132">page 132</a>.</p>&#13;
<p class="indent">In fact, using the JSON format significantly simplifies the process of composing a data structure for the database in your Python script. First, you don’t need to prepare a structure that conforms to a less widely used <span epub:type="pagebreak" id="page_130"/>format, which makes your code less tied to a given database type. Second, the elements in a JSON object can follow any order, which imposes fewer restrictions on how the process of determining and extraction of necessary elements from an input text can be organized.</p>&#13;
<p class="indent"><a href="../Text/ch09.xhtml#ch09fig03">Figure 9-3</a> illustrates how a food-ordering chatbot app might interact with its underlying database using JSON.</p>&#13;
<div class="image"><a id="ch09fig03"/><img src="../Images/fig9-3.jpg" alt="image" width="503" height="614"/></div>&#13;
<p class="figcap"><em>Figure 9-3: The workflow of a food-ordering chatbot app</em></p>&#13;
<p class="indent">In step 1, a user submits a request to the chatbot asking for a Greek pizza. In step 2, the chatbot processes the submitted utterance with spaCy, generating a JSON object that contains the information needed to take an order. In step 3, the JSON object representing the order form is submitted to the database, which stores the form and generates a response about it for the chatbot. In step 4, the chatbot informs the user about whether or not the order has been placed.</p>&#13;
<h4 class="h4" id="lev121"><strong><em>Moving Application Logic to the Database</em></strong></h4>&#13;
<p class="noindent">Notice that the database in the chatbot application in <a href="../Text/ch09.xhtml#ch09fig03">Figure 9-3</a> not only stores the submitted JSON object, but also generates a response to the <span epub:type="pagebreak" id="page_131"/>application about whether the operation of saving the order has been successful. The reason is that the database runs a portion of the application logic.</p>&#13;
<p class="indent">It’s quite common for database-powered applications to keep application logic related to data processing within the database. This approach allows you to reduce data moves between the application’s logic tier and the underlying database, eliminating redundancy, improving data processing efficiency, and maintaining data security.</p>&#13;
<p class="indent"><a href="../Text/ch09.xhtml#ch09fig04">Figure 9-4</a> details the database part of the chatbot application depicted in <a href="../Text/ch09.xhtml#ch09fig03">Figure 9-3</a>.</p>&#13;
<div class="image"><a id="ch09fig04"/><img src="../Images/fig9-4.jpg" alt="image" width="488" height="541"/></div>&#13;
<p class="figcap"><em>Figure 9-4: A more detailed view of the database used in the chatbot application depicted in <a href="../Text/ch09.xhtml#ch09fig03">Figure 9-3</a></em></p>&#13;
<p class="indent">In this application, the database will convert an input JSON object into relational data and store that data in a relational table in a way that guarantees that the data being inserted is correct and complete. If the value of a field is missing, the customer receives a message about what information they should supply.</p>&#13;
<p class="indent">You can check the value of each field before moving the input to the table with the help of stored procedures, <code>ON ERROR</code> clauses in SQL statements, or triggers defined on the table to which the data is sent. A more thorough discussion of SQL is outside the scope of this book. But in “<a href="../Text/ch09.xhtml#lev125">Preparing Your Database Environment</a>” on <a href="../Text/ch09.xhtml#page_135">page 135</a>, you’ll see an example of using SQL to create a database infrastructure to be used in the application, and then interact with this infrastructure using Python.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_132"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you’re using a database that doesn’t support features like converting JSON data into relational data, you’ll need to implement the logic that checks the data for completeness in Python on your own; however, this discussion is beyond the scope of this chapter.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="lev122"><strong>Building a Database-Powered Chatbot</strong></h3>&#13;
<p class="noindent">Now that you have a basic idea of how to implement a database-powered chatbot app, let’s create a simple one for the application shown in <a href="../Text/ch09.xhtml#ch09fig03">Figure 9-3</a>. The app should process a user’s utterance, extracting the information necessary to fill in an order form, such as product name, product type, and amount. Then this information gets packed into a JSON object that is sent to the underlying database. The database should shred the JSON object into relational data and then send a response to the application based on the data’s completeness.</p>&#13;
<h4 class="h4" id="lev123"><strong><em>Gathering the Data and Building a JSON Object</em></strong></h4>&#13;
<p class="noindent">We’ll start by developing the application’s logic tier and use Python to build a JSON object that we could then send to any database type. The following code shows what this implementation might look like:</p>&#13;
<pre>   import spacy<br/>&#13;
   nlp = spacy.load('en')<br/>&#13;
   doc = nlp(u'I want a Greek pizza.')<br/>&#13;
<span class="ent">➊</span> orderdict ={}<br/>&#13;
<span class="ent">➋</span> for token in doc:<br/>&#13;
  <span class="ent">➌</span> if token.dep_ == 'dobj':<br/>&#13;
       dobj = token<br/>&#13;
    <span class="ent">➍</span> orderdict.update(product = dobj.lemma_)<br/>&#13;
    <span class="ent">➎</span> for child in dobj.lefts:<br/>&#13;
      <span class="ent">➏</span> if child.dep_ == 'amod' or child.dep_ == 'compound': <br/>&#13;
           orderdict.update(ptype = child.text )<br/>&#13;
      <span class="ent">➐</span> elif child.dep_ == 'det': <br/>&#13;
           orderdict.update(qty = 1 )<br/>&#13;
      <span class="ent">➑</span> elif child.dep_ == 'nummod': <br/>&#13;
           orderdict.update(qty = child.text)<br/>&#13;
       break</pre>&#13;
<p class="indent">We define the <code>orderdict</code> dictionary as a container for the JSON object being created <span class="ent">➊</span>. We’ll be able to easily convert this dictionary to a JSON string later.</p>&#13;
<p class="indent">Then we iterate over the utterance’s tokens <span class="ent">➋</span>, looking for a direct object <span class="ent">➌</span>. We might want a pizza, or we might ask someone to make us a pizza. In either case, “pizza” will be a direct object in our utterance so we’re hunting for a direct object here. Of course, a real implementation would make more checks.</p>&#13;
<p class="noindent">Once it’s found, we define a key-value pair in the <code>orderdict</code> dictionary, sending in <code>product</code> as the key and the direct object’s lemma as the value <span class="ent">➍</span>. <span epub:type="pagebreak" id="page_133"/>We use lemmatization to reduce the possible word forms of a product’s name to its base form (converting from plural to singular in most cases).</p>&#13;
<p class="indent">Next, we iterate over the direct object’s syntactic left children <span class="ent">➎</span>, because that’s where we expect the information about the type of product requested. In terms of syntactic dependency labels, the product <code>type</code> can be either a compound or an adjectival modifier (<code>amod</code>) <span class="ent">➏</span>. For example, spaCy would consider the word “Greek” in the phrase “a Greek pizza” an adjectival modifier, whereas it considers the word “Chicago” in the phrase “a Chicago pizza” a compound.</p>&#13;
<p class="indent">Now we check for the presence of a determiner in the children of the modifier or compound. The presence of the “a” determiner implies that a customer requests a single unit of a product <span class="ent">➐</span>. In contrast, a word labeled with the dependency label <code>nummod</code> would indicate a particular number of units <span class="ent">➑</span>.</p>&#13;
<p class="indent">Print the <code>orderdict</code> dictionary using this command:</p>&#13;
<pre>print(orderdict)</pre>&#13;
<p class="indent">This should give you the following result:</p>&#13;
<pre>{'product': 'pizza', 'ptype': 'Greek', 'qty': 1}</pre>&#13;
<p class="indent">Now we have a JSON string that we can send to an underlying database for further processing.</p>&#13;
<h4 class="h4" id="lev124"><strong><em>Converting Number Words to Numbers</em></strong></h4>&#13;
<p class="noindent">Before moving on to the code that will send your JSON string to a database, consider what it will look like when a user explicitly specifies the quantity of a product, as in the following utterance:</p>&#13;
<pre>I want two Greek pizzas.</pre>&#13;
<p class="indent">If you put this into the previous script, you’d get the following result:</p>&#13;
<pre>{'product': 'pizza', 'ptype': 'Greek', 'qty': two}</pre>&#13;
<p class="indent">In the first sample sentence, the value of the <code>'qty'</code> key is a numeral. In the second, it’s a number spelled out as a word. At this stage, this difference doesn’t look like a problem. But the issue is that we must define a data type for each column of a relational table when we create it. Attempting to insert data of another type into that column will fail.</p>&#13;
<p class="indent">You should prepare your chatbot for the fact that customers will specify a product’s quantity in any way they like. To solve this problem, you’ll have to convert strings representing number words to their corresponding integer values.</p>&#13;
<p class="indent">To do this, define a list containing numbers spelled in words and sorted in increasing order; then iterate over that list to find the correct number. <span epub:type="pagebreak" id="page_134"/>In this example, we define a list for number words ranging from “zero” to “twenty,” which assumes we don’t expect that a customer will order more than twenty units of the same product with one transaction.</p>&#13;
<p class="indent">We need to implement this conversion scenario as a function that takes either a number word or a number (in the latter case, no conversion is needed) and returns a number. We should then use the function to modify the script’s code in the preceding section. Here is what the implementation of such a function might look like:</p>&#13;
<pre><span class="ent">➊</span> def word2int(numword):<br/>&#13;
     num = 0<br/>&#13;
  <span class="ent">➋</span> try:<br/>&#13;
    <span class="ent">➌</span> num = int(numword)<br/>&#13;
    <span class="ent">➍</span> return num<br/>&#13;
     except ValueError:<br/>&#13;
    <span class="ent">➎</span> pass<br/>&#13;
  <span class="ent">➏</span> words = ["zero", "one", "two", "three", "four", "five", "six", "seven",<br/>&#13;
     "eight","nine", "ten", "eleven", "twelve", "thirteen", "fourteen", <br/>&#13;
     "fifteen", "sixteen", "seventeen", "eighteen", "nineteen", "twenty"]<br/>&#13;
  <span class="ent">➐</span> for idx, word in enumerate(words):<br/>&#13;
        <span class="ent">➑</span> if word in numword:<br/>&#13;
             num = idx <br/>&#13;
  <span class="ent">➒</span> return num</pre>&#13;
<p class="indent">The <code>word2int()</code> function takes a single parameter: either a number word to be converted to the correspondent digits or a number already, in which case we won’t need to convert it <span class="ent">➊</span>. The function has to handle both cases, because we don’t know which one we’ll find in a customer’s utterance.</p>&#13;
<p class="indent">We use the <code>try</code> and <code>except</code> block to handle cases when no conversion is needed <span class="ent">➋</span>. We check whether the input is an integer <span class="ent">➌</span>, and if it is, all we have to do is return the input number as is <span class="ent">➍</span>. Otherwise, we ignore an error caused by an attempt to treat a nonnumber value as an integer and move on to converting it to a number <span class="ent">➎</span>.</p>&#13;
<p class="indent">We define a list of number words, starting from <code>zero</code> and listing them in increasing order <span class="ent">➏</span>. Then we iterate over this list with the <code>enumerate()</code> method <span class="ent">➐</span>, looking for the word the function received as input <span class="ent">➑</span>. When we find the match, we return the iteration number (the index of the word in the list) as the digit representation of the input number word <span class="ent">➒</span>.</p>&#13;
<p class="indent">Add the <code>word2int()</code> function definition to the previous script. Then move to the end of the script and find the following lines of code:</p>&#13;
<pre>      elif child.dep_ == 'nummod': <br/>&#13;
        orderdict.update(qty = child.text)</pre>&#13;
<p class="indent">Change them as follows, using the <code>word2int()</code> function defined in this section:</p>&#13;
<pre>      elif child.dep_ == 'nummod': <br/>&#13;
        orderdict.update(qty = word2int(child.text))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_135"/>Now let’s see how the script handles this sentence:</p>&#13;
<pre>I want two Greek pizzas.</pre>&#13;
<p class="indent">This time, you should get the following result:</p>&#13;
<pre>{'product': 'pizza', 'ptype': 'Greek', 'qty': 2}</pre>&#13;
<p class="indent">The value of the <code>'qty'</code> field is now a digit, and we have a consistent format to send to the database.</p>&#13;
<h4 class="h4" id="lev125"><strong><em>Preparing Your Database Environment</em></strong></h4>&#13;
<p class="noindent">To prepare your database environment, you need to install or obtain access to a database; create the components you’ll need in the database, such as a database schema, a table, and so on; and install a Python module that enables you to interact with the database.</p>&#13;
<p class="indent">Although you can choose any database that can receive and process JSON data, such as an Oracle database, this section uses MySQL. The MySQL database has a long history of supporting the most popular data interchange formats, which are XML and JSON. Also, MySQL is the world’s most popular open source database and is available on a majority of modern operating systems, including Linux, Windows, Unix, and macOS. MySQL has a freely downloadable version and commercial editions to meet specific business requirements.</p>&#13;
<p class="indent">For this chapter, you can use MySQL Community Edition—the freely downloadable version available under the GPL license. To learn more about the MySQL Community Edition, visit its official page at <em>https://www.mysql.com/products/community/</em>.</p>&#13;
<p class="indent">You’ll first need to install MySQL on your system. At the time of this writing, MySQL 8.0 is the most recent version. Refer to the “Installing and Upgrading MySQL” chapter at <em><a href="https://dev.mysql.com/doc/refman/8.0/en/installing.html">https://dev.mysql.com/doc/refman/8.0/en/installing.html</a></em> in the MySQL 8.0 Reference Manual, or the equivalent chapter for future versions of MySQL. Here, you’ll find the detailed installation instructions for your operating system.</p>&#13;
<p class="indent">After installation, you can start the MySQL server using the command the installation guide specifies for your operating system. Before you can start working with the database, you need to obtain a password for the <code>mysql</code> superuser (‘root’@‘localhost’) generated during the installation. You’ll find the password in the installation error log file.</p>&#13;
<p class="indent">Once you have the superuser password, you can connect to the MySQL server from a system terminal using the following command:</p>&#13;
<pre>$ mysql -uroot -p<br/>&#13;
Enter password: ******<br/>&#13;
mysql&gt;</pre>&#13;
<p class="indent">If you prefer to use a GUI, you can take advantage of MySQL Workbench (<em><a href="https://www.mysql.com/products/workbench/">https://www.mysql.com/products/workbench/</a></em>), which is a unified visual tool designed to model and manage MySQL databases.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_136"/>After connecting to the server, your first step is to choose a new password for the root user, replacing the random password generated during the installation. Use the following command to do so:</p>&#13;
<pre>ALTER USER 'root'@'localhost' IDENTIFIED BY <span class="codeitalic1">'Your-pswd'</span>;</pre>&#13;
<p class="indent">Now you’re ready to start developing the infrastructure on the server that you need for your application. You’ll begin by creating a database that you’ll use as the container for the other objects the application needs to interact with. To create the database, enter the following command at the <code>mysql&gt;</code> prompt:</p>&#13;
<pre>mysql&gt; CREATE DATABASE mybot;<br/>&#13;
Query OK, 1 row affected (0.03 sec)</pre>&#13;
<p class="indent">Then select the newly created database for use, as follows:</p>&#13;
<pre>mysql&gt; USE mybot;<br/>&#13;
Database changed</pre>&#13;
<p class="indent">You’re ready to start creating your database’s structure. For this example, you’ll need a single table you create with the following command:</p>&#13;
<pre>CREATE TABLE orders (<br/>&#13;
  id INT NOT NULL AUTO_INCREMENT,<br/>&#13;
  product VARCHAR(30),<br/>&#13;
  ptype VARCHAR(30),<br/>&#13;
  qty INT,<br/>&#13;
  PRIMARY KEY (id)<br/>&#13;
);</pre>&#13;
<p class="indent">With this database infrastructure set up, you need to install the MySQL Connector/Python driver, which allows your Python code to interact with that infrastructure. On any operating system, you can install Connector/Python via <code>pip</code>, as follows:</p>&#13;
<pre>pip install mysql-connector-python</pre>&#13;
<p class="indent">For further details on how to install this driver, check the documentation at <em><a href="https://dev.mysql.com/doc/connector-python/en/">https://dev.mysql.com/doc/connector-python/en/</a>.</em></p>&#13;
<p class="indent">Using the following simple script, ensure that you’ve installed Connector/Python:</p>&#13;
<pre>import mysql.connector<br/>&#13;
cnx = mysql.connector.connect(user='root', password='Your_pswd',<br/>&#13;
                              host='127.0.0.1',<br/>&#13;
                              database='mybot')<br/>&#13;
cnx.close()</pre>&#13;
<p class="indent">If the install is successful, you should see no error messages.</p>&#13;
<h4 class="h4" id="lev126"><span epub:type="pagebreak" id="page_137"/><strong><em>Sending Data to the Underlying Database</em></strong></h4>&#13;
<p class="noindent">Let’s return to the script we had on <a href="../Text/ch09.xhtml#page_134">page 134</a>. The following code connects to your database and passes order data to the <code>orders</code> table. Append this code to the script:</p>&#13;
<pre>   import json<br/>&#13;
<span class="ent">➊</span> json_str = json.dumps(orderdict)<br/>&#13;
   import mysql.connector<br/>&#13;
   from mysql.connector import errorcode<br/>&#13;
   try:<br/>&#13;
  <span class="ent">➋</span> cnx = mysql.connector.connect(user='root', password='Your_pswd',<br/>&#13;
                                   host='127.0.0.1',<br/>&#13;
                                   database='mybot')<br/>&#13;
  <span class="ent">➌</span> query = ("""INSERT INTO orders (product, ptype, qty)<br/>&#13;
     SELECT product, ptype, qty FROM<br/>&#13;
         JSON_TABLE(<br/>&#13;
        <span class="ent">➍</span> %s,<br/>&#13;
           "$" COLUMNS(<br/>&#13;
             qty    INT PATH '$.qty', <br/>&#13;
             product   VARCHAR(30) PATH "$.product",<br/>&#13;
             ptype     VARCHAR(30) PATH "$.ptype"<br/>&#13;
           )<br/>&#13;
         ) AS jt1""")<br/>&#13;
  <span class="ent">➎</span> cursor = cnx.cursor()<br/>&#13;
  <span class="ent">➏</span> cursor.execute(query, <span class="ent">➐</span>(json_str,))<br/>&#13;
  <span class="ent">➑</span> cnx.commit()<br/>&#13;
<span class="ent">➒</span> except mysql.connector.Error as err:<br/>&#13;
     print("Error-Code:", err.errno)<br/>&#13;
     print("Error-Message: {}".format(err.msg))<br/>&#13;
   finally:<br/>&#13;
     cursor.close()<br/>&#13;
     cnx.close()</pre>&#13;
<p class="indent">We start by converting the <code>orderdict</code> dictionary into a JSON string <span class="ent">➊</span>. Next, we connect to the database <span class="ent">➋</span> and define an insert SQL statement to be passed into the database for processing <span class="ent">➌</span>. Note the use of a placeholder (called a <em>bind variable</em>) in the statement <span class="ent">➍</span>. Using placeholders allows us to write SQL statements that accept inputs at runtime.</p>&#13;
<p class="indent">Before we can execute the statement, we create a <code>mysql.connector</code> cursor object <span class="ent">➎</span>, which enables operations over the objects in the database we’re connected to. Then we can execute the <code>INSERT</code> statement <span class="ent">➏</span>, binding the JSON string <span class="ent">➐</span> we obtained in the beginning of this code snippet to the placeholder in the statement. Note the use of the <code>JSON_TABLE</code> function that shreds the submitted JSON data to tabular data, making it appropriate for inserting into a relational table.</p>&#13;
<p class="indent">After the execution of the <code>INSERT</code> statement, we need to explicitly commit the statement’s changes with the <code>commit()</code> method <span class="ent">➑</span>. Otherwise, the insertion will roll back when the connection closes (either explicitly with <code>cnx.close()</code> or when the script’s execution is complete).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_138"/>The <code>except</code> block will begin to execute if an error occurs on the database side <span class="ent">➒</span>. In the next section, you’ll learn how to take advantage of this functionality when the JSON string passed in doesn’t contain all the fields.</p>&#13;
<p class="indent">Now execute the script. If you don’t see any error messages, return to the <code>mysql</code> prompt you worked with in the preceding section and enter the following select statement:</p>&#13;
<pre>mysql&gt; SELECT * FROM orders;<br/>&#13;
<br/>&#13;
ID   PRODUCT     PTYPE    QTY<br/>&#13;
---- ----------- -------- ---<br/>&#13;
1    pizza       Greek    2</pre>&#13;
<p class="indent">If you can see this output, your Python script is working as expected.</p>&#13;
<h4 class="h4" id="lev127"><strong><em>When a User’s Request Doesn’t Contain Enough Information</em></strong></h4>&#13;
<p class="noindent">Sometimes, a user’s request might not contain enough information to fill in all the fields in the order form. As an example, consider the following utterance:</p>&#13;
<pre>I want two pizzas.</pre>&#13;
<p class="indent"><a href="../Text/ch09.xhtml#ch09tab01">Table 9-1</a> shows the order form the application discussed here will generate from this sentence.</p>&#13;
<p class="tabcap" id="ch09tab01"><strong>Table 9-1:</strong> An Order Form Missing Information</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>product</strong></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>ptype</strong></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>quantity</strong></p>&#13;
</td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">pizza</p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba"/>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">2</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The value of the <code>ptype</code> field is missing because the user didn’t identify the type of pizza they want. To address this issue, enhance the <code>INSERT</code> statement in the previous script as follows:</p>&#13;
<pre>  query = ("""INSERT INTO orders (product, ptype, qty)<br/>&#13;
  SELECT product, ptype, qty FROM<br/>&#13;
      JSON_TABLE(<br/>&#13;
        %s,<br/>&#13;
        "$" <br/>&#13;
        COLUMNS(<br/>&#13;
             qty    INT PATH '$.qty' <span class="ent">➊</span>ERROR ON EMPTY, <br/>&#13;
             product   VARCHAR(30) PATH "$.product" <span class="ent">➊</span>ERROR ON EMPTY,<br/>&#13;
             ptype     VARCHAR(30) PATH "$.ptype" <span class="ent">➊</span>ERROR ON EMPTY<br/>&#13;
        )<br/>&#13;
      ) AS jt1""");</pre>&#13;
<p class="indent">We add the <code>ERROR ON EMPTY</code> option <span class="ent">➊</span> to each column in <code>JSON_TABLE</code>. This option allows us to handle errors caused by trying to insert a JSON string that doesn’t contain all the fields it’s supposed to contain.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_139"/>Now when you execute the script with the “I want two pizzas.” sample sentence, you should see the following output:</p>&#13;
<pre>Error-Code: 3665<br/>&#13;
Error-Message: Missing value for JSON_TABLE column 'ptype'</pre>&#13;
<p class="indent">We could expand on the script so in such cases the chatbot asks the customer to clarify their order using the following question:</p>&#13;
<pre>What type of pizza do you want?</pre>&#13;
<p class="indent">An answer might look like this:</p>&#13;
<pre>I want Greek ones.</pre>&#13;
<p class="indent">The structure of the sentence representing the answer we’re supposed to receive here is similar to the structure of the original sentence. Therefore, we can use the same code to analyze this answer that we used to analyze the original sentence. Of course, this approach makes assumptions about a user’s response. A real implementation would start with this approach and then, if necessary, move on to the other possible response structures. For example, a user’s response might consist of a single word, “Greek.” In that case, all we need to do is to check whether it’s included in our list of pizza types.</p>&#13;
<h4 class="h4" id="lev128"><strong><em>Try This</em></strong></h4>&#13;
<p class="noindent">The error message tells you what specific field is missing. But you still need to extract this field name from the message so you can ask the customer to clarify a specific part of their order. One way to do this is to look at the object of the preposition in the message. For example, in the message, <code>Error-Message:</code> <code>Missing value for JSON_TABLE column 'ptype'</code>, the object of the preposition is <code>ptype</code>.</p>&#13;
<h3 class="h3" id="lev129"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you learned how to cut raw text into shreds to insert the text into a relational database. You used the JSON format to interact with a database that can process a JSON input, extracting it into relational data. You also learned to implement some application logic within the database with the help of pure SQL, allowing you to move data processing closer to the data. To implement more complicated scenarios, you might need to use triggers and stored procedures—the details can be found in the documentation for the database you’re using.<span epub:type="pagebreak" id="page_140"/></p>&#13;
</div>&#13;
</body></html>