- en: Part IV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Going Further
  prefs: []
  type: TYPE_NORMAL
- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Financial Applications
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: The speech recognition and text-to-speech techniques can be applied to many
    aspects of life. In this chapter, we’ll focus on tracking the financial markets,
    but the techniques you learn here can be easily generalized and applied to your
    own area of interest, whatever that may be.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll build three projects in this chapter: an app that reports the up-to-date
    stock price of any publicly traded company; a script that builds visualizations
    of stock prices; and an app that uses recent daily stock prices to calculate returns,
    run regressions, and perform detailed analyses.'
  prefs: []
  type: TYPE_NORMAL
- en: As always, all scripts are available through the book’s resources page at [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
    Start by creating the folder */mpt/ch14/* for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Python, What’s the Facebook Stock Price?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, you’ll use the *yahoo_fin* package to obtain real-time price
    information based on the ticker symbol of a stock. A *ticker symbol* is a sequence
    of characters, or code, used to uniquely identify a stock. Most people will not
    know a company’s associated ticker symbol.
  prefs: []
  type: TYPE_NORMAL
- en: This provides the opportunity to work backward. You’ll learn to scrape the web
    to get a stock’s ticker symbol from the company name. When you enter the name
    of a firm into the script, Python will tell you the ticker symbol of the firm’s
    stock. Finally, you’ll add the text-to-speech and speech recognition features.
  prefs: []
  type: TYPE_NORMAL
- en: Obtain the Latest Stock Price
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *yahoo_fin* package lets you obtain the latest stock price information from
    Yahoo! Finance. This package isn’t in the Python standard library, so you need
    to `pip` `install` it first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your Anaconda prompt (in Windows) or a terminal (in Mac or Linux), activate
    the virtual environment *chatting*, and run the following command (note the underscore
    in the middle of the package name):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, open your Spyder editor and save [Listing 14-1](#listing14-1) as *live_price.py*
    in your chapter folder. To use this script, you need to find the ticker symbol
    for the stock you’re interested in beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-1: Retrieving real-time stock prices'
  prefs: []
  type: TYPE_NORMAL
- en: We import the *stock_info* module from the *yahoo_fin* package under the alias
    `si`. We then put the script in an infinite loop 1 to continuously take your written
    input requesting stock ticker symbols. Whenever you want to stop the script, you
    can enter `done` 2. Otherwise, the script automatically continues to obtain the
    latest stock price information for your requested company from Yahoo! Finance
    3. Finally, the script prints out the stock price information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output from an exchange with the script, with user input in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, I entered ticker symbols for Microsoft and Apple (`MSFT` and
    `AAPL`, respectively), and the script returned their latest prices.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the price of the Apple stock has many digits after the decimal.
    We’ll adjust the code a little later to show only two digits after the decimal
    for all stock prices.
  prefs: []
  type: TYPE_NORMAL
- en: For the script to work, you need the company’s stock ticker symbol, such as
    MSFT or AAPL. You may wonder, what if I don’t know the ticker symbols of the stocks
    that I’m interested in? Can Python find it if I know only the company name, such
    as Microsoft or Apple? The answer is yes, and this is when the web-scraping skills
    you learned in Chapter 6 become handy.
  prefs: []
  type: TYPE_NORMAL
- en: Find Ticker Symbols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many times, you’ll know the name of the company you’re interested in but not
    its ticker symbol. This script will find the ticker symbol when you enter the
    name of the company. This is important because our end goal is to create voice-controlled
    applications in the financial market. It’s relatively difficult for the Python
    script to pick up the ticker symbol via voice commands, but picking up the company
    name is much easier.
  prefs: []
  type: TYPE_NORMAL
- en: We need to first find a website that can reliably provide a company’s ticker
    symbol. We’ll use Yahoo! Finance and query the site using the URL [https://query1.finance.yahoo.com/v1/finance/search?q=](https://query1.finance.yahoo.com/v1/finance/search?q=)
    followed by the name of the company you want to query. For example, if you put
    *Bank of America* at the end, you’ll get a set of Python-friendly data results,
    as shown in [Figure 14-1](#figure14-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14001-r](Images/f14001-r.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-1: Results when you search for the ticker symbol for Bank of America'
  prefs: []
  type: TYPE_NORMAL
- en: This data is formatted in *JSON*, short for *JavaScript Object Notation*. This
    file format is used for browser-server communication that uses human-readable
    text to store and transmit data objects. JSON was derived from JavaScript, but
    it’s now a language-independent data format that’s used by many programming languages,
    include Python.
  prefs: []
  type: TYPE_NORMAL
- en: To make the JSON data easier to read, we’ll use the online JSON data formatter
    at [https://jsonformatter.curiousconcept.com/](https://jsonformatter.curiousconcept.com/).
    Open the URL and you’ll see a screen similar to [Figure 14-2](#figure14-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14002](Images/f14002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-2: A website to format JSON data'
  prefs: []
  type: TYPE_NORMAL
- en: Paste the data from [Figure 14-1](#figure14-1) into the designated space and
    click **Process**. The formatter will convert the data into a much more readable
    format, shown in [Listing 14-2](#listing14-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-2: The formatted JSON data for the ticker symbol search'
  prefs: []
  type: TYPE_NORMAL
- en: The dataset is a large dictionary of several elements with the key values `explains`,
    `count`, `quotes`, and so on. The value for the `quotes` key is a list of several
    dictionaries. The first dictionary contains the keys `exchange`, `shortname`,
    `quoteType`—and importantly, `symbol`, which contains the value `BAC`, the ticker
    symbol we need 1.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use a Python script to extract the ticker symbol based on the preceding
    pattern. The script *get_ticker_symbol.py*, shown in [Listing 14-3](#listing14-3),
    accomplishes that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-3: Finding a stock’s ticker symbol based on the company name'
  prefs: []
  type: TYPE_NORMAL
- en: We import the *requests* module, which allows Python to send HyperText Transfer
    Protocol (HTTP) requests. At 1, we start an infinite loop that asks for your written
    input in each iteration. To exit the loop, enter `done`. Otherwise, you enter
    in the company name 2. We use exception handling to prevent a crash 3.
  prefs: []
  type: TYPE_NORMAL
- en: We go into the JSON data and extract the list corresponding to the key `quotes`
    4. We then go to the first element and look for the value corresponding to the
    key `symbol`. The script prints out the ticker symbol at the IPython console.
    If there are no results, the script will print `Sorry, not a valid entry!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the script a few times and search for several companies to check that it
    works. The following output is one interaction with the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the script works for companies with one-word names, like Apple,
    as well as longer names, such as Walt Disney Company.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve Stock Prices via Voice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll mesh together the scripts *live_price.py* and *get_ticker_symbol.py*
    and add in the speech recognition and text-to-speech features. Enter [Listing
    14-4](#listing14-4) in a Spyder editor and save it as *live_price_hs.py* in your
    chapter folder, or download the script from the book’s resources.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-4: Use voice to retrieve real-time stock price'
  prefs: []
  type: TYPE_NORMAL
- en: We now import `print_say()` and `voice_to_text()` from the local *mptpkg* package
    to add the text-to-speech and speech recognition features.
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we start an infinite loop that asks for your voice input. To exit the
    loop, you say, “Stop listening.” Otherwise, you say a company name 2, and the
    script searches for the ticker symbol. We use `try` and `except` here to prevent
    the script from crashing because of a lack of results from Yahoo! Finance.
  prefs: []
  type: TYPE_NORMAL
- en: We save the stock price from Yahoo! Finance in `price` 3. Note that we use `round()`
    to round the stock price to two digits after the decimal. The script will speak
    the company’s stock price or, if there are no results, will say, “Sorry, I cannot
    find what you are looking for!”
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a sample interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Voice-Controlled Data Visualization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One efficient way to analyze data—for example, to find patterns in stock movements—is
    through data visualization. *Data visualization* puts data into visual contexts
    such as plots and charts to make it easy for human brains to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The price you obtained in the first project of this chapter is the latest price
    for the stock. That is, you have one data point for each stock you query. However,
    in order to learn more about a stock, it’s better to obtain a number of recent
    prices for the stock so that you can get a sense of velocity and direction. Is
    the stock staying at about the same value, rising, or falling? If the price is
    changing, how rapid is this change?
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll obtain recent daily stock price information from Yahoo!
    Finance. You’ll then plot a graph to see the price movements over time. You’ll
    also learn to create candlestick charts so that you can see intraday stock movement
    patterns. With that set up, we’ll add the speech recognition and text-to-speech
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Create Stock Price Plots
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll use the *pandas_datareader* module with *matplotlib* to create plots for
    stock prices over the last six months. First you’ll learn how to extract data,
    and then you’ll learn how to create plots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin, you need to install a few third-party modules. Go to your
    Anaconda prompt (in Windows) or a terminal (in Mac or Linux) and activate the
    virtual *chatting* environment. Then run the following lines of code one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Follow the instructions to finish the installations. The *pandas_datareader*
    module extracts online data from various sources into a *pandas* DataFrame. Then
    enter [Listing 14-5](#listing14-5) in your Spyder editor and save the script as
    *price_plot.py* in your chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-5: The script to create a stock price plot'
  prefs: []
  type: TYPE_NORMAL
- en: We import the modules, then specify the start and end dates of the data we want
    to extract 1. These will be hardcoded for now; we’ll make the dates dynamic later.
    The dates should be in the format *YYYY*-*MM*-*DD*. In this case, we’ll use the
    six-month period from September 1, 2020, to February 28, 2021\. We also provide
    the ticker symbol of the stock—in this case, Tesla with the ticker symbol TSLA
    2.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `get_data_yahoo()` in the *pandas_datareader* module to extract daily
    stock price information and save the data as a *pandas* DataFrame named `stock`
    3. The dataset looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The dataset uses dates as indexes. The 123 rows represent the 123 trading days
    during the six-month period. The six columns represent the following information
    in each trading day: high price, low price, open price, closing price, trading
    volume, and adjusted closing price.'
  prefs: []
  type: TYPE_NORMAL
- en: We then read the timestamp index of the dataset as a number and save it as an
    additional (seventh) column 4. This step is necessary because the dataset doesn’t
    recognize the index as a separate variable, but we need the date information to
    use as our x-axis in the charts. We then use the `figure()` function in *matplotlib.pyplot*
    to specify the size and resolution of the plot and name the generated figure `fig`
    5. The `dpi=128` argument makes the output 128 pixels per inch. The `figsize=(10,6)`
    argument sets the plot 10 inches wide and 6 inches tall.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `DateFormatter()` method from *matplotlib.dates* to specify the format
    of the dates we want to show 6. We do the actual plotting by using `plot()` 7.
    The first two arguments are the variables to use on the x- and y-axis, respectively.
    We also use a third argument to specify the color. In this case, we plot the adjusted
    closing price against the date and use blue as the color.
  prefs: []
  type: TYPE_NORMAL
- en: Starting at 8, we put a title on the graph and label the x- and y-axis. We also
    use `autofxt_xdate()` to show the dates on the x-axis diagonally to prevent overlapping
    text.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `show()` is called to display the plot 9. [Figure 14-3](#figure14-3)
    shows the output.
  prefs: []
  type: TYPE_NORMAL
- en: '![f14003](Images/f14003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-3: Stock price plot for Tesla from September 2020 through February
    2021'
  prefs: []
  type: TYPE_NORMAL
- en: We can see the price movement patterns of Tesla over the six-month period. The
    stock was at less than $500 per share in early September 2020 but shot up to over
    $800 per share in late December, before dropping slightly in mid-February. This
    visualization is much more reader-friendly (and informative) than the `stock`
    DataFrame output earlier!
  prefs: []
  type: TYPE_NORMAL
- en: Create Candlestick Charts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Price plots are great for summarizing patterns using one observation per day.
    Sometimes you’re interested in several intraday price movements, such as the range
    of the price fluctuation in a given day, whether the closing price is higher or
    lower than the opening price, and so on. With *candlestick charts*, you can visualize
    four pieces of information each day for a stock: daily high, daily low, opening
    price, and closing price.'
  prefs: []
  type: TYPE_NORMAL
- en: The following script generates the candlestick chart for Amazon stock in the
    month of February 2021\. I don’t recommend plotting stock prices from more than
    one month because the chart may become too crowded, making it hard to detect patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to install the third-party *mplfinance* module. Open your Anaconda
    prompt (in Windows) or a terminal (in Mac or Linux), activate the virtual environment
    *chatting*, and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Then open your Spyder editor and save [Listing 14-6](#listing14-6) as *candle_stick.py*
    in your chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-6: The script to create a candlestick chart'
  prefs: []
  type: TYPE_NORMAL
- en: We import all needed modules and functions, including the `candlestick_ohlc()`
    function from the *mplfinance* module that we’ll use to create the candlestick
    chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'At 1, we select the four daily prices that we want to extract and visualize
    in the chart: opening price, daily high, daily low, and closing price.'
  prefs: []
  type: TYPE_NORMAL
- en: The `setp()` function from *matplotlib* sets object properties, and we invoke
    it to rotate the dates on the x-axis 2. We pass two arguments (the first to obtain
    the x-axis label and the second to set the property) to rotate the x-axis label
    10 degrees, so text doesn’t overlap. At 3, we use `candlestick_ohlc()` to generate
    the candlestick chart. The first argument specifies where to place the chart,
    and the second specifies the data to use. The third argument is the width of the
    candle body relative to the distance between two observations (the distance on
    the x-axis between two trading days).
  prefs: []
  type: TYPE_NORMAL
- en: The candlestick chart uses colors to convey additional data. We use black to
    indicate that the closing price is higher than the opening price; otherwise, the
    value is gray. The information is also conveyed in the legend 4. Finally, we give
    the chart a title and label the two axes 5.
  prefs: []
  type: TYPE_NORMAL
- en: The candlestick chart for Amazon stock prices in February 2021 is shown in [Figure
    14-4](#figure14-4). The blank spaces in the chart are non-trading days (weekends
    and holidays).
  prefs: []
  type: TYPE_NORMAL
- en: The daily high and daily low are at the ends of the thin lines (which look like
    candle wicks), while the opening and closing prices are at the ends of the wide
    lines (which look like candle bodies). Hence the name!
  prefs: []
  type: TYPE_NORMAL
- en: 'From this, we can quickly see that, on February 1, the price jumped up: the
    body of the candle spans nearly $100 and is colored black. Compare this to the
    following day, where, although the thin line is relatively long, the candle body
    is short, showing that despite fluctuations, it closed at nearly the same price
    that it opened at.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f14004](Images/f14004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-4: A candlestick chart for Amazon daily stock prices in February
    2021'
  prefs: []
  type: TYPE_NORMAL
- en: Add Voice Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s add the speech functionality. When you say the company name, the script
    will search for the ticker symbol of the firm’s stock, retrieve daily price information,
    and display the plot or chart. We first need to create two local modules: one
    to display stock price plots and one to show candlestick charts.'
  prefs: []
  type: TYPE_NORMAL
- en: The Price Plot Module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll create a stock price plot module based on *price_plot.py*. Enter [Listing
    14-7](#listing14-7) in your Spyder editor and save it as *myplot.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-7: The script for the stock plot module'
  prefs: []
  type: TYPE_NORMAL
- en: We import the modules, including those we used to plot stock prices and to parse
    the HTML source file to find the firm’s ticker symbol. We also import the `print_say()`
    function from the local *mptpkg* package.
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we start `stock_plot()`, which takes the company name as the argument.
    We again use `try` and `except` to prevent crashes. We first find the ticker symbol
    of the firm 2.
  prefs: []
  type: TYPE_NORMAL
- en: Here we make the price information dynamic 3. The end date is today’s date,
    while the start date is six months ago. The script will generate a plot 4 and
    then tell you the plot is ready 5. If the ticker symbol or the price information
    can’t be found, the script will print and say, “Sorry, not a valid entry!”
  prefs: []
  type: TYPE_NORMAL
- en: The Candlestick Chart Module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next we’ll create the candlestick chart module. Open *mychart.py* from the book’s
    resources, as shown in [Listing 14-8](#listing14-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-8: The script to create the candlestick chart module'
  prefs: []
  type: TYPE_NORMAL
- en: We import the modules, including the `candlestick_ohlc()` function from the
    *mplfinance* module.
  prefs: []
  type: TYPE_NORMAL
- en: We define `candle_stick()` at 1. Here we make the price information dynamic.
    The end date is today’s date, while the start date is two weeks ago. We then perform
    the same actions as in *myplot.py* to search for the ticker symbol. With the ticker
    symbol, we retrieve the daily stock price information in the past 14 days from
    Yahoo! Finance. I’ve snipped this part of the script to save space.
  prefs: []
  type: TYPE_NORMAL
- en: The data used for the candlestick chart will be the date plus the opening price,
    daily high and low prices, and closing price 2. The script builds the candlestick
    chart and lets you know when it’s done 3.
  prefs: []
  type: TYPE_NORMAL
- en: The Main Script
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we’ll import the two modules to the main script so that we can voice-activate
    a stock price plot or a candlestick chart. Enter [Listing 14-9](#listing14-9)
    in your Spyder editor and save it as *plot_chart_hs.py* in your chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-9: The script to voice-control plot and chart creation'
  prefs: []
  type: TYPE_NORMAL
- en: We import the modules and add the `print_say()` and `voice_to_text()` functions.
    We also import `price_plot()` from the local *myplot* module and `candle_stick()`
    from the local *mychart* module that we just created.
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we start an infinite loop that asks for your voice input. To exit the
    script, you say, “Stop listening” 2. To see the stock plot of a firm (say, Goldman
    Sachs), you say, “Stock pattern for Goldman Sachs.” The “stock pattern for” will
    trigger the stock plot functionality 3. We use “stock pattern” instead of “stock
    plot” because it’s easier for the microphone to pick up. The script then extracts
    the company name, which is Goldman Sachs in this case, and uses it as the argument
    in the `price_plot()` function.
  prefs: []
  type: TYPE_NORMAL
- en: To see the candlestick chart of a firm (say, General Motors), you say, “Chart
    for General Motors.” The “chart for” part of the voice command will trigger the
    candlestick chart functionality 4. The script then extracts the company name and
    uses it as the argument in the `candle_stick()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my sample output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The “price pattern for Oracle” phrase triggered the price plot functionality,
    and the script generated the price plot for Oracle, shown in [Figure 14-5](#figure14-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14005](Images/f14005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-5: Voice-controlled stock price plot for Oracle'
  prefs: []
  type: TYPE_NORMAL
- en: The “chart for Intel” phrase prompted the script to create a candlestick chart
    for Intel, shown in [Figure 14-6](#figure14-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14006](Images/f14006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-6: Voice-controlled candlestick chart for Intel'
  prefs: []
  type: TYPE_NORMAL
- en: Voice-Controlled Stock Report
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the price plots and candlestick charts allow us to see recent price movements,
    they don’t give us information on how a stock has performed relative to the general
    market. Many times, investors are interested in how well a stock has performed
    in comparison to a benchmark index. They’re also interested in the risk of a stock,
    measured in how volatile a stock’s price has been relative to the market as a
    whole.
  prefs: []
  type: TYPE_NORMAL
- en: To that end, we’ll progress to a more detailed analysis of a stock’s price.
    You’ll obtain recent daily stock price information and perform regression analyses
    to figure out the recent performance and market risk of the stock. You’ll calculate
    the stock’s abnormal return (*alpha*, which is the relative performance of the
    stock compared to the market as a whole) and the market risk (*beta*, which measures
    how volatile the stock’s return has been compared to the market as a whole) by
    running a regression of the stock’s return on the market return.
  prefs: []
  type: TYPE_NORMAL
- en: Analyze Recent Stock Performance and Risk
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll use the same methods we’ve used so far to extract recent daily stock
    price information from Yahoo! Finance using the *pandas_datareader* module. You’ll
    then use a new module *statsmodels* to perform statistical analyses.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll install the third-party module and extract data. Go to your Anaconda
    prompt (in Windows) or a terminal (in Mac or Linux) and activate the virtual *chatting*
    environment. Then run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Enter [Listing 14-10](#listing14-10) in your Spyder editor and save the script
    as *alpha_beta.py* in your chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-10: The script to calculate stock alpha and beta'
  prefs: []
  type: TYPE_NORMAL
- en: We import the modules and then specify the start and end dates of the data you
    want to extract. We again use the most recent six-month period. We also provide
    the ticker symbols of the market index, which is an index that represents the
    market as a whole. The S&P 500 Index is often used, and that is what we will use.
    The company we’ll analyze is Microsoft Corporation. We use the `get_data_yahoo()`
    method in the *pandas_datareader* module to extract daily stock price information
    for the market index and Microsoft, and we save the data as two *pandas* DataFrames
    named `sp` and `stock`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We then calculate the daily stock returns for both the S&P 500 and Microsoft.
    The `shift()` method in *pandas* allows us to shift the index by a desired number
    of periods. We use `shift(1)` to obtain the price information of the previous
    trading day. This allows us to see how today compared to yesterday. Comparing
    the two days enables us to calculate returns. The *gross return* is the current
    value divided by the value at the close of the previous trading day, and the *net
    return* is the gross return minus one.
  prefs: []
  type: TYPE_NORMAL
- en: To calculate alpha and beta, we first merge the two datasets into one. For simplicity,
    we use a small constant value for the risk-free rate 1. We then use the `OLS()`
    method in the *statsmodels* module to run a regression 2 and print out the regression
    results. The alpha and beta we want are the regression coefficients on the constant
    and the excess return on the market, respectively 3.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-7](#figure14-7) shows the regression results.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f14007](Images/f14007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-7: Regression analysis results for Microsoft'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we print out the values of the firm’s alpha and beta as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The analysis shows that the alpha and beta are 0.202 percent and 1.1, respectively.
    This means Microsoft has outperformed similar stocks on the market by 0.202 percent
    per day, and the company has a market risk slightly greater than an average firm
    (which has a beta of 1), which means the stock’s return has been slightly more
    volatile than the market as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Add Voice Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s add the voice control! You’ll ask about a company, and the script will
    search for the ticker symbol, retrieve daily stock information, and calculate
    the alpha and beta. Then the script will let you know that information by voice.
    The phrase “stock report for” will trigger the stock report functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Enter [Listing 14-11](#listing14-11) in your Spyder editor and save the script
    as *alpha_beta_hs.py* in your chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-11: Voice-control the calculation of stock alpha and beta'
  prefs: []
  type: TYPE_NORMAL
- en: We import the modules, including the *requests* module and the `print_say()`
    and `voice_to_text()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we start the definition of `alpha_beta()`, using the firm name as its
    argument. As before, we use the plus sign to join words together to use as search
    terms for the ticker symbol on Yahoo! Finance 2. We use `try` and `except` to
    prevent crashes and let the user know if the entry is invalid. The script then
    calculates the firm’s alpha and beta, as it does in *alpha_beta.py*, and both
    prints and speaks the alpha and beta 3.
  prefs: []
  type: TYPE_NORMAL
- en: At 4, we start an infinite loop that asks for your voice input. To exit the
    script, say, “Stop listening.” Otherwise, you say, “Stock report for” followed
    by the company name to activate the stock report functionality. The script extracts
    the company name from your voice command and prepares the report for you 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my sample interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: I asked for the “stock report for Alibaba,” and the script obtained the report
    for me and replied, “The alpha of Alibaba is 0.059 percent; the beta of the stock
    Alibaba is 0.61.”
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you applied the speech recognition and text-to-speech techniques
    to the financial market. These skills—scraping information, forming search terms
    that can be used in URLs, and retrieving real-time as well as recent daily stock
    price information—can be applied to a huge variety of web applications. You also
    learned a few data analysis and visualization skills, which are also handy for
    many applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll create talking graphical market watches for financial
    markets such as the US stock market or the foreign exchange market.
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify *price_plot.py* so that the start and end dates are March 1, 2021 and
    June 1, 2021, respectively, and the plot color is red.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *candle_stick.py* so that the dates on the x-axis are in the format of
    01-01-2021 (instead of 01/01/2021 or January 1, 2021) and rotated 15 degrees.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stock Market Watch
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll create a graphical, speaking app that monitors the US
    stock market in real time. When you run the script during trading hours, you’ll
    see a graphical display of the major stock indexes and a couple of stocks you
    select. The app also lets you know the values of the indexes and the stock prices
    in a human voice.
  prefs: []
  type: TYPE_NORMAL
- en: To build up the necessary skills, you’ll first create a graphical Bitcoin watch
    to display live price information, using the Python *tkinter* package. You can
    generalize these techniques to other financial markets such as the world stock
    market or the US Treasury bond market.
  prefs: []
  type: TYPE_NORMAL
- en: As always, all scripts are available through the book’s resources page at [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/),
    and you should make the folder */mpt/ch15/* for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Bitcoin Watch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll start with Bitcoin because the Bitcoin price is updated 24/7, unlike the
    stock market, which gives live price updates only when it’s open. In the process
    of creating a Bitcoin watch, you’ll learn the necessary skills to build a market
    watch for other financial markets. The script tells you whenever the Bitcoin price
    changes or if the price moves outside preset upper or lower bounds.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll first learn how to read JSON data and some basics of the *tkinter* package.
  prefs: []
  type: TYPE_NORMAL
- en: How to Read JSON Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bitcoin prices are available online for free and are updated every minute or
    so day and night. We’ll access Bitcoin prices through Python by using the API
    [https://api.coindesk.com/v1/bpi/currentprice.json](https://api.coindesk.com/v1/bpi/currentprice.json).
    Open the URL with a web browser, and you should see price information similar
    to [Figure 15-1](#figure15-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f15001](Images/f15001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-1: Live online information about Bitcoin price'
  prefs: []
  type: TYPE_NORMAL
- en: This data is formatted in JSON and hard to read. There are so many nested dictionaries,
    it’s hard to tell where one dictionary starts and ends. We discussed in Chapter
    14 how to make the data easier to understand by using an online JSON data formatter.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to what you did in that chapter, go to the online JSON data formatter
    website, [https://jsonformatter.curiousconcept.com/](https://jsonformatter.curiousconcept.com/),
    paste the data from [Figure 15-1](#figure15-1) into the designated space, and
    then click **Process**. The formatter will convert the data into a much more readable
    format, shown in [Listing 15-1](#listing15-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-1: The formatted JSON data about the Bitcoin price'
  prefs: []
  type: TYPE_NORMAL
- en: 'The dataset is a large dictionary of four elements with keys named `time` 1,
    `disclaimer` 2, `chartName` 3, and `bpi` 4. The value for the `bpi` key is, in
    turn, another dictionary with three keys: `USD`, `GBP`, and `EUR`. These represent
    the Bitcoin price in US dollars, British pounds, and Euros, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: We want the Bitcoin price in US dollars. The script *bitcoin_price.py*, shown
    in [Listing 15-2](#listing15-2), retrieves the Bitcoin price and prints it out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-2: The script to retrieve the Bitcoin price'
  prefs: []
  type: TYPE_NORMAL
- en: We import the *requests* module and specify the URL for the live Bitcoin price.
    We then use the `get()` method from the *requests* module to pull the data from
    the API. The `json()` method in the *requests* module reads the information into
    JSON format. We then extract the USD dictionary that contains all the Bitcoin
    price information in US dollars. The value we need from the dictionary is the
    price, and we use the `rate_float` key to retrieve it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we print out the Bitcoin price. The output should be something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A Quick Introduction to the tkinter Package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python’s default standard package for building a GUI is *tkinter*, short for
    *Tk interface*. The *tkinter* package has a variety of *widgets*, which are various
    tools like buttons, labels, entries, and message boxes. Widgets appear as different
    types of small windows inside the top-level root window, but they can also be
    stand-alone entities. We’ll focus on labels since we’ll use them in the market
    watch projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *tkinter* package is in the Python standard library and needs no installation.
    If you are using Linux and encounter the `ModuleNotFoundError` when importing
    *tkinter*, execute this line of command in a terminal to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: I’ll introduce you to the basics of *tkinter*, including how to set up a screen
    and create a label widget. The script *tk_label.py*, shown in [Listing 15-3](#listing15-3),
    sets up a screen and adds a label to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-3: Create a label in the *tkinter* package'
  prefs: []
  type: TYPE_NORMAL
- en: We import the *tkinter* package. We set up a root window, which is used to hold
    all the widgets we’ll add to the script. We use the command `Tk()` and name the
    root window `root`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Labels* are a simple form of widget used to display messages or images for
    informational purposes. We give the root window a title, `A Label Inside a Root
    Window`, which will appear in the title bar. We call the `geometry()` method to
    specify the width and height of the root window as 800 by 200 pixels.'
  prefs: []
  type: TYPE_NORMAL
- en: We initiate a label by using `Label()`, which takes the text (or image) you
    want to display. You can optionally specify the color and font too. We use red
    and set the font to `("Helvetica", 80)`.
  prefs: []
  type: TYPE_NORMAL
- en: With the `pack()` method, we specify where we want to put the label. The default
    is to line up widgets starting from the top center of the root window. Finally,
    `mainloop()` starts the game loop so that the window shows up and stays on your
    computer screen.
  prefs: []
  type: TYPE_NORMAL
- en: Run the script and you should see [Figure 15-2](#figure15-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![f15002](Images/f15002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-2: A label inside the root window in *tkinter*'
  prefs: []
  type: TYPE_NORMAL
- en: A Graphical Bitcoin Watch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll create a graphical Bitcoin watch by using the *tkinter* package. Open
    your Spyder editor and save the code in [Listing 15-4](#listing15-4) as *bitcoin_tk.py*
    in your chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-4: Create a graphical Bitcoin price watch'
  prefs: []
  type: TYPE_NORMAL
- en: We import the necessary functions and modules, including the *arrow* module
    to show the current time and date 1. We then use the `Tk()` method to create a
    top-level root window and specify the title and the size 2.
  prefs: []
  type: TYPE_NORMAL
- en: We create two labels using `Label()` 3. We first leave the messages in both
    labels as empty strings because this information will fill in from the Bitcoin
    watch. At 4, we define `bitcoin_watch()`. The function first uses the *requests*
    module to obtain the Bitcoin price information from the URL we provide. We also
    obtain the current date and time and save them in the variables `tdate` and `tm`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: At 5, we put the current date and time information in the first label, using
    the escape character `\n` to separate the lines. We put the live Bitcoin price
    in the second label.
  prefs: []
  type: TYPE_NORMAL
- en: Next we set animation effects 6. We use `after()` to call another function after
    a specified amount of time. The command `after(1000, bitcoin_watch)` calls the
    function `bitcoin_watch()` after 1,000 milliseconds. Calling the command within
    the `bitcoin_watch()` function itself creates an infinite loop in which all the
    command lines inside `bitcoin_watch()` will be executed every 1,000 milliseconds.
    The result is that the time is constantly updated, and you can see the time value
    changes every second. If you keep the screen live long enough, you will also see
    the Bitcoin price change every minute or so.
  prefs: []
  type: TYPE_NORMAL
- en: When run, the script should look similar to [Figure 15-3](#figure15-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![f15003](Images/f15003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-3: Using the `after()` function to create an animated Bitcoin watch'
  prefs: []
  type: TYPE_NORMAL
- en: A Talking Bitcoin Watch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next we’ll add the speech functionality. Whenever the price updates, the script
    will let you know in a human voice. We’ll also add an alert system: when the Bitcoin
    price moves outside the preset upper and lower bounds, the script will alert you
    out loud.'
  prefs: []
  type: TYPE_NORMAL
- en: Open *bitcoin_watch.py* from your chapter folder. Its differences from *bitcoin_tk.py*
    are highlighted in [Listing 15-5](#listing15-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-5: Script to create a talking graphical Bitcoin price watch'
  prefs: []
  type: TYPE_NORMAL
- en: We import the modules, including the `print_say()` function from the local *mptpkg*
    package.
  prefs: []
  type: TYPE_NORMAL
- en: We retrieve a Bitcoin price to use as the starting price and save it as `oldprice`
    1. We set the upper and lower bounds as values 5 percent above and below the value
    stored in `oldprice` and save them as `maxprice` and `minprice`, respectively.
    The script announces in a human voice the price of Bitcoin at that moment 2.
  prefs: []
  type: TYPE_NORMAL
- en: We declare `oldprice` a global variable so that it can be recognized both inside
    and outside the function `bitcoin_watch()` 3. Every time `bitcoin_watch()` is
    called, it obtains the latest Bitcoin price and compares it to the value stored
    in `oldprice`. If the values are different, the value of `oldprice` is updated
    to the new price, and the script announces the updated price 4.
  prefs: []
  type: TYPE_NORMAL
- en: At 5, the script checks whether the price has gone above the upper bound; if
    yes, it makes the announcement. Similarly, the script checks whether the price
    is below the lower bound and makes the announcement if it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'This output is from running the script for a few minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: A Talking Stock Market Watch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we’ll use these skills to build the talking, graphical, live US stock market
    watch. We’ll make several significant changes to the Bitcoin version.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, instead of showing just one asset, we’ll cover three major players in
    the market: Apple, Amazon, and Tesla. We’ll also show, as the main indexes we
    are interested in, the Dow Jones Industrial Average and the S&P 500\.'
  prefs: []
  type: TYPE_NORMAL
- en: Second, instead of updating every thousand milliseconds, we’ll ask the script
    to update every two minutes. The script needs to retrieve five pieces of information
    instead of just one, and updating too frequently will cause information overload
    that could lead to the script freezing. More important, the values for the market
    indexes and prices for the preceding three stocks update every few seconds during
    the trading hours. Updating too often would make the announcements come nonstop
    and be distracting. You can choose to adjust the frequency that the script updates
    to your own liking.
  prefs: []
  type: TYPE_NORMAL
- en: Save the script in [Listing 15-6](#listing15-6) as *stock_watch.py* in your
    chapter folder or download it from the book’s resources page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-6: Script to create a talking, graphical live US stock market watch'
  prefs: []
  type: TYPE_NORMAL
- en: We import the modules, including *arrow* to show the time and date and *yahoo_fin*
    to obtain stock price information. We also import `print_say()` from the local
    *mptpkg* package to make announcements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting at 1, we create the *tkinter* root window and place two labels in
    it, as we did in *bitcoin_watch.py*. We then create three lists: `oldprice`, `maxprice`,
    and `minprice` 2. We use `oldprice` to keep track of the values of the two indexes
    and the prices of the three stocks when we start running the script. The list
    `maxprice` holds the five upper bounds, 5 percent above the corresponding values
    in `oldprice`. Similarly, we define the five lower bounds in `minprice`.'
  prefs: []
  type: TYPE_NORMAL
- en: The script then announces the values of the two indexes and the prices of the
    three stocks. Note that we put `dollars` after the three stock prices, but not
    after the two index values because index values are not measured in dollars.
  prefs: []
  type: TYPE_NORMAL
- en: We define `stock_watch()` at 3, which declares `oldprice`a global variable.
    Every time the function is called, it retrieves the values we’re interested in
    4. We keep two digits after the decimal for all values and save them in a list
    `p` 5.
  prefs: []
  type: TYPE_NORMAL
- en: We obtain the time and date and put them in the first label. We put the values
    of the two indexes and three stocks in the second label. At 6, we check each of
    the five values for updates, and we print and announce any updates. We also update
    the value stored in `oldprice` accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Starting at 7, we check whether any of the five values has gone out of bounds.
    If yes, the script makes an announcement. Finally, we use `after()` to create
    the animation effect 8. The `stock_watch()` function calls itself every 120,000
    milliseconds, updating the screen every two minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output from one interaction with the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In just a few minutes, the script has updated all five values three times. [Figure
    15-4](#figure15-4) shows the final screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![f15004](Images/f15004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-4: A graphical live US stock market watch'
  prefs: []
  type: TYPE_NORMAL
- en: Apply the Method to Other Financial Markets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can apply these methods to other financial markets. If the price information
    is available from Yahoo! Finance, the modification is minimal: we just change
    the ticker symbols in the scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: If the price information is not available from Yahoo! Finance, search online
    for a website that provides JSON data for the market and then use the same method
    we used to retrieve the Bitcoin price.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you first learned how to retrieve information from JSON data
    and use it to create a graphical Bitcoin watch using the *tkinter* package. You
    obtained the live Bitcoin price online and created widgets with animations in
    *tkinter*.
  prefs: []
  type: TYPE_NORMAL
- en: With these skills, you made a graphical live market watch for the US stock market
    with spoken alerts. The script generates a graphical display of two major US stock
    indexes and three stocks that you’re interested in. When the prices change, the
    script lets you know in a human voice. The script also alerts you if an index
    value or a stock price goes outside the preset bounds.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how to apply this process to create a talking graphical market
    watch for other financial markets.
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify *bitcoin_price.py* to retrieve the price in British pounds instead of
    US dollars and as a string variable instead of a floating-point number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *tk_label.py* so that the size of the root window is 850 by 160 pixels
    and the message in the label displays `here is your label`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *bitcoin_tk.py* so that the screen refreshes every 0.8 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *bitcoin_watch.py* so that the upper and lower bounds are set to 3 percent
    above and below the price when you start running the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use World Languages
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: So far, we’ve taught Python how to speak and listen in English. But Python can
    understand many other world languages. In this chapter, you’ll first teach Python
    to talk in several other languages with the modules we’ve been using. I’ll then
    introduce a useful module called *translate*, which can translate one language
    to another, and you’ll use this to silently translate languages. Then we’ll add
    the speech recognition and text-to-speech features so you can speak one language
    to the Python script and the script will say the translation in another language
    of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, all scripts in this chapter are available at the book’s resources
    page at [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
    Start by creating the folder */mpt/ch16/* for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Text to Speech in Other Languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work with non-English languages, we’ll use *gTTS* because it supports most
    major world languages. The downside to using *gTTS* is that it needs a separate
    module to play the audio file, but the alternative (*pyttsx3*) doesn’t support
    a wide range of non-English languages. Here we’ll try out the *gTTS* module with
    a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Install Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To install the *gTTS* module in Windows, activate the virtual environment *chatting*
    and then execute the following command in the Anaconda prompt and follow the onscreen
    instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re using Mac or Linux, you should already have installed the *gTTS*
    module in Chapter 4. However, Google Translate has been known to make significant
    changes to the module, so you should upgrade to the latest version by running
    the following command in a terminal with the virtual environment *chatting* activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You also need to install the *pydub* module to play audio files. You need to
    do this step no matter whether you’re using Windows, Mac, or Linux. Execute the
    following two lines of code in the Anaconda prompt (Windows) or a terminal (Mac
    or Linux), with the *chatting* virtual environment activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Follow the instructions all the way through.
  prefs: []
  type: TYPE_NORMAL
- en: Convert Text to Speech in Spanish
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The script *speak_spanish.py* in [Listing 16-1](#listing16-1) shows how the
    *gTTS* module converts written Spanish into spoken Spanish. Enter these lines
    of code in your Spyder editor and save the script as *speak_spanish.py* in your
    chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 16-1: Script to convert written Spanish to spoken Spanish'
  prefs: []
  type: TYPE_NORMAL
- en: We first import the modules, including *gTTS* and *pydub*, that will play the
    audio file.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the `gTTS()` function to convert the Spanish phrase `Buenos días`
    to spoken Spanish. The phrase can be literally translated to *Good day*. The first
    argument to `gTTS()` specifies which phrase to convert, and the second specifies
    what language to use. In this case, we use `es`, which stands for *Español*, or
    *Spanish* (see [Table 16-1](#table16-1) for a list of language codes).
  prefs: []
  type: TYPE_NORMAL
- en: The script generates a temporary file *voice* by using the `BytesIO()` function
    in the *io* module. If you instead used a fixed filename (such as *myfile.mp3*),
    the script may prevent you from overwriting the file when you rerun it and can
    crash. By using a temporary file each time you run the script, you avoid a crash.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we save the voice output as an audio file in the temporary file *voice*
    we just created. Then we play the audio file by using the *pydub* module. Run
    the script to hear Python say “Buenos días” in Spanish.
  prefs: []
  type: TYPE_NORMAL
- en: Support Text to Speech in Other Languages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *gTTS* module can convert text to speech in most major languages. [Table
    16-1](#table16-1) provides an incomplete list of the languages that the module
    supports, followed by the code used in the `gTTS()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 16-1: Major World Languages and the Corresponding Code in the *g**TTS*
    Module'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Language name** | **Language code** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Arabic | `ar` |'
  prefs: []
  type: TYPE_TB
- en: '| Chinese | `zh` |'
  prefs: []
  type: TYPE_TB
- en: '| Dutch | `nl` |'
  prefs: []
  type: TYPE_TB
- en: '| English | `en` |'
  prefs: []
  type: TYPE_TB
- en: '| French | `fr` |'
  prefs: []
  type: TYPE_TB
- en: '| German | `de` |'
  prefs: []
  type: TYPE_TB
- en: '| Italian | `it` |'
  prefs: []
  type: TYPE_TB
- en: '| Japanese | `ja` |'
  prefs: []
  type: TYPE_TB
- en: '| Korean | `ko` |'
  prefs: []
  type: TYPE_TB
- en: '| Portuguese | `pt` |'
  prefs: []
  type: TYPE_TB
- en: '| Russian | `ru` |'
  prefs: []
  type: TYPE_TB
- en: '| Spanish | `es` |'
  prefs: []
  type: TYPE_TB
- en: You can find a more comprehensive list at [https://cloud.google.com/speech-to-text/docs/languages/](https://cloud.google.com/speech-to-text/docs/languages/).
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll create a script to choose the language you want. After that, you’ll
    ask the script to translate a phrase from text to spoken language.
  prefs: []
  type: TYPE_NORMAL
- en: Convert Text to Speech in World Languages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The script *speak_world_languages.py* in [Listing 16-2](#listing16-2) shows
    you how to convert text to speech in several major world languages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 16-2: Script to convert written language to spoken language'
  prefs: []
  type: TYPE_NORMAL
- en: We create a dictionary *lang_abbre*, which maps different foreign languages
    to the corresponding codes in the *gTTS* module 1. The script then asks what language
    you want to use. You can type in your choice in the IPython console 2. Then type
    in the phrase you want to convert to voice at the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: The script converts your phrase into an audio file and saves it in the temporary
    file *voice*.Then it plays the audio file by using the *pydub* module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an interaction with the script, with my text input in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: I first chose the language Chinese and then typed in the text `嗨,你好吗?`, which
    is the Chinese phrase for *Hi, how are you?* After running the script, I heard
    Python speaking Chinese.
  prefs: []
  type: TYPE_NORMAL
- en: Speech Recognition in Major World Languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The speech recognition module we’ve used throughout this book is able to recognize
    other major world languages as well. We just need to let the script know which
    language we want to use.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use Japanese as an example to illustrate how it works. The script *sr_japanese.py*
    in [Listing 16-3](#listing16-3) recognizes spoken Japanese and converts your voice
    into written text.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 16-3: Speech recognition in Japanese'
  prefs: []
  type: TYPE_NORMAL
- en: We first import the speech recognition module. Then we initiate speech recognition
    by using the `Recognizer()` function. The script prints out the message `Python
    is listening in Japanese` to prompt you to speak Japanese into the microphone.
    We use the `adjust_for_ambient_noise()` function to reduce the influence of any
    ambient noise on your voice input.
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we specify Japanese by passing `language="ja"` in the `recognize_google()`
    function. Recall from Chapter 3 that `recognize_google()` uses the Google Web
    Speech API; this is in contrast to other methods such as `recognize_bing()`, which
    uses the services of Microsoft Bing Speech, or `recognize_ibm()`, which uses the
    services of IBM Speech to Text. The script then prints out your voice input in
    Japanese.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my output from interacting with the computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: I said into the microphone “Thank you” in Japanese. The script correctly captures
    the phrase and prints it out.
  prefs: []
  type: TYPE_NORMAL
- en: You can easily modify *sr_japanese.py* by replacing `language="ja"` (and the
    appropriate language titles in the prompts) with the language of your choice so
    that you can interact with the computer in another language. The list of world
    languages and their corresponding codes can be found at [https://www.science.co.il/language/Locale-codes.php.](https://www.science.co.il/language/Locale-codes.php.)
  prefs: []
  type: TYPE_NORMAL
- en: A Talking Wikipedia
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wikipedia supports most major world languages, detailed at [https://en.wikipedia.org/wiki/List_of_Wikipedias](https://en.wikipedia.org/wiki/List_of_Wikipedias).
    In Chapter 5, we created a talking Wikipedia in English. We’ll build a version
    you can adapt to work with any major language. [Listing 16-4](#listing16-4) uses
    Chinese. Enter the following code into your Spyder editor and save it as *wiki_world_languages.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 16-4: A talking Wikipedia in major world languages'
  prefs: []
  type: TYPE_NORMAL
- en: We import the modules, including the *wikipedia* module we used in Chapter 5.
    The dictionary *lang_abbre* maps different foreign languages to the corresponding
    codes in the *gTTS* module. We’ll also use the language codes in the *speech_recognition*
    module and the *wikipedia* module.
  prefs: []
  type: TYPE_NORMAL
- en: The script then asks what language you want to use 1. You can type in your choice
    in the IPython console. Then speak your query into the microphone in the language
    you chose 2. The script captures the voice input, converts it to written text,
    and stores it in `my_input`.
  prefs: []
  type: TYPE_NORMAL
- en: The script then prints your query 3. After it does so, we set the language of
    Wikipedia to the language of your choice. We then send the query to Wikipedia
    and print the result. Finally, we convert the answer to speech and let the script
    say it in a human voice 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output from an interaction with the script, with my written and
    voice inputs in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: I first typed in `chinese` as my choice of language. Then I said “United States
    of America” in Chinese into the microphone, and the script stored a short description
    of the United States in Chinese and both printed and spoke it.
  prefs: []
  type: TYPE_NORMAL
- en: Create Your Own Voice Translator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you’ll create your own voice translator. When you speak to the script in
    any major language, the script will translate it to another language of your choice
    and speak it out.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll first make a text version with the *translate* module, then add speech
    recognition and text-to-speech features.
  prefs: []
  type: TYPE_NORMAL
- en: A Text-Based Translator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We first need to install the *translate* module, powered by Google Translate.
    The module is not in the Python Standard Library, and we need to `pip install`
    it. Open the Anaconda prompt (in Windows) or a terminal (in Mac or Linux). With
    the virtual environment *chatting* activated, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Follow the instructions to finish the installation.
  prefs: []
  type: TYPE_NORMAL
- en: The script in [Listing 16-5](#listing16-5) translates English to Chinese, and
    translates Chinese to English, by using text input. Open your Spyder editor and
    copy the following code; then save it as *english_chinese.py* in your chapter
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 16-5: Translation between English and Chinese'
  prefs: []
  type: TYPE_NORMAL
- en: We first import the `Translator()` function from the *translate* module. We
    need to specify the input language (here, English `from_lang="en"`) and the output
    language (here, Chinese with `to_lang="zh"`). We translate the phrase `hello all`
    from English to Chinese and print it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we reverse the input and output languages to translate the phrase `请再说一遍`
    from Chinese to English and print it. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We can modify the input and output languages in *english_chinese.py* to use
    any two major world languages. To see the languages supported by the *translate*
    module and their corresponding codes, check [https://www.labnol.org/code/19899-google-translate-languages/](https://www.labnol.org/code/19899-google-translate-languages/).
  prefs: []
  type: TYPE_NORMAL
- en: A Voice-Based Translator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we’ll add speech recognition and text-to-speech functionality. Again,
    we’ll hardcode the language to translate to and from, but you can easily adapt
    this script to any supported language.
  prefs: []
  type: TYPE_NORMAL
- en: This version translates English to Spanish and Spanish to English. Open your
    Spyder editor and copy [Listing 16-6](#listing16-6). Save the script as *voice_translator.py*
    in your chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 16-6: A voice translator between English and Spanish'
  prefs: []
  type: TYPE_NORMAL
- en: We first import all modules. Then we initiate speech recognition by using the
    `Recognizer()` function. Next, the script prints `say something in English` to
    prompt you to speak the English phrase you want to translate.
  prefs: []
  type: TYPE_NORMAL
- en: The script captures your voice input, saves it in the variable `my_input`, and
    prints it. At 1, we specify the input language as English and the output language
    as Spanish. We then translate the text stored in `my_input` to Spanish and print
    it 2. After printing the translation, we convert the Spanish text to voice. Finally,
    we save the translation to an audio file and play it 3.
  prefs: []
  type: TYPE_NORMAL
- en: Starting at 4, we reverse the input and output languages. You can then speak
    a Spanish phrase to translate, and the computer will give the English translation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output from an interaction with the script, with my voice input
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: I spoke the phrase “Today is a great day” in English. The script printed and
    spoke the Spanish translation `Hoy es un gran día`. I then said in Spanish, “uno,
    dos, tres.” The script correctly printed and spoke the English translation `1
    2 3`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you adapted your speaking scripts to use any major world language.
    Along the way, you learned to convert text to speech in major world languages
    such as Spanish, Chinese, Japanese, French, and so on. You also learned how to
    perform speech recognition in major world languages. With these skills, you are
    able to interact with your computer in non-English languages.
  prefs: []
  type: TYPE_NORMAL
- en: You then learned how to install the *translate* module, which can translate
    text from one language to another. We combined the module with the speech recognition
    and text-to-speech features to create a voice translator. This is incredibly useful
    real-world functionality that can help make your deployed applications globally
    adaptable.
  prefs: []
  type: TYPE_NORMAL
- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ultimate Virtual Personal Assistant
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll load up a virtual personal assistant (VPA) with the
    interesting projects in this book, like voice-controlled games, voice translators,
    voice music activations, and so on. You’ll first add a chatting functionality
    to the script so you can carry out a daily conversation with the VPA. You’ll create
    a dictionary of questions and answers. Whenever your voice command matches one
    of the questions in the dictionary, the VPA speaks the answer from the dictionary.
    This enables the VPA to answer certain questions in a very particular way, instead
    of obtaining an answer from Wikipedia or WolframAlpha.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, you’ll add the following functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: The voice-activated music player from Chapter 5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The voice-activated NPR News Now from Chapter 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The voice-activated radio functionality from Chapter 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The voice-activated Connect Four game from Chapter 13 (and the tic-tac-toe game
    from the exercises)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stock price functionality that lets you find out the latest price of US stocks
    and their index values from Chapter 15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Translator functionality that renders English phrases in any major world language
    in Chapter 16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The whole idea of a VPA is its convenience, so we’ll make adjustments in these
    projects so that all added functionalities are 100 percent hands-free. After a
    functionality is finished, the VPA will go back to the main menu and wait for
    your voice command.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, all scripts in this chapter are available at the book’s resources
    page, [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
    Start by creating the folder */mpt/ch17/* for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: An Overview of the Final VPA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s have a look at the complete script of our final VPA. I’ll then explain
    its individual functionalities one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'First you need to download several local module files. From the book’s resources
    page ([https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/)),
    find the following files from the */mpt/mptpkg/* directory: *mymusic.py*, *mynews.py*,
    *myradio.py*, *myttt.py*, *myconn.py*, *mystock.py*, and *mytranslate.py*. Put
    them in the same directory as your self-made local package files (refer to Chapter
    5 for instructions). Make sure to place them in the package folder */mpt/mptpkg/*
    instead of the chapter folder */mpt/ch17/*. Later in this chapter, I’ll explain
    the purpose of these files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open *__init__.py* from */mpt/mptpkg/*. You began this file in Chapter
    5 and modified it in Chapters 7 and 8, so it should currently look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Add the seven lines of code in [Listing 17-1](#listing17-1) to the end of *__init__.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-1: Importing functions from local modules to the local package'
  prefs: []
  type: TYPE_NORMAL
- en: This code imports the 11 functions (`music_play()`, `music_stop()`, and so on)
    from the seven modules to the local package so you can later import them at the
    package level.
  prefs: []
  type: TYPE_NORMAL
- en: Open the script *vpa.py* from Chapter 8 and add the highlighted parts in [Listing
    17-2](#listing17-2). Save the new script as *vpa_final.py*. You can also download
    the script from the book’s resources.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-2: Your final VPA'
  prefs: []
  type: TYPE_NORMAL
- en: We first import the functions `voice_to_text()`, `print_say()`, `wakeup()`,
    and so on from the local package *mptpkg*. We already imported these functions
    in *__init__.py* from the local modules to the local package *mptpkg*, so here
    we import the functions at the package level directly. Further, since the custom
    package *mptpkg* is installed on your computer (in editable mode), the system
    knows where to find the files, and there is no need to tell the script where to
    look.
  prefs: []
  type: TYPE_NORMAL
- en: We then add the functionalities to the script using a series of `elif` statements.
    We start with the chatting functionality. We’ve prepared eight pairs of questions
    and answers and put them in the dictionary `chats`. If your voice input matches
    one of the eight questions, the chatting functionality is activated, and your
    VPA will speak the corresponding answer from `chats`.
  prefs: []
  type: TYPE_NORMAL
- en: The music functionality is activated by the phrase *music by*. The script will
    retrieve the artist’s name you speak after saying “Music by . . .” and will play
    a random song by that artist.
  prefs: []
  type: TYPE_NORMAL
- en: The news functionality is activated by the phrase *NPR news*. The script will
    extract and play the audio file of the latest news brief from *NPR News Now*.
    You can say “Stop” to stop the news, and the script will go back to the main menu
    and ask, “How may I help you?”
  prefs: []
  type: TYPE_NORMAL
- en: The radio functionality is activated by the phrase *live radio*. The script
    will play streaming audio from an online radio station. You can say “Stop” anytime
    to return to the main menu.
  prefs: []
  type: TYPE_NORMAL
- en: The tic-tac-toe functionality is activated by the words *tic*, *tac*, and *toe*
    together. A game board will appear on the screen, and before the game starts,
    you can choose to play first or second as well as against a person, a simple computer,
    or a smart computer.
  prefs: []
  type: TYPE_NORMAL
- en: The Connect Four functionality is activated by the words *connect* and *four*
    together (or `4` in text). A game board will appear on the screen, and you can
    choose to play first or second as well as against a person, a simple computer,
    or a smart computer.
  prefs: []
  type: TYPE_NORMAL
- en: The stock price functionality is activated by the phrase *stock price of*. The
    script will extract the company name you speak after “Stock price of . . .” and
    tell you the latest price.
  prefs: []
  type: TYPE_NORMAL
- en: The stock market functionality is activated by the phrase *stock market*. The
    script will tell you the values of the major indexes of the US stock market.
  prefs: []
  type: TYPE_NORMAL
- en: The voice translator functionality is activated by the phrase *how to say* together
    with the word *in*. The script will extract the English phrase you want to translate
    and the foreign language into which to translate it, then give you the translation
    aloud.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the individual functionalities one by one in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The Chatting Functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chatting functionality is new. It will allow the VPA to provide a predefined
    answer that you specify in the code, instead of an answer from Wikipedia or WolframAlpha.
    We’re building a simple chat bot with only eight questions, but interested readers
    can use the principles here to create a more sophisticated chatting functionality
    with more questions and answers. It might also be interesting to extend this functionality
    with artificial intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create a dictionary of questions and answers. Enter the text in [Listing
    17-3](#listing17-3) and save it as the file *chats.json* in */mpt/ch17/.* These
    are our question-response pairs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-3: The eight pairs of questions and answers in the chatting functionality'
  prefs: []
  type: TYPE_NORMAL
- en: The file is in JSON format, meaning it can be shared among different script
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: To make the chatting functionality more interesting, we’ve prepared multiple
    answers to some questions. Python will read the JSON file and load the data into
    a dictionary object. The values are all Python lists, and the script will randomly
    select an answer from the list. For example, if the question is `who are you`,
    the answer will be either `i am a Python script` or `i am a computer script`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s zoom in on the parts in *vpa_final.py* relevant to the chatting functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We import two modules. The *random* module is used to randomly select an answer.
    The *json* module reads the JSON data. Both modules are in the Python Standard
    Library, so installation is not needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we open *chats.json* and read the content as a large string variable.
    We use the `load()` function in the *json* module to load it into the dictionary
    `chats`. When you run the VPA script, your voice is captured and converted to
    text and stored in the string variable `inp`. If your question matches one of
    the eight questions in `chats`, the chatting functionality is activated 1. Note
    that `list(chats.keys())` produces the list of the eight keys in `chats`, and
    if you print the list, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The script uses `inp` as the key to locate the corresponding value, which is
    a list with one or two answers in it. The script randomly selects an answer from
    the list and speaks it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one example interaction, with my voice input in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: After the computer asked, “How may I help you?” I said, “Hello” to the microphone.
    Since `hello` is one of the eight questions, the chatting functionality was activated,
    and the computer selected one of the two answers (in this case, `hello`).
  prefs: []
  type: TYPE_NORMAL
- en: 'I then asked three more questions: Who are you? What can you do? How old are
    you? They all activated the chatting functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: The Music Functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll modify the script *play_selena_gomez.py* from Chapter 5 and add music
    functionality to our final VPA. You’ll create a music module and import it to
    the main script.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Music Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open the file *mymusic.py* you just downloaded from the book’s resources and
    saved in your local package folder */mpt/mptpkg*. The code is shown in [Listing
    17-4](#listing17-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-4: The script to add music functionality'
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 5, you created the subfolder */chat/* in your chapter folder */mpt/ch05/*
    and saved some MP3 files in it. Each filename should contain the artist’s name—for
    example, *SelenaGomezWolves.mp3* or *katy_perry_roar.mp3*—so that the Python script
    can locate it. A typical song is about four minutes long, which is a long time
    if you’re given a song that you don’t like, so you also learned how to stop the
    song while it’s playing. The *playsound* and *pydub* modules don’t allow the script
    to execute the next line of code while the song is playing, but with *pygame*,
    the script does move to the next line of code while the song is playing, allowing
    you to stop a song.
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we import the `mixer` module from *pygame*, which can play audio files.
    At 2, we start defining the `music_play()` function, which takes a voice command
    `v_inp` as its argument. We locate the phrase *music by* in the voice command
    and use that to extract the artist name.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `split()` function to separate the first name and last name and associate
    them with the variables `firstname` and `lastname`. The script then goes into
    the appropriate folder and selects a song with the artist’s first name or last
    name to play. Note here that we use `../ch05/chat` to access the subfolder */chat*
    in the parallel folder */mpt/ch05*.
  prefs: []
  type: TYPE_NORMAL
- en: We also define a `music_stop()` function, which will stop the music playing
    3. We use `try` and `except` here in case the script misunderstands your voice
    input and tells you that no song by the artist can be found. If that happens,
    you can still say “Stop” to go back to the main menu without crashing the script.
  prefs: []
  type: TYPE_NORMAL
- en: Activate the Music Functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, you’ll add the music module to the final VPA. Here’s the part of *vpa_final.py*
    that’s relevant for the music functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We import `music_play()` and `music_stop()`, which you just created, and then
    check for the activation phrase *music by* 1. Once activated, the `music_play()`
    function is called, with your voice input taken as the argument.
  prefs: []
  type: TYPE_NORMAL
- en: While the music is playing, the script continues to execute the next line of
    code, which starts an infinite loop listening for your voice input in the background
    2. Any detected voice input is converted to the variable `background`. If the
    word *stop* is detected, the `music_stop()` function is called. If the word *stop*
    isn’t detected, the script goes to the next iteration and continues listening
    for background voice input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example interaction with the music functionality, with my voice input
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: After about one minute of that tune, I said, “Stop playing.” The music stopped
    playing, and the script went back to the main menu and asked, “How may I help
    you?”
  prefs: []
  type: TYPE_NORMAL
- en: The News Brief Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll modify the script *npr_news.py* from Chapter 6 and add a news functionality
    to our final VPA. You’ll create a news module and import it to the main script.
  prefs: []
  type: TYPE_NORMAL
- en: Create a News Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The script *mynews.py* in [Listing 17-5](#listing17-5) creates the news module.
    This file is available from the book’s resources and needs to be saved in the
    local package directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-5: The script to create a news functionality'
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we import `mixer` from *pygame*. We’ll use the *pygame* module so that
    we can stop the news brief anytime. At 2, we define `news_brief()`. When this
    function is called, the script goes to the NPR news website, extracts the MP3
    file associated with the latest news brief, and saves it on your computer 3. The
    script uses `music.play()` to play the audio file 4.
  prefs: []
  type: TYPE_NORMAL
- en: We also define a `news_stop()` function that will stop playing the news file
    5.
  prefs: []
  type: TYPE_NORMAL
- en: Activate the News Functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s add the functionality you just created to the final VPA. Here are the
    parts of *vpa_final.py* relevant to the news functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We import `news_brief()` and `news_stop()` from *mynews*. We check for the activation
    phrase *NPR News* in your voice command. It’s a good idea to say “Play NPR News”
    or “Tell me the latest NPR news” instead of just “NPR news,” because the first
    word or two may be cut off due to timing. Putting something in front of “NPR News”
    provides a buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Once activated, the `news_brief()` function is called, which extracts the news
    brief audio file from the *NRR News Now* website and plays it using *pygame*.
  prefs: []
  type: TYPE_NORMAL
- en: While the news is broadcasting, the script starts an infinite loop to listen
    for your voice input in the background, listening for the word *stop*. If the
    word is detected, the `news_stop()` function is called. Otherwise, the script
    goes to the next iteration and continues listening for background commands.
  prefs: []
  type: TYPE_NORMAL
- en: As with to the music-playing functionality, you need to keep your speaker volume
    low so you can stop the audio by using voice input. After the news brief is finished,
    you need to say “Stop” to go back to the main menu.
  prefs: []
  type: TYPE_NORMAL
- en: The Live Radio Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll modify *play_live_radio.py* from Chapter 6 and add a radio module to our
    final VPA. As usual, you’ll create the radio module and import it to the main
    script.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Radio Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Frist we’ll create a radio module. The script *myradio.py* is shown in [Listing
    17-6](#listing17-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-6: The script to create livestreaming radio functionality'
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to put the file *chromedrive.exe in* the same folder as the
    VPA script (that is, in */mpt/ch17*). At 1, we define the `live_radio()` function.
    We make `button` a global variable so we can use it again later in another function.
    We use the `headless` option, which provides the same functionalities as the regular
    Chrome browser but does not display the browser window on the desktop. Then we
    define `button` as the play button on the online radio station Online Radio Box.
    The button is clicked via voice control so that the radio starts streaming when
    `live_radio()` is called.
  prefs: []
  type: TYPE_NORMAL
- en: At 2, we define a `radio_stop()` function that stops the radio playing. Note
    here that we need to make `button` a global variable as well so that it can be
    modified in `radio_stop()`.
  prefs: []
  type: TYPE_NORMAL
- en: Activate the Radio Functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, add the radio functionality you just created to the final VPA. Here are
    the relevant parts of *vpa_final.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We first import the `live_radio()` and `radio_stop()` functions you just created
    from the local *mptpkg* package. We listen for the activation phrase *live radio*.
    Again, it’s a good idea to include a word or two in front of “live radio” to provide
    a buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Once activated, `live_radio()` is called, which goes to Online Radio Box and
    clicks the play button to stream the audio.
  prefs: []
  type: TYPE_NORMAL
- en: While the radio is playing, the script starts an infinite loop to listen for
    background voice input, which if detected is stored in `background`. If the word
    *stop* is detected, `radio_stop()` is called to press the play button again so
    that the audio stops streaming. Otherwise, the script goes to the next iteration
    and listens for background voice commands.
  prefs: []
  type: TYPE_NORMAL
- en: The Tic-Tac-Toe Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll add a tic-tac-toe module so you can voice-activate the game and play
    with the computer 100 percent hands-free. Here, we use one script to offer six
    versions of the tic-tac-toe game: you can choose to play against another person,
    a simple computer that makes random moves, or a smart computer that thinks three
    steps ahead (recall Chapter 13). You can also choose to go either first or second.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll create a tic-tac-toe module and import it to the main script.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Tic-Tac-Toe Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First we’ll create a local tic-tac-toe module. The script *myttt.py* is based
    on the scripts *ttt_hs.py* in Chapter 10 and *ttt_think.py*, which is the answer
    to question #5 in the end-of-chapter exercises in Chapter 13 and is available
    at the book’s resources website. I highlight the key parts of *myttt.py* in [Listing
    17-7](#listing17-7).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-7: The script to create the tic-tac-toe functionality'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike in previous tic-tac-toe versions, here we don’t use the *messagebox*
    module to remind us about wins, ties, and invalid moves because we cannot use
    voice commands to remove the message box from the screen. You need to physically
    click the box to make it disappear. Instead we’ll just print and announce wins,
    ties, and invalid moves.
  prefs: []
  type: TYPE_NORMAL
- en: We define the `ttt()` function, which we’ll call from the VPA script to draw
    the game board and ask whether you want to play against a person, a simple computer,
    or a smart computer. After that, the script asks whether you want to play first
    or second. Once the game is over, the board disappears from the screen, and the
    script goes back to the main menu of the VPA automatically.
  prefs: []
  type: TYPE_NORMAL
- en: In the `ttt()` function, we use the `smart_computer()` function 1, which is
    based on the `best_move()` function in *ttt_think.py* but gives you the option
    to go first or second. We change `blue` and `white` to `turn` and `nonturn`, respectively,
    so the computer can be the white player if it plays second. We also allow the
    smart computer to occupy cell 5 if it’s empty even if it plays second because
    doing so increases its chance of winning the game.
  prefs: []
  type: TYPE_NORMAL
- en: We then define the `person()` function 2, which allows a human player to make
    a move by using voice commands. Similarly, the `simple_computer()` function allows
    the computer to make a random move 3.
  prefs: []
  type: TYPE_NORMAL
- en: At 4, we start an infinite loop. At each iteration, the script asks whether
    you want to choose a person, a simple computer, or a smart computer as your opponent.
    If your answer includes *person*, the variable `player` will be assigned a value
    of `person`. If your answer includes *simple* or *smart*, `player` will be assigned
    a value of `simple_computer` or `smart_computer`. Later, when we call the `player()`
    function, one of the three functions `person()`, `simple_computer()`, or `smart_computer()`
    will be called, depending on which function name is stored in `player`.
  prefs: []
  type: TYPE_NORMAL
- en: At 5, we start an infinite loop to determine whether you want to play first
    or second. If your answer includes *first*, the variable `preference` will be
    assigned a value of `1`. If your answer includes *second*, `preference` is assigned
    a value of `2`.
  prefs: []
  type: TYPE_NORMAL
- en: We then start the game loop. At each iteration, we first determine whether you
    or your opponent has the turn, based on the values of `preference` and `rounds`
    6. For example, if you choose to play first, the value of `preference` is `1`,
    and when the game starts, the value of `rounds` is `1`. So the condition `(preference+rounds)%2==0`
    is met, and you’ll have the first turn at the beginning of the game.
  prefs: []
  type: TYPE_NORMAL
- en: When it’s your opponent’s turn 7, the `player()` function is called. This means
    one of the three functions, `person()`, `simple_computer()`, or `smart_computer()`,
    is called, depending on the value stored in the `player` variable. The script
    announces the move 8. If the move is not valid, the script asks you or your opponent
    to choose again 9. Otherwise, a piece is placed on the game board.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when the game ends, we do not include the `done()` function in the
    script. As you may recall from the script *guess_letter.py* in Chapter 12, without
    `done()`, the script goes to the `bye()` function after the `while` loop is finished.
    This way, the game board will disappear from the screen a, and you can go back
    to the main menu of your VPA script.
  prefs: []
  type: TYPE_NORMAL
- en: Activate Tic-Tac-Toe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s now add the tic-tac-toe functionality to the final VPA. Here are the
    relevant parts of the script *vpa_final.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We import the `ttt()` function you just created from the local *mptpkg* package.
    To activate the tic-tac-toe game, you need to include *tic*, *tac*, and *toe*
    in your voice command. Once the game is over, the game board disappears, and you’ll
    go back to the main menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of one interaction, with my voice input in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: I activated the game by saying “Play tic-tac-toe.” I then chose to play first
    against a simple computer as my opponent. I won the game by occupying cells 5,
    7, and 3.
  prefs: []
  type: TYPE_NORMAL
- en: The Connect Four Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, adding the Connect Four module should be straightforward. We
    can modify the tic-tac-toe module and change the game to Connect Four. Then you’ll
    import the local module to the main script.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Connect Four Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First we’ll create a Connect Four module. The script *myconn.py* is based on
    *conn_think_hs.py* in Chapter 13 and *myttt.py*, which you just created. Again,
    we won’t use *messagebox* to remind us about wins, ties, and invalid moves. We’ll
    define a `conn()` function so that when the function is called, the game appears
    onscreen and you can start playing.
  prefs: []
  type: TYPE_NORMAL
- en: As in the tic-tac-toe module, you can choose who goes first and who your opponent
    is. We change `red` and `yellow` to `turn` and `nonturn`, respectively, so that
    the computer can be the yellow player if it plays second.
  prefs: []
  type: TYPE_NORMAL
- en: To save space, I won’t explain *myconn.py* in detail here, but it’s available
    at the book’s resources, in the folder */mpt/mptpkg*. Open it now and take a look;
    then go back to the main script for the VPA.
  prefs: []
  type: TYPE_NORMAL
- en: Activate Connect Four
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add the Connect Four module you just created to the final VPA, shown here in
    *vpa_final.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We import the `conn()` function you just created from the local *mptpkg* package.
    We listen for the activation phrase *Connect Four* in your voice command. Note
    that the script may convert your voice as either `connect four` or `connect 4`.
    As a result, we need to use `'4' in inp or 'four' in inp` to cover both cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one sample output from a game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: I chose to play second against the smart computer. By connecting four discs
    horizontally in columns 4, 5, 7, and 6, the smart computer wins the game.
  prefs: []
  type: TYPE_NORMAL
- en: The Stock Price Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s add stock price functionality to our final VPA, building the module
    and then importing it.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Stock Market–Tracking Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First we’ll create stock-monitoring functionality. The script *mystock.py* has
    the code shown in [Listing 17-8](#listing17-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-8: The script to create stock market–tracking functionality'
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we define the `stock_price()` function, saving the voice command `v_inp`
    as the argument. We then locate the company name in your voice command and use
    that to extract the ticker symbol of the firm’s stock 2. The script goes to Yahoo!
    Finance and obtains the stock price based on the ticker symbol 3. Finally, the
    script prints and announces the stock price.
  prefs: []
  type: TYPE_NORMAL
- en: We also define `stock_market()` 4. When this function is called, it will retrieve
    the latest values of the Dow Jones Industrial Average and the S&P 500\. The script
    then prints and announces the two values.
  prefs: []
  type: TYPE_NORMAL
- en: Activate the Stock Market–Tracking Functionalities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now add the stock-monitoring module you just created to the final VPA. Here
    are the relevant parts of *vpa_final.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We first import the `stock_price()` and `stock_market()` functions and listen
    for the activation phrase *stock price of* in your voice command, such as, “Tell
    me the stock price of General Motors.” The `stock_price()` function uses your
    voice command as the argument and tells you the latest price for the company’s
    stock.
  prefs: []
  type: TYPE_NORMAL
- en: We then listen for the activation phrase *stock market* for the `stock_market()`
    function. The script retrieves the latest values of the market indexes and announces
    them to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is one interaction with the stock module, with my voice input
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The Voice Translator Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll finally add the translator functionality so that your VPA can translate
    an English phrase into a foreign language of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Translator Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First we’ll create a translator module. The script *mytranslate.py* is shown
    in [Listing 17-9](#listing17-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-9: The script to create a voice translator functionality'
  prefs: []
  type: TYPE_NORMAL
- en: We start by importing the needed modules. In particular, we import *platform*
    to identify your operating system. At 1, we create a dictionary `lang_abbre`,
    which maps several world languages to their language codes in Google Translate.
    [Listing 17-9](#listing17-9) includes 10 languages, and you can add more to the
    dictionary if you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using Windows, at 2, we start the definition of the `voice_translate()`
    function, which takes your voice command as the argument. Your voice command should
    contain *how to say* and *in*. For example, you can ask, “Python, how to say *thank
    you* in Japanese?” The script locates the positions of *how to say* and *in* in
    your voice. It then extracts the English phrase you want to translate and the
    target language and stores them in variables `eng_phrase` and `tolang`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `Translator()` class from *translate* to translate the English
    phrase to the language you want in text. Next, the script converts the translation
    into voice. It saves the voice translation into an MP3 file and uses the *pydub*
    module to play it.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using Mac or Linux, the process is similar except that you don’t need
    to create and play the audio file. Instead, we use the command line method `gtts-cli`
    to play the audio file directly without saving and retrieving the audio file,
    similar to what we did in Chapter 4 3. Since we convert a foreign language to
    speech, we need to add the `--lang` option, followed by the abbreviation for the
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Activate the Voice Translator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, you’ll add the voice translator module you just created to the final
    VPA, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: We import the `voice_translate()` function you just created and listen for the
    activation phrase. Once the translator functionality is activated, `voice_translate()`
    is called, using your voice input as the argument. The function tells you the
    translation in a human voice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is one interaction with the functionality, with my voice input
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you added several projects created earlier in the book to your
    VPA. Along the way, you learned how to modify existing projects, modularize them,
    and use their functionality in your VPA. You learned how to use voice control
    to activate a functionality so that everything is 100 percent hands-free, and
    how to return to the main menu after the functionality is finished. You also efficiently
    included six versions of the tic-tac-toe or Connect Four game in a single module
    by allowing the script to ask you a couple of questions before the game starts.
    With these skills, you’ll be able to create your own functionalities and add them
    to your VPA.
  prefs: []
  type: TYPE_NORMAL
