- en: Part IV
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分
- en: Going Further
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步深入
- en: '14'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Financial Applications
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 金融应用
- en: '![](Images/chapterart.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: The speech recognition and text-to-speech techniques can be applied to many
    aspects of life. In this chapter, we’ll focus on tracking the financial markets,
    but the techniques you learn here can be easily generalized and applied to your
    own area of interest, whatever that may be.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 语音识别和文本到语音技术可以应用于生活的许多方面。在本章中，我们将专注于追踪金融市场，但你在这里学到的技术可以轻松推广并应用到你感兴趣的任何领域。
- en: 'You’ll build three projects in this chapter: an app that reports the up-to-date
    stock price of any publicly traded company; a script that builds visualizations
    of stock prices; and an app that uses recent daily stock prices to calculate returns,
    run regressions, and perform detailed analyses.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将构建三个项目：一个应用程序，报告任何上市公司最新的股价；一个构建股价可视化的脚本；以及一个应用程序，使用最近的日常股价计算回报、执行回归分析并进行详细分析。
- en: As always, all scripts are available through the book’s resources page at [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
    Start by creating the folder */mpt/ch14/* for this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，所有脚本都可以通过本书的资源页面获取：[https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/)。首先创建
    */mpt/ch14/* 文件夹，用于本章内容。
- en: Python, What’s the Facebook Stock Price?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python，Facebook 股票价格是多少？
- en: In this project, you’ll use the *yahoo_fin* package to obtain real-time price
    information based on the ticker symbol of a stock. A *ticker symbol* is a sequence
    of characters, or code, used to uniquely identify a stock. Most people will not
    know a company’s associated ticker symbol.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用 *yahoo_fin* 包来根据股票的代码获取实时价格信息。*股票代码* 是一串字符或代码，用于唯一标识一只股票。大多数人并不知道公司关联的股票代码。
- en: This provides the opportunity to work backward. You’ll learn to scrape the web
    to get a stock’s ticker symbol from the company name. When you enter the name
    of a firm into the script, Python will tell you the ticker symbol of the firm’s
    stock. Finally, you’ll add the text-to-speech and speech recognition features.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一个从后向前工作的机会。你将学习如何抓取网页，以便从公司名称中获取股票的代码。当你在脚本中输入一个公司的名称时，Python 会告诉你该公司股票的代码。最后，你将添加文本到语音和语音识别功能。
- en: Obtain the Latest Stock Price
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取最新的股票价格
- en: The *yahoo_fin* package lets you obtain the latest stock price information from
    Yahoo! Finance. This package isn’t in the Python standard library, so you need
    to `pip` `install` it first.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*yahoo_fin* 包可以让你从 Yahoo! Finance 获取最新的股价信息。这个包不在 Python 标准库中，因此你需要首先使用 `pip`
    `install` 来安装它。'
- en: 'Open your Anaconda prompt (in Windows) or a terminal (in Mac or Linux), activate
    the virtual environment *chatting*, and run the following command (note the underscore
    in the middle of the package name):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的 Anaconda 提示符（Windows 中）或终端（Mac 或 Linux 中），激活虚拟环境 *chatting*，并运行以下命令（注意包名中间有下划线）：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, open your Spyder editor and save [Listing 14-1](#listing14-1) as *live_price.py*
    in your chapter folder. To use this script, you need to find the ticker symbol
    for the stock you’re interested in beforehand.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开你的 Spyder 编辑器，并将[列表 14-1](#listing14-1)保存为 *live_price.py* 到你的章节文件夹中。要使用这个脚本，你需要事先找到你感兴趣的股票的代码。
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 14-1: Retrieving real-time stock prices'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14-1：获取实时股价
- en: We import the *stock_info* module from the *yahoo_fin* package under the alias
    `si`. We then put the script in an infinite loop 1 to continuously take your written
    input requesting stock ticker symbols. Whenever you want to stop the script, you
    can enter `done` 2. Otherwise, the script automatically continues to obtain the
    latest stock price information for your requested company from Yahoo! Finance
    3. Finally, the script prints out the stock price information.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 *yahoo_fin* 包中导入 *stock_info* 模块，并给它取别名为 `si`。然后，我们将脚本放入一个无限循环中，持续接收你输入的请求，获取股票代码。每当你想停止脚本时，可以输入
    `done`。否则，脚本将自动继续从 Yahoo! Finance 获取你请求的公司最新股价信息。最后，脚本将打印出股票价格信息。
- en: 'Here’s the output from an exchange with the script, with user input in bold:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是与脚本交互的输出，其中用户输入部分用粗体显示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, I entered ticker symbols for Microsoft and Apple (`MSFT` and
    `AAPL`, respectively), and the script returned their latest prices.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我输入了微软和苹果的股票代码（`MSFT` 和 `AAPL`），脚本返回了它们的最新价格。
- en: Notice that the price of the Apple stock has many digits after the decimal.
    We’ll adjust the code a little later to show only two digits after the decimal
    for all stock prices.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Apple 股票的价格有很多小数位。稍后我们会调整代码，只显示所有股票价格的小数点后两位。
- en: For the script to work, you need the company’s stock ticker symbol, such as
    MSFT or AAPL. You may wonder, what if I don’t know the ticker symbols of the stocks
    that I’m interested in? Can Python find it if I know only the company name, such
    as Microsoft or Apple? The answer is yes, and this is when the web-scraping skills
    you learned in Chapter 6 become handy.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让脚本正常工作，你需要公司的股票代码，例如 MSFT 或 AAPL。你可能会想，如果我不知道我感兴趣的股票的股票代码怎么办？如果我只知道公司名称，比如
    Microsoft 或 Apple，Python 能找到它吗？答案是可以的，这时你在第 6 章学到的网页抓取技术就派上用场了。
- en: Find Ticker Symbols
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找股票代码
- en: Many times, you’ll know the name of the company you’re interested in but not
    its ticker symbol. This script will find the ticker symbol when you enter the
    name of the company. This is important because our end goal is to create voice-controlled
    applications in the financial market. It’s relatively difficult for the Python
    script to pick up the ticker symbol via voice commands, but picking up the company
    name is much easier.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，你知道你感兴趣的公司名称，但不知道它的股票代码。这个脚本会在你输入公司名称时找到股票代码。这一点很重要，因为我们的最终目标是创建在金融市场中可以通过语音控制的应用程序。通过语音命令获取股票代码对
    Python 脚本来说相对较难，但识别公司名称要容易得多。
- en: We need to first find a website that can reliably provide a company’s ticker
    symbol. We’ll use Yahoo! Finance and query the site using the URL [https://query1.finance.yahoo.com/v1/finance/search?q=](https://query1.finance.yahoo.com/v1/finance/search?q=)
    followed by the name of the company you want to query. For example, if you put
    *Bank of America* at the end, you’ll get a set of Python-friendly data results,
    as shown in [Figure 14-1](#figure14-1).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要找到一个可以可靠提供公司股票代码的网站。我们将使用 Yahoo! Finance，并通过 URL [https://query1.finance.yahoo.com/v1/finance/search?q=](https://query1.finance.yahoo.com/v1/finance/search?q=)
    查询该网站，后面跟上你想查询的公司名称。例如，如果你在后面加上 *Bank of America*，你将得到一组适合 Python 使用的数据结果，如 [图
    14-1](#figure14-1) 所示。
- en: '![f14001-r](Images/f14001-r.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![f14001-r](Images/f14001-r.png)'
- en: 'Figure 14-1: Results when you search for the ticker symbol for Bank of America'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-1：查询美国银行股票代码时的结果
- en: This data is formatted in *JSON*, short for *JavaScript Object Notation*. This
    file format is used for browser-server communication that uses human-readable
    text to store and transmit data objects. JSON was derived from JavaScript, but
    it’s now a language-independent data format that’s used by many programming languages,
    include Python.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据采用 *JSON* 格式，JSON 是 *JavaScript 对象表示法* 的缩写。该文件格式用于浏览器与服务器之间的通信，使用人类可读的文本来存储和传输数据对象。JSON
    起源于 JavaScript，但现在已成为一种与语言无关的数据格式，被许多编程语言使用，包括 Python。
- en: To make the JSON data easier to read, we’ll use the online JSON data formatter
    at [https://jsonformatter.curiousconcept.com/](https://jsonformatter.curiousconcept.com/).
    Open the URL and you’ll see a screen similar to [Figure 14-2](#figure14-2).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 JSON 数据更易读，我们将使用在线 JSON 数据格式化工具 [https://jsonformatter.curiousconcept.com/](https://jsonformatter.curiousconcept.com/)。打开该网址，你将看到一个类似
    [图 14-2](#figure14-2) 的页面。
- en: '![f14002](Images/f14002.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![f14002](Images/f14002.png)'
- en: 'Figure 14-2: A website to format JSON data'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14-2：格式化 JSON 数据的网站
- en: Paste the data from [Figure 14-1](#figure14-1) into the designated space and
    click **Process**. The formatter will convert the data into a much more readable
    format, shown in [Listing 14-2](#listing14-2).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将 [图 14-1](#figure14-1) 中的数据粘贴到指定区域，并点击 **处理**。格式化工具将把数据转换为更易读的格式，如 [清单 14-2](#listing14-2)
    所示。
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 14-2: The formatted JSON data for the ticker symbol search'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 14-2：股票代码查询的格式化 JSON 数据
- en: The dataset is a large dictionary of several elements with the key values `explains`,
    `count`, `quotes`, and so on. The value for the `quotes` key is a list of several
    dictionaries. The first dictionary contains the keys `exchange`, `shortname`,
    `quoteType`—and importantly, `symbol`, which contains the value `BAC`, the ticker
    symbol we need 1.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集是一个包含多个元素的大型字典，键值包括 `explains`、`count`、`quotes` 等等。`quotes` 键的值是一个包含多个字典的列表。第一个字典包含键
    `exchange`、`shortname`、`quoteType` —— 更重要的是，包含 `symbol`，它的值是 `BAC`，即我们需要的股票代码
    1。
- en: Next, we use a Python script to extract the ticker symbol based on the preceding
    pattern. The script *get_ticker_symbol.py*, shown in [Listing 14-3](#listing14-3),
    accomplishes that.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用一个Python脚本，根据之前的模式提取股票代码符号。脚本*get_ticker_symbol.py*（见[列表14-3](#listing14-3)）实现了这一功能。
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 14-3: Finding a stock’s ticker symbol based on the company name'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-3：根据公司名称查找股票的代码符号
- en: We import the *requests* module, which allows Python to send HyperText Transfer
    Protocol (HTTP) requests. At 1, we start an infinite loop that asks for your written
    input in each iteration. To exit the loop, enter `done`. Otherwise, you enter
    in the company name 2. We use exception handling to prevent a crash 3.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入*requests*模块，它允许Python发送超文本传输协议（HTTP）请求。在第1行，我们开始一个无限循环，在每次迭代中要求提供书面输入。要退出循环，输入`done`。否则，输入公司名称2。我们使用异常处理来防止崩溃3。
- en: We go into the JSON data and extract the list corresponding to the key `quotes`
    4. We then go to the first element and look for the value corresponding to the
    key `symbol`. The script prints out the ticker symbol at the IPython console.
    If there are no results, the script will print `Sorry, not a valid entry!`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进入JSON数据，提取与`quotes`键对应的列表4。然后我们查找第一个元素，并寻找与`symbol`键对应的值。脚本将在IPython控制台输出股票代码符号。如果没有结果，脚本将打印出`抱歉，输入无效！`。
- en: 'Run the script a few times and search for several companies to check that it
    works. The following output is one interaction with the script:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 多次运行脚本，搜索几家公司，检查它是否正常工作。以下是与脚本的一次交互输出：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the script works for companies with one-word names, like Apple,
    as well as longer names, such as Walt Disney Company.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，脚本适用于单词公司名称（如Apple）以及更长的公司名称（如Walt Disney Company）。
- en: Retrieve Stock Prices via Voice
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过语音获取股票价格
- en: Now we’ll mesh together the scripts *live_price.py* and *get_ticker_symbol.py*
    and add in the speech recognition and text-to-speech features. Enter [Listing
    14-4](#listing14-4) in a Spyder editor and save it as *live_price_hs.py* in your
    chapter folder, or download the script from the book’s resources.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将脚本*live_price.py*和*get_ticker_symbol.py*结合起来，并添加语音识别和文本转语音功能。在Spyder编辑器中输入[列表14-4](#listing14-4)，并将其保存为*live_price_hs.py*，保存在你的章节文件夹中，或者从书籍资源中下载该脚本。
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 14-4: Use voice to retrieve real-time stock price'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-4：通过语音获取实时股票价格
- en: We now import `print_say()` and `voice_to_text()` from the local *mptpkg* package
    to add the text-to-speech and speech recognition features.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在从本地*mptpkg*包中导入`print_say()`和`voice_to_text()`，以添加文本转语音和语音识别功能。
- en: At 1, we start an infinite loop that asks for your voice input. To exit the
    loop, you say, “Stop listening.” Otherwise, you say a company name 2, and the
    script searches for the ticker symbol. We use `try` and `except` here to prevent
    the script from crashing because of a lack of results from Yahoo! Finance.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1行，我们开始一个无限循环，要求提供语音输入。要退出循环，你可以说“停止监听”。否则，你说出公司名称2，脚本会搜索股票代码符号。我们在这里使用`try`和`except`来防止脚本因Yahoo!
    Finance没有结果而崩溃。
- en: We save the stock price from Yahoo! Finance in `price` 3. Note that we use `round()`
    to round the stock price to two digits after the decimal. The script will speak
    the company’s stock price or, if there are no results, will say, “Sorry, I cannot
    find what you are looking for!”
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将Yahoo! Finance中的股票价格保存在`price`中3。注意，我们使用`round()`将股票价格四舍五入到小数点后两位。脚本将朗读公司的股票价格，或者如果没有结果，将说“抱歉，我找不到你要找的信息！”
- en: 'Here’s a sample interaction:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个交互示例：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Voice-Controlled Data Visualization
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语音控制数据可视化
- en: One efficient way to analyze data—for example, to find patterns in stock movements—is
    through data visualization. *Data visualization* puts data into visual contexts
    such as plots and charts to make it easy for human brains to understand.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 分析数据的一种高效方法——例如，寻找股票走势中的模式——是通过数据可视化。*数据可视化*将数据呈现为图形和图表等可视化形式，使人脑更容易理解。
- en: The price you obtained in the first project of this chapter is the latest price
    for the stock. That is, you have one data point for each stock you query. However,
    in order to learn more about a stock, it’s better to obtain a number of recent
    prices for the stock so that you can get a sense of velocity and direction. Is
    the stock staying at about the same value, rising, or falling? If the price is
    changing, how rapid is this change?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您在本章第一个项目中获得的股价是股票的最新价格。也就是说，您查询的每只股票都有一个数据点。然而，为了更好地了解某只股票，最好获取该股票的多个最近价格，以便您可以了解其速度和方向。该股票是保持在差不多的价值、上涨还是下跌？如果价格发生变化，这一变化有多快？
- en: In this project, you’ll obtain recent daily stock price information from Yahoo!
    Finance. You’ll then plot a graph to see the price movements over time. You’ll
    also learn to create candlestick charts so that you can see intraday stock movement
    patterns. With that set up, we’ll add the speech recognition and text-to-speech
    features.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，您将从 Yahoo! Finance 获取最新的每日股价信息。然后，您将绘制图表，以查看股价随时间的变化。您还将学习如何创建蜡烛图，以便查看日内股票的运动模式。设置好这些后，我们将添加语音识别和文本到语音功能。
- en: Create Stock Price Plots
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建股价图
- en: We’ll use the *pandas_datareader* module with *matplotlib* to create plots for
    stock prices over the last six months. First you’ll learn how to extract data,
    and then you’ll learn how to create plots.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用*pandas_datareader*模块和*matplotlib*来创建过去六个月的股价图表。首先，您将学习如何提取数据，然后学习如何创建图表。
- en: 'Before we begin, you need to install a few third-party modules. Go to your
    Anaconda prompt (in Windows) or a terminal (in Mac or Linux) and activate the
    virtual *chatting* environment. Then run the following lines of code one by one:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，您需要安装一些第三方模块。打开 Anaconda 提示符（Windows）或终端（Mac 或 Linux），并激活虚拟的*聊天*环境。然后逐行运行以下代码：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Follow the instructions to finish the installations. The *pandas_datareader*
    module extracts online data from various sources into a *pandas* DataFrame. Then
    enter [Listing 14-5](#listing14-5) in your Spyder editor and save the script as
    *price_plot.py* in your chapter folder.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 按照说明完成安装。*pandas_datareader*模块可以从各种来源提取在线数据，并将其导入到*pandas*数据框中。然后，在您的 Spyder
    编辑器中输入[示例 14-5](#listing14-5)并将脚本保存为*price_plot.py*，放在您的章节文件夹中。
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 14-5: The script to create a stock price plot'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 14-5：创建股价图的脚本
- en: We import the modules, then specify the start and end dates of the data we want
    to extract 1. These will be hardcoded for now; we’ll make the dates dynamic later.
    The dates should be in the format *YYYY*-*MM*-*DD*. In this case, we’ll use the
    six-month period from September 1, 2020, to February 28, 2021\. We also provide
    the ticker symbol of the stock—in this case, Tesla with the ticker symbol TSLA
    2.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入模块，然后指定我们想要提取的数据的开始和结束日期1。这些日期目前将被硬编码；稍后我们会使日期动态化。日期应采用*YYYY*-*MM*-*DD*格式。在此案例中，我们将使用从2020年9月1日到2021年2月28日的六个月期间。我们还提供了股票的股票代码——在此情况下为特斯拉，股票代码为TSLA
    2。
- en: 'We use `get_data_yahoo()` in the *pandas_datareader* module to extract daily
    stock price information and save the data as a *pandas* DataFrame named `stock`
    3. The dataset looks like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`get_data_yahoo()`函数，该函数位于*pandas_datareader*模块中，用于提取每日股价信息，并将数据保存为名为`stock`的*pandas*数据框。数据集如下所示：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The dataset uses dates as indexes. The 123 rows represent the 123 trading days
    during the six-month period. The six columns represent the following information
    in each trading day: high price, low price, open price, closing price, trading
    volume, and adjusted closing price.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集使用日期作为索引。123行代表六个月期间的123个交易日。六列分别代表每个交易日的信息：最高价、最低价、开盘价、收盘价、交易量和调整后的收盘价。
- en: We then read the timestamp index of the dataset as a number and save it as an
    additional (seventh) column 4. This step is necessary because the dataset doesn’t
    recognize the index as a separate variable, but we need the date information to
    use as our x-axis in the charts. We then use the `figure()` function in *matplotlib.pyplot*
    to specify the size and resolution of the plot and name the generated figure `fig`
    5. The `dpi=128` argument makes the output 128 pixels per inch. The `figsize=(10,6)`
    argument sets the plot 10 inches wide and 6 inches tall.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将数据集的时间戳索引读取为数字，并将其保存为一个额外的（第七）列4。此步骤是必要的，因为数据集没有将索引识别为单独的变量，但我们需要日期信息来作为图表的x轴。然后，我们使用*matplotlib.pyplot*中的`figure()`函数来指定图表的大小和分辨率，并将生成的图形命名为`fig`5。`dpi=128`参数使输出为每英寸128像素。`figsize=(10,6)`参数将图表宽度设置为10英寸，高度设置为6英寸。
- en: We use the `DateFormatter()` method from *matplotlib.dates* to specify the format
    of the dates we want to show 6. We do the actual plotting by using `plot()` 7.
    The first two arguments are the variables to use on the x- and y-axis, respectively.
    We also use a third argument to specify the color. In this case, we plot the adjusted
    closing price against the date and use blue as the color.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用*matplotlib.dates*中的`DateFormatter()`方法来指定我们想要显示的日期格式6。实际绘图是通过使用`plot()`7来完成的。前两个参数分别是x轴和y轴的变量。我们还使用第三个参数来指定颜色。在这种情况下，我们将调整后的收盘价与日期作图，并使用蓝色作为颜色。
- en: Starting at 8, we put a title on the graph and label the x- and y-axis. We also
    use `autofxt_xdate()` to show the dates on the x-axis diagonally to prevent overlapping
    text.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从第8步开始，我们在图表上添加标题并标注x轴和y轴。我们还使用`autofxt_xdate()`将x轴的日期显示为斜体，以防止文字重叠。
- en: Finally, `show()` is called to display the plot 9. [Figure 14-3](#figure14-3)
    shows the output.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用`show()`来显示图表9。[图14-3](#figure14-3)显示了输出结果。
- en: '![f14003](Images/f14003.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![f14003](Images/f14003.png)'
- en: 'Figure 14-3: Stock price plot for Tesla from September 2020 through February
    2021'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-3：2020年9月到2021年2月的特斯拉股票价格图
- en: We can see the price movement patterns of Tesla over the six-month period. The
    stock was at less than $500 per share in early September 2020 but shot up to over
    $800 per share in late December, before dropping slightly in mid-February. This
    visualization is much more reader-friendly (and informative) than the `stock`
    DataFrame output earlier!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到特斯拉在这六个月期间的价格波动模式。2020年9月初股票价格不到每股500美元，但到了12月下旬涨到了每股超过800美元，之后在2月中旬略有下跌。这个可视化比之前的`stock`数据框输出更具可读性（也更有信息量）！
- en: Create Candlestick Charts
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建蜡烛图
- en: 'Price plots are great for summarizing patterns using one observation per day.
    Sometimes you’re interested in several intraday price movements, such as the range
    of the price fluctuation in a given day, whether the closing price is higher or
    lower than the opening price, and so on. With *candlestick charts*, you can visualize
    four pieces of information each day for a stock: daily high, daily low, opening
    price, and closing price.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 价格图表非常适合通过每天一个观测值来总结模式。有时你会对几种日内价格波动感兴趣，比如当天的价格波动范围、收盘价是否高于或低于开盘价等等。使用*蜡烛图*，你可以可视化每天四个价格信息：日最高价、日最低价、开盘价和收盘价。
- en: The following script generates the candlestick chart for Amazon stock in the
    month of February 2021\. I don’t recommend plotting stock prices from more than
    one month because the chart may become too crowded, making it hard to detect patterns.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本生成了2021年2月亚马逊股票的蜡烛图。我不建议绘制超过一个月的股票价格图，因为图表可能会变得过于拥挤，导致很难发现模式。
- en: 'First, you need to install the third-party *mplfinance* module. Open your Anaconda
    prompt (in Windows) or a terminal (in Mac or Linux), activate the virtual environment
    *chatting*, and run the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要安装第三方的*mplfinance*模块。打开你的Anaconda命令行（Windows系统）或终端（Mac或Linux系统），激活虚拟环境*chatting*，并运行以下命令：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Then open your Spyder editor and save [Listing 14-6](#listing14-6) as *candle_stick.py*
    in your chapter folder.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后打开你的Spyder编辑器，并将[列表14-6](#listing14-6)保存为* candle_stick.py*文件，放入你的章节文件夹中。
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 14-6: The script to create a candlestick chart'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-6：创建蜡烛图的脚本
- en: We import all needed modules and functions, including the `candlestick_ohlc()`
    function from the *mplfinance* module that we’ll use to create the candlestick
    chart.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入所有需要的模块和函数，包括来自*mplfinance*模块的`candlestick_ohlc()`函数，这个函数将用于创建蜡烛图。
- en: 'At 1, we select the four daily prices that we want to extract and visualize
    in the chart: opening price, daily high, daily low, and closing price.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步，我们选择了要提取并在图表中可视化的四个日价格：开盘价、日最高价、日最低价和收盘价。
- en: The `setp()` function from *matplotlib* sets object properties, and we invoke
    it to rotate the dates on the x-axis 2. We pass two arguments (the first to obtain
    the x-axis label and the second to set the property) to rotate the x-axis label
    10 degrees, so text doesn’t overlap. At 3, we use `candlestick_ohlc()` to generate
    the candlestick chart. The first argument specifies where to place the chart,
    and the second specifies the data to use. The third argument is the width of the
    candle body relative to the distance between two observations (the distance on
    the x-axis between two trading days).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 来自*matplotlib*的`setp()`函数用于设置对象属性，我们调用它来旋转x轴上的日期2。我们传递两个参数（第一个用于获取x轴标签，第二个用于设置属性），将x轴标签旋转10度，以防文本重叠。在3处，我们使用`candlestick_ohlc()`生成蜡烛图。第一个参数指定图表放置的位置，第二个指定使用的数据。第三个参数是蜡烛实体相对于两次观察之间的距离（即x轴上两个交易日之间的距离）的宽度。
- en: The candlestick chart uses colors to convey additional data. We use black to
    indicate that the closing price is higher than the opening price; otherwise, the
    value is gray. The information is also conveyed in the legend 4. Finally, we give
    the chart a title and label the two axes 5.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 蜡烛图使用颜色传达额外的数据。我们使用黑色表示收盘价高于开盘价；否则，使用灰色。该信息也通过图例4传达。最后，我们给图表添加标题并标注两个坐标轴5。
- en: The candlestick chart for Amazon stock prices in February 2021 is shown in [Figure
    14-4](#figure14-4). The blank spaces in the chart are non-trading days (weekends
    and holidays).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 2021年2月亚马逊股票价格的蜡烛图如[图14-4](#figure14-4)所示。图表中的空白区域表示非交易日（周末和节假日）。
- en: The daily high and daily low are at the ends of the thin lines (which look like
    candle wicks), while the opening and closing prices are at the ends of the wide
    lines (which look like candle bodies). Hence the name!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每日最高价和最低价位于细线的两端（看起来像蜡烛的烛芯），而开盘价和收盘价位于宽线的两端（看起来像蜡烛的实体部分）。因此得名！
- en: 'From this, we can quickly see that, on February 1, the price jumped up: the
    body of the candle spans nearly $100 and is colored black. Compare this to the
    following day, where, although the thin line is relatively long, the candle body
    is short, showing that despite fluctuations, it closed at nearly the same price
    that it opened at.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以快速看到，2月1日股价猛涨：蜡烛的实体部分跨度接近100美元，并且是黑色的。与第二天对比，尽管细线相对较长，蜡烛的实体部分却很短，表明尽管有波动，但收盘价几乎与开盘价相同。
- en: '![f14004](Images/f14004.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![f14004](Images/f14004.png)'
- en: 'Figure 14-4: A candlestick chart for Amazon daily stock prices in February
    2021'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-4：2021年2月亚马逊每日股票价格的蜡烛图
- en: Add Voice Control
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加语音控制
- en: 'Let’s add the speech functionality. When you say the company name, the script
    will search for the ticker symbol of the firm’s stock, retrieve daily price information,
    and display the plot or chart. We first need to create two local modules: one
    to display stock price plots and one to show candlestick charts.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加语音功能。当你说出公司名称时，脚本将搜索该公司股票的股票代码，获取每日价格信息，并显示绘图或图表。我们首先需要创建两个本地模块：一个用于显示股票价格绘图，另一个用于显示蜡烛图。
- en: The Price Plot Module
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 股票价格绘图模块
- en: We’ll create a stock price plot module based on *price_plot.py*. Enter [Listing
    14-7](#listing14-7) in your Spyder editor and save it as *myplot.py*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于*price_plot.py*创建一个股票价格绘图模块。在你的Spyder编辑器中输入[Listing 14-7](#listing14-7)，并将其保存为*myplot.py*。
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 14-7: The script for the stock plot module'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 14-7：股票绘图模块的脚本
- en: We import the modules, including those we used to plot stock prices and to parse
    the HTML source file to find the firm’s ticker symbol. We also import the `print_say()`
    function from the local *mptpkg* package.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了所需的模块，包括用于绘制股票价格和解析HTML源文件以查找公司股票代码的模块。我们还从本地的*mptpkg*包中导入了`print_say()`函数。
- en: At 1, we start `stock_plot()`, which takes the company name as the argument.
    We again use `try` and `except` to prevent crashes. We first find the ticker symbol
    of the firm 2.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在1处，我们启动`stock_plot()`，它以公司名称作为参数。我们再次使用`try`和`except`来防止程序崩溃。首先，我们查找公司的股票代码2。
- en: Here we make the price information dynamic 3. The end date is today’s date,
    while the start date is six months ago. The script will generate a plot 4 and
    then tell you the plot is ready 5. If the ticker symbol or the price information
    can’t be found, the script will print and say, “Sorry, not a valid entry!”
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使价格信息变得动态3。结束日期是今天的日期，而开始日期是六个月前。脚本将生成一个绘图4，并告诉你绘图已经准备好5。如果找不到股票代码或价格信息，脚本将打印并说：“抱歉，输入无效！”
- en: The Candlestick Chart Module
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 蜡烛图模块
- en: Next we’ll create the candlestick chart module. Open *mychart.py* from the book’s
    resources, as shown in [Listing 14-8](#listing14-8).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将创建蜡烛图模块。打开书中资源中的*mychart.py*，如[清单14-8](#listing14-8)所示。
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 14-8: The script to create the candlestick chart module'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 清单14-8：创建蜡烛图模块的脚本
- en: We import the modules, including the `candlestick_ohlc()` function from the
    *mplfinance* module.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入模块，包括来自*mplfinance*模块的`candlestick_ohlc()`函数。
- en: We define `candle_stick()` at 1. Here we make the price information dynamic.
    The end date is today’s date, while the start date is two weeks ago. We then perform
    the same actions as in *myplot.py* to search for the ticker symbol. With the ticker
    symbol, we retrieve the daily stock price information in the past 14 days from
    Yahoo! Finance. I’ve snipped this part of the script to save space.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第1行定义`candle_stick()`。这里我们使得价格信息具有动态性。结束日期是今天的日期，而开始日期是两周前。然后我们执行与*myplot.py*相同的操作来查找股票代码。通过股票代码，我们从Yahoo!
    Finance获取过去14天的每日股价信息。为了节省空间，我已经剪裁了这部分脚本。
- en: The data used for the candlestick chart will be the date plus the opening price,
    daily high and low prices, and closing price 2. The script builds the candlestick
    chart and lets you know when it’s done 3.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 用于蜡烛图的数据将包括日期、开盘价、每日最高和最低价格以及收盘价2。脚本会构建蜡烛图并在完成时通知你3。
- en: The Main Script
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 主脚本
- en: Next, we’ll import the two modules to the main script so that we can voice-activate
    a stock price plot or a candlestick chart. Enter [Listing 14-9](#listing14-9)
    in your Spyder editor and save it as *plot_chart_hs.py* in your chapter folder.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将导入这两个模块到主脚本中，以便可以通过语音激活股价图表或蜡烛图。将[清单14-9](#listing14-9)输入到你的Spyder编辑器中，并将其保存为*plot_chart_hs.py*，保存在你的章节文件夹中。
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 14-9: The script to voice-control plot and chart creation'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 清单14-9：语音控制绘制和图表创建的脚本
- en: We import the modules and add the `print_say()` and `voice_to_text()` functions.
    We also import `price_plot()` from the local *myplot* module and `candle_stick()`
    from the local *mychart* module that we just created.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入模块并添加`print_say()`和`voice_to_text()`函数。我们还从本地*myplot*模块导入`price_plot()`，并从本地*mychart*模块导入我们刚刚创建的`candle_stick()`。
- en: At 1, we start an infinite loop that asks for your voice input. To exit the
    script, you say, “Stop listening” 2. To see the stock plot of a firm (say, Goldman
    Sachs), you say, “Stock pattern for Goldman Sachs.” The “stock pattern for” will
    trigger the stock plot functionality 3. We use “stock pattern” instead of “stock
    plot” because it’s easier for the microphone to pick up. The script then extracts
    the company name, which is Goldman Sachs in this case, and uses it as the argument
    in the `price_plot()` function.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1行，我们启动一个无限循环，询问你的语音输入。要退出脚本，你可以说：“停止监听”2。要查看某个公司的股价图表（比如，Goldman Sachs），你可以说：“Goldman
    Sachs的股价图案”。“股价图案”会触发股价图表功能3。我们使用“股价图案”而不是“股价图表”，因为这样更容易被麦克风识别。脚本随后提取公司名称，这里是Goldman
    Sachs，并将其作为`price_plot()`函数的参数。
- en: To see the candlestick chart of a firm (say, General Motors), you say, “Chart
    for General Motors.” The “chart for” part of the voice command will trigger the
    candlestick chart functionality 4. The script then extracts the company name and
    uses it as the argument in the `candle_stick()` function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看某个公司的蜡烛图（比如，通用汽车），你可以说：“通用汽车的图表。”语音命令中的“图表”部分将触发蜡烛图功能4。脚本随后提取公司名称，并将其作为`candle_stick()`函数的参数。
- en: 'Here’s my sample output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的示例输出：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The “price pattern for Oracle” phrase triggered the price plot functionality,
    and the script generated the price plot for Oracle, shown in [Figure 14-5](#figure14-5).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: “Oracle的价格图案”这个短语触发了价格图表功能，脚本为Oracle生成了价格图表，如[图14-5](#figure14-5)所示。
- en: '![f14005](Images/f14005.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![f14005](Images/f14005.png)'
- en: 'Figure 14-5: Voice-controlled stock price plot for Oracle'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-5：Oracle的语音控制股价图表
- en: The “chart for Intel” phrase prompted the script to create a candlestick chart
    for Intel, shown in [Figure 14-6](#figure14-6).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: “Intel的图表”这个短语促使脚本为Intel创建了一个蜡烛图，如[图14-6](#figure14-6)所示。
- en: '![f14006](Images/f14006.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![f14006](Images/f14006.png)'
- en: 'Figure 14-6: Voice-controlled candlestick chart for Intel'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-6：Intel的语音控制蜡烛图
- en: Voice-Controlled Stock Report
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语音控制股票报告
- en: While the price plots and candlestick charts allow us to see recent price movements,
    they don’t give us information on how a stock has performed relative to the general
    market. Many times, investors are interested in how well a stock has performed
    in comparison to a benchmark index. They’re also interested in the risk of a stock,
    measured in how volatile a stock’s price has been relative to the market as a
    whole.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然价格图表和蜡烛图可以让我们看到最近的价格波动，但它们并不能提供关于股票相对于整体市场表现的信息。许多时候，投资者关心的是股票与基准指数相比的表现如何。他们还关心股票的风险，即股票价格相对于整体市场的波动性。
- en: To that end, we’ll progress to a more detailed analysis of a stock’s price.
    You’ll obtain recent daily stock price information and perform regression analyses
    to figure out the recent performance and market risk of the stock. You’ll calculate
    the stock’s abnormal return (*alpha*, which is the relative performance of the
    stock compared to the market as a whole) and the market risk (*beta*, which measures
    how volatile the stock’s return has been compared to the market as a whole) by
    running a regression of the stock’s return on the market return.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将进一步详细分析股票的价格。你将获取最近的每日股票价格信息，并进行回归分析，以了解股票的近期表现和市场风险。你将通过对股票回报与市场回报的回归分析，计算股票的异常回报（*alpha*，即股票相对于整体市场的表现）和市场风险（*beta*，即股票回报相对于整体市场的波动性）。
- en: Analyze Recent Stock Performance and Risk
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析近期股票表现和风险
- en: You’ll use the same methods we’ve used so far to extract recent daily stock
    price information from Yahoo! Finance using the *pandas_datareader* module. You’ll
    then use a new module *statsmodels* to perform statistical analyses.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用我们迄今为止使用的方法，通过*pandas_datareader*模块从Yahoo! Finance提取最近的每日股票价格信息。然后，你将使用一个新的模块*statsmodels*进行统计分析。
- en: 'First, we’ll install the third-party module and extract data. Go to your Anaconda
    prompt (in Windows) or a terminal (in Mac or Linux) and activate the virtual *chatting*
    environment. Then run the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将安装第三方模块并提取数据。进入你的Anaconda提示符（在Windows中）或终端（在Mac或Linux中），并激活虚拟的*chatting*环境。然后运行以下命令：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Enter [Listing 14-10](#listing14-10) in your Spyder editor and save the script
    as *alpha_beta.py* in your chapter folder.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Spyder编辑器中输入[Listing 14-10](#listing14-10)，并将脚本保存为*alpha_beta.py*，保存在你的章节文件夹中。
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 14-10: The script to calculate stock alpha and beta'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 14-10：计算股票alpha和beta的脚本
- en: We import the modules and then specify the start and end dates of the data you
    want to extract. We again use the most recent six-month period. We also provide
    the ticker symbols of the market index, which is an index that represents the
    market as a whole. The S&P 500 Index is often used, and that is what we will use.
    The company we’ll analyze is Microsoft Corporation. We use the `get_data_yahoo()`
    method in the *pandas_datareader* module to extract daily stock price information
    for the market index and Microsoft, and we save the data as two *pandas* DataFrames
    named `sp` and `stock`, respectively.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入模块后，指定你想要提取的数据的起始和结束日期。我们再次使用最近的六个月数据。我们还提供市场指数的股票代码，市场指数代表整体市场。S&P 500指数通常被用作市场指数，我们也将使用该指数。我们将分析的公司是微软公司。我们使用*pandas_datareader*模块中的`get_data_yahoo()`方法提取市场指数和微软的每日股票价格信息，并将数据分别保存为两个*pandas*
    DataFrame，命名为`sp`和`stock`。
- en: We then calculate the daily stock returns for both the S&P 500 and Microsoft.
    The `shift()` method in *pandas* allows us to shift the index by a desired number
    of periods. We use `shift(1)` to obtain the price information of the previous
    trading day. This allows us to see how today compared to yesterday. Comparing
    the two days enables us to calculate returns. The *gross return* is the current
    value divided by the value at the close of the previous trading day, and the *net
    return* is the gross return minus one.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们计算S&P 500和微软的每日股票回报。*pandas*中的`shift()`方法允许我们将索引按所需的周期数移动。我们使用`shift(1)`获取前一个交易日的价格信息。这使我们能够看到今天与昨天的比较。比较这两天可以帮助我们计算回报。*毛回报*是当前价值与前一个交易日收盘价的比值，*净回报*是毛回报减去1。
- en: To calculate alpha and beta, we first merge the two datasets into one. For simplicity,
    we use a small constant value for the risk-free rate 1. We then use the `OLS()`
    method in the *statsmodels* module to run a regression 2 and print out the regression
    results. The alpha and beta we want are the regression coefficients on the constant
    and the excess return on the market, respectively 3.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算alpha和beta，我们首先将两个数据集合并为一个。为了简便，我们使用一个小常数值作为无风险利率1。然后，我们使用*statsmodels*模块中的`OLS()`方法进行回归
    2，并输出回归结果。我们需要的alpha和beta分别是常数项和市场超额收益的回归系数 3。
- en: '[Figure 14-7](#figure14-7) shows the regression results.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14-7](#figure14-7)显示了回归结果。'
- en: '![f14007](Images/f14007.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![f14007](Images/f14007.png)'
- en: 'Figure 14-7: Regression analysis results for Microsoft'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图14-7：微软回归分析结果
- en: 'Finally, we print out the values of the firm’s alpha and beta as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们按如下方式输出公司的alpha和beta值：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The analysis shows that the alpha and beta are 0.202 percent and 1.1, respectively.
    This means Microsoft has outperformed similar stocks on the market by 0.202 percent
    per day, and the company has a market risk slightly greater than an average firm
    (which has a beta of 1), which means the stock’s return has been slightly more
    volatile than the market as a whole.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 分析显示，alpha和beta分别为0.202%和1.1。这意味着微软的日均表现超越了市场上类似股票0.202%，并且该公司市场风险稍大于平均公司（其beta为1），这意味着该股票的回报波动性略高于整体市场。
- en: Add Voice Control
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加语音控制
- en: Let’s add the voice control! You’ll ask about a company, and the script will
    search for the ticker symbol, retrieve daily stock information, and calculate
    the alpha and beta. Then the script will let you know that information by voice.
    The phrase “stock report for” will trigger the stock report functionality.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加入语音控制！你可以询问某家公司，脚本将搜索其股票代码，获取每日股价信息并计算alpha和beta。然后，脚本会通过语音告诉你这些信息。短语“某公司股票报告”将触发股票报告功能。
- en: Enter [Listing 14-11](#listing14-11) in your Spyder editor and save the script
    as *alpha_beta_hs.py* in your chapter folder.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Spyder编辑器中输入[列表14-11](#listing14-11)，并将脚本保存为*alpha_beta_hs.py*在你的章节文件夹中。
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 14-11: Voice-control the calculation of stock alpha and beta'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表14-11：语音控制股票alpha和beta的计算
- en: We import the modules, including the *requests* module and the `print_say()`
    and `voice_to_text()` functions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入模块，包括*requests*模块以及`print_say()`和`voice_to_text()`函数。
- en: At 1, we start the definition of `alpha_beta()`, using the firm name as its
    argument. As before, we use the plus sign to join words together to use as search
    terms for the ticker symbol on Yahoo! Finance 2. We use `try` and `except` to
    prevent crashes and let the user know if the entry is invalid. The script then
    calculates the firm’s alpha and beta, as it does in *alpha_beta.py*, and both
    prints and speaks the alpha and beta 3.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步，我们开始定义`alpha_beta()`函数，使用公司名称作为其参数。如之前所示，我们使用加号将单词连接起来，作为Yahoo! Finance
    2上的股票代码的搜索关键词。我们使用`try`和`except`来防止程序崩溃，并让用户知道输入是否无效。然后，脚本计算公司的alpha和beta，正如在*alpha_beta.py*中一样，最后输出并朗读alpha和beta
    3。
- en: At 4, we start an infinite loop that asks for your voice input. To exit the
    script, say, “Stop listening.” Otherwise, you say, “Stock report for” followed
    by the company name to activate the stock report functionality. The script extracts
    the company name from your voice command and prepares the report for you 5.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步，我们开始一个无限循环，询问你的语音输入。要退出脚本，可以说“停止监听”。否则，你可以说“某公司股票报告”，后接公司名称，以激活股票报告功能。脚本将从你的语音命令中提取公司名称，并为你准备报告
    5。
- en: 'Here’s my sample interaction:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的示例交互：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: I asked for the “stock report for Alibaba,” and the script obtained the report
    for me and replied, “The alpha of Alibaba is 0.059 percent; the beta of the stock
    Alibaba is 0.61.”
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我询问了“阿里巴巴的股票报告”，脚本为我获取了报告并回答说：“阿里巴巴的alpha为0.059%，阿里巴巴股票的beta为0.61。”
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you applied the speech recognition and text-to-speech techniques
    to the financial market. These skills—scraping information, forming search terms
    that can be used in URLs, and retrieving real-time as well as recent daily stock
    price information—can be applied to a huge variety of web applications. You also
    learned a few data analysis and visualization skills, which are also handy for
    many applications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将语音识别和文本转语音技术应用于金融市场。这些技能——抓取信息、构建可用于URL的搜索词，并获取实时以及最近的每日股价信息——可以广泛应用于各种网页应用程序。你还学到了一些数据分析和可视化技能，这些技能在许多应用中也非常有用。
- en: In the next chapter, you’ll create talking graphical market watches for financial
    markets such as the US stock market or the foreign exchange market.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将创建图形化的语音市场监控工具，适用于如美国股票市场或外汇市场等金融市场。
- en: End-of-Chapter Exercises
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 章节末练习
- en: Modify *price_plot.py* so that the start and end dates are March 1, 2021 and
    June 1, 2021, respectively, and the plot color is red.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 *price_plot.py*，使得开始日期和结束日期分别为 2021 年 3 月 1 日和 2021 年 6 月 1 日，并且图表的颜色为红色。
- en: Modify *candle_stick.py* so that the dates on the x-axis are in the format of
    01-01-2021 (instead of 01/01/2021 or January 1, 2021) and rotated 15 degrees.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 *candle_stick.py*，使得 x 轴上的日期格式为 01-01-2021（而不是 01/01/2021 或 2021 年 1 月 1
    日），并旋转 15 度。
- en: '15'
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Stock Market Watch
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 股票市场监控工具
- en: '![](Images/chapterart.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: In this chapter, you’ll create a graphical, speaking app that monitors the US
    stock market in real time. When you run the script during trading hours, you’ll
    see a graphical display of the major stock indexes and a couple of stocks you
    select. The app also lets you know the values of the indexes and the stock prices
    in a human voice.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将创建一个图形化的语音应用程序，实时监控美国股票市场。当你在交易时段运行脚本时，你将看到主要股指和你选择的几只股票的图形展示。该应用程序还会用人的声音告诉你股指和股票价格的数值。
- en: To build up the necessary skills, you’ll first create a graphical Bitcoin watch
    to display live price information, using the Python *tkinter* package. You can
    generalize these techniques to other financial markets such as the world stock
    market or the US Treasury bond market.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了掌握必要的技能，你将首先创建一个图形化的比特币监控工具，显示实时价格信息，使用 Python 的 *tkinter* 包。你可以将这些技巧应用于其他金融市场，例如世界股票市场或美国国债市场。
- en: As always, all scripts are available through the book’s resources page at [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/),
    and you should make the folder */mpt/ch15/* for this chapter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，所有脚本可以通过本书的资源页面访问：[https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/)，你应为本章创建文件夹
    */mpt/ch15/*。
- en: Bitcoin Watch
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比特币监控工具
- en: We’ll start with Bitcoin because the Bitcoin price is updated 24/7, unlike the
    stock market, which gives live price updates only when it’s open. In the process
    of creating a Bitcoin watch, you’ll learn the necessary skills to build a market
    watch for other financial markets. The script tells you whenever the Bitcoin price
    changes or if the price moves outside preset upper or lower bounds.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从比特币开始，因为比特币的价格是 24/7 更新的，不像股票市场，股票市场只有在开放时才会更新实时价格。在创建比特币监控工具的过程中，你将学会构建其他金融市场监控工具所需的技能。该脚本会在比特币价格变化时提醒你，或者当价格超出预设的上下限时发出警告。
- en: You’ll first learn how to read JSON data and some basics of the *tkinter* package.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将学习如何读取 JSON 数据以及一些 *tkinter* 包的基础知识。
- en: How to Read JSON Data
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何读取 JSON 数据
- en: Bitcoin prices are available online for free and are updated every minute or
    so day and night. We’ll access Bitcoin prices through Python by using the API
    [https://api.coindesk.com/v1/bpi/currentprice.json](https://api.coindesk.com/v1/bpi/currentprice.json).
    Open the URL with a web browser, and you should see price information similar
    to [Figure 15-1](#figure15-1).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 比特币的价格可以在网上免费获取，并且每分钟更新一次，全天候更新。我们将通过 Python 使用 API [https://api.coindesk.com/v1/bpi/currentprice.json](https://api.coindesk.com/v1/bpi/currentprice.json)
    来获取比特币价格。用浏览器打开该 URL，你应该能看到类似 [图 15-1](#figure15-1) 的价格信息。
- en: '![f15001](Images/f15001.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![f15001](Images/f15001.png)'
- en: 'Figure 15-1: Live online information about Bitcoin price'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-1：比特币价格的实时在线信息
- en: This data is formatted in JSON and hard to read. There are so many nested dictionaries,
    it’s hard to tell where one dictionary starts and ends. We discussed in Chapter
    14 how to make the data easier to understand by using an online JSON data formatter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据是 JSON 格式的，且难以阅读。由于有许多嵌套字典，很难分辨每个字典的起始和结束位置。我们在第 14 章中讨论了如何通过使用在线 JSON 数据格式化工具来使数据更易于理解。
- en: Similar to what you did in that chapter, go to the online JSON data formatter
    website, [https://jsonformatter.curiousconcept.com/](https://jsonformatter.curiousconcept.com/),
    paste the data from [Figure 15-1](#figure15-1) into the designated space, and
    then click **Process**. The formatter will convert the data into a much more readable
    format, shown in [Listing 15-1](#listing15-1).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于你在那一章所做的，访问在线 JSON 数据格式化网站 [https://jsonformatter.curiousconcept.com/](https://jsonformatter.curiousconcept.com/)，将
    [图 15-1](#figure15-1) 中的数据粘贴到指定位置，然后点击 **Process**。格式化工具会将数据转换为更易读的格式，如 [清单 15-1](#listing15-1)
    所示。
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 15-1: The formatted JSON data about the Bitcoin price'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15-1：有关比特币价格的格式化JSON数据
- en: 'The dataset is a large dictionary of four elements with keys named `time` 1,
    `disclaimer` 2, `chartName` 3, and `bpi` 4. The value for the `bpi` key is, in
    turn, another dictionary with three keys: `USD`, `GBP`, and `EUR`. These represent
    the Bitcoin price in US dollars, British pounds, and Euros, respectively.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集是一个包含四个元素的大字典，键分别为`time` 1、`disclaimer` 2、`chartName` 3 和 `bpi` 4。`bpi`键的值又是一个字典，包含三个键：`USD`、`GBP`和`EUR`，分别表示比特币在美元、英镑和欧元中的价格。
- en: We want the Bitcoin price in US dollars. The script *bitcoin_price.py*, shown
    in [Listing 15-2](#listing15-2), retrieves the Bitcoin price and prints it out.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要获取美元（USD）的比特币价格。脚本*bitcoin_price.py*（见[列表 15-2](#listing15-2)）获取比特币价格并将其打印出来。
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 15-2: The script to retrieve the Bitcoin price'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15-2：用于获取比特币价格的脚本
- en: We import the *requests* module and specify the URL for the live Bitcoin price.
    We then use the `get()` method from the *requests* module to pull the data from
    the API. The `json()` method in the *requests* module reads the information into
    JSON format. We then extract the USD dictionary that contains all the Bitcoin
    price information in US dollars. The value we need from the dictionary is the
    price, and we use the `rate_float` key to retrieve it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了*requests*模块，并指定了实时比特币价格的URL。然后，我们使用*requests*模块中的`get()`方法从API中拉取数据。*requests*模块中的`json()`方法将信息读取为JSON格式。接着，我们提取包含所有比特币价格信息的美元（USD）字典。我们需要从字典中获取的值是价格，并使用`rate_float`键来检索它。
- en: 'Finally, we print out the Bitcoin price. The output should be something like
    this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们打印出比特币价格。输出应该类似于以下内容：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A Quick Introduction to the tkinter Package
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*tkinter*包简要介绍'
- en: Python’s default standard package for building a GUI is *tkinter*, short for
    *Tk interface*. The *tkinter* package has a variety of *widgets*, which are various
    tools like buttons, labels, entries, and message boxes. Widgets appear as different
    types of small windows inside the top-level root window, but they can also be
    stand-alone entities. We’ll focus on labels since we’ll use them in the market
    watch projects.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Python用于构建图形用户界面（GUI）的默认标准包是*tkinter*，即*Tk界面*的缩写。*tkinter*包有多种*控件*，例如按钮、标签、输入框和消息框等各种工具。控件作为小型窗口出现在顶层根窗口内，但也可以是独立的实体。我们将重点介绍标签控件，因为在市场监控项目中，我们将使用它们。
- en: 'The *tkinter* package is in the Python standard library and needs no installation.
    If you are using Linux and encounter the `ModuleNotFoundError` when importing
    *tkinter*, execute this line of command in a terminal to install it:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*tkinter*包是Python标准库的一部分，无需安装。如果你使用的是Linux，并且在导入*tkinter*时遇到`ModuleNotFoundError`，请在终端执行以下命令来安装它：'
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: I’ll introduce you to the basics of *tkinter*, including how to set up a screen
    and create a label widget. The script *tk_label.py*, shown in [Listing 15-3](#listing15-3),
    sets up a screen and adds a label to it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向你介绍*tkinter*的基础知识，包括如何设置屏幕和创建标签控件。脚本*tk_label.py*（见[列表 15-3](#listing15-3)）设置了一个屏幕并添加了一个标签。
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 15-3: Create a label in the *tkinter* package'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15-3：在*tkinter*包中创建标签
- en: We import the *tkinter* package. We set up a root window, which is used to hold
    all the widgets we’ll add to the script. We use the command `Tk()` and name the
    root window `root`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了*tkinter*包。我们设置了一个根窗口，用来容纳我们将要添加到脚本中的所有控件。我们使用命令`Tk()`并将根窗口命名为`root`。
- en: '*Labels* are a simple form of widget used to display messages or images for
    informational purposes. We give the root window a title, `A Label Inside a Root
    Window`, which will appear in the title bar. We call the `geometry()` method to
    specify the width and height of the root window as 800 by 200 pixels.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*标签*是用于显示消息或图片的简单控件，主要用于信息展示。我们为根窗口设置一个标题`A Label Inside a Root Window`，该标题会显示在标题栏中。我们调用`geometry()`方法来指定根窗口的宽度和高度为800x200像素。'
- en: We initiate a label by using `Label()`, which takes the text (or image) you
    want to display. You can optionally specify the color and font too. We use red
    and set the font to `("Helvetica", 80)`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`Label()`来初始化一个标签，该方法接受你想要显示的文本（或图片）。你也可以选择性地指定颜色和字体。我们使用红色，并将字体设置为`("Helvetica",
    80)`。
- en: With the `pack()` method, we specify where we want to put the label. The default
    is to line up widgets starting from the top center of the root window. Finally,
    `mainloop()` starts the game loop so that the window shows up and stays on your
    computer screen.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pack()`方法，我们可以指定标签的位置。默认情况下，控件从根窗口的顶部中心开始对齐。最后，`mainloop()`启动游戏循环，使得窗口出现在计算机屏幕上并保持显示。
- en: Run the script and you should see [Figure 15-2](#figure15-2).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，你应该看到[图 15-2](#figure15-2)。
- en: '![f15002](Images/f15002.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![f15002](Images/f15002.png)'
- en: 'Figure 15-2: A label inside the root window in *tkinter*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-2：*tkinter*中根窗口内的标签
- en: A Graphical Bitcoin Watch
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个图形化的比特币监视器
- en: Now we’ll create a graphical Bitcoin watch by using the *tkinter* package. Open
    your Spyder editor and save the code in [Listing 15-4](#listing15-4) as *bitcoin_tk.py*
    in your chapter folder.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用*tkinte*包创建一个图形化比特币监视器。打开你的Spyder编辑器，并将[列表 15-4](#listing15-4)中的代码保存为*bitcoin_tk.py*，存放在章节文件夹中。
- en: '[PRE27]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 15-4: Create a graphical Bitcoin price watch'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15-4：创建一个图形化比特币价格监视器
- en: We import the necessary functions and modules, including the *arrow* module
    to show the current time and date 1. We then use the `Tk()` method to create a
    top-level root window and specify the title and the size 2.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了必要的函数和模块，包括用于显示当前时间和日期的*arrow*模块 1。然后我们使用`Tk()`方法创建一个顶级根窗口，并指定标题和大小 2。
- en: We create two labels using `Label()` 3. We first leave the messages in both
    labels as empty strings because this information will fill in from the Bitcoin
    watch. At 4, we define `bitcoin_watch()`. The function first uses the *requests*
    module to obtain the Bitcoin price information from the URL we provide. We also
    obtain the current date and time and save them in the variables `tdate` and `tm`,
    respectively.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Label()`创建了两个标签 3。首先我们将两个标签中的信息设置为空字符串，因为这些信息将从比特币监视器中填充。在第 4 行，我们定义了`bitcoin_watch()`。该函数首先使用
    *requests* 模块从我们提供的 URL 获取比特币价格信息。我们还获取了当前的日期和时间，并分别将它们保存在变量`tdate`和`tm`中。
- en: At 5, we put the current date and time information in the first label, using
    the escape character `\n` to separate the lines. We put the live Bitcoin price
    in the second label.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 5 行，我们将当前的日期和时间信息放入第一个标签，使用转义字符`\n`来分隔行。我们将实时的比特币价格放入第二个标签。
- en: Next we set animation effects 6. We use `after()` to call another function after
    a specified amount of time. The command `after(1000, bitcoin_watch)` calls the
    function `bitcoin_watch()` after 1,000 milliseconds. Calling the command within
    the `bitcoin_watch()` function itself creates an infinite loop in which all the
    command lines inside `bitcoin_watch()` will be executed every 1,000 milliseconds.
    The result is that the time is constantly updated, and you can see the time value
    changes every second. If you keep the screen live long enough, you will also see
    the Bitcoin price change every minute or so.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们设置动画效果 6。我们使用`after()`在指定的时间后调用另一个函数。命令`after(1000, bitcoin_watch)`在 1000
    毫秒后调用`bitcoin_watch()`函数。在`bitcoin_watch()`函数内调用该命令，会创建一个无限循环，每 1000 毫秒执行一次`bitcoin_watch()`中的所有命令行。结果是时间不断更新，你会看到时间值每秒变化。如果你让屏幕长时间保持活跃，你也会看到比特币价格每隔大约一分钟发生变化。
- en: When run, the script should look similar to [Figure 15-3](#figure15-3).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，脚本应类似于[图 15-3](#figure15-3)。
- en: '![f15003](Images/f15003.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![f15003](Images/f15003.png)'
- en: 'Figure 15-3: Using the `after()` function to create an animated Bitcoin watch'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-3：使用`after()`函数创建一个动画比特币监视器
- en: A Talking Bitcoin Watch
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个会说话的比特币监视器
- en: 'Next we’ll add the speech functionality. Whenever the price updates, the script
    will let you know in a human voice. We’ll also add an alert system: when the Bitcoin
    price moves outside the preset upper and lower bounds, the script will alert you
    out loud.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加语音功能。每当价格更新时，脚本会用人声通知你。我们还将添加一个警报系统：当比特币价格超出预设的上下限时，脚本会大声提醒你。
- en: Open *bitcoin_watch.py* from your chapter folder. Its differences from *bitcoin_tk.py*
    are highlighted in [Listing 15-5](#listing15-5).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 打开章节文件夹中的*bitcoin_watch.py*。它与*bitcoin_tk.py*的区别在[列表 15-5](#listing15-5)中有突出显示。
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 15-5: Script to create a talking graphical Bitcoin price watch'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15-5：创建一个会说话的图形化比特币价格监视器的脚本
- en: We import the modules, including the `print_say()` function from the local *mptpkg*
    package.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了必要的模块，包括来自本地*mptpkg*包的`print_say()`函数。
- en: We retrieve a Bitcoin price to use as the starting price and save it as `oldprice`
    1. We set the upper and lower bounds as values 5 percent above and below the value
    stored in `oldprice` and save them as `maxprice` and `minprice`, respectively.
    The script announces in a human voice the price of Bitcoin at that moment 2.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取比特币的价格作为起始价格，并将其保存为`oldprice` 1。我们设置上限和下限，分别为`oldprice`存储值的上下5%的数值，并将其保存为`maxprice`和`minprice`。脚本会用人声宣布比特币当时的价格2。
- en: We declare `oldprice` a global variable so that it can be recognized both inside
    and outside the function `bitcoin_watch()` 3. Every time `bitcoin_watch()` is
    called, it obtains the latest Bitcoin price and compares it to the value stored
    in `oldprice`. If the values are different, the value of `oldprice` is updated
    to the new price, and the script announces the updated price 4.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`oldprice`声明为全局变量，这样它可以在`bitcoin_watch()`函数内外都能被识别3。每次调用`bitcoin_watch()`时，它都会获取最新的比特币价格，并与`oldprice`中存储的值进行比较。如果值不同，`oldprice`的值会更新为新价格，并且脚本会宣布更新后的价格4。
- en: At 5, the script checks whether the price has gone above the upper bound; if
    yes, it makes the announcement. Similarly, the script checks whether the price
    is below the lower bound and makes the announcement if it is.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步，脚本会检查价格是否超过上限；如果是，脚本会进行播报。类似地，脚本还会检查价格是否低于下限，如果是，也会进行播报。
- en: 'This output is from running the script for a few minutes:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行脚本几分钟后的输出：
- en: '[PRE29]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A Talking Stock Market Watch
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个会讲解的股市监控
- en: Now we’ll use these skills to build the talking, graphical, live US stock market
    watch. We’ll make several significant changes to the Bitcoin version.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用这些技巧来构建一个可以讲解的、图形化的实时美国股市监控。我们会对比特币版本做出一些重要的修改。
- en: 'First, instead of showing just one asset, we’ll cover three major players in
    the market: Apple, Amazon, and Tesla. We’ll also show, as the main indexes we
    are interested in, the Dow Jones Industrial Average and the S&P 500\.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将不再只展示一个资产，而是涵盖市场中的三大玩家：苹果、亚马逊和特斯拉。我们还会展示我们感兴趣的主要指数：道琼斯工业平均指数和标准普尔500指数。
- en: Second, instead of updating every thousand milliseconds, we’ll ask the script
    to update every two minutes. The script needs to retrieve five pieces of information
    instead of just one, and updating too frequently will cause information overload
    that could lead to the script freezing. More important, the values for the market
    indexes and prices for the preceding three stocks update every few seconds during
    the trading hours. Updating too often would make the announcements come nonstop
    and be distracting. You can choose to adjust the frequency that the script updates
    to your own liking.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们将脚本的更新时间从每千毫秒一次调整为每两分钟更新一次。脚本需要获取五个信息，而不是仅仅一个，频繁更新会导致信息过载，从而可能导致脚本冻结。更重要的是，市场指数和前三只股票的价格在交易时间内每几秒更新一次。过于频繁的更新会导致语音宣布不停，反而分散注意力。你可以根据自己的喜好调整脚本的更新时间频率。
- en: Save the script in [Listing 15-6](#listing15-6) as *stock_watch.py* in your
    chapter folder or download it from the book’s resources page.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 将[列表15-6](#listing15-6)中的脚本保存为*stock_watch.py*，放入章节文件夹中，或者从书籍的资源页面下载。
- en: '[PRE30]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 15-6: Script to create a talking, graphical live US stock market watch'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表15-6：创建一个讲解的、图形化的实时美国股市监控脚本
- en: We import the modules, including *arrow* to show the time and date and *yahoo_fin*
    to obtain stock price information. We also import `print_say()` from the local
    *mptpkg* package to make announcements.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了模块，包括用于显示时间和日期的*arrow*以及用于获取股票价格信息的*yahoo_fin*。我们还从本地的*mptpkg*包中导入了`print_say()`来进行语音播报。
- en: 'Starting at 1, we create the *tkinter* root window and place two labels in
    it, as we did in *bitcoin_watch.py*. We then create three lists: `oldprice`, `maxprice`,
    and `minprice` 2. We use `oldprice` to keep track of the values of the two indexes
    and the prices of the three stocks when we start running the script. The list
    `maxprice` holds the five upper bounds, 5 percent above the corresponding values
    in `oldprice`. Similarly, we define the five lower bounds in `minprice`.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 从第1步开始，我们创建了*tKinter*根窗口，并在其中放置了两个标签，就像在*bitcoin_watch.py*中做的一样。然后我们创建了三个列表：`oldprice`、`maxprice`和`minprice`
    2。我们使用`oldprice`来跟踪脚本运行时两个指数和三只股票的价格。`maxprice`列表保存上限，数值为`oldprice`中相应值的5%之上。同样，我们在`minprice`中定义了五个下限。
- en: The script then announces the values of the two indexes and the prices of the
    three stocks. Note that we put `dollars` after the three stock prices, but not
    after the two index values because index values are not measured in dollars.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，脚本会宣布两个指数的值和三只股票的价格。请注意，我们在三只股票价格后加上了`dollars`，但没有在两个指数值后加，因为指数值不是以美元为单位的。
- en: We define `stock_watch()` at 3, which declares `oldprice`a global variable.
    Every time the function is called, it retrieves the values we’re interested in
    4. We keep two digits after the decimal for all values and save them in a list
    `p` 5.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在3处定义了`stock_watch()`，声明了`oldprice`为全局变量。每次调用该函数时，它会检索我们感兴趣的值4。我们将所有值保留两位小数，并将它们保存在列表`p`中5。
- en: We obtain the time and date and put them in the first label. We put the values
    of the two indexes and three stocks in the second label. At 6, we check each of
    the five values for updates, and we print and announce any updates. We also update
    the value stored in `oldprice` accordingly.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取时间和日期并将其放入第一个标签。我们将两个指数和三只股票的值放入第二个标签。在6时，我们检查五个值是否有更新，并打印并宣布任何更新。同时，我们还会相应地更新存储在`oldprice`中的值。
- en: Starting at 7, we check whether any of the five values has gone out of bounds.
    If yes, the script makes an announcement. Finally, we use `after()` to create
    the animation effect 8. The `stock_watch()` function calls itself every 120,000
    milliseconds, updating the screen every two minutes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 从7处开始，我们检查五个值是否有越界。如果有，脚本会发出通知。最后，我们使用`after()`创建动画效果8。`stock_watch()`函数每隔120,000毫秒调用一次自身，每两分钟更新一次屏幕。
- en: 'Here’s the output from one interaction with the script:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与脚本交互的一次输出：
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In just a few minutes, the script has updated all five values three times. [Figure
    15-4](#figure15-4) shows the final screen.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅几分钟，脚本已经更新了所有五个值三次。[图15-4](#figure15-4)展示了最终的屏幕。
- en: '![f15004](Images/f15004.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![f15004](Images/f15004.png)'
- en: 'Figure 15-4: A graphical live US stock market watch'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-4：一个图形化的美国股市实时监控
- en: Apply the Method to Other Financial Markets
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将方法应用于其他金融市场
- en: 'We can apply these methods to other financial markets. If the price information
    is available from Yahoo! Finance, the modification is minimal: we just change
    the ticker symbols in the scripts.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些方法应用到其他金融市场。如果从Yahoo! Finance可以获取价格信息，修改就很小：我们只需在脚本中更改股票代码。
- en: If the price information is not available from Yahoo! Finance, search online
    for a website that provides JSON data for the market and then use the same method
    we used to retrieve the Bitcoin price.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从Yahoo! Finance无法获取价格信息，请在线查找一个提供市场JSON数据的网站，然后使用我们之前用来获取比特币价格的方法。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you first learned how to retrieve information from JSON data
    and use it to create a graphical Bitcoin watch using the *tkinter* package. You
    obtained the live Bitcoin price online and created widgets with animations in
    *tkinter*.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你首先学会了如何从JSON数据中获取信息，并使用这些信息创建一个图形化的比特币监控，使用了*tkinter*包。你在线获取了实时比特币价格，并在*tkinter*中创建了带动画的小部件。
- en: With these skills, you made a graphical live market watch for the US stock market
    with spoken alerts. The script generates a graphical display of two major US stock
    indexes and three stocks that you’re interested in. When the prices change, the
    script lets you know in a human voice. The script also alerts you if an index
    value or a stock price goes outside the preset bounds.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些技能，你创建了一个带语音提示的美国股市实时图形监控。脚本生成了两个主要美国股指和你感兴趣的三只股票的图形化显示。当价格发生变化时，脚本会用人声告诉你。若某个指数值或股票价格超出了预设范围，脚本也会发出警报。
- en: You also learned how to apply this process to create a talking graphical market
    watch for other financial markets.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学会了如何应用这个过程，为其他金融市场创建一个带语音的图形化市场监控。
- en: End-of-Chapter Exercises
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 章节末练习
- en: Modify *bitcoin_price.py* to retrieve the price in British pounds instead of
    US dollars and as a string variable instead of a floating-point number.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改*bitcoin_price.py*，以检索英镑价格而不是美元价格，并将其作为字符串变量而非浮动点数。
- en: Modify *tk_label.py* so that the size of the root window is 850 by 160 pixels
    and the message in the label displays `here is your label`.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改*tk_label.py*，使得根窗口的大小为850x160像素，并且标签中的消息显示为`here is your label`。
- en: Modify *bitcoin_tk.py* so that the screen refreshes every 0.8 seconds.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改*bitcoin_tk.py*，使得屏幕每0.8秒刷新一次。
- en: Modify *bitcoin_watch.py* so that the upper and lower bounds are set to 3 percent
    above and below the price when you start running the script.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 *bitcoin_watch.py*，使得当您开始运行脚本时，上下限设置为价格的 3% 上下浮动。
- en: '16'
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Use World Languages
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用世界语言
- en: '![](Images/chapterart.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: So far, we’ve taught Python how to speak and listen in English. But Python can
    understand many other world languages. In this chapter, you’ll first teach Python
    to talk in several other languages with the modules we’ve been using. I’ll then
    introduce a useful module called *translate*, which can translate one language
    to another, and you’ll use this to silently translate languages. Then we’ll add
    the speech recognition and text-to-speech features so you can speak one language
    to the Python script and the script will say the translation in another language
    of your choice.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经教会了 Python 如何用英语进行听说。但是 Python 可以理解许多其他世界语言。在本章中，您将首先教会 Python 使用我们之前使用的模块进行几种其他语言的口语表达。然后，我会介绍一个有用的模块
    *translate*，它可以将一种语言翻译成另一种语言，您将用它来静默翻译语言。接着我们将添加语音识别和语音合成功能，这样您就可以用一种语言对 Python
    脚本说话，脚本将以您选择的另一种语言进行翻译。
- en: As usual, all scripts in this chapter are available at the book’s resources
    page at [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
    Start by creating the folder */mpt/ch16/* for this chapter.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，本章的所有脚本可以在本书的资源页面找到，网址为 [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/)。首先创建文件夹
    */mpt/ch16/* 来存放本章内容。
- en: Text to Speech in Other Languages
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他语言的语音合成
- en: To work with non-English languages, we’ll use *gTTS* because it supports most
    major world languages. The downside to using *gTTS* is that it needs a separate
    module to play the audio file, but the alternative (*pyttsx3*) doesn’t support
    a wide range of non-English languages. Here we’ll try out the *gTTS* module with
    a few examples.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用非英语语言，我们将使用 *gTTS*，因为它支持大多数主要的世界语言。使用 *gTTS* 的缺点是它需要一个单独的模块来播放音频文件，但替代方案
    (*pyttsx3*) 不支持广泛的非英语语言。这里我们将尝试使用 *gTTS* 模块进行一些示例。
- en: Install Modules
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装模块
- en: 'To install the *gTTS* module in Windows, activate the virtual environment *chatting*
    and then execute the following command in the Anaconda prompt and follow the onscreen
    instructions:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中安装 *gTTS* 模块，激活虚拟环境 *chatting*，然后在 Anaconda 提示符中执行以下命令，并按照屏幕上的说明操作：
- en: '[PRE32]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you’re using Mac or Linux, you should already have installed the *gTTS*
    module in Chapter 4. However, Google Translate has been known to make significant
    changes to the module, so you should upgrade to the latest version by running
    the following command in a terminal with the virtual environment *chatting* activated:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 Mac 或 Linux，您应该已经在第 4 章中安装了 *gTTS* 模块。然而，Google 翻译已知会对该模块进行重大更改，因此您应该通过在终端中运行以下命令来升级到最新版本，同时激活虚拟环境
    *chatting*：
- en: '[PRE33]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You also need to install the *pydub* module to play audio files. You need to
    do this step no matter whether you’re using Windows, Mac, or Linux. Execute the
    following two lines of code in the Anaconda prompt (Windows) or a terminal (Mac
    or Linux), with the *chatting* virtual environment activated:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要安装 *pydub* 模块来播放音频文件。无论您使用的是 Windows、Mac 还是 Linux，您都需要执行这一步。在激活 *chatting*
    虚拟环境的情况下，在 Anaconda 提示符（Windows）或终端（Mac 或 Linux）中执行以下两行代码：
- en: '[PRE34]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Follow the instructions all the way through.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 按照指示一直执行下去。
- en: Convert Text to Speech in Spanish
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将文本转换为西班牙语语音
- en: The script *speak_spanish.py* in [Listing 16-1](#listing16-1) shows how the
    *gTTS* module converts written Spanish into spoken Spanish. Enter these lines
    of code in your Spyder editor and save the script as *speak_spanish.py* in your
    chapter folder.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 16-1](#listing16-1) 中的脚本 *speak_spanish.py* 展示了 *gTTS* 模块如何将书面西班牙语转换为口语西班牙语。在
    Spyder 编辑器中输入这些代码行，并将脚本保存为 *speak_spanish.py*，保存在您的章节文件夹中。
- en: '[PRE35]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 16-1: Script to convert written Spanish to spoken Spanish'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 16-1：将书面西班牙语转换为口语西班牙语的脚本
- en: We first import the modules, including *gTTS* and *pydub*, that will play the
    audio file.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入模块，包括 *gTTS* 和 *pydub*，这些模块将播放音频文件。
- en: Next, we use the `gTTS()` function to convert the Spanish phrase `Buenos días`
    to spoken Spanish. The phrase can be literally translated to *Good day*. The first
    argument to `gTTS()` specifies which phrase to convert, and the second specifies
    what language to use. In this case, we use `es`, which stands for *Español*, or
    *Spanish* (see [Table 16-1](#table16-1) for a list of language codes).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`gTTS()`函数将西班牙语短语`Buenos días`转换为语音西班牙语。该短语可以字面翻译为*早安*。`gTTS()`的第一个参数指定要转换的短语，第二个参数指定使用的语言。在这种情况下，我们使用`es`，即*Español*，或者*西班牙语*（请参见[表16-1](#table16-1)查看语言代码列表）。
- en: The script generates a temporary file *voice* by using the `BytesIO()` function
    in the *io* module. If you instead used a fixed filename (such as *myfile.mp3*),
    the script may prevent you from overwriting the file when you rerun it and can
    crash. By using a temporary file each time you run the script, you avoid a crash.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本通过使用`BytesIO()`函数在*io*模块中生成一个临时文件*voice*。如果你使用固定的文件名（例如*myfile.mp3*），脚本可能会阻止你在重新运行时覆盖该文件，并可能导致崩溃。通过每次运行脚本时使用临时文件，可以避免崩溃。
- en: Finally, we save the voice output as an audio file in the temporary file *voice*
    we just created. Then we play the audio file by using the *pydub* module. Run
    the script to hear Python say “Buenos días” in Spanish.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将语音输出保存为我们刚才创建的临时文件*voice*中的音频文件。然后，我们使用*pydub*模块播放音频文件。运行脚本可以听到Python用西班牙语说“Buenos
    días”。
- en: Support Text to Speech in Other Languages
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持其他语言的文本转语音
- en: The *gTTS* module can convert text to speech in most major languages. [Table
    16-1](#table16-1) provides an incomplete list of the languages that the module
    supports, followed by the code used in the `gTTS()` function.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*gTTS*模块可以将文本转换为大多数主要语言的语音。[表16-1](#table16-1)提供了该模块支持的语言的一个不完全列表，后面跟着在`gTTS()`函数中使用的代码。'
- en: 'Table 16-1: Major World Languages and the Corresponding Code in the *g**TTS*
    Module'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 表16-1：主要世界语言及其在*gTTS*模块中的对应代码
- en: '| **Language name** | **Language code** |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| **语言名称** | **语言代码** |'
- en: '| --- | --- |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Arabic | `ar` |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 阿拉伯语 | `ar` |'
- en: '| Chinese | `zh` |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 中文 | `zh` |'
- en: '| Dutch | `nl` |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| 荷兰语 | `nl` |'
- en: '| English | `en` |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 英语 | `en` |'
- en: '| French | `fr` |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 法语 | `fr` |'
- en: '| German | `de` |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 德语 | `de` |'
- en: '| Italian | `it` |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 意大利语 | `it` |'
- en: '| Japanese | `ja` |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 日语 | `ja` |'
- en: '| Korean | `ko` |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 韩语 | `ko` |'
- en: '| Portuguese | `pt` |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 葡萄牙语 | `pt` |'
- en: '| Russian | `ru` |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 俄语 | `ru` |'
- en: '| Spanish | `es` |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| 西班牙语 | `es` |'
- en: You can find a more comprehensive list at [https://cloud.google.com/speech-to-text/docs/languages/](https://cloud.google.com/speech-to-text/docs/languages/).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://cloud.google.com/speech-to-text/docs/languages/](https://cloud.google.com/speech-to-text/docs/languages/)找到更全面的列表。
- en: Next, you’ll create a script to choose the language you want. After that, you’ll
    ask the script to translate a phrase from text to spoken language.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将创建一个脚本来选择你想要的语言。之后，你会让脚本将短语从文本转换为语音。
- en: Convert Text to Speech in World Languages
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将文本转换为世界语言的语音
- en: The script *speak_world_languages.py* in [Listing 16-2](#listing16-2) shows
    you how to convert text to speech in several major world languages.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本*speak_world_languages.py*（见[列表16-2](#listing16-2)）演示了如何将文本转换为几种主要世界语言的语音。
- en: '[PRE36]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 16-2: Script to convert written language to spoken language'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 列表16-2：将书面语言转换为语音语言的脚本
- en: We create a dictionary *lang_abbre*, which maps different foreign languages
    to the corresponding codes in the *gTTS* module 1. The script then asks what language
    you want to use. You can type in your choice in the IPython console 2. Then type
    in the phrase you want to convert to voice at the prompt.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个字典*lang_abbre*，将不同的外语映射到*gTTS*模块中的相应代码。然后脚本会询问你想使用的语言。你可以在IPython控制台中输入你的选择。然后在提示符中输入你想转换为语音的短语。
- en: The script converts your phrase into an audio file and saves it in the temporary
    file *voice*.Then it plays the audio file by using the *pydub* module.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将你的短语转换成音频文件，并保存在临时文件*voice*中。然后它使用*pydub*模块播放音频文件。
- en: 'The following is an interaction with the script, with my text input in bold:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与脚本的交互，我的文本输入为粗体：
- en: '[PRE37]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: I first chose the language Chinese and then typed in the text `嗨,你好吗?`, which
    is the Chinese phrase for *Hi, how are you?* After running the script, I heard
    Python speaking Chinese.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先选择了中文语言，然后输入了文本`嗨,你好吗?`，这是中文的*嗨，你好吗？* 运行脚本后，我听到了Python用中文说话。
- en: Speech Recognition in Major World Languages
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要世界语言的语音识别
- en: The speech recognition module we’ve used throughout this book is able to recognize
    other major world languages as well. We just need to let the script know which
    language we want to use.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中使用的语音识别模块也能够识别其他主要世界语言。我们只需要告诉脚本我们想使用哪种语言。
- en: We’ll use Japanese as an example to illustrate how it works. The script *sr_japanese.py*
    in [Listing 16-3](#listing16-3) recognizes spoken Japanese and converts your voice
    into written text.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用日语作为示例来说明它是如何工作的。[列表 16-3](#listing16-3) 中的脚本 *sr_japanese.py* 能够识别日语语音并将你的声音转换为文字。
- en: '[PRE38]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 16-3: Speech recognition in Japanese'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16-3：日语语音识别
- en: We first import the speech recognition module. Then we initiate speech recognition
    by using the `Recognizer()` function. The script prints out the message `Python
    is listening in Japanese` to prompt you to speak Japanese into the microphone.
    We use the `adjust_for_ambient_noise()` function to reduce the influence of any
    ambient noise on your voice input.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入语音识别模块。然后，我们通过使用 `Recognizer()` 函数启动语音识别。脚本会打印出信息 `Python is listening
    in Japanese` 来提示你对着麦克风说日语。我们使用 `adjust_for_ambient_noise()` 函数来减少环境噪声对语音输入的影响。
- en: At 1, we specify Japanese by passing `language="ja"` in the `recognize_google()`
    function. Recall from Chapter 3 that `recognize_google()` uses the Google Web
    Speech API; this is in contrast to other methods such as `recognize_bing()`, which
    uses the services of Microsoft Bing Speech, or `recognize_ibm()`, which uses the
    services of IBM Speech to Text. The script then prints out your voice input in
    Japanese.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1行中，我们通过在 `recognize_google()` 函数中传递 `language="ja"` 来指定日语。回想一下第3章，`recognize_google()`
    使用的是 Google Web Speech API；与此相对的是其他方法，例如使用 Microsoft Bing Speech 服务的 `recognize_bing()`，或者使用
    IBM Speech to Text 服务的 `recognize_ibm()`。然后，脚本会输出你用日语输入的语音内容。
- en: 'Here’s my output from interacting with the computer:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我与计算机互动的输出：
- en: '[PRE39]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: I said into the microphone “Thank you” in Japanese. The script correctly captures
    the phrase and prints it out.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我对着麦克风用日语说“谢谢”。脚本正确地捕捉到这句话并输出。
- en: You can easily modify *sr_japanese.py* by replacing `language="ja"` (and the
    appropriate language titles in the prompts) with the language of your choice so
    that you can interact with the computer in another language. The list of world
    languages and their corresponding codes can be found at [https://www.science.co.il/language/Locale-codes.php.](https://www.science.co.il/language/Locale-codes.php.)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松修改 *sr_japanese.py*，只需将 `language="ja"`（以及提示中的适当语言标题）替换为你选择的语言，这样你就可以用另一种语言与计算机互动。世界语言及其相应代码的列表可以在
    [https://www.science.co.il/language/Locale-codes.php.](https://www.science.co.il/language/Locale-codes.php)
    找到。
- en: A Talking Wikipedia
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会话维基百科
- en: Wikipedia supports most major world languages, detailed at [https://en.wikipedia.org/wiki/List_of_Wikipedias](https://en.wikipedia.org/wiki/List_of_Wikipedias).
    In Chapter 5, we created a talking Wikipedia in English. We’ll build a version
    you can adapt to work with any major language. [Listing 16-4](#listing16-4) uses
    Chinese. Enter the following code into your Spyder editor and save it as *wiki_world_languages.py*.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 维基百科支持大多数主要世界语言，详细信息请参见 [https://en.wikipedia.org/wiki/List_of_Wikipedias](https://en.wikipedia.org/wiki/List_of_Wikipedias)。在第5章中，我们创建了一个英文版的会话维基百科。我们将构建一个版本，您可以将其调整为适应任何主要语言。[列表
    16-4](#listing16-4) 使用了中文。将以下代码输入到 Spyder 编辑器中并保存为 *wiki_world_languages.py*。
- en: '[PRE40]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 16-4: A talking Wikipedia in major world languages'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 16-4：多种主要世界语言的会话维基百科
- en: We import the modules, including the *wikipedia* module we used in Chapter 5.
    The dictionary *lang_abbre* maps different foreign languages to the corresponding
    codes in the *gTTS* module. We’ll also use the language codes in the *speech_recognition*
    module and the *wikipedia* module.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入模块，包括在第5章中使用的 *wikipedia* 模块。字典 *lang_abbre* 将不同的外语映射到 *gTTS* 模块中的相应代码。我们还将使用
    *speech_recognition* 模块和 *wikipedia* 模块中的语言代码。
- en: The script then asks what language you want to use 1. You can type in your choice
    in the IPython console. Then speak your query into the microphone in the language
    you chose 2. The script captures the voice input, converts it to written text,
    and stores it in `my_input`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，脚本会询问你想使用哪种语言 1。你可以在 IPython 控制台中输入你的选择。然后，用你选择的语言对着麦克风说出你的查询 2。脚本会捕捉语音输入，将其转为文字，并保存在
    `my_input` 中。
- en: The script then prints your query 3. After it does so, we set the language of
    Wikipedia to the language of your choice. We then send the query to Wikipedia
    and print the result. Finally, we convert the answer to speech and let the script
    say it in a human voice 4.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，脚本会打印出你的查询3。完成后，我们将维基百科的语言设置为你选择的语言。接着，我们将查询发送给维基百科并打印结果。最后，我们将答案转换为语音，并让脚本用人声播放4。
- en: 'Here is the output from an interaction with the script, with my written and
    voice inputs in bold:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是与脚本交互的输出，其中我的书面输入和语音输入以粗体显示：
- en: '[PRE42]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: I first typed in `chinese` as my choice of language. Then I said “United States
    of America” in Chinese into the microphone, and the script stored a short description
    of the United States in Chinese and both printed and spoke it.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我首先输入了`chinese`作为我的语言选择。然后，我用中文在麦克风前说出了“United States of America”（美国），脚本存储了美国的简短描述，并将其打印出来，同时用语音播报。
- en: Create Your Own Voice Translator
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建你自己的语音翻译器
- en: Now you’ll create your own voice translator. When you speak to the script in
    any major language, the script will translate it to another language of your choice
    and speak it out.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将创建你自己的语音翻译器。当你用任何主要语言对着脚本讲话时，脚本会将其翻译成你选择的另一种语言并用语音播报。
- en: We’ll first make a text version with the *translate* module, then add speech
    recognition and text-to-speech features.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先会使用*translate*模块创建一个文本版本，然后添加语音识别和文本转语音功能。
- en: A Text-Based Translator
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一种基于文本的翻译器
- en: 'We first need to install the *translate* module, powered by Google Translate.
    The module is not in the Python Standard Library, and we need to `pip install`
    it. Open the Anaconda prompt (in Windows) or a terminal (in Mac or Linux). With
    the virtual environment *chatting* activated, run the following command:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要安装由谷歌翻译提供支持的*translate*模块。该模块不在Python标准库中，因此我们需要使用`pip install`进行安装。打开Anaconda提示符（Windows中）或终端（Mac或Linux中）。在激活虚拟环境*chatting*的情况下，运行以下命令：
- en: '[PRE43]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Follow the instructions to finish the installation.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 按照说明完成安装。
- en: The script in [Listing 16-5](#listing16-5) translates English to Chinese, and
    translates Chinese to English, by using text input. Open your Spyder editor and
    copy the following code; then save it as *english_chinese.py* in your chapter
    folder.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单16-5](#listing16-5)中的脚本将英语翻译为中文，并将中文翻译为英语，使用文本输入。打开Spyder编辑器并复制以下代码；然后将其保存为*english_chinese.py*，放入你的章节文件夹中。'
- en: '[PRE44]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Listing 16-5: Translation between English and Chinese'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 清单16-5：英语和中文之间的翻译
- en: We first import the `Translator()` function from the *translate* module. We
    need to specify the input language (here, English `from_lang="en"`) and the output
    language (here, Chinese with `to_lang="zh"`). We translate the phrase `hello all`
    from English to Chinese and print it.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从*translate*模块导入`Translator()`函数。我们需要指定输入语言（此处为英语`from_lang="en"`）和输出语言（此处为中文`to_lang="zh"`）。我们将短语`hello
    all`从英语翻译为中文并打印出来。
- en: 'Then we reverse the input and output languages to translate the phrase `请再说一遍`
    from Chinese to English and print it. The output is as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们反转输入和输出语言，将短语`请再说一遍`从中文翻译为英语并打印出来。输出如下：
- en: '[PRE45]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We can modify the input and output languages in *english_chinese.py* to use
    any two major world languages. To see the languages supported by the *translate*
    module and their corresponding codes, check [https://www.labnol.org/code/19899-google-translate-languages/](https://www.labnol.org/code/19899-google-translate-languages/).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*english_chinese.py*中修改输入和输出语言，以使用任何两种主要的世界语言。要查看*translate*模块支持的语言及其对应的代码，请访问[https://www.labnol.org/code/19899-google-translate-languages/](https://www.labnol.org/code/19899-google-translate-languages/)。
- en: A Voice-Based Translator
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一种基于语音的翻译器
- en: Next, we’ll add speech recognition and text-to-speech functionality. Again,
    we’ll hardcode the language to translate to and from, but you can easily adapt
    this script to any supported language.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加语音识别和文本转语音功能。再次强调，我们将硬编码要翻译的语言，但你可以轻松地将此脚本适配为任何支持的语言。
- en: This version translates English to Spanish and Spanish to English. Open your
    Spyder editor and copy [Listing 16-6](#listing16-6). Save the script as *voice_translator.py*
    in your chapter folder.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本将英语翻译为西班牙语，西班牙语翻译为英语。打开你的Spyder编辑器并复制[清单16-6](#listing16-6)。将脚本保存为*voice_translator.py*，并放入你的章节文件夹中。
- en: '[PRE46]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Listing 16-6: A voice translator between English and Spanish'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 清单16-6：英语和西班牙语之间的语音翻译器
- en: We first import all modules. Then we initiate speech recognition by using the
    `Recognizer()` function. Next, the script prints `say something in English` to
    prompt you to speak the English phrase you want to translate.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入所有模块。然后，通过使用`Recognizer()`函数启动语音识别。接下来，脚本打印`say something in English`，提示你说出想要翻译的英语短语。
- en: The script captures your voice input, saves it in the variable `my_input`, and
    prints it. At 1, we specify the input language as English and the output language
    as Spanish. We then translate the text stored in `my_input` to Spanish and print
    it 2. After printing the translation, we convert the Spanish text to voice. Finally,
    we save the translation to an audio file and play it 3.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本捕捉到你的语音输入，将其保存在变量`my_input`中并打印。在第1步，我们指定输入语言为英语，输出语言为西班牙语。然后，我们将存储在`my_input`中的文本翻译成西班牙语并打印出来2。打印完翻译后，我们将西班牙语文本转换为语音。最后，我们将翻译保存为音频文件并播放3。
- en: Starting at 4, we reverse the input and output languages. You can then speak
    a Spanish phrase to translate, and the computer will give the English translation.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 从第4步开始，我们反转了输入和输出语言。你可以说出一句西班牙语短语进行翻译，计算机会给出英语翻译。
- en: 'Here is the output from an interaction with the script, with my voice input
    in bold:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与脚本交互的输出，包含我用**粗体**标出的语音输入：
- en: '[PRE47]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: I spoke the phrase “Today is a great day” in English. The script printed and
    spoke the Spanish translation `Hoy es un gran día`. I then said in Spanish, “uno,
    dos, tres.” The script correctly printed and spoke the English translation `1
    2 3`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我用英语说了短语“Today is a great day”。脚本打印并朗读了西班牙语翻译`Hoy es un gran día`。然后，我用西班牙语说“uno,
    dos, tres”。脚本正确地打印并朗读了英语翻译`1 2 3`。
- en: Summary
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you adapted your speaking scripts to use any major world language.
    Along the way, you learned to convert text to speech in major world languages
    such as Spanish, Chinese, Japanese, French, and so on. You also learned how to
    perform speech recognition in major world languages. With these skills, you are
    able to interact with your computer in non-English languages.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你调整了你的语音脚本，以使用任何主要的世界语言。在此过程中，你学习了如何将文本转化为西班牙语、中文、日语、法语等主要世界语言的语音。你还学习了如何在这些主要世界语言中进行语音识别。通过这些技能，你能够用非英语语言与计算机互动。
- en: You then learned how to install the *translate* module, which can translate
    text from one language to another. We combined the module with the speech recognition
    and text-to-speech features to create a voice translator. This is incredibly useful
    real-world functionality that can help make your deployed applications globally
    adaptable.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了如何安装*translate*模块，它可以将文本从一种语言翻译成另一种语言。我们将该模块与语音识别和文本转语音功能结合，创建了一个语音翻译器。这是一个非常实用的现实功能，可以帮助使你部署的应用程序具备全球适应性。
- en: '17'
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Ultimate Virtual Personal Assistant
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 终极虚拟个人助理
- en: '![](Images/chapterart.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: In this chapter, you’ll load up a virtual personal assistant (VPA) with the
    interesting projects in this book, like voice-controlled games, voice translators,
    voice music activations, and so on. You’ll first add a chatting functionality
    to the script so you can carry out a daily conversation with the VPA. You’ll create
    a dictionary of questions and answers. Whenever your voice command matches one
    of the questions in the dictionary, the VPA speaks the answer from the dictionary.
    This enables the VPA to answer certain questions in a very particular way, instead
    of obtaining an answer from Wikipedia or WolframAlpha.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将加载一个虚拟个人助理（VPA），并结合本书中的有趣项目，如语音控制游戏、语音翻译器、语音音乐激活等。你将首先向脚本添加聊天功能，以便你可以与VPA进行日常对话。你将创建一个问答字典，每当你的语音命令与字典中的某个问题匹配时，VPA就会从字典中说出答案。这使得VPA能够以非常特定的方式回答某些问题，而不是从维基百科或WolframAlpha获取答案。
- en: 'After that, you’ll add the following functionalities:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你将添加以下功能：
- en: The voice-activated music player from Chapter 5
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第5章中的语音激活音乐播放器
- en: The voice-activated NPR News Now from Chapter 6
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第6章中的语音激活NPR新闻功能
- en: The voice-activated radio functionality from Chapter 6
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第6章中的语音激活收音机功能
- en: The voice-activated Connect Four game from Chapter 13 (and the tic-tac-toe game
    from the exercises)
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第13章中的语音激活四子棋游戏（以及练习中的井字游戏）
- en: Stock price functionality that lets you find out the latest price of US stocks
    and their index values from Chapter 15
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第15章中的股票价格功能，让你可以查询美国股票的最新价格及其指数值
- en: Translator functionality that renders English phrases in any major world language
    in Chapter 16
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The whole idea of a VPA is its convenience, so we’ll make adjustments in these
    projects so that all added functionalities are 100 percent hands-free. After a
    functionality is finished, the VPA will go back to the main menu and wait for
    your voice command.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: As usual, all scripts in this chapter are available at the book’s resources
    page, [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
    Start by creating the folder */mpt/ch17/* for this chapter.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: An Overview of the Final VPA
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s have a look at the complete script of our final VPA. I’ll then explain
    its individual functionalities one by one.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'First you need to download several local module files. From the book’s resources
    page ([https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/)),
    find the following files from the */mpt/mptpkg/* directory: *mymusic.py*, *mynews.py*,
    *myradio.py*, *myttt.py*, *myconn.py*, *mystock.py*, and *mytranslate.py*. Put
    them in the same directory as your self-made local package files (refer to Chapter
    5 for instructions). Make sure to place them in the package folder */mpt/mptpkg/*
    instead of the chapter folder */mpt/ch17/*. Later in this chapter, I’ll explain
    the purpose of these files.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open *__init__.py* from */mpt/mptpkg/*. You began this file in Chapter
    5 and modified it in Chapters 7 and 8, so it should currently look something like
    this:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Add the seven lines of code in [Listing 17-1](#listing17-1) to the end of *__init__.py*.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Listing 17-1: Importing functions from local modules to the local package'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: This code imports the 11 functions (`music_play()`, `music_stop()`, and so on)
    from the seven modules to the local package so you can later import them at the
    package level.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Open the script *vpa.py* from Chapter 8 and add the highlighted parts in [Listing
    17-2](#listing17-2). Save the new script as *vpa_final.py*. You can also download
    the script from the book’s resources.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Listing 17-2: Your final VPA'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: We first import the functions `voice_to_text()`, `print_say()`, `wakeup()`,
    and so on from the local package *mptpkg*. We already imported these functions
    in *__init__.py* from the local modules to the local package *mptpkg*, so here
    we import the functions at the package level directly. Further, since the custom
    package *mptpkg* is installed on your computer (in editable mode), the system
    knows where to find the files, and there is no need to tell the script where to
    look.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: We then add the functionalities to the script using a series of `elif` statements.
    We start with the chatting functionality. We’ve prepared eight pairs of questions
    and answers and put them in the dictionary `chats`. If your voice input matches
    one of the eight questions, the chatting functionality is activated, and your
    VPA will speak the corresponding answer from `chats`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: The music functionality is activated by the phrase *music by*. The script will
    retrieve the artist’s name you speak after saying “Music by . . .” and will play
    a random song by that artist.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: The news functionality is activated by the phrase *NPR news*. The script will
    extract and play the audio file of the latest news brief from *NPR News Now*.
    You can say “Stop” to stop the news, and the script will go back to the main menu
    and ask, “How may I help you?”
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: The radio functionality is activated by the phrase *live radio*. The script
    will play streaming audio from an online radio station. You can say “Stop” anytime
    to return to the main menu.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: The tic-tac-toe functionality is activated by the words *tic*, *tac*, and *toe*
    together. A game board will appear on the screen, and before the game starts,
    you can choose to play first or second as well as against a person, a simple computer,
    or a smart computer.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: The Connect Four functionality is activated by the words *connect* and *four*
    together (or `4` in text). A game board will appear on the screen, and you can
    choose to play first or second as well as against a person, a simple computer,
    or a smart computer.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: The stock price functionality is activated by the phrase *stock price of*. The
    script will extract the company name you speak after “Stock price of . . .” and
    tell you the latest price.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: The stock market functionality is activated by the phrase *stock market*. The
    script will tell you the values of the major indexes of the US stock market.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: The voice translator functionality is activated by the phrase *how to say* together
    with the word *in*. The script will extract the English phrase you want to translate
    and the foreign language into which to translate it, then give you the translation
    aloud.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the individual functionalities one by one in detail.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: The Chatting Functionality
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chatting functionality is new. It will allow the VPA to provide a predefined
    answer that you specify in the code, instead of an answer from Wikipedia or WolframAlpha.
    We’re building a simple chat bot with only eight questions, but interested readers
    can use the principles here to create a more sophisticated chatting functionality
    with more questions and answers. It might also be interesting to extend this functionality
    with artificial intelligence.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create a dictionary of questions and answers. Enter the text in [Listing
    17-3](#listing17-3) and save it as the file *chats.json* in */mpt/ch17/.* These
    are our question-response pairs.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Listing 17-3: The eight pairs of questions and answers in the chatting functionality'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: The file is in JSON format, meaning it can be shared among different script
    languages.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: To make the chatting functionality more interesting, we’ve prepared multiple
    answers to some questions. Python will read the JSON file and load the data into
    a dictionary object. The values are all Python lists, and the script will randomly
    select an answer from the list. For example, if the question is `who are you`,
    the answer will be either `i am a Python script` or `i am a computer script`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s zoom in on the parts in *vpa_final.py* relevant to the chatting functionality:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We import two modules. The *random* module is used to randomly select an answer.
    The *json* module reads the JSON data. Both modules are in the Python Standard
    Library, so installation is not needed.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we open *chats.json* and read the content as a large string variable.
    We use the `load()` function in the *json* module to load it into the dictionary
    `chats`. When you run the VPA script, your voice is captured and converted to
    text and stored in the string variable `inp`. If your question matches one of
    the eight questions in `chats`, the chatting functionality is activated 1. Note
    that `list(chats.keys())` produces the list of the eight keys in `chats`, and
    if you print the list, it looks like this:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The script uses `inp` as the key to locate the corresponding value, which is
    a list with one or two answers in it. The script randomly selects an answer from
    the list and speaks it out.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one example interaction, with my voice input in bold:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: After the computer asked, “How may I help you?” I said, “Hello” to the microphone.
    Since `hello` is one of the eight questions, the chatting functionality was activated,
    and the computer selected one of the two answers (in this case, `hello`).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'I then asked three more questions: Who are you? What can you do? How old are
    you? They all activated the chatting functionality.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: The Music Functionality
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll modify the script *play_selena_gomez.py* from Chapter 5 and add music
    functionality to our final VPA. You’ll create a music module and import it to
    the main script.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Create a Music Module
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open the file *mymusic.py* you just downloaded from the book’s resources and
    saved in your local package folder */mpt/mptpkg*. The code is shown in [Listing
    17-4](#listing17-4).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Listing 17-4: The script to add music functionality'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 5, you created the subfolder */chat/* in your chapter folder */mpt/ch05/*
    and saved some MP3 files in it. Each filename should contain the artist’s name—for
    example, *SelenaGomezWolves.mp3* or *katy_perry_roar.mp3*—so that the Python script
    can locate it. A typical song is about four minutes long, which is a long time
    if you’re given a song that you don’t like, so you also learned how to stop the
    song while it’s playing. The *playsound* and *pydub* modules don’t allow the script
    to execute the next line of code while the song is playing, but with *pygame*,
    the script does move to the next line of code while the song is playing, allowing
    you to stop a song.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we import the `mixer` module from *pygame*, which can play audio files.
    At 2, we start defining the `music_play()` function, which takes a voice command
    `v_inp` as its argument. We locate the phrase *music by* in the voice command
    and use that to extract the artist name.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: We use the `split()` function to separate the first name and last name and associate
    them with the variables `firstname` and `lastname`. The script then goes into
    the appropriate folder and selects a song with the artist’s first name or last
    name to play. Note here that we use `../ch05/chat` to access the subfolder */chat*
    in the parallel folder */mpt/ch05*.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: We also define a `music_stop()` function, which will stop the music playing
    3. We use `try` and `except` here in case the script misunderstands your voice
    input and tells you that no song by the artist can be found. If that happens,
    you can still say “Stop” to go back to the main menu without crashing the script.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Activate the Music Functionality
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, you’ll add the music module to the final VPA. Here’s the part of *vpa_final.py*
    that’s relevant for the music functionality:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We import `music_play()` and `music_stop()`, which you just created, and then
    check for the activation phrase *music by* 1. Once activated, the `music_play()`
    function is called, with your voice input taken as the argument.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: While the music is playing, the script continues to execute the next line of
    code, which starts an infinite loop listening for your voice input in the background
    2. Any detected voice input is converted to the variable `background`. If the
    word *stop* is detected, the `music_stop()` function is called. If the word *stop*
    isn’t detected, the script goes to the next iteration and continues listening
    for background voice input.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example interaction with the music functionality, with my voice input
    in bold:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: After about one minute of that tune, I said, “Stop playing.” The music stopped
    playing, and the script went back to the main menu and asked, “How may I help
    you?”
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: The News Brief Module
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll modify the script *npr_news.py* from Chapter 6 and add a news functionality
    to our final VPA. You’ll create a news module and import it to the main script.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Create a News Module
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The script *mynews.py* in [Listing 17-5](#listing17-5) creates the news module.
    This file is available from the book’s resources and needs to be saved in the
    local package directory.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Listing 17-5: The script to create a news functionality'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we import `mixer` from *pygame*. We’ll use the *pygame* module so that
    we can stop the news brief anytime. At 2, we define `news_brief()`. When this
    function is called, the script goes to the NPR news website, extracts the MP3
    file associated with the latest news brief, and saves it on your computer 3. The
    script uses `music.play()` to play the audio file 4.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: We also define a `news_stop()` function that will stop playing the news file
    5.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Activate the News Functionality
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s add the functionality you just created to the final VPA. Here are the
    parts of *vpa_final.py* relevant to the news functionality:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We import `news_brief()` and `news_stop()` from *mynews*. We check for the activation
    phrase *NPR News* in your voice command. It’s a good idea to say “Play NPR News”
    or “Tell me the latest NPR news” instead of just “NPR news,” because the first
    word or two may be cut off due to timing. Putting something in front of “NPR News”
    provides a buffer.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Once activated, the `news_brief()` function is called, which extracts the news
    brief audio file from the *NRR News Now* website and plays it using *pygame*.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: While the news is broadcasting, the script starts an infinite loop to listen
    for your voice input in the background, listening for the word *stop*. If the
    word is detected, the `news_stop()` function is called. Otherwise, the script
    goes to the next iteration and continues listening for background commands.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: As with to the music-playing functionality, you need to keep your speaker volume
    low so you can stop the audio by using voice input. After the news brief is finished,
    you need to say “Stop” to go back to the main menu.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: The Live Radio Module
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll modify *play_live_radio.py* from Chapter 6 and add a radio module to our
    final VPA. As usual, you’ll create the radio module and import it to the main
    script.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: Create a Radio Module
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Frist we’ll create a radio module. The script *myradio.py* is shown in [Listing
    17-6](#listing17-6).
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Listing 17-6: The script to create livestreaming radio functionality'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to put the file *chromedrive.exe in* the same folder as the
    VPA script (that is, in */mpt/ch17*). At 1, we define the `live_radio()` function.
    We make `button` a global variable so we can use it again later in another function.
    We use the `headless` option, which provides the same functionalities as the regular
    Chrome browser but does not display the browser window on the desktop. Then we
    define `button` as the play button on the online radio station Online Radio Box.
    The button is clicked via voice control so that the radio starts streaming when
    `live_radio()` is called.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: At 2, we define a `radio_stop()` function that stops the radio playing. Note
    here that we need to make `button` a global variable as well so that it can be
    modified in `radio_stop()`.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Activate the Radio Functionality
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, add the radio functionality you just created to the final VPA. Here are
    the relevant parts of *vpa_final.py*:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We first import the `live_radio()` and `radio_stop()` functions you just created
    from the local *mptpkg* package. We listen for the activation phrase *live radio*.
    Again, it’s a good idea to include a word or two in front of “live radio” to provide
    a buffer.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Once activated, `live_radio()` is called, which goes to Online Radio Box and
    clicks the play button to stream the audio.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: While the radio is playing, the script starts an infinite loop to listen for
    background voice input, which if detected is stored in `background`. If the word
    *stop* is detected, `radio_stop()` is called to press the play button again so
    that the audio stops streaming. Otherwise, the script goes to the next iteration
    and listens for background voice commands.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: The Tic-Tac-Toe Module
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll add a tic-tac-toe module so you can voice-activate the game and play
    with the computer 100 percent hands-free. Here, we use one script to offer six
    versions of the tic-tac-toe game: you can choose to play against another person,
    a simple computer that makes random moves, or a smart computer that thinks three
    steps ahead (recall Chapter 13). You can also choose to go either first or second.'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: You’ll create a tic-tac-toe module and import it to the main script.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Create a Tic-Tac-Toe Module
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First we’ll create a local tic-tac-toe module. The script *myttt.py* is based
    on the scripts *ttt_hs.py* in Chapter 10 and *ttt_think.py*, which is the answer
    to question #5 in the end-of-chapter exercises in Chapter 13 and is available
    at the book’s resources website. I highlight the key parts of *myttt.py* in [Listing
    17-7](#listing17-7).'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Listing 17-7: The script to create the tic-tac-toe functionality'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Unlike in previous tic-tac-toe versions, here we don’t use the *messagebox*
    module to remind us about wins, ties, and invalid moves because we cannot use
    voice commands to remove the message box from the screen. You need to physically
    click the box to make it disappear. Instead we’ll just print and announce wins,
    ties, and invalid moves.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: We define the `ttt()` function, which we’ll call from the VPA script to draw
    the game board and ask whether you want to play against a person, a simple computer,
    or a smart computer. After that, the script asks whether you want to play first
    or second. Once the game is over, the board disappears from the screen, and the
    script goes back to the main menu of the VPA automatically.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: In the `ttt()` function, we use the `smart_computer()` function 1, which is
    based on the `best_move()` function in *ttt_think.py* but gives you the option
    to go first or second. We change `blue` and `white` to `turn` and `nonturn`, respectively,
    so the computer can be the white player if it plays second. We also allow the
    smart computer to occupy cell 5 if it’s empty even if it plays second because
    doing so increases its chance of winning the game.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: We then define the `person()` function 2, which allows a human player to make
    a move by using voice commands. Similarly, the `simple_computer()` function allows
    the computer to make a random move 3.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: At 4, we start an infinite loop. At each iteration, the script asks whether
    you want to choose a person, a simple computer, or a smart computer as your opponent.
    If your answer includes *person*, the variable `player` will be assigned a value
    of `person`. If your answer includes *simple* or *smart*, `player` will be assigned
    a value of `simple_computer` or `smart_computer`. Later, when we call the `player()`
    function, one of the three functions `person()`, `simple_computer()`, or `smart_computer()`
    will be called, depending on which function name is stored in `player`.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: At 5, we start an infinite loop to determine whether you want to play first
    or second. If your answer includes *first*, the variable `preference` will be
    assigned a value of `1`. If your answer includes *second*, `preference` is assigned
    a value of `2`.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: We then start the game loop. At each iteration, we first determine whether you
    or your opponent has the turn, based on the values of `preference` and `rounds`
    6. For example, if you choose to play first, the value of `preference` is `1`,
    and when the game starts, the value of `rounds` is `1`. So the condition `(preference+rounds)%2==0`
    is met, and you’ll have the first turn at the beginning of the game.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: When it’s your opponent’s turn 7, the `player()` function is called. This means
    one of the three functions, `person()`, `simple_computer()`, or `smart_computer()`,
    is called, depending on the value stored in the `player` variable. The script
    announces the move 8. If the move is not valid, the script asks you or your opponent
    to choose again 9. Otherwise, a piece is placed on the game board.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when the game ends, we do not include the `done()` function in the
    script. As you may recall from the script *guess_letter.py* in Chapter 12, without
    `done()`, the script goes to the `bye()` function after the `while` loop is finished.
    This way, the game board will disappear from the screen a, and you can go back
    to the main menu of your VPA script.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Activate Tic-Tac-Toe
  id: totrans-467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s now add the tic-tac-toe functionality to the final VPA. Here are the
    relevant parts of the script *vpa_final.py*:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We import the `ttt()` function you just created from the local *mptpkg* package.
    To activate the tic-tac-toe game, you need to include *tic*, *tac*, and *toe*
    in your voice command. Once the game is over, the game board disappears, and you’ll
    go back to the main menu.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of one interaction, with my voice input in bold:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: I activated the game by saying “Play tic-tac-toe.” I then chose to play first
    against a simple computer as my opponent. I won the game by occupying cells 5,
    7, and 3.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: The Connect Four Module
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, adding the Connect Four module should be straightforward. We
    can modify the tic-tac-toe module and change the game to Connect Four. Then you’ll
    import the local module to the main script.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: Create a Connect Four Module
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First we’ll create a Connect Four module. The script *myconn.py* is based on
    *conn_think_hs.py* in Chapter 13 and *myttt.py*, which you just created. Again,
    we won’t use *messagebox* to remind us about wins, ties, and invalid moves. We’ll
    define a `conn()` function so that when the function is called, the game appears
    onscreen and you can start playing.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: As in the tic-tac-toe module, you can choose who goes first and who your opponent
    is. We change `red` and `yellow` to `turn` and `nonturn`, respectively, so that
    the computer can be the yellow player if it plays second.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: To save space, I won’t explain *myconn.py* in detail here, but it’s available
    at the book’s resources, in the folder */mpt/mptpkg*. Open it now and take a look;
    then go back to the main script for the VPA.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Activate Connect Four
  id: totrans-480
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add the Connect Four module you just created to the final VPA, shown here in
    *vpa_final.py*:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We import the `conn()` function you just created from the local *mptpkg* package.
    We listen for the activation phrase *Connect Four* in your voice command. Note
    that the script may convert your voice as either `connect four` or `connect 4`.
    As a result, we need to use `'4' in inp or 'four' in inp` to cover both cases.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one sample output from a game:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: I chose to play second against the smart computer. By connecting four discs
    horizontally in columns 4, 5, 7, and 6, the smart computer wins the game.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: The Stock Price Module
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s add stock price functionality to our final VPA, building the module
    and then importing it.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: Create a Stock Market–Tracking Module
  id: totrans-489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First we’ll create stock-monitoring functionality. The script *mystock.py* has
    the code shown in [Listing 17-8](#listing17-8).
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Listing 17-8: The script to create stock market–tracking functionality'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we define the `stock_price()` function, saving the voice command `v_inp`
    as the argument. We then locate the company name in your voice command and use
    that to extract the ticker symbol of the firm’s stock 2. The script goes to Yahoo!
    Finance and obtains the stock price based on the ticker symbol 3. Finally, the
    script prints and announces the stock price.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: We also define `stock_market()` 4. When this function is called, it will retrieve
    the latest values of the Dow Jones Industrial Average and the S&P 500\. The script
    then prints and announces the two values.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: Activate the Stock Market–Tracking Functionalities
  id: totrans-495
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now add the stock-monitoring module you just created to the final VPA. Here
    are the relevant parts of *vpa_final.py*:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We first import the `stock_price()` and `stock_market()` functions and listen
    for the activation phrase *stock price of* in your voice command, such as, “Tell
    me the stock price of General Motors.” The `stock_price()` function uses your
    voice command as the argument and tells you the latest price for the company’s
    stock.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: We then listen for the activation phrase *stock market* for the `stock_market()`
    function. The script retrieves the latest values of the market indexes and announces
    them to you.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is one interaction with the stock module, with my voice input
    in bold:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The Voice Translator Module
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll finally add the translator functionality so that your VPA can translate
    an English phrase into a foreign language of your choice.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: Create a Translator Module
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First we’ll create a translator module. The script *mytranslate.py* is shown
    in [Listing 17-9](#listing17-9).
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Listing 17-9: The script to create a voice translator functionality'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: We start by importing the needed modules. In particular, we import *platform*
    to identify your operating system. At 1, we create a dictionary `lang_abbre`,
    which maps several world languages to their language codes in Google Translate.
    [Listing 17-9](#listing17-9) includes 10 languages, and you can add more to the
    dictionary if you prefer.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using Windows, at 2, we start the definition of the `voice_translate()`
    function, which takes your voice command as the argument. Your voice command should
    contain *how to say* and *in*. For example, you can ask, “Python, how to say *thank
    you* in Japanese?” The script locates the positions of *how to say* and *in* in
    your voice. It then extracts the English phrase you want to translate and the
    target language and stores them in variables `eng_phrase` and `tolang`, respectively.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `Translator()` class from *translate* to translate the English
    phrase to the language you want in text. Next, the script converts the translation
    into voice. It saves the voice translation into an MP3 file and uses the *pydub*
    module to play it.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using Mac or Linux, the process is similar except that you don’t need
    to create and play the audio file. Instead, we use the command line method `gtts-cli`
    to play the audio file directly without saving and retrieving the audio file,
    similar to what we did in Chapter 4 3. Since we convert a foreign language to
    speech, we need to add the `--lang` option, followed by the abbreviation for the
    language.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: Activate the Voice Translator
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, you’ll add the voice translator module you just created to the final
    VPA, shown here:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We import the `voice_translate()` function you just created and listen for the
    activation phrase. Once the translator functionality is activated, `voice_translate()`
    is called, using your voice input as the argument. The function tells you the
    translation in a human voice.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is one interaction with the functionality, with my voice input
    in bold:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Summary
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you added several projects created earlier in the book to your
    VPA. Along the way, you learned how to modify existing projects, modularize them,
    and use their functionality in your VPA. You learned how to use voice control
    to activate a functionality so that everything is 100 percent hands-free, and
    how to return to the main menu after the functionality is finished. You also efficiently
    included six versions of the tic-tac-toe or Connect Four game in a single module
    by allowing the script to ask you a couple of questions before the game starts.
    With these skills, you’ll be able to create your own functionalities and add them
    to your VPA.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
