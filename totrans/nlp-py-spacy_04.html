<html><head></head><body>
<div id="sbo-rt-content"><h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_47"/><strong><span class="big">4</span><br/>EXTRACTING AND USING LINGUISTIC FEATURES</strong></h2>&#13;
<div class="image1"><img src="../Images/comm1.jpg" alt="Image" width="191" height="191"/></div>&#13;
<p class="noindents">In the previous chapters, you learned how to access linguistic features, such as part-of-speech tags, syntactic dependencies, and named entities, as part of the text processing pipeline. This chapter will show you how to use part-of-speech tags and syntactic dependency labels to extract and generate text, allowing you to build question-asking chatbots, locate specific phrases in a text, and more.</p>&#13;
<p class="indent">Almost every NLP application needs to extract specific information from a text and generate new text that is relevant to a particular situation. For example, a chatbot must be able carry on a conversation with a user, which means it must be able to identify specific parts of a user’s text and then generate its own appropriate response. Let’s look at how to do all of that using linguistic features.</p>&#13;
<h3 class="h3" id="lev45"><span epub:type="pagebreak" id="page_48"/><strong>Extracting and Generating Text with Part-of-Speech Tags</strong></h3>&#13;
<p class="noindent">Part-of-speech tags can help you retrieve specific kinds of information from a text, and they can also help you generate entirely new sentences based on a submitted one. In this section, we’ll introduce you to some new part-of-speech tags, write a script that finds phrases describing amounts of money, and transform statements into questions. For a list of common part-of-speech tags used in spaCy for English models, refer to <a href="../Text/ch02.xhtml#ch02tab01">Table 2-1</a> on <a href="../Text/ch02.xhtml#page_22">page 22</a>.</p>&#13;
<h4 class="h4" id="lev46"><strong><em>Numeric, Symbolic, and Punctuation Tags</em></strong></h4>&#13;
<p class="noindent">In addition to part-of-speech tags for nouns, verbs, and other words in a sentence, spaCy has tags for symbols, numbers, and punctuation marks. Let’s look at these by processing the following sentence:</p>&#13;
<p class="programs">The firm earned $1.5 million in 2017.</p>&#13;
<p class="indent">To begin, let’s extract the coarse-grained part-of-speech features from the tokens in the sentence to see how spaCy distinguishes between different part-of-speech categories. We can do this with the following script:</p>&#13;
<p class="programs">&gt;&gt;&gt; import spacy<br/>&#13;
&gt;&gt;&gt; nlp = spacy.load('en')<br/>&#13;
&gt;&gt;&gt; doc = nlp(u"The firm earned $1.5 million in 2017.")<br/>&#13;
&gt;&gt;&gt; for token in doc:<br/>&#13;
...   print(token.text, <span class="ent">➊</span>token.pos_, <span class="ent">➋</span>spacy.explain(token.pos_))<br/>&#13;
...</p>&#13;
<p class="indent">We create a Doc object for the submitted sentence and then output the coarse-grained part-of-speech tags <span class="ent">➊</span>. We also use the <span class="literal">spacy.explain()</span> function, which returns a description for a given linguistic feature <span class="ent">➋</span>.</p>&#13;
<p class="indent">The output should look as follows:</p>&#13;
<p class="programs">&#13;
The     DET   determiner<br/>&#13;
firm    NOUN  noun<br/>&#13;
earned  VERB  verb<br/>&#13;
$       SYM   symbol<br/>&#13;
1.5     NUM   numeral<br/>&#13;
million NUM   numeral<br/>&#13;
in      ADP   adposition<br/>&#13;
2017    NUM   numeral<br/>&#13;
.       PUNCT punctuation</p>&#13;
<p class="indent">Notice that the coarse-grained tagger distinguishes numerals, symbols, and punctuation marks as individual categories. As you can see, it even recognizes “million” spelled out.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_49"/>Now, for the sake of comparison, let’s output both coarse-grained and fine-grained part-of-speech tags for this sample sentence along with a description column for the fine-grained tags:</p>&#13;
<p class="programs">&gt;&gt;&gt; for token in doc:<br/>&#13;
...   print(token.text, token.pos_, token.tag_, spacy.explain(token.tag_))</p>&#13;
<p class="indent">The output should look as follows:</p>&#13;
<p class="programs">&#13;
The     DET   DT  determiner<br/>&#13;
firm    NOUN  NN  noun, singular<br/>&#13;
earned  VERB  VBD verb, past tense<br/>&#13;
$       SYM   $   symbol, currency<br/>&#13;
1.5     NUM   CD  cardinal number<br/>&#13;
million NUM   CD  cardinal number<br/>&#13;
in      ADP   IN  conjunction, subordinating or preposition<br/>&#13;
2017    NUM   CD  cardinal number<br/>&#13;
.       PUNCT .   punctuation mark, sentence closer</p>&#13;
<p class="indent">The second and third columns contain the coarse-grained and fine-grained part-of-speech tags, respectively. The fourth column gives descriptions of the fine-grained tags provided in the third column.</p>&#13;
<p class="indent">The fine-grained tagging divides each category into subcategories. For example, the coarse-grained category <span class="literal">SYM</span> (symbols) has three fine-grained subcategories. These are <span class="literal">$</span> for currency symbols, <span class="literal">#</span> for the number sign, and <span class="literal">SYM</span> for all the other symbols, such as +, −, ×, ÷, =. This sub-dividing can be useful when you need to distinguish between different types of symbols. For example, you might be processing articles about math and want your script to recognize symbols commonly found in math formulas. Or you might be writing a script that needs to recognize currency symbols in financial reports.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Because spaCy’s part-of-speech tagger relies on a token’s context to generate its label, you might get different labels for tokens used in unusual contexts.</em></p>&#13;
</div>&#13;
<p class="indent">Now let’s look at how we can take advantage of these specific part-of-speech tags to extract and generate text.</p>&#13;
<h4 class="h4" id="lev47"><strong><em>Extracting Descriptions of Money</em></strong></h4>&#13;
<p class="noindent">Suppose you’re developing an application for processing financial reports that must extract necessary pieces of information from long, boring texts. In practice, financial reports can be quite large, but all you really need are the figures. In particular, you’re interested in phrases that refer to an amount of money and start with a currency symbol. For example, your script should pick out the phrase “$1.5 million” from the previous sample sentence, but not “2017”.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_50"/>The following script illustrates how you might extract this phrase from the sentence, relying on the tokens’ part-of-speech tags only. You can save this script to a file and then run it or execute the code from within a Python session:</p>&#13;
<p class="programs">   import spacy<br/>&#13;
   nlp = spacy.load('en')<br/>&#13;
   doc = nlp(u"The firm earned $1.5 million in 2017.")<br/>&#13;
   phrase = ''<br/>&#13;
<span class="ent">➊</span> for token in doc:<br/>&#13;
   <span class="ent">➋</span> if token.tag_ == '$':<br/>&#13;
         phrase = token.text<br/>&#13;
         i = token.i+1<br/>&#13;
      <span class="ent">➌</span> while doc[i].tag_ == 'CD':<br/>&#13;
             phrase += doc[i].text + ' '<br/>&#13;
             i += 1<br/>&#13;
      <span class="ent">➍</span> break<br/>&#13;
phrase = phrase[:-1]<br/>&#13;
print(phrase)</p>&#13;
<p class="indent">We iterate over the sentence’s tokens <span class="ent">➊</span>, searching for a token whose fine-grained part-of-speech tag is <span class="literal">$</span> <span class="ent">➋</span>. This tag indicates a currency symbol, and it typically starts a phrase that refers to an amount of money. Once we find a currency symbol, we start composing the phrase by checking whether the tokens that follow the currency symbol in the sentence are numbers. To do this, we implement a <span class="literal">while</span> loop in which we pick up the tokens located to the right of the currency symbol and check them for the <span class="literal">CD</span> tag, which is the cardinal number fine-grained part-of-speech-tag <span class="ent">➌</span>. When we reach a nonnumeric token, we quit the <span class="literal">while</span> loop and break the <span class="literal">for</span> loop <span class="ent">➍</span> that iterates over the sentence’s tokens.</p>&#13;
<p class="indent">When we run the script, the output should look as follows:</p>&#13;
<p class="programs">$1.5 million</p>&#13;
<p class="indent">This is exactly the kind of output we are looking for.</p>&#13;
<p class="indent">Keep in mind that a currency symbol assigned to the <span class="literal">$</span> fine-grained part-of-speech tag might not necessarily be “$”. The part-of-speech tag might label other common currency symbols, such as £ and €. For example, the preceding script would recognize the phrase “£1.500.000”.</p>&#13;
<h4 class="h4" id="lev48"><strong><em>Try This</em></strong></h4>&#13;
<p class="noindent">We wrote this script to extract a single phrase referring to an amount of money from the submitted sentence. Once the script finds the phrase, it completes its execution. But in practice, you might have a sentence that has more than one such phrase, as in the following example: “The firm earned $1.5 million in 2017, in comparison with $1.2 million in 2016.”</p>&#13;
<p class="indent">Modify the script so it extracts every phrase that refers to an amount of money within a sentence. To accomplish this, remove the <span class="literal">break</span> statement to prevent the loop from ending after it finds the first occurrence of the <span epub:type="pagebreak" id="page_51"/>phrase of interest. Then move the code that’s responsible for preparing and printing a found phrase (the last two lines of the script) into the loop, so you can invoke these two lines for every phrase of interest found in the submitted sentence.</p>&#13;
<h4 class="h4" id="lev49"><strong><em>Turning Statements into Questions</em></strong></h4>&#13;
<p class="noindent">Suppose your NLP application must be able to generate a question from a submitted statement. For example, one way chatbots maintain conversations with the user is by asking the user a confirmatory question. When a user says, “I am sure,” the chatbot might ask something like, “Are you really sure?” To do this, the chatbot must be able to generate a relevant question.</p>&#13;
<p class="indent">Let’s say the user’s submitted sentence is this:</p>&#13;
<p class="programs">I can promise it is worth your time.</p>&#13;
<p class="indent">This sentence contains several verbs and pronouns, each with different morphologies. To see this more clearly, let’s look at the part-of-speech tags spaCy assigned to the tokens in this sentence:</p>&#13;
<p class="programs">&gt;&gt;&gt; doc = nlp(u"I can promise it is worth your time.")<br/>&#13;
&gt;&gt;&gt; for token in doc:<br/>&#13;
...   print(token.text, token.pos_, token.tag_)<br/>&#13;
...</p>&#13;
<p class="indent">We print the tokens, their coarse-grained part-of-speech tags, and their fine-grained part-of-speech-tags, producing the following output:</p>&#13;
<p class="programs">&#13;
I       PRON PRP<br/>&#13;
can     VERB MD<br/>&#13;
promise VERB VB<br/>&#13;
it      PRON PRP<br/>&#13;
is      VERB VBZ<br/>&#13;
worth   ADJ  JJ<br/>&#13;
your    ADJ  PRP$<br/>&#13;
time    NOUN NN<br/>&#13;
.      PUNCT .</p>&#13;
<p class="indent">From the fine-grained part-of-speech tags, you can distinguish between the morphological categories of the verbs and pronouns present in the sentence. For example, the fine-grained part-of-speech tag <span class="literal">PRP</span> marks personal pronouns and <span class="literal">PRP$</span> marks possessive pronouns, allowing you to distinguish between these two types of pronouns programmatically. We’ll need this information when working on this example.</p>&#13;
<p class="indent">A confirmatory question to the sentence discussed here might be as follows (another statement would require another confirmatory question, of course):</p>&#13;
<p class="programs">Can you really promise it is worth my time?</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_52"/>From a human perspective, forming this question from the statement looks pretty straightforward: you change the order of some words, alter the pronouns accordingly, and add the adverbial modifier “really” to the main verb (the one that comes right after the subject). But how can you accomplish all these operations programmatically?</p>&#13;
<p class="indent">Let’s look at some part-of-speech tags. In the sample sentence, the verbs involved in forming the question are “can” and “promise”. The fine-grained part-of-speech tags mark the first one, “can”, as a modal auxiliary verb and the second one as a verb in the base form. Notice that in the preceding confirmatory question, the modal auxiliary verb has switched places with the personal pronoun, a process called <em>inversion</em>. We’ll have to implement this in the script.</p>&#13;
<p class="indent">When it comes to the pronouns, the chatbot should follow a pattern common to regular conversations. <a href="../Text/ch04.xhtml#ch04tab01">Table 4-1</a> summarizes the use of pronouns in such an application.</p>&#13;
<p class="tabcap" id="ch04tab01"><strong>Table 4-1:</strong> The Use of Pronouns in a Chatbot</p>&#13;
<table class="topbot-d">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"/>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Personal pronouns</strong></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Possessive pronouns</strong></p>&#13;
</td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-v"><p class="taba">chatbot</p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-v"><p class="taba">I, me</p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-v"><p class="taba">my, mine</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">user</p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">you</p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-ba"><p class="taba">your, yours</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">In other words, a chatbot refers to itself as “I” or “me,” and it refers to a user as “you.”</p>&#13;
<p class="indent">The following steps outline what we need to do to generate a question from the original statement:</p>&#13;
<ol>&#13;
<li class="noindent">Change the order of words in the original sentence from “subject + modal auxiliary verb + infinitive verb” to “modal auxiliary verb + subject + infinitive verb.”</li>&#13;
<li class="noindent">Replace the personal pronoun “I” (the sentence’s subject) with “you.”</li>&#13;
<li class="noindent">Replace the possessive pronoun “your” with “my.”</li>&#13;
<li class="noindent">Place the adverbial modifier “really” before the verb “promise” to emphasize the latter.</li>&#13;
<li class="noindent">Replace the punctuation mark “.” with “?” at the end of the sentence.</li>&#13;
</ol>&#13;
<p class="indent">The following script implements these steps:</p>&#13;
<p class="programs">  import spacy<br/>&#13;
  nlp = spacy.load('en')<br/>&#13;
  doc = nlp(u"I can promise it is worth your time.")<br/>&#13;
  sent = ''<br/>&#13;
  for i,token in enumerate(doc):<br/>&#13;
<span class="ent">➊</span> if token.tag_ == 'PRP' and doc[i+1].tag_ == 'MD' and doc[i+2].tag_ == 'VB':<br/>&#13;
    <span class="ent">➋</span> sent = doc[i+1].text.capitalize() + ' ' + doc[i].text<br/>&#13;
       sent = sent + ' ' + <span class="ent">➌</span>doc[i+2:].text<br/>&#13;
    <span class="ent">➍</span> break<br/>&#13;
 #By now, you should have: 'Can I promise it is worth your time.'<br/>&#13;
<span epub:type="pagebreak" id="page_53"/>   #Retokenization<br/>&#13;
<span class="ent">➎</span> doc=nlp(sent)<br/>&#13;
   for i,token in enumerate(doc):<br/>&#13;
 <span class="ent">➏</span> if token.tag_ == 'PRP' and token.text == 'I':<br/>&#13;
        sent = doc[:i].text + ' you ' + doc[i+1:].text<br/>&#13;
        break<br/>&#13;
 #By now, you should have: 'Can you promise it is worth your time.'<br/>&#13;
 doc=nlp(sent)<br/>&#13;
 for i,token in enumerate(doc):<br/>&#13;
<span class="ent">➐</span> if token.tag_ == 'PRP$' and token.text == 'your':<br/>&#13;
       sent = doc[:i].text + ' my ' + doc[i+1:].text<br/>&#13;
       break<br/>&#13;
 #By now, you should have: 'Can you promise it is worth my time.' <br/>&#13;
 doc=nlp(sent)<br/>&#13;
 for i,token in enumerate(doc):<br/>&#13;
   if token.tag_ == 'VB':<br/>&#13;
    <span class="ent">➑</span> sent = doc[:i].text + ' really ' + doc[i:].text<br/>&#13;
      break<br/>&#13;
 #By now, you should have: 'Can you really promise it is worth my time.'<br/>&#13;
 doc=nlp(sent)<br/>&#13;
<span class="ent">➒</span> sent = doc[:len(doc)-1].text + '?'<br/>&#13;
 #Finally, you should have: 'Can you really promise it is worth my time?'<br/>&#13;
 print(sent)</p>&#13;
<p class="indent">We perform the first four steps in separate <span class="literal">for</span> loops. First, we iterate over the tokens in the sentence and change the order of the subject and verb to make the sentence a question. In this example, we’re looking for the modal auxiliary verb (tagged <span class="literal">MD</span>) that follows a personal pronoun and is followed by an infinitive verb <span class="ent">➊</span>. Once we find this sequence of words, we move the modal auxiliary verb immediately before the personal pronoun, placing it at the beginning of the sentence <span class="ent">➋</span>.</p>&#13;
<p class="indent">To compose a new sentence, we use a technique known in Python as <em>slicing</em> that allows us to extract a subsequence from a sequence object, such as a string or a list, by specifying the start and end indices. In this case, we can apply slicing to a Doc object to extract a given subsequence of tokens from it. For example, <span class="literal">slice doc[2:]</span> will contain the doc’s tokens starting from the token at index 2 through the end of the doc, which in this case, is “promise it is worth your time.” <span class="ent">➌</span>. Once we move the modal verb to a new position, we exit the <span class="literal">for</span> loop <span class="ent">➍</span>.</p>&#13;
<p class="indent">You might wonder why we don’t just use the personal pronoun and auxiliary modal verb’s indices to perform inversion. Because we know the personal pronoun is at index 0 and the modal verb is at index 1, why do we have to use a loop that iterates over the entire set of tokens to find the modal verb’s position? Won’t the verb always follow the subject and so be the second word in the sentence?</p>&#13;
<p class="indent">The fact is that a sentence doesn’t always start with the subject. For example, what if the sentence were “Sure enough, I can promise it is worth your time.”? In that case, the script would know to omit the first two words and start processing with the subject.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_54"/>As a result of the inversion, we get the new sentence as a string. To make this sentence available for further processing, we need to obtain a Doc object for it <span class="ent">➎</span>.</p>&#13;
<p class="indent">Next, we create a new <span class="literal">for</span> loop that will replace the personal pronoun “I” with the personal pronoun “you.” To do this, we search for personal pronouns (tagged <span class="literal">PRP</span>). If the personal pronoun is “I,” we replace it with “you” <span class="ent">➏</span>. Then we quit the <span class="literal">for</span> loop.</p>&#13;
<p class="indent">We repeat this process to replace the possessive pronoun “your” with “my” by searching for the <span class="literal">PRP$</span> tag <span class="ent">➐</span>. Then, in a new <span class="literal">for</span> loop, we find a verb in the infinitive form and insert the adverbial modifier “really” before it <span class="ent">➑</span>.</p>&#13;
<p class="indent">Finally, we replace the sentence’s period with a question mark. This is the only step where we don’t need to use a loop. The reason is that in all possible sentences, the period and the question mark go at the end of a sentence, so we can reliably find them using their indices with <span class="literal">len(doc)-1</span> <span class="ent">➒</span>.</p>&#13;
<p class="indent">When we run this code, we should get the following output:</p>&#13;
<p class="programs">Can you really promise it is worth my time?</p>&#13;
<p class="indent">This script is a good start, but it won’t work with every submitted statement. For example, the statement might contain a personal pronoun other than “I,” but our script doesn’t explicitly check for that. Also, some sentences don’t contain auxiliary verbs, like the sentence “I love eating ice cream.” In those cases, we’d have to use the word “do” to form the question instead of a word like “can” or “should,” like this: “Do you really love eating ice cream?” But if the sentence contains the verb “to be,” as in the sentence “I am sleepy,” we’d have to move that verb to the front, like this: “Are you sleepy?”</p>&#13;
<p class="indent">A real implementation of this chatbot would have to be able to choose the appropriate option for a submitted sentence. You’ll see a “do” example in “<a href="../Text/ch04.xhtml#lev53">Deciding What Question a Chatbot Should Ask</a>” on <a href="../Text/ch04.xhtml#page_56">page 56</a>.</p>&#13;
<h4 class="h4" id="lev50"><strong><em>Try This</em></strong></h4>&#13;
<p class="noindent">Examining the script from “<a href="../Text/ch04.xhtml#lev49">Turning Statements into Questions</a>”, you might notice that some blocks of code in it look very similar, containing repetitive operations. In every step, you make a replacement in the sentence and then re-tokenize it. That means you might try to generalize the code, putting repetitive operations in a single function.</p>&#13;
<p class="indent">Before writing such a function, take some time to understand what parameters it will need to take to perform the text-manipulation operations you see in the script. In particular, you’ll need to explicitly specify what token you’re searching for and what operation you want to perform on it by either replacing it with another token or adding a token before it.</p>&#13;
<p class="indent">Once you define this function, you can write the main code that invokes it, implementing the same functionality as the original script.</p>&#13;
<h3 class="h3" id="lev51"><span epub:type="pagebreak" id="page_55"/><strong>Using Syntactic Dependency Labels in Text Processing</strong></h3>&#13;
<p class="noindent">As you learned in “<a href="../Text/ch04.xhtml#lev45">Extracting and Generating Text with Part-of-Speech Tags</a>” on <a href="../Text/ch04.xhtml#page_48">page 48</a>, part-of-speech tags are a powerful tool for smart text processing. But in practice, you might need to know more about a sentence’s tokens to process it intelligently.</p>&#13;
<p class="indent">For example, you might need to know whether a personal pronoun is the subject of a sentence or a grammatical object. Sometimes, this task is easy. The personal pronouns “I,” “he,” “she,” “they,” and “we” will almost always be the subject. When used as an object, “I” turns into “me,” as in “A postman brought me a letter.”</p>&#13;
<p class="indent">But this might not be as clear when it comes to some other personal pronouns, such as “you” or “it,” which look the same whether they’re used as subjects or objects. Consider the following two sentences: “I know you. You know me.” In the first sentence, “you” is the direct object of the verb “know.” In the second sentence, “you” is the verb’s subject.</p>&#13;
<p class="indent">Let’s solve this problem using syntactic dependency labels and part-of-speech tags. Then we’ll apply syntactic dependency labels to build a better version of the question-asking chatbot.</p>&#13;
<h4 class="h4" id="lev52"><strong><em>Distinguishing Subjects from Objects</em></strong></h4>&#13;
<p class="noindent">To programmatically determine the role of a pronoun like “you” or “it” in a given sentence, you need to check the dependency label assigned to it. By using part-of-speech tags in conjunction with dependency labels, you can get much more information about the tokens of a sentence.</p>&#13;
<p class="indent">Let’s return to the sentence in the previous example and look at the results of the dependency parsing performed on it:</p>&#13;
<p class="programs">&gt;&gt;&gt; doc = nlp(u"I can promise it is worth your time.")<br/>&#13;
&gt;&gt;&gt; for token in doc:<br/>&#13;
...   print(token.text, token.pos_, token.tag_, token.dep_, spacy.explain(token.dep_))</p>&#13;
<p class="indent">We extract the part-of-speech tags, the dependency labels, and the description for the dependency labels:</p>&#13;
<p class="programs">I       PRON  PRP  nsubj     nominal subject<br/>&#13;
can     VERB  MD   aux       auxiliary<br/>&#13;
promise VERB  VB   ROOT      None<br/>&#13;
it      PRON  PRP  nsubj     nominal subject<br/>&#13;
is      VERB  VBZ  ccomp     clausal complement<br/>&#13;
worth   ADJ   JJ   acomp     adjectival complement<br/>&#13;
your    ADJ   PRP$ poss      possession modifier<br/>&#13;
time    NOUN  NN   npadvmod  noun phrase as adverbial modifier<br/>&#13;
.       PUNCT .    punct     punctuation</p>&#13;
<p class="indent">The second and third columns contain the coarse-grained and fine-grained part-of-speech tags, respectively. The fourth column contains the dependency labels, and the fifth column contains descriptions for those dependency labels.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_56"/>Combining part-of-speech tags and dependency labels can give you a better picture of the grammatical role of each token in a sentence—more so than just part-of-speech tags or dependency labels alone. For instance, in this example, the part-of-speech tag <span class="literal">VBZ</span> assigned to the token “is” indicates a verb in the third person singular present, whereas the dependency label <span class="literal">ccomp</span>, assigned to the same token, indicates that “is” is a <em>clausal complement</em> (a dependent clause with an internal subject). In this example, “is” is a clausal complement of the verb “promise” with the internal subject “it.”</p>&#13;
<p class="indent">To figure out the role of “you” in “I know you. You know me.”, we’d check the following list of part-of-speech tags and dependency labels assigned to the tokens:</p>&#13;
<p class="programs">I     PRON  PRP  nsubj  nominal subject<br/>&#13;
know  VERB  VBP  ROOT   None<br/>&#13;
you   PRON  PRP  dobj   direct object<br/>&#13;
.     PUNCT .    punct  punctuation<br/>&#13;
You   PRON  PRP  nsubj  nominal subject<br/>&#13;
know  VERB  VBP  ROOT   None<br/>&#13;
me    PRON  PRP  dobj   direct object<br/>&#13;
.     PUNCT .    Punct  punctuation</p>&#13;
<p class="indent">In both cases, “you” is assigned the same part-of-speech tags: <span class="literal">PRON</span> and <span class="literal">PRP</span> (coarse-grained and fine-grained, respectively). But the two cases have different dependency labels: <span class="literal">dobj</span> in the first sentence and <span class="literal">nsubj</span> in the second.</p>&#13;
<h4 class="h4" id="lev53"><strong><em>Deciding What Question a Chatbot Should Ask</em></strong></h4>&#13;
<p class="noindent">Sometimes, you might need to navigate a sentence’s dependency tree to extract necessary information. For example, consider the following conversation between a chatbot and its user:</p>&#13;
<p class="programs">User: I want an apple.<br/>&#13;
Bot: Do you want a red apple?<br/>&#13;
User: I want a green apple.<br/>&#13;
Bot: Why do you want a green one?</p>&#13;
<p class="indent">The chatbot is able to continue the conversation by asking questions. But notice that the presence or absence of an adjectival modifier for the noun “apple” plays a key role in deciding what type of question it should ask.</p>&#13;
<p class="indent">There are two basic types of questions in English: yes/no questions and information questions. Yes/no questions, like the one we generated in the example discussed in “<a href="../Text/ch04.xhtml#lev49">Turning Statements into Questions</a>” on <a href="../Text/ch04.xhtml#page_51">page 51</a>, can have only two possible answers: yes or no. To form a question of this type, you place a modal auxiliary verb before the subject and the main verb after the subject. For example: “Could you modify it?”</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_57"/>Information questions are supposed to be answered with more information than just yes or no. They begin with a question word, such as “what,” “where,” “when,” “why,” or “how.” After the question word, the process of forming an information question is the same as for yes/no questions. For example: “What do you think about it?”</p>&#13;
<p class="indent">In the first case in the preceding apple example, the chatbot asks a yes/no question. In the second case, when the user modifies the noun “apple” with the adjective “green,” the chatbot asks an information question.</p>&#13;
<p class="indent">The flowchart in <a href="../Text/ch04.xhtml#ch04fig01">Figure 4-1</a> summarizes this approach.</p>&#13;
<div class="image"><a id="ch04fig01"/><img src="../Images/fig4-1.jpg" alt="image" width="599" height="189"/></div>&#13;
<p class="figcap"><em>Figure 4-1: The presence of a modifier in the input sentence determines what question the chatbot asks.</em></p>&#13;
<p class="indent">The following script simply analyzes a submitted sentence to decide what kind of question to ask and then forms the proper question. We’ll walk through the code in separate sections, but you should save the entire program in a single file called <em>question.py</em>.</p>&#13;
<p class="indent">Begin by importing the <span class="literal">sys</span> module, which provides functionality for accepting a sentence for processing as an argument:</p>&#13;
<p class="programs">import spacy<br/>&#13;
import sys</p>&#13;
<p class="indent">This is an improvement from the previous scripts where we hardcoded the sentence to analyze. Now users can submit their own sentences as input.</p>&#13;
<p class="indent">Next, we define a function that recognizes and extracts any noun chunk that is a direct object from a submitted doc. For example, if you submit a doc that contains the sentence “I want a green apple.”, it will return the chunk “a green apple”:</p>&#13;
<p class="programs"> def find_chunk(doc):<br/>&#13;
   chunk = ''<br/>&#13;
<span class="ent">➊</span> for i,token in enumerate(doc):<br/>&#13;
  <span class="ent">➋</span> if token.dep_ == 'dobj':<br/>&#13;
     <span class="ent">➌</span> shift = len([w for w in token.children])<br/>&#13;
     <span class="ent">➍</span> #print([w for w in token.children])<br/>&#13;
     <span class="ent">➎</span> chunk = doc[i-shift:i+1]<br/>&#13;
        break<br/>&#13;
 return chunk</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_58"/>We iterate over the tokens in the submitted sentence <span class="ent">➊</span> and look for the one that acts as a direct object by checking whether its dependency tag is <span class="literal">dobj</span> <span class="ent">➋</span>. In the sentence “I want a green apple.”, The direct object is the noun “apple.” Once we’ve found the direct object, we need to determine its syntactic children <span class="ent">➌</span>, because they form the chunk that we’ll use to decide what kind of question to ask. For debugging purposes, we might also want to look at the children of the direct object <span class="ent">➍</span>.</p>&#13;
<p class="indent">To extract the chunk, we slice the Doc object, calculating the start and the end indices of the slice as follows: the start index is the index of the direct object minus the number of its syntactic children. As you might guess, this is the index of the leftmost child. The end index is the index of the direct object plus one, so the last token included in the chunk is the direct object <span class="ent">➎</span>.</p>&#13;
<p class="indent">For simplicity, the algorithm implemented in this script assumes that a direct object has only leftward children. In fact, this isn’t always the case. For example, in the following sentence, “I want to touch a wall painted green.”, we’ll need to check the left and right children of the direct object “wall.” Also, because “green” is not a direct child of “wall,” we’ll need to walk the dependency tree to determine that “green” is a modifier of “wall.” We’ll discuss premodifiers and postmodifiers in more depth in <a href="../Text/ch06.xhtml#ch06">Chapter 6</a>.</p>&#13;
<p class="indent">The following function examines the chunk and decides what kind of question the chatbot should ask:</p>&#13;
<p class="programs"> def determine_question_type(chunk):<br/>&#13;
<span class="ent">➊</span> question_type = 'yesno'<br/>&#13;
   for token in chunk:<br/>&#13;
  <span class="ent">➋</span> if token.dep_ == 'amod':<br/>&#13;
    <span class="ent">➌</span> question_type = 'info'<br/>&#13;
   return question_type</p>&#13;
<p class="indent">We initialize the <span class="literal">question_type</span> variable to a value of <span class="literal">yesno</span>, which represents the yes/no question type <span class="ent">➊</span>. Then, in the submitted chunk, we search for a token tagged <span class="literal">amod</span>, which stands for adjectival modifier <span class="ent">➋</span>. If we find it, we set the <span class="literal">question_type</span> variable to <span class="literal">'info'</span>, which represents the information question type <span class="ent">➌</span>.</p>&#13;
<p class="indent">Once we’ve determined what question type to use, the following function generates a question from the submitted sentence:</p>&#13;
<p class="programs">&#13;
def generate_question(doc, question_type):<br/>&#13;
  sent = ''<br/>&#13;
  for i,token in enumerate(doc):<br/>&#13;
    if token.tag_ == 'PRP' and doc[i+1].tag_ == 'VBP':<br/>&#13;
     sent = 'do ' + doc[i].text<br/>&#13;
     sent = sent + ' ' + doc[i+1:].text<br/>&#13;
     break<br/>&#13;
  doc=nlp(sent)<br/>&#13;
  for i,token in enumerate(doc):<br/>&#13;
    if token.tag_ == 'PRP' and token.text == 'I':<br/>&#13;
     sent = doc[:i].text + ' you ' + doc[i+1:].text<br/>&#13;
     break<br/>&#13;
   <span epub:type="pagebreak" id="page_59"/>doc=nlp(sent)<br/>&#13;
<span class="ent">➊</span> if question_type == 'info':<br/>&#13;
     for i,token in enumerate(doc):<br/>&#13;
       if token.dep_ == 'dobj':<br/>&#13;
         sent = 'why ' + doc[:i].text + ' one ' + doc[i+1:].text<br/>&#13;
         break<br/>&#13;
<span class="ent">➋</span> if question_type == 'yesno':<br/>&#13;
     for i,token in enumerate(doc):<br/>&#13;
       if token.dep_ == 'dobj':<br/>&#13;
     <span class="ent">➌</span> sent = doc[:i-1].text + ' a red ' + doc[i:].text<br/>&#13;
        break<br/>&#13;
   doc=nlp(sent)<br/>&#13;
   sent = doc[0].text.capitalize() +' ' + doc[1:len(doc)-1].text + '?'<br/>&#13;
   return sent</p>&#13;
<p class="indent">In a sequence of <span class="literal">for</span> loops, we convert the submitted statement into a question by performing inversion and changing the personal pronouns. In this example, because there is no modal auxiliary verb in the statement, we add the verb “do” before the personal pronoun to form the question. (Remember that this will only work with certain sentences; in a more complete implementation, we’d have to programmatically figure out which processing approach to take.)</p>&#13;
<p class="indent">If <span class="literal">question_type</span> is set to <span class="literal">info</span>, we add the word “why” to the beginning of the question <span class="ent">➊</span>. If the <span class="literal">question_type</span> variable is set to <span class="literal">yesno</span> <span class="ent">➋</span>, we insert an adjective to modify the direct object in the question. In this example, we’ve hardcoded the adjective for the sake of simplicity. We’ve chosen the adjective “red”, <span class="ent">➌</span> which might sound strange in certain sentences. For example, we can say, “Do you want a red orange?” but not “Do you want a red idea?” In a better implementation of this chatbot, we could find a way to programmatically determine a suitable adjective to modify the direct object. We’ll come back to that topic in <a href="../Text/ch06.xhtml#ch06">Chapter 6</a>.</p>&#13;
<p class="indent">Notice also that the algorithm used here assumes that a submitted sentence ends with a punctuation mark, such as “.” or “!”.</p>&#13;
<p class="indent">Now that we’ve defined all the functions, here is the main block of the script:</p>&#13;
<p class="programs"><span class="ent">➊</span> if len(sys.argv) &gt; 1:<br/>&#13;
     sent = sys.argv[1]<br/>&#13;
     nlp = spacy.load('en')<br/>&#13;
  <span class="ent">➋</span> doc = nlp(sent)<br/>&#13;
  <span class="ent">➌</span> chunk = find_chunk(doc)<br/>&#13;
  <span class="ent">➍</span> if str(chunk) == '':<br/>&#13;
       print('The sentence does not contain a direct object.')<br/>&#13;
       sys.exit()<br/>&#13;
  <span class="ent">➎</span> question_type = determine_question_type(chunk)<br/>&#13;
  <span class="ent">➏</span> question = generate_question(doc, question_type)<br/>&#13;
     print(question)<br/>&#13;
  else:<br/>&#13;
     print('You did not submit a sentence!')</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_60"/>First, we check whether a user has passed a sentence in as a command line argument <span class="ent">➊</span>. If a sentence has been submitted, we apply spaCy’s pipeline to it, creating a Doc object instance <span class="ent">➋</span>.</p>&#13;
<p class="indent">We then send the doc to the <span class="literal">find_chunk</span> function, which should return a noun chunk containing a direct object, such as “a green apple”, for further processing <span class="ent">➌</span>. If there is no such noun chunk in the submitted sentence <span class="ent">➍</span>, we’ll receive the message “The sentence does not contain a direct object.”</p>&#13;
<p class="indent">Next, we pass the chunk we just extracted to the <span class="literal">determine_question_type</span> function, which determines which question to ask based on the chunk’s structure <span class="ent">➎</span>.</p>&#13;
<p class="indent">Finally, we pass the submitted sentence and the type of question to the <span class="literal">generate_question</span> function, which will generate an appropriate question and return it as a string <span class="ent">➏</span>.</p>&#13;
<p class="indent">The script’s output depends on the specific sentence submitted. Here are some possible variants:</p>&#13;
<p class="programs"><span class="ent">➊</span> $ python question.py 'I want a green apple.'<br/>&#13;
   Why do you want a green one?<br/>&#13;
<span class="ent">➋</span> $ python question.py 'I want an apple.'<br/>&#13;
   Do you want a red apple?<br/>&#13;
<span class="ent">➌</span> $ python question.py 'I want...'<br/>&#13;
   The sentence does not contain a direct object.<br/>&#13;
<span class="ent">➍</span> $ python question.py<br/>&#13;
   You did not submit a sentence!</p>&#13;
<p class="indent">If we submit a sentence that contains an adjectival modifier, such as “green” for a direct object like “apple”, the script should generate an information question <span class="ent">➊</span>.</p>&#13;
<p class="indent">If the sentence contains a direct object without an adjectival modifier, the script should respond with a yes/no question <span class="ent">➋</span>.</p>&#13;
<p class="indent">If we submit a sentence with no direct object, the script should recognize this at once and ask us to resubmit <span class="ent">➌</span>.</p>&#13;
<p class="indent">Finally, if we forget to submit a sentence, the script should respond with an appropriate message <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="lev54"><strong><em>Try This</em></strong></h4>&#13;
<p class="noindent">As noted earlier, the script discussed in the preceding section won’t work with all sentences. The script adds “do” to form a question, which works only with sentences that contain no auxiliary modal verb.</p>&#13;
<p class="indent">Enhance the functionality of this script so it can also work with statements containing modal auxiliary verbs. For example, given the following statement, “I might want a green apple,” the script should generate “Why might you want a green one?” For details on how to turn a statement containing a modal auxiliary verb into a question, refer to “<a href="../Text/ch04.xhtml#lev49">Turning Statements into Questions</a>” on <a href="../Text/ch04.xhtml#page_51">page 51</a>.</p>&#13;
<h3 class="h3" id="lev55"><span epub:type="pagebreak" id="page_61"/><strong>Summary</strong></h3>&#13;
<p class="noindent">Linguistic features are at the heart of all NLP tasks. This chapter taught you some techniques for smart text processing and text generation with linguistic features. You learned how to extract phrases of a certain type (say, those that refer to an amount of money), and then wrote a script using dependency labels and part-of-speech tags that generated a meaningful response to the sentence submitted by a user.</p>&#13;
<p class="indent">We’ll return to linguistic features in <a href="../Text/ch06.xhtml#ch06">Chapter 6</a> where you’ll implement them in more complex scenarios.<span epub:type="pagebreak" id="page_62"/></p>&#13;
</div>&#13;
</body></html>