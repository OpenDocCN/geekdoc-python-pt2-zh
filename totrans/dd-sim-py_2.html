<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="part">
<span class="PartNumber"><span epub:type="pagebreak" title="93" id="Page_93"/>Part II</span><br/>
<span class="PartTitle">ESSENTIAL STRUCTURES</span></h1>
</header>
</section>
</div>
<div id="sbo-rt-content"><section>

<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="95" id="Page_95"/>5</span><br/>
<span class="ChapterTitle">Variables and Types</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="406" height="406"/>
</figure>
<p class="ChapterIntro">Some of the most pernicious misconceptions about Python revolve around its nuances regarding variables and data types. Misunderstandings related to this <em>one</em> topic cause countless frustrating bugs, and this is unfortunate. Python’s way of handling variables is at the core of its power and versatility. If you understand this, everything else falls into place.</p>
<p>My own understanding of this topic was cemented by “Facts and Myths About Python Names and Values,” Ned Batchelder’s now-legendary talk at PyCon 2015. I recommend you watch the video of the presentation at <a href="https://youtu.be/_AEJHKGk9ns" class="LinkURL">https://youtu.be/_AEJHKGk9ns</a>, either now or after reading this chapter.</p>
<h2 id="h1-500920c05-0001"><span epub:type="pagebreak" title="96" id="Page_96"/>Variables According to Python: Names and Values</h2>
<p class="BodyFirst">Many myths about Python variables stem from people’s attempts to describe the language in terms of <em>other languages</em>. Perhaps most annoying to Python experts is the misleading aphorism, “Python has no variables,” which is really just the product of someone being overly clever about the fact that the Python language uses the terms <em>name</em> and <em>value</em>, instead of<em> variable</em>.</p>
<p>Python developers still use the term <em>variable</em> on a regular basis, and it even appears in the documentation, as it is part of understanding the overall system. However, for the sake of clarity, I’ll use the official Python terms exclusively throughout the rest of the book.</p>
<p>Python uses the term <em>name</em> to refer to what would conventionally be called a variable. A name refers to a value or an object, in the same way that your name refers to you but does not contain you. There may even be multiple names for the same thing, just as you may have a given name and a nickname. A <em>value</em> is a particular instance of data in memory. The term <em>variable</em> refers to the combination of the two: a name that refers to a value. From now on, I’ll only use the term <em>variable</em> in relation to this precise definition.</p>
<h2 id="h1-500920c05-0002">Assignment</h2>
<p class="BodyFirst">Let’s look at what happens under the hood when I define a variable per the above definitions like this:</p>
<pre><code>answer = 42</code></pre>
<p class="CodeListingCaption"><a id="listing5-1">Listing 5-1</a>: <em>simple_assignment.py:1</em></p>
<p>The name <code>answer</code> is <em>bound</em> to the value <code>42</code>, meaning the name can now be used to refer to the value in memory. This operation of binding is referred to as an <em>assignment</em>.</p>
<p>Look at what happens behind the scenes when I assign the variable <code>answer</code> to a new variable, <code>insight</code>:</p>
<pre><code>insight = answer</code></pre>
<p class="CodeListingCaption"><a id="listing5-2">Listing 5-2</a>: <em>simple_assignment.py:2</em></p>
<p>The name <code>insight</code> doesn’t refer to a copy of the value <code>42</code>, but rather to the same, original value. This is illustrated in <a href="#figure5-1" id="figureanchor5-1">Figure 5-1</a>.</p>
<figure>
<img src="Images/f05001.png" class="" alt="" width="295" height="106"/>
<figcaption><p><a id="figure5-1">Figure 5-1</a>: Multiple names can be bound to the same value in memory.</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="97" id="Page_97"/>In memory, the name <code>insight</code> is bound to the value <code>42</code>, which was already bound to another name: <code>answer</code>. Both names are still usable as variables. More importantly, <code>insight</code> is not bound to <code>answer</code>, but rather to the same value that <code>answer</code> was already bound to when I assigned <code>insight</code>. A name always points to a value.</p>
<p>Back in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>, I introduced the <code>is</code> operator, which compares <em>identity</em>—the specific location in memory that a name is bound to. This means <code>is</code> doesn’t check whether a name points to equivalent values, but rather whether it points to the <em>same</em> value in memory.</p>
<p>When you make an assignment, Python makes its own decisions behind the scenes about whether to create a new value in memory or bind to an existing value. The programmer often has very little control over this decision.</p>
<p>To see this, run this example in an interactive session instead of a file:</p>
<pre><code>spam = 123456789
maps = spam
eggs = 123456789</code></pre>
<p class="CodeListingCaption"><a id="listing5-3">Listing 5-3</a>: (Interactive session):1</p>
<p>I assign identical values to <code>spam</code> and <code>eggs</code>. I also bind <code>maps</code> to the same value as <code>spam</code>. (In case you didn’t catch it, “maps” is “spam” backward. No wonder GPS gets annoying.)</p>
<p>When I compare the names with the comparison operator (<code>==</code>) to check whether the values are equivalent, both expressions return <code>True</code>, as one would expect:</p>
<pre><code>print(spam == maps)  # prints True
print(spam == eggs)  # prints True</code></pre>
<p class="CodeListingCaption"><a id="listing5-4">Listing 5-4</a>: (Interactive session):2</p>
<p>However, when I compare the identities of the names with <code>is</code>, something surprising happens:</p>
<pre><code>print(spam is maps)  # prints True
print(spam is eggs)  # prints False (probably)</code></pre>
<p class="CodeListingCaption"><a id="listing5-5">Listing 5-5</a>: (Interactive session):3</p>
<p>The names <code>spam</code> and <code>maps</code> are both bound to the same value in memory, but <code>eggs</code> is probably bound to a different but equivalent value. Thus, <code>spam</code> and <code>eggs</code> don’t share an identity. This is illustrated in <a href="#figure5-2" id="figureanchor5-2">Figure 5-2</a>.</p>
<span epub:type="pagebreak" title="98" id="Page_98"/><figure>
<img src="Images/f05002.png" class="" alt="" width="345" height="166"/>
<figcaption><p><a id="figure5-2">Figure 5-2</a>: <span class="LiteralInCaption"><code>spam</code></span> and <span class="LiteralInCaption"><code>maps</code></span> share an identity; <span class="LiteralInCaption"><code>eggs</code></span> is bound to an equivalent value, but it does not share identity.</p></figcaption>
</figure>
<p>It just goes to show, spam by any other name is still spam.</p>
<p>Python isn’t guaranteed to behave exactly like this, and it may well decide to reuse an existing value. For example:</p>
<pre><code>answer = 42
insight = 42
print(answer is insight)  # prints True</code></pre>
<p class="CodeListingCaption"><a id="listing5-6">Listing 5-6</a>: (Interactive session)</p>
<p>When I assign the value <code>42</code> to <code>insight</code>, Python decides to bind that name to the existing value. Now, <code>answer</code> and <code>insight</code> happen to be bound to the same value in memory, and thus, they share an identity.</p>
<p>This is why the identity operator (<code>is</code>) can be sneaky. There are many situations in which <code>is</code> appears to work like the comparison operator (<code>==</code>).</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA ALERT</h2><p class="BoxBodyFirst">The <code>is</code> operator checks identity. Unless you <em>really</em> know what you’re doing, only use this to check if something <code>is None</code>.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<p>As a final note, the built-in function <code>id()</code> returns an integer representing the identity of whatever is passed to it. These integers are the values that the <code>is</code> operator compares. If you’re curious about how Python handles names and values, try playing with <code>id()</code>.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic Note</h2><p class="BoxBodyFirst">In CPython, the value returned from the <code>id()</code> function is derived from the memory address for the value.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500920c05-0003">Data Types</h2>
<p class="BodyFirst">As you’ve likely noticed, Python does not require you, the programmer, to declare a type for your variables. Back when I first picked up Python, I joined the <code>#python</code> channel on IRC and jumped right in.</p>
<p>“How do you declare the data type of a variable in Python?” I asked, in all the naivete of a first-year coder.</p>
<p>Within moments, I received a response that I consider to be my first true induction into the bizarre world of programming: “You’re a data type.”</p>
<p><span epub:type="pagebreak" title="99" id="Page_99"/>The room regulars went on to explain that Python is a dynamically typed language, meaning I didn’t have to tell the language what sort of information to put in a variable. Instead, Python would decide the type for me. I didn’t even have to use a special “variable declaration” keyword. I just had to assign like this:</p>
<pre><code>answer = 42</code></pre>
<p class="CodeListingCaption"><a id="listing5-7">Listing 5-7</a>: <em>types.py:1</em></p>
<p>At that precise moment, Python became my all-time favorite language.</p>
<p>It’s important to remember that Python is still a strongly typed language. I touched on this concept, along with dynamic typing, in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>. Ned Batchelder sums up Python’s type system quite brilliantly in his aforementioned PyCon 2015 talk about names and values:</p>
<blockquote class="blockquote">
<p class="Blockquote">Names have a scope—they come and go with functions—but they have no type. Values have a type . . . but they have no scope.</p>
</blockquote>
<p>Although I haven’t touched on scope yet, this should already make sense. Names are bound to values, and those values exist in memory, as long as there is some <em>reference</em> to them. You can bind a name to literally any value you want, but you are limited as to what you can do with any particular value.</p>
<h3 id="h2-500920c05-0001">The type() Function</h3>
<p class="BodyFirst">If you ever need to know a value’s data type, you can use the built-in <code>type()</code> function. Recall that everything in Python is an object, so this function will really just return what class the value is an instance of:</p>
<pre><code>print(type(answer))  # prints &lt;class 'int'&gt;</code></pre>
<p class="CodeListingCaption"><a id="listing5-8">Listing 5-8</a>: <em>types.py:2</em></p>
<p>Here, you can see that the value assigned to <code>answer</code> is an integer (<code>int</code>). On rare occasions, you may want to check the data type before you do something with a value. For that, you can pair the <code>type()</code> function with the <code>is</code> operator, like this:</p>
<pre><code>if type(answer) is int:
    print("What's the question?")</code></pre>
<p class="CodeListingCaption"><a id="listing5-9">Listing 5-9</a>: <em>types.py:3a</em></p>
<p>In many cases where this sort of introspection is necessary, it may be better to use <code>isinstance()</code> instead of <code>type()</code>, as it accounts for subclasses and inheritance (see <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span>). The function itself returns <code>True</code> or <code>False</code>, so I can use it as the condition in an <code>if</code> statement:</p>
<pre><code>if <b>isinstance(answer, int):</b>
    print("What's the question?")</code></pre>
<p class="CodeListingCaption"><a id="listing5-10">Listing 5-10</a>: <em>types.py:3b</em></p>
<p><span epub:type="pagebreak" title="100" id="Page_100"/>Truth be told, there is rarely a need for either. Instead, Python developers prefer a more dynamic approach.</p>
<h3 id="h2-500920c05-0002">Duck Typing</h3>
<p class="BodyFirst">Python uses what is known (unofficially) as <em>duck typing</em>. This isn’t a technical term at all; it comes from the old saying:</p>
<blockquote class="blockquote">
<p class="Blockquote">If it looks like a duck, walks like a duck, and quacks like a duck, then it probably <em>is</em> a duck.</p>
</blockquote>
<p>Python doesn’t care much about what a value’s data type is, but rather it cares about the <em>functionality</em> of the value’s data type. For example, if an object supports all the math operators and functions, and if it accepts floats and integers as operands on the binary operators, then Python considers the object to be a numeric type.</p>
<p>In other words, Python doesn’t care if it’s actually a robotic duck or a moose in a duck costume. If it has the traits needed, the rest of the details are usually moot.</p>
<p>If you’re familiar with object-oriented programming, particularly how quickly inheritance can get out of hand, then this whole concept of duck typing will probably be a breath of fresh air. If your class behaves as it should, it usually won’t matter what it inherits from.</p>
<h2 id="h1-500920c05-0004">Scope and Garbage Collection</h2>
<p class="BodyFirst"><em>Scope</em> is what defines where a variable can be accessed from. It might be available to an entire module or limited to the suite (body) of a function.</p>
<p>As I mentioned already, names have <em>scope</em>, whereas values do not. A name can be <em>global</em>, meaning it is defined by itself in a module, or it can be <em>local</em>, meaning it only exists within a particular function or comprehension.</p>
<h3 id="h2-500920c05-0003">Local Scope and the Reference-Counting Garbage Collector</h3>
<p class="BodyFirst">Functions (including lambdas) and comprehensions define their own scope; they are the only structures in the language to do so. Modules and classes don’t have their own scope in the strictest sense; they only have their own namespace. When a scope reaches its end, all the names defined within it are automatically deleted.</p>
<p>For any particular value, Python keeps a <em>reference count</em>, which is simply a count of how many references exist for that value. Every time a value is bound to a name, a reference is created (although there are other ways the language may create references). When there are no more references, the value is deleted. This is the <em>reference-counting garbage collector</em>, and it efficiently handles most garbage collection scenarios.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2><span epub:type="pagebreak" title="101" id="Page_101"/>Pedantic note</h2><p class="BoxBodyFirst">Technically, Python’s garbage collection behaviors are an implementation detail specific to CPython, the main “flavor” of Python. Other flavors of the language may (or may not) handle this differently, but it probably won’t ever matter to you, unless you’re doing something insanely advanced and weird.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p>You can see how this works with a typical function, like this:</p>
<pre><code>def spam():
    message = "Spam"
    word = "spam"
    for _ in range(100):
        separator = ", "
        message += separator + word
    message += separator
    message += "spam!"

    return message</code></pre>
<p class="CodeListingCaption"><a id="listing5-11">Listing 5-11</a>: <em>local_scope.py:1</em></p>
<p>I create a <code>spam()</code> function, inside of which I define the names <code>message</code>, <code>word</code>, and <code>separator</code>. I can access any of these names inside the function; that is their local scope. It doesn’t matter that <code>separator</code> is defined within a <code>for</code> loop, as loops don’t have their own scope. I can still access it outside of the loop.</p>
<p>However, I cannot access any of these names outside of the function:</p>
<pre><code>print(message)  # NameError: name 'message' is not defined</code></pre>
<p class="CodeListingCaption"><a id="listing5-12">Listing 5-12</a>: <em>local_scope.py:2</em></p>
<p class="BodyFirst">Trying to access <code>message</code> outside the context of the <code>spam()</code> function where it was defined will raise a <code>NameError</code>. In this example, <code>message</code> doesn’t exist in the outer scope. What’s more, as soon as the function <code>spam()</code> exits, the names <code>message</code>, <code>word</code>, and <code>separator</code> are deleted. Because <code>word</code> and <code>separator</code> each referred to values with a reference count of one (meaning only one name was bound to each), the values are also deleted.</p>
<p>The value of <code>message</code> is not deleted when the function exits, however, because of the return statement at the end of the function (see <a href="#listing5-11" id="listinganchor5-11">Listing 5-11</a>) and what I do with that value here:</p>
<pre><code>output = spam()
print(output)</code></pre>
<p class="CodeListingCaption"><a id="listing5-13">Listing 5-13</a>: <em>local_scope.py:3</em></p>
<p>I bind the value returned by <code>spam()</code> to <code>output</code> in the outer scope, meaning that value still exists in memory and can be accessed outside of the function. Assigning the value to <code>output</code> increases the reference count for that value, so even though the name <code>message</code> is deleted when <code>spam()</code> exits, the value is not.</p>
<h3 id="h2-500920c05-0004"><span epub:type="pagebreak" title="102" id="Page_102"/>Interpreter Shutdown</h3>
<p class="BodyFirst">When the Python interpreter is asked to shut down, such as when a Python program terminates, it enters <em>interpreter shutdown</em>. During this phase, the interpreter goes through the process of releasing all allocated resources, calling the garbage collector multiple times, and triggering destructors in objects.</p>
<p>You can use the <code>atexit</code> module from the standard library to add functions to this interpreter shutdown process. This may be necessary in some highly technical projects, although in general, you shouldn’t need to do this. Functions added via <code>atexit.register()</code> will be called in a last-in, first-out manner. However, be aware that it becomes difficult to work with modules, including the standard library, during interpreter shutdown. It’s like trying to work in a building as it’s being demolished: the janitor’s closet may disappear at any time, without warning.</p>
<h3 id="h2-500920c05-0005">Global Scope</h3>
<p class="BodyFirst">When a name is defined within a module but outside of any function, class, or comprehension, it is considered to be in <em>global</em> <em>scope</em>. Although it’s okay to have some global scope names, having too many usually leads to the creation of code that is difficult to debug and maintain. Therefore, you should use global scope names sparingly for variables. There is often a cleaner solution, such as a class (see <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>).</p>
<p>Properly using global scope names in the context of a more local scope, such as a function, requires you to think ahead a little. Consider what I do if I want a function that can modify a global variable storing a high score. First, I define the global variable:</p>
<pre><code>high_score = 10</code></pre>
<p class="CodeListingCaption"><a id="listing5-14">Listing 5-14</a>: <em>global</em><em>_scope.py:1</em></p>
<p>I’ll write this function the wrong way first:</p>
<pre><code>def score():
    new_score = 465               # SCORING LOGIC HERE
    if new_score &gt; <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> high_score:  # ERROR: UnboundLocalError
        print("New high score")
      <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> high_score = new_score


score()
print(high_score)</code></pre>
<p class="CodeListingCaption"><a id="listing5-15">Listing 5-15</a>: <em>global</em><em>_scope.py:2</em></p>
<p>When I run this code, Python complains that I’m using a local variable before I’ve assigned a value to it <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The problem is, I’m assigning to the name <code>high_score</code> within the scope of the function <code>score()</code> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, and that <em>shadows</em>, or hides, the global <code>high_score</code> name behind the new, local <code>high_score</code> name. The fact that I’ve created a local <code>high_score</code> name <em>anywhere in the function</em> makes it impossible for the function to ever “see” the global <code>high_score</code> name.</p>
<p><span epub:type="pagebreak" title="103" id="Page_103"/>To make this work, I need to declare that I’m going to use the global name in the local scope, instead of defining a new local name. I can do this with the <code>global</code> keyword:</p>
<pre><code>def score():
    <b>global high_score</b>
    new_score = 465  # SCORING LOGIC HERE
    if new_score &gt; high_score:
        print("New high score")
        high_score = new_score


score()
print(high_score)   # prints 465</code></pre>
<p class="CodeListingCaption"><a id="listing5-16">Listing 5-16</a>: <em>global</em><em>_scope.py:3</em></p>
<p>Before I do anything else in my function, I must specify that I’m using the global <code>high_score</code> name. This means that anywhere I assign a value to the name <code>high_score</code> in <code>score()</code>, the function will use the global name, instead of trying to create a new local name. The code now works as expected.</p>
<p>Every time you wish to rebind a global name from within a local scope, you must use the <code>global</code> keyword first. If you’re only accessing the current value bound to a global name, you don’t need to use the <code>global</code> keyword. It is vital for you to cultivate this habit, because Python won’t always raise an error if you handle scope incorrectly. Consider this example:</p>
<pre><code>current_score = 0


def score():
    new_score = 465   # SCORING LOGIC HERE
    current_score = new_score


score()
print(current_score)  # prints 0</code></pre>
<p class="CodeListingCaption"><a id="listing5-17">Listing 5-17</a>: <em>global</em><em>_scope_gotcha.py:1a</em></p>
<p>This code runs without raising any errors, but the output is wrong. A new name, <code>current_score</code>, is being created in the local scope of the function <code>score()</code>, and it is bound to the value <code>465</code>. This shadows the global name <code>current_score</code>. When the function terminates, both the <code>new_score</code> and the local <code>current_score</code> are deleted. In all of this, the global <code>current_score</code> has remained untouched. It is still bound to <code>0</code>, and that is what is printed out.</p>
<p>Once again, to resolve this problem, I need only use the <code>global</code> keyword:</p>
<pre><code>current_score = 0


def score():
    <b>global current_score</b>
<span epub:type="pagebreak" title="104" id="Page_104"/>    new_score = 465  # SCORING LOGIC HERE
    current_score = new_score


score()
print(current_score)  # prints 465</code></pre>
<p class="CodeListingCaption"><a id="listing5-18">Listing 5-18</a>: <em>global</em><em>_scope_gotcha.py:1b</em></p>
<p>Because I specified that the global <code>current_name</code> is to be used in this function, the code now behaves precisely as expected, printing out the value <code>465</code>.</p>
<h3 id="h2-500920c05-0006">The Dangers of Global Scope</h3>
<p class="BodyFirst">There is one more major gotcha to account for with global scope. Modifying any variable at a global level, as in rebinding or mutating on a name outside the context of a function, can lead to confusing behavior and surprising bugs—especially once you start dealing with multiple modules. It’s acceptable for you to initially “declare” a name at a global scope, but you should do all further rebinding and mutation of that global name at the local scope level.</p>
<p>By the way, this does <em>not</em> apply to classes, which do not actually define their own scope. I’ll return to this later in this chapter.</p>
<h3 id="h2-500920c05-0007">The nonlocal Keyword</h3>
<p class="BodyFirst">Python allows you to write functions within functions. I’ll defer discussing the practicality of this until <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>. Here, I mainly want to explore this functionality’s impact on scope. Consider the following example:</p>
<pre><code>spam = True


def order():
    eggs = 12

    def cook():
      <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> nonlocal eggs

        if spam:
            print("Spam!")

        if eggs:
            eggs -= 1
            print("...and eggs.")

    cook()


order()</code></pre>
<p class="CodeListingCaption"><a id="listing5-19">Listing 5-19</a>: <em>nonlocal</em><em>.py</em></p>
<p>The function <code>order()</code> contains another function: <code>cook()</code>. Each function has its own scope.</p>
<p><span epub:type="pagebreak" title="105" id="Page_105"/>Remember, as long as a function only accesses a global name like <code>spam</code>, you don’t need to do anything special. However, trying to <em>assign</em> to a global name will actually define a new local name that shadows the global one. The same behavior is true of the inner function using names defined in the outer function, which is known as the <em>nested scope</em> or <em>enclosing scope</em>. To get around this, I specify that <code>eggs</code> is <code>nonlocal</code>, meaning it can be found in the enclosing scope, rather than in the local scope <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The inner function <code>cook()</code> has no trouble accessing the global name <code>spam</code>.</p>
<p>The <code>nonlocal</code> keyword starts looking for the indicated name in the innermost nested scope, and if it doesn’t find it, it moves to the next enclosing scope above that. It repeats this until it either finds the name or determines that the name does not exist in a nonglobal enclosing scope.</p>
<h3 id="h2-500920c05-0008">Scope Resolution</h3>
<p class="BodyFirst">Python’s rule about which scopes it searches for a name, and in what order, is called the <em>scope resolution order</em>. The easiest way to remember the scope resolution order is with the acronym <em>LEGB—</em>for which my colleague Ryan gave me the handy mnemonic “Lincoln Eats Grant’s Breakfast”:</p>
<ol class="none">
<li>Local</li>
<li>Enclosing-function locals (that is, anything found via <code>nonlocal</code>)</li>
<li>Global</li>
<li>Built-in</li>
</ol>
<p>Python will look in these scopes, in order, until it finds a match or reaches the end. The <code>nonlocal</code> and <code>global</code> keywords adjust the behavior of this scope resolution order.</p>
<h3 id="h2-500920c05-0009">The Curious Case of the Class</h3>
<p class="BodyFirst">Classes have their own way of dealing with scope. Technically speaking, classes don’t directly factor into the scope resolution order. Every name declared directly within a class is known as an <em>attribute</em>, and it is accessed through the dot (<code>.</code>) operator on the class (or object) name.</p>
<p>To demonstrate this, I’ll define a class with a single attribute:</p>
<pre><code>class Nutrimatic:
  <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> output = "Something almost, but not quite, entirely unlike tea."

    def request(self, beverage):
        return <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> self.output


machine = Nutrimatic()
mug = machine.request("Tea")
print(mug)   # prints "Something almost, but not quite, entirely unlike tea."

print( <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> machine.output)
print( <span class="CodeAnnotationCode" aria-label="annotation4">❹</span> Nutrimatic.output)</code></pre>
<p class="CodeListingCaption"><a id="listing5-20">Listing 5-20</a>: <em>class_attributes</em><em>.py</em></p>
<p><span epub:type="pagebreak" title="106" id="Page_106"/>Those three print statements all output the same thing. Running that code gives me this:</p>
<pre><code>Something almost, but not quite, entirely unlike tea.
Something almost, but not quite, entirely unlike tea.
Something almost, but not quite, entirely unlike tea.</code></pre>
<p>The name <code>output</code> is a <em>class attribute</em> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, belonging to the <code>Nutrimatic</code> class. Even within that class, I would not be able to refer to it merely as <code>output</code>. I must access it through <code>self.output</code> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, as <code>self</code> refers to the class instance the function (instance method) <code>request()</code> is being called on. I can also access it via <code>machine.output</code> <span class="CodeAnnotation" aria-label="annotation3">❸</span> or <code>Nutrimatic.output</code> <span class="CodeAnnotation" aria-label="annotation4">❹</span> anywhere the object<code> machine</code> or the class <code>Nutrimatic</code> is, respectively, in scope. All of those names point to the exact same attribute: <code>output</code>. Especially in this case, there’s no real difference between them.</p>
<h3 id="h2-500920c05-0010">Generational Garbage Collector</h3>
<p class="BodyFirst">Behind the scenes, Python also has a more robust <em>generational garbage collector</em> that handles all of the odd situations a reference-counting garbage collector cannot, such as reference cycles (when two values reference one another). All of these situations, and the ways they’re handled by the garbage collector, are far beyond the scope of this book.</p>
<p>Moving forward, the most important takeaway to remember is that the generational garbage collector incurs some performance costs. Thus, it’s sometimes worthwhile to avoid reference cycles. One way to do this is with <code>weakref</code>, which creates a reference to a value without increasing that value’s reference count. This feature was defined in PEP 205, and the documentation exists at <a href="https://docs.python.org/library/weakref.html" class="LinkURL">https://docs.python.org/library/weakref.html</a>.</p>
<h2 id="h1-500920c05-0005">The Immutable Truth</h2>
<p class="BodyFirst">Values in Python can be either <em>immutable</em> or <em>mutable</em>. The difference hinges on whether the values can be <em>modified in place</em>, meaning they can be changed right where they are in memory.</p>
<p><em>Immutable</em> types cannot be modified in place. For example, integers (<code>int</code>), floating-point numbers (<code>float</code>), strings (<code>str</code>), and tuples (<code>tuple</code>) are all immutable. If you attempt to mutate an immutable value, you’ll wind up with a completely different value being created:</p>
<pre><code>eggs = 12
carton = eggs
print(eggs is carton)  # prints True
eggs += 1
print(eggs is carton)  # prints False
print(eggs)            # prints 13
print(carton)          # prints 12</code></pre>
<p class="CodeListingCaption"><a id="listing5-21">Listing 5-21</a>: <em>immutable_types.py</em></p>
<p><span epub:type="pagebreak" title="107" id="Page_107"/>Initially, <code>eggs</code> and <code>carton</code> are both bound to the same value, and thus, they share an identity. When I modify <code>eggs</code>, it is rebound to a new value, so it no longer shares an identity with <code>carton</code>. You can see that the two names now point to different values.</p>
<p><em>Mutable</em> types, on the other hand, can be modified in place. Lists constitute one example of a mutable type:</p>
<pre><code>temps = [87, 76, 79]
highs = temps
print(temps is highs)  # prints True
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> temps += [81]
print(temps is highs)  # prints True
print(highs)           # prints [87, 76, 79, 81]
print(temps)           # prints [87, 76, 79, 81]</code></pre>
<p class="CodeListingCaption"><a id="listing5-22">Listing 5-22</a>: <em>mutable_types.py</em></p>
<p>Because the list is aliased to both <code>temps</code> and <code>highs</code>, any modifications made to the list value <span class="CodeAnnotation" aria-label="annotation1">❶</span> are visible through either name. Both names are bound to the original value, as demonstrated by the <code>is</code> comparisons. This remains the case, even after that value is mutated.</p>
<h2 id="h1-500920c05-0006">Passing by Assignment</h2>
<p class="BodyFirst">Another frequent question from programmers new to the language is, “Does Python pass by value or by reference?”</p>
<p>The answer is, “Effectively, neither.” More accurately, as Ned Batchelder describes it, Python <em>passes by assignment</em>. </p>
<p>Neither the values nor the names bound to them are moved. Instead, each value is bound to the parameter via assignment. Consider a simple function:</p>
<pre><code>def greet(person):
    print(f"Hello, {person}.")


my_name = "Jason"
greet(my_name)</code></pre>
<p>Here, there is one copy of the string value <code>"Jason"</code> in memory, and that is bound to the name <code>my_name</code>. When I pass <code>my_name</code> to the <code>greet()</code> function—specifically, to the <code>person</code> parameter—it’s the same as if I had said (<code>person = my_name</code>).</p>
<p>Again, assignment never makes a copy of a value. The name <code>person</code> is now bound to the value <code>"Jason"</code>.</p>
<p>This concept of passing by assignment gets tricky when you start working with mutable values, such as lists. To demonstrate this often-unexpected <span epub:type="pagebreak" title="108" id="Page_108"/>behavior, I’ve written a function that finds the lowest temperature in a list passed to it:</p>
<pre><code>def find_lowest(temperatures):
    temperatures.sort()
    print(temperatures[0])</code></pre>
<p class="CodeListingCaption"><a id="listing5-23">Listing 5-23</a>: <em>lowest_temp.py:1a</em></p>
<p>At first glance, you may assume that passing a list to the <code>temperatures</code> parameter will make a copy, so it shouldn’t matter if you modify the value bound to the parameter. However, lists are mutable, meaning <em>the value itself</em> can be modified:</p>
<pre><code>temps = [85, 76, 79, 72, 81]
find_lowest(temps)
print(temps)</code></pre>
<p class="CodeListingCaption"><a id="listing5-24">Listing 5-24</a>: <em>lowest_temp.py:2</em></p>
<p>When I passed <code>temps</code> to the function’s <code>temperatures</code> parameter, I only <em>aliased</em> the list, so any changes made on <code>temperatures</code> are visible from all the other names bound to that same list value—namely, from <code>temps</code>.</p>
<p>You can see this in action when I run this code and get the following output:</p>
<pre><code>72
[72, 76, 79, 81, 85]</code></pre>
<p>When <code>find_lowest()</code> sorted the list passed to <code>temperatures</code>, it actually sorted the one mutable list that both <code>temps</code> and <code>temperatures</code> aliased. This is a clear case of a function having <em>side effects</em>, which are changes to values that existed before the function call.</p>
<p>An awe-inspiring number of bugs originate from this one type of misunderstanding. In general, functions should not have side effects, meaning that any values passed to the function as arguments should <em>not</em> be directly mutated. To avoid mutating the original value, I have to explicitly make a copy of it. Here’s how I’d do that in the <code>find_lowest()</code> function:</p>
<pre><code>def find_lowest(temperatures):
    <b>sorted_temps = </b><span class="CodeAnnotationCode" aria-label="annotation1">❶</span><b> sorted(</b>temperatures<b>)</b>  # sorted returns a new list
    print(sorted_temps[0])</code></pre>
<p class="CodeListingCaption"><a id="listing5-25">Listing 5-25</a>: <em>lowest_temp.py:1b</em></p>
<p>The <code>sorted()</code> function has no side effects; it creates a new list using the items in the list passed to it <span class="CodeAnnotation" aria-label="annotation1">❶</span>. It then sorts this new list and returns it. I bind this new list to <code>sorted_temps</code>. Thus, the original list (bound to <code>temps</code> and <code>temperatures</code>) is untouched.</p>
<p>If you’re coming from C and C++, it may be helpful to remember the potential hang-ups related to pass-by-pointer or pass-by-reference. Although <span epub:type="pagebreak" title="109" id="Page_109"/>Python’s assignment is scarcely similar from a technical standpoint, the risks of side effects and unintended mutations are the same.</p>
<h2 id="h1-500920c05-0007">Collections and References</h2>
<p class="BodyFirst">All collections, including lists, employ a clever little semantic detail that can become a royal pain if you don’t know to expect it: <b><i>Individual items are references.</i></b> Just as a name is bound to a value, so also are items in collections bound to values, in the same manner. This binding is called a <em>reference</em>.</p>
<p>A simple example involves trying to create a tic-tac-toe board. This first version won’t work quite how you’d expect.</p>
<p>I’ll start by creating the game board:</p>
<pre><code>board = [["-"] <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> * 3] * 3  # Create a board</code></pre>
<p class="CodeListingCaption"><a id="listing5-26">Listing 5-26</a>: <em>tic_tac_toe</em><em>.py:1a</em></p>
<p>I’m trying to create a two-dimensional board. You can fill a collection, like a list, with several items, all with the same repeating value, using the multiplication operator <span class="CodeAnnotation" aria-label="annotation1">❶</span>, as I’ve done here. I enclose the repeating value in square brackets and multiply it by the number of repetitions I want. A single row of my board is defined with <code>["-"] * 3</code>, which makes a list of three <code>"-"</code> strings.</p>
<p>Unfortunately, this won’t work the way you’d expect. The problem begins when I attempt to define the second dimension of the array—three copies of the <code>[["-"] * 3]</code> list—using multiplication. You can see the problem manifest when I try to make a move:</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation2">❷</span> board[1][0] = "X"  # Make a move

# Print board to screen
for row in board:
    print(f"{row[0]} {row[1]} {row[2]}")</code></pre>
<p class="CodeListingCaption"><a id="listing5-27">Listing 5-27</a>: <em>tic_tac_toe</em><em>.py:2</em></p>
<p>When I mark a move on the board <span class="CodeAnnotation" aria-label="annotation2">❷</span>, I want to see that change in only one spot on the board, like this:</p>
<pre><code>- - -
X - -
- - -</code></pre>
<p>Instead, I get this nasty surprise:</p>
<pre><code>X - -
X - -
X - -</code></pre>
<p>Cue the weeping and gnashing of teeth. Somehow, that one change has propagated to <em>all three</em> <em>rows</em>. Why?</p>
<p><span epub:type="pagebreak" title="110" id="Page_110"/>Initially, I created a list with three <code>"-"</code> values as items <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Since strings are immutable and thus cannot be modified in place, this works as expected. Rebinding the first item in the list to <code>"X"</code> does not affect the other two items.</p>
<p>The outer dimension of the list is composed of three list items. Because I defined <em>one</em> list and used it <em>three</em> times, I now have three <em>aliases</em> for one mutable value! By changing that list through one reference (the second row), I’m mutating that one shared value <span class="CodeAnnotation" aria-label="annotation2">❷</span>, so all three references see the change.</p>
<p>There are a few ways to fix this, but all of them work by ensuring each row references a separate value, like so:</p>
<pre><code>board = <b>[["-"] * 3 for _ in range(3)]</b></code></pre>
<p class="CodeListingCaption"><a id="listing5-28">Listing 5-28</a>: <em>tic_tac_toe</em><em>.py:1b</em></p>
<p>I only needed to change how I defined the game board initially. I now use a <em>list comprehension</em> to create the rows. In short, this list comprehension will define a separate list value from <code>["-"] * 3</code> three different times. (List comprehensions get complicated; they’ll be explained in depth in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>.) Running the code now results in the expected behavior:</p>
<pre><code>- - -
X - -
- - -</code></pre>
<p>Long story short, whenever you’re working with a collection, remember that an item is no different from any other name. Here is one more example to drive this point home:</p>
<pre><code>scores_team_1 = [100, 95, 120]
scores_team_2 = [45, 30, 10]
scores_team_3 = [200, 35, 190]

scores = (scores_team_1, scores_team_2, scores_team_3)</code></pre>
<p class="CodeListingCaption"><a id="listing5-29">Listing 5-29</a>: <em>team_scores</em><em>.py:1</em></p>
<p>I create three lists, assigning each to a name. Then, I pack all three into the tuple <code>scores</code>. You may remember from earlier that tuples cannot be modified directly, because they’re immutable. That same rule does not necessarily apply to a tuple’s items. You can’t change the tuple itself, but you can (indirectly) modify the values its items refer to:</p>
<pre><code>scores_team_1[0] = 300
print(scores[0])  # prints [300, 95, 120]</code></pre>
<p class="CodeListingCaption"><a id="listing5-30">Listing 5-30</a>: <em>team_scores</em><em>.py:2</em></p>
<p>When I mutate the list <code>scores_team_1</code>, that change appears in the first item of the tuple, because that item only aliased a mutable value.</p>
<p><span epub:type="pagebreak" title="111" id="Page_111"/>I could also directly mutate a mutable list in the <code>scores</code> tuple through two-dimensional subscription, like this:</p>
<pre><code>scores[0][0] = 400
print(scores[0])  # prints [400, 95, 120]</code></pre>
<p class="CodeListingCaption"><a id="listing5-31">Listing 5-31</a>: <em>team_scores</em><em>.py:3</em></p>
<p>Tuples don’t give you any sort of security about things being modified. Immutability exists mainly for efficiency, not for protecting data. Mutable values are <em>always</em> going to be mutable, no matter where they live or how they’re referred to.</p>
<p>The problems in the two examples above may seem relatively easy to spot, but things start getting troublesome when the related code is spread out across a large file or multiple files. Mutating on a name in one module may unexpectedly modify an item of a collection in a completely different module, and you might never have expected it.</p>
<h3 id="h2-500920c05-0011">Shallow Copy</h3>
<p class="BodyFirst">There are many ways to ensure you are binding a name to a <em>copy</em> of a mutable value, instead of aliasing the original; the most explicit of these ways is with the <code>copy()</code> function. This is sometimes also known as a <em>shallow copy</em>, in contrast to the <em>deep copy</em> I’ll cover later.</p>
<p>To demonstrate this, I’ll create a <code>Taco</code> class (see <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span> for more on classes) that allows you to define the class with various toppings and then add a sauce afterward. This first version has a bug:</p>
<pre><code>class Taco:

    def __init__(self, toppings):
        self.ingredients = toppings

    def add_sauce(self, sauce):
        self.ingredients.append(sauce)</code></pre>
<p class="CodeListingCaption"><a id="listing5-32">Listing 5-32</a>: <em>mutable_</em><em>tacos.py:1a</em></p>
<p>In the <code>Taco</code> class, the initializer <code>__init__()</code> accepts a list of toppings, which it stores as the <code>ingredients</code> list. The <code>add_sauce()</code> method will add the specified <code>sauce</code> string to the <code>ingredients</code> list.</p>
<p>(Can you anticipate the problem?)</p>
<p>I use the class as follows:</p>
<pre><code>default_toppings = ["Lettuce", "Tomato", "Beef"]
mild_taco = Taco(default_toppings)
hot_taco = Taco(default_toppings)
hot_taco.add_sauce("Salsa")</code></pre>
<p class="CodeListingCaption"><a id="listing5-33">Listing 5-33</a>: <em>mutable_</em><em>tacos.py:2a</em></p>
<p><span epub:type="pagebreak" title="112" id="Page_112"/>I define a list of toppings I want on all my tacos, and then I define two tacos: <code>hot_taco</code> and <code>mild_taco</code>. I pass the <code>default_toppings</code> list to the initializer for each taco. Then I add <code>"Salsa"</code> to the list of toppings to <code>hot_taco</code>, but I don’t want any <code>"Salsa"</code> on <code>mild_taco</code>.</p>
<p>To make sure this is working, I print out the list of <code>ingredients</code> for the two tacos, as well as the <code>default_toppings</code> list I started with:</p>
<pre><code>print(f"Hot: {hot_taco.ingredients}")
print(f"Mild: {mild_taco.ingredients}")
print(f"Default: {default_toppings}")</code></pre>
<p class="CodeListingCaption"><a id="listing5-34">Listing 5-34</a>: <em>mutable_</em><em>tacos.py:3</em></p>
<p>That outputs the following:</p>
<pre><code>Hot: ['Lettuce', 'Tomato', 'Beef', 'Salsa']
Mild: ['Lettuce', 'Tomato', 'Beef', 'Salsa']
Default: ['Lettuce', 'Tomato', 'Beef', 'Salsa']</code></pre>
<p>Waiter, there’s a bug in my taco!</p>
<p>The trouble is, when I created my <code>hot_taco </code>and<code> mild_taco</code> object by passing <code>default_toppings</code> to the <code>Taco</code> initializer, I bound both <code>hot_taco.ingredients</code> and <code>mild_taco.ingredients</code> to the same list value as <code>default_toppings</code>. These are now all aliases of the same value in memory. Then, when I call the function <code>hot_taco.add_sauce()</code>, I mutate that list value. The addition of <code>"Salsa"</code> is visible not only in <code>hot_taco.ingredients</code>, but also (unexpectedly) in <code>mild_taco.ingredients</code> and in the <code>default_toppings</code> list. This is definitely not the desired behavior; adding <code>"Salsa"</code> to one taco should only affect that one taco.</p>
<p>One way to resolve this is to ensure I’m assigning a copy of the mutable value. In the case of my <code>Taco</code> class, I will rewrite the initializer so it assigns a copy of the specified list to <code>self.ingredients</code>, instead of aliasing:</p>
<pre><code><b>import copy</b>


class Taco:

    def __init__(self, toppings):
        self.ingredients = <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> <b>copy.copy(toppings)</b>

    def add_sauce(self, sauce):
        self.ingredients.append(sauce)</code></pre>
<p class="CodeListingCaption"><a id="listing5-35">Listing 5-35</a>: <em>mutable_</em><em>tacos.py:1b</em></p>
<p>I make a copy with the <code>copy.copy()</code> function <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which is imported from <code>copy</code>.</p>
<p>I make a copy of the list passed to <code>toppings</code> within <code>Taco.__init__()</code>, assigning that copy to <code>self.ingredients</code>. Any changes made to <code>self.ingredients</code> <span epub:type="pagebreak" title="113" id="Page_113"/>don’t affect the others; adding <code>"Salsa"</code> to <code>hot_taco</code> does not change <code>mild_taco.ingredients</code>, nor does it change <code>default_toppings</code>:</p>
<pre><code>Hot: ['Lettuce', 'Tomato', 'Beef', 'Salsa']
Mild: ['Lettuce', 'Tomato', 'Beef']
Default: ['Lettuce', 'Tomato', 'Beef']</code></pre>
<h3 id="h2-500920c05-0012">Deep Copy</h3>
<p class="BodyFirst">A shallow copy is all well and good for lists of immutable values, but as previously mentioned, when a mutable value contains other mutable values, changes to those values can appear to replicate in weird ways.</p>
<p>For example, consider what happens when I try to make a copy of a <code>Taco</code> object before changing one of the two tacos. My first attempt results in some undesired behavior. Building on the same <code>Taco</code> class as before (see <a href="#listing5-35" id="listinganchor5-35">Listing 5-35</a>), I’ll use the copy of one taco to define another:</p>
<pre><code>default_toppings = ["Lettuce", "Tomato", "Beef"]
mild_taco = Taco(default_toppings)
hot_taco = <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> <b>copy.copy(mild_taco)</b>
hot_taco.add_sauce("Salsa")</code></pre>
<p class="CodeListingCaption"><a id="listing5-36">Listing 5-36</a>: <em>mutable_</em><em>tacos.py:2b</em></p>
<p>I want to create a new taco (<code>hot_taco</code>) that is initially identical to <code>mild_taco</code>, but with added <code>"Salsa"</code>. I’m attempting this by binding a copy of <code>mild_taco</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span> to <code>hot_taco</code>.</p>
<p>Running the revised code (including <a href="#listing5-34" id="listinganchor5-34">Listing 5-34</a>) produces the following:</p>
<pre><code>Hot: ["Lettuce", "Tomato", "Beef", "Salsa"]
Mild: ["Lettuce", "Tomato", "Beef", "Salsa"]
Default: ["Lettuce", "Tomato", "Beef"]</code></pre>
<p>I might not expect any changes made to <code>hot_taco</code> to reflect in <code>mild_taco</code>, but unexpected changes have clearly happened.</p>
<p>The issue is that, when I make a copy of the <code>Taco</code> object value itself, I am not making a copy of the <code>self.ingredients</code> list <em>within</em> the object. Both <code>Taco</code> objects contain references to the same list value.</p>
<p>To fix this problem, I can use <em>deep copy</em> to ensure that any mutable values inside the object are copied as well. In this case, a deep copy of a <code>Taco</code> object will create a copy of the <code>Taco</code> value, as well as a copy of any mutable values that <code>Taco</code> contains references to—namely, the list <code>self.ingredients</code>. <a href="#listing5-37" id="listinganchor5-37">Listing 5-37</a> shows that same program, using deep copy:</p>
<pre><code>default_toppings = ["Lettuce", "Tomato", "Beef"]
mild_taco = Taco(default_toppings)
hot_taco = <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> copy.<b>deepcopy</b>(mild_taco)
hot_taco.add_sauce("Salsa")</code></pre>
<p class="CodeListingCaption"><a id="listing5-37">Listing 5-37</a>: <em>mutable_</em><em>tacos.py:2c</em></p>
<p><span epub:type="pagebreak" title="114" id="Page_114"/>The only change is that I’m using <code>copy.deepcopy()</code>, instead of <code>copy.copy()</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Now when I mutate the list inside <code>hot_taco</code>, it doesn’t affect <code>mild_taco</code>:</p>
<pre><code>Hot: ["Lettuce", "Tomato", "Cheese", "Beef", "Salsa"]
Mild: ["Lettuce", "Tomato", "Cheese", "Beef"]
Default: ["Lettuce", "Tomato", "Cheese", "Beef"]</code></pre>
<p>I don’t know about you, but I’m getting hungry for tacos.</p>
<p>Copying is the most generic way to solve the problem of passing around mutable objects. However, depending on what you’re doing, there may be an approach better suited to the particular collection you’re using. For example, many collections, like lists, have functions that return a copy of the collection with some specific modification. When you’re solving these sorts of issues with mutability, you can start by employing copy and deep copy. Then, you can exchange that for a more domain-specific solution later.</p>
<h2 id="h1-500920c05-0008">Coercion and Conversion</h2>
<p class="BodyFirst">Names do not have types. Therefore, Python has no need of type casting, at least in the typical sense of the term.</p>
<p>Allowing Python to figure out the conversions by itself, such as when adding together an integer (<code>int</code>) and a <code>float</code>, is called <em>coercion</em>. Here are a few examples:</p>
<pre><code>print(42.5)   # coerces to a string
x = 5 + 1.5   # coerces to a float (6.5)
y = 5 + True  # coerces to an int (6)...and is also considered a bad idea</code></pre>
<p class="CodeListingCaption"><a id="listing5-38">Listing 5-38</a>: <em>coercion.py</em></p>
<p>Even so, there are potential situations in which you may need to use one value to create a value of a different type, such as when you are creating a string from an integer. <em>Conversion</em> is the process of explicitly casting a value of one type to another type.</p>
<p>Every type in Python is an instance of a class. Therefore, the class of the type you want to create only needs to have an initializer that can handle the data type of the value you’re converting from. (This is usually done through duck typing.)</p>
<p>One of the more common scenarios is to convert a string containing a number into a numeric type, such as a <code>float</code>:</p>
<pre><code>life_universe_everything = "42"

answer = float(life_universe_everything)</code></pre>
<p class="CodeListingCaption"><a id="listing5-39">Listing 5-39</a>: <em>conversion.py:1</em></p>
<p><span epub:type="pagebreak" title="115" id="Page_115"/>Here, I start with a piece of information as a string value, which is bound to the name <code>life_universe_everything</code>. Imagine I want to do some complex mathematical analysis on this data; to do this, I must first convert the data into a floating-point number. The desired type would be an instance of the class <code>float</code>. That particular class has an initializer (<code>__init__()</code>) that accepts a string as an argument, which is something I know from the documentation.</p>
<p>I initialize a <code>float()</code> object, pass <code>life_universe_everything</code> to the initializer, and bind the resulting object to the name <code>answer</code>.</p>
<p>I’ll print out the <code>type</code> and value of <code>answer</code>:</p>
<pre><code>print(type(answer))
print(answer)</code></pre>
<p class="CodeListingCaption"><a id="listing5-40">Listing 5-40</a>: <em>conversion.py:2</em></p>
<p>That outputs the following:</p>
<pre><code>&lt;class 'float'&gt;
42.0</code></pre>
<p>Since there were no errors, you can see that the result is a <code>float</code> with value <code>42.0</code>, bound to <code>answer</code>.</p>
<p>Every class defines its own initializers. In the case of <code>float()</code>, if the string passed to it cannot be interpreted as a floating-point number, a <code>ValueError</code> will be raised. Always consult the documentation for the object you’re initializing.</p>
<h2 id="h1-500920c05-0009">A Note About Systems Hungarian Notation</h2>
<p class="BodyFirst">If you’re coming from a statically typed language like C++ or Java, you’re probably used to working with data types. Thus, when picking up a dynamically typed language such as Python, it might be tempting to employ some means of “remembering” what type of value every name is bound to. <b><i>Don’t do this!</i></b> You will find the most success using Python if you learn to take full advantage of dynamic typing, weak binding, and duck typing.</p>
<p>I will confess: the first year I used Python, I used <em>Systems Hungarian notation</em>—the convention of appending a prefix denoting data type to every variable name—to try to “defeat” the language’s dynamic typing system. My code was littered with such debris as <code>intScore</code>, <code>floatAverage</code>, and <code>boolGameOver</code>. I picked up the habit from my time using Visual Basic .NET, and I thought I was brilliant. In fact, I was depriving myself of many opportunities to refactor.</p>
<p>Systems Hungarian notation will quickly render code obtuse. For example:</p>
<pre><code>def calculate_age(intBirthYear, intCurrentYear):
    intAge = intCurrentYear - intBirthYear
    return intAge


<span epub:type="pagebreak" title="116" id="Page_116"/>def calculate_third_age_year(intCurrentAge, intCurrentYear):
    floatThirdAge = intCurrentAge / 3
    floatCurrentYear = float(intCurrentYear)
    floatThirdAgeYear = floatCurrentYear - floatThirdAge
    intThirdAgeYear = int(floatThirdAgeYear)
    return intThirdAgeYear


strBirthYear = "1985"    # get from user, assume data validation
intBirthYear = int(strBirthYear)

strCurrentYear = "2010"  # get from system
intCurrentYear = int(strCurrentYear)

intCurrentAge = calculate_age(intBirthYear, intCurrentYear)
intThirdAgeYear = calculate_third_age_year(intCurrentAge, intCurrentYear)
print(intThirdAgeYear)</code></pre>
<p class="CodeListingCaption"><a id="listing5-41">Listing 5-41</a>: <em>evils_of_systems_hungarian.py</em></p>
<p>Needless to say, this code is quite painful to read. On the other hand, if you make full use of Python’s typing system (and resist the urge to store every intermediate step), the code will be decidedly more compact:</p>
<pre><code>def calculate_age(birth_year, current_year):
    return (current_year - birth_year)


def calculate_third_age_year(current_age, current_year):
    return int(current_year - (current_age / 3))


birth_year = "1985"    # get from user, assume data validation
birth_year = int(birth_year)

current_year = "2010"  # get from system
current_year = int(current_year)

current_age = calculate_age(birth_year, current_year)
third_age_year = calculate_third_age_year(current_age, current_year)
print(third_age_year)</code></pre>
<p class="CodeListingCaption"><a id="listing5-42">Listing 5-42</a>: <em>duck_typing_feels_better.py</em></p>
<p>My code became far cleaner once I stopped treating Python like a statically typed language. Python’s typing system is a big part of what makes it such a readable and compact language.</p>
<h2 id="h1-500920c05-0010">Terminology Review</h2>
<p class="BodyFirst">I’ve introduced a lot of important new words in this section. Since I’ll be using this vocabulary frequently throughout the rest of the book, doing a quick recap here is prudent.</p>
<p class="RunInPara"><span epub:type="pagebreak" title="117" id="Page_117"/><span class="RunInHead">alias (v.)</span>  To bind a mutable value to more than one name. Mutations performed on a value bound to one name will be visible on all names bound to that mutable value.</p>
<p class="RunInPara"><span class="RunInHead">assignment (n.)</span>  The act of binding a value to a name. Assignment never copies data.</p>
<p class="RunInPara"><span class="RunInHead">bind (v.)</span>  To create a reference between a name and a value.</p>
<p class="RunInPara"><span class="RunInHead">coercion (n.)</span>  The act of implicitly casting a value from one type to another.</p>
<p class="RunInPara"><span class="RunInHead">conversion (n.)</span>  The act of explicitly casting a value from one type to another.</p>
<p class="RunInPara"><span class="RunInHead">copy (v.)</span>  To create a new value in memory from the same data as another value.</p>
<p class="RunInPara"><span class="RunInHead">data (n.) </span>  Information stored in a value. You may have copies of any given data stored in other values.</p>
<p class="RunInPara"><span class="RunInHead">deep copy (v.)</span>  To both copy an object to a new value <em>and</em> copy all the data from values referenced within that object to new values.</p>
<p class="RunInPara"><span class="RunInHead">identity (n.) </span>  The specific location in memory that a name is bound to. When two names share an identity, they are bound to the same value in memory.</p>
<p class="RunInPara"><span class="RunInHead">immutable (adj.)</span>  Of or relating to a value that <em>cannot</em> be modified in place.</p>
<p class="RunInPara"><span class="RunInHead">mutable (adj.) </span>  Of or relating to a value that <em>can</em> be modified in place.</p>
<p class="RunInPara"><span class="RunInHead">mutate (v.) </span>  To change a value in place.</p>
<p class="RunInPara"><span class="RunInHead">name (n.)</span>  A reference to a value in memory, commonly thought of as a “variable” in Python. A name must always be bound to a value. <b><i>Names have scope, but not type.</i></b></p>
<p class="RunInPara"><span class="RunInHead">rebind (v.) </span>  To bind an existing name to a different value.</p>
<p class="RunInPara"><span class="RunInHead">reference (n.)</span>  The association between a name and a value.</p>
<p class="RunInPara"><span class="RunInHead">scope (n.)</span>  A property that defines what section of the code a name is accessible from, such as from within a function or within a module.</p>
<p class="RunInPara"><span class="RunInHead">shallow copy (v.)</span>  To copy an object to a new value but <em>not</em> copy the data from values referenced within that object to new values.</p>
<p class="RunInPara"><span class="RunInHead">type (n.)</span>  A property that defines how a raw value is interpreted, for example, as an integer or a boolean.</p>
<p class="RunInPara"><span class="RunInHead">value (n.)</span>  A unique copy of data in memory. There must be a reference to a value, or else the value is deleted. <b><i>Values have type, but not scope.</i></b></p>
<p class="RunInPara"><span class="RunInHead">variable (n.) </span>  A combination of a name and the value the name refers to.</p>
<p class="RunInPara"><span class="RunInHead">weakref (n.)</span>  A reference that does not increase the reference count on the value.</p>
<p>To help keep us grounded in these concepts, we usually use the term <em>name</em> instead of <em>variable</em>. Instead of <em>changing</em> something, we <em>(re)bind a name</em> or <em><span epub:type="pagebreak" title="118" id="Page_118"/>mutate a value</em>. Assignment never copies—it literally always binds a name to a value. Passing to a function is just assignment.</p>
<p>By the way, if you ever have trouble wrapping your head around these concepts and how they play out in your code, try the visualizer at <a href="http://pythontutor.com/" class="LinkURL">http://pythontutor.com/</a>.</p>
<h2 id="h1-500920c05-0011">Wrapping Up</h2>
<p class="BodyFirst">It’s easy to take something like variables for granted, but by understanding Python’s unique approach, you can better avail yourself of the power that is available through dynamic typing. I must admit, Python has somewhat spoiled me. When I work in statically typed languages, I find myself pining for the expressiveness of duck typing.</p>
<p>Still, working with Python-style dynamic typing can take getting used to if you have a background in other languages. It’s like learning how to speak a new human language: only with time and practice will you begin to think in the new tongue.</p>
<p>If all this is making your head swim, let me reiterate the single most important principles. Names have scope, but no type. Values have type, but no scope. A name can be bound to any value, and a value can be bound to any number of names. It really is that dead simple! If you remember that much, you’ll go a long way.</p>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="119" id="Page_119"/>6</span><br/>
<span class="ChapterTitle">Functions and Lambdas</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="406" height="406"/>
</figure>
<p class="ChapterIntro">Functions are one of the most elementary concepts in programming, yet Python packs a surprising amount of versatility into them. You’ll recall from <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span> that functions are first-class objects, so they are treated no differently from any other object. This fact, combined with the power of dynamic typing, opens up so many possibilities.</p>
<p>Python has full support for <em>functional programming</em>, a distinct paradigm from which we get those “lambdas,” or anonymous functions, you keep reading about online. If you’re used to languages like Haskell or Scala, a lot of the concepts in this chapter are going to seem familiar to you. However, if you’re more used to object-oriented programming, such as in Java or C++, this may be the first time you’ve encountered many of these concepts.</p>
<p>When learning Python, it makes sense to dive into functional programming early on. It is perfectly possible to write idiomatic Python code <span epub:type="pagebreak" title="120" id="Page_120"/>without ever creating a single class (see <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>). By contrast, functions and functional programming concepts underpin much of the language’s most powerful features.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Theory Recap: Functional Programming</h2>
<p class="BoxBodyFirst">Before digging into Python functions, you need to understand the functional programming paradigm.</p>
<p>If you’re coming from a pure functional language like Haskell, Scala, Clojure, or Elm, this section won’t give you any useful new information. Skip ahead to <span class="xref" itemid="xref_target_“Python Function Essentials.”">“Python Function Essentials.”</span></p>
<p>Otherwise, even if you think you’ve used functional programming principles before, stick with me. A lot of developers don’t realize all that’s involved in this paradigm.</p>
<h3>What Do We Mean By “Functional”?</h3>
<p class="BoxBodyFirst">To understand what functional programming is, you must understand what it is not. Chances are, you’ve been using either <em>procedural programming</em> or <em>object-oriented programming</em> up to this point. Both of those paradigms are <em>imperative</em>; you describe precisely how to accomplish a goal through specific, concrete processes.</p>
<p>Procedural programming organizes around <em>control blocks</em> and focuses heavily on <em>control flow</em>. Object-oriented programming organizes around classes and objects, and it focuses on <em>state</em>—specifically, the attributes (member variables) of those objects (see <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>).</p>
<p>Functional programming is organized around <em>functions</em>. This paradigm is considered <em>declarative</em>, meaning problems are broken down into abstract steps. The programming logic is mathematically consistent and basically unchanged from one language to the next.</p>
<p>In functional programming, you write a function for each step. Each function accepts an input and produces an output, is self-contained, and does exactly one thing; it does not care about the rest of the program. Functions also lack <em>state</em>, meaning they do not store information between calls. Once a function exits, all of its local names go out of scope. Every time the function is called on the same input, it generates the same output.</p>
<p>Perhaps most importantly, functions should have no <em>side effects</em>, meaning they shouldn’t mutate anything. If you pass a list to a pure function, the function should never change that list. Instead, it should output a brand-new list (or whatever value is expected).</p>
<p>The chief beauty of functional programming is that you can change the implementation of any one function without affecting anything else. As long as the input and output are consistent, it doesn’t matter how the task is accomplished. This sort of code is much easier to debug and refactor than more <em>tightly coupled</em> code, in which each function relies on the implementation of the others.</p>
<h4><span epub:type="pagebreak" title="121" id="Page_121"/>Pure or Not?</h4>
<p class="BoxBodyFirst">It’s easy to think that one is “doing functional programming” just because functions and lambdas are involved, but again, the paradigm organizes around <em>pure functions</em>, which have no side effects or state and only perform a single task per function.</p>
<p>Python’s functional programming behavior is generally considered “impure,” largely due to the existence of mutable data types. Extra effort is necessary to ensure functions have no side effects, as you saw in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>.</p>
<p>Given proper care, you can write pure functional code in Python. However, most Pythonistas choose to borrow specific ideas and concepts from functional programming, and to combine them with other paradigms.</p>
<p>In practice, you will find the most success if you follow the rules of functional programming <em>until you have a specific, well-reasoned motive to break them</em>. Those rules, in order from strictest to least strict, are as follows:</p>
<ol>
<li value="1">Every function should do one specific thing.</li>
<li value="2">A function’s implementation should never affect the behavior of the rest of the program.</li>
<li value="3">Avoid side effects! The one exception to this should occur when a function belongs to an object. In that case, the function should only be able to mutate that object’s members (see <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>).</li>
<li value="4">In general, functions shouldn’t have (or be affected by) state. Providing the same input should always yield the same output.</li>
</ol>
<p>Rule 4 is the most likely to have exceptions, especially where objects and classes are concerned.</p>
<p>In short, you’ll often find that writing an entire, large Python project to be pure functional is a tad impractical. Instead, incorporate the principles and concepts of the paradigm into your style.</p>
<h4>Functional Programming Myths</h4>
<p class="BoxBodyFirst">One common misconception about functional programming is that it avoids loops. In fact, because iteration is fundamental to the paradigm (as you’ll see shortly), loops are essential. The idea is to avoid fussing with control flow, so <em>recursion</em> (a function calling itself) is often preferred to manual loops. However, you can’t always avoid loops. If a few show up in your code, don’t be alarmed. Your main focus should be to write pure functions.</p>
<p>Understand, functional programming is not a magic bullet. It offers many advantages and is especially well-suited to a number of situations, but it is not without its downsides. Some important algorithms and collections, such as union-find and hash tables, cannot be implemented efficiently, if at all, in pure functional programming. There are a number of situations where this paradigm has worse performance and higher memory usage than the alternatives. Concurrency is notoriously difficult to achieve in pure functional code.</p>
<p><span epub:type="pagebreak" title="122" id="Page_122"/>These topics get technical very quickly. For most developers, it’s sufficient to understand that these issues exist with pure functional programming. If you find yourself needing to know more, there are many white papers on and discussions about these problems.</p>
<p>Functional programming is an excellent addition to your arsenal of knowledge, but be prepared to use it in conjunction with other paradigms and approaches. There are no magic bullets in programming.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500920c06-0001">Python Function Essentials</h2>
<p class="BodyFirst">I briefly touched on functions in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>. Building on that knowledge, I’ll gradually construct a more complex example in this chapter.</p>
<p>I’ll start by creating a function that rolls a single die with a specified number of sides:</p>
<pre><code>import random


def roll_dice(sides):
    return random.randint(1, sides)</code></pre>
<p class="CodeListingCaption"><a id="listing6-1">Listing 6-1</a>: <em>dice_roll.py:1a</em></p>
<p>I define a function named <code>roll_dice()</code>, which accepts a single parameter, <code>sides</code>. This function is considered pure, because it has no side effects; it accepts a value as an input and returns a new value as an output. I return a value from the function using the <code>return</code> keyword.</p>
<p>The <code>random</code> module has a number of functions for producing random values. Here, I use its <code>random.randint()</code> function to generate a pseudorandom number in Python. I generate a random number between <code>1</code> and <code>20</code> (the value of <code>sides</code> in this example) inclusively, with <code>random.randint(1, 20)</code>.</p>
<p>Here’s my usage for the function:</p>
<pre><code>print("Roll for initiative...")
player1 = <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> roll_dice(20)
player2 = roll_dice(20)
if player1 &gt;= player2:
    print(f"Player 1 goes first (rolled {player1}).")
else:
    print(f"Player 2 goes first (rolled {player2}).")</code></pre>
<p class="CodeListingCaption"><a id="listing6-2">Listing 6-2</a>: <em>dice_roll.py:2a</em></p>
<p><span epub:type="pagebreak" title="123" id="Page_123"/>Later, I call the function and pass the value <code>20</code> as an argument <span class="CodeAnnotation" aria-label="annotation1">❶</span>, so the function call is effectively the same as rolling a 20-sided die. The value that the first function call returns is bound to <code>player1</code>; the second call’s return is bound to <code>player2</code>.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic NOTE</h2><p class="BoxBodyFirst">The terms <em>parameter</em> and <em>argument</em> are commonly confused. A <em>parameter</em> is a “slot” in the function definition that accepts some data, while an <em>argument</em> is the data that is passed to the parameter in the function call. The definitions of those two words come from general computer programming, not just Python.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p>Because I defined <code>roll_dice()</code> as a function, I can use it as many times as I want. If I want to change its behavior, I only need to modify the function in the one place where it is defined, and every usage of that function will be affected.</p>
<p>Say I wanted to roll multiple dice at once and return the results in a tuple. I can rewrite the <code>roll_dice()</code> function to do that:</p>
<pre><code>import random


def roll_dice(sides, dice):
    <b>return tuple(random.randint(1, sides) for </b><b/><b>_ in range(dice))</b></code></pre>
<p class="CodeListingCaption"><a id="listing6-3">Listing 6-3</a>: <em>dice_roll.py:1b</em></p>
<p>To allow rolling multiple dice, the function accepts a second parameter, <code>dice</code>, which represents the number of dice being rolled. The first parameter, <code>sides</code>, still represents the number of sides on any one of the dice.</p>
<p>The scary-looking line of code at the top of the function is a <em>generator expression</em>, which I’ll cover in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>. For now, you can take it for granted that I’m generating one random number for each die being rolled and packing the results in a tuple.</p>
<p>Since my function now has a second parameter in the function call, I pass two arguments:</p>
<pre><code>print("Roll for initiative...")
player1<b>, player2 </b>= roll_dice(20<b>, 2</b>)
if player1 &gt;= player2:
    print(f"Player 1 goes first (rolled {player1}).")
else:
    print(f"Player 2 goes first (rolled {player2}).")</code></pre>
<p class="CodeListingCaption"><a id="listing6-4">Listing 6-4</a>: <em>dice_roll.py:2b</em></p>
<p>The returned tuple can be <em>unpacked</em>, meaning each item in the tuple is bound to a name I can use to access the value. The number of names listed on the left (separated by commas) and the number of values in the tuple <em>must</em> match for this to work, or else Python will raise an error. (See <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span> for more on unpacking and tuples.)</p>
<h2 id="h1-500920c06-0002"><span epub:type="pagebreak" title="124" id="Page_124"/>Recursion</h2>
<p class="BodyFirst"><em>Recursion</em> occurs when a function calls itself. This can be helpful when you need to repeat the entire logic of a function but a loop is unsuitable or feels too cluttered, as in the upcoming example.</p>
<p>For example, returning to my dice-rolling function, I can accomplish the exact same result using recursion, instead of that generator expression I was using earlier (although in practice, the generator expression is usually considered more Pythonic).</p>
<pre><code>import random


def roll_dice(sides, dice):
    <b>if dice &lt; 1:</b>
        <b>return ()</b>
    roll = random.randint(1, sides)
    return <b>(roll, ) + roll_dice(sides, dice-1)</b></code></pre>
<p class="CodeListingCaption"><a id="listing6-5">Listing 6-5</a>: <em>dice_roll_recursive.py:1a</em></p>
<p>I store the resulting roll for this function call in <code>roll</code>. Then, in the recursive call, I pass my <code>sides</code> parameter as is, while reducing the number of <code>dice</code> to roll by one, to account for the die I just rolled. Finally, I combine the tuple that is returned from that recursive function call with the result of the roll on this function call, and I return the resulting longer tuple.</p>
<p>The usage is essentially the same as before:</p>
<pre><code>dice_cup = roll_dice(6, 5)
print(dice_cup)</code></pre>
<p class="CodeListingCaption"><a id="listing6-6">Listing 6-6</a>: <em>dice_roll_recursive.py:2a</em></p>
<p>If you were to print out each value being returned, in order from deepest recursive call to outermost, here’s what you would see:</p>
<pre><code>()
(2,)
(3, 2)
(6, 3, 2)
(4, 6, 3, 2)
(4, 4, 6, 3, 2)</code></pre>
<p class="CodeListingCaption"><a id="listing6-7">Listing 6-7</a>: Returns from recursive calls to <code>roll_dice(6, 5)</code></p>
<p>When the number of dice left is zero or negative, I return an empty tuple instead of recursively calling it again. If I don’t do that, the recursion will try to run forever. Thankfully, Python will pull the plug at some point and just crash the program, instead of letting it consume all your computer’s memory (as some other programming languages are apt to do). The <em>recursion depth</em> is how many recursive function calls have not returned yet, and Python caps it at approximately one thousand.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2><span epub:type="pagebreak" title="125" id="Page_125"/>Pedantic NOTE</h2><p class="BoxBodyFirst">Typically, the effective maximum recursion depth is 997 in CPython, even though it should be 1000 according to the source code. Go figure.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p>If the recursion depth goes any deeper than the limit, the entire program stops and raises an error:</p>
<pre><code>RecursionError: maximum recursion depth exceeded while calling a Python object</code></pre>
<p>This is why it’s so important that you build some means of stopping when you use recursion. In the <code>roll_dice</code> function, this stopping mechanism is at the very top of the function:</p>
<pre><code>    if dice &lt; 1:
        return ()</code></pre>
<p>Since <code>dice</code> is getting decremented every time the function calls itself, sooner or later, it will reach zero. When it does, it returns an empty tuple, instead of producing another recursive call. Then, the rest of the recursive calls can finish running and return.</p>
<p>There may be cases in which a recursion depth of a thousand is not enough. If you need more, you can override the maximum:</p>
<pre><code>import sys
sys.setrecursionlimit(2000)</code></pre>
<p>The <code>sys.setrecursionlimit()</code> function allows you to set a new maximum recursion depth. In this case, my new limit is <code>2000</code>. The benefit of this approach is that once you no longer need your limit, you can set it back to the default so it can keep <em>other</em> recursive calls from getting out of hand.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>Gotcha Alert</h2>	<p class="BoxBodyFirst">It is still possible to have more serious problems if you raise the recursion limit too far. These problems might include stack overflows or segmentation faults, which are particularly difficult to debug. Recursion can also affect program performance. <em>Be careful with recursion!</em> How much is “too much” depends on your system.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500920c06-0003">Default Argument Values</h2>
<p class="BodyFirst">You might imagine that I would need to roll a single die far more often than any other option. As it stands right now, I would have to manually specify that I only want to roll one 20-sided die:</p>
<pre><code>result, = roll_dice(20, 1)</code></pre>
<p>I have to manually pass a <code>1</code> as the second argument of <code>roll_dice</code> to specify that I’m rolling a single die.</p>
<p><span epub:type="pagebreak" title="126" id="Page_126"/>By the way, that trailing comma after <code>result</code> is how I unpack a single value from a single-item tuple, meaning the actual value of the only item in the tuple is now bound to <code>result</code>. (See <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span> for more on unpacking.)</p>
<p>Since rolling a single die is likely the most common action I want to take with this function, I want to make it more convenient to use. I can use <em>default argument values</em> to accomplish this:</p>
<pre><code>import random


def roll_dice(sides, dice<b>=1</b>):
    return tuple(random.randint(1, sides) for _ in range(dice))</code></pre>
<p class="CodeListingCaption"><a id="listing6-8">Listing 6-8</a>: <em>dice_roll.py:1c</em></p>
<p>The <code>dice</code> parameter now has a default argument value of <code>1</code>. Thus, anytime I don’t specify the second argument, <code>dice</code> will use its default argument value. This makes it possible to use a simplified function call to roll a single six-sided die:</p>
<pre><code>result, = roll_dice(6)</code></pre>
<p>If I do want to roll multiple dice, I can still pass that second argument:</p>
<pre><code>player1, player2 = roll_dice(20, 2)</code></pre>
<p>When you specify a default argument value for a parameter, you are defining an <em>optional parameter</em>. Conversely, a parameter with no default argument value is a <em>required parameter</em>. You can have as many of each as you like, but you must list all required parameters <em>before</em> your optional parameters. Otherwise, the code won’t run.</p>
<p>When using optional parameters, there is one significant trap lurking in the dark: default argument values are only evaluated once, when the function is defined. One place where this gets treacherous is when you’re using any mutable data type, such as a list. Consider this code for generating values in a Fibonacci sequence, which doesn’t quite work as expected:</p>
<pre><code>def fibonacci_next(series <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> =[1, 1]):
  <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> series.append(series[-1] + series[-2])
    return series</code></pre>
<p class="CodeListingCaption"><a id="listing6-9">Listing 6-9</a>: <em>fibonacci.py:1a</em></p>
<p>This is going to have a problem because the default argument value <code>[1, 1]</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span> is evaluated when Python first processes the function definition, creating a single mutable list with the value <code>[1, 1]</code> in memory. That gets mutated on the first function call <span class="CodeAnnotation" aria-label="annotation2">❷</span> and then returned.</p>
<p><span epub:type="pagebreak" title="127" id="Page_127"/>This usage of the function shows the problem:</p>
<pre><code>fib1 = fibonacci_next()
print(fib1)  # prints [1, 1, 2]
fib1 = fibonacci_next(fib1)
print(fib1)  # prints [1, 1, 2, 3]

fib2 = fibonacci_next()
print(fib2)  # should be [1, 1, 2] riiiiight?</code></pre>
<p class="CodeListingCaption"><a id="listing6-10">Listing 6-10</a>: <em>fibonacci.py:2</em></p>
<p>Everything looks okay in the code, but it isn’t. <code>fib1</code> is now bound to the same mutable value as <code>series</code>, so any changes to <code>fib1</code> are reflected in the default argument value <em>for every function call</em>. The second function call mutates this list further.</p>
<p>When I call <code>fibonacci_next()</code> a third time, I’m probably expecting to start with a clean slate, <code>[1, 1, 2]</code>, which would be the result of a single mutation on the original default argument value. Instead, I’m getting the value of that single mutable value I’ve been messing with this whole time: <code>fib2</code> is now a third alias to the list. Oops!</p>
<p>This becomes apparent when I examine the output. This is what I’d be expecting:</p>
<pre><code>[1, 1, 2]
[1, 1, 2, 3]
[1, 1, 2]</code></pre>
<p>But this is what I actually get:</p>
<pre><code>[1, 1, 2]
[1, 1, 2, 3]
[1, 1, 2, 3, 5]</code></pre>
<p>In short, <em>never use mutable values for default argument values</em>. Instead, use <code>None</code> as a default value, as shown in the following:</p>
<pre><code>def fibonacci_next(series<b>=None</b>):
    <b>if series is None:</b>
        <b>series = [1, 1]</b>
    series.append(series[-1] + series[-2])
    return series</code></pre>
<p class="CodeListingCaption"><a id="listing6-11">Listing 6-11</a>: <em>fibonacci.py:1b</em></p>
<p>The proper way is to use <code>None</code> as the default argument value, and then to create a new mutable value if that default is being used.</p>
<p><span epub:type="pagebreak" title="128" id="Page_128"/>Running that same usage code as before (<a href="#listing6-9" id="listinganchor6-9">Listing 6-9</a>) now produces the expected output:</p>
<pre><code>[1, 1, 2]
[1, 1, 2, 3]
[1, 1, 2]</code></pre>
<h2 id="h1-500920c06-0004">Keyword Arguments</h2>
<p class="BodyFirst">Readability matters. Unfortunately, function calls with multiple parameters aren’t always the most readable bits of code. <em>Keyword arguments</em> help resolve this by attaching labels to arguments in function calls.</p>
<p>Arguments that are mapped to their parameters by the order you pass them in, like in all the prior examples, are called <em>positional arguments</em>.</p>
<p>If you knew nothing about the <code>roll_dice()</code> function from earlier and you encountered this line of code, what would you think it did?</p>
<pre><code>dice_cup = roll_dice(6, 5)</code></pre>
<p class="CodeListingCaption"><a id="listing6-12">Listing 6-12</a>: <em>dice_roll.py:3a</em></p>
<p>You would probably guess that this is rolling multiple dice, and perhaps that it is specifying how many sides those dice have—but which is which? Is it rolling six five-sided dice or five six-sided dice? You can imagine how confusing this would be with even more arguments. This is the shortcoming of positional arguments.</p>
<p>As The Zen of Python says:</p>
<blockquote class="blockquote">
<p class="Blockquote">In the face of ambiguity, refuse the temptation to guess.</p>
</blockquote>
<p>It can’t be good, then, to force the reader to guess. I can eliminate the ambiguity by using <em>keyword arguments</em>. I don’t need to change the function definition at all to be able to use keyword arguments. I only need to change my function call:</p>
<pre><code>dice_cup = roll_dice(<b>sides=6, dice=5</b>)</code></pre>
<p class="CodeListingCaption"><a id="listing6-13">Listing 6-13</a>: <em>dice_roll.py:3b</em></p>
<p>Each of those names comes from the earlier function definition of <code>roll_dice</code>, where I specified it had two parameters: <code>sides</code> and <code>dice</code>. In my function call, I can assign values directly to those parameters by name. Now, there is no question about what each argument does. Specify the name of the parameter, matching what is in the function definition, and then assign the desired value directly to it. That’s all.</p>
<p>When using keyword arguments, you don’t even have to list them in order, just as long as all the required parameters receive values:</p>
<pre><code><span epub:type="pagebreak" title="129" id="Page_129"/>dice_cups = roll_dice(<b>dice=5, sides=6</b>)</code></pre>
<p class="CodeListingCaption"><a id="listing6-14">Listing 6-14</a>: <em>dice_roll.py:3c</em></p>
<p>This can be even more helpful when you have multiple optional parameters on the function. Consider if I rewrote <code>roll_dice()</code> so that the dice being rolled were six sided, by default:</p>
<pre><code>import random


def roll_dice(sides=6, dice=1):
    return tuple(random.randint(1, sides) for _ in range(dice))</code></pre>
<p class="CodeListingCaption"><a id="listing6-15">Listing 6-15</a>: <em>dice_roll.py:1d</em></p>
<p>Keyword arguments allow you to simplify your function calls even further:</p>
<pre><code>dice_cups = roll_dice(<b>dice=5</b>)</code></pre>
<p class="CodeListingCaption"><a id="listing6-16">Listing 6-16</a>: <em>dice_roll.py:3d</em></p>
<p>You’re only passing a value to one of the optional arguments, <code>dice</code>. For the other one, <code>sides</code>, the default value is used. It no longer needs to matter whether <code>sides</code> or <code>dice</code> appears first in the function’s parameter list; you can just use the ones you want and leave the rest alone.</p>
<p>It is even possible to mix and match positional arguments and keyword arguments:</p>
<pre><code>dice_cups = roll_dice(6<b>, dice=5</b>)</code></pre>
<p class="CodeListingCaption"><a id="listing6-17">Listing 6-17</a>: <em>dice_roll.py:3e</em></p>
<p>Here, <code>6</code> is passed as a positional argument to the first parameter in the function definition, <code>sides</code>. Then, I pass <code>5</code> as a keyword argument to the parameter <code>dice</code>.</p>
<p>This can come in handy, particularly when you don’t want to bother with naming the positional arguments but you still want to use one of many possible optional parameters. The only rule here is that your keyword arguments must come after your positional arguments in the function call. (See also the section <span class="xref" itemid="xref_target_“Keyword-Only Parameters”">“Keyword-Only Parameters”</span> later in the chapter.)</p>
<h2 id="h1-500920c06-0005">On Overloaded Functions</h2>
<p class="BodyFirst">If you’re coming from a strictly typed language such as Java or C++, you’re probably used to writing <em>overloaded functions</em>, wherein you can write multiple functions with the same name but different parameters. Typically, overloaded functions in languages that support them provide a consistent interface (function name), while supporting arguments of different types.</p>
<p><span epub:type="pagebreak" title="130" id="Page_130"/>Python usually doesn’t need overloaded functions. Using dynamic typing, duck typing, and optional parameters, you can write single functions that handle all the input scenarios you need to throw at Python.</p>
<p>If you really, really need overloaded functions—and you probably don’t—you actually can create them with <em>single-dispatch functions</em>. I’ll cover this in <span class="xref" itemid="xref_target_Chapter 15">Chapter 15</span>.</p>
<h2 id="h1-500920c06-0006">Variadic Arguments</h2>
<p class="BodyFirst">With the skills discussed so far, even while using optional parameters, you still have to anticipate how many arguments can potentially get passed to your function. This is fine in most cases, but sometimes, you’ll have no idea how many to expect.</p>
<p>To solve this, your first instinct might be to pack all the arguments into a single tuple or a list. That works in some situations, but other times, it can become an extra inconvenience when calling the function.</p>
<p>A better solution is to use <em>arbitrary arguments lists</em>, also called <em>variadic arguments</em>, which automatically pack multiple arguments into a single <em>variadic parameter</em> or <em>variadic positional parameter</em>. In the dice-rolling function, I want to allow the rolling of multiple dice, where each die may have a different number of sides:</p>
<pre><code>import random


def roll_dice(*dice):
    return tuple(random.randint(1, d) for d in dice)</code></pre>
<p class="CodeListingCaption"><a id="listing6-18">Listing 6-18</a>: <em>dice_roll_variadic.py:1a</em></p>
<p>I turn the parameter <code>dice</code> into a variadic parameter by preceding it with a single asterisk (<code>*</code>). All the arguments passed to <code>roll_dice</code> will now be packed into a tuple, bound to the name <code>dice</code>.</p>
<p>Within the function, I can use this tuple in the usual manner. In this case, I’m using a generator expression (see <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>) to roll each die specified in <code>dice</code>.</p>
<p>The placement of the variadic parameter is important: it must come <em>after</em> any positional parameters in the function definition. Any parameters I list after it will only be usable as keyword arguments, because the variadic parameter consumes all the remaining positional arguments.</p>
<p>Here’s my usage:</p>
<pre><code>dice_cup = roll_dice(6, 6, 6, 6, 6)
print(dice_cup)

bunch_o_dice = roll_dice(20, 6, 8, 4)
print(bunch_o_dice)</code></pre>
<p class="CodeListingCaption"><a id="listing6-19">Listing 6-19</a>: <em>dice_roll_variadic.py:2</em></p>
<p><span epub:type="pagebreak" title="131" id="Page_131"/>In both function calls, I’m listing the dice I want to roll, with the number representing the number of sides of each die. In the first call, I’m rolling five six-sided dice. In the second call, I’m rolling four dice: a 20-sided die, a 6-sided die, an 8-sided die, and a 4-sided die.</p>
<p>If I wanted to use the recursive approach, I’d populate the argument list by automatically unpacking that tuple into the function call:</p>
<pre><code>def roll_dice(*dice):
<b>    if dice:</b>
<b>        roll = random.randint(1, dice[0])</b>
<b>        return (roll,) + roll_dice(</b><span class="CodeAnnotationCode" aria-label="annotation1">❶</span><b> *dice </b><span class="CodeAnnotationCode" aria-label="annotation2">❷</span><b> [1:])</b>
<b>    return ()</b></code></pre>
<p class="CodeListingCaption"><a id="listing6-20">Listing 6-20</a>: <em>dice_roll_variadic.py:1b</em></p>
<p>Most of this code is going to look similar to the earlier recursive version. The most significant change is in what I’m passing to the recursive function call. The asterisk (<code>*</code>) in front of the name unpacks the tuple <code>dice</code> into the argument list <span class="CodeAnnotation" aria-label="annotation1">❶</span>. I already processed the first item in the list, so I use the slice notation <code>[1:]</code> to remove that first item <span class="CodeAnnotation" aria-label="annotation2">❷</span> (see <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>), to ensure it isn’t processed again.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic note</h2><p class="BoxBodyFirst">If you want to use recursion, be prepared for a doozy of a debate in justifying it. Many Pythonistas consider recursion to be an anti-pattern, particularly when you can just use a loop.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500920c06-0001">Keyword Variadic Arguments</h3>
<p class="BodyFirst">To capture an unknown number of <em>keyword arguments</em>, precede the parameter name with <em>two</em> asterisks (<code>**</code>), making the parameter a <em>keyword variadic parameter</em>. The keyword arguments passed to the function are packed into a single dictionary object, so as to preserve the association between keyword and value. They are similarly unpacked by being preceded with two asterisks.</p>
<p>This doesn’t show up very often in the wild. After all, if you didn’t know what the arguments were named, it would be hard to use them.</p>
<p>One case where keyword variadic arguments are commonly useful is in blindly relaying arguments to another function call:</p>
<pre><code>def call_something_else(func, *args, **kwargs):
    return func(*args, **kwargs)</code></pre>
<p class="CodeListingCaption"><a id="listing6-21">Listing 6-21</a>: <em>variadic_relay.py:1</em></p>
<p>The <code>call_something_else()</code> function has one positional argument, <code>func</code>, where I’ll pass a <em>callable</em> object, such as another function. The second parameter, <code>args</code>, is a variadic parameter for capturing all the remaining positional arguments. Last is the keyword variadic parameter, <code>kwargs</code>, for capturing any keyword arguments; sometimes, the name <code>kw</code> is used instead. Remember, either of these can be empty and this code will still work.</p>
<p><span epub:type="pagebreak" title="132" id="Page_132"/>You can check whether an object is callable by passing it to the <code>callable()</code> function.</p>
<p>The names <code>args</code> and <code>kwargs</code> are conventionally used for positional variadic and keyword variadic parameters, respectively. However, if you can think of names that better fit your particular situation, that’s certainly acceptable!</p>
<p>When the function calls the callable object <code>func</code>, it first unpacks all the positional arguments that were captured, and then it unpacks all the keyword arguments. The function code doesn’t need any knowledge of the callable object’s parameter list; instead, any and every argument passed to <code>call_something_else()</code> after that first positional argument will get blindly passed on.</p>
<p>You can see this in action here:</p>
<pre><code>def say_hi(name):
    print(f"Hello, {name}!")


call_something_else(say_hi, name="Bob")</code></pre>
<p class="CodeListingCaption"><a id="listing6-22">Listing 6-22</a>: <em>variadic_relay.py:2</em></p>
<p>When I run that code, the <code>call_something_else()</code> function will call <code>say_hi()</code>, passing the argument <code>name="Bob"</code> to it. That produces the following output:</p>
<pre><code>Hello, Bob!</code></pre>
<p>This bit of magic will come back into play shortly in writing <em>decorators</em> (see the section <span class="xref" itemid="xref_target_“Decorators”">“Decorators”</span> later in this chapter).</p>
<h2 id="h1-500920c06-0007">Keyword-Only Parameters</h2>
<p class="BodyFirst">You can use variadic parameters to turn some of your keyword parameters into <em>keyword-only parameters</em>, which were introduced in PEP 3102. These parameters cannot have values passed in as positional arguments, but rather only as keyword arguments. This can be especially useful in ensuring that particularly long or perilous parameter lists are used in the proper manner, instead of as nigh-on unreadable chains of positional arguments.</p>
<p>To demonstrate this, I’ll rewrite my <code>roll_dice()</code> function to have two keyword-only parameters:</p>
<pre><code>import random


def roll_dice(*, sides=6, dice=1):
    return tuple(random.randint(1, sides) for _ in range(dice))</code></pre>
<p class="CodeListingCaption"><a id="listing6-23">Listing 6-23</a>: <em>dice_roll_keyword_only.py:1</em></p>
<p><span epub:type="pagebreak" title="133" id="Page_133"/>I use the unnamed variadic parameter <code>*</code>, which ensures every parameter that follows it in the list can only be accessed by name. If the caller passes in too many positional arguments (or in this case, <em>any</em> positional arguments), a <code>TypeError</code> is raised.</p>
<p>This affects the usage, such that I can only use keyword arguments now:</p>
<pre><code>dice_cup = roll_dice(sides=6, dice=5)
print(dice_cup)</code></pre>
<p class="CodeListingCaption"><a id="listing6-24">Listing 6-24</a>: <em>dice_roll_keyword_only.py:2</em></p>
<p>Attempting to use positional arguments raises an error:</p>
<pre><code>dice_cup = roll_dice(6, 5)  # raises TypeError
print(dice_cup)  </code></pre>
<p class="CodeListingCaption"><a id="listing6-25">Listing 6-25</a>: <em>dice_roll_keyword_only.py:3</em></p>
<h3 id="h2-500920c06-0002">Positional-Only Parameters</h3>
<p class="BodyFirst">As of Python 3.8 (via PEP 570), it is also possible to define <em>positional-only parameters</em>. This is useful when the parameter name is either unhelpful or likely to be changed down the road, meaning any code using it as a keyword parameter would be likely to break in the future.</p>
<p>You’ll recall that positional parameters must always come first in the parameter list. Placing a forward slash (<code>/</code>) in the list designates all preceding parameters as positional-only:</p>
<pre><code>import random


def roll_dice(dice=1, /, sides=6):
    return tuple(random.randint(1, sides) for _ in range(dice))</code></pre>
<p class="CodeListingCaption"><a id="listing6-26">Listing 6-26</a>: <em>dice_roll_positional_only.py:1</em></p>
<p>In this example, the parameter <code>dice</code> still has a default value of <code>1</code>, but it is now positional-only. On the other hand, <code>sides</code> can be used as either a positional or a keyword parameter. Here’s that behavior in action:</p>
<pre><code>roll_dice(4, 20)             # OK; dice=4, sides=20
roll_dice(4)                 # OK; dice=4, sides=6
roll_dice(sides=20)          # OK; dice=1, sides=20
roll_dice(4, sides=20)       # OK; dice=4, sides=20

roll_dice(dice=4)            # TypeError
roll_dice(dice=4, sides=20)  # TypeError</code></pre>
<p class="CodeListingCaption"><a id="listing6-27">Listing 6-27</a>: <em>dice_roll_positional_only.py:2</em></p>
<p><span epub:type="pagebreak" title="134" id="Page_134"/>The first four examples all work, because the positional-only argument <code>dice</code> is either included as the first argument or omitted altogether. Any attempt to access <code>dice</code> by keyword fails with a <code>TypeError</code>.</p>
<h3 id="h2-500920c06-0003">Argument Types: All Together Now!</h3>
<p class="BodyFirst">To ensure everything is clear regarding positional parameters and keyword parameters, I’ll take a moment to review with this (admittedly contrived) example:</p>
<pre><code>def func(pos_only=None, /, pos_kw=None, *, kw_only=None):</code></pre>
<p>The parameter <code>pos_only</code> is positional-only, as it comes before the forward-slash (<code>/</code>) marker. If I have any positional-only parameters, they must appear first in the list. Because this parameter has a default value, it is optional. However, if I wanted to pass an argument to it, it would need to be the first positional argument passed to the function; otherwise, a <code>TypeError</code> would be raised.</p>
<p>Next is the <code>pos_kw</code> parameter, which can be either positional or keyword. It comes after any positional-only parameters and after the forward-slash (<code>/</code>) marker, if there is one.</p>
<p>Finally, after the asterisk (<code>*</code>) marker, I have <code>kw_only</code>, which is a keyword-only parameter. In this example, if my function receives more than two positional arguments, a <code>TypeError</code> will be raised.</p>
<h2 id="h1-500920c06-0008">Nested Functions</h2>
<p class="BodyFirst">From time to time, you may want to reuse a piece of logic <em>within</em> a function but not clutter up your code by making yet another function. In this situation, you can nest functions within other functions.</p>
<p>I can use this to improve the recursive version of <code>roll_dice()</code>, making the logic for rolling a single die into something more reusable in the function:</p>
<pre><code>import random


def roll_dice(sides<b>=6</b>, dice<b>=1</b>):
    <b>def roll():</b>
        <b>return </b>random.randint(1, sides)
    
    if dice &lt; 1:
        return ()
    return (<b>roll()</b>, ) + roll_dice(sides, dice-1)</code></pre>
<p class="CodeListingCaption"><a id="listing6-28">Listing 6-28</a>: <em>dice_roll_recursive.py:1b</em></p>
<p>In this example, I moved the logic for rolling a single die into a nested function <code>roll()</code>, which I can call from anywhere in the function <code>roll_dice()</code>. <span epub:type="pagebreak" title="135" id="Page_135"/>The direct benefit of abstracting out this logic is that it can be maintained more easily, without disrupting the rest of the code.</p>
<p>Here’s the usage:</p>
<pre><code>dice_cup = roll_dice(<b>sides=</b>6, <b>dice=</b>5)
print(dice_cup)</code></pre>
<p class="CodeListingCaption"><a id="listing6-29">Listing 6-29</a>: <em>dice_roll_recursive.py:2b</em></p>
<p>That produces the usual random output.</p>
<p>In production, I’d rarely use a nested function for something that trivial. Normally, I’d employ a nested function for more complex logic that sees frequent reuse, especially if it is used in multiple places in the outer function.</p>
<p>You’ll recall from <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span> that the nested function can access the names of its enclosing scope. However, if I wanted to rebind or mutate any of those names from within the nested function, I’d need to use the <code>nonlocal</code> keyword.</p>
<h2 id="h1-500920c06-0009">Closures</h2>
<p class="BodyFirst">You can create a function that builds and returns a kind of function called a <em>closure</em>, which encloses one or more nonlocal names. This pattern acts as a sort of “function factory.”</p>
<p>Building on the dice example, I’ll write a function that returns a <em>closure</em> for rolling a particular set of dice:</p>
<pre><code>import random


def make_dice_cup(sides=6, dice=1):
    def roll():
        return tuple(random.randint(1, sides) for _ in range(dice))
    
  <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> return roll</code></pre>
<p class="CodeListingCaption"><a id="listing6-30">Listing 6-30</a>: <em>dice_cup_closure.py:1</em></p>
<p>I create the function <code>make_dice_cup()</code>, which accepts the arguments for <code>sides</code> and <code>dice</code>. Inside <code>make_dice_cup()</code>, I define a nested function <code>roll()</code>, which uses <code>sides</code> and <code>dice</code>. When that nested function is returned by the outer function (no parentheses!) <span class="CodeAnnotation" aria-label="annotation1">❶</span>, it becomes a closure, because it encloses <code>sides</code> and <code>dice</code>.</p>
<pre><code>roll_for_damage = make_dice_cup(sides=8, dice=5)
damage = roll_for_damage()
print(damage)</code></pre>
<p class="CodeListingCaption"><a id="listing6-31">Listing 6-31</a>: <em>dice_cup_closure.py:2</em></p>
<p><span epub:type="pagebreak" title="136" id="Page_136"/>I bind the closure returned by <code>make_dice_cup()</code> to the name <code>roll_for_damage</code>, which I can now call as a function without any arguments. The closure continues to use <code>sides</code> and <code>dice</code> with the values I specified earlier to roll dice and return values; it is now a function in its own right.</p>
<p>Caution is necessary when using closures, as you can easily violate the rules of functional programming with them. If a closure has the ability to mutate the values it encloses, it becomes a sort of de facto object, and a difficult one to debug at that!</p>
<h3 id="h2-500920c06-0004">Recursion with Closures</h3>
<p class="BodyFirst">The previous closure example didn’t use the recursive form of the dice-rolling code because, while it’s possible to implement such closure correctly, it’s even easier to do it wrong.</p>
<p>Here’s the most apparently obvious, yet wrong, way to make that closure recursive:</p>
<pre><code>import random


def make_dice_cup(sides=6, dice=1):
    def roll():
        nonlocal dice
        if dice &lt; 1:
            return ()
        die = random.randint(1, sides)
        dice -= 1
        return (die, ) + roll()

    return roll</code></pre>
<p class="CodeListingCaption"><a id="listing6-32">Listing 6-32</a>: <em>dice_cup_closure_recursive.py:1a</em></p>
<p>Using what you know about names and scope so far, can you anticipate what’s wrong with the above?</p>
<p>The giveaway that something is wrong with the closure is the keyword <code>nonlocal</code>, as it indicates I’m mutating or rebinding a nonlocal name: <code>dice</code>.</p>
<p>Attempting to use this closure will reveal the problem:</p>
<pre><code>roll_for_damage = make_dice_cup(sides=8, dice=5)
damage = roll_for_damage()
print(damage)

damage = roll_for_damage()
print(damage)</code></pre>
<p class="CodeListingCaption"><a id="listing6-33">Listing 6-33</a>: <em>dice_cup_closure_recursive.py:2</em></p>
<p>That code produces the following output (for example):</p>
<pre><code>(1, 3, 4, 3, 7)
()</code></pre>
<p><span epub:type="pagebreak" title="137" id="Page_137"/>The first time the closure <code>roll_for_damage()</code> is used, everything is fine. However, <code>dice</code> isn’t reset when the function exits, so all subsequent calls to the closure find that <code>dice == 0</code>. Thus, they only return <code>()</code>.</p>
<p>To write a recursive closure, you need to use an optional parameter on the closure:</p>
<pre><code>import random


def make_dice_cup(sides=6, dice=1):
    def roll(<b>dice=dice</b>):
        if dice &lt; 1:
            return ()
        die = random.randint(1, sides)
        return (die, ) + roll(<b>dice - 1</b>)

    return roll</code></pre>
<p class="CodeListingCaption"><a id="listing6-34">Listing 6-34</a>: <em>dice_cup_closure_recursive.py:1b</em></p>
<p>In this version, I use the nonlocal name <code>dice</code> as the default value of the new, local parameter <code>dice</code>. (Recall, this will only work with immutable types.) This behaves precisely as expected, as it still closes over <code>sides</code> and the nonlocal <code>dice</code>, but it rebinds neither.</p>
<h3 id="h2-500920c06-0005">Stateful Closures</h3>
<p class="BodyFirst">While it is generally best to write closures as pure functions, it is occasionally useful to create a <em>stateful closure</em>—that is, a closure that retains a little bit of state between calls that it can use. In general, you should avoid using stateful closures unless no other solution presents itself.</p>
<p>Just to demonstrate this, I’ll create a stateful closure that limits how many times a player can reroll a group of dice:</p>
<pre><code>import random


def start_turn(limit, dice=5, sides=6):
    def roll():
        nonlocal limit
        if limit &lt; 1:
            return None
        limit -= 1
        return tuple(random.randint(1, sides) for _ in range(dice))

    return roll</code></pre>
<p class="CodeListingCaption"><a id="listing6-35">Listing 6-35</a>: <em>dice_roll_turns.py:1</em></p>
<p>I write the closure <code>roll()</code> so that it only allows the caller to reroll the dice a maximum number of times, specified by <code>limit</code>, before the function starts returning <code>None</code>. By this design, after the limit is reached, a new closure <span epub:type="pagebreak" title="138" id="Page_138"/>must be created. The logic of tracking how many times a player can roll the dice has been abstracted out into the closure.</p>
<p>This closure is very limited and predictable in how it mutates and uses its state. It’s important to limit your closures in this way, since debugging a stateful closure can be difficult. There is no way to see the current value of <code>limit</code> from outside the closure; it’s simply not possible.</p>
<p>You can see this predictable behavior at work in the usage:</p>
<pre><code>turn1 = start_turn(limit=3)
while toss := turn1():
    print(toss)

turn2 = start_turn(limit=3)
while toss := turn2():
    print(toss)</code></pre>
<p class="CodeListingCaption"><a id="listing6-36">Listing 6-36</a>: <em>dice_roll_turns.py:2</em></p>
<p>Running that code produces the following randomized output, wherein each turn gets three tosses of the dice; each toss is represented by a tuple:</p>
<pre><code>(4, 1, 2, 1, 1)
(4, 2, 3, 1, 5)
(1, 6, 3, 4, 2)
(1, 6, 4, 5, 5)
(2, 1, 4, 5, 3)
(2, 4, 1, 6, 1)</code></pre>
<p>A stateful closure can be useful in situations where writing an entire class (see <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>) brings in too much boilerplate. Since I only have one piece of state, <code>limit</code>, and I am using it predictably, this approach is acceptable. Anything more complicated, and debugging becomes impractically difficult.</p>
<p>As I pointed out earlier, anytime you see <code>nonlocal</code> in a closure, you should be extra cautious, as it indicates the presence of state. This can be acceptable on occasion, but there is usually a better approach. Stateful closures are not pure functional programming!</p>
<h2 id="h1-500920c06-0010">Lambdas</h2>
<p class="BodyFirst">A <em>lambda</em> is an anonymous (nameless) function made up of a single expression. The structure is as follows:</p>
<pre><code>lambda x, y: x + y</code></pre>
<p>On the left side of the colon is the parameter list, which may be omitted if you don’t want to accept any arguments. On the right is the return expression, which is evaluated when the lambda is called and the result is implicitly returned. To use a lambda, you must bind it to a name, whether by assignment or by passing it as an argument to another function.</p>
<p><span epub:type="pagebreak" title="139" id="Page_139"/>For example, here’s a lambda that adds two numbers:</p>
<pre><code>add = lambda x, y: x + y
answer = add(20, 22)
print(answer)  # outputs "42"</code></pre>
<p class="CodeListingCaption"><a id="listing6-37">Listing 6-37</a>: <em>addition_lambda.py</em></p>
<p>I bind the <code>lambda</code> to the name <code>add</code> and then call it as a function. This particular lambda accepts two arguments and then returns their sum.</p>
<h3 id="h2-500920c06-0006">Why Lambdas Are Useful</h3>
<p class="BodyFirst">Many programmers can’t imagine ever needing nameless functions. It would seem to make reuse completely impractical. After all, if you’re just going to bind a lambda to a name, shouldn’t you have just written a function?</p>
<p>To understand how lambdas can be useful, let’s take a look at an example <em>without</em> lambdas first. This code represents a player character in a basic text adventure game:</p>
<pre><code>import random

health = 10
xp = 10</code></pre>
<p class="CodeListingCaption"><a id="listing6-38">Listing 6-38</a>: <em>text_adventure_v1.py:1</em></p>
<p>I’m keeping track of my character’s stats in a couple of global names at the top, <code>health</code> and <code>xp</code>, which I’ll use throughout my program:</p>
<pre><code>def attempt(action, min_roll, <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> outcome):
    global health, xp
    roll = random.randint(1, 20)
    if roll &gt;= min_roll:
        print(f"{action} SUCCEEDED.")
        result = True
    else:
        print(f"{action} FAILED.")
        result = False

    scores = <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> outcome(result)
    health = health + scores[0]
    print(f"Health is now {health}")
    xp = xp + scores[1]
    print(f"Experience is now {xp}")

    return result</code></pre>
<p class="CodeListingCaption"><a id="listing6-39">Listing 6-39</a>: <em>text_adventure_v1.py:2</em></p>
<p>My <code>attempt()</code> function handles rolling the dice, using the outcome to decide whether the player’s action succeeded or failed, and then modifying the values of the global <code>health</code> and <code>xp</code> variables accordingly. It determines <span epub:type="pagebreak" title="140" id="Page_140"/>how those values should be changed, based on the value returned from calling the function passed to <code>outcome</code>.</p>
<p>The part to focus on is the parameter <code>outcome</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>—which, by its usage in <code>attempt()</code> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, should be a function that accepts a boolean value and returns a tuple of two integers representing the desired changes to <code>health</code> and <code>xp</code>, respectively.</p>
<p>Expanding on that example, I’ll use what I’ve built so far:</p>
<pre><code>def eat_bread(success):
    if success:
        return (1, 0)
    return (-1, 0)


def fight_ice_weasel(success):
    if success:
        return (0, 10)
    return (-10, 10)


<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> attempt("Eating bread", 5, eat_bread)
attempt("Fighting ice weasel", 15, fight_ice_weasel)</code></pre>
<p class="CodeListingCaption"><a id="listing6-40">Listing 6-40</a>: <em>text_adventure_v1.py:3a</em></p>
<p>There’s no real pattern to the outcomes of each possible action, so I have to write functions for each one: in this example, <code>eat_bread()</code> and <code>fight_ice_weasel()</code>. Even this example is a bit oversimplified, as the code determining the outcome might involve a bunch of mathematics and randomization. Regardless, since I need a separate outcome function for each action, this code is going to grow rapidly, leading to a maintainability nightmare.</p>
<p>(Be advised, the <code>if</code> statement above is not the most Pythonic way to write that code; I deliberately chose that structure to illustrate the logic.)</p>
<p>When I attempt an action <span class="CodeAnnotation" aria-label="annotation1">❶</span>, I pass the string representing the action, the minimum dice roll necessary to succeed, and the function determining the outcome. When passing a function, remember not to include the trailing parentheses. Here, I want to pass the function itself, not the value it returns.</p>
<p>This sort of usage is where lambdas come in. I can replace the <code>eat_bread()</code> and <code>fight_ice_weasel()</code> functions, plus the two calls to <code>attempt()</code>, with just the following:</p>
<pre><code>attempt("Eating bread", 5,
        <b>lambda success: (1, 0) if success else (-1, 0)</b>)

attempt("Fighting ice weasel", 15,
        <b>lambda success: (0, 10) if success else (-10, 10)</b>)</code></pre>
<p class="CodeListingCaption"><a id="listing6-41">Listing 6-41</a>: <em>text_adventure_v1.py:3b</em></p>
<p><span epub:type="pagebreak" title="141" id="Page_141"/>The third argument of each is a lambda, which accepts a single parameter named <code>success</code> and returns a value depending on the value of <code>success</code>. Let’s isolate just that first lambda:</p>
<pre><code>lambda success: (1, 0) if success else (-1, 0))</code></pre>
<p>When the lambda is called, if the value of <code>success</code> is <code>True</code>, then <code>(1, 0)</code> will be returned. Otherwise, <code>(-1, 0)</code> is returned.</p>
<p>That lambda is being passed to (and thus bound to) the <code>outcome</code> parameter of the <code>attempt()</code> function, and it is subsequently called with a single boolean argument.</p>
<p>By using lambdas in this manner, I can create many different possible outcomes in my code with only one line of code.</p>
<p>Remember that <em>a lambda may only consist of a single return expression</em>! This makes lambdas suitable for short, clear fragments of logic, especially when the code is made more readable by keeping that logic close to its usage within another function call. If you want anything more complex, you’ll need to write a proper function.</p>
<h3 id="h2-500920c06-0007">Lambdas as Sorting Keys</h3>
<p class="BodyFirst">One of the most common situations where a lambda comes in handy is when specifying a <em>key function</em>, which is a callable that returns the part of a collection or object that should be used for sorting. A key function is typically passed to another function that is responsible for sorting data in some manner.</p>
<p>For example, here I have a list of tuples containing first and last names, and I want to sort the list by last name:</p>
<pre><code>people = [
    ("Jason", "McDonald"),
    ("Denis", "Pobedrya"),
    ("Daniel", "Foerster"),
    ("Jaime", "López"),
    ("James", "Beecham")
]

by_last_name = sorted(people, <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> key=lambda x: x[1])
print(by_last_name)</code></pre>
<p class="CodeListingCaption"><a id="listing6-42">Listing 6-42</a>: <em>sort_names.py</em></p>
<p>The <code>sorted()</code> function uses the <code>key</code> argument <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which is always a function or other callable, by passing each item to it and then using the value returned from that callable to determine the sorting order. Since I want the tuples sorted by last name, which is the second item of each tuple, I have the lambda return that item, which is <code>x[1]</code>.</p>
<p>The end result is that <code>by_last_name</code> contains the list, sorted by last name. </p>
<h2 id="h1-500920c06-0011"><span epub:type="pagebreak" title="142" id="Page_142"/>Decorators</h2>
<p class="BodyFirst"><em>Decorators</em> allow you to modify the behavior of a function (or even multiple functions) by wrapping it in an additional layer of logic. This changes the function’s behavior without you having to rewrite the function itself.</p>
<p>To demonstrate this, here’s another example with my text adventure game hero. I want to define multiple game events that affect the player character’s statistics in different ways, and I want those changes displayed as they happen. I’ll start with an implementation that doesn’t use decorators. This code only uses concepts I’ve already covered so far in this book, so I’ll mainly draw your attention to some inefficiencies.</p>
<p>I’ll start by defining my global variables:</p>
<pre><code>import random

character = "Sir Bob"
health = 15
xp = 0</code></pre>
<p class="CodeListingCaption"><a id="listing6-43">Listing 6-43</a>: <em>text_adventure_v2.py:1a</em></p>
<p>Next, I’ll define functions for each action the player can take:</p>
<pre><code>def eat_food(food):
    global health
  <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> if health &lt;= 0:
        print(f"{character} is too weak.")
        return

    print(f"{character} ate {food}.")
    health += 1
  <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> print(f"    Health: {health} | XP: {xp}")


def fight_monster(monster, strength):
    global health, xp
  <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> if health &lt;= 0:
        print(f"{character} is too weak.")
        return

    if random.randint(1, 20) &gt;= strength:
        print(f"{character} defeated {monster}.")
        xp += 10
    else:
        print(f"{character} flees from {monster}.")
        health -= 10
        xp += 5
  <span class="CodeAnnotationCode" aria-label="annotation4">❹</span> print(f"    Health: {health} | XP: {xp}")</code></pre>
<p class="CodeListingCaption"><a id="listing6-44">Listing 6-44</a>: <em>text_adventure_v2.py:2a</em></p>
<p>Each function represents an action the player can take, and some common code is shared between these functions. First, each function checks the character’s health to determine if the character is even able to perform <span epub:type="pagebreak" title="143" id="Page_143"/>the action <span class="CodeAnnotation" aria-label="annotation1">❶</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If the character’s health is sufficient, the player performs the action, which alters the character’s statistics. When the action is completed (or if the character’s health is too low to take an action), the current stats are displayed <span class="CodeAnnotation" aria-label="annotation2">❷</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>
<p>And then, of course, I have the usage:</p>
<pre><code>eat_food("bread")
fight_monster("Imp", 15)
fight_monster("Direwolf", 15)
fight_monster("Minotaur", 19)</code></pre>
<p class="CodeListingCaption"><a id="listing6-45">Listing 6-45</a>: <em>text_adventure_v2.py:3</em></p>
<p>That works, but as I said, the repeated code in <a href="#listing6-44" id="listinganchor6-44">Listing 6-44</a> is not very Pythonic. Your first instinct might be to move the common code—the code that checks the health and displays the statistics—out into their own functions. However, you would still need to remember to call each one within <em>every character action function</em>, and they’re easy to overlook. Furthermore, each function would still need that conditional statement at the top to ensure the code isn’t run when health is too low.</p>
<p>This situation, where I want to run the same code before and after every function, can be perfectly solved with decorators.</p>
<p>Here, I’ll create a decorator toward the top of the text adventure game code:</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">❶</span> <b>import functools</b>
import random

character = "Sir Bob"
health = 15
xp = 0


<b>def character_action(func):</b>
  <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> <b>@functools.wraps(func)</b>
  <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> <b>def wrapper(*args, **kwargs):</b>
<b>        if health &lt;= 0:</b>
<b>            print(f"{character} is too weak.")</b>
<b>            return</b>

<b>        result = func(*args, **kwargs)</b>
<b>        print(f"    Health: {health} | XP: {xp}")</b>
<b>        return result</b>

  <span class="CodeAnnotationCode" aria-label="annotation4">❹</span> <b>return wrapper</b></code></pre>
<p class="CodeListingCaption"><a id="listing6-46">Listing 6-46</a>: <em>text_adventure_v2.py:1b</em></p>
<p>A decorator is most often implemented as a closure, which closes over a function (or any other callable object) being modified. The decorator itself, <code>character_action()</code>, accepts a <code>func</code> parameter, which is the callable being modified.</p>
<p><span epub:type="pagebreak" title="144" id="Page_144"/>Within the decorator definition is the <em>wrapper</em>, which is the callable where the decorator’s logic lives <span class="CodeAnnotation" aria-label="annotation3">❸</span>. As I said, most commonly, the closure pattern is used for this. However, the wrapper can be implemented with any callable, including a class. (Technically, I could even implement the wrapper as a noncallable, but this is seldom, if ever, useful.)</p>
<p>Because I don’t know how many arguments will be passed to any function I’ll apply the decorator to, I set up the wrapper to accept variadic arguments.</p>
<p>The <code>@functools.wraps(func)</code> line <span class="CodeAnnotation" aria-label="annotation2">❷</span> prevents the callable being wrapped from having its identity concealed from the rest of the program. Without that line, wrapping the callable would mess up external access of such important function attributes as <code>__doc__</code> (the docstring) and <code>__name__</code>. This line is itself a decorator that ensures all the important attributes of the callable are retained by the now-wrapped function, thus making them accessible outside the function in all the usual ways. (To use that special decorator, I must import <code>functools</code> first <span class="CodeAnnotation" aria-label="annotation1">❶</span>.)</p>
<p>Inside the wrapper, I put all that logic I want to run before and after each function. After checking <code>health</code>, I call the function that is bound to <code>func</code>, unpacking all the variadic arguments into the call. I also bind the return value to <code>result</code>, so I can ensure that gets returned from the decorator after I print the stats.</p>
<p>As with any closure, it is supremely important that the outer function return the inner function <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>
<p>Now, I can use the decorator I wrote and refactor my other functions:</p>
<pre><code><b>@character_action</b>
def eat_food(food):
    global health
    print(f"{character} ate {food}.")
    health += 1


<b>@character_action</b>
def fight_monster(monster, strength):
    global health, xp
    if random.randint(1, 20) &gt;= strength:
        print(f"{character} defeated {monster}.")
        xp += 10
    else:
        print(f"{character} flees from {monster}.")
        health -= 10
        xp += 5</code></pre>
<p class="CodeListingCaption"><a id="listing6-47">Listing 6-47</a>: <em>text_adventure_v2.py:2b</em></p>
<p>To apply decorators to a function, I list each decorator I want to apply directly above the function definition, one decorator per line. I precede each decorator name with an <code>@</code> symbol. In my example, I only apply a single decorator to each function, but you can use as many as you like. They will be applied in order, with each decorator wrapping whatever is immediately below it.</p>
<p><span epub:type="pagebreak" title="145" id="Page_145"/>Since I moved all the repetitive logic about checking health and displaying stats out of the individual functions and into the decorator, my code is cleaner and easier to maintain. If you run the code, it works the same as before.</p>
<h2 id="h1-500920c06-0012">Type Hints and Function Annotations</h2>
<p class="BodyFirst">Python 3.5 onward allows you to specify <em>type hints</em>, which are exactly that: <em>hints</em> about what data type should be passed in or returned. These are not strictly necessary, given Python’s robust dynamic type system, but they may have a few benefits.</p>
<p>First, type hinting aids in documentation. The function definition now shows what type of information it wants, which is especially helpful when your IDE auto-magically shows hints as you type arguments in. </p>
<p>Second, type hints help you catch potential bugs sooner. Static type checkers like <em>Mypy</em> are the primary tools for this (see <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>). Some IDEs, like PyCharm, may warn you if you’re doing something weird, like passing a string to something type-hinted as an integer.</p>
<p>If you’re familiar with statically typed languages like Java and C++, this might make you a little excited.</p>
<p>However, understand that using type hints does not trade Python’s dynamic typing for static typing!</p>
<ol class="none">
<li>Python will not raise an error if you pass the wrong type.</li>
<li>Python will not try to convert data to the specified type.</li>
<li>Python will actually ignore these hints altogether!</li>
</ol>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA Alert</h2>	<p class="BoxBodyFirst">Lambdas do not support type hinting.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Type hints are specified with <em>annotations</em>, which are extra pieces of information that are permitted by the Python language but are not actually processed by the interpreter itself. There are two kinds of annotations.</p>
<p><em>Variable annotations</em> specify the expected type on a name, like this:</p>
<pre><code>answer: int = 42</code></pre>
<p><em>Function annotations</em> specify type hints on parameters and function returns. Here, I apply function annotations to the <code>roll_dice()</code> function from earlier:</p>
<pre><code>import random
<b>import typing</b>


def roll_dice(sides<b>: int</b> = 6, dice<b>: int</b> = 1) <b>-&gt; typing.Tuple[int, ...]</b>:
    # <var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing6-48">Listing 6-48</a>: <em>dice_roll.py:1e</em></p>
<p><span epub:type="pagebreak" title="146" id="Page_146"/>This notation allows me to denote what types I expect for the parameters and return. In this case, both parameters should receive an integer, so I follow each name with a colon and then <code>int</code> as the expected data type. If there’s a default value of the expected type, it is included after the type hint.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA ALERT</h2><p class="BoxBodyFirst">If a parameter has a default value of <code>None</code>, instead of a default value of the expected type, use the type hint <code>typing.Optional[int]</code>, where the expected type (<code>int</code>, in this case) appears in the brackets.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<p>I denote the return type with an arrow (<code>-&gt;</code>) and the expected type. Collections like tuples and lists are a little trickier to specify with type hints. From the <code>typing</code> module, I can use the notation <code>Tuple[ ]</code>, which is a <em>generic type</em>. Every value of this particular tuple should be an <code>int</code>, but since I don’t really know how many will be returned, I specify a <code>...</code> to say, “There may be more.” Now, the function will be expected to return one or more integers, but no other types.</p>
<p>By the way, if you don’t know what or how many types will be returned in a tuple, you can use the notation <code>typing.Tuple[typing.Any, ...]</code></p>
<p>That return type hint in the preceding code example is pretty long. I could shorten it by defining a <em>type alias</em>, like this:</p>
<pre><code>import random
import typing

<b>TupleInts = typing.Tuple[int, ...]</b>


def roll_dice(sides: int = 6, dice: int = 1) -&gt; <b>TupleInts</b>:
    # <var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing6-49">Listing 6-49</a>: <em>dice_roll.py:1f</em></p>
<p>I define <code>TupleInts</code> as a type alias for <code>Tuple[int, ...]</code>, and I can use it the same way throughout my code.</p>
<p>Again, Python itself won’t act on these type hints; it will only recognize the notation system as valid and store it in the <code>__annotations__</code> attribute of the function, nothing more.</p>
<p>I can now run this code through Mypy:</p>
<pre><code>mypy dice_roll.py</code></pre>
<p>If there are any mismatches between the type hints and the actual usage, Mypy will list these in detail, so they can be fixed.</p>
<h3 id="h2-500920c06-0008">Duck Typing and Type Hints</h3>
<p class="BodyFirst">You might think that type hinting is incompatible with duck typing, but thanks to the <code>typing</code> module, the two generally play very well with one another.</p>
<p><span epub:type="pagebreak" title="147" id="Page_147"/>For example, if you wanted a function that could accept a single parameter of any type that could be iterated over (see <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>), such as a tuple or a list, you could use <code>typing.Iterable[]</code>, with the contained type in the brackets. For this example, I’ll presume that the iterable may contain any type.</p>
<pre><code>def search(within: typing.Iterable[typing.Any]):</code></pre>
<p>The parameter <code>within</code> is type-hinted to be an iterable with <code>typing.Iterable[ ]</code>. The hint <code>typing.Any</code> within the square brackets indicates that the <code>Iterable</code> can contain items of any data type.</p>
<p>The typing module contains many different such types, enough to fill up a separate chapter altogether. The best way to learn more about type hinting is to read the documentation: <a href="https://docs.python.org/library/typing.html" class="LinkURL">https://docs.python.org/library/typing.html</a>. I also recommend taking a look at PEP 484, which defined type hinting, and PEP 3107, which defined function annotations.</p>
<h3 id="h2-500920c06-0009">Should You Use Type Hinting?</h3>
<p class="BodyFirst">Type hinting is entirely optional, and there are cases for it and against it. Some argue that it clutters up the code, impairing the natural readability that Python attained through dynamic typing. Others see it as a much-needed tool for mitigating the bugs made possible through the lack of static typing.</p>
<p>In practice, you don’t need to make a wholesale “use or don’t use” decision. Because type hinting is optional, you can use it in cases where it improves the readability and stability of the code and skip it in cases where it doesn’t. Even within a function, you can define a type hint for one parameter and omit it for the next.</p>
<p>Ultimately, the decision is up to you and your team alone. Only you know if and when type hints will be helpful. In short, <em>know thine own project</em>.</p>
<p>Since this book focuses on idiomatic Python above all else, and since type hinting is entirely optional, I won’t use it in any future examples.</p>
<h2 id="h1-500920c06-0013">Wrapping Up</h2>
<p class="BodyFirst">I hope you come away from this chapter with a newfound appreciation for functional programming in the Python language. Even when the paradigm is not embraced wholesale, its concepts and guidelines inform Pythonic code.</p>
<p>I’ll still apply functional concepts as I move into object-oriented programming in the next chapter. I’ve found that, when combined correctly, these paradigms interact in surprisingly positive ways.</p>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="149" id="Page_149"/>7</span><br/>
<span class="ChapterTitle">Objects and Classes</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="406" height="406"/>
</figure>
<p class="ChapterIntro">Objects are the bread and butter of many a programmer. Python makes full use of objects, even to the point of inspiring the mantra, “Everything is an object.” However, if you’ve worked with classes and objects in any other language, Python’s take may surprise you.</p>
<p><em>Object-oriented programming</em> (or <em>OOP</em>) is a paradigm in which data and its corresponding logic is organized into objects. If you’re familiar with such languages as Java, C++, Ruby, and C#, you’re well acquainted with these concepts.</p>
<p>Yet, object-oriented programming in Python is not mutually exclusive with functional programming; in fact, the two paradigms work very well together.</p>
<p>In this chapter, I’ll cover the essentials of object-oriented programming in Python: creating classes with attributes, modules, and properties. I’ll demonstrate adding various behaviors via special methods, and I’ll wrap up with a summary of the situations in which classes are the most useful.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><span epub:type="pagebreak" title="150" id="Page_150"/>Theory Recap: Object-Oriented Programming</h2>
<p class="BoxBodyFirst">Python uses class-based, object-oriented programming, so that’s what I discuss herein. If you’re coming from a class-based, object-oriented language like Java or C++, this section won’t give you any useful insights. You can skip right to the “Declaring a Class” section.</p>
<p>Otherwise, even if you’ve used objects and classes in passing, I strongly recommend you hang in there with me. There’s a deep canyon of difference between “coding with objects” and object-oriented programming.</p>
<p>In object-oriented programming, code is organized into classes, from which you create objects. A <em>class</em> is a sort of blueprint for creating one or more objects, which are known as <em>instances</em> in Python. Imagine you have a blueprint for a house; although you create one blueprint, it can be used to build many separate houses. Each of those houses is structurally identical, but with different contents.</p>
<p>Objects are composed of <em>member variables</em> and <em>member functions</em>, which are known respectively as <em>attributes</em> and <em>methods</em> in Python. More broadly, an instance has data in the form of attributes, and it has methods that work on that data.</p>
<p>The purpose of a class is <em>encapsulation</em>, which means two things:</p>
<ol>
<li value="1">The data and the functions that manipulate said data are bound together into one cohesive unit.</li>
<li value="2">The implementation of a class’s behavior is kept out of the way of the rest of the program. (This is sometimes referred to as a <em>black box</em>.)</li>
</ol>
<p>For example, a basic social media comment could be implemented as a class. It has specific attributes (data): the text of the comment and the number of likes the comment received. It also has specific methods that work on the attributes: editing and liking. The code that uses this class shouldn’t care about how the behavior is implemented, while the class’s methods allow the desired behavior to be invoked.</p>
<p>A method that exists purely to access an attribute is called a <em>getter</em>, while a method that modifies an attribute is called a <em>setter</em>. Particularly in Python, the existence of these methods should be justified by some form of data modification or data validation that the methods perform in conjunction with accessing or modifying the attribute. If a method does none of that and merely returns from or assigns to the attribute, it is known as a <em>bare</em> getter or setter, which is considered an anti-pattern, especially in Python.</p>
<p>With this <code>Comment</code> class, one particular comment (“My pet llama is a brilliant coder!!!”) is an instance of the class. You can have multiple instances of the same class, and each of those objects will contain distinct data; modifying the contents of one object will not affect any other instance of the same class.</p>
<p>There are two important relationships in object-oriented programming. The first is <em>composition</em>, wherein an object contains other objects. For example, you <span epub:type="pagebreak" title="151" id="Page_151"/>might create a <code>Like</code> class to store the username of the person liking the comment. A particular <code>Comment</code> instance might have a list of <code>Like</code> instances. This is also called a <em>has-a</em> relationship: a <code>Comment</code> <em>has a</em> <code>Like</code>.</p>
<p>The second type of relationship is <em>inheritance</em>, wherein a class inherits and builds on another existing class. For example, I might create an <code>AuthorComment</code> class that has the same attributes and methods as a <code>Comment</code>, along with some additional attributes or methods. This is called an <em>is-a</em> relationship: an <code>AuthorComment</code> <em>is a</em> <code>Comment</code>. Inheritance is a big topic, so I’ll cover it in depth in <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500920c07-0001">Declaring a Class</h2>
<p class="BodyFirst">Creating a new class is simple. I’ll create a class named <code>SecretAgent</code>:</p>
<pre><code>class SecretAgent:</code></pre>
<p class="CodeListingCaption"><a id="listing7-1">Listing 7-1</a>: Initializing a class</p>
<p>Below this, in the accompanying suite of the class declaration, I’d add any methods I want to include in the object. An object is known as an <em>instance</em> of a class in Python. I’ll cover this in detail shortly.</p>
<p>In Python, everything is an object, in that everything inherits from the <code>object</code> class. In Python 3, this inheritance from <code>object</code> is implicit, as seen in <a href="#listing7-1" id="listinganchor7-1">Listing 7-1</a>. In Python 2, you had to explicitly inherit from <code>object</code>, or from another class that inherits from <code>object</code>. (I cover inheritance in <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span>. You can take it for granted here.)</p>
<p>Here’s the <code>SecretAgent</code> class declaration again, this time explicitly inheriting from <code>object</code>, as Python 2 would have required:</p>
<pre><code>class SecretAgent(object):</code></pre>
<p class="CodeListingCaption"><a id="listing7-2">Listing 7-2</a>: Initializing a class with explicit inheritance</p>
<p>Listings 7-1 and 7-2 are functionally identical. Python developers really hate <em>boilerplate code</em>, which is code that is widely reused, with little or no modification. That is why Python 3 added the shorter technique seen in <a href="#listing7-1">Listing 7-1</a>. Unless you need to support Python 2, the shorter technique is preferred. You’ll encounter both ways often enough, so it’s important to know that they do the exact same thing in Python 3.</p>
<h3 id="h2-500920c07-0001">The Initializer</h3>
<p class="BodyFirst">A class often has an <em>initializer</em> method for defining the initial values of <em>instance attributes</em>, which are the member variables that exist in each instance. If your instance will have no instance attributes, you don’t need to define <code>__init__()</code>.</p>
<p><span epub:type="pagebreak" title="152" id="Page_152"/>I want each instance of <code>SecretAgent</code> to have a code name and a list of secrets. Here’s the initializer for my <code>SecretAgent</code> class, which has two instance attributes:</p>
<pre><code>class SecretAgent:

    def __init__(self, codename):
        self.codename = codename
        self._secrets = []</code></pre>
<p class="CodeListingCaption"><a id="listing7-3">Listing 7-3</a>: <em>secret_agent.py:1a</em></p>
<p>The initializer must have the name <code>__init__</code> to be recognized as an initializer, and it must accept at least one argument, conventionally called <code>self</code>. This <code>self</code> argument references the instance the method is acting on.</p>
<p>In this case, I also accept a second argument, <code>codename</code>, which I use as the initial value of one of my instance attributes. This <code>self.codename</code> attribute will be the code name of the secret agent.</p>
<p>Instance attributes are part of the class instance itself, so I must access them through the dot (<code>.</code>) operator on <code>self</code>. All instance attributes should be declared in the initializer method, rather than on the fly in other instance methods. Therefore, I’m also defining <code>self._secrets</code> as an empty list. This will be a list of secrets the particular secret agent (instance) is keeping.</p>
<p>Lastly, an initializer must never return a value via the <code>return</code> keyword; if it does, calling the initializer will raise a <code>TypeError</code>. However, you may use <code>return</code> by itself to explicitly exit the method, if you ever need to.</p>
<p>Whenever I create a new class instance, the initializer is automatically called. Here, I create three <code>SecretAgent</code> instances and provide arguments for the <code>codename</code> parameter of the initializer:</p>
<pre><code>from secret_agent import SecretAgent
mouse = SecretAgent("Mouse")
armadillo = SecretAgent("Armadillo")
fox = SecretAgent("Fox")</code></pre>
<p class="CodeListingCaption"><a id="listing7-4">Listing 7-4</a>: <em>secret_agent_usage.py:1</em></p>
<p>In this module, I import my <code>SecretAgent</code> class and create three new instances. You’ll notice that I didn’t need to pass anything to the first parameter, <code>self</code>. That’s taken care of behind the scenes. Instead, my first argument, <code>"Mouse"</code>, is passed to the second parameter of the initializer, <code>codename</code>. Each instance also has its own empty <code>_secrets</code> list.</p>
<h3 id="h2-500920c07-0002">The Constructor</h3>
<p class="BodyFirst">If you’re coming from C++, Java, or some similar language, you may expect to write a <em>constructor</em>—a function that constructs an instance of a class—or you may think that the initializer does the same thing as a constructor. In fact, Python 3 splits the duties of a typical constructor between the initializer <code>__init__()</code> and the constructor <code>__new__()</code>.</p>
<p><span epub:type="pagebreak" title="153" id="Page_153"/>In Python, the constructor <code>__new__()</code> takes care of actually creating the instance in memory. When you create a new instance, the constructor is automatically called first, followed by a call to the initializer. The constructor is the only method in the class to be called automatically before the object is created!</p>
<p>You don’t normally need to define a constructor; one is provided automatically. The only time you would create a constructor would be if you needed additional control over the process. However, to familiarize you with the syntax, I’ll write a very basic (and effectively pointless) constructor, which could go in a class definition:</p>
<pre><code>    def __new__(cls, *args, **kwargs):
        return super().__new__(cls, *args, **kwargs)</code></pre>
<p>The constructor always has the name <code>__new__</code>, and it implicitly accepts a class as its first parameter, <code>cls</code> (in contrast to the initializer, which accepts a class instance on <code>self</code>). Since the initializer accepts parameters, I also need to prepare the constructor to accept these on the constructor, so I use variadic arguments to capture these arguments and pass them on to the initializer parameters.</p>
<p>The constructor must return the class instance that gets created. Technically, I could return whatever I wanted here, but the expected behavior would almost certainly be to return an instance that has been instantiated from the <code>SecretAgent</code> class. To do that, I call the <code>__new__</code> function on the parent class, which you may recall (from <a href="#listing7-2" id="listinganchor7-2">Listing 7-2</a>) is <code>object</code>. (I’ll return to <code>super()</code> in <span class="xref" itemid="xref_target_Chapter 13">Chapter 13</span>. Don’t worry about understanding it now.)</p>
<p>In practice, if this is all your constructor needs to do, just omit it! Python automatically handles the constructor behavior if you don’t write any code for it. Only write a constructor when you need to control the behavior around instantiating the class instance itself. In any event, that scenario is rare; it is perfectly plausible that you will never write a constructor in your entire Python programming career.</p>
<h3 id="h2-500920c07-0003">The Finalizer</h3>
<p class="BodyFirst">The <em>finalizer</em> is called when a class instance finally reaches the end of its lifespan and is cleaned up by the garbage collector. It exists solely to handle any technically complex cleanup that your particular class may require. As with the constructor, you will seldom, if ever, need to write this function yourself. If you do, it’s important to understand: the finalizer is only called if the class instance (value) itself is cleaned up by the garbage collector!</p>
<p>If any references to the class instance still exist, the finalizer won’t be called; furthermore, depending on the implementation of Python you’re using, the garbage collector might not always clean up the class instance when you’d expect, if at all.</p>
<p>Therefore, only use the finalizer for code directly relating to garbage-collecting the class instance. It should never contain code that needs to be run as part of any other circumstance.</p>
<p><span epub:type="pagebreak" title="154" id="Page_154"/>Here’s a rather useless finalizer that prints a message when the garbage collector cleans up a <code>SecretAgent</code> class instance:</p>
<pre><code>    def __del__(self):
        print(f"Agent {self.codename} has been disavowed!")</code></pre>
<p class="CodeListingCaption"><a id="listing7-5">Listing 7-5</a>: <em>secret_agent.py:2</em></p>
<p>A finalizer always has the name <code>__del__</code> and accepts a single parameter, <code>self</code>. It must not return anything.</p>
<p>To demonstrate this finalizer, I’ll create and manually delete an instance. It is possible to delete a name, thereby unbinding it from its value, by using the <code>del</code> keyword. Given the <code>SecretAgent</code> class with that finalizer method, I can create and then delete a name referring to a class instance:</p>
<pre><code>from secret_agent import SecretAgent
weasel = SecretAgent("Weasel")
del weasel</code></pre>
<p class="CodeListingCaption"><a id="listing7-6">Listing 7-6</a>: <em>secret_agent_disavow.py</em></p>
<p>I create a new instance from the <code>SecretAgent</code> class and bind it to the name <code>weasel</code>. Then, I immediately delete the name by using the <code>del</code> operator. The name <code>weasel</code> is now undefined again. Coincidentally, because no references remain to the <code>SecretAgent</code> instance the name was bound to, that instance is cleaned up by the garbage collector, which first calls the finalizer.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic NOTE</h2><p class="BoxBodyFirst">This garbage collector behavior is implementation-specific to CPython. Other implementations of Python may behave differently.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p>Thus, running that code displays this output:</p>
<pre><code>Agent Weasel has been disavowed!</code></pre>
<p>Note that <code>del</code> only deletes the name, not the value! If you have multiple names bound to the same value, and if you <code>del</code> one of those names, then the other names and their values will be unaffected. In other words, <code>del</code> will not force the garbage collector to delete the objects.</p>
<h2 id="h1-500920c07-0002">Attributes</h2>
<p class="BodyFirst">All variables belonging to a class or instance are called <em>attributes</em>. Attributes belonging to the instance itself are called <em>instance attributes</em>, which are also sometimes referred to as <em>member variables</em>. Attributes belonging to the class itself are <em>class attributes</em>, which are also sometimes called <em>class variables</em>.</p>
<p>Many intermediate-level Python programmers don’t realize there is a significant difference between the two. I must admit, I spent the first few years of my Python development career using them utterly incorrectly!</p>
<h3 id="h2-500920c07-0004"><span epub:type="pagebreak" title="155" id="Page_155"/>Instance Attributes</h3>
<p class="BodyFirst">An <em>instance attribute </em>exists on the instance itself; its value is unique to the instance and is not available to other instances. All instance attributes should be declared in the class’s initializer.</p>
<p>Revisiting the <code>__init__()</code> method from <a href="#listing7-3" id="listinganchor7-3">Listing 7-3</a>, you’ll see I have two instance attributes:</p>
<pre><code>class SecretAgent:
    def __init__(self, codename):
        self.codename = codename
        self._secrets = []</code></pre>
<h3 id="h2-500920c07-0005">Class Attributes</h3>
<p class="BodyFirst">A <em>class attribute</em> exists on the class, instead of on an individual instance. In practice, this means that all related class instances effectively “share” a class attribute, although it would exist even without any instances.</p>
<p>Class attributes are declared at the top of the class, outside of any methods. Here, I add one class attribute directly into the suite of the class:</p>
<pre><code>class SecretAgent:

    <b>_codeword = ""</b>

    def __init__(self, codename):
        self.codename = codename
        self._secrets = []</code></pre>
<p class="CodeListingCaption"><a id="listing7-7">Listing 7-7</a>: <em>secret_agent.py:1b</em></p>
<p>The attribute <code>_codeword</code> belongs to the <code>SecretAgent</code> class. Typically, all class attributes are declared before any methods to make them easier to find, although this is just convention. The important part is that they are defined outside of any methods.</p>
<p>The class attribute can be accessed like this:</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">❶</span> SecretAgent._codeword = "Parmesan"
print(armadillo._codeword)  # prints "Parmesan"
print(mouse._codeword)      # prints "Parmesan"

<span class="CodeAnnotationHang" aria-label="annotation2">❷</span> mouse._codeword = "Cheese"
print(mouse._codeword)      # prints "Cheese"
print(armadillo._codeword)  # prints "Parmesan"</code></pre>
<p class="CodeListingCaption"><a id="listing7-8">Listing 7-8</a>: <em>secret_agent_usage.py:2a</em></p>
<p>I can access the class attribute <code>_codeword</code> directly through the class, or through any instances instantiated from the class. If the class attribute is rebound or mutated on the class itself <span class="CodeAnnotation" aria-label="annotation1">❶</span>, the changes will appear in all cases. However, if a value is assigned to the name on an instance, it will <span epub:type="pagebreak" title="156" id="Page_156"/>create an instance attribute with the same name <span class="CodeAnnotation" aria-label="annotation2">❷</span>, which shadows the class attribute on that instance, without affecting other instances.</p>
<p>Class attributes are particularly useful for constant values that the class’s methods use. I also find them more practical and maintainable than global variables in many cases, especially in GUI programming. For example, I often employ class attributes when I need to maintain a shared instance of a widget, like a window.</p>
<h2 id="h1-500920c07-0003">Scope-Naming Conventions</h2>
<p class="BodyFirst">If you’re coming from a language that has class scope, you may wonder why I haven’t mentioned it yet. Isn’t data hiding an important part of encapsulation? In fact, Python has no formal concept of data hiding. Instead, PEP 8 outlines a naming convention that indicates whether an attribute is safe to modify externally (public) or not (nonpublic).</p>
<p>While I talk a lot about attributes in this section, these naming conventions apply to methods as well.</p>
<h3 id="h2-500920c07-0006">Nonpublic</h3>
<p class="BodyFirst">By preceding a name with an underscore, I declare that the attribute <code>_secrets</code> is intended to be <em>nonpublic</em>, meaning it shouldn’t be modified (or, ideally, accessed) outside of the class. This is more of a social contract via style convention; I’m not actually hiding anything.</p>
<p>This may seem dangerous to many developers coming from languages with explicit scope, like Java, but it works out pretty well. As my pal “grym” likes to put it, “If you know why you shouldn’t stick a fork in a toaster, you are therefore qualified to stick a fork in a toaster.” In other words, if the client is going to disregard the underscore warning label, they probably know what they’re doing. (On the off-chance they don’t, they’re fully responsible for the consequences.) That little underscore hanging out after the dot operator is advertising “You really shouldn’t mess with me!”</p>
<h3 id="h2-500920c07-0007">Public</h3>
<p class="BodyFirst">The attribute <code>codename</code>, which does not start with an underscore, is intended to be <em>public</em>. It is okay for this attribute to be accessed or modified externally, as it won’t really affect the behavior of the class. Public attributes are preferable to writing a plain getter/setter pair of methods; the behavior is the same, but the result is cleaner, with less boilerplate.</p>
<p>If an attribute needs a custom getter or setter, one approach is to define the attribute as nonpublic and create a public <em>property</em>, which I’ll come back to shortly.</p>
<h3 id="h2-500920c07-0008">Name Mangling</h3>
<p class="BodyFirst">Python does offer <em>name mangling</em>, which rewrites an attribute or method name to prevent it from being shadowed by derived (inheriting) classes. <span epub:type="pagebreak" title="157" id="Page_157"/>This provides a sort of weak form of data hiding. It can also be useful for an added level of forewarning: “No, <em>really</em>, if you mess with this attribute, terrible things will happen!”</p>
<p>To mark an attribute (or method) for name mangling, precede the name with two underscores (<code>__</code>), like this:</p>
<pre><code>class Message:

    def __init__(self):
        self.__format = "UTF-8"</code></pre>
<p class="CodeListingCaption"><a id="listing7-9">Listing 7-9</a>: <em>message.py:1</em></p>
<p>The <code>__format</code> attribute will be name mangled, so accessing it externally in the ordinary manner will not work:</p>
<pre><code>msg = Message()
print(msg.__format)  # AttributeError</code></pre>
<p class="CodeListingCaption"><a id="listing7-10">Listing 7-10</a>: <em>message.py:2</em></p>
<p>This will raise an <code>AttributeError</code> because the <code>msg</code> instance does not have an attribute named <code>__format</code>; the name of that attribute was mangled. Be aware that name mangling is <em>not</em> a true form of data hiding! It is still perfectly possible to access a name-mangled attribute:</p>
<pre><code>print(msg._Message__format)</code></pre>
<p class="CodeListingCaption"><a id="listing7-11">Listing 7-11</a>: <em>message.py:3</em></p>
<p>The name-mangling pattern is predictable: an underscore, the name of the class, and then the name of the attribute, with its two leading underscores.</p>
<h3 id="h2-500920c07-0009">Public, Nonpublic, or Name Mangled?</h3>
<p class="BodyFirst">When deciding whether to make an attribute public or nonpublic, I ask myself one question: could changing this attribute externally cause unexpected or negative behavior in the class? If the answer is yes, I make the attribute nonpublic by preceding it with an underscore. If the answer is no, I leave the attribute public. It is up to the coder using the class to respect the rules or suffer the consequences.</p>
<p>As to name mangling, in practice, I very rarely employ this pattern. I reserve it only for those cases where (a) I need to avoid a naming conflict in the context of inheritance or (b) external access of the attribute will have exceptionally horrific effects on the behavior of the class, and thus, an extra degree of warning is justified.</p>
<p>Always remember that Python does not have private class scope. Truly secret data should be properly encrypted, not just concealed from your API. There are also no optimization benefits to private class scope, unlike in languages like Java, since all attribute lookups occur at runtime.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2><span epub:type="pagebreak" title="158" id="Page_158"/>Pedantic NOTE</h2><p class="BoxBodyFirst">There are a few hacker-y ways to achieve a form of true data hiding, but they’re too complex or impractical for regular usage.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500920c07-0004">Methods</h2>
<p class="BodyFirst">A class is nothing without its methods, which make encapsulation possible. There are three distinct types of methods: instance methods, class methods, and static methods.</p>
<h3 id="h2-500920c07-0010">Instance Methods</h3>
<p class="BodyFirst"><em>Instance methods</em> are your run-of-the-mill methods, which exist on the instance itself. The first parameter, conventionally named <code>self</code>, provides access to the instance attributes of the instance.</p>
<p>Here, I add an instance method to my <code>SecretAgent</code> class:</p>
<pre><code>    def remember(self, secret):
        self._secrets.append(secret)</code></pre>
<p class="CodeListingCaption"><a id="listing7-12">Listing 7-12</a>: <em>secret_agent.py:3</em></p>
<p>Besides the required first parameter, the instance method accepts a second parameter, <code>secret</code>, which is appended to the list bound to the instance attribute <code>_secrets</code>.</p>
<p>I call this method on the instance, using the dot operator:</p>
<pre><code>mouse.remember(("42.864025, -72.568511"))</code></pre>
<p class="CodeListingCaption"><a id="listing7-13">Listing 7-13</a>: <em>secret_agent_usage.py:2b</em></p>
<p>The dot operator implicitly passes <code>mouse</code> to the <code>self</code> parameter, so my first argument, the tuple of coordinates (notice the extra set of parentheses), is passed to the second parameter, <code>secret</code>, on the <code>remember()</code> method.</p>
<h3 id="h2-500920c07-0011">Class Methods</h3>
<p class="BodyFirst">Like class attributes, <em>class methods</em> belong to the class, instead of to the instances instantiated from the class. These are useful for working with class attributes.</p>
<p>Back in <a href="#listing7-7" id="listinganchor7-7">Listing 7-7</a>, I defined<code> _codeword</code> as a class attribute so all <code>SecretAgent</code> instances would be aware of the code word; it’s something all agents should have in common. I need a way to inform all the agents at once of the new code word, so I’ll add a class method, <code>inform()</code>, which will modify the <code>_codeword</code> class attribute:</p>
<pre><code>    @classmethod
    def inform(cls, codeword):
        cls._codeword = codeword</code></pre>
<p class="CodeListingCaption"><a id="listing7-14">Listing 7-14</a>: <em>secret_agent.py:4</em></p>
<p><span epub:type="pagebreak" title="159" id="Page_159"/>I precede a class method with the built-in <code>@classmethod</code> decorator. A class method receives the class as its first argument, so the first parameter is named <code>cls</code>. Class attributes like <code>_codeword</code> are accessed on the class passed to <code>cls</code>.</p>
<p>One of the benefits of this approach is that I don’t have to worry about whether I’m calling <code>inform()</code> on the class or on an instance. Because the method is a class instance, it will always access the class attribute on the class (<code>cls</code>), instead of the instance (<code>self</code>), and thus avoid accidentally shadowing <code>_codeword</code> on a single instance (see <a href="#listing7-8" id="listinganchor7-8">Listing 7-8</a>).</p>
<p>I don’t plan to include a getter for this attribute. After all, secret agents have to keep secrets!</p>
<p>To use this method, I would call something like this:</p>
<pre><code>SecretAgent.inform("The goose honks at midnight.")
print(mouse._codeword)  # prints "The goose honks at midnight."

fox.inform("The duck quacks at midnight.")
print(mouse._codeword)  # prints "The duck quacks at midnight."</code></pre>
<p class="CodeListingCaption"><a id="listing7-15">Listing 7-15</a>: <em>secret_agent_usage.py:3</em></p>
<p>I can call the <code>inform()</code> class method directly on the <code>SecretAgent</code> class, or on any <code>SecretAgent</code> instance, such as <code>fox</code>. The changes that <code>inform()</code> makes to the class attribute <code>_codeword</code> appear on the class itself and all its instances.</p>
<p>When calling the class method with the dot operator, the class is implicitly passed to the <code>cls</code> parameter. That parameter name is still just a convention; the <code>@classmethod</code> decorator is what ensures that the first argument is always the class, never the instance.</p>
<p>One awesome use of class methods is to provide alternative means of initializing instances. For example, the built-in integer class offers <code>int.from_bytes()</code>, which initializes a new <code>int</code> class instance, using a <code>bytes</code> value.</p>
<h3 id="h2-500920c07-0012">Static Methods</h3>
<p class="BodyFirst">A <em>static method</em> is a regular function defined within a class, which accesses neither the instance attributes nor the class attributes. The only difference between a static method and a function is that a static method belongs to the class for namespace reasons.</p>
<p>The main reason to write a static method comes up when your class offers some functionality that doesn’t need to access any of the class or instance attributes or methods. For example, you may write a static method for handling some particularly complicated algorithm that is critical to your class’s implementation. By including the static method in the class, you are indicating that the algorithm is part of the class’s self-contained implementation logic, even though it does not access any attributes or methods.</p>
<p><span epub:type="pagebreak" title="160" id="Page_160"/>I’ll add a static method to the <code>SecretAgent</code> class, which handles one thing all the agents would do the same, regardless of their data—answer questions:</p>
<pre><code>    @staticmethod
    def inquire(question):
        print("I know nothing.")</code></pre>
<p class="CodeListingCaption"><a id="listing7-16">Listing 7-16</a>: <em>secret_agent.py:5</em></p>
<p>I precede the static method with the <code>@staticmethod</code> decorator. You’ll notice that I don’t need to worry about a special first parameter, since the method doesn’t need access to any attributes. When this method is called on a class or on an instance, it only prints out the message, “I know nothing.”</p>
<h2 id="h1-500920c07-0005">Properties</h2>
<p class="BodyFirst"><em>Properties</em> constitute a special variety of instance method that allows you to write getters and setters that behave so it appears that you were directly accessing an instance attribute. Properties allow you to write a consistent interface, where you use the object directly through what appear to be its attributes.</p>
<p>It is preferable to use properties, instead of making the user remember whether to call a method or use an attribute. Using properties is also much more Pythonic than cluttering your class with bare getters and setters that don’t augment attribute access or modification.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic Note</h2>	<p class="BoxBodyFirst">The above assertion set off a heated debate among my colleagues, some of whom really hate properties. I’ve tried to address the counterpoints toward the end of this section, but I firmly believe my position above stands.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500920c07-0013">Setting Up the Scenario</h3>
<p class="BodyFirst">To demonstrate properties in action, I’ll expand on my <code>SecretAgent</code> class. Here’s the class so far. First, to set up, I’ll move it to a new file:</p>
<pre><code>class SecretAgent:

    _codeword = None

    def __init__(self, codename):
        self.codename = codename
        self._secrets = []

    def __del__(self):
        print(f"Agent {self.codename} has been disavowed!")

    def remember(self, secret):
        self._secrets.append(secret)

<span epub:type="pagebreak" title="161" id="Page_161"/>    @classmethod
    def inform(cls, codeword):
        cls._codeword = codeword

    @staticmethod
    def inquire(question):
        print("I know nothing.")</code></pre>
<p class="CodeListingCaption"><a id="listing7-17">Listing 7-17</a>: <em>secret_agent_property.py:1</em></p>
<p>Next, I will add one more class method to encrypt whatever message is passed to it, using an encryption system of my own devising. This method has nothing to do with properties per se, but I include it to make the example complete:</p>
<pre><code>    @classmethod
    def _encrypt(cls, message, *, decrypt=False):
        code = sum(ord(c) for c in cls._codeword)
        if decrypt:
            code = -code
        return ''.join(chr(ord(m) + code) for m in message)</code></pre>
<p class="CodeListingCaption"><a id="listing7-18">Listing 7-18</a>: <em>Using a property with no getter</em></p>
<p>The <code>_encrypt()</code> class method uses the <code>_codeword</code> class attribute to perform a basic substitution cipher encoding on a string <code>message</code>. I use <code>sum()</code> to find the sum of the Unicode code points (as integers) for each character in <code>_codeword</code>. I pass a character (string) to the <code>ord()</code> function, which returns the Unicode code point as an integer. This sum of code points is bound to <code>code</code>. (The odd-looking loop here is actually a generator expression, which I’ll cover in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>. You can take it for granted here that it calls <code>ord()</code> on each character in the string bound to <code>cls._codeword</code>.)</p>
<p>I use <code>code</code> to offset the Unicode code point of each character in the message. The <code>chr()</code> function returns the character associated with the given code point. I pass to it the sum of the current code point and <code>code</code>, for each character in the message. (Once again, I’m employing a generator expression here.)</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA Alert</h2>	<p class="BoxBodyFirst">Writing my own encrypt function is fine for the context of a silly example or toy program, where security doesn’t matter. If you have any data you truly need to keep secret, <em>NEVER</em> write your own encryption functions! An unbelievable amount of academic research, experimentation, and testing goes into engineering encryption algorithms. Stick with well-established, industry-accepted algorithms and tools.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500920c07-0014">Defining a Property</h3>
<p class="BodyFirst">A <em>property</em> behaves like an attribute, but it is made up of three instance methods: a <em>getter</em>, a <em>setter</em>, and a <em>deleter</em>. Remember that a property appears to be an ordinary attribute to the user of the class. Accessing the property calls the getter, assigning a value to it calls the setter, and deleting the property with the <code>del</code> keyword calls the deleter.</p>
<p><span epub:type="pagebreak" title="162" id="Page_162"/>Like an ordinary getter or setter method, a property might access or modify a nonpublic attribute, multiple attributes, or even no attributes at all. It all depends on what behavior you want.</p>
<p>Here, I’ll define a property called <code>secret</code> for my <code>SecretAgent</code> class, which will serve as the getter, setter, and deleter for my <code>_secrets</code> instance attribute. This approach will allow me to add logic, such as having the setter encrypt the assigned data before storing it in the <code>_secrets</code> attribute.</p>
<p>Before defining the property itself, I need to define the three functions that will make up the property. Technically, I can call them whatever I like, but the convention is to name them <code>getx</code>, <code>setx</code>, or <code>delx</code>, where <code>x</code> is the name of the property. I’m also making these nonpublic methods, since I want the client to use the property directly.</p>
<p>First, the getter:</p>
<pre><code>    def _getsecret(self):
        return self._secrets[-1] if self._secrets else None</code></pre>
<p class="CodeListingCaption"><a id="listing7-19">Listing 7-19</a>: <em>secret_agent_property.py:3</em></p>
<p>The getter, <code>_getsecret()</code>, accepts no parameters and should return the value of the property. In this example, I want the getter to return the last item stored in the list bound to the instance attribute <code>self._secrets</code>, or if the list is empty, to return <code>None</code>.</p>
<p>Next, the setter:</p>
<pre><code>    def _setsecret(self, value):
        self._secrets.append(self._encrypt(value))</code></pre>
<p class="CodeListingCaption"><a id="listing7-20">Listing 7-20</a>: <em>secret_agent_property.py:4</em></p>
<p>The setter, <code>_setsecret()</code>, accepts a single parameter, which receives the value being assigned to the property in the call (see <a href="#listing7-23" id="listinganchor7-23">Listing 7-23</a>). In this case, I assume this is some sort of string, which I run through the static method <code>_encode()</code> I defined earlier and then store in the list <code>self._secrets</code>.</p>
<p>Finally, here’s the deleter:</p>
<pre><code>    def _delsecret(self):
        self._secrets = []</code></pre>
<p class="CodeListingCaption"><a id="listing7-21">Listing 7-21</a>: <em>secret_agent_property.py:5</em></p>
<p>The <em>deleter</em>, <code>_delsecret()</code>, accepts no parameters and returns no value. This method is called when the property is deleted, either in the background, by the garbage collector, or explicitly, with <code>del secret</code>. In this example, when the property is deleted, I want the entire list of secrets to be cleared.</p>
<p>You actually don’t need to define a deleter if you have no need for special behavior when the decorator is deleted. Consider what you want to happen if <code>del</code> is called on your decorator, such as when you are deleting an associated attribute that the property controls; if you can’t think of anything, skip writing the deleter.</p>
<p><span epub:type="pagebreak" title="163" id="Page_163"/>Finally, I define the property itself:</p>
<pre><code>    secret = property(fget=_getsecret, fset=_setsecret, fdel=_delsecret)</code></pre>
<p class="CodeListingCaption"><a id="listing7-22">Listing 7-22</a>: <em>secret_agent_property.py:6a</em></p>
<p>This is defined on the class itself, outside of the <code>__init__()</code> method and after the functions that make it up. I pass the three methods to the <code>fget</code>, <code>fset</code>, and <code>fdel</code> keyword arguments, respectively (although you can also pass them as positional arguments, in that same order). I bind the property to the name <code>secret</code>, which becomes the property name.</p>
<p>The property can now be used as if it were an instance attribute:</p>
<pre><code>mouse = SecretAgent("Mouse")
mouse.inform("Parmesano")

print(mouse.secret)     # prints "None"
mouse.secret = "12345 Main Street"
print(mouse.secret)     # prints "ϗϘϙϚϛφϳЇЏДφϹКИЋЋК"
mouse.secret = "555-1234"
print(mouse.secret)     # prints "ϛϛϛϓϗϘϙϚ"

print(mouse._secrets)   # prints two values
del mouse.secret
print(mouse._secrets)   # prints empty list</code></pre>
<p class="CodeListingCaption"><a id="listing7-23">Listing 7-23</a>: <em>secret_agent_property.py:7a</em></p>
<p>Every time I try to retrieve the value of the property, the getter is called. Meanwhile, assigning a value to the property calls the setter. There’s no need to remember and explicitly call dedicated getter or setter methods; I treat the property like an attribute.</p>
<p>You’ll recall that the deleter for <code>secrets</code> clears the contents of the <code>_secrets</code> list. Just before deleting the property, the list contains two secrets. After deleting, the list is empty.</p>
<p>It is not necessary to define all three parts of the property. For example, I don’t want the <code>secret</code> property to even have a getter, so I can remove <code>_getsecret()</code> from my class code. Secret agents shouldn’t share their secrets, after all.</p>
<pre><code>    def _setsecret(self, value):
        self._secrets.append(self._encrypt(value))

    def _delsecret(self):
        self._secrets = []

    secret = property( <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> fset=_setsecret, fdel=_delsecret)</code></pre>
<p class="CodeListingCaption"><a id="listing7-24">Listing 7-24</a>: A secret property with no getter</p>
<p><span epub:type="pagebreak" title="164" id="Page_164"/>Because I don’t pass an argument to <code>fget</code>, the default value of <code>None</code> is used instead <span class="CodeAnnotation" aria-label="annotation1">❶</span>. This property has a setter and a deleter, but no getter.</p>
<p>As a result, I can assign to <code>secret</code>, but I can’t access the value:</p>
<pre><code>mouse = SecretAgent("Mouse")
mouse.inform("Parmesano")

mouse.secret = "12345 Main Street"
mouse.secret = "555-1234"

print(mouse.secret)  # AttributeError</code></pre>
<p class="CodeListingCaption"><a id="listing7-25">Listing 7-25</a>: <em>Using a property with no getter</em></p>
<p>Assigning values to <code>mouse.secret</code> works as before, since that calls the setter.</p>
<p>However, attempting to access the value throws an <code>AttributeError</code>. I could instead have written a getter for secrets that always returned <code>None</code>, but the client would have to remember that it returned this useless value. Recall The Zen of Python:</p>
<blockquote class="blockquote">
<p class="Blockquote">Errors should never pass silently.</p>

<p class="Blockquote">Unless explicitly silenced.</p></blockquote>
<p>If a particular usage is not desired, especially when it comes to designing a class or interface, the usage should <em>explicitly fail</em>.</p>
<h3 id="h2-500920c07-0015">Property with Decorators</h3>
<p class="BodyFirst">Creating a property is easy enough, but the approach to implementing it that I’ve shown thus far doesn’t really feel very Pythonic, because I have to rely on my method names to remind me that they’re part of a property. Thankfully, there’s another way.</p>
<p>Python offers a cleaner approach to defining properties: with decorators. There are two approaches to this technique.</p>
<h4 id="h3-500920c07-0001">Approach 1: property() and Decorators</h4>
<p class="BodyFirst">The first approach is to still employ the <code>property()</code> function but use decorators to denote the associated methods. The chief benefit of this approach is the added readability, and it is mainly used when the getter will be omitted. I can use the name of the property as the method name and rely on the decorator to clarify its role.</p>
<p>Here’s my rewritten code for the <code>secret</code> property, using this approach:</p>
<pre><code>    secret = property<b>()</b></code></pre>
<p class="CodeListingCaption"><a id="listing7-26">Listing 7-26</a>: <em>secret_agent_property.py:3b</em></p>
<p><span epub:type="pagebreak" title="165" id="Page_165"/>In this approach, I define <code>secret</code> as a property before writing its methods. I pass no arguments to <code>property()</code>, so all three functions default to <code>None</code>. Next, I add the getter:</p>
<pre><code>    <b>@secret.getter</b>
    def <b>secret</b>(self):
        return self._secrets[-1] if self._secrets else None</code></pre>
<p class="CodeListingCaption"><a id="listing7-27">Listing 7-27</a>: <em>secret_agent_property.py:4b</em></p>
<p>My getter method now must have the same name as the property, <code>secret</code>. If it doesn’t, it will fail with an <code>AttributeError</code> when the getter is first called, rather than when the class is created. The method is preceded by the decorator <code>@secret.getter</code>. This designates it as the getter for the property, just as if I had passed it to <code>property(fget=)</code>.</p>
<p>Here’s the setter:</p>
<pre><code>    <b>@secret.setter</b>
    def <b>secret</b>(self, value):
        self._secrets.append(self._encrypt(value))</code></pre>
<p class="CodeListingCaption"><a id="listing7-28">Listing 7-28</a>: <em>secret_agent_property.py:5b</em></p>
<p>Similarly, the setter method must share its name with the property it relates to, and it is preceded by the decorator <code>@secret.setter</code>.</p>
<p>Finally, the deleter:</p>
<pre><code>    <b>@secret.deleter</b>
    def <b>secret</b>(self):
        self._secrets = []</code></pre>
<p class="CodeListingCaption"><a id="listing7-29">Listing 7-29</a>: <em>secret_agent_property.py:6b</em></p>
<p>Similar to the getter and setter, the deleter is preceded by the decorator <code>@secret.deleter</code>.</p>
<p>This version works as is, but there is an even better technique.</p>
<h4 id="h3-500920c07-0002">Approach 2: Decorators Without property()</h4>
<p class="BodyFirst">The second approach to declaring a property with decorators is even shorter, and it is the most commonly used. This approach is preferred when defining a property that has a getter.</p>
<p>If you have defined a getter, you don’t have to explicitly create and assign a <code>property()</code>. Instead, the decorator <code>@property</code> can be applied to the getter:</p>
<pre><code>    <b>@property</b>
    def secret(self):
        return self._secrets[-1] if self._secrets else None

    @secret.setter
    def secret(self, value):
        self._secrets.append(self._encrypt(value))

<span epub:type="pagebreak" title="166" id="Page_166"/>    @secret.deleter
    def secret(self):
        self._secrets = [] </code></pre>
<p>I precede the getter function with the decorator <code>@property</code>, instead of <code>@secret.getter</code>, which creates a property with the same name as the method. Since this defines the property <code>secret</code>, I don’t need <code>secret = property()</code> anywhere in my code.</p>
<p>Bear in mind, this shortcut only works with the getter method. The setter and deleter must be defined in the same manner as before.</p>
<p>As before, I can omit any of the three methods if their behavior is not desired. For example, if I don’t want <code>secret</code> to be readable, I omit the getter, so my full property code looks like this:</p>
<pre><code>  <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> secret = property()

    @secret.setter
    def secret(self, value):
        self._secrets.append(self._encrypt(value))

    @secret.deleter
    def secret(self):
        self._secrets = []</code></pre>
<p>Because I don’t have a getter, I must explicitly declare my property up front <span class="CodeAnnotation" aria-label="annotation1">❶</span>. In this version, assignment and deletion of <code>secret</code> works as before, but accessing the value raises an <code>AttributeError</code>.</p>
<h3 id="h2-500920c07-0016">When Not to Use Properties</h3>
<p class="BodyFirst">There’s some debate about when to use properties, versus traditional getter and setter methods. One of the chief drawbacks of properties is that they conceal that some calculation or processing is being performed upon assignment, which the client might not expect. This especially becomes a problem if this processing is particularly long or complicated, such that a client may need to run it concurrently with <code>async </code>or threads (see Chapters<span class="xref" itemid="xref_target_ 16"> 16</span> and <span class="xref" itemid="xref_target_17">17</span>); you cannot run an assignment concurrently with the same ease as running a method concurrently.</p>
<p>You must also consider the expected behavior of an assignment. When a value is directly assigned to an attribute, you would typically expect the same value to be retrievable <em>from</em> that attribute. In reality, depending on how you wrote your properties, the value might be transformed when assigned or accessed. You’ll need to take this client expectation into consideration when designing your class.</p>
<p>Some camps believe properties should only be used as a way of deprecating attributes that used to be public or that have been removed entirely. Others, like myself, find properties useful as replacements for otherwise relatively simplistic getters and setters that still involve more logic than plain assignment and access.</p>
<p><span epub:type="pagebreak" title="167" id="Page_167"/>In any case, properties are some of those cool features of Python that are all too easy to misuse or misapply. Carefully consider the implications of properties, public attributes, or methods in your specific case. Take the occasion to consult the advice of other experienced Python developers, such as in the Libera.Chat IRC <code>#python</code> channel. (If you want to debate the most Pythonic general position on properties, though, bring a helmet.)</p>
<h2 id="h1-500920c07-0006">Special Methods</h2>
<p class="BodyFirst">Special methods are my favorite part of Python object-oriented programming. I’m trembling a little with excitement right now (or maybe I had too much coffee). <em>Special methods</em>, sometimes called <em>magic methods</em>, allow you to add support to your classes for virtually any Python operator or built-in command!</p>
<p>Special methods are also colloquially known as <em>dunder methods</em>—which is short for “<b><i>d</i></b>ouble <b><i>under</i></b>score”—because they begin and end with two underscore characters (<code>__</code>). You’ve already seen three examples of special methods: <code>__init__()</code>, <code>__new__()</code>, and <code>__del__()</code>. The Python language defines about a hundred special methods, most of which are documented at <a href="https://docs.python.org/3/reference/datamodel.html" class="LinkURL">https://docs.python.org/3/reference/datamodel.html</a>. I’ll cover a number of the most common ones here. In future chapters, I’ll discuss other special methods as they become relevant. I also list all the special methods in Python in Appendix A.</p>
<h3 id="h2-500920c07-0017">Scenario Setup</h3>
<p class="BodyFirst">For the examples in this section, I’ll use a new class, <code>GlobalCoordinates</code>, which will store a global coordinate as latitude and longitude. This class is defined as follows:</p>
<pre><code>import math
class GlobalCoordinates:

    def __init__(self, *, latitude, longitude):

        self._lat_deg = latitude[0]
        self._lat_min = latitude[1]
        self._lat_sec = latitude[2]
        self._lat_dir = latitude[3]

        self._lon_deg = longitude[0]
        self._lon_min = longitude[1]
        self._lon_sec = longitude[2]
        self._lon_dir = longitude[3]

    @staticmethod
    def degrees_from_decimal(dec, *, lat):
        if lat:
            direction = "S" if dec &lt; 0 else "N"
        else:
            direction = "W" if dec &lt; 0 else "E"
        dec = abs(dec)
        degrees = int(dec)
<span epub:type="pagebreak" title="168" id="Page_168"/>        dec -= degrees
        minutes = int(dec * 60)
        dec -= minutes / 60
        seconds = round(dec * 3600, 1)
        return (degrees, minutes, seconds, direction)

    @staticmethod
    def decimal_from_degrees(degrees, minutes, seconds, direction):
        dec = degrees + minutes/60 + seconds/3600
        if direction == "S" or direction == "W":
            dec = -dec
        return round(dec, 6)

    @property
    def latitude(self):
        return self.decimal_from_degrees(
            self._lat_deg, self._lat_min, self._lat_sec, self._lat_dir
        )

    @property
    def longitude(self):
        return self.decimal_from_degrees(
            self._lon_deg, self._lon_min, self._lon_sec, self._lon_dir
        )</code></pre>
<p class="CodeListingCaption"><a id="listing7-30">Listing 7-30</a>: <em>global_coordinates.py:1</em></p>
<p>You can probably work out what’s going on here, based on the knowledge you have so far. The class <code>GlobalCoordinates</code> converts and stores a latitude and longitude as tuples of degrees, minutes, seconds, and a string literal representing a cardinal direction.</p>
<p>I chose to create this particular class because its data lends itself well to a healthy subset of the special methods I’ll cover.</p>
<h3 id="h2-500920c07-0018">Conversion Methods</h3>
<p class="BodyFirst">There are many ways to represent the same data, and most clients will expect to be able to convert an object containing data to any Python primitive type that makes sense. For example, global coordinates could be expressed as strings or hashes. You should carefully consider what data types your class should support conversion to. Here, I cover some special methods for data conversions.</p>
<h4 id="h3-500920c07-0003">Canonical String Representation: __repr__()</h4>
<p class="BodyFirst">When writing a class, it is considered good practice to define, at minimum, the <code>__repr__()</code> instance method, which returns the <em>canonical string representation</em> of the object. This string representation should ideally contain all the data necessary to create another class instance with the same contents.</p>
<p><span epub:type="pagebreak" title="169" id="Page_169"/>If I don’t define a <code>__repr__()</code> instance method for <code>GlobalCoordinates</code>, Python falls back on its default version for objects, which is pretty uselessly underwhelming. I’ll create an instance of <code>GlobalCoordinates</code> and print this default representation via <code>repr()</code>:</p>
<pre><code>from global_coordinates import GlobalCoordinates
nsp = GlobalCoordinates(latitude=(37, 46, 32.6, "N"),
                        longitude=(122, 24, 39.4, "W"))
print(repr(nsp))</code></pre>
<p class="CodeListingCaption"><a id="listing7-31">Listing 7-31</a>: <em>global_coordinates_usage.py:1</em></p>
<p>Running that prints out the following canonical string representation:</p>
<pre><code>&lt;__main__.GlobalCoordinates object at 0x7f61b0c4c7b8&gt;</code></pre>
<p>Not good for much, is it? Instead, I’ll define my own <code>__repr__()</code> instance method for the class:</p>
<pre><code>    def __repr__(self):
        return (
            f"&lt;GlobalCoordinates "
            f"lat={self._lat_deg}°{self._lat_min}'"
            f"{self._lat_sec}\"{self._lat_dir}  "
            f"lon={self._lon_deg}°{self._lon_min}'"
            f"{self._lon_sec}\"{self._lon_dir}&gt;"
        )</code></pre>
<p class="CodeListingCaption"><a id="listing7-32">Listing 7-32</a>: <em>global_coordinates.py:2</em></p>
<p>I return a string containing all the information needed to recreate the instance: the class name, the latitude, and the longitude.</p>
<p>Rerunning the code in <a href="#listing7-31" id="listinganchor7-31">Listing 7-31</a> now produces more useful information:</p>
<pre><code>&lt;GlobalCoordinates lat=37°46'32.6"N  lon=122°24'39.4"W&gt;</code></pre>
<h4 id="h3-500920c07-0004">Human-Readable String Representation: __str__()</h4>
<p class="BodyFirst">The <code>__str__()</code> special method has a similar purpose to <code>__repr__()</code>, except that it’s meant to be human-readable, as opposed to the more technically inclined canonical representation, which is more useful for debugging.</p>
<p>If you don’t define <code>__str__()</code>, the <code>__repr__()</code> function will be used instead, but that wouldn’t be desirable in this example. The user should only see the pretty coordinates!</p>
<p>Here’s my <code>__str__()</code> instance method for <code>GlobalCoordinates</code>:</p>
<pre><code>    def __str__(self):
        return (
            f"{self._lat_deg}°{self._lat_min}'"
            f"{self._lat_sec}\"{self._lat_dir} "
<span epub:type="pagebreak" title="170" id="Page_170"/>            f"{self._lon_deg}°{self._lon_min}'"
            f"{self._lon_sec}\"{self._lon_dir}"
        )</code></pre>
<p class="CodeListingCaption"><a id="listing7-33">Listing 7-33</a>: <em>global_coordinates.py:3</em></p>
<p>Unlike with <code>__repr__()</code>, I omit all that boring technical information and focus on composing and returning a string representation a user might want to see.</p>
<p>This method is called when an instance of the class is passed to <code>str()</code>, although passing the instance directly to <code>print()</code> or as an expression in a formatted string will also invoke <code>__str__()</code>. For example:</p>
<pre><code>print(f"No Starch Press's offices are at {nsp}")</code></pre>
<p class="CodeListingCaption"><a id="listing7-34">Listing 7-34</a>: <em>global_coordinates_usage.py:2</em></p>
<p>That outputs the following:</p>
<pre><code>No Starch Press's offices are at 37°46'32.6"N 122°24'39.4"W</code></pre>
<p>Lovely and readable!</p>
<h4 id="h3-500920c07-0005">Unique Identifier (Hash): __hash__()</h4>
<p class="BodyFirst">The <code>__hash__()</code> method typically returns a <em>hash value</em>, which is an integer that is unique to the data within the class instance. This allows you to use instances of the class in certain collections, such as keys in a dictionary or values in a set (see <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>). It’s often helpful to write this method yourself, as the default behavior results in every class instance having a unique hash value, even if two instances contain the exact same data.</p>
<p>The <code>__hash__()</code> method should only depend on values that won’t change for the life of the instance! Several collections rely on these hash values <em>never changing</em>, but the value of a mutable object might change.</p>
<p>Here’s my <code>__hash__()</code> function for <code>GlobalCoordinates</code>:</p>
<pre><code>    def __hash__(self):
        return hash((
            self._lat_deg, self._lat_min, self._lat_sec, self._lat_dir,
            self._lon_deg, self._lon_min, self._lon_sec, self._lon_dir
        ))</code></pre>
<p class="CodeListingCaption"><a id="listing7-35">Listing 7-35</a>: <em>global_coordinates.py:4</em></p>
<p>I’ve taken the most common approach, which is to create a tuple containing all the important instance attributes and then to call <code>hash()</code> on the tuple, which returns the hash value of whatever is passed to it. I then return that hash value.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA Alert</h2>	<p class="BoxBodyFirst">According to the documentation, if you define <code>__hash__()</code>, you should also define <code>__eq__()</code> (see the “Comparison Methods” subsection).</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-500920c07-0006"><span epub:type="pagebreak" title="171" id="Page_171"/>Additional Conversion Special Methods</h4>
<p class="BodyFirst">Python has special methods for converting the data in the instance to other forms. It is up to you to decide which of these you will define on your class:</p>
<ul>
<li><code>__bool__()</code> should return <code>True</code> or <code>False</code>. If this isn’t defined, the automatic conversion to a boolean value will check whether <code>__len__()</code> returns a nonzero value (see <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>); otherwise, <code>True</code> will always be used.</li>
<li><code>__bytes__()</code> should return a <code>bytes</code> object (see <span class="xref" itemid="xref_target_Chapter 12">Chapter 12</span>).</li>
<li><code>__ceil__()</code> should return an <code>int</code> numeric value, usually resulting from rounding up a <code>float</code> value to the nearest integer.</li>
<li><code>__complex__()</code> should return a <code>complex</code> numeric value.</li>
<li><code>__float__()</code> should return a <code>float</code> numeric value.</li>
<li><code>__floor__()</code> should return an <code>int</code> numeric value, usually resulting from rounding down a <code>float</code> numeric value to the nearest integer.</li>
<li><code>__format__()</code> should accept a string representing the format specification (see <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>) and return a string representation of the instance, with the specification applied. How exactly you apply the specification is up to you.</li>
<li><code>__index__()</code> should return the same value as <code>__int__()</code>, which must also be defined if you write this method. The presence of this method indicates that the class should be considered a type of integer; you don’t have to throw away any data to get the integer value (lossless conversion).</li>
<li><code>__int__()</code> should return an <code>int</code> numeric value. You may simply have this function call <code>__ceil__()</code>, <code>__floor__()</code>, <code>__round__()</code>, or <code>__trunc__()</code>.</li>
<li><code>__round__()</code> should return an <code>int</code> numeric value, usually resulting from rounding a <code>float</code> numeric value up or down.</li>
<li><code>__trunc__()</code> should return an <code>int</code> numeric value, usually resulting from dropping the non-whole (decimal) part of a <code>float</code> numeric value.</li>
</ul>
<p>You only need to define the special methods that make sense for your class. In my case, <em>none</em> of these additional conversion methods are particularly suitable for a pair of global coordinates.</p>
<h3 id="h2-500920c07-0019">Comparison Methods</h3>
<p class="BodyFirst">Python has six comparison special methods that correspond to the six comparison operators in Python: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code>. Each one conventionally returns a boolean value.</p>
<p>If one of these special methods is called, but the method isn’t defined, the class instance will return the special value <code>NotImplemented</code> to alert Python that the comparison didn’t happen. This allows the language to decide the best response. In the case of comparisons with built-in types, <code>NotImplemented</code> will be coerced to the boolean value <code>False</code>, so as to not break algorithms that rely on those functions. In most other situations, a <code>TypeError</code> will be raised.</p>
<h4 id="h3-500920c07-0007"><span epub:type="pagebreak" title="172" id="Page_172"/>Equals: __eq__()</h4>
<p class="BodyFirst">The <code>__eq__()</code> special method is called by the equals (<code>==</code>) operator. I’ll define this method for my <code>GlobalCoordinates</code> class:</p>
<pre><code>    def __eq__(self, other):
        if not <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> isinstance(other, GlobalCoordinates):
            return <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> NotImplemented

        return (
            self._lat_deg == other._lat_deg
            and self._lat_min == other._lat_min
            and self._lat_sec == other._lat_sec
            and self._lat_dir == other._lat_dir
            and self._lon_deg == other._lon_deg
            and self._lon_min == other._lon_min
            and self._lon_sec == other._lon_sec
            and self._lon_dir == other._lon_dir
        )</code></pre>
<p class="CodeListingCaption"><a id="listing7-36">Listing 7-36</a>: <em>global_coordinates.py:5</em></p>
<p>All comparison special methods accept two parameters: <code>self</code> and <code>other</code>. These represent the operands on the left and right of the operator, so <code>a == b</code> would call <code>a.__eq__(b)</code>.</p>
<p>In the ongoing example, it would only make sense to compare two <code>GlobalCoordinates</code> class instances to one another. Comparing a <code>GlobalCoordinates</code> instance directly to an integer or a float wouldn’t be logical. Thus, this is one of those rare scenarios where type matters. I use <code>isinstance()</code> to ensure <code>other</code> is an instance of the <code>GlobalCoordinates</code> class (or a subclass thereof) <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If it is, I compare the instance attributes that constitute the latitude and longitude of one <code>GlobalCoordinates</code> instance to the same attributes of the other instance. I return <code>True</code> if they all match.</p>
<p>However, if <code>other</code> is of a different type, the comparison doesn’t happen, so I return the special value <code>NotImplemented</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>
<h4 id="h3-500920c07-0008">Not Equals: __ne__()</h4>
<p class="BodyFirst">The <code>__ne__()</code> special method corresponds to the not-equals (<code>!=</code>) operator. If undefined, a call to <code>__ne__()</code> <em>delegates</em> to <code>__eq__()</code>, just returning the opposite value that <code>__eq__()</code> does. If this is what you’re expecting, there’s no need to define <code>__ne__()</code>.</p>
<p>However, if there’s more complex logic to your not-equals comparison, it might make sense to define it.</p>
<h4 id="h3-500920c07-0009">Less Than and Greater Than: __lt__() and __gt__()</h4>
<p class="BodyFirst">The special methods <code>__lt__()</code> and <code>__gt__()</code> correspond to the less-than (<code>&lt;</code>) and greater-than (<code>&gt;</code>) operators, respectively. These two special methods are <em>reflections</em> of one another, meaning one operator in the pair can be substituted for the other. The expression <code>a &lt; b</code> calls <code>a.__lt__(b)</code>, but if that returns <code/><span epub:type="pagebreak" title="173" id="Page_173"/>NotImplemented, Python automatically flips the logic and calls <code>b.__gt__(a)</code>. Thus, if you’re only comparing instances of the same class, you can often get away with defining just one of the two special methods: usually, <code>__lt__()</code>. The same is true of <code>__le__()</code> and <code>__ge__()</code>, which correspond to less-than-or-equal-to (<code>&lt;=</code>) and greater-than-or-equal-to (<code>&gt;=</code>).</p>
<p>Be careful with this reflection, however! If you want to support comparing objects of different types, you should define both special methods in the pair.</p>
<p>In my particular example, there’s no clear logic for less than or greater than on two <code>GlobalCoordinates</code>, so I’m not defining any of those four special methods. Since I don’t define them, calls to any of them will return <code>NotImplemented</code>.</p>
<h3 id="h2-500920c07-0020">Binary Operator Support</h3>
<p class="BodyFirst">Special methods will also let you add support for <em>binary operators</em>—operators with two operands—to your class. If any of the methods are undefined, they will default to returning <code>NotImplemented</code>, which, in the context of an expression, will usually cause an error to be raised.</p>
<p>With <code>GlobalCoordinates</code>, I’ll only implement the subtraction operator (<code>-</code>) via the <code>__sub__()</code> method:</p>
<pre><code>    def __sub__(self, other):
        if not isinstance(other, GlobalCoordinates):
            return NotImplemented

        lat_diff = self.latitude - other.latitude
        lon_diff = self.longitude - other.longitude
        return (lat_diff, lon_diff)</code></pre>
<p class="CodeListingCaption"><a id="listing7-37">Listing 7-37</a>: <em>global_coordinates.py:6</em></p>
<p>As with comparison special methods, binary-operator special methods require two parameters: <code>self</code> and <code>other</code>. In my case, it’s logical for these operands to be <code>GlobalCoordinates</code> class instances; if <code>other</code> is of a different type, I return <code>NotImplemented</code>. Otherwise, I perform the math and return a tuple representing the difference between latitudes and longitudes in decimal degrees.</p>
<p>Because I’m only supporting subtraction of two <code>GlobalCoordinates</code> instances, I’m done. However, if I were supporting subtracting some other type, I’d have to also implement <code>__rsub__()</code>, which is the reflection of <code>__sub__()</code>. The expression <code>a - b</code> calls <code>a.__sub__(b)</code>, but if that returns <code>NotImplemented</code>, then Python tries to call <code>b.__rsub__(a)</code> behind the scenes. Because <code>a - b</code> is not the same as <code>b - a</code>, I must define those two methods separately; <code>b.__rsub__(a)</code> should return the value of <code>a - b</code>.</p>
<p>A third method, <code>__isub__()</code>, corresponds to the subtraction-augmented assignment operator (<code>-=</code>). If this method is undefined, that operator will fall back on the <code>__sub__()</code> and <code>__rsub__()</code> functions (<code>a -= b</code> becomes <code>a = a - b</code>), so you’d only need to define <code>__isub__()</code> if you needed some special behavior.</p>
<p><span epub:type="pagebreak" title="174" id="Page_174"/>All 13 binary operators, as well as <code>divmod()</code>, rely on the same three sorts of special methods, although there is no augmented assignment for <code>divmod()</code>. For your reference, <a href="#table7-1" id="tableanchor7-1">Table 7-1</a> outlines them all.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table7-1">Table 7-1</a>: Operator Special Methods</p></figcaption>
<table id="table-500920c07-0001" border="1">
<thead>
<tr>
<td><b>Operator</b></td>
<td><b>Method</b></td>
<td><b>Reflected method</b></td>
<td><b>Augmented method</b></td>
</tr>
</thead>
<tbody>
<tr>
<td>Addition (<code>+</code>)</td>
<td><code>__add__()</code></td>
<td><code>__radd__()</code></td>
<td><code>__iadd__()</code></td>
</tr>
<tr>
<td>Subtraction (<code>-</code>)</td>
<td><code>__sub__()</code></td>
<td><code>__rsub__()</code></td>
<td><code>__isub__()</code></td>
</tr>
<tr>
<td>Multiplication (<code>*</code>)</td>
<td><code>__mul__()</code></td>
<td><code>__rmul__()</code></td>
<td><code>__imul__()</code></td>
</tr>
<tr>
<td>Matrix multiplication (<code>@</code>)</td>
<td><code>__matmul__()</code></td>
<td><code>__rmatmul__()</code></td>
<td><code>__imatmul__()</code></td>
</tr>
<tr>
<td>Division (<code>/</code>)</td>
<td><code>__truediv__()</code></td>
<td><code>__rtruediv__()</code></td>
<td><code>__itruediv__()</code></td>
</tr>
<tr>
<td>Floor division (<code>//</code>)</td>
<td><code>__floordiv__()</code></td>
<td><code>__rfloordiv__()</code></td>
<td><code>__ifloordiv__()</code></td>
</tr>
<tr>
<td>Modulo (<code>%</code>)</td>
<td><code>__mod__()</code></td>
<td><code>__mod__()</code></td>
<td><code>__imod__()</code></td>
</tr>
<tr>
<td><code>divmod()</code></td>
<td><code>__divmod__()</code></td>
<td><code>__rdivmod__()</code></td>
<td>N/A</td>
</tr>
<tr>
<td>Power/exponent (<code>**</code>)</td>
<td><code>__pow__()</code></td>
<td><code>__rpow__()</code></td>
<td><code>__ipow()__</code></td>
</tr>
<tr>
<td>Left shift (<code>&lt;&lt;</code>)</td>
<td><code>__lshift__()</code></td>
<td><code>__rlshift__()</code></td>
<td><code>__ilshift__()</code></td>
</tr>
<tr>
<td>Right shift (<code>&gt;&gt;</code>)</td>
<td><code>__rshift__()</code></td>
<td><code>__rrshift__()</code></td>
<td><code>__irshift__()</code></td>
</tr>
<tr>
<td>Logical AND (<code>and</code>)</td>
<td><code>__and__()</code></td>
<td><code>__rand__()</code></td>
<td><code>__iand__()</code></td>
</tr>
<tr>
<td>Logical OR (<code>or</code>)</td>
<td><code>__or__()</code></td>
<td><code>__ror__()</code></td>
<td><code>__ior__()</code></td>
</tr>
<tr>
<td>Logical XOR (<code>xor</code>)</td>
<td><code>__xor__()</code></td>
<td><code>__rxor__()</code></td>
<td><code>__ixor__()</code></td>
</tr>
</tbody>
</table>
</figure>
<h3 id="h2-500920c07-0021">Unary Operator Support</h3>
<p class="BodyFirst">You can also add support for unary operators—those with only one operand. Unary-operator special methods accept one parameter: <code>self</code>. As before, all three default to returning <code>NotImplemented</code> if undefined.</p>
<p>In the case of my <code>GlobalCoordinates</code>, I’d like to override the invert operator (<code>~</code>) to return a <code>GlobalCoordinates</code> instance that is the opposite position on the globe, in terms of both latitude and longitude:</p>
<pre><code>    def __invert__(self):
        return GlobalCoordinates(
            latitude=self.degrees_from_decimal(-self.latitude, lat=True),
            longitude=self.degrees_from_decimal(-self.longitude, lat=False)
        )</code></pre>
<p class="CodeListingCaption"><a id="listing7-38">Listing 7-38</a>: <em>global_coordinates.py:7</em></p>
<p>Not much new there; I’m creating and returning a new instance of <code>GlobalCoordinates</code> from the negated current latitude and longitude.</p>
<p>The unary operators and their special methods are as follows:</p>
<ol class="none">
<li><code>__abs__()</code> handles the absolute value <code>abs()</code> operation function.</li>
<li><code>__invert__()</code> handles the invert/binary flip <code>~</code> operator.</li>
<li><span epub:type="pagebreak" title="175" id="Page_175"/><code>__neg__()</code> handles the negative-sign operator <code>-</code>.</li>
<li><code>__pos__()</code> handles the positive-sign operator <code>+</code>.</li>
</ol>
<h3 id="h2-500920c07-0022">Making Callable</h3>
<p class="BodyFirst">The last of the special methods I’ll cover in this chapter concerns making an instance <em>callable</em>, meaning the instance can be treated like a function. This special method, <code>__call__()</code>, can accept any number of arguments and return anything.</p>
<p>To wrap up my example, I’ll write a <code>__call__()</code> method that, when passed another <code>GlobalCoordinate</code> instance, will return the distance between the two in degrees, minutes, and seconds. This is a rather contrived example without obvious usage, however, and I wouldn’t have made <code>GlobalCoordinates</code> callable in real life. This merely completes my example:</p>
<pre><code>    def __call__(self, <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> other):
        EARTH_RADIUS_KM = 6371

        distance_lat = math.radians(other.latitude - self.latitude)
        distance_lon = math.radians(other.longitude - self.longitude)
        lat = math.radians(self.latitude)
        lon = math.radians(self.longitude)
        a = (
            math.sin(distance_lat / 2)
            * math.sin(distance_lat / 2)
            + math.sin(distance_lon)
            * math.sin(distance_lon / 2)
            * math.cos(lat)
            * math.cos(lon)
        )
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))

      <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> return c * EARTH_RADIUS_KM</code></pre>
<p class="CodeListingCaption"><a id="listing7-39">Listing 7-39</a>: <em>global_coordinates.py:8</em></p>
<p>Remember, <code>__call__()</code> can be written to accept any parameters you want. In my case, I accept another <code>GlobalCoordinate</code> class instance on <code>other</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then, I calculate the distance between the two points in kilometers and return that result as a float <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>
<p>Now, I can use any class instance of <code>GlobalCoordinate</code> in the same manner as a function:</p>
<pre><code>nostarch = GlobalCoordinates(latitude=(37, 46, 32.6, "N"),
                             longitude=(122, 24, 39.4, "W"))

psf = GlobalCoordinates(latitude=(45, 27, 7.7, "N"),
                        longitude=(122, 47, 30.2 "W"))

distance = nostarch(psf)
print(distance)  # 852.6857266443297</code></pre>
<p class="CodeListingCaption"><a id="listing7-40">Listing 7-40</a>: <em>global_coordinates_usage.py:3</em></p>
<p><span epub:type="pagebreak" title="176" id="Page_176"/>I define two instances of <code>GlobalCoordinate</code>, and then I calculate the distance between them by passing one instance to the other and storing the result. Indeed, the distance from No Starch Press’s offices to those of the Python Software Foundation is about 852 kilometers (529 miles).</p>
<h3 id="h2-500920c07-0023">More Special Methods: Looking Ahead</h3>
<p class="BodyFirst">There are several more special methods, but I’ll cover those in chapters where their functionality is relevant. Be on the lookout for special methods relating to <em>iterables</em> (<span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>), <em>context managers</em> (<span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span>), and <em>async</em> (<span class="xref" itemid="xref_target_Chapter 16">Chapter 16</span>). You can also refer to Appendix A for a complete list of special methods.</p>
<h2 id="h1-500920c07-0007">Class Decorators</h2>
<p class="BodyFirst">Classes support <em>decorators</em>, much like functions do. Class decorators wrap the instantiation of the class, allowing you to intervene in any number of ways: adding attributes, initializing another class containing an instance of the one being decorated, or performing some behavior immediately on the new object.</p>
<p>To demonstrate this, I need to set up for a decently believable example. I’ll create a class for <code>CoffeeRecipe</code> that contains the recipe for a particular coffee shop menu item. I’ll also create a separate class for a <code>CoffeeOrder</code>, which is a single person’s coffee order:</p>
<pre><code>class CoffeeOrder:

    def __init__(self, recipe, to_go=False):
        self.recipe = recipe
        self.to_go = to_go

    def brew(self):
        vessel = "in a paper cup" if self.to_go else "in a mug"
        print("Brewing", *self.recipe.parts, vessel)


class CoffeeRecipe:

    def __init__(self, parts):
        self.parts = parts


special = CoffeeRecipe(["double-shot", "grande", "no-whip", "mocha"])
order = CoffeeOrder(special, to_go=False)
order.brew()  # prints "Brewing double-shot grande no-whip mocha in a mug"</code></pre>
<p class="CodeListingCaption"><a id="listing7-41">Listing 7-41</a>: <em>coffee_order_decorator.py:1</em></p>
<p>By this point, you can probably figure out what’s going on here.</p>
<p>Next, I’m opening a drive-thru coffee shack that only does to-go orders, so I don’t want to have to specify each order as to go manually.</p>
<p><span epub:type="pagebreak" title="177" id="Page_177"/>Instead of writing a whole new <code>CoffeeOrder</code> class, I can define a class decorator that allows me to specify that all orders are to go (or not) up front:</p>
<pre><code>import functools
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> def auto_order(to_go):
    def decorator(cls):
        @functools.wraps(cls)
        def wrapper(*args, **kwargs):
         <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> recipe = cls(*args, **kwargs)
         <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> return (CoffeeOrder(recipe, to_go), recipe)
        return wrapper
  <span class="CodeAnnotationCode" aria-label="annotation4">❹</span> return decorator</code></pre>
<p class="CodeListingCaption"><a id="listing7-42">Listing 7-42</a>: <em>coffee_order_decorator.py:2</em></p>
<p>This decorator accepts the additional argument <code>to_go</code>, so I have to wrap the decorator itself in another function, creating a double closure <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The decorator is returned from the outermost function <span class="CodeAnnotation" aria-label="annotation4">❹</span>, but the decorator’s effective name will always come from the outermost function name. This pattern works with all decorators, not just class decorators.</p>
<p>The decorator, itself, will look pretty familiar, if you recall <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>. After initializing an instance of the wrapped class <span class="CodeAnnotation" aria-label="annotation2">❷</span>, I immediately use that instance to initialize a <code>CoffeeOrder</code> instance, which I return in a tuple with the <code>CoffeeShackRecipe</code> instance <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>
<p>I can now create a new <code>CoffeeShackRecipe</code> that inherits from <code>CoffeeRecipe</code> and adds nothing new, and then I can apply the decorator to make it always make orders to go:</p>
<pre><code>@auto_order(to_go=True)
class CoffeeShackRecipe(CoffeeRecipe):
    pass


order, recipe = CoffeeShackRecipe(["tall", "decaf", "cappuccino"])
order.brew()  # prints "Brewing tall decaf cappuccino in a paper cup"</code></pre>
<p class="CodeListingCaption"><a id="listing7-43">Listing 7-43</a>: <em>coffee_order_decorator.py:3</em></p>
<p>The only reason I created this new class is to extend it with the <code>@auto_order</code> decorator, without losing the ability to create <code>CoffeeRecipe</code> instances when I want them.</p>
<p>In the usage, you see that I can now specify a <code>CoffeeShackRecipe</code> as I would a <code>CoffeeRecipe</code>, but the <code>CoffeeShackRecipe</code> instance will return both a <code>CoffeeOrder</code> instance and a <code>CoffeeShackRecipe</code> instance. I call <code>brew()</code> on the <code>CoffeeOrder</code>. Neat trick, no?</p>
<h2 id="h1-500920c07-0008">Structural Pattern Matching with Objects</h2>
<p class="BodyFirst">Structural pattern matching, which was added in Python 3.10, supports matching objects in patterns by their attributes.</p>
<p><span epub:type="pagebreak" title="178" id="Page_178"/>For example, I might have a class that represents a pizza, and I might want to perform structural pattern matching based on attributes in a given <code>Pizza</code> object:</p>
<pre><code>class Pizza:

    def __init__(self, topping, second_topping=None):
        self.first = topping
        self.second = second_topping

order = Pizza("pepperoni", "mushrooms")

match order:
    case Pizza(first='pepperoni', second='mushroom'):
        print("ANSI standard pizza")
    case Pizza(first='pineapple'):
        print("Is this even pizza?")</code></pre>
<p class="CodeListingCaption"><a id="listing7-44">Listing 7-44</a>: <em>pattern_match_object.py:1a</em></p>
<p>In each pattern, I specify the object that I’m expecting the subject <code>order</code> to be—in this case, <code>Pizza</code>—and then I list the attributes of that object and the expected values thereof. For example, if <code>order.first</code> is <code>"pepperoni"</code> and <code>order.second</code> is <code>"mushroom"</code>, then I print <code>"ANSI standard pizza"</code>.</p>
<p>In the second case, you’ll see I don’t even need to specify an expected value for each attribute. If <code>order.first</code> is <code>"pineapple"</code>, then the message <code>"Is this even pizza?"</code> will be displayed, regardless of the second value. (However, I like pineapple on pizza! Sorry, not sorry.)</p>
<p>Capture patterns can come into play here, too. If the second topping is <code>"cheese"</code>, but the first is something else, I want to capture the first topping as <code>first</code>, so I can use the value in the case suite:</p>
<pre><code>#<var> --snip--</var>

match order:
  # <var>--snip--</var>
    case Pizza(first='pineapple'):
        print("Is this even pizza?")
<b>    case Pizza(first=first, second='cheese'):</b>
<b>        print(f"Very cheesy pizza with {first}.")</b></code></pre>
<p class="CodeListingCaption"><a id="listing7-45">Listing 7-45</a>: <em>pattern_match_object.py:1b</em></p>
<p>Here, if the value of <code>order.second</code> is <code>"cheese"</code>, then the value of <code>order.first</code> is captured as <code>first</code>, which I use in the message.</p>
<p>I’ll also use capture patterns to create a fallback case here:</p>
<pre><code>#<var> --snip--</var>

match order:
  # <var>--snip--</var>
<code>    case Pizza(first=first, second='cheese'):</code>
<code>        print(f"Very cheesy pizza with {first}.")</code>
<span epub:type="pagebreak" title="179" id="Page_179"/>    <b>case Pizza(first=first, second=second):</b>
<b>        print(f"Pizza with {first} and {second}.")</b></code></pre>
<p class="CodeListingCaption"><a id="listing7-46">Listing 7-46</a>: <em>pattern_match_object.py:1c</em></p>
<p>Here, if none of the preceding patterns match, then I capture both <code>order.first</code> and <code>order.second</code> and use them to compose a generic message about the pizza.</p>
<p>This works well if you don’t mind typing out the names of the attributes. However, there are times when this feels redundant. For example, if you have a <code>Point</code> class that represents a point in three-dimensional space, it would feel a bit tedious to spell out <em>x</em>, <em>y</em>, and <em>z</em> every time:</p>
<pre><code>class Point:
    def __init__(self, x, y, z):
        self.x_pos = x
        self.y_pos = y
        self.z_pos = z


point = Point(0, 100, 0)

match point:
    case Point(x_pos=0, y_pos=0, z_pos=0):
        print("You are here.")
    case Point(x_pos=0, y_pos=_, z_pos=0):
        print("Look up!")</code></pre>
<p class="CodeListingCaption"><a id="listing7-47">Listing 7-47</a>: <em>point.py:1a</em></p>
<p>That pattern feels pretty long for something, especially when most people would expect to specify a point in 3D space as <em>x, y, z</em>.</p>
<p>Instead of writing out the attributes every time, I can define the special <code>__match_args__</code> class attribute, which specifies how a pattern’s values map positionally to the object’s attributes:</p>
<pre><code>class Point:
<b>    __match_args__ = ('x_pos', 'y_pos', 'z_pos')</b>

    def __init__(self, x, y, z):
        self.x_pos = x
        self.y_pos = y
        self.z_pos = z


point = Point(0, 123, 0)

match point:
    case Point(<b>0, 0, 0</b>):
        print("You are here.")
    case Point(<b>0, _, 0</b>):
        print("Look up!")</code></pre>
<p class="CodeListingCaption"><a id="listing7-48">Listing 7-48</a>: <em>point.py:1b</em></p>
<p><span epub:type="pagebreak" title="180" id="Page_180"/>I define <code>__match_args__</code> as a tuple of strings representing the attributes I want to map to positional values in pattern matching on the object. That is, the first positional value in the pattern maps to <code>x_pos</code>, the second maps to <code>y_pos</code>, and so on. Now, I can shorten my patterns by omitting the names of the attributes.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic NOTE</h2>	<p class="BoxBodyFirst">The <code>__match_args__</code> class attribute is automatically defined on dataclasses (not discussed).</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500920c07-0009">Functional Meets Object Oriented</h2>
<p class="BodyFirst">As I’ve mentioned, functional and object-oriented programming can fit together very well. Here are the functional programming rules for methods (adapted slightly from the function rules in <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>):</p>
<ol class="decimal">
<li value="1">Every method should do one specific thing.</li>
<li value="2">A method’s implementation should never affect other methods, nor should it affect the behavior of the rest of the program.</li>
<li value="3">Avoid side effects! A method should only directly mutate attributes belonging to its class, and only when that behavior is an expected part of the method’s purpose.</li>
<li value="4">In general, methods shouldn’t have (or be affected by) state, other than the attributes belonging to its class. Providing the same input should always yield the same output, unless the method’s expected behavior dictates otherwise.</li>
</ol>
<p>To summarize all that in another way, the only state that methods should have is the attributes of their class or instance, and only when relying on that state is essential to the purpose of the method.</p>
<p>Don’t hesitate to use functional patterns in the context of object-oriented programming. Treat an instance like you would any other variable. Attributes should only be modified by their instance’s or class’s methods, called via the dot operator:</p>
<pre><code>thing.action()  # this can mutate attributes in thing</code></pre>
<p>When an object is passed to a function, it should not be mutated (no side effects):</p>
<pre><code>action(thing)  # should not modify thing; returns new value or object</code></pre>
<p>If you combine the rules of functional and object-oriented programming, your code will be much easier to maintain.</p>
<h2 id="h1-500920c07-0010"><span epub:type="pagebreak" title="181" id="Page_181"/>When to Use Classes</h2>
<p class="BodyFirst">Unlike with class-centric languages such as Java and C#, it is not always necessary to write classes in Python. An important part of object-oriented programming in Python is to know when to use classes and when <em>not</em> to.</p>
<h3 id="h2-500920c07-0024">Classes Aren’t Modules</h3>
<p class="BodyFirst">You shouldn’t use a class where a module will be sufficient. Python modules already allow you to organize variables and functions by purpose or category, so you don’t need to use classes in the same manner.</p>
<p>The purpose of a class is to bundle data with the methods responsible for accessing and modifying that data. Thus, your decision on whether to make a class should be based on the data. Do the attributes make sense as a cohesive object? Let the word <em>attribute</em> be the hint: is the data descriptive of the thing your object is attempting to represent?</p>
<p>Also, you should ensure that any methods included in the class directly relate to the attributes. In other words, think of methods as things the object can <em>do</em>. Any method that doesn’t fit this criteria doesn’t belong in the class.</p>
<p>Similarly, beware of how you structure classes. A <code>House</code> has a kitchen sink, but the attributes and methods relating to the kitchen sink belong in their own <code>KitchenSink</code> class, and an <em>instance</em> of said class belongs in the house. (This is a compositional relationship between the two classes.)</p>
<h3 id="h2-500920c07-0025">Single Responsibility</h3>
<p class="BodyFirst">One of the essential rules in object-oriented programming is the <em>single-responsibility principle</em>. Just like a function, a class should have a single, well-defined responsibility. A function <em>does</em> something, while a class <em>is</em> something.</p>
<p>Avoid writing <em>god classes</em>, which try to do many different things in one class. Not only are these bug prone and difficult to maintain, but they also make for a very confusing code structure.</p>
<h3 id="h2-500920c07-0026">Sharing State</h3>
<p class="BodyFirst">Class attributes and class methods allow you to write <em>static classes</em>, which provide one of the preferred ways to share state across multiple modules in your program. Static classes are cleaner and more predictable than global variables, and they are easier to write, maintain, and debug than the singleton design pattern. (And if you’ve never heard of singletons, all the better for you.)</p>
<p>The single-responsibility principle still applies here. For example, a static class containing current user preferences might make sense, but the current user profile shouldn’t be thrown into that same class.</p>
<h3 id="h2-500920c07-0027"><span epub:type="pagebreak" title="182" id="Page_182"/>Are Objects Right for You?</h3>
<p class="BodyFirst">Just because you <em>can</em> write your entire program with classes and objects doesn’t mean you <em>should</em>.</p>
<p>Instead, you should reserve classes and objects for what they’re best at: <em>encapsulation</em>. Remember:</p>
<ol class="none">
<li>Modules organize things by purpose and category.</li>
<li>Functions perform tasks with provided data (arguments) and return values.</li>
<li>Collections store cohesive sets of data, which are accessed predictably (see <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>).</li>
<li>Classes define objects, which contain attributes and related behaviors (methods).</li>
</ol>
<p>Take the time to select the right tools for the job. When you do this, you’ll find that classes and objects complement modules, functions (and functional programming), and collections.</p>
<h2 id="h1-500920c07-0011">Wrapping Up</h2>
<p class="BodyFirst">Depending on the language you come from, classes and objects are probably either your bread and butter or things you seldom use, if at all. In Python, you can’t get away from objects—everything is one, after all—but you do get to decide what role classes will play in your code.</p>
<p>In any case, whether you follow more traditional object-oriented programming techniques or favor a functional approach, Python classes provide a reliable way of organizing data. Properties make it possible to write getters and setters that look the same as accessing an ordinary attribute. Special methods even make it possible to create whole new data types that work with all of Python’s language features.</p>
<p>Objectively speaking, Python is one classy language.</p>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="183" id="Page_183"/>8</span><br/>
<span class="ChapterTitle">Errors and Exceptions</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="406" height="406"/>
</figure>
<p class="ChapterIntro">In many languages, exceptions are regarded as the archnemeses of programmers and the hallmarks of some degree of failure. Something, somewhere was used improperly! Python developers, on the other hand, recognize exceptions as friends that help write better code.</p>
<p>Python offers many familiar error-handling tools, but the way we use them may look different from what you’re used to. These tools can help you do more than clean up messes. You might even say, error handling in Python is “exceptional.”</p>
<p>I’ll start by demonstrating what exceptions look like in Python and how to read their accompanying messages. I’ll cover catching exceptions, handling them, and raising them. Then, I’ll show you how to leverage errors to control the flow of your program. Finally, I’ll give you a tour of the common exception types.</p>
<h2 id="h1-500920c08-0001"><span epub:type="pagebreak" title="184" id="Page_184"/>Exceptions in Python</h2>
<p class="BodyFirst">If case <em>exceptions</em>, which are sometimes called <em>errors</em> in Python, are unfamiliar to you, here’s the general definition:</p>
<blockquote class="blockquote">
<p class="Blockquote">exception: (computing) An interruption in normal processing, typically caused by an error condition, that can be handled by another part of the program. (Wiktionary)</p>
</blockquote>
<p>Let’s start with a seemingly innocuous program: a number-guessing game. I’m only using concepts introduced in previous chapters, so see if you can spot the bug before I point it out.</p>
<p>First, I create a function that selects a random number, which the player will have to try to guess:</p>
<pre><code>import random


def generate_puzzle(low=1, high=100):
    print(f"I'm thinking of a number between {low} and {high}...")
    return random.randint(low, high)</code></pre>
<p class="CodeListingCaption"><a id="listing8-1">Listing 8-1</a>: <em>number_guess.py:1</em></p>
<p>Next, I create a function that gets a guess from the user and outputs whether the number guessed was too high, too low, or correct:</p>
<pre><code>def make_guess(target):
    guess = int(input("Guess: "))

    if guess == target:
        return True

    if guess &lt; target:
        print("Too low.")
    elif guess &gt; target:
        print("Too high.")
    return False</code></pre>
<p class="CodeListingCaption"><a id="listing8-2">Listing 8-2</a>: <em>number_guess.py:2a</em></p>
<p>I return a boolean value to indicate whether the <code>guess</code> is correct or not.</p>
<p>The following function is responsible for running the game and tracking how many guesses the player has left:</p>
<pre><code>def play(tries=8):
    target = generate_puzzle()
    while tries &gt; 0:
        if make_guess(target):
            print("You win!")
            return

<span epub:type="pagebreak" title="185" id="Page_185"/>        tries -= 1
        print(f"{tries} tries left.")

    print(f"Game over! The answer was {target}.")</code></pre>
<p class="CodeListingCaption"><a id="listing8-3">Listing 8-3</a>: <em>number_guess.py:3</em></p>
<p>I call the <code>play()</code> function when the module is executed directly, thereby starting the game:</p>
<pre><code>if __name__ == '__main__':
    play()</code></pre>
<p class="CodeListingCaption"><a id="listing8-4">Listing 8-4</a>: <em>number_guess.py:4</em></p>
<p>If I test this game by playing it the normal way, everything seems to work as expected. Here’s my first playthrough:</p>
<pre><code>I'm thinking of a number between 1 and 100...
Guess: 50
Too low.
7 tries left.
Guess: 75
Too low.
6 tries left.
Guess: 90
Too high.
5 tries left.
Guess: 87
You win!</code></pre>
<p>Our first instinct as programmers is to test things politely. We have a subconscious sense about what will cause the code to break, and we inherently tiptoe around those possible errors. However, if you’ve done any meaningful testing, you know the value of “doing horrible things to your code,” as Stack Overflow cofounder Jeff Atwood says.</p>
<p>Or, as programmer Bill Sempf puts it:</p>
<blockquote class="blockquote">
<p class="Blockquote">QA Engineer walks into a bar. Orders a beer. Orders 0 beers. Orders 999999999 beers. Orders a lizard. Orders ‒1 beers. Orders a sfdeljknesv.</p>
</blockquote>
<p>So, proper testing of this code involves throwing input to it that it doesn’t expect or understand, like so:</p>
<pre><code>I'm thinking of a number between 1 and 100...
Guess: Fifty
Traceback (most recent call last):
  File "./number_guess.py", line 35, in &lt;module&gt;
    play()
  File "./number_guess.py", line 25, in play
    if make_guess(target):
<span epub:type="pagebreak" title="186" id="Page_186"/>  File "./number_guess.py", line 10, in make_guess
    guess = int(input("Guess: "))
ValueError: invalid literal for int() with base 10: 'Fifty'</code></pre>
<p class="CodeListingCaption"><a id="listing8-5">Listing 8-5</a>: Traceback from running <em>number_guess.py</em></p>
<p>Eww, a bug! My program can’t handle numbers spelled out as words. Clearly, I need to do something about this.</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic note</h2><p class="BoxBodyFirst">There’s another half to the above joke: “First real customer walks in and asks where the bathroom is. The bar bursts into flames, killing everyone.” In other words, don’t get stuck on testing only the obvious functionality.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500920c08-0002">Reading Tracebacks</h2>
<p class="BodyFirst">That block of output you receive when an error occurs is called the <em>traceback</em>, and it tells you what went wrong and where. It includes the details of the error that occurred, the line where it happened, and the entire <em>call stack</em>—which contains the function calls leading directly from the main function to the error. The entire call stack will always be displayed; it is up to you to determine the location of the coding mistake.</p>
<p>I recommend reading tracebacks from the bottom up. Let’s take apart that traceback I received in <a href="#listing8-5" id="listinganchor8-5">Listing 8-5</a>, piece by piece, starting from the final line:</p>
<pre><code>ValueError: invalid literal for int() with base 10: 'Fifty'</code></pre>
<p>This tells you what went wrong. Specifically, a <code>ValueError</code> was raised because the value <code>'Fifty'</code> was passed to the <code>int()</code> function. The <code>with base 10</code> part has to do with the default value of the <code>base</code> parameter. In other words, Python can’t convert the string <code>'Fifty'</code> to an integer using the <code>int()</code> function.</p>
<p>This last line of the traceback is the single-most important. Always read and completely understand it before moving forward with fixing the bug!</p>
<p>The two lines above the error tell you precisely where the error occurred: in file <code>./number_guess.py</code>, on line 10, in the <code>make_guess()</code> function:</p>
<pre><code>  File "./number_guess.py", line 10, in make_guess
    guess = int(input("Guess: "))</code></pre>
<p>Python even gives you the offending line in question, and sure enough, you can see the <code>int()</code> function wrapped around <code>input()</code>.</p>
<p>Sometimes, you can stop there and go fix the problem. In this case, the problem is right here. In other situations, the error may occur because of a mistake in the code further up in the call stack, such as passing bad data to a parameter. Even though I know that’s not the problem here, I’ll go up another step:</p>
<pre><code>  File "./number_guess.py", line 25, in play
    if make_guess(target):</code></pre>
<p><span epub:type="pagebreak" title="187" id="Page_187"/>You already know that the error is occurring in the <code>make_guess()</code> function, and that is being called from within <code>./number_guess.py</code>, on line 25, in the <code>play()</code> function. No problem here; the argument <code>target</code> had nothing to do with the error. Likewise, this part of the code can’t possibly have caused the error:</p>
<pre><code>  File "./number_guess.py", line 35, in &lt;module&gt;
    play()</code></pre>
<p>Now I’m at the top of the traceback. The <code>play()</code> function is being called on line 35 of <code>./number_guess.py</code>, and the call isn’t occurring inside of any function; rather it’s coming from the module scope, as indicated by <code>&lt;module&gt;</code>.</p>
<p>That first line is always the same, but it’s a useful reminder if you ever forget how to read a traceback properly:</p>
<pre><code>Traceback (most recent call last):</code></pre>
<p>The most recently executed code is always listed last! Thus, as I’ve said before, always read tracebacks from the bottom up.</p>
<h2 id="h1-500920c08-0003">Catching Exceptions: LBYL vs. EAFP</h2>
<p class="BodyFirst">In many languages, the common practice is to test the input before trying to convert it to an integer. This is known as the <em>Look Before You Leap (LBYL)</em> philosophy.</p>
<p>Python has a different approach, officially known as <em>Easier to Ask Forgiveness than Permission (EAFP)</em>. Instead of preventing errors, we embrace them, using <code>try</code> statements to handle exceptional situations.</p>
<p>I’ll rewrite my <code>make_guess()</code> function to use error handling:</p>
<pre><code>def make_guess(target):
    <b>guess = None</b>
    <b>while guess is None:</b>
        <b>try:</b>
            guess = int(input("Guess: "))
        <b>except ValueError:</b>
            <b>print("Enter an integer.")</b>

    if guess == target:
        return True

    if guess &lt; target:
        print("Too low.")
    elif guess &gt; target:
        print("Too high.")
    return False</code></pre>
<p class="CodeListingCaption"><a id="listing8-6">Listing 8-6</a>: <em>number_guess.py:2b</em></p>
<p><span epub:type="pagebreak" title="188" id="Page_188"/>I initially set the value of <code>guess</code> to <code>None</code>, so that as long as I don’t have something usable assigned to guess, I keep prompting the user for input. I use <code>None</code> instead of <code>0</code>, since <code>0</code> is still technically a valid integer.</p>
<p>On each iteration of the loop, in the context of <code>try</code>, I attempt to get the user input and convert it to an <code>int()</code>. If that conversion fails, <code>int()</code> will raise a <code>ValueError</code>, as you saw earlier.</p>
<p>If <code>ValueError</code> is raised, it can only mean that the user entered some non-numeric input, such as <code>'Fifty'</code> or an empty string. I catch that error and handle the situation by printing an error message. Because <code>guess</code> is still <code>None</code>, the entire loop repeats to prompt for input again.</p>
<p>If <code>int()</code> is successful, no further action is taken in this section of code, and I move on to the rest of the function. The so-called <em>happy path</em>, the one with no errors, is efficient.</p>
<p>To understand why the EAFP approach is the preferred error-handling philosophy, compare it to the LBYL strategy. Here’s the LBYL approach to confirming that the string only contains digits:</p>
<pre><code>def make_guess(target):
    guess = None
    while guess is None:
        guess = input()
        <b>if guess.isdigit():</b>
            guess = int(guess)
        <b>else:</b>
            print("Enter an integer.")
            guess = None

    if guess == target:
        return True

    if guess &lt; target:
        print("Too low.")
    elif guess &gt; target:
        print("Too high.")
    return False</code></pre>
<p class="CodeListingCaption"><a id="listing8-7">Listing 8-7</a>: <em>number_guess.py:2c</em></p>
<p>While this code is perfectly valid, it’s not very efficient. I run <code>isdigit()</code> on <em>every single guess</em>, whether it’s erroneous or not, and then I run the <code>int()</code> conversion if it passes the test. Thus, I process the string in <code>guess</code> <em>twice</em> on the happy path, and once in the case of an error. Contrast this with the  EAFP strategy with the <code>try</code> statement from earlier, where I only ever process the string once.</p>
<p>Some will complain, “Yes, but, error handling is expensive!” True, but only on the exceptions. A successful try typically has very little overhead in Python. The extra code for handling special cases is run when an error occurs. If you’ve designed your code right, the happy path should be far more common than the exceptional path, such as in the example above.</p>
<p>The EAFP approach is also easier to think about. Instead of coming up with tests to anticipate every possible erroneous input—an arduous task in <span epub:type="pagebreak" title="189" id="Page_189"/>more complex, real-world scenarios—you only need to anticipate the likely exceptions, catch them, and handle them accordingly. That said, it can sometimes take some real effort to figure out what errors to expect. Be prepared to invest time here, either way.</p>
<h2 id="h1-500920c08-0004">Multiple Exceptions</h2>
<p class="BodyFirst">The <code>try</code> statement is not limited to a single error type. I can handle multiple scenarios in one compound statement.</p>
<p>To demonstrate this, I’ll create a simple, callable <code>AverageCalculator</code> class that will accept a list of inputs and use them to recalculate a stored running average:</p>
<pre><code>class AverageCalculator:

    def __init__(self):
        self.total = 0
        self.count = 0

    def __call__(self, *values):
        if values:
            for value in values:
                self.total += float(value)
                self.count += 1
        return self.total / self.count</code></pre>
<p class="CodeListingCaption"><a id="listing8-8">Listing 8-8</a>: <em>average_calculator.py:1</em></p>
<p>There are a few possible errors that can occur while using this <code>AverageCalculator</code> class, but I’d prefer to let the user interface code handle those, so they can be used for displaying error messages.</p>
<p>Here’s a basic command line interface for the calculator:</p>
<pre><code>average = AverageCalculator()
values = input("Enter scores, separated by spaces:\n    ").split()
try:
    print(f"Average is {average(*values)}")
except <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> ZeroDivisionError:
    print("ERROR: No values provided.")
except ( <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> ValueError, <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> UnicodeError):
    print(f"ERROR: All inputs should be numeric.")</code></pre>
<p class="CodeListingCaption"><a id="listing8-9">Listing 8-9</a>: <em>average_calculator.py:2</em></p>
<p>There are three errors that can occur when calling <code>average()</code>: </p>
<ol class="none">
<li>The user might pass no values, meaning <code>total</code> (the divisor of the division in <code>__call__()</code>) might be zero and thus raise a <code>ZeroDivisionError</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</li>
<li>One or more of the inputs might not be convertible by <code>float()</code>, thus raising a <code>ValueError</code> <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</li>
<li><span epub:type="pagebreak" title="190" id="Page_190"/>There might be a problem encoding or decoding Unicode, which will raise a <code>UnicodeError</code> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. (Actually, that last one is entirely redundant with <code>ValueError</code> in this case; I’m only including it to demonstrate the concept.)</li>
</ol>
<p>I handle all three exceptional cases by calling <code>average()</code> within the <code>try</code> clause’s suite and then catching the errors in the <code>except</code> clauses.</p>
<p>When a <code>ZeroDivisionError</code> is caught <span class="CodeAnnotation" aria-label="annotation1">❶</span>, I print that no values were provided by the user.</p>
<p>I handle the <code>ValueError</code> <span class="CodeAnnotation" aria-label="annotation2">❷</span> and the (redundant) <code>UnicodeError</code> <span class="CodeAnnotation" aria-label="annotation3">❸</span> in the same way; either error would occur if the user tried inputting something non-numeric. By specifying both in a tuple after <code>except</code>, I catch either error and handle both the same way—in this case, by printing a message that some inputs weren’t numeric.</p>
<p>To demonstrate this in a reasonably contained example, I’ve written slightly convoluted code here. In the real world, I’d place the <code>try</code> statement within the <code>__call__()</code> method itself. While this example code departs from idiomatic Python, it demonstrates a more complex <code>try</code> statement, albeit without any truly useful error-handling behavior (which I’ll get to shortly).</p>
<h2 id="h1-500920c08-0005">Beware the Diaper Anti-pattern</h2>
<p class="BodyFirst">Sooner or later, every Python developer will discover that a bare <code>except</code> clause will work:</p>
<pre><code>try:
    some_scary_function()
except:
    print("An error occurred. Moving on!")</code></pre>
<p class="CodeListingCaption"><a id="listing8-10">Listing 8-10</a>: <em>diaper_antipattern.py</em></p>
<p>Here, a bare <code>except</code> allows you to catch all exceptions in one. This is one of the most insidious anti-patterns in Python. It catches and silences literally every conceivable exception, whether you expect it to or not.</p>
<p>The entire point of an exception is to alert you that your program is now in an <em>exceptional state</em>, meaning it can no longer proceed along the ordinary, intended happy path without unexpected or even disastrous results. By silencing every error, you have created a situation where you have no idea what those exceptional states are or what is causing them. You’ve thrown away your precious traceback and forced the program to continue as if nothing had happened.</p>
<p>In his book <em>How to Make Mistakes in Python</em>, Mike Pirnat calls this the <em>diaper pattern</em>:</p>
<blockquote class="blockquote">
<p class="Blockquote">[A]ll the precious context for the actual error is being trapped in the diaper, never to see the light of day or the inside of your issue tracker. When the “blowout” exception occurs later on, the stack trace points to the location where the secondary error happened, not to the actual failure inside the try block.</p>
</blockquote>
<p><span epub:type="pagebreak" title="191" id="Page_191"/>Worse yet, if your program never raises another exception but keeps attempting to work in its invalid state, weird behavior will often abound.</p>
<p>Instead, always explicitly catch a particular exception type! Any error that you cannot foresee is probably related to some bug that needs to be resolved.</p>
<p>As usual, The Zen of Python has something to say about this:</p>
<blockquote class="blockquote">
<p class="Blockquote">Errors should never pass silently.</p>

<p class="Blockquote">Unless explicitly silenced.</p></blockquote>
<p>There’s another diabolical side effect of this anti-pattern, which I can demonstrate with this simple program for greeting someone by name:</p>
<pre><code>def greet():
    name = input("What's your name? ")
    print(f"Hello, {name}.")


while True:
    try:
        greet()
        break
    except:
        print("Error caught")</code></pre>
<p class="CodeListingCaption"><a id="listing8-11">Listing 8-11</a>: <em>no_escape.py:1a</em></p>
<p>If I were running this program in the Linux terminal and decided I wanted to quit, I’d press <span class="Caps">Ctrl</span>-<span class="Caps">C</span>. Look what happens when I do exactly that:</p>
<pre><code>What's your name? ^CError caught
What's your name? ^CError caught
What's your name? ^CError caught
What's your name? </code></pre>
<p>Ack! I’m trapped! The trouble is, the <code>KeyboardInterrupt</code>, which is produced by pressing <span class="Caps">Ctrl</span>-<span class="Caps">C</span> on a UNIX terminal, uses the <code>except</code> system. It’s getting caught, “handled,” and utterly ignored. There’s no escape from this program, except to kill my terminal altogether and manually kill the Python process. (Thankfully in this example, you can still quit by typing a name.)</p>
<p>The <code>KeyboardInterrupt</code> exception does not itself inherit from the <code>Exception</code> class, like errors do. Thus, some (overly) clever developer might try this:</p>
<pre><code>def greet():
    name = input("What's your name? ")
    print(f"Hello, {name}.")


while True:
    try:
        greet()
        break
<span epub:type="pagebreak" title="192" id="Page_192"/>    <b>except Exception:</b>
        print("Error caught")</code></pre>
<p class="CodeListingCaption"><a id="listing8-12">Listing 8-12</a>: <em>no_escape.py:1b</em></p>
<p>I’m no longer catching <code>KeyboardInterrupt</code>, which is good, so I can now escape with <span class="Caps">Ctrl</span>-<span class="Caps">C</span>. Unfortunately, this is still a form of the <em>diaper anti-pattern</em>, for the reasons I mentioned earlier: it catches every conceivable error! The one time this might be acceptable would be in conjunction with logging, which I’ll address later in this chapter.</p>
<h2 id="h1-500920c08-0006">Raising Exceptions</h2>
<p class="BodyFirst">You can also <em>raise</em> exceptions to indicate the occurrence of a problem that your code cannot recover from automatically, such as when someone calling a function you wrote passes an unusable argument. There are several dozen common exceptions available for you to raise as needed (see “A Gallery of Exceptions” near the end of this chapter).</p>
<p>To demonstrate this, here’s a function that accepts a string containing numbers (separated by spaces) and calculates the average. Here, I’m catching the most common error scenario and providing a more useful and relevant error:</p>
<pre><code>def average(number_string):
    total = 0
    skip = 0
    values = 0
    for n in number_string.split():
        values += 1
      <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> try:
            total += float(n)
      <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> except ValueError:
            skip += 1</code></pre>
<p class="CodeListingCaption"><a id="listing8-13">Listing 8-13</a>: <em>average.py:1</em></p>
<p>I split the provided string into the individual space-separated parts, looping through each part. Within a <code>try</code> clause <span class="CodeAnnotation" aria-label="annotation1">❶</span>, I attempt to convert each part to a floating-point number and add it to the <code>total</code> accumulator. If any of the values cannot be converted to a number, thereby raising a <code>ValueError</code> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, I mark that I’ve skipped an item, and I move on.</p>
<p>I continue with that function:</p>
<pre><code>  <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> if skip == values:
        raise ValueError("No valid numbers provided.")
    elif skip:
        print(f"&lt;!&gt; Skipped {skip} invalid values.")

    return total / values</code></pre>
<p class="CodeListingCaption"><a id="listing8-14">Listing 8-14</a>: <em>average.py:2</em></p>
<p><span epub:type="pagebreak" title="193" id="Page_193"/>Once I’ve processed the string, I check whether I’ve skipped all the values <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If I have, I’ll <code>raise</code> another <code>ValueError</code>, passing my error message to the constructor of the exception. Otherwise, if only some of the values have been skipped, I’ll print a helpful message and move on.</p>
<p>Raising an exception breaks out of the function <em>immediately</em>, in the same manner as a <code>return</code> statement. Thus, I don’t need to worry about the final <code>return</code> statement being run if I have no values (such as if the user passed in an empty string).</p>
<p>The usage of that function is as follows:</p>
<pre><code>while True:
    line = input("Enter numbers (space delimited):\n    ")
    avg = average(line)
    print(avg)</code></pre>
<p class="CodeListingCaption"><a id="listing8-15">Listing 8-15</a>: <em>average.py:3a</em></p>
<p>I’ll run that code and try some inputs:</p>
<pre><code>Enter numbers (space delimited):
    4 5 6 7 
5.5</code></pre>
<p>The first input works just fine, returning the average of the four numbers I specified.</p>
<pre><code>Enter numbers (space delimited):
    four five 6 7
&lt;!&gt; Skipped 2 invalid values.
3.25</code></pre>
<p>The second input works as well, skipping my two invalid values and returning the average of the other two.</p>
<pre><code>Enter numbers (space delimited):
    four five six seven
Traceback (most recent call last):
  File "./raiseexception.py", line 25, in &lt;module&gt;
    avg = average(line)
  File "./raiseexception.py", line 16, in average
    raise ValueError("No valid numbers provided.")
ValueError: No valid numbers provided.</code></pre>
<p>The third input contains no valid numbers, so it crashes the program, which is exactly what I wanted. Reading the traceback, you can see the exception I raised earlier and where I raised it from.</p>
<p>I wouldn’t ship a program like this, so I can, in turn, catch the exception I raised. I’ll rewrite my infinite loop at the bottom of the program, like so:</p>
<pre><code>while True:
    <b>try:</b>
        line = input("Enter numbers (space delimited):\n    ")
        avg = average(line)
<span epub:type="pagebreak" title="194" id="Page_194"/>        print(avg)
    <b>except ValueError:</b>
        <b>print("No valid numbers provided.")</b></code></pre>
<p class="CodeListingCaption"><a id="listing8-16">Listing 8-16</a>: <em>average.py:3b</em></p>
<p>I wrap the user input/output logic in a <code>try</code> clause, and then I catch the <code>ValueError</code> and print a nice message instead. Let’s try out this new version:</p>
<pre><code>Enter numbers (space delimited):
    four five six
No valid numbers provided.
Enter numbers (space delimited):
    4 5 6
5.0</code></pre>
<p>Perfect! When the input is bad, the exception I raised inside the <code>average()</code> function is caught here, and the appropriate message is printed. (I can press CTRL-C to quit.)</p>
<h2 id="h1-500920c08-0007">Using Exceptions</h2>
<p class="BodyFirst">Like everything else in Python, exceptions are objects that you can both use directly and extract information from.</p>
<p>You can, for example, use exceptions to handle the logic of accessing values from a dictionary, without knowing in advance whether the key you specified is valid. (There’s some debate about whether and when to use this approach, which I’ll revisit in <span class="xref" itemid="xref_target_Chapter 9">Chapter 9</span>.)</p>
<p>As an example of using exceptions with dictionaries, here’s a program that allows a user to look up an email address by a person’s name.</p>
<p>I start by defining a dictionary containing names and email addresses:</p>
<pre><code>friend_emails = {
    "Anne": "anne@example.com",
    "Brent": "brent@example.com",
    "Dan": "dan@example.com",
    "David": "david@example.com",
    "Fox": "fox@example.com",
    "Jane": "jane@example.com",
    "Kevin": "kevin@example.com",
    "Robert": "robert@example.com"
}</code></pre>
<p class="CodeListingCaption"><a id="listing8-17">Listing 8-17</a>: <em>address_book.py:1</em></p>
<p>Here is my lookup function:</p>
<pre><code>def lookup_email(name):
    try:
        return friend_emails[name]
<span epub:type="pagebreak" title="195" id="Page_195"/>    except KeyError <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> as e:
        print(f"&lt;No entry for friend {e}&gt;")</code></pre>
<p class="CodeListingCaption"><a id="listing8-18">Listing 8-18</a>: <em>address_book.py:2</em></p>
<p>I start by trying to use the <code>name</code> argument as a key on my dictionary, within the context of a <code>try</code> clause. If the key is not in the dictionary, a <code>KeyError</code> will be raised, which I’ll catch. I capture said exception with <code>as e</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, allowing me to use the exception object later. In the case of a <code>KeyError</code>, <code>str(e)</code> will return the value that I just tried to use as a key in the dictionary.</p>
<p>Finally, here’s the code using that function:</p>
<pre><code>name = input("Enter name to look up: ")
email = lookup_email(name)
print(f"Email: {email}")</code></pre>
<p class="CodeListingCaption"><a id="listing8-19">Listing 8-19</a>: <em>address_book.py:3</em></p>
<p>If I run this code and pass a name that isn’t in my dictionary, I see the result of the error handling:</p>
<pre><code>Enter name to look up: Jason
&lt;No entry for friend 'Jason'&gt;
Email: None</code></pre>
<h3 id="h2-500920c08-0001">Exceptions and Logging</h3>
<p class="BodyFirst">An unusual aspect of <code>KeyError</code> is that its message consists purely of the erroneous key. Most exceptions contain their complete error message, one use of which is <em>logging</em>, wherein errors, warnings, and other informational messages are printed to the terminal or saved to a file for inspection by the end user, in case of bugs. Users expect programs to behave well and not crash, but errors aren’t always avoidable. It’s common for software to log errors to a file or the terminal, to aid in debugging crashes and bugs.</p>
<p>To demonstrate this, I’ll write a very basic calculator program, which is intended to demonstrate the concept without getting too deep into the logging tools and practices themselves. I’ll cover logging more thoroughly in <span class="xref" itemid="xref_target_Chapter 19">Chapter 19</span>.</p>
<h4 id="h3-500920c08-0001">Logging Configuration</h4>
<p class="BodyFirst">My calculator program will need a few imports that may be unfamiliar to you:</p>
<pre><code>import logging
from operator import add, sub, mul, truediv
import sys</code></pre>
<p class="CodeListingCaption"><a id="listing8-20">Listing 8-20</a>: <em>calculator.py:1</em></p>
<p><span epub:type="pagebreak" title="196" id="Page_196"/>The <code>logging</code> module contains Python’s built-in logging tools, which I’ll use in a moment. The <code>operator</code> module contains optimized functions for performing mathematical operations on arbitrary values, which I’ll use in my calculator function. Third, <code>sys</code> provides tools for interacting with the interpreter itself; in my case, I’ll use one of its functions later on to tell my program to exit.</p>
<p>The <code>logging.basicConfig()</code> function allows me to configure my logging level, as well as specify things like which file to write the log to:</p>
<pre><code>logging.basicConfig(filename='log.txt', level=logging.INFO)</code></pre>
<p class="CodeListingCaption"><a id="listing8-21">Listing 8-21</a>: <em>calculator.py:2</em></p>
<p>There are five increasing severity levels of logging: <code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, and <code>CRITICAL</code>. By passing <code>level=logging.INFO</code>, I’m telling the logging module to log all messages of that level, as well as the three severity levels above it (<code>WARNING</code>, <code>ERROR</code>, and <code>CRITICAL</code>). That means only log messages marked as <code>DEBUG</code> are ignored on this setting.</p>
<p>With the argument <code>filename=log.txt</code>, I also specify that the log should be written to a file called <em>log.txt</em>. I could also leave this blank if I wanted to print the log to the console instead.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA ALERT </h2>	<p class="BoxBodyFirst">In practice, <code>logging.basicConfig()</code> should usually only appear in the <code>if __name__ == "__main__":</code> section of your program, as this will change the <em>global</em> behavior of the logging module. (See <span class="xref" itemid="xref_target_Chapter 19">Chapter 19</span>.)</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Here is my actual <code>calculator()</code> function:</p>
<pre><code>def calculator(a, b, op):
    a = float(a)
    b = float(b)
    if op == '+':
        return <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> add(a, b)
    elif op == '-':
        return sub(a, b)
    elif op == '*':
        return mul(a, b)
    elif op == '/':
        return truediv(a, b)
    else:
      <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> raise NotImplementedError(f"No operator {op}")</code></pre>
<p class="CodeListingCaption"><a id="listing8-22">Listing 8-22</a>: <em>calculator.py:3</em></p>
<p>The math operator functions, such as <code>add()</code> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, are coming from the <code>operator</code> module I imported earlier.</p>
<p>The <code>calculator()</code> function doesn’t perform error checking by design, according to the <em>single-responsibility principle</em> from <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>. Code that uses the <code>calculator()</code> function should provide the right arguments to the function, anticipate and handle the errors itself, or crash with an explicit unhandled error (thereby indicating the code is erroneous).</p>
<p><span epub:type="pagebreak" title="197" id="Page_197"/>There is one exception (no pun intended). If the user specifies an operator in the <code>op</code> parameter that I don’t support in my <code>calculator()</code> function, I raise <code>NotImplementedError</code> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. This exception should be raised anytime functionality that doesn’t exist is requested.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<h2>GOTCHA ALERT </h2>	<p class="BoxBodyFirst">Don’t confuse <code>NotImplementedError</code> with <code>NotImplemented</code>. Any special (dunder) method that is not implemented should return <code>NotImplemented</code>, so code relying on such a special method is informed without failing. Any custom method or function (or, in this case, functionality) that hasn’t been implemented yet (or never will be) should return <code>NotImplementedError</code>, so any attempted usage will fail with an error.</p><div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-500920c08-0002">Logging Errors</h4>
<p class="BodyFirst">The following is my usage of the <code>calculator()</code> function, along with all the error handling and logging code. I’ll break this down into several pieces and discuss each separately:</p>
<pre><code>print("""CALCULATOR
Use postfix notation.
Ctrl+C or Ctrl+D to quit.
""")

<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> while True:
  <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> try:
        equation = input(" ").split()
        result = calculator(*equation)
        print(result)</code></pre>
<p class="CodeListingCaption"><a id="listing8-23">Listing 8-23</a>: <em>calculator.py:4</em></p>
<p>First, I print the program name and some user instructions. Then, in my program loop <span class="CodeAnnotation" aria-label="annotation1">❶</span>, within a <code>try</code> <span class="CodeAnnotation" aria-label="annotation2">❷</span>, I attempt to collect the input from the user and pass it to the <code>calculator()</code> function. If that works, I print the result, and the loop starts over. However, there are a number of errors that can occur, and I handle them in my <code>except</code> clauses:</p>
<pre><code>    except NotImplementedError as e:
        print("&lt;!&gt; Invalid operator.")
        logging.info(e)</code></pre>
<p class="CodeListingCaption"><a id="listing8-24">Listing 8-24</a>: <em>calculator.py:5</em></p>
<p>If I encounter the <code>NotImplementedError</code>, which I capture as a usable object with <code>as e</code>, it means an invalid operator was specified in the <code>op=</code> argument passed to <code>calculator()</code>. After printing some information for the user, I log this (as level <code>INFO</code>) by passing the error, <code>e</code>, to the <code>logging.info()</code> function. That logs the error message (which you’ll see in a moment), but it throws away the traceback, which I do not need to show to the program’s user, since the problem was their input.</p>
<pre><code><span epub:type="pagebreak" title="198" id="Page_198"/>    except ValueError as e:
        print("&lt;!&gt; Expected format: &lt;A&gt; &lt;B&gt; &lt;OP&gt;")
        logging.info(e)</code></pre>
<p class="CodeListingCaption"><a id="listing8-25">Listing 8-25</a>: <em>calculator.py:6</em></p>
<p>The <code>ValueError</code> is raised if <code>float()</code> was not able to convert the arguments <code>a</code> or <code>b</code> to floating-point numbers. That might mean that the user entered non-numeric characters for one of the operands, or that the operator was specified in the wrong order. Remember, I ask the user for <em>postfix notation</em>, meaning the operator comes after the two operands. In either case, I remind the user of the format they need to use, and once again, I log the error to level <code>INFO</code>:</p>
<pre><code>    except TypeError as e:
        print("&lt;!&gt; Wrong number of arguments. Use: &lt;A&gt; &lt;B&gt; &lt;OP&gt;")
        logging.info(e)</code></pre>
<p class="CodeListingCaption"><a id="listing8-26">Listing 8-26</a>: <em>calculator.py:7</em></p>
<p>The <code>TypeError</code> shows up if the user passes either too many or too few arguments to the <code>calculator()</code> function. Once again, I log this as level <code>INFO</code>, print a reminder for the user about the proper format of input, and move on:</p>
<pre><code>    except ZeroDivisionError as e:
        print("&lt;!&gt; Cannot divide by zero.")
        logging.info(e)</code></pre>
<p class="CodeListingCaption"><a id="listing8-27">Listing 8-27</a>: <em>calculator.py:8</em></p>
<p>If the user tries to divide by zero, it raises the error <code>ZeroDivisionError</code>. Handling that error is, again, a matter of logging to <code>INFO</code> and notifying the user:</p>
<pre><code>    except (KeyboardInterrupt, EOFError):
        print("\nGoodbye.")
        sys.exit(0)</code></pre>
<p class="CodeListingCaption"><a id="listing8-28">Listing 8-28</a>: <em>calculator.py:9</em></p>
<p>Lastly, I use <code>KeyboardInterrupt</code> and <code>EOFError</code> to catch the UNIX terminal keystrokes <span class="Caps">Ctrl</span>-<span class="Caps">C</span> (abort) and <span class="Caps">Ctrl</span>-<span class="Caps">D</span> (end of file), respectively. In either case, I print a friendly farewell message and then use <code>sys.exit(0)</code> to properly quit the program. Technically, I could have left both of these uncaught, but that would have resulted in an ugly error message appearing upon quitting the program. That might scare some users into thinking there’s a bug in the program.</p>
<p>I’ll run this program now and try things out:</p>
<pre><code>CALCULATOR
Use postfix notation.
Ctrl+C or Ctrl+D to quit.

<span epub:type="pagebreak" title="199" id="Page_199"/> 11 31 +
42.0
 11 + 31
&lt;!&gt; Expected format: &lt;A&gt; &lt;B&gt; &lt;OP&gt;
 11 + 31 + 10
&lt;!&gt; Wrong number of arguments. Use: &lt;A&gt; &lt;B&gt; &lt;OP&gt;
 11 +
&lt;!&gt; Wrong number of arguments. Use: &lt;A&gt; &lt;B&gt; &lt;OP&gt;
 10 0 /
&lt;!&gt; Cannot divide by zero.
 10 40 @
&lt;!&gt; Invalid operator.
 ^C
Goodbye.</code></pre>
<p>All in all, this is a clean user experience. All the errors I’ve anticipated are being caught and handled appropriately, and I can quit nicely.</p>
<h4 id="h3-500920c08-0003">Reviewing the Logs and Cleaning Up</h4>
<p class="BodyFirst">Take a look at the <em>log.txt</em> file that’s been created:</p>
<pre><code>INFO:root:could not convert string to float: '+'
INFO:root:calculator() takes 3 positional arguments but 5 were given
INFO:root:calculator() missing 1 required positional argument: 'op'
INFO:root:float division by zero
INFO:root:No operator @</code></pre>
<p class="CodeListingCaption"><a id="listing8-29">Listing 8-29</a>: <em>log.txt</em></p>
<p>Here are all five of the error messages that were logged while I used the program.</p>
<p>Practically speaking, in production software, I’d never write any of the expected errors to a file, because it would result in a huge and unwieldy file! Thus, I might change all my logging commands to <code>logging.debug()</code>, to log the error messages at the <code>DEBUG</code> level. That way, if I were to need to peruse the errors during debugging, I’d only need to change my logging configuration to <code>logging.basicConfig(filename='log.txt', level=logging.DEBUG)</code>. I’d ship with a logging level of <code>INFO</code>, thereby suppressing the <code>DEBUG</code> messages. That way, the end user wouldn’t see a bloated log.</p>
<h3 id="h2-500920c08-0002">Bubbling Up</h3>
<p class="BodyFirst">There’s one nonoptimal part of the logging scheme I’ve created: any unexpected errors won’t get logged. Ideally, any exception I haven’t anticipated should be logged at level <code>ERROR</code> but still be allowed to crash the program, so the code doesn’t try to carry on in an unhandled exceptional state.</p>
<p>Thankfully, any error you catch can be re-raised, or <em>bubbled up</em> in Python terminology. Since the error isn’t caught again after being re-raised, the program will crash.</p>
<p><span epub:type="pagebreak" title="200" id="Page_200"/>I’m leaving the rest of the earlier <code>try</code> statement the same (Listings 8-23 through 8-28), but I’m adding one more <code>except</code> to the end:</p>
<pre><code>    except Exception as e:
        logging.exception(e)
      <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> raise</code></pre>
<p class="CodeListingCaption"><a id="listing8-30">Listing 8-30</a>: <em>calculator.py:10</em></p>
<p>The <code>except</code> clauses are evaluated in order, which is why this new clause has to appear at the end of the current <code>try</code> statement. I don’t want this “catch-all” to gobble up the exceptions I specifically want to handle separately.</p>
<p>This may seem dangerously close to the diaper anti-pattern, except here, I don’t hide the error, and I’m only catching <em>actual errors</em>—that is, any object that inherits from <code>Exception</code>. Non-error “exceptions” like <code>StopIteration</code> and <code>KeyboardInterrupt</code>, which don’t inherit from <code>Exception</code>, won’t get caught by this <code>except</code> clause.</p>
<p>I log the error message, <em>along with the traceback</em>, at <code>ERROR</code> level, using the special method <code>logging.exception(e)</code>. When the user sends me the log file with his bug report, I, the developer, will need this traceback to find and fix the bug.</p>
<p>Then, I bubble up the error with a bare <code>raise</code> statement, which raises the <em>last-caught</em> exception <span class="CodeAnnotation" aria-label="annotation1">❶</span>. (I could also have done <code>raise e</code>, but the bare <code>raise</code> is preferred in this context for brevity in my code and traceback.) It is <em>absolutely essential</em> that I bubble up the error here, lest this become a case of the diaper anti-pattern.</p>
<h3 id="h2-500920c08-0003">Exception Chaining</h3>
<p class="BodyFirst">When you catch one exception and then raise another, you’re at risk of losing the context of the original error. To avoid this situation, Python offers <em>exception chaining</em>, whereby you can raise a new exception without throwing away all the helpful information already provided. This feature was added in Python 3.0 (via PEP 3134).</p>
<p>I’ll apply this concept to a program for looking up the city and state of famous landmarks. I start by defining the dictionaries for the program:</p>
<pre><code>cities = {
    "SEATTLE": "WASHINGTON, USA",
    "PORTLAND": "OREGON, USA",
    "BOSTON": "MASSACHUSETTS, USA",
}

landmarks = {
    "SPACE NEEDLE": "SEATTLE",
    "LIBERTY SHIP MEMORIAL": "PORTLAND",
    "ALAMO": "SAN ANTONIO",
}</code></pre>
<p class="CodeListingCaption"><a id="listing8-31">Listing 8-31</a>: <em>landmarks.py:1</em></p>
<p><span epub:type="pagebreak" title="201" id="Page_201"/>Here is the function for looking up landmarks and their corresponding cities in the dictionaries:</p>
<pre><code>def lookup_landmark(landmark):
    landmark = landmark.upper()
    try:
        city = landmarks[landmark]
        state = cities[city]
  <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> except KeyError as e:
      <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> raise KeyError("Landmark not found.") from e
    print(f"{landmark} is in {city}, {state}")</code></pre>
<p class="CodeListingCaption"><a id="listing8-32">Listing 8-32</a>: <em>landmarks.py:2</em></p>
<p>In this function, I try to find the landmark in the <code>landmarks</code> dictionary. If it’s not there, a <code>KeyError</code> is raised, which I catch <span class="CodeAnnotation" aria-label="annotation1">❶</span> and then re-raise with more useful information in the error message <span class="CodeAnnotation" aria-label="annotation2">❷</span>. When I raise the new exception, I use <code>from e</code> to specify that it was caused by the exception (<code>e</code>) I caught. This ensures that the traceback shows what led to the error: either the city or the landmark not being found.</p>
<p>Here’s an example usage of this function:</p>
<pre><code>lookup_landmark("space needle")
lookup_landmark("alamo")
lookup_landmark("golden gate bridge")</code></pre>
<p class="CodeListingCaption"><a id="listing8-33">Listing 8-33</a>: <em>landmarks.py:3</em></p>
<p>I test the <code>lookup_landmark()</code> function by looking up three landmarks, two of which (<code>"alamo"</code> and <code>"golden gate bridge"</code>) are going to throw an exception, but for different reasons. In the case of the Alamo, although the landmark is in the <code>landmarks</code> dictionary, the corresponding city of "<code>SAN ANTONIO</code>" is missing from the cities dictionary. In the case of the Golden Gate Bridge, the landmark isn’t even in the <code>landmarks</code> dictionary. (Sorry, San Francisco!)</p>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic NOTE</h2><p class="BoxBodyFirst">This implementation is more than a bit silly, but that is a necessary evil for this technical example. The better design here would be to split the two dictionary lookups between two <code>try</code> statements; the best design would be to use some collection better suited to this situation, since a dictionary really isn’t.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p>The code as written won’t get to the last line, because the second-to-last line will throw an exception, as you’ll see in the output:</p>
<pre><code>SPACE NEEDLE is in SEATTLE, WASHINGTON, USA
Traceback (most recent call last):
  File "./chaining.py", line 18, in lookup_landmark
    state = cities[city]
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> KeyError: 'SAN ANTONIO'

<span class="CodeAnnotationHang" aria-label="annotation2">❷</span> The above exception was the direct cause of the following exception:

Traceback (most recent call last):
<span epub:type="pagebreak" title="202" id="Page_202"/>  File "./chaining.py", line 25, in &lt;module&gt;
    lookup_landmark("alamo")
  File "./chaining.py", line 20, in lookup_landmark
    raise KeyError("Landmark not found.") from e
<span class="CodeAnnotationHang" aria-label="annotation3">❸</span> KeyError: 'Landmark not found.'</code></pre>
<p>The first call to <code>lookup_landmark()</code> works, as you can see from the output. Remembering that you read traceback from the bottom up, you see that the second call fails, raising the <code>"Landmark not found"</code> error <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>
<p>Above that traceback is a notification that the exception was caused by a different exception <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>
<p>Sure enough, in the traceback above that, you find the problem; Python couldn’t find the city of <code>"SAN ANTONIO"</code> in the <code>cities</code> dictionary <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>
<p>Even if I hadn’t taken the time to add <code>raise KeyError from e</code> earlier, Python would ordinarily have included the context, although the two tracebacks would have been separated with a message I consider far more cryptic and less helpful:</p>
<pre><code>During handling of the above exception, another exception occurred:</code></pre>
<p>So, even though you might be able to get away without explicit exception chaining, it’s just a good habit to take on.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<p>You can explicitly disable chaining with <code>raise e from None</code>.</p>
<div class="bottom hr"><hr/></div>
</aside>
<h2 id="h1-500920c08-0008">Else and Finally</h2>
<p class="BodyFirst">Up to this point, all my error handling examples have relied on <code>try</code> and <code>except</code>, which leaves the rest of the code to run the same in any case, whatever happens, unless I call <code>return</code> or take advantage of the breaking behavior of a <code>raise</code> statement to bail out of a function.</p>
<p>There are two more optional clauses for <code>try</code> statements: <code>else</code> runs if there is no exception, and <code>finally</code> runs in any situation, but in a surprising way.</p>
<h3 id="h2-500920c08-0004">Else: “If All Goes Well”</h3>
<p class="BodyFirst">You would use the <code>else</code> clause for any section of code that should only run if none of the <code>except</code> clauses caught anything.</p>
<p>To demonstrate this, I’ll revise my program for finding the average of a list of numbers. This time, I want it to always output a valid <code>float</code> value. The average of an empty string should be the constant <code>math.inf</code> (the result of division by zero), and the presence of any non-numeric values should produce the constant <code>math.nan</code>.</p>
<pre><code>import math


def average_string(number_string):
    try:
        numbers = [float(n) for n in number_string.split()]
<span epub:type="pagebreak" title="203" id="Page_203"/>    except ValueError:
        total = math.nan
        values = 1</code></pre>
<p class="CodeListingCaption"><a id="listing8-34">Listing 8-34</a>: <em>average_string.py:1</em></p>
<p>Every time the <code>average_string()</code> function is called, it first tries to create a list of <code>float</code> values. If any part of the string is non-numeric, a <code>ValueError</code> is raised. I catch that exception, assign the value <code>math.nan</code> to <code>total</code>, and ensure there is a <code>1</code> in <code>values</code>, which I will use as the divisor in the upcoming division.</p>
<p>If no exception was raised by that first <code>try</code> clause, the <code>else</code> clause is run:</p>
<pre><code>    else:
        total = sum(numbers)
        values = len(numbers)</code></pre>
<p class="CodeListingCaption"><a id="listing8-35">Listing 8-35</a>: <em>average_string.py:2</em></p>
<p>The <code>total</code> and <code>values</code> are calculated based on the now-valid assumption that <code>numbers</code> is a list of <code>float</code> values. <em>The </em><code>else</code><em> clause only runs if the </em><code>try</code><em> raises no exceptions.</em></p>
<p>So, why not just return <code>math.nan</code> in the <code>except ValueError</code> clause? That would certainly be a bit more efficient, but there are two reasons I chose not to do that:</p>
<ol class="decimal">
<li value="1">This approach better accommodates later refactoring; the rest of the math is always executed, and it always produces a valid result (except for the division-by-zero scenario I handle separately in the next part of the code).</li>
<li value="2">If I need to add a <code>finally</code> clause anywhere, the code will still behave as expected (see next section).</li>
</ol>
<p>Here’s the rest of the program. Notice that I have a separate <code>try</code> statement to handle attempted division by zero:</p>
<pre><code>    try:
        average = total / values
    except ZeroDivisionError:
        average = math.inf

    return average


while True:
    number_string = input("Enter space-delimited list of numbers:\n    ")
    print(average_string(number_string))</code></pre>
<p class="CodeListingCaption"><a id="listing8-36">Listing 8-36</a>: <em>average_string.py:3</em></p>
<p><span epub:type="pagebreak" title="204" id="Page_204"/>I’ve handled all of the exceptional paths that could be reasonably anticipated in the code. Testing this out, everything behaves as expected, with no unhandled exceptions.</p>
<pre><code>    4 5 6 7
5.5
    
inf
    four five six
nan</code></pre>
<h3 id="h2-500920c08-0005">Finally: “After Everything”</h3>
<p class="BodyFirst">The <code>finally</code> clause is always executed, no matter what! There aren’t any exceptions to this: even <code>raise</code> or <code>return</code> will not prevent the <code>finally</code> clause from being executed. This is what sets <code>finally</code> apart from plain code after the <code>try</code> statement.</p>
<p>Because of this, <code>finally</code> is especially well-suited for any cleanup code you need to run, <em>no matter what</em>.</p>
<p>Here’s a function that reads numbers from a file, one number per line, and finds the average. In this case, I want exceptions to be raised if the file contains non-numeric data or if the file cannot be found.</p>
<p>For this example, I’ll use manual opening and closing of a file—although in production, I’d use a <em>context manager</em> for this instead (see <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span>).</p>
<pre><code>def average_file(path):
    file = open(path, 'r')

    try:
      <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> numbers = [float(n) for n in file.readlines()]</code></pre>
<p class="CodeListingCaption"><a id="listing8-37">Listing 8-37</a>: <em>average_file.py:1</em></p>
<p>When the <code>average_file()</code> function is called, it attempts to open the file indicated by the argument <code>path</code>. If this file doesn’t exist, <code>file.open()</code> will raise a <code>FileNotFoundError</code> exception, which I’m allowing as is, in this case.</p>
<p>Once the file is opened, I try to iterate over it, converting it into a list of numbers <span class="CodeAnnotation" aria-label="annotation1">❶</span>. (You’re welcome to take this particular line of code for granted for now. See <span class="xref" itemid="xref_target_Chapters 10">Chapters 10</span> and <span class="xref" itemid="xref_target_11">11</span>.)</p>
<pre><code>    except ValueError as e:
        raise ValueError("File contains non-numeric values.") from e</code></pre>
<p class="CodeListingCaption"><a id="listing8-38">Listing 8-38</a>: <em>average_file.py:2</em></p>
<p>If any of the values are non-numeric, I catch the <code>ValueError</code>. In this clause, I raise a chained exception with more specific information describing what was wrong with the file.</p>
<p><span epub:type="pagebreak" title="205" id="Page_205"/>Otherwise, if no errors were raised by the <code>try</code> clause, the <code>else</code> clause runs:</p>
<pre><code>    else:
        try:
            return sum(numbers) / len(numbers)
        except ZeroDivisionError as e:
            raise ValueError("Empty file.") from e</code></pre>
<p class="CodeListingCaption"><a id="listing8-39">Listing 8-39</a>: <em>average_file.py:3</em></p>
<p>This clause’s suite attempts to calculate and return the average, but it also contains a nested <code>try</code> statement to handle an empty file.</p>
<p>After either the <code>except</code> or the <code>else</code> clause has run, the <code>finally</code> clause is always executed, <em>even after a </em><code>raise</code><em> or </em><code>return</code>! This is important, because no matter the outcome, the file needs to be closed:</p>
<pre><code>    finally:
        print("Closing file.")
        file.close()</code></pre>
<p class="CodeListingCaption"><a id="listing8-40">Listing 8-40</a>: <em>average_file.py:4 </em></p>
<p>I’ll test the program with four files, three of which I’ve created: a file containing integers called <em>numbers_good.txt</em>, a file containing words called <em>numbers_bad.txt</em>, an empty file called <em>numbers_empty.txt</em>, and a nonexistent file called <em>nonexistent.txt</em>.</p>
<p>Let’s examine the output of these four scenarios one by one. These have to be run separately, because the program execution ceases when an exception is raised:</p>
<pre><code>print(average_file('numbers_good.txt'))</code></pre>
<p class="CodeListingCaption"><a id="listing8-41">Listing 8-41</a>: <em>average_file.py:5a</em></p>
<p>The file <em>numbers_good.txt</em> contains 12 integers, each on a separate line. Running that scenario, I get the following output:</p>
<pre><code>Closing file.
42.0</code></pre>
<p>The function works correctly; it opens the file and calculates the average of the values. Notice when the <code>finally</code> clause runs, as evidenced by the printed message "<code>Closing file.</code>" Although it is running <em>after </em>the <code>return</code> statement in the <code>average_file()</code> function from earlier, it appears <em>before</em> the function returns. This is a good thing, because the <code>finally</code> clause in this function is responsible for closing the file, which absolutely <em>must</em> happen.</p>
<p>Now for the second scenario:</p>
<pre><code>print(average_file('numbers_bad.txt'))</code></pre>
<p class="CodeListingCaption"><a id="listing8-42">Listing 8-42</a>: <em>average_file_usage.py:5b</em></p>
<p><span epub:type="pagebreak" title="206" id="Page_206"/>The <em>numbers_bad.txt</em> file contains words, not numbers. This output is a lot longer because of the exception:</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">❶</span> Closing file.
Traceback (most recent call last):
  File "tryfinally.py", line 5, in average_file
    numbers = [float(n) for n in file.readlines()]
  File "tryfinally.py", line 5, in &lt;listcomp&gt;
    numbers = [float(n) for n in file.readlines()]
ValueError: could not convert string to float: 'thirty-three\n'

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "tryfinally.py", line 20, in &lt;module&gt;
    print(average_file('numbers_bad.txt'))  # ValueError
  File "tryfinally.py", line 7, in average_file
    raise ValueError("File contains non-numeric values.") from e
ValueError: File contains non-numeric values.</code></pre>
<p>In this case, a <code>ValueError</code> is raised. Yet, once again, the <code>finally</code> clause is run <span class="CodeAnnotation" aria-label="annotation1">❶</span> before the exception is raised, even though the <code>raise</code> statement seems to come first in the function’s source code.</p>
<p>Here’s the third scenario:</p>
<pre><code>print(average_file('numbers_empty.txt'))</code></pre>
<p class="CodeListingCaption"><a id="listing8-43">Listing 8-43</a>: <em>average_file_usage.py:5c</em></p>
<p>The file <em>numbers_empty.txt</em> is, as its name suggests, an empty file. The output is as follows:</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">❶</span> Closing file.
Traceback (most recent call last):
  File "tryfinally.py", line 10, in average_file
    return sum(numbers) / len(numbers)
ZeroDivisionError: division by zero

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "tryfinally.py", line 21, in &lt;module&gt;
    print(average_file('numbers_empty.txt'))  # ValueError
  File "tryfinally.py", line 12, in average_file
    raise ValueError("Empty file.") from e
<span class="CodeAnnotationHang" aria-label="annotation2">❷</span> ValueError: Empty file.</code></pre>
<p>You can see that the error message about the empty file is working as well <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Also, as before, it is evident the <code>finally</code> clause is running <span class="CodeAnnotation" aria-label="annotation1">❶</span> before the exception is raised.</p>
<p><span epub:type="pagebreak" title="207" id="Page_207"/>Now for the last scenario:</p>
<pre><code>print(average_file('nonexistent.txt'))</code></pre>
<p class="CodeListingCaption"><a id="listing8-44">Listing 8-44</a>: <em>average_file_usage.py:5d</em></p>
<p>This is attempting to read from a file that <em>doesn’t exist</em>. Here’s the output of that scenario:</p>
<pre><code>Traceback (most recent call last):
  File "tryfinally.py", line 22, in &lt;module&gt;
    print(average_file('nonexistent.txt'))  # FileNotFoundError
  File "tryfinally.py", line 2, in average_file
    file = open(path, 'r')
FileNotFoundError: [Errno 2] No such file or directory: 'nonexistent.txt'</code></pre>
<p>This exception comes from the <code>file.open()</code> call, which, if you refer back to the source code for <code>average_file()</code>, you’ll notice occurs <em>before</em> the <code>try</code> statement. The <code>finally</code> clause only runs if its connected <code>try</code> clause is executed; since control flow never reached the <code>try</code>, the <code>finally</code> never gets called. Just as well, since there’s no point in trying to close a file that was never opened.</p>
<h2 id="h1-500920c08-0009">Creating Exceptions</h2>
<p class="BodyFirst">Python has quite the menagerie of exceptions, and their uses are very well documented. Sometimes, however, you need something a bit more customized.</p>
<p>All error-type exception classes inherit from the <code>Exception</code> class, which in turn inherits from the <code>BaseException</code> class. This dual hierarchy exists to let you catch all error exceptions, as I did earlier, without also reacting to the special, non-error exceptions like <code>KeyboardInterrupt</code>, which inherit from <code>BaseException</code> and not <code>Exception</code>.</p>
<p>When making a custom exception class, you can inherit from any exception class you like. However, avoid inheriting from <code>BaseException</code>, as that class is not designed to be directly inherited from by custom classes. Sometimes, it’s best to inherit from the exception class that is closest in purpose to the one you’re making (see the next section). However, if you’re at a loss, you can inherit from <code>Exception</code>.</p>
<p>Before going through all the effort to write a custom exception, consider why you <em>want</em> to. My recommendation is to ensure your use case fits at least two of these three criteria:</p>
<ol class="decimal">
<li value="1">No existing exception effectively describes the error, even if you provide a custom message.</li>
<li value="2">You will raise or catch the exception more than once.</li>
<li value="3">You need to be able to catch this specific exception, without catching any of the similar built-in exceptions.</li>
</ol>
<p><span epub:type="pagebreak" title="208" id="Page_208"/>If your use case cannot satisfy at least two of these criteria, you <em>probably</em> don’t need a custom exception and can instead use one of the existing exceptions.</p>
<p>Most of the time, the need for custom exceptions arises in more complicated projects, so it’s very difficult to create a practical example for this. For demonstration purposes, here’s the code for a uselessly simple and rather silly custom exception and its usage:</p>
<pre><code>class <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> SillyWalkException( <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> RuntimeError):
    def __init__(self, <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> message="Someone walked silly."):
        super().__init__(message)


def walking():
  <span class="CodeAnnotationCode" aria-label="annotation4">❹</span> raise SillyWalkException("My walk has gotten rather silly.")


try:
    walking()
<span class="CodeAnnotationHang" aria-label="annotation5">❺</span> except SillyWalkException as e:
    print(e)</code></pre>
<p class="CodeListingCaption"><a id="listing8-45">Listing 8-45</a>: <em>silly_walk_exception.py</em></p>
<p>I define a new class with the name of the exception <span class="CodeAnnotation" aria-label="annotation1">❶</span>, and I inherit from the most <em>specific</em> exception class that makes sense <span class="CodeAnnotation" aria-label="annotation2">❷</span>. In this case, I’m inheriting from <code>RuntimeError</code> because my exception doesn’t fit into the description of any of the other built-in exceptions.</p>
<p>There’s some debate about whether it’s necessary to write an initializer for custom exceptions. I prefer to, because it provides an opportunity to specify a default error message <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Writing your own initializer also allows you to accept and store multiple parameters for various bits of information, not just the message attribute that all <code>Exception</code> classes must have (although I don’t do that here).</p>
<p>If you accept a string for a message and don’t want to provide a default, you can get away with this version to define the custom exception class with nothing more than a header and a docstring:</p>
<pre><code>class SillyWalkException(RuntimeError):
    """Exception for walking silly."""</code></pre>
<p>Either way, the custom exception can be raised <span class="CodeAnnotation" aria-label="annotation4">❹</span> and caught <span class="CodeAnnotation" aria-label="annotation5">❺</span> in the same way as any other exception.</p>
<h2 id="h1-500920c08-0010">A Gallery of Exceptions</h2>
<p class="BodyFirst">The Python documentation provides an exhaustive list of all the built-in exceptions and their uses. You can find this list at <a href="https://docs.python.org/library/exceptions.html" class="LinkURL">https://docs.python.org/library/exceptions.html</a>.</p>
<p><span epub:type="pagebreak" title="209" id="Page_209"/>However, since that documentation can feel like an information dump, I’ll briefly cover the most common exception classes. There are four base classes from which all the other exceptions are inherited; when you need to catch an entire category of exceptions, you can often use these:</p>
<ol class="none">
<li><code>BaseException</code> is the base class for all exceptions. Remember not to inherit directly from this; it’s not designed to be used as such.</li>
<li><code>Exception</code> is the base class for all error-type exceptions.</li>
<li><code>ArithmeticError</code> is the base class for arithmetic-related errors.</li>
<li><code>LookupError</code> is the base class for any error related to finding values in collections.</li>
</ol>
<aside epub:type="sidebar">
<div class="dottedTop hr"><hr/></div>
<section class="boxcustom2">
<h2>Pedantic NOTE</h2><p class="BoxBodyFirst">There’s also <code>BufferError</code>, which relates to memory errors behind the Python language. No other exceptions inherit from this one, and you shouldn’t either.</p><div class="dottedBottom hr"><hr/></div>
</section>
</aside>
<p>Next, after the base exception classes, come the <em>concrete exceptions</em>, each of which describes a particular type of error. As of this writing, there are 35 concrete exceptions in the Python language, although I’m only covering some of the most common of these (see the documentation for the rest). A few others will be introduced in later chapters. All of these inherit directly from <code>Exception</code>, except as noted:</p>
<ol class="none">
<li><code>AttributeError</code> is raised when accessing or assigning to a class attribute that doesn’t exist.</li>
<li><code>ImportError</code> is raised when an <code>import</code> statement isn’t able to find a package, module, or a name within the module. You may also encounter the subclass exception <code>ModuleNotFoundError</code>.</li>
<li><code>IndexError</code> is raised when an index (subscript) is out of range for a sequential collection, such as a list or tuple. This inherits from <code>LookupError</code>.</li>
<li><code>KeyError</code> is raised when a key is not found in a dictionary. This inherits from <code>LookupError</code>.</li>
<li><code>KeyboardInterrupt</code> is raised when the user presses a <span class="Caps">key</span>-<span class="Caps">key</span> combination to interrupt the running program, such as with <span class="Caps">Ctrl</span>-<span class="Caps">C</span> on UNIX-like systems. This inherits from <code>BaseException</code>, not <code>Exception</code>.</li>
<li><code>MemoryError</code> is raised when Python runs out of memory. However, there are still steps you can take to (probably) fix the problem, usually by deleting stuff.</li>
<li><code>NameError</code> is raised when a name is not found in the local or global scope. This isn’t used in relation to class attributes (see <code>AttributeError</code>) or imports (see <code>ImportError</code>).</li>
<li><code>OSError</code> is both a concrete error and a base class for many exceptions relating to the operating system, including <code>FileNotFoundError</code> (which is raised when a file cannot be opened). I’ll explore some of these in later chapters.</li>
<li><span epub:type="pagebreak" title="210" id="Page_210"/><code>OverflowError</code> is raised when an arithmetic operation would produce a result that is too large to be represented or stored. This mainly occurs with floating-point numbers. Integers never raise <code>OverflowError</code>, because they have no official size limits in Python; they will raise a <code>BufferError</code> if a similar situation occurs. This inherits from <code>ArithmeticError</code>.</li>
<li><code>RecursionError</code> is raised when a function calls itself too many times (see <span class="xref" itemid="xref_target_Chapter 6">Chapter 6</span>), whether directly or indirectly. This inherits from <code>RuntimeError</code>.</li>
<li><code>RuntimeError</code> is a sort of catch-all for any error that doesn’t fit into the other categories.</li>
<li><code>SyntaxError</code> is raised if there are any syntax errors in the Python code. These often come up when you run your program, but you may encounter them at any point during runtime when using arbitrary execution (see <span class="xref" itemid="xref_target_Chapter 15">Chapter 15</span>). This also includes the subclasses <code>IndentationError</code> and <code>TabError</code>.</li>
<li><code>SystemError</code> is raised when the interpreter has an internal error. There’s not much you can do about these errors; report them to the developers of the Python implementation you use.</li>
<li><code>SystemExit</code> is raised when <code>sys.exit()</code> is called. Be careful about catching this, as you can prevent your program from quitting normally! This inherits from <code>BaseException</code>.</li>
<li><code>TypeError</code> is raised when an operation or function tries to act on an object of the wrong type. This is the best exception to raise if your function is not intended to work on a particular value type received as an argument.</li>
<li><code>UnboundLocalError</code>, a subclass of <code>NameError</code>, is raised when you try to access a local name that has no value yet assigned to it. This inherits from <code>NameError</code>.</li>
<li><code>ValueError</code> is raised when an operation or function tries to act on an argument that is the right <em>type</em>, but the wrong <em>value</em>.</li>
<li><code>ZeroDivisionError</code> is raised when trying to divide by zero, whether through the true division (<code>/</code>), floor division (<code>//</code>), modulo (<code>%</code>), or <code>divmod()</code> operators. This inherits from <code>ArithmeticError</code>.</li>
</ol>
<h2 id="h1-500920c08-0011">Wrapping Up</h2>
<p class="BodyFirst">I’ve spent a lot of time discussing how and when to use exceptions and error handling. This is a vast topic, yet the syntax itself boils down to the structure of <code>try</code>, <code>except</code>, <code>else</code>, <code>finally</code>, and the <code>raise</code> keyword.</p>
</section>
</div></body></html>