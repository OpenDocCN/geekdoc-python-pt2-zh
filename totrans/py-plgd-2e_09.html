<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="header0601" class="chapter" epub:type="chapter" id="ch06" role="doc-chapter">
<header id="header0601">
<h1 class="cn"><span aria-label=" Page 100. " class="page" epub:type="pagebreak" id="p100" role="doc-pagebreak"/><span aria-label=" Page 101. " class="page" epub:type="pagebreak" id="p101" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rch06">6</a></h1>
<h1 class="ct">ASCII Art</h1>
</header>
<figure class="figure">
<p class="fig"><img alt="" height="100" src="images/nsp-venkitachalam503045-circle-image.jpg" width="100"/></p>
</figure>
<p class="pf">In the 1990s, when email ruled and graphics capabilities were limited, it was common to include a <span class="idx" data-level1="email" data-term="signature"/>signature in your email that contained a graphic made of text, commonly called <span class="idx" data-term="text-based graphics"/><span class="idx" data-term="ASCII art (begin)"/><i>ASCII art</i>. (ASCII is simply a character-encoding scheme.) <a class="xref" href="nsp-venkitachalam503045-0019.xhtml#fig6-1">Figure 6-1</a> shows a couple of examples. Although the internet has made sharing images immeasurably easier, the humble text graphic isn’t quite dead yet.</p>
<p>ASCII art has its origins in typewriter art created in the late 1800s. In the 1960s, when computers had minimal graphics processing hardware, ASCII was used to represent images. These days, ASCII art continues as a form of expression on the internet, and you can find a variety of creative examples online.</p>
<figure class="figure" id="fig6-1">
<p class="fig"><span aria-label=" Page 102. " class="page" epub:type="pagebreak" id="p102" role="doc-pagebreak"/><img alt="" height="526" src="images/nsp-venkitachalam503045-f06001.jpg" style="width:95%; height:auto;" width="1200"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 6-1:</span> Examples of ASCII art</p>
</figcaption>
</figure>
<p>In this project, you’ll use Python to create a program that generates ASCII art from graphical images. The program will let you specify the width of the output (the number of columns of text) and set a vertical scale factor. It also supports two <span class="idx" data-term="mapping"/>mappings of grayscale values to ASCII characters: a sparse 10-level mapping and a more finely calibrated 70-level mapping.</p>
<p>To generate your ASCII art from an image, you’ll learn how to do the following:</p>
<ul style="list-style-type:none">
<li class="blf">• Convert images to grayscale using <code>Pillow</code>, a fork of the Python Imaging Library (PIL).</li>
<li class="bl">• Compute the average brightness of a grayscale image using <code>numpy</code>.</li>
<li class="bl">• Use a string as a quick lookup table for <span class="idx" data-level1="values" data-term="grayscale"/>grayscale values<span class="idx" data-term="ASCII art (end)"/>.</li>
</ul>
<section>
<h2 class="ah" id="ah0801"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0801"><span class="idx" data-level1="generating (begin)" data-term="ASCII art"/>How It Works</a></h2>
<p class="paft">This project takes advantage of the fact that from a distance, we perceive <span class="idx" data-level1="images" data-term="grayscale"/>grayscale images as the average value of their brightness. For example, in <a class="xref" href="nsp-venkitachalam503045-0019.xhtml#fig6-2">Figure 6-2</a>, you can see a grayscale image of a building and, next to it, an image filled with the average brightness value of the building image. If you look at the images from across the room, they will look similar.</p>
<p>ASCII art is generated by splitting an image into tiles and replacing each tile with an ASCII character, based on the tile’s average brightness value. Brighter tiles are replaced with sparser ASCII characters (that is, characters that contain a lot of whitespace), such as a period (<code>.</code>) or colon (<code>:</code>), while darker tiles are replaced with denser ASCII characters, such as an ampersand (<code>@</code>) or dollar sign (<code>$</code>). From a distance, since our eyes have limited resolution, we sort of see the “average” values in ASCII art while losing the details that would otherwise make the art look less real.</p>
<figure class="figure" id="fig6-2">
<p class="fig"><span aria-label=" Page 103. " class="page" epub:type="pagebreak" id="p103" role="doc-pagebreak"/><img alt="" height="276" src="images/nsp-venkitachalam503045-f06002.jpg" width="422"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 6-2:</span> The average value of a grayscale image</p>
</figcaption>
</figure>
<p>This program will take a given image and first convert it to <span class="idx" data-term="8-bit image"/>8-bit grayscale so that each pixel has a grayscale value in the range [0, 255] (the range of an 8-bit integer). Think of this 8-bit value as the pixel’s <span class="idx" data-level1="brightness" data-term="ASCII art"/><i>brightness</i>, with 0 being black, 255 being white, and the values in between being shades of gray.</p>
<p>Next, it will split the image into a grid of <i>M</i>×<i>N</i> tiles (where <i>M</i> is the number of rows and <i>N</i> the number of columns in the ASCII image). The program will then calculate the average brightness value for each tile in the grid and match it with an appropriate ASCII character by predefining a <span class="idx" data-level1="ramp" data-term="ASCII art"/><i>ramp</i> (an increasing set of values) of ASCII characters to represent grayscale values in the range [0, 255]. It will use these ramp values as a lookup table for the brightness values.</p>
<p>The finished ASCII art is just a bunch of lines of text. To display the text, you’ll use a constant-width (also called <i>monospace</i>) font such as Courier because unless each text character has the same width, the characters in the image won’t line up properly along a grid, and you’ll end up with unevenly spaced and scrambled output.</p>
<p>The <span class="idx" data-level1="aspect ratio" data-term="ASCII art"/><i>aspect ratio</i> (the ratio of width to height) of the <span class="idx" data-level1="font" data-term="ASCII art"/>font used also affects the final image. If the aspect ratio of the space taken up by a character is different from the aspect ratio of the image tile the character is replacing, the final ASCII image will appear distorted. In effect, you’re trying to replace an image tile with an ASCII character, so their shapes need to match. For example, if you were to split your image into square tiles and then replace each of the tiles with a font where characters are taller than they are wide, the final output would appear stretched vertically. To address this issue, you’ll scale the rows in your grid to match the Courier aspect ratio. (You can send the program command line arguments to modify the scaling to match other fonts.)</p>
<p>In sum, here are the steps the program takes to generate the ASCII image:</p>
<ol style="list-style-type:none">
<li class="nlf">1. Convert the input image to grayscale.</li>
<li class="nl">2. Split the image into <i>M</i>×<i>N</i> <span class="idx" data-level1="tiles" data-term="ASCII art"/>tiles.</li>
<li class="nl">3. Correct <i>M</i> (the number of rows) to match the image and font aspect ratio.</li>
<li class="nl"><span aria-label=" Page 104. " class="page" epub:type="pagebreak" id="p104" role="doc-pagebreak"/>4. Compute the average brightness for each image tile and then look up a suitable ASCII character for each.</li>
<li class="nl">5. Assemble rows of ASCII character strings and print them to a file to form the final image.<span class="idx" data-level1="generating (end)" data-term="ASCII art"/></li>
</ol>
</section>
<section>
<h2 class="ah" id="ah0802"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0802">Requirements</a></h2>
<p class="paft">In this project, you’ll use <span class="idx" data-term="Pillow module"/><code>Pillow</code>, the friendly fork of the Python Imaging Library, to read in the images, access their underlying data, and create and modify them. You’ll also use the <code>numpy</code> library to compute averages.</p>
</section>
<section>
<h2 class="ah" id="ah0803"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0803">The Code</a></h2>
<p class="paft">You’ll begin by defining the grayscale levels used to generate the ASCII art. Then you’ll look at how the image is split into tiles and how average brightness is computed for those tiles. Next, you’ll work on replacing the tiles with ASCII characters to generate the final output. Finally, you’ll set up command line parsing for the program to allow users to specify the output size, output filename, and so on.</p>
<p>For the full project code, skip to <a class="xref" href="nsp-venkitachalam503045-0019.xhtml#ah0807">“The Complete Code”</a> on <a class="xref" href="nsp-venkitachalam503045-0019.xhtml#p109">page 109</a>. You can also download the code for this project from <a class="url-i" href="https://github.com/mkvenkit/pp2e/blob/main/ascii/ascii.py">https://github.com/mkvenkit/pp2e/blob/main/ascii/ascii.py</a>.</p>
<section>
<h3 class="bh" id="bh0801"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0801">Defining the Grayscale Levels and Grid</a></h3>
<p class="paft">As the first step in creating your program, define the scales you’ll use to convert <span class="idx" data-level1="brightness" data-term="ASCII art"/>image brightness values to ASCII characters as global values.</p>
<div class="codeline1">
<p class="cl1f"># 70 levels of gray</p>
<p class="cl1">gscale1 = "$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~&lt;&gt;i!lI;:,\"^`'. "</p>
<p class="cl1"># 10 levels of gray</p>
<p class="cl1l">gscale2 = "@%#*+=-:. "</p>
</div>
<p>The value <code>gscale1</code> is a 70-level grayscale <span class="idx" data-level1="ramp" data-term="ASCII art"/>ramp, while <code>gscale2</code> is a simpler 10-level grayscale ramp. Both of these values are stored as strings, with a range of characters that progress from darkest to lightest. The program will use the <code>gscale2</code> ramp by default, but you’ll include a command line option to use the more nuanced <code>gscale1</code> ramp instead.</p>
<p class="pcust1"><span class="ccust3">NOTE</span> To learn more about how characters are represented as grayscale values, see Paul Bourke’s “Character Representation of Grey Scale Images” at <a class="url-i" href="http://paulbourke.net/dataformats/asciiart/">http://paulbourke.net/dataformats/asciiart/</a>.</p>
<p>Now that you have your grayscale ramps, you can set up the image. The following code opens the image using <code>Pillow</code> and splits it into a grid:</p>
<div class="codeline">
<p class="clf"># open the image and convert to grayscale</p>
<p class="cl">image = Image.open(fileName).convert("L")</p>
<p class="cl"><span aria-label=" Page 105. " class="page" epub:type="pagebreak" id="p105" role="doc-pagebreak"/># store the image dimensions</p>
<p class="cl2"><!--<ccust1>1</ccust1>-->❶ W, H = image.size[0], image.size[1]</p>
<p class="cl"># compute the tile width</p>
<p class="cl2"><!--<ccust1>2</ccust1>-->❷ w = W/cols</p>
<p class="cl"># compute the tile height based on the aspect ratio and scale of the font</p>
<p class="cl2"><!--<ccust1>3</ccust1>-->❸ h = w/scale</p>
<p class="cl"># compute the number of rows to use in the final grid</p>
<p class="cl2l"><!--<ccust1>4</ccust1>-->❹ rows = int(H/h)</p>
</div>
<p>First, <code>Image.</code><span class="idx" data-level1="Image" data-term="Python Imaging Library"/><code>open()</code> opens the input image file, and <code>Image.</code><span class="idx" data-level1="convert() method" data-term="Python Imaging Library"/><code>convert()</code> converts the image to grayscale. The <code>"L"</code> stands for <span class="idx" data-term="luminance"/><span class="idx" data-level1="luminance" data-term="Python Imaging Library"/><i>luminance</i>, a measure of the brightness of an image. You store the width and height (measured in pixels) of the input image <!--<ccust1>1</ccust1>-->❶. Then you compute the width of a tile for the number of columns (<code>cols</code>) specified by the user <!--<ccust1>2</ccust1>-->❷. (The program uses a default of 80 columns if the user doesn’t set another value in the command line.) You use floating-point, not integer, division to avoid truncation errors while calculating the dimensions of the tiles.</p>
<p>Once you know the width of a tile, you compute its height using the vertical scale factor passed in as <code>scale</code> <!--<ccust1>3</ccust1>-->❸. This way, each tile will match the aspect ratio of the font you’re using to display the text so that the final image won’t be distorted. The value for <code>scale</code> can be passed in as an argument, or it’s set to a default of <code>0.43</code>, which works well for displaying the result in Courier. Having calculated the height of each row, you compute the number of rows in the grid <!--<ccust1>4</ccust1>-->❹.</p>
</section>
<section>
<h3 class="bh" id="bh0802"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0802">Computing the Average Brightness</a></h3>
<p class="paft">Next, you need a way to compute the average <span class="idx" data-level1="brightness" data-term="ASCII art"/>brightness for a tile in the grayscale image. The function <code>getAverageL()</code> does the job.</p>
<div class="codeline">
<p class="clf">def getAverageL(image):</p>
<p class="cl">    # get the image as a numpy array</p>
<p class="cl">  <!--<ccust1>1</ccust1>-->❶ im = np.array(image)</p>
<p class="cl">    # get the dimensions</p>
<p class="cl">    w,h = im.<span class="idx" data-level1="array" data-term="numpy module"/>shape</p>
<p class="cl">    # get the average</p>
<p class="cll">  <!--<ccust1>2</ccust1>-->❷ return np.<span class="idx" data-level1="average()" data-term="numpy module"/>average(im.<span class="idx" data-level1="array" data-term="numpy module"/>reshape(w*h))</p>
</div>
<p>The image tile is passed into the function as a PIL <code>Image</code> object. You convert the image into a <code>numpy</code> array <!--<ccust1>1</ccust1>-->❶, at which point <code>im</code> becomes a two-dimensional array containing the brightness values of the image’s pixels. You store the dimensions (width and height) of the array and then use <code>numpy.reshape()</code> to convert the two-dimensional array into a flat one-dimensional array whose length is a product of the original array’s width and height (<code>w*h</code>). You pass the reshaped array to <code>numpy.average()</code>, which sums the array values and computes the average brightness level of the entire image tile <!--<ccust1>2</ccust1>-->❷.</p>
</section>
<section>
<h3 class="bh" id="bh0803"><span aria-label=" Page 106. " class="page" epub:type="pagebreak" id="p106" role="doc-pagebreak"/><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0803"><span class="idx" data-level1="generating (begin)" data-term="ASCII art"/><span class="idx" data-level1="generating (begin)" data-term="ASCII art"/>Generating the ASCII Content from the Image</a></h3>
<p class="paft">The main part of the program generates the ASCII content from the image:</p>
<div class="codeline">
<p class="clf"># an ASCII image is a list of character strings</p>
<p class="cl2"><!--<ccust1>1</ccust1>-->❶ aimg = []</p>
<p class="cl"># generate the list of tile dimensions</p>
<p class="cl2"><!--<ccust1>2</ccust1>-->❷ for j in range(rows):</p>
<p class="cl">    y1 = int(j*h)</p>
<p class="cl">    y2 = int((j+1)*h)</p>
<p class="cl">    # correct the last tile</p>
<p class="cl">    if j == rows-1:</p>
<p class="cl">      <!--<ccust1>3</ccust1>-->❸ y2 = H</p>
<p class="cl">    # append an empty string</p>
<p class="cl">  <!--<ccust1>4</ccust1>-->❹ aimg.append("")</p>
<p class="cl">  <!--<ccust1>5</ccust1>-->❺ for i in range(cols):</p>
<p class="cl">        # crop the image to fit the tile</p>
<p class="cl">        x1 = int(i*w)</p>
<p class="cl">        x2 = int((i+1)*w)</p>
<p class="cl">        # correct the last tile</p>
<p class="cl">        if i == cols-1:</p>
<p class="cl">            x2 = W</p>
<p class="cl">        # crop the image to extract the tile into another Image object</p>
<p class="cl">      <!--<ccust1>6</ccust1>-->❻ img = image.<span class="idx" data-level1="Image" data-term="Python Imaging Library"/><span class="idx" data-level1="image" data-term="numpy module"/>crop((x1, y1, x2, y2))</p>
<p class="cl">        # get the average luminance</p>
<p class="cl">      <!--<ccust1>7</ccust1>-->❼ avg = int(getAverageL(img))</p>
<p class="cl">        # look up the ASCII character for grayscale value (avg)</p>
<p class="cl">        if moreLevels:</p>
<p class="cl">          <!--<ccust1>8</ccust1>-->❽ gsval = gscale1[int((avg*69)/255)]</p>
<p class="cl">        else:</p>
<p class="cl">          <!--<ccust1>9</ccust1>-->❾ gsval = gscale2[int((avg*9)/255)]</p>
<p class="cl">        # append the ASCII character to the string</p>
<p class="cll">      <!--<ccust1>10</ccust1>-->❿ aimg[j] += gsval</p>
</div>
<p>In this section of the program, the ASCII image is first stored as a list of strings, which you initialize <!--<ccust1>1</ccust1>-->❶. Next, you iterate through the rows of image tiles <!--<ccust1>2</ccust1>-->❷, calculating the top and bottom y-coordinates of each image tile in a given row as <i>y1</i> and <i>y2</i>. These are floating-point calculations, but you truncate them to integers before passing them to an image-cropping method.</p>
<p>Next, because dividing the image into tiles creates edge tiles of the same size only when the image width is an integer multiple of the number of columns, you correct for the bottom y-coordinate of the tiles in the last row by setting the y-coordinate to the image’s actual height (<code>H</code>) <!--<ccust1>3</ccust1>-->❸. By doing so, you ensure that the bottom edge of the image isn’t truncated.</p>
<p>You add an empty string into the ASCII image list as a compact way to represent the current image row <!--<ccust1>4</ccust1>-->❹. You’ll fill in this string next. Essentially, you’re treating the string as a list of characters that you can append to. Then you iterate over all the tiles in a given row of the image, column by column <!--<ccust1>5</ccust1>-->❺. You compute the left and right x-coordinates of each tile <span aria-label=" Page 107. " class="page" epub:type="pagebreak" id="p107" role="doc-pagebreak"/>as <i>x1</i> and <i>x2</i>. When you get to the last tile in the row, you set the right x-coordinate to the width of the image (<code>W</code>), for the same reasons you corrected the final y-coordinate to the image’s height.</p>
<p>You’ve now calculated (<i>x1</i>, <i>y1</i>) and (<i>x2</i>, <i>y2</i>), the coordinates of the top-left and bottom-right corners of the current image tile. You pass these coordinates to <code>image.crop()</code> to extract the tile from the complete image <!--<ccust1>6</ccust1>-->❻. Then you pass that tile (which takes the form of a PIL <code>Image</code> object) to the <code>getAverageL()</code> function <!--<ccust1>7</ccust1>-->❼, defined in <a class="xref" href="nsp-venkitachalam503045-0019.xhtml#bh0802">“Computing the Average Brightness”</a> on <a class="xref" href="nsp-venkitachalam503045-0019.xhtml#p105">page 105</a>, to get the average brightness of the tile. You scale the average brightness value from [0, 255] to [0, 9], the range of values for the default 10-level grayscale ramp <!--<ccust1>9</ccust1>-->❾. You then use <code>gscale2</code> (the stored ramp string) as a lookup table for the relevant ASCII character. The line at <!--<ccust1>8</ccust1>-->❽ is similar, except it scales the brightness value to the [0, 69] range of the 70-level grayscale ramp. This line will be used only when the <code>moreLevels</code> command line flag has been set. Finally, you append the looked-up ASCII character, <code>gsval</code>, to the text row <!--<ccust1>10</ccust1>-->❿, and the code loops until all rows are processed.<span class="idx" data-level1="generating (end)" data-term="ASCII art"/></p>
</section>
<section>
<h3 class="bh" id="bh0804"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0804">Creating <span class="idx" data-level1="command line options" data-term="ASCII art"/>Command Line Options</a></h3>
<p class="paft">Next, define some command line options for the program. This code uses the built-in <code>argparse.ArgumentParser</code> class:</p>
<div class="codeline">
<p class="clf">parser = argparse.<span class="idx" data-level1="ArgumentParser" data-term="argparse module"/>ArgumentParser(description="descStr")</p>
<p class="cl"># add expected arguments</p>
<p class="cl">parser.add_argument('--file', dest='imgFile', required=True)</p>
<p class="cl">parser.add_argument('--scale', dest='scale', required=False)</p>
<p class="cl">parser.add_argument('--out', dest='outFile', required=False)</p>
<p class="cl">parser.add_argument('--cols', dest='cols', required=False)</p>
<p class="cll">parser.add_argument('--morelevels', dest='moreLevels', action='store_true')</p>
</div>
<p>You include the following options:</p>
<p class="pcust2"><span class="hemb">--file</span> Specifies the image file to input. This is the only required argument.</p>
<p class="pcust2"><span class="hemb">--scale</span> Sets the vertical scale factor for a font other than Courier.</p>
<p class="pcust2"><span class="hemb">--out</span> Sets the output filename for the generated ASCII art. Defaults to <i>out.txt</i>.</p>
<p class="pcust2"><span class="hemb">--cols</span> Sets the number of text columns in the ASCII output.</p>
<p class="pcust2"><span class="hemb">--morelevels</span> Selects the 70-level grayscale ramp instead of the default 10-level ramp.</p>
</section>
<section>
<h3 class="bh" id="bh0805"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rbh0805"><span class="idx" data-level1="writing to text file" data-term="ASCII art"/>Writing the ASCII Art Strings to a Text File</a></h3>
<p class="paft">Finally, take the generated list of ASCII character strings and write those strings to a text file:</p>
<div class="codeline">
<p class="clf"># open a new text file</p>
<p class="cl2"><!--<ccust1>1</ccust1>-->❶ f = open(outFile, 'w')</p>
<p class="cl"># write each string in the list to the new file</p>
<p class="cl2"><!--<ccust1>2</ccust1>-->❷ for row in aimg:</p>
<p class="cl"><span aria-label=" Page 108. " class="page" epub:type="pagebreak" id="p108" role="doc-pagebreak"/>    f.write(row + '\n')</p>
<p class="cl"># clean up</p>
<p class="cl2l"><!--<ccust1>3</ccust1>-->❸ f.close()</p>
</div>
<p>You use the built-in <code>open()</code> function to open a new text file for writing <!--<ccust1>1</ccust1>-->❶. Then you iterate through each string in the <code>aimg</code> list and write it to the file <!--<ccust1>2</ccust1>-->❷. When you’re done, you close the file object to release system resources <!--<ccust1>3</ccust1>-->❸.</p>
</section>
</section>
<section>
<h2 class="ah" id="ah0804"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0804">Running the ASCII Art Generator</a></h2>
<p class="paft">To run your finished program, enter a command like the following one, replacing <code class="i">data/robot.jpg</code> with the relative path to the image file you want to use:</p>
<div class="codeline">
<p class="cls">$ <code class="b">python ascii.py --file</code> <code class="bi">data/robot.jpg</code> <code class="b">--cols 100</code></p>
</div>
<p><a class="xref" href="nsp-venkitachalam503045-0019.xhtml#fig6-3">Figure 6-3</a> shows the ASCII art that results from sending the image <i>robot.jpg</i> (at the left). Try adding the <code>--morelevels</code> option to see how the 70-level grayscale ramp compares to the 10-level ramp.</p>
<figure class="figure" id="fig6-3">
<p class="fig"><img alt="" height="365" src="images/nsp-venkitachalam503045-f06003.jpg" style="width:95%; height:auto;" width="1184"/></p>
<figcaption>
<p class="figh"><span class="fighn">Figure 6-3:</span> A sample run of <i>ascii.py</i></p>
</figcaption>
</figure>
<p>Now you’re all set to create your own ASCII art!</p>
</section>
<section>
<h2 class="ah" id="ah0805"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0805">Summary</a></h2>
<p class="paft">In this project, you learned how to generate ASCII art from any input image. In the process, you learned how to split an image into a grid of tiles, how to compute the average brightness value of each tile, and how to replace each tile with a character based on the brightness values. Have fun creating your own ASCII art!</p>
</section>
<section>
<h2 class="ah" id="ah0806"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0806">Experiments!</a></h2>
<p class="paft">Here are some ideas for exploring ASCII art further:</p>
<ol style="list-style-type:none">
<li class="nlf">1. Run the program with the command line option <code>--scale 1.0</code>. How does the resulting image look? Experiment with different values for <code>scale</code>. <span aria-label=" Page 109. " class="page" epub:type="pagebreak" id="p109" role="doc-pagebreak"/>Copy the output to a text editor and try setting the text to different fixed-width fonts to see how doing so affects the appearance of the final image.</li>
<li class="nl">2. Add a command line option <code>--invert</code> to the program to invert the generated ASCII images so that black appears white, and vice versa. (Hint: try subtracting the tile brightness value from 255 during lookup.)</li>
<li class="nl">3. In this project, you created lookup tables for grayscale values based on two hardcoded character ramps. Implement a command line option to pass in a different character ramp to create the ASCII art, like so:
            <div class="codeline">
<p class="cl3s">$ <code class="b">python ascii.py --map "@$%^`."</code></p>
</div>
<p class="nlp">This should create the ASCII output using the given six-character ramp, where <code>@</code> maps to a brightness value of 0 and <code>.</code> maps to a value of 255.</p>
</li>
</ol>
</section>
<section>
<h2 class="ah" id="ah0807"><a class="xref" href="nsp-venkitachalam503045-0008.xhtml#rah0807">The Complete Code</a></h2>
<p class="paft">Here is the complete ASCII art program.</p>
<div class="codeline1">
<p class="cl1f">"""</p>
<p class="cl1">ascii.py</p>
<p class="cl1f">A Python program that convert images to ASCII art.</p>
<p class="cl1f">Author: Mahesh Venkitachalam</p>
<p class="cl1">"""</p>
<p class="cl1f">import sys, random, argparse</p>
<p class="cl1">import numpy as np</p>
<p class="cl1">import math</p>
<p class="cl1f">from PIL import Image</p>
<p class="cl1f"># grayscale level values from:</p>
<p class="cl1"># http://paulbourke.net/dataformats/asciiart/</p>
<p class="cl1f"># 70 levels of gray</p>
<p class="cl1">gscale1 = "$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~&lt;&gt;i!lI;:,\"^`'. "</p>
<p class="cl1"># 10 levels of gray</p>
<p class="cl1">gscale2 = '@%#*+=-:. '</p>
<p class="cl1f">def getAverageL(image):</p>
<p class="cl1">    """</p>
<p class="cl1">    given PIL Image, return average value of grayscale value</p>
<p class="cl1">    """</p>
<p class="cl1">    # get image as numpy array</p>
<p class="cl1">    im = np.array(image)</p>
<p class="cl1">    # get shape</p>
<p class="cl1">    w,h = im.shape</p>
<p class="cl1">    # get average</p>
<p class="cl1">    return np.average(im.reshape(w*h))</p>
<p class="cl1f"><span aria-label=" Page 110. " class="page" epub:type="pagebreak" id="p110" role="doc-pagebreak"/>def convertImageToAscii(fileName, cols, scale, moreLevels):</p>
<p class="cl1">    """</p>
<p class="cl1">    given Image and dims (rows, cols) returns an m*n list of Images</p>
<p class="cl1">    """</p>
<p class="cl1">    # declare globals</p>
<p class="cl1">    global gscale1, gscale2</p>
<p class="cl1">    # open image and convert to grayscale</p>
<p class="cl1">    image = Image.open(fileName).convert('L')</p>
<p class="cl1">    # store dimensions</p>
<p class="cl1">    W, H = image.size[0], image.size[1]</p>
<p class="cl1">    print("input image dims: {} x {}".format(W, H))</p>
<p class="cl1">    # compute width of tile</p>
<p class="cl1">    w = W/cols</p>
<p class="cl1">    # compute tile height based on aspect ratio and scale</p>
<p class="cl1">    h = w/scale</p>
<p class="cl1">    # compute number of rows</p>
<p class="cl1">    rows = int(H/h)</p>
<p class="cl1f">    print("cols: {}, rows: {}".format(cols, rows))</p>
<p class="cl1">    print("tile dims: {} x {}".format(w, h))</p>
<p class="cl1f">    # check if image size is too small</p>
<p class="cl1">    if cols &gt; W or rows &gt; H:</p>
<p class="cl1">        print("Image too small for specified cols!")</p>
<p class="cl1">        exit(0)</p>
<p class="cl1f">    # an ASCII image is a list of character strings</p>
<p class="cl1">    aimg = []</p>
<p class="cl1">    # generate list of dimensions</p>
<p class="cl1">    for j in range(rows):</p>
<p class="cl1">        y1 = int(j*h)</p>
<p class="cl1">        y2 = int((j+1)*h)</p>
<p class="cl1">        # correct last tile</p>
<p class="cl1">        if j == rows-1:</p>
<p class="cl1">            y2 = H</p>
<p class="cl1">        # append an empty string</p>
<p class="cl1">        aimg.append("")</p>
<p class="cl1">        for i in range(cols):</p>
<p class="cl1">            # crop image to tile</p>
<p class="cl1">            x1 = int(i*w)</p>
<p class="cl1">            x2 = int((i+1)*w)</p>
<p class="cl1">            # correct last tile</p>
<p class="cl1">            if i == cols-1:</p>
<p class="cl1">                x2 = W</p>
<p class="cl1">            # crop image to extract tile</p>
<p class="cl1">            img = image.crop((x1, y1, x2, y2))</p>
<p class="cl1">            # get average luminance</p>
<p class="cl1">            avg = int(getAverageL(img))</p>
<p class="cl1">            # look up ASCII char</p>
<p class="cl1">            if moreLevels:</p>
<p class="cl1">                gsval = gscale1[int((avg*69)/255)]</p>
<p class="cl1">            else:</p>
<p class="cl1">                gsval = gscale2[int((avg*9)/255)]</p>
<p class="cl1">            # append ASCII char to string</p>
<p class="cl1">            aimg[j] += gsval</p>
<p class="cl1f"><span aria-label=" Page 111. " class="page" epub:type="pagebreak" id="p111" role="doc-pagebreak"/>    # return image</p>
<p class="cl1">    return aimg</p>
<p class="cl1f"># main() function</p>
<p class="cl1">def main():</p>
<p class="cl1">    # create parser</p>
<p class="cl1">    descStr = "This program converts an image into ASCII art."</p>
<p class="cl1">    parser = argparse.ArgumentParser(description=descStr)</p>
<p class="cl1">    # add expected arguments</p>
<p class="cl1">    parser.add_argument('--file', dest='imgFile', required=True)</p>
<p class="cl1">    parser.add_argument('--scale', dest='scale', required=False)</p>
<p class="cl1">    parser.add_argument('--out', dest='outFile', required=False)</p>
<p class="cl1">    parser.add_argument('--cols', dest='cols', required=False)</p>
<p class="cl1">    parser.add_argument('--morelevels',dest='moreLevels',action='store_true')</p>
<p class="cl1f">    # parse args</p>
<p class="cl1">    args = parser.parse_args()</p>
<p class="cl1f">    imgFile = args.imgFile</p>
<p class="cl1">    # set output file</p>
<p class="cl1">    outFile = 'out.txt'</p>
<p class="cl1">    if args.outFile:</p>
<p class="cl1">        outFile = args.outFile</p>
<p class="cl1">    # set scale default as 0.43, which suits a Courier font</p>
<p class="cl1">    scale = 0.43</p>
<p class="cl1">    if args.scale:</p>
<p class="cl1">        scale = float(args.scale)</p>
<p class="cl1">    # set cols</p>
<p class="cl1">    cols = 80</p>
<p class="cl1">    if args.cols:</p>
<p class="cl1">        cols = int(args.cols)</p>
<p class="cl1f">    print('generating ASCII art...')</p>
<p class="cl1">    # convert image to ASCII text</p>
<p class="cl1">    aimg = convertImageToAscii(imgFile, cols, scale, args.moreLevels)</p>
<p class="cl1f">    # open file</p>
<p class="cl1">    f = open(outFile, 'w')</p>
<p class="cl1">    # write to file</p>
<p class="cl1">    for row in aimg:</p>
<p class="cl1">        f.write(row + '\n')</p>
<p class="cl1">    # clean up</p>
<p class="cl1">    f.close()</p>
<p class="cl1">    print("ASCII art written to {}.".format(outFile))</p>
<p class="cl1f"># call main</p>
<p class="cl1">if __name__ == '__main__':</p>
<p class="cl1">    main()</p>
</div>
</section>
</section>
</div></body></html>