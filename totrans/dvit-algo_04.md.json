["```py\nx = 105\ny = 33\nbig = max(x,y)\nsmall = min(x,y)\n```", "```py\nimport math\noutput = []\nquotient = math.floor(big/small)\noutput.append(quotient)\n```", "```py\nnew_small = big % small\nbig = small\nsmall = new_small\n```", "```py\nimport math\ndef continued_fraction(x,y,length_tolerance):\n    output = []\n    big = max(x,y)\n    small = min(x,y)\n\n while small > 0 and len(output) < length_tolerance:\n        quotient = math.floor(big/small)\n        output.append(quotient)\n        new_small = big % small\n        big = small\n        small = new_small\n    return(output)\n```", "```py\nprint(continued_fraction(105,33,10))\n```", "```py\n[3,5,2]\n```", "```py\ndef get_number(continued_fraction):\n    index = -1\n    number = continued_fraction[index]\n\n    while abs(index) < len(continued_fraction):\n        next = continued_fraction[index - 1]\n        number = 1/number + next\n        index -= 1\n    return(number) \n```", "```py\nx = 1.4142135623730951\noutput = []\nfirst_term = int(x)\nleftover = x - int(x)\noutput.append(first_term)\n```", "```py\nnext_term = math.floor(1/leftover)\nleftover = 1/leftover - next_term\noutput.append(next_term)\n```", "```py\ndef continued_fraction_decimal(x,error_tolerance,length_tolerance):\n    output = []\n    first_term = int(x)\n    leftover = x - int(x)\n    output.append(first_term)\n    error = leftover\n    while error > error_tolerance and len(output) <length_tolerance:\n        next_term = math.floor(1/leftover)\n        leftover = 1/leftover - next_term\n        output.append(next_term)\n        error = abs(get_number(output) - x)\n    return(output)\n```", "```py\nprint(continued_fraction_decimal(1.4142135623730951,0.00001,100))\n```", "```py\n[1, 2, 2, 2, 2, 2, 2, 2]\n```", "```py\ndef square_root(x,y,error_tolerance):\n    our_error = error_tolerance * 2\n    while(our_error > error_tolerance):\n        z = x/y\n        y = (y + z)/2\n        our_error = y**2 - x\n    return y\n```", "```py\nprint(square_root(5,1,.000000000000001))\n```", "```py\nprint(math.sqrt(5))\n```", "```py\ndef next_random(previous,n1,n2,n3):\n    the_next = (previous * n1 + n2) % n3\n    return(the_next)\n```", "```py\ndef list_random(n1,n2,n3):\n    output = [1]\n    while len(output) <=n3:\n        output.append(next_random(output[len(output) - 1],n1,n2,n3))\n    return(output)\n```", "```py\n[1, 20, 27, 6, 5, 8, 31, 26, 9, 28, 3, 14, 13, 16, 7, 2, 17, 4, 11, 22, 21, 24, 15, 10, 25, 12, 19, 30, 29, 0, 23, 18, 1]\n```", "```py\n[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 1]\n```", "```py\n[1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1]\n```", "```py\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 0, 1]\n```", "```py\ndef overlapping_sums(the_list,sum_length):\n    length_of_list = len(the_list)\n    the_list.extend(the_list)\n    output = []\n    for n in range(0,length_of_list):\n        output.append(sum(the_list[n:(n + sum_length)]))\n    return(output)\n```", "```py\nimport matplotlib.pyplot as plt\noverlap = overlapping_sums(list_random(211111,111112,300007),12)\nplt.hist(overlap, 20, facecolor = 'blue', alpha = 0.5)\nplt.title('Results of the Overlapping Sums Test')\nplt.xlabel('Sum of Elements of Overlapping Consecutive Sections of List')\nplt.ylabel('Frequency of Sum')\nplt.show()\n```", "```py\nbits = [1,1,1]\n```", "```py\nxor_result = (bits[1] + bits[2]) % 2\n```", "```py\noutput = bits.pop()\n```", "```py\nbits.insert(0,xor_result)\n```", "```py\ndef feedback_shift(bits):\n    xor_result = (bits[1] + bits[2]) % 2\n    output = bits.pop()\n    bits.insert(0,xor_result)\n    return(bits,output)\n```", "```py\ndef feedback_shift_list(bits_this):\n    bits_output = [bits_this.copy()]\n    random_output = []\n    bits_next = bits_this.copy()\n while(len(bits_output) < 2**len(bits_this)):\n        bits_next,next = feedback_shift(bits_next)\n        bits_output.append(bits_next.copy())\n        random_output.append(next)\n    return(bits_output,random_output)\n```", "```py\nbitslist = feedback_shift_list([1,1,1])[0]\n```", "```py\n[[1, 1, 1], [0, 1, 1], [0, 0, 1], [1, 0, 0], [0, 1, 0], [1, 0, 1], [1, 1, 0], [1, 1, 1]]\n```", "```py\npseudorandom_bits = feedback_shift_list([1,1,1])[1]\n```", "```py\n[1, 1, 1, 0, 0, 1, 0]\n```"]