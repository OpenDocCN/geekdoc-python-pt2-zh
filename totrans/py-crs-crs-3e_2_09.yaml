- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with APIs
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll learn how to write a self-contained program that generates
    a visualization based on data it retrieves. Your program will use an *application
    programming interface (**API)* to automatically request specific information from
    a website and then use that information to generate a visualization. Because programs
    written like this will always use current data to generate a visualization, even
    when that data might be rapidly changing, the visualization will always be up
    to date.
  prefs: []
  type: TYPE_NORMAL
- en: Using an API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An API is a part of a website designed to interact with programs. Those programs
    use very specific URLs to request certain information. This kind of request is
    called an *API call*. The requested data will be returned in an easily processed
    format, such as JSON or CSV. Most apps that use external data sources, such as
    apps that integrate with social media sites, rely on API calls.
  prefs: []
  type: TYPE_NORMAL
- en: Git and GitHub
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll base our visualization on information from GitHub ([https://github.com](https://github.com)),
    a site that allows programmers to collaborate on coding projects. We’ll use GitHub’s
    API to request information about Python projects on the site, and then generate
    an interactive visualization of the relative popularity of these projects using
    Plotly.
  prefs: []
  type: TYPE_NORMAL
- en: 'GitHub takes its name from Git, a distributed version control system. Git helps
    people manage their work on a project in a way that prevents changes made by one
    person from interfering with changes other people are making. When you implement
    a new feature in a project, Git tracks the changes you make to each file. When
    your new code works, you *commit* the changes you’ve made, and Git records the
    new state of your project. If you make a mistake and want to revert your changes,
    you can easily return to any previously working state. (To learn more about version
    control using Git, see Appendix D.) Projects on GitHub are stored in *repositories*,
    which contain everything associated with the project: its code, information on
    its collaborators, any issues or bug reports, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: When users on GitHub like a project, they can “star” it to show their support
    and keep track of projects they might want to use. In this chapter, we’ll write
    a program to automatically download information about the most-starred Python
    projects on GitHub, and then we’ll create an informative visualization of these
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Requesting Data Using an API Call
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'GitHub’s API lets you request a wide range of information through API calls.
    To see what an API call looks like, enter the following into your browser’s address
    bar and press ENTER:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This call returns the number of Python projects currently hosted on GitHub,
    as well as information about the most popular Python repositories. Let’s examine
    the call. The first part, `https://api.github.com/`, directs the request to the
    part of GitHub that responds to API calls. The next part, `search/repositories`,
    tells the API to conduct a search through all the repositories on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: The question mark after `repositories` signals that we’re about to pass an argument.
    The `q` stands for *query*, and the equal sign (`=`) lets us begin specifying
    a query (`q=`). By using `language:python`, we indicate that we want information
    only on repositories that have Python as the primary language. The final part,
    `+sort:stars`, sorts the projects by the number of stars they’ve been given.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows the first few lines of the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the response that this URL is not primarily intended to be
    entered by humans, because it’s in a format that’s meant to be processed by a
    program. GitHub found just under nine million Python projects as of this writing
    ❶. The value for `"incomplete_results"` is `true`, which tells us that GitHub
    didn’t fully process the query ❷. GitHub limits how long each query can run, in
    order to keep the API responsive for all users. In this case it found some of
    the most popular Python repositories, but it didn’t have time to find all of them;
    we’ll fix that in a moment. The `"items"` returned are displayed in the list that
    follows, which contains details about the most popular Python projects on GitHub
    ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *Requests* package allows a Python program to easily request information
    from a website and examine the response. Use pip to install Requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use a command other than `python` to run programs or start a terminal
    session, such as `python3`, your command will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Processing an API Response
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we’ll write a program to automatically issue an API call and process the
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '**python_repos.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We first import the `requests` module. Then we assign the URL of the API call
    to the `url` variable ❶. This is a long URL, so we break it into two lines. The
    first line is the main part of the URL, and the second line is the query string.
    We’ve included one more condition to the original query string: `stars:>10000`,
    which tells GitHub to only look for Python repositories that have more than 10,000
    stars. This should allow GitHub to return a complete, consistent set of results.'
  prefs: []
  type: TYPE_NORMAL
- en: GitHub is currently on the third version of its API, so we define headers for
    the API call that ask explicitly to use this version of the API, and return the
    results in the JSON format ❷. Then we use `requests` to make the call to the API
    ❸. We call `get()` and pass it the URL and the header that we defined, and we
    assign the response object to the variable `r`.
  prefs: []
  type: TYPE_NORMAL
- en: The response object has an attribute called `status_code`, which tells us whether
    the request was successful. (A status code of 200 indicates a successful response.)
    We print the value of `status_code` so we can make sure the call went through
    successfully ❹. We asked the API to return the information in JSON format, so
    we use the `json()` method to convert the information to a Python dictionary ❺.
    We assign the resulting dictionary to `response_dict`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we print the keys from `response_dict` and see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the status code is `200`, we know that the request was successful.
    The response dictionary contains only three keys: `''total_count''`, `''incomplete_results''`,
    and `''items''`. Let’s take a look inside the response dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Response Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the information from the API call represented as a dictionary, we can
    work with the data stored there. Let’s generate some output that summarizes the
    information. This is a good way to make sure we received the information we expected,
    and to start examining the information we’re interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: '**python_repos.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We start exploring the response dictionary by printing the value associated
    with `''total_count''`, which represents the total number of Python repositories
    returned by this API call ❶. We also use the value associated with `''incomplete_results''`,
    so we''ll know if GitHub was able to fully process the query. Rather than printing
    this value directly, we print its opposite: a value of `True` will indicate that
    we received a complete set of results.'
  prefs: []
  type: TYPE_NORMAL
- en: The value associated with `'items'` is a list containing a number of dictionaries,
    each of which contains data about an individual Python repository. We assign this
    list of dictionaries to `repo_dicts` ❷. We then print the length of `repo_dicts`
    to see how many repositories we have information for.
  prefs: []
  type: TYPE_NORMAL
- en: To look closer at the information returned about each repository, we pull out
    the first item from `repo_dicts` and assign it to `repo_dict` ❸. We then print
    the number of keys in the dictionary to see how much information we have ❹. Finally,
    we print all the dictionary’s keys to see what kind of information is included
    ❺.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results give us a clearer picture of the actual data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: At the time of this writing, there are only `248` Python repositories with over
    10,000 stars ❶. We can see that GitHub was able to fully process the API call
    ❷. In this response, GitHub returned information about the first `30` repositories
    that match the conditions of our query. If we want more repositories, we can request
    additional pages of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'GitHub’s API returns a lot of information about each repository: there are
    `78` keys in `repo_dict` ❸. When you look through these keys, you’ll get a sense
    of the kind of information you can extract about a project. (The only way to know
    what information is available through an API is to read the documentation or to
    examine the information through code, as we’re doing here.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s pull out the values for some of the keys in `repo_dict`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**python_repos.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we print the values for a number of keys from the first repository’s dictionary.
    We start with the name of the project ❶. An entire dictionary represents the project’s
    owner, so we use the key `owner` to access the dictionary representing the owner,
    and then use the key `login` to get the owner’s login name ❷. Next, we print how
    many stars the project has earned ❸ and the URL for the project’s GitHub repository.
    We then show when it was created ❹ and when it was last updated ❺. Finally, we
    print the repository’s description.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the most-starred Python project on GitHub as of this writing
    is *public-apis*. Its owner is an organization with the same name, and it has
    been starred by almost 200,000 GitHub users. We can see the URL for the project’s
    repository, its creation date of March 2016, and that it was updated recently.
    Additionally, the description tells us that *public-apis* contains a list of free
    APIs that programmers might be interested in.
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing the Top Repositories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we make a visualization for this data, we’ll want to include more than
    one repository. Let’s write a loop to print selected information about each repository
    the API call returns so we can include them all in the visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '**python_repos.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We first print an introductory message ❶. Then we loop through all the dictionaries
    in `repo_dicts` ❷. Inside the loop, we print the name of each project, its owner,
    how many stars it has, its URL on GitHub, and the project’s description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Some interesting projects appear in these results, and it might be worth looking
    at a few. But don’t spend too much time here, because we’re about to create a
    visualization that will make the results much easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring API Rate Limits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most APIs have *rate limits*, which means there’s a limit to how many requests
    you can make in a certain amount of time. To see if you’re approaching GitHub’s
    limits, enter [https://api.github.com/rate_limit](https://api.github.com/rate_limit%20)
    into a web browser. You should see a response that begins like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The information we’re interested in is the rate limit for the search API ❶.
    We see that the limit is 10 requests per minute ❷ and that we have 9 requests
    remaining for the current minute ❸. The value associated with the key `"reset"`
    represents the time in *Unix* or *epoch time* (the number of seconds since midnight
    on January 1, 1970) when our quota will reset ❹. If you reach your quota, you’ll
    get a short response that lets you know you’ve reached the API limit. If you reach
    the limit, just wait until your quota resets.
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing Repositories Using Plotly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s make a visualization using the data we’ve gathered to show the relative
    popularity of Python projects on GitHub. We’ll make an interactive bar chart:
    the height of each bar will represent the number of stars the project has acquired,
    and you’ll be able to click the bar’s label to go to that project’s home on GitHub.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Save a copy of the program we’ve been working on as *python_repos_visual.py*,
    then modify it so it reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**python_repos_visual.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We import Plotly Express and then make the API call as we have been doing. We
    continue to print the status of the API call response so we’ll know if there is
    a problem ❶. When we process the overall results, we continue to print the message
    confirming that we got a complete set of results ❷. We remove the rest of the
    `print()` calls because we’re no longer in the exploratory phase; we know we have
    the data we want.
  prefs: []
  type: TYPE_NORMAL
- en: We then create two empty lists ❸ to store the data we’ll include in the initial
    chart. We’ll need the name of each project to label the bars (`repo_names`) and
    the number of stars to determine the height of the bars (`stars`). In the loop,
    we append the name of each project and the number of stars it has to these lists.
  prefs: []
  type: TYPE_NORMAL
- en: We make the initial visualization with just two lines of code ❹. This is consistent
    with Plotly Express’s philosophy that you should be able to see your visualization
    as quickly as possible before refining its appearance. Here we use the `px.bar()`
    function to create a bar chart. We pass the list `repo_names` as the `x` argument
    and `stars` as the `y` argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 17-1](#figure17-1) shows the resulting chart. We can see that the first
    few projects are significantly more popular than the rest, but all of them are
    important projects in the Python ecosystem.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c17/f17001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-1: The most-starred Python projects on GitHub'
  prefs: []
  type: TYPE_NORMAL
- en: Styling the Chart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Plotly supports a number of ways to style and customize the plots, once you
    know the information in the plot is correct. We’ll make some changes in the initial
    `px.bar()` call and then make some further adjustments to the `fig` object after
    it’s been created.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start styling the chart by adding a title and labels for each axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '**python_repos_visual.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We first add a title and labels for each axis, as we did in Chapters 15 and
    16. We then use the `fig.update_layout()` method to modify specific elements of
    the chart ❶. Plotly uses a convention where aspects of a chart element are connected
    by underscores. As you become familiar with Plotly’s documentation, you’ll start
    to see consistent patterns in how different elements of a chart are named and
    modified. Here we set the title font size to `28` and the font size for each axis
    title to `20`. The result is shown in [Figure 17-2](#figure17-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c17/f17002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-2: A title has been added to the main chart, and to each axis as
    well.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding Custom Tooltips
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Plotly, you can hover the cursor over an individual bar to show the information
    the bar represents. This is commonly called a *tooltip*, and in this case, it
    currently shows the number of stars a project has. Let’s create a custom tooltip
    to show each project’s description as well as the project’s owner.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to pull some additional data to generate the tooltips:'
  prefs: []
  type: TYPE_NORMAL
- en: '**python_repos_visual.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We first define a new empty list, `hover_texts`, to hold the text we want to
    display for each project ❶. In the loop where we process the data, we pull the
    owner and the description for each project ❷. Plotly allows you to use HTML code
    within text elements, so we generate a string for the label with a line break
    (`<br />`) between the project owner’s username and the description ❸. We then
    append this label to the list `hover_texts`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `px.bar()` call, we add the `hover_name` argument and pass it `hover_texts`
    ❹. This is the same approach we used to customize the label for each dot in the
    map of global earthquake activity. As Plotly creates each bar, it will pull labels
    from this list and only display them when the viewer hovers over a bar. [Figure
    17-3](#figure17-3) shows one of these custom tooltips.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c17/f17003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-3: Hovering over a bar shows the project’s owner and description.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding Clickable Links
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because Plotly allows you to use HTML on text elements, we can easily add links
    to a chart. Let’s use the *x*-axis labels as a way to let the viewer visit any
    project’s home page on GitHub. We need to pull the URLs from the data and use
    them when generating the *x*-axis labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '**python_repos_visual.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We update the name of the list we’re creating from `repo_names` to `repo_links`
    to more accurately communicate the kind of information we’re putting together
    for the chart ❶. We then pull the URL for the project from `repo_dict` and assign
    it to the temporary variable `repo_url` ❷. Next, we generate a link to the project
    ❸. We use the HTML anchor tag, which has the form `<a href='URL'>link text</a>`,
    to generate the link. We then append this link to `repo_links`.
  prefs: []
  type: TYPE_NORMAL
- en: When we call `px.bar()`, we use `repo_links` for the *x*-values in the chart.
    The result looks the same as before, but now the viewer can click any of the project
    names at the bottom of the chart to visit that project’s home page on GitHub.
    Now we have an interactive, informative visualization of data retrieved through
    an API!
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Marker Colors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once a chart has been created, almost any aspect of the chart can be customized
    through an update method. We’ve used the `update_layout()` method previously.
    Another method, `update_traces()`, can be used to customize the data that’s represented
    on a chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s change the bars to a darker blue, with some transparency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In Plotly, a *trace* refers to a collection of data on a chart. The `update_traces()`
    method can take a number of different arguments; any argument that starts with
    `marker_` affects the markers on the chart. Here we set each marker’s color to
    `'SteelBlue'`; any named CSS color will work here. We also set the opacity of
    each marker to `0.6`. An opacity of 1.0 will be entirely opaque, and an opacity
    of 0 will be entirely invisible.
  prefs: []
  type: TYPE_NORMAL
- en: More About Plotly and the GitHub API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Plotly’s documentation is extensive and well organized; however, it can be hard
    to know where to start reading. A good place to start is with the article “Plotly
    Express in Python,” at [https://plotly.com/python/plotly-express](https://plotly.com/python/plotly-express).
    This is an overview of all the plots you can make with Plotly Express, and you
    can find links to longer articles about each individual chart type.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to understand how to customize Plotly charts better, the article
    “Styling Plotly Express Figures in Python” will expand on what you’ve seen in
    Chapters 15–17. You can find this article at [https://plotly.com/python/styling-plotly-express](https://plotly.com/python/styling-plotly-express).
  prefs: []
  type: TYPE_NORMAL
- en: For more about the GitHub API, refer to its documentation at [https://docs.github.com/en/rest](https://docs.github.com/en/rest).
    Here you’ll learn how to pull a wide variety of information from GitHub. To expand
    on what you saw in this project, look for the Search section of the reference
    in the sidebar. If you have a GitHub account, you can work with your own data
    as well as the publicly available data from other users’ repositories.
  prefs: []
  type: TYPE_NORMAL
- en: The Hacker News API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To explore how to use API calls on other sites, let’s take a quick look at Hacker
    News ([https://news.ycombinator.com](https://news.ycombinator.com)). On Hacker
    News, people share articles about programming and technology and engage in lively
    discussions about those articles. The Hacker News API provides access to data
    about all submissions and comments on the site, and you can use the API without
    having to register for a key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following call returns information about the current top article as of
    this writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When you enter this URL in a browser, you’ll see that the text on the page
    is enclosed by braces, meaning it’s a dictionary. But the response is difficult
    to examine without some better formatting. Let’s run this URL through the `json.dumps()`
    method, like we did in the earthquake project in Chapter 16, so we can explore
    the kind of information that’s returned about an article:'
  prefs: []
  type: TYPE_NORMAL
- en: '**hn_article.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Everything in this program should look familiar, because we’ve used it all in
    the previous two chapters. The main difference here is that we can print the formatted
    response string ❶ instead of writing it to a file, because the output is not particularly
    long.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is a dictionary of information about the article with the ID `31353677`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The dictionary contains a number of keys we can work with. The key `"descendants"`
    tells us the number of comments the article has received ❶. The key `"kids"` provides
    the IDs of all comments made directly in response to this submission ❷. Each of
    these comments might have comments of their own as well, so the number of descendants
    a submission has is usually greater than its number of kids. We can see the title
    of the article being discussed ❸ and a URL for the article being discussed as
    well ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following URL returns a simple list of all the IDs of the current top articles
    on Hacker News:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this call to find out which articles are on the home page right
    now, and then generate a series of API calls similar to the one we just examined.
    With this approach, we can print a summary of all the articles on the front page
    of Hacker News at the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**hn_submissions.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: First, we make an API call and print the status of the response ❶. This API
    call returns a list containing the IDs of up to 500 of the most popular articles
    on Hacker News at the time the call is issued. We then convert the response object
    to a Python list ❷, which we assign to `submission_ids`. We’ll use these IDs to
    build a set of dictionaries, each of which contains information about one of the
    current submissions.
  prefs: []
  type: TYPE_NORMAL
- en: We set up an empty list called `submission_dicts` to store these dictionaries
    ❸. We then loop through the IDs of the top 30 submissions. We make a new API call
    for each submission by generating a URL that includes the current value of `submission_id`
    ❹. We print the status of each request along with its ID, so we can see whether
    it’s successful.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a dictionary for the submission currently being processed ❺.
    We store the title of the submission, a link to the discussion page for that item,
    and the number of comments the article has received so far. Then we append each
    `submission_dict` to the list `submission_dicts` ❻.
  prefs: []
  type: TYPE_NORMAL
- en: Each submission on Hacker News is ranked according to an overall score based
    on a number of factors, including how many times it’s been voted on, how many
    comments it’s received, and how recent the submission is. We want to sort the
    list of dictionaries by the number of comments. To do this, we use a function
    called `itemgetter()` ❼, which comes from the `operator` module. We pass this
    function the key `'comments'`, and it pulls the value associated with that key
    from each dictionary in the list. The `sorted()` function then uses this value
    as its basis for sorting the list. We sort the list in reverse order, to place
    the most-commented stories first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the list is sorted, we loop through the list ❽ and print out three pieces
    of information about each of the top submissions: the title, a link to the discussion
    page, and the number of comments the submission currently has:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You would use a similar process to access and analyze information with any API.
    With this data, you could make a visualization showing which submissions have
    inspired the most active recent discussions. This is also the basis for apps that
    provide a customized reading experience for sites like Hacker News. To learn more
    about what kind of information you can access through the Hacker News API, visit
    the documentation page at [https://github.com/HackerNews/API](https://github.com/HackerNews/API).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use APIs to write self-contained programs
    that automatically gather the data they need and use that data to create a visualization.
    You used the GitHub API to explore the most-starred Python projects on GitHub,
    and you also looked briefly at the Hacker News API. You learned how to use the
    Requests package to automatically issue an API call and how to process the results
    of that call. We also introduced some Plotly settings that further customize the
    appearance of the charts you generate.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll use Django to build a web application as your final
    project.
  prefs: []
  type: TYPE_NORMAL
