- en: '**4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4'
- en: DECODING AMERICAN CIVIL WAR CIPHERS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**解码美国内战密码**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Cryptography is the science of secure communication through the use of *codes*
    and *ciphers*. A code replaces whole words with other words; a cipher scrambles
    or replaces the letters in words (so technically, Morse code is really Morse cipher).
    One goal of cryptography is to use a *key* to both *encrypt* readable *plaintext*
    into unreadable *ciphertext* and then *decrypt* it back to plaintext. The goal
    of *cryptanalysis* is to decode ciphers and codes without knowing their key or
    encryption algorithm.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学是通过使用*代码*和*密码*实现安全通信的科学。代码将整个单词替换为其他单词；密码则是对单词中的字母进行混排或替换（因此，摩尔斯电码实际上就是摩尔斯密码）。密码学的一个目标是使用*密钥*将可读的*明文*加密成不可读的*密文*，然后再*解密*回明文。*密码分析*的目标是解码密码和代码，而不需要知道它们的密钥或加密算法。
- en: 'In this chapter, we’ll investigate two ciphers used in the American Civil War:
    the route cipher, used by the North, and the rail fence cipher, used by both sides.
    We’ll also look at what made one so successful and how we can use lessons learned
    from its application to better write programs for inexperienced users and those
    unfamiliar with your Python code.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将研究美国内战中使用的两种密码：北方使用的路线密码和双方都使用的铁路篱笆密码。我们还将探讨是什么使其中一种密码如此成功，并且我们可以如何借鉴其应用中的经验教训，来更好地为没有经验的用户和那些不熟悉你Python代码的用户编写程序。
- en: '**Project #8: The Route Cipher**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #8：路线密码**'
- en: In the American Civil War, the Union had just about every advantage over the
    Confederacy, including the field of cryptography. The Union had better codes,
    better ciphers, and better-trained personnel. But perhaps its biggest advantage
    was in leadership and organization.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在美国内战中，联邦几乎在所有领域都比南方联邦占有优势，包括密码学。联邦拥有更好的代码、更好的密码和更训练有素的人员。但或许其最大优势在于领导力和组织能力。
- en: The head of the US Military Telegraph Department was Anson Stager ([Figure 4-1](ch04.xhtml#ch04fig1)).
    As the cofounder of Western Union, Stager knew from experience that telegraph
    operators made fewer mistakes when sending whole words, as opposed to the strings
    of random letters and numbers common to most ciphertext. He also knew that military
    dispatches only needed to stay secret long enough for orders to be carried out.
    His secure solution was a hybrid cryptosystem called the *route transposition
    cipher*, a combination of transposed real words and code words that became one
    of the most successful military ciphers of all time.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 美国军事电报部门的负责人是安森·斯塔杰（[图 4-1](ch04.xhtml#ch04fig1)）。作为西联汇款的共同创始人，斯塔杰通过经验了解到，电报操作员在发送完整单词时犯错较少，而不像大多数密文那样由随机字母和数字组成。他还知道，军事命令只需要保持机密，直到指令执行完毕为止。他的安全解决方案是一种混合加密系统，称为*路线换位密码*，它结合了重排的真实单词和代码单词，成为历史上最成功的军事密码之一。
- en: '![image](../images/f0064-01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0064-01.jpg)'
- en: '*Figure 4-1: General Anson Stager, US Telegraph Corps, 1865*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：安森·斯塔杰将军，美国电报队，1865年*'
- en: Transposition ciphers *scramble* the arrangement of letters or words, unlike
    substitution ciphers, which *replace* the letters in the plaintext with different
    characters or symbols. [Figure 4-2](ch04.xhtml#ch04fig2) shows an example of a
    route transposition cipher. The message is written left to right over a number
    of predetermined columns and rows, important plaintext words are replaced by code
    words, and the last row is filled with dummy placeholder words. The reader determines
    the order of the rearranged words by traversing up and down these columns, as
    shown. The starting word is *REST*, and then the encryption route is shown with
    arrows.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 换位密码*打乱*字母或单词的排列方式，不同于替代密码，后者*替换*明文中的字母，用不同的字符或符号。[图 4-2](ch04.xhtml#ch04fig2)展示了一个路线换位密码的示例。消息从左到右书写，在多个预定的列和行上，重要的明文单词被代码词替换，最后一行填充了虚拟占位符单词。读者通过上下遍历这些列来确定重排单词的顺序，如图所示。起始单词是*REST*，然后通过箭头显示加密路线。
- en: '![image](../images/f0065-01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0065-01.jpg)'
- en: '*Figure 4-2: A route cipher using actual Union code words*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-2：使用实际联邦代码词的路线密码*'
- en: To fully decode this message, you need to know both the starting point and route
    used to traverse the message and create the final ciphertext *and* the meaning
    of the code words.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全解码这条消息，你需要知道起点和用来遍历消息并创建最终密文的路线*以及*代码词的含义。
- en: 'In the early 20th century, the distinguished military cryptanalyst William
    Friedman disparaged Stager’s route cipher. He considered it too unsophisticated
    and found it highly improbable that the Confederates never cracked it. But the
    fact remains that hundreds of thousands of route ciphers sent during the war were
    apparently never decoded, and not from lack of trying. In an early example of
    crowdsourcing, the Confederates published the coded messages in newspapers, hoping
    for some help with the decryption, but to no avail. While some historians speculate
    that this cipher was broken at times, Stager’s design teaches several important
    lessons:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪初，著名的军事密码分析师威廉·弗里德曼贬低了Stager的路线密码。他认为它过于简单，并认为南方联邦军队不可能从未破解过它。但事实仍然是，战时发送的数十万个路线密码显然从未被解码，且并非因为缺乏尝试。作为众包的早期实例，南方联邦将加密消息刊登在报纸上，希望能得到一些解密帮助，但未果。虽然一些历史学家推测这一密码有时被破解，但Stager的设计教给我们几个重要的教训：
- en: '**Design for human error.** Military ciphers have to be simple, as hundreds
    might be sent in a day. The real words used in the route cipher made it much less
    likely to be garbled by telegraph operators. Stager knew his customer and designed
    for them. He recognized the limitations of his workforce and tailored his product
    accordingly. The Confederates, by contrast, had great difficulty deciphering their
    own complex messages, sometimes giving up and riding around enemy lines to talk
    face-to-face!'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**为人为错误设计。** 军事密码必须简洁，因为一天可能会发送数百条。路线密码中使用的真实单词使其更不容易被电报操作员弄乱。Stager了解他的客户，并为他们量身设计。他认识到自己员工的局限性，并根据这些局限性调整了产品。相比之下，南方联邦军队在解密自己复杂的消息时遇到了很大困难，有时甚至放弃并绕过敌军去面对面交谈！'
- en: '**Innovation trumps invention.** Sometimes you don’t need to invent something
    new; you just need to rediscover something old. The short word-transposition ciphers
    suitable for telegraph transmission were too weak to use on their own, but combined
    with code names and disruptive dummy words, they confounded the Confederates.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**创新胜于发明。** 有时你不需要发明新东西；你只需要重新发现旧东西。适用于电报传输的短词换位密码本身太弱，不能单独使用，但通过结合密码名和干扰性虚词，它们使南方联邦难以破解。'
- en: '**Share learning.** Because everyone in the Telegraph Corps used the same methodology,
    it was easy to build on existing techniques and share lessons learned. This allowed
    the route cipher to evolve over time with the introduction of slang and intentional
    misspellings, as well as a growing number of code words for places, people, and
    dates.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**共享学习**。由于电报队中的每个人都使用相同的方法论，因此很容易在现有技术上进行改进并共享经验教训。这使得随着俚语、故意拼写错误的引入，以及越来越多的地点、人物和日期的密码词的出现，路线密码得以随时间演变。'
- en: Stager’s practical cipher may not have pleased later “purists,” but it was the
    perfect design for the time. The concepts behind it are timeless and easily transferable
    to modern-day applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Stager的实用密码可能没有让后来的“纯粹主义者”满意，但它在当时是完美的设计。其背后的概念是永恒的，且易于转化为现代应用。
- en: '**THE OBJECTIVE**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: In Harry Turtledove’s award-winning 1992 novel *Guns of the South*, time travelers
    provide Confederate armies with modern weaponry, changing the course of history.
    Instead of AK-47s, let’s pretend you’ve traveled back to 1864 with your laptop,
    a few extra batteries, and Python to design an algorithm that will decrypt a route
    cipher based on an assumed encryption matrix and path. In the spirit of Stager,
    you’ll write a user-friendly program that will reduce human error.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在哈里·特图尔多夫的1992年获奖小说《南方的枪火》中，时间旅行者为南方军队提供现代武器，从而改变了历史的进程。假设你没有携带AK-47，而是带着你的笔记本电脑、几个额外的电池和Python回到了1864年，设计一种基于假设的加密矩阵和路径来解密路线密码的算法。在Stager的精神下，你将编写一个用户友好的程序，减少人为错误。
- en: '***The Strategy***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: When it comes to solving ciphers, it’s a lot easier if you know what type you’re
    dealing with. In this case, you know it’s a transposition cipher, because it’s
    composed of real words that are jumbled. You also know there are code words and
    null words present. Your job is to figure out ways to decrypt the *transposition*
    part of the route cipher and let someone else worry about code words while you
    go have a well-deserved mint julep.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决密码时，如果你知道自己面对的是哪种类型的密码，事情就会变得容易得多。在这种情况下，你知道它是一个换位密码，因为它由真实的单词组成并被打乱。你还知道其中有密码词和虚词。你的任务是找出解密*换位*部分的方式，而让别人担心密码词的部分，同时你去好好享受一杯应得的薄荷朱利普。
- en: '**Creating a Control Message**'
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建控制消息**'
- en: 'To understand how to do this, create your own message and route cipher. Call
    this your *control message*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Number of columns = 4
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of rows = 5
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start position = Bottom left
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Route = Alternating up and down columns
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plaintext = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ciphertext = 16 12 8 4 0 1 5 9 13 17 18 14 10 6 2 3 7 11 15 19
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key = –1 2 –3 4
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a numeric progression for the plaintext allows you to instantly tell whether
    you’ve gotten all or part of the decryption correct, at any place within the message.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The transposition matrix is shown in [Figure 4-3](ch04.xhtml#ch04fig3). The
    gray arrows indicate the encryption route.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0067-01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: The transposition matrix for the control message with the route
    cipher path and resulting ciphertext*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'The key keeps track of both the *order* and *direction* of the route through
    the columns. The route doesn’t have to move through the columns in order. For
    instance, it can move down the first column, up the third, down the fourth, and
    finally up the second. Negative numbers mean you start at the bottom and read
    up a column; positive numbers mean the reverse. For the control message, the final
    key used in the program will be a list: [–1, 2, –3, 4]. This list will instruct
    the program to start reading up from the bottom of column 1, move to the top of
    column 2 and read down, move to the bottom of column 3 and read up, and move to
    the top of column 4 and read down.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Note that you shouldn’t use 0 in keys because the users, being human, prefer
    to start counting at 1\. Of course, Python prefers to start counting at 0, so
    you’ll need to subtract 1 from the key values behind the scenes. Everybody wins!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, in “[Route Transposition Cipher: Brute-Force Attack](ch04.xhtml#lev111)”
    on [page 88](ch04.xhtml#page_88), you can use this compact key structure to brute-force
    your way through a route cipher, automatically trying hundreds of keys until the
    plaintext is restored.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**Designing, Populating, and Depopulating the Matrix**'
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You’ll input the ciphertext as a continuous string. For your program to unravel
    the route through this string, you’ll first need to build and populate a translation
    matrix. The ciphertext string is just the columns in the transposition matrix
    in [Figure 4-3](ch04.xhtml#ch04fig3) laid end to end, in the order they were read.
    And as there are five rows in the transposition matrix, every group of five elements
    in the ciphertext represents a separate column. You can represent this matrix
    with a list of lists:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '>>> list_of_lists = [[''16'', ''12'', ''8'', ''4'', ''0''], [''1'', ''5'',
    ''9'', ''13'', ''17''],'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[''18'', ''14'', ''10'', ''6'', ''2''], [''3'', ''7'', ''11'', ''15'', ''19'']]'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'The items in this new list now represent lists—with each list representing
    a column—and the five elements in each list represent the rows that comprise that
    column. This is a little hard to see, so let’s print each of these nested lists
    on a separate line:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for nested_list in list_of_lists'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: print(nested_list)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[16, 12, 8, 4, 0]'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[16, 12, 8, 4, 0]'
- en: '[1, 5, 9, 13, 17]'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[1, 5, 9, 13, 17]'
- en: '[18, 14, 10, 6, 2]'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[18, 14, 10, 6, 2]'
- en: '[3, 7, 11, 15, 19]'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[3, 7, 11, 15, 19]'
- en: If you read each list left to right, starting at the top, you follow the transposition
    route, which was up and down alternate columns (see [Figure 4-3](ch04.xhtml#ch04fig3)).
    From Python’s point of view, the first column read is list-of-lists[0], and the
    starting point is list-of-lists[0][0].
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从上到下、从左到右读取每个列表，你将遵循转置路线，即上下一列交替（参见[图4-3](ch04.xhtml#ch04fig3)）。从Python的角度看，第一个读取的列是list-of-lists[0]，起点是list-of-lists[0][0]。
- en: 'Now, normalize the route by reading all columns in the same direction as the
    starting column (up). This requires reversing the order of elements in every other
    list, as shown in bold here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过按与起始列相同的方向（向上）读取所有列来规范化路线。这需要反转每个其他列表中的元素顺序，如这里所示的粗体部分：
- en: '[16, 12, 8, 4, 0]'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[16, 12, 8, 4, 0]'
- en: '[17, 13, 9, 5, 1]'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[17, 13, 9, 5, 1]'
- en: '[18, 14, 10, 6, 2]'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[18, 14, 10, 6, 2]'
- en: '[19, 15, 11, 7, 3]'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[19, 15, 11, 7, 3]'
- en: A pattern emerges. If you start at the upper right and read down each column,
    ending at the lower left, the numbers are in numerical order; you’ve restored
    the plaintext!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模式出现了。如果你从右上角开始，沿着每一列向下读取，直到左下角，数字会按顺序排列；你已恢复了明文！
- en: 'To replicate this, your script can loop through every nested list, removing
    the last item in that list and adding the item to a new string, until the translation
    matrix has been emptied. The script will know from the key which nested lists
    it needs to reverse and the order in which to depopulate the matrix. The output
    will be a string of the restored plaintext:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，脚本可以遍历每个嵌套列表，移除该列表中的最后一个元素并将其添加到新字符串中，直到翻译矩阵被清空。脚本将通过密钥知道需要反转哪些嵌套列表，并按顺序清空矩阵。输出将是恢复后的明文字符串：
- en: '''0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19'''
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '''0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19'''
- en: You should now have a very general view of the strategy. Let’s get more descriptive
    and write the pseudocode next.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该对策略有了一个非常通用的了解。接下来，让我们更详细地描述并编写伪代码。
- en: '***The Pseudocode***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***伪代码***'
- en: 'The script can be broken up into three major parts: user input, translation
    matrix population, and decryption to plaintext. You should be able to see these
    parts in the following pseudocode:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本可以分为三大部分：用户输入、翻译矩阵填充和解密到明文。你应该能够在以下伪代码中看到这些部分：
- en: Load the ciphertext string.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 加载密文字符串。
- en: Convert ciphertext into a cipherlist to split out individual words.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将密文转换为密文列表，以便拆分出单个单词。
- en: Get input for the number of columns and rows.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 获取列数和行数的输入。
- en: Get input for the key.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 获取密钥的输入。
- en: Convert key into a list to split out individual numbers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将密钥转换为列表，以便拆分出单个数字。
- en: Create a new list for the translation matrix.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为翻译矩阵创建一个新列表。
- en: 'For every number in the key:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对密钥中的每个数字进行操作：
- en: 'Create a new list and append every n items (n = # of rows) from the cipherlist.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的列表，并从密文列表中附加每n个元素（n = 行数）。
- en: Use the sign of key number to decide whether to read the row forward or backward.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用键值的符号来决定是按正向还是反向读取行。
- en: Using the chosen direction, add the new list to the matrix. The index of each
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用选定的方向，将新的列表添加到矩阵中。每个索引的
- en: new list is based on the column number used in the key.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 新列表是基于密钥中使用的列号。
- en: Create a new string to hold translation results.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的字符串来保存翻译结果。
- en: 'For range of rows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对行的范围进行操作：
- en: 'For the nested list in translation matrix:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对翻译矩阵中的嵌套列表进行操作：
- en: Remove the last word in nested list
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 移除嵌套列表中的最后一个单词
- en: Add the word to the translation string.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将单词添加到翻译字符串中。
- en: Print the translation string.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 打印翻译字符串。
- en: Everything before the first loop is essentially just collecting and reformatting
    the cipher data. The first loop is responsible for building and populating the
    matrix, and the second loop creates a translation string from that matrix. Finally,
    the translation string is printed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 循环前的所有操作本质上只是收集和重新格式化密文数据。第一个循环负责构建和填充矩阵，第二个循环则从矩阵中创建翻译字符串。最后，翻译字符串会被打印出来。
- en: '***The Route Cipher Decryption Code***'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***路线密码解密代码***'
- en: '[Listing 4-1](ch04.xhtml#ch04list1) takes a message encrypted with the route
    cipher, the number of columns and rows in the transposition matrix, and a key
    and then displays the translated plaintext. It will decrypt all “common” route
    ciphers, where the route starts at the top or bottom of a column and continues
    up and/or down columns.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 4-1](ch04.xhtml#ch04list1) 获取使用路由密码加密的消息，转置矩阵中的列数和行数，以及密钥，然后显示翻译后的明文。它将解密所有“常见”的路由密码，其中路线从列的顶部或底部开始，并在列中向上或向下继续。'
- en: This is the prototype version; once you’re sure it’s working, you’ll package
    it for others to use. You can download this code at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是原型版本；一旦你确认它工作正常，就可以将它打包供其他人使用。你可以在 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载这段代码。
- en: '*route_cipher_decrypt_prototype.py*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*route_cipher_decrypt_prototype.py*'
- en: ➊ ciphertext = "16 12 8 4 0 1 5 9 13 17 18 14 10 6 2 3 7 11 15 19"
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ ciphertext = "16 12 8 4 0 1 5 9 13 17 18 14 10 6 2 3 7 11 15 19"
- en: '# split elements into words, not letters'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将元素拆分为单词，而不是字母'
- en: ➋ cipherlist = list(ciphertext.split())
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ cipherlist = list(ciphertext.split())
- en: '➌ # initialize variables'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ # 初始化变量'
- en: COLS = 4
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: COLS = 4
- en: ROWS = 5
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ROWS = 5
- en: key = '-1 2 -3 4'  # neg number means read UP column vs. DOWN
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'key = ''-1 2 -3 4''  # 负数表示从上到下读取列'
- en: translation_matrix = [None] * COLS
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: translation_matrix = [None] * COLS
- en: plaintext = ''
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: plaintext = ''
- en: start = 0
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: start = 0
- en: stop = ROWS
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: stop = ROWS
- en: '# turn key_int into list of integers:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将 key_int 转换为整数列表：'
- en: ➍ key_int = [int(i) for i in key.split()]
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ key_int = [int(i) for i in key.split()]
- en: '# turn columns into items in list of lists:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将列转换为列表中的项目：'
- en: '➎ for k in key_int:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ for k in key_int:'
- en: ➏ if k < 0:  # reading bottom-to-top of column
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '➏ if k < 0:  # 从列的底部到顶部读取'
- en: col_items = cipherlist[start:stop]
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: col_items = cipherlist[start:stop]
- en: elif k > 0:  # reading top-to-bottom of columnn
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif k > 0:  # 从列的顶部到底部读取'
- en: col_items = list((reversed(cipherlist[start:stop])))
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: col_items = list((reversed(cipherlist[start:stop])))
- en: translation_matrix[abs(k) - 1] = col_items
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: translation_matrix[abs(k) - 1] = col_items
- en: start += ROWS
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: start += ROWS
- en: stop += ROWS
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: stop += ROWS
- en: print("\nciphertext = {}".format(ciphertext))
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: print("\n密文 = {}".format(ciphertext))
- en: print("\ntranslation matrix =", *translation_matrix, sep="\n")
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: print("\n翻译矩阵 =", *translation_matrix, sep="\n")
- en: print("\nkey length = {}".format(len(key_int)))
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: print("\n密钥长度 = {}".format(len(key_int)))
- en: '# loop through nested lists popping off last item to new list:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '# 遍历嵌套列表，将最后一个项目弹出到新列表：'
- en: '➐ for i in range(ROWS):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '➐ for i in range(ROWS):'
- en: 'for col_items in translation_matrix:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 'for col_items in translation_matrix:'
- en: ➑ word = str(col_items.pop())
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ word = str(col_items.pop())
- en: ➒ plaintext += word + ' '
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ plaintext += word + ' '
- en: print("\nplaintext = {}".format(plaintext))
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: print("\n明文 = {}".format(plaintext))
- en: '*Listing 4-1: Code for* route_cipher_decrypt_prototype.py'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 4-1: 路由密码解密原型.py 的代码*'
- en: Start by loading the ciphertext ➊ as a string. You want to deal with words,
    not letters, so split the string apart based on empty spaces using the split()
    string method to create a new list named cipherlist ➋. The split() method is the
    inverse of the join() method, which you’ve seen before. You can split on any string;
    the method just defaults to runs of consecutive whitespace, deleting each whitespace
    before it moves to the next.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先加载密文 ➊ 作为字符串。你需要处理的是单词，而不是字母，因此使用 split() 字符串方法根据空格将字符串拆分，创建一个新的列表名为 cipherlist
    ➋。split() 方法是 join() 方法的逆操作，你以前见过。你可以基于任何字符串进行拆分；该方法默认基于连续的空白字符进行拆分，并在进入下一个拆分之前删除每个空白字符。
- en: 'Now it’s time to input what you know about the cipher ➌: the columns and rows,
    which form the matrix, and the key, which contains the route. Initialize the column
    and row numbers as constants. Then make an empty list named translation_matrix
    to hold the contents of each column as a (nested) list. Assign placeholders by
    multiplying the value None by the number of columns. You can use the indexes of
    these empty items to put columns back in their correct order for keys that are
    not in numerical order.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候输入你对密码的了解了 ➌：列和行，它们形成矩阵，以及包含路线的密钥。将列和行的数字初始化为常量。然后创建一个名为 translation_matrix
    的空列表来保存每一列的内容，作为一个（嵌套）列表。通过将 None 的值乘以列数来分配占位符。你可以使用这些空项目的索引，将列按正确的顺序放回，适用于那些密钥不是按数字顺序排列的情况。
- en: An empty string named plaintext will hold the decrypted message. Next are some
    slicing parameters. Note that some of these are derived from the number of rows,
    which equates to the number of items in each column.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 plaintext 的空字符串将保存解密后的消息。接下来是一些切片参数。请注意，其中一些是从行数派生出来的，行数等于每列的项数。
- en: Now, convert the key variable, which is a string, into a list of integers using
    *list comprehension*—a shorthand way of performing operations on lists ➍. You’ll
    use the numbers in the key as indexes later, so they need to be integers.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用*列表推导*将 key 变量（一个字符串）转换为整数列表——这是一种对列表进行操作的简便方法 ➍。稍后你将使用 key 中的数字作为索引，因此它们需要是整数。
- en: The next block of code is a for loop that populates the translation_matrix,
    which is just a list of lists ➎. Since each column becomes a nested list and the
    length of the key_int list is equal to the number of columns, the range for the
    loop is the key, which also describes the route.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码块是一个 for 循环，用于填充 translation_matrix，它只是一个列表的列表 ➎。由于每一列变成一个嵌套列表，而 key_int
    列表的长度等于列数，所以循环的范围是 key，它也描述了路径。
- en: Inside the loop, use a conditional to check whether the key is positive or negative
    ➏; if the key is positive, then the direction of the slice is reversed. Assign
    the slice to the correct position in translation_matrix based on the absolute
    key value and subtract 1 (since the keys don’t include 0, but the list indexes
    do). Finish the loop by advancing the slice endpoints by the number of rows and
    printing some useful information.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，使用条件判断检查 key 是正数还是负数 ➏；如果 key 为正，则切片的方向将被反转。根据绝对的 key 值，将切片分配到 translation_matrix
    的正确位置，并减去 1（因为密钥不包括 0，但列表索引是从 0 开始的）。通过将切片端点按行数推进并打印一些有用的信息来完成循环。
- en: The final block ➐ loops through the number of rows—which is equivalent to the
    number of words in one of the nested lists—and through each nested list. The first
    two of these loops are shown in [Figure 4-4](ch04.xhtml#ch04fig4). As you stop
    in each nested list, you get to employ one of my favorite Python functions, the
    list pop() method ➑. The pop() method removes and returns the last item from a
    list, unless a specific index is provided. It destroys the nested list, but you’re
    done with it anyway.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的代码块 ➐ 遍历行数——这等同于嵌套列表中单词的数量——以及每个嵌套列表。前两个循环在[图 4-4](ch04.xhtml#ch04fig4)中展示。当你停留在每个嵌套列表时，你可以使用我最喜欢的
    Python 函数之一——列表的 pop() 方法 ➑。pop() 方法会移除并返回列表中的最后一个元素，除非提供了特定的索引。它会销毁嵌套列表，但反正你已经不再需要它了。
- en: '![image](../images/f0071-01.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0071-01.jpg)'
- en: '*Figure 4-4: First and second loop through the nested lists, removing and appending
    each end item to the translation string*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-4：第一次和第二次遍历嵌套列表，移除并将每个末尾元素追加到翻译字符串中*'
- en: 'As soon as you pop off a word, concatenate it to the plaintext string and add
    a space ➒. All that’s left to do is display the decrypted ciphertext. The output
    for the numeric test set looks like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你弹出一个单词，将其连接到明文字符串并添加一个空格 ➒。接下来要做的就是显示解密后的密文。数字测试集的输出看起来像这样：
- en: plaintext = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: plaintext = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
- en: That looks like success!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来是成功了！
- en: '***Hacking the Route Cipher***'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***破解路线密码***'
- en: 'The preceding code assumes you know the route through the encryption matrix
    or have correctly guessed the key. If those assumptions aren’t true, your only
    recourse is to try every possible key and matrix arrangement. You’ll get a chance
    to automate the key selection process—for a given number of columns—in “[Route
    Transposition Cipher: Brute-Force Attack](ch04.xhtml#lev111)” on [page 88](ch04.xhtml#page_88).
    But, as you’ll see, the Union route cipher is well fortified against brute-force
    attacks. You can crack it, but you’ll end up with so much data, you’ll feel like
    the dog that chased a car and caught it.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码假设你知道加密矩阵的路径，或者已经正确猜测了密钥。如果这些假设不成立，你唯一的解决方法就是尝试每一个可能的密钥和矩阵排列。你将有机会自动化密钥选择过程——针对给定的列数——在
    “[路线换位密码：暴力破解](ch04.xhtml#lev111)” 的 [第 88 页](ch04.xhtml#page_88)。但是，正如你将看到的，Union
    路线密码对暴力破解攻击有很好的防护。你可以破解它，但你会得到大量的数据，最终会感觉像那只追逐并抓住汽车的狗。
- en: 'As messages get longer, the number of possible encryption paths in a transposition
    cipher becomes too large for a brute-force solution, even using modern computers.
    For example, if there are eight columns, and you allow the route to skip to any
    column, the number of ways to combine the columns is the factorial of eight: 8
    × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 40,320\. That’s 40,320 paths *before* you start
    choosing alternative routes through the columns. If the route can change direction
    up or down a column, the number of combinations increases to 10,321,920\. And
    if you consider starting *anywhere* in a column—instead of at the very top or
    bottom—and allow *any* route through the matrix (such as spiraling), things will
    really start to get out of hand!'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 随着消息变得更长，换位密码中的可能加密路径数目变得过大，即使使用现代计算机也无法通过暴力破解解决。例如，如果有八列，并且允许路线跳跃到任何一列，那么组合列的方式就是八的阶乘：8
    × 7 × 6 × 5 × 4 × 3 × 2 × 1 = 40,320。这是40,320条路径，*在*你开始选择穿越各列的替代路径之前。如果路线可以向上或向下改变方向，组合数将增加到10,321,920。而如果你考虑从*任何*位置开始——而不是从顶部或底部开始——并允许*任何*路径穿越矩阵（例如螺旋形），事情就真的会变得难以控制！
- en: For this reason, even short transposition ciphers can have thousands to millions
    of possible paths. Even if the number of paths is manageable for a computer and
    a brute-force attack may prevail, you’ll still need a way to sift through the
    myriad outcomes and either choose a winner computationally or select a small subset
    of candidates to visually examine.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使是短小的换位密码也可能有成千上万到百万级的可能路径。即使路径数目对计算机来说是可以管理的，并且暴力破解攻击可能会成功，你仍然需要一种方法来筛选大量的结果，要么通过计算选择一个最优解，要么选择一个小的候选集进行人工检查。
- en: For the more common *letter*-transposition ciphers, it’s easy to write a function
    that detects English by comparing each decryption attempt to a dictionary file.
    If the number of decrypted words belonging to a dictionary is greater than a certain
    threshold percentage, you’ve probably cracked the cipher. Likewise, if there’s
    a high frequency of common letter pairs (*digrams*)—like *er*, *th*, *on*, or
    *an*—you may have found the solution. Unfortunately, this approach won’t work
    for a *word*-transposition cipher like the one you’re using here.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更常见的*字母*换位密码，编写一个通过将每个解密尝试与字典文件进行比较来检测英语的函数非常容易。如果解密出来的单词中属于字典的数量超过某个阈值百分比，那么你可能已经破解了密码。同样，如果出现常见字母对（*双字母组合*）的频率很高——例如*er*、*th*、*on*或*an*——你也许找到了破解的线索。不幸的是，这种方法对于像你在这里使用的*单词*换位密码是行不通的。
- en: Dictionaries can’t help you figure out whether words have been arranged correctly.
    For word arrangement, you could try using approaches like grammatical rules and
    probabilistic language models, such as *n*-grams, combing through thousands of
    decryptions and picking candidate outcomes programmatically, but Stager’s wise
    use of code names and dummy words in his route cipher will greatly complicate
    the process.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 字典无法帮助你判断单词是否被正确排列。对于单词排列，你可以尝试使用像语法规则和概率语言模型（如*n*-gram）的方式，通过检查数千个解密结果并编程选择候选结果，但Stager在他的路径密码中巧妙地使用了代号和虚假单词，这将大大增加这个过程的复杂性。
- en: Cryptanalysts consider short, straight-up transposition ciphers to be fairly
    easy to crack without a computer, despite the issues just described. They look
    for common word or letter pairs that make sense, and use those to guess the number
    of rows in the transposition matrix.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 密码分析师认为，尽管如上所述存在一些问题，短小的、直接的换位密码仍然相对容易破解，而无需计算机。他们寻找合理的常见单词或字母组合，并利用这些信息猜测换位矩阵中的行数。
- en: To illustrate, let’s use our control message composed of numbers. In [Figure
    4-5](ch04.xhtml#ch04fig5), you can see the ciphertext outcomes for a 4×5 matrix,
    each produced by starting at one of the four corners of the grid, and following
    an alternating, sequential route. All cases include repetition of adjacent numbers
    (shaded in [Figure 4-5](ch04.xhtml#ch04fig5)). These indicate where you’re moving
    laterally through the grid, and they provide clues to the design of the matrix
    and the route taken through it. You can immediately see that there were five rows,
    because the first of each common pair is a fifth word. Moreover, knowing there
    are 20 words in the message, you learn the number of columns was four (20 / 5
    = 4). Using the reasonable assumption that the plaintext message was written left
    to right, you can even guess the route. For example, if you start in the lower
    right, you go up to 3, then left to 2, then down to 18, then left to 17, then
    up to 1 and left to 0\. Of course, this would be more difficult with words, since
    the connection between words isn’t as explicit, but using numbers really makes
    the point.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们使用由数字组成的控制信息。在[图4-5](ch04.xhtml#ch04fig5)中，您可以看到4×5矩阵的密文结果，每个结果都是通过从网格的四个角之一开始，并沿着交替的顺序路线走出。所有情况包括相邻数字的重复（在[图4-5](ch04.xhtml#ch04fig5)中阴影部分）。这些重复数字指示了你在网格中横向移动的位置，并为矩阵的设计以及路线提供了线索。您可以立即看出有五行，因为每对共同的数字中的第一个是第五个单词。此外，知道消息中有20个单词，您可以推断出列数为四（20
    / 5 = 4）。通过合理假设明文消息是从左到右写的，您甚至可以猜测路线。例如，如果您从右下角开始，您首先向上走到3，然后向左走到2，再向下走到18，再向左走到17，再向上走到1并向左走到0。
    当然，使用单词时，这样做会更加困难，因为单词之间的联系并不明显，但使用数字确实突出了这一点。
- en: '![image](../images/f0073-01.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0073-01.jpg)'
- en: '*Figure 4-5: Characters or words in logical order (shaded) can be used to guess
    an encryption route.*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-5：可以用来猜测加密路线的按逻辑顺序排列的字符或单词（阴影部分）。*'
- en: Look at [Figure 4-6](ch04.xhtml#ch04fig6), based on the message in [Figure 4-2](ch04.xhtml#ch04fig2).
    End words and possible linked words, like “is just” or “heading to,” are shaded.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[图4-6](ch04.xhtml#ch04fig6)，它基于[图4-2](ch04.xhtml#ch04fig2)中的信息。结束词和可能的关联词，如“is
    just”或“heading to”，已被阴影标记。
- en: '![image](../images/f0073-02.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0073-02.jpg)'
- en: '*Figure 4-6: Human hacking of the route cipher in [Figure 4-2](ch04.xhtml#ch04fig2).
    A five-row matrix is indicated.*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-6：基于[图4-2](ch04.xhtml#ch04fig2)的人类破解路线密码。这里标示了一个五行矩阵。*'
- en: There are 20 total words, for which there could be 4, 5, or 10 rows. It’s doubtful
    that a two-column matrix would be used, so we are realistically dealing with a
    4×5 or a 5×4 arrangement. If the route cipher path is like that in [Figure 4-5](ch04.xhtml#ch04fig5),
    then we’d expect to see two nonshaded words between shaded words for a four-row
    matrix and three nonshaded words for a five-row matrix. It’s harder to come up
    with sensical word pairs that honor the four-column pattern, regardless of which
    direction you read the ciphertext. So, we’re probably dealing with a five-column
    solution that starts on the left side of the matrix—since the linked words make
    sense read left to right.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有20个单词，可能有4行、5行或10行。使用两列矩阵的可能性较小，因此我们实际上在处理一个4×5或5×4的排列。如果路线密码路径像[图4-5](ch04.xhtml#ch04fig5)中的那样，那么我们预计在四行矩阵中会看到两个未阴影的单词，而在五行矩阵中会看到三个未阴影的单词。无论从哪个方向读取密文，想要符合四列模式的词对都更难构造。所以，我们很可能在处理一个五列解决方案，它从矩阵的左侧开始——因为关联单词从左到右读是有意义的。
- en: 'Note how the shaded words in [Figure 4-6](ch04.xhtml#ch04fig6) fill out the
    top and bottom rows in the transposition matrix in [Figure 4-7](ch04.xhtml#ch04fig7).
    This is what we would expect, as the path is “turning around” at the top and bottom
    of every column. Graphical solutions: God’s gift to the innumerate!'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意[图4-6](ch04.xhtml#ch04fig6)中阴影单词如何填充[图4-7](ch04.xhtml#ch04fig7)中的转置矩阵的顶部和底部行。这正是我们所期望的，因为路径在每列的顶部和底部“转弯”了。图形解决方案：上帝给无数人的礼物！
- en: '![image](../images/f0074-01.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0074-01.jpg)'
- en: '*Figure 4-7: Shaded words in [Figure 4-6](ch04.xhtml#ch04fig6) placed in the
    transposition matrix*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4-7：[图4-6](ch04.xhtml#ch04fig6)中阴影单词放置在转置矩阵中*'
- en: This seemed easy, but then again, we know how a route cipher works. Confederate
    code breakers eventually discovered it too, but the use of code words denied them
    full entry into the system. To hack the codes, they needed a captured codebook
    or a large organization capable of acquiring and analyzing big data, which was
    beyond the reach of the Confederacy in the 19th century.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很简单，但话说回来，我们知道路线密码是如何工作的。南方联邦的密码破译员最终也发现了这一点，但由于使用了密码词，他们无法完全进入系统。为了破解密码，他们需要一本被捕获的密码本，或者一个能够收集和分析大数据的大型组织，而这在19世纪的南方联邦是无法实现的。
- en: '***Adding a User Interface***'
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***添加用户界面***'
- en: The second goal of this project is to write the code in such a way as to reduce
    human error, especially from those with less experience (including technicians,
    interns, peers, and telegraph clerks in 1864). Of course, the best way to make
    a program user-friendly is to include a *graphical user interface (GUI)*, but
    at times, this isn’t practical or possible. For example, code-cracking programs
    automatically loop through thousands of possible keys, and autogenerating these
    keys is easier than getting them directly from a user.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的第二个目标是将代码编写得尽量减少人为错误，尤其是那些经验较少的人（包括技术员、实习生、同事以及1864年的电报文员）。当然，使程序更易于使用的最佳方式是包含一个*图形用户界面（GUI）*，但有时这既不实际也不可能。例如，破解程序会自动循环遍历数千个可能的密钥，自动生成这些密钥比直接从用户那里获得它们要容易。
- en: 'In this example, you’ll proceed with the assumption that the user will crack
    open the program file and enter some input or even make minor code changes. Here
    are some guidelines to follow:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你将假设用户会打开程序文件并输入一些内容，甚至可能做一些小的代码更改。以下是一些需要遵循的指南：
- en: Start with a useful docstring (see [Chapter 1](ch01.xhtml#ch01)).
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个有用的文档字符串开始（见[第1章](ch01.xhtml#ch01)）。
- en: Place all required user input at the top.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有必需的用户输入放在顶部。
- en: Use comments to clarify input requirements.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用注释来澄清输入要求。
- en: Clearly separate user input from the remaining code.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清楚地区分用户输入和其余代码。
- en: Encapsulate most processes in functions.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将大多数过程封装在函数中。
- en: Include functions to catch predictable user errors.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括用于捕捉可预见的用户错误的函数。
- en: The nice thing about this approach is that no one’s intelligence gets insulted.
    If a user *wants* to scroll down and look at the code, or even change it, there’s
    nothing stopping them. If all they want to do is enter some values and get a black
    box solution, then they’re happy, too. And we’ve honored the spirit of Anson Stager
    by making things simple and reducing the chance for error.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的好处是没有人会觉得自己的智商受到侮辱。如果用户*想*向下滚动并查看代码，甚至修改它，没有什么可以阻止他们。如果他们只是想输入一些值并获得一个黑盒解决方案，那么他们也会很高兴。我们通过简化操作并减少错误的机会，尊重了安森·斯塔格的精神。
- en: '**Instructing the User and Getting Input**'
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**指导用户并获取输入**'
- en: '[Listing 4-2](ch04.xhtml#ch04list2) shows the prototype code repackaged for
    sharing with others. You can find this code at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表4-2](ch04.xhtml#ch04list2)展示了一个原型代码，重新包装以便与他人共享。你可以在*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*找到这段代码。'
- en: '*route_cipher_decrypt.py,* part 1'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*route_cipher_decrypt.py,* 第1部分'
- en: ➊ """Decrypt a path through a Union Route Cipher.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ """解密通过联邦路线密码的路径。
- en: ➋ Designed for whole-word transposition ciphers with variable rows & columns.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 设计用于具有可变行和列的全词置换密码。
- en: Assumes encryption began at either top or bottom of a column.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设加密从列的顶部或底部开始。
- en: Key indicates the order to read columns and the direction to traverse.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥指示读取列的顺序和遍历的方向。
- en: Negative column numbers mean start at bottom and read up.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 负的列号表示从底部开始并向上读取。
- en: Positive column numbers mean start at top & read down.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正的列号表示从顶部开始并向下读取。
- en: Example below is for 4x4 matrix with key -1 2 -3 4.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例是一个4x4矩阵，密钥为 -1 2 -3 4。
- en: Note "0" is not allowed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，“0”是不允许的。
- en: Arrows show encryption route; for negative key values read UP.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头表示加密路线；对于负密钥值，向上读取。
- en: 1   2   3   4
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 1   2   3   4
- en: ___ ___ ___ ___
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ___ ___ ___ ___
- en: '| ^ | | | ^ | | | MESSAGE IS WRITTEN'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '| ^ | | | ^ | | | 消息已写入'
- en: '|_|_|_v_|_|_|_v_|'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '|_|_|_v_|_|_|_v_|'
- en: '| ^ | | | ^ | | | ACROSS EACH ROW'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '| ^ | | | ^ | | | 穿越每一行'
- en: '|_|_|_v_|_|_|_v_|'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '|_|_|_v_|_|_|_v_|'
- en: '| ^ | | | ^ | | | IN THIS MANNER'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '| ^ | | | ^ | | | 以这种方式'
- en: '|_|_|_v_|_|_|_v_|'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '|_|_|_v_|_|_|_v_|'
- en: '| ^ | | | ^ | | | LAST ROW IS FILLED WITH DUMMY WORDS'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '| ^ | | | ^ | | | 最后一行填充了虚拟单词'
- en: '|_|_|_v_|_|_|_v_|'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '|_|_|_v_|_|_|_v_|'
- en: START        END
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 开始        结束
- en: 'Required inputs - a text message, # of columns, # of rows, key string'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 必需的输入 - 一条文本消息，列数，行数，密钥字符串
- en: Prints translated plaintext
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 打印转换后的明文
- en: '"""'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: ➌ import sys
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ import sys
- en: '#=============================================================================='
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '#=============================================================================='
- en: '➍ # USER INPUT:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ # 用户输入：'
- en: '➎ # the string to be decrypted (type or paste between triple-quotes):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ # 要解密的字符串（在三重引号之间输入或粘贴）：'
- en: ciphertext = """16 12 8 4 0 1 5 9 13 17 18 14 10 6 2 3 7 11 15 19
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ciphertext = """16 12 8 4 0 1 5 9 13 17 18 14 10 6 2 3 7 11 15 19
- en: '"""'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: '➏ # number of columns in the transposition matrix:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '➏ # 转置矩阵中的列数：'
- en: COLS = 4
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: COLS = 4
- en: '# number of rows in the transposition matrix:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '# 转置矩阵中的行数：'
- en: ROWS = 5
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ROWS = 5
- en: '➐ # key with spaces between numbers; negative to read UP column (ex = -1 2
    -3 4):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '➐ # 带有数字之间空格的密钥；负数表示向上读取列（例如：-1 2 -3 4）：'
- en: key = """ -1 2 -3 4 """
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: key = """ -1 2 -3 4 """
- en: '➑ # END OF USER INPUT - DO NOT EDIT BELOW THIS LINE!'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '➑ # 用户输入结束 - 请勿编辑以下内容！'
- en: '#=============================================================================='
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '#=============================================================================='
- en: ➒ ________________________________________________________________________________
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ ________________________________________________________________________________
- en: '*Listing 4-2: Docstring, imports, and user input for* route_cipher_decrypt.py'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-2：route_cipher_decrypt.py 的文档字符串、导入和用户输入*'
- en: Start with a multiline docstring in triple quotes ➊. The docstring informs the
    user that the program only decrypts a typical route cipher—one that starts at
    either the top or bottom of a column—and how to enter the key information ➋. A
    diagram is included to help make the point.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 从三重引号开始编写多行文档字符串 ➊。文档字符串告诉用户该程序仅解密典型的路径密码——一种从列的顶部或底部开始的密码——以及如何输入密钥信息 ➋。附带的图示有助于说明这一点。
- en: Next, import sys for access to system fonts and functions ➌. You’re going to
    check the user’s input for acceptance criteria, so you need to display messages
    in the shell in eye-catching red. Putting this import statement here is a catch-22\.
    Since the strategic goal is to hide the working code from the user, you really
    should apply this later in the program. But the Python convention of putting all
    import statements at the top is too strong to ignore.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，导入 sys 以访问系统字体和函数 ➌。你需要检查用户输入是否符合接受标准，因此需要在 shell 中用显眼的红色显示消息。将这条导入语句放在这里是一个两难问题。由于战略目标是将工作代码隐藏在用户看不见的地方，因此最好在程序后面再应用它。但
    Python 的约定是将所有导入语句放在最上面，这种惯例强大到几乎不能忽视。
- en: Now for the input section. How often have you seen or dealt with code where
    inputs or changes have to be made *throughout* the program? This can be confusing
    for the author and even worse for another user. So, move all these important variables
    to the top for convenience, common courtesy, and error prevention.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是输入部分。你有多少次看到或处理过必须*贯穿*整个程序的输入或更改？这会让作者感到困惑，对其他用户来说可能更糟。因此，为了方便、出于礼貌并避免错误，将所有这些重要变量移到顶部。
- en: First, separate the input section with a line and then let the user know that
    they’re on deck with an all-caps comment ➍. The required inputs are clearly defined
    with comments. You can use triple quotes for the text input to better accommodate
    long snippets of text. Note that I’ve entered the string of numbers from [Figure
    4-3](ch04.xhtml#ch04fig3) ➎. Next, the user needs to add the number of columns
    and rows for the transposition matrix ➏, followed by the proposed (or known) key
    ➐.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，用一行分隔输入部分，然后用大写注释让用户知道他们已经准备好输入 ➍。所需的输入通过注释进行了明确的定义。可以使用三重引号来处理文本输入，以便更好地容纳长文本。请注意，我已经输入了[图
    4-3](ch04.xhtml#ch04fig3) ➎中的数字串。接下来，用户需要添加转置矩阵的列数和行数 ➏，然后是提议的（或已知的）密钥 ➐。
- en: End the user input section with a declaration comment to that effect and a caution
    to not edit anything below the following line ➑. Then add some extra spaces to
    more clearly separate the input section from the rest of the program ➒.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 用一个声明性的注释结束用户输入部分，并提醒不要编辑以下内容 ➑。然后添加一些额外的空行，以更清楚地将输入部分与程序的其余部分分开 ➒。
- en: '**Defining the main() Function**'
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义 main() 函数**'
- en: '[Listing 4-3](ch04.xhtml#ch04list3) defines the main() function, which runs
    the program and prints out the plaintext after the cipher is decoded. The main()
    function can be defined before or after the functions it calls, as long as it
    is the last function called.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-3](ch04.xhtml#ch04list3) 定义了 main() 函数，该函数运行程序并在解密后打印明文。main() 函数可以在它调用的函数之前或之后定义，只要它是最后一个被调用的函数。'
- en: '*route_cipher_decrypt.py,* part 2'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*route_cipher_decrypt.py,* 第 2 部分'
- en: 'def main():'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '"""Run program and print decrypted plaintext."""'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '"""运行程序并打印解密后的明文。"""'
- en: ➊ print("\nCiphertext = {}".format(ciphertext))
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ print("\n密文 = {}".format(ciphertext))
- en: print("Trying {} columns".format(COLS))
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: print("尝试 {} 列".format(COLS))
- en: print("Trying {} rows".format(ROWS))
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: print("尝试 {} 行".format(ROWS))
- en: print("Trying key = {}".format(key))
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: print("尝试密钥 = {}".format(key))
- en: '# split elements into words, not letters'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将元素拆分为单词，而不是字母'
- en: ➋ cipherlist = list(ciphertext.split())
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ cipherlist = list(ciphertext.split())
- en: ➌ validate_col_row(cipherlist)
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ validate_col_row(cipherlist)
- en: ➍ key_int = key_to_int(key)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ key_int = key_to_int(key)
- en: ➎ translation_matrix = build_matrix(key_int, cipherlist)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ translation_matrix = build_matrix(key_int, cipherlist)
- en: ➏ plaintext = decrypt(translation_matrix)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ plaintext = decrypt(translation_matrix)
- en: ➐ print("Plaintext = {}".format(plaintext))
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ print("明文 = {}".format(plaintext))
- en: '*Listing 4-3: Defines the* main() *function*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-3：定义了* main() *函数*'
- en: Start the main() function by printing the user input to the shell ➊. Then turn
    the ciphertext into a list by splitting on whitespace, as you did in the prototype
    code ➋.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 开始 main() 函数，首先将用户输入打印到终端 ➊。然后通过空格拆分将密文转换为列表，正如你在原型代码中所做的 ➋。
- en: The next series of statements call functions you will define shortly. The first
    checks whether the input rows and columns are valid for the message length ➌.
    The second converts the key variable from a string to a list of integers ➍. The
    third builds the translation matrix ➎, and the fourth runs the decryption algorithm
    on the matrix and returns a plaintext string ➏. Finish main() by printing the
    plaintext ➐.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行语句调用了你将很快定义的函数。第一个函数检查输入的行和列是否适合消息长度 ➌。第二个函数将密钥变量从字符串转换为整数列表 ➍。第三个函数构建了翻译矩阵
    ➎，第四个函数在矩阵上运行解密算法并返回明文字符串 ➏。通过打印明文 ➐ 完成 main() 函数。
- en: '**Verifying Data**'
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**验证数据**'
- en: As you continue to package *route_cipher_decrypt.py* for the end user, you need
    to verify that the input is valid. [Listing 4-4](ch04.xhtml#ch04list4) anticipates
    common user errors and provides the user with helpful feedback and guidance.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续为最终用户打包 *route_cipher_decrypt.py* 时，你需要验证输入是否有效。[列表 4-4](ch04.xhtml#ch04list4)预见了常见的用户错误，并为用户提供了有用的反馈和指导。
- en: '*route_cipher_decrypt.py,* part 3'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*route_cipher_decrypt.py,* 第3部分'
- en: '➊ def validate_col_row(cipherlist):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def validate_col_row(cipherlist):'
- en: '"""Check that input columns & rows are valid vs. message length."""'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '"""检查输入的列和行是否与消息长度有效。"""'
- en: factors = []
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: factors = []
- en: len_cipher = len(cipherlist)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: len_cipher = len(cipherlist)
- en: ➋ for i in range(2, len_cipher):  # range excludes 1-column ciphers
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ for i in range(2, len_cipher):  # 范围排除了 1 列密码'
- en: 'if len_cipher % i == 0:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 'if len_cipher % i == 0:'
- en: factors.append(i)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: factors.append(i)
- en: ➌ print("\nLength of cipher = {}".format(len_cipher))
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ print("\n密码长度 = {}".format(len_cipher))
- en: 'print("Acceptable column/row values include: {}".format(factors))'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("可接受的列/行值包括: {}".format(factors))'
- en: print()
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: print()
- en: '➍ if ROWS * COLS != len_cipher:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ if ROWS * COLS != len_cipher:'
- en: print("\nError - Input columns & rows not factors of length "
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: print("\n错误 - 输入的列和行不是长度的因子"
- en: '"of cipher. Terminating program.", file=sys.stderr)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '"密码的错误。程序终止。", file=sys.stderr)'
- en: sys.exit(1)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit(1)
- en: '➎ def key_to_int(key):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ def key_to_int(key):'
- en: '"""Turn key into list of integers & check validity."""'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将密钥转换为整数列表并检查有效性。"""'
- en: ➏ key_int = [int(i) for i in key.split()]
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ key_int = [int(i) for i in key.split()]
- en: key_int_lo = min(key_int)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: key_int_lo = min(key_int)
- en: key_int_hi = max(key_int)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: key_int_hi = max(key_int)
- en: ➐ if len(key_int) != COLS or key_int_lo < -COLS or key_int_hi > COLS \
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ if len(key_int) != COLS or key_int_lo < -COLS or key_int_hi > COLS \
- en: 'or 0 in key_int:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 或者 0 在 key_int 中：
- en: ➑ print("\nError - Problem with key. Terminating.", file=sys.stderr)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ print("\n错误 - 密钥有问题。程序终止。", file=sys.stderr)
- en: sys.exit(1)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit(1)
- en: 'else:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: ➒ return key_int
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ return key_int
- en: '*Listing 4-4: Defines functions for checking and prepping user input*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 4-4：定义用于检查和准备用户输入的函数*'
- en: The validate_col_row() function checks that the input column and row numbers
    are appropriate for the length of the cipherlist, which you pass as an argument
    ➊. The transposition matrix is always the same size as the number of words in
    the message, so the number of columns and the number of rows have to be a factor
    of the message size. To determine all the permissible factors, first make an empty
    list to hold the factors and then get the length of the cipherlist. Use the *cipherlist*,
    rather than the input *ciphertext*, as the elements in the ciphertext are *letters*,
    not words.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: validate_col_row() 函数检查输入的列和行数字是否适合 cipherlist 的长度，你将其作为参数传递 ➊。换位矩阵的大小始终与消息中的单词数量相同，因此列数和行数必须是消息大小的因子。要确定所有允许的因子，首先创建一个空列表来保存因子，然后获取
    cipherlist 的长度。使用 *cipherlist*，而不是输入的 *ciphertext*，因为密文中的元素是 *字母*，而不是单词。
- en: Normally, to get the factors of a number, you would use a range of (1, number
    + 1), but you don’t want these endpoints in the factors list, because a translation
    matrix with these dimensions would just be the plaintext. So exclude these values
    from the range ➋. Since a factor of a number divides evenly into that number,
    use the modulo operator (%) to find the factors and then append them to the factors
    list.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为了得到一个数的因数，你会使用范围 (1, number + 1)，但你不希望这些端点出现在因数列表中，因为具有这些维度的翻译矩阵将只是明文。所以将这些值从范围中排除
    ➋。由于一个数的因数能够整除该数，因此使用取模运算符 (%) 查找因数，然后将它们添加到因数列表中。
- en: 'Next, display some useful information for the user: the length of the cipherlist
    and the acceptable choices for rows and columns ➌. Finally, multiply the user’s
    two choices together and compare the product to the length of the cipherlist.
    If they don’t match, print a red warning message in the shell (using our old file=sys.stderr
    trick) and terminate the program ➍. Use sys.exit(1), as the 1 indicates an abnormal
    exit.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，显示一些对用户有用的信息：cipherlist 的长度，以及行和列的可选选择 ➌。最后，将用户的两个选择相乘，并将结果与 cipherlist
    的长度进行比较。如果不匹配，在 shell 中打印红色警告信息（使用我们以前的 file=sys.stderr 技巧），并终止程序 ➍。使用 sys.exit(1)，因为
    1 表示异常退出。
- en: Now define a function to check the key and convert it from a string to a list
    ➎. Pass it the key variable as an argument. Split out each item in key and convert
    it to an integer; name the list key_int to distinguish it from the user-entered
    key variable ➏. Next, determine the minimum and maximum values in the key_int
    list. Then use an if statement to make sure the list contains the same number
    of items as there are columns and none of the items in key is too large, too small,
    or equal to 0 ➐. Terminate the program with an error message if any of those criteria
    fail to pass ➑. Otherwise, return the key_int list ➒.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在定义一个函数来检查密钥并将其从字符串转换为列表 ➎。将密钥变量作为参数传递给它。将密钥中的每个项目拆分并转换为整数；命名列表为 key_int，以区分用户输入的密钥变量
    ➏。接下来，确定 key_int 列表中的最小值和最大值。然后使用 if 语句确保列表中包含与列数相同的项目，且密钥中的项目不太大、不太小或等于 0 ➐。如果任何条件未通过，则终止程序并显示错误信息
    ➑。否则，返回 key_int 列表 ➒。
- en: '**Building and Decoding the Translation Matrix**'
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**构建和解码翻译矩阵**'
- en: '[Listing 4-5](ch04.xhtml#ch04list5) defines two functions, one to build the
    translation matrix and one to decode it, and calls the main() function as a module
    or in stand-alone mode.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-5](ch04.xhtml#ch04list5) 定义了两个函数，一个用于构建翻译矩阵，另一个用于解码翻译矩阵，并将 main() 函数作为模块或独立模式调用。'
- en: '*route_cipher_decrypt.py,* part 4'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*route_cipher_decrypt.py，* 第 4 部分'
- en: '➊ def build_matrix(key_int, cipherlist):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def build_matrix(key_int, cipherlist):'
- en: '"""Turn every n items in a list into a new item in a list of lists."""'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将列表中的每 n 项转换为一个新项目，形成一个列表的列表。"""'
- en: translation_matrix = [None] * COLS
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: translation_matrix = [None] * COLS
- en: start = 0
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: start = 0
- en: stop = ROWS
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: stop = ROWS
- en: 'for k in key_int:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 'for k in key_int:'
- en: if k < 0:  # read bottom-to-top of column
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 'if k < 0:  # 从列的底部到顶部读取'
- en: col_items = cipherlist[start:stop]
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: col_items = cipherlist[start:stop]
- en: elif k > 0:  # read top-to-bottom of columnn
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif k > 0:  # 从列的顶部到底部读取'
- en: col_items = list((reversed(cipherlist[start:stop])))
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: col_items = list((reversed(cipherlist[start:stop])))
- en: translation_matrix[abs(k) - 1] = col_items
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: translation_matrix[abs(k) - 1] = col_items
- en: start += ROWS
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: start += ROWS
- en: stop += ROWS
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: stop += ROWS
- en: return translation_matrix
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: return translation_matrix
- en: '➋ def decrypt(translation_matrix):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ def decrypt(translation_matrix):'
- en: '"""Loop through nested lists popping off last item to a string."""'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '"""遍历嵌套列表，将最后一个项目弹出为字符串。"""'
- en: plaintext = ''
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: plaintext = ''
- en: 'for i in range(ROWS):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(ROWS):'
- en: 'for matrix_col in translation_matrix:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 'for matrix_col in translation_matrix:'
- en: word = str(matrix_col.pop())
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: word = str(matrix_col.pop())
- en: plaintext += word + ' '
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: plaintext += word + ' '
- en: return plaintext
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: return plaintext
- en: '➌ if __name__ == ''__main__'':'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ if __name__ == ''__main__'':'
- en: main()
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: '*Listing 4-5: Defines the functions for building and decoding the translation
    matrix*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-5：定义了构建和解码翻译矩阵的函数*'
- en: These two functions represent encapsulation of code in the *route_cipher_decrypt_prototype.py*
    program. See [Listing 4-1](ch04.xhtml#ch04list1) for a detailed description.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数代表了 *route_cipher_decrypt_prototype.py* 程序中代码的封装。详细描述请参见 [清单 4-1](ch04.xhtml#ch04list1)。
- en: First, define a function to build the translation matrix; pass it the key_int
    and cipherlist variables as arguments ➊. Have the function return the list of
    lists.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义一个函数来构建翻译矩阵；将 key_int 和 cipherlist 变量作为参数传递给它 ➊。让该函数返回列表的列表。
- en: Next, bundle the decryption code, where you pop off the end of each nested list,
    as a function that uses the translation_matrix list as an argument ➋. Return the
    plaintext, which will be printed by the main() function.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将解密代码捆绑起来，弹出每个嵌套列表的末尾，作为一个函数，该函数使用 translation_matrix 列表作为参数 ➋。返回明文，主函数将打印出该明文。
- en: End with the conditional statement that lets the program run as a module or
    in stand-alone mode ➌.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以条件语句结束，让程序可以作为模块或独立模式运行 ➌。
- en: If you’re an occasional or one-time user of this code, you’ll appreciate how
    straightforward and approachable it is. If you plan to alter the code for your
    own purposes, you’ll also appreciate that the key variables are accessible and
    the major tasks are modularized. You won’t have to dig through the program to
    tease out what matters or understand the difference between arcane variables like
    list1 and list2.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是这个代码的偶尔使用者或一次性用户，你会很欣赏它的简洁和易于接触。如果你计划为了自己的目的修改代码，你也会欣赏密钥变量的可访问性以及主要任务的模块化。你无需深入程序查找关键信息，或者去理解像
    list1 和 list2 这样的晦涩变量之间的区别。
- en: 'Here’s the output of the program, using the ciphertext from [Figure 4-3](ch04.xhtml#ch04fig3):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是程序的输出，使用来自[图 4-3](ch04.xhtml#ch04fig3)的密文：
- en: Ciphertext = 16 12 8 4 0 1 5 9 13 17 18 14 10 6 2 3 7 11 15 19
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 密文 = 16 12 8 4 0 1 5 9 13 17 18 14 10 6 2 3 7 11 15 19
- en: Trying 4 columns
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试 4 列
- en: Trying 5 rows
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试 5 行
- en: Trying key = -1 2 -3 4
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试密钥 = -1 2 -3 4
- en: Length of cipher = 20
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 密码长度 = 20
- en: 'Acceptable column/row values include: [2, 4, 5, 10]'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 可接受的列/行值包括：[2, 4, 5, 10]
- en: Plaintext = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 明文 = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
- en: 'You should now be able to easily decrypt a route transposition cipher with
    a known key or test suspected routes by using the script’s clear and accessible
    interface to adjust the key. You’ll get a chance to truly crack one of these ciphers,
    by automatically trying every possible key, in “[Route Transposition Cipher: Brute-Force
    Attack](ch04.xhtml#lev111)” on [page 88](ch04.xhtml#page_88).'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够轻松解密已知密钥的路线换位密码，或者通过使用脚本的清晰和易于访问的界面调整密钥来测试怀疑的路径。你将有机会真正破解这些密码，通过自动尝试每个可能的密钥，在“[路线换位密码：暴力破解攻击](ch04.xhtml#lev111)”中，位于[第88页](ch06.xhtml#page_88)。
- en: '**Project #9: The Rail Fence Cipher**'
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #9：Rail Fence 密码**'
- en: Confederate officers and spies were pretty much on their own when it came to
    cryptography. This led to unsophisticated solutions, one of the favorites being
    the rail fence cipher, so named due to its resemblance to the zigzag pattern of
    a split-rail fence (shown in [Figure 4-8](ch04.xhtml#ch04fig8)).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 南方邦联的军官和间谍在密码学方面几乎是独立的，这导致了不复杂的解决方案，其中最受欢迎的就是 rail fence 密码，之所以这样命名，是因为它与分裂的栅栏的锯齿形图案相似（见[图
    4-8](ch04.xhtml#ch04fig8)）。
- en: '![image](../images/f0080-01.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0080-01.jpg)'
- en: '*Figure 4-8: A rail fence*'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-8：一个 rail fence*'
- en: The rail fence is a simple-to-use transposition cipher, like the Union’s route
    cipher, but differs from the route cipher in that it transposes letters rather
    than words, making it more error-prone. And since the number of possible keys
    is much more restrictive than the number of paths through a route cipher, the
    rail fence cipher is much easier to “tear down.”
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Rail fence 是一种简单易用的换位密码，就像联邦军的路线密码一样，但与路线密码不同的是，它对字母进行换位，而不是单词，这使得它更容易出错。而且，由于可能的密钥数量远比路线密码中的路径数量要有限，因此
    rail fence 密码更容易被“破解”。
- en: Both the Union and Confederates used the rail fence as a field cipher, and the
    spies probably didn’t use code words very often. Codebooks needed to be tightly
    controlled, for obvious reasons, and were more likely to be secured in a military
    telegraph office than carried around by easily compromised undercover agents.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦军和南方邦联都使用了 rail fence 作为场地密码，而间谍们可能并不经常使用密码词。出于显而易见的原因，密码本需要严格控制，更有可能保存在军事电报局，而不是被易于泄露的卧底特工随身携带。
- en: 'Sometimes the Confederates used the more complex Vigenère cipher (see “[Project
    #12: Hiding a Vigenère Cipher](ch06.xhtml#lev130)” on [page 106](ch06.xhtml#page_106))
    for important messages—and some unimportant ones to mislead enemies—but it was
    tedious work to decipher and equally laborious to encrypt and not suitable for
    fast field communications.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '有时，联邦军使用更复杂的维吉尼亚密码（见“[项目 #12：隐藏维吉尼亚密码](ch06.xhtml#lev130)”在[第106页](ch06.xhtml#page_106)）来传递重要信息——以及一些不重要的消息来误导敌人——但这是一项繁琐的解密工作，同样加密也非常繁琐，不适合快速的战场通信。'
- en: Despite their lack of training in the mechanics of cryptography, the Confederacy,
    and Southerners in general, were clever and innovative. Among their more impressive
    accomplishments in the art of secret messages was the use of microphotography,
    100 years before it was widely adopted during the Cold War.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管缺乏密码学的训练，但南方邦联和南方人普遍来说都非常聪明和创新。在秘密信息艺术方面，他们更令人印象深刻的成就之一是使用微摄影，比冷战期间广泛应用早了100年。
- en: '**THE OBJECTIVE**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Write Python programs that will help a spy encrypt and decrypt a “two-rail”
    (two-row) rail fence cipher. You should write the programs in a way that will
    reduce potential errors by inexperienced users.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 编写Python程序，帮助间谍加密和解密“二轨”（两行）栅栏密码。你应该以一种减少缺乏经验的用户可能犯错的方式编写程序。
- en: '***The Strategy***'
  id: totrans-307
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: To encrypt a message with the rail fence cipher, follow the steps in [Figure
    4-9](ch04.xhtml#ch04fig9).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用栅栏密码加密消息，请按照[图 4-9](ch04.xhtml#ch04fig9)中的步骤操作。
- en: '![image](../images/f0081-01.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0081-01.jpg)'
- en: '*Figure 4-9: Encryption process for a “two-rail” rail fence cipher*'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-9: “两轨”栅栏密码的加密过程*'
- en: After the plaintext is written, the spaces are removed, and all the letters
    are converted to uppercase (Step 2). Using uppercase is common convention in cryptography,
    as it obfuscates the presence of proper names and the beginning of sentences,
    giving a cryptanalyst fewer clues for deciphering the message.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 明文写好后，去除空格，所有字母转换为大写（步骤 2）。在密码学中使用大写字母是常见的惯例，因为它掩盖了专有名词和句子开头的存在，从而给密码分析师提供了更少的解密线索。
- en: The message is then written in stacked fashion, with every other letter below
    the previous letter and shifted over one space (Step 3). This is where the “rail
    fence” analogy becomes apparent.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，消息以堆叠的方式写出，每个字母位于前一个字母的下方，并偏移一个位置（步骤 3）。这就是“栅栏”类比变得明显的地方。
- en: The first row is then written, followed immediately by the second row on the
    same line (Step 4), and then the letters are broken into groups of five to create
    the illusion of distinct words and to further confuse the cryptanalyst (Step 5).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行写完后，紧接着在同一行写下第二行（步骤 4），然后将字母分成五个一组，以制造出不同单词的错觉，并进一步迷惑密码分析师（步骤 5）。
- en: To decrypt a rail fence cipher, reverse the process. Just remove the spaces,
    divide the message in half, stack the second half below the first, offset by one
    letter, and read the message using the zigzag pattern. If the ciphertext has an
    odd number of letters, put the extra letter in the first (upper) half.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密栅栏密码，只需反转过程。只需去掉空格，将消息分成两部分，将第二部分堆叠在第一部分下方，偏移一个字母，并使用之字形模式读取消息。如果密文中的字母数是奇数，则将额外的字母放在第一（上）部分。
- en: To make things easy for people who want to use a rail fence cipher, follow the
    preceding steps to write two programs, one to encrypt and another to decrypt.
    [Figure 4-9](ch04.xhtml#ch04fig9) is essentially your pseudocode, so let’s get
    to it. And since you now know how to package the code for inexperienced users,
    take that approach from the start.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便那些想使用栅栏密码的人，请按照前面的步骤编写两个程序，一个用于加密，另一个用于解密。[图 4-9](ch04.xhtml#ch04fig9)本质上是你的伪代码，所以让我们开始吧。既然你现在知道如何为缺乏经验的用户打包代码，就从一开始就采用这种方法。
- en: '***The Rail Fence Cipher Encryption Code***'
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***栅栏密码加密代码***'
- en: The code in this section allows a user to enter a plaintext message and have
    the encrypted results print in the interpreter window. This code is available
    for download with the book’s resources at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的代码允许用户输入明文消息，并在解释器窗口中打印加密结果。此代码可以通过本书资源下载，地址为*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*。
- en: '**Instructing the User and Getting Input**'
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**指导用户并获取输入**'
- en: '[Listing 4-6](ch04.xhtml#ch04list6), at the top of *rail_fence_cipher_encrypt.py*,
    provides the program’s instructions and assigns the plaintext to a variable.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-6](ch04.xhtml#ch04list6)位于*rail_fence_cipher_encrypt.py*的顶部，提供了程序的说明，并将明文赋值给一个变量。'
- en: '*rail_fence_cipher_encrypt.py,* part 1'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '*rail_fence_cipher_encrypt.py,* 第1部分'
- en: ➊ r"""Encrypt a Civil War 'rail fence' type cipher.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ r"""加密一个内战时期的‘栅栏’类型密码。
- en: This is for a "2-rail" fence cipher for short messages.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这是针对短消息的“2轨”栅栏密码。
- en: Example text to encrypt:  'Buy more Maine potatoes'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 加密示例文本：‘购买更多的缅因土豆’
- en: Rail fence style:  B Y O E A N P T T E
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 栅栏密码样式： B Y O E A N P T T E
- en: U M R M I E O A O S
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: U M R M I E O A O S
- en: Read zigzag:       \/\/\/\/\/\/\/\/\/\/
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 按照之字形读： \/\/\/\/\/\/\/\/\/
- en: Encrypted:  BYOEA NPTTE UMRMI EOSOS
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 加密结果： BYOEA NPTTE UMRMI EOSOS
- en: '"""'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: '#------------------------------------------------------------------------------'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '#------------------------------------------------------------------------------'
- en: '➋ # USER INPUT:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ # 用户输入：'
- en: '# the string to be encrypted (paste between quotes):'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '# 要加密的字符串（粘贴在引号之间）：'
- en: ➌ plaintext = """Let us cross over the river and rest under the shade of the
    trees
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ plaintext = """让我们跨过这条河流，休息在树荫下
- en: '"""'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: '➍ # END OF USER INPUT - DO NOT EDIT BELOW THIS LINE!'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ # 用户输入结束 - 请勿编辑以下内容！'
- en: '#------------------------------------------------------------------------------'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '#------------------------------------------------------------------------------'
- en: '*Listing 4-6: Docstring and user input section for* rail_fence_cipher_encrypt.py'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表4-6：rail_fence_cipher_encrypt.py的文档字符串和用户输入部分*'
- en: Start with a multiline docstring, placing an r (which stands for “raw”) prefix
    before the first set of triple quotes ➊. Without this prefix, Pylint will complain
    bitterly about the \/\ slashes used further down. Fortunately, pydocstyle points
    this out so you can fix it (read [Chapter 1](ch01.xhtml#ch01) to learn all about
    Pylint and pydocstyle). If you want to know more about *raw strings*, see Section
    2.4.1 in the Python docs (*[https://docs.python.org/3.6/reference/lexical_analysis.html#string-and-bytes-literals](https://docs.python.org/3.6/reference/lexical_analysis.html#string-and-bytes-literals)*).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 从多行文档字符串开始，在第一组三重引号之前加上r前缀（表示“原始”） ➊。没有这个前缀，Pylint会强烈抱怨下文中使用的\/\斜杠。幸运的是，pydocstyle会指出这一点，这样你就能修复它（阅读[第1章](ch01.xhtml#ch01)来了解有关Pylint和pydocstyle的所有信息）。如果你想了解更多关于*原始字符串*的信息，请参阅Python文档中的第2.4.1节（*
    [https://docs.python.org/3.6/reference/lexical_analysis.html#string-and-bytes-literals](https://docs.python.org/3.6/reference/lexical_analysis.html#string-and-bytes-literals)
    *）。
- en: Next, separate the program’s docstring and import statements from the input
    section with a line and let the user know they’re on deck with an all-caps comment
    ➋. Clearly define the input requirement with comments and place the plaintext
    inside triple quotes to better accommodate long text strings ➌.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用一行分隔程序的文档字符串和导入语句，并通过全大写注释让用户知道他们即将进入输入部分 ➋。清楚地定义输入要求，并将明文放在三重引号内，以便更好地容纳长文本字符串
    ➌。
- en: Finally, end the user input section with a declaration to that effect and caution
    to not edit anything below the following line ➍.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，用声明标明用户输入部分的结束，并提醒不要编辑以下内容 ➍。
- en: '**Encrypting a Message**'
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**加密消息**'
- en: Add [Listing 4-7](ch04.xhtml#ch04list7) to *rail_fence_cipher_encrypt.py* in
    order to handle the encryption processes.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 将[列表4-7](ch04.xhtml#ch04list7)添加到 *rail_fence_cipher_encrypt.py* 以处理加密过程。
- en: '*rail_fence_cipher_encrypt.py,* part 2'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '*rail_fence_cipher_encrypt.py,* 第二部分'
- en: '➊ def main():'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def main():'
- en: '"""Run program to encrypt message using 2-rail rail fence cipher."""'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '"""运行程序，使用2轨道栅栏密码加密消息。"""'
- en: message = prep_plaintext(plaintext)
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: message = prep_plaintext(plaintext)
- en: rails = build_rails(message)
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: rails = build_rails(message)
- en: encrypt(rails)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: encrypt(rails)
- en: '➋ def prep_plaintext(plaintext):'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ def prep_plaintext(plaintext):'
- en: '"""Remove spaces & leading/trailing whitespace."""'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '"""去除空格和前后空白字符。"""'
- en: ➌ message = "".join(plaintext.split())
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ message = "".join(plaintext.split())
- en: ➍ message = message.upper()  # convention for ciphertext is uppercase
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ message = message.upper()  # 密文的惯例是大写字母'
- en: print("\nplaintext = {}".format(plaintext))
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: print("\nplaintext = {}".format(plaintext))
- en: return message
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: return message
- en: '➎ def build_rails(message):'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ def build_rails(message):'
- en: '"""Build strings with every other letter in a message."""'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '"""用消息中的每个其他字母构建字符串。"""'
- en: evens = message[::2]
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: evens = message[::2]
- en: odds = message[1::2]
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: odds = message[1::2]
- en: ➏ rails = evens + odds
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ rails = evens + odds
- en: return rails
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: return rails
- en: '➐ def encrypt(rails):'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '➐ def encrypt(rails):'
- en: '"""Split letters in ciphertext into chunks of 5 & join to make string."""'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将密文中的字母拆分为5个一组，并连接成字符串。"""'
- en: ➑ ciphertext = ' '.join([rails[i:i+5] for i in range(0, len(rails), 5)])
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ ciphertext = ' '.join([rails[i:i+5] for i in range(0, len(rails), 5)])
- en: print("ciphertext = {}".format(ciphertext))
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: print("ciphertext = {}".format(ciphertext))
- en: '➒ if __name__ == ''__main__'':'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '➒ if __name__ == ''__main__'':'
- en: main()
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: '*Listing 4-7: Defines functions to encrypt the plaintext message*'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表4-7：定义函数以加密明文消息*'
- en: 'To start, define a main() function to run the program ➊. Having a main() function
    gives you the flexibility to use this program as a module in another program later,
    should the need arise. This function calls three other functions: one to prepare
    the input plaintext, one to build the “rails” used by the cipher, and one to break
    the encrypted text into five-letter chunks.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义一个main()函数来运行程序 ➊。拥有一个main()函数可以在以后需要时，使你有灵活性将这个程序作为模块用于另一个程序。这个函数调用了三个其他函数：一个用来准备输入的明文，一个用来构建密码使用的“轨道”，以及一个用来将加密文本分成五个字母一组。
- en: Next, define a function to take the input string and prepare it for encryption
    ➋. This involves removing spaces ➌ and converting letters to uppercase (as in
    Step 2 in [Figure 4-9](ch04.xhtml#ch04fig9)) ➍. Then, after a newline, print the
    plaintext to the screen and return it.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个函数来处理输入字符串并准备进行加密 ➋。这个过程包括去除空格 ➌ 并将字母转换为大写（如[图 4-9](ch04.xhtml#ch04fig9)中的步骤
    2所示） ➍。然后，在换行后，将明文打印到屏幕上并返回。
- en: Now, define a function to build two strings, as in Step 3 of [Figure 4-9](ch04.xhtml#ch04fig9),
    by slicing message for evens (starting at 0 and stepping by 2) and for odds (starting
    at 1 and stepping by 2) ➎. The two strings are then concatenated in a new string,
    named rails ➏, and returned.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，定义一个函数，通过对消息进行切片来创建两个字符串，如[图 4-9](ch04.xhtml#ch04fig9)中的步骤 3所示，分别获取偶数索引（从
    0 开始，步长为 2）和奇数索引（从 1 开始，步长为 2） ➎。然后，将这两个字符串连接成一个新的字符串，命名为 rails ➏，并返回。
- en: Define an encryption function that takes the rails string as an argument ➐.
    Use list comprehension to split the ciphertext into chunks of five (as in Step
    5 of [Figure 4-9](ch04.xhtml#ch04fig9)) ➑. The encrypted text is then printed
    to the screen. Finish with the code to run the program as a module or in stand-alone
    mode ➒.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个加密函数，将 rails 字符串作为参数 ➐。使用列表推导式将密文拆分为五个字符一组（如[图 4-9](ch04.xhtml#ch04fig9)中的步骤
    5所示） ➑。然后将加密文本打印到屏幕上。最后，编写代码以作为模块或独立模式运行程序 ➒。
- en: 'Here is the output from this program:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该程序的输出：
- en: plaintext = Let us cross over the river and rest under the shade of the trees
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 明文 = 让我们跨过河流，在树荫下休息
- en: ciphertext = LTSRS OETEI EADET NETEH DOTER EEUCO SVRHR VRNRS UDRHS AEFHT ES
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 密文 = LTSRS OETEI EADET NETEH DOTER EEUCO SVRHR VRNRS UDRHS AEFHT ES
- en: '***The Rail Fence Cipher Decryption Code***'
  id: totrans-374
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***栅栏密码解密代码***'
- en: The code in this section allows a user to enter a message encrypted with the
    rail fence cipher and have the plaintext printed in the interpreter window. This
    code is available for download along with the rest of the book’s resources at
    *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的代码允许用户输入用栅栏密码加密的信息，并在解释器窗口中打印明文。此代码可与本书的其他资源一起下载，链接地址为 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*。
- en: '**Importing Modules, Instructing the User, and Getting Input**'
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**导入模块、指导用户并获取输入**'
- en: '[Listing 4-8](ch04.xhtml#ch04list8) starts with instructions similar to those
    in the *rail_fence_cipher_encrypt.py* program ([Listing 4-6](ch04.xhtml#ch04list6)),
    imports two modules, and gets the user input.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-8](ch04.xhtml#ch04list8)开始时有类似于*rail_fence_cipher_encrypt.py*程序中的指令（[清单
    4-6](ch04.xhtml#ch04list6)），导入了两个模块，并获取了用户输入。'
- en: '*rail_fence_cipher_decrypt.py,* part 1'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '*rail_fence_cipher_decrypt.py*，第一部分'
- en: r"""Decrypt a Civil War 'rail fence' type cipher.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: r"""解密美国内战时期的“栅栏密码”。
- en: This is for a 2-rail fence cipher for short messages.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于短信息的2轨栅栏密码。
- en: Example plaintext:  'Buy more Maine potatoes'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 示例明文：  ‘购买更多缅因州土豆’
- en: Rail fence style:  B Y O E A N P T T E
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 栅栏风格：  B Y O E A N P T T E
- en: U M R M I E O A O S
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: U M R M I E O A O S
- en: Read zigzag:       \/\/\/\/\/\/\/\/\/\/
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 按之字形读取：   \/\/\/\/\/\/\/\/\/\/
- en: Ciphertext:  BYOEA NPTTE UMRMI EOSOS
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 密文：  BYOEA NPTTE UMRMI EOSOS
- en: '"""'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: ➊ import math
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ import math
- en: import itertools
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: import itertools
- en: '#------------------------------------------------------------------------------'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '#------------------------------------------------------------------------------'
- en: '# USER INPUT:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '# 用户输入：'
- en: '# the string to be decrypted (paste between quotes):'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '# 要解密的字符串（请在引号之间粘贴）：'
- en: ➋ ciphertext = """LTSRS OETEI EADET NETEH DOTER EEUCO SVRHR VRNRS UDRHS AEFHT
    ES
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 密文 = """LTSRS OETEI EADET NETEH DOTER EEUCO SVRHR VRNRS UDRHS AEFHT ES
- en: '"""'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: '# END OF USER INPUT - DO NOT EDIT BELOW THIS LINE!'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '# 用户输入结束 - 请勿编辑以下内容！'
- en: '#------------------------------------------------------------------------------'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '#------------------------------------------------------------------------------'
- en: '*Listing 4-8: Imports modules, instructs the user, and gets user input*'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-8：导入模块、指导用户并获取用户输入*'
- en: One difference here is that you need to import the math and itertools modules
    ➊. You’ll use math for rounding. The itertools module is a group of functions
    in the Python Standard Library that create iterators for efficient looping. You’ll
    use itertool’s zip_longest() function during the decryption process.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个区别是，你需要导入 math 和 itertools 模块 ➊。你将使用 math 进行四舍五入。itertools 模块是 Python 标准库中的一组函数，用于创建高效循环的迭代器。在解密过程中，你将使用
    itertools 的 zip_longest() 函数。
- en: The only other change is that the user should enter ciphertext, rather than
    plaintext ➋.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的其他更改是，用户应输入密文，而不是明文 ➋。
- en: '**Decrypting a Message**'
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**解密一条信息**'
- en: '[Listing 4-9](ch04.xhtml#ch04list9) defines the functions for preparing and
    decoding the ciphertext and finishes off *rail_fence_cipher_decrypt.py*.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-9](ch04.xhtml#ch04list9)定义了用于准备和解码密文的函数，并完成了*rail_fence_cipher_decrypt.py*。'
- en: '*rail_fence_cipher_decrypt.py,* part 2'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '*rail_fence_cipher_decrypt.py,* 第二部分'
- en: '➊ def main():'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def main():'
- en: '"""Run program to decrypt 2-rail rail fence cipher."""'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '"""运行程序以解密2轨铁丝栅加密。"""'
- en: message = prep_ciphertext(ciphertext)
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: message = prep_ciphertext(ciphertext)
- en: row1, row2 = split_rails(message)
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: row1, row2 = split_rails(message)
- en: decrypt(row1, row2)
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: decrypt(row1, row2)
- en: '➋ def prep_ciphertext(ciphertext):'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ def prep_ciphertext(ciphertext):'
- en: '"""Remove whitespace."""'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '"""去除空格。"""'
- en: message = "".join(ciphertext.split())
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: message = "".join(ciphertext.split())
- en: print("\nciphertext = {}".format(ciphertext))
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: print("\nciphertext = {}".format(ciphertext))
- en: return message
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: return message
- en: '➌ def split_rails(message):'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ def split_rails(message):'
- en: '"""Split message in two, always rounding UP for 1st row."""'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将消息分成两部分，总是对第一行进行向上取整。"""'
- en: ➍ row_1_len = math.ceil(len(message)/2)
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ row_1_len = math.ceil(len(message)/2)
- en: ➎ row1 = (message[:row_1_len]).lower()
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ row1 = (message[:row_1_len]).lower()
- en: row2 = (message[row_1_len:]).lower()
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: row2 = (message[row_1_len:]).lower()
- en: return row1, row2
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: return row1, row2
- en: '➏ def decrypt(row1, row2):'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '➏ def decrypt(row1, row2):'
- en: '"""Build list with every other letter in 2 strings & print."""'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '"""构建列表，将两个字符串中的每隔一个字母拼接并打印。"""'
- en: ➐ plaintext = []
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ plaintext = []
- en: '➑ for r1, r2 in itertools.zip_longest(row1, row2):'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '➑ for r1, r2 in itertools.zip_longest(row1, row2):'
- en: plaintext.append(r1)
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: plaintext.append(r1)
- en: plaintext.append(r2)
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: plaintext.append(r2)
- en: '➒ if None in plaintext:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '➒ if None in plaintext:'
- en: plaintext.pop()
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: plaintext.pop()
- en: print("rail 1 = {}".format(row1))
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: print("rail 1 = {}".format(row1))
- en: print("rail 2 = {}".format(row2))
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: print("rail 2 = {}".format(row2))
- en: print("\nplaintext = {}".format(''.join(plaintext)))
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: print("\nplaintext = {}".format(''.join(plaintext)))
- en: '➓ if __name__ == ''__main__'':'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '➓ if __name__ == ''__main__'':'
- en: main()
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: '*Listing 4-9: Prepares, decodes, and prints the message*'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4-9：准备、解码并打印消息*'
- en: 'The main() function here ➊ is similar to the one used in the encryption program
    in [Listing 4-7](ch04.xhtml#ch04list7). Three functions are called: one to prepare
    the input string, one to “split the rails” in the rail fence cipher, and one to
    stitch the two rails back together into readable plaintext.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的main()函数 ➊ 与[清单 4-7](ch04.xhtml#ch04list7)中的加密程序相似。调用了三个函数：一个准备输入字符串，一个用于“分割铁丝栅”，一个将两行重新拼接成可读的明文。
- en: Start with a function that repeats the preprocessing steps used during encryption
    ➋. Remove the spaces between the five-letter chunks, as well as any other whitespace
    created during the pasting of the ciphertext, and print and return the ciphertext.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个函数开始，该函数重复加密过程中使用的预处理步骤 ➋。去除五个字母块之间的空格以及在粘贴密文时产生的其他任何空格，然后打印并返回密文。
- en: Next, you need to split the message back into two halves to reverse the encryption
    process ➌. As I mentioned in “[The Strategy](ch04.xhtml#lev97)” on [page 81](ch04.xhtml#page_81),
    the extra letter in a message with an odd number of characters is assigned to
    the top row. To address the odd-numbered case, use the math.ceil() method ➍. “Ceil”
    stands for “ceiling,” so when you divide by 2, the answer is always rounded up
    to the nearest integer. Assign this number to the row_1_len variable. Once you
    know the length of the first row, use that value and slicing to divide the message
    variable into two strings representing the rows ➎. End the function by returning
    the row variables.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要将消息分成两半，以便逆转加密过程 ➌。正如我在“[策略](ch04.xhtml#lev97)”中提到的，[第81页](ch04.xhtml#page_81)中，字符数为奇数的消息中的额外字母被分配到第一行。为了处理奇数情况，使用math.ceil()方法
    ➍。“Ceil”代表“天花板”，所以当你除以2时，答案总是四舍五入到最接近的整数。将这个数字分配给row_1_len变量。一旦你知道第一行的长度，就可以使用该值和切片将消息变量分成两串，表示两行
    ➎。通过返回这两个行变量来结束函数。
- en: Now it’s just a matter of choosing and joining every other letter from the rows
    to stitch the plaintext back together. Define a decrypt() function and pass it
    the strings for row1 and row2 ➏. Start the translation process by making an empty
    list to hold the results ➐. Next, you need an easy way to deal with cases where
    the ciphertext has an odd number of letters—resulting in two rows of different
    lengths—because Python prevents you from looping through two uneven sequences
    by raising an index-out-of-range error. This is why we’ve imported the itertools
    module—its functions help with looping to circumvent this problem.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需要选择并连接每行的其他字母，将明文拼接起来。定义一个 decrypt() 函数，并传入轨道 1 和轨道 2 的字符串 ➏。通过创建一个空列表来保存结果，开始翻译过程
    ➐。接下来，你需要一种简便的方法来处理密文中包含奇数个字母的情况——这会导致两行的长度不同——因为 Python 不允许你循环遍历两个长度不等的序列，会引发超出索引范围的错误。这就是为什么我们导入了
    itertools 模块——它的函数可以帮助循环处理这个问题。
- en: The itertools.zip_longest() function accepts two strings as arguments and loops
    through them without complaint, appending a null value (None) to the plaintext
    list when it gets to the end of the shorter string ➑. You don’t want to print
    this null value, so if it’s there, remove it using the pop() method you applied
    in the route cipher code ➒. Complete the decryption process by printing the two
    rows (rails) to the screen, followed by the decrypted ciphertext.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: itertools.zip_longest() 函数接受两个字符串作为参数，并在遍历它们时不会报错。当遍历到较短字符串的末尾时，它会将一个空值（None）附加到明文列表中
    ➑。你不希望打印这个空值，因此如果它存在，可以使用你在路线密码代码中应用的 pop() 方法将其删除 ➒。通过打印两行（轨道）到屏幕，接着输出解密后的密文，完成解密过程。
- en: 'End with the standard code for running the program as a module or in stand-alone
    mode ➓. The output from the program is as follows:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 以标准代码结束程序，使其能够作为模块或独立模式运行 ➓。程序的输出如下：
- en: ciphertext = LTSRS OETEI EADET NETEH DOTER EEUCO SVRHR VRNRS UDRHS AEFHT ES
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 密文 = LTSRS OETEI EADET NETEH DOTER EEUCO SVRHR VRNRS UDRHS AEFHT ES
- en: rail 1 = LTSRSOETEIEADETNETEHDOTERE
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 轨道 1 = LTSRSOETEIEADETNETEHDOTERE
- en: rail 2 = EUCOSVRHRVRNRSUDRHSAEFHTES
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 轨道 2 = EUCOSVRHRVRNRSUDRHSAEFHTES
- en: plaintext = letuscrossovertheriverandrestundertheshadeofthetrees
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 明文 = letuscrossovertheriverandrestundertheshadeofthetrees
- en: Note that there will be no spaces between words, but that’s okay—you don’t want
    to leave the cryptanalyst feeling completely useless!
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，单词之间没有空格，但这没关系——你不想让密码分析师完全感到无用！
- en: '**Summary**'
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: That completes our foray into Civil War ciphers. You wrote a program that helps
    a user decrypt a route cipher, and you gained valuable insights into how it works
    and how to hack it. You can implement an automated attack on the cipher in the
    following practice projects, but remember, with its many possible paths and use
    of code words, the Union route cipher is a tough nut to fully crack.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对南北战争密码的探讨。你编写了一个帮助用户解密路线密码的程序，并且获得了关于其工作原理以及如何破解它的宝贵见解。你可以在接下来的练习项目中实现对该密码的自动化攻击，但请记住，由于其多种可能的路径和使用密码词，联邦路线密码仍然是一个难以完全破解的难题。
- en: Next, you wrote programs to encrypt and decrypt two-rail fence ciphers. Given
    how tedious and error-prone the manual encryption and decryption processes are,
    having an automated way to do most of the work would have been valuable to both
    sides in the war. And to further address these types of issues, you wrote your
    code to be user-friendly to the inexperienced cryptanalyst or spy.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你编写了程序来加密和解密二轨栅栏密码。考虑到手动加密和解密过程既繁琐又容易出错，有一个自动化的方法来完成大部分工作对战争双方来说都非常有价值。为了进一步解决这些问题，你编写了一个用户友好的代码，方便那些没有经验的密码分析师或间谍使用。
- en: '**Further Reading**'
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: More beginner-level Python programs for working with transposition ciphers are
    available in *Cracking Codes with Python* (No Starch Press, 2018) by Al Sweigart.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 更多适合初学者的 Python 程序用于处理换位密码，可以参考*《用 Python 破解密码》*（No Starch Press，2018年）作者 Al
    Sweigart。
- en: 'Excellent and well-illustrated overviews of cryptography can be found in *Mysterious
    Messages: A History of Codes and Ciphers* (The Penguin Group, 2009) by Gary Blackwood
    and *The Code Book: The Science of Secrecy from Ancient Egypt to Quantum Cryptography*
    (Anchor, 2000) by Simon Singh.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 关于密码学的优秀且图文并茂的概述可以在*《神秘信息：密码和暗号的历史》*（企鹅出版集团，2009年）作者 Gary Blackwood 和*《密码书：从古埃及到量子密码学的秘密科学》*（Anchor，2000年）作者
    Simon Singh 中找到。
- en: The sites *[http://www.civilwarsignals.org/pages/crypto/crypto.html](http://www.civilwarsignals.org/pages/crypto/crypto.html)*
    and *[http://www.mathaware.org/mam/06/Sauerberg_route-essay.html](http://www.mathaware.org/mam/06/Sauerberg_route-essay.html)*
    include descriptions of Edward Porter Alexander’s attempt to solve a route cipher.
    Alexander was the father of the Confederate Army Signal Corps and a brilliant
    military innovator with many impressive accomplishments.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Projects**'
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hone your cryptography skills with these projects. Solutions are available in
    the appendix and online.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '***Hacking Lincoln***'
  id: totrans-452
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In his book, *Mysterious Messages: A History of Codes and Ciphers*, Gary Blackwood
    reproduces an actual message sent by Abraham Lincoln and encrypted with a route
    cipher:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '**THIS OFF DETAINED ASCERTAIN WAYLAND CORRESPONDENTS OF AT WHY AND IF FILLS
    IT YOU GET THEY NEPTUNE THE TRIBUNE PLEASE ARE THEM CAN UP**'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Use the *route_cipher_decrypt.py* program to solve this cryptogram. The number
    of columns and rows must be factors of the message length, and the route starts
    in one of the corners, doesn’t skip columns, and alternates direction with every
    column change. The code word definitions and plaintext solution can be found in
    the appendix.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '***Identifying Cipher Types***'
  id: totrans-456
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The sooner you know what type of cipher you’re dealing with, the sooner you
    can break it. Word-transposition ciphers are easy to spot, but letter-transposition
    ciphers can look like letter-*substitution* ciphers. Fortunately, you can distinguish
    between the two by using the frequency of occurrence of letters in the ciphertext.
    Since the letters are just scrambled and not replaced in transposition ciphers,
    their frequency distribution will be the same as for the language in which the
    plaintext was written. An exception, however, is military messages, which use
    jargon and omit many common words. For these, you need a frequency table built
    from other military messages.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: Write a Python program that takes a string of ciphertext as input and determines
    whether it is more likely to be a transposition cipher or a substitution cipher.
    Test it with the files *cipher_a.txt* and *cipher_b.txt*, downloadable from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    A solution can be found in the appendix and online at the book’s website in *identify_cipher_type_practice.py*.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '***Storing a Key as a Dictionary***'
  id: totrans-459
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Write a short script to break a route cipher key into two parts: one to record
    the column order and one to record the direction to read through the rows in the
    column (up or down). Store the column number as a dictionary key and the reading
    direction as the dictionary value. Have the program interactively request the
    key value for each column from the user. A solution can be found in the appendix
    and online in the file *key_dictionary_practice.py.*'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '***Automating Possible Keys***'
  id: totrans-461
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To attempt to decipher a route cipher using any combination of columns in its
    path, you need to know what those combinations are, so you can enter them as arguments
    in a decryption function. Write a Python program that accepts an integer (such
    as the number of columns) and returns a collection of tuples. Each tuple should
    contain a unique ordering of column numbers, like (1, 2, 3, 4). Include negative
    values—for example, (2, -3, 4, -1)—to capture encryption routes that go up columns
    versus down. A solution is provided in the appendix, with a downloadable version
    on the book’s website in *permutations_practice.py*.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试解密路径密码并使用路径中的任何列组合，你需要知道这些组合是什么，以便你可以将它们作为参数传递给解密函数。编写一个接受整数（例如列数）的 Python
    程序，并返回一个元组集合。每个元组应包含列号的唯一排列，例如 (1, 2, 3, 4)。包括负值——例如 (2, -3, 4, -1)——以捕捉向上与向下的加密路径。附录中提供了一个解决方案，并且在本书的官方网站上提供了一个可下载的版本，文件名为
    *permutations_practice.py*。
- en: '***Route Transposition Cipher: Brute-Force Attack***'
  id: totrans-463
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***路径置换密码：暴力破解***'
- en: Copy and modify the *route_cipher_decrypt.py* program to hack the route cipher
    in [Figure 4-2](ch04.xhtml#ch04fig2). Rather than inputting a single key, loop
    through all possible keys—for an assumed number of columns—and print the results
    (use the earlier permutations code to generate the keys for this four-column cipher).
    The impact of switching the order of columns and allowing up-and-down paths through
    the transposition matrix is clearly illustrated in [Figure 4-10](ch04.xhtml#ch04fig10).
    The dashed line is the factorial of the number of columns; the solid line captures
    the effect of reading up columns as well as down (captured by the inclusion of
    negative values in the key). If you only needed to deal with the factorial of
    4, your job as a cryptanalyst would be easy. But as the cipher gets longer, the
    number of possible keys explodes. And some actual Union route ciphers had 10 or
    more columns!
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 复制并修改 *route_cipher_decrypt.py* 程序来破解 [图 4-2](ch04.xhtml#ch04fig2) 中的路径密码。不要输入单一的密钥，而是循环遍历所有可能的密钥——假设列数已知——并打印结果（使用之前的排列代码生成四列密码的密钥）。[图
    4-10](ch04.xhtml#ch04fig10) 清楚地展示了交换列的顺序和允许上下路径通过置换矩阵的影响。虚线表示列数的阶乘；实线表示通过列向上和向下读取的效果（通过在密钥中包含负值来捕捉）。如果你只需要处理4的阶乘，那么作为密码分析员的工作会很简单。但随着密码变得更长，可能的密钥数量急剧增加。实际上，一些联邦的路径密码包含10列或更多列！
- en: '![image](../images/f0089-01.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0089-01.jpg)'
- en: '*Figure 4-10: Number of possible keys versus number of columns for a route
    cipher*'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-10：路径密码中可能的密钥数与列数的关系*'
- en: 'Here are four translations out of the 384 produced for the ciphertext in [Figure
    4-2](ch04.xhtml#ch04fig2):'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从 [图 4-2](ch04.xhtml#ch04fig2) 中的密文产生的384种翻译中的四种：
- en: using key = [-4, -1, -2, -3]
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 使用密钥 = [-4, -1, -2, -3]
- en: translated = IS HEADING FILLER VILLAGE YOUR SNOW SOUTH GODWIN ARE FREE TO YOU
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译结果 = IS HEADING FILLER VILLAGE YOUR SNOW SOUTH GODWIN ARE FREE TO YOU
- en: WITH SUPPLIES GONE TRANSPORT ROANOKE JUST TO REST
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: WITH SUPPLIES GONE TRANSPORT ROANOKE JUST TO REST
- en: using key = [1, 2, -3, 4]
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 使用密钥 = [1, 2, -3, 4]
- en: translated = REST ROANOKE HEADING TO TRANSPORT WITH SNOW GONE YOU ARE FREE TO
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译结果 = REST ROANOKE HEADING TO TRANSPORT WITH SNOW GONE YOU ARE FREE TO
- en: GODWIN YOUR SUPPLIES SOUTH VILLAGE IS JUST FILLER
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: GODWIN YOUR SUPPLIES SOUTH VILLAGE IS JUST FILLER
- en: using key = [-1, 2, -3, 4]
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 使用密钥 = [-1, 2, -3, 4]
- en: translated = VILLAGE ROANOKE HEADING TO GODWIN WITH SNOW GONE YOU ARE FREE TO
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译结果 = VILLAGE ROANOKE HEADING TO GODWIN WITH SNOW GONE YOU ARE FREE TO
- en: TRANSPORT YOUR SUPPLIES SOUTH REST IS JUST FILLER
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: TRANSPORT YOUR SUPPLIES SOUTH REST IS JUST FILLER
- en: using key = [4, -1, 2, -3]
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 使用密钥 = [4, -1, 2, -3]
- en: translated = IS JUST FILLER REST YOUR SUPPLIES SOUTH TRANSPORT ARE FREE TO YOU
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译结果 = IS JUST FILLER REST YOUR SUPPLIES SOUTH TRANSPORT ARE FREE TO YOU
- en: WITH SNOW GONE GODWIN ROANOKE HEADING TO VILLAGE
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: WITH SNOW GONE GODWIN ROANOKE HEADING TO VILLAGE
- en: The correct answer is present, but you can appreciate how hard it would be to
    pick it out quickly, given the use of code words and dummy words. Still, you did
    your job. Go have that mint julep or some sweet tea.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 正确答案已经出现，但你可以理解，在使用密码词和虚拟词的情况下，快速挑选出正确答案是多么困难。尽管如此，你已经完成了你的任务。去喝一杯薄荷朱勒普或些许甜茶吧。
- en: A solution to this project is provided in the appendix and at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    in *route_cipher_hacker.py*. You will also need the *perms.py* program, which
    is based on the previous practice project.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的解决方案可以在附录中找到，也可以在 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    上找到，文件名为 *route_cipher_hacker.py*。你还需要 *perms.py* 程序，它基于之前的实践项目。
- en: '**Challenge Projects**'
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**挑战项目**'
- en: No solutions are provided for challenge projects.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战项目没有提供解决方案。
- en: '***Route Cipher Encoder***'
  id: totrans-484
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***路线密码编码器***'
- en: A greenhorn Union telegraph clerk needs to encrypt the following message, complete
    with code words ([Table 4-1](ch04.xhtml#ch04tab1)). Help them out by writing a
    program that takes the message as input and automatically substitutes the code
    words, fills the bottom row with dummy words, and transposes the words using the
    key [-1, 3, -2, 6, 5, -4]. Use a 6×7 matrix and make up your own dummy words.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 一名菜鸟联邦电报员需要加密以下信息，且需使用密码词（[表格 4-1](ch04.xhtml#ch04tab1)）。帮助他们编写一个程序，输入消息后自动替换密码词，填充底行的虚拟词，并使用密钥
    [-1, 3, -2, 6, 5, -4] 转置词汇。使用 6×7 的矩阵，并自创虚拟词。
- en: We will run the batteries at Vicksburg the night of April 16 and proceed to
    Grand Gulf where we will reduce the forts. Be prepared to cross the river on April
    25 or 29\. Admiral Porter.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 4 月 16 日晚上在维克斯堡部署电池，随后前往格兰德峡湾，在那里我们将削弱堡垒。请准备在 4 月 25 日或 29 日过河。海军上将波特。
- en: '**Table 4-1:** Code Words'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格 4-1:** 密码词'
- en: '| Batteries | HOUNDS |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '| 电池 | 猎犬 |'
- en: '| Vicksburg | ODOR |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '| 维克斯堡 | 气味 |'
- en: '| April | CLAYTON |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '| 四月 | CLAYTON |'
- en: '| 16 | SWEET |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 甜美 |'
- en: '| Grand | TREE |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '| 格兰德 | 树 |'
- en: '| Gulf | OWL |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| 海湾 | 猫头鹰 |'
- en: '| Forts | BAILEY |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| 堡垒 | 贝利 |'
- en: '| River | HICKORY |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| 河流 | 山核桃 |'
- en: '| 25 | MULTIPLY |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| 25 | 乘法 |'
- en: '| 29 | ADD |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| 29 | 加法 |'
- en: '| Admiral | HERMES |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| 海军上将 | HERMES |'
- en: '| Porter | LANGFORD |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| 波特 | LANGFORD |'
- en: Consider using a Python dictionary for the lexicon of code words in this table.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用 Python 字典来表示此表中的密码词词汇表。
- en: '***Three-Rail Fence Cipher***'
  id: totrans-501
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***三排栅栏密码***'
- en: Write a version of the rail fence cipher that uses three rails (rows) instead
    of two. You can find a hint at *[https://en.wikipedia.org/wiki/Rail_fence_cipher](https://en.wikipedia.org/wiki/Rail_fence_cipher)*.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个使用三排（行）而不是两排的铁路栅栏密码版本。你可以在 *[https://en.wikipedia.org/wiki/Rail_fence_cipher](https://en.wikipedia.org/wiki/Rail_fence_cipher)*
    找到提示。
