- en: '**8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**8'
- en: INTENT RECOGNITION**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**意图识别**'
- en: '![Image](../Images/comm1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../Images/comm1.jpg)'
- en: A chatbot should be smart enough to understand a user’s needs. For example,
    a conversational chatbot must recognize a user’s intent to properly sustain a
    conversation with the user, and a food-ordering chatbot needs to understand a
    customer’s intent to take an order. Although the task of intent recognition was
    touched on in previous chapters, this chapter discusses it in more depth.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天机器人应该足够智能，能够理解用户的需求。例如，一个对话型聊天机器人必须识别用户的意图，才能与用户保持良好的对话，而一个点餐聊天机器人则需要理解顾客的意图，以便接受订单。虽然在之前的章节中曾简要提到过意图识别，但本章将更深入地讨论这一话题。
- en: You’ll start by recognizing a user’s intent by extracting the transitive verb
    and direct object of an utterance. Then you’ll explore how to derive a user’s
    intent from a sequence of sentences, recognize synonyms for different possible
    intents, and determine a user’s intent using semantic similarity.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过提取话语中的及物动词和直接宾语来开始识别用户的意图。然后，你将探索如何从一系列句子中推导出用户的意图，识别不同意图的同义词，并使用语义相似度确定用户的意图。
- en: '**Extracting the Transitive Verb and Direct Object for Intent Recognition**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**提取及物动词和直接宾语以识别意图**'
- en: 'You can typically recognize a user’s intent in three steps: parsing the sentence
    into tokens, connecting the tokens with labeled arcs representing syntactic relations,
    and navigating the arcs to extract the relevant tokens. In many cases, extracting
    the sentence’s transitive verb and direct object can identify the user’s intent,
    as shown by the syntactic dependency parsing in [Figure 8-1](../Text/ch08.xhtml#ch08fig01).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常可以通过三个步骤来识别用户的意图：将句子解析成词元（tokens），用表示句法关系的标记弧连接词元，并通过导航这些弧提取相关词元。在许多情况下，提取句子的及物动词和直接宾语可以识别用户的意图，如[图8-1](../Text/ch08.xhtml#ch08fig01)中的句法依存分析所示。
- en: '![image](../Images/fig8-1.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig8-1.jpg)'
- en: '*Figure 8-1: An example of a graphical representation of a sentence’s syntactic
    structure*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-1：句子句法结构的图形表示示例*'
- en: 'The arc connecting the transitive verb with the direct object indicates that
    the user’s intent is finding a hotel, or just findHotel, if you merged the transitive
    verb and the direct object into a single word. You could use this structure as
    an *intent identifier* in a later part of a program, as in the following code
    fragment:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 连接及物动词和直接宾语的弧表明用户的意图是寻找一家酒店，或者如果将及物动词和直接宾语合并为一个词，则为 findHotel。你可以将这个结构作为后续程序中的*意图标识符*，如以下代码片段所示：
- en: intent = extract_intent(doc)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: intent = extract_intent(doc)
- en: 'if intent == ''orderPizza'':'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 'if intent == ''orderPizza'':'
- en: print('We need you to answer some questions to place your order.')
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: print('我们需要你回答一些问题才能下单。')
- en: '...'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'elif intent == ''showPizza'':'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif intent == ''showPizza'':'
- en: print('Would you like to look at our menu?')
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: print('你想看看我们的菜单吗？')
- en: '...'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '**NOTE**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In [Chapter 11](../Text/ch11.xhtml#ch11), you’ll see more detailed examples
    of how to use intent identifiers in a chatbot app’s code.*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*在[第11章](../Text/ch11.xhtml#ch11)中，你将看到更多关于如何在聊天机器人应用代码中使用意图标识符的详细示例。*'
- en: But sometimes finding the meaning from the transitive verb/direct object pair
    isn’t so easy. You might need to explore the transitive verb and direct object’s
    syntactic relations to find the verb and noun that best describe the intent.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时仅通过及物动词/直接宾语对来找到意义并不容易。你可能需要探索及物动词和直接宾语的句法关系，以找到最能描述意图的动词和名词。
- en: In other situations, a user’s intent isn’t expressed explicitly, so you must
    figure out an implied intent. In this section, you’ll learn strategies for extracting
    intent using the syntactic dependency structure.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，用户的意图并没有明确表达，因此你必须推测出隐含的意图。在本节中，你将学习如何利用句法依存结构提取意图的策略。
- en: '***Obtaining the Transitive Verb/Direct Object Pair***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***获取及物动词/直接宾语对***'
- en: 'Let’s start by extracting the transitive verb/direct object pair from a sentence
    by checking the dependency label of each token, looking for dobj. Once we find
    the direct object, we can easily get the corresponding transitive verb by obtaining
    the syntactic head of the direct object, as illustrated in the following script:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先通过检查每个词元的依存标签，寻找 dobj，来从句子中提取及物动词/直接宾语对。一旦找到直接宾语，我们可以通过获取直接宾语的句法中心来轻松获得相应的及物动词，如下面的脚本所示：
- en: import spacy
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: import spacy
- en: nlp = spacy.load('en')
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: nlp = spacy.load('en')
- en: ➊ doc = nlp(u'show me the best hotel in berlin')
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ doc = nlp(u'给我展示柏林最好的酒店')
- en: '➋ for token in doc:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 对于 doc 中的每个词元：
- en: 'if token.dep_ == ''dobj'':'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 'if token.dep_ == ''dobj'':'
- en: print(➌token.head.text + token.text.capitalize())
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: print(➌token.head.text + token.text.capitalize())
- en: In this script, we apply the pipeline to a sample sentence ➊ and then iterate
    over the tokens, searching for the one whose dependency label is dobj ➋. When
    it’s found, we determine the corresponding transitive verb by obtaining the direct
    object’s head ➌. In this example, we also concatenate the transitive verb and
    its direct object to express the intent in the form of a single word.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个脚本中，我们将管道应用于示例句子 ➊，然后遍历每个 token，寻找其依赖标签为 dobj ➋ 的 token。当找到时，我们通过获取直接对象的
    head ➌ 来确定相应的及物动词。在这个例子中，我们还将及物动词和直接对象连接起来，以单个词的形式表达意图。
- en: 'The script generates the following string:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本生成的字符串如下：
- en: showHotel
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: showHotel
- en: Keep in mind that not all sentences containing a transitive verb/direct object
    pair express intent. For example, “He gave me a book” is just a statement of fact.
    We could filter out such sentences by checking the verb’s characteristics, picking
    up only those sentences whose verbs are in the present tense and not third person.
    Still, it would be uncommon to hear a sentence like that from a customer talking
    to a chatbot that takes orders for a business.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，并非所有包含及物动词/直接对象对的句子都表达意图。例如，“他给了我一本书”只是一个陈述事实的句子。我们可以通过检查动词的特征来过滤出这样的句子，只挑选那些动词是现在时且不是第三人称的句子。不过，从客户与接受订单的聊天机器人交谈时，听到这样的句子还是不太常见的。
- en: '***Extracting Multiple Intents with token.conjuncts***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 token.conjuncts 提取多个意图***'
- en: 'Sometimes, you might find a sentence that seems to express more than one intent.
    For example, consider the following sentence:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会遇到一个看似表达多个意图的句子。例如，考虑以下句子：
- en: I want a pizza and cola.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要一份比萨和可乐。
- en: In this scenario, a user wants to order a pizza and a cola. But in most cases,
    you can consider these intents part of a single complex intent. Although a user
    requests items of different types, you’d typically treat this sentence as a single
    order consisting of several items. In this example, you might recognize the intent
    as orderPizza, formed by combining the transitive verb and direct object pair,
    but extract pizza and cola as items for the order being placed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，用户想要点一份比萨和一瓶可乐。但在大多数情况下，你可以将这些意图视为一个复杂的单一意图。尽管用户请求了不同类型的物品，你通常会将此句子视为包含多个项目的单个订单。在这个例子中，你可能会将意图识别为
    orderPizza，它是通过结合及物动词和直接对象对形成的，但会提取比萨和可乐作为订单中的物品。
- en: '[Figure 8-2](../Text/ch08.xhtml#ch08fig02) shows the dependency tree for the
    sample sentence.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-2](../Text/ch08.xhtml#ch08fig02) 显示了示例句子的依赖树。'
- en: '![image](../Images/fig8-2.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig8-2.jpg)'
- en: '*Figure 8-2: The dependency tree of a sentence containing a direct object and
    its conjunct*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-2：包含直接对象及其连接词的句子的依赖树*'
- en: 'In the diagram, you can see two arrows pointing to the arcs for the direct
    object “pizza” and the conjunct “cola” associated with it. The *conjunct* of a
    noun is another noun that is joined to it by a conjunction, such as “and,” “or,”
    and so on. To extract the direct object and the conjunct associated with it, we
    can use the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在图示中，你可以看到两条箭头指向直接对象“比萨”和与之相关的连接词“可乐”的弧线。名词的 *conjunct* 是通过连词（例如“和”、“或”等）与之连接的另一个名词。为了提取直接对象及其相关连接词，我们可以使用以下代码：
- en: doc = nlp(u'I want a pizza and cola.')
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: doc = nlp(u'I want a pizza and cola.')
- en: '#extract the direct object and the conjunct associated with it'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '#提取直接对象及其相关连接词'
- en: 'for token in doc:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 'for token in doc:'
- en: 'if token.dep_ == ''dobj'':'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 'if token.dep_ == ''dobj'':'
- en: dobj = [token.text]
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: dobj = [token.text]
- en: conj = [t.text for t in ➊token.conjuncts]
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: conj = [t.text for t in ➊token.conjuncts]
- en: '#compose the list of the extracted elements'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '#合并提取的元素列表'
- en: ➋ dobj_conj = dobj + conj
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ dobj_conj = dobj + conj
- en: print(dobj_conj)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: print(dobj_conj)
- en: We extract the conjunct associated with the direct object using the conjuncts
    property of the Token object used for the direct object ➊. Once we’ve obtained
    the direct object and its conjuncts, we combine them into a single list ➋.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用直接对象 ➊ 的 Token 对象的 conjuncts 属性来提取与直接对象相关的连接词。一旦我们获得了直接对象及其连接词，就将它们合并成一个单一的列表
    ➋。
- en: 'The script output should be as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本输出应该如下所示：
- en: '[''pizza'', ''cola'']'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[''比萨'', ''可乐'']'
- en: 'To compose the intent, we should extract the verb, too. The simplest way to
    obtain it when we already have the direct object is to obtain the direct object’s
    syntactic head (you saw an example of this in “[Obtaining the Transitive Verb/Direct
    Object Pair](../Text/ch08.xhtml#lev105)” on [page 113](../Text/ch08.xhtml#page_113)):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建意图，我们也应该提取动词。我们已经有了直接宾语，获得它最简单的方法是获取直接宾语的句法头（你在“[获取及物动词/直接宾语对](../Text/ch08.xhtml#lev105)”中看到过这个示例，见[第113页](../Text/ch08.xhtml#page_113)）：
- en: verb = dobj.head
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: verb = dobj.head
- en: Then, using the text property of the verb and the direct object, we can compose
    the intent.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用动词和直接宾语的 text 属性，我们可以构建意图。
- en: '***Try This***'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***尝试这个***'
- en: In the script provided in on [page 114](../Text/ch08.xhtml#page_114), you accessed
    the conjunct linked to the direct object through the Token object’s conjuncts
    property. In a new script, replace that line with code that extracts the conjunct
    by finding the arc labeled conj moving outward from the direct object. You can
    do this within the same loop in which you obtain the direct object by finding
    the arc labeled dobj. Be sure to check that the head of the conj arc matches the
    direct object.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第114页](../Text/ch08.xhtml#page_114)提供的脚本中，你通过 Token 对象的 conjuncts 属性访问了与直接宾语相关联的连接词。在新的脚本中，将那一行代码替换为提取连接词的代码，通过查找从直接宾语向外延伸的标记为
    conj 的弧线。你可以在获取直接宾语的同一个循环中完成这项操作，方法是查找标记为 dobj 的弧线。务必检查 conj 弧线的头部是否与直接宾语匹配。
- en: '***Using Word Lists to Extract the Intent***'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用词汇列表提取意图***'
- en: In some cases, tokens other than the transitive verb and direct object best
    describe the user’s intent. These tokens are typically related to the transitive
    verb or direct object. So you’ll need to go a step further and explore the transitive
    verb and direct object’s syntactic relations to discover the words that best formulate
    the intent.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，除及物动词和直接宾语之外的其他词汇更能准确描述用户的意图。这些词汇通常与及物动词或直接宾语相关。因此，你需要进一步探索及物动词和直接宾语的句法关系，以发现最能表达意图的词汇。
- en: 'As an example, consider the following utterance:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下话语：
- en: I want to place an order for a pizza.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要订购一个披萨。
- en: In this sentence, the words “want” and “pizza” best describe the intent, but
    neither word is a direct object or transitive verb. However, looking at the utterance’s
    dependency tree, you’ll see that “want” and “pizza” are related to the transitive
    verb “place” and the direct object “order,” respectively. [Figure 8-3](../Text/ch08.xhtml#ch08fig03)
    shows the dependency tree discussed here.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个句子中，“want”和“pizza”这两个词最能表达意图，但这两个词都不是直接宾语或及物动词。然而，通过查看话语的依赖关系树，你会发现，“want”和“pizza”分别与及物动词“place”和直接宾语“order”相关联。[图8-3](../Text/ch08.xhtml#ch08fig03)展示了这里讨论的依赖关系树。
- en: '![image](../Images/fig8-3.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig8-3.jpg)'
- en: '*Figure 8-3: The dependency tree of an utterance whose transitive verb and
    direct object don’t convey the user’s intent*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8-3：一个话语的依赖关系树，其中的及物动词和直接宾语并没有传达用户的意图*'
- en: To extract these words from the utterance, we’ll use a list of predefined words,
    and then search the user’s utterance for those words.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从话语中提取这些词汇，我们将使用一个预定义的词汇列表，然后在用户的输入中查找这些词汇。
- en: 'An experienced programmer might call into question the effectiveness of hardcoding
    such a list, because it can be quite long, especially if used in many different
    contexts. But if the list is intended for a specific context, say, ordering pizza,
    it can be surprisingly short, which makes this approach very efficient. The following
    code implements this approach:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一位经验丰富的程序员可能会质疑硬编码如此列表的有效性，因为这个列表可能相当长，特别是在许多不同的上下文中使用时。但如果这个列表是针对特定上下文的，比如说订购披萨，它可能非常简短，这使得这种方法非常高效。以下代码实现了这种方法：
- en: '#apply the pipeline to the sample sentence'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将管道应用于示例句子'
- en: doc = nlp(u'I want to place an order for a pizza.')
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: doc = nlp(u'我想要订购一个披萨。')
- en: '# extract the direct object and its transitive verb'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '# 提取直接宾语及其及物动词'
- en: dobj = ''
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: dobj = ''
- en: tverb = ''
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: tverb = ''
- en: 'for token in doc:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 'for token in doc:'
- en: '➊ if token.dep_ == ''dobj'':'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 如果 token.dep_ == 'dobj'：
- en: dobj = token
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: dobj = token
- en: tverb = token.head
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: tverb = token.head
- en: '# extract the verb for the intent''s definition'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '# 提取动词以定义意图'
- en: intentVerb = ''
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: intentVerb = ''
- en: verbList = ['want', 'like', 'need', 'order']
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: verbList = ['want', 'like', 'need', 'order']
- en: '➋ if tverb.text in verbList:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 如果 tverb.text 在 verbList 中：
- en: intentVerb = tverb
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: intentVerb = tverb
- en: '➌ else:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ 否则：
- en: 'if tverb.head.dep_ == ''ROOT'':'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 'if tverb.head.dep_ == ''ROOT'':'
- en: intentVerb = tverb.head
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: intentVerb = tverb.head
- en: '# extract the object for the intent''s definition'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '# 提取对象以定义意图'
- en: intentObj = ''
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: intentObj = ''
- en: objList = ['pizza', 'cola']
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: objList = ['披萨', '可乐']
- en: '➍ if dobj.text in objList:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ if dobj.text in objList:'
- en: intentObj = dobj
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: intentObj = dobj
- en: 'else:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: 'for child in dobj.children:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'for child in dobj.children:'
- en: 'if child.dep_ == ''prep'':'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 'if child.dep_ == ''prep'':'
- en: ➎ intentObj = list(child.children)[0]
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ intentObj = list(child.children)[0]
- en: break
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: '➏ elif child.dep_ == ''compound'':'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '➏ elif child.dep_ == ''compound'':'
- en: intentObj = child
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: intentObj = child
- en: break
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: '# print the intent expressed in the sample sentence'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打印样本句子中表达的意图'
- en: print(intentVerb.text + intentObj.text.capitalize())
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: print(intentVerb.text + intentObj.text.capitalize())
- en: 'As always, we start by finding and extracting the direct object and its transitive
    verb ➊. Once we’ve obtained them, we check whether they can be found in the corresponding
    lists of predefined words. Here, we use simplified lists, of course: the verbList
    list contains the verbs a customer might use to place an order, and the objList
    contains direct objects that are possible menu items. We start by checking the
    transitive verb ➋. If it’s not in the list of allowed verbs ➌, we check the main
    verb (ROOT) of the sentence, which is the head of the transitive verb. If the
    transitive verb is the main verb of the sentence, this implementation will work
    anyway, because the head of the main verb (ROOT) refers to itself.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，我们首先找到并提取直接宾语和它的及物动词 ➊。一旦我们得到它们，我们检查它们是否可以在预定义的词汇列表中找到。这里我们使用了简化的列表：verbList
    列表包含客户可能用来下订单的动词，而 objList 列表包含可能的菜单项的直接宾语。我们首先检查及物动词 ➋。如果它不在允许的动词列表 ➌ 中，我们检查句子的主要动词（ROOT），它是及物动词的核心。如果及物动词是句子的主要动词，这个实现方法仍然有效，因为主要动词的核心（ROOT）会指向它自己。
- en: Next, we move on to checking the direct object ➍. If it’s not in the list of
    allowed words, we check its syntactic children. We start by checking the preposition
    of the direct object. If it exists, we pick up the preposition’s child (it can
    have only one child) ➎, which is always the object of the preposition.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查直接宾语 ➍。如果它不在允许的词汇列表中，我们检查它的句法子节点。我们首先检查直接宾语的介词。如果存在介词，我们取介词的子节点（它只能有一个子节点）
    ➎，它总是介词的宾语。
- en: 'To make this approach applicable to a wider variety of cases, it’s not enough
    to just check for prepositions in the direct object’s children. For example, this
    logic wouldn’t work for the following utterance: “I want to place a pizza order,”
    where there is no preposition child branch. Instead, the direct object has a left
    child, “pizza,” which spaCy tags as a compound. Therefore, we check for compounds
    in the direct object’s children ➏.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这种方法适用于更多的情况，仅仅检查直接宾语子节点中的介词是不够的。例如，这个逻辑无法适用于以下句子：“我想下一个披萨订单”，其中没有介词子分支。相反，直接宾语有一个左子节点，“披萨”，spaCy将其标记为复合词。因此，我们检查直接宾语的子节点中是否有复合词
    ➏。
- en: 'Finally, we print the string representing the intent identifier. We should
    get the following string:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们打印表示意图标识符的字符串。我们应该得到以下字符串：
- en: wantPizza
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: wantPizza
- en: Notice that we use wantPizza as the intent identifier instead of placeOrder
    (which we would have gotten if we’d simply used the transitive verb/direct object
    pair). This approach allows us to reduce the number of intent identifiers used
    in the application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用wantPizza作为意图标识符，而不是placeOrder（如果我们直接使用及物动词/直接宾语组合，应该会得到placeOrder）。这种方法可以减少应用中使用的意图标识符的数量。
- en: '**Finding the Meanings of Words Using Synonyms and Semantic Similarity**'
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用同义词和语义相似性寻找单词的意义**'
- en: English, like many other natural languages, lets you express the same thoughts
    and intents in different ways, because it contains *synonyms*—words or phrases
    that mean nearly the same thing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 英语，像许多其他自然语言一样，让你可以用不同的方式表达相同的思想和意图，因为它包含了*同义词*——意义几乎相同的词或短语。
- en: As a developer of a chatbot application, you need to account for the fact that
    your users might use a fairly wide set of phrases for each intent the application
    is supposed to support. This means that your application must recognize synonymous
    phrases in user input. In fact, if you’re building your chatbot on a popular bot
    platform, such as Google’s Dialogflow, you’re required to submit a set of phrases
    for each possible intent. You then use these utterances behind the scenes to train
    the bot’s model.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个聊天机器人应用的开发者，你需要考虑到用户可能会为每个应用应该支持的意图使用相当广泛的短语。这意味着你的应用必须识别用户输入中的同义短语。事实上，如果你在一个流行的聊天机器人平台上构建你的聊天机器人，比如谷歌的Dialogflow，你就需要为每个可能的意图提交一组短语。然后，你会在后台使用这些语句来训练机器人的模型。
- en: There’s more than one approach to recognizing synonyms. One option is to use
    a set of predefined lists of synonyms. You check a word of interest against those
    lists, recognizing the word’s meaning based on the list in which it was found.
    Another option is to recognize synonyms based on semantic similarity, a task described
    in [Chapter 5](../Text/ch05.xhtml#ch05) in detail. I discuss both approaches in
    the following sections.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 识别同义词有多种方法。一种方法是使用一组预定义的同义词列表。您将感兴趣的单词与这些列表进行比对，基于找到该单词的列表来识别其含义。另一种方法是根据语义相似性识别同义词，这一任务在[第5章](../Text/ch05.xhtml#ch05)中有详细描述。我将在接下来的章节中讨论这两种方法。
- en: '***Recognizing Synonyms Using Predefined Lists***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用预定义列表识别同义词***'
- en: You already know that, in most cases, the transitive verb and its direct object
    best describe the intent of a phrase. A simple way to recognize whether two phrases
    express the same intent is to make sure the transitive verbs in both phrases are
    synonymous and their direct objects are synonyms as well.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经知道，在大多数情况下，及物动词及其直接宾语最好描述了短语的意图。识别两个短语是否表达相同意图的一个简单方法是，确保两个短语中的及物动词是同义词，并且它们的直接宾语也是同义词。
- en: 'For example, the following three sentences express the same intent, which you
    might define as orderPizza:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下三个句子表达了相同的意图，您可以将其定义为orderPizza：
- en: I want a dish. I'd like to order a pizza. Give me a pie.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要一道菜。我想点一个披萨。给我一份派。
- en: 'To process these utterances, you use the following steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理这些话语，您可以使用以下步骤：
- en: Perform dependency parsing to extract a transitive verb and its direct object
    from a sentence.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行依赖句法分析，从句子中提取及物动词及其直接宾语。
- en: Check with the predefined lists of synonyms to replace the transitive verb and
    the direct object with words that the application recognizes.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查预定义的同义词列表，将及物动词和直接宾语替换为应用程序能识别的单词。
- en: Compose the string that represents the intent.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组成表示意图的字符串。
- en: The diagram in [Figure 8-4](../Text/ch08.xhtml#ch08fig04) summarizes these steps,
    illustrating how this might work for, say, “I want a dish.”
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-4](../Text/ch08.xhtml#ch08fig04)中的图示总结了这些步骤，展示了如何处理比如“我想要一道菜”这样的句子。'
- en: '![image](../Images/fig8-4.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig8-4.jpg)'
- en: '*Figure 8-4: Processing intent recognition using lists of synonyms*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-4：使用同义词列表处理意图识别*'
- en: After dependency parsing (done implicitly when you apply the pipeline to an
    utterance), you extract the direct object and the transitive verb, and then check
    them against the corresponding list of synonyms. If you find a match, you replace
    the word with the one that tops the list, which the application should recognize.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行依赖句法分析后（当您将管道应用于话语时，依赖句法分析是隐式完成的），您提取直接宾语和及物动词，然后检查它们是否与相应的同义词列表匹配。如果找到匹配项，您将用列表中的首位单词替换该单词，该单词应是应用程序可以识别的。
- en: 'Let’s examine what a Python implementation of this scenario might look like:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个场景的Python实现可能是什么样的：
- en: '#apply the pipeline to the sample sentence'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将管道应用于样本句子'
- en: doc = nlp(u'I want a dish.')
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: doc = nlp(u'我想要一道菜。')
- en: '#extract the transitive verb and its direct object from the dependency tree'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '# 从依赖树中提取及物动词及其直接宾语'
- en: '➊ for token in doc:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ for token in doc:'
- en: 'if token.dep_ == ''dobj'':'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 'if token.dep_ == ''dobj'':'
- en: verb = token.head.text
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: verb = token.head.text
- en: dobj = token.text
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: dobj = token.text
- en: '#create a list of tuples for possible verb synonyms'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建一个可能的动词同义词元组列表'
- en: ➋ verbList = [('order','want','give','make'),('show','find')]
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ verbList = [('order','want','give','make'),('show','find')]
- en: '#find the tuple containing the transitive verb extracted from the sample'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '# 查找包含从样本中提取的及物动词的元组'
- en: ➌ verbSyns = [item for item in verbList if verb in item]
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ verbSyns = [item for item in verbList if verb in item]
- en: '#create a list of tuples for possible direct object synonyms'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建一个可能的直接宾语同义词元组列表'
- en: ➍ dobjList = [('pizza','pie','dish'),('cola','soda')]
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ dobjList = [('pizza','pie','dish'),('cola','soda')]
- en: '#find the tuple containing the direct object extracted from the sample'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '# 查找包含从样本中提取的直接宾语的元组'
- en: dobjSyns = [item for item in dobjList if dobj in item]
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: dobjSyns = [item for item in dobjList if dobj in item]
- en: '#replace the transitive verb and the direct object with synonyms supported
    by'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '# 用同义词替换及物动词和直接宾语'
- en: the application
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序
- en: '#and compose the string that represents the intent'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '# 并组成表示意图的字符串'
- en: ➎ intent = verbSyns[0][0] + dobjSyns[0][0].capitalize()
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ intent = verbSyns[0][0] + dobjSyns[0][0].capitalize()
- en: print(intent)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: print(intent)
- en: We start by creating a Doc object instance for the sample sentence. Then we
    iterate over the dependency tree available through the Doc object, extracting
    the transitive verb and its direct object ➊. Next, we create a list of tuples
    containing all allowable transitive verbs along with their synonyms ➋. The first
    element in each tuple contains a transitive verb that the application can recognize,
    and the other elements in the tuple are its synonyms.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve defined the allowable transitive verbs and their synonyms and
    put them all in a list of tuples, we can loop over the entire list to find a tuple
    that contains the transitive verb extracted from the sample sentence ➌.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we create a list of tuples for the recognized direct objects and
    their synonyms, and then find the tuple containing the direct object extracted
    from the sample ➍.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we concatenate the first elements of the chosen tuples to compose
    the intent name ➎. As a result, the print command should output the following
    string:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: orderPizza
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the set of synonyms to choose for a given verb depends largely
    on the type of application we’re creating. For example, in the context of a bot
    application that takes pizza orders, the verbs “make” and “give” can be considered
    synonymous. The reason is that users might interchangeably use the phrases “Make
    me a pizza” and “Give me a pizza” when ordering a pizza.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '***Try This***'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Use the sample code provided on [page 118](../Text/ch08.xhtml#page_118) as
    the basis for creating a new script. Make the script retain the original functionality
    but generate “unrecognized” as the intent name when the transitive verb, its direct
    object, or both can’t be found in the respective lists. To test your code, experiment
    with the sample sentence, changing it so the new functionality can be seen in
    action. For example, you might use the following sentence:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: I want an apple.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Test it with a sentence containing a verb that isn’t included in the list.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Also, you might try to handle the conjunction problem discussed in the previous
    sections using synonym lists.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '***Recognizing Implied Intents Using Semantic Similarity***'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Real-world implementations will likely include more complex logic than you’ve
    seen in the examples provided in this chapter so far. Even using a large set of
    predefined lists of synonyms won’t always work. The reason is that users express
    their intentions in many different ways, and they don’t always do so explicitly.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing an implied intent depends heavily on the context. For example, if
    your bot is designed for a specific type of task, say, ordering food, it should
    recognize phrases that imply a request, such as “I feel like eating a pie.”, as
    the intention to place a pizza order.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: One widely known technique to make the user express their intent more clearly
    is asking clarifying questions. To determine what question to ask, you can calculate
    the semantic similarity of the previous user utterance.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 8-5](../Text/ch08.xhtml#ch08fig05) illustrates how to implement this
    task.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-5](../Text/ch08.xhtml#ch08fig05)展示了如何实现这个任务。'
- en: '![image](../Images/fig8-5.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig8-5.jpg)'
- en: '*Figure 8-5: Recognizing an implied intent by calculating semantic similarity
    and asking clarifying questions*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-5：通过计算语义相似度和提问澄清问题来识别隐含意图*'
- en: You start by analyzing the dependency tree of the input utterance to extract
    the direct object and its transitive verb. If, for example, the direct object
    can’t be found in the predefined list of synonyms, as discussed in “[Recognizing
    Synonyms Using Predefined Lists](../Text/ch08.xhtml#lev110)” on [page 117](../Text/ch08.xhtml#page_117),
    you might try to determine how similar the direct object is to the words included
    in the list. Based on the results of calculating semantic similarity, you can
    then generate a clarifying user question.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你从分析输入语句的依赖树开始，提取直接宾语及其及物动词。例如，如果在预定义的同义词列表中找不到直接宾语，如在《[使用预定义列表识别同义词](../Text/ch08.xhtml#lev110)》一节中的[第117页](../Text/ch08.xhtml#page_117)所讨论的，你可以尝试确定直接宾语与列表中单词的相似度。根据计算的语义相似度结果，你可以生成一个澄清性用户问题。
- en: 'Let’s implement this technique in code, which I’ll break up into sections.
    As usual, we start with applying the text-processing pipeline to the sample sentence:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在代码中实现这个技术，我会将其分成几个部分。像往常一样，我们从对示例句子应用文本处理管道开始：
- en: doc = nlp(u'I feel like eating a pie.')
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: doc = nlp(u'I feel like eating a pie.')
- en: 'Then we extract the direct object token:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们提取直接宾语标记：
- en: 'for token in doc:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 doc 中的每个标记：
- en: 'if token.dep_ == ''dobj'':'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 'if token.dep_ == ''dobj'':'
- en: dobj = token
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: dobj = token
- en: 'We create a token for the word “food.” We’ll calculate the semantic similarity
    between this token and the direct object token:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为单词“food”创建一个标记。接下来，我们将计算这个标记与直接宾语标记之间的语义相似度：
- en: tokens = nlp(u'food')
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: tokens = nlp(u'food')
- en: 'If the level of similarity is greater than a predefined threshold, the application
    guesses that the user is most likely interested in placing an order. Then it asks
    a clarifying question to confirm this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相似度大于预定义的阈值，应用程序会猜测用户最有可能是想要下订单。然后，它会提出一个澄清问题来确认这一点：
- en: 'if dobj.similarity(tokens[0]) > 0.6:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 'if dobj.similarity(tokens[0]) > 0.6:'
- en: question = 'Would you like to look at our menu?'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: question = 'Would you like to look at our menu?'
- en: Recall from [Chapter 5](../Text/ch05.xhtml#ch05) that spaCy uses word vectors
    to calculate the semantic similarity of tokens. The closer two vectors are in
    the vector space, the higher the level of similarity is between them. In this
    example, we use 0.6 as the minimum degree of similarity required to assume the
    direct object resembles a food product.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下[第五章](../Text/ch05.xhtml#ch05)，spaCy 使用词向量来计算标记之间的语义相似度。两个词向量在向量空间中越接近，它们之间的相似度就越高。在这个例子中，我们使用
    0.6 作为假设直接宾语与食物产品相似的最小相似度。
- en: '***Try This***'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***尝试这个***'
- en: Of course, you won’t know in advance which phrases the user will use and how
    easy it will be to recognize the user’s intent. Neither will your application.
    That’s why real-world applications typically combine several approaches to recognize
    intent. Combine the approach based on recognizing synonyms with the approach based
    on handling implied intents, discussed in the previous sections, so you can handle
    more possible situations. Start by trying to extract the intent from an utterance
    using the synonyms-based approach. Then, if that fails, try the approach based
    on using semantic similarity. If both approaches fail, you might label the utterance
    as expressing an unrecognized intent.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不能提前知道用户会使用哪些短语以及多容易识别用户的意图。你的应用程序也无法预知。这就是为什么现实中的应用通常会结合多种方法来识别意图。将基于识别同义词的方法与上一节讨论的基于处理隐含意图的方法结合使用，这样你就可以应对更多可能的情况。首先，尝试通过同义词方法从语句中提取意图。如果失败了，再尝试使用基于语义相似度的方法。如果两种方法都失败了，你可以将语句标记为表达了无法识别的意图。
- en: '**Extracting Intent from a Sequence of Sentences**'
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**从一系列句子中提取意图**'
- en: 'In a discourse, the words reflecting a user’s intent might appear across different
    sentences, as in the following example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在对话中，反映用户意图的词语可能出现在不同的句子中，如以下示例所示：
- en: I have finished my pizza. I want another one.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经吃完了我的比萨，我想要另一个。
- en: Your bot should be ready to handle this scenario by extracting a user’s intent
    from an entire discourse. In this section, I’ll walk you through a technique for
    doing this.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你的机器人应该准备好通过提取整个对话中的用户意图来处理这种场景。在这一节中，我将向你展示一种实现这一目标的技术。
- en: '***Walking the Dependency Structures of a Discourse***'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***遍历话语的依存结构***'
- en: Let’s start by looking at the dependency parsing for the discourse, which will
    disclose the transitive verb/direct object pairs in each sentence, as shown in
    [Figure 8-6](../Text/ch08.xhtml#ch08fig06).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先来看看话语的依存句法分析，这将揭示每个句子中的及物动词/直接宾语对，如[图 8-6](../Text/ch08.xhtml#ch08fig06)所示。
- en: '![image](../Images/fig8-6.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig8-6.jpg)'
- en: '*Figure 8-6: A visual representation of the dependency parsing of the entire
    discourse*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-6：整个话语的依存句法分析的可视化展示*'
- en: The pale arrow in the diagram represents the dependency of interest. In other
    words, you want to replace the substitute “one” with the noun “pizza” it stands
    for. But the dependency parser in spaCy doesn’t show this link because it can’t
    connect tokens from different sentences. So the task of determining these dependencies
    is left to you.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的淡色箭头表示我们关注的依存关系。换句话说，您希望将替代词“one”替换为它所代表的名词“pizza”。但是，spaCy的依存句法分析器不会显示此链接，因为它无法连接来自不同句子的标记。因此，确定这些依存关系的任务留给了您。
- en: '***Replacing Proforms with Their Antecedents***'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***用前后文替换代词***'
- en: 'An *antecedent* is an expression (such as a word or clause) that gives its
    meaning to a *proform* (such as a pronoun or pro-verb). In this kind of intent
    extraction, you’ll have to determine the antecedents and replace the corresponding
    proforms with them. You can do so using the following steps:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*前后文*是一个表达（如词语或从句），它为*代词*（如代词或代动词）赋予其含义。在这种意图提取中，您需要确定前后文并用它们替换相应的代词。您可以通过以下步骤来实现：'
- en: Parse the dependencies of the entire discourse.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析整个话语的依存关系。
- en: Dissect the discourse into sentences.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将话语分解成句子。
- en: Find the antecedent for the pronoun that is the direct object of the transitive
    verb to be used in the intent definition.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到代词的前后文，代词是将要在意图定义中使用的及物动词的直接宾语。
- en: '[Figure 8-7](../Text/ch08.xhtml#ch08fig07) shows these steps diagrammatically.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-7](../Text/ch08.xhtml#ch08fig07)以图示方式展示了这些步骤。'
- en: '![image](../Images/fig8-7.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig8-7.jpg)'
- en: '*Figure 8-7: A graphical depiction of extracting intent from a sequence of
    sentences*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8-7：从一系列句子中提取意图的图形展示*'
- en: 'In spaCy, we can implement the first two steps with a couple lines of code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在spaCy中，我们可以用几行代码实现前两个步骤：
- en: doc = nlp(u'I have finished my pizza. I want another one.')
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: doc = nlp(u'I have finished my pizza. I want another one.')
- en: We convert the object that the doc.sents property returns into a list so we
    can refer to each sentence in the text by its index. (We could also directly iterate
    over a sequence of sentences contained in doc.sents using a for loop.)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将doc.sents属性返回的对象转换成列表，以便通过索引引用文本中的每个句子。（我们也可以直接使用for循环遍历doc.sents中的句子序列。）
- en: 'Next, we define two lists containing the allowable transitive verbs and allowable
    direct objects, respectively:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义两个列表，分别包含允许的及物动词和允许的直接宾语：
- en: verbList = [('order','want','give','make'),('show','find')]
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: verbList = [('order','want','give','make'),('show','find')]
- en: dobjList = [('pizza','pie','pizzaz'),('cola','soda')]
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: dobjList = [('pizza','pie','pizzaz'),('cola','soda')]
- en: These lists contain tuples of synonyms (refer to “[Recognizing Synonyms Using
    Predefined Lists](../Text/ch08.xhtml#lev110)” on [page 117](../Text/ch08.xhtml#page_117)
    for details).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这些列表包含同义词的元组（有关详细信息，请参阅[《使用预定义列表识别同义词》](../Text/ch08.xhtml#lev110)，在[第 117 页](../Text/ch08.xhtml#page_117)）。
- en: 'We also need to define a list for allowable substitutes. To do so, we must
    determine what proforms the direct object could be. Let’s first figure out what
    other phrases we could use in place of the last sentence, and then highlight the
    direct object in each phrase. Possible alternatives include the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要定义一个可接受的替代词列表。为此，我们必须确定直接宾语可能是什么代词。我们先来想想可以替换最后一个句子的其他短语，然后突出显示每个短语中的直接宾语。可能的替代选项包括：
- en: I want another one. I want it again. I want the same. I want more.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要另一个。我再要一次。我想要相同的。我想要更多。
- en: 'So, we can define the substitute list as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们可以按如下方式定义替代词列表：
- en: substitutes = ('one','it','same','more')
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: substitutes = ('one','it','same','more')
- en: Unlike the transitive verb and direct object lists, the substitute list has
    a simple structure, because we don’t need to group substitutes. The same substitute
    could refer to any of the direct objects.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 与及物动词和直接宾语列表不同，替代词列表具有简单的结构，因为我们不需要对替代词进行分组。同一个替代词可以指代任何直接宾语。
- en: 'In addition to the lists, we might want to define a dictionary to hold the
    intent definition parts as they’re being extracted:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'intent = {''verb'': '''', ''dobj'': ''''}'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we’re ready to start the intent recognition process:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'for sent in doc.sents:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'for token in sent:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'if token.dep_ == ''dobj'':'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: verbSyns = [item for item in verbList if token.head.text in item]
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: ➊ dobjSyns = [item for item in dobjList if token.text in item]
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: substitute =  [item for item in substitutes if token.text in item]
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'if ➋(dobjSyns != [] or substitute != []) and ➌verbSyns != []:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: intent['verb'] = verbSyns[0][0]
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '➍ if dobjSyns != []:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: intent['dobj'] = dobjSyns[0][0]
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The outer loop iterates over the sequence of sentences held in the Doc object.
    The inner loop, in turn, iterates over the tokens found in a sentence. We check
    each token to see whether it’s a direct object. If it is, we determine whether
    the direct object is part of either the direct object synonyms list or the substitutes
    list ➊. We also check whether the corresponding transitive verb is in the transitive
    verb synonyms list.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'We extract the direct object only if it’s in either the direct object synonyms
    list or the substitutes list ➋. For example, we wouldn’t be interested in extracting
    the transitive verb from the following phrase (unless we sell apples, of course):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: I want an apple.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Nor are we interested in a transitive verb if it’s not in the allowable list
    ➌, even if its direct object satisfies this condition, as in the following phrase:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: I like it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: That’s why, before picking up the transitive verb, we check not only whether
    the direct object is in either the direct object synonyms list or the substitutes
    list, but also whether the transitive verb is in the transitive verb synonyms
    list.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to pick up the direct object that defines the intent, we make sure
    we can find it in the direct object synonyms list ➍. Now we can compose the intent
    definition:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: intentStr = intent['verb'] + intent['dobj'].capitalize()
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, we might want to print it to make sure everything works as expected:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: print(intentStr)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'We should get the following output:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: orderPizza
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: This result indicates that the user intends to order a pizza.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '***Try This***'
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In some discourses, several sentences might separate an antecedent from its
    proform. For example, consider the following sequence of sentences:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: I have finished my pizza. It was delicious. I want another one.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Edit the script provided on [page 124](../Text/ch08.xhtml#page_124) so it can
    handle this or a similar sequence of sentences.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Intent recognition is a complex task that might require you to combine several
    approaches. In this chapter, you learned how to extract the most important parts
    of an utterance’s dependency tree for intent recognition. Then you analyzed them
    using predefined lists, semantic similarity, or both approaches. You also extracted
    the intent from a sequence of sentences by replacing proforms with their antecedents.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
