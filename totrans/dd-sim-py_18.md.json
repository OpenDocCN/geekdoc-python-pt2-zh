["```py\nprint(type(\"Hello\"))    # prints \"<class 'str'>\"\nprint(type(123))        # prints \"<class 'int'>\"\n\nclass Thing: pass\nprint(type(Thing))      # prints \"<class 'type'>\"\n\nsomething = Thing()\nprint(type(something))  # prints \"<class '__main__.Thing'>\"\n\nprint(type(type))       # prints \"<class 'type'>\"\n```", "```py\nFood = type('Food', (), {})\n```", "```py\nclass Food: pass\n```", "```py\ndef __init__(obj, toppings):\n    obj.toppings = toppings\n\nPizza = type( ❶ 'Pizza', ❷ (Food,), ❸ {'name':'pizza', '__init__':__init__})\n```", "```py\nclass Pizza(Food):\n    name = pizza\n\n    def __init__(self):\n        self.toppings = toppings\n```", "```py\nprint(Pizza.name)                     # 'name' is a class attribute\npizza = Pizza(['sausage', 'garlic'])  # instantiate like normal\nprint(pizza.toppings)                 # prints \"['sausage', 'garlic']\"\n```", "```py\nclass Gadget(type):\n\n    def __new__(self, name, bases, namespace):\n        print(f\"Creating a {name} gadget!\")\n        return super().__new__(self, name, bases, namespace)\n```", "```py\n @classmethod\n    def __prepare__(cls, name, bases):\n        return {'color': 'white'}\n```", "```py\nclass Thingamajig(metaclass=Gadget):\n    def __init__(self, widget):\n        self.widget = widget\n\n    def frob(self):\n        print(f\"Frobbing {self.widget}.\")\n```", "```py\nthing = Thingamajig(\"button\")  # also prints \"Creating Thingamajig gadget!\"\nthing.frob()                   # prints \"Frobbing button.\"\n\nprint(Thingamajig.color)       # prints \"white\"\nprint(thing.__class__)         # prints \"<class '__main__.Thingamajig'>\"\n```", "```py\ndef product_of_thirds(sequence):\n    if not ❶ hasattr(sequence, '__iter__'):\n        raise ValueError(\"Argument must be iterable.\")\n\n r = sequence[0]\n    for i in sequence[1::3]:\n        r *= i\n    return r\n\nprint(product_of_thirds(range(1, 50)))  # prints '262134882788466688000'\nprint(product_of_thirds(False))         # raises TypeError\n```", "```py\nclass Nonsense:\n    def __init__(self):\n        self.__iter__ = self\n```", "```py\ndef product_of_thirds(sequence):\n    if **(**\n        not hasattr(sequence, '__iter__')\n        **or not hasattr(sequence, '__getitem__'**\n    **)**:\n        raise TypeError(\"Argument must be iterable.\")\n **elif not hasattr(sequence[0], '__mul__'):**\n **raise TypeError(\"Sequence elements must support multiplication.\")**\n\n    r = sequence[0]\n    for i in sequence[1::3]:\n        r *= i\n    return r\n\n# `--snip--`\n\nprint(product_of_thirds(range(1, 50)))  # prints '262134882788466688000'\n**print(product_of_thirds(\"Foobarbaz\"))   # raises WRONG TypeError**\n```", "```py\nTypeError: can't multiply sequence by non-int of type 'str'\n```", "```py\nif not hasattr(some_obj, '__ge__'):\n    raise TypeError\n```", "```py\n**from collections.abc import Sequence**\n**from numbers import Complex**\n\ndef product_of_thirds(sequence):\n    **if not isinstance(sequence, Sequence):**\n        raise TypeError(\"Argument must be a sequence.\")\n    **if not isinstance(sequence[0], Complex):**\n        raise TypeError(\"Sequence elements must support multiplication.\")\n\n    r = sequence[0]\n    for i in sequence[1::3]:\n        r *= i\n    return r\n\nprint(product_of_thirds(range(1, 50)))  # prints '262134882788466688000'\nprint(product_of_thirds(\"Foobarbaz\"))   # raises TypeError\n```", "```py\nfrom collections.abc import Container, Sized, Iterable, Iterator\n```", "```py\nclass CafeQueue(**Container, Sized, Iterable**):\n\n    def __init__(self):\n        self._queue = []\n        self._orders = {}\n        self._togo = {}\n\n    def __iter__(self):\n        return CafeQueueIterator(self)\n\n    def __len__(self):\n        return len(self._queue)\n\n    def __contains__(self, customer):\n        return (customer in self._queue)\n\n    def add_customer(self, customer, *orders, to_go=True):\n        self._queue.append(customer)\n        self._orders[customer] = tuple(orders)\n        self._togo[customer] = to_go\n```", "```py`Because ABCs use metaclasses under the hood, they have the same problems with multiple inheritance that metaclasses do. I don’t have issues here because `type(Container)`, `type(Sized)`, and `type(Iterable)` are all instances of the `abc.ABCMeta` metaclass, but I wouldn’t be able to simultaneously inherit from an ABC or class that uses an altogether different metaclass.    I can achieve the same effect in a cleaner and simpler way by using the `Collection` ABC, which itself inherits from `Container`, `Sized`, and `Iterable`. This shortens the import line:    ```", "```py    Listing 14-14: *cafe_queue_abc.py:1b*    More importantly, it cleans up the inheritance list on the `CafeQueue` class:    ```", "```py    Listing 14-15: *cafe_queue_abc.py:2b*    This version is effectively identical to the previous one in [Listing 14-13](#listing14-13).    Next, I adjust my `CafeQueueIterator` class from Chapter 9 to use the `Iterator` ABC:    ```", "```py    Listing 14-16: *cafe_queue_**abc**.py:3*    Once again, I haven’t changed the implementation from the version in Chapter 9, except to inherit from `Iterator`. That ABC requires the `__next__()` method and inherits from `Iterable`, thereby also requiring `__iter__()`.    Here’s a revised usage of my `CafeQueue` class, to demonstrate ABCs at work:    ```", "```py    Listing 14-17: *cafe_queue_**abc**.py:4a*    In the `serve_customers()` function, I check that the `queue` argument is an instance of a class inheriting from the `Collection` ABC before proceeding ❶, as the function logic is relying on both `len()` and iteration.    Running this code produces what you’d expect:    ```", "```py    Although there are no functional changes to the example, ABCs contribute two advantages. First, anyone using my classes can check their functionality through the standard library ABCs. Second, and perhaps more important, it’s an insurance policy against one of these special methods the code relies on being accidentally removed from a class.    ### Implementing Custom ABCs    There often isn’t a preexisting abstract base class for everything you need, so you’ll need to write your own. You can make a class an ABC by having it inherit from `abc.ABC` or another ABC *and* giving it at least one method marked with the `@abstractmethod` decorator.    For my `CafeQueue` example, I’ll create a custom ABC to define a queue of customers. The rest of my code will expect a queue of customers to have certain methods and behaviors, so I’ll use the ABC to codify those expectations up front:    ```", "```py    Listing 14-18: *cafe_queue_abc.py:1c*    I make the `CustomerQueue` class inherit from `Collection` so its own derived classes must implement `__iter__()`, `__len__()`, and `__contains__()`, and so `CustomerQueue` indirectly inherits from `ABC` via `Collection`. Then, I add two additional abstract methods—`add_customer()` and the property `first()`—each marked with the `@abstractmethod` decorator, which I imported from `abc`. Any class that inherits from `CustomerQueue` must implement that property and those methods.    Before Python 3.3, if you wanted to require some types of methods in an abstract class, you had to use special decorators like `@abstractproperty`, `@abstractclassmethod`, and `@abstractstaticmethod`. You’ll still see code like that, but thankfully, that’s no longer necessary; instead, as long as `@abstractmethod` is the innermost decorator, you can use the usual method decorators, like `@property`.    While I can add abstract methods to require derived classes to have particular instance methods, class methods, static methods, and even properties, I *cannot* require derived classes to have particular instance attributes. ABCs are intended to specify *interfaces*, not data.    None of my abstract methods need implementations here, although I could write default implementations to be explicitly called via `super()`.    I can now update my `CafeQueue` class to inherit from this new `CustomerQueue` ABC:    ```", "```py    Listing 14-19: *cafe_queue_abc.py:2c*    I need to add the required property, `first()`, which, in my case, I use to peek at the name of the first person in line. If I don’t add this property, running the code would produce an error like this:    ```", "```py    Since I have implemented `first()`, I don’t need to worry about that error occurring.    I’ll also update the `serve_customers()` function to require a `CustomerQueue`, rather than a `Collection`. I can do this here because `CustomerQueue` inherits from `Collection`, so any class that inherits from `CustomerQueue` will also satisfy the interface of `Collection`.    ```", "```py    Listing 14-20: *cafe_queue_**abc**.py:4b*    In addition to testing whether `queue` is an instance of a class that inherits from `CustomerQueue`, I use the `queue.first` property toward the end, to test it out.    Running that code still produces the expected output:    ```", "```py    Aside from being able to check who is first in line, the functionality here hasn’t changed from prior versions of this example. As before, using ABCs here ensures that `CafeQueue` implements all the functionality the rest of my code depends on. If part of the expected interface is missing, the code will fail right away, instead of mid-execution.    ## Virtual Subclasses    As you start relying on custom abstract classes, you may reach a conundrum: you might require an argument to be an instance of a class derived from your custom ABC, and yet, you may want to somehow allow instances of certain preexisting classes to be used as well. For example, you cannot modify the built-in `list` class just to report that it satisfies some interface you specified in a custom ABC.    *Virtual subclassing* allows you to cause an ABC to report certain classes as being derived, even if they aren’t. This allows you to indicate particular built-in and third-party classes as fulfilling the interface outlined by one of your custom ABCs.    This works because calling `isinstance(Derived, Base)` or `issubclass(Derived, Base)` first checks for and calls the method `Base.__instancecheck__(Derived)` or `Base._subclasscheck__(Derived)`, respectively. Otherwise, `Derived.__isinstance__(Base)` or `Derived.__issubclass__(Base)` is called.    A critical limitation of virtual subclassing is that you’re bypassing the interface enforcement and instead reporting that *you* have verified that a particular class satisfies the interface. You can make any class a virtual subclass of ABC, but it’s entirely your own responsibility to ensure it has the expected interface.    ### Setting Up the Example    I’ll first create an example of a custom ABC that doesn’t use virtual subclassing, but where virtual subclassing can be helpful. Say that I’m creating a library of super-useful functions all related to palindromes, and I want to ensure I’m working with objects that implement certain methods: specifically, `__reversed__()`, `__iter__()`, and `__str__()`. I don’t want to require any further methods, since I’ll write a custom class for working with a sentence palindrome, which is more complex than a word palindrome. Unfortunately, there isn’t a built-in ABC that supports all those methods and *only* those.    There are different forms of palindromes, and I want to be able to interact with them all in the same way. This is why I create the custom `Palindromable` ABC:    ```", "```py    Listing 14-21: *palindrome_check.py:1*    The `Palindromable` ABC class doesn’t expand on any other ABC, so I only inherit from `abc.ABC`. With this ABC, I require the three methods I mentioned.    I now build a special `LetterPalindrome` class that interprets a string as a letter-based palindrome or sentence palindrome. This class inherits from the ABC `Palindromable`:    ```", "```py    Listing 14-22: *palindrome_check.py:2*    The initializer of `LetterPalindrome` accepts a string, strips out any non-letters, and converts it to all lowercase, thereby allowing it to check whether it’s a palindrome by reversing it and comparing it to the original.    Although I’m omitting it for reasons of space, I could also create a `WordPalindrome` class, which similarly accepts a string but reverses it word by word, instead of letter by letter.    I also implement all three required methods. Remember that, because the ABC mandates a `__str__()` method, I *must* implement it here. It doesn’t matter that one of the base classes—namely, `object`—has implemented `__str__()`; the `ABC` overwrote it as an abstract method, forcing me to reimplement it.    Below is my function for checking whether something is a palindrome. This function doesn’t care about the form of the palindrome; it just returns `True` as long as comparing the iterable to its reverse matches, item for item:    ```", "```py    Listing 14-23: *palindrome_check.py:3*    Before doing anything, I check that `sequence` is an instance of a class derived from `Palindromable`. If it is, I iteratively compare the items on sequence and its reversed form, indirectly relying on `sequence.__iter__()` and `sequence.__reversed__()`. In addition, I print a result onto the screen, indirectly using `sequence.__str__()`.    If I passed this function an instance of any class that lacked those three methods, this code wouldn’t make sense, and I would fail-fast with an exception. The particular strength of abstract base classes is that they aid in safely and effectively utilizing a form of duck typing. As long as a class can be used in a certain manner, it satisfies the ABC and nothing else matters.    I’ll try out my palindrome checker so far by instantiating a couple of `LetterPalindrome` instances and passing them to `check_palindrome()`:    ```", "```py    Listing 14-24: *palindrome_check.py:4*    Running that code outputs what I expect:    ```", "```py    ### Using Virtual Subclassing    Because my `check_palindrome()` function expects a class that inherits from my `Palindromable` ABC, that function would fail to work with some built-in classes, like lists, which could be palindromic in their own right. Instead, trying to pass a list to `check_palindrome()` fails with a `TypeError`:    ```", "```py    Listing 14-25: *palindrome_check.py:5a*    The code fails because `list` isn’t derived from `Palindromable`. I can’t reasonably go back and edit Python’s `list` class (nor should I try). Instead, I can make `list` a virtual subclass of `Palindromable`.    There are two ways of accomplishing this. The easiest is to register any class with an ABC by using the `register()` method, like this:    ```", "```py    Listing 14-26: *palindrome_check.py:5b*    That revised version works now because `list` is a virtual subclass of `Palindromable`. Instead of changing the `list` class to actually inherit from the `Palindromable` ABC, I have the ABC claim that `list` is among its derived classes.    However, this only applies to `list` so far. If I tried to pass a tuple to `check_palindrome()`, which should also work, it similarly fails. Sure, I could register `tuple` the same as I did with `list`, but it would be a pain to have to register every imaginable compatible class as a virtual subclass of `Palindromable`.    Anything could be considered a valid virtual subclass of `Palindromable`, as long as it implements the required methods and was *ordered* (so that the elements can be reversed reliably) and *finite*. Thinking it through, any class that is ordered would probably also be subscriptable via `__getitem__()`, and if it were finite, it would have a `__len__()` method as well. The built-in ABC `collections.abc.Sequence` mandates both of these methods, in addition to `__iter__()` and `__reversed__()`.    I can make `Sequence` a virtual subclass of `Palindromable`, thereby making any class that inherits from `Sequence` also a virtual subclass of `Palindromable`. I do that like this:    ```", "```py    Listing 14-27: *palindrome_check.py:5c*    Now I can use list, tuple, and any other class that inherits from `collections.abc.Sequence` with `check_palindrome()`.    If my rules for what qualifies as a `Palindromable` get any more complicated, as they often will in real life, I’ll need to either add more calls to `Palindromable.register()` or find another technique altogether. To deal with these potential complications, I can implement a special class method on the ABC called `__subclasshook__()`, which is called by `__subclasscheck__()` and augments the subclass checking behavior.    ```", "```py    Listing 14-28: *palindrome_check.py:1d*    The logic for the `__subclasshook__()` class method can be as simple or complex as I need it to be, and in this case, it’s extraordinarily simple. In any case, `__subclasshook__()` must return `True` if `C` should be considered a subclass of the `Palindromable` ABC, `False` if it definitely shouldn’t, and `NotImplemented` otherwise. This last part is important! When `__subclasshook__()` returns `NotImplemented`, it causes `__subclasscheck__()` to then check if `C` is an actual subclass, rather than a virtual one. If I returned `False` at the end of the method, it would cause my `LetterPalindrome` class to no longer be considered a subclass of `Palindromable`.    Unlike with most special methods, Python doesn’t require me to implement `__subclasscheck__()` directly, because that would mean I had to reimplement all the complicated subclass checking logic.    With this change made, I no longer need to register `list` and `Sequence` as virtual subclasses:    ```", "```py    Listing 14-29: *palindrome_check.py:5d*    As you can see, `check_palindrome()` now works with `list`, `tuple`, and `str`, in addition to `LetterPalindrome`.    Meanwhile, passing a `set` to `check_palindrome()` fails, which makes sense, because a set is unordered and cannot be reliably reversed.    Such is the beauty of duck typing with ABCs! I am able to write fail-fast code using a LBYL strategy, but I don’t have to specify every conceivable class that would work with that code. Instead, by creating a `Palindromable` abstract base class and adding `collections.abc.Sequence` as a virtual subclass, I’ve made my function work with practically any class that implements the needed interface.    ## Wrapping Up    Metaclasses are the mysterious “blueprints” from which classes are instantiated, in the same way classes are the blueprints for objects. Although seldom used by themselves, metaclasses allow you to override or extend how a class is created.    You can use abstract base classes, or ABCs, to mandate and then check for a specific interface on a class.    None of this means you shouldn’t use the type hints I mentioned back in Chapter 6. When it comes to enforcing a particular interface from a user perspective, annotations are going to be quite useful in clarifying how your code should be used. The purpose of ABCs and subclass checks is to make code that fails fast in situations where it cannot hope to succeed, especially when it may fail in subtle or unpredictable ways. Duck typing, inheritance, and type hints are complementary concepts. How they intersect in your code depends on you.```"]