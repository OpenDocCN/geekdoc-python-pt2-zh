- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Dynamic Data Structures
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 动态数据结构
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: This chapter introduces *dynamic data structures*, which alter their structure
    as the data changes. These structural adaptations may include growing the size
    of the data structure on demand, creating dynamic, mutable linkings between different
    values, and more. Dynamic data structures lie at the heart of almost every computer
    program in the world and are the foundation of some of the most exciting, interesting,
    and powerful algorithms in computer science.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了*动态数据结构*，它们会随着数据的变化而改变结构。这些结构的调整可能包括根据需要增长数据结构的大小，创建动态的、可变的链接以连接不同的值等。动态数据结构是几乎所有计算机程序的核心，并且是一些最令人兴奋、最有趣和最强大的计算机科学算法的基础。
- en: The basic data structures introduced in the previous chapters are like parking
    lots—they give us a place to store information, but don’t provide much in the
    way of adaptation. Sure, we can sort the values in an array (or cars in our parking
    lot) and use that structure to make binary search efficient. But we’re just changing
    the ordering of the data within the array. The data structure itself is neither
    changing nor responding to changes in the data. If we later change the data in
    a sorted array, say by modifying the value of an element, we need to re-sort the
    array. Worse yet, when we need to change the data structure itself—by growing
    or shrinking the array, for example—simple static data structures don’t provide
    any help.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章介绍的基本数据结构就像停车场——它们为我们提供了存储信息的地方，但不提供太多的适应性。当然，我们可以对数组中的值（或者说停车场中的车）进行排序，利用这种结构使得二分查找更加高效。但是，我们仅仅是改变了数组中数据的顺序。数据结构本身既没有发生变化，也没有对数据的变化做出响应。如果我们后来修改了排序数组中的数据，比如改变某个元素的值，我们就需要重新排序数组。更糟糕的是，当我们需要改变数据结构本身时——例如扩展或缩小数组——简单的静态数据结构并不会提供任何帮助。
- en: 'This chapter compares the static data structure introduced in Chapter 1, the
    array, with a simple dynamic data structure, the linked list, to demonstrate the
    advantages of the latter. In some respects, these two data structures are similar:
    they both allow programmers to store and access multiple values through a single
    reference, either the array or the head of the linked list. However, arrays have
    a structure fixed at time of creation, like rows of parking spaces. In contrast,
    linked lists can grow throughout the program’s memory. They behave more like a
    lengthening or shrinking line of people, allowing for additions and removals.
    Understanding these differences provides a foundation for understanding the more
    advanced data structures that we will visit in the rest of this book.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将第1章中介绍的静态数据结构——数组，与一种简单的动态数据结构——链表进行比较，以展示后者的优势。在某些方面，这两种数据结构是相似的：它们都允许程序员通过一个引用（无论是数组还是链表的头部）来存储和访问多个值。然而，数组在创建时的结构是固定的，就像停车位的行列。而链表则可以在程序的内存中不断增长。它们更像是一个不断伸长或缩短的排队队伍，允许随时进行增减。理解这些差异为理解本书后续将讨论的更高级数据结构提供了基础。
- en: The Limitations of Arrays
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组的局限性
- en: 'While arrays are excellent data structures for storing multiple values, they
    suffer from one important limitation: their size and layout in memory are fixed
    at the time of creation. If we want to store more values than can fit in our array,
    we need to create a new, larger array and copy over the data from the older array.
    This fixed-size memory is acceptable for when we have an unmoving upper bound
    on the number of items we need to store. If we have sufficient bins to fit our
    data, we can set individual entries all day long without worrying about the array’s
    static layout in memory. However, many applications require dynamic data structures
    that can grow and change with our program.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数组是存储多个值的优秀数据结构，但它们有一个重要的局限性：它们的大小和内存布局在创建时是固定的。如果我们想要存储比数组所能容纳的更多的值，就需要创建一个新的、更大的数组，并将旧数组中的数据复制过来。这种固定大小的内存对于当我们有一个不变的上限时是可以接受的。如果我们有足够的空间来存储数据，我们可以随时设置各个条目，而不必担心数组在内存中的静态布局。然而，许多应用程序需要动态数据结构，这些结构能够随着程序的变化而增长和变化。
- en: To meet this need for dynamic data structures, many modern programming languages
    offer dynamic “arrays” that grow and shrink as you add elements. However, these
    are actually wrappers around static arrays or other data structures that hide
    the complexities and costs associated with their dynamic nature. While this is
    convenient for the programmer, it can lead to hidden inefficiencies. When we add
    elements past the end of the array, the program still needs to increase the memory
    used. It just does so behind the scenes. To understand why dynamic data structures
    are so important, we need to discuss the limitations of static data structures.
    In this book, we’ll use the term *array* to refer to a simple static array.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足对动态数据结构的需求，许多现代编程语言提供了动态“数组”，它们会随着你添加元素而增长或缩小。然而，这些实际上是围绕静态数组或其他数据结构的包装器，隐藏了与它们动态特性相关的复杂性和成本。虽然这对程序员来说很方便，但它可能导致隐藏的低效。当我们向数组的末尾添加元素时，程序仍然需要增加所使用的内存。它只是在幕后完成这个操作。为了理解动态数据结构为何如此重要，我们需要讨论静态数据结构的限制。在本书中，我们将使用*数组*一词来指代简单的静态数组。
- en: To illustrate the array’s restrictions, imagine that you spend an entire week
    mastering the latest retro video game phenomenon, Space Frogger 2000\. You smile
    with glee every time the main screen displays your five top scores. These monumental
    achievements represent hours of sweat, tears, shouting, and more tears. However,
    the very next day, your (soon to be former) best friend visits and goes on to
    beat your highest score five times in a row. Once you kick the traitorous ex-friend
    out of the house, you return to your game and gaze at the new top scores, shown
    in [Figure 3-1](#figure3-1), and cry out, “Why couldn’t the game store more scores?
    Would it really be so hard to keep a top ten list, or at least add one more to
    the very end?”
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明数组的限制，假设你花了一整周时间掌握最新的复古视频游戏现象《太空青蛙 2000》。每次主屏幕显示你的五个最高分时，你都会开心地笑出声。这些辉煌的成就代表了无数小时的汗水、眼泪、喊叫和更多的眼泪。然而，第二天，你的（很快就会成为前）最好的朋友来访，并连续五次击败了你的最高分。当你把背叛的前朋友赶出家门后，你回到游戏中，凝视着新显示的最高分，如[图
    3-1](#figure3-1)所示，忍不住喊道：“为什么游戏不能保存更多的分数？真的很难保留一个前十名榜单，或者至少在最后加一个分数吗？”
- en: '![Figure showing an index with five slots cataloging best scores in a video
    game. The highest score, 1025, is index zero, and the lowest score, 949, is index
    4.](image_fi/502604c03/f03001.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图示，显示一个索引，包含五个插槽，用于记录视频游戏的最佳分数。最高分 1025 位于索引 0，最低分 949 位于索引 4。](image_fi/502604c03/f03001.png)'
- en: 'Figure 3-1: A five-element array holding high scores for a video game. None,
    alas, are yours.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-1：一个包含视频游戏高分的五元素数组。遗憾的是，里面没有你的分数。
- en: This is one of the fundamental limitations of any fixed-size data structure
    and its fixed layout in memory—it can’t grow with the data. As we see below, this
    restriction makes some common operations expensive. More practically, imagine
    the limitations of a word processor with space for only a fixed number of characters,
    a spreadsheet with a fixed number of rows, a photo storage program that can store
    a limited number of pictures, or a coffee journal limited to only a thousand entries.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是任何固定大小数据结构及其在内存中固定布局的基本限制之一——它无法随着数据的增加而增长。正如我们下面所看到的，这种限制使得某些常见操作变得昂贵。更实际的说，想象一下一个只能容纳固定字符数的文字处理器，一个只有固定行数的电子表格，一个只能存储有限数量照片的照片存储程序，或一个最多只能记录一千条记录的咖啡日记。
- en: Since the size of an array is fixed at the time of creation, if we want to extend
    the array to store more data, we must create a new, larger block of memory. Consider
    the simplest case of adding a single element to the end of an array. Because an
    array is a single, fixed-size block of memory, we can’t just shove another value
    into the end. There might be another variable already occupying that space in
    the memory. Rather than risk overwriting that variable’s value, we have to allocate
    a new (bigger) block of memory, copy all the values of the original array into
    the new block, and write the new value at the end. That’s a lot of overhead for
    a single addition, as illustrated in [Figure 3-2](#figure3-2).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组的大小在创建时是固定的，如果我们想要扩展数组以存储更多的数据，就必须创建一个新的、更大的内存块。考虑最简单的情况，向数组的末尾添加一个元素。由于数组是一个单一的固定大小的内存块，我们不能只是将另一个值插入到末尾。内存中可能已经有另一个变量占用了这个空间。为了避免覆盖该变量的值，我们必须分配一个新的（更大的）内存块，将原数组中的所有值复制到新块中，并将新值写入末尾。这对于一个简单的增加来说是大量的开销，正如[图
    3-2](#figure3-2)所示。
- en: '![Figure showing an array of six data elements that is copied, and then a seventh
    data element is added to the end of the copy.](image_fi/502604c03/f03002.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图示显示了一个包含六个数据元素的数组被复制，接着在复制的数组末尾添加了第七个数据元素。](image_fi/502604c03/f03002.png)'
- en: 'Figure 3-2: Adding an element to the end of a full array.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-2：向满载的数组末尾添加元素。
- en: Think of an array as one of those heated hotel buffet counters with a fixed
    number of slots. It’s easy to pop out the empty tray of scrambled eggs and add
    a new one in its place. But you can’t just stick a new tray onto the end. There’s
    no room for it. If the chef decides to add pancakes to the menu, something else
    has to go.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将数组比作一个有固定数量插槽的加热酒店自助餐台。很容易把空的炒蛋托盘拿掉，换上新的托盘。但你不能简单地把一个新托盘加到末尾。没有空间。如果厨师决定把煎饼加入菜单，其他的东西必须被拿走。
- en: If you know you’ll need to insert a lot of new values, you might spread the
    cost out over multiple updates, *amortizing* the cost. You might adopt a strategy
    like *array doubling*, in which the size of an array doubles whenever it is expanded.
    For example, if we try to add a 129th element to our array of size 128, we first
    allocate a new array of size 256 and copy over the original 128 elements. This
    allows us to continue growing the array for a while before we next need to worry
    about allocating new space. However, the cost is potentially wasted space. If
    we only need 129 elements total, we have overallocated by 127.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道你需要插入大量的新值，你可能会将成本分摊到多个更新中，*摊销*成本。你可能会采用像*数组扩容*这样的策略，即每当数组扩展时，其大小会翻倍。例如，如果我们尝试向一个大小为128的数组添加第129个元素，我们首先分配一个大小为256的新数组，并将原来的128个元素复制过来。这让我们可以在不担心再次分配新空间之前继续扩展数组一段时间。然而，这种方法的代价可能是浪费空间。如果我们只需要129个元素，总共多分配了127个空间。
- en: Array doubling provides a reasonable balance between expensive array copies
    and wasted memory. As the array grows, the doublings become less and less frequent.
    At the same time, by doubling the array when it is full, we are guaranteed to
    waste less than half the space. However, even with this balanced approach, we
    can clearly see the cost of using a fixed-size array in terms of both copying
    cost and memory usage.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数组扩容提供了在高昂的数组复制成本和浪费内存之间的合理平衡。随着数组的增长，扩容的频率会越来越低。同时，通过在数组满时进行扩容，我们可以确保浪费的空间不会超过一半。然而，即使采用这种平衡方法，我们仍然能清晰地看到使用固定大小数组在复制成本和内存使用方面的代价。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code for array doubling starts by allocating a new array twice the size
    of the current array. A single `WHILE` loop iterates over the elements in the
    current array, copying their values into the new array. The new array is returned.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 数组扩容的代码首先分配一个新数组，新数组的大小是当前数组的两倍。一个单一的`WHILE`循环遍历当前数组中的元素，将它们的值复制到新数组中。新数组随后被返回。
- en: 'Imagine applying this strategy to shelf space. We establish a bookstore, Data
    Structures and More*,* in a location and install a humble five shelves. Opening
    day sees surprising demand and requests for more variety: we need to expand our
    inventory. Panicked, we move to a new location with 10 shelves and migrate the
    books. The demand has temporarily been met. Since the lack of a comprehensive
    data structure store is a clear gap in the retail books market, our store is a
    runaway success, and demand continues to grow and grow. We might upgrade the store
    a few more times to locations with 20, 40, then 80 shelves. Each time we pay a
    cost to secure a new location and migrate the books.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 想象将这种策略应用到书架空间上。我们在某个地点开了一家名为“数据结构与更多”的书店，安装了五个简单的书架。开业当天需求超出预期，大家要求更多的品种：我们需要扩展库存。慌乱之中，我们搬到了一个有10个书架的新地点，并迁移了书籍。需求暂时得到满足。由于零售市场上缺乏全面的数据结构书店，这家店大获成功，需求继续增长。我们可能会将店面升级几次，搬到拥有20、40，再到80个书架的地点。每次我们都需要支付一定成本来确保新的地点并迁移书籍。
- en: The fixed location of the array’s values in memory provides another limitation.
    We cannot easily insert additional items in the middle of an array. Even if there
    are enough empty spaces at the end of our original array to accommodate a new
    element, and therefore we don’t need to move the whole array to a new memory block,
    we still need to shift each existing element over one by one to make a space for
    the new value in the middle. Unlike a shelf of books, we can’t just shove all
    the elements over at once with a single good push. If we had 10,000 elements and
    wanted to add something in the second position, we’d need to move 9,999 elements
    over. That’s a lot of effort to insert a single element.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数组值在内存中的固定位置带来了另一个限制。我们不能轻松地在数组中间插入新的元素。即使在原始数组末尾有足够的空闲空间来容纳新元素，因此我们不需要将整个数组移动到新的内存块中，我们仍然需要逐个移动每个现有元素，为新值腾出空间。与书架上的书籍不同，我们不能通过一次用力就将所有元素推到一边。如果我们有
    10,000 个元素，并且想要在第二个位置添加一个元素，我们需要移动 9,999 个元素。为了插入一个元素，这需要付出很大的努力。
- en: The problems compound when we try to insert new values into the middle of an
    array that is already full. Not only do we have to allocate a new block and copy
    the old values, but we need to shift the values after the new value down one position
    to clear a space for our new value. For example, suppose we wanted to insert the
    value 23 as the fourth element of an existing array of six elements, as illustrated
    in [Figure 3-3](#figure3-3).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们试图将新值插入到已经满的数组的中间时，问题变得更加复杂。不仅需要分配一个新的内存块并复制旧值，还需要将新值之后的元素向下移动一个位置，为新值腾出空间。例如，假设我们想将值
    23 插入到一个已有六个元素的数组的第四个位置，如[图 3-3](#figure3-3)所示。
- en: '![One array with six boxes is split in two. The values in each half are copied
    and moved into a new seven‐box array with a new value in the middle.](image_fi/502604c03/f03003.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含六个盒子的数组被分成两部分。每一半的值被复制并移动到一个新的七盒子数组中，中间插入一个新值。](image_fi/502604c03/f03003.png)'
- en: 'Figure 3-3: Adding an element to the middle of a full array'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-3：在满数组的中间添加一个元素
- en: 'To address the shortfalls of arrays, we need to move to more flexible data
    structures that can grow as new data is added: dynamic data structures. Before
    we jump into the details, let’s introduce pointers, the variable type that’s key
    to reconfiguring and growing data structures.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了弥补数组的不足，我们需要转向更灵活的数据结构，这些结构能够随着新数据的加入而增长：动态数据结构。在我们深入细节之前，让我们先介绍指针这一变量类型，它是重新配置和增长数据结构的关键。
- en: Pointers and References
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针与引用
- en: 'One variable type stands above its peers in terms of both its sheer power and
    its ability to confuse new programmers: *pointers*. A pointer is a variable that
    stores only the addresses in the computer’s memory. The pointer therefore points
    to a second location in memory where the actual data is stored, as shown in [Figure
    3-4](#figure3-4).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种变量类型在其强大的功能和使新程序员困惑的能力上，超越了其他类型：*指针*。指针是一个只存储计算机内存中地址的变量。因此，指针指向内存中的第二个位置，实际数据存储在该位置，如[图
    3-4](#figure3-4)所示。
- en: '![Eight memory addresses, each with corresponding boxes. The fourth box down
    has address 2103 and value 109, and it is labeled “address where the pointer points.”
    the seventh box down has address 2106 and value 2103, and it is labeled “pointer.”](image_fi/502604c03/f03004.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![八个内存地址，每个地址对应一个盒子。第四个盒子地址是 2103，值是 109，标记为“指针指向的地址。”第七个盒子地址是 2106，值是 2103，标记为“指针。”](image_fi/502604c03/f03004.png)'
- en: 'Figure 3-4: A pointer indicating an address in the computer’s memory'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-4：指针表示计算机内存中的一个地址
- en: The astute reader may ask, “What is the purpose of a variable that simply points
    to another location in memory? I thought the variable’s name already served this
    function. Why not store your data in the variable like a normal person? Why do
    you always have to make things so complicated?” Don’t listen to the skeptics.
    Pointers are the essential ingredient in dynamic data structures, as we’ll see
    shortly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 精明的读者可能会问：“一个变量只是指向内存中另一个位置，它有什么意义？我以为变量的名字已经起到了这个作用。为什么不把数据像正常人一样直接存储在变量里？为什么你们总是要把事情搞得这么复杂？”不要听那些怀疑者的声音。指针是动态数据结构的核心组成部分，稍后我们会看到这一点。
- en: 'Suppose we are working on a major architectural project at the office and have
    assembled a folder of example drawings to share with our team. Soon the project
    folder contains numerous floorplans, cost estimates, and artistic renderings.
    Rather than make a copy of the hefty file and leave it out in the open, we leave
    a note telling our collaborators to find the file in the third-floor records room,
    filing cabinet #3, the second drawer down, fifth folder. This note plays the role
    of a pointer. It doesn’t detail all the information that’s in the file, but rather
    allows our colleagues to find and retrieve the information. More importantly,
    we can share this single “address” with each of our coworkers without making a
    full copy of the file for them. They can each use this information to look up
    and modify the folder when needed. We could even leave an individual sticky note
    on each team member’s desk, providing 10 variables pointing to the same information.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '假设我们正在办公室进行一个大型建筑项目，并且已经整理了一份示例图纸文件夹与团队分享。很快，项目文件夹里便包含了多个楼层平面图、成本估算和艺术效果图。与其复制这份沉重的文件并公开放置，我们留下了一张纸条，告诉合作者们去三楼的档案室找文件，档案柜
    #3，第二个抽屉，第五个文件夹。这张纸条就扮演了指针的角色。它并没有详细列出文件里的所有信息，而是允许我们的同事们找到并提取其中的信息。更重要的是，我们可以与每个同事共享这一个“地址”，而不必为他们复制整个文件。他们每个人都可以利用这个信息，在需要时查找并修改文件夹。我们甚至可以在每个团队成员的桌上留下单独的便签，提供
    10 个指向相同信息的变量。'
- en: In addition to storing the location of a block of memory, pointers can take
    on a null value (denoted as None, Nil, or 0 in some programming languages). The
    null value simply denotes that the pointer isn’t currently pointing to a valid
    memory location. In other words, it indicates that the pointer doesn’t actually
    point to anything yet.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了存储内存块的位置外，指针还可以拥有一个空值（在某些编程语言中用 None、Nil 或 0 表示）。空值仅表示指针当前没有指向一个有效的内存位置。换句话说，它表示指针实际上还没有指向任何东西。
- en: 'Different programming languages provide different mechanisms to accomplish
    the task of pointers, and not all of them provide the raw memory address to the
    programmer. Lower-level languages like C and C++ give you raw pointers and allow
    you to directly access the memory location they store. Other programming languages,
    such as Python, use references, which use syntax like that of a normal variable
    while still allowing you to reference another variable. These different variations
    come with different behaviors and usages (dereferencing, pointer math, the form
    of null values, and so forth). For the sake of simplicity, throughout this book
    we will use the term *pointer* to cover all variables implemented by pointers,
    references, or indices into preallocated blocks of memory. We won’t worry about
    the complicated syntax needed to access the blocks of memory (which has caused
    more than a few programming enthusiasts to break down in tears). We will also
    use the final data’s type (instead of the more generic type pointer) when defining
    a pointer variable in pseudocode. The key concept for our purposes is that pointers
    provide a mechanism for linking to a block of memory as featured in our first
    dynamic data structure: the linked list.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的编程语言提供了不同的机制来实现指针的功能，并且并非所有语言都会向程序员提供原始的内存地址。像 C 和 C++ 这样的低级语言提供原始指针，允许你直接访问它们存储的内存位置。其他编程语言，如
    Python，则使用引用，这种引用的语法与普通变量相似，但仍然允许你引用另一个变量。这些不同的实现方式有不同的行为和用法（如解除引用、指针运算、空值的形式等）。为了简化起见，在本书中我们将使用*指针*一词来涵盖所有通过指针、引用或索引访问预分配内存块实现的变量。我们不必担心访问内存块所需的复杂语法（这曾让不少编程爱好者泪如雨下）。我们在定义伪代码中的指针变量时，也将使用最终数据类型（而非更通用的类型指针）。对于我们来说，关键概念是指针提供了一种机制，用于链接到一块内存，这正是我们第一个动态数据结构——链表——的核心。
- en: Linked Lists
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链表
- en: '*Linked lists* are the simplest example of a dynamic data structure and are
    a close cousin to arrays. Like arrays, they are a data structure for storing multiple
    values. Unlike arrays, linked lists are composed of a chain of nodes linked together
    by pointers. A basic *node* in a linked list is a composite data structure containing
    two parts: a value (of any type) and a pointer to the next node in the list:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*链表* 是最简单的动态数据结构示例，也是数组的近亲。像数组一样，它们是一种用于存储多个值的数据结构。不同于数组，链表由一系列由指针链接在一起的节点组成。链表中的基本*节点*是一个复合数据结构，包含两个部分：一个值（可以是任何类型）和指向列表中下一个节点的指针：'
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can picture a linked list as a series of linked bins, as in [Figure 3-5](#figure3-5).
    Each bin stores a single value and contains a pointer to the next bin in the series.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将链表看作是一系列相互连接的容器，如[图 3-5](#figure3-5)所示。每个容器存储一个值，并包含指向下一个容器的指针。
- en: '![Six nodes, each containing a numeric value. Right‐pointing arrows connect
    the nodes. The last arrow at the far right points to a slash indicating the end
    of the list.](image_fi/502604c03/f03005.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![六个节点，每个节点包含一个数值。指向右的箭头连接节点。最后一个箭头指向右侧的斜线，表示链表的结束。](image_fi/502604c03/f03005.png)'
- en: 'Figure 3-5: A linked list shown as a series of nodes linked by pointers'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-5：一个由指针连接的节点序列所表示的链表
- en: The slash at the end of the list represents a null value and indicates the end
    of the list. Effectively we are saying that the last node’s `next` pointer does
    not point to a valid node.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 链表末尾的斜线表示空值，指示链表的结束。实际上，我们是在说最后一个节点的`next`指针不指向一个有效的节点。
- en: A linked list is like a long line of people waiting at our favorite coffee shop.
    People rarely know their absolute position in the line—“I’m on the fifty-third
    floor tile back from the counter.” They pay attention to their relative order,
    namely the single person before them, which we store in a pointer. Even if the
    line winds throughout the store (and its parking lot) in complex loops, we can
    still reconstruct the order by asking each person who is immediately in front
    of them. We can traverse the line toward the counter by asking each person who
    is before them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 链表就像我们最喜欢的咖啡店前排队的长队伍。人们很少知道自己在队伍中的绝对位置——“我在离柜台五十三块地砖的位置。”他们关注的是自己相对的位置，也就是排在自己前面的人，这一点我们通过指针来存储。即使队伍在店内（甚至停车场）绕来绕去，形成复杂的环状结构，我们仍然可以通过询问每个人前面是谁来重建队伍的顺序。我们可以通过询问每个人前面是谁来向柜台移动。
- en: Because they include pointers as well as values, linked lists require more memory
    than arrays to store the same items. If we have an array of size *K*, storing
    values of *N* bytes each, we only need *K* × *N* bytes. In contrast, if each pointer
    requires another *M* bytes, our data structure now has a cost of *K* × (*M* +
    *N*) bytes. Unless the size of the pointers is much smaller than the size of our
    values, the overhead is significant. However, the increased memory usage is often
    worth it for the increased flexibility the pointers provide.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因为链表包含指针和数值，它们比数组在存储相同数据时需要更多的内存。如果我们有一个大小为*K*的数组，每个元素的大小为*N*字节，那么我们只需要*K* ×
    *N*字节。相比之下，如果每个指针需要额外的*M*字节，那么我们的数据结构的内存开销将是*K* × (*M* + *N*)字节。除非指针的大小远小于数据值的大小，否则这种开销是显著的。然而，增加的内存使用通常是值得的，因为指针提供的灵活性。
- en: While textbooks often represent linked lists as neat, orderly structures (as
    shown in [Figure 3-5](#figure3-5) or implied in our line-of-humans example), our
    list can actually be scattered throughout the program’s memory. As illustrated
    in [Figure 3-6](#figure3-6), the list’s nodes are linked only via their pointers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然教科书通常将链表表示为整齐有序的结构（如[图 3-5](#figure3-5)所示，或在我们的人队列示例中所暗示的那样），但实际上我们的链表可能分散在程序的内存中。正如[图
    3-6](#figure3-6)所示，链表的节点仅通过它们的指针连接。
- en: This is the real power of pointers and dynamic data structures. We aren’t constrained
    to keep the entire list in a single contiguous block of memory. We’re free to
    grab space for new nodes wherever space happens to exist.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是指针和动态数据结构的真正威力。我们不必将整个链表保存在一个连续的内存块中。我们可以在任何有空闲空间的地方为新的节点分配空间。
- en: '![The same six nodes and slash indicating the end of the list as in Figure
    3‐5, but in a different order and with various empty bins between nodes. Arrows
    indicate the order in which the nodes link.](image_fi/502604c03/f03006.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![与图 3-5 中相同的六个节点和表示链表结束的斜线，不过顺序不同，并且节点之间有多个空的容器。箭头表示节点连接的顺序。](image_fi/502604c03/f03006.png)'
- en: 'Figure 3-6: A linked list in the computer’s memory. Nodes are not necessarily
    adjacent to each other.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-6：计算机内存中的链表。节点不一定彼此相邻。
- en: 'Programs typically store linked lists by keeping a single pointer to the front,
    or *head*, of the linked list. The program can then access any element in the
    list by starting at the head and iterating through the nodes via the pointers:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 程序通常通过保留指向链表前端或*头部*的指针来存储链表。然后，程序可以从头部开始，通过指针遍历节点，从而访问链表中的任何元素：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code starts at the head of the list ❶. We maintain a second variable `count`
    to track the index of the current node. The `WHILE` loop then iterates through
    each node in the list until it has found the correct number, `count == element_number`,
    or run off the end of the list, `current == null` ❷. In either case, the code
    can return `current`. If the loop terminates due to running off the edge of the
    list, then the index is not in the list and the code returns `null`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 代码从列表的头部开始❶。我们维护一个第二个变量`count`来跟踪当前节点的索引。然后，`WHILE`循环遍历列表中的每个节点，直到找到正确的数字，`count
    == element_number`，或者遍历到列表末尾，`current == null`❷。无论哪种情况，代码都会返回`current`。如果循环由于遍历到列表边缘而终止，那么索引不在列表中，代码会返回`null`。
- en: For example, if we wanted to access the fourth element of a linked list, the
    program would access first the head, then the second, third, and fourth elements
    in order to find the correct memory location. [Figure 3-7](#figure3-7) shows this
    process, where the node with value 3 is the head of the list.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想访问链表的第四个元素，程序将依次访问头节点、第二、第三和第四个元素，以找到正确的内存位置。[图 3-7](#figure3-7) 展示了这个过程，其中值为3的节点是列表的头部。
- en: '![A linked list of six nodes, with the program accessing first the head of
    the list, then the node directly next to it, to which its pointer points, and
    so on.](image_fi/502604c03/f03007.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![六个节点的链表，程序首先访问列表头节点，然后访问直接连接到它的下一个节点，以此类推。](image_fi/502604c03/f03007.png)'
- en: 'Figure 3-7: Traversing a linked list requires moving from one node to the next
    along the chain of pointers.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-7：遍历链表需要沿着指针链从一个节点移动到下一个节点。
- en: 'It’s worth noting, however, that there’s a tradeoff: linked lists have a higher
    computing overhead than arrays. When accessing an element in an array, we just
    compute a single offset and look up the correct address of memory. The array access
    only takes one mathematical computation and one memory lookup regardless of which
    index we choose. Linked lists require us to iterate from the beginning of the
    list until we get to the element of interest. For longer lists, the lack of direct
    access can add significant overhead.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得注意的是，这存在一个权衡：链表比数组有更高的计算开销。当访问数组中的元素时，我们只需计算一个偏移量并查找正确的内存地址。无论选择哪个索引，数组访问只需要一次数学计算和一次内存查找。链表则需要我们从列表的开头开始遍历，直到找到感兴趣的元素。对于较长的列表，缺乏直接访问可能会增加显著的开销。
- en: At first glance, this restricted access pattern is a strike against the linked
    list. We’ve dramatically increased the cost of looking up an arbitrary element!
    Consider what this means for binary search. A single lookup requires iterating
    over many of the elements, removing the advantage of a sorted list.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，这种受限的访问模式似乎是链表的一大缺点。我们大幅增加了查找任意元素的成本！想一想这对二分查找意味着什么。一次查找需要遍历多个元素，失去了排序列表的优势。
- en: Yet despite these costs, linked lists can become real assets in practical programs.
    Data structures almost always involve tradeoffs among complexity, efficiency,
    and usage patterns. The very behaviors that disqualify a data structure for one
    use might make it the perfect choice to support other algorithms. Understanding
    these tradeoffs is the key to effectively combining algorithms and data structures.
    In the case of linked lists, the tradeoff for increased overhead in accessing
    elements is a significant increase in the flexibility of the overall data structure,
    as we will see in the next section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管存在这些成本，链表在实际程序中仍然可以成为宝贵的资源。数据结构几乎总是涉及复杂性、效率和使用模式之间的权衡。使得某个数据结构不适合某种用途的行为，可能使它成为支持其他算法的完美选择。理解这些权衡是有效结合算法和数据结构的关键。以链表为例，访问元素的开销增加的权衡是整体数据结构灵活性的显著提升，正如我们将在下一节中看到的那样。
- en: Operations on Linked Lists
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链表的操作
- en: While some lament the chaotic sprawl of the linked list compared to the aesthetic
    beauty of the compact array, it is exactly this ability to link across different
    blocks of memory that makes the data structure so powerful, allowing us to *dynamically*
    rearrange the data structure. Let’s compare inserting a new value to an array
    with adding a value to a linked list.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有些人抱怨链表的杂乱无章，相较于紧凑数组的美学，但正是这种跨不同内存块链接的能力使得数据结构如此强大，允许我们*动态*地重新排列数据结构。让我们将向数组中插入新值与向链表中添加值进行比较。
- en: Inserting into a Linked List
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插入到链表中
- en: As we’ve seen, inserting a new element into an array may require us to allocate
    a new (bigger) block of memory and copy all the values of the original array into
    the new block. Further, the insertion itself may require us to traverse the array
    and shift elements over.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，将新元素插入数组中可能需要我们分配一个新的（更大的）内存块，并将原数组中的所有值复制到新块中。此外，插入操作本身可能需要我们遍历数组并移动元素。
- en: The linked list, on the other hand, doesn’t need to stay in a single contiguous
    block—it probably isn’t in a single block to begin with. We only need to know
    the location of the new node, update the previous node’s `next` pointer to point
    to our new node, and point the new node’s `next` pointer at the correct node.
    If we want to add a node with value 23 to the front of the linked list in [Figure
    3-5](#figure3-5), we simply set the new node’s `next` pointer to the previous
    start of the list (value = 3). This procedure is shown in [Figure 3-8](#figure3-8).
    Any variables previously pointing to the start of the list (the first node) also
    need to be updated to point to the new first node.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，链表不需要保持在一个单一的连续内存块中——它可能一开始就不在单一块中。我们只需要知道新节点的位置，更新前一个节点的 `next` 指针指向新节点，并将新节点的
    `next` 指针指向正确的节点。如果我们想将值为 23 的节点添加到 [图3-5](#figure3-5) 中链表的前端，我们只需将新节点的 `next`
    指针指向原链表的起始节点（值 = 3）。这个过程如 [图3-8](#figure3-8) 所示。任何之前指向链表起始位置（第一个节点）的变量也需要更新为指向新的第一个节点。
- en: '![The linked list from Figure 3‐5 with a new node added to the front. A right‐pointing
    arrow links the new first node to what is now the second node. ](image_fi/502604c03/f03008.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图3-5中的链表，新增节点已添加到前端。右箭头将新的第一个节点链接到现在的第二个节点。](image_fi/502604c03/f03008.png)'
- en: 'Figure 3-8: Extending a linked list by adding a new node to the front'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-8：通过将新节点添加到前端来扩展链表
- en: Similarly, we can add a node to the end of the list, as shown in [Figure 3-9](#figure3-9),
    by traversing the list to the end, updating the `next` pointer from the final
    node (value = 8) to point to the new node, and setting the new node’s `next` pointer
    to `null`. Done naively, this approach requires traversing the entire array to
    reach the end, but, as we will see in the next chapter, there are ways to avoid
    this additional cost.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以通过遍历链表直到末尾，然后更新最后一个节点的 `next` 指针（值 = 8）指向新节点，并将新节点的 `next` 指针设为 `null`，来将节点添加到链表的末尾，正如
    [图3-9](#figure3-9) 所示。这个方法天真地实现时，需要遍历整个数组到达末尾，但正如我们在下一章将看到的那样，有方法可以避免这种额外的成本。
- en: '![The linked list from Figure 3‐5 with a new node added to the end. A right‐pointing
    arrow links the formerly last node to the new last node, and a right‐pointing
    arrow links the new last node to the slash indicating the end of the list. ](image_fi/502604c03/f03009.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图3-5中的链表，新增节点已添加到末尾。右箭头将原本的最后一个节点链接到新的最后一个节点，右箭头将新的最后一个节点链接到表示链表结束的斜杠。](image_fi/502604c03/f03009.png)'
- en: 'Figure 3-9: Extending a linked list by appending an additional node to the
    end'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-9：通过将一个附加节点附加到末尾来扩展链表
- en: 'If we want to insert a value in the middle, we update two pointers: the previous
    node and the inserted node. For example, to add node *N* between nodes *X* and
    *Y*, we have two steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在中间插入一个值，需要更新两个指针：前一个节点和插入的节点。例如，要在节点 *X* 和节点 *Y* 之间添加节点 *N*，我们有两个步骤：
- en: Set *N*’s `next` pointer to point at *Y* (the same place *X*’s `next` pointer
    currently points).
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *N* 的 `next` 指针指向 *Y*（即当前 *X* 的 `next` 指针指向的地方）。
- en: Set *X*’s `next` pointer to point at *N*.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 *X* 的 `next` 指针指向 *N*。
- en: The order of these two steps is important. Pointers, like all other variables,
    can hold only a single value—in this case a single address in memory. If we set
    *X*’s `next` pointer first, we would lose the data on where *Y* resides.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个步骤的顺序非常重要。指针就像所有其他变量一样，只能保存一个单一的值——在这个案例中是内存中的一个地址。如果我们先设置 *X* 的 `next` 指针，那么我们将丧失
    *Y* 所在位置的数据。
- en: Once we’ve finished, *X* points to *N* and *N* points to *Y*. [Figure 3-10](#figure3-10)
    illustrates this process.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，*X* 指向 *N*，*N* 指向 *Y*。[图3-10](#figure3-10)展示了这个过程。
- en: '![Diagram of the process of inserting a new node N into a linked list between
    nodes X and Y. Before the insertion, X points to Y. During the insertion, both
    N and X point to Y. After the insertion, X points to N and N points to Y. ](image_fi/502604c03/f03010.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![将新节点 *N* 插入到链表中，位于节点 *X* 和节点 *Y* 之间的过程示意图。插入之前，*X* 指向 *Y*；插入过程中，*N* 和 *X*
    都指向 *Y*；插入后，*X* 指向 *N*，*N* 指向 *Y*。](image_fi/502604c03/f03010.png)'
- en: 'Figure 3-10: The process of inserting a new node *N* into a linked list between
    nodes *X* and *Y*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite the shuffling of pointers, the code for this kind of operation is relatively
    simple:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Say we instead wanted to insert a node with value 23 between the nodes 9 and
    37 in our current linked list. The resulting chain of pointers would appear as
    shown in [Figure 3-11](#figure3-11).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![The linked list from Figure 3‐5 in which node 9 previously pointed at node
    37\. Now a right arrow points from node 9 to newly inserted node 23, and a right
    arrow points from node 23 to node 37\. ](image_fi/502604c03/f03011.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-11: Inserting the node 23 into a linked list requires updating pointers
    from the previous node (9) and to the following node (37).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, when a customer lets their friend step in front of them to join the
    middle of the line, two pointers change. Recall that in this analogy, each person
    “points” to, or keeps track of, the person in front of them. The overly generous
    customer now points to their line-jumping friend who stands right in front of
    them. Meanwhile the happy line jumper points to the person who was previously
    in front of their enabling friend. Everyone behind them in line gives dirty looks
    and mumbles unkind things.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Again, the diagrams and the café line analogy hide the insertion process’s true
    messiness. While we aren’t inserting the new node in a memory location adjacent
    to the last node, we are logically inserting it next in line. The node itself
    could be on the other end of the computer’s memory next to the variable counting
    our spelling errors or daily cups of coffee. As long as we keep the list’s pointers
    up-to-date, we can treat them and the nodes to which they point as a single list.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we must take extra care when inserting a node in front of the head
    node (`index == 0`) or at an index *past* the end of the list. If we are inserting
    a node before the head node, we need to update the head pointer itself; otherwise,
    it will continue to point to the old front of the list, and we will lose the ability
    to access the new first element. If we are trying to insert a node into an index
    past the end of the list, there is no valid previous node at `index - 1`. In this
    case, we could fail the insertion, return an error, or append the element to the
    end of the list (at a smaller index). Whichever approach you choose, it is critical
    that you clearly document your code. We can bundle this extra logic into a helper
    function that combines our linear lookup code to insert a new node at a given
    position:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code for insertion starts with the special case of inserting a new node
    at `index = 0`, the beginning of the list ❶. It creates a new head node, sets
    the new head node’s `next` pointer to the previous head of the list, and returns
    the new head of the list. Since there isn’t a node before the new head node, we
    do not need to update a previous node’s `next` pointer in this case.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'For elements in the middle of the list, the code needs to traverse the list
    to find the correct location ❷. This is similar to the `LinkedListLookUp` search:
    the code follows each node’s `next` pointer, while tracking the `current` node
    and the `count` seen, until it hits the end of the list or the correct location.
    The code also tracks an additional piece of information, `previous`, a pointer
    to the node *before* the current node. Tracking `previous` allows us to update
    the pointer into the inserted node.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: The code then checks whether it has arrived at the desired index of insertion
    ❸. By making the check `count < index`, we still allow insertion at the very end
    of the list. We only fail with an error in cases where we try to insert at least
    one additional spot *past* the end of the list.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: If the code has found the correct location to insert the node, it splices it
    in between `previous` and `current`. The code performs the insertion by creating
    a new node, setting that node’s `next` pointer to the address indicated by `previous.next`,
    and then setting `previous.next` to point to the new node ❹. This logic also works
    for the case where we are appending the new node immediately after the last node
    in the list. Since `previous.next == null` in that case, the new node’s `next`
    pointer is assigned to `null` and correctly indicates the new end of the list.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: By returning the head of the list ❺, we can account for insertions before the
    head node. Alternatively, we could wrap the head node in a `LinkedList` composite
    data structure and operate on that directly. We will use this alternate approach
    later in the book to handle binary search trees.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Deleting from a Linked List
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To delete an element anywhere in a linked list, all we need to do is delete
    that node and adjust the previous node’s pointer, as shown in [Figure 3-12](#figure3-12).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![The seven‐node linked list from Figure 3‐9\. Node 37 is in the middle, with
    node 9 preceding it and node 7 following. Node 37 is crossed out, and node 9 now
    points to node 7\.  ](image_fi/502604c03/f03012.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-12: Removing a node (37) from a linked list requires updating the
    pointer in the previous node (9) to skip ahead to the following node (7).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: This corresponds to someone making the questionable decision that coffee isn’t
    worth the wait in line. They look at their watch, mutter something about having
    instant at home, and leave. As long as the person behind the newly departed customer
    knows who they are now behind, the line’s integrity is maintained.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: In the case of an array, we would have to pay a significantly higher cost to
    delete an element, shifting everything following the node containing 37 by one
    bin toward the front of the array in order to close up the gap. This could require
    us to walk the entire array.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we must take special care when deleting the first element in a linked
    list or deleting past the end of the list. When deleting the first node, we update
    the list’s head pointer to the address of the new head node, effectively making
    that node the new head of the list. When deleting past the end of the list, we
    have options similar to those for insertion: we can skip the deletion or return
    an error. The following code does the latter:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code follows the same approach as insertion. This time we start with an
    additional check ❶. If the list is empty, there is nothing to delete, and we can
    return the value `null` to indicate the list is still empty. Otherwise, we check
    whether we are deleting the first node ❷ and, if so, remove the previous first
    node from the list and return the address of the new head node.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: To remove any later nodes (`index > 0`), the code must travel to the correct
    location in the list. Using the same logic as for insertion, the code tracks `current`,
    `count`, and `previous` while iterating through the nodes until it either finds
    the correct location or hits the end of the list ❸. If the code finds a node at
    the correct index ❹, it splices out the node to be removed by setting `previous.next`
    to point at one node past the current node ❺. However, if the `WHILE` loop ran
    off the end of the list and `current` is `null`, there is nothing to delete, so
    the code throws an error. The function also sets the removed node’s `next` pointer
    to `null` both to ensure consistency (it no longer has a `next` node in the list)
    and to allow programming languages with memory management to correctly free memory
    that is no longer used ❻. The function completes by returning the address of the
    list’s head node ❼.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'We can adapt this code to use information other than the node’s index for deletion.
    If we have the value of the node to delete, we could update the loop conditions
    ❸ to remove the first node with that value:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, we need to reverse the order of comparison and check if `current`
    is `null` `before accessing its value. Similarly, if we need to delete a node
    given a pointer to it, we could compare the address stored in that pointer to
    the address of the current node.`
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7] DoublyLinkedListNode {     Type: Value     DoublyLinkedListNode: next     DoublyLinkedListNode:
    previous } [PRE8]`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
