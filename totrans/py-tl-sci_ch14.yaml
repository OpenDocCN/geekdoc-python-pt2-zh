- en: '**14'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DOCUMENTING YOUR WORK**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Python is famous for the readability of its code, but this readability can take
    you only so far. To collaborate with others, and to remind yourself why you did
    what you did, you’ll need to rely on natural human language to convey information,
    make your meaning as clear as possible, or explain the purpose of your program.
    Python enables this through comments and docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: A *comment* is a non-executable annotation within a computer program. A *docstring*,
    short for *documentation string*, is a multiline string, unassigned to any variable,
    used to add documentation to Python modules, classes, methods, and functions.
    Together, comments and docstrings comprise code documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Good documentation makes your intentions clear and saves future users (including
    yourself) both time and effort. There should be no reason to reverse engineer
    parts of the code or waste time trying to understand arcane arguments or numbers
    applied without context.
  prefs: []
  type: TYPE_NORMAL
- en: Proper documentation might also include lessons learned during programming and
    can flag potential problems such as those encountered when working across operating
    systems. These will let you pass on valuable knowledge and save others from discovering
    and dealing with these problems on their own.
  prefs: []
  type: TYPE_NORMAL
- en: Given that code generated in a console is usually temporary, you’ll need only
    to document *persistent* programs, such as those generated in a text editor or
    Jupyter Notebook. These types of files are saved to disk and reused, sometimes
    months later, so it’s important to record any intentions and assumptions that
    aren’t clearly self-evident.
  prefs: []
  type: TYPE_NORMAL
- en: '**Comments**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Comments* are notes that you add to code to remind you of what you were doing,
    explain the purpose of a new block of code, flag a to-do item, and temporarily
    “turn off” code that you don’t want to run. They’re especially helpful when other
    people need to understand and modify your work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Comments start with the hash (`#`) symbol, which tells Python to ignore (not
    execute) any remaining code on the same line. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In consoles and text editors, comments display with a different color than regular
    code. If you’re using the “Spyder” syntax highlighting theme (see “Configuring
    the Spyder Interface” on [page 64](ch04.xhtml#ch00lev1sec23)), comments will be
    colored gray, and docstrings will be green.
  prefs: []
  type: TYPE_NORMAL
- en: Comments can occur on a single line, extend over multiple lines, or be embedded
    in a line of code. The latter are called *inline* comments.
  prefs: []
  type: TYPE_NORMAL
- en: Like variable names, comments should be as concise as possible, and it will
    take multiple iterations to get them right. If comments are too long or if there
    are too many, they’ll become distracting, and users might ignore them. If they’re
    too short and cryptic, their purpose will be wasted. If they’re lacking, users
    might end up squandering time deciphering the code. And that user could be you!
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you’ll always want to avoid rude comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Comments like this offend people, adversely affect teamwork, and make you look
    unprofessional.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another commenting error is to violate the DRY (Don’t Repeat Yourself) maxim
    and elaborate on code that’s already readable and explicit. Here’s an example
    of a redundant comment that adds no value and creates visual noise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following comments state the obvious and clutter the code without adding
    much value, as the code itself is easy to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The cryptic inline comment that follows was probably meant as a temporary reminder,
    but the coder forgot to remove it so now it adds confusion rather than clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Along these lines, comments that contradict the code are worse than no comments
    at all. Consequently, you should keep comments up to date and address any code
    changes. This is difficult to do in practice and is a good argument for limiting
    the number of comments to those that are strictly necessary.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the official Python guidelines for comments in the PEP8 *Style
    Guide for Python Code* at *[https://pep8.org/](https://pep8.org/)*. Most of this
    content will be summarized in the sections that follow.
  prefs: []
  type: TYPE_NORMAL
- en: '***Single-Line Comments***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A comment will often occupy a single line and summarize some code that follows,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Because users might not be familiar with the `product` function from the built-in
    `itertools` module, the comment saves them the effort of looking it up.
  prefs: []
  type: TYPE_NORMAL
- en: When writing single-line comments, you should insert a single space after the
    hash mark and use complete sentences with periods. If the comment contains multiple
    sentences, each period should be followed by two spaces. Comments should start
    with capital letters unless the first word is an identifier that begins in lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, all comments should be indented to the same level as the code
    they address. For example, because matter can’t reach or exceed the speed of light
    (`C`), the following comment explains the purpose of reassigning the `velocity`
    variable to the speed of light minus 0.000001:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Because the referenced variable assignment occurs *within* the `if` statement
    block, the comment is indented four spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '***Multiline Comments***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Comments that span multiple lines are known as *multiline* comments or *block*
    comments. Python does not have an official syntax for multiline comments. One
    way to handle them is to treat them as a series of single-line comments beginning
    with hash marks, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The drawback to this method is that it’s somewhat unreadable. An alternative
    is to use a multiline string with triple quotes. This works because Python ignores
    strings that aren’t assigned to a variable. It’s also more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also place the triple quotes on the same lines as the comments, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If a block comment contains more than one paragraph, separate the paragraphs
    with a blank line.
  prefs: []
  type: TYPE_NORMAL
- en: Block comments break up the continuity of code and should be used only in special
    circumstances. These include documenting important lessons learned, adding license
    and copyright information, and inserting temporary reminders such as TODO lists,
    FIXME flags, and warnings.
  prefs: []
  type: TYPE_NORMAL
- en: '***Inline Comments***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An inline comment occurs at the end of a statement. A common use is to specify
    measurement units, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: By including a comment to specify the value’s unit instead of including that
    unit in the name of the variable, we were able to use a more concise variable
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Inline comments should be separated from the code by at least two spaces, and
    the `#` should be followed by a single space. If the comment won’t fit on the
    same line as the code, use a single line or multiline comment above the statement
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inline comments are distracting and should be used sparingly. They should never
    state the obvious and should add clarity. For example, some functions and methods
    come with non-intuitive argument values, like the built-in `turtle` module’s `screen()`
    method, which sets up a drawing window. Normally, you pass it the size of the
    window that you want, in pixels, such as `width=800, height=900`, but to use the
    whole screen, you just pass it `1`. An inline comment can make this clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'An inline comment can also provide context to a variable assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, the inline comment can provide a formatting tip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And here, the comment adds clarity to an argument in a user-defined function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You’ll be tempted to use inline comments far more than they’re really needed.
    In most cases, they can be avoided or minimized by using clear object names.
  prefs: []
  type: TYPE_NORMAL
- en: '***Commenting-Out Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because Python ignores comments, you can use the `#` symbol to block the execution
    of some code. This can help you test and debug code by turning parts of it off
    and on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you might want your program to print out a good deal of information,
    but during development, these printouts can slow down the code and obscure other
    outputs that you want to see. While working on the code, you can *comment-out*
    these lines by turning them into comments, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For convenience, you can highlight and comment-out blocks of code using keyboard
    shortcuts. In Spyder, you can see the shortcuts for your system by clicking **File**
    ▸ **Edit** on the top toolbar. For example, in Windows, you can toggle code on
    and off with CTRL-1\. To comment out a block of code that includes an explanatory
    comment, use CTRL-4 to comment-out the block and CTRL-1 to restore it.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  How many spaces should proceed the hash mark of an inline comment?
  prefs: []
  type: TYPE_NORMAL
- en: a.  1
  prefs: []
  type: TYPE_NORMAL
- en: b.  2
  prefs: []
  type: TYPE_NORMAL
- en: c.  0
  prefs: []
  type: TYPE_NORMAL
- en: d.  Inline comments should use triple quotes
  prefs: []
  type: TYPE_NORMAL
- en: '2.  True or false: Multiline comments are more readable if they use triple
    quotes.'
  prefs: []
  type: TYPE_NORMAL
- en: '3.  In Python, the hash mark (`#`) denotes which of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  A comment
  prefs: []
  type: TYPE_NORMAL
- en: b.  A number
  prefs: []
  type: TYPE_NORMAL
- en: c.  A non-executable line of code
  prefs: []
  type: TYPE_NORMAL
- en: d.  Weight in pounds
  prefs: []
  type: TYPE_NORMAL
- en: '4.  A good alternative to using inline comments is:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  A multiline docstring
  prefs: []
  type: TYPE_NORMAL
- en: b.  A single-line comment
  prefs: []
  type: TYPE_NORMAL
- en: c.  Good naming conventions
  prefs: []
  type: TYPE_NORMAL
- en: d.  Judicious use of constants
  prefs: []
  type: TYPE_NORMAL
- en: '**Docstrings**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A docstring is a triple-quoted string literal that occurs as the first statement
    in a module, function, class, or method definition. Because of this positioning
    and the use of triple quotes, various types of help tools can discover and display
    docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docstrings usually consist of a summary line followed by a more elaborate description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Because the summary line can be used by automatic indexing tools, it should
    fit on one line and be separated from the rest of the docstring by a blank line.
    The summary line can be on the same line as the opening quotes or on the next
    line. Unless the entire docstring fits on a single line, you should place the
    closing quotes on a line by themselves. The docstring should be indented to the
    same level as the quotes at its first line.
  prefs: []
  type: TYPE_NORMAL
- en: 'When docstrings are properly set up, you can access them with the special `__doc__`
    attribute. To see an example using the `pickle` module that we used in [Chapter
    12](ch12.xhtml), enter the following in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display the module’s docstring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can also see this in Spyder’s Help pane, by typing **pickle** in the Object
    box ([Figure 14-1](ch14.xhtml#ch014fig1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/14fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-1: The pickle module docstring displayed in Spyder’s Help pane*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For simple functions or methods, the docstring can consist entirely of the
    one-line summary. Even though this summary doesn’t span multiple lines, you should
    still use triple quotes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is about as terse as a docstring can get, but it’s sufficient for simple
    functions and functions you define for your own use. However, if you plan to work
    on enterprise-scale code or contribute to open source projects, you’ll want to
    follow the instructions in PEP 257, which covers docstring conventions (*[https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/)*).
    Some of these cases can be quite elaborate, with docstrings several screens long.
  prefs: []
  type: TYPE_NORMAL
- en: In the sections that follow, we’ll look at docstring conventions appropriate
    for scientists and engineers working alone or in close groups. In these cases,
    users will be applying the code more often than modifying it, and simple docstrings
    should address their needs.
  prefs: []
  type: TYPE_NORMAL
- en: '***Documenting Modules***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The docstring of a module should be placed at the top of the module above any
    import statements. The first line should describe the module’s purpose. The rest
    of the docstring should generally list the classes, exceptions, functions, and
    any other objects that are exported by the module, with a one-line summary of
    each. It’s okay if these summaries provide less detail than the summary line in
    the object’s own docstring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how the `pickle` module’s docstring looks in the actual code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As modules become larger and more complex, their docstrings can become quite
    technical. This makes them difficult for beginners and non-developers to both
    write and read. For programs written for your own use or for that of your immediate
    team, simpler summaries might be appropriate. Here’s a friendly module docstring
    (in bold) for the *mymath.py* module we wrote in [Chapter 11](ch11.xhtml):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get this documentation using `__doc__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, the built-in `help()` function can retrieve this docstring with more
    information, including the location of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This docstring gives the user a nice overview of the `my_math` module. Don’t
    worry that the description of the functions is a little sparse. As you’ll see
    in a later section, functions get their own docstrings, in which you can expand
    on the function’s purpose, parameters, outputs, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '***Documenting Classes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The docstring for a class should follow the same pattern as a module-level docstring.
    It should summarize the class behavior and list the public methods and instance
    variables. Any subclasses, constructors, and methods should have their own docstrings.
    You should insert a blank line after all docstrings that document a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a docstring for a Starship class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This docstring is simple, but that’s okay because one of the main uses of docstrings
    is to provide dynamic hints when using the class (see [Figure 13-4](ch13.xhtml#ch013fig4)).
    Consequently, you’ll want to present the information as concisely as possible.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we start the docstring with a one-line summary followed by a list
    of attributes. This listing includes the attribute name, its data type, and a
    brief description. Next, we list the class methods along with a single-line summary
    of each.
  prefs: []
  type: TYPE_NORMAL
- en: '***Documenting Functions and Methods***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The docstring for a function or method should summarize its behavior and document
    its arguments, return values, and side effects as well as any exceptions raised
    and restrictions on when it can be called (if applicable). You should indicate
    optional and keyword arguments as such.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, if your function or method takes no arguments and returns a single
    value, a one-line summary should provide enough documentation. This summary should
    use *imperative mood*; in other words, use “Return” not “Returns”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a longer docstring for a function that accepts two words and returns
    `True` if the words are anagrams (composed of the same letters in different orders)
    or `False` if they’re not. It provides information on the function’s arguments
    and return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output of this code. Because “softer” is an anagram of “forest,”
    the comparison returns `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If a function’s arguments have default values, you should mention them. Here’s
    an example using the `tax_rate` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '***Keeping Docstrings Up to Date with doctest***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s easy to update a program and forget to edit the associated docstring. With
    the `doctest` built-in module, you can embed usage examples in docstrings to check
    whether there’s a divergence between the code and its documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `doctest` module searches for pieces of text that look like interactive
    Python sessions and then executes those sessions to verify that they work exactly
    as shown. Let’s look at a simple function that takes a starship’s warp factor
    value and adjusts it so that it falls within acceptable operating limits. The
    code highlighted in bold represents the embedded test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The test cases check both acceptable and unacceptable values. Unacceptable values
    are those that will fail the comparison statements, such as `12` and `-4`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run `doctest` in several ways. One way is by running the script from
    the text editor by pressing F5\. Another is to open the console, import the `doctest`
    module and your custom module (without the *.py* extension), and call the `testmod()`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Because none of the tests failed, you got an abbreviated summary of the test
    result. If you go back to the docstring and edit the expected result for `warp(-4)`
    from `0` to `4`, you’ll see this output when you rerun the method (remember to
    save your script first):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To print a detailed log of what the `doctest` module is trying, what it’s expecting,
    and what it found, pass `verbose=True` to `testmod()`. Here’s the result for a
    no-failure case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also run `doctest` from Anaconda Prompt or a terminal. Just navigate
    to the directory that holds your Python file and run the following using the `-v`
    switch (for verbose mode):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Leave off the `-v` switch for a simple summary.
  prefs: []
  type: TYPE_NORMAL
- en: Besides checking that a module’s docstrings are up to date, you can use `doctest`
    to verify that interactive examples from a test file or a test object work as
    expected. This is known as *regression testing*, and it ensures that previously
    developed and tested software still performs after a change.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use `doctest` to write tutorial documentation for a package, liberally
    illustrated with input-output examples. To learn more, visit *[https://docs.python.org/3/library/doctest.html](https://docs.python.org/3/library/doctest.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Checking Docstrings in the Spyder Code Analysis Pane***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can use the Spyder IDE to check how your docstrings conform to established
    guidelines. The results are presented in the code analysis pane, which was introduced
    on [page 85](ch04.xhtml#ch00lev1sec29) in [Chapter 4](ch04.xhtml), and within
    the text editor itself.
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting Spyder Preferences**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To set up Spyder to check docstrings, on the top toolbar, click **Tools** ▸
    **Preferences**. In the Preferences window, click **Completion and linting**.
    Then, choose the **Docstring style** tab. You should see the window shown in [Figure
    14-2](ch14.xhtml#ch014fig2). Ensure that the **Enable docstring style linting**
    checkbox is selected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/14fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-2: Spyder’s Docstring style window*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Choose the convention used to lint docstrings** drop-down menu offers
    you three choices: PEP 257, NumPy, and Custom. As previously discussed, PEP 257
    is Python’s official docstring guide, so we’ll use it here.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to PEP 257, some members of the scientific community use a NumPy
    docstring standard (*[https://numpydoc.readthedocs.io/en/latest/install.html](https://numpydoc.readthedocs.io/en/latest/install.html)*).
    You can find examples of this style at *[https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_numpy.html](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_numpy.html)*).
  prefs: []
  type: TYPE_NORMAL
- en: You can also choose to show or ignore certain errors, based on the codes found
    at *[http://www.pydocstyle.org/en/stable/error_codes.html](http://www.pydocstyle.org/en/stable/error_codes.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In addition to PEP 257 and NumPy, there are other docstring formats that you
    can follow. Google has its own format and an excellent style guide ([https://google.github.io/styleguide/pyguide.html](https://google.github.io/styleguide/pyguide.html)).
    You can see examples of this style at [https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html](https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html).
    In addition, *reStructuredText* is a popular format used mainly in conjunction
    with a tool called *Sphinx*. Sphinx uses docstrings to generate documentation
    for Python projects in formats such as HTML and PDF. If you’ve ever read the docs
    ([https://readthedocs.org/](https://readthedocs.org/)) for a Python module, you’ve
    seen Sphinx in action.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Running the Analysis**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To see how checking docstrings with Spyder works in practice, let’s write some
    docstring-challenged code. Open the text editor, enter the following, and save
    it as *test_docs.py* (you can do this in the *oop* Spyder project from the previous
    chapter or somewhere else):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, you’ve noticed several documentation errors here, but if you haven’t,
    don’t despair, Spyder will find and flag these for you. To start, on the top toolbar,
    click **Source**. This will produce the menu shown in [Figure 14-3](ch14.xhtml#ch014fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/14fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-3: The Source menu from Spyder’s top toolbar*'
  prefs: []
  type: TYPE_NORMAL
- en: Be sure that the **Show docstring style warnings** checkbox is selected, and
    then, at the bottom of the menu, click the **Run code analysis** option (or press
    the F8 shortcut). The code analysis pane should appear ([Figure 14-4](ch14.xhtml#ch014fig4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/14fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-4: The code analysis pane with messages related to the docstrings*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the right-facing arrow (**>**) symbol next to the **Convention** heading
    to expand the style messages for code and docstrings. In the *test_docs.py* example,
    we’re missing two recommended docstrings: one for the entire program, called the
    module docstring, and one for the `pyroclastic_cloud` method.'
  prefs: []
  type: TYPE_NORMAL
- en: The messages in the code analysis pane are from the code linting tool and lack
    granularity with respect to docstrings. To see specific documentation errors,
    hover your cursor over the orange triangles to the left of the line numbers in
    the text editor ([Figure 14-5](ch14.xhtml#ch014fig5)). You’ll see multiple error
    codes along with their descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/14fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-5: The code analysis messages for Line 1*'
  prefs: []
  type: TYPE_NORMAL
- en: The message about the missing module docstring is repeated, but with a different
    error code than in the code analysis pane. Then, for the `Volcano` class definition,
    there are messages flagging a missing blank line, the incorrect use of quotes,
    and the need for a period at the end of the docstring.
  prefs: []
  type: TYPE_NORMAL
- en: If you hover your cursor over the Line 3 triangle, which refers to the `__init__()`
    method, you’ll see a window with similar errors ([Figure 14-6](ch14.xhtml#ch014fig6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/14fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 14-6: The code analysis messages for Line 3*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the tool checks for the *presence* of a summary description, but it
    doesn’t evaluate the *content* of the description. A nonsensical summary such
    as `"""sfsds"""` will pass the test.
  prefs: []
  type: TYPE_NORMAL
- en: Spyder’s code analysis tool is a great way to ensure that your code, and its
    documentation, conform to Python community standards.
  prefs: []
  type: TYPE_NORMAL
- en: '**TEST YOUR KNOWLEDGE**'
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Which of the following help you access docstrings?
  prefs: []
  type: TYPE_NORMAL
- en: a.  The `__doc__ special` attribute
  prefs: []
  type: TYPE_NORMAL
- en: b.  `help()`
  prefs: []
  type: TYPE_NORMAL
- en: c.  The Spyder Help pane
  prefs: []
  type: TYPE_NORMAL
- en: d.  All the above
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Import the built-in `itertools` module and get help on its `product()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 7.  Which Python Enhancement Proposals provide guidance on code documentation?
  prefs: []
  type: TYPE_NORMAL
- en: a.  PEP 248
  prefs: []
  type: TYPE_NORMAL
- en: b.  PEP 8
  prefs: []
  type: TYPE_NORMAL
- en: c.  PEP 549
  prefs: []
  type: TYPE_NORMAL
- en: d.  PEP 257
  prefs: []
  type: TYPE_NORMAL
- en: 8.  Which of the following make docstrings accessible to automatic help tools?
  prefs: []
  type: TYPE_NORMAL
- en: a.  Use of triple quotes
  prefs: []
  type: TYPE_NORMAL
- en: b.  Description of input and output data types
  prefs: []
  type: TYPE_NORMAL
- en: c.  That it immediately follows a `def` statement
  prefs: []
  type: TYPE_NORMAL
- en: d.  Final triple quote followed by a space
  prefs: []
  type: TYPE_NORMAL
- en: '9.  Spyder’s code analysis tool can check your docstrings for conformity to:'
  prefs: []
  type: TYPE_NORMAL
- en: a.  PEP 8 conventions
  prefs: []
  type: TYPE_NORMAL
- en: b.  PEP 257 and Google conventions
  prefs: []
  type: TYPE_NORMAL
- en: c.  PEP 8 and Google conventions
  prefs: []
  type: TYPE_NORMAL
- en: d.  PEP 257 and NumPy conventions
  prefs: []
  type: TYPE_NORMAL
- en: 10.  Write a docstring for the `Frigate` class defined in the *ships.py* program
    from [Chapter 13](ch13.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Good documentation maximizes the usability of your code as well as its maintainability
    over time. In the Python community, well-written code is synonymous with well-documented
    code. Comments and docstrings let you add human language to programs to fill in
    any explanatory gaps about their purpose, meaning, and usability.
  prefs: []
  type: TYPE_NORMAL
- en: Comments represent non-executable notes for annotating code or for temporarily
    commenting-out lines so that they don’t run. You should use comments sparingly
    to explain your intent, capture important programming lessons learned, provide
    warnings, include legal information such as for license and copyright data, specify
    units, and so on. Most comments occupy a single line, or are placed inline, and
    start with a `#` symbol. Multiline comments can use triple-quotes for readability.
  prefs: []
  type: TYPE_NORMAL
- en: Docstrings are special triple-quoted strings that occur at the top of a module
    or immediately after a `class` or `def` statement. They provide a user with an
    overview of what the code does and how to use it, and you can access them using
    automatic help tools. You should use docstrings with every module, class, method,
    and function, and these should be kept up to date as the code changes.
  prefs: []
  type: TYPE_NORMAL
- en: Various tools can help you check that your docstrings are up to date and well
    formatted. With the built-in `doctest` module, you can embed testable cases in
    docstrings. These let you check that code updates don’t change expected behaviors.
    They can also provide example use cases for new users. The Spyder IDE includes
    a tool for checking your docstrings against the PEP 257 and NumPy guidelines.
    The results are displayed in the code analysis pane and along the margin of the
    text editor, adjacent to the problem lines.
  prefs: []
  type: TYPE_NORMAL
