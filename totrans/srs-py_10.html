<html><head></head><body>
<h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_151"/><strong><span class="big">10</span></strong><br/><strong>PERFORMANCES AND OPTIMIZATIONS</strong></h2>&#13;
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>&#13;
<p class="noindent">Optimizing is rarely the first thing you think about when developing, but there always comes a time when optimizing for better performance will be appropriate. That’s not to say you should write a program with the idea that it will be slow, but thinking about optimization without first figuring out the right tools to use and doing the proper profiling is a waste of time. As Donald Knuth wrote, “Premature optimization is the root of all evil.”<sup><a id="foot_2"/><a href="footnote.xhtml#foot2">1</a></sup></p>&#13;
<p class="indent">Here, I’ll show you how to use the right approach to write fast code and where to look when more optimization is needed. Many developers try to guess where Python might be slower or faster. Rather than speculating, this <span epub:type="pagebreak" id="page_152"/>chapter will help you understand how to profile your application so you’ll know what part of your program is slowing things down and where the bottlenecks are.</p>&#13;
<h3 class="h3" id="lev1sec51"><strong>Data Structures</strong></h3>&#13;
<p class="noindent">Most programming problems can be solved in an elegant and simple manner with the right data structures—and Python provides many data structures to choose from. Learning to leverage those existing data structures results in cleaner and more stable solutions than coding custom data structures.</p>&#13;
<p class="indent">For example, everybody uses <span class="literal">dict</span>, but how many times have you seen code trying to access a dictionary by catching the <span class="literal">KeyError</span> exception, as shown here:</p>&#13;
<p class="programs">def get_fruits(basket, fruit):<br/>    try:<br/>        return basket[fruit]<br/>    except KeyError:<br/>        return None</p>&#13;
<p class="indent">Or by checking whether the key is present first:</p>&#13;
<p class="programs">def get_fruits(basket, fruit):<br/>    if fruit in basket:<br/>        return basket[fruit]</p>&#13;
<p class="indent">If you use the <span class="literal">get()</span> method already provided by the <span class="literal">dict</span> class, you can avoid having to catch an exception or checking the key’s presence in the first place:</p>&#13;
<p class="programs">def get_fruits(basket, fruit):<br/>    return basket.get(fruit)</p>&#13;
<p class="indent">The method <span class="literal">dict.get()</span> can also return a default value instead of <span class="literal">None</span>; just call it with a second argument:</p>&#13;
<p class="programs">def get_fruits(basket, fruit):<br/>    # Return the fruit, or Banana if the fruit cannot be found.<br/>    return basket.get(fruit, Banana())</p>&#13;
<p class="indent">Many developers are guilty of using basic Python data structures without being aware of all the methods they provide. This is also true for sets; methods in set data structures can solve many problems that would otherwise need to be addressed by writing nested <span class="literal">for</span>/<span class="literal">if</span> blocks. For example, developers often use <span class="literal">for</span>/<span class="literal">if</span> loops to determine whether an item is in a list, like this:</p>&#13;
<p class="programs">def has_invalid_fields(fields):<br/>    for field in fields:<span epub:type="pagebreak" id="page_153"/><br/>        if field not in ['foo', 'bar']:<br/>            return True<br/>    return False</p>&#13;
<p class="indent">The loop iterates over each item in the list and checks that all items are either <span class="literal">foo</span> or <span class="literal">bar</span>. But you can write this more efficiently, removing the need for a loop:</p>&#13;
<p class="programs">def has_invalid_fields(fields):<br/>    return bool(set(fields) - set(['foo', 'bar']))</p>&#13;
<p class="indent">This changes the code to convert the fields to a set, and it gets the rest of the set by subtracting the <span class="literal">set(['foo', 'bar'])</span>. It then converts the set to a Boolean value, which indicates whether any items that aren’t <span class="literal">foo</span> and <span class="literal">bar</span> are left over. By using sets, there is no need to iterate over any list and to check items one by one. A single operation on two sets, done internally by Python, is faster.</p>&#13;
<p class="indent">Python also has more advanced data structures that can greatly reduce the burden of code maintenance. For example, take a look at <a href="ch10.xhtml#ch10list1">Listing 10-1</a>.</p>&#13;
<p class="programs">def add_animal_in_family(species, animal, family):<br/>    if family not in species:<br/>        species[family] = set()<br/>    species[family].add(animal)<br/><br/>species = {}<br/>add_animal_in_family(species, 'cat', 'felidea')</p>&#13;
<p class="listing1"><a id="ch10list1"/><em>Listing 10-1: Adding an entry in a dictionary of sets</em></p>&#13;
<p class="indent">This code is perfectly valid, but how many times will your programs require a variation of <a href="ch10.xhtml#ch10list1">Listing 10-1</a>? Tens? Hundreds?</p>&#13;
<p class="indent">Python provides the <span class="literal">collections.defaultdict</span> structure, which solves the problem in an elegant way:</p>&#13;
<p class="programs">import collections<br/><br/>def add_animal_in_family(species, animal, family):<br/>    species[family].add(animal)<br/><br/>species = collections.defaultdict(set)<br/>add_animal_in_family(species, 'cat', 'felidea')</p>&#13;
<p class="indent">Each time you try to access a nonexistent item from your <span class="literal">dict</span>, the <span class="literal">defaultdict</span> will use the function that was passed as argument to its constructor to build a new value, instead of raising a <span class="literal">KeyError</span>. In this case, the <span class="literal">set()</span> function is used to build a new <span class="literal">set</span> each time we need it.</p>&#13;
<p class="indent">The <span class="literal">collections</span> module offers a few more data structures that you can use to solve other kinds of problems. For example, imagine that you want <span epub:type="pagebreak" id="page_154"/>to count the number of distinct items in an iterable. Let’s take a look at the <span class="literal">collections.Counter()</span> method, which provides methods that solve this problem:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">import collections</span><br/>&gt;&gt;&gt; <span class="codestrong1">c = collections.Counter("Premature optimization is the root of all evil.")</span><br/>&gt;&gt;&gt; <span class="codestrong1">c</span><br/>&gt;&gt;&gt; <span class="codestrong1">c['P']  # Returns the name of occurrence of the letter 'P'</span><br/>1<br/>&gt;&gt;&gt; <span class="codestrong1">c['e']  # Returns the name of occurrence of the letter 'e'</span><br/>4<br/>&gt;&gt;&gt; <span class="codestrong1">c.most_common(2)  # Returns the 2 most common letters</span><br/>[(' ', 7), ('i', 5)]</p>&#13;
<p class="indent">The <span class="literal">collections.Counter</span> object works with any iterable that has hashable items, removing the need to write your own counting functions. It can easily count the number of letters in a string and return the top <em>n</em> most common items of an iterable. You might have tried to implement something like this on your own if you were not aware it was already provided by Python’s Standard Library.</p>&#13;
<p class="indent">With the right data structure, the correct methods, and—obviously—an adequate algorithm, your program should perform well. However, if it is not performing well enough, the best way to get clues about where it might be slow and need optimization is to profile your code.</p>&#13;
<h3 class="h3" id="lev1sec52"><strong>Understanding Behavior Through Profiling</strong></h3>&#13;
<p class="noindent"><em>Profiling</em> is a form of dynamic program analysis that allows us to understand how a program behaves. It allows us to determine where there might be bottlenecks and a need for optimization. A profile of a program takes the form of a set of statistics that describe how often parts of the program execute and for how long.</p>&#13;
<p class="indent">Python provides a few tools for profiling your program. One, <span class="literal">cProfile</span>, is part of the Python Standard Library and does not require installation. We’ll also look at the <span class="literal">dis</span> module, which can disassemble Python code into smaller parts, making it easier to understand what is happening under the hood.</p>&#13;
<h4 class="h4" id="lev2sec58"><strong><em>cProfile</em></strong></h4>&#13;
<p class="noindent">Python has included <span class="literal">cProfile</span> by default since Python 2.5. To use <span class="literal">cProfile</span>, call it with your program using the syntax <span class="literal">python –m cProfile &lt;<span class="codeitalic">program</span>&gt;</span>. This should load and enable the <span class="literal">cProfile</span> module, then run the regular program with instrumentation enabled, as shown in <a href="ch10.xhtml#ch10list2">Listing 10-2</a>.</p>&#13;
<p class="programs">$ <span class="codestrong1">python -m cProfile myscript.py</span><br/>         343 function calls (342 primitive calls) in 0.000 seconds<br/><br/>   Ordered by: standard name<span epub:type="pagebreak" id="page_155"/><br/>   ncalls  tottime  percall  cumtime  percall filename:lineno(function)<br/>        1    0.000    0.000    0.000    0.000 :0(_getframe)<br/>        1    0.000    0.000    0.000    0.000 :0(len)<br/>      104    0.000    0.000    0.000    0.000 :0(setattr)<br/>        1    0.000    0.000    0.000    0.000 :0(setprofile)<br/>        1    0.000    0.000    0.000    0.000 :0(startswith)<br/>      2/1    0.000    0.000    0.000    0.000 &lt;string&gt;:1(&lt;module&gt;)<br/>        1    0.000    0.000    0.000    0.000 StringIO.py:30(&lt;module&gt;)<br/>        1    0.000    0.000    0.000    0.000 StringIO.py:42(StringIO)</p>&#13;
<p class="listing1"><a id="ch10list2"/><em>Listing 10-2: Default output of <span class="codeitalic">cProfile</span> used against a Python script</em></p>&#13;
<p class="indent"><a href="ch10.xhtml#ch10list2">Listing 10-2</a> shows the output of running a simple script with <span class="literal">cProfile</span>. This tells you the number of times each function in the program was called and the time spent on its execution. You can also use the <span class="literal">-s</span> option to sort by other fields; for example, <span class="literal">-s time</span> would sort the results by internal time.</p>&#13;
<p class="indent">We can visualize the information generated by <span class="literal">cProfile</span> using a great tool called KCacheGrind. This tool was created to deal with programs written in C, but luckily we can use it with Python data by converting the data to a call tree.</p>&#13;
<p class="indent">The <span class="literal">cProfile</span> module has an <span class="literal">-o</span> option that allows you to save the profiling data, and <span class="literal">pyprof2calltree</span> can convert data from one format to the other. First, install the converter with the following:</p>&#13;
<p class="programs">$ <span class="codestrong1">pip install pyprof2calltree</span></p>&#13;
<p class="indent">Then run the converter as shown in <a href="ch10.xhtml#ch10list3">Listing 10-3</a> to both convert the data (<span class="literal">-i</span> option) and run KCacheGrind with the converted data (<span class="literal">-k</span> option).</p>&#13;
<p class="programs">$ <span class="codestrong1">python -m cProfile -o myscript.cprof myscript.py</span><br/>$ <span class="codestrong1">pyprof2calltree -k -i myscript.cprof</span></p>&#13;
<p class="listing1"><a id="ch10list3"/><em>Listing 10-3: Running <span class="codeitalic">cProfile</span> and launching KCacheGrind</em></p>&#13;
<p class="indent">Once KCacheGrind opens, it will display information that looks like that in <a href="ch10.xhtml#ch10fig1">Figure 10-1</a>. With these visual results, you can use the call graph to follow the percentage of time spent in each function, allowing you to determine what part of your program might be consuming too many resources.</p>&#13;
<p class="indent">The easiest way to read KCacheGrind is to start with the table on the left of the screen, which lists all the functions and methods executed by your program. You can sort these by execution time, then identify the one that consumes the most CPU time and click on it.</p>&#13;
<p class="indent">The right panels of KCacheGrind can show you which functions have called that function and how many times, as well as which other functions are being called by the function. The call graph of your program, including the execution time of each part, is easy to navigate.</p>&#13;
<p class="indent">This should allow you to better understand which parts of your code might need optimization. The way to optimize the code is up to you and depends on what your program is trying to achieve!</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_156"/><a id="ch10fig1"/><img alt="image" src="../images/f10-01.jpg"/></div>&#13;
<p class="figcap"><em>Figure 10-1: Example of KCacheGrind output</em></p>&#13;
<p class="indent">While retrieving information about how your program runs and visualizing it works well to get a macroscopic view of your program, you might need a more microscopic view of some parts of the code to inspect its elements more closely. In such a case, I find it better to rely on the <span class="literal">dis</span> module to find out what’s going on behind the scenes.</p>&#13;
<h4 class="h4" id="lev2sec59"><strong><em>Disassembling with the dis Module</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">dis</span> module is a disassembler of Python bytecode. Taking code apart can be useful to understand what’s going on behind each line so you can properly optimize it. For example, <a href="ch10.xhtml#ch10list4">Listing 10-4</a> shows the <span class="literal">dis.dis()</span> function, which disassembles whichever function you pass as a parameter and prints the list of bytecode instructions that are run by the function.</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">def x():</span><br/>...     <span class="codestrong1">return 42</span><br/>...<br/>&gt;&gt;&gt; <span class="codestrong1">import dis</span><br/>&gt;&gt;&gt; <span class="codestrong1">dis.dis(x)</span><br/>  2           0 LOAD_CONST               1 (42)<br/>              3 RETURN_VALUE</p>&#13;
<p class="listing1"><a id="ch10list4"/><em>Listing 10-4: Disassembling a function</em></p>&#13;
<p class="indent">In <a href="ch10.xhtml#ch10list4">Listing 10-4</a>, the function <span class="literal">x</span> is disassembled and its constituents, made of bytecode instructions, are printed. There are only two operations here: loading a constant (<span class="literal">LOAD_CONST</span>), which is <span class="literal">42</span>, and returning that value (<span class="literal">RETURN_VALUE</span>).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_157"/>To see <span class="literal">dis</span> in action and how it can be useful, we’ll define two functions that do the same thing—concatenate three letters—and disassemble them to see how they do their tasks in different ways:</p>&#13;
<p class="programs">abc = ('a', 'b', 'c')<br/><br/>def concat_a_1():<br/>    for letter in abc:<br/>            abc[0] + letter<br/><br/>def concat_a_2():<br/>    a = abc[0]<br/>    for letter in abc:<br/>            a + letter</p>&#13;
<p class="indent">Both functions appear to do the same thing, but if we disassemble them using <span class="literal">dis.dis</span>, as shown in <a href="ch10.xhtml#ch10list5">Listing 10-5</a>, we’ll see that the generated bytecode is a bit different.</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">dis.dis(concat_a_1)</span><br/>  2           0 SETUP_LOOP              26 (to 29)<br/>              3 LOAD_GLOBAL              0 (abc)<br/>              6 GET_ITER<br/>        &gt;&gt;    7 FOR_ITER                18 (to 28)<br/>             10 STORE_FAST               0 (letter)<br/><br/>  3          13 LOAD_GLOBAL              0 (abc)<br/>             16 LOAD_CONST               1 (0)<br/>             19 BINARY_SUBSCR<br/>             20 LOAD_FAST                0 (letter)<br/>             23 BINARY_ADD<br/>             24 POP_TOP<br/>             25 JUMP_ABSOLUTE            7<br/>        &gt;&gt;   28 POP_BLOCK<br/>        &gt;&gt;   29 LOAD_CONST               0 (None)<br/>             32 RETURN_VALUE<br/>&gt;&gt;&gt; <span class="codestrong1">dis.dis(concat_a_2)</span><br/>  2           0 LOAD_GLOBAL              0 (abc)<br/>              3 LOAD_CONST               1 (0)<br/>              6 BINARY_SUBSCR<br/>              7 STORE_FAST               0 (a)<br/><br/>  3          10 SETUP_LOOP              22 (to 35)<br/>             13 LOAD_GLOBAL              0 (abc)<br/>             16 GET_ITER<br/>        &gt;&gt;   17 FOR_ITER                14 (to 34)<br/>             20 STORE_FAST               1 (letter)<br/><br/>  4          23 LOAD_FAST                0 (a)<br/>             26 LOAD_FAST                1 (letter)<br/>             29 BINARY_ADD<br/>             30 POP_TOP<br/>             31 JUMP_ABSOLUTE           17<br/>        &gt;&gt;   34 POP_BLOCK<span epub:type="pagebreak" id="page_158"/><br/>        &gt;&gt;   35 LOAD_CONST               0 (None)<br/>             38 RETURN_VALUE</p>&#13;
<p class="listing1"><a id="ch10list5"/><em>Listing 10-5: Disassembling functions that concatenate strings</em></p>&#13;
<p class="indent">In the second function in <a href="ch10.xhtml#ch10list5">Listing 10-5</a>, we store <span class="literal">abc[0]</span> in a temporary variable before running the loop. This makes the bytecode that’s executed inside the loop a little smaller than the bytecode for the first function, as we avoid having to do the <span class="literal">abc[0]</span> lookup for each iteration. Measured using <span class="literal">timeit</span>, the second version is 10 percent faster than the first function; it takes a whole microsecond less to execute! Obviously this microsecond is not worth optimizing for unless you call this function billions of times, but this is the kind of insight that the <span class="literal">dis</span> module can provide.</p>&#13;
<p class="indent">Whether you rely on “tricks” such as storing the value outside the loop depends on the situation—ultimately, it should be the compiler’s work to optimize this kind of thing. On the other hand, it’s difficult for the compiler to be sure that optimization wouldn’t have negative side effects because Python is heavily dynamic. In <a href="ch10.xhtml#ch10list5">Listing 10-5</a>, using <span class="literal">abc[0]</span> will call <span class="literal">abc.__getitem__</span>, which could have side effects if it has been overridden by inheritance. Depending on the version of the function you use, the <span class="literal">abc.__getitem__</span> method will be called once or several times, which might make a difference. Therefore, be careful when writing and optimizing your code!</p>&#13;
<h3 class="h3" id="lev1sec53"><strong>Defining Functions Efficiently</strong></h3>&#13;
<p class="noindent">One common mistake I have found when reviewing code is definitions of functions within functions. This is inefficient because the function is then redefined repeatedly and needlessly. For example, <a href="ch10.xhtml#ch10list6">Listing 10-6</a> shows the <span class="literal">y()</span> function being defined multiple times.</p>&#13;
<p class="programs">&gt;&gt; <span class="codestrong1">import dis</span><br/>&gt;&gt;&gt; <span class="codestrong1">def x():</span><br/>...     <span class="codestrong1">return 42</span><br/>...<br/>&gt;&gt;&gt; <span class="codestrong1">dis.dis(x)</span><br/>  2           0 LOAD_CONST               1 (42)<br/>              3 RETURN_VALUE<br/>&gt;&gt;&gt; <span class="codestrong1">def x():</span><br/>...     <span class="codestrong1">def y():</span><br/>...             <span class="codestrong1">return 42</span><br/>...     <span class="codestrong1">return y()</span><br/>...<br/>&gt;&gt;&gt; <span class="codestrong1">dis.dis(x)</span><br/>  2           0 LOAD_CONST               1 (&lt;code object y at<br/>x100ce7e30, file "&lt;stdin&gt;", line 2&gt;)<br/>              3 MAKE_FUNCTION            0<br/>              6 STORE_FAST               0 (y)<br/>  4           9 LOAD_FAST                0 (y)<span epub:type="pagebreak" id="page_159"/><br/>             12 CALL_FUNCTION            0<br/>             15 RETURN_VALUE</p>&#13;
<p class="listing1"><a id="ch10list6"/><em>Listing 10-6: Function redefinition</em></p>&#13;
<p class="indent"><a href="ch10.xhtml#ch10list6">Listing 10-6</a> shows the calling of <span class="literal">MAKE_FUNCTION</span>, <span class="literal">STORE_FAST</span>, <span class="literal">LOAD_FAST</span>, and <span class="literal">CALL_FUNCTION</span>, which requires many more opcodes than those needed to return <span class="literal">42</span>, as seen in <a href="ch10.xhtml#ch10list4">Listing 10-4</a>.</p>&#13;
<p class="indent">The only case in which you’d need to define a function within a function is when building a function closure, and this is a perfectly identified use case in Python’s opcodes with <span class="literal">LOAD_CLOSURE</span>, as shown in <a href="ch10.xhtml#ch10list7">Listing 10-7</a>.</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">def x():</span><br/>...     <span class="codestrong1">a = 42</span><br/>...     <span class="codestrong1">def y():</span><br/>...             <span class="codestrong1">return a</span><br/>...     <span class="codestrong1">return y()</span><br/>...<br/>&gt;&gt;&gt; <span class="codestrong1">dis.dis(x)</span><br/>  2           0 LOAD_CONST               1 (42)<br/>              3 STORE_DEREF              0 (a)<br/><br/>  3           6 LOAD_CLOSURE             0 (a)<br/>              9 BUILD_TUPLE              1<br/>             12 LOAD_CONST               2 (&lt;code object y at<br/>x100d139b0, file "&lt;stdin&gt;", line 3&gt;)<br/>             15 MAKE_CLOSURE             0<br/>             18 STORE_FAST               0 (y)<br/><br/>  5          21 LOAD_FAST                0 (y)<br/>             24 CALL_FUNCTION            0<br/>             27 RETURN_VALUE</p>&#13;
<p class="listing1"><a id="ch10list7"/><em>Listing 10-7: Defining a closure</em></p>&#13;
<p class="indent">While you probably won’t need to use it every day, disassembling code is a handy tool for when you want a closer look at what happens under the hood.</p>&#13;
<h3 class="h3" id="lev1sec54"><strong>Ordered Lists and bisect</strong></h3>&#13;
<p class="noindent">Next, let’s look at optimizing lists. If a list is unsorted, the worst-case scenario for finding a particular item’s position in the list has a complexity of <em>O(n)</em>, meaning that in the worst case, you’ll find your item after iterating over every item of the list.</p>&#13;
<p class="indent">The usual solution for optimizing this problem is to use a <em>sorted</em> list instead. Sorted lists use a bisecting algorithm for lookup to achieve a retrieve time of <em>O(log n)</em>. The idea is to recursively split the list in half and look on which side, left or right, the item must appear in and so which side should be searched next.</p>&#13;
<p class="indent">Python provides the <span class="literal">bisect</span> module, which contains a bisection algorithm, as shown in <a href="ch10.xhtml#ch10list8">Listing 10-8</a>.</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_160"/>&gt;&gt;&gt; <span class="codestrong1">farm = sorted(['haystack', 'needle', 'cow', 'pig'])</span><br/>&gt;&gt;&gt; <span class="codestrong1">bisect.bisect(farm, 'needle')</span><br/>3<br/>&gt;&gt;&gt; <span class="codestrong1">bisect.bisect_left(farm, 'needle')</span><br/>2<br/>&gt;&gt;&gt; <span class="codestrong1">bisect.bisect(farm, 'chicken')</span><br/>0<br/>&gt;&gt;&gt; <span class="codestrong1">bisect.bisect_left(farm, 'chicken')</span><br/>0<br/>&gt;&gt;&gt; <span class="codestrong1">bisect.bisect(farm, 'eggs')</span><br/>1<br/>&gt;&gt;&gt; <span class="codestrong1">bisect.bisect_left(farm, 'eggs')</span><br/>1</p>&#13;
<p class="listing1"><a id="ch10list8"/><em>Listing 10-8: Using <span class="codeitalic">bisect</span> to find a needle in a haystack</em></p>&#13;
<p class="indent">As shown in <a href="ch10.xhtml#ch10list8">Listing 10-8</a>, the <span class="literal">bisect.bisect()</span> function returns the position where an element should be inserted to keep the list sorted. Obviously, this only works if the list is properly sorted to begin with. Initial sorting allows to us get the <em>theoretical</em> index of an item: <span class="literal">bisect()</span> does not return whether the item is in the list but where the item should be if it is in the list. Retrieving the item at this index will answer the question about whether the item is in the list.</p>&#13;
<p class="indent">If you wish to insert the element into the correct sorted position immediately, the <span class="literal">bisect</span> module provides the <span class="literal">insort_left()</span> and <span class="literal">insort_right()</span> functions, as shown in <a href="ch10.xhtml#ch10list9">Listing 10-9</a>.</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">farm</span><br/>['cow', 'haystack', 'needle', 'pig']<br/>&gt;&gt;&gt; <span class="codestrong1">bisect.insort(farm, 'eggs')</span><br/>&gt;&gt;&gt; <span class="codestrong1">farm</span><br/>['cow', 'eggs', 'haystack', 'needle', 'pig']<br/>&gt;&gt;&gt; <span class="codestrong1">bisect.insort(farm, 'turkey')</span><br/>&gt;&gt;&gt; <span class="codestrong1">farm</span><br/>['cow', 'eggs', 'haystack', 'needle', 'pig', 'turkey']</p>&#13;
<p class="listing1"><a id="ch10list9"/><em>Listing 10-9: Inserting an item in a sorted list</em></p>&#13;
<p class="indent">Using the <span class="literal">bisect</span> module, you could also create a special <span class="literal">SortedList</span> class inheriting from <span class="literal">list</span> to create a list that is always sorted, as shown in <a href="ch10.xhtml#ch10list10">Listing 10-10</a>:</p>&#13;
<p class="programs">import bisect<br/>import unittest<br/><br/>class SortedList(list):<br/>    def __init__(self, iterable):<br/>        super(SortedList, self).__init__(sorted(iterable))<br/><br/>    def insort(self, item):<br/>        bisect.insort(self, item)<span epub:type="pagebreak" id="page_161"/><br/>    def extend(self, other):<br/>        for item in other:<br/>            self.insort(item)<br/><br/>    @staticmethod<br/>    def append(o):<br/>        raise RuntimeError("Cannot append to a sorted list")<br/><br/>    def index(self, value, start=None, stop=None):<br/>        place = bisect.bisect_left(self[start:stop], value)<br/>        if start:<br/>            place += start<br/>        end = stop or len(self)<br/>        if place &lt; end and self[place] == value:<br/>            return place<br/>        raise ValueError("%s is not in list" % value)<br/><br/>class TestSortedList(unittest.TestCase):<br/>    def setUp(self):<br/>        self.mylist = SortedList(<br/>            ['a', 'c', 'd', 'x', 'f', 'g', 'w']<br/>        )<br/><br/>    def test_sorted_init(self):<br/>        self.assertEqual(sorted(['a', 'c', 'd', 'x', 'f', 'g', 'w']),<br/>                         self.mylist)<br/><br/>    def test_sorted_insort(self):<br/>        self.mylist.insort('z')<br/>        self.assertEqual(['a', 'c', 'd', 'f', 'g', 'w', 'x', 'z'],<br/>                         self.mylist)<br/>        self.mylist.insort('b')<br/>        self.assertEqual(['a', 'b', 'c', 'd', 'f', 'g', 'w', 'x', 'z'],<br/>                         self.mylist)<br/><br/>    def test_index(self):<br/>        self.assertEqual(0, self.mylist.index('a'))<br/>        self.assertEqual(1, self.mylist.index('c'))<br/>        self.assertEqual(5, self.mylist.index('w'))<br/>        self.assertEqual(0, self.mylist.index('a', stop=0))<br/>        self.assertEqual(0, self.mylist.index('a', stop=2))<br/>        self.assertEqual(0, self.mylist.index('a', stop=20))<br/>        self.assertRaises(ValueError, self.mylist.index, 'w', stop=3)<br/>        self.assertRaises(ValueError, self.mylist.index, 'a', start=3)<br/>        self.assertRaises(ValueError, self.mylist.index, 'a', start=333)<br/><br/>    def test_extend(self):<br/>        self.mylist.extend(['b', 'h', 'j', 'c'])<br/>        self.assertEqual(<br/>            ['a', 'b', 'c', 'c', 'd', 'f', 'g', 'h', 'j', 'w', 'x']<br/>            self.mylist)</p>&#13;
<p class="listing1"><a id="ch10list10"/><em>Listing 10-10: A <span class="codeitalic">SortedList</span> object implementation</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_162"/>Using a <span class="literal">list</span> class like this is slightly slower when it comes to inserting the item, because the program has to look for the right spot to insert it. However, this class is faster at using the <span class="literal">index()</span> method than its parent. Obviously, one shouldn’t use the <span class="literal">list.append()</span> method on this class: you can’t append an item at the end of the list or it could end up unsorted!</p>&#13;
<p class="indent">Many Python libraries implement various versions of <a href="ch10.xhtml#ch10list10">Listing 10-10</a> for many more data types, such as binary or red-black tree structures. The <span class="literal">blist</span> and <span class="literal">bintree</span> Python packages contain code that can be used for these purposes and are a handy alternative to implementing and debugging your own version.</p>&#13;
<p class="indent">In the next section, we’ll see how the native tuple data type provided by Python can be leveraged to make your Python code a little faster.</p>&#13;
<h3 class="h3" id="lev1sec55"><strong>namedtuple and Slots</strong></h3>&#13;
<p class="noindent">Often in programming, you’ll need to create simple objects that possess only a few fixed attributes. A simple implementation might be something along these lines:</p>&#13;
<p class="programs">class Point(object):<br/>    def __init__(self, x, y):<br/>        self.x = x<br/>        self.y = y</p>&#13;
<p class="indent">This definitely gets the job done. However, there is a downside to this approach. Here we’re creating a class that inherits from the object class, so by using this <span class="literal">Point</span> class, you are instantiating full objects and allocating a lot of memory.</p>&#13;
<p class="indent">In Python, regular objects store all of their attributes inside a dictionary, and this dictionary is itself stored in the <span class="literal">__dict__</span> attribute, as shown in <a href="ch10.xhtml#ch10list11">Listing 10-11</a>.</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">p = Point(1, 2)</span><br/>&gt;&gt;&gt; <span class="codestrong1">p.__dict__</span><br/>{'y': 2, 'x': 1}<br/>&gt;&gt;&gt; <span class="codestrong1">p.z = 42</span><br/>&gt;&gt;&gt; <span class="codestrong1">p.z</span><br/>42<br/>&gt;&gt;&gt; <span class="codestrong1">p.__dict__</span><br/>{'y': 2, 'x': 1, 'z': 42}</p>&#13;
<p class="listing1"><a id="ch10list11"/><em>Listing 10-11: How attributes are stored internally in a Python object</em></p>&#13;
<p class="indent">For Python, the advantage of using a <span class="literal">dict</span> is that it allows you to add as many attributes as you want to an object. The drawback is that using a dictionary to store these attributes is expensive in terms of memory—you need to store the object, the keys, the value references, and everything else. That makes it slow to create and slow to manipulate, with a high memory cost.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_163"/>As an example of this unnecessary memory usage, consider the following simple class:</p>&#13;
<p class="programs">class Foobar(object):<br/>    def __init__(self, x):<br/>        self.x = x</p>&#13;
<p class="indent">This creates a simple <span class="literal">Point</span> object with a single attribute named <span class="literal">x</span>. Let’s check the memory usage of this class using the <span class="literal">memory_profiler</span>, a nice Python package that allows us to see the memory usage of a program line by line, and a small script that creates 100,000 objects, as shown in <a href="ch10.xhtml#ch10list12">Listing 10-12</a>.</p>&#13;
<p class="programs">$ <span class="codestrong1">python -m memory_profiler object.py</span><br/>Filename: object.py<br/><br/>Line #    Mem usage    Increment   Line Contents<br/>     5                             @profile<br/>     6     9.879 MB     0.000 MB   def main():<br/>     7    50.289 MB    40.410 MB       f = [ Foobar(42) for i in range(100000) ]</p>&#13;
<p class="listing1"><a id="ch10list12"/><em>Listing 10-12: Using <span class="codeitalic">memory_profiler</span> on a script using objects</em></p>&#13;
<p class="indent"><a href="ch10.xhtml#ch10list12">Listing 10-12</a> demonstrates that creating 100,000 of the objects of the <span class="literal">Foobar</span> class would consume 40MB of memory. Although 400 bytes per object might not sound that big, when you are creating thousands of objects, the memory adds up.</p>&#13;
<p class="indent">There is a way to use objects while avoiding this default behavior of <span class="literal">dict</span>: classes in Python can define a <span class="literal">__slots__</span> attribute that will list only the attributes allowed for instances of this class. Instead of allocating a whole dictionary object to store the object attributes, you can use a <em>list</em> object to store them.</p>&#13;
<p class="indent">If you go through CPython source code and take a look at the <em>Objects/typeobject.c</em> file, it is quite easy to understand what Python does when <span class="literal">__slots__</span> is set on a class. <a href="ch10.xhtml#ch10list13">Listing 10-13</a> is an abbreviated version of the function that handles this:</p>&#13;
<p class="programs">static PyObject *<br/>type_new(PyTypeObject *metatype, PyObject *args, PyObject *kwds)<br/>{<br/>    --<span class="codeitalic1">snip</span>--<br/>    /* Check for a __slots__ sequence variable in dict, and count it */<br/>    slots = _PyDict_GetItemId(dict, &amp;PyId___slots__);<br/>    nslots = 0;<br/>    if (slots == NULL) {<br/>        if (may_add_dict)<br/>            add_dict++;<br/>        if (may_add_weak)<br/>            add_weak++;<br/>    }<span epub:type="pagebreak" id="page_164"/><br/>    else {<br/>        /* Have slots */<br/>        /* Make it into a tuple */<br/>        if (PyUnicode_Check(slots))<br/>            slots = PyTuple_Pack(1, slots);<br/>        else<br/>            slots = PySequence_Tuple(slots);<br/>        /* Are slots allowed? */<br/>        nslots = PyTuple_GET_SIZE(slots);<br/>        if (nslots &gt; 0 &amp;&amp; base-&gt;tp_itemsize != 0) {<br/>            PyErr_Format(PyExc_TypeError,<br/>                         "nonempty __slots__ "<br/>                         "not supported for subtype of '%s'",<br/>                         base-&gt;tp_name);<br/>            goto error;<br/>        }<br/>        /* Copy slots into a list, mangle names and sort them.<br/>           Sorted names are needed for __class__ assignment.<br/>           Convert them back to tuple at the end.<br/>        */<br/>        newslots = PyList_New(nslots - add_dict - add_weak);<br/>        if (newslots == NULL)<br/>            goto error;<br/>        if (PyList_Sort(newslots) == -1) {<br/>            Py_DECREF(newslots);<br/>            goto error;<br/>        }<br/>        slots = PyList_AsTuple(newslots);<br/>        Py_DECREF(newslots);<br/>        if (slots == NULL)<br/>            goto error;<br/>    }<br/>    /* Allocate the type object */<br/>    type = (PyTypeObject *)metatype-&gt;tp_alloc(metatype, nslots);<br/>    --<span class="codeitalic1">snip</span>--<br/>    /* Keep name and slots alive in the extended type object */<br/>    et = (PyHeapTypeObject *)type;<br/>    Py_INCREF(name);<br/>    et-&gt;ht_name = name;<br/>    et-&gt;ht_slots = slots;<br/>    slots = NULL;<br/>    --<span class="codeitalic1">snip</span>--<br/>    return (PyObject *)type;</p>&#13;
<p class="listing1"><a id="ch10list13"/><em>Listing 10-13: An extract from <span class="roman">Objects/typeobject.c</span></em></p>&#13;
<p class="indent">As you can see in <a href="ch10.xhtml#ch10list13">Listing 10-13</a>, Python converts the content of <span class="literal">__slots__</span> into a tuple and then into a list, which it builds and sorts before converting the list back into a tuple to use and store in the class. In this way, Python can retrieve the values quickly, without having to allocate and use an entire dictionary.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_165"/>It’s easy enough to declare and use such a class. All you need to do is to set the <span class="literal">__slots__</span> attribute to a list of the attributes that will be defined in the class:</p>&#13;
<p class="programs">class Foobar(object):<br/>    __slots__ = ('x',)<br/><br/>    def __init__(self, x):<br/>        self.x = x</p>&#13;
<p class="indent">We can compare the memory usage of the two approaches using the <span class="literal">memory_profiler</span> Python package, as shown in <a href="ch10.xhtml#ch10list14">Listing 10-14</a>.</p>&#13;
<p class="programs">% <span class="codestrong1">python -m memory_profiler slots.py</span><br/>Filename: slots.py<br/><br/>Line #    Mem usage    Increment   Line Contents<br/>     7                             @profile<br/>     8     9.879 MB     0.000 MB   def main():<br/>     9    21.609 MB    11.730 MB       f = [ Foobar(42) for i in range(100000) ]</p>&#13;
<p class="listing1"><a id="ch10list14"/><em>Listing 10-14: Running <span class="codeitalic">memory_profiler</span> on the script using <span class="codeitalic">__slots__</span></em></p>&#13;
<p class="indent"><a href="ch10.xhtml#ch10list14">Listing 10-14</a> shows that this time, less than 12MB of memory was needed to create 100,000 objects—or fewer than 120 bytes per object. Thus, by using the <span class="literal">__slots__</span> attribute of Python classes, we can reduce memory usage, so when we are creating a large number of simple objects, the <span class="literal">__slots__</span> attribute is an effective and efficient choice. However, this technique shouldn’t be used for performing static typing by hardcoding the list of attributes of every class: doing so wouldn’t be in the spirit of Python programs.</p>&#13;
<p class="indent">The drawback here is that the list of attributes is now fixed. No new attribute can be added to the <span class="literal">Foobar</span> class at runtime. Due to the fixed nature of the attribute list, it’s easy enough to imagine classes where the attributes listed would always have a value and where the fields would always be sorted in some way.</p>&#13;
<p class="indent">This is exactly what occurs in the <span class="literal">namedtuple</span> class from the <span class="literal">collection</span> module. This <span class="literal">namedtuple</span> class allows us to dynamically create a class that will inherit from the tuple class, thus sharing characteristics such as being immutable and having a fixed number of entries.</p>&#13;
<p class="indent">Rather than having to reference them by index, <span class="literal">namedtuple</span> provides the ability to retrieve tuple elements by referencing a named attribute. This makes the tuple easier to access for humans, as shown in <a href="ch10.xhtml#ch10list15">Listing 10-15</a>.</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">import collections</span><br/>&gt;&gt;&gt; <span class="codestrong1">Foobar = collections.namedtuple('Foobar', ['x'])</span><br/>&gt;&gt;&gt; <span class="codestrong1">Foobar = collections.namedtuple('Foobar', ['x', 'y'])</span><br/>&gt;&gt;&gt; <span class="codestrong1">Foobar(42, 43)</span><span epub:type="pagebreak" id="page_166"/><br/>Foobar(x=42, y=43)<br/>&gt;&gt;&gt; <span class="codestrong1">Foobar(42, 43).x</span><br/>42<br/>&gt;&gt;&gt; <span class="codestrong1">Foobar(42, 43).x = 44</span><br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>AttributeError: can't set attribute<br/>&gt;&gt;&gt; <span class="codestrong1">Foobar(42, 43).z = 0</span><br/>Traceback (most recent call last):<br/>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br/>AttributeError: 'Foobar' object has no attribute 'z'<br/>&gt;&gt;&gt; <span class="codestrong1">list(Foobar(42, 43)</span>)<br/>[42, 43]</p>&#13;
<p class="listing1"><a id="ch10list15"/><em>Listing 10-15: Using <span class="codeitalic">namedtuple</span> to reference tuple elements</em></p>&#13;
<p class="indent"><a href="ch10.xhtml#ch10list15">Listing 10-15</a> shows how you can create a simple class with just one line of code and then instantiate it. We can’t change any attributes of objects of this class or add attributes to them, both because the class inherits from <span class="literal">namedtuple</span> and because the <span class="literal">__slots__</span> value is set to an empty tuple, avoiding the creation of the <span class="literal">__dict__</span>. Since a class like this would inherit from tuple, we can easily convert it to a list.</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch10list16">Listing 10-16</a> demonstrates the memory usage of the <span class="literal">namedtuple</span> class factory.</p>&#13;
<p class="programs">% <span class="codestrong1">python -m memory_profiler namedtuple.py</span><br/>Filename: namedtuple.py<br/><br/>Line #    Mem usage    Increment   Line Contents<br/>     4                             @profile<br/>     5     9.895 MB     0.000 MB   def main():<br/>     6    23.184 MB    13.289 MB       f = [ Foobar(42) for i in range(100000) ]</p>&#13;
<p class="listing1"><a id="ch10list16"/><em>Listing 10-16: Using <span class="codeitalic">namedtuple</span> to run <span class="codeitalic">memory_profiler</span> on a script</em></p>&#13;
<p class="indent">At around 13MB for 100,000 objects, using <span class="literal">namedtuple</span> is slightly less efficient than using an object with <span class="literal">__slots__</span>, but the bonus is that it is compatible with the tuple class. It can therefore be passed to many native Python functions and libraries that expect an iterable as an argument. A <span class="literal">namedtuple</span> class factory also enjoys the various optimizations that exist for tuples: for example, tuples with fewer items than <span class="literal">PyTuple_MAXSAVESIZE</span> (20 by default) will use a faster memory allocator in CPython.</p>&#13;
<p class="indent">The <span class="literal">namedtuple</span> class also provides a few extra methods that, even if prefixed by an underscore, are actually intended to be public. The <span class="literal">_asdict()</span> method can convert the <span class="literal">namedtuple</span> to a <span class="literal">dict</span> instance, the <span class="literal">_make()</span> method allows you to convert an existing iterable object to this class, and <span class="literal">_replace()</span> returns a new instance of the object with some fields replaced.</p>&#13;
<p class="indent">Named tuples are a great replacement for small objects that consists of only a few attributes and do not require any custom methods—consider using them rather than dictionaries, for example. If your data type needs <span epub:type="pagebreak" id="page_167"/>methods, has a fixed list of attributes, and might be instantiated thousands of times, then creating a custom class using <span class="literal">__slots__</span> might be a good idea to save some memory.</p>&#13;
<h3 class="h3" id="lev1sec56"><strong>Memoization</strong></h3>&#13;
<p class="noindent"><em>Memoization</em> is an optimization technique used to speed up function calls by caching their results. The results of a function can be cached only if the function is <em>pure</em>, meaning that it has no side effects and does not depend on any global state. (See <a href="ch08.xhtml#ch08">Chapter 8</a> for more on pure functions.)</p>&#13;
<p class="indent">One trivial function that can be memoized is <span class="literal">sin()</span>, shown in <a href="ch10.xhtml#ch10list17">Listing 10-17</a>.</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">import math</span><br/>&gt;&gt;&gt; <span class="codestrong1">_SIN_MEMOIZED_VALUES = {}</span><br/>&gt;&gt;&gt; <span class="codestrong1">def memoized_sin(x):</span><br/>...    <span class="codestrong1">if x not in _SIN_MEMOIZED_VALUES:</span><br/>...        <span class="codestrong1">_SIN_MEMOIZED_VALUES[x] = math.sin(x)</span><br/>...    <span class="codestrong1">return _SIN_MEMOIZED_VALUES[x]</span><br/>&gt;&gt;&gt; <span class="codestrong1">memoized_sin(1)</span><br/>0.8414709848078965<br/>&gt;&gt;&gt; <span class="codestrong1">_SIN_MEMOIZED_VALUES</span><br/>{1: 0.8414709848078965}<br/>&gt;&gt;&gt; <span class="codestrong1">memoized_sin(2)</span><br/><span class="codestrong1">0.</span>9092974268256817<br/>&gt;&gt;&gt; <span class="codestrong1">memoized_sin(2)</span><br/>0.9092974268256817<br/>&gt;&gt;&gt; <span class="codestrong1">_SIN_MEMOIZED_VALUES</span><br/>{1: 0.8414709848078965, 2: 0.9092974268256817}<br/>&gt;&gt;&gt; <span class="codestrong1">memoized_sin(1)</span><br/>0.8414709848078965<br/>&gt;&gt;&gt; <span class="codestrong1">_SIN_MEMOIZED_VALUES</span><br/>{1: 0.8414709848078965, 2: 0.9092974268256817}</p>&#13;
<p class="listing1"><a id="ch10list17"/><em>Listing 10-17: A memoized <span class="codeitalic">sin()</span> function</em></p>&#13;
<p class="indent">In <a href="ch10.xhtml#ch10list17">Listing 10-17</a>, the first time that <span class="literal">memoized_sin()</span> is called with an argument that is not stored in <span class="literal">_SIN_MEMOIZED_VALUES</span>, the value is computed and stored in this dictionary. If we call the function with the same value again, the result will be retrieved from the dictionary rather than recomputed. While <span class="literal">sin()</span> computes very quickly, some advanced functions involving more complicated computations may take longer, and this is where memoization really shines.</p>&#13;
<p class="indent">If you’ve already read about decorators (if not, see “<a href="ch07.xhtml#lev1sec34">Decorators and When to Use Them</a>” on <a href="ch07.xhtml#page_100">page 100</a>), you might see a perfect opportunity to use them here, and you’d be right. PyPI lists a few implementations of memoization through decorators, from very simple cases to the most complex and complete.</p>&#13;
<p class="indent">Starting with Python 3.3, the <span class="literal">functools</span> module provides a <em>least recently used (LRU)</em> cache decorator. This provides the same functionality as memoization, but with the benefit that it limits the number of entries in <span epub:type="pagebreak" id="page_168"/>the cache, removing the least recently used one when the cache reaches its maximum size. The module also provides statistics on cache hits and misses (whether something was in the accessed cache or not), among other data. In my opinion, these statistics are must-haves when implementing such a cache. The strength of using memoization, or any caching technique, is in the ability to meter its usage and usefulness.</p>&#13;
<p class="indent"><a href="ch10.xhtml#ch10list18">Listing 10-18</a> demonstrates how to use the <span class="literal">functools.lru_cache()</span> method to implement the memoization of a function. When decorated, the function gets a <span class="literal">cache_info()</span> method that can be called to get statistics about the cache usage.</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">import functools</span><br/>&gt;&gt;&gt; <span class="codestrong1">import math</span><br/>&gt;&gt;&gt; <span class="codestrong1">@functools.lru_cache(maxsize=2)</span><br/>... <span class="codestrong1">def memoized_sin(x):</span><br/>...     <span class="codestrong1">return math.sin(x)</span><br/>...<br/>&gt;&gt;&gt; <span class="codestrong1">memoized_sin(2)</span><br/>0.9092974268256817<br/>&gt;&gt;&gt; <span class="codestrong1">memoized_sin.cache_info()</span><br/>CacheInfo(hits=0, misses=1, maxsize=2, currsize=1)<br/>&gt;&gt;&gt; <span class="codestrong1">memoized_sin(2)</span><br/>0.9092974268256817<br/>&gt;&gt;&gt; <span class="codestrong1">memoized_sin.cache_info()</span><br/>CacheInfo(hits=1, misses=1, maxsize=2, currsize=1)<br/>&gt;&gt;&gt; <span class="codestrong1">memoized_sin(3)</span><br/>0.1411200080598672<br/>&gt;&gt;&gt; <span class="codestrong1">memoized_sin.cache_info()</span><br/>CacheInfo(hits=1, misses=2, maxsize=2, currsize=2)<br/>&gt;&gt;&gt; <span class="codestrong1">memoized_sin(4)</span><br/>-0.7568024953079282<br/>&gt;&gt;&gt; <span class="codestrong1">memoized_sin.cache_info()</span><br/>CacheInfo(hits=1, misses=3, maxsize=2, currsize=2)<br/>&gt;&gt;&gt; <span class="codestrong1">memoized_sin(3)</span><br/>0.1411200080598672<br/>&gt;&gt;&gt; <span class="codestrong1">memoized_sin.cache_info()</span><br/>CacheInfo(hits=2, misses=3, maxsize=2, currsize=2)<br/>&gt;&gt;&gt; <span class="codestrong1">memoized_sin.cache_clear()</span><br/>&gt;&gt;&gt; <span class="codestrong1">memoized_sin.cache_info()</span><br/>CacheInfo(hits=0, misses=0, maxsize=2, currsize=0)</p>&#13;
<p class="listing1"><a id="ch10list18"/><em>Listing 10-18: Inspecting cache statistics</em></p>&#13;
<p class="indent"><a href="ch10.xhtml#ch10list18">Listing 10-18</a> demonstrates how your cache is being used and how to tell whether there are optimizations to be made. For example, if the number of misses is high when the cache is not full, then the cache may be useless because the arguments passed to the function are never identical. This will help determine what should or should not be memoized!</p>&#13;
<h3 class="h3" id="lev1sec57"><span epub:type="pagebreak" id="page_169"/><strong>Faster Python with PyPy</strong></h3>&#13;
<p class="noindent"><em>PyPy</em> is an efficient implementation of the Python language that complies with standards: you should be able to run any Python program with it. Indeed, the canonical implementation of Python, CPython—so called because it’s written in C—can be very slow. The idea behind PyPy was to write a Python interpreter in Python itself. In time, it evolved to be written in RPython, which is a restricted subset of the Python language.</p>&#13;
<p class="indent">RPython places constraints on the Python language such that a variable’s type can be inferred at compile time. The RPython code is translated into C code, which is compiled to build the interpreter. RPython could of course be used to implement languages other than Python.</p>&#13;
<p class="indent">What’s interesting in PyPy, besides the technical challenge, is that it is now at a stage where it can act as a faster replacement for CPython. PyPy has a <em>just-in-time (JIT)</em> compiler built-in; in other words, it allows the code to run faster by combining the speed of compiled code with the flexibility of interpretation.</p>&#13;
<p class="indent">How fast? That depends, but for pure algorithmic code, it is much faster. For more general code, PyPy claims to achieve three times the speed of CPython most of the time. Unfortunately, PyPy also has some of the limitations of CPython, including the <em>global interpreter lock (GIL)</em>, which allows only one thread to execute at a time.</p>&#13;
<p class="indent">Though it’s not strictly an optimization technique, targeting PyPy as one of your supported Python implementations might be a good idea. To make PyPy a support implementation, you need to make sure that you are testing your software under PyPy as you would under CPython. In <a href="ch06.xhtml#ch06">Chapter 6</a>, we discussed <span class="literal">tox</span> (see “Using <span class="literal">virtualenv</span> with <span class="literal">tox</span>” on <a href="ch06.xhtml#page_92">page 92</a>), which supports the building of virtual environments using PyPy, just as it does for any version of CPython, so putting PyPy support in place should be pretty straightforward.</p>&#13;
<p class="indent">Testing PyPy support right at the beginning of the project will ensure that there’s not too much work to do at a later stage if you decide that you want to be able to run your software with PyPy.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>For the Hy project discussed in <a href="ch09.xhtml#ch09">Chapter 9</a>, we successfully adopted this strategy from the beginning. Hy always has supported PyPy and all other CPython versions without much trouble. On the other hand, OpenStack failed to do so for its projects and, as a result, is now blocked by various code paths and dependencies that don’t work on PyPy for various reasons; they weren’t required to be fully tested in the early stages.</em></p>&#13;
</div>&#13;
<p class="indent">PyPy is compatible with Python 2.7 and Python 3.5, and its JIT compiler works on 32- and 64-bit, x86, and ARM architectures and under various operating systems (Linux, Windows, and Mac OS X). PyPy often lags behind CPython in features, but it regularly catches up. Unless your project is reliant on the latest CPython features, this lag might not be a problem.</p>&#13;
<h3 class="h3" id="lev1sec58"><span epub:type="pagebreak" id="page_170"/><strong>Achieving Zero Copy with the Buffer Protocol</strong></h3>&#13;
<p class="noindent">Often programs have to deal with huge amounts of data in the form of large arrays of bytes. Handling such a large quantity of input in strings can be very ineffective once you start manipulating the data by copying, slicing, and modifying it.</p>&#13;
<p class="indent">Let’s consider a small program that reads a large file of binary data and copies it partially into another file. To examine the memory usage of this program, we will use <span class="literal">memory_profiler</span>, as we did earlier. The script to partially copy the file is shown in <a href="ch10.xhtml#ch10list19">Listing 10-19</a>.</p>&#13;
<p class="programs">@profile<br/>def read_random():<br/>    with open("/dev/urandom", "rb") as source:<br/>        content = source.read(1024 * 10000)<br/>        content_to_write = content[1024:]<br/>    print("Content length: %d, content to write length %d" %<br/>          (len(content), len(content_to_write)))<br/>    with open("/dev/null", "wb") as target:<br/>        target.write(content_to_write)<br/><br/>if __name__ == '__main__':<br/>    read_random()</p>&#13;
<p class="listing1"><a id="ch10list19"/><em>Listing 10-19: Partially copying a file</em></p>&#13;
<p class="indent">Running the program in <a href="ch10.xhtml#ch10list19">Listing 10-19</a> using <span class="literal">memory_profiler</span> produces the output shown in <a href="ch10.xhtml#ch10list20">Listing 10-20</a>.</p>&#13;
<p class="programs">$ <span class="codestrong1">python -m memory_profiler memoryview/copy.py</span><br/>Content length: 10240000, content to write length 10238976<br/>Filename: memoryview/copy.py<br/><br/>Mem usage    Increment   Line Contents<br/>                         @profile<br/> 9.883 MB     0.000 MB   def read_random():<br/> 9.887 MB     0.004 MB       with open("/dev/urandom", "rb") as source:<br/>19.656 MB     9.770 MB           content = source.read(1024 * 10000)<span class="ent">➊</span><br/>29.422 MB     9.766 MB           content_to_write = content[1024:]<span class="ent">➋</span><br/>29.422 MB     0.000 MB       print("Content length: %d, content to write length %d" %<br/>29.434 MB     0.012 MB             (len(content), len(content_to_write)))<br/>29.434 MB     0.000 MB       with open("/dev/null", "wb") as target:<br/>29.434 MB     0.000 MB           target.write(content_to_write)</p>&#13;
<p class="listing1"><a id="ch10list20"/><em>Listing 10-20: Memory profiling of partial file copy</em></p>&#13;
<p class="indent">According to the output, the program reads 10MB from <em>_/dev/urandom</em> <span class="ent">➊</span>. Python needs to allocate around 10MB of memory to store this data as a string. It then copies the entire block of data, minus the first KB <span class="ent">➋</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_171"/>What’s interesting in <a href="ch10.xhtml#ch10list20">Listing 10-20</a> is that the program’s memory usage is increased by about 10MB when building the variable <span class="literal">content_to_write</span>. In fact, the <span class="literal">slice</span> operator is copying the entirety of content, minus the first KB, into a new string object, allocating a large chunk of the 10MB.</p>&#13;
<p class="indent">Performing this kind of operation on large byte arrays is going to be a disaster since large pieces of memory will be allocated and copied. If you have experience writing in C code, you know that using the <span class="literal">memcpy()</span> function has a significant cost in terms of both memory usage and general performance.</p>&#13;
<p class="indent">But as a C programmer, you’ll also know that strings are arrays of characters and that nothing stops you from looking at only <em>part</em> of an array without copying it. You can do this through the use of basic pointer arithmetic, assuming that the entire string is in a contiguous memory area.</p>&#13;
<p class="indent">This is also possible in Python using objects that implement the <em>buffer protocol</em>. The buffer protocol is defined in PEP 3118, as a C API that needs to be implemented on various types for them to provide this protocol. The <span class="literal">string</span> class, for example, implements this protocol.</p>&#13;
<p class="indent">When you implement this protocol on an object, you can then use the <span class="literal">memoryview</span> class constructor to build a new <span class="literal">memoryview</span> object that will reference the original object memory. For example, <a href="ch10.xhtml#ch10list21">Listing 10-21</a> shows how to use <span class="literal">memoryview</span> to access slice of a string without doing any copying:</p>&#13;
<p class="programs">   &gt;&gt;&gt; <span class="codestrong1">s = b"abcdefgh"</span><br/>   &gt;&gt;&gt; <span class="codestrong1">view = memoryview(s)</span><br/>   &gt;&gt;&gt; <span class="codestrong1">view[1]</span><br/><span class="ent">➊</span> 98 &lt;1&gt;<br/>   &gt;&gt;&gt; <span class="codestrong1">limited = view[1:3]</span><br/>   &gt;&gt;&gt; <span class="codestrong1">limited</span><br/>   &lt;memory at 0x7fca18b8d460&gt;<br/>   &gt;&gt;&gt; <span class="codestrong1">bytes(view[1:3])</span><br/>   b'bc'</p>&#13;
<p class="listing1"><a id="ch10list21"/><em>Listing 10-21: Using <span class="codeitalic">memoryview</span> to avoid copying data</em></p>&#13;
<p class="indent">At <span class="ent">➊</span>, you find the ASCII code for the letter <em>b</em>. In <a href="ch10.xhtml#ch10list21">Listing 10-21</a>, we are making use of the fact that the <span class="literal">memoryview</span> object’s <span class="literal">slice</span> operator itself returns a <span class="literal">memoryview</span> object. That means it does <em>not</em> copy any data but merely references a particular slice of it, saving the memory that would be used by a copy. <a href="ch10.xhtml#ch10fig2">Figure 10-2</a> illustrates what happens in <a href="ch10.xhtml#ch10list21">Listing 10-21</a>.</p>&#13;
<div class="image"><a id="ch10fig2"/><img alt="image" src="../images/f10-02.jpg"/></div>&#13;
<p class="figcap"><em>Figure 10-2: Using <span class="codeitalic">slice</span> on <span class="codeitalic">memoryview</span> objects</em></p>&#13;
<p class="indent">We can rewrite the program from <a href="ch10.xhtml#ch10list19">Listing 10-19</a>, this time referencing the data we want to write using a <span class="literal">memoryview</span> object rather than allocating a new string.</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_172"/>@profile<br/>def read_random():<br/>    with open("/dev/urandom", "rb") as source:<br/>        content = source.read(1024 * 10000)<br/>        content_to_write = memoryview(content)[1024:]<br/>    print("Content length: %d, content to write length %d" %<br/>          (len(content), len(content_to_write)))<br/>    with open("/dev/null", "wb") as target:<br/>        target.write(content_to_write)<br/><br/>if __name__ == '__main__':<br/>    read_random()</p>&#13;
<p class="listing1"><a id="ch10list22"/><em>Listing 10-22: Partially copying a file using <span class="codeitalic">memoryview</span></em></p>&#13;
<p class="indent">The program in <a href="ch10.xhtml#ch10list22">Listing 10-22</a> uses half the memory of the first version in <a href="ch10.xhtml#ch10list19">Listing 10-19</a>. We can see this by testing it with <span class="literal">memory_profiler</span> again, like so:</p>&#13;
<p class="programs">$ <span class="codestrong1">python -m memory_profiler memoryview/copy-memoryview.py</span><br/>Content length: 10240000, content to write length 10238976<br/>Filename: memoryview/copy-memoryview.py<br/><br/>Mem usage    Increment   Line Contents<br/>                         @profile<br/> 9.887 MB     0.000 MB   def read_random():<br/> 9.891 MB     0.004 MB <span class="ent">➊</span>     with open("/dev/urandom", "rb") as source:<br/>19.660 MB     9.770 MB <span class="ent">➋</span>        content = source.read(1024 * 10000)<br/>19.660 MB     0.000 MB           content_to_write = memoryview(content)[1024:]<br/>19.660 MB     0.000 MB       print("Content length: %d, content to write length %d" %<br/>19.672 MB     0.012 MB             (len(content), len(content_to_write)))<br/>19.672 MB     0.000 MB       with open("/dev/null", "wb") as target:<br/>19.672 MB     0.000 MB           target.write(content_to_write)</p>&#13;
<p class="indent">These results show that we are reading 10,000KB from <em>/dev/urandom</em> and not doing much with it <span class="ent">➊</span>. Python needs to allocate 9.77MB of memory to store this data as a string <span class="ent">➋</span>.</p>&#13;
<p class="indent">We reference the entire block of data minus the first KB, because we won’t be writing that first KB to the target file. Because we aren’t copying, no more memory is used!</p>&#13;
<p class="indent">This kind of trick is especially useful when dealing with sockets. When sending data over a socket, it’s possible that the data might split between calls rather than be sent in a single call: the <span class="literal">socket.send</span> methods return the actual data length that was able to be sent by the network, which might be smaller than the data that was intended to be sent. <a href="ch10.xhtml#ch10list23">Listing 10-23</a> shows how the situation is usually handled.</p>&#13;
<p class="programs">   import socket<br/>   s = socket.socket(...)<br/>   s.connect(...)<br/><span class="ent">➊</span> data = b"a" * (1024 * 100000) &lt;1&gt;<span epub:type="pagebreak" id="page_173"/><br/>   while data:<br/>       sent = s.send(data)<br/>    <span class="ent">➋</span> data = data[sent:] &lt;2&gt;</p>&#13;
<p class="listing1"><a id="ch10list23"/><em>Listing 10-23: Sending data over a socket</em></p>&#13;
<p class="indent">First, we build a <span class="literal">bytes</span> object that contains the letter <em>a</em> more than 100 million times <span class="ent">➊</span>. Then we remove the first <span class="literal">sent</span> bytes <span class="ent">➋</span>.</p>&#13;
<p class="indent">Using a mechanism that implemented in <a href="ch10.xhtml#ch10list23">Listing 10-23</a>, a program will copy the data over and over until the socket has sent everything.</p>&#13;
<p class="indent">We can alter the program in <a href="ch10.xhtml#ch10list23">Listing 10-23</a> to use <span class="literal">memoryview</span> to achieve the same functionality with zero copying, and therefore higher performance, as shown in <a href="ch10.xhtml#ch10list24">Listing 10-24</a>.</p>&#13;
<p class="programs">   import socket<br/>   s = socket.socket(...)<br/>   s.connect(...)<br/><span class="ent">➊</span> data = b"a" * (1024 * 100000) &lt;1&gt;<br/>   mv = memoryview(data)<br/>   while mv:<br/>       sent = s.send(mv)<br/>    <span class="ent">➋</span> mv = mv[sent:] &lt;2&gt;</p>&#13;
<p class="listing1"><a id="ch10list24"/><em>Listing 10-24: Sending data over a socket using <span class="codeitalic">memoryview</span></em></p>&#13;
<p class="indent">First, we build a <span class="literal">bytes</span> object that contains the letter <em>a</em> more than 100 million times <span class="ent">➊</span>. Then, we build a new <span class="literal">memoryview</span> object pointing to the data that remains to be sent, rather than copying that data <span class="ent">➋</span>. This program won’t copy anything, so it won’t use any more memory than the 100MB initially needed for the <span class="literal">data</span> variable.</p>&#13;
<p class="indent">We’ve seen how <span class="literal">memoryview</span> objects can be used to write data efficiently, and this same method can be used to <em>read</em> data. Most I/O operations in Python know how to deal with objects implementing the buffer protocol: they can read from those, and also write to those. In this case, we don’t need <span class="literal">memoryview</span> objects; we can just ask an I/O function to write into our preallocated object, as shown in <a href="ch10.xhtml#ch10list25">Listing 10-25</a>.</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">ba = bytearray(8)</span><br/>&gt;&gt;&gt; <span class="codestrong1">ba</span><br/>bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00')<br/>&gt;&gt;&gt; <span class="codestrong1">with open("/dev/urandom", "rb") as source:</span><br/>...     <span class="codestrong1">source.readinto(ba)</span><br/>...<br/>8<br/>&gt;&gt;&gt; <span class="codestrong1">ba</span><br/>bytearray(b'`m.z\x8d\x0fp\xa1')</p>&#13;
<p class="listing1"><a id="ch10list25"/><em>Listing 10-25: Writing into a preallocated <span class="codeitalic">bytearray</span></em></p>&#13;
<p class="indent">In <a href="ch10.xhtml#ch10list25">Listing 10-25</a>, by using the <span class="literal">readinto()</span> method of the opened file, Python can directly read the data from the file and write it to a <span epub:type="pagebreak" id="page_174"/>preallocated <span class="literal">bytearray</span>. With such techniques, it’s easy to preallocate a buffer (as you would do in C to mitigate the number of calls to <span class="literal">malloc()</span>) and fill it at your convenience. Using <span class="literal">memoryview</span>, you can place data at any point in the memory area, as shown in <a href="ch10.xhtml#ch10list26">Listing 10-26</a>.</p>&#13;
<p class="programs">   &gt;&gt;&gt; b<span class="codestrong1">a = bytearray(8)</span><br/><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong1">ba_at_4 = memoryview(ba)[4:]</span><br/>   &gt;&gt;&gt; <span class="codestrong1">with open("/dev/urandom", "rb") as source:</span><br/><span class="ent">➋</span> ...     <span class="codestrong1">source.readinto(ba_at_4)</span><br/>   ...<br/>   4<br/>   &gt;&gt;&gt; <span class="codestrong1">ba</span><br/>   bytearray(b'\x00\x00\x00\x00\x0b\x19\xae\xb2')</p>&#13;
<p class="listing1"><a id="ch10list26"/><em>Listing 10-26: Writing into an arbitrary position of <span class="codeitalic">bytearray</span></em></p>&#13;
<p class="indent">We reference the <span class="literal">bytearray</span> from offset 4 to its end <span class="ent">➊</span>. Then, we write the content of <em>/dev/urandom</em> from offset 4 to the end of <span class="literal">bytearray</span>, effectively reading just 4 bytes <span class="ent">➋</span>.</p>&#13;
<p class="indent">The buffer protocol is extremely important for achieving low memory overhead and great performances. As Python hides all the memory allocations, developers tend to forget what happens under the hood, at great cost to the speed of their programs!</p>&#13;
<p class="indent">Both the objects in the <span class="literal">array</span> module and the functions in the <span class="literal">struct</span> module can handle the buffer protocol correctly and can therefore perform efficiently when targeting zero copying.</p>&#13;
<h3 class="h3" id="lev1sec59"><strong>Summary</strong></h3>&#13;
<p class="noindent">As we’ve seen in this chapter, there are plenty of ways to make Python code faster. Choosing the right data structure and using the correct methods for manipulating the data can have a huge impact in terms of CPU and memory usage. That’s why it’s important to understand what happens in Python internally.</p>&#13;
<p class="indent">However, optimization should never be done prematurely, without first performing a proper profiling. It is too easy to waste time rewriting some barely used code with a faster variant while missing central pain points. Don’t miss the big picture.</p>&#13;
<h3 class="h3" id="lev1sec60"><strong>Victor Stinner on Optimization</strong></h3>&#13;
<p class="noindent">Victor is a longtime Python hacker, a core contributor, and the author of many Python modules. He authored PEP 454 in 2013, which proposed a new <span class="literal">tracemalloc</span> module to trace memory block allocation inside Python, and he wrote a simple AST optimizer called FAT. He also regularly contributes to the improvement of CPython performance.</p>&#13;
<p class="noindentt"><span epub:type="pagebreak" id="page_175"/><strong>What’s a good starting strategy for optimizing Python code?</strong></p>&#13;
<p class="noindent">The strategy is the same in Python as in other languages. First, you need a well-defined use case in order to get a stable and reproducible benchmark. Without a reliable benchmark, trying different optimizations may result in wasted time and premature optimization. Useless optimizations may make the code worse, less readable, or even slower. A useful optimization must speed the program up by at least 5 percent if it’s to be worth pursuing.</p>&#13;
<p class="indent">If a specific part of the code is identified as being “slow,” a benchmark should be prepared on this code. A benchmark on a short function is usually called a <em>micro-benchmark</em>. The speedup should be at least 20 percent, maybe 25 percent, to justify an optimization on a micro-benchmark.</p>&#13;
<p class="indent">It may be interesting to run a benchmark on different computers, different operating systems, or different compilers. For example, performances of <span class="literal">realloc()</span> may vary between Linux and Windows.</p>&#13;
<p class="noindentt"><strong>What are your recommended tools for profiling or optimizing Python code?</strong></p>&#13;
<p class="noindent">Python 3.3 has a <span class="literal">time.perf_counter()</span> function to measure elapsed time for a benchmark. It has the best resolution available.</p>&#13;
<p class="indent">A test should be run more than once; three times is a minimum, and five may be enough. Repeating a test fills disk cache and CPU caches. I prefer to keep the minimum timing; other developers prefer the geometric mean.</p>&#13;
<p class="indent">For micro-benchmarks, the <span class="literal">timeit</span> module is easy to use and gives results quickly, but the results are not reliable using default parameters. Tests should be repeated manually to get stable results.</p>&#13;
<p class="indent">Optimizing can take a lot of time, so it’s better to focus on functions that use the most CPU power. To find these functions, Python has <span class="literal">cProfile</span> and <span class="literal">profile</span> modules to record the amount of time spent in each function.</p>&#13;
<p class="noindentt"><strong>Do you have any Python tricks that could improve performance?</strong></p>&#13;
<p class="noindent">You should reuse the Standard Library as much as possible—it’s well tested and also usually efficient. Built-in Python types are implemented in C and have good performance. Use the correct container to get the best performance; Python provides many different kind of containers: <span class="literal">dict</span>, <span class="literal">list</span>, <span class="literal">deque</span>, <span class="literal">set</span>, and so on.</p>&#13;
<p class="indent">There are some hacks for optimizing Python, but you should avoid these because they make the code less readable in exchange for a minor speedup.</p>&#13;
<p class="indent">The Zen of Python (PEP 20) says, “There should be one—and preferably only one—obvious way to do it.” In practice, there are different ways to write Python code, and performances are not the same. Only trust benchmarks on your use case.</p>&#13;
<p class="noindentt"><span epub:type="pagebreak" id="page_176"/><strong>Which areas of Python have the poorest performance and should be watched out for?</strong></p>&#13;
<p class="noindent">In general, I prefer not to worry about performance while developing a new application. Premature optimization is the root of all evil. When you identify slow functions, change the algorithm. If the algorithm and the container types are well chosen, you might rewrite short functions in C to get the best performance.</p>&#13;
<p class="indent">One bottleneck in CPython is the global interpreter lock, known as the GIL. Two threads cannot execute Python bytecode at the same time. However, this limitation only matters if two threads are executing pure Python code. If most processing time is spent in function calls, and these functions release the GIL, then the GIL is not the bottleneck. For example, most I/O functions release the GIL.</p>&#13;
<p class="indent">The multiprocessing module can easily be used to work around the GIL. Another option, more complex to implement, is to write asynchronous code. Twisted, Tornado, and Tulip projects, which are network-oriented libraries, make use of this technique.</p>&#13;
<p class="noindentt"><strong>What are some often-seen performance mistakes?</strong></p>&#13;
<p class="noindent">When Python is not well understood, inefficient code can be written. For example, I have seen <span class="literal">copy.deepcopy()</span> misused, when no copying was required.</p>&#13;
<p class="indent">Another performance killer is an inefficient data structure. With less than 100 items, the container type has no impact on performance. With more items, the complexity of each operation (<span class="literal">add</span>, <span class="literal">get</span>, <span class="literal">delete</span>) and its effects must be known.</p>&#13;
</body></html>