- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Information in Memory
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Any remotely interesting computer program needs to be able to store and access
    data from memory. This data might be the text in a document, the information on
    a web page, or the details of every variety of coffee we’ve ever sampled stored
    within a database. In each case, the data is fundamental to the program performing
    its intended function.
  prefs: []
  type: TYPE_NORMAL
- en: These examples only represent the data that users see and think about. The program
    must also track numerous pieces of data behind the scenes, such as how many times
    we have passed through a loop, the current location of our character in a game,
    or the current system time. Without this data, a program can’t represent changes
    to its internal state.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we examine the very basics of storing data in memory. We’ll
    look at how the simplest data structures—plain old variables, composite data structures,
    and arrays—store their data. We’ll also introduce the book’s pseudocode conventions.
    For readers who have experience programming, this chapter’s key concepts might
    already be familiar. Even so, they’re a critical starting point for our journey
    and worth a review since they provide the foundations to build more powerful and
    exciting data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Individual pieces of data are often stored in *variables*, which are essentially
    names representing the location (or *address*) of a piece of data in the computer’s
    memory*.* Readers with even a passing exposure to programming will already be
    familiar with variables: they are a foundational concept in computer science,
    necessary for even the simplest programs. Variables enable programs to track information
    that changes throughout the course of the program. Need to count how many times
    you have passed through a `FOR` loop? Track the player’s score in a game? Count
    how many spelling errors you’ve made while writing an introductory chapter about
    variables? Use a variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Without variables, a programmer can’t track, evaluate, or update the program’s
    internal state. When you create a variable, the system allocates and assigns it
    a location behind the scenes. You are then free to write data to that location
    using a variable name of your choice and look it up using the same name. As long
    as you know the variable’s name, you don’t need to know the memory location of
    the data. We can visualize the computer’s memory as a long column of bins. Each
    variable occupies one or more contiguous bins, depending on the size of the variable,
    as shown in [Figure 1-1](#figure1-1) for three variables: `Level`, `Score`, and
    `AveScore`. In this illustration, the average score (`AveScore`) is a floating-point
    number (a number with a decimal) that uses two bins of memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram showing that the level variable with value 20 occupies one bin,
    the score variable with value 109 occupies one bin, and the average score variable
    stores with value 100 point 111111 occupies two bins.](image_fi/502604c01/f01001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-1: Computer memory depicted as a column of bins'
  prefs: []
  type: TYPE_NORMAL
- en: 'In some ways, variables are like the little paper labels on file folders, like
    the ones in [Figure 1-2](#figure1-2): once we have attached the label, we don’t
    need to remember the folders’ order or exactly how we stored them. We just look
    up the folder by its label—but this means that it’s important to use informative
    names. The author’s own filing cabinet is crammed full of overloaded folders with
    names such as *Stuff*, *Misc*, *Important*, and *Other Stuff*, making it difficult
    to know what is stored inside. Likewise, vague variable names make it hard to
    guess what values they represent.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Files with their label tabs sticking up so the files can be easily found.
    From front to back, labels say Level, Top Score, Score, and Other Stuff.](image_fi/502604c01/f01002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-2: Variables, like the labels on file folders, provide a convenient
    way to find and access your stored values.'
  prefs: []
  type: TYPE_NORMAL
- en: In many programming languages, variables have an associated type that denotes
    exactly what type of data they store, such as integers, “floats” for floating-point
    values, or Booleans for true or false values. These types tell the program how
    much memory the variable occupies and how to use it. A Boolean variable, for example,
    stores a limited range of values and often requires only a small amount of memory.
    A double-precision floating-point number might store a much larger and more precise
    number and so would use multiple bins. The syntax of defining types, and even
    whether types need to be explicitly defined, varies among programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this book, we will use the language-independent `<type>: <name>`
    pseudocode format to specify our variables in examples. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes a variable will be of the general type `Type` to indicate that it
    could take on a range of types depending on the implementation. We’ll operate
    on the variables using syntax typical of most programming languages, including
    the use of `=` for assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For numeric types, including integers and floats, we’ll use standard arithmetic
    operations, such as `+`, `-`, `*`, and `/`. For Boolean data types, we’ll use
    Boolean operations, such as `AND`, `OR`, and `NOT`. The syntax you’ll need to
    use in your programs will vary depending on your programming language (and is
    a common focal point in fights over the relative merits of different languages).
  prefs: []
  type: TYPE_NORMAL
- en: Composite Data Structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many programming languages provide the ability to create *composite data structures*,
    such as astruct or an object, which gather multiple individual variables into
    a single group. Composite data structures provide an easy way to gather related
    pieces of data and pass them around together. For example, we might define a `CoffeeRecord`
    to track some information about the kinds of coffees we have sampled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of maintaining six individual variables to track a coffee’s properties,
    we store all of that information in a single composite data structure, `CoffeeRecord`.
    Of course, a true coffee connoisseur would likely track a few hundred additional
    properties, as well as exact information about the date, time, location, and weather
    conditions related to the coffee consumption. Coffee is, after all, a complex
    subject and deserves thorough documentation. Each additional property further
    underscores the importance of using a composite data structure: the alternative
    of passing around hundreds of related variables not only is tedious but also increases
    the probability that the programmer will make a mistake, such as passing variables
    to a function in the wrong order.'
  prefs: []
  type: TYPE_NORMAL
- en: Business cards provide a real-world example of composite data structures. Each
    individual card is a packet of data containing multiple pieces of information
    such as your name, phone number, and email address. Bundling this information
    into a single card increases the efficiency of tracking it and passing it around.
    Imagine the mess and confusion of handing a colleague five different scraps of
    paper, each containing a single datapoint.
  prefs: []
  type: TYPE_NORMAL
- en: In many programming languages, including Java and Python, data composites can
    take the form of *objects*, which contain both the data and functions for operating
    on their own data. The object’s functions use special syntax to access that object’s
    data, such as the `self` reference in Python. An object can also provide different
    visibility rules that specify whether its internal data is publicly accessible
    outside the object’s own functions or only privately accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an attempt to be general, we will treat composite data structures in their
    most general form: as a collection of data. While example code snippets in this
    book and elsewhere may implement the composite data structures as objects, the
    algorithms can be adapted to use non-object representations as well. In code that
    uses composite data structures or objects, we use the syntax of `composite.field`
    to indicate accessing a particular field of a composite data structure. For example,
    using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: we set the `name` field of the record `latest_record` in our coffee log to have
    the value `Sublime Blend`.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *array* is generally used to store multiple related values. For example,
    we might want to track the amount of coffee consumed daily over a year. We could
    brute-force the storage by creating 365 individual variables, such as `AmountDay1`,
    `AmountDay2`, `AmountDay3`, and so forth, but this is tedious to type and doesn’t
    allow us to use any structure for the data. `AmountDay2` is only a textual tag,
    so the program doesn’t know that `AmountDay1` stores information for the day before
    and `AmountDay3` for the day after; only the programmer knows this.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays provide a simple mechanism for storing multiple values in adjacent and
    indexable bins. An array is effectively a row of variables—a contiguous block
    of equal-sized bins in the computer’s memory, as in [Figure 1-3](#figure1-3).
    Like individual variables, arrays occupy a chunk of memory and can sit adjacent
    to arbitrary other information. Each of the array’s bins can store a value of
    the given type, such as a number, a character, pointer, or even other (fixed-size)
    data structures.
  prefs: []
  type: TYPE_NORMAL
- en: '![A column of 12 bins. An array occupies the middle 5 bins. The 4 bins below
    and the 3 bins above the array are labeled Other Stuff.](image_fi/502604c01/f01003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-3: Arrays as bins in the computer’s memory'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays appear throughout our real-world daily lives as well. The row of lockers
    lining a high school hallway, for example, is a physical array for storing students’
    coats and books. We can access any individual storage container by just opening
    the corresponding locker.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of an array allows you to access any value, also known as an *element*,
    within the array by specifying its location, or *index*. The bins occupy adjacent
    locations in the computer’s memory, so we can access individual bins by computing
    their offset from the first element and reading the memory in that location. This
    requires just a single addition and memory lookup regardless of which bin we access.
    This structure makes arrays especially convenient for storing items that have
    an ordered relationship, such as our daily coffee intake tracker.
  prefs: []
  type: TYPE_NORMAL
- en: Formally, we reference the value at index `i` of array `A` as `A[i]`. In our
    locker example, the index would be the number displayed on the front of the locker.
    Most programming languages use *zero-indexed arrays*, which means the first value
    of the array resides at index 0, the second at index 1, and so forth, as shown
    in [Figure 1-4](#figure1-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram showing a series of values stored in nine bins. Below the values
    are their index values. The first index value on the left is zero. The index values
    increase by 1 and end with 8 on the right.](image_fi/502604c01/f01004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-4: A zero-indexed array'
  prefs: []
  type: TYPE_NORMAL
- en: We will use zero-indexed arrays throughout this book, to stick to general computing
    convention. [Figure 1-5](#figure1-5) represents how zero-indexed arrays appear
    in the computer’s memory, where the white spaces are the elements of the array.
  prefs: []
  type: TYPE_NORMAL
- en: '![ A column of 12 bins. An array occupies the middle 5 bins. These 5 bins are
    labeled A zero through A 4.](image_fi/502604c01/f01005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-5: A zero-indexed array arranged in computer memory'
  prefs: []
  type: TYPE_NORMAL
- en: 'Zero-indexing conveniently allows us to compute an element’s location in memory
    as an offset from where the array starts in memory. The location of the *i*th
    item in the array can be computed by:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Location*(*item* i) = *Location*(*start of array*) + *Size of each element*
    × i'
  prefs: []
  type: TYPE_NORMAL
- en: The location of the element at index zero is the start of the array. For example,
    the fifth element of the example array `A` in [Figure 1-5](#figure1-5) would be
    `A[4]`, and, going by the values indexed in [Figure 1-4](#figure1-4), contain
    the value 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most programming languages, we get and set values in an array using a combination
    of the array’s name and the index. For example, we might set the value of the
    bin with index 5 equal to 16:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For our coffee-tracking example, we could define an array `Amount` to store
    the number of cups consumed in a day and store the corresponding counts in `Amount[0]`
    through `Amount[364]`. The single array allows us to access 365 distinct values,
    in order, through a single variable name. We have transitioned from a series of
    similarly named, but independent, variables to a mathematical offset of a single
    location. To understand the power of this, consider our school lockers. Naming
    individual lockers “Jeremy’s Locker” or “Locker for the third student with a last
    name starting with K” would make them nearly impossible to find quickly. Rather
    than simply accessing a specific index, students would have to check a large number
    of lockers, comparing textual tags until they found the correct match. With array
    indexing, the students can just use its offset to determine where the locker is
    and access it directly.
  prefs: []
  type: TYPE_NORMAL
- en: Although we often visualize and discuss arrays as the whole data structure,
    it is important to remember that each bin behaves like an individual variable.
    When we want to make a global change to the array, such as shifting the elements
    forward one position, we need to apply the change individually to each bin as
    shown in [Figure 1-6](#figure1-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram showing 8 bins. Arrows indicate that the values in the bins are
    all shifting to the left by 1 bin.](image_fi/502604c01/f01006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-6: Shifting elements in an array forward, bin by bin'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays aren’t like books on a bookshelf. We can’t shove the entire collection
    over at once to make room for the newest edition of *Coffee Lover’s Guide to the
    Best Free-Trade Coffees*. Arrays are more like a row of storefronts. We can’t
    just squeeze a new coffee shop between our favorite neighborhood bookseller and
    barbershop. To make space, we’d need to shift the storefronts down one by one,
    by emptying each store and moving its contents into the adjacent building.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, we have to juggle values simply to swap two values in an array. To
    swap the values at some indices `i` and `j`, for instance, we need to first assign
    one of them to a temporary variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, we would overwrite the value in one of the bins and the two bins
    would end up with the same value. Similarly, if we are swapping the locations
    of the coffee shop and bookseller, we first need to move the contents of the bookstore
    into an empty third location in order to make space for the contents of the coffee
    shop. Only after we’ve moved the coffee shop can we move the bookstore’s contents
    from the temporary third location into the coffee shop’s former location.
  prefs: []
  type: TYPE_NORMAL
- en: Insertion Sort
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The best way to understand the impact an array’s structure has on how it can
    be used is to examine it in the context of an actual algorithm. *Insertion sort*
    is an algorithm to sort the values in an array. It works on any type of value
    that can be ordered. We could sort integers, strings, or even the coffees in our
    pantry by expiration date.
  prefs: []
  type: TYPE_NORMAL
- en: Insertion sort works by sorting a subset of the array and expanding this sorted
    range until the entire array is in order. The algorithm iterates through each
    element in the unsorted array and moves it down into the correct location of the
    sorted section. At the start of iteration `i`, the items in bins 0 through `i`
    − 1 are all in sorted order. The algorithm then takes the item at index `i`, finds
    the correct location in the sorted prefix, and inserts it, shifting the necessary
    items down to make room. The sorted prefix has now grown by one—bins 0 through
    `i` are in sorted order. We can start at `i` = 1 by declaring the first element
    to be our initial sorted prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Say we want to sort our coffee collection in order of freshness—after all, it
    would be tragic to leave a bag of premium coffee languishing at the back of the
    pantry until it was stale. We need to move the earliest best-by dates to the left
    side of the shelf where they can be readily accessible.
  prefs: []
  type: TYPE_NORMAL
- en: We begin our coffee insertion sort by proclaiming a single bag at the front
    to be *sorted* and using this range as our sorted prefix. We then look at the
    second bag on the shelf and compare dates to determine whether it should go before
    the first one. After we swap the order, or determine that a swap isn’t necessary,
    we can confidently proclaim that the first two elements are sorted. We have a
    subset that’s fully sorted. We then progress to the third bag and determine where
    it should sit relative to the first two, perhaps making a few swaps in the process.
    This process continues down the shelf until we’ve achieved perfect coffee organization.
  prefs: []
  type: TYPE_NORMAL
- en: We can implement insertion sort with a pair of nested loops, as shown in [Listing
    1-1](#listing1-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-1: Implementing insertion sort with nested loops'
  prefs: []
  type: TYPE_NORMAL
- en: The outer loop with iterator `i` starts at the first unsorted element, `i =
    1` and progresses through each value in the unsorted range ❶. The inner loop with
    iterator `j` shifts the current value down into the sorted prefix ❷. At each step,
    we check the position within the sorted prefix by comparing the `current` value
    to the preceding location in the prefix, index `j`. If the element at `j` is larger,
    the two values are in the wrong order and must be swapped. Since we are storing
    the current value in a separate variable `current`, we copy the data from the
    preceding bin directly. There is no need to do a full swap. The inner loop continues
    until it shifts the current value to the front of the array or it finds a preceding
    value that is smaller, which indicates the current value is in the correct location
    of the sorted prefix. We only need to write the current value at the end of the
    loop when it is in the correct location. The outer loop then proceeds to the next
    unsorted value.
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize the behavior of the algorithm as shown in [Figure 1-7](#figure1-7).
    Each row shows the state of the array at the beginning of the iteration. The shaded
    box represents the current item being shifted into position, and the arrows represent
    the corresponding shifts.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram showing 8 bins through 8 iterations. At the start, the value at
    the zero index is 61 and is assumed to be sorted. The second value  is 82, which
    is left where it is. The third value is 67, which is swapped with 82\. The fourth
    value is 4, which is moved to index zero; the three preceding values are shifted
    one place forward to make room. And so forth until all eight values are in order
    from least to greatest.](image_fi/502604c01/f01007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-7: Visualization of an insertion sort algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: Insertion sort isn’t particularly efficient. When inserting elements into the
    array, we could end up shifting around significant portions of the array. In the
    worst case, the cost of the algorithm scales proportionally with the square of
    the number of items—for every item in the list, we shift all the items in front
    of it. If we double the size of the array, we increase the worst-case cost by
    a factor of four. While this may not be a huge cost in our coffee pantry, where
    we are likely to keep only a small number of coffees that we can consume before
    they go stale, the quadratic cost of the algorithm skyrockets in many applications.
  prefs: []
  type: TYPE_NORMAL
- en: Yet insertion sort provides an important insight into how arrays function. Within
    this simple algorithm we illustrate several attributes of the array, including
    the power of being able to access items by their index, the ability to swap values
    when inserting new elements, and the valuable ability to iterate over entries.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Strings* are ordered lists of characters that can often be thought of as a
    special kind of arrays. Each bin in the string holds a single character, be that
    a letter, number, symbol, space, or one of a limited set of special indicators.
    A special character is often used to indicate the end of the string, as represented
    by the `/` in the last bin in [Figure 1-8](#figure1-8). Characters in strings
    can often be accessed directly using their index.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram showing 13 characters, indexed zero to 12\.  The characters spell
    Hello World, exclamation mark, and the last character is a slash.](image_fi/502604c01/f01008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-8: A string spelling “Hello world!”'
  prefs: []
  type: TYPE_NORMAL
- en: In some programming languages, strings are directly implemented as simple arrays
    of characters. In others, strings may be objects, and the string class serves
    as a wrapper around an array or other data structure holding the characters. The
    wrapper class for a string provides additional functionality, such as the ability
    to dynamically resize the string or search for a substring. In either case, it
    is useful to think about how the general array-like structure impacts operations
    on the string. When we display a string on the computer screen, we are effectively
    iterating through each of its characters and displaying them one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The common test of equality is more interesting to consider. Unlike integers,
    which can be directly compared with a single operation, strings must be compared
    by iterating through each character. The program compares it individually to its
    counterpart and returns whether it finds a mismatch.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-2](#listing1-2) shows the algorithm for checking the equality of
    two strings. The algorithm starts by comparing the strings’ size. If they are
    not the same length, the algorithm stops there. If they are the same length, the
    algorithm iterates through each position and compares the respective letters of
    each string. We can terminate the loop as soon as we find a single mismatch. Only
    if we make it all the way to the end of the strings without a mismatch can we
    declare the strings equal.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 1-2: The algorithm for checking the equality of two strings'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-9](#figure1-9) demonstrates how this algorithm operates on two strings.
    The equality sign indicates which pairs of characters matched when compared. The
    X represents the first mismatched pair, where the test terminates.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two strings, Hello world and Hello friend. Equal signs show the first 6 characters
    are the same. An X in position 7 shows the W and F are different.](image_fi/502604c01/f01009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-9: A comparison of two strings'
  prefs: []
  type: TYPE_NORMAL
- en: The worst-case computational cost of string comparison grows proportionally
    with the length of the strings. While the work required to compare two small strings
    can be negligible, the same operation on two long strings can be time-consuming.
    For comparison, imagine the tedium of scanning through two editions of the same
    book, letter by letter, looking for each difference in the arrangement of text
    from one book to the next. In the best case, we find a mismatch early. In the
    worst case, we need to examine the majority of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Many programming languages, such as Python, provide a string class that allows
    direct comparisons, so we never need to implement the comparison code in [Listing
    1-2](#listing1-2) directly. Still, underneath the simple comparison function lies
    a loop that iterates over all the letters. Without understanding this vital detail,
    it is possible to vastly underestimate the cost of string comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: Why This Matters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variables and arrays are staples of introductory programming classes and thus
    might seem less than exciting, but they are important to examine because they
    provide the very foundations for computer programming and data structures. These
    concepts also provide the baseline against which to evaluate dynamic data structures
    and their impact on algorithms. In later chapters, we will see how dynamic data
    structures can offer different tradeoffs among efficiency, flexibility, and complexity.
  prefs: []
  type: TYPE_NORMAL
