- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Science in Other Languages
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'All of our business solutions so far have had one thing in common: they’ve
    used only Python. Python is standard in the world of data science, but it’s not
    the only language out there. The best data scientists are versatile and capable
    of writing code in multiple languages. This chapter contains a short introduction
    to both Structured Query Language (SQL) and R, two common languages that every
    good data scientist should know. This chapter isn’t a comprehensive overview of
    either language. It’s only a basic introduction that will enable you to recognize
    and write a few lines of SQL or R code.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start the chapter by introducing a business scenario. Then we’ll go over
    some simple SQL code to set up a database and manipulate data within it. We’ll
    go on to discuss R and how to use it to perform simple operations and linear regressions.
    Instead of spending a lot of effort setting up environments for running SQL and
    R commands, you’ll learn how to run SQL and R commands from within a Python session.
  prefs: []
  type: TYPE_NORMAL
- en: Winning Soccer Games with SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that you receive a job offer to be the manager of a European soccer
    team. This may seem like more of a sports scenario than a business scenario, but
    remember that sports is a business, one with billions of dollars of revenues worldwide
    every year. Teams hire managers to maximize their revenues and profits and make
    sure everything runs well.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most important things every team needs to do from a business perspective
    is win games—teams that win often earn higher profits than teams that tend to
    lose. As a good data scientist, you know exactly what to do first to set yourself
    up for success in your new job: you start diving into and exploring data, and
    trying to learn what it takes to win soccer games.'
  prefs: []
  type: TYPE_NORMAL
- en: Reading and Analyzing Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can download several files that contain data related to European soccer
    from the following URLs: [https://bradfordtuckfield.com/players.csv](https://bradfordtuckfield.com/players.csv),
    [https://bradfordtuckfield.com/games.csv](https://bradfordtuckfield.com/games.csv),
    and [https://bradfordtuckfield.com/shots.csv](https://bradfordtuckfield.com/shots.csv).
    The first file, *players.csv*, contains a list of professional soccer players,
    including their names and unique ID numbers. The next file, *games.csv*, contains
    detailed statistics related to thousands of individual soccer games, including
    which teams played, the number of goals scored, and much more. The third file,
    *shots.csv*, is the largest. It contains information about hundreds of thousands
    of individual shots taken during games, including who took the shot, which foot
    the player used, where the shot was taken, and the result of the shot (whether
    it was blocked, missed, or a goal).'
  prefs: []
  type: TYPE_NORMAL
- en: If you can do rigorous analysis of this data, you can get a deep understanding
    of European soccer and have much of the most important knowledge you’ll need to
    succeed as a manager. (The original sources of this public domain data include
    [https://www.kaggle.com/technika148/football-database](https://www.kaggle.com/technika148/football-database),
    [https://understat.com](https://understat.com), and [https://www.football-data.co.uk](https://www.football-data.co.uk).)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by reading these files. We’ll use Python here, but don’t worry,
    we’ll be using SQL soon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, this should look familiar. It’s standard Python code for reading *.csv*
    files. After importing pandas, we read in datasets that have information about
    European soccer. You can see that we read all three datasets that we’ll be working
    with here: `players`, which contains data about individual players; `games`, which
    contains data about individual games; and `shots`, which contains data about shots
    that players took during games.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the first few rows of each of these datasets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `players` table has only two columns, and when you run `print(players.head())`,
    you should see the top five rows of both of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `shots` data is more detailed. When you run `print(shots.head())`, you
    should see its top five rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that by default, the pandas package has omitted some columns that
    don’t fit in the output console. You can see a list of all the columns in the
    dataset by running `print(shots.columns)`, which will show you the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We have detailed data about each shot. We know the foot that was used to shoot
    (in the `shotType` column), the results of the shot (in the `shotResult` column),
    and the position at which it was taken (in the `positionX` and `positionY` columns).
    But one thing that’s not stated explicitly in this data is the name of the player
    who took the shot. All we have is the `shooterID`, a number. If we want to find
    out the name of the person who took the shot, we have to look it up: find the
    `shooterID` number in the `shots` data, then look at the `players` dataset to
    find the name of the player whose ID matches that `shooterID` number.'
  prefs: []
  type: TYPE_NORMAL
- en: The first shot, for example, was taken by the player with `shooterID` 554\.
    If we want to know the name of that player, we need to look at the `players` dataset.
    If you scroll through the `players` data, or if you run `print(players.loc[7,'name'])`
    in Python, you can see that this player is Juan Mata.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Familiar with SQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s go over some SQL code that will enable you to do these kinds of lookups.
    We’ll start by looking at SQL code, and we’ll discuss how to run the code later.
    Individual SQL commands are usually called SQL *queries*. The following code is
    a SQL query that will show you the entire `players` dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Often, short SQL queries are simple to interpret as long as you know English.
    In this snippet, `SELECT` tells us that we’re selecting data. The `FROM` `playertable`
    text at the end of the query means that we’ll be selecting data from the table
    called `playertable`. Between `SELECT` and `FROM playertable` is where we’re supposed
    to specify the columns we want to select from the `playertable` data. The asterisk
    (`*`) is a shortcut that means that we want to select all the columns of the `playertable`
    table. The semicolon (`;`) tells SQL that we’ve finished this particular query.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this SQL query selects our entire `players` table. If you don’t want to
    select all the columns of the data, you can replace the `*` with the names of
    one or more columns. For example, both of the following are also valid SQL queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first query will select only the `playerID` column from the `playertable`.
    The second will select both the `playerID` and the `name` columns from the `playertable`
    table—the output we get from specifying that we want both columns by name is the
    same as the output we get from writing an asterisk.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that our SQL queries use all caps for their keywords. This
    is a common practice when writing SQL queries, though it’s not technically required
    in most environments. We’ll do it to follow convention.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up a SQL Database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you paste the preceding SQL queries directly into a Python session, they
    won’t run correctly; they’re not Python code. If you’re running SQL frequently,
    you will probably want to set up an environment that’s designed for editing and
    running SQL queries. However, this is a Python book, and we don’t want to get
    you bogged down in the details of setting up a SQL environment. Instead, let’s
    go over a few steps that will allow you to run SQL queries directly in Python.
    You can start by running the following commands in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we import the SQLite3 package, which allows us to run SQL queries in
    Python. SQL is a language that’s designed to work with databases, so we need to
    use SQLite3 to connect to a database. On the second line, we tell SQLite3 to connect
    to a database called `soccer.db`. You probably don’t have a database on your computer
    called `soccer.db`, so there may be nothing for SQLite3 to connect to. That’s
    all right, because the SQLite3 module is very helpful: when we specify a database
    we want to connect to, it will connect to the database if it exists, and if we
    try to connect to a database that doesn’t exist, it will create the database for
    us and then connect to it.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re connected to our database, we need to define a *cursor* to access
    this database. You can think of this cursor as similar to the cursor you use on
    your computer; it helps you select and manipulate objects. If that’s not clear
    to you now, don’t worry. The way we use this cursor will become clearer later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a database, we want to fill it up. Usually, a database contains
    a collection of tables, but our `soccer.db` database is currently empty. The three
    pandas dataframes we’ve worked with so far can all be saved to our database as
    tables. We can add the `players` dataframe to our database with one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the `to_sql()` method to push our `players` dataframe to the database’s
    `playertable` table. We use the connection we created before, called `conn`, which
    ensures that the table gets pushed to our `soccer.db` database. Now the players
    data is stored in our database instead of being accessible only as a pandas dataframe
    in our Python session.
  prefs: []
  type: TYPE_NORMAL
- en: Running SQL Queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’re finally ready to run our SQL query on our data. This is Python code that
    will run our SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the cursor we created, `curr`, is finally useful. The cursor
    is the object we’ll use to execute SQL queries on our data. In this case, we execute
    a simple query that selects the entire table called `playertable`. It’s important
    to note that this has selected the data, but it hasn’t displayed it. If we want
    to actually see the data that we selected, we need to print it to our console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The cursor has selected the data and pushed it to your Python session’s memory,
    but we need to use the `fetchall()` method to access this data. When you run `fetchall()`,
    it selects a list of rows. That’s why we print each row individually in a `for`
    loop. The `playertable` table has thousands of rows, and you may not want to print
    all of them to your screen at once. You can limit the number of rows returned
    by your query by adding a `LIMIT` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we run the same code as before, adding only seven characters: `LIMIT
    5`. By adding `LIMIT 5` to the SQL query, we limit the rows that are returned
    to only the first five. Since we get only the top five rows in the table, printing
    them to the screen becomes easier. This shows us the same data as we see when
    we run `print(players.head())` when we’re using pandas in Python. But be careful:
    in this case, `LIMIT 5` will give us the top five rows, but in other database
    environments, it will give you a random five rows. You can depend on getting five
    rows from the `LIMIT 5` clause, but you can’t always be sure which five you’ll
    get.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We often want only particular subsets of our data. For example, what if we
    want to find the player with a particular ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we run much of the same code, but we add a `WHERE` clause. Instead of
    selecting the whole table, we select only rows for which a particular condition
    is true. The condition we’re interested in is `playerID=554`. The output shows
    us one row, and that row tells us that the player with `playerID` equal to 554
    is named Juan Mata. This tells us what we wanted to know, that Juan Mata is the
    person who took the first shot recorded in the data. You should be starting to
    notice a pattern here: when creating SQL queries, we start with a short query
    that selects a whole table, and then we add *clauses* to the query (like the `LIMIT`
    clause or `WHERE` clause we added here) to refine the results we get. SQL queries
    consist of many clauses, each of which has an effect on the data the query selects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `WHERE` clauses to select all sorts of conditions. For example,
    we can use a `WHERE` clause to select the ID of a player with a particular name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the `AND` operator to specify multiple conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we select the rows of the `playertable` that satisfy two conditions
    simultaneously: both `playerID>100` and `playerID <200`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may want to look up a name in a table, but feel uncertain about the spelling.
    In that case, you can use the `LIKE` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we’re using the percent character (`%`) as a *wildcard*, meaning
    that it stands for any collection of characters. You may notice that this is similar
    to the way we used the asterisk earlier in the query (`SELECT *`). We use `*`
    to mean all columns and `%` to mean any possible character. But though these uses
    are similar (both representing unknown values), they’re not interchangeable, and
    there are two important differences. First, the `*` can be used as part of a query
    itself, while the `%` can be used only as part of a string of characters. Second,
    the `*` is used to refer to columns, and the `%` is used to refer to other characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you look at the results of this code, you can see that we’ve found several
    players whose names start with *Juan M*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If what we’ve done so far feels familiar, it should. The string we searched
    for, `Juan M%`, is a regular expression, just like the regular expressions we
    covered in Chapter 8. You can see that every programming language has its own
    rules and syntax, but huge overlaps occur across these languages. Most languages
    allow the use of regular expressions to search for text. Many languages allow
    you to create tables and select their top five rows. Often, when you learn a new
    programming language, you’re not learning totally new capabilities, but rather
    learning to do things you’ve already done in new ways.
  prefs: []
  type: TYPE_NORMAL
- en: You can create and work with tables by using Python and pandas, as well as SQL.
    The advantage of using SQL is that in many cases, SQL can be faster, more reliable,
    and more secure than pandas. It also may have compatibility with some programs
    that do not allow you to use Python and pandas.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Data by Joining Tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we’ve worked with our players table. But we can also work with our
    other tables. Let’s read in our `games` table, push it to our soccer database,
    and then select its top five rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet does everything we did previously with the `players` table: reads
    it, converts it to a SQL database table, and selects rows from it. We can do the
    same thing yet again, for our `shots` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our database has three tables: one for players, one for shots, and one
    for games. This situation is a little new to us. Throughout most of this book,
    we’ve had data conveniently gathered into a single table in each of our chapters.
    However, the data you’re interested in could be spread across several tables.
    In this case, we already noticed that our `shots` table has detailed information
    about individual shots, but it doesn’t have the name of the player who took each
    shot. To find out the name of the player who took a shot, we have to find the
    `shooterID` in the `shots` table and then look up this ID number in the `players`
    table.'
  prefs: []
  type: TYPE_NORMAL
- en: We have to do matching and lookups across multiple tables. If we have to do
    this only once or twice, manually scrolling through tables is probably not a big
    deal. But if we have to get the names of players who took thousands of shots,
    using manual lookups over and over again will become extremely time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, imagine if we could automatically combine the information in these
    two tables. This is a natural specialty of SQL. We can see what we need to do
    in [Figure 11-1](#figure11-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502888c11/f11001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-1: Joining two tables together, so lookups become easier and faster'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that if we join two tables together, we no longer have to look
    at multiple tables to find all the information we need. Each row contains not
    only the information from the `shots` table but also the shooter name from the
    `players` table. We’re going to accomplish the joining illustrated in [Figure
    11-1](#figure11-1) by using a SQL query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at this snippet, one piece at a time. We start with `SELECT *`, just
    like our previous SQL queries. Next, we have `FROM shotstable`, indicating that
    we’ll be selecting from the table called `shotstable`. However, that’s where the
    difference starts. We see `shotstable JOIN` `playertable`, indicating that we’re
    not going to select only from the `shotstable`, but instead want to join these
    two tables and select from the combined table.
  prefs: []
  type: TYPE_NORMAL
- en: But how should they be joined? We need to specify the way to join these two
    tables. Specifically, we’re going to join these tables by looking up where the
    IDs match. Every place where the `shotstable` column called `shooterID` is the
    same as the `playertable` column called `playerID`, we know that our rows match,
    and we can join them together. Finally, we add `LIMIT 5`, indicating that we want
    to see only the top five rows so the quantity of output rows isn’t overwhelming.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run this SQL query in Python as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we run the SQL query explained previously on the tables in our database.
    Our SQL query joins our tables together in the way shown in [Figure 11-1](#figure11-1).
    In that figure, you can see that for every shooter ID, we found the player with
    a matching player ID and added that player’s name to the matching row of the joined
    table. Our query does the same thing: since we specify `WHERE shotstable.shooterID=playertable.playerID`,
    it will find all matches between `shooterID` values (from the `shotstable`) and
    `playerID` values (from the `playertable`). After finding those matches, it will
    combine information from rows that match, and the final result will be a joined
    table with more complete information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After we run our query, we print out the rows that the query has returned.
    Overall, we’ve followed the same process we followed before: executing a query
    with the cursor, then fetching what we selected and printing it to the console.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that this output shows the data we want: shots, combined with information
    about the players who made the shots (their names are the last element of each
    row). Joining tables in this way can be valuable to enable advanced analyses like
    the ones we’ve done in previous chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: Joining tables may seem simple, but the process has many subtleties that you
    should learn about if you want to become great at SQL. For example, what happens
    if you have a shot with an ID that doesn’t appear in the `players` table? Or,
    what if two players have the same ID—how will we know which player took a shot
    that had their ID assigned to it? By default, SQL performs joining with `INNER
    JOIN`. An inner join will return nothing if no player ID matches a particular
    shooter ID; it will give you only rows where it knows exactly which player took
    a shot. But SQL provides other types of joins, and each uses different logic and
    follows different rules.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a SQL book, so we won’t go into every detail of the language and
    every type of join. When you study SQL more deeply, you’ll learn that advanced
    SQL capabilities usually consist of more and more sophisticated ways to select
    data and join tables. For now, you can feel proud that you’re able to do basic
    SQL queries. You’re able to put data in a database, select data from tables, and
    even join tables together.
  prefs: []
  type: TYPE_NORMAL
- en: Winning Soccer Games with R
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: R is another language that can be useful for a data science career. Let’s go
    over how to run R commands that will help you with your soccer management career.
    Just as we did with SQL, we can run our R commands from within a Python session
    instead of worrying about setting up an R environment. In many ways, R is similar
    to Python, so after gaining Python skills for data science, you may find that
    picking up R skills is less challenging.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Familiar with R
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start by looking at some R code. Just as we did with SQL queries, we’ll
    start by looking at the R code before running it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first line defines a variable called `my_variable`. If we were writing Python,
    the equivalent statement would be `my_variable=512`. In R, we use `<-` instead
    of `=`, because in R, `<-` is the *assignment operator*—the collection of characters
    used to define the values of variables. The `<-` characters are meant to resemble
    an arrow pointing from right to left, indicating that the number 512 is being
    pushed from the right to be assigned as the value of `my_variable`. After we assign
    the variable, we can add to it, or print it out, or do anything else we want with
    it. In our snippet, we print out the value of our variable plus 12 by writing
    `print(my_variable+12)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like when we were running SQL queries, you may wonder: How can we run
    this R code? If you’d like, you can download R and set up an R environment where
    this code can be run. But instead, we can run it from within the comfort of our
    Python session, after some straightforward preparation. Let’s start by importing
    a module we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the rpy2 package will be helpful for running R commands within
    a Python session. Now that we’ve imported our package, running R code is a breeze:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to what we did to run SQL code. We can use the `robjects.r()`
    function to run any R code within a Python session. You can see that the output
    shows 524, the result of the addition we did in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we’ve run simple R code, but nothing related to your soccer management
    job. Let’s run R code related to our soccer data, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first line reads our *players.csv* file, using the `read.csv()` command.
    We store the data in the `players` variable by using the same assignment operator
    as before (`<-`). In the second line, we print the top few rows of the data.
  prefs: []
  type: TYPE_NORMAL
- en: By looking at this R code, you can see some differences between R and Python.
    In Python, we use `pd.read_csv()`, and in R, we use `read.csv()`. Both are functions
    for reading *.csv* files, but there are small differences in the way they’re written.
    Similarly, in Python, we need to use `players.head()` to get the top rows of the
    data. In R, we use `head(players)`. When we’re working with pandas datasets, the
    `head()` method gives us the top five rows. But in R, the `head()` function gives
    the top six rows. R and Python have many similarities, but they are not identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can read our other tables in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we read and print the top few rows of the `shots` data. We can also
    print out the top few elements of particular columns of our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In R, the dollar sign (`$`) is used to refer to columns by name. This snippet
    prints out the head (top six elements) of the `minute` and `positionX` columns
    in our `shots` data. The `minute` column has the following top six elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the minutes at which the first six shots (in our data) were taken.
    The first six elements of `positionX` are these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: These are the x-positions at which these first six shots (in our data) were
    taken. Here, we use the term *x-position* to mean how far “down the field” each
    shot was taken. One team’s goal has an x-position of 0, and the other team’s goal
    has an x-position of 1, so the x-position tells us how close to the opposing team’s
    goal a particular shot was taken.
  prefs: []
  type: TYPE_NORMAL
- en: Applying Linear Regression in R
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whenever we look at data, we can try to learn from it. One thing we might want
    to learn is how shots from the beginning of the game are different from shots
    at the end of the game. How does the time during the game influence the position
    from which shots are being taken? Several hypotheses could be true:'
  prefs: []
  type: TYPE_NORMAL
- en: Offensive players could get more tired and desperate as a game progresses, so
    they start to take shots from farther away from the goal (a lower x-position).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defensive players could get more tired and careless as a game progresses, so
    players are able to take shots from closer to the goal (a higher x-position).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maybe neither of the first two hypotheses is true, or another pattern exists
    in the relationship between the minutes of a game and the x-position of shots.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To decide which of these hypotheses is true, we can try linear regression in
    R:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use the `lm()` command to run a linear regression. This regression
    attempts to find the relationship between the `minute` variable and the `positionX`
    variable in our `shots` data. Just as we did in Chapter 2, we want to look at
    the coefficients that are part of the output of every linear regression. Remember
    that the coefficient can be interpreted as the slope of a line. If we find a positive
    coefficient from this regression, we interpret that to mean that people take shots
    that are closer to the goal later in the game. If we find a negative coefficient,
    we interpret that to mean that people take shots that are farther from the goal
    later in the game. When we look at the output of our linear regression code, we
    see that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If you look in the `Estimate` column of this output, you can see that the estimated
    coefficient for the `minute` variable is `5.251e-05`. This is a positive coefficient,
    so as games progress through time, we expect to see shots that are (slightly)
    closer to the goal.
  prefs: []
  type: TYPE_NORMAL
- en: Using R to Plot Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we’ve performed our regression, we can draw a plot of our data, together
    with the regression results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we use the `png()` command. This tells R to open a file to
    draw a plot on. We also have to specify a filename where we’ll write the file.
    Next, we use the `plot()` command. We specify what we’ll put on the x-axis first,
    and then we specify the y-axis. The `abline()` command is used to draw a line
    for our regression output. Finally, we run `dev.off()`. This command turns off
    the graphics device, meaning it tells R that we’ve finished the plotting, and
    the file should be written to your computer’s memory. After you run this snippet,
    you should be able to see the file saved to your laptop; it should look like [Figure
    11-2](#figure11-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502888c11/f11002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-2: The x-position of shots at each minute of thousands of soccer
    games, with a regression line'
  prefs: []
  type: TYPE_NORMAL
- en: If you have trouble finding the output file on your laptop, you can change the
    filename argument in the preceding snippet. For example, you can write `png(filename='``/home/Yossarian/Documents``/plotoutput.png')`
    to save it to any specific location on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: You can see a huge number of shots on this plot, and many are being plotted
    right on top of one another. The regression line is barely visible—you can see
    it poking out at the left and right of the plot close to where *y* is about 0.85\.
    It has a positive slope, but it’s only slightly positive; very little pattern
    can be discerned in the shot locations by minute of soccer games. This is something
    that you could have done with Python, using the code and ideas from Chapter 2,
    but now you’re able to do it in another language as well.
  prefs: []
  type: TYPE_NORMAL
- en: This one plot and one regression won’t make you a perfect soccer manager yet,
    but it will give you information and context that will be helpful as you study
    what it takes to win soccer games and help your team succeed. Instead of relying
    on theories or hearsay, you have the skills of a data scientist, so you can determine
    what works well in soccer games by examining the data directly. After reading
    this chapter, you can examine data and learn from it not only with Python but
    also with SQL and R.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do so much more with R; anything we’ve done with Python in this book
    can also be done with R. In addition to plots and linear regression, you could
    do supervised learning, k-means clustering, and much more. But already, you know
    how to do a lot: you can read data, calculate a regression, and draw a plot.'
  prefs: []
  type: TYPE_NORMAL
- en: Gaining Other Valuable Skills
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After you finish this book and close it, you’ll have some strong data science
    skills. But you can always learn more. One thing you should consider is gaining
    proficiency in even more programming languages. In addition to Python, SQL, and
    R, there are many other programming languages that you might want to learn, at
    least at a beginner or intermediate level. Here are some other languages that
    you might consider learning:'
  prefs: []
  type: TYPE_NORMAL
- en: '**C++**'
  prefs: []
  type: TYPE_NORMAL
- en: C++ is a high-performance language; code written in C++ is powerful and fast.
    It tends to be harder to work with than Python.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Scala**'
  prefs: []
  type: TYPE_NORMAL
- en: Scala is used for working with big data—that is, datasets that have millions
    or billions of rows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Julia**'
  prefs: []
  type: TYPE_NORMAL
- en: Julia has been growing in popularity in recent years, gaining a reputation for
    efficiency and the speed of mathematical calculations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**JavaScript**'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is extremely common in web programming. It enables you to create
    dynamic, interactive websites.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**MATLAB**'
  prefs: []
  type: TYPE_NORMAL
- en: Short for *matrix laboratory*, MATLAB was designed for precision in mathematical
    calculations, including matrix manipulation. It’s often used for scientific computing,
    but only by people or institutions that can afford its hefty price tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SAS, Stata, SPSS**'
  prefs: []
  type: TYPE_NORMAL
- en: These are proprietary statistics packages. Stata is in common use among professional
    economists. SPSS, owned by IBM, is commonly used by some social scientists. SAS
    is used by some businesses. Just like MATLAB, all of these languages also have
    hefty price tags that often persuade people to use free alternatives like Python,
    SQL, and R.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Besides these, many others exist. Some data scientists say that a data scientist
    should be a better programmer than any statistician, and a better statistician
    than any programmer. Speaking of statistics, you may want to study the following
    topics in advanced statistics further:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Linear algebra**'
  prefs: []
  type: TYPE_NORMAL
- en: Many statistical methods like linear regression are, at heart, linear algebra
    methods. When you read textbooks related to advanced data science or advanced
    machine learning, you will see notation from linear algebra, and linear algebra
    ideas like matrix inversion. If you can gain deep knowledge of linear algebra,
    you’ll be better able to master these advanced topics.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Bayesian statistics**'
  prefs: []
  type: TYPE_NORMAL
- en: In recent decades, a set of statistical techniques known as *Bayesian statistics*
    have become popular. Bayesian techniques allow us to reason effectively about
    our levels of confidence about different ideas and how we update our beliefs in
    the face of new information. They also allow us to use our prior beliefs in our
    statistical inferences and reason carefully about the uncertainty we have about
    statistical models.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Nonparametric statistics**'
  prefs: []
  type: TYPE_NORMAL
- en: Like Bayesian statistics, nonparametric methods allow us to reason about data
    in new ways. Nonparametric methods are powerful because they require us to make
    very few assumptions about data, so they’re robust and applicable to all kinds
    of data, even data that isn’t “well behaved.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Data science is about more than statistical theory. It’s also about deploying
    technology. Here are some technical skills related to technology deployment you
    will want to gain:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data engineering**'
  prefs: []
  type: TYPE_NORMAL
- en: In most of the chapters of this book, we provided you clean data for analysis.
    However, in many real-life scenarios, you’ll receive data that’s messy, incomplete,
    badly labeled, constantly changing, or otherwise in need of careful management.
    Data engineering is a set of skills for working with big, unruly datasets in a
    careful and effective way. You may find yourself working at a company that has
    data engineers on staff to clean and prepare data for you, but you’ll likely find
    yourself in many situations where you need to do these tasks yourself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**DevOps**'
  prefs: []
  type: TYPE_NORMAL
- en: After a data scientist performs some analysis, more steps are often required
    before the analysis is useful. For example, if you use linear regression to do
    forecasting, you may want to install the regression on a server and have it performed
    regularly. How and where will you install it? Do you need to update it regularly?
    How will you monitor it? How and when will you redeploy it? These kinds of questions
    are related to machine learning DevOps, also called *MLOps*, and if you can gain
    some DevOps and MLOps skills, you can have more success in your data science career.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Advanced/fluent/efficient programming**'
  prefs: []
  type: TYPE_NORMAL
- en: A beginner data scientist can write code that works. A talented data scientist,
    by contrast, can write code that’s efficient. It will run fast, and will be readable
    and concise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Besides these skills, you will want to gain expertise in applied fields related
    to the work you do (or the work you want to do). If you’re interested in working
    as a data scientist in the world of finance, you should study mathematical finance
    and the types of quantitative models that top finance companies use. If you’re
    interested in working for a pharmaceutical or medical company, you should consider
    biostatistics or even just pure biology as fields to dive into. The more you know,
    the more effective you’ll be in your data science career.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we discussed other languages besides Python that can be useful
    for data scientists. We started with SQL, a powerful language used to work with
    tables. We used SQL to select data from tables as well as to join tables together.
    We continued with a discussion of R, a language designed by statisticians that
    can be used for many powerful data analyses. Now you’ve completed the book, and
    you have excellent data science skills. Congratulations, good luck, and all the
    best!
  prefs: []
  type: TYPE_NORMAL
