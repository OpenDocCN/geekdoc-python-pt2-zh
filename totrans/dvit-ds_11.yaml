- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Science in Other Languages
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: 'All of our business solutions so far have had one thing in common: they’ve
    used only Python. Python is standard in the world of data science, but it’s not
    the only language out there. The best data scientists are versatile and capable
    of writing code in multiple languages. This chapter contains a short introduction
    to both Structured Query Language (SQL) and R, two common languages that every
    good data scientist should know. This chapter isn’t a comprehensive overview of
    either language. It’s only a basic introduction that will enable you to recognize
    and write a few lines of SQL or R code.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start the chapter by introducing a business scenario. Then we’ll go over
    some simple SQL code to set up a database and manipulate data within it. We’ll
    go on to discuss R and how to use it to perform simple operations and linear regressions.
    Instead of spending a lot of effort setting up environments for running SQL and
    R commands, you’ll learn how to run SQL and R commands from within a Python session.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Winning Soccer Games with SQL
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that you receive a job offer to be the manager of a European soccer
    team. This may seem like more of a sports scenario than a business scenario, but
    remember that sports is a business, one with billions of dollars of revenues worldwide
    every year. Teams hire managers to maximize their revenues and profits and make
    sure everything runs well.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most important things every team needs to do from a business perspective
    is win games—teams that win often earn higher profits than teams that tend to
    lose. As a good data scientist, you know exactly what to do first to set yourself
    up for success in your new job: you start diving into and exploring data, and
    trying to learn what it takes to win soccer games.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Reading and Analyzing Data
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can download several files that contain data related to European soccer
    from the following URLs: [https://bradfordtuckfield.com/players.csv](https://bradfordtuckfield.com/players.csv),
    [https://bradfordtuckfield.com/games.csv](https://bradfordtuckfield.com/games.csv),
    and [https://bradfordtuckfield.com/shots.csv](https://bradfordtuckfield.com/shots.csv).
    The first file, *players.csv*, contains a list of professional soccer players,
    including their names and unique ID numbers. The next file, *games.csv*, contains
    detailed statistics related to thousands of individual soccer games, including
    which teams played, the number of goals scored, and much more. The third file,
    *shots.csv*, is the largest. It contains information about hundreds of thousands
    of individual shots taken during games, including who took the shot, which foot
    the player used, where the shot was taken, and the result of the shot (whether
    it was blocked, missed, or a goal).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: If you can do rigorous analysis of this data, you can get a deep understanding
    of European soccer and have much of the most important knowledge you’ll need to
    succeed as a manager. (The original sources of this public domain data include
    [https://www.kaggle.com/technika148/football-database](https://www.kaggle.com/technika148/football-database),
    [https://understat.com](https://understat.com), and [https://www.football-data.co.uk](https://www.football-data.co.uk).)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够对这些数据进行严格分析，你将能深入了解欧洲足球，并掌握作为经理成功所需的大部分重要知识。（这些公共领域数据的原始来源包括[https://www.kaggle.com/technika148/football-database](https://www.kaggle.com/technika148/football-database)、[https://understat.com](https://understat.com)
    和 [https://www.football-data.co.uk](https://www.football-data.co.uk)。）
- en: 'Let’s start by reading these files. We’ll use Python here, but don’t worry,
    we’ll be using SQL soon:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从读取这些文件开始。我们这里使用 Python，但别担心，我们很快会使用 SQL：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So far, this should look familiar. It’s standard Python code for reading *.csv*
    files. After importing pandas, we read in datasets that have information about
    European soccer. You can see that we read all three datasets that we’ll be working
    with here: `players`, which contains data about individual players; `games`, which
    contains data about individual games; and `shots`, which contains data about shots
    that players took during games.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这应该看起来很熟悉。这是读取 *.csv* 文件的标准 Python 代码。在导入 pandas 后，我们读取包含关于欧洲足球信息的数据集。你可以看到，我们读取了将在此使用的所有三个数据集：`players`，包含有关个人球员的数据；`games`，包含关于单场比赛的数据；以及
    `shots`，包含球员在比赛中射门的数据。
- en: 'Let’s look at the first few rows of each of these datasets:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这些数据集的前几行：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `players` table has only two columns, and when you run `print(players.head())`,
    you should see the top five rows of both of them:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`players` 表只有两列，当你运行`print(players.head())`时，你应该能够看到它们的前五行：'
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `shots` data is more detailed. When you run `print(shots.head())`, you
    should see its top five rows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`shots` 数据更为详细。当你运行`print(shots.head())`时，你应该能够看到它的前五行：'
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can see that by default, the pandas package has omitted some columns that
    don’t fit in the output console. You can see a list of all the columns in the
    dataset by running `print(shots.columns)`, which will show you the following list:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，默认情况下，pandas 包省略了一些在输出控制台中无法显示的列。你可以通过运行`print(shots.columns)`来查看数据集中所有列的列表，执行后将显示如下列表：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have detailed data about each shot. We know the foot that was used to shoot
    (in the `shotType` column), the results of the shot (in the `shotResult` column),
    and the position at which it was taken (in the `positionX` and `positionY` columns).
    But one thing that’s not stated explicitly in this data is the name of the player
    who took the shot. All we have is the `shooterID`, a number. If we want to find
    out the name of the person who took the shot, we have to look it up: find the
    `shooterID` number in the `shots` data, then look at the `players` dataset to
    find the name of the player whose ID matches that `shooterID` number.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有关于每次射门的详细数据。我们知道使用哪只脚进行射门（在 `shotType` 列中），射门的结果（在 `shotResult` 列中），以及射门的位置（在
    `positionX` 和 `positionY` 列中）。但有一点数据中没有明确提到，那就是射门球员的姓名。我们所拥有的只是 `shooterID`，一个数字。如果我们想知道谁射门了，我们必须查找：首先在
    `shots` 数据中找到 `shooterID`，然后在 `players` 数据集中查找与该 `shooterID` 匹配的球员姓名。
- en: The first shot, for example, was taken by the player with `shooterID` 554\.
    If we want to know the name of that player, we need to look at the `players` dataset.
    If you scroll through the `players` data, or if you run `print(players.loc[7,'name'])`
    in Python, you can see that this player is Juan Mata.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，第一脚射门是由 `shooterID` 为 554 的球员完成的。如果我们想知道这名球员的名字，我们需要查找 `players` 数据集。如果你浏览
    `players` 数据，或者在 Python 中运行 `print(players.loc[7,'name'])`，你会看到这名球员是胡安·马塔（Juan
    Mata）。
- en: Getting Familiar with SQL
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 熟悉 SQL
- en: 'Let’s go over some SQL code that will enable you to do these kinds of lookups.
    We’ll start by looking at SQL code, and we’ll discuss how to run the code later.
    Individual SQL commands are usually called SQL *queries*. The following code is
    a SQL query that will show you the entire `players` dataset:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些 SQL 代码，这些代码将帮助你进行此类查找。我们先从 SQL 代码开始，然后再讨论如何执行这些代码。单独的 SQL 命令通常被称为 SQL
    *查询*。以下代码是一个 SQL 查询，它将展示整个 `players` 数据集：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Often, short SQL queries are simple to interpret as long as you know English.
    In this snippet, `SELECT` tells us that we’re selecting data. The `FROM` `playertable`
    text at the end of the query means that we’ll be selecting data from the table
    called `playertable`. Between `SELECT` and `FROM playertable` is where we’re supposed
    to specify the columns we want to select from the `playertable` data. The asterisk
    (`*`) is a shortcut that means that we want to select all the columns of the `playertable`
    table. The semicolon (`;`) tells SQL that we’ve finished this particular query.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this SQL query selects our entire `players` table. If you don’t want to
    select all the columns of the data, you can replace the `*` with the names of
    one or more columns. For example, both of the following are also valid SQL queries:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first query will select only the `playerID` column from the `playertable`.
    The second will select both the `playerID` and the `name` columns from the `playertable`
    table—the output we get from specifying that we want both columns by name is the
    same as the output we get from writing an asterisk.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that our SQL queries use all caps for their keywords. This
    is a common practice when writing SQL queries, though it’s not technically required
    in most environments. We’ll do it to follow convention.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up a SQL Database
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you paste the preceding SQL queries directly into a Python session, they
    won’t run correctly; they’re not Python code. If you’re running SQL frequently,
    you will probably want to set up an environment that’s designed for editing and
    running SQL queries. However, this is a Python book, and we don’t want to get
    you bogged down in the details of setting up a SQL environment. Instead, let’s
    go over a few steps that will allow you to run SQL queries directly in Python.
    You can start by running the following commands in Python:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we import the SQLite3 package, which allows us to run SQL queries in
    Python. SQL is a language that’s designed to work with databases, so we need to
    use SQLite3 to connect to a database. On the second line, we tell SQLite3 to connect
    to a database called `soccer.db`. You probably don’t have a database on your computer
    called `soccer.db`, so there may be nothing for SQLite3 to connect to. That’s
    all right, because the SQLite3 module is very helpful: when we specify a database
    we want to connect to, it will connect to the database if it exists, and if we
    try to connect to a database that doesn’t exist, it will create the database for
    us and then connect to it.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re connected to our database, we need to define a *cursor* to access
    this database. You can think of this cursor as similar to the cursor you use on
    your computer; it helps you select and manipulate objects. If that’s not clear
    to you now, don’t worry. The way we use this cursor will become clearer later.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a database, we want to fill it up. Usually, a database contains
    a collection of tables, but our `soccer.db` database is currently empty. The three
    pandas dataframes we’ve worked with so far can all be saved to our database as
    tables. We can add the `players` dataframe to our database with one line:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we use the `to_sql()` method to push our `players` dataframe to the database’s
    `playertable` table. We use the connection we created before, called `conn`, which
    ensures that the table gets pushed to our `soccer.db` database. Now the players
    data is stored in our database instead of being accessible only as a pandas dataframe
    in our Python session.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Running SQL Queries
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’re finally ready to run our SQL query on our data. This is Python code that
    will run our SQL query:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can see that the cursor we created, `curr`, is finally useful. The cursor
    is the object we’ll use to execute SQL queries on our data. In this case, we execute
    a simple query that selects the entire table called `playertable`. It’s important
    to note that this has selected the data, but it hasn’t displayed it. If we want
    to actually see the data that we selected, we need to print it to our console:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The cursor has selected the data and pushed it to your Python session’s memory,
    but we need to use the `fetchall()` method to access this data. When you run `fetchall()`,
    it selects a list of rows. That’s why we print each row individually in a `for`
    loop. The `playertable` table has thousands of rows, and you may not want to print
    all of them to your screen at once. You can limit the number of rows returned
    by your query by adding a `LIMIT` clause:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we run the same code as before, adding only seven characters: `LIMIT
    5`. By adding `LIMIT 5` to the SQL query, we limit the rows that are returned
    to only the first five. Since we get only the top five rows in the table, printing
    them to the screen becomes easier. This shows us the same data as we see when
    we run `print(players.head())` when we’re using pandas in Python. But be careful:
    in this case, `LIMIT 5` will give us the top five rows, but in other database
    environments, it will give you a random five rows. You can depend on getting five
    rows from the `LIMIT 5` clause, but you can’t always be sure which five you’ll
    get.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'We often want only particular subsets of our data. For example, what if we
    want to find the player with a particular ID:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we run much of the same code, but we add a `WHERE` clause. Instead of
    selecting the whole table, we select only rows for which a particular condition
    is true. The condition we’re interested in is `playerID=554`. The output shows
    us one row, and that row tells us that the player with `playerID` equal to 554
    is named Juan Mata. This tells us what we wanted to know, that Juan Mata is the
    person who took the first shot recorded in the data. You should be starting to
    notice a pattern here: when creating SQL queries, we start with a short query
    that selects a whole table, and then we add *clauses* to the query (like the `LIMIT`
    clause or `WHERE` clause we added here) to refine the results we get. SQL queries
    consist of many clauses, each of which has an effect on the data the query selects.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `WHERE` clauses to select all sorts of conditions. For example,
    we can use a `WHERE` clause to select the ID of a player with a particular name:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also use the `AND` operator to specify multiple conditions:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this case, we select the rows of the `playertable` that satisfy two conditions
    simultaneously: both `playerID>100` and `playerID <200`.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'You may want to look up a name in a table, but feel uncertain about the spelling.
    In that case, you can use the `LIKE` operator:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this case, we’re using the percent character (`%`) as a *wildcard*, meaning
    that it stands for any collection of characters. You may notice that this is similar
    to the way we used the asterisk earlier in the query (`SELECT *`). We use `*`
    to mean all columns and `%` to mean any possible character. But though these uses
    are similar (both representing unknown values), they’re not interchangeable, and
    there are two important differences. First, the `*` can be used as part of a query
    itself, while the `%` can be used only as part of a string of characters. Second,
    the `*` is used to refer to columns, and the `%` is used to refer to other characters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'When you look at the results of this code, you can see that we’ve found several
    players whose names start with *Juan M*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If what we’ve done so far feels familiar, it should. The string we searched
    for, `Juan M%`, is a regular expression, just like the regular expressions we
    covered in Chapter 8. You can see that every programming language has its own
    rules and syntax, but huge overlaps occur across these languages. Most languages
    allow the use of regular expressions to search for text. Many languages allow
    you to create tables and select their top five rows. Often, when you learn a new
    programming language, you’re not learning totally new capabilities, but rather
    learning to do things you’ve already done in new ways.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: You can create and work with tables by using Python and pandas, as well as SQL.
    The advantage of using SQL is that in many cases, SQL can be faster, more reliable,
    and more secure than pandas. It also may have compatibility with some programs
    that do not allow you to use Python and pandas.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Combining Data by Joining Tables
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we’ve worked with our players table. But we can also work with our
    other tables. Let’s read in our `games` table, push it to our soccer database,
    and then select its top five rows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了我们的球员表。但我们也可以使用其他的表。让我们读取`games`表，将其推送到我们的足球数据库中，然后选择前五行：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This snippet does everything we did previously with the `players` table: reads
    it, converts it to a SQL database table, and selects rows from it. We can do the
    same thing yet again, for our `shots` table:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段完成了我们之前在`players`表中做的所有操作：读取它，将其转换为SQL数据库表，并从中选择行。我们可以再次对`shots`表做相同的事情：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, our database has three tables: one for players, one for shots, and one
    for games. This situation is a little new to us. Throughout most of this book,
    we’ve had data conveniently gathered into a single table in each of our chapters.
    However, the data you’re interested in could be spread across several tables.
    In this case, we already noticed that our `shots` table has detailed information
    about individual shots, but it doesn’t have the name of the player who took each
    shot. To find out the name of the player who took a shot, we have to find the
    `shooterID` in the `shots` table and then look up this ID number in the `players`
    table.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的数据库中有三张表：一张是球员表，一张是投篮表，另一张是比赛表。这对我们来说有点新颖。在本书的大部分内容中，我们的数据都集中在每个章节中的单一表格中。然而，你感兴趣的数据可能会分散在多个表中。在这种情况下，我们已经注意到我们的`shots`表包含了关于每次投篮的详细信息，但没有包含投篮球员的名字。为了找出投篮球员的名字，我们需要在`shots`表中查找`shooterID`，然后在`players`表中查找该ID号。
- en: We have to do matching and lookups across multiple tables. If we have to do
    this only once or twice, manually scrolling through tables is probably not a big
    deal. But if we have to get the names of players who took thousands of shots,
    using manual lookups over and over again will become extremely time-consuming.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在多张表之间进行匹配和查找。如果我们只需要做一两次，手动滚动查看表格可能不是大问题。但如果我们需要获取投篮了数千次的球员名字，反复使用手动查找将变得非常耗时。
- en: Instead, imagine if we could automatically combine the information in these
    two tables. This is a natural specialty of SQL. We can see what we need to do
    in [Figure 11-1](#figure11-1).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，假设我们能自动将这两张表中的信息结合起来。这是SQL的一个自然特性。我们可以在[图11-1](#figure11-1)中看到我们需要做的事情。
- en: '![](image_fi/502888c11/f11001.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502888c11/f11001.png)'
- en: 'Figure 11-1: Joining two tables together, so lookups become easier and faster'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-1：连接两张表，使得查找变得更加容易和快速
- en: 'You can see that if we join two tables together, we no longer have to look
    at multiple tables to find all the information we need. Each row contains not
    only the information from the `shots` table but also the shooter name from the
    `players` table. We’re going to accomplish the joining illustrated in [Figure
    11-1](#figure11-1) by using a SQL query:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，如果我们将两张表连接起来，就不再需要查看多个表来获取我们需要的所有信息。每一行不仅包含来自`shots`表的信息，还包含来自`players`表的投篮球员名字。我们将通过使用SQL查询来完成[图11-1](#figure11-1)所示的连接操作：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let’s look at this snippet, one piece at a time. We start with `SELECT *`, just
    like our previous SQL queries. Next, we have `FROM shotstable`, indicating that
    we’ll be selecting from the table called `shotstable`. However, that’s where the
    difference starts. We see `shotstable JOIN` `playertable`, indicating that we’re
    not going to select only from the `shotstable`, but instead want to join these
    two tables and select from the combined table.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看这个代码片段。我们从`SELECT *`开始，就像我们之前的SQL查询一样。接下来是`FROM shotstable`，表示我们将从名为`shotstable`的表中选择数据。然而，差异从这里开始。我们看到`shotstable
    JOIN playertable`，这意味着我们不仅仅从`shotstable`中选择数据，而是想将这两张表连接起来，并从合并后的表中选择数据。
- en: But how should they be joined? We need to specify the way to join these two
    tables. Specifically, we’re going to join these tables by looking up where the
    IDs match. Every place where the `shotstable` column called `shooterID` is the
    same as the `playertable` column called `playerID`, we know that our rows match,
    and we can join them together. Finally, we add `LIMIT 5`, indicating that we want
    to see only the top five rows so the quantity of output rows isn’t overwhelming.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这两张表应该如何连接呢？我们需要指定连接这两张表的方式。具体来说，我们将通过查找ID是否匹配来连接这些表。每当`shotstable`表中的`shooterID`与`playertable`表中的`playerID`匹配时，我们就知道我们的行是匹配的，并可以将它们连接起来。最后，我们添加`LIMIT
    5`，表示我们只想看到前五行，以避免输出的行数过多。
- en: 'We can run this SQL query in Python as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Python中运行以下SQL查询：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, we run the SQL query explained previously on the tables in our database.
    Our SQL query joins our tables together in the way shown in [Figure 11-1](#figure11-1).
    In that figure, you can see that for every shooter ID, we found the player with
    a matching player ID and added that player’s name to the matching row of the joined
    table. Our query does the same thing: since we specify `WHERE shotstable.shooterID=playertable.playerID`,
    it will find all matches between `shooterID` values (from the `shotstable`) and
    `playerID` values (from the `playertable`). After finding those matches, it will
    combine information from rows that match, and the final result will be a joined
    table with more complete information.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们运行了前面解释的 SQL 查询，查询的是我们数据库中的表格。我们的 SQL 查询以 [图 11-1](#figure11-1) 中所示的方式将表格连接在一起。在该图中，你可以看到，对于每个投篮者
    ID，我们找到了与之匹配的球员 ID，并将该球员的名字添加到了连接表格的匹配行中。我们的查询也做了同样的事情：由于我们指定了 `WHERE shotstable.shooterID=playertable.playerID`，它会查找
    `shooterID`（来自 `shotstable`）和 `playerID`（来自 `playertable`）之间的所有匹配项。在找到这些匹配项后，它会将匹配行中的信息结合在一起，最终的结果将是一个包含更多完整信息的连接表格。
- en: 'After we run our query, we print out the rows that the query has returned.
    Overall, we’ve followed the same process we followed before: executing a query
    with the cursor, then fetching what we selected and printing it to the console.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行查询后，我们会打印出查询返回的行。总体而言，我们遵循了之前相同的流程：使用光标执行查询，然后获取所选的数据并将其打印到控制台。
- en: 'The output looks like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下所示：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can see that this output shows the data we want: shots, combined with information
    about the players who made the shots (their names are the last element of each
    row). Joining tables in this way can be valuable to enable advanced analyses like
    the ones we’ve done in previous chapters.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，输出结果展示了我们想要的数据：投篮数据，以及关于投篮球员的信息（球员的名字是每行的最后一个元素）。以这种方式连接表格可以为进行更复杂的分析提供有价值的数据支持，就像我们在前几章中所做的那样。
- en: Joining tables may seem simple, but the process has many subtleties that you
    should learn about if you want to become great at SQL. For example, what happens
    if you have a shot with an ID that doesn’t appear in the `players` table? Or,
    what if two players have the same ID—how will we know which player took a shot
    that had their ID assigned to it? By default, SQL performs joining with `INNER
    JOIN`. An inner join will return nothing if no player ID matches a particular
    shooter ID; it will give you only rows where it knows exactly which player took
    a shot. But SQL provides other types of joins, and each uses different logic and
    follows different rules.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 连接表格看起来可能很简单，但这个过程有很多细微之处，如果你想在 SQL 上做到精通，这些细节是你需要了解的。例如，如果你有一个 ID 不出现在 `players`
    表中的投篮记录会发生什么？或者，如果两个球员有相同的 ID——我们如何知道哪个球员投出了那个 ID 的投篮？默认情况下，SQL 使用 `INNER JOIN`
    来执行连接。如果没有球员 ID 与特定的投篮者 ID 匹配，内连接将不会返回任何结果；它只会返回那些能够精确知道是哪个球员投篮的行。但 SQL 还提供了其他类型的连接，每种连接使用不同的逻辑并遵循不同的规则。
- en: This is not a SQL book, so we won’t go into every detail of the language and
    every type of join. When you study SQL more deeply, you’ll learn that advanced
    SQL capabilities usually consist of more and more sophisticated ways to select
    data and join tables. For now, you can feel proud that you’re able to do basic
    SQL queries. You’re able to put data in a database, select data from tables, and
    even join tables together.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一本 SQL 书籍，因此我们不会深入讨论 SQL 语言的每个细节以及每种连接方式。当你深入学习 SQL 时，你会了解到，SQL 的高级功能通常包括越来越复杂的选择数据和连接表格的方式。目前，你可以为自己感到自豪，因为你已经能够执行基本的
    SQL 查询了。你能够将数据存入数据库，从表格中选择数据，甚至将多个表格连接起来。
- en: Winning Soccer Games with R
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 R 赢得足球比赛
- en: R is another language that can be useful for a data science career. Let’s go
    over how to run R commands that will help you with your soccer management career.
    Just as we did with SQL, we can run our R commands from within a Python session
    instead of worrying about setting up an R environment. In many ways, R is similar
    to Python, so after gaining Python skills for data science, you may find that
    picking up R skills is less challenging.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: R 是另一种对数据科学职业非常有用的语言。让我们来学习如何运行一些 R 命令，这些命令将帮助你在足球管理的职业生涯中取得成功。就像我们使用 SQL 一样，我们可以在
    Python 会话中运行 R 命令，而不必担心设置 R 环境。在许多方面，R 与 Python 非常相似，因此在掌握 Python 数据科学技能之后，你会发现掌握
    R 技能相对容易一些。
- en: Getting Familiar with R
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 熟悉 R 语言
- en: 'Let’s start by looking at some R code. Just as we did with SQL queries, we’ll
    start by looking at the R code before running it:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下一些 R 代码。就像我们对 SQL 查询的处理一样，我们也先看一下 R 代码，然后再执行它：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first line defines a variable called `my_variable`. If we were writing Python,
    the equivalent statement would be `my_variable=512`. In R, we use `<-` instead
    of `=`, because in R, `<-` is the *assignment operator*—the collection of characters
    used to define the values of variables. The `<-` characters are meant to resemble
    an arrow pointing from right to left, indicating that the number 512 is being
    pushed from the right to be assigned as the value of `my_variable`. After we assign
    the variable, we can add to it, or print it out, or do anything else we want with
    it. In our snippet, we print out the value of our variable plus 12 by writing
    `print(my_variable+12)`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like when we were running SQL queries, you may wonder: How can we run
    this R code? If you’d like, you can download R and set up an R environment where
    this code can be run. But instead, we can run it from within the comfort of our
    Python session, after some straightforward preparation. Let’s start by importing
    a module we need:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this case, the rpy2 package will be helpful for running R commands within
    a Python session. Now that we’ve imported our package, running R code is a breeze:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is similar to what we did to run SQL code. We can use the `robjects.r()`
    function to run any R code within a Python session. You can see that the output
    shows 524, the result of the addition we did in the code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we’ve run simple R code, but nothing related to your soccer management
    job. Let’s run R code related to our soccer data, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, the first line reads our *players.csv* file, using the `read.csv()` command.
    We store the data in the `players` variable by using the same assignment operator
    as before (`<-`). In the second line, we print the top few rows of the data.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: By looking at this R code, you can see some differences between R and Python.
    In Python, we use `pd.read_csv()`, and in R, we use `read.csv()`. Both are functions
    for reading *.csv* files, but there are small differences in the way they’re written.
    Similarly, in Python, we need to use `players.head()` to get the top rows of the
    data. In R, we use `head(players)`. When we’re working with pandas datasets, the
    `head()` method gives us the top five rows. But in R, the `head()` function gives
    the top six rows. R and Python have many similarities, but they are not identical.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'We can read our other tables in the same way:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This time, we read and print the top few rows of the `shots` data. We can also
    print out the top few elements of particular columns of our data:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In R, the dollar sign (`$`) is used to refer to columns by name. This snippet
    prints out the head (top six elements) of the `minute` and `positionX` columns
    in our `shots` data. The `minute` column has the following top six elements:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'These are the minutes at which the first six shots (in our data) were taken.
    The first six elements of `positionX` are these:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These are the x-positions at which these first six shots (in our data) were
    taken. Here, we use the term *x-position* to mean how far “down the field” each
    shot was taken. One team’s goal has an x-position of 0, and the other team’s goal
    has an x-position of 1, so the x-position tells us how close to the opposing team’s
    goal a particular shot was taken.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Applying Linear Regression in R
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whenever we look at data, we can try to learn from it. One thing we might want
    to learn is how shots from the beginning of the game are different from shots
    at the end of the game. How does the time during the game influence the position
    from which shots are being taken? Several hypotheses could be true:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Offensive players could get more tired and desperate as a game progresses, so
    they start to take shots from farther away from the goal (a lower x-position).
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defensive players could get more tired and careless as a game progresses, so
    players are able to take shots from closer to the goal (a higher x-position).
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maybe neither of the first two hypotheses is true, or another pattern exists
    in the relationship between the minutes of a game and the x-position of shots.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To decide which of these hypotheses is true, we can try linear regression in
    R:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, we use the `lm()` command to run a linear regression. This regression
    attempts to find the relationship between the `minute` variable and the `positionX`
    variable in our `shots` data. Just as we did in Chapter 2, we want to look at
    the coefficients that are part of the output of every linear regression. Remember
    that the coefficient can be interpreted as the slope of a line. If we find a positive
    coefficient from this regression, we interpret that to mean that people take shots
    that are closer to the goal later in the game. If we find a negative coefficient,
    we interpret that to mean that people take shots that are farther from the goal
    later in the game. When we look at the output of our linear regression code, we
    see that it looks like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you look in the `Estimate` column of this output, you can see that the estimated
    coefficient for the `minute` variable is `5.251e-05`. This is a positive coefficient,
    so as games progress through time, we expect to see shots that are (slightly)
    closer to the goal.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Using R to Plot Data
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we’ve performed our regression, we can draw a plot of our data, together
    with the regression results:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the first line, we use the `png()` command. This tells R to open a file to
    draw a plot on. We also have to specify a filename where we’ll write the file.
    Next, we use the `plot()` command. We specify what we’ll put on the x-axis first,
    and then we specify the y-axis. The `abline()` command is used to draw a line
    for our regression output. Finally, we run `dev.off()`. This command turns off
    the graphics device, meaning it tells R that we’ve finished the plotting, and
    the file should be written to your computer’s memory. After you run this snippet,
    you should be able to see the file saved to your laptop; it should look like [Figure
    11-2](#figure11-2).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502888c11/f11002.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-2: The x-position of shots at each minute of thousands of soccer
    games, with a regression line'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: If you have trouble finding the output file on your laptop, you can change the
    filename argument in the preceding snippet. For example, you can write `png(filename='``/home/Yossarian/Documents``/plotoutput.png')`
    to save it to any specific location on your computer.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: You can see a huge number of shots on this plot, and many are being plotted
    right on top of one another. The regression line is barely visible—you can see
    it poking out at the left and right of the plot close to where *y* is about 0.85\.
    It has a positive slope, but it’s only slightly positive; very little pattern
    can be discerned in the shot locations by minute of soccer games. This is something
    that you could have done with Python, using the code and ideas from Chapter 2,
    but now you’re able to do it in another language as well.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: This one plot and one regression won’t make you a perfect soccer manager yet,
    but it will give you information and context that will be helpful as you study
    what it takes to win soccer games and help your team succeed. Instead of relying
    on theories or hearsay, you have the skills of a data scientist, so you can determine
    what works well in soccer games by examining the data directly. After reading
    this chapter, you can examine data and learn from it not only with Python but
    also with SQL and R.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do so much more with R; anything we’ve done with Python in this book
    can also be done with R. In addition to plots and linear regression, you could
    do supervised learning, k-means clustering, and much more. But already, you know
    how to do a lot: you can read data, calculate a regression, and draw a plot.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Gaining Other Valuable Skills
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After you finish this book and close it, you’ll have some strong data science
    skills. But you can always learn more. One thing you should consider is gaining
    proficiency in even more programming languages. In addition to Python, SQL, and
    R, there are many other programming languages that you might want to learn, at
    least at a beginner or intermediate level. Here are some other languages that
    you might consider learning:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '**C++**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: C++ is a high-performance language; code written in C++ is powerful and fast.
    It tends to be harder to work with than Python.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Scala**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Scala is used for working with big data—that is, datasets that have millions
    or billions of rows.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Julia**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Julia has been growing in popularity in recent years, gaining a reputation for
    efficiency and the speed of mathematical calculations.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**JavaScript**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is extremely common in web programming. It enables you to create
    dynamic, interactive websites.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**MATLAB**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Short for *matrix laboratory*, MATLAB was designed for precision in mathematical
    calculations, including matrix manipulation. It’s often used for scientific computing,
    but only by people or institutions that can afford its hefty price tag.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SAS, Stata, SPSS**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: These are proprietary statistics packages. Stata is in common use among professional
    economists. SPSS, owned by IBM, is commonly used by some social scientists. SAS
    is used by some businesses. Just like MATLAB, all of these languages also have
    hefty price tags that often persuade people to use free alternatives like Python,
    SQL, and R.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Besides these, many others exist. Some data scientists say that a data scientist
    should be a better programmer than any statistician, and a better statistician
    than any programmer. Speaking of statistics, you may want to study the following
    topics in advanced statistics further:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '**Linear algebra**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Many statistical methods like linear regression are, at heart, linear algebra
    methods. When you read textbooks related to advanced data science or advanced
    machine learning, you will see notation from linear algebra, and linear algebra
    ideas like matrix inversion. If you can gain deep knowledge of linear algebra,
    you’ll be better able to master these advanced topics.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Bayesian statistics**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: In recent decades, a set of statistical techniques known as *Bayesian statistics*
    have become popular. Bayesian techniques allow us to reason effectively about
    our levels of confidence about different ideas and how we update our beliefs in
    the face of new information. They also allow us to use our prior beliefs in our
    statistical inferences and reason carefully about the uncertainty we have about
    statistical models.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Nonparametric statistics**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Like Bayesian statistics, nonparametric methods allow us to reason about data
    in new ways. Nonparametric methods are powerful because they require us to make
    very few assumptions about data, so they’re robust and applicable to all kinds
    of data, even data that isn’t “well behaved.”
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Data science is about more than statistical theory. It’s also about deploying
    technology. Here are some technical skills related to technology deployment you
    will want to gain:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '**Data engineering**'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: In most of the chapters of this book, we provided you clean data for analysis.
    However, in many real-life scenarios, you’ll receive data that’s messy, incomplete,
    badly labeled, constantly changing, or otherwise in need of careful management.
    Data engineering is a set of skills for working with big, unruly datasets in a
    careful and effective way. You may find yourself working at a company that has
    data engineers on staff to clean and prepare data for you, but you’ll likely find
    yourself in many situations where you need to do these tasks yourself.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**DevOps**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: After a data scientist performs some analysis, more steps are often required
    before the analysis is useful. For example, if you use linear regression to do
    forecasting, you may want to install the regression on a server and have it performed
    regularly. How and where will you install it? Do you need to update it regularly?
    How will you monitor it? How and when will you redeploy it? These kinds of questions
    are related to machine learning DevOps, also called *MLOps*, and if you can gain
    some DevOps and MLOps skills, you can have more success in your data science career.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Advanced/fluent/efficient programming**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: A beginner data scientist can write code that works. A talented data scientist,
    by contrast, can write code that’s efficient. It will run fast, and will be readable
    and concise.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Besides these skills, you will want to gain expertise in applied fields related
    to the work you do (or the work you want to do). If you’re interested in working
    as a data scientist in the world of finance, you should study mathematical finance
    and the types of quantitative models that top finance companies use. If you’re
    interested in working for a pharmaceutical or medical company, you should consider
    biostatistics or even just pure biology as fields to dive into. The more you know,
    the more effective you’ll be in your data science career.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we discussed other languages besides Python that can be useful
    for data scientists. We started with SQL, a powerful language used to work with
    tables. We used SQL to select data from tables as well as to join tables together.
    We continued with a discussion of R, a language designed by statisticians that
    can be used for many powerful data analyses. Now you’ve completed the book, and
    you have excellent data science skills. Congratulations, good luck, and all the
    best!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
