- en: '**7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: VISUALIZATIONS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../Images/comm1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Perhaps the simplest way to discover insights in data is to represent that data
    graphically. Visualizations, like the one shown in [Figure 7-1](../Text/ch07.xhtml#ch07fig01),
    allow you to immediately identify patterns within your data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn how to generate visualizations for the syntactic
    structure of a sentence and the named entities in a document using spaCy’s built-in
    visualizers: the displaCy dependency visualizer and the displaCy named entity
    visualizer.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by exploring interactive demos of these visualizers, which are available
    on the Explosion AI website (Explosion AI is the maker of spaCy), to understand
    what the spaCy visualizers can accomplish. Next, you’ll learn to spin up a displaCy
    web server on your machine, allowing you to programmatically visualize a Doc object
    from within spaCy. You’ll also learn how to customize your visualizations. Finally,
    you’ll learn how to use displaCy to render manually prepared data without having
    to pass in a Doc object.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting Started with spaCy’s Built-In Visualizers**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s begin by exploring how the displaCy dependency visualizer and the displaCy
    named entity visualizer work. The quickest way to get started with spaCy’s built-in
    visualizers is to take advantage of their interactive demos available at *[https://explosion.ai/demos/](https://explosion.ai/demos/)*.
    On this page, you’ll find links to the demo pages for the two displaCy visualizers
    along with some other demo links.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '***displaCy Dependency Visualizer***'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The displaCy dependency visualizer generates a syntactic dependency visualization
    for a submitted text. To use its interactive demo, navigate to *[https://explosion.ai/demos/displacy/](https://explosion.ai/demos/displacy/)*.
    Replace the sample sentence in the “Text to parse” text box with your text, and
    then click the search icon (magnifying glass) at the right of the box to generate
    a visualization. The result might look like [Figure 7-1](../Text/ch07.xhtml#ch07fig01).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/fig7-1.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The displaCy dependency visualizer on the Explosion AI website*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The dependency visualizer shows the part-of-speech tags and syntactic dependencies
    in a submitted text, displaying its syntactic structure immediately.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The visualizer allows you to customize your graphic with the “Merge Punctuation”
    and “Merge Phrases” checkboxes. “Merge Punctuation” merges a punctuation mark
    to the preceding token, making a visualization more compact and therefore more
    readable. “Merge Phrases” merges each noun phrase into a single token, as shown
    in the example in [Figure 7-1](../Text/ch07.xhtml#ch07fig01). Both options are
    set by default.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: You can change either or both of these defaults by deselecting the corresponding
    box or boxes. For example, if you deselect the “Merge Phrases” box for “I want
    a Greek pizza now,” you’ll see a more detailed dependency parsing for this sentence
    that shows you the dependencies within the noun phrase “a Greek pizza.”
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过取消选中相应的框来更改这些默认设置中的一个或多个。例如，如果你取消选中“合并短语”框，对于句子“我现在想要一份希腊披萨”，你将看到更详细的依赖解析，展示名词短语“a
    Greek pizza”中的依赖关系。
- en: 'Keeping the “Merge Phrases” box selected allows you to get a more compact dependency
    tree, which can be especially useful when dealing with a sentence containing several
    noun phrases. For example, consider the following sentence: “I see a few young
    people working in their vegetable field.” It contains two noun phrases: “a few
    young people” and “their vegetable field.” The first one is the direct object
    of the verb “see,” and the second is the object of the preposition in the prepositional
    phrase that modifies the verb “work,” showing the dependency labels dobj and pobj,
    respectively. Strictly speaking, these dependency labels are related to the nouns
    in the corresponding phrases rather than to an entire sentence.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 保持选中“合并短语”框可以让你获得更简洁的依赖树，这在处理包含多个名词短语的句子时尤其有用。例如，考虑以下句子：“我看到一些年轻人在他们的蔬菜田里工作。”它包含两个名词短语：“一些年轻人”和“他们的蔬菜田”。第一个是动词“看到”的直接宾语，第二个是介词短语中表示“工作”的动词修饰的宾语，分别显示依赖标签
    dobj 和 pobj。严格来说，这些依赖标签与相应短语中的名词有关，而不是与整个句子有关。
- en: 'In addition to the “Merge Punctuation” and “Merge Phrases” options, you can
    choose a statistical language model to use from the list of available models.
    This option allows you to try a model for dependency parsing without downloading
    and installing it in your environment. Currently, you can choose from the following
    models: en_core_web_sm, en_core_web_md, and en_core_web_lg, as well as small (sm)
    models for other European languages, such as German, Spanish, Portuguese, French,
    Italian, and Dutch.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 除了“合并标点符号”和“合并短语”选项外，你还可以从可用模型列表中选择一个统计语言模型。这个选项允许你在不下载和安装模型的情况下尝试进行依赖解析。目前，你可以从以下模型中选择：en_core_web_sm、en_core_web_md
    和 en_core_web_lg，以及其他欧洲语言的小型(sm)模型，如德语、西班牙语、葡萄牙语、法语、意大利语和荷兰语。
- en: '***displaCy Named Entity Visualizer***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***displaCy 命名实体可视化工具***'
- en: The displaCy named entity visualizer generates a named entity visualization
    for a submitted text. You’ll find its interactive demo at *[https://explosion.ai/demos/displacy-ent/](https://explosion.ai/demos/displacy-ent/)*.
    From a user’s standpoint, it works similarly to the displaCy dependency visualizer
    demo discussed in the previous section. To generate a visualization for a text,
    enter it into the text box, and then click the search icon. The visualizer will
    process your query and output an original text at the bottom of the window, highlighting
    the named entities discovered along with their labels, as shown in [Figure 7-2](../Text/ch07.xhtml#ch07fig02).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: displaCy 命名实体可视化工具为提交的文本生成命名实体可视化。你可以在 *[https://explosion.ai/demos/displacy-ent/](https://explosion.ai/demos/displacy-ent/)*
    找到其互动演示。从用户的角度来看，它的工作方式类似于前面一节中讨论的 displaCy 依赖可视化演示。要生成文本的可视化，只需将其输入文本框中，然后点击搜索图标。可视化工具会处理你的查询，并在窗口底部输出原始文本，突出显示已发现的命名实体及其标签，如
    [图 7-2](../Text/ch07.xhtml#ch07fig02) 所示。
- en: You can choose what types of named entities the application should recognize
    in a submitted text by selecting or deselecting the boxes under “Entity labels”.
    In the example shown in [Figure 7-2](../Text/ch07.xhtml#ch07fig02), you add PERCENT
    and CARDINAL to the list of entity label types chosen by default. Adding the PERCENT
    entity type tells the visualizer to recognize phrases expressing a percentage
    or that include the “%” symbol. Adding the CARDINAL entity type guarantees that
    the visualizer will recognize phrases related to numerals in the submitted text.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过选中或取消选中“实体标签”下的框来选择应用程序应该在提交的文本中识别哪些类型的命名实体。在[图 7-2](../Text/ch07.xhtml#ch07fig02)中所示的示例中，你将
    PERCENT 和 CARDINAL 添加到默认选择的实体标签类型列表中。添加 PERCENT 实体类型会告诉可视化工具识别表示百分比或包含“%”符号的短语。添加
    CARDINAL 实体类型则保证可视化工具会识别与提交文本中的数字相关的短语。
- en: Which boxes you should select depends on your context. When processing a financial
    report, you might select the money and date boxes. But if the report includes
    records of the financial activities of more than one company, you might also want
    to select the ORG entity label box to instruct the visualizer to highlight company
    names in the text.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该选择哪些框取决于你的上下文。例如，在处理财务报告时，你可能会选择钱币和日期框。但如果报告包括多个公司的财务活动记录，你可能还想选择 ORG 实体标签框，以指示可视化工具在文本中突出显示公司名称。
- en: '![image](../Images/fig7-2.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig7-2.jpg)'
- en: '*Figure 7-2: The displaCy named entity visualizer on the Explosion AI website*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：Explosion AI 网站上的 displaCy 命名实体可视化工具*'
- en: '**Visualizing from Within spaCy**'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**从 spaCy 内部进行可视化**'
- en: Starting with spaCy v2.0, the displaCy visualizers are integrated into the core
    library. This means that you can start using them from within your Python code
    immediately after installing spaCy.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从 spaCy v2.0 开始，displaCy 可视化工具已集成到核心库中。这意味着你在安装 spaCy 后，可以立即在 Python 代码中使用它们。
- en: 'To do so, you must use the following process: start a built-in web server,
    and then send a Doc object (or a list of Doc objects) to it for rendering. The
    server will generate a visualization for the submitted Doc, which you can then
    view in your browser. We’ll walk through several examples in this section.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，你必须使用以下过程：启动内置的 Web 服务器，然后将一个 Doc 对象（或 Doc 对象列表）发送给它进行渲染。服务器将为提交的 Doc
    生成一个可视化，你可以在浏览器中查看它。在本节中，我们将演示几个例子。
- en: '***Visualizing Dependency Parsing***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***依存解析可视化***'
- en: 'The following script shows the simplest way to generate a dependency tree visualization
    for a sentence:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本展示了生成句子依存树可视化的最简单方法：
- en: import spacy
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: import spacy
- en: nlp = spacy.load('en')
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: nlp = spacy.load('en')
- en: ➊ doc = nlp(u"I want a Greek pizza.")
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ doc = nlp(u"I want a Greek pizza.")
- en: ➋ from spacy import displacy
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ from spacy import displacy
- en: ➌ displacy.serve(doc, ➍style='dep')
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ displacy.serve(doc, ➍style='dep')
- en: We create a Doc object to submit to displaCy ➊. Then we import the displaCy
    library from the core library ➋, after which we can start a displaCy web server,
    passing the Doc object to it. Both operations are done by calling the displacy.serve()
    method ➌. By setting parameter style to 'dep', we instruct displaCy to use the
    dependency visualizer ➍, generating a dependency tree visualization for the text
    in the Doc object. If you’re interested in implementing the checkbox options explored
    earlier in this chapter, reference “[Try This](../Text/ch07.xhtml#lev97)” on [page
    104](../Text/ch07.xhtml#page_104).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个 Doc 对象以提交给 displaCy ➊。然后我们从核心库导入 displaCy 库 ➋，之后可以启动一个 displaCy Web 服务器，将
    Doc 对象传递给它。这两个操作通过调用 displacy.serve() 方法完成 ➌。通过将 style 参数设置为 'dep'，我们指示 displaCy
    使用依存可视化工具 ➍，为 Doc 对象中的文本生成一个依存树可视化。如果你有兴趣实现本章前面探讨的复选框选项，请参考 [“试试这个”](../Text/ch07.xhtml#lev97)，并查看
    [第 104 页](../Text/ch07.xhtml#page_104)。
- en: 'Whether you run this code in a Python session or as a separate script, the
    execution enters an infinite loop and shows messages from the displaCy web server.
    The initial messages you should see are the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是以 Python 会话运行此代码，还是作为独立脚本运行，它都会进入一个无限循环并显示来自 displaCy Web 服务器的消息。你应该首先看到以下初始消息：
- en: Serving on port 5000...
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正在端口 5000 上提供服务...
- en: Using the 'dep' visualizer
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 'dep' 可视化工具
- en: This means that the server has generated a dependency tree visualization for
    the submitted text and serves HTTP requests on port 5000 (the default port) on
    your host. In practical terms, this means you can point your browser to *http://localhost:5000*
    to view the visualization. In this example, it should look like [Figure 7-3](../Text/ch07.xhtml#ch07fig03).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着服务器已为提交的文本生成了依存树可视化，并在主机的端口 5000（默认端口）上提供 HTTP 请求。实际操作中，这意味着你可以将浏览器指向 *http://localhost:5000*
    来查看可视化内容。在这个例子中，它应该看起来像 [图 7-3](../Text/ch07.xhtml#ch07fig03)。
- en: '![image](../Images/fig7-3.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig7-3.jpg)'
- en: '*Figure 7-3: An example of a dependency tree visualization you can generate
    from within your Python code and then view in your browser*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：一个依存树可视化示例，你可以从 Python 代码内部生成并在浏览器中查看*'
- en: 'To shut down the displaCy server, enter CTRL-C in the terminal in which you
    executed the script that started the server. As a result, you should see the following
    final message from the server:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭 displaCy 服务器，请在你执行启动服务器脚本的终端中按 CTRL-C。这样，你应该会看到服务器发出的以下最终消息：
- en: Shutting down server on port 5000.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正在关闭端口 5000 上的服务器。
- en: After shutting down the server, you won’t be able to generate a new copy of
    the visualization in your browser, but you’ll be able to view the copies you’ve
    already generated.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '***Try This***'
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Try using the named entity visualizer by altering the script for the dependency
    visualizer in the previous section. To instruct displaCy to apply the named entity
    visualizer, set the displacy.serve() method’s style parameter to 'ent'.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'To produce a more interesting visualization, you might use longer text containing,
    perhaps, more than one sentence. For example, try using the following text:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Windows is a family of proprietary operating systems developed and
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: sold by Microsoft. Bill Gates announced Microsoft Windows on November 10,
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 1983\. Microsoft first released Windows for sale on November 20, 1985\. Windows
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 1.0 was initially sold for $100.00, and its sales surpassed 500,000 copies in
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: April 1987\. For comparison, more than a million copies of Windows 95 were sold
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: in just the first 4 days.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: After calling the displacy.serve() method on the Doc object, point your browser
    to *http://localhost:5000* to view the visualization. Pay attention to the named
    entities and their types recognized by the entity recognizer in this sample text.
    In particular, you should see that the entity recognizer finds the names of persons,
    products, and companies, as well as phrases related to dates, numbers, and money.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '***Sentence-by-Sentence Visualizations***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Visualizing dependency trees works fine when you’re working with a single sentence.
    But the graphics can get long and space consuming when you’re visualizing a long
    text, making them difficult to read when displayed in one row. Although displaCy
    generates separate visualizations for each sentence, when you pass in a Doc containing
    more than one sentence, it lays them out in a single row.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of passing in a Doc object, you might want to visualize sentence-by-sentence.
    For example, this might be useful when you need to extract the meaning from an
    entire discourse and want to explore a sequence of sentences. Starting with version
    2.0.12, displaCy allows you to pass in Span objects and then lays out the visualizations
    in rows. You can pass in a list of doc.sents if you want to create one visualization
    for each sentence found in doc.sents, as shown in the following code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: import spacy
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: nlp = spacy.load('en')
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: doc = nlp(u"I have a relaxed pair of jeans. Now I want a skinny pair.")
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: ➊ spans = list(doc.sents)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: from spacy import displacy
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: displacy.serve(➋spans, style='dep')
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Chapter 3](../Text/ch03.xhtml#ch03), the Doc object’s doc.sents
    property is an iterator over the sentences in a Doc object. For this reason, you
    can’t use this property to refer to sentences by index, but you can iterate over
    them in a loop or create a list of Span objects where each span represents a sentence.
    In this code, we convert the sentences in the Doc into a list of Span objects ➊.
    Then we pass in that spans list to displacy.serve() to visualize ➋.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第3章](../Text/ch03.xhtml#ch03)中讨论的，Doc对象的doc.sents属性是一个迭代器，用于迭代Doc对象中的句子。因此，不能通过索引来引用这些句子，但你可以通过循环迭代它们，或创建一个Span对象的列表，其中每个span表示一个句子。在这段代码中，我们将Doc中的句子转换为Span对象列表 ➊。然后我们将这个span列表传递给displacy.serve()进行可视化
    ➋。
- en: This should generate one visualization for each sentence, laid out in rows,
    allowing you to view them by scrolling vertically.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该为每个句子生成一个可视化图，按行排列，允许你通过垂直滚动查看它们。
- en: '**Customizing Your Visualizations with the Options Argument**'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**自定义你的可视化与选项参数**'
- en: In addition to the docs and style arguments that you saw in the examples so
    far, the displacy.serve() method can take several other arguments. The options
    argument is perhaps one of the most interesting because it allows you to define
    a dictionary of settings to customize the layout of the visualization. We’ll cover
    some of the most useful options settings in this section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你在之前的例子中看到的docs和style参数，displacy.serve()方法还可以接受其他多个参数。options参数可能是最有趣的之一，因为它允许你定义一个设置字典来自定义可视化的布局。在本节中，我们将介绍一些最有用的选项设置。
- en: '***Using Dependency Visualizer Options***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用依赖可视化选项***'
- en: Long sentences can be difficult to view when they’re displayed in one row. In
    such cases, you can create visualizations in *compact mode*, which takes less
    space. For that you need to set the 'compact' option to True in the options argument,
    as illustrated in this script. The script also changes the font that the visualizer
    uses. (The entire list of available options in the displaCy API documentation
    is at *[https://spacy.io/api/top-level/#options-dep/](https://spacy.io/api/top-level/#options-dep/)*.)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 长句子在一行显示时可能难以查看。在这种情况下，你可以创建*紧凑模式*的可视化，它占用的空间较少。为此，你需要在选项参数中将“compact”选项设置为True，如本脚本所示。该脚本还更改了可视化器使用的字体。（displaCy
    API文档中所有可用选项的完整列表可以在*[https://spacy.io/api/top-level/#options-dep/](https://spacy.io/api/top-level/#options-dep/)*找到。）
- en: import spacy
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: import spacy
- en: nlp = spacy.load('en')
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: nlp = spacy.load('en')
- en: doc = nlp(u"I want a Greek pizza.")
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: doc = nlp(u"I want a Greek pizza.")
- en: from spacy import displacy
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: from spacy import displacy
- en: 'options = {➊''compact'': True, ➋''font'': ''Tahoma''}'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 'options = {➊''compact'': True, ➋''font'': ''Tahoma''}'
- en: displacy.serve(doc, style='dep', ➌options=options)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: displacy.serve(doc, style='dep', ➌options=options)
- en: 'The displacy.serve() method expects the options argument to be a dictionary.
    In this example, we set only two options: the ''compact'' option to True ➊ and
    the ''font'' option to ''Tahoma'' ➋, changing their defaults in both cases. (The
    visualizer lets you use most standard web fonts, such as Arial, Courier, and so
    on.) We then pass the dictionary of options in as the options argument ➌.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: displacy.serve()方法期望options参数是一个字典。在这个例子中，我们只设置了两个选项：'compact'选项为True ➊，以及'font'选项为'Tahoma'
    ➋，在这两种情况下都改变了默认值。（该可视化器允许你使用大多数标准网页字体，如Arial、Courier等。）然后我们将选项字典作为options参数传递给displacy.serve()
    ➌。
- en: '[Figure 7-4](../Text/ch07.xhtml#ch07fig04) shows what your browser should display
    when you point it to *http://localhost:5000* after running the script.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-4](../Text/ch07.xhtml#ch07fig04)展示了当你运行脚本后，浏览器指向*http://localhost:5000*时应该显示的内容。'
- en: The square arcs you see in the figure might look unusual, but they make the
    overall visualization more compact, which often can spare you from having to scroll
    to see the entire diagram.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图中看到的方弧可能看起来不太寻常，但它们使整体可视化更紧凑，这通常可以避免你必须滚动才能看到完整的图表。
- en: '![image](../Images/fig7-4.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig7-4.jpg)'
- en: '*Figure 7-4: An example of a customized dependency visualization*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：自定义依赖关系可视化的示例*'
- en: '***Try This***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***试试看***'
- en: In the dependency visualizer’s interactive demo discussed in “displaCy Dependency
    Visualizer” on [page 98](../Text/ch07.xhtml#page_98), you used the “Merge Phrases”
    and “Merge Punctuation” options. In spaCy, you can merge noun phrases into one
    token with the collapse_phrases option (Figure 7-1 shows the equivalent option
    on the displaCy visualizer website.), which is set to False by default. The collapse_punct
    option, which is responsible for attaching punctuation to tokens, is set to True
    by default.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第98页](../Text/ch07.xhtml#page_98)的“displaCy依赖可视化工具”互动演示中，您使用了“合并短语”和“合并标点符号”选项。在spaCy中，您可以使用collapse_phrases选项将名词短语合并为一个标记（图7-1显示了在displaCy可视化器网站上的等效选项），该选项默认设置为False。负责将标点符号附加到标记的collapse_punct选项默认设置为True。
- en: Change the code in the previous script so it sets the collapse_phrases option
    to True in the set of passed-in options. Run the script, and then view the generated
    visualization in your browser to make sure the noun phrases are displayed as a
    single token.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 修改之前脚本中的代码，使其在传入的选项集合中将collapse_phrases选项设置为True。运行脚本，然后在浏览器中查看生成的可视化结果，确保名词短语以单一标记的形式显示。
- en: '***Using Named Entity Visualizer Options***'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用命名实体可视化器选项***'
- en: The list of named entity visualizer options (available at *[https://spacy.io/api/top-level/#displacy_options-ent/](https://spacy.io/api/top-level/#displacy_options-ent/)*)
    is much shorter than the list of dependency visualizer options. When using the
    entity visualizer, you can choose which entity types to highlight with the 'ents'
    option and override default colors with the 'colors' option.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 命名实体可视化器选项的列表（可在*[https://spacy.io/api/top-level/#displacy_options-ent/](https://spacy.io/api/top-level/#displacy_options-ent/)*查看）比依赖关系可视化器选项的列表要短得多。使用命名实体可视化器时，您可以通过'ents'选项选择要突出显示的实体类型，并通过'colors'选项覆盖默认的颜色设置。
- en: The first option is the more important of the two, because it allows you to
    instruct the visualizer to highlight entities of selected types only. The following
    example illustrates a case when you might want to limit the entity types that
    the visualizer displays.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项是两个选项中更重要的一个，因为它允许您指示可视化器仅突出显示选定类型的实体。以下示例说明了一个您可能希望限制可视化器显示的实体类型的情况。
- en: In this script, we don’t provide any options for the entity visualizer, which
    means it will highlight entities of all types in the submitted Doc.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本中，我们未为命名实体可视化器提供任何选项，这意味着它将突出显示提交的Doc中的所有类型的实体。
- en: import spacy
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: import spacy
- en: nlp = spacy.load('en')
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: nlp = spacy.load('en')
- en: doc = nlp(u"In 2011, Google launched Google +, its fourth foray into social
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: doc = nlp(u"在2011年，Google推出了Google +，这是其在社交领域的第四次尝试")
- en: networking.")
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: networking.")
- en: ➊ doc.user_data['title'] = "An example of an entity visualization"
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ doc.user_data['title'] = "命名实体可视化示例"
- en: from spacy import displacy
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: from spacy import displacy
- en: displacy.serve(doc, style=➋'ent')
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: displacy.serve(doc, style=➋'ent')
- en: We use the Doc’s user_data attribute to set a title for the Doc ➊. The displaCy
    visualizer automatically puts the text in this attribute as a headline for the
    visualization. Adding a title to a visualization is optional but can be useful
    when you need to annotate your visualizations.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Doc的user_data属性为Doc设置标题➊。displaCy可视化器会自动将此属性中的文本作为可视化的标题。为可视化添加标题是可选的，但当您需要注释您的可视化时，它是很有用的。
- en: We set the style parameter of displacy.serve() to 'ent' ➋, instructing displaCy
    to use the named entity visualizer. The resulting visualization should look like
    the one in [Figure 7-5](../Text/ch07.xhtml#ch07fig05) (although these images are
    in grayscale, the website uses color).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将displacy.serve()的style参数设置为'ent' ➋，指示displaCy使用命名实体可视化器。生成的可视化效果应与[图7-5](../Text/ch07.xhtml#ch07fig05)中的内容相似（尽管这些图像是灰度的，但网站使用彩色图像）。
- en: '![image](../Images/fig7-5.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig7-5.jpg)'
- en: '*Figure 7-5: An example of a named entity visualization generated with default
    options*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-5：使用默认选项生成的命名实体可视化示例*'
- en: 'The visualization looks fine in general. But in this context, highlighting
    the ordinal number “fourth” is probably unnecessary. It’s hard to figure out why
    we might need to extract that information in this context. With the ''ents'' option,
    we select the entity types that we want the visualizer to highlight. The following
    code illustrates how to implement this. To see how it works, we replace the last
    line of code in the previous script with the following two lines of code, and
    then run the updated script:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'options = {➊''ents'': ["ORG", "PRODUCT", "DATE"], ➋''colors'': {"ORG": "aqua",'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '"PRODUCT": "aqua"}}'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: displacy.serve(doc, style='ent', options=options)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: This time, the visualizer shouldn’t recognize any entities except for those
    that are of the ORG, PRODUCT, or DATE type ➊. This example also illustrates the
    use of the 'colors' option that allows us to change the default colors assigned
    to entity types. In this example, we map the ORG and PRODUCT types to the color
    "aqua" ➋.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '*Using the ''colors'' option, you can map entity types to web color names or
    hex color codes. In the example on [page 105](../Text/ch07.xhtml#page_105), using
    the hex code "#00FFFF" would be equal to using the color name "aqua".*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-6](../Text/ch07.xhtml#ch07fig06) illustrates what the resulting visualization
    should look like.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/fig7-6.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: An example of an entity visualization generated with the ''ents''
    and ''colors'' options specified*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this visualization is almost identical to the one shown in [Figure
    7-5](../Text/ch07.xhtml#ch07fig05). But this time the visualizer doesn’t highlight
    the entity of type ORDINAL, because the 'ents' option list we’ve passed in doesn’t
    include this type.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '**Exporting a Visualization to a File**'
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the examples so far, we’ve used the displaCy web server to view the visualizations
    being generated. As you learned in these examples, you can open the visualization
    generated with the displacy.serve() method in your browser as long as the server
    started with this same invocation of displacy.serve() is running.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Using the displacy.render() method, you can avoid this limitation and create
    a visualization for later use. The displacy.render() method allows you to render
    the markup wrapped as an HTML page and then save it in a separate file. Later,
    you can open this file in any browser without having to invoke a web browser.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script shows how to use the displacy.render() method for the
    named entity visualization shown in [Figure 7-5](../Text/ch07.xhtml#ch07fig05):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: import spacy
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: nlp = spacy.load('en')
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: doc = nlp(u"In 2011, Google launched Google +, its fourth foray into social
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: networking.")
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: ➊ doc.user_data["title"] = "An example of an entity visualization"
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '#In the next block, you instruct displaCy to render the markup wrapped as a'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: full HTML page.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: from spacy import displacy
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: ➋ html = displacy.render(doc, style='ent', ➌page=True)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '#In the next block, you save the html file generated by displacy.render() to'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: disk on your machine.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 硬盘上的数据。
- en: ➍ from pathlib import Path
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ from pathlib import Path
- en: ➎ output_path = Path("/visualizations/ent_visual.html")
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ output_path = Path("/visualizations/ent_visual.html")
- en: ➏ output_path.open("w", encoding="utf-8").write(html)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ output_path.open("w", encoding="utf-8").write(html)
- en: We can divide the code in this script into three parts, each of which begins
    with a comment line. The first block should be familiar. Here, we create a text
    processing pipeline and then apply it to a text. Then we use the Doc’s user_data
    attribute to set a headline for the Doc ➊.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这段代码分为三个部分，每个部分以注释行开始。第一部分应该很熟悉。在这里，我们创建一个文本处理管道，然后将其应用于文本。接着，我们使用 Doc
    的 user_data 属性为 Doc 设置一个标题 ➊。
- en: In the second block, we render a named entity visualization for the Doc created
    in the previous step, using the displacy.render() method ➋. Unlike displacy.serve(),
    displacy.render() doesn’t run a web server but generates the HTML markup for a
    visualization. By setting the page argument to True, we instruct displacy.render()
    to generate the markup wrapped as a full HTML page ➌.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个代码块中，我们使用之前步骤创建的 Doc 渲染命名实体可视化，方法是使用 displacy.render() ➋。与 displacy.serve()
    不同，displacy.render() 不会运行 Web 服务器，而是生成可视化的 HTML 标记。通过将页面参数设置为 True，我们指示 displacy.render()
    生成完整 HTML 页面的标记 ➌。
- en: 'In the final block, we import the Path class from the pathlib module introduced
    in Python 3.4 ➍. We can use Path to perform system calls on path objects. In this
    example, we instantiate this class on the following path: */visualizations/ent_visual.html*
    ➎, assuming we already have the */visualizations* folder available in our local
    filesystem (otherwise, an exception is thrown). Then we open the *ent_visual.html*
    file (it will be created if it doesn’t already exist) in the */visualizations*
    folder and write the HTML page generated in the previous step to it ➏.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个代码块中，我们导入 pathlib 模块中的 Path 类，该模块是在 Python 3.4 中引入的 ➍。我们可以使用 Path 对路径对象执行系统调用。在这个示例中，我们在以下路径上实例化该类：*/visualizations/ent_visual.html*
    ➎，假设我们已经在本地文件系统中创建了 */visualizations* 文件夹（否则会抛出异常）。然后我们打开 *ent_visual.html* 文件（如果该文件不存在，将会创建）并将上一步生成的
    HTML 页面写入其中 ➏。
- en: To sum up, this script generates an HTML file containing a named entity visualization
    for the submitted text and saves that file in your filesystem. If you move to
    the folder where the file has been saved and double-click the file, it opens in
    your browser.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，这段脚本生成一个包含提交文本的命名实体可视化的 HTML 文件，并将该文件保存在你的文件系统中。如果你进入保存文件的文件夹并双击该文件，它将在浏览器中打开。
- en: '**Using displaCy to Manually Render Data**'
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 displaCy 手动渲染数据**'
- en: The displaCy visualizers allow you to manually create a dataset that you can
    then render rather than passing in data as either a doc or span. This can be useful
    when you need, for example, to visualize output from other NLP libraries or when
    you need to create a visualization using a set of custom tags or custom dependency
    labels. (I’ll discuss how to make these custom tags and labels in [Chapter 10](../Text/ch10.xhtml#ch10).)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: displaCy 可视化工具允许你手动创建数据集，然后渲染它，而不是将数据作为 doc 或 span 传递。这在你需要可视化来自其他 NLP 库的输出，或者需要使用一组自定义标签或自定义依赖标签来创建可视化时非常有用。（我将在[第10章](../Text/ch10.xhtml#ch10)讨论如何创建这些自定义标签和标签。）
- en: As an example, let’s manually render the sentence “I want a Greek pizza.”
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们手动渲染句子 “I want a Greek pizza.”。
- en: '***Formatting the Data***'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***格式化数据***'
- en: 'To begin with, you need to put your data in displaCy’s format: a dictionary
    containing two lists: "words" and "arcs", as illustrated in the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要将数据按照 displaCy 的格式放置：一个包含两个列表的字典："words" 和 "arcs"，如下代码所示：
- en: sent = {
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: sent = {
- en: '"words": ['
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '"words": ['
- en: '➊ {"text": "I", "tag": "PRON"},'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ {"text": "I", "tag": "PRON"}'
- en: '{"text": "want", "tag": "VERB"},'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '{"text": "want", "tag": "VERB"},'
- en: '{"text": "a", "tag": "DET"},'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '{"text": "a", "tag": "DET"},'
- en: '{"text": "Greek", "tag": "ADJ"},'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '{"text": "Greek", "tag": "ADJ"},'
- en: '{"text": "pizza", "tag": "NOUN"}'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '{"text": "pizza", "tag": "NOUN"}'
- en: '],'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: '"arcs": ['
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '"arcs": ['
- en: '➋ {"start": 0, "end": 1, "label": "nsubj", "dir": "left"},'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ {"start": 0, "end": 1, "label": "nsubj", "dir": "left"}'
- en: '{"start": 2, "end": 4, "label": "det", "dir": "left"},'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '{"start": 2, "end": 4, "label": "det", "dir": "left"},'
- en: '{"start": 3, "end": 4, "label": "amod", "dir": "left"},'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '{"start": 3, "end": 4, "label": "amod", "dir": "left"},'
- en: '{"start": 1, "end": 4, "label": "dobj", "dir": "right"}'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '{"start": 1, "end": 4, "label": "dobj", "dir": "right"}'
- en: ']'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '}'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'The sent dictionary contains two lists: "words" and "arcs", each of which,
    in turn, includes a set of dictionaries. A dictionary in the "words" list assigns
    a tag to a certain token in the sentence ➊, and a dictionary in the "arcs" list
    defines an arc in the dependency tree, connecting two syntactically related words
    in the sentence ➋. In this example, five words are in the sentence and four syntactic
    relations are defined on them. That’s why the dictionary contains five items in
    the "words" list and four items in the "arcs" list.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a dictionary with the data, we need to generate a dependency
    parsing visualization for the sample sentence; we can use the following code to
    render it:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: ➊ from spacy import displacy
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: displacy.serve(➋sent, style="dep", ➌manual=True)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Note that we don’t have to import the entire spaCy library. All we need to do
    is import the displacy module from it ➊. Then we invoke the displacy.serve() method,
    passing in the sent dictionary as the first parameter in place of a Doc object
    ➋. The third parameter, manual, tells displaCy that we created the dataset for
    rendering manually ➌, so displaCy doesn’t need to extract the data from a Doc
    object.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '***Try This***'
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you choose to manually create a dictionary with data to render into a visualization,
    you can use custom tags, specifying, for example, that the visualizer should use
    fine-grained part-of-speech tags instead of the coarse-grained tags used by default.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: You could accomplish this task by simply setting the fine_grained option to
    True when passing in a Doc object for rendering, but for practice, try to implement
    this manually.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: In the example from “[Formatting the Data](../Text/ch07.xhtml#lev101)” on [page
    108](../Text/ch07.xhtml#page_108), change the tags in the "words" list of the
    "sent" dictionary so their values are fine-grained tags. Next, start the displaCy
    server and instruct it to generate a visualization based on the data specified
    in the "sent" dictionary. Then point your browser to *http://localhost:5000* to
    view the visualization.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve seen syntactic structure visualizations in previous chapters, but in
    this chapter, you learned how to generate those visualizations using the displaCy
    dependency visualizer. You also learned to generate graphics of named entity information
    with the displaCy named entity visualizer.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
