- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Gaining Insights from Data
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据中获取洞察
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Companies generate vast amounts of data every day in the form of raw facts,
    figures, and events, but what does all that data really tell you? To extract knowledge
    and gain insight from the data, you need to transform, analyze, and visualize
    it. In other words, you need to turn the raw data into meaningful information
    that you can use to make decisions, answer questions, and solve problems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 公司每天生成大量的数据，以原始事实、数字和事件的形式存在，但所有这些数据到底告诉了你什么？要从数据中提取知识并获得洞察，您需要将其转换、分析和可视化。换句话说，您需要将原始数据转化为可以用来做决策、回答问题和解决问题的有意义信息。
- en: Consider the case of a supermarket that collects large volumes of customer transaction
    data. Analysts at the supermarket may be interested in studying this data to gain
    insight into customers’ buying preferences. In particular, they may want to perform
    a *market basket analysis*, a data mining technique that analyzes transactions
    and identifies items that are commonly purchased together. Armed with this knowledge,
    the supermarket could make more informed business decisions—for instance, about
    the layout of items in the store, or about how to bundle items together into discounts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个收集大量客户交易数据的超市的情况。超市的分析师可能有兴趣研究这些数据，以洞察客户的购买偏好。特别是，他们可能希望执行*市场篮子分析*，这是一种分析交易并识别常一起购买的物品的数据挖掘技术。有了这些知识，超市可以做出更加明智的业务决策，例如关于商店内物品的布局或如何将物品捆绑成折扣。
- en: In this chapter, we’ll explore this example in detail, examining how to gain
    insights from transaction data by performing a market basket analysis with Python.
    You’ll learn how to use the mlxtend library and the Apriori algorithm to identify
    items that are commonly purchased together, and you’ll see how that knowledge
    can be leveraged to make smart business decisions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细探讨这个例子，通过Python执行市场篮子分析，深入分析如何从交易数据中获取洞察。您将学习如何使用mlxtend库和Apriori算法识别常一起购买的项目，并了解如何利用这些知识做出明智的业务决策。
- en: Although identifying buyer preferences will be the focus of this chapter, this
    isn’t the only application for a market basket analysis. The technique is also
    used in domains such as telecommunications, web usage mining, banking, and health
    care. In web usage mining, for example, a market basket analysis can determine
    where the user of a web page will likely go next and generate associations of
    pages frequently visited together.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管识别购买者偏好是本章的重点，但这并不是市场篮子分析的唯一应用。该技术还用于电信、网络使用挖掘、银行和医疗等领域。例如，在网络使用挖掘中，市场篮子分析可以确定网页用户下一步可能去哪里，并生成经常一起访问的页面的关联。
- en: Association Rules
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联规则
- en: 'A market basket analysis is about measuring the strength of the relationships
    between objects based on their co-occurrence in the same transactions. The relationships
    between objects are represented as *association rules*, which are denoted as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 市场篮子分析是衡量对象之间基于它们在相同交易中共同出现的关系强度的技术。对象之间的关系表示为*关联规则*，如下所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`X` and `Y`, referred to as the *antecedent* and *consequent* of the rule,
    respectively, represent distinct *itemsets*, or groups of one or more items from
    the transaction data being mined. For example, an association rule that describes
    a relationship between the items *curd* and *sour cream* would be denoted like
    so:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`X` 和 `Y`，分别被称为*前项*和*后项*规则，表示从被挖掘的交易数据中分组的不同*项目集*，或者一个或多个项的组。例如，描述*curd*和*sour
    cream*项之间关系的关联规则将如下所示：'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this case, `curd` is the antecedent and `sour cream` is the consequent. The
    rule is asserting that people who buy curd are also likely to buy sour cream.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`curd`是前项，`sour cream`是后项。规则断言购买curd的人也可能购买sour cream。
- en: By itself, an association rule such as this doesn’t actually tell you very much.
    The key to a successful market basket analysis is to use the transaction data
    to evaluate the strength of association rules based on various metrics. To demonstrate,
    we’ll take a simple example. Suppose we have 100 customer transactions, 25 of
    which contain curd and 30 of which contain sour cream. Of those 30 transactions
    that contain sour cream, 20 transactions also contain curd. [Table 11-1](#table11-1)
    summarizes these figures.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 单独看这样一条关联规则，其实并不能告诉你太多。成功的市场篮分析的关键在于利用交易数据根据各种指标评估关联规则的强度。为了演示这一点，我们用一个简单的例子。假设我们有
    100 笔顾客交易，其中 25 笔包含奶酪，30 笔包含酸奶油。在这 30 笔包含酸奶油的交易中，有 20 笔同时包含奶酪。[表 11-1](#table11-1)
    汇总了这些数据。
- en: 'Table 11-1: Transaction Figures for Curd and Sour Cream'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11-1：奶酪和酸奶油的交易数据
- en: '|  | **Curd** | **Sour cream** | **Curd and sour cream** | **Total** |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|  | **奶酪** | **酸奶油** | **奶酪和酸奶油** | **总计** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| **Transactions** | 25 | 30 | 20 | 100 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **交易数量** | 25 | 30 | 20 | 100 |'
- en: Given this transaction data, we can evaluate the strength of the association
    rule `curd -> sour cream` using metrics such as support, confidence, and lift.
    These metrics will help us gauge whether or not there truly is an association
    between curd and sour cream.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些交易数据，我们可以使用支持度、置信度和提升度等指标来评估 `奶酪 -> 酸奶油` 关联规则的强度。这些指标将帮助我们判断奶酪和酸奶油之间是否确实存在关联。
- en: Support
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持度
- en: '*Support* is the ratio of transactions that include one or more items to the
    total number of transactions. For example, the support for curd in the sample
    transaction data can be calculated as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*支持度*是至少包含一个项目的交易占总交易数的比例。例如，可以如下计算样本交易数据中奶酪的支持度：'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the context of an association rule, support is the ratio of transactions
    that include both the antecedent and consequent to the total number of transactions.
    The support of the `curd -> sour cream` association rule is therefore:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在关联规则的上下文中，支持度是同时包含前件和后件的交易占总交易数的比例。因此，`奶酪 -> 酸奶油` 关联规则的支持度为：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The support metric falls in the range of 0 to 1, and it tells you what percent
    of the time an itemset appears in a transaction. In this case, we can see that
    20 percent of transactions included both curd and sour cream. Support is symmetric
    for any given association rule; that is, the support for `curd -> sour cream`
    is the same as the support for `sour cream -> curd`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 支持度指标的范围是 0 到 1，它告诉你一个项目集在交易中出现的百分比。在这种情况下，我们可以看到 20% 的交易同时包含了奶酪和酸奶油。对于任何给定的关联规则，支持度是对称的；也就是说，`奶酪
    -> 酸奶油` 的支持度与 `酸奶油 -> 奶酪` 的支持度是相同的。
- en: Confidence
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 置信度
- en: 'The *confidence* of an association rule is the ratio of transactions where
    both the antecedent and consequent are bought to transactions where the antecedent
    is bought. In other words, confidence measures what share of transactions containing
    the antecedent also contain the consequent. The confidence for the `curd -> sour
    cream` association rule can be calculated as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关联规则的 *置信度* 是同时购买前件和后件的交易占购买前件的交易数的比例。换句话说，置信度衡量的是包含前件的交易中有多少比例也包含后件。可以如下计算
    `奶酪 -> 酸奶油` 关联规则的置信度：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can interpret this as meaning that if a customer purchased curd, there’s
    an 80 percent likelihood that they also purchased sour cream.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其理解为，如果一个顾客购买了奶酪，那么他们有 80% 的可能性也购买了酸奶油。
- en: 'Like support, confidence falls within a range of 0 to 1, but unlike support,
    confidence isn’t symmetric. That means the confidence for the rule `curd -> sour
    cream` may be different from the confidence for the rule `sour cream -> curd`,
    as shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 和支持度一样，置信度的范围是从 0 到 1，但与支持度不同的是，置信度并不是对称的。这意味着规则 `奶酪 -> 酸奶油` 的置信度可能与规则 `酸奶油
    -> 奶酪` 的置信度不同，如下所示：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, you get a lower confidence value when the antecedent and consequent
    of the association rule are reversed. This tells you it’s less likely that someone
    buying sour cream will also buy curd than it is that someone buying curd will
    also buy sour cream.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当关联规则的前件和后件位置交换时，你会得到一个较低的置信度值。这告诉你，购买酸奶油的人同时购买奶酪的可能性低于购买奶酪的人同时购买酸奶油的可能性。
- en: Lift
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提升度
- en: '*Lift* assesses the strength of an association rule compared to the random
    co-occurrence of the items that appear in the rule. The lift of the association
    rule `curd -> sour cream` is the ratio of the observed support for `curd -> sour
    cream` to that expected if curd and sour cream were independent of each other.
    This can be calculated as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*提升*评估关联规则的强度，相对于规则中出现的项的随机共现情况。关联规则`酸奶 -> 酸奶油`的提升值是观察到的`酸奶 -> 酸奶油`支持度与假设酸奶和酸奶油彼此独立时预期的支持度之比。可以通过以下公式计算：'
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Lift values are symmetric—if you swap the antecedent and consequent, the lift
    remains the same. The possible values for lift range from 0 to infinity, and the
    larger the lift ratio, the stronger the association. In particular, a lift ratio
    larger than 1 indicates that the relationship between the antecedent and consequent
    is stronger than would be expected if they were independent, meaning the two items
    are often bought together. A lift ratio equal to 1 indicates no correlation between
    the antecedent and consequent. A lift ratio less than 1 tells you that there’s
    a negative correlation between the antecedent and consequent, meaning they’re
    unlikely to be purchased together. In this case, you can interpret the lift ratio
    of 2.66 as meaning that when a customer buys curd, there’s a 166 percent increase
    in expectation that they will also purchase sour cream.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 提升值是对称的——如果你交换前件和后件，提升值保持不变。提升值的可能范围是从0到无穷大，提升比率越大，关联性越强。特别地，提升比率大于1表明前件和后件之间的关系比它们独立时预期的要强，这意味着这两个项目经常一起被购买。提升比率等于1表示前件和后件之间没有相关性。提升比率小于1则表示前件和后件之间存在负相关，意味着它们不太可能一起被购买。在这种情况下，你可以将提升比率2.66解释为：当顾客购买酸奶时，预期他们购买酸奶油的概率增加了166%。
- en: The Apriori Algorithm
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Apriori算法
- en: 'You’ve learned what association rules are and seen some metrics for evaluating
    their strength, but how do you actually generate association rules for a market
    basket analysis? One way is to use the *Apriori algorithm*, an automated process
    for analyzing transaction data. In general terms, the algorithm consists of two
    steps:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了什么是关联规则，并看到了评估其强度的一些指标，但你如何实际生成市场篮子分析的关联规则呢？一种方法是使用*Apriori算法*，这是一种自动化的交易数据分析过程。一般来说，该算法由两个步骤组成：
- en: Identify all the *frequent itemsets*, or groups of one or more items that appear
    in many transactions, in the dataset. The algorithm does this by finding all the
    items or groups of items whose support value exceeds a certain threshold.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据集中识别所有的*频繁项集*，即出现在许多交易中的一个或多个项目的组合。该算法通过找到所有支持度值超过某个阈值的项目或项目组合来实现这一点。
- en: Generate association rules for these frequent itemsets by considering all possible
    binary partitions of each itemset (that is, all divisions of the itemset into
    an antecedent group and a consequent group) and calculating a set of association
    metrics for each partition.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过考虑每个频繁项集的所有可能的二元分割（即将项集分为前件组和后件组的所有划分），并为每个划分计算一组关联指标，来生成这些频繁项集的关联规则。
- en: Once the association rules have been generated, you can evaluate them based
    on the metrics discussed in the previous section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成了关联规则，你可以根据前一节中讨论的指标来评估它们。
- en: 'Several third-party Python libraries come with implementations of the Apriori
    algorithm. One is the mlxtend library. Short for *machine learning extensions*,
    mlxtend includes tools for carrying out a number of common data science tasks.
    In this section, we’ll walk through an example market basket analysis using mlxtend’s
    Apriori algorithm implementation. But first, install the mlxtend library with
    `pip`, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个第三方Python库提供了Apriori算法的实现。其中一个是mlxtend库。mlxtend是*机器学习扩展*的缩写，包含了执行许多常见数据科学任务的工具。在本节中，我们将通过一个使用mlxtend的Apriori算法实现的市场篮子分析示例来演示。但首先，使用`pip`安装mlxtend库，如下所示：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Creating a Transaction Dataset
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建交易数据集
- en: 'To conduct your market basket analysis, you need some sample transaction data.
    For simplicity, you can use just a few transactions, defined as a list of lists,
    as shown here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行市场篮子分析，你需要一些样本交易数据。为了简化，可以只使用几个交易数据，定义为如下所示的列表列表：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Each inner list contains the itemset for a single transaction, with the whole
    `transactions` list containing 20 transactions in total. To maintain the quantitative
    proportions defined in the original curd/sour cream example, the dataset contains
    five transactions with curd, six transactions with sour cream, and four that contain
    both curd and sour cream.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 每个内层列表包含单个交易的项集，而整个 `transactions` 列表包含 20 笔交易。为了保持原始酸奶/酸奶油示例中定义的数量比例，数据集包含五笔包含酸奶的交易，六笔包含酸奶油的交易，以及四笔同时包含酸奶和酸奶油的交易。
- en: 'To run the transaction data through mlxtend’s Apriori algorithm, you need to
    transform it into a *one-hot encoded Boolean array*, a structure where each column
    represents an item that can be purchased, each row represents a transaction, and
    each value is either `True` or `False` (`True` if the transaction included that
    particular item or `False` if not). Here you perform the necessary transformation
    using mlxtend’s `TransactionEncoder` object:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过 mlxtend 的 Apriori 算法处理交易数据，你需要将其转换为 *独热编码布尔数组*，这种结构中每一列代表一个可以购买的商品，每一行代表一笔交易，每个值要么是
    `True`（如果交易中包括该商品），要么是 `False`（如果交易中不包括该商品）。在这里，你通过 mlxtend 的 `TransactionEncoder`
    对象执行必要的转换：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You create a `TransactionEncoder` object ❶ and use it to transform the `transactions`
    list of lists into a one-hot encoded Boolean array called `encoded_array` ❷. Then
    you convert the array into a pandas DataFrame called `df_itemsets` ❸, a fragment
    of which is shown here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建一个 `TransactionEncoder` 对象 ❶ 并使用它将 `transactions` 列表列表转换为一个名为 `encoded_array`
    的独热编码布尔数组 ❷。然后你将这个数组转换为一个名为 `df_itemsets` 的 pandas DataFrame ❸，其片段如下所示：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The DataFrame consists of 20 rows and 20 columns, where the rows represent
    the transactions and the columns represent the items. To confirm that the original
    list of lists included 20 transactions drawing on 20 possible items, use the following
    code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该 DataFrame 由 20 行和 20 列组成，行代表交易，列代表商品。为了确认原始的列表列表包含 20 笔交易并涉及 20 个可能的商品，可以使用以下代码：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In both cases, you should get `20`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，你应该得到 `20`。
- en: Identifying Frequent Itemsets
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别频繁项集
- en: 'Now that the transaction data is in a usable format, you can use mlxtend’s
    `apriori()` function to identify all the frequent itemsets in the transaction
    data—that is, all the items or groups of items with a high enough support metric.
    Here’s how:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，交易数据已经是可用格式，你可以使用 mlxtend 的 `apriori()` 函数来识别交易数据中的所有频繁项集——也就是说，识别所有支持度足够高的商品或商品组合。操作如下：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You import the `apriori()` function from the `mlxtend.frequent_patterns` module.
    Then you call the function, passing the DataFrame containing the transaction data
    as the first parameter. You also set the `min_support` parameter to `0.1` to return
    the itemsets with at least 10 percent support. (Remember, the support metric indicates
    what percentage of the transactions an item or group of items occurs in.) You
    set `use_colnames` to `True` to identify the columns included in each itemset
    by name (such as `curd` or `sour cream`) rather than by index number. As a result,
    `apriori()` returns the following DataFrame:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你从 `mlxtend.frequent_patterns` 模块导入 `apriori()` 函数。然后调用该函数，将包含交易数据的 DataFrame
    作为第一个参数传递。你还将 `min_support` 参数设置为 `0.1`，以返回至少支持度为 10% 的项集。（记住，支持度指标表示某个商品或商品组合出现在交易中的百分比。）你将
    `use_colnames` 设置为 `True`，以通过名称（如 `curd` 或 `sour cream`）而非索引号来识别每个项集中的列。结果，`apriori()`
    返回如下 DataFrame：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As noted earlier, an itemset can consist of one or more items, and indeed,
    `apriori()` has returned several single-item itemsets. Ultimately, mlxtend will
    omit these single-item itemsets when it formulates association rules, but it will
    nevertheless need data on *all* the frequent itemsets (including those with one
    item) to successfully generate the rules. Still, as a matter of interest, you
    may wish at this point to view only those itemsets with multiple items. To do
    so, first add a `length` column to the `frequent_itemsets` DataFrame, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，项集可以由一个或多个商品组成，实际上，`apriori()` 返回了几个单一商品的项集。最终，mlxtend 在生成关联规则时会忽略这些单一商品的项集，但在成功生成规则时，仍然需要
    *所有* 频繁项集的数据（包括那些只有一个商品的项集）。不过，出于兴趣，你此时可能希望仅查看包含多个商品的项集。为此，首先在 `frequent_itemsets`
    DataFrame 中添加一个 `length` 列，如下所示：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, use pandas’s select syntax to filter the DataFrame to just those rows
    with a `length` field of `2` or more:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 pandas 的选择语法来过滤 DataFrame，仅保留 `length` 字段值为 `2` 或更多的行：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You’ll see the following result, without any of the single-item itemsets:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下结果，且没有任何单一项项集：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To reiterate, however, mlxtend requires information on all the frequent itemsets
    when generating association rules. Therefore, make sure you don’t actually remove
    any rows from the original `frequent_itemsets` DataFrame.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得重申的是，mlxtend 在生成关联规则时需要所有频繁项集的信息。因此，请确保你没有从原始 `frequent_itemsets` DataFrame
    中删除任何行。
- en: Generating Association Rules
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成关联规则
- en: 'You’ve identified all the itemsets that meet the desired support threshold.
    The second step of the Apriori algorithm is to generate association rules for
    those itemsets. For this, you use the `association_rules()` function from mlxtend’s
    `frequent_patterns` module:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经找出了所有满足所需支持度阈值的项集。Apriori 算法的第二步是为这些项集生成关联规则。为此，你使用 mlxtend `frequent_patterns`
    模块中的 `association_rules()` 函数：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here you invoke the `association_rules()` function, passing in the `frequent_itemsets`
    DataFrame as the first parameter. You also choose a metric for evaluating the
    rules and set a threshold value for that metric. Specifically, you say that the
    function should only return those association rules with a confidence metric of
    0.5 or more. As noted in the previous section, the function will automatically
    skip generating rules for single-member itemsets.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你调用 `association_rules()` 函数，将 `frequent_itemsets` DataFrame 作为第一个参数传入。你还选择了一个用于评估规则的指标，并设置了该指标的阈值。具体来说，你指定该函数仅返回置信度指标为
    0.5 或更高的关联规则。如前一节所述，函数会自动跳过生成单一项集的规则。
- en: 'The `association_rules()` function returns the rules in the form of a DataFrame,
    where each row represents a single association rule. The DataFrame has columns
    for the antecedents, consequents, and various metrics, including support, confidence,
    and lift. Here, you print a selection of the columns:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`association_rules()` 函数返回以 DataFrame 形式表示的规则，每一行代表一个关联规则。该 DataFrame 包含前提、后果和各种指标的列，包括支持度、置信度和提升度。在这里，你可以打印出选择的列：'
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You’ll see the following output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Looking over these rules, some may seem redundant. For example, there’s both
    a `bread -> butter` rule and a `butter -> bread` rule. Likewise, there are several
    rules based on the `(bread, cheese, butter)` itemset. In part, this is because,
    as noted earlier in the chapter, confidence isn’t symmetric; if you swap the antecedent
    and consequent in a rule, the confidence value can change. Additionally, for a
    three-member itemset, the lift can change depending on which items are part of
    the antecedent and which are part of the consequent. Thus, `(bread, cheese) ->
    butter` has a different lift than `(bread, butter) -> cheese`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 看这些规则，有些可能显得冗余。例如，既有 `bread -> butter` 规则，又有 `butter -> bread` 规则。同样，也有多个基于
    `(bread, cheese, butter)` 项集的规则。部分原因是，正如本章早些时候提到的，置信度并不是对称的；如果你交换规则中的前提和后果，置信度值可能会变化。此外，对于一个三项项集，提升度也可能会根据哪些项目是前提，哪些是后果而发生变化。因此，`(bread,
    cheese) -> butter` 的提升度与 `(bread, butter) -> cheese` 的提升度不同。
- en: Visualizing Association Rules
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化关联规则
- en: As you learned in Chapter 8, visualization is a simple yet powerful technique
    for analyzing data. In the context of a market basket analysis, visualization
    provides a convenient way to evaluate the strength of a set of association rules
    by viewing the metrics for different antecedent/consequent pairs. In this section,
    you’ll use Matplotlib to visualize the association rules you generated in the
    previous section as an annotated heatmap.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在第 8 章中学到的，数据可视化是一种简单而强大的分析技术。在市场购物篮分析的背景下，可视化提供了一种便捷的方式，通过查看不同前提/后果对的指标来评估一组关联规则的强度。在这一节中，你将使用
    Matplotlib 将前一节生成的关联规则可视化为带注释的热力图。
- en: A *heatmap* is a grid-like plot where cells are color-coded to indicate their
    value. In this example, you’ll create a heatmap showing the lift metric of the
    various association rules. You’ll arrange all the antecedents along the y-axis
    and the consequents along the x-axis, and fill in the area where a rule’s antecedent
    and consequent intersect with a color to indicate that rule’s lift value. The
    darker the color, the higher the lift.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*热力图* 是一种网格状的图表，其中的单元格通过颜色编码来表示其值。在这个例子中，你将创建一个显示各种关联规则提升度的热力图。你将把所有前提沿着 y
    轴排列，后果沿着 x 轴排列，并在规则的前提和后果相交的区域填充颜色，以表示该规则的提升度。颜色越深，提升度越高。'
- en: 'To create the visualization, you first make an empty DataFrame, into which
    you copy the `antecedents`, `consequents`, and `lift` columns of the `rules` DataFrame
    created earlier:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建可视化，首先创建一个空的 DataFrame，并将之前创建的 `rules` DataFrame 中的 `antecedents`、`consequents`
    和 `lift` 列复制到其中：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You use lambda functions to convert the values of the `antecedents` and `consequents`
    columns from the `rules` DataFrame into strings, which will make it easier to
    use them as labels in the visualization. Originally the values were frozensets,
    immutable versions of Python sets. You use another lambda function to round the
    lift values to two decimal places.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用 lambda 函数将 `rules` DataFrame 中 `antecedents` 和 `consequents` 列的值转换为字符串，这样可以更方便地将它们用作可视化中的标签。最初，值是
    frozenset 类型，即 Python 集合的不可变版本。您使用另一个 lambda 函数将 lift 值四舍五入到小数点后两位。
- en: 'Next, you need to transform the newly created `rules_plot` DataFrame into a
    matrix that will be used for creating the heatmap, with the consequents arranged
    horizontally and the antecedents arranged vertically. For that, you can reshape
    `rules_plot` so that the unique values in the `antecedents` column form the index
    and the unique values in the `consequents` column become the new columns, while
    the values of the `lift` column are used for populating the reshaped DataFrame’s
    values. You use the `rules_plot` DataFrame’s `pivot()` method for this, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要将新创建的 `rules_plot` DataFrame 转换为一个矩阵，用于创建热图，其中后件水平排列，前件垂直排列。为此，您可以重塑
    `rules_plot`，使得 `antecedents` 列中的唯一值形成索引，`consequents` 列中的唯一值成为新列，而 `lift` 列的值用于填充重塑后的
    DataFrame 值。您可以使用 `rules_plot` DataFrame 的 `pivot()` 方法，如下所示：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You specify the `antecedents` and `consequents` columns to form axes of the
    resulting `pivot` DataFrame and draw on the `lift` column for the values. If you
    print `pivot`, it will look like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您指定 `antecedents` 和 `consequents` 列作为结果 `pivot` DataFrame 的轴，并用 `lift` 列作为值。如果打印
    `pivot`，它将如下所示：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This DataFrame contains everything you need to build your heatmap: the values
    of the index (the antecedents) will become the y-axis labels, the names of the
    columns (the consequents) will become the x-axis labels, and the grid of numbers
    and `NaN`s will become the values for the plot. (In this context, a `NaN` indicates
    no association rule was generated for that antecedent/consequent pair.) Here,
    you extract these components into separate variables:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 该 DataFrame 包含构建热图所需的一切：索引的值（前件）将成为 y 轴标签，列名（后件）将成为 x 轴标签，数字和 `NaN` 的网格将成为绘图的值。（在此上下文中，`NaN`
    表示未为该前件/后件对生成关联规则。）在这里，您将这些组件提取到单独的变量中：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now you have the y-axis labels in the `antecedents` list, the x-axis labels
    in the `consequents` list, and the values for the plot in the `pivot` NumPy array.
    You use all these components in the following script to build the heatmap with
    Matplotlib:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经有了 `antecedents` 列表中的 y 轴标签，`consequents` 列表中的 x 轴标签，以及 `pivot` NumPy
    数组中的绘图值。您将使用以下脚本中的所有组件来使用 Matplotlib 构建热图：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The key points of plotting with Matplotlib were covered in Chapter 8. Here,
    we’ll only consider the lines specific to this particular example. The `imshow()`
    method converts the data from the `pivot` array into a color-coded 2D image ❶.
    With the method’s `cmap` parameter, you specify how to map the numeric values
    from the array to colors. Matplotlib has a number of built-in color mappings you
    can choose from, including the `Reds` mapping used here.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制 Matplotlib 图表的关键点已在第 8 章中介绍。这里，我们只考虑与此特定示例相关的代码行。`imshow()` 方法将 `pivot` 数组中的数据转换为颜色编码的
    2D 图像 ❶。通过该方法的 `cmap` 参数，您可以指定如何将数组中的数值映射到颜色。Matplotlib 提供了多个内置的颜色映射供您选择，其中包括此处使用的
    `Reds` 映射。
- en: After creating the axis labels, you use the `setp()` method to rotate the x-axis
    labels by 45 degrees ❷. This helps fit the labels within the horizontal space
    allotted. Then, you loop over the data in the `pivot` array ❸ and create text
    annotations for each square in the heatmap using the `text()` method ❺. The first
    two parameters, `j` and `i`, are the x- and y-coordinates for the label. The next
    parameter, `pivot[i, j]`, is the text of the label, and the remaining parameters
    set the label’s justification. Before calling the `text()` method, you use an
    `if` statement to filter out the antecedent/consequent pairs without any lift
    data ❹. Otherwise, a `NaN` label would appear in each empty square of the heatmap.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建坐标轴标签后，你使用`setp()`方法将 x 轴标签旋转 45 度 ❷。这样可以帮助将标签适配到分配的水平空间内。然后，你遍历 `pivot`
    数组中的数据 ❸，并使用 `text()` 方法为热力图中的每个方格创建文本注释 ❺。前两个参数，`j` 和 `i`，是标签的 x 和 y 坐标。下一个参数，`pivot[i,
    j]`，是标签的文本，剩余的参数设置标签的对齐方式。在调用 `text()` 方法之前，你使用 `if` 语句过滤掉没有任何提升度数据的前置/后置项对 ❹。否则，热力图中的每个空白方格会显示
    `NaN` 标签。
- en: '[Figure 11-1](#figure11-1) shows the resulting visualization.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-1](#figure11-1)展示了结果可视化。'
- en: '![A chart with products arranged along the x- and y-axes. At the intersections
    of some products, a shaded square contains those products’ lift metric. The higher
    the number, the darker the shading.](image_fi/502208c11/f11001.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![一个图表，产品沿 x 轴和 y 轴排列。在某些产品的交点处，一个带阴影的方格包含了这些产品的提升度值。数字越高，阴影越深。](image_fi/502208c11/f11001.png)'
- en: 'Figure 11-1: A heatmap of the lift metric for the sample association rules'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-1：样本关联规则的提升度热力图
- en: The heatmap helps you immediately see which association rules have the highest
    lift values based on the darkness of the shading. Looking at this visualization,
    you can state with a high degree of certainty that a customer who buys milk is
    also likely to buy eggs. Similarly, you can be pretty sure that a customer who
    buys pasta will also buy cheese. Other associations, such as butter with cheese,
    also exist, but as you can see, they aren’t backed as strongly by the lift metric.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 热力图帮助你通过阴影的深浅立即看到哪些关联规则具有最高的提升度值。通过观察这个可视化图表，你可以非常确定地说，购买牛奶的顾客也很可能购买鸡蛋。同样，你可以相当确定购买意大利面条的顾客也会购买奶酪。其他关联规则，例如黄油与奶酪的关系也存在，但正如你所见，它们并没有像前者那样得到提升度指标的强有力支持。
- en: The heatmap also illustrates how the lift metric is symmetric. Look, for example,
    at the values of the `bread -> butter` and `butter -> bread` rules. They’re the
    same. You may notice, however, that some antecedent/consequent pairs in the plot
    don’t have a symmetric lift value. For example, the lift for the `cheese -> bread`
    rule is shown as `1.5`, but there isn’t a lift value for `bread ->` `cheese` on
    the plot. This is because when you originally generated the association rules
    with mlxtend’s `association_rules()` function, you set a 50 percent confidence
    threshold. This excluded many potential association rules, including `bread ->
    cheese`, which has a 37.5 percent confidence rating compared to the 60 percent
    confidence rating of `cheese -> bread`. Thus, no data for a `bread -> cheese`
    rule was available to plot.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 热力图还说明了提升度指标的对称性。例如，看看 `bread -> butter` 和 `butter -> bread` 规则的值。它们是一样的。然而，你可能会注意到，图中的某些前置/后置项对并没有对称的提升度值。例如，`cheese
    -> bread` 规则的提升度显示为 `1.5`，但图中没有显示 `bread -> cheese` 的提升度值。这是因为在最初使用 mlxtend 的
    `association_rules()` 函数生成关联规则时，你设置了 50% 的置信度阈值。这排除了许多潜在的关联规则，包括 `bread -> cheese`，它的置信度为
    37.5%，而 `cheese -> bread` 的置信度为 60%。因此，没有数据可供绘制 `bread -> cheese` 规则。
- en: Gaining Actionable Insights from Association Rules
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从关联规则中获得可操作的见解
- en: Using the Apriori algorithm, you identified the frequent itemsets in a sample
    batch of transaction data, and you generated association rules based on those
    itemsets. These rules tell you, in essence, how likely it is that a customer will
    buy one product if they’ve bought another, and by visualizing the rules’ lift
    metrics on a heatmap, you saw which rules were particularly convincing. The next
    logical question to consider is how a business could actually benefit from this
    information.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Apriori 算法，你从一批交易数据中识别出了频繁项集，并基于这些项集生成了关联规则。这些规则本质上告诉你，如果顾客购买了一种产品，他们购买另一种产品的可能性有多大。通过在热力图上可视化规则的提升度指标，你看到了哪些规则特别具有说服力。接下来需要考虑的合理问题是，企业如何从这些信息中获益。
- en: In this section, we’ll look at two different ways a business could derive useful
    insights from a collection of association rules. We’ll examine how to generate
    product recommendations based on the items a customer has purchased and how to
    efficiently plan discounts based around frequent itemsets. Both of these applications
    have the potential to increase revenue for the business while also delivering
    a better experience for customers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨企业如何从关联规则集中提取有用的见解的两种不同方法。我们将研究如何基于客户已购买的商品生成产品推荐，以及如何围绕频繁项集高效地规划折扣。这两种应用不仅能为企业增加收入，还能为客户提供更好的体验。
- en: Generating Recommendations
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成推荐
- en: After an item has appeared in a customer’s basket, which item is likely to be
    added next? Of course, you can’t say for sure, but you can make a prediction based
    on the association rules mined from your transaction data. The results of this
    prediction can form the basis for a set of recommendations of items that are frequently
    bought together with the item currently in the basket. Retailers commonly use
    such recommendations to show customers other items they may want to purchase.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在顾客的购物篮中出现一个商品后，下一个可能被添加的商品是什么？当然，你不能完全确定，但你可以根据从交易数据中挖掘出来的关联规则做出预测。这个预测的结果可以作为一组推荐的基础，推荐那些与当前购物篮中的商品经常一起购买的商品。零售商常常利用这些推荐向顾客展示他们可能想购买的其他商品。
- en: 'Perhaps the most natural way to generate recommendations of this type is to
    look at all the association rules where the item currently in the basket acts
    as the antecedent. Then, you identify the strongest rules—perhaps the three rules
    with the highest confidence values—and extract their consequents. The following
    example illustrates how to do this for the item *butter*. You start by finding
    the rules where *butter* is the antecedent, using the pandas library’s filtering
    features:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 生成此类推荐最自然的方式或许是查看所有当前购物篮中商品作为前项的关联规则。然后，找出最强的规则——可能是三个具有最高置信度值的规则——并提取它们的后项。以下示例演示了如何针对商品*黄油*进行此操作。你首先找到*黄油*作为前项的规则，使用
    pandas 库的过滤功能：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here you sort the rules by the `confidence` column so that the rules with the
    highest confidence rating appear at the beginning of the `butter_antecedent` DataFrame.
    Next you use a list comprehension to extract the top three consequents:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你按 `confidence` 列对规则进行排序，这样置信度最高的规则就会出现在 `butter_antecedent` 数据框的前面。接着，你使用列表推导提取前三个后项：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this list comprehension, you loop over the `consequents` column in the `butter_antecedent`
    DataFrame, picking up the first three values. Based on the `butter_consequents`
    list, you can generate a recommendation:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表推导中，你遍历 `butter_antecedent` 数据框中的 `consequents` 列，提取前三个值。基于 `butter_consequents`
    列表，你可以生成一个推荐：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The recommendation will look as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐将如下所示：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This indicates that customers who buy butter also often buy either bread or
    cheese, or both.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明购买黄油的顾客也常常购买面包或奶酪，或者两者都买。
- en: Planning Discounts Based on Association Rules
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于关联规则规划折扣
- en: The association rules generated for frequent itemsets can also be used for choosing
    which products to discount. Ideally, you should have a discounted item in each
    significant group of products to satisfy as many customers as possible. In other
    words, you should choose a single item to be discounted in each frequent itemset.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为频繁项集生成的关联规则也可以用于选择哪些产品进行折扣。理想情况下，你应该在每个重要的产品组中都有一个折扣商品，以满足尽可能多的客户。换句话说，你应该在每个频繁项集中选择一个商品进行折扣。
- en: 'To accomplish this, the first thing you need is a set of frequent itemsets
    to work on. Unfortunately, the `rules` DataFrame generated earlier by the `association_rules()`
    function has columns for antecedents and consequents but not for the rules’ complete
    itemsets. You therefore need to create an `itemsets` column by merging the `antecedents`
    and `consequents` columns, as shown here:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，首先你需要一组频繁项集来进行处理。不幸的是，`association_rules()` 函数之前生成的 `rules` 数据框有前项和后项列，但没有规则的完整项集。因此，你需要通过合并
    `antecedents` 和 `consequents` 列来创建一个 `itemsets` 列，如下所示：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You use the `reduce()` function from Python’s `functools` module to apply the
    `frozenset.union()` method to the values of the `antecedents` and `consequents`
    columns. This combines the separate frozensets from these columns into a single
    one.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用Python的`functools`模块中的`reduce()`函数，将`frozenset.union()`方法应用于`antecedents`和`consequents`列的值。这会将这两列中的单独frozenset合并成一个frozenset。
- en: 'To see what you have as a result, you might print the newly created `itemsets`
    column along with the `antecedents` and `consequents` columns:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 若要查看结果，你可以打印新创建的`itemsets`列，以及`antecedents`和`consequents`列：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output will look as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Notice that there are some duplicates in the new `itemsets` column. As discussed
    earlier, the same itemset may form more than one association rule, since the order
    of items influences some rule metrics. The order of items in an itemset doesn’t
    matter for the current task, however, so you can safely remove duplicate itemsets,
    as shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，新`itemsets`列中有一些重复项。正如前面讨论的，相同的项集可能形成多个关联规则，因为商品的顺序会影响某些规则度量。不过，对于当前任务，项集中的商品顺序并不重要，因此你可以安全地移除重复的项集，如下所示：
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You use the DataFrame’s `drop_duplicates()` method for this, specifying to look
    for duplicates in the `itemsets` column. You keep the first row within a set of
    duplicates, and by setting `inplace` to `True`, you delete the duplicate rows
    from the existing DataFrame rather than creating a new DataFrame with the duplicates
    removed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用DataFrame的`drop_duplicates()`方法，指定检查`itemsets`列中的重复项。你保留一组重复项中的第一行，并通过设置`inplace`为`True`，直接从现有的DataFrame中删除重复行，而不是创建一个新的DataFrame来移除重复项。
- en: 'If you now print out the `itemsets` column:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在打印出`itemsets`列：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'you’ll only see the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你将只看到以下内容：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, you choose one item from each itemset to be discounted:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你从每个项集中选择一个商品进行折扣：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You first create the `discounted` list to accumulate the items being chosen
    for discount and the `others` list to receive the items in an itemset that aren’t
    chosen for discount. Then you iterate over each itemset ❶ and each item in it
    ❷. You look for an item not already included in the `others` list, since such
    an item would either not be in any of the preceding itemsets or have already been
    chosen as the discounted item for a preceding itemset, meaning it would be efficient
    to choose it as this itemset’s discounted item too ❸. You send the chosen item
    to the `discounted` list ❹, then send the remaining items of the itemset to the
    `others` list ❺. If you’ve iterated over all the items in an itemset and failed
    to find an item that isn’t included in the `others` list, you choose the last
    item in the itemset and send it to the `discounted` list ❻.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先创建`discounted`列表来积累被选择为折扣商品的商品，并创建`others`列表来接收项集中未被选择为折扣商品的商品。然后你遍历每个项集❶和项集中的每个商品❷。你会查找一个未包含在`others`列表中的商品，因为这种商品要么不在任何前面的项集中，要么已经被选为前一个项集的折扣商品，这意味着选择它作为当前项集的折扣商品也是高效的❸。你将选择的商品发送到`discounted`列表❹，然后将项集中其余的商品发送到`others`列表❺。如果你遍历完项集中的所有商品后，仍未找到一个不在`others`列表中的商品，那么你选择项集中的最后一个商品，并将其发送到`discounted`列表❻。
- en: 'The resulting `discounted` list will vary, since the Python frozensets representing
    the itemsets are unordered, but it will look something like the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的`discounted`列表会有所不同，因为表示项集的Python frozensets是无序的，但它看起来会像以下示例：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Compare the result with the `itemsets` column shown earlier, and you’ll see
    that each itemset has one discounted item in it. Moreover, you’ve distributed
    the discounts very efficiently, so the actual number of discounted items is significantly
    less than the number of itemsets. You can see this by removing the duplicates
    from the `discounted` list:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将结果与之前显示的`itemsets`列进行比较，你会发现每个项集都有一个折扣商品。此外，你已经非常高效地分配了折扣，因此实际的折扣商品数量显著少于项集的数量。你可以通过从`discounted`列表中移除重复项来看到这一点：
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As the output shows, even though there are eight itemsets, you’ve only had
    to discount five items:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如输出所示，尽管有八个项集，你只需要对五个商品进行折扣：
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Thus, you’ve managed to discount one item in each itemset (a significant benefit
    for many customers) without actually having to discount many items (a significant
    benefit for the business).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你成功地在每个项集中折扣了一件商品（对于许多客户来说这是一个显著的好处），而实际上并没有折扣太多商品（对于企业来说这是一个显著的好处）。
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: As you’ve seen, performing a market basket analysis is a valuable way to extract
    useful information from large amounts of transaction data. In this chapter, you
    learned how to use the Apriori algorithm to mine transaction data for association
    rules, and you saw how to evaluate those rules along different metrics. In this
    way, you were able to gain insight about what items are commonly purchased together.
    You used that knowledge to make product recommendations to customers and to efficiently
    plan discounts.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，进行市场篮分析是从大量交易数据中提取有用信息的一种宝贵方式。在本章中，你学习了如何使用Apriori算法挖掘交易数据中的关联规则，并了解了如何通过不同的度量标准来评估这些规则。通过这种方式，你能够深入了解哪些商品通常会一起购买。你利用这些知识向客户提供产品推荐，并有效地规划折扣。
