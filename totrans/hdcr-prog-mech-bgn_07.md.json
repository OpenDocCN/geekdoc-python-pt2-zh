["```py\nfrom geom2d.point import Point\n\nclass Segment:\n    def __init__(self, start: Point, end: Point):\n        self.start = start\n        self.end = end\n```", "```py\n>>> from geom2d.segment import Segment\n>>> s = Segment(\"foo\", \"bar\")\n\n>>> s.start\n'foo'\n```", "```py\nfrom geom2d.point import Point\nfrom geom2d.vectors import make_vector_between, make_versor_between\n\nclass Segment:\n    --snip--\n\n    @property\n    def direction_vector(self):\n        return make_vector_between(self.start, self.end)\n\n    @property\n    def direction_versor(self):\n        return make_versor_between(self.start, self.end)\n```", "```py\nclass Segment:\n    --snip--\n\n    @property\n    def normal_versor(self):\n        return self.direction_versor.perpendicular()\n```", "```py\ndef normal_versor(self):\n    d = self.direction_versor\n    return d.perpendicular()\n```", "```py\nclass Segment:\n    --snip--\n\n    @property\n    def length(self):\n        return self.start.distance_to(self.end)\n```", "```py\nfrom geom2d.point import Point\nfrom geom2d.vectors import make_vector_between, make_versor_between\n\nclass Segment:\n    def __init__(self, start: Point, end: Point):\n        self.start = start\n        self.end = end\n\n    @property\n    def direction_vector(self):\n        return make_vector_between(self.start, self.end)\n\n    @property\n    def direction_versor(self):\n        return make_versor_between(self.start, self.end)\n\n    @property\n    def normal_versor(self):\n        return self.direction_versor.perpendicular()\n\n    @property\n    def length(self):\n        return self.start.distance_to(self.end)\n```", "```py\nimport math\nimport unittest\n\nfrom geom2d.point import Point\nfrom geom2d.segment import Segment\n\nclass TestSegment(unittest.TestCase):\n\n    start = Point(400, 0)\n    end = Point(0, 400)\n    segment = Segment(start, end)\n\n    def test_length(self):\n        expected = 400 * math.sqrt(2)\n        actual = self.segment.length\n        self.assertAlmostEqual(expected, actual)\n```", "```py\nexpected = self.start.distance_to(self.end)\n```", "```py\n$ python3 -m unittest geom2d/segment_test.py\n```", "```py\nself.start.distance_to(self.start)\n```", "```py\nclass Segment:\n    --snip--\n\n   def point_at(self, t: float):\n      return self.start.displaced(self.direction_vector, t)\n```", "```py\nclass Segment:\n    --snip--\n\n    @property\n   def middle(self):\n       return self.point_at(0.5)\n```", "```py\nOops! We were expecting the value of 't' to be in the  range [0, 1],\nbut you gave us a value of '739928393839'.\n```", "```py\nMIN = 0.0\nMIDDLE = 0.5\nMAX = 1.0\n\ndef make(value: float):\n    if value < MIN:\n        return MIN\n\n    if value > MAX:\n        return MAX\n\n    return value\n\ndef ensure_valid(t):\n    if not is_valid(t):\n        raise TParamError(t)\n\ndef is_valid(t):\n    return False if t < MIN or t > MAX else True\n\nclass TParamError(Exception):\n    def __init__(self, t):\n        self.t = t\n\n    def __str__(self):\n        return f'Expected t to be in [0, 1] but was {self.t}'\n```", "```py\n>>> from geom2d import tparam\n>>> tparam.ensure_valid(10.5)\nTraceback (most recent call last):\n  --snip--\ngeom2d.tparam.TParamError: Expected t to be in [0, 1] but was 10.5\n```", "```py\nExpected t to be in [0, 1] but was 10.5\n```", "```py\nfrom geom2d import tparam\n```", "```py\ndef point_at(self, t: float):\n    tparam.ensure_valid(t)\n    return self.start.displaced(self.direction_vector, t)\n```", "```py\n@property\ndef middle(self):\n    return self.point_at(tparam.MIDDLE)\n```", "```py\nfrom geom2d import tparam\nfrom geom2d.point import Point\nfrom geom2d.vectors import make_vector_between, make_versor_between\n\nclass Segment:\n    def __init__(self, start: Point, end: Point):\n        self.start = start\n        self.end = end\n\n    @property\n    def direction_vector(self):\n        return make_vector_between(self.start, self.end)\n\n    @property\n    def direction_versor(self):\n        return make_versor_between(self.start, self.end)\n\n    @property\n    def normal_versor(self):\n        return self.direction_versor.perpendicular()\n\n    @property\n    def length(self):\n        return self.start.distance_to(self.end)\n\n    def point_at(self, t: float):\n        tparam.ensure_valid(t)\n        return self.start.displaced(self.direction_vector, t)\n\n    @property\n    def middle(self):\n        return self.point_at(tparam.MIDDLE)\n```", "```py\nfrom geom2d import tparam\n```", "```py\nclass TestSegment(unittest.TestCase):\n\n    start = Point(400, 0)\n    end = Point(0, 400)\n    segment = Segment(start, end)\n\n    --snip--\n\n    def test_point_at_wrong_t(self):\n        self.assertRaises(\n         ➊ tparam.TParamError,\n         ➋ self.segment.point_at,\n         ➌ 56.7\n        )\n```", "```py\nclass TestSegment(unittest.TestCase):\n\n    start = Point(400, 0)\n    end = Point(0, 400)\n    segment = Segment(start, end)\n\n    --snip--\n\n    def test_point_at(self):\n        t = tparam.make(0.25)\n        expected = Point(300, 100)\n        actual = self.segment.point_at(t)\n        self.assertEqual(expected, actual)\n\n    def test_middle_point(self):\n        expected = Point(200, 200)\n        actual = self.segment.middle\n        self.assertEqual(expected, actual)\n```", "```py\n$  python3 -m unittest geom2d/segment_test.py\n```", "```py\nclass Segment:\n    --snip--\n\n   def closest_point_to(self, p: Point):\n       v = make_vector_between(self.start, p)\n       d = self.direction_versor\n       vs = v.projection_over(d)\n\n       if vs < 0:\n           return self.start\n\n       if vs > self.length:\n           return self.end\n\n       return self.start.displaced(d, vs)\n```", "```py\nclass TestSegment(unittest.TestCase):\n\n    start = Point(400, 0)\n    end = Point(0, 400)\n    segment = Segment(start, end)\n\n    --snip--\n\n    def test_closest_point_is_start(self):\n        p = Point(500, 20)\n        expected = self.start\n        actual = self.segment.closest_point_to(p)\n        self.assertEqual(expected, actual)\n\n    def test_closest_point_is_end(self):\n        p = Point(20, 500)\n        expected = self.end\n        actual = self.segment.closest_point_to(p)\n        self.assertEqual(expected, actual)\n\n    def test_closest_point_is_middle(self):\n        p = Point(250, 250)\n        expected = Point(200, 200)\n        actual = self.segment.closest_point_to(p)\n        self.assertEqual(expected, actual)\n```", "```py\n$ python3 -m unittest geom2d/segment_test.py\n```", "```py\nclass Segment:\n    --snip--\n\n   def distance_to(self, p: Point):\n       return p.distance_to(\n           self.closest_point_to(p)\n       )\n```", "```py\nresult = seg_a.intersection_with(seg_b)\n\nif type(result) is Point:\n    # intersection is a point\nelif type(result) is Segment:\n    # intersection is a segment\nelse:\n    # no intersection\n```", "```py\nclass Segment:\n    --snip--\n\n    def intersection_with(self, other):\n        d1, d2 = self.direction_vector, other.direction_vector\n\n        if d1.is_parallel_to(d2):\n            return None\n\n        cross_prod = d1.cross(d2)\n        delta = other.start - self.start\n        t1 = (delta.u * d2.v - delta.v * d2.u) / cross_prod\n        t2 = (delta.u * d1.v - delta.v * d1.u) / cross_prod\n\n        if tparam.is_valid(t1) and tparam.is_valid(t2):\n            return self.point_at(t1)\n        else:\n            return None\n```", "```py\nclass TestSegment(unittest.TestCase):\n\n    start = Point(400, 0)\n    end = Point(0, 400)\n    segment = Segment(start, end)\n\n    --snip--\n\n    def test_parallel_segments_no_intersection(self):\n        other = Segment(Point(200, 0), Point(0, 200))\n        actual = self.segment.intersection_with(other)\n        self.assertIsNone(actual)\n\n    def test_segments_intersection(self):\n        other = Segment(Point(0, 0), Point(400, 400))\n        expected = Point(200, 200)\n        actual = self.segment.intersection_with(other)\n        self.assertEqual(expected, actual)\n```", "```py\n$ python3 -m unittest geom2d/segment_test.py\n```", "```py\nclass Segment:\n    --snip--\n\n   def __eq__(self, other):\n       if self is other:\n           return True\n\n       if not isinstance(other, Segment):\n           return False\n\n       return self.start == other.start \\\n              and self.end == other.end\n\n   def __str__(self):\n       return f'segment from {self.start} to {self.end}'\n```", "```py\nfrom geom2d import tparam\nfrom geom2d.point import Point\nfrom geom2d.vectors import make_vector_between, make_versor_between\n\nclass Segment:\n    def __init__(self, start: Point, end: Point):\n        self.start = start\n        self.end = end\n\n    @property\n    def direction_vector(self):\n        return make_vector_between(self.start, self.end)\n\n    @property\n    def direction_versor(self):\n        return make_versor_between(self.start, self.end)\n\n    @property\n    def normal_versor(self):\n        return self.direction_versor.perpendicular()\n\n    @property\n    def length(self):\n        return self.start.distance_to(self.end)\n\n    def point_at(self, t: float):\n        tparam.ensure_valid(t)\n        return self.start.displaced(self.direction_vector, t)\n\n    @property\n    def middle(self):\n        return self.point_at(tparam.MIDDLE)\n\n    def closest_point_to(self, p: Point):\n        v = make_vector_between(self.start, p)\n        d = self.direction_versor\n        vs = v.projection_over(d)\n\n        if vs < 0:\n            return self.start\n\n        if vs > self.length:\n            return self.end\n\n        return self.start.displaced(d, vs)\n\n    def distance_to(self, p: Point):\n        return p.distance_to(\n            self.closest_point_to(p)\n        )\n\n    def intersection_with(self, other):\n        d1, d2 = self.direction_vector, other.direction_vector\n\n        if d1.is_parallel_to(d2):\n            return None\n\n        cross_prod = d1.cross(d2)\n        delta = other.start - self.start\n        t1 = (delta.u * d2.v - delta.v * d2.u) / cross_prod\n        t2 = (delta.u * d1.v - delta.v * d1.u) / cross_prod\n\n        if tparam.is_valid(t1) and tparam.is_valid(t2):\n            return self.point_at(t1)\n        else:\n            return None\n\n    def __eq__(self, other):\n        if self is other:\n            return True\n\n        if not isinstance(other, Segment):\n            return False\n\n        return self.start == other.start \\\n               and self.end == other.end\n\n    def __str__(self):\n        return f'segment from {self.start} to {self.end}'\n```", "```py\nfrom geom2d.point import Point\nfrom geom2d.vector import Vector\n\nclass Line:\n    def __init__(self, base: Point, direction: Vector):\n        self.base = base\n        self.direction = direction\n```", "```py\nclass Line:\n   --snip--\n\n   def is_parallel_to(self, other):\n       return self.direction.is_parallel_to(other.direction)\n\n   def is_perpendicular_to(self, other):\n       return self.direction.is_perpendicular_to(other.direction)\n```", "```py\nd1 = line_one.direction\nd2 = line_two.direction\nd1.is_parallel_to(d2)\n```", "```py\nline_one.is_parallel_to(line_two)\n```", "```py\nfrom geom2d.point import Point\nfrom geom2d.vector import Vector\n\nclass Line:\n    --snip--\n\n    def perpendicular_through(self, point: Point):\n        return Line(point, self.direction.perpendicular())\n\n    def parallel_through(self, point: Point):\n        return Line(point, self.direction)\n```", "```py\nfrom geom2d.point import Point\nfrom geom2d.vector import Vector\nfrom geom2d.vectors import make_vector_between\n\nclass Line:\n   --snip--\n\n   def intersection_with(self, other):\n       if self.is_parallel_to(other):\n           return None\n\n       d1, d2 = self.direction, other.direction\n       cross_prod = d1.cross(d2)\n       delta = make_vector_between(self.base, other.base)\n       t1 = (delta.u * d2.v - delta.v * d2.u) / cross_prod\n\n       return self.base.displaced(d1, t1)\n```", "```py\nimport unittest\n\nfrom geom2d.line import Line\nfrom geom2d.point import Point\nfrom geom2d.vector import Vector\n\nclass TestLine(unittest.TestCase):\n\n    def test_parallel_lines_no_intersection(self):\n        l1 = Line(Point(0, 0), Vector(1, 1))\n        l2 = Line(Point(10, 10), Vector(1, 1))\n        self.assertIsNone(l1.intersection_with(l2))\n\n    def test_lines_intersection(self):\n        l1 = Line(Point(50, 0), Vector(0, 1))\n        l2 = Line(Point(0, 30), Vector(1, 0))\n        actual = l1.intersection_with(l2)\n        expected = Point(50, 30)\n        self.assertEqual(expected, actual)\n```", "```py\nRan 2 tests in 0.001s\n\nOK\n\nProcess finished with exit code 0\n```", "```py\n$  python3 -m unittest geom2d/line_test.py\n```", "```py\nfrom geom2d.point import Point\nfrom geom2d.vector import Vector\nfrom geom2d.vectors import make_vector_between\n\nclass Line:\n    def __init__(self, base: Point, direction: Vector):\n        self.base = base\n        self.direction = direction\n\n    def is_parallel_to(self, other):\n        return self.direction.is_parallel_to(other.direction)\n\n    def is_perpendicular_to(self, other):\n        return self.direction.is_perpendicular_to(other.direction)\n\n    def perpendicular_through(self, point: Point):\n        return Line(point, self.direction.perpendicular())\n\n    def parallel_through(self, point: Point):\n        return Line(point, self.direction)\n\n    def intersection_with(self, other):\n        if self.is_parallel_to(other):\n            return None\n\n        d1, d2 = self.direction, other.direction\n        cross_prod = d1.cross(d2)\n        delta = make_vector_between(self.base, other.base)\n        t1 = (delta.u * d2.v - delta.v * d2.u) / cross_prod\n\n        return self.base.displaced(d1, t1)\n```", "```py\nfrom geom2d import tparam\nfrom geom2d.line import Line\nfrom geom2d.point import Point\nfrom geom2d.vectors import make_vector_between, make_versor_between\n\nclass Segment:\n    --snip--\n\n    @property\n   def bisector(self):\n       return Line(self.middle, self.normal_versor)\n```"]