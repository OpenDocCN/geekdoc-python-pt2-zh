["```py\n{\n    \"sizes\": {\n        \"margin\": 170,\n        \"node_radius\": 5,\n        \"stroke\": 4,\n        \"arrow\": 14\n    },\n    \"colors\": {\n        \"node_stroke\": \"#354595\",\n        \"back\": \"#FFFFFF\",\n        \"traction\": \"#005005\",\n        \"compression\": \"#BB2727\",\n        \"original\": \"#D5DBF8\",\n        \"load\": \"#FFC046\",\n        \"reaction\": \"#4A0072\"\n    },\n    \"font\": {\n        \"family\": \"sans-serif\",\n        \"size\": 14\n    }\n}\n```", "```py\nimport json\n\nimport pkg_resources as res\n\ndef __read_config():\n    config = res.resource_string(__name__, 'config.json')\n    return json.loads(config)\n```", "```py\n--snip--\n\n__expected_settings = (\n    # scale applied to the diagram\n    'scale',\n    # scale applied to the node displacements\n    'disp_scale',\n    # scale applied to the load vectors\n    'load_scale',\n    # boolean to decide whether to draw the original geometry\n    'no_draw_original'\n)\n\ndef __validate_settings(settings):\n    for setting in __expected_settings:\n        if setting not in settings:\n            raise ValueError(f'\"{setting}\" missing in settings')\n```", "```py\nimport json\n\nimport pkg_resources as res\n\nfrom geom2d import AffineTransform\nfrom graphic import svg\nfrom structures.solution.structure import StructureSolution\n\ndef structure_solution_to_svg(\n        result: StructureSolution,\n        settings,\n        _config=None,\n):\n    __validate_settings(settings)\n    default_config = __read_config()\n\n ➊ config = {**default_config, **(_config or {})}\n\n ➋ viewbox = result.bounds_rect(\n        config['sizes']['margin'],\n        settings.scale\n    )\n    transform = AffineTransform(sx=1, sy=-1, tx=0, ty=0)\n\n ➌ return svg.svg_content(\n        size=viewbox.size,\n        primitives=[],\n        viewbox_rect=viewbox,\n        transform=transform\n\n   )\n\n--snip--\n```", "```py\nfrom geom2d import Point, Vector, make_rotation, make_scale\nfrom graphic import svg\nfrom graphic.svg import attributes\n\ndef caption_to_svg(\n        caption: str,\n        position: Point,\n        angle: float,\n        color: str,\n        config\n):\n ➊ font = config['font']['family']\n    size = config['font']['size']\n\n    rotation = make_rotation(angle, position)\n    scale = make_scale(1, -1, position)\n ➋ transform = rotation.then(scale)\n\n ➌ return svg.text(\n        caption,\n        position,\n        Vector(0, 0),\n        [\n            attributes.fill_color(color),\n            attributes.affine_transform(transform),\n            attributes.font_family(font),\n            attributes.font_size(size)\n        ]\n    )\n```", "```py\nfrom math import sqrt\n\nfrom graphic import svg\nfrom graphic.svg import attributes\n\ndef __bar_svg(geometry, color, cross_section):\n ➊ section_height = sqrt(cross_section)\n ➋ return svg.segment(\n        geometry,\n        [\n            attributes.stroke_color(color),\n            attributes.stroke_width(section_height)\n        ]\n    )\n```", "```py\nfrom math import sqrt\n\nfrom graphic import svg\nfrom graphic.svg import attributes\nfrom structures.solution.bar import StrBarSolution\n\ndef bars_to_svg(bars: [StrBarSolution], settings, config):\n    should_draw_original = not settings.no_draw_original\n ➊ original, final, stresses = [], [], []\n\n    for bar in bars:\n     ➋ if should_draw_original:\n            original.append(original_bar_to_svg(bar))\n     ➌ final.append(bar_to_svg(bar))\n     ➍ stresses.append(bar_stress_to_svg(bar))\n\n    # Ordering is important to preserve z-depth\n ➎ return original + final + stresses\n\ndef __bar_svg(geometry, color, cross_section):\n    --snip--\n```", "```py\nfrom math import sqrt\n\nfrom graphic import svg\nfrom graphic.svg import attributes\nfrom structures.solution.bar import StrBarSolution\n\ndef bars_to_svg(bars: [StrBarSolution], settings, config):\n    def original_bar_to_svg(_bar: StrBarSolution):\n     ➊ color = config['colors']['original']\n     ➋ return __bar_svg(\n            _bar.original_geometry,\n            color,\n            _bar.cross_section\n        )\n\n    --snip--\n\n    # Ordering is important to preserve z-depth\n    return original + final + stresses\n\ndef __bar_svg(geometry, color, cross_section):\n    --snip--\n```", "```py\nfrom math import sqrt\n\nfrom graphic import svg\nfrom graphic.svg import attributes\nfrom structures.solution.bar import StrBarSolution\n\ndef bars_to_svg(bars: [StrBarSolution], settings, config):\n    def original_bar_to_svg(_bar: StrBarSolution):\n        --snip--\n\n    def bar_to_svg(_bar: StrBarSolution):\n        return __bar_svg(\n         ➊ _bar.final_geometry_scaling_displacement(\n                settings.disp_scale\n            ),\n         ➋ bar_color(_bar),\n         ➌ _bar.cross_section\n        )\n\n    def bar_color(_bar: StrBarSolution):\n        if _bar.stress >= 0:\n            return config['colors']['traction']\n        else:\n            return config['colors']['compression']\n\n    --snip--\n\n    # Ordering is important to preserve z-depth\n    return original + final + stresses\n\ndef __bar_svg(geometry, color, cross_section):\n    --snip--\n```", "```py\nfrom math import sqrt\n\nfrom geom2d import Vector\nfrom graphic import svg\nfrom graphic.svg import attributes\nfrom structures.solution.bar import StrBarSolution\nfrom .captions_svg import caption_to_svg\n\n__I_VERSOR = Vector(1, 0)\n__STRESS_DISP = 10\n__DECIMAL_POS = 4\n\ndef bars_to_svg(bars: [StrBarSolution], settings, config):\n    def original_bar_to_svg(_bar: StrBarSolution):\n        --snip--\n\n    def bar_to_svg(_bar: StrBarSolution):\n        --snip--\n\n    def bar_stress_to_svg(_bar: StrBarSolution):\n     ➊ geometry = _bar.final_geometry_scaling_displacement(\n           settings.disp_scale\n        )\n     normal = geometry.normal_versor\n     ➋ position = geometry.middle.displaced(normal, __STRESS_DISP)\n     ➌ angle = geometry.direction_versor.angle_to(__I_VERSOR)\n\n     ➍ return caption_to_svg(\n           f'σ = {round(_bar.stress, __DECIMAL_POS)}',\n           position,\n           angle,\n           bar_color(_bar),\n           config\n        )\n\n   def bar_color(_bar: StrBarSolution):\n       --snip--\n\n    --snip--\n\n    # Ordering is important to preserve z-depth\n    return original + final + stresses\n\ndef __bar_svg(geometry, color, cross_section):\n    --snip--\n```", "```py\nfrom math import sqrt\n\nfrom geom2d import Vector\nfrom graphic import svg\nfrom graphic.svg import attributes\nfrom structures.solution.bar import StrBarSolution\nfrom .captions_svg import caption_to_svg\n\n__I_VERSOR = Vector(1, 0)\n__STRESS_DISP = 10\n__DECIMAL_POS = 4\n\ndef bars_to_svg(bars: [StrBarSolution], settings, config):\n    def original_bar_to_svg(_bar: StrBarSolution):\n        color = config['colors']['original']\n        return __bar_svg(\n            _bar.original_geometry,\n            color,\n            _bar.cross_section\n        )\n\n    def bar_to_svg(_bar: StrBarSolution):\n        return __bar_svg(\n            _bar.final_geometry_scaling_displacement(\n                settings.disp_scale\n            ),\n            bar_color(_bar),\n            _bar.cross_section\n        )\n\n    def bar_stress_to_svg(_bar: StrBarSolution):\n        geometry = _bar.final_geometry_scaling_displacement(\n            settings.disp_scale\n        )\n        normal = geometry.normal_versor\n        position = geometry.middle.displaced(normal, __STRESS_DISP)\n        angle = geometry.direction_versor.angle_to(__I_VERSOR)\n\n        return caption_to_svg(\n            f  ' = {round(_bar.stress, __DECIMAL_POS)}',\n            position,\n            angle,\n            bar_color(_bar),\n            config\n        )\n\n    def bar_color(_bar: StrBarSolution):\n        if _bar.stress >= 0:\n            return config['colors']['traction']\n        else:\n            return config['colors']['compression']\n\n    should_draw_original = not settings.no_draw_original\n    original, final, stresses = [], [], []\n\n    for bar in bars:\n        if should_draw_original:\n            original.append(original_bar_to_svg(bar))\n        final.append(bar_to_svg(bar))\n        stresses.append(bar_stress_to_svg(bar))\n\n    # Ordering is important to preserve z-depth\n    return original + final + stresses\n\ndef __bar_svg(geometry, color, cross_section):\n    section_height = sqrt(cross_section)\n    return svg.segment(\n        geometry,\n        [\n            attributes.stroke_color(color),\n            attributes.stroke_width(section_height)\n        ]\n    )\n```", "```py\nfrom geom2d import Circle, Vector\nfrom graphic import svg\nfrom graphic.svg import attributes\nfrom structures.solution.node import StrNodeSolution\nfrom .captions_svg import caption_to_svg\n\ndef nodes_to_svg(nodes: [StrNodeSolution], settings, config):\n ➊ def node_to_svg(node: StrNodeSolution):\n        radius = config['sizes']['node_radius']\n        stroke_size = config['sizes']['stroke']\n        stroke_color = config['colors']['node_stroke']\n        fill_color = config['colors']['back']\n\n     ➋ position = node.displaced_pos_scaled(settings.disp_scale)\n     ➌ caption_pos = position.displaced(Vector(radius, radius))\n\n        return svg.group([\n         ➍ svg.circle(\n                Circle(position, radius),\n                [\n                    attributes.stroke_width(stroke_size),\n                    attributes.stroke_color(stroke_color),\n                    attributes.fill_color(fill_color)\n                ]\n            ),\n         ➎ caption_to_svg(\n                f'{node.id}', caption_pos, 0, stroke_color, config\n\n            )\n        ])\n\n ➏ return [\n        node_to_svg(node)\n        for node in nodes\n    ]\n```", "```py\nfrom geom2d import Point, Vector, Segment\nfrom graphic import svg\nfrom graphic.svg import attributes\nfrom .captions_svg import caption_to_svg\n\n__I_VERSOR = Vector(1, 0)\n__CAPTION_DISP = 10\n__DECIMAL_POS = 2\n\ndef vector_to_svg(\n        position: Point,\n        vector: Vector,\n        scale: float,\n        color: str,\n        config\n):\n ➊ segment = Segment(\n        position.displaced(vector, -scale),\n        position\n    )\n ➋ caption_origin = segment.start.displaced(\n        segment.normal_versor,\n        __CAPTION_DISP\n    )\n\n    def svg_arrow():\n        pass\n\n    def svg_caption():\n        pass\n\n ➌ return svg.group([\n        svg_arrow(),\n        svg_caption()\n    ])\n```", "```py\n--snip--\n\ndef vector_to_svg(\n        position: Point,\n        vector: Vector,\n        scale: float,\n        color: str,\n        config\n):\n    segment = Segment(\n        position.displaced(vector, -scale),\n        position\n    )\n    caption_origin = segment.start.displaced(\n        segment.normal_versor,\n        __CAPTION_DISP\n    )\n\n    def svg_arrow():\n        width = config['sizes']['stroke']\n        arrow_size = config['sizes']['arrow']\n\n     ➊ return svg.arrow(\n            segment,\n            arrow_size,\n            arrow_size,\n            [\n                attributes.stroke_color(color),\n                attributes.stroke_width(width),\n                attributes.fill_color('none')\n            ]\n        )\n\n    def svg_caption():\n     ➋ return caption_to_svg(\n           vector.to_formatted_str(__DECIMAL_POS),\n           caption_origin,\n           vector.angle_to(__I_VERSOR),\n           color,\n           config\n        )\n\n    return svg.group([\n        svg_arrow(),\n        svg_caption()\n    ])\n```", "```py\nclass Vector:\n    --snip--\n\n    def to_formatted_str(self, decimals: int):\n        u = round(self.u, decimals)\n        v = round(self.v, decimals)\n        norm = round(self.norm, decimals)\n\n        return f'({u}, {v}) with norm {norm}'\n```", "```py\nclass Point:\n    --snip--\n\n    def to_formatted_str(self, decimals: int):\n        x = round(self.x, decimals)\n        y = round(self.y, decimals)\n\n        return f'({x}, {y})'\n```", "```py\nfrom structures.solution.node import StrNodeSolution\nfrom structures.solution.structure import StructureSolution\nfrom .vector_svg import vector_to_svg\n\ndef node_reactions_to_svg(\n        solution: StructureSolution,\n        settings,\n        config\n):\n    def reaction_svg(node: StrNodeSolution):\n     ➊ position = node.displaced_pos_scaled(settings.disp_scale)\n     ➋ reaction = solution.reaction_for_node(node)\n     ➌ return vector_to_svg(\n            position=position,\n            vector=reaction,\n            scale=settings.load_scale,\n            color=config['colors']['reaction'],\n            config=config\n        )\n\n ➍ return [\n        reaction_svg(node)\n        for node in solution.nodes\n        if node.is_constrained\n    ]\n```", "```py\nfrom geom2d import Vector, Point\nfrom graphic import svg\nfrom structures.solution.node import StrNodeSolution\nfrom .vector_svg import vector_to_svg\n\ndef loads_to_svg(nodes: [StrNodeSolution], settings, config):\n    def svg_node_loads(node: StrNodeSolution):\n     ➊ position = node.displaced_pos_scaled(settings.disp_scale)\n     ➋ return svg.group(\n            [\n                svg_load(position, load)\n                for load in node.loads\n            ]\n        )\n\n    def svg_load(position: Point, load: Vector):\n     ➌ return vector_to_svg(\n            position=position,\n            vector=load,\n            scale=settings.load_scale,\n            color=config['colors']['load'],\n            config=config\n        )\n\n ➍ return [\n        svg_node_loads(node)\n        for node in nodes\n        if node.is_loaded\n    ]\n```", "```py\n  import json\n\n  import pkg_resources as res\n\n  from geom2d import AffineTransform\n  from graphic import svg\n  from structures.solution.structure import StructureSolution\n➊ from .bar_svg import bars_to_svg\n  from .load_svg import loads_to_svg\n  from .node_svg import nodes_to_svg\n  from .reaction_svg import node_reactions_to_svg\n\n  def structure_solution_to_svg(\n          result: StructureSolution,\n          settings,\n          _config=None,\n  ):\n      __validate_settings(settings)\n      default_config = __read_config()\n      config = {**default_config, **(_config or {})}\n\n      viewbox = result.bounds_rect(\n          config['sizes']['margin'],\n          settings.scale\n      )\n      transform = AffineTransform(sx=1, sy=-1, tx=0, ty=0)\n\n    ➋ svg_bars = bars_to_svg(result.bars, settings, config)\n       svg_nodes = nodes_to_svg(result.nodes, settings, config)\n       svg_react = node_reactions_to_svg(result, settings, config)\n       svg_loads = loads_to_svg(result.nodes, settings, config)\n\n       return svg.svg_content(\n           size=viewbox.size,\n        ➌ primitives=svg_bars + svg_nodes + svg_react + svg_loads,\n           viewbox_rect=viewbox,\n           transform=transform\n\n      )\n\n--snip--\n```", "```py\nimport json\n\nimport pkg_resources as res\n\nfrom geom2d import AffineTransform\nfrom graphic import svg\nfrom structures.solution.structure import StructureSolution\nfrom .bar_svg import bars_to_svg\nfrom .load_svg import loads_to_svg\nfrom .node_svg import nodes_to_svg\nfrom .reaction_svg import node_reactions_to_svg\n\ndef structure_solution_to_svg(\n        result: StructureSolution,\n        settings,\n        _config=None,\n):\n    __validate_settings(settings)\n    default_config = __read_config()\n\n    config = {**default_config, **(_config or {})}\n\n    viewbox = result.bounds_rect(\n        config['sizes']['margin'],\n        settings.scale\n    )\n    transform = AffineTransform(sx=1, sy=-1, tx=0, ty=0)\n\n    svg_bars = bars_to_svg(result.bars, settings, config)\n    svg_nodes = nodes_to_svg(result.nodes, settings, config)\n    svg_react = node_reactions_to_svg(result, settings, config)\n    svg_loads = loads_to_svg(result.nodes, settings, config)\n\n    return svg.svg_content(\n        size=viewbox.size,\n        primitives=svg_bars + svg_nodes + svg_react + svg_loads,\n        viewbox_rect=viewbox,\n        transform=transform\n    )\n\ndef __read_config():\n    config = res.resource_string(__name__, 'config.json')\n    return json.loads(config)\n\n__expected_settings = (\n    # scale applied to the diagram\n    'scale',\n    # scale applied to the node displacements\n    'disp_scale',\n    # scale applied to the load vectors\n    'load_scale',\n    # boolean to decide whether to draw the original geometry\n    'no_draw_original'\n)\n\ndef __validate_settings(settings):\n    for setting in __expected_settings:\n        if setting not in settings:\n            raise ValueError(f'\"{setting}\" missing in settings')\n```", "```py\nNODE 25\n    original position: (1400.0, 150.0)\n    displacement: (0.1133, -0.933) with norm 0.9398\n    displaced position: (1400.1133, 149.067)\n```", "```py\nNODE 1\n    original position: (0.0, 0.0)\n    displacement: (0.0, 0.0) with norm 0.0\n    displaced position: (0.0, 0.0)\n    reaction: (-283.6981, 9906.9764) with norm 9911.0376\n```", "```py\n[mathescape=true]\nBAR 8 (25 → 9) : ⊕ TENSION\n    Δl (elongation) = 0.0026\n    ϵ  (strain)     = 1.045e-05\n    σ  (stress)     = 209.0219\n```", "```py\ndef list_to_string(strings: [str]) -> str:\n    return '\\n'.join(strings)\n```", "```py\n  from structures.solution.bar import StrBarSolution\n  from structures.solution.node import StrNodeSolution\n  from structures.solution.structure import StructureSolution\n  from utils.strings import list_to_string\n\n➊ __DECIMAL_POS = 4\n  __SEPARATION = ['------------------------------------------', '\\n']\n\n  def structure_solution_to_string(result: StructureSolution):\n   ➋ nodes_text = __nodes_to_string(result)\n   ➌ bars_text = __bars_to_string(result.bars)\n   ➍ return list_to_string(nodes_text + __SEPARATION + bars_text)\n\n  def __nodes_to_string(result: StructureSolution):\n      pass\n\n  def __node_to_string(\n          result: StructureSolution,\n          node: StrNodeSolution\n  ):\n      pass\n\n  def __bars_to_string(bars: [StrBarSolution]):\n      pass\n\n  def __bar_to_string(bar: StrBarSolution):\n      pass\n```", "```py\n--snip--\n\ndef __nodes_to_string(result: StructureSolution):\n    return [\n     ➊ __node_to_string(result, node)\n        for node in result.nodes\n    ]\n\ndef __node_to_string(\n        result: StructureSolution,\n        node: StrNodeSolution\n):\n ➋ orig_pos = node.original_pos.to_formatted_str(__DECIMAL_POS)\n    displacement = node.global_disp.to_formatted_str(__DECIMAL_POS)\n    disp_pos = node.displaced_pos.to_formatted_str(__DECIMAL_POS)\n\n ➌ strings = [\n        f'NODE {node.id}',\n        f'\\toriginal position: {orig_pos}',\n        f'\\tdisplacement: {displacement}',\n        f'\\tdisplaced position: {disp_pos}'\n    ]\n\n ➍ if node.is_constrained:\n        react = result.reaction_for_node(node)\n        react_str = react.to_formatted_str(__DECIMAL_POS)\n        strings.append(f'\\treaction: {react_str}')\n\n ➎ return list_to_string(strings) + '\\n'\n\n--snip--\n```", "```py\nNODE 2\n    original position: (200.0, 0.0)\n    displacement: (0.0063, -0.1828) with norm 0.1829\n    displaced position: (200.0063, -0.1828)\n```", "```py\n--snip--\n\ndef __bars_to_string(bars: [StrBarSolution]):\n ➊ return [__bar_to_string(bar) for bar in bars]\n\ndef __bar_to_string(bar: StrBarSolution):\n ➋ nodes_str = f'{bar.start_node.id} → {bar.end_node.id}'\n    type_str = '⊕ TENSION' if bar.stress >= 0 else '⊖ COMPRESSION'\n    elongation = round(bar.elongation, __DECIMAL_POS)\n    strain = '{:.3e}'.format(bar.strain)\n    stress = round(bar.stress, __DECIMAL_POS)\n\n ➌ return list_to_string([\n        f'BAR {bar.id} ({nodes_str}) : {type_str}',\n        f'\\tΔl (elongation) = {elongation}',\n        f'\\tϵ  (strain)     = {strain}',\n        f'\\tσ  (stress)     = {stress}\\n'\n    ])\n```", "```py\n>>> '\\u2295 is a Unicode symbol'\n'⊕ is a Unicode symbol'\n```", "```py\nfrom structures.solution.bar import StrBarSolution\nfrom structures.solution.node import StrNodeSolution\nfrom structures.solution.structure import StructureSolution\nfrom utils.strings import list_to_string\n\n__DECIMAL_POS = 4\n__SEPARATION = ['------------------------------------------', '\\n']\n\ndef structure_solution_to_string(result: StructureSolution):\n    nodes_text = __nodes_to_string(result)\n    bars_text = __bars_to_string(result.bars)\n    return list_to_string(nodes_text + __SEPARATION + bars_text)\n\ndef __nodes_to_string(result: StructureSolution):\n    return [\n        __node_to_string(result, node)\n        for node in result.nodes\n    ]\n\ndef __node_to_string(\n        result: StructureSolution,\n        node: StrNodeSolution\n):\n    orig_pos = node.original_pos.to_formatted_str(__DECIMAL_POS)\n    displacement = node.global_disp.to_formatted_str(__DECIMAL_POS)\n    disp_pos = node.displaced_pos.to_formatted_str(__DECIMAL_POS)\n\n    strings = [\n        f'NODE {node.id}',\n        f'\\toriginal position: {orig_pos}',\n        f'\\tdisplacement: {displacement}',\n        f'\\tdisplaced position: {disp_pos}'\n    ]\n\n    if node.is_constrained:\n        react = result.reaction_for_node(node)\n        react_str = react.to_formatted_str(__DECIMAL_POS)\n        strings.append(f'\\treaction: {react_str}')\n\n    return list_to_string(strings) + '\\n'\n\ndef __bars_to_string(bars: [StrBarSolution]):\n    return [__bar_to_string(bar) for bar in bars]\n\ndef __bar_to_string(bar: StrBarSolution):\n    nodes_str = f'{bar.start_node.id} → {bar.end_node.id}'\n    type_str = '⊕ TENSION' if bar.stress >= 0 else '⊖ COMPRESSION'\n    elongation = round(bar.elongation, __DECIMAL_POS)\n    strain = '{:.3e}'.format(bar.strain)\n    stress = round(bar.stress, __DECIMAL_POS)\n\n    return list_to_string([\n        f'BAR {bar.id} ({nodes_str}) : {type_str}',\n        f'\\tΔl (elongation) = {elongation}',\n        f'\\tϵ  (strain)     = {strain}',\n        f'\\tσ  (stress)     = {stress}\\n'\n    ])\n```"]