## **2

PYTHON 技巧**

![Image](img/comm-1.jpg)

对我们来说，*技巧*是一种出人意料地快速或简便地完成任务的方法。在本书中，你将学习多种技巧和技术，使代码更加简洁，并提高实现的速度。虽然本书的所有技术章节都展示了 Python 技巧，但这一章关注的是“低垂的果实”：你可以迅速而轻松地采纳的技巧，但对提高编码生产力有极大帮助。

本章也为后面更高级的章节奠定基础。你需要理解这些单行代码中介绍的技能，才能理解后续的内容。特别地，我们将涵盖一系列基本的 Python 功能，帮助你编写高效的代码，包括列表推导式、文件访问、`map()` 函数、`lambda` 函数、`reduce()` 函数、切片、切片赋值、生成器函数以及 `zip()` 函数。

如果你已经是一个高级程序员，可以快速浏览这一章，并选择你想要深入研究的部分——以及你已经掌握得很好的一些部分。

### **使用列表推导式查找高收入者**

在这一节中，你将学习到一个既优美又强大、高效的 Python 特性——列表推导式。你将在接下来的许多单行代码中使用列表推导式。

#### ***基础知识***

假设你在一家大公司的 HR 部门工作，需要找出所有年收入至少为 10 万美元的员工。你期望的输出结果是一个元组列表，每个元组包含两个值：员工姓名和员工的年薪。你可以开发出以下代码：

```py
employees = {'Alice' : 100000,

             'Bob' : 99817,

             'Carol' : 122908,

             'Frank' : 88123,

             'Eve' : 93121}

top_earners = []

for key, val in employees.items():

    if val >= 100000:

        top_earners.append((key,val))

print(top_earners)

# [('Alice', 100000), ('Carol', 122908)]
```

虽然代码是正确的，但有一种更简单、更加简洁——因此也更易读——的方法可以实现相同的结果。其他条件相同的情况下，*行数更少*的解决方案能让读者更快地理解代码的含义。

Python 提供了一种强大的创建新列表的方法：*列表推导式*。其简单的公式如下：

```py
[ expression + context ]
```

包围的括号表示结果是一个新的列表。*上下文*定义了选择哪些列表元素。*表达式*定义了如何在将结果添加到列表之前修改每个列表元素。下面是一个示例：

```py
[x * 2 for x in range(3)]
```

方程中的粗体部分，**for x in range(3)**，是上下文，剩余部分 `x * 2` 是表达式。大致来说，表达式将上下文生成的 0、1、2 的值翻倍。因此，列表推导式的结果是如下列表：

```py
[0, 2, 4]
```

表达式和上下文都可以是任意复杂的。表达式可以是上下文中定义的任何变量的函数，并且可以执行任何计算——它甚至可以调用外部函数。表达式的目标是修改每个列表元素，然后将其添加到新列表中。

上下文可以由一个或多个变量组成，这些变量是通过一个或多个嵌套的 `for` 循环定义的。你也可以通过使用 `if` 语句来限制上下文。在这种情况下，只有在用户定义的条件成立时，新的值才会被添加到列表中。

列表推导式最好通过示例来解释。仔细研究以下示例，你将能更好地理解列表推导式：

```py
print([➊x ➋for x in range(5)])

# [0, 1, 2, 3, 4]
```

**表达式** ➊：恒等函数（不改变上下文变量 `x`）。

**上下文** ➋：上下文变量 `x` 获取由范围函数返回的所有值：`0, 1, 2, 3, 4`。

```py
print([➊(x, y) ➋for x in range(3) for y in range(3)])

# [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
```

**表达式** ➊：从上下文变量 `x` 和 `y` 创建一个新的元组。

**上下文** ➋：上下文变量 `x` 遍历范围函数返回的所有值 (`0`、`1`、`2`)，而上下文变量 `y` 遍历范围函数返回的所有值 (`0`、`1`、`2`)。这两个 `for` 循环是嵌套的，因此上下文变量 `y` 会对上下文变量 `x` 的每个值重复其迭代过程。因此，总共有 3 × 3 = 9 种上下文变量组合。

```py
print([➊x ** 2 ➋for x in range(10) if x % 2 > 0])

# [1, 9, 25, 49, 81]
```

**表达式** ➊：对上下文变量 `x` 应用平方函数。

**上下文** ➋：上下文变量 `x` 遍历范围函数返回的所有值——`0`、`1`、`2`、`3`、`4`、`5`、`6`、`7`、`8`、`9`——但仅当它们是奇数时，即 `x % 2 > 0`。

```py
print([➊x.lower() ➋for x in ['I', 'AM', 'NOT', 'SHOUTING']])

# ['i', 'am', 'not', 'shouting']
```

**表达式** ➊：对上下文变量 `x` 应用字符串小写函数。

**上下文** ➋：上下文变量 `x` 遍历列表中的所有字符串值：`'I'`、`'AM'`、`'NOT'`、`'SHOUTING'`。

现在，你应该能够理解以下的代码片段。

#### ***代码***

让我们考虑之前提到的员工薪水问题：给定一个包含字符串键和整数值的字典，创建一个新的 (key, value) 元组列表，其中键对应的值大于或等于 100,000。 示例 2-1 展示了相关代码。

```py
## Data

employees = {'Alice' : 100000,

             'Bob' : 99817,

             'Carol' : 122908,

             'Frank' : 88123,

             'Eve' : 93121}

## One-Liner

top_earners = [(k, v) for k, v in employees.items() if v >= 100000]

## Result

print(top_earners)
```

*列表推导式的单行解决方案：示例 2-1*

这段代码的输出是什么？

#### ***它是如何工作的***

让我们来分析这个单行代码：

```py
top_earners = [ ➊(k, v) ➋for k, v in employees.items() if v >= 100000]
```

**表达式** ➊：为上下文变量 `k` 和 `v` 创建一个简单的 (key, value) 元组。

**上下文** ➋：字典方法 `dict.items()` 确保上下文变量 `k` 遍历字典中的所有键，同时上下文变量 `v` 遍历与上下文变量 `k` 关联的值——但仅在上下文变量 `v` 的值大于或等于 100,000 时，这一点通过 `if` 条件得到确保。

单行代码的结果如下：

```py
print(top_earners)

# [('Alice', 100000), ('Carol', 122908)]
```

这个简单的单行程序介绍了一个重要的概念——*列表推导式*。在本书的多个实例中，我们使用了列表推导式，因此在继续阅读之前，请确保理解本节中的示例。

### **使用列表推导式查找高信息量的词语**

在这个单行代码中，你将更深入地探讨列表推导式的强大功能。

#### ***基础概念***

搜索引擎根据文本信息与用户查询的相关性来对文本进行排名。为此，搜索引擎分析要搜索的文本内容。所有文本都由单词组成。某些单词能提供大量关于文本内容的信息，而其他单词则没有。例如，前者的单词包括*white*、*whale*、*Captain*、*Ahab*（你知道这段文本吗？）。后者的单词包括*is*、*to*、*as*、*the*、*a*或*how*，因为大多数文本都包含这些单词。过滤掉那些对意义贡献不大的单词是实现搜索引擎时的常见做法。一种简单的启发式方法是过滤掉所有字符数为三个或更少的单词。

#### ***代码***

我们的目标是解决以下问题：给定一个多行字符串，创建一个由多个列表组成的列表——每个列表包含该行中所有字符数大于三的单词。清单 2-2 提供了数据和解决方案。

```py
## Data

text = '''

Call me Ishmael. Some years ago - never mind how long precisely - having

little or no money in my purse, and nothing particular to interest me

on shore, I thought I would sail about a little and see the watery part

of the world. It is a way I have of driving off the spleen, and regulating

the circulation. - Moby Dick'''

## One-Liner

w = [[x for x in line.split() if len(x)>3] for line in text.split('\n')]

## Result

print(w)
```

*清单 2-2：一行解决方案，用于查找具有高信息量的单词*

这段代码的输出是什么？

#### ***工作原理***

这行代码通过使用两个嵌套的列表推导式，创建了一个由多个列表组成的列表：

+   内层列表推导式`[x for x in line.split() if len(x)>3]`使用字符串的`split()`函数将给定行分割成一系列单词。我们遍历所有单词`x`，如果它们的字符数大于三，就将它们添加到列表中。

+   外层列表推导式创建了之前语句中使用的字符串`line`。同样，它使用`split()`函数根据换行符`'\n'`将文本分割开来。

当然，您需要习惯以列表推导式的方式思考，因此其含义可能对您来说并不直观。但是在读完本书后，列表推导式将成为您的基本工具——您会很快像这样阅读和编写符合 Python 风格的代码。

### **读取文件**

在本节中，您将读取一个文件并将结果存储为一个字符串列表（每行一个字符串）。您还将删除行首和行尾的空白字符。

#### ***基础知识***

在 Python 中，读取文件非常简单，但通常需要几行代码（以及一两次 Google 搜索）才能完成。以下是 Python 中读取文件的一种标准方式：

```py
filename = "readFileDefault.py" # this code

f = open(filename)

lines = []

for line in f:

    lines.append(line.strip())

print(lines)

"""

['filename = "readFileDefault.py" # this code',

'',

'f = open(filename)',

'lines = []',

'for line in f:',

'lines.append(line.strip())',

'',

'print(lines)']

"""
```

代码假设您已经将这段代码片段存储在名为*readFileDefault.py*的文件中，并且该文件位于某个文件夹中。代码接着打开该文件，创建一个空列表`lines`，并通过在`for`循环体中使用`append()`操作遍历文件中的所有行，将字符串添加到列表中。您还使用了字符串方法`strip()`来移除任何行首或行尾的空白字符（否则换行符`'\n'`将出现在字符串中）。

要访问你计算机上的文件，你需要知道如何打开和关闭文件。只有在打开文件后，你才能访问文件的数据。关闭文件后，你可以确定数据已经写入文件。Python 可能会创建一个缓冲区，并等待一段时间，才将整个缓冲区的数据写入文件中（图 2-1）。原因很简单：文件访问速度较慢。为了提高效率，Python 避免每次单独写入每一个字节，而是等待直到缓冲区填充足够的字节，再一次性将整个缓冲区写入文件。

![images](img/fig2-1.jpg)

*图 2-1：在 Python 中打开和关闭文件*

这就是为什么在读取文件后最好使用命令`f.close()`关闭文件，以确保所有数据正确写入文件，而不是停留在临时内存中。不过，Python 在一些特殊情况下会自动关闭文件：其中一个例外是当引用计数降为零时，正如你将在以下代码中看到的。

#### ***代码***

我们的目标是打开一个文件，读取所有行，去除前后空格字符，并将结果存储在一个列表中。清单 2-3 提供了这行代码。

```py
print([line.strip() for line in open("readFile.py")])
```

*清单 2-3：逐行读取文件的单行解决方案。*

在继续阅读之前，不妨先猜猜这个代码片段的输出是什么。

#### ***工作原理***

你使用 `print()` 语句将结果列表打印到命令行。你通过使用列表推导式来创建该列表（请参见 “使用列表推导式查找收入最高的人” 在 第 18 页）。在列表推导式的*表达式*部分，你使用字符串对象的 `strip()` 方法。

列表推导式的*上下文*部分会遍历文件中的所有行。

一行代码的输出就是这行代码本身（因为它读取了名为*readFile.py*的 Python 源代码文件），并将其包装成字符串，填入一个列表中：

```py
print([line.strip() for line in open("readFile.py")])

# ['print([line.strip() for line in open("readFile.py")])']
```

本节展示了通过让代码更简洁、精炼，可以在不牺牲效率的情况下提高可读性。

### **使用 Lambda 和 Map 函数**

本节介绍了两个重要的 Python 特性：`lambda` 和 `map()` 函数。这两个函数是你 Python 工具箱中的宝贵工具。你将使用这些函数在一个字符串列表中查找另一个字符串的出现。

#### ***基础知识***

在第一章中，你学习了如何使用`def`关键字定义一个新函数，后跟函数的内容。然而，这并不是在 Python 中定义函数的唯一方式。你还可以使用*lambda 函数*定义一个简单的*具有返回值*的函数（返回值可以是任何对象，包括元组、列表和集合）。换句话说，每个 lambda 函数都会向其调用环境返回一个对象值。需要注意的是，这给 lambda 函数带来了实际的限制，因为与标准函数不同，lambda 函数并不设计用来执行*没有*返回对象值的代码。

**注意**

*我们在第一章中已经介绍了 lambda 函数，但由于它是本书中贯穿始终的重要概念，我们将在本节深入探讨。*

lambda 函数允许你通过使用关键字`lambda`在一行中定义一个新函数。这在你需要快速创建一个只会使用一次并且可以立即进行垃圾回收的函数时非常有用。我们首先来研究 lambda 函数的具体语法：

```py
lambda arguments : return expression
```

你以关键字`lambda`开始定义函数，后跟一系列函数参数。在调用该函数时，调用者必须提供这些参数。然后，你在函数定义中包含一个冒号（`:`）和*返回表达式*，该表达式根据 lambda 函数的参数计算返回值。返回表达式计算函数的输出，并且可以是任何 Python 表达式。以下是一个函数定义的示例：

```py
lambda x, y: x + y
```

这个 lambda 函数有两个参数，`x`和`y`。返回值就是这两个参数的和，`x + y`。

通常在你只会调用一次函数，并且可以在一行代码中轻松定义它时，才会使用 lambda 函数。一个常见的例子是将 lambda 与`map()`函数一起使用，`map()`函数的输入参数是一个函数对象`f`和一个序列`s`。然后，`map()`函数将在序列`s`中的每个元素上应用函数`f`。当然，你*可以*定义一个完整的命名函数来定义函数参数`f`，但这样做通常不方便，并且会降低可读性——特别是当函数很短且只需要使用一次时——因此，通常最好在这里使用 lambda 函数。

在展示单行代码之前，我将简要介绍另一个小的 Python 技巧，帮助你更轻松地处理问题：通过使用表达式`y in x`来检查字符串`x`是否包含子字符串`y`。如果字符串`x`中至少有一个`y`，该表达式将返回`True`。例如，表达式`'42' in 'The answer is 42'`的结果为`True`，而表达式`'21' in 'The answer is 42'`的结果为`False`。

现在让我们来看一下我们的单行代码。

#### ***代码***

给定一个字符串列表，接下来的单行代码（Listing 2-4）将创建一个包含布尔值和原始字符串的元组的新列表。布尔值表示字符串 `'anonymous'` 是否出现在原始字符串中！我们将结果列表命名为 `mark`，因为布尔值 *标记* 了列表中包含字符串 `'anonymous'` 的元素。

```py
## Data

txt = ['lambda functions are anonymous functions.',

       'anonymous functions dont have a name.',

       'functions are objects in Python.']

## One-Liner

mark = map(lambda s: (True, s) if 'anonymous' in s else (False, s), txt)

## Result

print(list(mark))
```

*Listing 2-4：标记包含字符串 `'anonymous'` 的字符串的单行解决方案*

这段代码的输出是什么？

#### ***工作原理***

`map()` 函数将布尔值添加到原始 `txt` 列表中的每个字符串元素。如果字符串元素包含单词 *anonymous*，则布尔值为 `True`。第一个参数是匿名的 lambda 函数，第二个参数是你想检查的字符串列表。

你使用 lambda 返回表达式 `(True, s) if 'anonymous' in s else (False, s)` 来查找字符串 `'anonymous'`。值 `s` 是 lambda 函数的输入参数，在此例中是一个字符串。如果查询的字符串 `'anonymous'` 存在于该字符串中，表达式将返回元组 `(True, s)`。否则，返回元组 `(False, s)`。

单行代码的结果如下：

```py
## Result

print(list(mark))

# [(True, 'lambda functions are anonymous functions.'), 

# (True, 'anonymous functions dont have a name.'), 

# (False, 'functions are objects in Python.')]
```

布尔值表明列表中只有前两个字符串包含子字符串 `'anonymous'`。

在接下来的单行代码中，你会发现 lambda 表达式非常有用。你也在不断向目标前进：理解你在实践中遇到的每一行 Python 代码。

**练习 2-1**

使用列表推导式而不是 `map()` 函数来实现相同的输出。（你可以在本章末尾找到解决方案。）

### **使用切片提取匹配的子字符串环境**

本节讲解了 *切片* 的重要基础概念——从原始完整序列中提取子序列的过程——用于处理简单的文本查询。我们将搜索文本中的特定字符串，然后提取该字符串及其周围的一些字符，以提供上下文。

#### ***基础知识***

切片是许多 Python 概念和技能的核心，无论是高级还是基础的，譬如在使用 Python 内置的数据结构（如列表、元组和字符串）时。切片也是许多高级 Python 库（如 NumPy、Pandas、TensorFlow 和 scikit-learn）的基础。深入学习切片将对你作为 Python 编程人员的职业生涯产生积极的连锁反应。

切片从序列中提取子序列，例如提取字符串的一部分。语法非常简单。假设你有一个变量 `x`，它引用了一个字符串、列表或元组。你可以使用以下符号来提取子序列：

```py
x[start:stop:step].
```

结果子序列从索引 `start`（包含）开始，到索引 `stop`（不包含）结束。你可以包含一个可选的第三个 `step` 参数，用于确定提取哪些元素，因此你可以选择仅包括每隔 `step` 个元素。例如，对变量 `x = 'hello world'` 使用切片操作 `x[1:4:1]`，结果为字符串 `'ell'`。对同一变量使用切片操作 `x[1:4:2]`，结果为字符串 `'el'`，因为每隔一个元素才会被包含到结果切片中。回顾 第一章，在 Python 中，任何序列类型（如字符串和列表）的第一个元素的索引是 0。

如果你不包含 `step` 参数，Python 会假定步长默认为 1。例如，切片调用 `x[1:4]` 将返回字符串 `'ell'`。

如果你不包含起始或结束参数，Python 假定你希望从开始处切片，或从结束处切片。例如，切片调用 `x[:4]` 将返回字符串 `'hell'`，而切片调用 `x[4:]` 将返回字符串 `'o world'`。

研究以下示例，以进一步提升你的直观理解。

```py
  s = 'Eat more fruits!'

  print(s[0:3])

  # Eat

➊ print(s[3:0]) 

  # (empty string '')

  print(s[:5])

  # Eat m

  print(s[5:])

  # ore fruits!

➋ print(s[:100]) 

  # Eat more fruits!

  print(s[4:8:2])

  # mr

➌ print(s[::3]) 

  # E rfi!

➍ print(s[::-1]) 

  # !stiurf erom taE

  print(s[6:1:-1]) 

  # rom t
```

这些 Python 切片基本的 `[start:stop:step]` 模式的变种突出了该技巧的许多有趣属性：

+   如果 `start` >= `stop` 且 `step` 为正数，则切片为空 ➊。

+   如果 `stop` 参数大于序列长度，Python 将切片到并包含最右边的元素 ➋。

+   如果 `step` 大小为正，默认的起始位置是最左边的元素，默认的结束位置是最右边的元素（包含） ➌。

+   如果 `step` 大小为负（`step` < 0），切片将按反向顺序遍历序列。在没有指定起始和结束参数的情况下，你将从最右侧的元素（包含）切片到最左侧的元素（包含）➍。注意，如果给定了 `stop` 参数，相应的位置将被排除在切片之外。

接下来，你将使用切片和 `string.find(value)` 方法来查找给定字符串中 `value` 的索引位置。

#### ***代码***

我们的目标是在一个多行字符串中查找特定的文本查询。你希望在文本中找到查询内容，并返回其即时环境，最多包括查询前后 18 个位置。提取环境以及查询本身有助于看到找到的字符串的文本上下文——就像 Google 在搜索关键词时展示的文本片段。在 示例 2-5 中，你要在亚马逊致股东的信中查找字符串 `'SQL'`，并返回该字符串前后最多 18 个字符的环境。

```py
## Data

letters_amazon = '''

We spent several years building our own database engine,

Amazon Aurora, a fully-managed MySQL and PostgreSQL-compatible

service with the same or better durability and availability as

the commercial engines, but at one-tenth of the cost. We were

not surprised when this worked.

'''

## One-Liner

find = lambda x, q: x[x.find(q)-18:x.find(q)+18] if q in x else -1

## Result

print(find(letters_amazon, 'SQL'))
```

*示例 2-5：在文本中查找字符串及其直接环境的单行解决方案*

猜一猜这段代码的输出。

#### ***工作原理***

你定义了一个包含两个参数的 lambda 函数：一个字符串值`x`，和一个查询`q`，用于在文本中查找。你将 lambda 函数赋值给名称`find`。函数`find(x, q)`在字符串文本`x`中查找字符串查询`q`。

如果查询`q`没有出现在字符串`x`中，你直接返回结果`-1`。否则，你使用切片操作在文本字符串上切出查询第一次出现的部分，并在查询左侧和右侧各加上 18 个字符，以捕捉查询的上下文。你发现`q`在`x`中的第一次出现的索引是通过字符串函数`x.find(q)`来找到的。你调用该函数两次：一次用于确定切片的起始索引，另一次用于确定结束索引，但这两次函数调用返回相同的值，因为查询`q`和字符串`x`都没有发生变化。虽然这段代码完全正常工作，但冗余的函数调用导致了不必要的计算——这是一个可以通过添加一个辅助变量来暂时存储第一次函数调用结果并重用的缺点。

本讨论突出了一个重要的折中：通过将自己限制为一行代码，你不能定义和重用一个辅助变量来存储查询的第一次出现的索引。相反，你必须执行相同的`find`函数来计算起始索引（并将结果减去 18 个索引位置），并计算结束索引（并将结果加上 18 个索引位置）。在第五章，你将学习一种更高效的字符串模式搜索方法（使用正则表达式），解决这个问题。

在搜索亚马逊给股东的信中查询`'SQL'`时，你会在文本中找到查询的一个出现：

```py
## Result

print(find(letters_amazon, 'SQL'))

# a fully-managed MySQL and PostgreSQL
```

结果，你得到字符串及其周围的几个单词，以提供查找的上下文。切片是你基础 Python 学习中的一个关键元素。让我们通过另一个切片单行代码来进一步加深你的理解。

### **结合列表推导式和切片**

本节结合了列表推导式和切片，用于从一个二维数据集中采样。我们的目标是从一个庞大的样本中创建一个更小但具有代表性的样本。

#### ***基础知识***

假设你在一家大银行担任金融分析师，并正在为股票价格预测训练一个新的机器学习模型。你拥有一个真实世界股票价格的训练数据集。然而，数据集非常庞大，模型训练在你的电脑上似乎永远也训练不完。例如，在机器学习中，通常需要测试不同模型参数集的预测准确度。在我们的应用中，假设你必须等上好几个小时，直到训练程序结束（在大规模数据集上训练高度复杂的模型实际上确实需要几个小时）。为了加快速度，你通过排除每隔一个的股票价格数据点将数据集减半。你并不期望这种修改会显著降低模型的准确性。

本节中，你将使用本章前面学习过的两个 Python 特性：列表推导式和切片。列表推导式允许你遍历每个列表元素并随后修改它。切片允许你快速选择给定列表中的每隔一个元素——它自然适用于简单的过滤操作。让我们详细看看这两个特性如何结合使用。

#### ***代码***

我们的目标是从数据中创建一个新的训练数据样本——一个由六个浮动值组成的列表的列表——只包括原始数据集中每隔一个的浮动值。请查看清单 2-6。

```py
## Data (daily stock prices ($))

price = [[9.9, 9.8, 9.8, 9.4, 9.5, 9.7],

         [9.5, 9.4, 9.4, 9.3, 9.2, 9.1],

         [8.4, 7.9, 7.9, 8.1, 8.0, 8.0],

         [7.1, 5.9, 4.8, 4.8, 4.7, 3.9]]

## One-Liner

sample = [line[::2] for line in price]

## Result

print(sample)
```

*清单 2-6：单行代码解决方案来抽样数据*

和往常一样，看看你能否猜出输出结果。

#### ***它是如何工作的***

我们的解决方案是一个两步法。首先，你使用列表推导式遍历原始列表`price`的所有行。第二，你通过切片每一行来创建一个新的浮动值列表；你使用`line[start:stop:step]`，其中 start 和 stop 使用默认参数，步长为`2`。新的浮动值列表仅包含三个（而不是六个）浮动值，结果是以下数组：

```py
## Result

print(sample)

# [[9.9, 9.8, 9.5], [9.5, 9.4, 9.2], [8.4, 7.9, 8.0], [7.1, 4.8, 4.7]]
```

这个使用内置 Python 功能的一行代码并不复杂。然而，你将在第三章中了解一个更简短的版本，它使用 NumPy 库进行数据科学计算。

**练习 2-2**

在学习完第三章后，重新审视这一行代码，并用 NumPy 库来提出一个更简洁的解决方案。一点提示：使用 NumPy 更强大的切片功能。

### **使用切片赋值来修正损坏的列表**

本节向你展示了 Python 中一个强大的切片功能：切片赋值。*切片赋值*在赋值操作的*左侧*使用切片符号来修改原始序列的子序列。

#### ***基础知识***

假设您在一家小型互联网创业公司工作，负责追踪用户的 Web 浏览器（如谷歌 Chrome、Firefox、Safari）。您将数据存储在数据库中。为了分析数据，您将收集到的浏览器数据加载到一个包含大量字符串的列表中，但由于跟踪算法中的一个 bug，每隔一个字符串会被损坏，需要替换为正确的字符串。

假设您的 Web 服务器总是将用户的第一次 Web 请求重定向到另一个 URL（这在 Web 开发中是一种常见做法，称为 HTML 代码 301：*永久移动*）。您得出结论，在大多数情况下，第一个浏览器值将等于第二个浏览器值，因为用户的浏览器在等待重定向发生时保持不变。这意味着您可以轻松地重现原始数据。实质上，您想要将列表中的每隔一个字符串复制一次：列表 `['Firefox', 'corrupted', 'Chrome', 'corrupted']` 变成 `['Firefox', 'Firefox', 'Chrome', 'Chrome']`。

如何以快速、易读且高效的方式（最好是一行代码）实现这一点？您的第一个想法是创建一个新的列表，遍历损坏的列表，并将每个未损坏的浏览器字符串添加到新列表中两次。但您放弃了这个想法，因为那样您就得在代码中维护两个列表——而且每个列表可能有数百万个条目。此外，这种解决方案需要几行代码，会影响代码的简洁性和可读性。

幸运的是，您已经读过一个很棒的 Python 特性：切片赋值。您将使用切片赋值来选择并替换索引 `i` 和 `j` 之间的*元素序列*，通过使用切片符号 `lst[i:j] = [0 0 ...0]`。因为您在赋值操作的*左侧*使用了切片 `lst[i:j]`（而不是之前在右侧使用），这个特性被称为切片*赋值*。

切片赋值的思路很简单：将原始序列中左侧选定的所有元素替换为右侧的元素。

#### ***代码***

我们的目标是用它前面的字符串替换每个字符串；请参见 列表 2-7。

```py
## Data

visitors = ['Firefox', 'corrupted', 'Chrome', 'corrupted',

            'Safari', 'corrupted', 'Safari', 'corrupted',

            'Chrome', 'corrupted', 'Firefox', 'corrupted']

## One-Liner

visitors[1::2] = visitors[::2]

## Result

print(visitors)
```

*列表 2-7：替换所有损坏字符串的单行解决方案*

这段代码中的固定浏览器序列是什么？

#### ***它是如何工作的***

单行解决方案将 `'corrupted'` 字符串替换为它们前面的浏览器字符串。您使用切片赋值符号来访问 `visitors` 列表中每个被损坏的元素。我在以下代码片段中高亮显示了选定的元素：

```py
visitors = ['Firefox', 'corrupted', 'Chrome', 'corrupted',

            'Safari', 'corrupted', 'Safari', 'corrupted',

            'Chrome', 'corrupted', 'Firefox', 'corrupted']
```

代码通过赋值操作右侧的切片来替换这些选定的元素。这些元素在以下代码片段中被高亮显示：

```py
visitors = ['Firefox', 'corrupted', 'Chrome', 'corrupted',

            'Safari', 'corrupted', 'Safari', 'corrupted',

            'Chrome', 'corrupted', 'Firefox', 'corrupted']
```

前面的元素被后面的元素替换。因此，结果 `visitors` 列表如下所示（高亮显示了被替换的元素）：

```py
## Result

print(visitors)

'''

['Firefox', 'Firefox', 'Chrome', 'Chrome',

'Safari', 'Safari', 'Safari', 'Safari',

'Chrome', 'Chrome', 'Firefox', 'Firefox']

'''
```

结果是，原始列表中的每个 `'corrupted'` 字符串都被其前一个浏览器字符串替换。这样，你就清理了受损的数据集。

使用切片赋值来解决这个问题是完成你小任务最快、最有效的方法。请注意，清洗后的数据具有非偏倚的浏览器使用统计信息：在受损数据中占有 70% 市场份额的浏览器，在清洗后的数据中仍将保持 70% 的市场份额。清洗后的数据可以用于进一步分析——例如，找出是否 Safari 用户是更好的客户（毕竟，他们往往在硬件上花费更多）。你已经学会了一种简单且简洁的方式来编程修改列表并且在原地进行修改。

### **使用列表连接分析心脏健康数据**

在本节中，你将学习如何使用列表连接操作来反复复制较小的列表，并将它们合并成一个较大的列表，从而生成循环数据。

#### ***基础知识***

这次，你正在为一家医院开发一个小型代码项目。你的目标是通过跟踪患者的心脏周期来监控和可视化患者的健康统计数据。通过绘制预期的心脏周期数据，你将帮助患者和医生监控心脏周期的任何偏差。例如，给定一个包含单次心脏周期的测量数据列表 `[62, 60, 62, 64, 68, 77, 80, 76, 71, 66, 61, 60, 62]`，你希望在 图 2-2 中实现该可视化效果。

![images](img/fig2-2.jpg)

*图 2-2：通过复制* 选定的 *测量数据中的值* 来可视化预期的心脏周期

问题在于列表中的第一个和最后两个数据值是冗余的：`[62, 60, 62, 64, 68, 77, 80, 76, 71, 66, 61, 60, 62]`。当仅绘制单个心脏周期时，这些冗余数据可能会有用，以表示一个完整的周期已被可视化。然而，我们必须去除这些冗余数据，以确保我们复制相同的心脏周期时，预期的心脏周期不会像 图 2-3 中的那样。

![images](img/fig2-3.jpg)

*图 2-3：通过复制* 所有 *测量数据中的值（不过滤冗余数据）* 来可视化预期的心脏周期

显然，你需要 *清理* 原始列表，去除第一个和最后两个冗余数据值：`[62, 60, 62, 64, 68, 77, 80, 76, 71, 66, 61, 60, 62]` 变为 `[60, 62, 64, 68, 77, 80, 76, 71, 66, 61]`。

你将结合切片操作与 Python 新特性 *列表连接*，该特性通过 *连接*（即 *合并*）现有的列表来创建一个新列表。例如，操作 `[1, 2, 3] + [4, 5]` 会生成新列表 `[1, 2, 3, 4, 5]`，但不会替换原始列表。你可以使用 `*` 运算符将 *同一列表* 一次次地连接起来，创建更大的列表：例如，操作 `[1, 2, 3] * 3` 会生成新列表 `[1, 2, 3, 1, 2, 3, 1, 2, 3]`。

此外，您将使用`matplotlib.pyplot`模块来绘制您生成的心脏数据。matplotlib 的`plot(data)`函数期望一个可迭代的参数`data`——*可迭代对象*就是指可以迭代的对象，例如列表——并将其作为后续数据点的`y`值，用于二维图形的绘制。我们来深入了解一下这个示例。

#### ***代码***

给定一个反映测量心脏周期的整数列表，您首先需要通过去除列表中的前两个和最后两个值来清理数据。其次，您通过将心脏周期数据复制到未来时间点来创建一个新的列表，预测未来的心率。列表 2-8 展示了代码。

```py
## Dependencies

import matplotlib.pyplot as plt

## Data

cardiac_cycle = [62, 60, 62, 64, 68, 77, 80, 76, 71, 66, 61, 60, 62]

## One-Liner

expected_cycles = cardiac_cycle[1:-2] * 10

## Result

plt.plot(expected_cycles)

plt.show()
```

*列表 2-8：预测不同时间心率的一行解决方案*

接下来，您将学习这个代码片段的结果。

#### ***它是如何工作的***

这个一行解决方案包含两个步骤。首先，您使用切片来清理数据，通过使用负的停止参数`-2`来切片，直到右边但跳过最后两个冗余的值。其次，您使用复制操作符`*`将结果数据值重复 10 次。最终结果是一个由 10 × 10 = 100 个整数组成的列表，这些整数是通过连接的心脏周期数据。当您绘制结果时，您会看到先前在图 2-2 中显示的期望输出。

### **使用生成器表达式查找支付低于最低工资的公司**

本节结合了您已经学过的一些 Python 基础知识，并介绍了有用的`any()`函数。

#### ***基础知识***

您在美国劳工部从事执法工作，负责找出支付低于最低工资的公司，以便进行进一步调查。就像饿狼盯着肉车一样，您的公平劳动标准法（FLSA）官员已经在等待那些违反最低工资法的公司名单。您能给他们吗？

这是您的武器：Python 的`any()`函数，它接受一个可迭代对象（例如列表），并在至少一个元素的值为`True`时返回`True`。例如，表达式`any([True, False, False, False])`的结果为`True`，而表达式`any([2<1, 3+2>5+5, 3-2<0, 0])`的结果为`False`。

**注意**

*Python 的创造者 Guido van Rossum 非常喜欢内建函数*`any()`*，甚至提议将其作为 Python 3 的内建函数之一。请参阅他 2005 年的博客文章《Python 3000 中的*`reduce()`*命运》，详情请见[`www.artima.com/weblogs/viewpost.jsp?thread=98196`](https://www.artima.com/weblogs/viewpost.jsp?thread=98196)。*

一个有趣的 Python 扩展是列表推导式的概括：生成器表达式。*生成器表达式*的工作方式与列表推导式完全相同——但它不会在内存中创建一个实际的列表。这些数字是动态生成的，而不是显式存储在列表中。例如，代替使用列表推导式来计算前 20 个数字的平方，`sum([x*x for x in range(20)])`，你可以使用生成器表达式：`sum(x*x for x in range(20))`。

#### ***代码***

我们的数据是一个字典的字典，存储着公司员工的时薪。你希望提取出至少有一名员工的工资低于你所在州最低工资（< $9）的公司列表；见列表 2-9。

```py
## Data

companies = {

    'CoolCompany' : {'Alice' : 33, 'Bob' : 28, 'Frank' : 29},

    'CheapCompany' : {'Ann' : 4, 'Lee' : 9, 'Chrisi' : 7},

    'SosoCompany' : {'Esther' : 38, 'Cole' : 8, 'Paris' : 18}}

## One-Liner

illegal = [x for x in companies if any(y<9 for y in companies[x].values())]

## Result

print(illegal)
```

*列表 2-9：找到低于最低工资的公司的一行解决方案*

哪些公司需要进一步调查？

#### ***它是如何工作的***

你在这行代码中使用了两个生成器表达式。

第一个生成器表达式`y<9 for y in companies[x].values()`生成了输入给`any()`函数的内容。它检查每个公司员工的薪水，查看是否低于最低工资`y<9`。结果是一个布尔值的可迭代对象。你使用字典函数`values()`返回字典中存储的所有值。例如，表达式`companies['CoolCompany'].values()`返回时薪的集合`dict_values([33, 28, 29])`。如果其中至少有一个低于最低工资，`any()`函数将返回`True`，公司名称`x`将作为字符串存储在结果列表`illegal`中，如下所述。

第二个生成器表达式是列表推导式`[x for x in companies if any(...)]`，它创建了一个公司名称的列表，其中先前调用的`any()`函数返回`True`。这些公司是那些支付低于最低工资的公司。注意，表达式`for x in companies`访问所有字典的键——公司名称`'CoolCompany'`、`'CheapCompany'`和`'SosoCompany'`。

因此，结果如下：

```py
## Result

print(illegal)

# ['CheapCompany', 'SosoCompany']
```

三家公司中有两家需要进一步调查，因为它们至少有一名员工的薪资过低。你的工作人员可以开始与 Ann、Chrisi 和 Cole 交谈！

### **使用 zip()函数格式化数据库**

在本节中，你将学习如何通过使用`zip()`函数将数据库列名应用到一系列行中。

#### ***基础知识***

`zip()`函数接受可迭代对象`iter_1`、`iter_2`、`...`、`iter_n`，并通过将相应的*i*-th 值对齐为一个元组，将它们聚合成一个单一的可迭代对象。结果是一个元组的*可迭代对象*。例如，考虑这两个列表：

```py
[1,2,3]

[4,5,6]
```

如果你将它们压缩在一起——经过一个简单的数据类型转换，正如你稍后会看到的——你将得到一个新的列表：

```py
[(1,4), (2,5), (3,6)]
```

将它们解压回原始元组需要两个步骤。首先，你需要移除结果的外部方括号，得到以下三个元组：

```py
(1,4)

(2,5)

(3,6)
```

然后，当你将它们一起压缩时，你将得到新的列表：

```py
[(1,2,3), (4,5,6)]
```

所以，你又得到了原来的两个列表！下面的代码片段展示了这一过程的完整实现：

```py
lst_1 = [1, 2, 3]

lst_2 = [4, 5, 6]

# Zip two lists together

zipped = list(zip(lst_1, lst_2))

print(zipped)

# [(1, 4), (2, 5), (3, 6)]

# Unzip to lists again

lst_1_new, lst_2_new = zip(➊*zipped)

print(list(lst_1_new))

print(list(lst_2_new))
```

你使用星号操作符 `*` 来解包 ➊ 列表中的所有元素。此操作符去掉了列表 `zipped` 的外部括号，使得 `zip()` 函数的输入由三个可迭代对象组成（元组 `(1, 4), (2, 5), (3, 6)`）。如果你将这些可迭代对象进行 zip 操作，你会将前三个元组值 `1`、`2` 和 `3` 打包成一个新元组，再将接下来的三个元组值 `4`、`5` 和 `6` 打包成另一个新元组。最终，你得到的迭代对象是 `(1, 2, 3)` 和 `(4, 5, 6)`，这就是原始（未解压）数据。

现在，假设你在公司财务部门的 IT 分支工作。你负责维护所有员工的数据库，包含列名：`'name'`、`'salary'` 和 `'job'`。然而，你的数据格式不规范——它是以 `('Bob', 99000, 'mid-level manager')` 形式存储的多行数据。你想将列名与每条数据关联起来，使其变为可读的形式 `{'name': 'Bob', 'salary': 99000, 'job': 'mid-level manager'}`。你该如何实现？

#### ***代码***

你的数据包含列名和组织为元组列表（行）的员工数据。将列名分配给每一行数据，进而创建一个字典列表。每个字典将列名分配给相应的数据值（列出 2-10）。

```py
## Data

column_names = ['name', 'salary', 'job']

db_rows = [('Alice', 180000, 'data scientist'),

           ('Bob', 99000, 'mid-level manager'),

           ('Frank', 87000, 'CEO')]

## One-Liner

db = [dict(zip(column_names, row)) for row in db_rows]

## Result

print(db)
```

*列出 2-10：将数据库格式应用于元组列表的简洁解法*

那么，数据库 `db` 的打印格式是什么？

#### ***它是如何工作的***

你通过使用列表推导式创建列表（更多关于表达式 *+* 上下文的内容请参见 “使用列表推导式查找高薪员工” 以及 第 18 页）。上下文由变量 `db_rows` 中每一行的元组组成。表达式 `zip(column_names, row)` 将列名和每一行数据打包在一起。例如，列表推导式创建的第一个元素是 `zip(['name', 'salary', 'job'], ('Alice', 180000, 'data scientist'))`，它生成一个 zip 对象，转换成列表后格式为 `[('name', 'Alice'), ('salary', 180000), ('job', 'data scientist')]`。这些元素是 `(*key*, *value*)` 形式，因此你可以通过使用转换函数 `dict()` 将其转换成字典，达到所需的数据库格式。

**注意**

*`zip()`* 函数不关心一个输入是列表而另一个是元组。该函数只要求输入是可迭代的（列表和元组都是可迭代的）。

这是单行代码片段的输出结果：

```py
## Result

print(db)

'''

[{'name': 'Alice', 'salary': 180000, 'job': 'data scientist'},

{'name': 'Bob', 'salary': 99000, 'job': 'mid-level manager'},

{'name': 'Frank', 'salary': 87000, 'job': 'CEO'}]

'''
```

每个数据项现在都与其名称关联，形成了一个字典列表。你已经学会了如何有效地使用 `zip()` 函数。

### **总结**

在本章中，你已经掌握了列表推导式、文件输入、`lambda` 函数、`map()` 和 `zip()` 函数、`all()` 量词、切片和基本的列表运算。你还学会了如何使用和操作数据结构来解决各种日常问题。

数据结构的来回转换是一项对编程生产力有深远影响的技能。可以放心，当你提高快速操作数据的能力时，你的编程生产力将迅速提升。像本章中看到的小型处理任务，实际上会对常见的“千刀万剐”产生显著影响：频繁执行许多小任务对整体生产力的压迫性伤害。通过使用本章介绍的 Python 技巧、函数和特性，你已经有效地抵御了这些千刀万剐的伤害。用比喻来说，新获得的工具帮助你在每次受伤后更快恢复。

在下一章，你将通过深入学习 NumPy 库提供的一组工具来进一步提升你的数据科学技能，这些工具专为 Python 中的数值计算而设计。

**练习 2-1 的解答**

下面是如何使用列表推导式替代 `map()` 函数，达到相同的效果，即过滤掉包含字符串 `'anonymous'` 的所有行。在这种情况下，我甚至推荐使用更快、更简洁的列表推导式特性。

```py
mark = [(True, s) if 'anonymous' in s else (False, s) for s in txt]
```
