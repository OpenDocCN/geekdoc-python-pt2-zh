<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="part">
<span class="PartNumber"><span epub:type="pagebreak" title="167" id="Page_167"/>Part III</span><br/>
<span class="PartTitle">Interactive Games</span></h1>
</header>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="169" id="Page_169"/>9</span><br/>
<span class="ChapterTitle">Graphics and Animation with the <em>turtle</em> Module</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="200" height="200"/>
</figure>
<p class="ChapterIntro">Our goal in the next few chapters is to build voice-controlled graphical games such as tic-tac-toe, Connect Four, and guess-the-word. You’ll do all these with the <em>turtle</em> module.</p>
<p>In this chapter, you won’t be working with voice interactivity. Instead you’ll learn the <em>turtle</em> module’s basic commands that will let you set up a turtle screen, draw shapes, and create animations. This functionality will be the basis for all the games you’ll be building. </p>
<p>Before you begin, set up the folder <em>/mpt/ch09/</em> for this chapter. As always, all scripts in this chapter are available at the book’s resources page, <a href="https://www.nostarch.com/make-python-talk/" class="LinkURL">https://www.nostarch.com/make-python-talk/</a>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><span epub:type="pagebreak" title="170" id="Page_170"/>New Skills </h2>
<ul>
<li>Getting started with the <em>turtle</em> module</li>
<li>Learning movements such as forward/backward and right/left turns</li>
<li>Creating basic shapes such as dots, triangles, rectangles, and gridlines</li>
<li>Creating animation effects</li>
<li>Using multiple turtles</li>
</ul>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501560c09-0001">	Basic Commands </h2>
<p class="BodyFirst">The <em>turtle</em> module allows us to use a robotic turtle to draw shapes and create animations on a canvas. The turtle mimics the way people draw on a physical canvas, but we use commands to move the turtle and create the drawings.</p>
<p>For its underlying graphics, the <em>turtle</em> module uses the <em>tkinter</em> module, which is Python’s de facto standard graphical user interface (GUI) package. Both <em>turtle</em> and <em>tkinter</em> are in the Python standard library, so there’s no need to install them. </p>
<p>Turtle graphics were invented in the 1960s, three decades before the Python language. The <em>turtle</em> module allows Python programmers to take advantage of many features of turtle graphics. The first is their simplicity: <em>turtle</em> is easier to learn than other game modules such as <em>pygame</em> or <em>tkinter</em>. The <em>turtle</em> module is also intuitive, making it easy to create pictures and shapes by manipulating the drawing pen on a canvas (that is, the screen). </p>
<p>The <em>turtle</em> module is also better suited to voice activation. Unlike other game modules, which constantly run through a game loop too fast to capture voice commands, <em>turtle</em> scripts don’t need a game loop. This makes voice-controlled games possible.</p>
<h3 id="h2-501560c09-0001">Create a turtle Screen </h3>
<p class="BodyFirst">To use <em>turtle</em>, you need to create a turtle screen to contain all objects in the script. The following script shows you a simple example of the turtle screen. Enter the following lines of code in Spyder and save the script as <em>set_up_screen.py</em>:</p>
<pre><code>import turtle as t

<span class="CodeAnnotationHang" aria-label="annotation1">1</span> t.Screen()
t.setup(600,500,100,200)
t.bgcolor('SpringGreen3')
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> t.title('Setting Up a Screen with Turtle Graphics')
t.done()
t.bye() </code></pre>
<p><span epub:type="pagebreak" title="171" id="Page_171"/>We import the <em>turtle</em> module and give it a short alias name, <code>t</code>. This is one situation where a short alias module name is beneficial, since we’ll be calling multiple functions from the module, and often. Therefore, we want to use only <code>t.</code>, instead of <code>turtle.</code>, in front of all the functions.</p>
<p>At <span class="CodeAnnotation" aria-label="annotation1">1</span>, we create a screen by using <code>Screen()</code>, which doesn’t require arguments. We then use <code>setup()</code> to specify the size and location of the screen. The four parameters are screen width, screen height, horizontal distance from the top left of your computer screen, and vertical distance from the top left of your computer screen, in that order. Our screen will be 600 pixels wide and 500 pixels tall, 100 pixels from the left edge of the computer screen, and 200 pixels from the top edge. </p>
<p>Next, we give the turtle screen a background color by using <code>bgcolor()</code>. The <em>turtle</em> module provides a wide range of colors, including <code>brown</code>, <code>black</code>, <code>gray</code>, <code>white</code>, <code>yellow</code>, <code>gold</code>, <code>orange</code>, <code>red</code>, <code>purple</code>, <code>navy</code>, <code>blue</code>, <code>lightblue</code>, <code>darkblue</code>, <code>cyan</code>, <code>turquoise</code>, <code>lightgreen</code>, <code>green</code>, and <code>darkgreen</code>. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	For a more comprehensive list of colors in the <em>turtle</em> and <em>tkin</em><em>t</em><em>er</em> modules, see <a href="https://www.tcl.tk/man/tcl8.4/TkCmd/colors.htm" class="LinkURL">https://www.tcl.tk/man/tcl8.4/TkCmd/colors.htm</a>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>At <span class="CodeAnnotation" aria-label="annotation2">2</span>, we give a title to the screen, which you’ll see at the top beside the turtle graphics symbol (<a href="#figure9-1" id="figureanchor9-1">Figure 9-1</a>).</p>
<p>The <code>done()</code> command tells the script to start the event, which is how objects on the screen could be animated. The <code>bye()</code> command tells the script to exit <em>turtle</em> when you click the X symbol.</p>
<p>The screen should look something like <a href="#figure9-1">Figure 9-1</a>.</p>
<figure>
<img src="Images/f09001.png" alt="f09001" width="536" height="473"/>
<figcaption><p><a id="figure9-1">Figure 9-1</a>: Set up the size, background color, and title of the screen.</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="172" id="Page_172"/>A turtle screen uses a <em>Cartesian</em> coordinate system, with the center coordinate (x = 0, y = 0). The x-value increases from left to right, and the y-value increases from bottom to top, just like the two-dimensional plane you learned in high school mathematics. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	In <em>turtle</em>, the point (x = 0, y = 0) is at the center of the screen. This is different from most other graphical modules such as <em>pygame</em> or <em>tkin</em><em>t</em><em>er</em>, which have the point (x = 0, y = 0) at the top-left corner.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-501560c09-0002">Create Movements </h3>
<p class="BodyFirst">In earlier days, the turtle cursor was literally a picture of a turtle moving around on the screen. Now, instead of a literal turtle, you see a small arrowhead as the default cursor. The turtle has three attributes: location, direction, and a pen. You can adjust the color and width of the pen, and you can decide whether to put the pen down on the plane so the turtle’s path is marked when it moves or lift it up so the movement isn’t tracked.</p>
<p>Let’s see an actual drawing before looking at the various movements in the module. Enter the code shown in <a href="#listing9-1" id="listinganchor9-1">Listing 9-1</a> in a Spyder editor and save it as <em>show_turtle.py </em>in your chapter folder. </p>
<pre><code>import turtle as t

t.Screen()
t.setup(600,500,100,200)
t.bgcolor('SpringGreen')
t.title('Show Turtle')
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> t.shape('turtle')
t.forward(200)
t.right(90)
t.up()
t.forward(100)
t.done()
t.bye()</code></pre>
<p class="CodeListingCaption"><a id="listing9-1">Listing 9-1</a>: Showing the turtle in the <em>turtle</em> module </p>
<p>At <span class="CodeAnnotation" aria-label="annotation1">1</span>, we change the shape of the cursor back to the original turtle shape, as you can see in <a href="#figure9-2" id="figureanchor9-2">Figure 9-2</a>. If you run the script, you can see that the turtle starts at position (x = 0, y = 0) and faces right. It moves forward 200 pixels with the default down pen position, so this movement draws a line on the canvas. We turn the turtle right 90 degrees and lift up the pen before moving forward 100 pixels. This time, no line is drawn on the canvas since the drawing pen is not touching the canvas. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Try it yourself</h2>
<p class="BoxBodyFirst">Use the F9 key to run the code in <em>show_turtle.py </em>one line at a time. See the changes in cursor shape, pen position, and cursor movements on the screen.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<span epub:type="pagebreak" title="173" id="Page_173"/><figure>
<img src="Images/f09002.png" alt="f09002" width="549" height="487"/>
<figcaption><p><a id="figure9-2">Figure 9-2</a>: The turtle moves on the canvas to make a drawing. </p></figcaption>
</figure>
<p>Now we’ll discuss in detail some basic movements in the <em>turtle</em> module that are useful for our projects. </p>
<h4 id="h3-501560c09-0001">The forward() and backward() Functions</h4>
<p class="BodyFirst">The <code>forward()</code> function tells the turtle to move forward the specified number of pixels on the screen. The <code>backward()</code> function does the same backward. Enter the code shown in <a href="#listing9-2" id="listinganchor9-2">Listing 9-2</a> in a Spyder editor and save it as <em>forward_backward.py </em>in your chapter folder. </p>
<pre><code>import turtle as t

t.Screen()
t.setup(600,500,100,200)
t.bgcolor('blue')
t.title('Movements in Turtle Graphics')
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> t.forward(200)
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> t.backward(300)
t.done()
t.bye()</code></pre>
<p class="CodeListingCaption"><a id="listing9-2">Listing 9-2</a>: Basic movement functions in the <em>turtle</em> module </p>
<p>We set up the screen with a different background color and a title. At <span class="CodeAnnotation" aria-label="annotation1">1</span>, the turtle moves forward 200 pixels. The default starting position of the turtle is at (x = 0, y = 0), facing to the right, so moving forward 200 pixels leads the turtle to the point (x = 200, y = 0).</p>
<p><span epub:type="pagebreak" title="174" id="Page_174"/>At <span class="CodeAnnotation" aria-label="annotation2">2</span>, the turtle moves from the point (x = 200, y = 0) backward 300 pixels, ending up at (x = –100, y = 0).</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Turtle Adjustments in Spyder</h2>
<p class="BoxBodyFirst">When you run <em>turtle</em> scripts in Spyder, the turtle scripts crash with a <code>Terminator</code> error after multiple runs in the same IPython console instance. This is a known problem for <em>turtle</em> scripts in Spyder. To avoid the crash and the error message, we’ll use <code>try</code> and <code>except</code> for the remainder of the book, starting in the script <em>l</em><em>eft</em><em>_r</em><em>ight.py</em>. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-501560c09-0002">The left() and right() Functions</h4>
<p class="BodyFirst">The <code>left()</code> or <code>right()</code> function changes the direction the turtle is facing. As the argument, we give the degree of the angle to move by. For example, <code>90</code> degrees turns the turtle perpendicular to the original direction. A degree value of <code>360</code> turns the turtle in a full circle so it’s still going in the original direction.</p>
<p>The script <em>left_right.py</em> in <a href="#listing9-3" id="listinganchor9-3">Listing 9-3</a> shows how the <code>left()</code> and <code>right()</code> functions work. </p>
<pre><code>import turtle as t

t.Screen()
t.setup(600,500,100,200)
t.bgcolor('light blue')
t.title('Python Turtle Graphics')
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> t.pensize(5)
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> t.right(30)
t.forward(200)
t.left(30)
t.backward(400)
t.left(90)
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> t.pencolor('red')
t.forward(200)
t.done()
try:
    t.bye()
except Terminator:
    print('exit turtle')</code></pre>
<p class="CodeListingCaption"><a id="listing9-3">Listing 9-3</a>: Python code for <em>left_right.py</em></p>
<p>The <code>pensize()</code> function specifies the thickness of the line the turtle is drawing <span class="CodeAnnotation" aria-label="annotation1">1</span>. The default value is 1 pixel. Here we set the pen size to 5 pixels. At <span class="CodeAnnotation" aria-label="annotation2">2</span>, we tell the turtle to turn right 30 degrees. Then, we move the turtle forward 200 pixels. We then turn the turtle left 30 degrees and move backward 400 pixels.</p>
<p><span epub:type="pagebreak" title="175" id="Page_175"/>The <code>pencolor()</code> function changes the color of the drawing pen to red <span class="CodeAnnotation" aria-label="annotation3">3</span>. The default is black. After this step, the lines will be red instead of black.</p>
<p>Run the script and you should see a screen similar to <a href="#figure9-3" id="figureanchor9-3">Figure 9-3</a>.</p>
<figure>
<img src="Images/f09003.png" alt="f09003" width="456" height="404"/>
<figcaption><p><a id="figure9-3">Figure 9-3</a>: The <span class="LiteralInCaption"><code>left()</code></span> and <span class="LiteralInCaption"><code>right()</code></span> functions in the <em>turtle</em> module</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Try it Out</h2>
<p class="BoxBodyFirst">Run <em>left_right.py</em> and then add more activity: change the pen color to green, make a 90-degree right turn, and move forward 250 pixels.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-501560c09-0003">The goto() Function</h4>
<p class="BodyFirst">The <code>goto()</code> function tells the turtle to go to the specified point on the screen. Together with <code>up()</code> and <code>down()</code>, it can create straight lines and dashed lines. The <code>up()</code> function means the turtle pen is not touching the canvas and so doesn’t draw as it moves. The <code>down()</code> function puts the pen on the canvas and creates drawings.</p>
<p>If the turtle pen is in the down position, <code>goto()</code> will create a straight line between the current position and the specified position. However, if the turtle pen is in the up position, <code>goto()</code> will create nothing on the screen, but merely moving the turtle from the current position to the specified position. Dashed lines can be created by drawing a sequence of short lines with spaces in between.</p>
<p>Enter the script <em>create_lines.py</em> in <a href="#listing9-4" id="listinganchor9-4">Listing 9-4</a>.</p>
<pre><code>import turtle as t

t.Screen()
t.setup(600,500,100,200)
<span epub:type="pagebreak" title="176" id="Page_176"/>t.bgcolor('lightgreen')
t.title('Python Turtle Graphics')
t.pensize(6)
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> t.goto(200,100)
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> t.up()
t.pencolor('blue')
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> for i in range(8):
    t.goto(-200+50*i,-150)
    t.down()
    t.goto(-200+50*i+30,-150)
    t.up()
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> t.hideturtle()
t.done()
try:
    t.bye()
except t.Terminator:
    print('exit turtle')</code></pre>
<p class="CodeListingCaption"><a id="listing9-4">Listing 9-4</a>: Python code for <em>create_lines</em><em>.py</em> </p>
<p>At <span class="CodeAnnotation" aria-label="annotation1">1</span>, we tell the turtle to go to (x = 200, y = 100). By default, the turtle is in the down position and the starting position is (x = 0, y = 0), so <code>goto(200,100)</code> draws a line between the two points (0, 0) and (200, 100), as you can see in <a href="#figure9-4" id="figureanchor9-4">Figure 9-4</a>.</p>
<p>At <span class="CodeAnnotation" aria-label="annotation2">2</span>, the script tells the turtle to lift up the pen so that no line is drawn on the screen when the turtle goes to another point. We then change the pen color to blue. At <span class="CodeAnnotation" aria-label="annotation3">3</span>, we start a <code>for</code> loop. In each iteration, the turtle goes to a point, puts down the pen, and goes to another point 30 pixels to the right. This leaves a 30-pixel-long dash, done eight times with gaps between. </p>
<p>The <code>hideturtle()</code> function hides the turtle so that the black arrow cursor is not shown on the screen <span class="CodeAnnotation" aria-label="annotation4">4</span>.</p>
<p>Run the script and you should see a screen similar to <a href="#figure9-4">Figure 9-4</a>.</p>
<figure>
<img src="Images/f09004.png" alt="f09004" width="460" height="406"/>
<figcaption><p><a id="figure9-4">Figure 9-4</a>: Use the <span class="LiteralInCaption"><code>goto()</code></span> function to create lines using the <em>turtle</em> module.</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><span epub:type="pagebreak" title="177" id="Page_177"/>Try It Out</h2>
<p class="BoxBodyFirst">Run <em>create_lines</em><em>.py</em> and then add another eight-dash line 100 pixels above the existing eight-dash line.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501560c09-0002">	Basic Shapes </h2>
<p class="BodyFirst">The <em>turtle</em> module has several built-in shapes, including the commonly used <code>dot()</code> function that creates a dot. You’ll also learn how to create basic shapes such as a triangle, a square, and gridlines.</p>
<h3 id="h2-501560c09-0003">Use the dot() Function</h3>
<p class="BodyFirst">The <code>dot()</code> function creates a dot with the specified diameter and color. For example, the command <code>dot(30,'red')</code> creates a red dot with a diameter of 30 pixels. We’ll use this in our tic-tac-toe and Connect Four games to create game pieces. </p>
<p><a href="#listing9-5" id="listinganchor9-5">Listing 9-5</a>, <em>dots.py</em>, shows how the <code>dot()</code> function works. </p>
<pre><code>import turtle as t

t.Screen()
t.setup(600,500,100,200)
t.bgcolor('lightgreen')
t.title('Python Turtle Graphics')
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> t.up()
t.goto(150,100)
t.dot(120,'red')
t.goto(-150,100)
t.dot(135,'yellow')
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> t.goto(150,-100)
t.dot(125,'blue')
t.goto(-150,-100)
t.dot(140,'green')
t.hideturtle()
t.done()
try:
    t.bye()
except t.Terminator:
    print('exit turtle')</code></pre>
<p class="CodeListingCaption"><a id="listing9-5">Listing 9-5</a>: Python code for <em>dots.py</em> </p>
<p>First we lift up the pen <span class="CodeAnnotation" aria-label="annotation1">1</span>. Then we go to the point (150, 100). We tell the turtle to put a red dot centered on the point (150, 100) and with a diameter of 120 pixels.</p>
<p><span epub:type="pagebreak" title="178" id="Page_178"/>Next, we move the turtle to (–150, 100) and draw a yellow dot with a diameter of 135 pixels. Note that you don’t need to use <code>up()</code> again since the pen is already lifted up. With the pen up, the turtle can still draw dots.</p>
<p>Starting from <span class="CodeAnnotation" aria-label="annotation2">2</span>, the turtle goes to (150, –100) and draws a blue dot with a diameter of 125 pixels. Then it goes to (–150, –100) and draws a green dot with a diameter of 140 pixels. <a href="#figure9-5" id="figureanchor9-5">Figure 9-5</a> shows the outcome.</p>
<figure>
<img src="Images/f09005.png" alt="f09005" width="455" height="402"/>
<figcaption><p><a id="figure9-5">Figure 9-5</a>: Create dots using the <em>turtle</em> module.</p></figcaption>
</figure>
<h3 id="h2-501560c09-0004">Draw Your Own Shapes </h3>
<p class="BodyFirst">You can also draw your own shapes using the <em>turtle</em> module. We’ll look at some basic shapes here.</p>
<h4 id="h3-501560c09-0004">Triangles</h4>
<p class="BodyFirst">The easiest way to create a triangle is by using <code>goto()</code>. <a href="#listing9-6" id="listinganchor9-6">Listing 9-6</a>, <em>triangle.py</em>, draws a triangle with the corners at (–50, –50), (50, –50), and (0, 100). </p>
<pre><code>from turtle import *

Screen()
setup(600,500,100,200)
bgcolor('springgreen3')
title('Python Turtle Graphics')
hideturtle()
tracer(False)
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> pencolor('blue')
pensize(5)
up()
goto(-50,-50)
down()
<span epub:type="pagebreak" title="179" id="Page_179"/>goto(50,-50)
goto(0,100)
goto(-50,-50)
update()
done()
try:
    bye()
except Terminator:
    pass</code></pre>
<p class="CodeListingCaption"><a id="listing9-6">Listing 9-6</a>: Python code for <em>t</em><em>riangle.py</em> </p>
<p>The <code>tracer()</code> function tells the script whether to trace the movements of the turtle. The default value is <code>tracer(True)</code>, which means the script shows you the movement of the turtle step-by-step. When the turtle pen draws something, you’ll see the drawing, one stroke after another. Here, we use <code>tracer(False)</code>, so the final drawing is printed, but the script doesn’t show the intermediate steps.</p>
<p>We change the pen’s color to blue <span class="CodeAnnotation" aria-label="annotation1">1</span> and its size to 5. We lift up the pen and go to point (–50, –50) then put down the pen and go to point (50, –50). This forms the first leg of the triangle. With the pen down, we ask the turtle to go to point (0, 100), which forms the second leg. The base is drawn when we send the pen back to point (–50, –50) to complete the triangle.</p>
<p>Note that since we’ve used the command <code>tracer(False)</code> to not display each drawing step (thus saving time), we need to put <code>update()</code> at the end of the script to show the completed picture, as shown in <a href="#figure9-6" id="figureanchor9-6">Figure 9-6</a>.</p>
<figure>
<img src="Images/f09006.png" alt="f09006" width="517" height="460"/>
<figcaption><p><a id="figure9-6">Figure 9-6</a>: Draw a triangle using the <em>turtle</em> module.</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><span epub:type="pagebreak" title="180" id="Page_180"/>Try it Out</h2>
<p class="BoxBodyFirst">Run <em>t</em><em>riangle.py</em> and add another triangle with the following three points as corners: (–100, –100), (100, 100), and (0, 150).</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-501560c09-0005">Rectangles</h4>
<p class="BodyFirst">We can draw rectangles by using <code>goto()</code>, as we did for triangles, but we can also use <code>forward()</code> and <code>left()</code>. In many situations, you can achieve the same goal by using either the <code>goto()</code> function or the <code>forward()</code> and <code>left()</code> functions. If you know the coordinates of the destination, <code>goto()</code> is easier, and if you know the distances between two points, the directional functions are easier. </p>
<p>Here, we’ll use <code>forward()</code> and <code>left()</code>. You’ll achieve the same results by using <code>goto()</code> in the <span class="xref" itemid="xref_target_“End-of-Chapter Exercises” on page 187">“End-of-Chapter Exercises” on page 187</span>. </p>
<p>We’ll draw a rectangle with the points (0, 0), (200, 0), (200, 100), and (0, 100). Enter the script <em>rectangle.py</em> shown in <a href="#listing9-7" id="listinganchor9-7">Listing 9-7</a>.</p>
<pre><code>import turtle as t

# Set up the screen
t.Screen()
t.setup(600,500,100,200)
t.bgcolor('green')
t.title('Python Turtle Graphics')
t.hideturtle()
t.tracer(False)
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> t.pensize(6)
# Draw the first side
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> t.forward(200)
t.left(90)
# Draw the second side
t.forward(100)
t.left(90)
# Draw the third side
t.forward(200)
t.left(90)
# Finish the rectangle
t.forward(100)
t.update()
t.done()
try:
    t.bye()
except t.Terminator:
    print('exit turtle')</code></pre>
<p class="CodeListingCaption"><a id="listing9-7">Listing 9-7</a>: Python code for <em>r</em><em>ectangle.py</em> </p>
<p><span epub:type="pagebreak" title="181" id="Page_181"/>We first set up the screen. At <span class="CodeAnnotation" aria-label="annotation1">1</span>, we set the pen size to 6. We don’t specify the pen color, so the default color of black will be used. At <span class="CodeAnnotation" aria-label="annotation2">2</span>, the turtle moves forward 200 pixels from the initial position of (0, 0) to form the first side of the rectangle.</p>
<p>Next, the turtle turns left 90 degrees so that it faces up. Then it moves forward 100 pixels to form the second side. We then make the turtle turn left 90 degrees so that it faces west, and move it forward 200 pixels for the third side. The last side of the rectangle is formed similarly.</p>
<p>The output is shown in <a href="#figure9-7" id="figureanchor9-7">Figure 9-7</a>.</p>
<figure>
<img src="Images/f09007.png" alt="f09007" width="536" height="471"/>
<figcaption><p><a id="figure9-7">Figure 9-7</a>: Draw a rectangle using the <em>turtle</em> module.</p></figcaption>
</figure>
<p>We’ll use this rectangle-drawing skill to create a board for our upcoming games.</p>
<h3 id="h2-501560c09-0005">Draw Grid Lines</h3>
<p class="BodyFirst">Games such as tic-tac-toe and Connect Four use a grid. We can make a grid simply by drawing squares. Here we’ll draw a game board with six rows and seven columns; the horizontal lines will be thinner and lighter than the vertical ones to match what we’ll do in the Connect Four game. Enter the code from <em>grid_lines.py</em> in <a href="#listing9-8" id="listinganchor9-8">Listing 9-8</a>.</p>
<pre><code>import turtle as t

# Set up the screen
t.Screen()
<span epub:type="pagebreak" title="182" id="Page_182"/>t.setup(810,710, 10, 70)
t.hideturtle()
t.tracer(False)
t.bgcolor('lightgreen')
# Draw the vertical lines to create 7 columns
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> t.pensize(5)
for i in range(-350,400,100):
    t.up()
    t.goto(i, -298)
    t.down()
    t.goto(i, 303)
    t.up()
# Draw the horizontal lines to separate the screen in 6 rows
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> t.pensize(1)
t.color('gray')
for i in range(-300,400,101):  
    t.up()
    t.goto(-350,i)
    t.down()
    t.goto(350,i)
    t.up()   
t.done()
try:
    t.bye()
except t.Terminator:
    print('exit turtle')</code></pre>
<p class="CodeListingCaption"><a id="listing9-8">Listing 9-8</a>: Python code for <em>g</em><em>rid</em><em>_l</em><em>ines.py</em> </p>
<p>We first set up the screen. Since we plan to draw a game board with six rows and seven columns, we set the screen size to 810 pixels wide and 710 pixels tall. This way, we can make each cell a square that’s 100 by 100 pixels, with a 55-pixel margin around the board. It’s important to think about your screen size so you can calculate the coordinates of various points.</p>
<p>We draw eight thick vertical lines with a pen size of 5 <span class="CodeAnnotation" aria-label="annotation1">1</span> to divide the screen into seven columns. The function <code>range(-350,400,100)</code> produces eight values: <code>-350, -250, ..., 350</code>. </p>
<p>After that, we draw seven thin, gray, horizontal lines to form six rows <span class="CodeAnnotation" aria-label="annotation2">2</span>. If you run the script, you’ll see a screen similar to <a href="#figure9-8" id="figureanchor9-8">Figure 9-8</a>. </p>
<p>We’ll use this board in <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span> for our games.</p>
<h2 id="h1-501560c09-0003">	Animation </h2>
<p class="BodyFirst">In this section, you’ll learn to create animation by using <code>clear()</code> and <code>update()</code> to clear the current image and replace it with the next, producing animation frames. </p>
<span epub:type="pagebreak" title="183" id="Page_183"/><figure>
<img src="Images/f09008.png" alt="f09008" width="567" height="517"/>
<figcaption><p><a id="figure9-8">Figure 9-8</a>: Draw grid lines to form a six-by-seven game board</p></figcaption>
</figure>
<h3 id="h2-501560c09-0006">How Animation Works</h3>
<p class="BodyFirst">The <code>clear()</code> function erases everything the turtle has drawn on the screen. You can then redraw objects and use <code>update()</code> to put them onscreen. If you do this repeatedly, the rapid replacement of images will create an animation effect. </p>
<p>We’ll explore animation by making a simple clock, shown in <em>turtle_clock.py</em> in <a href="#listing9-9" id="listinganchor9-9">Listing 9-9</a>.</p>
<pre><code>import turtle as t
import time

import arrow

# Set up the screen
t.setup(800,600, 10, 70)
t.tracer(False)
t.bgcolor('lightgreen')
t.hideturtle()
# Put the script in an infinite loop
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> while True:
    # Clear the screen
    t.clear()
    # Obtain the current time
    current_time = arrow.now().format('hh:mm:ss A')
<span epub:type="pagebreak" title="184" id="Page_184"/>    t.color('blue')
    t.up()
    t.goto(-300,50)
    # Write the first line of text
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> t.write('The Current Time Is\n',font=('Arial',50,'normal'))
    t.color('red')
    t.goto(-300,-100)
    # Write what time it is
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> t.write(current_time,font=('Arial',80,'normal'))
    time.sleep(1)
    # Put everything on screen
    t.update()
t.done()
try:
    t.bye()
except t.Terminator:
    print('exit turtle')</code></pre>
<p class="CodeListingCaption"><a id="listing9-9">Listing 9-9</a>: Python code for <em>turtle_clock</em><em>.py</em> </p>
<p>We import the modules and set up the screen. At <span class="CodeAnnotation" aria-label="annotation1">1</span>, we start an infinite loop. In each iteration, the script first erases everything onscreen by using <code>clear()</code>. We then obtain the current time by using the <em>arrow</em> module and store the value in the variable <code>current_time</code>. </p>
<p>The <code>write()</code> function from the <em>turtle</em> module writes text onscreen. It takes the text to be displayed as the first argument and the font to use as the second argument. At <span class="CodeAnnotation" aria-label="annotation2">2</span>, we write <code>The Current Time Is</code> to the screen in blue. At <span class="CodeAnnotation" aria-label="annotation3">3</span>, the script writes the current time in red. </p>
<p>The script then pauses for one second and makes sure that all the new drawings are updated by using <code>update()</code>. If you run the script, you’ll notice that the time changes every second (<a href="#figure9-9" id="figureanchor9-9">Figure 9-9</a>).</p>
<figure>
<img src="Images/f09009.png" alt="f09009" width="555" height="441"/>
<figcaption><p><a id="figure9-9">Figure 9-9</a>: Create animation in the <em>turtle</em> module.</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="185" id="Page_185"/>We’ll use this method frequently to create animations in various games. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Try it Out</h2>
<p class="BoxBodyFirst">Run <em>turtle_clock</em><em>.py</em>. Then modify the script to replace <code>The Current Time Is</code> with the current date obtained from the <em>arrow</em> module in the format of January 01, 2021.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-501560c09-0007">Use Multiple Turtles </h3>
<p class="BodyFirst">Now we’ll look at using two turtles simultaneously—the equivalent of using two pens. In <span class="xref" itemid="xref_target_Chapter 12">Chapter 12</span>, when we create a guess-the-word game, we’ll use one turtle to create a gold coin on the game board and another to count the number of chances the player has left. Whenever the player misses a letter, we’ll erase the previous number and change it to the new number. If we used only one turtle, everything, including the coin image, would be wiped. If we use a second turtle, we can keep everything else onscreen and change only whatever the second turtle draws.</p>
<p>In <a href="#listing9-10" id="listinganchor9-10">Listing 9-10</a>, <em>two_turtles.py</em>, we’ll use one turtle to draw a square and another to write something below it. </p>
<pre><code>import turtle as t

# Set up the screen
t.setup(810,710, 10, 70)
t.tracer(False)
t.hideturtle()
t.bgcolor('lightgreen')
t.color('blue')
t.pensize(5)
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> t.up()
t.goto(-200,-100)
t.down()
t.forward(400)
t.left(90)
t.forward(400)
t.left(90)
t.forward(400)
t.left(90)
t.forward(400)
# Create a second turtle 
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> msg = t.Turtle()
msg.hideturtle()
msg.up()
msg.color('red')
msg.goto(-300,-200)
msg.write('this is written by the second turtle',font=('Arial',30,'normal'))
t.update()
t.done()
<span epub:type="pagebreak" title="186" id="Page_186"/>try:
    t.bye()
except t.Terminator:
    print('exit turtle')</code></pre>
<p class="CodeListingCaption"><a id="listing9-10">Listing 9-10</a>: Python code for <em>two_turtles</em><em>.py</em> </p>
<p>We import the <em>turtle</em> module and set up a screen with a size of 810 by 710 pixels. Starting at <span class="CodeAnnotation" aria-label="annotation1">1</span>, we draw a blue square in the middle of the screen, similar to the way we drew a rectangle but with all sides the same length.</p>
<p>At <span class="CodeAnnotation" aria-label="annotation2">2</span>, we create a second turtle with <code>Turtle()</code> and name it <code>msg</code>. We tell the script to hide the second turtle </p>
<p>The second turtle <code>msg</code> lifts up the pen, changes the color to red, goes to (–300, –200), and writes the message <code>this is written by the second turtle</code>. The <code>update()</code> function refreshes the screen to draw everything created by the two turtles, shown in <a href="#figure9-10" id="figureanchor9-10">Figure 9-10</a>.</p>
<figure>
<img src="Images/f09010.png" alt="f09010" width="540" height="494"/>
<figcaption><p><a id="figure9-10">Figure 9-10</a>: A screen created with two turtles</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Try it Out</h2>
<p class="BoxBodyFirst">Run <em>two_turtles</em><em>.py</em> and then modify it to add a third turtle. Use the new turtle to write a message at the bottom of the screen. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501560c09-0004"><span epub:type="pagebreak" title="187" id="Page_187"/>	Summary</h2>
<p class="BodyFirst">In this chapter, you learned the basics of the <em>turtle</em> module. You first learned how to set up a turtle screen and then learned basic movements like going forward or backward and turning left or right. You created various shapes by using both the built-in function and basic movement commands.</p>
<p>Finally, you learned to create animation effects in the <em>turtle</em> module by using the <code>clear()</code> and <code>update()</code> functions. In the next few chapters, you’ll learn how to use these skills to create voice-controlled graphical games.</p>
<h2 id="h1-501560c09-0005">	End-of-Chapter Exercises</h2>
<ol class="decimal">
<li value="1">Modify <em>set_up_screen.py</em> so that the screen size is 500 pixels wide and 400 pixels tall, the background color is blue, and the title is <code>Modified Screen</code>. </li>
<li value="2">Modify <em>forward_backward.py </em>so that the turtle first moves backward 100 pixels and then moves forward 250 pixels.</li>
<li value="3">Modify <em>dots.py</em> to have only two light green dots with diameters of 60 at points (–100, –100) and (100, 100).</li>
<li value="4">Modify <em>triangle.py</em> so that the three sides of the triangle are red with a thickness of 3. </li>
<li value="5">Replicate the result in <em>rectangle.py</em> by using <code>goto()</code>. You aren’t allowed to use the functions <code>forward()</code>, <code>backward()</code>, <code>left()</code>, or<code> right()</code>.</li>
</ol>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="189" id="Page_189"/>10</span><br/>
<span class="ChapterTitle">Tic-Tac-Toe </span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="200" height="200"/>
</figure>
<p class="ChapterIntro">In this chapter, you’ll build a voice-controlled tic-tac-toe game to put all your new skills into practice. You’ll draw a game board with blue and white game pieces, disallow invalid moves, and detect if a player has won. You’ll then add the speech recognition and text-to-speech functionality and set the game so you play with your own computer. </p>
<p>As usual, all scripts in this chapter are available at the book’s resources page at <a href="https://www.nostarch.com/make-python-talk/" class="LinkURL">https://www.nostarch.com/make-python-talk/</a>. Before you begin, set up the folder <em>/mpt/ch10/</em> for this chapter.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><span epub:type="pagebreak" title="190" id="Page_190"/>new skills </h2>
<ul>
<li>Using mouse clicks in the <em>turtle</em> module </li>
<li>Converting coordinates to cell numbers on game boards</li>
<li>Coding game rules</li>
<li>Using <em>tkinter</em> to display pop-up message boxes </li>
<li>Voice-controlling games</li>
</ul>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501560c10-0001">	Game Rules </h2>
<p class="BodyFirst">Tic-tac-toe is probably one of the most well-known games in the world, but just to be sure, I’ll go over the rules before we create our game board. In tic-tac-toe, two players take turns marking a cell with an X or O in a three-by-three grid. The first player to connect three Xs or Os in a row horizontally, vertically, or diagonally wins. If no one connects three before all the cells are full, the game is tied. Instead of X and O, we’ll use blue and white dots as game pieces. </p>
<h2 id="h1-501560c10-0002">	Draw the Game Board </h2>
<p class="BodyFirst">We’ll draw a three-by-three grid on the screen and assign a number to each cell so we can tell the script where to place each game piece. Open your Spyder editor, copy the code in <a href="#listing10-1" id="listinganchor10-1">Listing 10-1</a>, and save the script as <em>ttt_board.py</em> in your chapter folder.</p>
<pre><code>import turtle as t

# Set up the screen
t.setup(600,600,10,70)
t.tracer(False)
t.bgcolor("red")
t.hideturtle()
t.title("Tic-Tac-Toe in Turtle Graphics")
# Draw horizontal lines and vertical lines to form grid
t.pensize(5)
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> for i in (-100,100):
    t.up()
    t.goto(i,-300)
    t.down()
    t.goto(i,300)
    t.up()
    t.goto(-300,i)
    t.down()
<span epub:type="pagebreak" title="191" id="Page_191"/>    t.goto(300,i)
    t.up()
# Create a dictionary to map cell numbers to cell center coordinates
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> cellcenter = {'1':(-200,-200), '2':(0,-200), '3':(200,-200),
            '4':(-200,0), '5':(0,0), '6':(200,0),
            '7':(-200,200), '8':(0,200), '9':(200,200)} 
# Go to the center of each cell, write down the cell number
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> for cell, center in list(cellcenter.items()):
    t.goto(center)
    t.write(cell,font = ('Arial',20,'normal'))
t.done()
try:
    t.bye()
except t.Terminator:
    print('exit turtle')</code></pre>
<p class="CodeListingCaption"><a id="listing10-1">Listing 10-1</a>: Drawing the tic-tac-toe game board</p>
<p>We import all functions in the <em>turtle</em> module and set the screen to 600 by 600 pixels. Because we have a three-by-three grid, each cell is 200 by 200 pixels. We set the background color to red and set the title as <code>Tic-Tac-Toe in Turtle Graphics</code>.</p>
<p>With the command <code>for i in (-100, 100)</code>, we iterate the variable <code>i</code> through the range –100 to 100 <span class="CodeAnnotation" aria-label="annotation1">1</span>. As a result, the <code>for</code> loop produces two horizontal lines and two vertical lines. The two horizontal lines are between points (–300, –100) and (300, –100) and points (–300, 100) and (300, 100). The two vertical lines are between points (–100, –300) and (–100, 300) and points (100, –300) and (100, 300). These lines evenly divide the screen into nine cells.</p>
<p>We then create a dictionary <code>cellcenter</code> to map each cell number to the x- and y-coordinates of the center of the corresponding cell <span class="CodeAnnotation" aria-label="annotation2">2</span>. For example, the lower-left cell is cell number 1, and the coordinates of its center are (x = –200, y = –200). We do this for all nine cells in the dictionary, using the cell number as the key and the coordinates as the value. </p>
<p>At <span class="CodeAnnotation" aria-label="annotation3">3</span>, we use the <code>for</code> loop to iterate through nine pairs of values to write the cell number at the cell’s center. The command <code>list(cellcenter.items())</code> produces a list of the nine key-and-value pairs from <code>cellcenter</code>, which should look like this:</p>
<pre><code>[('1', (-200, -200)), ('2', (0, -200)), ('3', (200, -200)), ('4', (-200, 0)),
('5', (0, 0)), ('6', (200, 0)), ('7', (-200, 200)), ('8', (0, 200)), ('9', 
(200, 200))]</code></pre>
<p>At each iteration of the <code>for</code> loop, the turtle goes to the center of the cell and writes the cell number there. Run the script and you should see a screen similar to <a href="#figure10-1" id="figureanchor10-1">Figure 10-1</a>.</p>
<span epub:type="pagebreak" title="192" id="Page_192"/><figure>
<img src="Images/f10001.png" alt="f10001" width="568" height="592"/>
<figcaption><p><a id="figure10-1">Figure 10-1</a>: The board for tic-tac-toe </p></figcaption>
</figure>
<h2 id="h1-501560c10-0003">	Create the Game Pieces</h2>
<p class="BodyFirst">Now we’ll add code to place game pieces in the cells. You’ll first learn how mouse clicks work in the <em>turtle</em> module and then use them to place the pieces.</p>
<h3 id="h2-501560c10-0001">How Mouse Clicks Work in turtle </h3>
<p class="BodyFirst">When you left-click on the turtle screen, the x- and y-coordinates of the point you clicked are displayed onscreen. <a href="#listing10-2" id="listinganchor10-2">Listing 10-2</a>, <em>mouse_click.py</em>, handles a simple mouse click. This is just for example purposes; we won’t use this code in the final script but will use the same principles.</p>
<pre><code>import turtle as t

# Set up the screen
t.setup(620,620,360,100)
t.title("How Mouse-Clicks Work in Turtle Graphics")
# Define get_xy() to print the coordinates of the point you click
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> def get_xy(x,y):
    print(f'(x, y) is ({x}, {y})')
# Hide the turtle so that you don't see the arrowhead
t.hideturtle()
# Bind the mouse click to the get_xy() function
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> t.onscreenclick(get_xy)
<span epub:type="pagebreak" title="193" id="Page_193"/><span class="CodeAnnotationHang" aria-label="annotation3">3</span> t.listen()    
t.done()
try:
    t.bye()
except t.Terminator:
    print('exit turtle')<span class="CodeAnnotationCode" aria-label="annotation "> </span></code></pre>
<p class="CodeListingCaption"><a id="listing10-2">Listing 10-2</a>: How mouse clicks work in the <em>turtle</em> module</p>
<p>As usual, we import the <em>turtle</em> module and set up the screen. At <span class="CodeAnnotation" aria-label="annotation1">1</span>, we define the function <code>get_xy()</code>, which prints out the x- and y-coordinates of your click. We also hide the turtle so you don’t see the cursor moving around the screen. At <span class="CodeAnnotation" aria-label="annotation2">2</span>, we bind the onscreen mouse click to the <code>get_xy()</code> function by using the <em>turtle</em> function <code>onscreenclick()</code>, which returns the x- and y-coordinates of the click. As a result, <code>onscreenclick(get_xy)</code> supplies the x- and y-coordinates of your mouse click to <code>get_xy()</code> as its two inputs. At <span class="CodeAnnotation" aria-label="annotation3">3</span>, we use <code>listen()</code> to detect events like mouse clicks and keyboard presses. </p>
<p>Run <em>mouse_click.py</em>, randomly click the screen several times, and you should see something like this:</p>
<pre><code>(x, y) is (-46.0, 109.0)
(x, y) is (14.0, -9.0)
(x, y) is (-185.0, -19.0)
(x, y) is (-95.0, 109.0)
(x, y) is (13.0, -81.0)</code></pre>
<p>For each of my five clicks, <code>onscreenclick()</code> captured the x- and y-coordinates of the point and provided the two values to <code>get_xy()</code>, which printed out the corresponding x- and y-values. </p>
<h3 id="h2-501560c10-0002">Convert Mouse Clicks to Cell Numbers</h3>
<p class="BodyFirst">Next, we’ll combine the board creation and click detection scripts so that when you click a cell, the script prints out the cell number. In <a href="#figure10-2" id="figureanchor10-2">Figure 10-2</a>, I’ve marked the row and column numbers on the game board along with the x- and y-coordinates of the gridlines. </p>
<p>Open <em>ttt_board.py</em>, add the code in <a href="#listing10-3" id="listinganchor10-3">Listing 10-3</a> at the bottom (above <code>t.done()</code>) and save the new script as <em>cell_number.py</em> in your chapter folder. This script is just an example; we won’t use it in the final code but will use something similar.</p>
<pre><code><var>--snip--</var>
for cell, center in list(cellcenter.items()):
    t.goto(center)
    t.write(cell,font = ('Arial',20,'normal'))
# Define a function cell_number() to print out the cell number
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> def cell_number(x,y):
    if -300&lt;x&lt;300 and -300&lt;y&lt;300:
        # Calculate the column number based on x value
      <span class="CodeAnnotationCode" aria-label="annotation2">2</span> col = int((x+500)//200)
        print('column number is ', col)
        # Calculate the row number based on y value
<span epub:type="pagebreak" title="194" id="Page_194"/>        row = int((y+500)//200)
        print('row number is ', row)
        # Calculate the cell number based on col and row
      <span class="CodeAnnotationCode" aria-label="annotation3">3</span> cellnumber = col+(row-1)*3
        print('cell number is ', cellnumber)
    else:
        print('you have clicked outside the game board')
# Hide turtle so that you don't see the arrowhead
t.hideturtle()
# bind the mouse click to the cell_number() function
  onscreenclick(cell_number)
t.listen()
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing10-3">Listing 10-3</a>: Converting mouse clicks to cell numbers</p>
<figure>
<img src="Images/f10002.png" alt="f10002" width="564" height="520"/>
<figcaption><p><a id="figure10-2">Figure 10-2</a>: Mark the row and column numbers on the game board.</p></figcaption>
</figure>
<p>At <span class="CodeAnnotation" aria-label="annotation1">1</span>, we define <code>cell_number()</code>, which will convert the x- and y-coordinates of the mouse click to the cell number. Inside the function, we restrict the x- and y-coordinates of the point you click to the range of the board. If you click outside the range, the script will print <code>you have clicked outside the game board</code>.</p>
<p>At <span class="CodeAnnotation" aria-label="annotation2">2</span>, we convert the x-coordinate of the click to the column number. Points in column 1 have x-coordinates between –300 and –100, and points in column 2 have x-coordinates between –100 and 100, so we use the formula <code><span epub:type="pagebreak" title="195" id="Page_195"/>col = int((x+500)//200)</code> to get the full range of pixel coordinates in the column so we can convert the x-coordinate to the column number. We use the same method to convert the y-coordinate to the row number.</p>
<p>We then calculate the cell number by using the formula <code>cellnumber = col+(row-1)*3</code> because the cell numbers increase from left to right and then from bottom to top <span class="CodeAnnotation" aria-label="annotation3">3</span>. Finally, we bind the onscreen click to <code>cell_number()</code>. </p>
<p>Run <em>cell_number.py</em>. Here’s the output from one exchange with the script:</p>
<pre><code>column number is  3
row number is  2
cell number is  6
column number is  1
row number is  3
cell number is  7
column number is  2
row number is  1
cell number is  2</code></pre>
<p>Each time you click a cell, the script prints out the column number, row number, and cell number.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Try it Out</h2>
<p class="BoxBodyFirst">Run <em>c</em><em>ell_number.py</em> and click each cell to make sure the numbers match those in <a href="#figure10-2">Figure 10-2</a>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-501560c10-0003">Place Game Pieces</h3>
<p class="BodyFirst">Next, we’ll place the game pieces on the board. When you first click any of the nine cells, a blue piece will appear at the center of the cell. When you click again, the piece will be white, then blue, and so on. </p>
<p>Open <em>ttt_board.py</em>, add the code in <a href="#listing10-4" id="listinganchor10-4">Listing 10-4</a>, and save the new script as <em>mark_cell.py</em> in your chapter folder. Make sure you don’t add this code snippet to <em>cell_number.py</em>!</p>
<pre><code><var>--snip--</var>
<span class="LiteralGray">for cell, center in list(cellcenter.items()):</span>
<span class="LiteralGray">    t.goto(center)</span>
<span class="LiteralGray">    t.write(cell,font = ('Arial',20,'normal'))</span>
# The blue player moves first
turn = "blue"
# Define a function mark_cell() to place a dot in the cell
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> def mark_cell(x,y):
    # Make the variable turn a global variable
<span epub:type="pagebreak" title="196" id="Page_196"/>  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> global turn
    # Calculate the cell number based on x and y values
    if -300&lt;x&lt;300 and -300&lt;y&lt;300:
        col = int((x+500)//200)
        row = int((y+500)//200)
        # The cell number is a string variable
      <span class="CodeAnnotationCode" aria-label="annotation3">3</span> cellnumber = str(col + (row - 1)*3)
    else:
        print('you have clicked outside the game board')

    # Go to the corresponding cell and place a dot of the player's color
    t.up()
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> t.goto(cellcenter[cellnumber])
    t.dot(180,turn)
    t.update()
    # give the turn to the other player
    if turn == "blue":
        turn = "white"
    else:
        turn = "blue"

# Hide the turtle so that you don't see the arrowhead
t.hideturtle()
# Bind the mouse click to the mark_cell() function
t.onscreenclick(Mark_cell)
t.listen()
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing10-4">Listing 10-4</a>: Placing game pieces on the board</p>
<p>We draw the board and then define the variable <code>turn</code> that will keep track of whose turn it is. We first assign the value <code>blue</code> to the variable so that the blue player moves first. </p>
<p>At <span class="CodeAnnotation" aria-label="annotation1">1</span>, we define <code>mark_cell()</code>, which places a piece in the cell you click. At <span class="CodeAnnotation" aria-label="annotation2">2</span>, we declare the global variable <code>turn</code>. Python provides the <code>global</code> keyword, which allows <code>turn</code> to be used both inside and outside <code>mark_cell()</code>. Without making the variable global, you’d get the error message <code>UnboundLocalError: local variable 'turn' referenced before assignment</code> each time you clicked the board.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Python has two types of variables: <em>global variables</em>, which can be reached anywhere in the script, and <em>local variables</em>, which live only inside a function and can’t be reached outside the function. By declaring a global variable, you make it reachable everywhere in the script. In <em>mark</em><em>_</em><em>cell</em><em>.py</em>, the variable <code>turn</code> is created outside the function <code>m</code><code>ark_cell</code><code>()</code>, but because <code>turn</code> will be modified in <code>m</code><code>ark_cell</code><code>()</code>, we need to make it accessible in the global namespace as well. Otherwise, the change in the value of <code>turn</code> will not be carried outside the function.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" title="197" id="Page_197"/>We then convert the x- and y-coordinates of the click to the cell number on the game board <span class="CodeAnnotation" aria-label="annotation3">3</span>. Within the same line, we also convert the cell number from an integer to a string to match the variable type used in the dictionary <code>cellcenter</code>. </p>
<p>At <span class="CodeAnnotation" aria-label="annotation4">4</span>, we get the coordinates for the center of the clicked cell from <code>cellcenter</code> and tell the turtle to go there. The turtle places a dot 180 pixels wide and the color of the value stored in <code>turn</code>. After that, the turn is over, and we assign the turn to the other player. Finally, we bind <code>mark_cell()</code> to the mouse-click event.</p>
<p>Run the script and you’ll be able to click the board and mark the cell. The color of the dot will alternate between blue and white, as in <a href="#figure10-3" id="figureanchor10-3">Figure 10-3</a>.</p>
<figure>
<img src="Images/f10003.png" alt="f10003" width="536" height="563"/>
<figcaption><p><a id="figure10-3">Figure 10-3</a>: Mark cells on the tic-tac-toe board.</p></figcaption>
</figure>
<p>The script is now a playable game! However, we need to implement three new rules to make it follow the rules of tic-tac-toe:</p>
<ul>
<li>If a cell is already occupied, you cannot mark it again.</li>
<li>If a player marks three cells in a straight line—either horizontally, vertically, or diagonally—the player wins, and the game should stop.</li>
<li>If all nine cells are occupied, the game should stop, and a tie should be called if no player wins.</li>
</ul>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><span epub:type="pagebreak" title="198" id="Page_198"/>Try it Out</h2>
<p class="BoxBodyFirst">Run <em>m</em><em>ark_cell</em><em>.py</em> and find someone to play the game with you. You’ll need to adjust your game play to make allowances for the unimplemented rules. Be sure to use your own judgment for the preceding three rules.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501560c10-0004">	Determine Valid Moves, Wins, and Ties</h2>
<p class="BodyFirst">Next, we’ll implement those rules, allowing only valid moves and declaring wins (or ties). Download <em>ttt_click.py</em> from the book’s resources and save it in your chapter folder or alter <em>mark_cell.py</em> with the differences highlighted in <a href="#listing10-5" id="listinganchor10-5">Listing 10-5</a>.</p>
<pre><code>from tkinter import messagebox
<var>--snip--</var>
<span class="LiteralGray"># The blue player moves first</span>
<span class="LiteralGray">turn = "blue"</span>
# Count how many rounds played
rounds = 1 <span class="CodeAnnotationCode" aria-label="annotation1">1</span>
# Create a list of valid moves
validinputs = list(cellcenter.keys())
# Create a dictionary of moves made by each player
occupied = {"blue":[],"white":[]}
# Determine if a player has won the game
def win_game(): <span class="CodeAnnotationCode" aria-label="annotation2">2</span>
    win = False
    if '1' in occupied[turn] and '2' in occupied[turn] and '3' in occupied[turn]:
        win = True
    if '4' in occupied[turn] and '5' in occupied[turn] and '6' in occupied[turn]:
        win = True
    if '7' in occupied[turn] and '8' in occupied[turn] and '9' in occupied[turn]:
        win = True
    if '1' in occupied[turn] and '4' in occupied[turn] and '7' in occupied[turn]:
        win = True
    if '2' in occupied[turn] and '5' in occupied[turn] and '8' in occupied[turn]:
        win = True
    if '3' in occupied[turn] and '6' in occupied[turn] and '9' in occupied[turn]:
        win = True
    if '1' in occupied[turn] and '5' in occupied[turn] and '9' in occupied[turn]:
        win = True
    if '3' in occupied[turn] and '5' in occupied[turn] and '7' in occupied[turn]:
        win = True
    return win
<span class="LiteralGray"># Define a function mark_cell() to place a dot in the cell</span>
<span class="LiteralGray">def mark_cell(x,y):</span>
<span class="LiteralGray">    # Declare global variables</span>
    global turn, rounds, validinputs <span class="CodeAnnotationCode" aria-label="annotation3">3</span>
<span epub:type="pagebreak" title="199" id="Page_199"/>    <span class="LiteralGray"># Calculate the cell number based on x and y values</span>
<span class="LiteralGray">    if -300&lt;x&lt;300 and -300&lt;y&lt;300:</span>
<span class="LiteralGray">        col = int((x+500)//200)</span>
<span class="LiteralGray">        row = int((y+500)//200)</span>
<span class="LiteralGray">        # The cell number is a string variable</span>
<span class="LiteralGray">        cellnumber = str(col + (row - 1)*3)</span>
<span class="LiteralGray">    else:</span>
<span class="LiteralGray">        print('you have clicked outside the game board')</span>
    # Check if the move is a valid one
    if cellnumber in validinputs: <span class="CodeAnnotationCode" aria-label="annotation4">4</span>
        <span class="LiteralGray"># Go to the corresponding cell and place a dot of the player's color</span>
<span class="LiteralGray">        t.up()</span>
<span class="LiteralGray">        t.goto(cellcenter[cellnumber])</span>
<span class="LiteralGray">        t.dot(180,turn)</span>
<span class="LiteralGray">        t.update()</span>
        # Add the move to the occupied list for the player
        occupied[turn].append(cellnumber) <span class="CodeAnnotationCode" aria-label="annotation5">5</span>
        # Disallow the move in future rounds
        validinputs.remove(cellnumber)
        # Check if the player has won the game
        if win_game() == True: <span class="CodeAnnotationCode" aria-label="annotation6">6</span>
            # If a player wins, invalid all moves, end the game
            validinputs = []
            messagebox.showinfo("End Game",f"Congrats player {turn}, you won!")
        # If all cells are occupied and no winner, it's a tie
        elif rounds == 9: <span class="CodeAnnotationCode" aria-label="annotation7">7</span>
            messagebox.showinfo("Tie Game","Game over, it's a tie!")
        # Counting rounds
        rounds += 1
        <span class="LiteralGray"># Give the turn to the other player</span>
<span class="LiteralGray">        if turn == "blue":</span>
<span class="LiteralGray">            turn = "white"</span>
<span class="LiteralGray">        else:</span>
<span class="LiteralGray">            turn = "blue"</span>
    # If the move is not a valid move, remind the player 
    else:
        messagebox.showerror("Error","Sorry, that's an invalid move!")
<span class="LiteralGray"># Bind the mouse click to the mark_cell() function</span>
<span class="LiteralGray">t.onscreenclick(mark_cell)</span>
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing10-5">Listing 10-5</a>: Allow only valid moves and declare wins and ties.</p>
<p>Our first change is to import the <em>messagebox</em> module from the <em>tkinter</em> package; this module displays a message box for a win, tie, or invalid move. </p>
<p>Starting at <span class="CodeAnnotation" aria-label="annotation1">1</span>, we create a variable <code>rounds</code>, a list <code>validinputs</code>, and a dictionary <code>occupied</code>. The variable <code>rounds</code> keeps track of the number of turns taken, which is the number of cells that have been marked. When the number of rounds reaches nine and no player wins (which is often the case in tic-tac-toe), we’ll declare a tie game. </p>
<p><span epub:type="pagebreak" title="200" id="Page_200"/>We use <code>validinputs</code> to determine whether a move is valid. If a cell is marked by a player, we’ll remove it from the list of valid moves. </p>
<p>The dictionary <code>occupied</code> keeps track of each player’s moves. At the beginning of the game, the keys <code>blue</code> and <code>white</code> both have an empty list as their value. When a player occupies a cell, the cell number will be added to that player’s list. For example, if the blue player has occupied cells 1, 5, and 9 and the white player has occupied cells 3 and 7, <code>occupied</code> will become <code>{"blue":["1","5","9"],"white":["3","7"]}</code>. We’ll use this later to determine whether a player has won the game.</p>
<p>At <span class="CodeAnnotation" aria-label="annotation2">2</span>, we define <code>win_game()</code>, which checks whether a player has won the game. There are eight ways a player can win, which we explicitly check for:</p>
<ul>
<li>Cells 1, 2, and 3 have been occupied by the same player.</li>
<li>Cells 4, 5, and 6 have been occupied by the same player. </li>
<li>Cells 7, 8, and 9 have been occupied by the same player. </li>
<li>Cells 1, 4, and 7 have been occupied by the same player. </li>
<li>Cells 2, 5, and 8 have been occupied by the same player. </li>
<li>Cells 3, 6, and 9 have been occupied by the same player. </li>
<li>Cells 1, 5, and 9 have been occupied by the same player. </li>
<li>Cells 3, 5, and 7 have been occupied by the same player. </li>
</ul>
<p>The function <code>win_game()</code> creates the variable <code>win</code> and assigns <code>False</code> as a default value. The function checks the dictionary <code>occupied</code> for the list of cells occupied by the player who currently has the turn, checking all eight win cases listed earlier. If one of the cases matches, the value <code>win</code> changes to <code>True</code>. When <code>win_game()</code> is called, it returns the value stored in the variable <code>win</code>.</p>
<p>We’ve made significant changes to <code>mark_cell()</code>. At <span class="CodeAnnotation" aria-label="annotation3">3</span>, we declare three global variables; all must be declared global because they will be modified inside the function. At <span class="CodeAnnotation" aria-label="annotation4">4</span>, we check whether the cell number most recently clicked is in the list <code>validinputs</code>; if it is, a dot is placed in the cell, and the cell number is added to the player’s list of occupied cells <span class="CodeAnnotation" aria-label="annotation5">5</span>. The cell is then removed from <code>validinputs</code> so that players can’t mark the same cell in future rounds. </p>
<p>At <span class="CodeAnnotation" aria-label="annotation6">6</span>, we call <code>win_game()</code> and see whether the current player has won the game. If yes, we change <code>validinputs</code> to an empty list so no further moves can be made. A message box will pop up to say, <code>Congrats player blue, you won!</code> or <code>Congrats player white, you won!</code>, using <code>showinfo()</code> from the <em>messagebox</em> module (<a href="#figure10-4" id="figureanchor10-4">Figure 10-4</a>).</p>
<span epub:type="pagebreak" title="201" id="Page_201"/><figure>
<img src="Images/f10004.png" alt="f10004" width="497" height="500"/>
<figcaption><p><a id="figure10-4">Figure 10-4</a>: A win for blue!</p></figcaption>
</figure>
<p>If the player hasn’t won, the script checks whether the number of rounds has reached nine <span class="CodeAnnotation" aria-label="annotation7">7</span>. If yes, the script declares a tie game, displaying <code>Game over, it's a tie!</code> (<a href="#figure10-5" id="figureanchor10-5">Figure 10-5</a>). </p>
<figure>
<img src="Images/f10005.png" alt="f10005" width="499" height="499"/>
<figcaption><p><a id="figure10-5">Figure 10-5</a>: A tied game</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="202" id="Page_202"/>If the game doesn’t end, we increase the number of rounds by one and assign the turn to the other player. During the game, if a player clicks an invalid cell, we’ll display <code>Sorry, that's an invalid move!</code> (<a href="#figure10-6" id="figureanchor10-6">Figure 10-6</a>).</p>
<figure>
<img src="Images/f10006.png" alt="f10006" width="539" height="537"/>
<figcaption><p><a id="figure10-6">Figure 10-6</a>: An invalid move</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Try it Out</h2>
<p class="BoxBodyFirst">Run <em>t</em><em>tt_click</em><em>.py</em> and play a few games, generating the following three instances: you make an invalid move, a player wins the game, and the game is tied.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501560c10-0005">	Voice-Controlled Version</h2>
<p class="BodyFirst">Now we’re ready to add the voice control and speech functionality. One significant change is that we’ll now make your opponent your computer. We’ll build on the latest <em>ttt_click.py</em> file. After you make a move as the blue player, the computer will randomly select a move as the white player until the game ends. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If you want to play a voice-controlled game with two players, go to the book’s resources page and download <em>ttt_</em><em>hs_2players.py</em>. We discuss only the one-player version here to save space. In our ultimate VPA in <span class="xref" itemid="xref_target_Chapter 17">Chapter 17</span>, you’ll see a generalized version of the game in which you can choose to play against a computer or a human and whether you want to play first or second.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" title="203" id="Page_203"/>Download <em>ttt_hs.py</em> from the book’s resources or make the changes shown in <a href="#listing10-6" id="listinganchor10-6">Listing 10-6</a>.</p>
<pre><code><span class="LiteralGray">import turtle as t</span>
from random import choice
<span class="LiteralGray">from tkinter import messagebox</span>

# Import functions from the local package
from mptpkg import voice_to_text, print_say
<em>--snip--</em>
<span class="LiteralGray">    if '3' in occupied[turn] and '5' in occupied[turn] and '7' in occupied[turn]:</span>
<span class="LiteralGray">        win = True</span>
<span class="LiteralGray">    return win</span>
<span class="LiteralGray"># Start an infinite loop to take voice inputs</span>
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> while True:
    # Ask for your move
    print_say(f"Player {turn}, what's your move?")
    # Capture your voice input
    inp = voice_to_text()
    print(f"You said {inp}.")
    inp = inp.replace('number ','')
    inp = inp.replace('one','1')   
    inp = inp.replace('two','2')
    inp = inp.replace('three','3')
    inp = inp.replace('four','4')
    inp = inp.replace('five','5')
    inp = inp.replace('six','6')
    inp = inp.replace('seven','7')
    inp = inp.replace('eight','8')
    inp = inp.replace('nine','9')
    <span class="LiteralGray">if inp in validinputs:</span>
        # Go to the corresponding cell and place a dot of the player's color
        t.up()
        t.goto(cellcenter[inp])
        t.dot(180,turn)
        t.update()
        # Add the move to the occupied list for the player
        occupied[turn].append(inp)
        # Disallow the move in future rounds
        validinputs.remove(inp)
        # <b>Check if the player has won the game</b>
      <span class="CodeAnnotationCode" aria-label="annotation2">2</span> <span class="LiteralGray">if win_game() == True:</span>
            # If a player wins, invalid all moves, end the game
            validinputs = []
            <span class="LiteralGray">print_say(f"Congrats player {turn}, you won!")</span>
            messagebox.showinfo\
            ("End Game",f"Congrats player {turn}, you won!")
            break

        # If all cells are occupied and no winner, game is a tie
        <span class="LiteralGray">elif rounds == 9:</span>
            print_say("Game over, it's a tie!")
            messagebox.showinfo("Tie Game","Game over, it's a tie!")
            break

<span epub:type="pagebreak" title="204" id="Page_204"/>        # Counting rounds
        rounds += 1
        # Give the turn to the other player
        if turn == "blue":
            turn = "white"
        else:
            turn = "blue"  
        
        # The computer makes a random move
      <span class="CodeAnnotationCode" aria-label="annotation3">3</span> <span class="LiteralGray">inp = choice(validinputs)</span>
        print_say(f'The computer occupies cell {inp}.')
        t.up()
        t.goto(cellcenter[inp])
        t.dot(180,turn)
        t.update()
        occupied[turn].append(inp)
        validinputs.remove(inp)
        if win_game() == True:
            validinputs = []
            print_say(f"Congrats player {turn}, you won!")
            messagebox.showinfo\
            ("End Game",f"Congrats player {turn}, you won!")
            break
        elif rounds == 9:
            print_say("Game over, it's a tie!")
            messagebox.showinfo("Tie Game","Game over, it's a tie!")
            
            break
        rounds += 1
        if turn == "blue":
            turn = "white"
        else:
            turn = "blue"     

    # If the move is not a valid move, remind the player 
    <span class="LiteralGray">else:</span>
        print_say("Sorry, that's an invalid move!")
<span class="LiteralGray">t.done()</span>
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing10-6">Listing 10-6</a>: Adding speech and voice-control functionality</p>
<p>We import the functions we’ll need: the <code>choice()</code> function from the <em>random</em> module to let the computer randomly select a move and our <code>print_say()</code> and <code>voice_to_text()</code> functions from the custom package <em>mptpkg</em>.</p>
<p>At <span class="CodeAnnotation" aria-label="annotation1">1</span>, we start an infinite <code>while</code> loop. At each iteration, the script asks for your move out loud. You speak into the microphone to make your move, and the script captures your voice command, storing the response in the variable <code>inp</code>. </p>
<p>Here we did a little tweaking to make <code>voice_to_text()</code> more responsive to your voice commands. When your voice input is just one word, such as “One” or “Two,” it’s hard for the software to put the word in context and respond. On the other hand, if you say “Number one” or “Number two,” the software <span epub:type="pagebreak" title="205" id="Page_205"/>can easily pick up your meaning. The script simply replaces the “number” part of the voice command with an empty string so that only the number is left in <code>inp</code>. Sometimes <code>voice_to_text()</code> returns the number in word form such as <code>one</code> or <code>two</code>, instead of in numeric form, such as <code>1</code> or <code>2</code>. We therefore also change all the word forms to numerical forms. This way, you can say “number one” or “one” to the microphone, and <code>inp</code> will always be in the form you want: <code>1</code>. </p>
<p>If your choice is in <code>validinputs</code>, the script performs the sequence of actions to make the move: place a dot in the corresponding cell, add the cell number to your list of occupied cells, and remove the occupied cell number from the list of valid inputs. </p>
<p>The script then checks if you’ve won or tied the game <span class="CodeAnnotation" aria-label="annotation2">2</span> and responds out loud appropriately.</p>
<p>Once your turn is over, the computer randomly selects a move from <code>validinputs</code> to play against you <span class="CodeAnnotation" aria-label="annotation3">3</span>. The script checks whether the computer has won or tied the game. If your voice command is not a valid move, the script speaks an alert.</p>
<p>Here’s one interaction with the game:</p>
<pre><code>Player blue, what's your move?
You said 7.
The computer occupies cell 3.
Player blue, what's your move?
You said 8.
The computer occupies cell 1.
Player blue, what's your move?
You said 9.
Congrats player blue, you won!</code></pre>
<p>I’ve managed to win in just three moves! </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Try it Out</h2>
<p class="BoxBodyFirst">Run <em>ttt_hs</em><em>.py</em> and try to beat the computer.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501560c10-0006">	Summary</h2>
<p class="BodyFirst">In this chapter, you learned to build a voice-controlled graphical tic-tac-toe game that talks in a human voice. Along the way, you learned a few new skills.</p>
<p>You learned how mouse clicks work in the <em>turtle</em> module. With that knowledge, we marked cells on the game board with mouse clicks. </p>
<p>You learned how to determine whether a player has won tic-tac-toe based on the explicit game rules. This is at the heart of game creation. You listed all cases when a player can win the game, then added code to check all cases and see whether there is a winner. </p>
<p><span epub:type="pagebreak" title="206" id="Page_206"/>You also added the speech recognition and text-to-speech features to a game, making a few tweaks to make sure the script can understand your input. By combining these skills, you’ll be able to create your own voice-controlled games.</p>
<h2 id="h1-501560c10-0007">	End-of-Chapter Exercises</h2>
<ol class="decimal">
<li value="1">Modify <em>ttt_board.py </em>so that the cell number appears in 15-point font at the lower-left corner of each cell (80 pixels from the center of the cell, both horizontally and vertically).</li>
<li value="2">Modify <em>mouse_click.py</em> so that each time you click the screen, the script prints out the additional message <code>x + y is</code>, followed by the actual value of the x- and y-coordinates of the clicked point.</li>
<li value="3">Modify <em>cell_number.py</em> so that each time you click the screen, the script prints <code>you clicked the point (</code><var>x</var><code>, </code><var>y</var><code>)</code> before printing the column, row, and cell numbers, where <var>x</var> and <var>y</var> are the actual coordinates. For example, if you click the point (x = –100, y = 50), the message should say <code>you clicked the point (-100, 50)</code>.</li>
<li value="4">Modify <em>mark_cell.py</em> so that the white player moves first.</li>
<li value="5">Modify <em>ttt_click.py</em> so that a player wins only by marking three cells in a row horizontally or vertically, but not diagonally. </li>
</ol>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="207" id="Page_207"/>11</span><br/>
<span class="ChapterTitle">Connect Four </span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="200" height="200"/>
</figure>
<p class="ChapterIntro">In this chapter, you’ll build a voice-controlled Connect Four game. As with tic-tac-toe in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>, you’ll first draw the board and set the yellow and red game pieces to alternate turns. You’ll animate the effect of a disc falling from the top of a column to the lowest available row to make the game more visually engaging. You’ll disallow invalid moves, detect if a player has won, and detect if all 42 cells have been occupied with no winner, meaning the game is tied.</p>
<p>In <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>, you learned how to check whether a player has won the game by laying out all winning scenarios and checking whether the current game board matches one of the scenarios. We’ll apply that same strategy here. You’ll also learn how to use exception handling to prevent crashing during the process of checking and how to prevent negative indexing errors.</p>
<p><span epub:type="pagebreak" title="208" id="Page_208"/>Once the game is set up, we’ll add the speech recognition and text-to-speech features so you can play the game with your voice alone. </p>
<p>To start, set up the folder <em>/mpt/ch11/</em> for this chapter. All scripts in this chapter are available through the book’s resources page at <a href="https://www.nostarch.com/make-python-talk/" class="LinkURL">https://www.nostarch.com/make-python-talk/</a>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>new skills</h2>
<ul>
<li>Creating animations using <em>turtle</em> </li>
<li>Using exception handling to check for winning cases</li>
<li>Handling negative indexing in Python</li>
<li>Mapping a list of lists to coordinates in a two-dimensional space</li>
</ul>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501560c11-0001">	Game Rules</h2>
<p class="BodyFirst">Connect Four is a well-known board game, but I’ll go over the rules to clarify the logic in the upcoming code. In Connect Four, two players take turns dropping discs into one of seven columns, from the top. One player has red discs and the other yellow. The seven columns are on a six-row, vertically suspended grid. When a disc is dropped into a column, it will fall to the lowest available space in that column. Discs cannot move from one column to another. </p>
<p>The first player who forms a direct line—either horizontally, vertically, or diagonally—with four of their game pieces wins. If all 42 slots have been filled and nobody has won, the game is tied. We’ll use a red dot and a yellow dot to represent the discs. </p>
<h2 id="h1-501560c11-0002">	Draw the Game Board </h2>
<p class="BodyFirst">We first draw a grid with six rows and seven columns. We’ll number the columns at the top of the screen to make it easier to play. </p>
<p>Open your Spyder editor and enter the code from <a href="#listing11-1" id="listinganchor11-1">Listing 11-1</a>. Save the script as <em>conn_board.py</em> in your chapter folder.</p>
<pre><code>import turtle as t

# Set up the screen
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> t.setup(700,600,10,70)
t.hideturtle()
t.tracer(False)
t.bgcolor("lightgreen")
t.title("Connect Four in Turtle Graphics")
# Draw six thick vertical lines
<span epub:type="pagebreak" title="209" id="Page_209"/><span class="CodeAnnotationHang" aria-label="annotation2">2</span> t.pensize(5)
for i in range(-250,350,100):
    t.up()
    t.goto(i,-350)
    t.down()
    t.goto(i,350)
    t.up()
# Draw five thin gray horizontal lines to form grid
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> t.pensize(1)
t.pencolor("grey")
for i in range(-200,300,100):  
    t.up()
    t.goto(-350,i)
    t.down()
    t.goto(350,i)
    t.up()
# Write column numbers on the board
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> colnum = 1
for x in range(-300,350,100):
    t.goto(x,270)
    t.write(colnum,font = ('Arial',20,'normal'))
    colnum += 1
t.done()
try:
    t.bye()
except t.Terminator:
    print('exit turtle')</code></pre>
<p class="CodeListingCaption"><a id="listing11-1">Listing 11-1</a>: Drawing the Connect Four game board</p>
<p>We first import all functions in the <em>turtle</em> module, and then we set up the screen as 700 by 600 pixels <span class="CodeAnnotation" aria-label="annotation1">1</span>. That lets us make each cell 100 by 100 pixels to keep things simple. We set the background color to light green and the title to <code>Connect Four in Turtle Graphics</code>. </p>
<p>We then draw six thick vertical lines to divide the screen into seven columns. At <span class="CodeAnnotation" aria-label="annotation2">2</span>, we set the pen width to 5 pixels. The command line <code>for i in range(-250,350,100)</code> tells the variable <code>i</code> to iterate through the following six values: –250, –150, –50, 50, 150, and 250. These are the x-coordinates of the six vertical lines. The y-coordinates of the two endpoints of the six vertical lines are all –350 and 350. Similarly, we draw five thin, gray horizontal lines to divide the screen into six rows, starting at <span class="CodeAnnotation" aria-label="annotation3">3</span>, with a pen size of 1 pixel and color of gray so that the lines appear thin and light. This all gives us an even grid with seven columns and six rows.</p>
<p>Next, we number the columns to let players know where to place the discs. We first create a variable <code>colnum</code> and assign a value <code>1</code> to it <span class="CodeAnnotation" aria-label="annotation4">4</span>. We then iterate through the x-coordinates of the center of the seven columns and write the corresponding column number by adding one to the value of <code>colnum</code>. </p>
<p>Run the script and you should see a screen like <a href="#figure11-1" id="figureanchor11-1">Figure 11-1</a>.</p>
<span epub:type="pagebreak" title="210" id="Page_210"/><figure>
<img src="Images/f11001.png" alt="f11001" width="572" height="515"/>
<figcaption><p><a id="figure11-1">Figure 11-1</a>: The board for the Connect Four game</p></figcaption>
</figure>
<h2 id="h1-501560c11-0003">	The Mouse-Click Version</h2>
<p class="BodyFirst">Now you have a game board. Let’s drop some discs into the columns. In this section, you’ll learn how to use mouse clicks to place a disc in a column and let it fall to the lowest available cell. After that, you’ll detect invalid moves, wins, and ties.</p>
<h3 id="h2-501560c11-0001">Drop a Disc </h3>
<p class="BodyFirst">Here, you’ll use mouse clicks to place a disc in a column of your choice. The column number in which the disc will appear is determined by where you click. The row number depends on the number of discs already in that column. </p>
<p>When you first click a column, a red dot will be placed in the lowest available cell. The colors will alternate with each click.</p>
<p>Open <em>conn_board.py</em> and add the code in <a href="#listing11-2" id="listinganchor11-2">Listing 11-2</a>. Then save the new script as <em>show_disc.py</em> in your chapter folder. </p>
<pre><code><var>--snip--</var>
<span class="LiteralGray"># Write column numbers on the board</span>
<span class="LiteralGray">colnum = 1</span>
<span class="LiteralGray">for x in range(-300, 350, 100):</span>
<span class="LiteralGray">    t.goto(x,270)</span>
<span class="LiteralGray">    t.write(colnum,font = ('Arial',20,'normal'))</span>
<span class="LiteralGray">    colnum += 1</span>
# The red player moves first
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> turn = "red"
# The x-coordinates of the center of the 7 columns
<span epub:type="pagebreak" title="211" id="Page_211"/><span class="CodeAnnotationCode" aria-label="annotation2">2</span> xs = [-300,-200,-100,0,100,200,300]
# The y-coordinates of the center of the 6 rows
ys = [-250,-150,-50,50,150,250]
# Keep track of the occupied cells
occupied = [list(),list(),list(),list(),list(),list(),list()]
# Define a function conn() to place a disc in a cell
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> def conn(x,y):
    # Make the variable turn a global variable
    global turn
    # Calculate the column number based on x- and y-values
    if -350&lt;x&lt;350 and -300&lt;y&lt;300:
        col = int((x+450)//100)
    else:
        print('You have clicked outside the game board!')
    # Calculate the lowest available row number in that column
    row = len(occupied[col-1])+1
    # Go to the cell and place a dot of the player's color
    t.up()
    t.goto(xs[col-1],ys[row-1])
    t.dot(80,turn)
    # Add the move to the occupied list to keep track
    occupied[col-1].append(turn)
    # Give the turn to the other player
    if turn == "red":
        turn = "yellow"
    else:
        turn = "red"
# Bind the mouse click to the conn() function
t.onscreenclick(conn)
t.listen()    
<span class="LiteralGray">t.done()</span>
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing11-2">Listing 11-2</a>: Dropping discs on the game board</p>
<p>The red player goes first, so after the game board is drawn, we define the variable <code>turn</code> and assign the value <code>red</code> to it <span class="CodeAnnotation" aria-label="annotation1">1</span>. Starting at <span class="CodeAnnotation" aria-label="annotation2">2</span>, we define three lists. The list <code>xs</code> contains values corresponding to the x-coordinates of the middle points of the seven columns. The list <code>ys</code> has six values corresponding to the y-coordinates of the middle points of the six rows. Later, we’ll use these lists to determine the x- and y-coordinates of the center of all 42 cells.</p>
<p>The list <code>occupied</code> is a list of lists. It starts as a list of seven empty lists, each representing a column. When you place a disc in a column, the disc will be added to the corresponding list. This way, <code>occupied</code> will keep track of all discs placed and their positions. </p>
<p>At <span class="CodeAnnotation" aria-label="annotation3">3</span>, we define <code>conn()</code>, which places the disc on the column you click. We declare <code>turn</code> as a global variable, so that its value can be recognized both inside and outside <code>conn()</code>. Then, we convert the x-coordinate of the user’s click to the column number on the game board. We then determine the lowest row available in that column, which tells us which row to place the disc in. Note that <code>occupied[col-1]</code> is the list of all discs currently in the column, and we use <code>col-1</code> instead of <code>col</code> because Python uses zero indexing but our columns are numbered starting at 1. </p>
<p><span epub:type="pagebreak" title="212" id="Page_212"/>We then obtain the x- and y-coordinates of the center of the cell in which to place the new disc. The <em>turtle</em> module places a dot with a diameter of 80 pixels and the color value stored in <code>turn</code>. We add the disc to the corresponding list within <code>occupied</code> so that next time a disc is placed in the same column, the appropriate cell is marked as invalid. With this, the player’s turn is over, and we hand the turn to the other player. Finally, we bind <code>conn()</code> to the mouse-click event.</p>
<p>Run the script, and you should be able to click on the game board and mark the cell with a red or yellow dot. Keep clicking, and the color of the dot will alternate between red and yellow (<a href="#figure11-2" id="figureanchor11-2">Figure 11-2</a>).</p>
<figure>
<img src="Images/f11002.png" alt="f11002" width="556" height="499"/>
<figcaption><p><a id="figure11-2">Figure 11-2</a>: Place discs on the Connect Four game board.</p></figcaption>
</figure>
<h3 id="h2-501560c11-0002">Animate the Falling Discs</h3>
<p class="BodyFirst">When you play Connect Four in the real world, you drop the disc at the top, and it falls into the proper position. Next, you’ll create the animation effect of the disc falling. This is a good opportunity to learn how to create animation effects using the <em>turtle</em> module. </p>
<p>Open <em>show_disc.py</em> and add the code in <a href="#listing11-3" id="listinganchor11-3">Listing 11-3</a>. Save this as <em>disc_fall.py</em> in your chapter folder. </p>
<pre><code><span class="LiteralGray">import turtle as t</span>
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> from time import sleep
<em>--snip--</em>
<span class="LiteralGray"># Keep track of the occupied cells</span>
<span class="LiteralGray">occupied = [list(),list(),list(),list(),list(),list(),list()] </span>
# Create a second turtle to show disc falling
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> fall = t.Turtle()
fall.up()
<span epub:type="pagebreak" title="213" id="Page_213"/><span class="CodeAnnotationCode" aria-label="annotation3">3</span> fall.hideturtle()
<span class="LiteralGray"># Define a function conn() to place a disc in a cell</span>
<span class="LiteralGray">def conn(x,y):</span>
<span class="LiteralGray">    # Make the variable turn a global variable</span>
<span class="LiteralGray">    global turn</span>
<span class="LiteralGray">    # Calculate the column number based on x and y values</span>
<span class="LiteralGray">    if -350&lt;x&lt;350 and -300&lt;y&lt;300:</span>
<span class="LiteralGray">        col = int((x+450)//100)</span>
<span class="LiteralGray">    else:</span>
<span class="LiteralGray">        print('You have clicked outside the game board!')</span>
<span class="LiteralGray">    # Calculate the lowest available row number in that column</span>
<span class="LiteralGray">    row = len(occupied[col-1])+1</span>
    # Show the disc fall from the top
    <span class="CodeAnnotationCode" aria-label="annotation4">4</span> if row&lt;6:
        for i in range(6,row,-1):
            fall.goto(xs[col-1],ys[i-1])
            fall.dot(80,turn)
            update()
            sleep(0.05)
            fall.clear()
<span class="LiteralGray">    # Go to the cell and place a dot of the player's color</span>
<span class="LiteralGray">    up()</span>
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing11-3">Listing 11-3</a>: Script to show the animation effect of discs falling</p>
<p>We import <code>sleep()</code> so we can pause the script to let the falling disc stay in a cell for a short while, allowing the user to see its movement <span class="CodeAnnotation" aria-label="annotation1">1</span>. Starting at <span class="CodeAnnotation" aria-label="annotation2">2</span>, we create a second turtle named <code>fall</code>. We lift the drawing pen of the new turtle so that it won’t leave a line as it moves. We also use <code>hideturtle()</code> to hide the cursor <span class="CodeAnnotation" aria-label="annotation3">3</span>.</p>
<p>Starting at <span class="CodeAnnotation" aria-label="annotation4">4</span>, we animate the falling disc. We first see if the column is full by checking whether the row number is less than 6. If yes, we’ll show the animation effect. If the lower rows in the column are full, the disc can be left in place (there’s no need to show the disc falling). </p>
<p>We iterate <code>i</code> through all the empty cells above the lowest available cell. If the lowest available position is <code>row = 2</code>, for example, the command <code>for i in range(6,row,-1)</code> iterates <code>i</code> through values 6, 5, 4, and 3. The <code>-1</code> tells the range function to count backward. At each iteration, the <code>fall</code> turtle places a dot in the center of the empty cell. The script draws a dot to the screen, pauses for 0.05 seconds, and then erases the dot before going to the next iteration. </p>
<p>The script is now a complete game! However, at the moment, players must use their own judgment to enforce the following rules:</p>
<ul>
<li>If a column is already full, you cannot drop a disc in it.</li>
<li>If a player connects four cells in a straight line, that player wins, and the game should stop.</li>
<li>If all 42 cells are occupied and nobody has won, the game should stop and a tie be declared.</li>
</ul>
<p>Let’s code that into the game.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><span epub:type="pagebreak" title="214" id="Page_214"/>Try it Out</h2>
<p class="BoxBodyFirst">Run <em>disc_fall.py</em>, click a few times, and then start it again. Find someone to play with you, being mindful of the three rules just mentioned.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501560c11-0004">	Determine Valid Moves, Wins, and Ties</h2>
<p class="BodyFirst">Next, we’ll improve the game by blocking invalid moves and declaring wins or ties. Open <em>disc_fall.py</em> and add the code in <a href="#listing11-4" id="listinganchor11-4">Listing 11-4</a>. Save the new script as <em>conn_click.py</em>. The code changes are shown in two sections, so it’s easier to refer back to the code when reading the explanations.</p>
<pre><code><span class="LiteralGray">import turtle as t</span>
<span class="LiteralGray">from time import sleep</span>
from tkinter import messagebox

<span class="LiteralGray"># Set up the screen</span>
<var>--snip--</var>
<span class="LiteralGray"># Create a second turtle to show disc falling</span>
<span class="LiteralGray">fall = t.Turtle()</span>
<span class="LiteralGray">fall.up()</span>
<span class="LiteralGray">fall.hideturtle()</span>
# Create a list of valid moves
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> validinputs = [1,2,3,4,5,6,7]
# Define a horizontal4() function to check connecting 4 horizontally
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> def horizontal4(x, y, turn):
    win = False
    for dif in (-3, -2, -1, 0):
        try:
            if occupied[x+dif][y] == turn\
            and occupied[x+dif+1][y] == turn\
            and occupied[x+dif+2][y] == turn\
            and occupied[x+dif+3][y] == turn\
            and  x+dif &gt;= 0:
                win = True 
        except IndexError:
            pass
    return win     
# Define a vertical4() function to check connecting 4 vertically
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> def vertical4(x, y, turn):
    win = False
    try:
        if occupied[x][y] == turn\
        and occupied[x][y-1] == turn\
        and occupied[x][y-2] == turn\
        and occupied[x][y-3] == turn\
        and y-3 &gt;= 0:
          win = True
    except IndexError:
        pass
    return win      
<span epub:type="pagebreak" title="215" id="Page_215"/># Define a forward4() function to check connecting 4 diagonally in / shape
def forward4(x, y, turn):
    win = False
    for dif in (-3, -2, -1, 0):
        try:
            if occupied[x+dif][y+dif] == turn\
            and occupied[x+dif+1][y+dif+1] == turn\
            and occupied[x+dif+2][y+dif+2] == turn\
            and occupied[x+dif+3][y+dif+3] == turn\
            and x+dif &gt;= 0 and y+dif &gt;= 0:
              win = True
        except IndexError:
            pass
    return win     
# Define a back4() function to check connecting 4 diagonally in \ shape
def back4(x, y, turn):
    win = False
    for dif in (-3, -2, -1, 0):
        try:
            if occupied[x+dif][y-dif] == turn\
            and occupied[x+dif+1][y-dif-1] == turn\
            and occupied[x+dif+2][y-dif-2] == turn\
            and occupied[x+dif+3][y-dif-3] == turn\
            and x+dif &gt;= 0 and y-dif-3 &gt;= 0:
              win = True
        except IndexError:
            pass
    return win 
# Define a win_game() function to check if someone wins the game
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> def win_game(col, row, turn):
    win = False
    # Convert column and row numbers to indexes in the list of lists occupied
    x = col-1
    y = row-1
    # Check all winning possibilities
    if vertical4(x, y, turn) == True:
        win = True
    if horizontal4(x, y, turn) == True:
        win = True
    if forward4(x, y, turn) == True:
        win = True
    if back4(x, y, turn) == True:
        win = True
    # Return the value stored in win
    return win
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing11-4">Listing 11-4</a>: First half of the script to disallow invalid moves and declare wins and ties</p>
<p>We import the <em>messagebox</em> module from the <em>tkinter</em> package to allow us to display messages about wins, ties, and invalid moves. </p>
<p>At <span class="CodeAnnotation" aria-label="annotation1">1</span>, we create the list <code>validinputs</code> to keep track of valid moves. All seven columns are valid to start with. If a column contains six discs, it will be removed from the list.</p>
<p><span epub:type="pagebreak" title="216" id="Page_216"/>A player can win the game by collecting four discs in a row in one of four orientations: horizontally, vertically, diagonally in a forward-slash fashion (/), or diagonally in a backslash fashion (\). Therefore, we define four functions to check for each way of winning. </p>
<p>At <span class="CodeAnnotation" aria-label="annotation2">2</span>, we define <code>horizontal4()</code>, which checks if a player has won the game by successfully connecting four discs in a row horizontally. In the function, we create the variable <code>win</code> and assign a default value of <code>False</code>. The function then checks whether the player has connected four discs horizontally. If yes, the value of <code>win</code> changes to <code>True</code>. When the function <code>horizontal4()</code> is called, it returns the value stored in the variable <code>win</code>. Let’s look at the details of this function. </p>
<p>We’ll use <code>x = col-1</code> and <code>y = row-1</code> to convert column and row numbers on the game board to indexes in the <code>occupied</code><em> </em>list. The cell with column number <code>col</code> and row number <code>row</code> corresponds to <code>occupied[x][y]</code> in <code>occupied</code>. For simplicity, we’ll call this cell <code>[x][y]</code> for the rest of the chapter.</p>
<p>A player can connect four pieces horizontally in four ways: </p>
<ul>
<li>Cells <code>[x-3][y]</code>, <code>[x-2][y]</code>, and <code>[x-1][y]</code> all have the same color as cell <code>[x][y]</code>.</li>
<li>Cells <code>[x-2][y]</code>, <code>[x-1][y]</code>, and <code>[x+1][y]</code> all have the same color as cell <code>[x][y]</code>.</li>
<li>Cells <code>[x-1][y]</code>, <code>[x+1][y]</code>, and <code>[x+2][y]</code> all have the same color as cell <code>[x][y]</code>.</li>
<li>Cells <code>[x+1][y]</code>, <code>[x+2][y]</code>, and <code>[x+3][y]</code> all have the same color as cell <code>[x][y]</code>.</li>
</ul>
<p>We therefore define a variable <code>dif</code> to iterate through four values <code>(-3, -2, -1, 0)</code>. For each value of <code>dif</code>, we check whether all four cells—<code>[x+dif][y]</code>, <code>[x+dif+1][y]</code>, <code>[x+dif+2][y]</code>, and <code>[x+dif+3][y]</code>—have the same color. If yes, we change the value of <code>win</code> to <code>True</code>. </p>
<p>In the process, we need to make exceptions for <code>IndexError</code> because, for example, the value of <code>x+3</code> may be 8, but the board has only seven columns. If we do not make exceptions for <code>IndexError</code>, the script will crash in the process of checking whether the player has won the game. </p>
<p>Further, we ensure that none of the indexes have negative values, because negative indexing has a very specific meaning in Python. In Python, a negative index wraps around to the beginning of the list instead of falling off at the end. For example, index <code>-1</code> refers to the last element in a list in Python, <code>-2</code> to the second to last, and so on. Negative indexing will not raise an <code>IndexOutOfBounds</code> error, but it will also not behave as you expect. </p>
<p>Let’s look at a concrete example: for x = 1 and y = 2, when the script checks the cell <code>[x-3][2]</code>, it will look at cell <code>[-2][2]</code>, which is actually cell <code>[5][2</code>] because <code>-2</code> refers to the second-to-last value in x, which is 5 (that is, the sixth column, since there is a total of seven columns). Therefore, we put the condition <code>x+dif&gt; = 0</code> in the function to ensure that we have no negative indexing anywhere. </p>
<p>Finally, we use <code>try</code> and <code>except</code> in every one of the four cases of winning by connecting four discs horizontally. If instead we had used just one set of <code>try</code> and <code>except</code> for all four cases of wins, whenever any <code>IndexError </code>occured, the script would skip all remaining cases and go to the <code>except</code> branch directly. This would cause the script to fail to identify many cases of wins. </p>
<p><span epub:type="pagebreak" title="217" id="Page_217"/>Similarly, we define <code>vertical4()</code> to check for a win by connecting four discs in a row vertically <span class="CodeAnnotation" aria-label="annotation3">3</span>. Then <code>forward4()</code><em> </em>checks for a forward diagonal win, and <code>back4()</code><em> </em>checks for a backward diagonal win. </p>
<p>At <span class="CodeAnnotation" aria-label="annotation4">4</span>, we define <code>win_game()</code>, which checks for a win in any of the 13 win scenarios (four horizontally, one vertically, four diagonally in a forward-slash fashion, and four diagonally in a backslash fashion). In <code>win_game()</code>, we create the variable <code>win</code> and assign a default value of <code>False</code>. The function first converts column and row numbers, <code>col</code> and <code>row</code>, to indexes in the <code>occupied</code><em> </em>list, <code>x</code> and <code>y</code>. The function then calls the four functions just defined to see if the player may have won. If any of the four functions returns a value of <code>True</code>, the value of <code>win</code> changes to <code>True</code>, and <code>win_game()</code> will return a value of <code>True</code> when it’s called. </p>
<p>Now let’s examine the second half of the script (which we are saving as <em>conn_click.py</em>), shown in <a href="#listing11-5" id="listinganchor11-5">Listing 11-5</a>.</p>
<pre><code><var>--snip--</var>
# Count the number of rounds
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> rounds=1
<span class="LiteralGray"># Define a function conn() to place a disc in a cell</span>
<span class="LiteralGray">def conn(x,y):</span>
    # Declare global variables
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> global turn, rounds, validinputs
<span class="LiteralGray">    # Calculate the column number based on x and y values</span>
<span class="LiteralGray">    if -350&lt;x&lt;350 and -300&lt;y&lt;300:</span>
<span class="LiteralGray">        col = int((x+450)//100)</span>
<span class="LiteralGray">    else:</span>
<span class="LiteralGray">        print('You have clicked outside the game board!')</span>
    # Check if it's a valid move
    if col in validinputs:
<span class="LiteralGray">        # Calculate the lowest available row number in that column</span>
<span class="LiteralGray">        row = len(occupied[col-1])+1</span>
<var>--snip--</var>
<span class="LiteralGray">        # Go to the cell and place a dot of the player's color</span>
<span class="LiteralGray">        t.up()</span>
<span class="LiteralGray">        t.goto(xs[col-1],ys[row-1])</span>
<span class="LiteralGray">        t.dot(80,turn)</span>
<span class="LiteralGray">        t.update()</span>
<span class="LiteralGray">        # Add the move to the occupied list to keep track</span>
<span class="LiteralGray">        occupied[col-1].append(turn)</span>
# Check if the player has won
      <span class="CodeAnnotationCode" aria-label="annotation3">3</span> if win_game(col, row, turn) == True:
            # If a player wins, invalid all moves, end the game
            validinputs = []
            messagebox.showinfo\
           ("End Game",f"Congrats player {turn}, you won!")
        # If all cells are occupied and no winner, it's a tie
        elif rounds == 42:
            messagebox.showinfo("Tie Game","Game over, it's a tie!")
        # Counting rounds
        rounds += 1
        
        # Update the list of valid moves
      <span class="CodeAnnotationCode" aria-label="annotation4">4</span> if len(occupied[col-1]) == 6:
<span epub:type="pagebreak" title="218" id="Page_218"/>            validinputs.remove(col)
<span class="LiteralGray">        # Give the turn to the other player</span>
<span class="LiteralGray">        if turn == "red":</span>
<span class="LiteralGray">            turn = "yellow"</span>
<span class="LiteralGray">        else:</span>
<span class="LiteralGray">            turn = "red"     </span>
    # If col is not a valid move, show error message
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> else:
        messagebox.showerror("Error","Sorry, that's an invalid move!")

<span class="LiteralGray"># Bind the mouse click to the conn() function</span>
<span class="LiteralGray">t.onscreenclick(conn)</span>
<span class="LiteralGray">t.listen()</span>
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing11-5">Listing 11-5</a>: Second half of the script to disallow invalid moves and declare wins and ties</p>
<p>At <span class="CodeAnnotation" aria-label="annotation1">1</span>, we create the variable <code>rounds</code><em> </em>to keep track of the number of rounds played, corresponding to the number of discs on the game board, so that we can declare a tie when the number reaches 42. </p>
<p>We change <code>conn()</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> to declare three global variables so that their values can be recognized both inside and outside the function. At <span class="CodeAnnotation" aria-label="annotation3">3</span>, we call <code>win_game()</code> to see whether anyone has won. If yes, we change <code>validinputs</code> to an empty list so no further moves can be made. A message box will pop up that says <code>Congrats player red, you won!</code> or <code>Congrats player yellow, you won!</code> </p>
<p><a href="#figure11-3" id="figureanchor11-3">Figure 11-3</a> shows the red player winning a game.</p>
<figure>
<img src="Images/f11003.png" alt="f11003" width="536" height="483"/>
<figcaption><p><a id="figure11-3">Figure 11-3</a>: Red wins! The darker discs are red, and the lighter are yellow.</p></figcaption>
</figure>
<p>If no one has won but <code>rounds</code> reaches 42, the script declares a tie game (<a href="#figure11-4" id="figureanchor11-4">Figure 11-4</a>). </p>
<span epub:type="pagebreak" title="219" id="Page_219"/><figure>
<img src="Images/f11004.png" alt="f11004" width="531" height="477"/>
<figcaption><p><a id="figure11-4">Figure 11-4</a>: A tied game </p></figcaption>
</figure>
<p>If no player has won or the game is not tied, we increase the value of <code>rounds</code> by one and assign the turn to the other player. We also update the list of valid moves. If the number of discs in the current column reaches six, we remove the column number from the list <code>validinputs</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>.</p>
<p>During the game, if a player clicks an invalid cell <span class="CodeAnnotation" aria-label="annotation5">5</span>, a message box will say <code>Sorry, that's an invalid move!</code> (<a href="#figure11-5" id="figureanchor11-5">Figure 11-5</a>).</p>
<figure>
<img src="Images/f11005.png" alt="f11005" width="522" height="469"/>
<figcaption><p><a id="figure11-5">Figure 11-5</a>: An invalid move</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><span epub:type="pagebreak" title="220" id="Page_220"/>Try it Out</h2>
<p class="BoxBodyFirst">Run <em>conn_click.py</em> and play a few games against yourself. Try to generate the following three instances: you make an invalid move, player yellow wins the game, and the game is tied.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501560c11-0005">	The Voice-Controlled Version</h2>
<p class="BodyFirst">Now we’re ready to add the voice control functionality! </p>
<p>First, we’ll set the computer as your opponent in the game. After you make a move as the red player, the computer will randomly select a yellow move until the game ends. Once you understand how playing against a computer works, a voice-controlled game in which you play against another person is really simple. I’ll leave that as an end-of-chapter exercise, and the script is provided at the book’s resources website. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	We discuss only the one-player version in which you always move first to save space and to focus on creating a voice-controlled Connect Four. In our ultimate VPA in <span class="xref" itemid="xref_target_Chapter 17">Chapter 17</span>, you’ll see a generalized version of the game in which you can choose to play against a computer or a human and whether you move first or second.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Download <em>conn_hs.py</em> from the book’s resources and save it in your chapter folder. <a href="#listing11-6" id="listinganchor11-6">Listing 11-6</a> highlights the differences between <em>conn_hs.py</em> and <em>conn_click.py</em>.</p>
<pre><code><span class="LiteralGray">import turtle as t</span>
<span class="LiteralGray">from time import sleep</span>
<span class="LiteralGray">from tkinter import messagebox</span>
from random import choice

# Import functions from the local package
from mptpkg import voice_to_text, print_say

<span class="LiteralGray"># Set up the screen</span>
<var>--snip--</var>
# Create a list of valid moves
validinputs = ['1','2','3','4','5','6','7']
<var>--snip--</var>
# Add a dictionary of words to replace
to_replace = {'number ':'', 'cell ':'',
              'one':'1', 'two':'2', 'three':'3',
              'four':'4', 'for':'4', 'five':'5',
              'six':'6', 'seven':'7'}
# Start an infinite loop to take voice inputs
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> while True:
    # Ask for your move
<span epub:type="pagebreak" title="221" id="Page_221"/>    print_say(f"Player {turn}, what's your move?")
    # Capture your voice input
    inp = voice_to_text().lower()
    print_say(f"You said {inp}.")
    for x in list(to_replace.keys()):   
        inp = inp.replace(x, to_replace[x])
    # If it is not a valid move, try again
    if inp not in validinputs:
        print_say("Sorry, that's an invalid move!")    
    # If your voice input is a valid move, play the move
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> else:
        col = int(inp)
<span class="LiteralGray">        # Calculate the lowest available row number in that column</span>
<span class="LiteralGray">        row = len(occupied[col-1])+1</span>
<span class="LiteralGray">        # Show the disc fall from the top</span>
<span class="LiteralGray">        if row&lt;6:</span>
<span class="LiteralGray">            for i in range(6,row,-1):</span>
<span class="LiteralGray">                fall.goto(xs[col-1],ys[i-1])</span>
<span class="LiteralGray">                fall.dot(80,turn)</span>
<span class="LiteralGray">                t.update()</span>
<span class="LiteralGray">                sleep(0.05)</span>
<span class="LiteralGray">                fall.clear()</span>
<span class="LiteralGray">        # Go to the cell and place a dot of the player's color</span>
<span class="LiteralGray">        t.up()</span>
<span class="LiteralGray">        t.goto(xs[col-1],ys[row-1])</span>
<span class="LiteralGray">        t.dot(80,turn)</span>
<span class="LiteralGray">        t.update()</span>
<span class="LiteralGray">        # Add the move to the occupied list to keep track</span>
<span class="LiteralGray">        occupied[col-1].append(turn)</span>

<span class="LiteralGray">        # Check if the player has won</span>
<span class="LiteralGray">        if win_game(col, row, turn) == True:</span>
<span class="LiteralGray">            # If a player wins, invalid all moves, end the game</span>
<span class="LiteralGray">            validinputs = []</span>
          <span class="CodeAnnotationCode" aria-label="annotation3">3</span> print_say(f"Congrats player {turn}, you won!")
<span class="LiteralGray">            messagebox.showinfo/</span>
<span class="LiteralGray">            ("End Game",f"Congrats player {turn}, you won!")</span>
<span class="LiteralGray">            break</span>
<span class="LiteralGray">        # If all cells are occupied and no winner, it's a tie</span>
<span class="LiteralGray">        elif rounds == 42:</span>
            print_say("Game over, it's a tie!")
<span class="LiteralGray">            messagebox.showinfo("Tie Game","Game over, it's a tie!")</span>
<span class="LiteralGray">            break</span>
<span class="LiteralGray">        # Counting rounds</span>
<span class="LiteralGray">        rounds += 1</span>
<span class="LiteralGray">        # Update the list of valid moves</span>
        if len(occupied[col-1]) == 6:
            validinputs.remove(str(col)) 
<span class="LiteralGray">        # Give the turn to the other player</span>
<span class="LiteralGray">        if turn == "red":</span>
<span class="LiteralGray">            turn = "yellow"</span>
<span class="LiteralGray">        else:</span>
<span class="LiteralGray">            turn = "red" </span>
<span epub:type="pagebreak" title="222" id="Page_222"/>        # The computer randomly selects a move
      <span class="CodeAnnotationCode" aria-label="annotation4">4</span> if len(validinputs)&gt;0:
            col = int(choice(validinputs))
        print_say(f'The computer chooses column {col}.')
        # Calculate the lowest available row number in that column
        row = len(occupied[col-1])+1
        # Show the disc fall from the top
        if row &lt; 6:
            for i in range(6,row,-1):
                fall.goto(xs[col-1],ys[i-1])
                fall.dot(80,turn)
                update()
                sleep(0.05)
                fall.clear()
        # Go to the cell and place a dot of the player's color
        t.up()
        t.goto(xs[col-1],ys[row-1])
        t.dot(80,turn)
        t.update()
        # Add the move to the occupied list to keep track
        occupied[col-1].append(turn)

        # Check if the player has won
        if win_game(col, row, turn) == True:
            # If a player wins, invalid all moves, end the game
            validinputs = []
          <span class="CodeAnnotationCode" aria-label="annotation5">5</span> print_say(f"Congrats player {turn}, you won!")
            messagebox.showinfo\
            ("End Game",f"Congrats player {turn}, you won!")
            break
        # If all cells are occupied and no winner, it's a tie
        elif rounds == 42:
            print_say("Game over, it's a tie!")
            messagebox.showinfo("Tie Game","Game over, it's a tie!")
            break
        # Counting rounds
        rounds += 1
        # Update the list of valid moves
        if len(occupied[col-1])==6:
            validinputs.remove(str(col))
        # Give the turn to the other player
        if turn == "red":
            turn = "yellow"
        else:
            turn = "red" 
<span class="LiteralGray">t.done()</span>
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing11-6">Listing 11-6</a>: Script highlights for the voice-controlled Connect Four game</p>
<p>We import a few extra modules. The <code>choice()</code> function from the <em>random</em> module lets the computer randomly select a move to play against you. We also import our local <code>print_say()</code> and <code>voice_to_text()</code> functions from the local package <em>mptpkg</em> to handle the voice-control functionality.</p>
<p><span epub:type="pagebreak" title="223" id="Page_223"/>This time, we’ll use string values instead of integers to represent the seven column numbers in the list <code>validinputs</code>, because voice inputs are naturally string variables and, in many cases, attempting to convert voice inputs to integers will crash the script.</p>
<p>At <span class="CodeAnnotation" aria-label="annotation1">1</span>, we start an infinite <code>while</code> loop. At each iteration, the script asks for your move out loud. You speak into the microphone to make your move, and the script captures your voice command and stores it in <code>inp</code>. </p>
<p>Here we did a little tweaking to make <code>voice_to_text()</code> more responsive to your voice commands, as we did in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span> (see <a href="c10.xhtml#listing10-6" id="listinganchor10-6">Listing 10-6</a> as a reminder). Further, the script always interprets <em>number four</em> as <code>number for</code>, so we replace <code>for</code> with <code>4</code> to get a better response from the script.</p>
<p>If your voice command is not in <code>validinputs</code>, the script reminds you out loud: “Sorry, that’s an invalid move!” I’ve moved up the invalid voice input so that the <code>if</code> and <code>else</code> branches are close together in the script, making it easy for you to understand the logic. If the two branches are far apart, it’s easy to get lost in the long lines of code.</p>
<p>If your voice command is a valid move <span class="CodeAnnotation" aria-label="annotation2">2</span>, the script will place the disc as directed, let the disc fall to the lowest available space in the column, add the cell number to your list of occupied cells, remove the cell number from the list of valid inputs, and so on. </p>
<p>The script then checks whether you won the game and, if you have, congratulates you out loud <span class="CodeAnnotation" aria-label="annotation3">3</span>. If not, it will check for a tie and announce accordingly. </p>
<p>When your turn is over, and if you haven’t won or tied the game, the computer randomly selects a move from <code>validinputs</code> to play against you <span class="CodeAnnotation" aria-label="annotation4">4</span>, make the move, and check whether the computer has won the game <span class="CodeAnnotation" aria-label="annotation5">5</span>. It will also check for a tie.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">WARNING</span></h2>
<p>	You need a decent internet connection for the script to work properly. Further, avoid saying a single number as the voice input. Instead, start with “number” so that the script can put your voice command in context. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Here’s the printed message from one interaction with the game:</p>
<pre><code>Player red, what's your move?
You said number four.
The computer chooses column 2.
Player red, what's your move?
You said number four.
The computer chooses column 2.
Player red, what's your move?
You said number four.
The computer chooses column 2.
Player red, what's your move?
You said number four.
Congrats player red, you won! </code></pre>
<p><a href="#figure11-6" id="figureanchor11-6">Figure 11-6</a> shows my winning game.</p>
<span epub:type="pagebreak" title="224" id="Page_224"/><figure>
<img src="Images/f11006.png" alt="f11006" width="507" height="458"/>
<figcaption><p><a id="figure11-6">Figure 11-6</a>:  Red winning the voice-controlled version</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Try it Out</h2>
<p class="BoxBodyFirst">Run <em>conn_hs.py</em> and play a complete game with the computer. See if you can make the script understand your every voice command on the first try.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501560c11-0006">	Summary</h2>
<p class="BodyFirst">In this chapter, you created a voice-controlled graphical Connect Four game that talks back to you in a human voice. You set up the game board and mechanisms as you did in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>, but this time animated the moves. </p>
<p>You learned how to let Python determine whether a player has won the game. In the process, you learned to lay out all cases of winning and use the script to check each one. You also learned how to properly use exception handling and prevent negative indexing from causing mistakes in your script.</p>
<p>You added the voice recognition and text-to-speech features, but also did a bit of refactoring to make sure your code stayed user readable as you added to it. In the next couple of chapters, you’ll create more voice-controlled graphical games and make them intelligent.</p>
<h2 id="h1-501560c11-0007"><span epub:type="pagebreak" title="225" id="Page_225"/>	End-of-Chapter Exercises</h2>
<ol class="decimal">
<li value="1">Modify <em>conn_board.py</em> so that six row numbers appear at the right of the screen, with the top row being 6 and the bottom row being 1. Make the x-coordinates of the row numbers 325.</li>
<li value="2">Modify <em>disc_fall.py</em> so that the discs fall at twice the speed.</li>
<li value="3">Modify <em>conn_click.py</em> so that a player wins only by connecting four discs of the same color horizontally or diagonally, and not vertically. </li>
<li value="4">Currently, when you play Connect Four using the final <em>conn_hs.py</em>, you can say either “number four” or “four” if you want to place a disc in column 4. Modify the script so that you can also say “column four” to place a disc in that column. </li>
<li value="5">Modify <em>conn_hs.py</em> so that you play against a person instead of the computer. </li>
</ol>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="227" id="Page_227"/>12</span><br/>
<span class="ChapterTitle">Guess-the-Word Game</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="200" height="200"/>
</figure>
<p class="ChapterIntro">In this chapter, you’ll build a voice-controlled graphical guess-the-word game. This is an interesting challenge because when playing guess-the-word, players often talk quickly, so we’ll need to fine-tune our script’s listening abilities. </p>
<p>As usual, we’ll go over the game rules and draw a game board; this game board uses six coins to represent your six guesses. You’ll learn how to load a picture to a Python script and create multiple images of it onscreen. You’ll also learn to make the images disappear one by one. </p>
<p>We’ll start the game by using written inputs. Then, when we have it working well, we’ll add the speech recognition and text-to-speech features. </p>
<p>All scripts in this chapter are available on the book’s resources page at <a href="https://www.nostarch.com/make-python-talk/" class="LinkURL">https://www.nostarch.com/make-python-talk/</a>. Start by creating the folder <em>/mpt/ch12/</em> for this chapter. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><span epub:type="pagebreak" title="228" id="Page_228"/>New Skills</h2>
<ul>
<li>Loading a picture file into a script and manipulating it</li>
<li>Creating multiple images from the same file</li>
<li>Drawing messages and shapes on a turtle screen </li>
<li>Coding a new set of rules </li>
</ul>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501560c12-0001">	Game Rules</h2>
<p class="BodyFirst">Our guess-the-word game is loosely based on the hangman game. Our game will present only four-letter words to keep it simple, but you should try adapting it later when you’re comfortable with how it all works. Let’s go over the rules of the game first.</p>
<p>Similar to hangman, our guess-the-word game involves two players. The first player thinks of a word and draws a number of dashes equal to the number of letters in the word. The first player also draws six coins in the middle of the screen to represent the six incorrect guesses the second player will be allowed. </p>
<p>The second player tries to figure out the word by guessing one letter at a time. If the suggested letter is in the word, the first player fills in the blanks with the letter in the right places. If a suggested letter is not in the word, the first player erases a coin in the middle of the screen. If the second player completes the word before making six incorrect guesses, they win the game. If that player fails to identify the word before using up their six wrong guesses, they lose.</p>
<h2 id="h1-501560c12-0002">	Draw the Game Board </h2>
<p class="BodyFirst">Our game board will preload with four dashes to represent the word. We’ll also include the message <code>incorrect guesses</code> onscreen. Open your Spyder editor and enter the code in <a href="#listing12-1" id="listinganchor12-1">Listing 12-1</a>, saving it as <em>guess_word_board.py</em>.</p>
<pre><code>import turtle as t

# Set up the board
t.setup(600,500)
t.hideturtle()
t.tracer(False)
t.bgcolor("lavender")
t.title("Guess the Word Game in Turtle Graphics")
# Define a variable to count how many guesses left
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> score = 6
# Create a second turtle to show guesses left
left = t.Turtle()
left.up()
left.hideturtle()
left.goto(-290,200)
left.write(f"guesses left:   {score}",font=('Arial',20,'normal'))
<span epub:type="pagebreak" title="229" id="Page_229"/># Put incorrect guesses on top
t.up()
t.goto(-290,150)
t.write("incorrect guesses:",font=('Arial',20,'normal'))
# Put four empty spaces for the four letters at bottom
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> for x in range(4):
    t.goto(-275+150*x,-200)
    t.down()
    t.goto(-175+150*x,-200)
    t.up()
t.done()
try:
    t.bye()
except t.Terminator:
    print('exit turtle')</code></pre>
<p class="CodeListingCaption"><a id="listing12-1">Listing 12-1</a>: Python script to draw the guess-the-word game board</p>
<p>We import the <em>turtle</em> module and set up the screen to be 600 by 500 pixels with a lavender background. The title will read <code>Guess the Word Game in Turtle Graphics</code>. Note that we omitted the last two arguments in <code>setup()</code>, so the game board will appear at the center of your computer screen by default. </p>
<p>At <span class="CodeAnnotation" aria-label="annotation1">1</span>, we create a variable <code>score</code> to keep track of the number of guesses the player has left. It starts with a value of 6. Later in the game, every time the player guesses an incorrect letter, the value will decrease by 1. We also create a new turtle named <code>left</code>, representing the number of guesses remaining. We use the new turtle to write the number of chances the player has left, erasing whatever was there before. By using a new turtle, we limit the number of objects we need to redraw onscreen. </p>
<p>We then add the text <code>incorrect guesses</code>, which will later show the incorrect letters the player guessed. We draw four dashes at the bottom of the board <span class="CodeAnnotation" aria-label="annotation3">3</span> to hold the four letters in the word. Run the script and you should see a board similar to <a href="#figure12-1" id="figureanchor12-1">Figure 12-1</a>.</p>
<figure>
<img src="Images/f12001.png" alt="f12001" width="438" height="387"/>
<figcaption><p><a id="figure12-1">Figure 12-1</a>: The board for the guess-the-word game</p></figcaption>
</figure>
<h2 id="h1-501560c12-0003"><span epub:type="pagebreak" title="230" id="Page_230"/>	The Text Version</h2>
<p class="BodyFirst">In this section, you’ll place the six coins on the screen and enable the player to enter letters with the keyboard. You’ll then determine whether a player has won or lost the game. This completes the silent version of guess-the-word.</p>
<h3 id="h2-501560c12-0001">Load the Coins</h3>
<p class="BodyFirst">You’ll place six coins at the center of the screen. In the process, you’ll learn how to load a picture to the script, resize it to any shape you like, and place as many objects on the turtle screen as you like. As noted, each coin corresponds to one incorrect guess. </p>
<p>Download the picture file <em>cash.png</em> from the book’s resources and place it in your chapter folder. Open <em>guess_word_board.py</em>, add the highlighted code in <a href="#listing12-2" id="listinganchor12-2">Listing 12-2</a>, and save the new script as <em>show_coins.py</em> in the same chapter folder containing <em>cash.png</em>. </p>
<pre><code><var>--snip--</var>
from tkinter import PhotoImage
from time import sleep
<var>--snip--</var>
<span class="LiteralGray"># Put four empty spaces for the four letters at bottom</span>
<span class="LiteralGray">for x in range(4):</span>
<span class="LiteralGray">    t.goto(-275+150*x,-200)</span>
<span class="LiteralGray">    t.down()</span>
<span class="LiteralGray">    t.goto(-175+150*x,-200)   </span>
<span class="LiteralGray">    t.up()</span>
# Load a picture of the coin to the script
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> coin = PhotoImage(file="cash.png").subsample(10,10)
t.addshape("coin", t.Shape("image", coin))
# Create six coins on screen 
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> coins = [0]*6
for i in range(6):
    coins[i] = t.Turtle('coin')
    coins[i].up()
    coins[i].goto(-100+50*i,0)
t.update()
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> sleep(3)
# Make the coins disappear one at a time
for i in range(6):
    coins[-(i+1)].hideturtle()
    t.update()
    sleep(1)
<span class="LiteralGray">t.done()</span>
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing12-2">Listing 12-2</a>: Script to show and remove coins</p>
<p>We import the <code>PhotoImage()</code> class from the <em>tkinter </em>module and the <code>sleep()</code> function from the <em>time </em>module. We then load <em>cash.png</em> by using <code>PhotoImage()</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. We use <code>subsample()</code> to scale the image to the size we want. In this case, we use scale factors of <code>(10,10)</code>, which means that both the width and the height of the picture are one-tenth that of the original picture. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="231" id="Page_231"/><h2><span class="NoteHead">NOTE</span></h2>
<p>	To scale up the size of the image onscreen, you can use the <code>zoom()</code> method in the <code>PhotoImage()</code> class from <em>tkinter</em>. For example, <code>zoom(</code><code>2</code><code>,</code><code>3</code><code>)</code> will double the width and triple the height of the original picture.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>At <span class="CodeAnnotation" aria-label="annotation2">2</span>, we create a list <code>coins</code> with six elements by using <code>[0]*6</code>. If you print out the list, it will look like this:</p>
<pre><code>[0, 0, 0, 0, 0, 0]</code></pre>
<p>We’ll change the elements later; the <code>0</code> values are just placeholders. </p>
<p>Next, we create a new turtle in each element in <code>coins</code>. We then make the coin turtles go to the center of the screen and line up horizontally. To demonstrate how to load and then hide the coins, we have them stay onscreen for three seconds <span class="CodeAnnotation" aria-label="annotation3">3</span> before using <code>hideturtle()</code> from the <em>turtle</em> module to make them disappear from the screen one at a time, starting with the last one.</p>
<p><a href="#figure12-2" id="figureanchor12-2">Figure 12-2</a> shows the screen in the first three seconds, as the coins are lined up.</p>
<figure>
<img src="Images/f12002.png" alt="f12002" width="416" height="367"/>
<figcaption><p><a id="figure12-2">Figure 12-2</a>: Showing coins on the guess-the-word game board</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Try it Out</h2>
<p class="BoxBodyFirst">Run <em>show_coins</em><em>.py</em> and see the output screen. Once you confirm it’s working, change <code>tracer(False)</code> to <code>tracer(True)</code> in the script and rerun it. You should be able to see the six coins placed onscreen one by one. After that, change <code>tracer(True)</code> back to <code>tracer(False)</code> before continuing to the next subsection. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-501560c12-0002">Guess the Letters</h3>
<p class="BodyFirst">The next version of the game will use 15 four-letter words, picked from a list of the most commonly used four-letter words according to Professor Barry Keating’s website at the University of Notre Dame (<em>https://bit.ly/3g7z7cg</em>). <span epub:type="pagebreak" title="232" id="Page_232"/>Keating has done extensive work in the fields of business forecasting and data mining. He is also the coauthor of the popular textbook <em>Forecasting and Predictive Analytics </em>(McGraw Hill, 2018). </p>
<p>After we make the following modifications, the script will randomly choose one word, ask you to guess a letter, and then accept input from the IPython console. If a guess is right, the letter will show up on one of the dashes corresponding to the position of the letter in the word. In the rare case that the letter appears in the word twice, the letter will show up on two of the dashes. If the letter is not in the word, it will show up at the top of the screen in the list of incorrect guesses. We’ll skip placing the coins in this script to make testing of the code easier to follow.</p>
<p>Open <em>guess_word_board.py</em>, add the highlighted code in <a href="#listing12-3" id="listinganchor12-3">Listing 12-3</a>, and save the new script as <em>guess_letter.py</em>. </p>
<pre><code><span class="LiteralGray">import turtle as t</span>
from random import choice
<var>--snip--</var>
<span class="LiteralGray"># Put four empty spaces for the four letters at bottom</span>
<span class="LiteralGray">for x in range(4):</span>
<span class="LiteralGray">    t.goto(-275+150*x,-200)</span>
<span class="LiteralGray">    t.down()</span>
<span class="LiteralGray">    t.goto(-175+150*x,-200)</span>
<span class="LiteralGray">    t.up()</span>
t.update()
# Put words in a dictionary and randomly pick one
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> words = ['that', 'with', 'have', 'this', 'will', 'your', 
   'from', 'they', 'know', 'want', 'been', 
   'good', 'much', 'some', 'time']
word = choice(words)
# Create a missed list
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> missed = []
# Start the game loop
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> while True:
    # Take written input 
    inp = input("What's your guess?\n").lower()
    # Stop the loop if you key in "done"
    if inp == "done":
        break
    # Check if the letter is in the word
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> elif inp in list(word):
        # If yes, put it in the right position(s)
        for w in range(4):
            if inp == list(word)[w]:
                t.goto(-250+150*w,-190)
                t.write(inp,font=('Arial',60,'normal'))
    # If the letter is not in the word, show it at the top
  <span class="CodeAnnotationCode" aria-label="annotation5">5</span> else:
        missed.append(inp)
        t.goto(-290+80*len(missed),60)
        t.write(inp,font=('Arial',60,'normal'))
    # Update everything that happens in the iteration
    t.update()
<span class="LiteralGray">try:</span>
<span epub:type="pagebreak" title="233" id="Page_233"/><span class="LiteralGray">    t.bye()</span>
<span class="LiteralGray">except t.Terminator:</span>
<span class="LiteralGray">    print('exit turtle')</span></code></pre>
<p class="CodeListingCaption"><a id="listing12-3">Listing 12-3</a>: Script to put letters on the game board</p>
<p>We first import <code>choice()</code> from the <em>random</em> module so the script can randomly pick a word from the list. We put the 15 words in the list <code>words</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> and allocate the randomly selected word to <code>word</code>. At <span class="CodeAnnotation" aria-label="annotation2">2</span>, we create the list <code>missed</code> to hold all incorrectly guessed letters. We then put the script in an infinite loop<em> </em><span class="CodeAnnotation" aria-label="annotation3">3</span> to continuously take your text input. If you want to stop the loop, you can enter <code>done</code> in the Spyder IPython console. </p>
<p>At <span class="CodeAnnotation" aria-label="annotation4">4</span>, we check whether the letter you guess is in one of the letters in <code>word</code>. We use <code>list()</code>, which takes a string variable as input and breaks it into a list of individual letters; for example, the command <code>list("have")</code> produces the list <code>["h","a","v","e"]</code>. </p>
<p>If your guessed letter is in <code>word</code>, the function checks every letter in <code>word</code> to see if your guess matches the letter in that position. If so, the function writes the letter on the corresponding position onscreen. </p>
<p>If your guess is not in <code>word</code> <span class="CodeAnnotation" aria-label="annotation5">5</span>, the letter is added to <code>missed</code> and is written at the top of the screen in the <code>incorrect guesses</code> section.</p>
<p>Note that we also removed the line <code>t.done()</code> in this script. This means that, once you finish guessing and enter <code>done</code>, the script will end and everything will disappear from your screen.</p>
<p>Here’s the output from one exchange with the script, when the script randomly selected the word <em>have</em> from the list of the 15 words, with my typed input in bold:</p>
<pre><code>What's your guess?
<b>a</b>
What's your guess?
<b>b</b>
What's your guess?
<b>v</b>
What's your guess?
<b>v</b>
What's your guess?
<b>b</b>
What's your guess?
<b>h</b>
What's your guess?
<b>e</b>
What's your guess?
<b>f</b>
What's your guess?
<b>g</b>
What's your guess?
<b>h</b>
What's your guess?
<b>u</b>
What's your guess?
<b>done</b></code></pre>
<p><span epub:type="pagebreak" title="234" id="Page_234"/><a href="#figure12-3" id="figureanchor12-3">Figure 12-3</a> shows the resultant screen.</p>
<figure>
<img src="Images/f12003.png" alt="f12003" width="478" height="424"/>
<figcaption><p><a id="figure12-3">Figure 12-3</a>: A guess-the-word game board with letters on it</p></figcaption>
</figure>
<p>It’s working, but you may have noticed that some things need improvement. To have a complete version of guess-the-word, we need the script to do the following:</p>
<ol class="decimal">
<li value="1">Prevent the players from guessing the same letter more than once. In my preceding interaction, I guessed <em>b</em>, <em>v</em>, and <em>h</em> twice, wasting my guesses.</li>
<li value="2">Notify the players when a word is complete.</li>
<li value="3">Stop taking input after a player completes the word. </li>
<li value="4">Put the six coins onscreen and remove one every time a player misses a letter.</li>
</ol>
<h3 id="h2-501560c12-0003">Determine Valid Guesses, Wins, and Losses</h3>
<p class="BodyFirst">Next, we’ll disallow duplicate-letter guesses, declare a win if you complete the word while missing fewer than six letters, and declare a loss if not. </p>
<p>Open <em>guess_letter.py</em> and add the highlighted parts in <a href="#listing12-4" id="listinganchor12-4">Listing 12-4</a>. Then save the new script as <em>guess_word.py</em>. A block of code in <em>guess_letter.py</em> is modified and replaced by the newly added blocks. If you’re uncertain what’s different, download the script <em>guess_word.py</em> from the book’s resources page.</p>
<pre><code><span class="LiteralGray">import turtle as t</span>
<span class="LiteralGray">from random import choice</span>
from tkinter import messagebox
from tkinter import PhotoImage

<var>--snip--</var>
<span class="LiteralGray"># Create a missed list</span>
<span epub:type="pagebreak" title="235" id="Page_235"/><span class="LiteralGray">missed = []</span>
# Load a picture of the coin to the script
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> coin = PhotoImage(file = "cash.png").subsample(10,10)
t.addshape("coin", t.Shape("image", coin))
# Create six coins on screen 
coins = [0]*6
for i in range(6):
    coins[i] = t.Turtle('coin')
    coins[i].up()
    coins[i].goto(-100+50*i,0)
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> t.update()
# Prepare the validinputs and gotright lists
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> validinputs = list('abcdefghijklmnopqrstuvwxyz')
gotright = []
<span class="LiteralGray"># Start the game loop</span>
<span class="LiteralGray">while True:</span>
<span class="LiteralGray">    # Take written input </span>
<span class="LiteralGray">    inp = input("What's your guess?\n").lower()</span>
<span class="LiteralGray">    # Stop the loop if you key in "done"</span>
<span class="LiteralGray">    if inp == "done":</span>
<span class="LiteralGray">        break</span>
    # If the letter is not a valid input, remind
    elif inp not in validinputs:
        messagebox.showerror("Error","Sorry, that's an invalid input!")
    # Otherwise, go ahead with the game
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> else:
        # Check if the letter is in the word
        if inp in list(word):
            # If yes, put it in the right position(s)
            for w in range(4):
                if inp == list(word)[w]:
                    t.goto(-250+150*w,-190)
                    t.write(inp,font = ('Arial',60,'normal'))
                    gotright.append(inp)
            # If got four positions right, the player wins
            if len(gotright) == 4:
                messagebox.showinfo\
                ("End Game","Great job, you got the word right!")
                break
        # If the letter is not in the word, show it at the top
      <span class="CodeAnnotationCode" aria-label="annotation5">5</span> else:
            # Reduce guesses left by 1
            score -=  1
            # Remove a coin
            coins[-(6-score)].hideturtle()
            # Update the number of guesses left on board
            left.clear()
            left.write\
            (f"guesses left:   {score}",font = ('Arial',20,'normal'))
            t.update()            
            missed.append(inp)
            t.goto(-290+80*len(missed),60)
            t.write(inp,font = ('Arial',60,'normal'))
            if len(missed) == 6:
                # If all six chances are used up, end game
<span epub:type="pagebreak" title="236" id="Page_236"/>                messagebox.showinfo\
                ("End Game","Sorry, you used up all your six guesses!")
                break 
        # Remove the letter from the validinputs list
        validinputs.remove(inp)       
<span class="LiteralGray">    # Update everything that happens in the iteration</span>
<span class="LiteralGray">    t.update()</span>
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing12-4">Listing 12-4</a>: A graphical guess-the-word game that takes written input</p>
<p>We import the <em>messagebox</em> module from the <em>tkinter</em> Python package again so we can display messages to the game screen.</p>
<p>Starting at <span class="CodeAnnotation" aria-label="annotation1">1</span>, we display the six coins onscreen. We update the screen so that everything we put there shows up properly <span class="CodeAnnotation" aria-label="annotation2">2</span>. </p>
<p>At <span class="CodeAnnotation" aria-label="annotation3">3</span>, we create the list <code>validinputs</code>, which has the 26 letters in the alphabet as elements. Later in the script, if the player guesses a letter, we’ll remove the letter from the list so that the same letter can’t be guessed more than once. We also create the empty list <code>gotright</code>. Later we’ll use it to keep track of how many positions the player has guessed right in the word. </p>
<p>We start an infinite <code>while</code> loop that asks for your keyboard input in every iteration. If you enter <code>done</code>, the loop stops, and the script quits taking input from you. If you enter invalid input (either a non-letter or a letter you’ve already guessed), the script will show a message box indicating <code>Sorry, that's an invalid input!</code></p>
<p>If you enter valid input <span class="CodeAnnotation" aria-label="annotation4">4</span>, the script checks whether the letter is in the word. If yes, the script checks each of the four positions in the word and, for each match, adds the letter to the list <code>gotright</code>. Note that since the same letter can appear in a word more than once, a letter may be added to the list <code>gotright</code> more than once. </p>
<p>The script then checks whether <code>gotright</code> has four elements. If yes, it means all four letters have been correctly guessed, and a message box will pop up with <code>Great job, you got the word right!</code> </p>
<p>If the guessed letter is not in the word <span class="CodeAnnotation" aria-label="annotation5">5</span>, the value of <code>score</code> is decreased by one, meaning the player has one less guess left. The script will remove a coin from the screen by using <code>hideturtle()</code>. The second turtle will erase whatever it has drawn on the screen and rewrite the number of guesses left. If the length of the list <code>missed</code> reaches six, a message box appears: <code>Sorry, you used up all your six guesses!</code> </p>
<p>Here’s one exchange with the script with the user input in bold:</p>
<pre><code>What's your guess?
<b>a</b>
What's your guess?
<b>o</b>
What's your guess?
<b>d</b>
What's your guess?
<b>c</b>
What's your guess?
<b>b</b>
<span epub:type="pagebreak" title="237" id="Page_237"/>What's your guess?
<b>k</b>
What's your guess?
<b>m</b></code></pre>
<p>My losing game is shown in <a href="#figure12-4" id="figureanchor12-4">Figure 12-4</a>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Since the word is randomly chosen from the 15 words, you won’t likely get the same output as mine even if you use the same guesses. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<figure>
<img src="Images/f12004.png" alt="f12004" width="473" height="418"/>
<figcaption><p><a id="figure12-4">Figure 12-4</a>: A losing game of guess-the-word</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Try it Out</h2>
<p class="BoxBodyFirst">Run <em>guess_word</em><em>.py</em> and play a few games, generating the following instances: you make an invalid move, you win the game by completing the word before missing six letters, and you fail to complete the word before missing six letters and hence lose the game.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501560c12-0004">	The Voice-Controlled Version</h2>
<p class="BodyFirst">Now we’ll build on the written-input version of the game to add speech functionality. Download <em>guess_word_hs.py</em> and save it in your chapter folder. The new code is highlighted in <a href="#listing12-5" id="listinganchor12-5">Listing 12-5</a>. </p>
<pre><code><var>--snip--</var>
# Import functions from the local package
from mptpkg import voice_to_text, print_say
<span epub:type="pagebreak" title="238" id="Page_238"/><var>--snip--</var>
<span class="LiteralGray"># Start the game loop</span>
<span class="CodeAnnotationHang" aria-label="annotation1">1</span><span class="LiteralGray"> while True:</span>
    # Ask for your move
    print_say("What's your guess?")
    # Capture your voice input
    inp = voice_to_text().lower()
    print_say(f"you said {inp}")
    inp = inp.replace('letter ','')
# Say "stop listening" or press CTRL-C to stop the game
    if inp == "stop listening":
        break
<span class="LiteralGray">    # If the letter is not a valid input, remind</span>
<span class="LiteralGray">    elif inp not in validinputs:</span>
        print_say("Sorry, that's an invalid input!")
<span class="LiteralGray">    # Otherwise, go ahead with the game</span>
<span class="LiteralGray">  </span><span class="CodeAnnotationCode" aria-label="annotation2">2</span><span class="LiteralGray"> else:  </span>
<span class="LiteralGray">        # Check if the letter is in the word</span>
<span class="LiteralGray">        if inp in list(word):</span>
<span class="LiteralGray">            # If yes, put it in the right position(s)</span>
<span class="LiteralGray">            for w in range(4):</span>
<span class="LiteralGray">                if inp == list(word)[w]:</span>
<span class="LiteralGray">                    t.goto(-250+150*w,-190)</span>
<span class="LiteralGray">                    t.write(inp,font = ('Arial',60,'normal'))</span>
<span class="LiteralGray">                    gotright.append(inp)</span>
<span class="LiteralGray">            # If got four positions right, the player wins</span>
<span class="LiteralGray">            if len(gotright) == 4:</span>
              <span class="CodeAnnotationCode" aria-label="annotation3">3</span> print_say("Great job, you got the word right!")
<span class="LiteralGray">                messagebox.showinfo\</span>
<span class="LiteralGray">                ("End Game","Great job, you got the word right!")</span>
<span class="LiteralGray">                break</span>
<span class="LiteralGray">        # If the letter is not in the word, show it at the top</span>
<span class="LiteralGray">        else:</span>
<span class="LiteralGray">            # Reduce guesses left by 1</span>
<span class="LiteralGray">            score -= 1</span>
<span class="LiteralGray">            # Remove a coin</span>
<span class="LiteralGray">            coins[-(6-score)].hideturtle()</span>
<span class="LiteralGray">            # Update the number of guesses left on board</span>
<span class="LiteralGray">            left.clear()</span>
<span class="LiteralGray">            left.write\</span>
<span class="LiteralGray">            (f"guesses left:   {score}",font = ('Arial',20,'normal'))</span>
<span class="LiteralGray">            t.update()            </span>
<span class="LiteralGray">            missed.append(inp)</span>
<span class="LiteralGray">            t.goto(-290+80*len(missed),60)</span>
<span class="LiteralGray">            t.write(inp,font = ('Arial',60,'normal'))</span>
<span class="LiteralGray">            if len(missed) == 6:</span>
<span class="LiteralGray">                # If all six changes are used up, end game</span>
              <span class="CodeAnnotationCode" aria-label="annotation4">4</span> print_say("Sorry, you used up all your six guesses!")
                messagebox.showinfo\
                ("End Game","Sorry, you used up all your six guesses!")
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing12-5">Listing 12-5</a>: A graphical guess-the-word game that takes voice input</p>
<p><span epub:type="pagebreak" title="239" id="Page_239"/>We import the usual functions from our local package <em>mptpkg</em>: <code>voice_to_text()</code> and <code>print_say()</code>. Because we installed the package (in editable mode), there’s no need to tell the system where to find it.</p>
<p>We start an infinite <code>while</code> loop that asks for your choice of letter in each iteration <span class="CodeAnnotation" aria-label="annotation1">1</span>. You speak your guess into the microphone, and the script captures your voice command and stores it in <code>inp</code>. We make allowances so the player can say either “letter a” or just “a.” If the former, we replace <em>letter</em> with an empty string so that only <code>a</code> is left in the variable <code>inp</code>.</p>
<p>To stop the <code>while</code> loop, you say, “Stop listening.” If your guess is not in the list <code>validinputs</code>, the script will answer, “Sorry, that’s an invalid input!” out loud. If your guess is in <code>validinputs</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, the script checks whether the letter is in the word. This time, when you complete the word without missing six times, the game will say, “Great job, you got the word right!” <span class="CodeAnnotation" aria-label="annotation3">3</span>. If you guess wrong six times, the voice will say, “Sorry, you used up your six guesses!” <span class="CodeAnnotation" aria-label="annotation4">4</span>. </p>
<p>Here’s an exchange with the script in which the player has successfully guessed the word <em>good</em>, missing only two letters: </p>
<pre><code>What's your choice?
you said letter a
What's your choice?
you said letter d
What's your choice?
you said letter f
What's your choice?
you said letter o
What's your choice?
you said letter g
Great job, you got the word right!</code></pre>
<p>You can see the screen in <a href="#figure12-5" id="figureanchor12-5">Figure 12-5</a>. </p>
<figure>
<img src="Images/f12005.png" alt="f12005" width="481" height="427"/>
<figcaption><p><a id="figure12-5">Figure 12-5</a>: Winning the voice-controlled guess-the-word game</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><span epub:type="pagebreak" title="240" id="Page_240"/>Try it Out</h2>
<p class="BoxBodyFirst">Run <em>guess_word</em><em>_hs.py</em> and try giving voice input in a few different ways to see what the script best understands.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501560c12-0005">	Summary</h2>
<p class="BodyFirst">In this chapter, you created a voice-controlled graphical guess-the-word game that talks back to you in a human voice.</p>
<p>You first learned how to draw the game board. You then learned to upload a picture file to the script and scale it to the size you want. You used the image to create six coins on the screen to represent monetary rewards and made them disappear from the screen one by one. You also learned how to type in your guess and have it show up onscreen. You learned how to disallow guessing the same letter twice and how to determine whether a player has won or lost the game.</p>
<p>You added the speech recognition and text-to-speech features so that the game can be voice controlled. Along the way, you learned how to create an image by manipulating a picture file in <em>turtle</em> and how to use multiple turtles to reduce the number of objects you have to redraw on the screen. </p>
<h2 id="h1-501560c12-0006">	End-of-Chapter Exercises</h2>
<ol class="decimal">
<li value="1">Modify <em>show_coins.py</em> so that the positions of the six coins are 10 pixels below their current positions vertically. Keep the positions of everything else the same. </li>
<li value="2">Modify <em>show_coins.py</em> so that the leftmost coin disappears from the screen first and the rightmost one is the last to disappear.</li>
<li value="3">Try to figure out what the following line of code will produce. First write down your answer and then run the code in Spyder to verify.
<pre><code>list('Hi Python')</code></pre></li>
</ol>
</section>
</div>
<div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="241" id="Page_241"/>13</span><br/>
<span class="ChapterTitle">Smart Games: Adding Intelligence </span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="200" height="200"/>
</figure>
<p class="ChapterIntro">In the one-player version of Connect Four we built in <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span>, the computer always randomly selects a move. This allowed us to focus on the game’s speech recognition and text-to-speech aspects.</p>
<p>However, once you play against the random computer for a few games, you start to wonder if there’s a way to make our Connect Four game more challenging. The answer is yes, and in this chapter, you’ll learn to make an intelligent Connect Four opponent. </p>
<p>In one approach, we’ll ask the script to think three steps ahead, as people do when playing a game: two moves by the computer and one by the player. </p>
<p>In the first step, the computer checks whether a move leads to winning the game right away. If yes, the computer will take it. </p>
<p>Thinking two steps ahead in Connect Four means the computer tries to prevent the opponent from winning in the next turn. This is complicated, because sometimes the computer must block a position and other times it must avoid taking a position. The computer will distinguish these <span epub:type="pagebreak" title="242" id="Page_242"/>two cases and block some moves and avoid others to prevent the opponent from winning. </p>
<p>By thinking three steps ahead, the computer will follow the path that most likely leads to a victory for the computer after three moves. In many scenarios, thinking three steps ahead can guarantee a win in three steps. In particular, if there is a move that guarantees the computer to win in three moves, the computer will select that as the best next move.</p>
<p>The second method uses an approach that could be classified as a type of <em>machine learning</em>. You’ll simulate a million games in which both players select random moves. You’ll then record the outcome and the intermediate steps. With this data, the computer will learn at each move and select the one most likely to lead to a winning outcome.</p>
<p>We’ll assess the effectiveness of the two strategies and choose the one that is more difficult to beat. We’ll then add speech recognition and text-to-speech features to the intelligent Connect Four. </p>
<p>Along the way, I’ll also challenge you to apply the same methods to the tic-tac-toe game in the <span class="xref" itemid="xref_target_“End-of-Chapter Exercises” on page 267">“End-of-Chapter Exercises” on page 267</span>. As always, all scripts are available at <a href="https://www.nostarch.com/make-python-talk/" class="LinkURL">https://www.nostarch.com/make-python-talk/</a>, and you should create the folder <em>/mpt/ch13/ </em>for this chapter. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>new skills</h2>
<ul>
<li>Getting your computer games to think one, two, and three steps ahead</li>
<li>Understanding the difference between <code>deepcopy</code> and assignment statements</li>
<li>Creating simulated games</li>
<li>Using basic machine-learning skills to create intelligent games</li>
<li>Using <em>pickle</em> to save and open data files</li>
<li>Testing the effectiveness of game strategies</li>
</ul>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501560c13-0001">	The Think-Three-Steps-Ahead Strategy</h2>
<p class="BodyFirst">We’ll first use the mouse-click version of Connect Four to speed up the testing of scripts. After we incorporate the strategy of thinking three steps ahead, we’ll add the speech features back.</p>
<h3 id="h2-501560c13-0001">Think One Step Ahead</h3>
<p class="BodyFirst">Thinking one step ahead in Connect Four is easy. The computer checks all possible next moves, and if one of them will lead to a win right away, the computer will take it. </p>
<p>Download <em>conn_think1.py</em> from the book’s resources and save it in your chapter folder. This is based on the script <em>conn_click.py</em> in <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span>, but I’ve altered the code so that you’re playing against an automated player that thinks one step ahead rather than another human player.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="243" id="Page_243"/><h2><span class="NoteHead">NOTE</span></h2>
<p>	In <span class="xref" itemid="xref_target_Chapter 17">Chapter 17</span>, you’ll learn how to choose your opponent: a human player, a simple automated player (computer) that chooses random moves, or an automated player that chooses smart moves.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><a href="#listing13-1" id="listinganchor13-1">Listing 13-1</a> highlights the key parts of <em>conn_think1.py</em>. </p>
<pre><code><var>--snip--</var>
from random import choice
from copy import deepcopy
<var>--snip--</var>
# Define a horizontal4() function to check connecting 4 horizontally
<span class="CodeAnnotationCode" aria-label="annotation1">1</span> def horizontal4(x, y, color, board):
    win = False
    for dif in (-3, -2, -1, 0):
        try:
            if board[x+dif][y] == color\
            and board[x+dif+1][y] == color\
            and board[x+dif+2][y] == color\
            and board[x+dif+3][y] == color\
            and  x+dif &gt;= 0:
                win = True
        except IndexError:
            pass
    return win     
# Define a vertical4() function to check connecting 4 vertically
def vertical4(x, y, color, board):
<var>--snip--</var>
# Define a win_game() function to check if someone wins the game
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> def win_game(num, color, board):
    win = False
    # Convert column and row numbers to indexes in the list of lists board
    x = num-1
    y = len(board[x])-1
    # Check all winning possibilities
    if vertical4(x, y, color, board) == True:
        win = True
    if horizontal4(x, y, color, board) == True:
        win = True
    if forward4(x, y, color, board) == True:
        win = True
    if back4(x, y, color, board) == True:
        win = True
    # Return the value stored in win
    return win
<var>    --snip--</var>
# Define the best_move() function
<span class="CodeAnnotationCode" aria-label="annotation3">3</span> def best_move():
    # Take column 4 in the first move
    if len(occupied[3]) == 0:
        return 4
    # If only one column has free slots, take it
    if len(validinputs) == 1:
<span epub:type="pagebreak" title="244" id="Page_244"/>        return validinputs[0]
    # Otherwise, see what will happen in the next move hypothetically 
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> winner = []
    # Go through all possible moves and see if there is a winning move
    for move in validinputs:
        tooccupy = deepcopy(occupied)
        tooccupy[move-1].append('red')
        if win_game(move,'red',tooccupy) == True:
            winner.append(move)        
    # If there is a winning move, take it
    if len(winner)&gt;0:
            return winner[0] 
<span class="CodeAnnotationCode" aria-label="annotation5">5</span> def computer_move():
    global turn, rounds, validinputs
    # Choose the best move
    col = best_move()
    if col == None:
        col = choice(validinputs)
    # Calculate the lowest available row number in that column
    row = 1+len(occupied[col-1])
<var>--snip--</var>
<span class="LiteralGray">    # Check if the player has won the game</span>
  <span class="CodeAnnotationCode" aria-label="annotation6">6</span> if win_game(col, turn, occupied) == True:
<var>--snip--</var>
# Computer moves first
computer_move()
<span class="LiteralGray"># Define a function conn() to place a disc in a cell</span>
<span class="LiteralGray">def conn(x,y):</span>
<span class="LiteralGray">    # Declare global variables</span>
<span class="LiteralGray">    global turn, rounds, validinputs</span>
<var>--snip--</var>
      <span class="CodeAnnotationCode" aria-label="annotation7">7</span> if win_game(col, turn, occupied) == True:
<var>--snip--</var>
<span class="LiteralGray">    # Computer moves next</span>
    if len(validinputs)&gt;0:
        computer_move()
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing13-1">Listing 13-1</a>: Think one step ahead in the Connect Four game.</p>
<p>We import all needed modules. In particular, we import <code>choice()</code> from the <em>random</em> module and <code>deepcopy()</code> from the <em>copy</em> module. The <em>copy</em> module is in the Python standard library, so no installation is needed. </p>
<p>To search for the best strategy, we’ll look one step ahead and see what would happen hypothetically if certain actions were taken. We need <code>deepcopy()</code> to copy a list without altering the original list. We can’t simply use assignment statements in this script when copying lists. Assignment statements in Python create a link to the original list object, so if we alter the copy, we alter the original as well. Altering the original list is not what we intend and would cause unexpected behavior.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="245" id="Page_245"/><h2><span class="NoteHead">WARNING</span></h2>
<p>	Assignment statements in Python don’t copy objects. Instead, they create bindings between a target and an object. If we use an assignment statement to create a copy of the list <code>occupied</code> in <em>conn_think</em><em>1</em><em>.py</em> and make changes to the copy, the original will be altered as well. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>At <span class="CodeAnnotation" aria-label="annotation1">1</span>, we make <code>horizontal4(x,y,color,board)</code>more general so that it can be applied to any four arguments. Later in the script, we’ll use it to check whether certain moves win the game by collecting four discs horizontally in a hypothetical situation. We define the functions <code>vertical4()</code>, <code>forward4()</code>, and <code>back4()</code> in a similar way. </p>
<p>At <span class="CodeAnnotation" aria-label="annotation2">2</span>, we define <code>win_game(num,color,board)</code>, which checks whether the player has won in any of the preceding four scenarios. We’ve also omitted the row number as an argument because it will be inferred from the argument <code>board</code>.</p>
<p>The main action is in <code>best_move()</code>, starting at <span class="CodeAnnotation" aria-label="annotation3">3</span>. This function searches for the best move for the computer (the red player). If column 4 is empty, the computer takes the center column. Since the red player moves first, this line of code ensures that the very first move of the game is always the center column 4, giving whoever makes the first move an advantage. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Since our goal in this chapter is to make Connect Four more challenging, we let the computer move first. However, letting the human play first is straightforward, and we’ll leave that as an exercise at the end of the chapter. In <span class="xref" itemid="xref_target_Chapter 17,">Chapter 17,</span> you’ll see how to choose who plays first.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>If only one move is left (that is, six columns are full and only one column has empty cells), there’s no point searching for a best move, so the computer takes the only remaining move.</p>
<p>If more than one move remains, the function checks every possible move to see if any will lead to a win for the computer right away. The script creates the list <code>winner</code> to contain the potentially winning moves <span class="CodeAnnotation" aria-label="annotation4">4</span>. We go through all possible next moves. We use <code>win_game()</code> to check whether a move will win the game hypothetically. If yes, the move is added to <code>winner</code>. The function then checks whether <code>winner</code> is empty, and if it isn’t, the computer takes the first available move in the list.</p>
<p>We then define <code>computer_move()</code><span class="CodeAnnotation" aria-label="annotation5">5</span>. When called, this function tells the computer to make the move produced by <code>best_move()</code>. The computer then places a disc in the corresponding column. Once the computer places the disc, the script uses <code>win_game()</code> to check if the move wins the game <span class="CodeAnnotation" aria-label="annotation6">6</span>. </p>
<p>The computer makes the first move of the game. After that, we define <code>conn()</code>, which allows you to click the screen to play your move. The script checks whether your move wins the game <span class="CodeAnnotation" aria-label="annotation7">7</span>. The computer will move after you if the game isn’t over.</p>
<p>Run the script several times and play against the computer. You’ll notice that the computer will always take the winning move if there is one. For example, at the left of <a href="#figure13-1" id="figureanchor13-1">Figure 13-1</a>, an opportunity emerges for the red player to take column 7 and win the game. The computer thinks one step ahead and takes the winning move. </p>
<span epub:type="pagebreak" title="246" id="Page_246"/><figure class="graphic">
<img src="Images/f13001a.png" alt="f13001a" width="414" height="372"/></figure>

<figure>
<img src="Images/f13001b.png" alt="f13001b" width="414" height="373"/>
<figcaption><p><a id="figure13-1">Figure 13-1</a>: A Connect Four game that thinks one step ahead</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Try it Out</h2>
<p class="BoxBodyFirst">Run <em>conn_think1.py</em> and create opportunities for the computer to win. See if the computer takes the winning move right away.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-501560c13-0002">Think Two Steps Ahead</h3>
<p class="BodyFirst">Thinking two steps ahead in Connect Four is a little complicated. The computer’s next move can either block the opponent (which is you) or help the opponent’s chance of winning the game on the next turn. </p>
<p>We’ll separate these two cases: if the computer’s move blocks the opponent’s chance of winning, the script will take it; if the computer’s move helps the opponent’s chance of winning, the script will avoid it. Let’s use examples to demonstrate the two cases.</p>
<h4 id="h3-501560c13-0001">Moves to Avoid</h4>
<p class="BodyFirst">In this example, the computer should avoid a certain move so that the opponent won’t win on the next turn. </p>
<p>At the left of <a href="#figure13-2" id="figureanchor13-2">Figure 13-2</a>, it’s the red player’s turn. If the red player chooses column 6 as the next move, the opponent can win on the following turn, as shown on the right in the figure. Therefore, the red player should avoid this move.</p>
<span epub:type="pagebreak" title="247" id="Page_247"/><figure class="graphic">
<img src="Images/f13002a.png" alt="f13002a" width="414" height="373"/></figure>

<figure>
<img src="Images/f13002b.png" alt="f13002b" width="414" height="372"/>
<figcaption><p><a id="figure13-2">Figure 13-2</a>: The red player should avoid column 6 in this example.</p></figcaption>
</figure>
<p>Here, the red player has made a move that allows yellow to win. We can avoid that win with this rule: if you make a next move <em>x</em>, and your opponent places a disc in the same column <em>x</em> two steps ahead and wins the game, you should avoid the move <em>x</em> in the next step. </p>
<h4 id="h3-501560c13-0002">Moves to Block</h4>
<p class="BodyFirst">In the next case, the computer should block a certain move so the opponent won’t win in two steps. </p>
<p>At the left in <a href="#figure13-3" id="figureanchor13-3">Figure 13-3</a>, it’s the red player’s turn. If the red player doesn’t choose column 3 in the next move, the opponent can choose column 3 and win on the following turn. Therefore, the red player should block this move. </p>
<figure class="graphic">
<img src="Images/f13003a.png" alt="f13003a" width="414" height="374"/></figure>

<figure>
<img src="Images/f13003b.png" alt="f13003b" width="414" height="370"/>
<figcaption><p><a id="figure13-3">Figure 13-3</a>: The red player should block column 3. </p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="248" id="Page_248"/>Here, the red player makes a different move—column 6—and loses the game. So the rule is as follows: if red makes the next move, <em>x</em>, and the yellow opponent can make a different move <em>y</em> within two steps and win, red should block yellow’s move <em>y</em> in the next step. </p>
<h3 id="h2-501560c13-0003">Implement the Think-Two-Steps-Ahead Strategy</h3>
<p class="BodyFirst">Let’s allow the computer to think up to two steps ahead by using the three techniques just discussed (one for thinking one step ahead, two for thinking two steps ahead). </p>
<p>Open <em>conn_think1.py</em>, replace its <code>best_move()</code> with the new <code>best_move()</code> function defined in <a href="#listing13-2" id="listinganchor13-2">Listing 13-2</a>, and save the new script as <em>conn_think2.py</em> in your chapter folder (or you can download it from the book’s resources). </p>
<pre><code><var>--snip--</var>
# Define the best_move() function
def best_move():
    # Take column 4 in the first move
    if len(occupied[3]) == 0:
        return 4
    # If only one column has free slots, take it
    if len(validinputs) == 1:
        return validinputs[0]
    # Otherwise, see what will happen in the next move hypothetically 
    winner = []
    # Go through all possible moves and see if there is a winning move
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> for move in validinputs:
        tooccupy = deepcopy(occupied)
        tooccupy[move-1].append('red')
        if win_game(move,'red',tooccupy) == True:
            winner.append(move)        
    # If there is a winning move, take it
    if len(winner)&gt;0:
        return winner[0]  
    # If no winning move, look two steps ahead
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> if len(winner) == 0 and len(validinputs)&gt;=2:
        loser = []
        # Check if your opponent has a winning move
        for m1 in validinputs:
            for m2 in validinputs:
                if m2 != m1:
                    tooccupy = deepcopy(occupied)
                    tooccupy[m1-1].append('red')
                    tooccupy[m2-1].append('yellow')
                    if win_game(m2, 'yellow',tooccupy) == True:
                        winner.append(m2) 
                if m2 == m1 and len(occupied[m1-1]) &lt;= 4:
                    tooccupy2 = deepcopy(occupied)
                    tooccupy2[m1-1].append('red')
                    tooccupy2[m2-1].append('yellow')
                    if win_game(m2,'yellow',tooccupy2) == True:
                        loser.append(m2) 
        # If your opponent has a winning move, block it
        if len(winner)&gt;0:
            return winner[0]
<span epub:type="pagebreak" title="249" id="Page_249"/>        # If you can make a move to help your opponent to win, avoid it
      <span class="CodeAnnotationCode" aria-label="annotation3">3</span> if len(loser)&gt;0:
            myvalids = deepcopy(validinputs)
            for i in range(len(loser)):
                myvalids.remove(loser[i])
            if len(myvalids)&gt;0:
                return choice(myvalids)  
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing13-2">Listing 13-2</a>: Allow the computer to think up to two steps ahead. </p>
<p>In the newly defined function <code>best_move()</code>, the script searches for the best move based on discs currently on the board. If this is the very first move of the game, the function takes the column in the middle. If only one move is left, the function defines the best move to be the only move left.</p>
<p>If more than one move remains, the function checks every possible move to see if any will lead to a win for the red player (the computer) right away <span class="CodeAnnotation" aria-label="annotation1">1</span>. If yes, the function returns the move as the best move and stores it in <code>winner</code>. If not, the function will look two steps ahead to see if the opponent can win within two steps <span class="CodeAnnotation" aria-label="annotation2">2</span>.</p>
<p>The function checks two separate cases: if the red player’s move <code>m1</code> (the first move) and the yellow player’s move <code>m2</code> (the second move) lead to a win for the yellow player in two steps, we add the move <code>m2</code> to the list <code>winner</code>. If the red player’s move <code>m1</code> and the yellow player’s move <code>m2=m1</code> lead to a win for the yellow player in two steps, we add the move <code>m2</code> to the list <code>loser</code>. </p>
<p>The script checks whether <code>winner</code> is empty. If it isn’t, the computer will select the opponent’s winning move to block the opponent from winning. Otherwise, the computer will check whether the list <code>loser</code> is empty. If not, the computer will avoid all elements in <code>loser</code> so as not to help the opponent win <span class="CodeAnnotation" aria-label="annotation3">3</span>. </p>
<p>Run <em>conn_think2.py</em> and play a few times against the computer. You’ll notice an improvement in the game in the sense that the computer can now think two steps ahead and try to prevent you from winning on your next turn.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Try it Out</h2>
<p class="BoxBodyFirst">Run <em>conn_think2.py</em> and try to win the game yourself. Pay attention to whether the computer prevents you from winning if such opportunities arise.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-501560c13-0004">Think Three Steps Ahead</h3>
<p class="BodyFirst">This next section will allow the computer to think up to three steps ahead before taking its turn. If the computer has no winning move in the next step and the opponent has no winning moves two steps ahead, the computer will look three steps ahead.</p>
<p>The computer will take the next move that most likely leads to a win in three steps. In particular, if there’s a next move that guarantees the computer to win in three steps, the computer will select that next move as the best one. Let’s use an example to demonstrate.</p>
<h4 id="h3-501560c13-0003"><span epub:type="pagebreak" title="250" id="Page_250"/>An Example of a Win in Three Steps</h4>
<p class="BodyFirst">The script <em>conn_think2.py</em> is harder to beat than <em>conn_think1.py</em>, but not impossible. A sophisticated player will notice that the computer misses some moves that could have led to a win in three steps. </p>
<p>Here’s an example. At the left of <a href="#figure13-4" id="figureanchor13-4">Figure 13-4</a>, it’s the computer’s (the red player’s) turn to move. If the computer drops a disc in column 3, the computer is guaranteed to win on its next turn, because the opponent (the yellow player) can block only either column 1 or column 5. The computer can then occupy the other column (either column 5 or column 1) in this third step and win the game. </p>
<p>But instead, the computer chooses column 6, as shown at the right of <a href="#figure13-4">Figure 13-4</a>, missing a chance to guarantee a win.</p>
<figure class="graphic">
<img src="Images/f13004a.png" alt="f13004a" width="414" height="373"/></figure>

<figure>
<img src="Images/f13004b.png" alt="f13004b" width="414" height="372"/>
<figcaption><p><a id="figure13-4">Figure 13-4</a>: The computer (the red player) fails to make a move that guarantees a win.</p></figcaption>
</figure>
<p>We should, therefore, make further improvements on the game. You’ll build a game that thinks three steps ahead. </p>
<h4 id="h3-501560c13-0004">Implement the Think-Three-Steps-Ahead Strategy</h4>
<p class="BodyFirst">Let’s allow the computer to think up to three steps ahead. </p>
<p>Open <em>conn_think2.py</em>, add the newly defined <code>validmoves()</code> function and the highlighted part in <a href="#listing13-3" id="listinganchor13-3">Listing 13-3</a> to the <code>best_move()</code> function, and save the new script as <em>conn_think.py</em> in your chapter folder. Alternatively, you can download it from the book’s resources. This is the complete script for our think-ahead strategy. </p>
<pre><code><var>--snip--</var>
# Define the validmoves() function to ensure three future moves 
# will not cause any column to have more than six discs in it 
def validmoves(m1,m2,m3,occupied):
    validmove = False
    if m1 == m2 == m3 and len(occupied[m1-1]) &lt;= 3:
<span epub:type="pagebreak" title="251" id="Page_251"/>        validmove = True
    if m1 == m2 and m2 != m3 and len(occupied[m1-1]) &lt;= 4:
        validmove = True
    if m1 == m3 and m2 != m3 and len(occupied[m1-1]) &lt;= 4:
        validmove = True
    if m3 == m2 and m2 != m1 and len(occupied[m3-1]) &lt;= 4:
        validmove = True
    return validmove
<span class="LiteralGray"># Define the best_move() function</span>
<span class="LiteralGray">def best_move():</span>
<span class="LiteralGray">    # Take column 4 in the first move</span>
<var>--snip--</var>
# Otherwise, look 3 moves ahead
      <span class="CodeAnnotationCode" aria-label="annotation1">1</span> if len(winner) == 0 and len(loser) == 0:
            # Look at all possible combinations of 3 moves ahead
            for m1 in validinputs:
                for m2 in validinputs:
                    for m3 in validinputs:
                        if validmoves(m1,m2,m3,occupied) == True: 
                            tooccupy3 = deepcopy(occupied)
                            tooccupy3[m1-1].append('red')
                            tooccupy3[m2-1].append('yellow')
                            tooccupy3[m3-1].append('red')
                            if win_game(m3, 'red', tooccupy3) == True:
                                winner.append(m1) 
            # See if there is a move now that can lead to winning in 3 moves
            if len(winner)&gt;0:
             <span class="CodeAnnotationCode" aria-label="annotation2">2</span> cnt = {winner.count(x):x for x in winner}
               maxcnt = sorted(cnt.keys())[-1]
               return cnt[maxcnt]
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing13-3">Listing 13-3</a>: Allow the computer to think up to three steps ahead. </p>
<p>We first define <code>validmoves(m1,m2,m3,occupied)</code> to ensure that none of the three future hypothetical moves <code>m1</code>, <code>m2</code>, and <code>m3</code> on the game board (represented by the list of lists <code>occupied</code>) will cause any columns to have more than six discs. If the three moves cause any of the seven columns to contain more than six discs, the function returns <code>False</code>; otherwise, it returns<em> </em><code>True</code>. </p>
<p>As in <em>conn_think2.py</em>, the computer first checks whether a winning move could be made right away. If yes, it will take it. If not, it checks whether a winning move could be made two steps ahead for the opponent. If yes, the computer tries to prevent it.</p>
<p>If no winning moves are available for the opponent two steps ahead, the computer looks three steps ahead <span class="CodeAnnotation" aria-label="annotation1">1</span>. It checks all combinations of three moves: the computer’s next move, <code>m1</code>; the opponent’s move two steps ahead, <code>m2</code>; and the computer’s move at the third step, <code>m3</code>. If a combination leads to a win for the player, the next move <code>m1</code> is added to the list <code>winner</code>. </p>
<p>However, just because a move <var>x</var> is in <code>winner</code> doesn’t mean this move will guarantee a computer win in three steps, because it can’t guarantee that the opponent will choose <code>m2</code> in the second step. Further, <code>winner</code> could <span epub:type="pagebreak" title="252" id="Page_252"/>contain multiple values. The function <code>best_move()</code> therefore looks for the most frequent value in <code>winner</code>, since that’s the move most likely to lead to a win for the computer in three steps. </p>
<p>As with most things in Python, there are many ways to find the most frequent value in a list<em>.</em> We utilize a trick known as a <em>list comprehension</em> to create an inline dictionary <code>cnt</code><em>.</em> In this dictionary, the key is the number of times a move appears in <code>winner</code>, and the value is the move <span class="CodeAnnotation" aria-label="annotation2">2</span>. For example, if <code>winner</code> has six elements <code>[7, 6, 6, 5, 5, 5]</code>, the dictionary <code>cnt</code> would be <code>{1:7, 2:6, 3:5}</code>. We then sort the keys in <code>cnt</code> to find the highest frequency and call it <code>maxcnt</code>. Here, <code>maxcnt</code> has a value of <code>3</code> because the highest number of times a value appears is three. Finally, we use <code>maxcnt</code> to retrieve the dictionary element with the highest frequency. Here, the move <code>5</code> appears most frequently in <code>winner</code>. </p>
<p>If you run <em>conn_think.py</em> and play the game, you’ll find the computer almost impossible to beat. If you do everything right, you can tie the game. The moment you make a wrong move, the computer will seize the opportunity and win the game.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Try it Out</h2>
<p class="BoxBodyFirst">Run <em>conn_think.py</em> five times and try your best to win each game. See how many games you can manage to win.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501560c13-0002">	The Machine-Learning Strategy </h2>
<p class="BodyFirst">Another way to make Connect Four smart is to let the computer learn from actual game outcomes. You’ll generate a million games in which both players use random moves. You’ll record the intermediate steps and the outcome of each game. The computer will use the game outcome data to design the best strategy. </p>
<p>At each move, the computer looks at all games with the same game history as the current game board. It calculates the average outcome for each possible next move and chooses the one that most likely leads to a favorable outcome.</p>
<h3 id="h2-501560c13-0005">Create a Dataset of Simulated Games</h3>
<p class="BodyFirst">The first step in the machine-learning strategy is to generate data to learn from. We’ll simulate two players choosing random moves and record both the outcome and the steps taken to reach that outcome. Even though the moves by both players are random, we repeat the game many times. The randomness in all these games is washed out by the law of large numbers. As a result, the outcome data will be useful to the computer to predict the outcome of a move. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="253" id="Page_253"/><h2><span class="NoteHead">NOTE</span></h2>
<p>	In statistics, the <em>law of large numbers </em>says that if you perform the same experiment many times, the average outcome should be close to the expected value. See an example at <a href="https://en.wikipedia.org/wiki/Law_of_large_numbers" class="LinkURL">https://en.wikipedia.org/wiki/Law_of_large_numbers</a>. In our setting, if the average outcome from playing move A is better than the average outcome from playing move B over a large number of trials, move A should be chosen over move B. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Download <em>conn_simulation.py</em> from the book’s resources. I explain the script in <a href="#listing13-4" id="listinganchor13-4">Listing 13-4</a>.</p>
<pre><code>from random import choice
import pickle

# Define a simulate() function to generate a complete game
  def simulate():
    occupied=[list(),list(),list(),list(),list(),list(),list()]
    validinputs=[1,2,3,4,5,6,7]
# Define a horizontal4() function to check connecting 4 horizontally
def horizontal4(x, y, turn):
    win=False
    for dif in (-3, -2, -1, 0):
<var>--snip--</var>
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> def win_game(col, row, turn):
        win=False
<var>--snip--</var>
        # Return the value stored in win
        return win
    # The red player takes the first move 
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> turn="red"
    # Keep track of all intermediate moves
    moves=[]
    # Use winlose to record game outcome, default value is 0 (a tie)
    winlose=[0]
    # Play a maximum of 42 steps
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> for i in range(42):
        # The player randomly selects a move
        col=choice(validinputs)
        row=len(occupied[col-1])+1
        moves.append(col)
        # Check if the player has won
        if win_game(col, row, turn)==True:
            if turn=='red':
                winlose[0]=1
            if turn=='yellow':
                winlose[0]=-1
            break
        # Add the move to the occupied list to keep track
        occupied[col-1].append(turn)
        # Update the list of valid moves
        if len(occupied[col-1])==6 and col in validinputs:
            validinputs.remove(col)
        # Give the turn to the other player
        if turn=="red":
            turn="yellow"
        else:
<span epub:type="pagebreak" title="254" id="Page_254"/>            turn="red" 
    # Record both game outcome and intermediate steps
    return winlose+moves
# Simulate the game 1 million times and record all games
results=[]        
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> for x in range(1000000):
    result=simulate()
    results.append(result)
# Save the simulation data on your computer
<span class="CodeAnnotationHang" aria-label="annotation5">5</span> with open('conn_simulates.pickle', 'wb') as fp:
    pickle.dump(results,fp)
# Read the data and print out the first 10 games
with open('conn_simulates.pickle', 'rb') as fp:
    mylist=pickle.load(fp)
print(mylist[0:10])</code></pre>
<p class="CodeListingCaption"><a id="listing13-4">Listing 13-4</a>: Simulating a million Connect Four games</p>
<p>We first define <code>simulate()</code>. When called, it simulates a complete Connect Four game and records each move and the game outcome. We omit the graphics part of the game to save time. </p>
<p>We define <code>win_game()</code> to check if a player has won the game <span class="CodeAnnotation" aria-label="annotation1">1</span>. In each game, the red player moves first <span class="CodeAnnotation" aria-label="annotation2">2</span>. We create the two lists <code>moves</code> and <code>winlose</code> to record the intermediate moves and the game outcome, respectively. </p>
<p>We create a game loop to iterate a maximum of 42 times because each Connect Four game has a maximum of 42 moves <span class="CodeAnnotation" aria-label="annotation3">3</span>. In each iteration, a player randomly selects a move. The move is added to <code>moves</code> to keep track of the history of the game. At each step, we check whether a player wins. If yes, we’ll record an outcome of <code>1</code> if the winner is the red player and <code>-1</code> if the winner is the yellow player. The default outcome is a tie, in which case we’ll record a value of <code>0</code>.</p>
<p>We then call <code>simulate()</code> a million times <span class="CodeAnnotation" aria-label="annotation4">4</span>. The result of each game is saved in a list <code>result</code>, with its first element being the outcome of the game (<code>-1</code>, <code>1</code>, or <code>0</code>), followed by the intermediate steps of the game. </p>
<p>The outcomes and intermediate steps of the million games are saved in <em>conn_simulates.pickle</em> for later use <span class="CodeAnnotation" aria-label="annotation5">5</span>. We print out the results of the first 10 games, shown in <a href="#listing13-5" id="listinganchor13-5">Listing 13-5</a>.</p>
<pre><code>[[1, 1, 7, 1, 5, 7, 6, 5, 1, 5, 7, 5, 2, 5], 
[1, 5, 4, 2, 7, 5, 2, 5, 6, 2, 7, 5], 
[1, 7, 3, 5, 5, 3, 7, 3, 7, 4, 2, 7, 7, 6], 
[-1, 6, 7, 6, 6, 5, 1, 5, 3, 5, 7, 6, 5, 4, 2, 5, 7, 3, 4,
7, 1, 1, 6, 4, 5, 6, 1, 1, 4, 1, 7, 3, 3, 7, 2, 3, 2, 3, 4], 
[-1, 1, 3, 5, 1, 4, 5, 4, 6, 2, 7, 3, 2, 3, 4, 2, 3], 
[1, 6, 5, 7, 1, 3, 3, 1, 5, 5, 5, 2, 3, 6, 7, 2, 6, 3, 2, 7, 
5, 4, 3, 7, 6, 7, 6, 6, 1, 2, 2, 4, 5, 4, 7, 3, 2, 1, 1, 4], 
[1, 2, 5, 3, 5, 3, 4, 7, 7, 5, 3, 4, 2, 2, 2, 5, 4, 4, 4, 4, 6, 6], 
[1, 2, 5, 6, 4, 6, 7, 5, 5, 7, 4, 1, 3, 6, 3, 2, 1, 7, 1, 6], 
[1, 7, 4, 4, 6, 3, 1, 2, 2, 3, 3, 4, 6, 3, 6, 1, 3, 4, 1, 3, 7, 7, 5, 4], 
[-1, 1, 4, 1, 4, 1, 2, 4, 5, 6, 6, 6, 3]] </code></pre>
<p class="CodeListingCaption"><a id="listing13-5">Listing 13-5</a>: The first 10 simulated Connect Four games</p>
<p><span epub:type="pagebreak" title="255" id="Page_255"/>For example, the output for the first game is <code>[1, 1, 7, 1, 5, 7, 6, 5, 1, 5, 7, 5, 2, 5]</code>. The first element, <code>1</code>, means that the red player has won the game. The remaining elements, <code>1, 7, 1 ... </code>, indicate the columns the players dropped their discs into, alternating between red and yellow. The red player eventually wins this game by connecting four red discs vertically in column 5.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Try it Out</h2>
<p class="BoxBodyFirst">Run <em>conn_simulation.py</em> and print out the first 10 games in the generated dataset. Interpret the numbers in each game and confirm that the intermediate steps are consistent with the game’s outcome.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-501560c13-0006">Apply the Data</h3>
<p class="BodyFirst">The next step is to use the outcome data to design intelligent moves for the computer. At each move, the computer will turn to the simulated data to retrieve all games with the same history. It searches through all possible next moves, finds the one that leads to the most favorable outcome, and uses that as the next move. </p>
<p>Download <em>conn_ml.py</em> and save it in your chapter folder. The script is based on <em>conn_think.py</em>. <a href="#listing13-6" id="listinganchor13-6">Listing 13-6</a> highlights the main differences.</p>
<pre><code><var>--snip--</var>
<span class="LiteralGray"># A history of moves made</span>
moves_made=[]
<span class="LiteralGray"># Obtain game data</span>
with open('conn_simulates.pickle', 'rb') as fp:
    gamedata=pickle.load(fp)
<span class="LiteralGray"># Define the best_move() function</span>
<span class="CodeAnnotationHang" aria-label="annotation1">1</span><span class="LiteralGray"> def best_move():</span>
<span class="LiteralGray">    # Take column 4 in the first move</span>
<span class="LiteralGray">    if len(occupied[3])==0:</span>
<span class="LiteralGray">        return 4</span>
<span class="LiteralGray">    # If there is only one column has free slots, use the column</span>
<span class="LiteralGray">    if len(validinputs)==1:</span>
<span class="LiteralGray">        return validinputs[0]</span>
    simu=[]
    for y in gamedata:
       if y[1:len(moves_made)+1]==moves_made:
           simu.append(y)
    # Now we look at the next move; 
    outcomes={x:[] for x in validinputs} 
    # We collect all the outcomes for each next move
    for y in simu:
       outcomes[y[len(moves_made)+1]].append(y[0])
    # Set the initial value of bestoutcome
    bestoutcome=-2;
    # Randomly select a move to be best_move
<span epub:type="pagebreak" title="256" id="Page_256"/>    best_move=validinputs[0]
    # iterate through all possible next moves 
    for move in validinputs:
        if len(outcomes[move])&gt;0:
            outcome=sum(outcomes[move])/len(outcomes[move])
            # If the average outcome beats the current best 
            if outcome&gt;bestoutcome:
                # Update the bestoutcome
                bestoutcome=outcome
                # Update the best move
                best_move=move
    return best_move
# Define a function computer_move()
<span class="CodeAnnotationHang" aria-label="annotation2">2</span><span class="LiteralGray"> def computer_move():</span>
<span class="LiteralGray">    # Declare global variables</span>
<span class="LiteralGray">    global turn, rounds, validinputs</span>
<span class="LiteralGray">    # Get the best move</span>
<span class="LiteralGray">    col=best_move()</span>
<span class="LiteralGray">    if col==None:</span>
<span class="LiteralGray">        col=choice(validinputs)</span>
<var>--snip--</var>
    moves_made.append(col)
<var>--snip--</var>
<span class="LiteralGray"># Computer moves first</span>
<span class="CodeAnnotationHang" aria-label="annotation3">3</span><span class="LiteralGray"> computer_move()</span>
<span class="LiteralGray"># Define a function conn() to place a disc in a cell</span>
<span class="CodeAnnotationHang" aria-label="annotation4">4</span><span class="LiteralGray"> def conn(x,y):</span>
<span class="LiteralGray">    # Declare global variables</span>
<span class="LiteralGray">    global turn, rounds, validinputs</span>
<var>--snip--</var>
    moves_made.append(col)
<var>--snip--</var>
<span class="LiteralGray">    # Computer moves next</span>
<span class="LiteralGray">    if len(validinputs)&gt;0:</span>
<span class="LiteralGray">        computer_move()</span>
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing13-6">Listing 13-6</a>: A Connect Four game player with the machine-learning strategy</p>
<p>We create the new list <code>moves_made</code> to keep track of all moves in the game so far; we’ll use it later in <code>best_move()</code>. We open the simulated Connect Four game data and save it in a list <code>gamedata</code>.</p>
<p>In <code>best_move()</code>, we make sure the first move is always to place a disc in column 4, as that gives the computer a starting advantage <span class="CodeAnnotation" aria-label="annotation1">1</span>. We check if only one move is left and, if so, just take it as the next best move. Otherwise, we check all simulated games with the same history as the current game and see which next move will be most favorable to the red player. We assign that move as the best move. I’ll explain how we do that in detail in <em>ml_move.py</em>, using a concrete example.</p>
<p>At <span class="CodeAnnotation" aria-label="annotation2">2</span>, we define <code>computer_move()</code>. When it’s the computer’s turn to play, it calls <code>best_move()</code> to generate a move. The computer makes the move, and we add that move to the list <code>moves_made</code> to track the game history.</p>
<p><span epub:type="pagebreak" title="257" id="Page_257"/>We set the computer to make the first move <span class="CodeAnnotation" aria-label="annotation3">3</span>. After that, the player clicks to make their move <span class="CodeAnnotation" aria-label="annotation4">4</span>. The human player’s move is also added to <code>moves_made</code>. The computer will move after you if the game isn’t over.</p>
<p>Run <em>conn_ml.py</em> and play the game a few times. You might be surprised to find that it’s relatively easy to win. The machine-learning strategy is not nearly as effective as our three-steps method. We’ll look into why later in the chapter.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Try it Out</h2>
<p class="BoxBodyFirst">Run <em>conn_ml.py</em> and play five games against the computer. See how many games you can win.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501560c13-0003">	Test the Effectiveness of the Two Strategies</h2>
<p class="BodyFirst">Next, we want to measure how intelligent the two strategies are. We’ll simulate 1,000 games and record the outcomes. In each game, the intelligent computer version will play against a simple computer player that selects random moves. We’ll see how many times the intelligent player wins or ties the game.</p>
<h3 id="h2-501560c13-0007">The Think-Three-Steps-Ahead Strategy </h3>
<p class="BodyFirst">We’ll start with the three-steps version. The script <em>outcome_conn_think.py, </em>shown in <a href="#listing13-7" id="listinganchor13-7">Listing 13-7</a>, has our two computer players play 1,000 times, then prints out the number of winning, tying, and losing games. </p>
<pre><code>import pickle
from random import choice
from copy import deepcopy

# Define the simulate() function to play a complete game
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> def simulate():
    occupied=[list(),list(),list(),list(),list(),list(),list()]
    validinputs=[1,2,3,4,5,6,7]
<var>--snip--</var>
    def win_game(num, color, lst):
        win=False
<var>--snip--</var>
    def best_move():
        # Take column 4 in the first move
        if len(occupied[3])==0:
            return 4
<var>--snip--</var>
    # The red player takes the first move
    turn="red"
    # Keep track of all intermediate moves
    moves_made=[]
<span epub:type="pagebreak" title="258" id="Page_258"/>  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> winlose=[0]
    # Play a maximum of 42 steps (21 rounds)
    for i in range(21):
        # The player selects the best move
      <span class="CodeAnnotationCode" aria-label="annotation3">3</span> col=best_move()
        if col==None:
            col=choice(validinputs)
        moves_made.append(col)
<var>--snip--</var>
        # The other player randomly selects a move
        col=choice(validinputs)
        moves_made.append(col)
<var>--snip--</var>
    # Record both game outcome and intermediate steps 
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> return winlose+moves_made
# Repeat the game 1000 times and record all game outcomes
results=[]        
<span class="CodeAnnotationHang" aria-label="annotation5">5</span> for x in range(1000):
    result=simulate()
    results.append(result)    
with open('outcome_conn_think.pickle', 'wb') as fp:
    pickle.dump(results,fp)
with open('outcome_conn_think.pickle', 'rb') as fp:
    mylist=pickle.load(fp)    
winlose=[x[0] for x in mylist]
# Print out the number of winning games
  print("the number of winning games is", winlose.count(1))
# Print out the number of tying games
print("the number of tying games is", winlose.count(0))
# Print out the number of losing games
print("the number of losing games is", winlose.count(-1))</code></pre>
<p class="CodeListingCaption"><a id="listing13-7">Listing 13-7</a>: Test the effectiveness of the think-three-steps-ahead strategy.</p>
<p>At <span class="CodeAnnotation" aria-label="annotation1">1</span>, we define <code>simulate()</code>, which pits the intelligent computer (the red player) using the think-three-steps-ahead strategy against a computer player that selects random moves. </p>
<p>The <code>win_game()</code> and <code>best_move()</code> functions are the same as those defined in <em>conn_think.py</em>. We use the list <code>winlose</code> to record the game outcomes <span class="CodeAnnotation" aria-label="annotation2">2</span>: <code>1</code> if the red player wins, <code>-1</code> if the yellow player wins, and <code>0</code> if it’s a tie.</p>
<p>Once the game starts, the red player calls <code>best_move()</code> to obtain a move <span class="CodeAnnotation" aria-label="annotation3">3</span>, while the yellow player randomly selects a move <span class="CodeAnnotation" aria-label="annotation4">4</span>.</p>
<p>At <span class="CodeAnnotation" aria-label="annotation5">5</span>, we call <code>simulate()</code> 1,000 times and record the outcome of all games. We then print out the number of winning, tying, and losing games, summing the count of <code>1</code>, <code>-1</code>, and <code>0</code> to make it easier to read. Here’s an example of the output:</p>
<pre><code>the number of winning games is 995
the number of tying games is 0
the number of losing games is 5</code></pre>
<p><span epub:type="pagebreak" title="259" id="Page_259"/>Out of all the games, the intelligent player with the think-three-steps-ahead strategy has won 995 times, never tied, and lost 5 times. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Try it Out</h2>
<p class="BoxBodyFirst">Rerun <em>outcome_conn_think.py</em> a few times to see how many times the “intelligent” computer wins.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-501560c13-0008">The Machine-Learning Strategy </h3>
<p class="BodyFirst">Now we’ll test the machine-learning strategy in the same way. Download <em>outcome_conn_ml.py</em> and save it in your chapter folder. This is similar to <em>outcome_conn_think.py</em>, so I’ll just highlight the differences here:</p>
<pre><code><var>--snip--</var>
    # Obtain gamedata
    with open('conn_simulates.pickle', 'rb') as fp:
        gamedata=pickle.load(fp)
# Define the best_move() function based on the machine-learning strategy
    def best_move():
        # Take column 4 in the first move
        if len(occupied[3])==0:
            return 4
<var>--snip--</var>
with open('outcome_conn_ml.pickle', 'wb') as fp:
    pickle.dump(results,fp)
with open('outcome_conn_ml.pickle', 'rb') as fp:
    mylist=pickle.load(fp)    
<var>--snip--</var></code></pre>
<p>First, we obtain the simulated game outcome data that we’ve generated from <em>conn_simulation.py</em>. Second, we base the definition of <code>best_move()</code> on the machine-learning strategy instead of the three-steps strategy.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">WARNING</span></h2>
<p>	The script <em>outcome_conn_ml.py</em> may take a long time (up to a couple of hours) to run, depending on the speed of your computer. If you aren’t sure about your computer’s speed, change the number of games from 1,000 to 100 and run the script first.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>We call <code>simulate()</code> 1,000 times and record the outcomes, printing them as before. Here’s an example output:</p>
<pre><code>the number of winning games is 882
the number of tying games is 0
the number of losing games is 118	</code></pre>
<p>Out of all the games, the computer has won 882 times, never tied, and lost 118 times—it did significantly worse than with the three-steps strategy. Let’s look at why.</p>
<h3 id="h2-501560c13-0009"><span epub:type="pagebreak" title="260" id="Page_260"/>Why Doesn’t the Machine-Learning Strategy Work Well in Connect Four?</h3>
<p class="BodyFirst">The machine-learning strategy is less effective in our game mainly because so many moves are available in a Connect Four game: a maximum of 42. That means, exponentially, that a very large number of possible game outcomes exist. We simulated a million games, which sounds like a lot, but when the data is spread among many game outcomes, it’s inevitable that some game outcomes will not be in the simulated data. As a result, it’s impossible to find a best strategy for many of the game histories. </p>
<p>As an example, we’ll test the machine-learning strategy with one particular game history. Assume that the red and yellow players have both made three moves and next it’s the red player’s turn. The game board at this stage is as shown in <a href="#figure13-5" id="figureanchor13-5">Figure 13-5</a>.</p>
<figure>
<img src="Images/f13005.png" alt="f13005" width="530" height="478"/>
<figcaption><p><a id="figure13-5">Figure 13-5</a>: One game simulation</p></figcaption>
</figure>
<p>We’ll simulate this game setup in code to see how our machine-learning strategy decides which move to make next. Enter <em>ml_move.py</em>, shown in <a href="#listing13-8" id="listinganchor13-8">Listing 13-8</a>.</p>
<pre><code>import pickle
  validinputs=[1,2,3,4,5,6,7]
# A game history
  moves_made=[4,5,4,5,4,5]
# The game board
occupied=[list(),list(),list(),
            ['red','red','red'],
            ['yellow','yellow','yellow'],
            list(),list()]
<span epub:type="pagebreak" title="261" id="Page_261"/># Obtain gamedata
with open('conn_simulates.pickle', 'rb') as fp:
    gamedata=pickle.load(fp)
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> simu=[]
for y in gamedata:
   if y[1:len(moves_made)+1]==moves_made:
       simu.append(y)
# Now we look at the next move 
outcomes={x:[] for x in validinputs} 
# We collect all the outcomes for each next move
for y in simu:
   outcomes[y[len(moves_made)+1]].append(y[0])
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> print(outcomes) 
# Set the initial value of bestoutcome
bestoutcome=-2;
# Randomly select a move to be best_move
best_move=validinputs[0]
# Iterate through all possible next moves 
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> for move in validinputs:
    if len(outcomes[move])&gt;0:
        outcome=sum(outcomes[move])/len(outcomes[move])
        print\
        (f'when the next move is {move}, the average outcome is {outcome}')
        # If the average outcome from that move beats the current best move
        if outcome&gt;bestoutcome:
            # Update the best outcome
            bestoutcome=outcome
            # Update the best move
            best_move=move
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> print(f'the best next move is {best_move}')</code></pre>
<p class="CodeListingCaption"><a id="listing13-8">Listing 13-8</a>: Search for the best machine learning strategy move.</p>
<p>We import <em>pickle</em>, which enables us to work with datasets saved in the <em>pickle</em> format. We open the simulation data file, <em>conn_simulates.pickle,</em> which was created earlier in <em>conn_simulation.py. </em>The data is saved in the <code>gamedata</code> list.</p>
<p>At this point, the red player is able to place a disc in any of the seven columns in the next move, so we have all seven values in <code>validinputs</code>. We save the six moves already made in <a href="#figure13-4">Figure 13-4</a>, <code>[4, 5, 4, 5, 4, 5]</code>, in the list <code>moves_made</code>. The list of lists <code>occupied</code> keeps track of the disc positions currently on the game board.</p>
<p>We check the million simulated games data to see if any of those games match the game history of the current game. If yes, we put all the historical games that match in the list <code>simu</code><em> </em><span class="CodeAnnotation" aria-label="annotation1">1</span>. We then focus on the seventh move in all those games. We look at the outcomes (win, lose, or tie) of all games associated with each of the seven possible moves, 1 through 7, and put them in a dictionary <code>outcomes</code>.</p>
<p>We then print out the content of <code>outcomes</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>:</p>
<pre><code>{1: [], 2: [-1, 1], 3: [1], 4: [1], 5: [-1], 6: [-1, -1, 1], 7: [-1]}</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="262" id="Page_262"/><h2><span class="NoteHead">WARNING</span></h2>
<p>	The outcome will be different when you run <em>ml_move.py</em> because the simulated data is generated randomly.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>As you can see, nine games have the same game history: none of which placed the next disc in column 1, two that used column 2 for the next move, one that used column 3, and so on. The values <code>-1</code>, <code>0</code>, and <code>1</code> inside the square brackets indicate that the red player loses, ties, and wins the game, respectively. </p>
<p>To help us compare which of the seven moves leads to the best outcome for the red player, we calculate the average outcome for each move <span class="CodeAnnotation" aria-label="annotation3">3</span>. If a move leads to wins 100 percent of the time, the average outcome is <code>1</code>; if a move leads to 50 percent wins and 50 percent losses, the average outcome is <code>0</code>; if a move leads to a loss 100 percent of the time, the average is <code>-1</code>.</p>
<p>We print the average outcomes (we don’t have results for move 1 because no simulated game in <code>simu</code><em> </em>used this move):</p>
<pre><code>when the next move is 2, the average outcome is 0.0
when the next move is 3, the average outcome is 1.0
when the next move is 4, the average outcome is 1.0
when the next move is 5, the average outcome is -1.0
when the next move is 6, the average outcome is -0.3333333333333333
when the next move is 7, the average outcome is -1.0</code></pre>
<p>Both moves 3 and 4 lead to an average outcome of <code>1</code>. The script prints out the first best move, which is 3 in this case <span class="CodeAnnotation" aria-label="annotation4">4</span>:</p>
<pre><code>the best next move is 3</code></pre>
<p>However, when we look at this move in the game (<a href="#figure13-6" id="figureanchor13-6">Figure 13-6</a>), we can see it clearly isn’t the best move we could have made.</p>
<figure>
<img src="Images/f13006.png" alt="f13006" width="512" height="460"/>
<figcaption><p><a id="figure13-6">Figure 13-6</a>: The machine-learning computer makes a mistake.</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="263" id="Page_263"/>As you can see, the problem with the machine-learning strategy is that we don’t have enough simulated games that match our game history. </p>
<p>You may wonder whether we can just increase the number of simulated games to solve the problem. The answer is yes and no. Increasing the number of simulated games will make the strategy more intelligent, but it will also increase the data size enough to slow the response of the machine-learning script. Thus, the player will have to wait a long time for the computer to make a move. This is the trade-off when using machine learning.</p>
<p>Let’s test this by increasing the size of the simulated games to 10 million. Generating this data takes several hours. We rerun <em>ml_move.py</em> with the larger dataset and get the following output:</p>
<pre><code>{1: [-1, 1, -1, 1, -1, -1, 1, 1, -1, -1, -1, 1, 1, -1, 1], 
2: [1, 1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1, 1], 
3: [-1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1], 
4: [1, 1, 1, 1, 1, 1, 1, 1, 1], 
5: [1, 1, 1, 1, 1, 1, -1], 
6: [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1, -1], 
7: [1, -1, 1, -1, -1, -1, 1, -1, -1, 1]}
when the next move is 1, the average outcome is -0.06666666666666667
when the next move is 2, the average outcome is 0.42857142857142855
when the next move is 3, the average outcome is -0.8181818181818182
when the next move is 4, the average outcome is 1.0
when the next move is 5, the average outcome is 0.7142857142857143
when the next move is 6, the average outcome is -0.07692307692307693
when the next move is 7, the average outcome is -0.2
the best next move is 4</code></pre>
<p>Now that we have much more data to base our decision on, the machine-learning strategy correctly recommends column 4, resulting in <a href="#figure13-7" id="figureanchor13-7">Figure 13-7</a>. </p>
<figure>
<img src="Images/f13007.png" alt="f13007" width="500" height="450"/>
<figcaption><p><a id="figure13-7">Figure 13-7</a>: With 10 million simulated games, the strategy makes the correct move.</p></figcaption>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2><span epub:type="pagebreak" title="264" id="Page_264"/>Try it Out</h2>
<p class="BoxBodyFirst">Change the number of the simulated games in <em>conn_simulation.py</em> to five million. Play the game using <em>conn_ml.py</em> and compare the response time and the competence of the machine-learning strategy. Finally, run <em>outcome_conn_ml.py</em> using the new data and see how often the intelligent player wins. (Warning: the process may be time-consuming.)</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501560c13-0004">	Voice-Controlled Intelligent Connect Four Games</h2>
<p class="BodyFirst">Let’s wrap up this chapter by adding speech recognition and text-to-speech features to the intelligent Connect Four games.</p>
<h3 id="h2-501560c13-0010">A Voice-Controlled Game That Thinks Ahead</h3>
<p class="BodyFirst">We’ll mesh together two scripts, <em>conn_think.py</em> and <em>conn_hs.py</em>, into <em>conn_think_hs.py</em>. Download this file from the book’s resources and save it in your chapter folder. The main differences are shown in <a href="#listing13-9" id="listinganchor13-9">Listing 13-9</a>.</p>
<pre><code><var>--snip--</var>
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> def best_move():
    # Take column 4 in the first move
    if len(occupied[3])==0:
        return 4
<var>--snip--</var>
# Define the computer_move() function
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> def computer_move():
    global turn, rounds, validinputs
    # Choose the best move
    col=best_move()
    if col==None:
        col=choice(validinputs)
    print_say(f"The computer chooses column {col}.")
<var>--snip--</var>
    # Check if the player has won
    if win_game(col, turn, occupied)==True:
        # If a player wins, invalid all moves, end the game
        validinputs=[]
      <span class="CodeAnnotationCode" aria-label="annotation3">3</span> print_say(f"Congrats player {turn}, you won!")
        messagebox.showinfo("End Game",f"Congrats player {turn}, you won!")
    # If all cells are occupied and no winner, it's a tie
    if rounds==42:
        print_say("Game over, it's a tie!")
        messagebox.showinfo("Tie Game","Game over, it's a tie!")
<var>--snip--</var>
# Computer moves first
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> computer_move()
# Add a dictionary of words to replace
<span epub:type="pagebreak" title="265" id="Page_265"/>to_replace = {'number ':'', 'cell ':'', 'column ':'',
              'one':'1', 'two':'2', 'three':'3',
              'four':'4', 'for':'4', 'five':'5',
              'six':'6', 'seven':'7'}
# Start a while loop to take voice inputs
<span class="CodeAnnotationHang" aria-label="annotation5">5</span> while len(validinputs)&gt;0:
    # Ask for your move
    print_say(f"Player {turn}, what's your move?")
    # Capture your voice input
    inp= voice_to_text().lower()
    print_say(f"You said {inp}.")
    for x in list(to_replace.keys()):   
        inp = inp.replace(x, to_replace[x])
    try:
        col=int(inp)
    except:
        print_say("Sorry, that's an invalid input!")
        continue
    # If col is not a valid move, try again
  <span class="CodeAnnotationCode" aria-label="annotation6">6</span> if col not in validinputs:
        print_say("Sorry, that's an invalid move!") 
        continue
    # If your voice input is a valid column number, play the move
    else:
        # Calculate the lowest available row number in that column
        row=len(occupied[col-1])+1
<var>--snip--</var>
            print_say(f"Congrats player {turn}, you won!")
<var>--snip--</var>
            print_say("Game over, it's a tie!")
<var>--snip--</var>
        if len(validinputs)&gt;0:
            computer_move()
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing13-9">Listing 13-9</a>: A voice-controlled Connect Four game with the three-steps strategy</p>
<p>The function <code>best_move()</code> is the same as in the script <em>conn_think.py</em> <span class="CodeAnnotation" aria-label="annotation1">1</span>. We define <code>computer_move()</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, which uses <code>best_move()</code> to choose a move and speaks aloud the selected column. If the computer’s move wins or ties the game, the script also announces it <span class="CodeAnnotation" aria-label="annotation3">3</span>. </p>
<p>The computer then makes the first move of the game<em> </em><span class="CodeAnnotation" aria-label="annotation4">4</span>, and it starts a <code>while</code> loop that keeps running as long as the list <code>validinputs</code><em> </em>isn’t empty <span class="CodeAnnotation" aria-label="annotation5">5</span>. At each iteration, the script captures your voice input, which should be the number of the column you want to drop a disc in. You can say “number five,” “column five,” or “5.” It then converts the voice command to an integer number to match the format in <code>validinputs</code><em> </em>so it can compare your input to the list. If you said something that isn’t convertible to an integer, the script will say, “Sorry, that’s an invalid input.” </p>
<p>If you’ve given an invalid move <span class="CodeAnnotation" aria-label="annotation6">6</span>, the script will say, “Sorry, that’s an invalid move.” If your move is valid, the script places the disc on the game <span epub:type="pagebreak" title="266" id="Page_266"/>board. In the process, it will check whether you’ve won or tied the game and, if so, will announce the result aloud. If the game is not yet over, the computer makes a move.</p>
<p>Run the script and play the voice-controlled game with the computer. You’ll notice that the game is more challenging and more interesting to play.</p>
<h3 id="h2-501560c13-0011">A Voice-Controlled Game Using Machine Learning</h3>
<p class="BodyFirst">We’ll mesh together two scripts we created before, <em>conn_ml.py</em> and <em>conn_hs.py</em>, into <em>conn_ml_hs.py</em>. Download the file from the book’s resources and save it in your chapter folder. <a href="#listing13-10" id="listinganchor13-10">Listing 13-10</a> shows the main differences.</p>
<pre><code><var>--snip--</var>
import pickle
<var>--snip--</var>
# A history of moves made
moves_made=[]
# Obtain gamedata
with open('conn_simulates.pickle', 'rb') as fp:
    gamedata=pickle.load(fp)
# Define the best_move() function based on machine learning
def best_move():
    # Take column 4 in the first move
    if len(occupied[3])==0:
        return 4
<var>--snip--</var>
# Define the computer_move() function 
def computer_move():
    global turn, rounds, validinputs
    # Choose the best move
    move=best_move()
    if move==None:
        move=choice(validinputs)
    print_say(f"The computer decides to occupy cell {move}.")
<var>--snip--</var>
    moves_made.append(move)
<var>--snip--</var>
# Computer moves first
computer_move()
# Start an infinite loop to take voice inputs
while len(validinputs)&gt;0:
    # Ask for your move
    print_say(f"Player {turn}, what's your move?")
    # Capture your voice input
    inp= voice_to_text().lower()
<var>--snip--</var>
        moves_made.append(inp)
<var>--snip--</var>
        # Computer moves
        if len(validinputs)&gt;0:
            computer_move()
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing13-10">Listing 13-10</a>: A voice-controlled Connect Four game using the machine-learning strategy</p>
<p><span epub:type="pagebreak" title="267" id="Page_267"/>This works in the same way as the voice-controlled three-steps version. Run the script and play a game. You should find the game interesting but easier to beat than the three-steps strategy.</p>
<h2 id="h1-501560c13-0005">	Summary</h2>
<p class="BodyFirst">In this chapter, you created intelligent, voice-controlled graphical Connect Four games by using two methods: the think-three-steps-ahead strategy and the machine-learning strategy. This taught some important reasoning skills—how do we make a script intelligent?—as well as some basic machine-learning skills. </p>
<p>You learned to generalize these two strategies and apply them to specific games. You can apply these skills to create your own intelligent voice-controlled games. </p>
<h2 id="h1-501560c13-0006">	End-of-Chapter Exercises</h2>
<ol class="decimal">
<li value="1">Modify <em>conn_think1.py</em> so that the human player moves first and the computer moves second.</li>
<li value="2">Mesh together <em>ttt_click.py</em> from Chapter 10 and <em>conn_think1.py</em> to create a mouse-click version of the tic-tac-toe game in which the computer thinks one step ahead. </li>
<li value="3">Create a mouse-click version of the tic-tac-toe game in which the computer thinks two steps ahead, based on <em>ttt_click.py</em> and <em>conn_think2.py</em>.</li>
<li value="4">In <code>best_move()</code>, defined in <em>conn_think.py</em>, if the list <code>winner</code> has eight elements <code>[7, 7, 4, 5, 6, 6, 6, 6]</code>, what’s the value of <code>cnt</code>, <code>maxcnt</code>, and <code>cnt[maxcnt]</code>, respectively? </li>
<li value="5">Design a mouse-click version of the tic-tac-toe game in which the computer thinks three steps ahead, based on <em>ttt_click.py</em> and <em>conn_think.py</em>.</li>
<li value="6">Simulate a million tic-tac-toe games and save the game outcome and intermediate steps as <em>ttt_simulates.pickle</em>. Then create a mouse-click version of tic-tac-toe in which the computer uses the machine-learning strategy, similar to what we’ve done in <em>conn_simulation.py</em> and <em>conn_ml.py</em>.</li>
<li value="7">Modify <em>outcome_conn_think.py</em> and <em>outcome_conn_ml.py</em> to test the effectiveness of the three-steps strategy and the machine-learning strategy in the tic-tac-toe games you just created. </li>
<li value="8">After running <em>conn_simulation.py</em>, we printed out 10 observations from the dataset <em>conn_simulates.pickle</em>, as shown in <a href="#listing13-5">Listing 13-5</a>. The 10th observation is <code>[-1, 1, 4, 1, 4, 1, 2, 4, 5, 6, 6, 6, 3]</code>. Who has won the 10th game? Are the four discs connected vertically, horizontally, or diagonally? </li>
</ol>
</section>
</div></body></html>