- en: '**1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**1'
- en: SETTING THE STAGE**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置舞台**'
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: Although this book has no traditional math exercises, we do need to play around
    with the concepts if we want to master them. We’ll have plenty of opportunities
    for that, but instead of pencil and paper exercises, we’ll use code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书没有传统的数学练习，但如果我们想掌握这些概念，我们确实需要玩弄一下。我们将有很多机会做到这一点，但我们将使用代码而不是铅笔和纸的练习。
- en: This chapter will help you set the stage by configuring our working environment.
    Throughout the book, I’ll work in Linux, specifically Ubuntu 20.04, though what
    we’re doing most likely will work in later versions of Ubuntu and most other Linux
    distributions as well. For completeness, I’ve included sections on configuring
    macOS and Windows environments. I should point out that the expected operating
    system for deep learning is Linux, with most things working under macOS as well.
    Windows is typically an afterthought, and many deep learning toolkit ports are
    poorly maintained, though this is improving with time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助您通过配置我们的工作环境来设置舞台。在整本书中，我将在Linux中工作，具体来说是Ubuntu 20.04，尽管我们所做的大多数工作也可能适用于Ubuntu的后续版本和大多数其他Linux发行版。为了完整起见，我还包括了配置macOS和Windows环境的部分。我应该指出，深度学习的预期操作系统是Linux，大多数事情也可以在macOS下工作。Windows通常是一个次要考虑因素，并且许多深度学习工具包的移植维护不佳，尽管随着时间的推移情况有所改善。
- en: We’ll begin with some instructions for installing the expected software packages.
    Then we’ll take a quick look at the NumPy library for Python 3.*x*. NumPy is foundational
    to virtually all scientific uses of Python, and it’s essential that you know how
    to work with it at a basic level. Next, I’ll introduce SciPy. This is also a necessary
    toolkit for science, but we’ll only need the tiniest portion of it here. Finally,
    I’ll talk a bit about the Scikit-Learn toolkit, abbreviated here as `sklearn`.
    This valuable toolkit implements many of the traditional machine learning models.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一些安装预期软件包的说明开始。然后，我们将快速查看Python 3.*x*中的NumPy库。NumPy是几乎所有Python科学用途的基础，并且您需要知道如何在基本水平上使用它。接下来，我将介绍SciPy。这也是科学上必需的工具包，但在这里我们只需要使用它的一小部分。最后，我会简要介绍Scikit-Learn工具包，这里简称为`sklearn`。这个有价值的工具包实现了许多传统的机器学习模型。
- en: 'Throughout the book, I’ll often use running examples to illustrate concepts.
    All code snippets assume the following line has been executed:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我经常使用运行示例来说明概念。所有代码片段都假定执行了以下行：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Also, in some places, the code will reference output from a snippet that appeared
    earlier in the chapter. The code examples are brief, so following one to the next
    shouldn’t be burdensome. I do recommend leaving a single Python session running
    as you work through a chapter, though this is not required.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在某些地方，代码将引用本章前面出现的片段的输出。代码示例很简短，因此从一个到另一个的跟随不应该是繁琐的。我建议在您阅读一章时保持单个Python会话运行，尽管这不是必需的。
- en: Installing the Toolkits
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装工具包
- en: 'The end goal of this section is to have the following toolkits installed with
    *at least* the version number listed:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的最终目标是安装以下工具包，并且*至少*具有列出的版本号：
- en: Python 3.8.5
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.8.5
- en: NumPy 1.17.4
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy 1.17.4
- en: SciPy 1.4.1
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SciPy 1.4.1
- en: Matplotlib 3.1.2
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Matplotlib 3.1.2
- en: Scikit-Learn (`sklearn`) 0.23.2
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scikit-Learn (`sklearn`) 0.23.2
- en: Later versions than these almost certainly will work as well.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 比这些版本更新的版本几乎肯定也会起作用。
- en: Let’s take a quick look at how we can install each of these toolkits in the
    major operating systems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看看如何在主要操作系统中安装这些工具包。
- en: Linux
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Linux
- en: For the following, the `$` prompt represents the command line, whereas `>>>`
    is the Python prompt.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下内容，`$`提示符表示命令行，而`>>>`是Python提示符。
- en: A fresh install of Ubuntu 20.04 desktop gives us Python 3.8.5 for free. Use
    the code
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu 20.04桌面的新安装为我们提供了Python 3.8.5。使用以下代码
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: to verify your operating system version and use `python3` to run Python, as
    `python` alone starts the older Python 2.7.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 验证您的操作系统版本并使用`python3`运行Python，因为仅使用`python`将启动较旧的Python 2.7。
- en: 'These commands install NumPy, SciPy, Matplotlib, and `sklearn`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令安装了NumPy、SciPy、Matplotlib和`sklearn`：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Test the installation by starting Python 3 and importing each module: `numpy`,
    `scipy`, and `sklearn`. Then print the `__version__` string to make sure it meets
    or exceeds the versions listed above. For example, see the following code.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启动Python 3并导入每个模块（`numpy`，`scipy`和`sklearn`）来测试安装。然后打印`__version__`字符串以确保它符合或超过上述版本。例如，请参阅以下代码。
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: macOS
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: macOS
- en: To install Python 3.*x* for Macintosh, go to *[https://www.python.org/](https://www.python.org/)*,
    and under **Downloads**, choose **Mac OS X**. Then select the latest stable Python
    3 release. At the time of this writing, it’s 3.9.2\. When the download is complete,
    run the installer to get Python 3.9.2 set up.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'After the installation, open a terminal window and verify the installation
    with the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Assuming Python 3 installed correctly, now we can install the libraries using
    the terminal window and `pip3`, which the installer set up for us:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: And, finally, we can check the versions of the libraries from within Python
    3\. Enter **python3** in the terminal to pull up a Python console, and then import
    `numpy`, `scipy`, `matplotlib`, and `sklearn` and print the version strings, as
    we did above, to verify that they meet or exceed the minimum versions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To install Python 3 and the toolkits for Windows 10, use the following steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Go to *[https://www.python.org/](https://www.python.org/)* and click **Downloads**
    and **Windows**.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the bottom of the page, select the x86-64 executable installer.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the installer, choosing the default options.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Install for All Users** and **Add Python to the Windows PATH**. This
    is important.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the installer finishes, Python will be available from the command prompt
    because we told the installer to add Python to the `PATH` environment variable.
    Therefore, open the command prompt (WINDOWS-R, `cmd`), and enter `python`. If
    all goes well, you’ll be greeted by the Python startup message and see a `>>>`
    interactive prompt. At the time of this writing, the version installed was 3.8.2\.
    Note that to exit Python in Windows, use CTRL-Z, not CTRL-D.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python installer did us the courtesy of installing `pip` as well. We can
    use it directly from the Windows command prompt to install the libraries we need.
    At the prompt, enter the following lines to install the NumPy, SciPy, Matplotlib,
    and `sklearn` libraries:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For me, this installed NumPy 1.18.1, SciPy 1.4.1, Matplotlib 3.2.1, and `sklearn`
    0.22.2, which meet the minimum versions above, so all is well.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: To test things, start Python from the command prompt and import `numpy`, `scipy`,
    `matplotlib`, and `sklearn`. All three should load without error. To write Python
    code, install any editor you’re comfortable with, or simply use Notepad.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: With your toolkits installed and good to go, let’s take a quick look at each
    library to become at least a bit more familiar with them. We’ll see examples throughout
    the book, but I recommend you look at the suggested documentation. It’s worth
    it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: NumPy
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We installed NumPy in the previous section. Now I’ll introduce some basic NumPy
    concepts and manipulations. A full tutorial is available online at *[https://docs.scipy.org/doc/numpy/user/quickstart.html](https://docs.scipy.org/doc/numpy/user/quickstart.html)*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Start Python. Then try the following at the prompt:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first line loads NumPy and sets up a shortcut name for it, `np`. Using the
    shortcut name isn’t required, but doing so is nearly universal. We’ll assume `np`
    going forward. The second line displays the version. It should be at least what
    is shown above.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Defining Arrays
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'NumPy operates on arrays and is quite good at turning lists into arrays. Think
    about the sort of arrays one finds in a language like C or Java. NumPy provides
    an advantage because although Python is elegant, it’s too slow for scientific
    uses when simulating arrays with lists. Actual arrays are much faster. Here’s
    an example defining an array from a list, and then examining some of its properties:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This example defines a list of four elements and then passes it to `np.array`
    to turn it into a NumPy array. Basic array properties include the size and the
    shape. The size is four elements. The shape is also four, as a tuple, showing
    that `a` is a vector, a one-dimensional (1D) array. The shape is four because
    array `a` has four elements. If `a` was two-dimensional (2D), the shape would
    have two values, one for each axis of the array. See the following example, where
    the shape of `b` tells us that `b` has two rows and four columns:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Data Types
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Python numeric data types come in two flavors: integers of arbitrary size (try
    `2**1000`) or floating-point numbers. NumPy, however, allows for arrays of many
    different types. Under the hood, NumPy is implemented in C, so it supports the
    same set of data types C supports. The previous example shows that the `np.array`
    function took the given list and, since every element of the list was an integer,
    created an array where each element was a signed 64-bit integer. [Table 1-1](ch01.xhtml#ch01tab01)
    has the data types NumPy works with; we can let NumPy choose the data type for
    us, or we can specify it explictly.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 1-1:** NumPy Data Type Names, C Equivalents, and Range'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '| **NumPy name** | **Equivalent C type** | **Range** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| float64 | double | ±[2.225 × 10^(–308), 1.798 × 10^(308)] |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| float32 | float | ±[1.175 × 10^(–38), 3.403 × 10^(38)] |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| int64 | long long | [–2^(63), 2^(63)–1] |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| uint64 | unsigned long long | [0, 2^(64)–1] |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| int32 | long | [–2^(31), 2^(31)–1] |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| uint32 | unsigned long | [0, 2^(32)–1] |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| uint8 | unsigned char | [0, 255 = 2²–1] |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: 'Let’s look at some examples of arrays with specific data types:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The examples with array `a` use integer types, and the examples with array `b`
    use floating-point types. Notice that the first `b` example defaulted to a 64-bit
    float. NumPy did this because one of the input list elements was a float (`4.0`).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The last example defining array `c` seems to be a bug. But it isn’t. NumPy doesn’t
    warn us if the requested data type can’t hold the given values. Here, we have
    an 8-bit integer that can only hold values in the range [0, 255]. The first two,
    111 and 222, fit, but the last two, 333 and 444, are too large. NumPy quietly
    kept only the lowest 8 bits of these values, which correspond to 77 and 188, respectively.
    The lesson is that NumPy expects you to know what you’re doing in regard to data
    types. Usually, this isn’t an issue, but it is something to keep in mind.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 2D Arrays
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a list turns into a 1D vector, we might suspect that a list of lists would
    turn into a 2D array. We’d be right:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We see that a list of three sublists is mapped to a 3 × 3 array (a matrix).
    Subscripts on NumPy arrays count from zero, so referencing `d[1,2]` above returns
    6.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Zeros and Ones
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Two particularly useful NumPy functions are `np.zeros` and `np.ones`. Both
    define arrays given a shape. The first initializes the array elements to zero,
    while the second initializes them to one. This is the primary way to create NumPy
    arrays from scratch:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first argument is a tuple giving the size of each dimension. If we pass
    in a scalar, the resulting array is a 1D vector. Let’s look at the definition
    of `b`. Here, we multiply the 3 × 1 array by a scalar (`11`). This causes each
    element of the array, which was initialized to 1.0, to be multiplied by 11.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Indexing
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We saw simple array indexing in the examples above, where we indexed with a
    single value. NumPy supports more sophisticated array indexing. One type we’ll
    use often is a single index that returns a complete subarray. Here’s an example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This example introduces `np.arange`, which is the NumPy equivalent of Python’s
    `range` function. Notice the use of the `reshape` method to change the 12-element
    vector into a 3 × 4 matrix. Also, notice that `a[1]` returns the entire subarray,
    starting with the first index of the first dimension. This syntax is short for
    `a[1,:]` where `:` means all elements of the given dimension. This shorthand also
    works for assignments, as the next line shows.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'The same syntax for indexing slices from a Python list works with NumPy. Here’s
    what that looks like if we continue with the example above:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We see that `a[:2]` returns the first two rows with an implied `:` for the
    second dimension, as the following line shows. With our third command, we get
    a subarray in two dimensions by taking the first two rows and first three columns
    with `a[:2,:3]`. The examples with `b` show how to extract every other or every
    third element. The last example is particularly handy: it uses a negative increment
    to reverse the dimension. The increment is –1 to reverse all values. If it was
    –2, we’d get every other element of `b` in reverse order.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy uses `:` to indicate all the elements along a specific dimension. It
    also allows `...` (ellipsis) as a shorthand for “as many `:`s as needed.” For
    example, let’s define a three-dimensional (3D) array:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy使用`:`表示特定维度上所有元素。它还允许使用`...`（省略号）作为“根据需要使用多个`:`”的简写。例如，让我们定义一个三维（3D）数组：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can think of array `a` as a collection of four 3 × 2 matrices. To update
    the second of these matrices, you could use the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把数组`a`看作是四个3 × 2矩阵的集合。要更新其中的第二个矩阵，你可以使用如下代码：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we specified the dimensions explicitly with `:` and showed that NumPy
    isn’t picky: it knows that a list of lists matched the expected shape of the subarray
    and updated array `a` accordingly. We get the same effect by using the ellipsis
    as seen next.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`:`显式地指定了维度，并展示了NumPy并不挑剔：它知道一个列表的列表符合子数组的预期形状，并相应地更新了数组`a`。我们也可以使用省略号`...`来实现相同的效果，如下所示。
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We’ve now updated the third 3 × 2 subarray.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经更新了第三个3 × 2子数组。
- en: Reading and Writing to Disk
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 读取和写入磁盘
- en: 'NumPy arrays can be written to and loaded from disk by using `np.save` and
    `np.load`, like so:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组可以通过使用`np.save`和`np.load`从磁盘写入和加载，如下所示：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we’re using `np.random.randint` to create a random 3 × 4 integer array
    with values in the range 0 through 5\. NumPy has extensive libraries for random
    numbers. We write array `a` to disk as `random.npy`. The `.npy` extension is necessary
    and will be added if we don’t supply it. We then load the array back from disk
    using `np.load`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`np.random.randint`创建一个随机的3 × 4整数数组，值的范围在0到5之间。NumPy拥有丰富的随机数库。我们将数组`a`保存为`random.npy`文件。`.npy`扩展名是必要的，如果没有提供，系统会自动添加。然后，我们使用`np.load`从磁盘加载该数组。
- en: We’ll encounter other NumPy functions throughout the book. I’ll explain them
    when they’re first introduced. Let’s move on now to a quick look at the SciPy
    library.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中遇到其他NumPy函数。我会在首次介绍时对它们进行解释。接下来，让我们快速了解一下SciPy库。
- en: SciPy
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SciPy
- en: 'SciPy adds a plethora of functionality to Python. It uses NumPy under the hood,
    so the two are often installed together. A full tutorial is available here: *[https://docs.scipy.org/doc/scipy/reference/tutorial/index.html](https://docs.scipy.org/doc/scipy/reference/tutorial/index.html)*.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy为Python添加了大量功能。它在底层使用NumPy，因此这两个库通常是一起安装的。这里有一个完整的教程：[https://docs.scipy.org/doc/scipy/reference/tutorial/index.html](https://docs.scipy.org/doc/scipy/reference/tutorial/index.html)。
- en: 'In this book, we’ll focus on the functions in the `scipy.stats` module. Start
    Python and try the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将重点介绍`scipy.stats`模块中的函数。启动Python并尝试以下操作：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This loads the SciPy module and verifies that the version number is at least
    what it should be. Any later version of SciPy should work just fine.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这会加载SciPy模块并验证版本号至少是应该的版本。任何更新的SciPy版本应该都能正常工作。
- en: 'As a quick test, let’s try the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 作为快速测试，让我们尝试以下操作：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'First, we load NumPy and then the `ttest_ind` function from SciPy’s `stats`
    module. This function takes two sets of data, say test scores from two classes,
    and asks the question: do these sets of data have the same average value? Or,
    more accurately, it asks: how strongly can we believe that the same process generated
    these two sets of data? The *t-test* is a classic method for answering this question.
    One way to evaluate its result is to look at the *p-value*. You can think of a
    *p*-value as the probability that the two sets would have the measured difference
    in average value if they came from the same generating process. A probability
    near 1 means we have a lot of confidence that the two sets are from the same process.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们加载NumPy，然后加载SciPy的`stats`模块中的`ttest_ind`函数。该函数接受两组数据，例如两班的考试成绩，并提出问题：这两组数据的平均值是否相同？或者，更准确地说，它问：我们能有多大信心认为这两组数据来自相同的过程？*t检验*是回答这个问题的经典方法。评估其结果的一种方式是查看*p值*。你可以将*p值*理解为如果这两组数据来自相同的生成过程，它们的平均值差异会有多大概率出现。接近1的概率意味着我们非常有信心这两组数据来自同一个过程。
- en: 'The variables `a`, `b`, and `c` are 1D arrays where the values from the array
    (here 1,000) are extracted from Gaussian curves, also called *normal curves*.
    We’ll get to these later, but for now, know that the numbers are pulled from a
    bell curve where values near the middle are more likely to be selected than those
    near the edges. The first two arguments to `normal` are the average value and
    the standard deviation, a measure of how spread out the bell curve is: the larger
    the standard deviation, the flatter, and wider, the curve.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we’d expect `a` and `b` to be very similar, as they both have
    an average value of 0.0, though slightly different bell curve shapes. However,
    `c` has an average value of 0.1\. We hope the t-test picks up on this and tells
    us that we might want to be careful in believing `a` and `c` were generated by
    the same process.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The output of the `ttest_ind` function lists the *p*-value (`pvalue`). And,
    as we expected, comparing `a` and `b` returns a *p*-value of 0.98, meaning that
    the probability we’d see the difference between the averages of these two sets
    of data, given they came from the same generating process, is about 98 percent.
    However, when we compare `a` and `c`, we get a *p*-value of 2.7 percent (0.027).
    This means there is about a 3 percent chance we’d see the difference between `a`
    and `c` if they were generated by the same process. Therefore, we conclude that
    `a` and `c` are from different processes. We state, then, that the difference
    between these two datasets is *statistically significant*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Historically, *p*-values less than 0.05 have been considered statistically significant.
    However, this threshold is arbitrary, and recent experience in replicating experiments,
    especially in the soft sciences, has led to a call for a stricter threshold. Using
    a *p*-value of 0.05 means you’ll be wrong about 1 time in 20 (1/20 = 0.05), which
    is too generous a threshold. That said, a *p*-value close to 0.05 suggests that
    *something* is going on, and more investigation (and a larger dataset) is warranted.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll use Matplotlib to generate graphs. Let’s verify its 2D and 3D plotting
    abilities here. First, a simple 2D example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This example loads NumPy, with which Matplotlib works best, and generates a
    vector, `x`, of 100 random values, [0, 1), the output of `np.random.random`. We
    then use `plt.plot` to plot the vector and `plt.show` to display it. Matplotlib
    output is interactive. Play around with the plot to get familiar with how to use
    the plot window. For example, [Figure 1-1](ch01.xhtml#ch01fig01) shows what the
    plot window looks like on Linux. Since the plot is random, you’ll see a different
    sequence of values, but the controls on the window will be the same.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/01fig01.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-1: A sample Matplotlib plotting window*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'For 3D, give this a try:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We first load the 3D axes toolkit, Matplotlib, and NumPy. Then, using NumPy,
    we generate three random vectors, [0, 1). These are our 3D points. Using `plt.figure`
    and `fig.add_subplot`, we set up a 3D projection. The `111` is shorthand telling
    Matplotlib that we want a grid of 1 × 1 and that the current plot should go in
    index 1 of that grid. So, `111` means a single plot. The `projection` keyword
    gets the plot ready for 3D. Finally, the scatter plot is made, `ax.scatter`, and
    shown, `plt.show`. As with the 2D plot, the 3D plot is interactive. Grab and hold
    with the mouse to rotate the plot.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Scikit-Learn
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The goal of this book is to cover the math of deep learning, not the implementation
    of deep learning. However, from time to time, it’ll be helpful to look at a simple
    neural network model or two. In those cases, we’ll make use of `sklearn`, in particular,
    the `MLPClassifier` class. Also, `sklearn` contains some useful tools for evaluating
    the performance of a model and for visualization of high-dimensional data.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick example, let’s build a simple neural network to classify small 8×8-pixel
    grayscale images of handwritten digits. This dataset is built into `sklearn`.
    Here’s the code for the example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We first import NumPy. From `sklearn` itself, we import the `load_digits` function
    to return the small digit image dataset and the `MLPClassifier` class to train
    a traditional neural network, that is, a multilayer perceptron. We then get the
    digit data and pull out the images and their associated labels, 0 . . . 9 ❶. The
    digit images are stored as 8 × 8 = 64-element vectors representing the image unraveled
    so the rows are laid end to end. The digits data-set includes 1,797 images, so
    `digits` is a 2D NumPy array with 1,797 rows, with 64 columns per row, and `labels`
    is a vector of 1,797 digit labels.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: We randomize the order of the images, being careful to keep the right label
    with the right digit ❷ and extract train and test data (`x_train`, `x_test`) and
    labels (`y_train`, `y_test`). We’ll set the first 200 digit images aside to use
    as test data and train the model with the remaining 1,597 images. This leaves
    us with approximately 160 images of each digit to train with and about 20 of each
    digit for testing.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Next, we build the model by creating an instance of `MLPClassifier` ❸. We’ll
    take all the defaults and specify only the size of the single hidden layer, which
    has 128 nodes. The input vectors are 64 elements, so we double that for the hidden
    layer. There’s no need to specify the output layer size explicitly; `sklearn`
    deduces it from the labels in `y_train`. Training the model is a simple call to
    `clf.fit` passing the training image vectors (`x_train`) and labels (`y_train`).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Training for a small dataset like this will take only a few seconds. When it’s
    done, the learned weights and biases are in the model (`clf`). We first get the
    score, the overall accuracy (`score`), and then the actual model class label predictions
    on the test set (`pred`). Any errors are captured in `err` by looking for places
    where the actual label (`y_test`) does not match the prediction. We end by showing
    the actual class label and predicted label for the errors.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像这样的一个小数据集，训练只需要几秒钟。当训练完成后，学习到的权重和偏差会存储在模型（`clf`）中。我们首先获取得分，整体准确率（`score`），然后是测试集上的实际模型类标签预测（`pred`）。通过查找实际标签（`y_test`）与预测结果不匹配的地方，任何错误都会被捕捉到`err`中。最后，我们展示错误的实际类标签和预测标签。
- en: Each time we run this code, we’ll get a different ordering of the digit data,
    which leads to a different train and test set. Additionally, neural networks are
    randomly initialized prior to training. So, we’ll get a different result each
    time. The first time I ran this code, I had an overall score of 0.97 (97 percent)
    accuracy. Guessing would give an accuracy of about 10 percent, so we can say that
    the model has learned rather well.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行这段代码时，我们都会得到不同的数字数据排序，这导致了不同的训练集和测试集。此外，神经网络在训练前是随机初始化的。所以，每次我们都会得到不同的结果。我第一次运行这段代码时，整体得分为0.97（97%的准确率）。如果通过猜测来预测，准确率大约为10%，因此我们可以说模型已经学得相当不错了。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to configure our working environment. I then
    introduced our suite of Python toolkits at a high level and supplied pointers
    on where to learn more. With the work environment secure and flourishing, the
    next chapter dives headfirst into probability theory.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何配置我们的工作环境。接着，我从高层次介绍了我们的 Python 工具包，并提供了进一步学习的指引。在工作环境安全并繁荣发展的基础上，下一章将深入探讨概率论。
