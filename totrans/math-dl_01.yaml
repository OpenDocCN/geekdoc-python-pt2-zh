- en: '**1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SETTING THE STAGE**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although this book has no traditional math exercises, we do need to play around
    with the concepts if we want to master them. We’ll have plenty of opportunities
    for that, but instead of pencil and paper exercises, we’ll use code.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will help you set the stage by configuring our working environment.
    Throughout the book, I’ll work in Linux, specifically Ubuntu 20.04, though what
    we’re doing most likely will work in later versions of Ubuntu and most other Linux
    distributions as well. For completeness, I’ve included sections on configuring
    macOS and Windows environments. I should point out that the expected operating
    system for deep learning is Linux, with most things working under macOS as well.
    Windows is typically an afterthought, and many deep learning toolkit ports are
    poorly maintained, though this is improving with time.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin with some instructions for installing the expected software packages.
    Then we’ll take a quick look at the NumPy library for Python 3.*x*. NumPy is foundational
    to virtually all scientific uses of Python, and it’s essential that you know how
    to work with it at a basic level. Next, I’ll introduce SciPy. This is also a necessary
    toolkit for science, but we’ll only need the tiniest portion of it here. Finally,
    I’ll talk a bit about the Scikit-Learn toolkit, abbreviated here as sklearn. This
    valuable toolkit implements many of the traditional machine learning models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout the book, I’ll often use running examples to illustrate concepts.
    All code snippets assume the following line has been executed:'
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  prefs: []
  type: TYPE_NORMAL
- en: Also, in some places, the code will reference output from a snippet that appeared
    earlier in the chapter. The code examples are brief, so following one to the next
    shouldn’t be burdensome. I do recommend leaving a single Python session running
    as you work through a chapter, though this is not required.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Toolkits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The end goal of this section is to have the following toolkits installed with
    *at least* the version number listed:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.8.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NumPy 1.17.4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SciPy 1.4.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matplotlib 3.1.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scikit-Learn (sklearn) 0.23.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Later versions than these almost certainly will work as well.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a quick look at how we can install each of these toolkits in the
    major operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the following, the $ prompt represents the command line, whereas >>> is
    the Python prompt.
  prefs: []
  type: TYPE_NORMAL
- en: A fresh install of Ubuntu 20.04 desktop gives us Python 3.8.5 for free. Use
    the code
  prefs: []
  type: TYPE_NORMAL
- en: $ cat /etc/os-release
  prefs: []
  type: TYPE_NORMAL
- en: to verify your operating system version and use python3 to run Python, as python
    alone starts the older Python 2.7.
  prefs: []
  type: TYPE_NORMAL
- en: 'These commands install NumPy, SciPy, Matplotlib, and sklearn:'
  prefs: []
  type: TYPE_NORMAL
- en: $ sudo apt-get install python3-pip
  prefs: []
  type: TYPE_NORMAL
- en: $ sudo apt-get install python3-numpy
  prefs: []
  type: TYPE_NORMAL
- en: $ sudo apt-get install python3-scipy
  prefs: []
  type: TYPE_NORMAL
- en: $ sudo pip3 install matplotlib
  prefs: []
  type: TYPE_NORMAL
- en: $ sudo pip3 install scikit-learn
  prefs: []
  type: TYPE_NORMAL
- en: 'Test the installation by starting Python 3 and importing each module: numpy,
    scipy, and sklearn. Then print the __version__ string to make sure it meets or
    exceeds the versions listed above. For example, see the following code.'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> import numpy; numpy.__version__'
  prefs: []
  type: TYPE_NORMAL
- en: '''1.17.4'''
  prefs: []
  type: TYPE_NORMAL
- en: '>>> import scipy; scipy.__version__'
  prefs: []
  type: TYPE_NORMAL
- en: '''1.4.1'''
  prefs: []
  type: TYPE_NORMAL
- en: '>>> import matplotlib; matplotlib.__version__'
  prefs: []
  type: TYPE_NORMAL
- en: '''3.1.2'''
  prefs: []
  type: TYPE_NORMAL
- en: '>>> import sklearn; sklearn.__version__'
  prefs: []
  type: TYPE_NORMAL
- en: '''0.23.2'''
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To install Python 3.*x* for Macintosh, go to *[https://www.python.org/](https://www.python.org/)*,
    and under **Downloads**, choose **Mac OS X**. Then select the latest stable Python
    3 release. At the time of this writing, it’s 3.9.2\. When the download is complete,
    run the installer to get Python 3.9.2 set up.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the installation, open a terminal window and verify the installation
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: $ python3 --version
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.9.2
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming Python 3 installed correctly, now we can install the libraries using
    the terminal window and pip3, which the installer set up for us:'
  prefs: []
  type: TYPE_NORMAL
- en: $ pip3 install numpy --user
  prefs: []
  type: TYPE_NORMAL
- en: $ pip3 install scipy --user
  prefs: []
  type: TYPE_NORMAL
- en: $ pip3 install matplotlib --user
  prefs: []
  type: TYPE_NORMAL
- en: $ pip3 install scikit-learn --user
  prefs: []
  type: TYPE_NORMAL
- en: And, finally, we can check the versions of the libraries from within Python
    3\. Enter **python3** in the terminal to pull up a Python console, and then import
    numpy, scipy, matplotlib, and sklearn and print the version strings, as we did
    above, to verify that they meet or exceed the minimum versions.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To install Python 3 and the toolkits for Windows 10, use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to *[https://www.python.org/](https://www.python.org/)* and click **Downloads**
    and **Windows**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the bottom of the page, select the x86-64 executable installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the installer, choosing the default options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Install for All Users** and **Add Python to the Windows PATH**. This
    is important.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the installer finishes, Python will be available from the command prompt
    because we told the installer to add Python to the PATH environment variable.
    Therefore, open the command prompt (WINDOWS-R, cmd), and enter python. If all
    goes well, you’ll be greeted by the Python startup message and see a >>> interactive
    prompt. At the time of this writing, the version installed was 3.8.2\. Note that
    to exit Python in Windows, use CTRL-Z, not CTRL-D.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python installer did us the courtesy of installing pip as well. We can
    use it directly from the Windows command prompt to install the libraries we need.
    At the prompt, enter the following lines to install the NumPy, SciPy, Matplotlib,
    and sklearn libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: pip install numpy
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: pip install scipy
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: pip install matplotlib
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: pip install sklearn
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For me, this installed NumPy 1.18.1, SciPy 1.4.1, Matplotlib 3.2.1, and sklearn
    0.22.2, which meet the minimum versions above, so all is well.
  prefs: []
  type: TYPE_NORMAL
- en: To test things, start Python from the command prompt and import numpy, scipy,
    matplotlib, and sklearn. All three should load without error. To write Python
    code, install any editor you’re comfortable with, or simply use Notepad.
  prefs: []
  type: TYPE_NORMAL
- en: With your toolkits installed and good to go, let’s take a quick look at each
    library to become at least a bit more familiar with them. We’ll see examples throughout
    the book, but I recommend you look at the suggested documentation. It’s worth
    it.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We installed NumPy in the previous section. Now I’ll introduce some basic NumPy
    concepts and manipulations. A full tutorial is available online at *[https://docs.scipy.org/doc/numpy/user/quickstart.html](https://docs.scipy.org/doc/numpy/user/quickstart.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start Python. Then try the following at the prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> import numpy as np'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> np.__version__'
  prefs: []
  type: TYPE_NORMAL
- en: '''1.16.2'''
  prefs: []
  type: TYPE_NORMAL
- en: The first line loads NumPy and sets up a shortcut name for it, np. Using the
    shortcut name isn’t required, but doing so is nearly universal. We’ll assume np
    going forward. The second line displays the version. It should be at least what
    is shown above.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'NumPy operates on arrays and is quite good at turning lists into arrays. Think
    about the sort of arrays one finds in a language like C or Java. NumPy provides
    an advantage because although Python is elegant, it’s too slow for scientific
    uses when simulating arrays with lists. Actual arrays are much faster. Here’s
    an example defining an array from a list, and then examining some of its properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a = np.array([1,2,3,4])'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a'
  prefs: []
  type: TYPE_NORMAL
- en: array([1, 2, 3, 4])
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a.size'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a.shape'
  prefs: []
  type: TYPE_NORMAL
- en: (4,)
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a.dtype'
  prefs: []
  type: TYPE_NORMAL
- en: dtype('int64')
  prefs: []
  type: TYPE_NORMAL
- en: 'This example defines a list of four elements and then passes it to np.array
    to turn it into a NumPy array. Basic array properties include the size and the
    shape. The size is four elements. The shape is also four, as a tuple, showing
    that a is a vector, a one-dimensional (1D) array. The shape is four because array
    a has four elements. If a was two-dimensional (2D), the shape would have two values,
    one for each axis of the array. See the following example, where the shape of
    b tells us that b has two rows and four columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b = np.array([[1,2,3,4],[5,6,7,8]])'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> print(b)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[1 2 3 4]'
  prefs: []
  type: TYPE_NORMAL
- en: '[5 6 7 8]]'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b.shape'
  prefs: []
  type: TYPE_NORMAL
- en: (2, 4)
  prefs: []
  type: TYPE_NORMAL
- en: Data Types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Python numeric data types come in two flavors: integers of arbitrary size (try
    2**1000) or floating-point numbers. NumPy, however, allows for arrays of many
    different types. Under the hood, NumPy is implemented in C, so it supports the
    same set of data types C supports. The previous example shows that the np.array
    function took the given list and, since every element of the list was an integer,
    created an array where each element was a signed 64-bit integer. [Table 1-1](ch01.xhtml#ch01tab01)
    has the data types NumPy works with; we can let NumPy choose the data type for
    us, or we can specify it explictly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 1-1:** NumPy Data Type Names, C Equivalents, and Range'
  prefs: []
  type: TYPE_NORMAL
- en: '| **NumPy name** | **Equivalent C type** | **Range** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| float64 | double | ±[2.225 × 10^(–308), 1.798 × 10^(308)] |'
  prefs: []
  type: TYPE_TB
- en: '| float32 | float | ±[1.175 × 10^(–38), 3.403 × 10^(38)] |'
  prefs: []
  type: TYPE_TB
- en: '| int64 | long long | [–2^(63), 2^(63)–1] |'
  prefs: []
  type: TYPE_TB
- en: '| uint64 | unsigned long long | [0, 2^(64)–1] |'
  prefs: []
  type: TYPE_TB
- en: '| int32 | long | [–2^(31), 2^(31)–1] |'
  prefs: []
  type: TYPE_TB
- en: '| uint32 | unsigned long | [0, 2^(32)–1] |'
  prefs: []
  type: TYPE_TB
- en: '| uint8 | unsigned char | [0, 255 = 2²–1] |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s look at some examples of arrays with specific data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a = np.array([1,2,3,4], dtype="uint8")'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a.dtype'
  prefs: []
  type: TYPE_NORMAL
- en: dtype('uint8')
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a = np.array([1,2,3,4], dtype="int16")'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a = np.array([1,2,3,4], dtype="uint32")'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b = np.array([1,2,3,4.0])'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b.dtype'
  prefs: []
  type: TYPE_NORMAL
- en: dtype('float64')
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b = np.array([1,2,3,4.0], dtype="float32")'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> c = np.array([111,222,333,444], dtype="uint8")'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> c'
  prefs: []
  type: TYPE_NORMAL
- en: array([111, 222,  77, 188], dtype=uint8)
  prefs: []
  type: TYPE_NORMAL
- en: The examples with array a use integer types, and the examples with array b use
    floating-point types. Notice that the first b example defaulted to a 64-bit float.
    NumPy did this because one of the input list elements was a float (4.0).
  prefs: []
  type: TYPE_NORMAL
- en: The last example defining array c seems to be a bug. But it isn’t. NumPy doesn’t
    warn us if the requested data type can’t hold the given values. Here, we have
    an 8-bit integer that can only hold values in the range [0, 255]. The first two,
    111 and 222, fit, but the last two, 333 and 444, are too large. NumPy quietly
    kept only the lowest 8 bits of these values, which correspond to 77 and 188, respectively.
    The lesson is that NumPy expects you to know what you’re doing in regard to data
    types. Usually, this isn’t an issue, but it is something to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 2D Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a list turns into a 1D vector, we might suspect that a list of lists would
    turn into a 2D array. We’d be right:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d = np.array([[1,2,3],[4,5,6],[7,8,9]])'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d.shape'
  prefs: []
  type: TYPE_NORMAL
- en: (3, 3)
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d.size'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> d'
  prefs: []
  type: TYPE_NORMAL
- en: array([[1, 2, 3],
  prefs: []
  type: TYPE_NORMAL
- en: '[4, 5, 6],'
  prefs: []
  type: TYPE_NORMAL
- en: '[7, 8, 9]])'
  prefs: []
  type: TYPE_NORMAL
- en: We see that a list of three sublists is mapped to a 3 × 3 array (a matrix).
    Subscripts on NumPy arrays count from zero, so referencing d[1,2] above returns
    6.
  prefs: []
  type: TYPE_NORMAL
- en: Zeros and Ones
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Two particularly useful NumPy functions are np.zeros and np.ones. Both define
    arrays given a shape. The first initializes the array elements to zero, while
    the second initializes them to one. This is the primary way to create NumPy arrays
    from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a = np.zeros((3,4), dtype="uint32")'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a[0,3] = 42'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a[1,1] = 66'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a'
  prefs: []
  type: TYPE_NORMAL
- en: array([[ 0,  0,  0, 42],
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0, 66,  0,  0],'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 0,  0,  0,  0]], dtype=uint32)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b = 11*np.ones((3,1))'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b'
  prefs: []
  type: TYPE_NORMAL
- en: array([[11.],
  prefs: []
  type: TYPE_NORMAL
- en: '[11.],'
  prefs: []
  type: TYPE_NORMAL
- en: '[11.]])'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is a tuple giving the size of each dimension. If we pass
    in a scalar, the resulting array is a 1D vector. Let’s look at the definition
    of b. Here, we multiply the 3 × 1 array by a scalar (11). This causes each element
    of the array, which was initialized to 1.0, to be multiplied by 11.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Indexing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We saw simple array indexing in the examples above, where we indexed with a
    single value. NumPy supports more sophisticated array indexing. One type we’ll
    use often is a single index that returns a complete subarray. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a = np.arange(12).reshape((3,4))'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a'
  prefs: []
  type: TYPE_NORMAL
- en: array([[ 0,  1,  2,  3],
  prefs: []
  type: TYPE_NORMAL
- en: '[ 4,  5,  6,  7],'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 8,  9, 10, 11]])'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a[1]'
  prefs: []
  type: TYPE_NORMAL
- en: array([4, 5, 6, 7])
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a[1] = [44,55,66,77]'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a'
  prefs: []
  type: TYPE_NORMAL
- en: array([[ 0,  1,  2,  3],
  prefs: []
  type: TYPE_NORMAL
- en: '[44, 55, 66, 77],'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 8,  9, 10, 11]])'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example introduces np.arange, which is the NumPy equivalent of Python’s
    range function. Notice the use of the reshape method to change the 12-element
    vector into a 3 × 4 matrix. Also, notice that a[1] returns the entire subarray,
    starting with the first index of the first dimension. This syntax is short for
    a[1,:] where : means all elements of the given dimension. This shorthand also
    works for assignments, as the next line shows.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same syntax for indexing slices from a Python list works with NumPy. Here’s
    what that looks like if we continue with the example above:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a[:2]'
  prefs: []
  type: TYPE_NORMAL
- en: array([[ 0,  1,  2,  3],
  prefs: []
  type: TYPE_NORMAL
- en: '[44, 55, 66, 77]])'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a[:2,:]'
  prefs: []
  type: TYPE_NORMAL
- en: array([[ 0,  1,  2,  3],
  prefs: []
  type: TYPE_NORMAL
- en: '[44, 55, 66, 77]])'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a[:2,:3]'
  prefs: []
  type: TYPE_NORMAL
- en: array([[ 0,  1,  2],
  prefs: []
  type: TYPE_NORMAL
- en: '[44, 55, 66]])'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b = np.arange(12)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b'
  prefs: []
  type: TYPE_NORMAL
- en: array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b[::2]'
  prefs: []
  type: TYPE_NORMAL
- en: array([ 0,  2,  4,  6,  8, 10])
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b[::3]'
  prefs: []
  type: TYPE_NORMAL
- en: array([0, 3, 6, 9])
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b[::-1]'
  prefs: []
  type: TYPE_NORMAL
- en: array([11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1,  0])
  prefs: []
  type: TYPE_NORMAL
- en: 'We see that a[:2] returns the first two rows with an implied : for the second
    dimension, as the following line shows. With our third command, we get a subarray
    in two dimensions by taking the first two rows and first three columns with a[:2,:3].
    The examples with b show how to extract every other or every third element. The
    last example is particularly handy: it uses a negative increment to reverse the
    dimension. The increment is –1 to reverse all values. If it was –2, we’d get every
    other element of b in reverse order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy uses : to indicate all the elements along a specific dimension. It also
    allows ... (ellipsis) as a shorthand for “as many :s as needed.” For example,
    let’s define a three-dimensional (3D) array:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a = np.arange(24).reshape((4,3,2))'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a'
  prefs: []
  type: TYPE_NORMAL
- en: array([[[ 0,  1],
  prefs: []
  type: TYPE_NORMAL
- en: '[ 2,  3],'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 4,  5]],'
  prefs: []
  type: TYPE_NORMAL
- en: '[[ 6,  7],'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 8,  9],'
  prefs: []
  type: TYPE_NORMAL
- en: '[10, 11]],'
  prefs: []
  type: TYPE_NORMAL
- en: '[[12, 13],'
  prefs: []
  type: TYPE_NORMAL
- en: '[14, 15],'
  prefs: []
  type: TYPE_NORMAL
- en: '[16, 17]],'
  prefs: []
  type: TYPE_NORMAL
- en: '[[18, 19],'
  prefs: []
  type: TYPE_NORMAL
- en: '[20, 21],'
  prefs: []
  type: TYPE_NORMAL
- en: '[22, 23]]])'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can think of array a as a collection of four 3 × 2 matrices. To update
    the second of these matrices, you could use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a[1,:,:] = [[11,22],[33,44],[55,66]]'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a'
  prefs: []
  type: TYPE_NORMAL
- en: array([[[ 0,  1],
  prefs: []
  type: TYPE_NORMAL
- en: '[ 2,  3],'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 4,  5]],'
  prefs: []
  type: TYPE_NORMAL
- en: '[[11, 22],'
  prefs: []
  type: TYPE_NORMAL
- en: '[33, 44],'
  prefs: []
  type: TYPE_NORMAL
- en: '[55, 66]],'
  prefs: []
  type: TYPE_NORMAL
- en: '[[12, 13],'
  prefs: []
  type: TYPE_NORMAL
- en: '[14, 15],'
  prefs: []
  type: TYPE_NORMAL
- en: '[16, 17]],'
  prefs: []
  type: TYPE_NORMAL
- en: '[[18, 19],'
  prefs: []
  type: TYPE_NORMAL
- en: '[20, 21],'
  prefs: []
  type: TYPE_NORMAL
- en: '[22, 23]]])'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we specified the dimensions explicitly with : and showed that NumPy isn’t
    picky: it knows that a list of lists matched the expected shape of the subarray
    and updated array a accordingly. We get the same effect by using the ellipsis
    as seen next.'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a[2,...] = [[99,99],[99,99],[99,99]]'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a'
  prefs: []
  type: TYPE_NORMAL
- en: array([[[ 0,  1],
  prefs: []
  type: TYPE_NORMAL
- en: '[ 2,  3],'
  prefs: []
  type: TYPE_NORMAL
- en: '[ 4,  5]],'
  prefs: []
  type: TYPE_NORMAL
- en: '[[11, 22],'
  prefs: []
  type: TYPE_NORMAL
- en: '[33, 44],'
  prefs: []
  type: TYPE_NORMAL
- en: '[55, 66]],'
  prefs: []
  type: TYPE_NORMAL
- en: '[[99, 99],'
  prefs: []
  type: TYPE_NORMAL
- en: '[99, 99],'
  prefs: []
  type: TYPE_NORMAL
- en: '[99, 99]],'
  prefs: []
  type: TYPE_NORMAL
- en: '[[18, 19],'
  prefs: []
  type: TYPE_NORMAL
- en: '[20, 21],'
  prefs: []
  type: TYPE_NORMAL
- en: '[22, 23]]])'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now updated the third 3 × 2 subarray.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and Writing to Disk
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'NumPy arrays can be written to and loaded from disk by using np.save and np.load,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a = np.random.randint(0,5,(3,4))'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a'
  prefs: []
  type: TYPE_NORMAL
- en: array([[4, 2, 1, 3],
  prefs: []
  type: TYPE_NORMAL
- en: '[4, 0, 2, 4],'
  prefs: []
  type: TYPE_NORMAL
- en: '[0, 4, 3, 1]])'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> np.save("random.npy",a)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b = np.load("random.npy")'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b'
  prefs: []
  type: TYPE_NORMAL
- en: array([[4, 2, 1, 3],
  prefs: []
  type: TYPE_NORMAL
- en: '[4, 0, 2, 4],'
  prefs: []
  type: TYPE_NORMAL
- en: '[0, 4, 3, 1]])'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’re using np.random.randint to create a random 3 × 4 integer array with
    values in the range 0 through 5\. NumPy has extensive libraries for random numbers.
    We write array a to disk as random.npy. The .npy extension is necessary and will
    be added if we don’t supply it. We then load the array back from disk using np.load.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll encounter other NumPy functions throughout the book. I’ll explain them
    when they’re first introduced. Let’s move on now to a quick look at the SciPy
    library.
  prefs: []
  type: TYPE_NORMAL
- en: SciPy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SciPy adds a plethora of functionality to Python. It uses NumPy under the hood,
    so the two are often installed together. A full tutorial is available here: *[https://docs.scipy.org/doc/scipy/reference/tutorial/index.html](https://docs.scipy.org/doc/scipy/reference/tutorial/index.html)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we’ll focus on the functions in the scipy.stats module. Start
    Python and try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> import scipy'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> scipy.__version__'
  prefs: []
  type: TYPE_NORMAL
- en: '''1.2.1'''
  prefs: []
  type: TYPE_NORMAL
- en: This loads the SciPy module and verifies that the version number is at least
    what it should be. Any later version of SciPy should work just fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick test, let’s try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> from scipy.stats import ttest_ind'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a = np.random.normal(0,1,1000)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b = np.random.normal(0,0.5,1000)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> c = np.random.normal(0.1,1,1000)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ttest_ind(a,b)'
  prefs: []
  type: TYPE_NORMAL
- en: Ttest_indResult(statistic=-0.027161815649563964, pvalue=0.9783333836992686)
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ttest_ind(a,c)'
  prefs: []
  type: TYPE_NORMAL
- en: Ttest_indResult(statistic=-2.295584443456226, pvalue=0.021802794508002675)
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we load NumPy and then the ttest_ind function from SciPy’s stats module.
    This function takes two sets of data, say test scores from two classes, and asks
    the question: do these sets of data have the same average value? Or, more accurately,
    it asks: how strongly can we believe that the same process generated these two
    sets of data? The *t-test* is a classic method for answering this question. One
    way to evaluate its result is to look at the *p-value*. You can think of a *p*-value
    as the probability that the two sets would have the measured difference in average
    value if they came from the same generating process. A probability near 1 means
    we have a lot of confidence that the two sets are from the same process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The variables a, b, and c are 1D arrays where the values from the array (here
    1,000) are extracted from Gaussian curves, also called *normal curves*. We’ll
    get to these later, but for now, know that the numbers are pulled from a bell
    curve where values near the middle are more likely to be selected than those near
    the edges. The first two arguments to normal are the average value and the standard
    deviation, a measure of how spread out the bell curve is: the larger the standard
    deviation, the flatter, and wider, the curve.'
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we’d expect a and b to be very similar, as they both have
    an average value of 0.0, though slightly different bell curve shapes. However,
    c has an average value of 0.1\. We hope the t-test picks up on this and tells
    us that we might want to be careful in believing a and c were generated by the
    same process.
  prefs: []
  type: TYPE_NORMAL
- en: The output of the ttest_ind function lists the *p*-value (pvalue). And, as we
    expected, comparing a and b returns a *p*-value of 0.98, meaning that the probability
    we’d see the difference between the averages of these two sets of data, given
    they came from the same generating process, is about 98 percent. However, when
    we compare a and c, we get a *p*-value of 2.7 percent (0.027). This means there
    is about a 3 percent chance we’d see the difference between a and c if they were
    generated by the same process. Therefore, we conclude that a and c are from different
    processes. We state, then, that the difference between these two datasets is *statistically
    significant*.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, *p*-values less than 0.05 have been considered statistically significant.
    However, this threshold is arbitrary, and recent experience in replicating experiments,
    especially in the soft sciences, has led to a call for a stricter threshold. Using
    a *p*-value of 0.05 means you’ll be wrong about 1 time in 20 (1/20 = 0.05), which
    is too generous a threshold. That said, a *p*-value close to 0.05 suggests that
    *something* is going on, and more investigation (and a larger dataset) is warranted.
  prefs: []
  type: TYPE_NORMAL
- en: Matplotlib
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll use Matplotlib to generate graphs. Let’s verify its 2D and 3D plotting
    abilities here. First, a simple 2D example:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> import numpy as np'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> import matplotlib.pylab as plt'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x = np.random.random(100)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> plt.plot(x)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> plt.show()'
  prefs: []
  type: TYPE_NORMAL
- en: This example loads NumPy, with which Matplotlib works best, and generates a
    vector, x, of 100 random values, [0, 1), the output of np.random.random. We then
    use plt.plot to plot the vector and plt.show to display it. Matplotlib output
    is interactive. Play around with the plot to get familiar with how to use the
    plot window. For example, [Figure 1-1](ch01.xhtml#ch01fig01) shows what the plot
    window looks like on Linux. Since the plot is random, you’ll see a different sequence
    of values, but the controls on the window will be the same.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/01fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-1: A sample Matplotlib plotting window*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For 3D, give this a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> from mpl_toolkits.mplot3d import Axes3D'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> import matplotlib.pylab as plt'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> import numpy as np'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> x = np.random.random(20)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> y = np.random.random(20)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> z = np.random.random(20)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> fig = plt.figure()'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ax = fig.add_subplot(111, projection=''3d'')'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ax.scatter(x,y,z)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> plt.show()'
  prefs: []
  type: TYPE_NORMAL
- en: We first load the 3D axes toolkit, Matplotlib, and NumPy. Then, using NumPy,
    we generate three random vectors, [0, 1). These are our 3D points. Using plt.figure
    and fig.add_subplot, we set up a 3D projection. The 111 is shorthand telling Matplotlib
    that we want a grid of 1 × 1 and that the current plot should go in index 1 of
    that grid. So, 111 means a single plot. The projection keyword gets the plot ready
    for 3D. Finally, the scatter plot is made, ax.scatter, and shown, plt.show. As
    with the 2D plot, the 3D plot is interactive. Grab and hold with the mouse to
    rotate the plot.
  prefs: []
  type: TYPE_NORMAL
- en: Scikit-Learn
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The goal of this book is to cover the math of deep learning, not the implementation
    of deep learning. However, from time to time, it’ll be helpful to look at a simple
    neural network model or two. In those cases, we’ll make use of sklearn, in particular,
    the MLPClassifier class. Also, sklearn contains some useful tools for evaluating
    the performance of a model and for visualization of high-dimensional data.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a quick example, let’s build a simple neural network to classify small 8×8-pixel
    grayscale images of handwritten digits. This dataset is built into sklearn. Here’s
    the code for the example:'
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  prefs: []
  type: TYPE_NORMAL
- en: from sklearn.datasets import load_digits
  prefs: []
  type: TYPE_NORMAL
- en: from sklearn.neural_network import MLPClassifier
  prefs: []
  type: TYPE_NORMAL
- en: ❶ d = load_digits()
  prefs: []
  type: TYPE_NORMAL
- en: digits = d["data"]
  prefs: []
  type: TYPE_NORMAL
- en: labels = d["target"]
  prefs: []
  type: TYPE_NORMAL
- en: N = 200
  prefs: []
  type: TYPE_NORMAL
- en: ❷ idx = np.argsort(np.random.random(len(labels)))
  prefs: []
  type: TYPE_NORMAL
- en: x_test, y_test = digits[idx[:N]], labels[idx[:N]]
  prefs: []
  type: TYPE_NORMAL
- en: x_train, y_train = digits[idx[N:]], labels[idx[N:]]
  prefs: []
  type: TYPE_NORMAL
- en: ❸ clf = MLPClassifier(hidden_layer_sizes=(128,))
  prefs: []
  type: TYPE_NORMAL
- en: clf.fit(x_train, y_train)
  prefs: []
  type: TYPE_NORMAL
- en: score = clf.score(x_test, y_test)
  prefs: []
  type: TYPE_NORMAL
- en: pred = clf.predict(x_test)
  prefs: []
  type: TYPE_NORMAL
- en: err = np.where(y_test != pred)[0]
  prefs: []
  type: TYPE_NORMAL
- en: 'print("score      : ", score)'
  prefs: []
  type: TYPE_NORMAL
- en: print("errors:")
  prefs: []
  type: TYPE_NORMAL
- en: 'print("  actual   : ", y_test[err])'
  prefs: []
  type: TYPE_NORMAL
- en: 'print("  predicted: ", pred[err])'
  prefs: []
  type: TYPE_NORMAL
- en: We first import NumPy. From sklearn itself, we import the load_digits function
    to return the small digit image dataset and the MLPClassifier class to train a
    traditional neural network, that is, a multilayer perceptron. We then get the
    digit data and pull out the images and their associated labels, 0 . . . 9 ❶. The
    digit images are stored as 8 × 8 = 64-element vectors representing the image unraveled
    so the rows are laid end to end. The digits data-set includes 1,797 images, so
    digits is a 2D NumPy array with 1,797 rows, with 64 columns per row, and labels
    is a vector of 1,797 digit labels.
  prefs: []
  type: TYPE_NORMAL
- en: We randomize the order of the images, being careful to keep the right label
    with the right digit ❷ and extract train and test data (x_train, x_test) and labels
    (y_train, y_test). We’ll set the first 200 digit images aside to use as test data
    and train the model with the remaining 1,597 images. This leaves us with approximately
    160 images of each digit to train with and about 20 of each digit for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we build the model by creating an instance of MLPClassifier ❸. We’ll take
    all the defaults and specify only the size of the single hidden layer, which has
    128 nodes. The input vectors are 64 elements, so we double that for the hidden
    layer. There’s no need to specify the output layer size explicitly; sklearn deduces
    it from the labels in y_train. Training the model is a simple call to clf.fit
    passing the training image vectors (x_train) and labels (y_train).
  prefs: []
  type: TYPE_NORMAL
- en: Training for a small dataset like this will take only a few seconds. When it’s
    done, the learned weights and biases are in the model (clf). We first get the
    score, the overall accuracy (score), and then the actual model class label predictions
    on the test set (pred). Any errors are captured in err by looking for places where
    the actual label (y_test) does not match the prediction. We end by showing the
    actual class label and predicted label for the errors.
  prefs: []
  type: TYPE_NORMAL
- en: Each time we run this code, we’ll get a different ordering of the digit data,
    which leads to a different train and test set. Additionally, neural networks are
    randomly initialized prior to training. So, we’ll get a different result each
    time. The first time I ran this code, I had an overall score of 0.97 (97 percent)
    accuracy. Guessing would give an accuracy of about 10 percent, so we can say that
    the model has learned rather well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we learned how to configure our working environment. I then
    introduced our suite of Python toolkits at a high level and supplied pointers
    on where to learn more. With the work environment secure and flourishing, the
    next chapter dives headfirst into probability theory.
  prefs: []
  type: TYPE_NORMAL
