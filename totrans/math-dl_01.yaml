- en: '**1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**1'
- en: SETTING THE STAGE**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 设置环境**
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: Although this book has no traditional math exercises, we do need to play around
    with the concepts if we want to master them. We’ll have plenty of opportunities
    for that, but instead of pencil and paper exercises, we’ll use code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书没有传统的数学练习，但如果我们想掌握这些概念，还是需要进行一定的练习。我们有很多机会来进行这些练习，但我们将使用代码，而非纸笔。
- en: This chapter will help you set the stage by configuring our working environment.
    Throughout the book, I’ll work in Linux, specifically Ubuntu 20.04, though what
    we’re doing most likely will work in later versions of Ubuntu and most other Linux
    distributions as well. For completeness, I’ve included sections on configuring
    macOS and Windows environments. I should point out that the expected operating
    system for deep learning is Linux, with most things working under macOS as well.
    Windows is typically an afterthought, and many deep learning toolkit ports are
    poorly maintained, though this is improving with time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将帮助你通过配置工作环境来为后续工作做好准备。在整本书中，我将使用 Linux，特别是 Ubuntu 20.04，但我们所做的事情很可能也适用于更新版本的
    Ubuntu 以及大多数其他 Linux 发行版。为了完整性，我还包括了 macOS 和 Windows 环境配置的部分。我应该指出，深度学习所期望的操作系统是
    Linux，虽然大多数事情也可以在 macOS 上运行。Windows 通常是事后考虑的系统，许多深度学习工具包的移植维护得不好，尽管这一点随着时间的推移正在有所改善。
- en: We’ll begin with some instructions for installing the expected software packages.
    Then we’ll take a quick look at the NumPy library for Python 3.*x*. NumPy is foundational
    to virtually all scientific uses of Python, and it’s essential that you know how
    to work with it at a basic level. Next, I’ll introduce SciPy. This is also a necessary
    toolkit for science, but we’ll only need the tiniest portion of it here. Finally,
    I’ll talk a bit about the Scikit-Learn toolkit, abbreviated here as sklearn. This
    valuable toolkit implements many of the traditional machine learning models.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍如何安装预期的软件包。接着，我们将快速了解 Python 3.*x* 的 NumPy 库。NumPy 是几乎所有 Python 科学用途的基础，掌握它的基本用法是非常必要的。然后，我将介绍
    SciPy。这也是科学所需的工具包，但在这里我们只需使用它的极小一部分。最后，我会谈谈 Scikit-Learn 工具包，简写为 sklearn。这个有价值的工具包实现了许多传统的机器学习模型。
- en: 'Throughout the book, I’ll often use running examples to illustrate concepts.
    All code snippets assume the following line has been executed:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我会经常使用运行实例来说明概念。所有代码片段都假设已执行以下行：
- en: import numpy as np
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: Also, in some places, the code will reference output from a snippet that appeared
    earlier in the chapter. The code examples are brief, so following one to the next
    shouldn’t be burdensome. I do recommend leaving a single Python session running
    as you work through a chapter, though this is not required.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在某些地方，代码会引用本章前面出现的代码片段的输出。代码示例较简短，所以从一个到下一个跟着做应该不会造成负担。不过，我确实建议在完成一个章节时保持一个
    Python 会话持续运行，尽管这不是必须的。
- en: Installing the Toolkits
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装工具包
- en: 'The end goal of this section is to have the following toolkits installed with
    *at least* the version number listed:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的最终目标是安装以下工具包，*至少*包括所列的版本号：
- en: Python 3.8.5
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.8.5
- en: NumPy 1.17.4
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy 1.17.4
- en: SciPy 1.4.1
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SciPy 1.4.1
- en: Matplotlib 3.1.2
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Matplotlib 3.1.2
- en: Scikit-Learn (sklearn) 0.23.2
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scikit-Learn (sklearn) 0.23.2
- en: Later versions than these almost certainly will work as well.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 比这些版本更新的版本几乎肯定也能正常工作。
- en: Let’s take a quick look at how we can install each of these toolkits in the
    major operating systems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速了解一下如何在主要操作系统中安装这些工具包。
- en: Linux
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Linux
- en: For the following, the $ prompt represents the command line, whereas >>> is
    the Python prompt.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下内容中，$ 提示符代表命令行，而 >>> 是 Python 提示符。
- en: A fresh install of Ubuntu 20.04 desktop gives us Python 3.8.5 for free. Use
    the code
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 全新安装的 Ubuntu 20.04 桌面版会免费提供 Python 3.8.5。使用以下代码：
- en: $ cat /etc/os-release
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: $ cat /etc/os-release
- en: to verify your operating system version and use python3 to run Python, as python
    alone starts the older Python 2.7.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 验证操作系统版本并使用 python3 运行 Python，因为仅使用 python 会启动旧版的 Python 2.7。
- en: 'These commands install NumPy, SciPy, Matplotlib, and sklearn:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令安装了 NumPy、SciPy、Matplotlib 和 sklearn：
- en: $ sudo apt-get install python3-pip
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: $ sudo apt-get install python3-pip
- en: $ sudo apt-get install python3-numpy
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: $ sudo apt-get install python3-numpy
- en: $ sudo apt-get install python3-scipy
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: $ sudo apt-get install python3-scipy
- en: $ sudo pip3 install matplotlib
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: $ sudo pip3 install matplotlib
- en: $ sudo pip3 install scikit-learn
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: $ sudo pip3 install scikit-learn
- en: 'Test the installation by starting Python 3 and importing each module: numpy,
    scipy, and sklearn. Then print the __version__ string to make sure it meets or
    exceeds the versions listed above. For example, see the following code.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启动Python 3并导入每个模块：numpy、scipy和sklearn来测试安装情况。然后打印 __version__ 字符串，以确保它符合或超过上述版本要求。例如，参见以下代码。
- en: '>>> import numpy; numpy.__version__'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import numpy; numpy.__version__'
- en: '''1.17.4'''
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '''1.17.4'''
- en: '>>> import scipy; scipy.__version__'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import scipy; scipy.__version__'
- en: '''1.4.1'''
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '''1.4.1'''
- en: '>>> import matplotlib; matplotlib.__version__'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import matplotlib; matplotlib.__version__'
- en: '''3.1.2'''
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '''3.1.2'''
- en: '>>> import sklearn; sklearn.__version__'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import sklearn; sklearn.__version__'
- en: '''0.23.2'''
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '''0.23.2'''
- en: macOS
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: macOS
- en: To install Python 3.*x* for Macintosh, go to *[https://www.python.org/](https://www.python.org/)*,
    and under **Downloads**, choose **Mac OS X**. Then select the latest stable Python
    3 release. At the time of this writing, it’s 3.9.2\. When the download is complete,
    run the installer to get Python 3.9.2 set up.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Macintosh上安装Python 3.*x*，请访问 *[https://www.python.org/](https://www.python.org/)*，在
    **Downloads** 下选择 **Mac OS X**，然后选择最新的稳定版Python 3发布版本。撰写本文时，最新版本是3.9.2。下载完成后，运行安装程序以安装Python
    3.9.2。
- en: 'After the installation, open a terminal window and verify the installation
    with the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，打开终端窗口并通过以下命令验证安装：
- en: $ python3 --version
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: $ python3 --version
- en: Python 3.9.2
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.9.2
- en: 'Assuming Python 3 installed correctly, now we can install the libraries using
    the terminal window and pip3, which the installer set up for us:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 假设Python 3正确安装，现在我们可以使用终端窗口和pip3安装库，安装程序为我们配置了这些工具：
- en: $ pip3 install numpy --user
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: $ pip3 install numpy --user
- en: $ pip3 install scipy --user
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: $ pip3 install scipy --user
- en: $ pip3 install matplotlib --user
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: $ pip3 install matplotlib --user
- en: $ pip3 install scikit-learn --user
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: $ pip3 install scikit-learn --user
- en: And, finally, we can check the versions of the libraries from within Python
    3\. Enter **python3** in the terminal to pull up a Python console, and then import
    numpy, scipy, matplotlib, and sklearn and print the version strings, as we did
    above, to verify that they meet or exceed the minimum versions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在Python 3中检查库的版本。打开终端并输入 **python3** 以启动Python控制台，然后导入numpy、scipy、matplotlib和sklearn，打印版本信息，正如我们上面所做的，确认它们符合或超过最低版本要求。
- en: Windows
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Windows
- en: 'To install Python 3 and the toolkits for Windows 10, use the following steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows 10上安装Python 3和工具包，请按照以下步骤操作：
- en: Go to *[https://www.python.org/](https://www.python.org/)* and click **Downloads**
    and **Windows**.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 *[https://www.python.org/](https://www.python.org/)*，点击 **Downloads** 和 **Windows**。
- en: At the bottom of the page, select the x86-64 executable installer.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面底部，选择x86-64可执行安装程序。
- en: Run the installer, choosing the default options.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行安装程序，选择默认选项。
- en: Select **Install for All Users** and **Add Python to the Windows PATH**. This
    is important.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Install for All Users** 和 **Add Python to the Windows PATH**。这一点很重要。
- en: When the installer finishes, Python will be available from the command prompt
    because we told the installer to add Python to the PATH environment variable.
    Therefore, open the command prompt (WINDOWS-R, cmd), and enter python. If all
    goes well, you’ll be greeted by the Python startup message and see a >>> interactive
    prompt. At the time of this writing, the version installed was 3.8.2\. Note that
    to exit Python in Windows, use CTRL-Z, not CTRL-D.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装程序完成时，Python将可从命令提示符使用，因为我们告诉安装程序将Python添加到PATH环境变量中。因此，打开命令提示符（WINDOWS-R，cmd），输入python。如果一切顺利，你将看到Python启动消息，并进入
    >>> 交互式提示符。撰写本文时，安装的版本是3.8.2。请注意，要在Windows退出Python，使用CTRL-Z，而不是CTRL-D。
- en: 'The Python installer did us the courtesy of installing pip as well. We can
    use it directly from the Windows command prompt to install the libraries we need.
    At the prompt, enter the following lines to install the NumPy, SciPy, Matplotlib,
    and sklearn libraries:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Python安装程序还帮我们安装了pip。我们可以直接在Windows命令提示符下使用它来安装所需的库。在命令提示符下，输入以下行来安装NumPy、SciPy、Matplotlib和sklearn库：
- en: pip install numpy
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: pip install numpy
- en: pip install scipy
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: pip install scipy
- en: pip install matplotlib
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: pip install matplotlib
- en: pip install sklearn
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: pip install sklearn
- en: For me, this installed NumPy 1.18.1, SciPy 1.4.1, Matplotlib 3.2.1, and sklearn
    0.22.2, which meet the minimum versions above, so all is well.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，这安装了NumPy 1.18.1、SciPy 1.4.1、Matplotlib 3.2.1和sklearn 0.22.2，满足上述最低版本要求，所以一切正常。
- en: To test things, start Python from the command prompt and import numpy, scipy,
    matplotlib, and sklearn. All three should load without error. To write Python
    code, install any editor you’re comfortable with, or simply use Notepad.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试，请从命令提示符启动Python，并导入numpy、scipy、matplotlib和sklearn。这三个模块都应该能顺利加载而不报错。要编写Python代码，可以安装任何你喜欢的编辑器，或者简单使用记事本。
- en: With your toolkits installed and good to go, let’s take a quick look at each
    library to become at least a bit more familiar with them. We’ll see examples throughout
    the book, but I recommend you look at the suggested documentation. It’s worth
    it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装好工具包并准备就绪后，让我们快速了解每个库，至少让我们对它们稍微熟悉一些。全书中我们会看到相关的例子，但我建议你查看推荐的文档。值得一读。
- en: NumPy
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NumPy
- en: We installed NumPy in the previous section. Now I’ll introduce some basic NumPy
    concepts and manipulations. A full tutorial is available online at *[https://docs.scipy.org/doc/numpy/user/quickstart.html](https://docs.scipy.org/doc/numpy/user/quickstart.html)*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中安装了 NumPy。现在我将介绍一些基本的 NumPy 概念和操作。完整的教程可以在 *[https://docs.scipy.org/doc/numpy/user/quickstart.html](https://docs.scipy.org/doc/numpy/user/quickstart.html)*
    上找到。
- en: 'Start Python. Then try the following at the prompt:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Python。然后在提示符下尝试以下操作：
- en: '>>> import numpy as np'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import numpy as np'
- en: '>>> np.__version__'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> np.__version__'
- en: '''1.16.2'''
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '''1.16.2'''
- en: The first line loads NumPy and sets up a shortcut name for it, np. Using the
    shortcut name isn’t required, but doing so is nearly universal. We’ll assume np
    going forward. The second line displays the version. It should be at least what
    is shown above.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行加载了 NumPy，并为它设置了一个快捷名称 np。使用快捷名称不是必须的，但几乎是普遍的做法。我们接下来将假设使用 np。第二行显示了版本信息，应该至少与上面显示的版本一致。
- en: Defining Arrays
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义数组
- en: 'NumPy operates on arrays and is quite good at turning lists into arrays. Think
    about the sort of arrays one finds in a language like C or Java. NumPy provides
    an advantage because although Python is elegant, it’s too slow for scientific
    uses when simulating arrays with lists. Actual arrays are much faster. Here’s
    an example defining an array from a list, and then examining some of its properties:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 主要处理数组，并且非常擅长将列表转换成数组。可以类比 C 语言或 Java 中的数组。NumPy 提供了优势，因为虽然 Python 很优雅，但当用列表模拟数组时，它在科学计算中会显得过于慢。实际的数组要快得多。这里有一个例子，定义了一个数组并检查它的一些属性：
- en: '>>> a = np.array([1,2,3,4])'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = np.array([1,2,3,4])'
- en: '>>> a'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a'
- en: array([1, 2, 3, 4])
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: array([1, 2, 3, 4])
- en: '>>> a.size'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a.size'
- en: '4'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '>>> a.shape'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a.shape'
- en: (4,)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: (4,)
- en: '>>> a.dtype'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a.dtype'
- en: dtype('int64')
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: dtype('int64')
- en: 'This example defines a list of four elements and then passes it to np.array
    to turn it into a NumPy array. Basic array properties include the size and the
    shape. The size is four elements. The shape is also four, as a tuple, showing
    that a is a vector, a one-dimensional (1D) array. The shape is four because array
    a has four elements. If a was two-dimensional (2D), the shape would have two values,
    one for each axis of the array. See the following example, where the shape of
    b tells us that b has two rows and four columns:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子定义了一个包含四个元素的列表，并将其传递给 np.array 函数，将其转化为 NumPy 数组。基本的数组属性包括大小和形状。大小为四个元素，形状也为四，作为一个元组，表明
    a 是一个一维（1D）数组。之所以形状为四，是因为数组 a 具有四个元素。如果 a 是二维（2D）数组，形状将有两个值，分别对应数组的两个轴。参见下一个例子，数组
    b 的形状表明它有两行四列：
- en: '>>> b = np.array([[1,2,3,4],[5,6,7,8]])'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = np.array([[1,2,3,4],[5,6,7,8]])'
- en: '>>> print(b)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print(b)'
- en: '[[1 2 3 4]'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[[1 2 3 4]'
- en: '[5 6 7 8]]'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[5 6 7 8]]'
- en: '>>> b.shape'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b.shape'
- en: (2, 4)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: (2, 4)
- en: Data Types
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'Python numeric data types come in two flavors: integers of arbitrary size (try
    2**1000) or floating-point numbers. NumPy, however, allows for arrays of many
    different types. Under the hood, NumPy is implemented in C, so it supports the
    same set of data types C supports. The previous example shows that the np.array
    function took the given list and, since every element of the list was an integer,
    created an array where each element was a signed 64-bit integer. [Table 1-1](ch01.xhtml#ch01tab01)
    has the data types NumPy works with; we can let NumPy choose the data type for
    us, or we can specify it explictly.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Python 数值数据类型有两种类型：任意大小的整数（尝试 2**1000）或浮点数。然而，NumPy 允许创建多种类型的数组。NumPy 底层是用 C
    实现的，因此它支持 C 支持的相同数据类型。前面的例子展示了 np.array 函数接受了给定的列表，并且由于列表的每个元素都是整数，因此创建了一个每个元素都是带符号
    64 位整数的数组。[表 1-1](ch01.xhtml#ch01tab01)列出了 NumPy 支持的数据类型；我们可以让 NumPy 为我们选择数据类型，或者我们可以明确指定数据类型。
- en: '**Table 1-1:** NumPy Data Type Names, C Equivalents, and Range'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-1:** NumPy 数据类型名称、C 语言等效类型及其范围'
- en: '| **NumPy name** | **Equivalent C type** | **Range** |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **NumPy 名称** | **等效 C 类型** | **范围** |'
- en: '| --- | --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| float64 | double | ±[2.225 × 10^(–308), 1.798 × 10^(308)] |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| float64 | 双精度浮点数 | ±[2.225 × 10^(–308), 1.798 × 10^(308)] |'
- en: '| float32 | float | ±[1.175 × 10^(–38), 3.403 × 10^(38)] |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| float32 | 浮点数 | ±[1.175 × 10^(–38), 3.403 × 10^(38)] |'
- en: '| int64 | long long | [–2^(63), 2^(63)–1] |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| int64 | 长整型 | [–2^(63), 2^(63)–1] |'
- en: '| uint64 | unsigned long long | [0, 2^(64)–1] |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| uint64 | 无符号长整型 | [0, 2^(64)–1] |'
- en: '| int32 | long | [–2^(31), 2^(31)–1] |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| int32 | long | [–2^(31), 2^(31)–1] |'
- en: '| uint32 | unsigned long | [0, 2^(32)–1] |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| uint32 | 无符号长整型 | [0, 2^(32)–1] |'
- en: '| uint8 | unsigned char | [0, 255 = 2²–1] |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| uint8 | 无符号字符 | [0, 255 = 2²–1] |'
- en: 'Let’s look at some examples of arrays with specific data types:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些具有特定数据类型的数组示例：
- en: '>>> a = np.array([1,2,3,4], dtype="uint8")'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = np.array([1,2,3,4], dtype="uint8")'
- en: '>>> a.dtype'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a.dtype'
- en: dtype('uint8')
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: dtype('uint8')
- en: '>>> a = np.array([1,2,3,4], dtype="int16")'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = np.array([1,2,3,4], dtype="int16")'
- en: '>>> a = np.array([1,2,3,4], dtype="uint32")'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = np.array([1,2,3,4], dtype="uint32")'
- en: '>>> b = np.array([1,2,3,4.0])'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = np.array([1,2,3,4.0])'
- en: '>>> b.dtype'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b.dtype'
- en: dtype('float64')
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: dtype('float64')
- en: '>>> b = np.array([1,2,3,4.0], dtype="float32")'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = np.array([1,2,3,4.0], dtype="float32")'
- en: '>>> c = np.array([111,222,333,444], dtype="uint8")'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> c = np.array([111,222,333,444], dtype="uint8")'
- en: '>>> c'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> c'
- en: array([111, 222,  77, 188], dtype=uint8)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: array([111, 222,  77, 188], dtype=uint8)
- en: The examples with array a use integer types, and the examples with array b use
    floating-point types. Notice that the first b example defaulted to a 64-bit float.
    NumPy did this because one of the input list elements was a float (4.0).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 数组a的示例使用了整数类型，而数组b的示例使用了浮点类型。注意，第一个b的例子默认使用了64位浮点数。NumPy这样做是因为输入列表中的一个元素是浮动数（4.0）。
- en: The last example defining array c seems to be a bug. But it isn’t. NumPy doesn’t
    warn us if the requested data type can’t hold the given values. Here, we have
    an 8-bit integer that can only hold values in the range [0, 255]. The first two,
    111 and 222, fit, but the last two, 333 and 444, are too large. NumPy quietly
    kept only the lowest 8 bits of these values, which correspond to 77 and 188, respectively.
    The lesson is that NumPy expects you to know what you’re doing in regard to data
    types. Usually, this isn’t an issue, but it is something to keep in mind.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个定义数组c的例子看起来像是一个 bug。但实际上不是。NumPy不会警告我们如果请求的数据类型无法容纳给定的值。在这里，我们有一个8位整数，它只能容纳范围在[0,
    255]内的值。前两个值，111和222，符合要求，但后两个值，333和444，太大了。NumPy悄悄地只保留了这些值的最低8位，分别对应77和188。教训是，NumPy期望你知道自己在数据类型方面在做什么。通常这不是问题，但值得注意。
- en: 2D Arrays
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 二维数组
- en: 'If a list turns into a 1D vector, we might suspect that a list of lists would
    turn into a 2D array. We’d be right:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个列表变成了一个1D向量，我们可能会怀疑一个由列表组成的列表会变成一个2D数组。我们猜对了：
- en: '>>> d = np.array([[1,2,3],[4,5,6],[7,8,9]])'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d = np.array([[1,2,3],[4,5,6],[7,8,9]])'
- en: '>>> d.shape'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d.shape'
- en: (3, 3)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: (3, 3)
- en: '>>> d.size'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d.size'
- en: '9'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: '>>> d'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d'
- en: array([[1, 2, 3],
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: array([[1, 2, 3],
- en: '[4, 5, 6],'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[4, 5, 6],'
- en: '[7, 8, 9]])'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[7, 8, 9]])'
- en: We see that a list of three sublists is mapped to a 3 × 3 array (a matrix).
    Subscripts on NumPy arrays count from zero, so referencing d[1,2] above returns
    6.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到三个子列表组成的列表被映射到一个3×3的数组（一个矩阵）。NumPy数组的下标是从零开始的，因此上面引用的d[1,2]返回的是6。
- en: Zeros and Ones
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 零与一
- en: 'Two particularly useful NumPy functions are np.zeros and np.ones. Both define
    arrays given a shape. The first initializes the array elements to zero, while
    the second initializes them to one. This is the primary way to create NumPy arrays
    from scratch:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个特别有用的NumPy函数，分别是np.zeros和np.ones。两者都可以根据给定的形状定义数组。第一个将数组元素初始化为零，而第二个将它们初始化为一。这是从头创建NumPy数组的主要方法：
- en: '>>> a = np.zeros((3,4), dtype="uint32")'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = np.zeros((3,4), dtype="uint32")'
- en: '>>> a[0,3] = 42'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a[0,3] = 42'
- en: '>>> a[1,1] = 66'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a[1,1] = 66'
- en: '>>> a'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a'
- en: array([[ 0,  0,  0, 42],
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: array([[ 0,  0,  0, 42],
- en: '[ 0, 66,  0,  0],'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 0, 66,  0,  0],'
- en: '[ 0,  0,  0,  0]], dtype=uint32)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 0,  0,  0,  0]], dtype=uint32)'
- en: '>>> b = 11*np.ones((3,1))'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = 11*np.ones((3,1))'
- en: '>>> b'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b'
- en: array([[11.],
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: array([[11.],
- en: '[11.],'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[11.],'
- en: '[11.]])'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[11.]])'
- en: The first argument is a tuple giving the size of each dimension. If we pass
    in a scalar, the resulting array is a 1D vector. Let’s look at the definition
    of b. Here, we multiply the 3 × 1 array by a scalar (11). This causes each element
    of the array, which was initialized to 1.0, to be multiplied by 11.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个元组，表示每个维度的大小。如果我们传入一个标量，结果数组就是一个1D向量。让我们看看b的定义。在这里，我们将3×1的数组与一个标量（11）相乘。这导致数组中的每个元素，初始值为1.0，都被乘以11。
- en: Advanced Indexing
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 高级索引
- en: 'We saw simple array indexing in the examples above, where we indexed with a
    single value. NumPy supports more sophisticated array indexing. One type we’ll
    use often is a single index that returns a complete subarray. Here’s an example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上面的例子中看到的是简单的数组索引，其中我们使用单一的值进行索引。NumPy支持更复杂的数组索引。我们常用的一种类型是单个索引返回一个完整的子数组。以下是一个例子：
- en: '>>> a = np.arange(12).reshape((3,4))'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = np.arange(12).reshape((3,4))'
- en: '>>> a'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a'
- en: array([[ 0,  1,  2,  3],
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: array([[ 0,  1,  2,  3],
- en: '[ 4,  5,  6,  7],'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 4,  5,  6,  7],'
- en: '[ 8,  9, 10, 11]])'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[ 8,  9, 10, 11]])'
- en: '>>> a[1]'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a[1]'
- en: array([4, 5, 6, 7])
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: array([4, 5, 6, 7])
- en: '>>> a[1] = [44,55,66,77]'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a[1] = [44,55,66,77]'
- en: '>>> a'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a'
- en: array([[ 0,  1,  2,  3],
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: array([[ 0,  1,  2,  3],
- en: '[44, 55, 66, 77],'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[ 8,  9, 10, 11]])'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'This example introduces np.arange, which is the NumPy equivalent of Python’s
    range function. Notice the use of the reshape method to change the 12-element
    vector into a 3 × 4 matrix. Also, notice that a[1] returns the entire subarray,
    starting with the first index of the first dimension. This syntax is short for
    a[1,:] where : means all elements of the given dimension. This shorthand also
    works for assignments, as the next line shows.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'The same syntax for indexing slices from a Python list works with NumPy. Here’s
    what that looks like if we continue with the example above:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a[:2]'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: array([[ 0,  1,  2,  3],
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[44, 55, 66, 77]])'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a[:2,:]'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: array([[ 0,  1,  2,  3],
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[44, 55, 66, 77]])'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a[:2,:3]'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: array([[ 0,  1,  2],
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[44, 55, 66]])'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b = np.arange(12)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b[::2]'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: array([ 0,  2,  4,  6,  8, 10])
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b[::3]'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: array([0, 3, 6, 9])
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b[::-1]'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: array([11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1,  0])
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'We see that a[:2] returns the first two rows with an implied : for the second
    dimension, as the following line shows. With our third command, we get a subarray
    in two dimensions by taking the first two rows and first three columns with a[:2,:3].
    The examples with b show how to extract every other or every third element. The
    last example is particularly handy: it uses a negative increment to reverse the
    dimension. The increment is –1 to reverse all values. If it was –2, we’d get every
    other element of b in reverse order.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'NumPy uses : to indicate all the elements along a specific dimension. It also
    allows ... (ellipsis) as a shorthand for “as many :s as needed.” For example,
    let’s define a three-dimensional (3D) array:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a = np.arange(24).reshape((4,3,2))'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: array([[[ 0,  1],
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[ 2,  3],'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[ 4,  5]],'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[[ 6,  7],'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[ 8,  9],'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[10, 11]],'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[[12, 13],'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[14, 15],'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[16, 17]],'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[[18, 19],'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[20, 21],'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[22, 23]]])'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'You can think of array a as a collection of four 3 × 2 matrices. To update
    the second of these matrices, you could use the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a[1,:,:] = [[11,22],[33,44],[55,66]]'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: array([[[ 0,  1],
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[ 2,  3],'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[ 4,  5]],'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[[11, 22],'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[33, 44],'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[55, 66]],'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[[12, 13],'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[14, 15],'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[16, 17]],'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[[18, 19],'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[20, 21],'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[22, 23]]])'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we specified the dimensions explicitly with : and showed that NumPy isn’t
    picky: it knows that a list of lists matched the expected shape of the subarray
    and updated array a accordingly. We get the same effect by using the ellipsis
    as seen next.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a[2,...] = [[99,99],[99,99],[99,99]]'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: array([[[ 0,  1],
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[ 2,  3],'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[ 4,  5]],'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[[11, 22],'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[33, 44],'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[55, 66]],'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[[99, 99],'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[99, 99],'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[99, 99]],'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[[18, 19],'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[20, 21],'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[22, 23]]])'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now updated the third 3 × 2 subarray.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Reading and Writing to Disk
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'NumPy arrays can be written to and loaded from disk by using np.save and np.load,
    like so:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a = np.random.randint(0,5,(3,4))'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '>>> a'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: array([[4, 2, 1, 3],
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[4, 0, 2, 4],'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[0, 4, 3, 1]])'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '>>> np.save("random.npy",a)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b = np.load("random.npy")'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '>>> b'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: array([[4, 2, 1, 3],
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[4, 0, 2, 4],'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[4, 0, 2, 4],'
- en: '[0, 4, 3, 1]])'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 4, 3, 1]])'
- en: Here, we’re using np.random.randint to create a random 3 × 4 integer array with
    values in the range 0 through 5\. NumPy has extensive libraries for random numbers.
    We write array a to disk as random.npy. The .npy extension is necessary and will
    be added if we don’t supply it. We then load the array back from disk using np.load.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 np.random.randint 创建一个随机的 3 × 4 整数数组，值的范围是 0 到 5。NumPy 提供了广泛的随机数库。我们将数组
    a 写入磁盘，命名为 random.npy。扩展名 .npy 是必要的，如果没有提供，它会被自动添加。然后我们使用 np.load 从磁盘加载该数组。
- en: We’ll encounter other NumPy functions throughout the book. I’ll explain them
    when they’re first introduced. Let’s move on now to a quick look at the SciPy
    library.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书中遇到其他 NumPy 函数。我会在它们首次出现时进行解释。现在让我们快速了解一下 SciPy 库。
- en: SciPy
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SciPy
- en: 'SciPy adds a plethora of functionality to Python. It uses NumPy under the hood,
    so the two are often installed together. A full tutorial is available here: *[https://docs.scipy.org/doc/scipy/reference/tutorial/index.html](https://docs.scipy.org/doc/scipy/reference/tutorial/index.html)*.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: SciPy 为 Python 添加了大量功能。它在底层使用 NumPy，因此两者通常一起安装。这里有一个完整的教程：[https://docs.scipy.org/doc/scipy/reference/tutorial/index.html](https://docs.scipy.org/doc/scipy/reference/tutorial/index.html)*。
- en: 'In this book, we’ll focus on the functions in the scipy.stats module. Start
    Python and try the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将重点介绍 scipy.stats 模块中的函数。启动 Python 并尝试以下操作：
- en: '>>> import scipy'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import scipy'
- en: '>>> scipy.__version__'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> scipy.__version__'
- en: '''1.2.1'''
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '''1.2.1'''
- en: This loads the SciPy module and verifies that the version number is at least
    what it should be. Any later version of SciPy should work just fine.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载 SciPy 模块并验证其版本号至少与预期一致。任何较新的 SciPy 版本都应该可以正常工作。
- en: 'As a quick test, let’s try the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速测试，让我们尝试以下操作：
- en: '>>> from scipy.stats import ttest_ind'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from scipy.stats import ttest_ind'
- en: '>>> a = np.random.normal(0,1,1000)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = np.random.normal(0,1,1000)'
- en: '>>> b = np.random.normal(0,0.5,1000)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = np.random.normal(0,0.5,1000)'
- en: '>>> c = np.random.normal(0.1,1,1000)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> c = np.random.normal(0.1,1,1000)'
- en: '>>> ttest_ind(a,b)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ttest_ind(a,b)'
- en: Ttest_indResult(statistic=-0.027161815649563964, pvalue=0.9783333836992686)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Ttest_indResult(statistic=-0.027161815649563964, pvalue=0.9783333836992686)
- en: '>>> ttest_ind(a,c)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ttest_ind(a,c)'
- en: Ttest_indResult(statistic=-2.295584443456226, pvalue=0.021802794508002675)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Ttest_indResult(statistic=-2.295584443456226, pvalue=0.021802794508002675)
- en: 'First, we load NumPy and then the ttest_ind function from SciPy’s stats module.
    This function takes two sets of data, say test scores from two classes, and asks
    the question: do these sets of data have the same average value? Or, more accurately,
    it asks: how strongly can we believe that the same process generated these two
    sets of data? The *t-test* is a classic method for answering this question. One
    way to evaluate its result is to look at the *p-value*. You can think of a *p*-value
    as the probability that the two sets would have the measured difference in average
    value if they came from the same generating process. A probability near 1 means
    we have a lot of confidence that the two sets are from the same process.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们加载 NumPy，然后加载 SciPy 中 stats 模块的 ttest_ind 函数。这个函数接受两组数据，例如来自两个班级的测试成绩，并提出一个问题：这两组数据是否具有相同的平均值？或者更准确地说，它问：我们能多大程度上相信这两组数据来自同一个生成过程？*t
    检验*是用来回答这个问题的经典方法。评估其结果的一种方式是查看 *p 值*。你可以将 *p* 值看作是一个概率，表示如果这两组数据来自同一个生成过程，它们会有测量到的平均值差异的概率。接近
    1 的概率意味着我们非常有信心这两组数据来自同一个过程。
- en: 'The variables a, b, and c are 1D arrays where the values from the array (here
    1,000) are extracted from Gaussian curves, also called *normal curves*. We’ll
    get to these later, but for now, know that the numbers are pulled from a bell
    curve where values near the middle are more likely to be selected than those near
    the edges. The first two arguments to normal are the average value and the standard
    deviation, a measure of how spread out the bell curve is: the larger the standard
    deviation, the flatter, and wider, the curve.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 a、b 和 c 是 1D 数组，其中的值（这里是 1,000）是从高斯曲线中提取出来的，也叫 *正态曲线*。我们稍后会详细介绍它们，但目前要知道的是，这些数字是从一个钟形曲线中抽取的，其中位于中间的值比位于边缘的值更可能被选中。normal
    函数的前两个参数分别是平均值和标准差，标准差是衡量钟形曲线如何扩展的一个指标：标准差越大，曲线就越平坦、越宽。
- en: For this example, we’d expect a and b to be very similar, as they both have
    an average value of 0.0, though slightly different bell curve shapes. However,
    c has an average value of 0.1\. We hope the t-test picks up on this and tells
    us that we might want to be careful in believing a and c were generated by the
    same process.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们预计 a 和 b 会非常相似，因为它们的平均值都是 0.0，尽管钟形曲线的形状略有不同。然而，c 的平均值为 0.1。我们希望 t 检验能够检测到这一点，并告诉我们可能需要小心，a
    和 c 是否真的来自相同的过程。
- en: The output of the ttest_ind function lists the *p*-value (pvalue). And, as we
    expected, comparing a and b returns a *p*-value of 0.98, meaning that the probability
    we’d see the difference between the averages of these two sets of data, given
    they came from the same generating process, is about 98 percent. However, when
    we compare a and c, we get a *p*-value of 2.7 percent (0.027). This means there
    is about a 3 percent chance we’d see the difference between a and c if they were
    generated by the same process. Therefore, we conclude that a and c are from different
    processes. We state, then, that the difference between these two datasets is *statistically
    significant*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ttest_ind 函数的输出列出了 *p*-值（pvalue）。正如我们预期的那样，比较 a 和 b 返回的 *p*-值为 0.98，这意味着在假设它们来自相同生成过程的情况下，我们看到这两组数据均值之间的差异的概率大约为
    98%。然而，当我们比较 a 和 c 时，得到的 *p*-值为 2.7%（0.027）。这意味着如果 a 和 c 来自相同的生成过程，我们看到它们之间的差异的概率约为
    3%。因此，我们得出结论，a 和 c 来自不同的过程。我们可以说，这两组数据之间的差异是 *统计上显著的*。
- en: Historically, *p*-values less than 0.05 have been considered statistically significant.
    However, this threshold is arbitrary, and recent experience in replicating experiments,
    especially in the soft sciences, has led to a call for a stricter threshold. Using
    a *p*-value of 0.05 means you’ll be wrong about 1 time in 20 (1/20 = 0.05), which
    is too generous a threshold. That said, a *p*-value close to 0.05 suggests that
    *something* is going on, and more investigation (and a larger dataset) is warranted.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，*p*-值小于 0.05 被认为是统计显著的。然而，这一阈值是任意的，最近在复制实验（尤其是软科学领域）中的经验表明，需要更严格的阈值。使用 *p*-值为
    0.05 意味着你大约每 20 次就会错一次（1/20 = 0.05），这是一个过于宽松的阈值。也就是说，一个接近 0.05 的 *p*-值表明可能存在某种现象，需要更多的调查（以及更大的数据集）。
- en: Matplotlib
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Matplotlib
- en: 'We’ll use Matplotlib to generate graphs. Let’s verify its 2D and 3D plotting
    abilities here. First, a simple 2D example:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Matplotlib 来生成图表。让我们在这里验证它的 2D 和 3D 绘图能力。首先是一个简单的 2D 示例：
- en: '>>> import numpy as np'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import numpy as np'
- en: '>>> import matplotlib.pylab as plt'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import matplotlib.pylab as plt'
- en: '>>> x = np.random.random(100)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = np.random.random(100)'
- en: '>>> plt.plot(x)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plt.plot(x)'
- en: '>>> plt.show()'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plt.show()'
- en: This example loads NumPy, with which Matplotlib works best, and generates a
    vector, x, of 100 random values, [0, 1), the output of np.random.random. We then
    use plt.plot to plot the vector and plt.show to display it. Matplotlib output
    is interactive. Play around with the plot to get familiar with how to use the
    plot window. For example, [Figure 1-1](ch01.xhtml#ch01fig01) shows what the plot
    window looks like on Linux. Since the plot is random, you’ll see a different sequence
    of values, but the controls on the window will be the same.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子加载了 NumPy，Matplotlib 与它配合使用效果最佳，并生成一个包含 100 个随机值（范围为 [0, 1)）的向量 x，这是 np.random.random
    的输出。然后我们使用 plt.plot 绘制这个向量，并用 plt.show 显示它。Matplotlib 的输出是交互式的。可以在图表上进行操作，熟悉如何使用绘图窗口。例如，[图
    1-1](ch01.xhtml#ch01fig01) 显示了在 Linux 上绘图窗口的样子。由于绘图是随机的，你将看到一组不同的值，但窗口上的控件将保持不变。
- en: '![image](Images/01fig01.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/01fig01.jpg)'
- en: '*Figure 1-1: A sample Matplotlib plotting window*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-1：一个示例的 Matplotlib 绘图窗口*'
- en: 'For 3D, give this a try:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 3D，可以试试这个：
- en: '>>> from mpl_toolkits.mplot3d import Axes3D'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from mpl_toolkits.mplot3d import Axes3D'
- en: '>>> import matplotlib.pylab as plt'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import matplotlib.pylab as plt'
- en: '>>> import numpy as np'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import numpy as np'
- en: '>>> x = np.random.random(20)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = np.random.random(20)'
- en: '>>> y = np.random.random(20)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> y = np.random.random(20)'
- en: '>>> z = np.random.random(20)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> z = np.random.random(20)'
- en: '>>> fig = plt.figure()'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> fig = plt.figure()'
- en: '>>> ax = fig.add_subplot(111, projection=''3d'')'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ax = fig.add_subplot(111, projection=''3d'')'
- en: '>>> ax.scatter(x,y,z)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ax.scatter(x,y,z)'
- en: '>>> plt.show()'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> plt.show()'
- en: We first load the 3D axes toolkit, Matplotlib, and NumPy. Then, using NumPy,
    we generate three random vectors, [0, 1). These are our 3D points. Using plt.figure
    and fig.add_subplot, we set up a 3D projection. The 111 is shorthand telling Matplotlib
    that we want a grid of 1 × 1 and that the current plot should go in index 1 of
    that grid. So, 111 means a single plot. The projection keyword gets the plot ready
    for 3D. Finally, the scatter plot is made, ax.scatter, and shown, plt.show. As
    with the 2D plot, the 3D plot is interactive. Grab and hold with the mouse to
    rotate the plot.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先加载 3D 坐标轴工具包 Matplotlib 和 NumPy。然后，使用 NumPy 生成三个随机向量，[0, 1)。这些就是我们的 3D 点。使用
    `plt.figure` 和 `fig.add_subplot` 设置 3D 投影。`111` 是一种简写，告诉 Matplotlib 我们希望得到 1 ×
    1 的网格，并且当前的绘图应该放在该网格的索引 1 位置。因此，`111` 表示一个单独的绘图。`projection` 关键字让绘图准备好进行 3D 展示。最后，通过
    `ax.scatter` 创建散点图，并使用 `plt.show` 显示出来。与 2D 绘图一样，3D 绘图是交互式的。使用鼠标拖动并按住即可旋转图形。
- en: Scikit-Learn
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Scikit-Learn
- en: The goal of this book is to cover the math of deep learning, not the implementation
    of deep learning. However, from time to time, it’ll be helpful to look at a simple
    neural network model or two. In those cases, we’ll make use of sklearn, in particular,
    the MLPClassifier class. Also, sklearn contains some useful tools for evaluating
    the performance of a model and for visualization of high-dimensional data.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目标是讲解深度学习的数学，而非深度学习的实现。然而，偶尔我们会需要看一下简单的神经网络模型。在这些情况下，我们会使用 sklearn，特别是 MLPClassifier
    类。此外，sklearn 还包含一些用于评估模型性能和高维数据可视化的有用工具。
- en: 'As a quick example, let’s build a simple neural network to classify small 8×8-pixel
    grayscale images of handwritten digits. This dataset is built into sklearn. Here’s
    the code for the example:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速示例，让我们构建一个简单的神经网络，用于分类手写数字的 8×8 像素灰度图像。此数据集已内置在 sklearn 中。以下是示例代码：
- en: import numpy as np
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: from sklearn.datasets import load_digits
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: from sklearn.datasets import load_digits
- en: from sklearn.neural_network import MLPClassifier
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: from sklearn.neural_network import MLPClassifier
- en: ❶ d = load_digits()
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ d = load_digits()
- en: digits = d["data"]
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: digits = d["data"]
- en: labels = d["target"]
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: labels = d["target"]
- en: N = 200
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: N = 200
- en: ❷ idx = np.argsort(np.random.random(len(labels)))
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ idx = np.argsort(np.random.random(len(labels)))
- en: x_test, y_test = digits[idx[:N]], labels[idx[:N]]
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: x_test, y_test = digits[idx[:N]], labels[idx[:N]]
- en: x_train, y_train = digits[idx[N:]], labels[idx[N:]]
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: x_train, y_train = digits[idx[N:]], labels[idx[N:]]
- en: ❸ clf = MLPClassifier(hidden_layer_sizes=(128,))
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ clf = MLPClassifier(hidden_layer_sizes=(128,))
- en: clf.fit(x_train, y_train)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: clf.fit(x_train, y_train)
- en: score = clf.score(x_test, y_test)
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: score = clf.score(x_test, y_test)
- en: pred = clf.predict(x_test)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: pred = clf.predict(x_test)
- en: err = np.where(y_test != pred)[0]
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: err = np.where(y_test != pred)[0]
- en: 'print("score      : ", score)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("score      : ", score)'
- en: print("errors:")
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: print("errors:")
- en: 'print("  actual   : ", y_test[err])'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("  actual   : ", y_test[err])'
- en: 'print("  predicted: ", pred[err])'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("  predicted: ", pred[err])'
- en: We first import NumPy. From sklearn itself, we import the load_digits function
    to return the small digit image dataset and the MLPClassifier class to train a
    traditional neural network, that is, a multilayer perceptron. We then get the
    digit data and pull out the images and their associated labels, 0 . . . 9 ❶. The
    digit images are stored as 8 × 8 = 64-element vectors representing the image unraveled
    so the rows are laid end to end. The digits data-set includes 1,797 images, so
    digits is a 2D NumPy array with 1,797 rows, with 64 columns per row, and labels
    is a vector of 1,797 digit labels.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入 NumPy。然后从 sklearn 导入 `load_digits` 函数，用于返回小数字图像数据集，并导入 MLPClassifier
    类，用于训练传统神经网络，即多层感知机（MLP）。接着，我们获取数字数据并提取图像及其关联标签，0 . . . 9 ❶。数字图像存储为 8 × 8 = 64
    元素的向量，表示图像的展开形式，即将行按顺序排列。数字数据集包含 1,797 张图像，因此 `digits` 是一个 2D NumPy 数组，包含 1,797
    行，每行有 64 列，而 `labels` 是一个包含 1,797 个数字标签的向量。
- en: We randomize the order of the images, being careful to keep the right label
    with the right digit ❷ and extract train and test data (x_train, x_test) and labels
    (y_train, y_test). We’ll set the first 200 digit images aside to use as test data
    and train the model with the remaining 1,597 images. This leaves us with approximately
    160 images of each digit to train with and about 20 of each digit for testing.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随机打乱图像的顺序，并小心地确保每个标签与对应的数字匹配 ❷，然后提取训练数据和测试数据（x_train, x_test）以及标签（y_train,
    y_test）。我们将前 200 张数字图像留作测试数据，使用剩余的 1,597 张图像训练模型。这意味着我们每个数字大约有 160 张图像用于训练，每个数字大约有
    20 张图像用于测试。
- en: Next, we build the model by creating an instance of MLPClassifier ❸. We’ll take
    all the defaults and specify only the size of the single hidden layer, which has
    128 nodes. The input vectors are 64 elements, so we double that for the hidden
    layer. There’s no need to specify the output layer size explicitly; sklearn deduces
    it from the labels in y_train. Training the model is a simple call to clf.fit
    passing the training image vectors (x_train) and labels (y_train).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过创建 MLPClassifier ❸ 的实例来构建模型。我们采用所有默认设置，只指定一个隐藏层的大小，该层包含 128 个节点。输入向量有
    64 个元素，因此我们将隐藏层的节点数设为输入的两倍。无需显式指定输出层的大小；sklearn 会根据 y_train 中的标签自动推断。训练模型只需要简单地调用
    clf.fit，并传入训练图像向量（x_train）和标签（y_train）。
- en: Training for a small dataset like this will take only a few seconds. When it’s
    done, the learned weights and biases are in the model (clf). We first get the
    score, the overall accuracy (score), and then the actual model class label predictions
    on the test set (pred). Any errors are captured in err by looking for places where
    the actual label (y_test) does not match the prediction. We end by showing the
    actual class label and predicted label for the errors.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像这样的一个小数据集，训练只需几秒钟。当训练完成时，学习到的权重和偏置会保存在模型 (clf) 中。我们首先获取分数，整体准确率（score），然后是模型在测试集上的实际类别标签预测
    (pred)。通过检查实际标签 (y_test) 与预测标签不匹配的地方，任何错误都会被记录在 err 中。最后，我们展示错误的实际类别标签和预测标签。
- en: Each time we run this code, we’ll get a different ordering of the digit data,
    which leads to a different train and test set. Additionally, neural networks are
    randomly initialized prior to training. So, we’ll get a different result each
    time. The first time I ran this code, I had an overall score of 0.97 (97 percent)
    accuracy. Guessing would give an accuracy of about 10 percent, so we can say that
    the model has learned rather well.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行这段代码时，我们都会得到不同的数字数据排序，从而生成不同的训练集和测试集。此外，神经网络在训练前会随机初始化。因此，每次运行时我们都会得到不同的结果。第一次运行这段代码时，我的整体得分为
    0.97（97% 的准确率）。如果只是猜测，准确率大约为 10%，所以我们可以说模型已经学得相当不错。
- en: Summary
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to configure our working environment. I then
    introduced our suite of Python toolkits at a high level and supplied pointers
    on where to learn more. With the work environment secure and flourishing, the
    next chapter dives headfirst into probability theory.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何配置我们的工作环境。接着，我简要介绍了我们的 Python 工具包，并提供了进一步学习的资源。工作环境已经设置好并且顺利运行，下一章将深入探讨概率论。
