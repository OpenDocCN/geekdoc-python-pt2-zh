- en: '1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A SHORT PYTHON PRIMER
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this first chapter, we’ll take a look at some of the Python features we’ll
    use throughout the book. This is not meant to be an introduction to Python; I’m
    assuming you have a basic understanding of the language. If you don’t, there are
    plenty of good books and online tutorials that’ll get you started.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll first explore how Python code can be split into packages and how to import
    these packages into our programs. We’ll learn how to document Python code and
    how to consult this documentation using Python. Then, we’ll review tuples, lists,
    sets, and dictionaries, which are the most popular Python collections.
  prefs: []
  type: TYPE_NORMAL
- en: '**Python Packages and Modules**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Software projects of a reasonable size usually consist of lots of source files,
    also called *modules*. A coherent bundle of Python modules is referred to as a
    *package*. Let’s start our discussion on Python by taking a look at these two
    concepts: modules and packages.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Modules***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A Python *module* is a file that contains Python code that’s meant to be imported
    by other Python modules or scripts. A *script*, on the other hand, is a Python
    file that’s meant to be run.
  prefs: []
  type: TYPE_NORMAL
- en: Python modules allow us to share code between files, which spares us from having
    to write the same code over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every Python file has access to a global variable named __name__. This variable
    can have two possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the module, that is, the name of the file without the *.py* extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string ’__main__’
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python determines the value of __name__ based on whether the file is imported
    by some other module or run as a script. When the module is imported inside another
    module or script, __name__ is set to the name of the module. If we run the module
    as a script, for example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: then the value of __name__ is set to ’__main__’. This may seem a bit abstract
    at the moment, but we’ll explain why we care about the __name__ global variable
    later in the chapter. As we’ll see, knowing if a given module is being imported
    or run as a script is an important piece of information we’ll want to consider.
  prefs: []
  type: TYPE_NORMAL
- en: As we write more and more Python modules for our project, it makes sense to
    separate them into groups according to functionality. These groups of modules
    are called *packages*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Packages***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *package* is a directory containing Python modules and a special file whose
    name is required to be *__init__.py*. Python’s interpreter will understand any
    folder containing an *__init__.py* file as a package.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, a folder structure like:'
  prefs: []
  type: TYPE_NORMAL
- en: geom2d
  prefs: []
  type: TYPE_NORMAL
- en: '|- __init__.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- point.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- vector.py'
  prefs: []
  type: TYPE_NORMAL
- en: 'is a Python package called *geom2d* containing two files, or modules: *point.py*
    and *vector.py*.'
  prefs: []
  type: TYPE_NORMAL
- en: The *__init__.py* file is executed whenever something is imported from the package.
    This means that the *__init__.py* file can contain Python code, usually initialization
    code. Most of the time, however, this *__init__.py* file remains empty.
  prefs: []
  type: TYPE_NORMAL
- en: '**Running Files**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When Python imports a file, it reads its contents. If this file contains only
    functions and data, Python loads these definitions, but no code is actually executed.
    However, if there are top-level instructions or function calls, Python will execute
    them as part of the import process—something we usually don’t want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier, we saw how when a file is run (as opposed to imported), Python sets
    the __name__ global variable to be the string ’__main__’. We can use this fact
    to execute the main logic only when the file is being run, and not when the file
    is imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We’ll refer to this pattern as the “if name is main” pattern, and we’ll use
    it in the applications we’ll write in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that when a file is imported, Python sets the __name__ variable to
    the name of that module.
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing Code**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s say you had some Python code you wanted to use in multiple files. One
    way to do that would be to copy and paste the code every time you wanted to use
    it. Not only would this be tedious and boring, but imagine what would happen if
    you changed your mind about how that code works: you’d need to open every single
    file where you pasted the code and modify it in the same way. As you can imagine,
    this is not a productive way of writing software.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Python provides a powerful system to share code: importing modules.
    When *module_b* imports *module_a*, *module_b* gains access to the code written
    in *module_a*. This lets us write algorithms in a single place and then share
    that code across files. Let’s look at an example using two modules we’ll write
    in the next part of the book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we have two modules: *point.py* and *vector.py*. Both modules are inside
    the package we saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: geom2d
  prefs: []
  type: TYPE_NORMAL
- en: '|- __init__.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- point.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|- vector.py'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first module, named *point.py*, defines the geometric primitive Point,
    and the second one, *vector.py*, defines the Vector, another geometric primitive.
    [Figure 1-1](ch01.xhtml#ch1fig1) illustrates these two modules. Each module is
    divided into two sections: a section in gray, for the code in the module that
    has been imported from somewhere else, and a section in white, for the code defined
    by the module itself.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/01fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-1: Two Python modules*'
  prefs: []
  type: TYPE_NORMAL
- en: Now, say we need our *point.py* module to implement some functionality that
    uses a Vector (like, for example, displacing a point by a given vector). We can
    gain access to the Vector code in *vector.py* using Python’s import command. [Figure
    1-2](ch01.xhtml#ch1fig2) illustrates this process, which brings the Vector code
    to the “imported” section of the *point.py* module, making it available inside
    the entire module.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/01fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-2: Importing the Vector class from the* vector.py'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 1-2](ch01.xhtml#ch1fig2), we use the following Python command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This command brings just the Vector class from *vector.py*. We’re not importing
    anything else defined in *vector.py*.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll see in the next section, there are a few ways to import from modules.
  prefs: []
  type: TYPE_NORMAL
- en: '***Different Import Forms***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To understand the different ways we can import modules and names inside a module,
    let’s use two packages from our *Mechanics* project.
  prefs: []
  type: TYPE_NORMAL
- en: Mechanics
  prefs: []
  type: TYPE_NORMAL
- en: '|- geom2d'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- __init__.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- point.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- vector.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '|- eqs'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- __init__.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- matrix.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- vector.py'
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we’ll use the *geom2d* and *eqs* packages, using two files,
    or modules, inside of each. Each of these modules defines a single class that
    has the same name as the module, only capitalized. For example, the module in
    *point.py* defines the Point class, *vector.py* defines the Vector class, and
    *matrix.py* defines the Matrix class. [Figure 1-3](ch01.xhtml#ch1fig3) illustrates
    this package structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/01fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-3: Two packages from our Mechanics project and some of their modules*'
  prefs: []
  type: TYPE_NORMAL
- en: With this directory set up in our minds, let’s analyze several scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: '**Importing from a Module in the Same Package**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If we are in module *point.py* from the package *geom2d* and we want to import
    the entire *vector.py* module, we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use the *vector.py* module’s contents like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s important to note that since we imported the entire module and not any
    of its individual entities, we have to refer to the module-defined entities using
    the module name. If we want to refer to the module using a different name, we
    can alias it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can use it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also import specific names from a module instead of importing the entire
    module. As you saw earlier, the syntax for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With this import, we can instead do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we can also alias the imported name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When we *alias* an imported name, we simply rename it to something else. In
    this case, we can now write it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Importing from a Module in a Different Package**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If we wanted to import the *point.py* module from inside the *matrix.py* module,
    which is in a different package, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: or equivalently
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This lets us use the entire *point.py* module inside *matrix.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we can choose to alias the imported module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: or equivalently
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Either way, we can use pt as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also import names from the module, instead of bringing the entire module,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, we can use an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Relative Imports**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Finally, we have relative imports. A *relative import* is one that refers to
    a module using a route whose start point is the file’s current location.
  prefs: []
  type: TYPE_NORMAL
- en: We use one dot (.) to refer to modules or packages inside the same package and
    two dots (..) to refer to the parent directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following our previous example, we could import the *point.py* module from
    within *matrix.py* using a relative import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the route ..geom.point means this: from the current directory
    move to our parent’s directory and look for the *point.py* module.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Documenting the Code with Docstrings**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we write code that other developers will use, it’s good practice to document
    it. This documentation should include information about how to use our code, what
    assumptions the code makes, and what each function does.
  prefs: []
  type: TYPE_NORMAL
- en: Python uses *docstrings* to document code. These docstrings are defined between
    triple quotes (""") and appear as the first statement of the function, class,
    or module they document.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed how the code for the *Mechanics* project you downloaded
    earlier uses these docstrings. For example, if you open the *matrix.py* file,
    the methods of the Matrix class are documented this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you ever find yourself using this code and can’t figure something out, Python
    has the help global function; if you give help a module, function, class, or method,
    it returns that code’s docstring. For example, we could get the documentation
    for this set_data method inside a Python interpreter console as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There are automated tools, like Sphinx ([*https://www.sphinx-doc.org/*](https://www.sphinx-doc.org/)),
    that generate documentation reports in HTML, PDF, or plaintext using the docstrings
    in a project. You can distribute this documentation along with your code so that
    other developers have a good place to start learning about the code you write.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t be writing the docstrings in this book as they take up considerable
    space. But they should all be in the code you downloaded, and you can look at
    them there.
  prefs: []
  type: TYPE_NORMAL
- en: '**Collections in Python**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our programs often work with collections of items, sometimes very large ones.
    We want to store these items in a way that is convenient for our purposes. Sometimes
    we’ll be interested in knowing whether a collection includes a particular item,
    and other times we’ll need to know the order of our items; we may also want a
    fast way of finding a given item, maybe one that fulfills a particular condition.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are many ways to interact with a collection of items.
    As it turns out, choosing the right way to store data is crucial for our programs
    to perform well. There are different collection flavors, each good for certain
    cases; knowing which type of collection to use in each particular situation is
    an important skill every software developer should master.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python offers us four main collections: the set, the tuple, the list, and the
    dictionary. Let’s explain how each of these collections stores elements and how
    to use them.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Sets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *set* is an unordered collection of unique elements. Sets are most useful
    when we need to quickly determine whether an element exists in a collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a set in Python, we can use the set function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the literal syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when using the literal syntax, we define the set using curly brackets
    ({}).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get the number of elements contained inside a set using the global len
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking whether an element exists in the set is a fast operation and can be
    done using the in operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add new elements to the set using the add method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to add an element that’s already present, nothing happens because
    a set doesn’t allow repeated elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can remove an element from a set using the remove method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can operate with sets using the familiar mathematical operations for sets.
    For example, we can compute the difference between two sets, which is the set
    containing the elements of the first set that aren’t in the second set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also compute the union of two sets, which is the set containing all
    the elements that appear in both sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can iterate through sets, but the order of the iteration is not guaranteed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '***Tuples***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Tuples* are immutable and ordered sequences of elements. *Immutable* means
    that, once created, the tuple cannot be changed in any way. Elements in a tuple
    are referred to with the index they occupy, starting with zero. Counting in Python
    always starts from zero.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuples are a good option when we’re passing a collection of ordered data around
    our code but don’t want the collection to be mutated in any way. For example,
    in code like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'you can be sure the names tuple won’t be changed by some_function in any way.
    By contrast, if you decided to use a set like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: nothing would prevent some_function from adding or removing elements from the
    passed-in names, so you’d need to check the function’s code to understand whether
    the code alters the elements.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In any case, as we’ll see later, functions shouldn’t mutate their parameters,
    so the functions we’ll write in this book will never modify their input parameters
    in any way. You might, nevertheless, use functions written by other developers
    who didn’t follow the same rule, so you want to check whether those functions
    have these kinds of side effects.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuples are defined between parentheses, and the elements inside a tuple are
    comma-separated. Here’s a tuple, defined using literal syntax, containing my name
    and age:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to create a tuple with only one element, we need to write a comma
    after it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be created using the tuple function, passing it a list of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get the number of items in a tuple using the len global function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also count how many times a given value appears inside a tuple using
    the tuple’s count method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get the index of the first occurrence of a given item using the index
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we’re looking for the index of the string ’Alvaro’, which
    appears twice: at indices 1 and 5\. The index method yields the first occurrence’s
    index, which is 1 in this case.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The in operator can be used to check whether an element exists inside a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuples can be multiplied by numbers, a peculiar operation that yields a new
    tuple with the original elements repeated as many times as the multiplier number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can iterate through tuple values using for loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Using Python’s built-in enumerate function, we can iterate through the items
    in the tuple with their indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '***Lists***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *list* is an ordered collection of nonunique elements referenced by their
    index. Lists are well suited for cases where we need to keep elements in order
    and where we know the index at which they appear.
  prefs: []
  type: TYPE_NORMAL
- en: Lists and tuples are similar, with the tuple’s immutability being the only difference;
    items in a list move around, and items can be added and removed. If you are sure
    the items in a large collection won’t be modified, use a tuple instead of a list;
    tuple manipulations are faster than their list equivalents. Python can do some
    optimizations if it knows the items in the collection won’t change.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a list in Python, we can use the list function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can use the literal syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Note the usage of the square brackets ([]).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check the number of items in a list using the len function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'List elements can be accessed by index (the index of the first element is zero):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also replace an existing element in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Be careful not to use an index that doesn’t exist in the list; it’ll raise
    an IndexError:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Items can be appended to the end of the list using the append method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Lists can be iterated, and the order of iteration is guaranteed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Often enough, we’re interested not only in the element itself but also in its
    index in the list. In those cases, we can use the enumerate function, which yields
    a tuple of the index and element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: A new list can be created by taking contiguous elements from another list. This
    process is called *slicing*. Slicing is a big topic that requires a section of
    its own.
  prefs: []
  type: TYPE_NORMAL
- en: '**Slicing Lists**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Slicing a list looks a bit like indexing into the list using square brackets,
    except we use two indices separated by a colon: [*<start>* : *<end>*]. Here’s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we have a list a with values [1, 2, 3, 4]. We create
    a new list, b, by slicing the original list and taking the items starting at index
    1 (inclusive) and ending at index 3 (noninclusive).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Don’t forget that slices in Python always include the element in the start
    index and exclude the element in the end index.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-4](ch01.xhtml#ch1fig4) illustrates this process.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/01fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-4: Slicing a list*'
  prefs: []
  type: TYPE_NORMAL
- en: Both the start and end indices in the slice operator are optional because they
    have a default value. By default, the start index is assigned the first index
    in the list, which is always zero. The end index is assigned the last index in
    the list plus one, which is equal to len(the_list).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, both b_1 and b_2 lists are a copy of the original a list.
    By copy we really mean they’re different lists; you can safely modify b_1 or b_2,
    and list a remains unchanged. You can test this by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Negative indices are another trick you can use. A negative index is an index
    that is counted starting from the end of the list and moving toward the beginning
    of the list. Negative indices can be used in slicing operations the same way as
    positive indices, with a small exception: negative indices start at –1, not at
    –0\. We could, for instance, slice a list to get its two last values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here we’re creating a new list starting at the second position from the end
    all the way to the last element of the list. [Figure 1-5](ch01.xhtml#ch1fig5)
    illustrates this.
  prefs: []
  type: TYPE_NORMAL
- en: Slicing lists is a versatile operation in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/01fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-5: Slicing a list using negative indices*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Dictionaries***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *dictionary* is a collection of key-value pairs. Values in a dictionary are
    mapped to their key; we retrieve elements from a dictionary using their key. Finding
    a value in a dictionary is fast.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries are useful when we want to store elements referenced by some key.
    For example, if we wanted to store information about our siblings and wanted to
    be able to retrieve it by the name of the sibling, we could use a dictionary.
    We’ll take a look at this in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: To create a dictionary in Python, you can either use the dict function,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: or use the literal syntax,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The dict function expects a list of tuples. These tuples should contain two
    values: the first one is used as the key, and the second is used as the value.
    The literal version for creating dictionaries is much less verbose, and in both
    cases the resulting dictionary is the same.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with a list, we access values in a dictionary using square brackets. However,
    this time we use the key of the value between the brackets, as opposed to the
    index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: You can use anything that’s immutable as the key in a dictionary. Remember that
    tuples are immutable, whereas lists are not. Numbers, strings, and booleans are
    also immutable and thus can be used as dictionary keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a dictionary where the keys are tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we map the age to a key composed of a name and a surname in
    a tuple. If we want to know Jen’s age, we can ask for the value in a dictionary
    by using its key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: What happens when we look for a key that’s not in the dictionary?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We get an error. We can check whether a key is in a dictionary before getting
    its value using the in operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also get a set-like view of all the keys in the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do the same for the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the in operator to check for the existence of a value in both the
    keys and values stored in Python dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Dictionaries can be iterated in a few ways. Let’s imagine we have the following
    ages dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use for loops to iterate through the dictionary keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do the same for the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can do the same for the key-value tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: That’s about all we need to know about Python’s collections for now. Let’s continue
    our Python tour by looking at destructuring collections.
  prefs: []
  type: TYPE_NORMAL
- en: '**Destructuring**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Destructuring* or *unpacking* is a technique that allows us to assign values
    inside a collection to variables. Let’s look at some examples.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine we have a tuple containing information about a person, including her
    name and favorite beverage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Say we want to have those two pieces of information in separate variables.
    We could separate them out like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This is perfectly fine, but we can do it in a more elegant way using destructuring
    syntax. To destructure the two strings inside the tuple into two variables, we
    have to use another tuple with the variable names on the left side of the assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: We can also destructure lists. For example, if we had a list containing similar
    information about another person, like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'we could destructure the name and favorite beverage using a list on the left
    side of the assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The left-side tuple or list has to match the size of the one on the right side,
    but there might be cases where we’re not interested in all of the unpacked values.
    In such cases, you can use an underscore in those positions where you want to
    ignore the corresponding value. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: assigns the value 1 to variable a and assigns 3 to variable c, but it discards
    the value 2.
  prefs: []
  type: TYPE_NORMAL
- en: This is another technique that helps us write more concise code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter has been a tour of some intermediate and advanced Python techniques
    we’ll use throughout the book. We took a look at how Python programs are made
    of modules bundled into packages and how to import these modules from other parts
    of our code.
  prefs: []
  type: TYPE_NORMAL
- en: We also explained the “if name is main” pattern, which is used to avoid executing
    portions of the code when the file is imported.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we briefly touched on the four basic Python collections: tuples, lists,
    sets, and dictionaries. We also looked at how to destructure, or unpack, these
    collections.'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s shift gears and talk about a few programming paradigms.
  prefs: []
  type: TYPE_NORMAL
