- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python Data Structures
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Data structures organize and store data, making it easier to access the data.
    Python ships with four data structures: lists, tuples, dictionaries, and sets.
    These structures are easy to work with, yet they can be used to tackle complex
    data operations, making Python one of the most popular languages for data analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will cover Python’s four built-in data structures, with an emphasis
    on the features that allow you to easily build functional data-centric applications
    with minimal coding. You’ll also learn how to combine the basic structures into
    more complex structures, such as a list of dictionaries, to more accurately represent
    real-world objects. You’ll apply this knowledge to the field of natural language
    processing and in a short introduction to processing photographs.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Python *list* is an ordered collection of objects. The elements in a list
    are separated by commas, and the entire list is enclosed in square brackets, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Lists are mutable, meaning you can add, remove, and modify a list’s elements.
    Unlike sets, which we’ll discuss later in the chapter, lists can have duplicate
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: Lists contain elements that represent series of usually related, similar things
    that can be logically grouped together. A typical list contains only elements
    belonging to a single category (that is, homogeneous data, such as people’s names,
    article titles, or participant numbers). Understanding this point is essential
    when it comes to choosing the right tool for the task at hand. If you need a structure
    to include objects with different properties, consider using a tuple or a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a basic list, simply place a sequence of elements inside square brackets
    and assign the sequence to a variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In practice, however, lists are commonly populated dynamically from scratch,
    often using a loop that calculates one item per iteration. In such cases, your
    first step is to create an empty list, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once you’ve created a list, you can add, remove, and sort items in that list
    as needed. You can perform these and other tasks using Python’s various list object
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Using Common List Object Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'List object methods are functions that implement particular behaviors within
    lists. In this section we’ll look at some common list object methods, including
    `append()`, `index()`, `insert()`, and `count()`. To practice using them, start
    by creating a blank list. You’ll build it into a to-do list as you go along, filling
    it with chores and organizing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Perhaps the most common list object method is `append()`. It adds an item to
    the end of the list. You can use `append()` to add some chores to your to-do list,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The list now contains four items, in the order in which they were appended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Each item in a list has a numeric key known as an *index*. This feature enables
    a list to keep its items in a specified order. Python uses zero-based indexing,
    meaning the initial item of a sequence is assigned the index 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access an individual item from a list, specify the name of the list, followed
    by the index of the desired item in square brackets. For example, here’s how to
    print just the first item of your to-do list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `print()` function yields the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use a list’s indices not only to access a required item but also to
    insert a new item at a certain position in the list. Say you want to add a new
    chore to your to-do list between walking the dog and cooking dinner. To make this
    insertion, you first use the `index()` method to determine the index of the item
    before which you want to insert the new item. Here, you’ll store it in the variable
    `i`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will become the index for the new chore, which you can now add using the
    `insert()` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The new chore is added to the list at the specified index, shifting all subsequent
    chores down by one. This is what the updated list looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Because lists allow for duplicate items, you may need to check how many times
    a certain item appears in a list. This can be done with the `count()` method,
    as illustrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `print()` function reveals only one instance of `'Tidy up'` in the list,
    but it might be a good idea to include this item in your daily list more than
    once!
  prefs: []
  type: TYPE_NORMAL
- en: Using Slice Notation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s possible to access a range of items from a sequential data type such as
    a list by using *slice notation*. To take a slice of a list, specify the index
    of the starting position and the index of the ending position plus 1\. Separate
    the two indices with a colon, and enclose them in square brackets. For example,
    you can print the first three items from your to-do list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a list of the items with indices 0 through 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the start and end indices in a slice are optional. If you omit the start
    index, the slice will start at the beginning of the list. This means that the
    slice in the preceding example can be safely changed to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you omit the end index, the slice will continue through the end of the list.
    Here’s how to print the items with indices of 3 and higher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is the last two items in your to-do list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can omit both indices, in which case you’ll get a copy of the
    whole list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Slice notation is not limited to extracting a subsequence from a list. You
    can also use it instead of the `append()` and `insert()` methods to populate a
    list with data. Here, for example, you add two items to the end of your list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `len()` function returns the number of items in the list, which is also
    the index of the first unused position outside the list. You can safely add new
    items starting from this index. Here’s how the list looks now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can remove items using the `del` command and slicing as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This removes the items with indices 5 and above, thus returning the list to
    its previous form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Using a List as a Queue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *queue* is an abstract data type that can be implemented using the list data
    structure. One end of a queue is always used to insert items (*enqueue*), and
    the other is used to remove them (*dequeue*), thus following the *first-in, first-out
    (FIFO)* methodology. In practice, the FIFO methodology is often used in warehousing:
    the first products that arrive at the warehouse are the first products to leave.
    Organizing the sale of goods in this way can help prevent product expiration by
    ensuring that the older products are the first to be sold.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to turn a Python list into a queue using Python’s `deque` object (short
    for *double-ended queue*). In this section, we’ll explore how this works using
    your to-do list. For a list to function as a queue, completed tasks should drop
    off the beginning while new tasks appear at the end of the list, as illustrated
    in [Figure 2-1](#figure2-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![To-do list tasks arranged in a block diagram from left to right. New tasks
    are added on the right; completed tasks are removed on the left.](image_fi/502208c02/f02001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-1: An example of using a list as a queue'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to implement the process shown in the figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In this script, you first turn the `my_list` object from the previous examples
    into a `deque` object, which is part of Python’s `collections` module. The `deque()`
    object constructor adds a set of methods to the list object being passed into
    it, making it easier to use that list as a queue. In this particular example,
    you add a new element to the right side of the queue with the `append()` method,
    then you remove an item from the left side of the queue using the `popleft()`
    method. This method not only removes the leftmost item but also returns it, thus
    feeding it into your printed message. You should see the following message as
    a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After being converted back from a `deque` object to a list in the last line
    of the script, the updated to-do list appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the first item has been pushed out of the list, while a new
    one has been appended.
  prefs: []
  type: TYPE_NORMAL
- en: Using a List as a Stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like a queue, a *stack* is an abstract data structure that you can organize
    on top of a list. A stack implements the *last-in, first-out (LIFO)* methodology,
    where the last item added is the first item retrieved. For your to-do list to
    function as a stack, you would complete the tasks in reverse order, starting with
    the rightmost task. Here’s how to implement this concept in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `for` loop, you push the tasks from the to-do list into a stack defined
    as another list, starting from the first task. This is an example of using `append()`
    in a loop to dynamically populate an empty list. Then, in the `while` loop, you
    remove the tasks from the stack, starting from the last one. You do this with
    the `pop()` method, which removes the last item from a list and returns the removed
    item. The stack’s output will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Using Lists and Stacks for Natural Language Processing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lists and stacks have many real-world applications, including in the field of
    NLP. For example, you can use lists and stacks to extract all the noun chunks
    from a text. A noun chunk consists of a noun and its left syntactic children (that
    is, all those words to the noun’s left that are syntactically dependent on the
    noun, such as adjectives or determiners). Thus, to extract the noun chunks from
    a text, you’ll need to search the text for all the nouns and the nouns’ left syntactic
    children. This can be implemented with a stack-based algorithm, as illustrated
    in [Figure 2-2](#figure2-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![The phrase “a ubiquitous data structure” is added to a stack one word at
    a time, from left to right, and words are removed from right to left. a parsing
    of the phrase  shows  arrows  going  from “structure” to each of the other words.](image_fi/502208c02/f02002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-2: An example of using a list as a stack'
  prefs: []
  type: TYPE_NORMAL
- en: The figure uses a single noun chunk as an example, *A ubiquitous data structure*.
    The arrows in the syntactic tree on the right illustrate how the words *A*, *ubiquitous*,
    and *data* are syntactic children of the noun *structure*, which is known as the
    *head* of those syntactic children. The algorithm analyzes the text from left
    to right, one word at a time, pushing the word to the stack if it’s a noun or
    the left syntactic child of a noun. When the algorithm encounters a word that
    doesn’t fit that description, or if there are no words left in the text, an entire
    noun chunk has been found, and the chunk is extracted from the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this stack-based algorithm for noun chunk extraction, you’ll need
    to install spaCy, the leading open source Python library for natural language
    processing, as well as one of its English models. Use these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following script uses spaCy to implement the leading open source Python
    library for natural language processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The first few lines of the script go through the standard setup process for
    analyzing a text phrase with spaCy. You import the spaCy library, define a sentence
    to be processed, and load spaCy’s English model. After that, you apply the `nlp`
    pipeline to the sentence, instructing spaCy to generate the sentence’s syntactic
    structure, which is needed for tasks like noun chunk extraction.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you implement the algorithm described previously, iterating through each
    word of the text. If you find either a noun ❶ or one of its left syntactic children
    ❷, you send it to the stack using the `append()` operation. You make these determinations
    using spaCy’s built-in properties, such as `w.head.lefts`, which allow you to
    navigate across the sentence’s syntactic structure and find desired words in it.
    Thus, with `w in w.head.lefts`, you look up the head of a word (`w.head`), then
    look up the left syntactic children of that head (`.lefts`) and determine whether
    the word in question is one of them. To illustrate, when evaluating the word *ubiquitous*,
    `w.head` would yield *structure*, the syntactic head of *ubiquitous*, and `.lefts`
    of *structure* would yield the words *a*, *ubiquitous*, and *data*, demonstrating
    that *ubiquitous* is indeed a left child of *structure*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finishing up the algorithm, once you determine that the next word in the text
    isn’t part of the noun chunk at hand (neither a noun nor a left child of a noun)
    ❸, you have a complete noun chunk, and you extract the words from the stack ❹.
    This script finds and outputs the following three noun chunks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Making Improvements with List Comprehensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Chapter 1, you saw an example of creating a list using the list comprehension
    feature. In this section, we’ll use list comprehensions to improve our noun chunk
    extraction algorithm. Improving the functionality of a solution often requires
    you to make significant enhancements to existing code. In this case, however,
    since list comprehensions are involved, the enhancements to be made will be quite
    compact.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the syntactic dependency tree shown in [Figure 2-2](#figure2-2),
    you may notice that each element of the phrase depicted there is directly related
    by a syntactic arc to the noun *structure*. However, a noun chunk can also follow
    another pattern, where some words are not connected to the phrase’s noun by a
    direct syntactic relationship. [Figure 2-3](#figure2-3) illustrates what the dependency
    tree of such a phrase might look like. Notice that the adverb *most* is the child
    of the adjective *useful*, not the noun *type*, yet it’s still part of the noun
    chunk that has *type* as its head.
  prefs: []
  type: TYPE_NORMAL
- en: '![Parsing the phrase “the most useful type.” Arrows  go  from “type” to “the,”
    from “type” to “useful,” and from “useful” to “most.”](image_fi/502208c02/f02003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-3: The syntactic dependency tree of a more complex noun chunk'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to improve the script from the previous section so that it can also
    extract noun chunks like the one shown in [Figure 2-3](#figure2-3), where some
    words in a chunk are not connected to the phrase’s noun directly. To refine our
    algorithm, let’s first compare the syntactic dependency trees depicted in Figures
    2-2 and 2-3 to find what they have in common. The important similarity is that
    in both trees, the head of each word that is dependent in a noun chunk can be
    found to the right of the word. However, the noun that forms the phrase may not
    follow this pattern. For example, in the sentence “List is a ubiquitous data structure
    in the Python programming language,” the word *structure* is the head of a noun
    chunk, but its own head, the verb *is*, is located to its left. To make sure it
    is so, you can run the following script that outputs the head for each word in
    the sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Our new algorithm needs to scan a text looking for words whose heads are to
    their right, thus indicating potential noun chunks. The idea is to create a kind
    of matrix for a sentence that indicates whether the head of a word is to its right
    or not. For readability, the words whose heads are on the right could be included
    in the matrix as they are in the sentence, while all the others could be replaced
    with zeros. Thus, for the following sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'you would have the following matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create this matrix using a list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, you iterate over the words of the submitted sentence in the loop within
    the list comprehension, substituting zeros for those words whose heads are not
    to the right ❶.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated list looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that the list contains one more element than there are words
    in the sentence. This is because spaCy actually breaks the text up into tokens,
    which may be words or punctuation marks. The final `0` in the list represents
    the period at the end of the sentence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you need a way to move through this list in order to find and extract noun
    chunks. You’ll need to create a series of text fragments, where each fragment
    starts at a certain position and continues until the end of the text. In the following
    snippet, you move word by word from the start through the rest of the text, generating
    a matrix of the sides of the heads in each iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You use slice notation in the `doc` object to get the fragment that is needed
    ❶. This mechanism allows you to shift the leftmost position of the resulting slice
    one word to the right at each iteration of the `for` loop. The code generates
    the following set of matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You must analyze each fragment next, looking for the first zero. The words
    up to and including that zero could potentially be a noun chunk. Here’s the code
    for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You set `i0` equal to `head_lefts.index(0)` to find the index of the first zero
    in the fragment ❶. If there are multiple zero elements, `head_lefts.index(0)`
    returns the index of the first element. Then, you check whether `i0 > 0` to weed
    out fragments that don’t start with a head-left element.
  prefs: []
  type: TYPE_NORMAL
- en: You then use another list comprehension to process the elements of the noun
    chunks to be sent to the stack. In this second list comprehension, you look for
    a noun or a proper noun within each fragment that could potentially be a noun
    chunk. You loop over the fragment in reverse order to first pick up the noun or
    proper noun that forms the chunk and which, therefore, is supposed to appear in
    the last position of the fragment ❷. What you actually send to the list when any
    noun or proper noun is found is a `1`, and you send a `0` for every other element.
    Thus, the first `1` found in the list indicates the position of the main noun
    in the fragment relative to the fragment’s end ❸. You’ll need it when calculating
    the slice of the text representing the noun chunk ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, you simply output the generated fragments along with the nouns found
    within them. You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can incorporate the new code into the solution introduced in the previous
    section. Putting it all together, you arrive at the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You iterate over the tokens in the submitted sentence ❶, generating a `head_lefts`
    list in each iteration ❷. Recall that this list is a matrix containing zeros for
    those words in the sentence whose syntactic heads are to their left. These matrices
    are used to identify noun chunks. For each chunk you identify, you send each noun
    or proper noun to the stack ❸, as well as any other word that belongs to the chunk
    but is not a noun ❹. Once you reach the end of the chunk, you extract the tokens
    from the stack, forming a phrase ❺.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like a list, a *tuple* is an ordered collection of objects. Unlike lists, however,
    tuples are immutable. Once a tuple is created, it cannot be changed. The items
    in a tuple are separated by commas and can optionally be enclosed in parentheses,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Tuples are typically used to store collections of heterogeneous data; that is,
    data of different types, such as the make, model, and year of a car. As this example
    illustrates, they are especially useful when you need a structure to hold the
    properties of a real-world object.
  prefs: []
  type: TYPE_NORMAL
- en: A List of Tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s common to nest Python data structures inside each other. For example,
    you can have a list where each element is a tuple, which lets you assign more
    than one attribute to each element in the list. Say you want to assign a start
    time to each task in the to-do list you created earlier in the chapter. Each item
    in the list will become a data structure unto itself, consisting of two elements:
    the description of a task and its scheduled start time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement such a structure, tuples are an ideal choice, since they are intended
    to collect heterogeneous data in a single structure. Your list of tuples might
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can build this list of tuples from the following two simple lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the first list is the original `my_list`, and the second one
    is a list containing the corresponding start times. The easiest way to combine
    them into a list of tuples is to use a list comprehension, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Within the list comprehension, you use Python’s `zip()` function, which iterates
    over the two simple lists simultaneously, combining the corresponding times and
    tasks into tuples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with lists, to access an item in a tuple you specify the item’s index
    enclosed in square brackets following the name of the tuple. Note, however, that
    tuples nested within a list are not assigned names. To access an item in a nested
    tuple, you first need to specify the name of the list, then the index of the tuple
    in the list, and finally the index of the item in the tuple. For example, to see
    the time assigned to the second task in your to-do list, you would use the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Immutability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An important thing to remember about tuples is that they’re immutable. That
    is, you can’t modify them. For example, if you try to change the start time for
    one of your chores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'you’ll get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Because they’re immutable, tuples are not suitable for holding data values that
    need to be updated periodically.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *dictionary* is another widely used built-in data structure in Python.
    Dictionaries are mutable, unordered collections of *key-value pairs*, where each
    *key* is a unique name that identifies an item of data, the *value*. A dictionary
    is delimited by curly brackets. Each key is separated from its value by a colon,
    and key-value pairs are separated by commas, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Dictionaries, like tuples, are useful for storing heterogeneous data about real-world
    objects. As this example illustrates, dictionaries have the added benefit of assigning
    a label to each item of data.
  prefs: []
  type: TYPE_NORMAL
- en: A List of Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like other data structures, dictionaries can be nested inside other structures.
    Your to-do list, when implemented as a list of dictionaries, might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike tuples, dictionaries are mutable, which means that you can easily change
    the value in a key-value pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This example also illustrates how to access values in a dictionary: unlike
    with lists and tuples, you use key names rather than numeric indices.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding to a Dictionary with setdefault()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `setdefault()` method provides a convenient way to add new data to a dictionary.
    It takes a key-value pair as its parameter. If the specified key already exists,
    the method simply returns the current value of that key. If the key doesn’t exist,
    `setdefault()` inserts the key with the specified value. To see an example, first
    create a dictionary called `car` where the model is `Jetta`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try adding a new `model` key with a value of `Passat` using `setdefault()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output, showing that the value of the `model` key
    has remained the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you specify a new key, `setdefault()` inserts the key-value pair
    and returns the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now print the entire dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'this is what you see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `setdefault()` method relieves you from having to manually
    check whether the key in the key-value pair you want to insert is already in the
    dictionary. You can safely try to insert a key-value pair into a dictionary without
    the risk of overwriting the value of a key that already exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know how `setdefault()` works, let’s look at a practical example.
    Counting the number of occurrences of each word in a text phrase is a common task
    in NLP. The following example demonstrates how this can be accomplished, with
    the help of a dictionary, using the `setdefault()` method. Here’s the text that
    you’ll process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step is to remove the punctuation from the text. Without this step,
    `''languages''` and `''languages.''` would count as two separate words. Here,
    you remove the periods and commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you split the text into words, putting them into a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated list of words is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can count the occurrences of each word in the list. This can be implemented
    with a dictionary using the `setdefault()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: First, you create an empty dictionary. Then you add key-value pairs to it, using
    the words from the list as the keys. The `setdefault()` method sets the initial
    value for each key to `0`. The value is then increased by 1 for the first occurrence
    of each word, yielding a count of 1\. On subsequent occurrences of that word,
    `setdefault()` will leave the previous count value intact, but the count value
    will be incremented by 1 with the `+=` operator, producing an accurate count.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before outputting the dictionary, you might want to sort the words by number
    of occurrences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the dictionary’s `items()` method, you can convert this dictionary into
    a list of tuples, where each tuple contains a key and its value. Thus, when you
    specify `x[1]` in `lambda` for the `key` parameter of the `sorted()` function,
    you’re sorting according to the items in the tuples with index `1`—that is, the
    values (word counts) from the original dictionary. The resulting dictionary appears
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Loading JSON into a Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the help of dictionaries, you can easily convert Python data structures
    into JSON strings and vice versa. Here’s how to load a string representing a JSON
    document into a dictionary using only the assignment operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As you might notice, this dictionary has a complex structure. The value of the
    `ShippingInstructions` key is itself a dictionary, in which the value of the `Address`
    key is yet another dictionary and the value of the `Phone` key is a list of dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can save the dictionary directly to a JSON file with Python’s `json` module
    using the `json.dump()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you can use the `json.load()` method to load the contents of a JSON
    file directly into a Python dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: As a result, you get the same dictionary that was shown at the beginning of
    this section. We’ll discuss working with files in more detail in Chapter 4.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Python *set* is an unordered collection of unique items. Duplicate items
    are not allowed in a set. A set is defined with curly brackets containing items
    separated by commas, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Removing Duplicates from Sequences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since members of a set must be unique, sets are useful when you need to remove
    duplicate items from a list or a tuple. Suppose a business wants to see a list
    of its customers. You might obtain such a list by deriving customers’ names from
    the orders they’ve placed. Since a customer may have placed more than one order,
    the list may have duplicate names. The duplicates can be removed with the help
    of a set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'You simply convert the original list to a set and then back to a list. The
    set constructor automatically deletes the duplicates. The updated list looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: A drawback of this approach is that it does not preserve the initial order of
    elements. This is due to the fact that a set is an unordered collection of items.
    Indeed, if you run the preceding code two or three times, the order of the output
    might be different each time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform the same operation without losing the initial order, use Python’s
    `sorted()` function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'This sorts the set by the indices of the original list, thus preserving the
    order. The updated list is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Performing Common Set Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Set objects come with methods for performing common math operations on sequences,
    like unions and intersections. These methods let you easily combine sets or extract
    the elements shared by multiple sets.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you need to classify a huge number of photos into groups based
    on what’s in the photos. To automate this task, you might start with a visual
    recognition tool like Clarifai API that will generate a set of descriptive tags
    for each photo. The sets of tags can then be compared with each other using the
    `intersection()` method. This method compares two sets and creates a new set containing
    all of the elements that are in both. In this particular case, the more tags that
    there are in both sets, the more similar the two images are with respect to their
    theme.
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplicity, the following example uses just two photos. Using their corresponding
    sets of descriptive tags, you can determine the extent to which the subject matter
    of the two photos coincides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In this code, you perform the intersection operation to find the items shared
    by both sets. If the number of the items that the sets have in common is equal
    to or greater than two, you can conclude that the photos have a similar theme
    and, therefore, can be grouped together.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter has covered Python’s four built-in data structures: lists, tuples,
    dictionaries, and sets. You saw a wide range of examples showing how these structures
    can represent real-world objects, and you learned how they can be combined into
    nested structures, including a list of tuples, a list of dictionaries, and a dictionary
    whose values are lists.'
  prefs: []
  type: TYPE_NORMAL
- en: The chapter also explored features that allow you to easily build functional
    data analysis applications in Python. For example, you learned how to use list
    comprehensions to create new lists from existing ones and how to use the `setdefault()`
    method to efficiently access and manipulate the data in a dictionary. Through
    examples, you saw how these features are transferable to common challenges like
    text processing and photo analysis.
  prefs: []
  type: TYPE_NORMAL
