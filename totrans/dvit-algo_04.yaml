- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Pure Math
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 纯数学
- en: '![](Images/circleart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/circleart.png)'
- en: The quantitative precision of algorithms makes them naturally suited to applications
    in mathematics. In this chapter, we explore algorithms that are useful in pure
    mathematics and look at how mathematical ideas can improve any of our algorithms.
    We’ll start by discussing continued fractions, an austere topic that will take
    us to the dizzy­ing heights of the infinite and give us the power to find order
    in chaos. We’ll continue by discussing square roots, a more prosaic but arguably
    more useful topic. Finally, we’ll discuss randomness, including the mathematics
    of randomness and some important algorithms that generate random numbers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的定量精确性使得它们自然适用于数学应用。在本章中，我们将探讨在纯数学中有用的算法，并讨论数学思想如何改善我们的算法。我们将从讨论连分数开始，这是一个严谨的话题，它将带领我们攀登无限的高峰，并赋予我们在混乱中找到秩序的能力。接着，我们将讨论平方根，这是一个更为平凡但无疑更有用的话题。最后，我们将讨论随机性，包括随机性的数学以及一些生成随机数的重要算法。
- en: Continued Fractions
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连分数
- en: 'In 1597, the great Johannes Kepler wrote about what he considered geometry’s
    “two great treasures”: the Pythagorean theorem and a number that has since come
    to be called the *golden ratio*. Often denoted by the Greek letter *phi*, the
    golden ratio is equal to about 1.618, and Kepler was only one of dozens of great
    thinkers who have been entranced by it. Like pi and a few other famous constants,
    such as the exponential base *e*, phi has a tendency to show up in unexpected
    places. People have found phi in many places in nature, and have painstakingly
    documented where it occurs in fine art, as in the annotated version of the Rokeby
    Venus shown in [Figure 5-1](#figure5-1).'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 1597年，伟大的约翰内斯·开普勒写到他认为几何学的“两个伟大宝藏”：毕达哥拉斯定理和一个后来被称为*黄金比例*的数字。黄金比例通常用希腊字母*phi*表示，约等于1.618，而开普勒只是众多被它吸引的伟大思想家中的一位。像圆周率(pi)以及其他一些著名常数，如指数基数*e*，phi也有一种倾向，常常出现在一些出乎意料的地方。人们在大自然中发现了phi，并且费心记录它在美术作品中的出现，比如[Figure
    5-1](#figure5-1)中注释版的《罗克比维纳斯》。
- en: In [Figure 5-1](#figure5-1), a phi enthusiast has added overlays that indicate
    that the ratios of some of these lengths, like *b*/*a* and *d*/*c*, seem to be
    equal to phi. Many great paintings have a composition that’s amenable to this
    kind of phi-hunting.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Figure 5-1](#figure5-1)中，一位phi爱好者添加了叠加图层，标示出某些长度的比率，如*b*/*a*和*d*/*c*，似乎等于phi。许多伟大的画作的构图都适合进行这种phi狩猎。
- en: '![Figure_5-1](Images/figure_5-1.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![Figure_5-1](Images/figure_5-1.png)'
- en: '[Figure 5-1:](#figureanchor5-1) Phi/Venus (from *[https://commons.wikimedia.org/wiki/File:DV_The_Toilet_of_Venus_Gr.jpg](https://commons.wikimedia.org/wiki/File:DV_The_Toilet_of_Venus_Gr.jpg)*)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 5-1:](#figureanchor5-1) Phi/Venus（来自*[https://commons.wikimedia.org/wiki/File:DV_The_Toilet_of_Venus_Gr.jpg](https://commons.wikimedia.org/wiki/File:DV_The_Toilet_of_Venus_Gr.jpg)*）'
- en: Compressing and Communicating Phi
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压缩与传递phi
- en: Phi’s exact value is surprisingly hard to express. I could say that it’s equal
    to 1.61803399 . . . . The ellipsis here is a way of cheating; it means that more
    numbers follow (an infinite number of numbers, in fact), but I haven’t told you
    what those numbers are, so you still don’t know the exact value of phi.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: phi的精确值出奇地难以表达。我可以说它等于1.61803399...。这里的省略号是一种“作弊”方式；它意味着后面有更多的数字（实际上是无限多个数字），但我并没有告诉你这些数字是什么，因此你仍然不知道phi的精确值。
- en: For some numbers with infinite decimal expansions, a fraction can represent
    them exactly. For example, the number 0.11111 . . . is equal to 1/9—here, the
    fraction provides an easy way to express the exact value of an infinitely continued
    decimal. Even if you didn’t know the fractional representation, you could see
    the pattern of repeating 1s in 0.1111 . . . and thereby understand its exact value.
    Unfortunately, the golden ratio is what’s called an *irrational number*, meaning
    that there are no two integers *x* and *y* that enable us to say that phi is equal
    to *x*/*y*. Moreover, no one has yet been able to discern any pattern in its digits.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些具有无限小数扩展的数字，一个分数可以精确表示它们。例如，数字0.11111...等于1/9——在这里，分数提供了一种简便的方法来表达无限连续小数的精确值。即使你不知道这种分数表示法，你也可以看到0.1111...中重复1的模式，从而理解它的精确值。不幸的是，黄金比例是所谓的*无理数*，这意味着没有两个整数*x*和*y*，使得我们可以说phi等于*x*/*y*。而且，至今没有人能够辨认出它的数字中有任何规律。
- en: 'We have an infinite decimal expansion with no clear pattern and no fractional
    representation. It may seem impossible to ever clearly express phi’s exact value.
    But if we learn more about phi, we can find a way to express it both exactly and
    concisely. One of the things we know about phi is that it’s the solution to this
    equation:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个无限的小数展开式，既没有明显的规律，也没有分数表示。似乎不可能清楚地表达 phi 的精确值。但是，如果我们进一步了解 phi，就能找到一种既精确又简洁的表达方式。我们知道，phi
    是这个方程的解：
- en: '![c05eq001](Images/c05eq001.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq001](Images/c05eq001.png)'
- en: One way we might imagine expressing the exact value of phi would be to write
    “the solution to the equation written above this paragraph.” This has the benefit
    of being concise and technically exact, but it means that we have to solve the
    equation somehow. That description also doesn’t tell us the 200th or 500th digit
    in phi’s expansion.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设想一种表达 phi 精确值的方法，那就是写下“上面这段文字中所写方程的解”。这种方法既简洁又在技术上是精确的，但这意味着我们必须以某种方式求解该方程。而且，这种描述并没有告诉我们
    phi 展开式中的第 200 位或第 500 位数字。
- en: 'If we divide our equation by phi, we get the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将方程除以 phi，我们得到以下结果：
- en: '![c05eq002](Images/c05eq002.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq002](Images/c05eq002.png)'
- en: 'And if we rearrange that equation, we get this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新排列该方程，我们得到：
- en: '![c05eq003](Images/c05eq003.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq003](Images/c05eq003.png)'
- en: 'Now imagine if we attempted a strange substitution of this equation into itself:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下，如果我们尝试将这个方程奇异地代入自己：
- en: '![c05eq004](Images/c05eq004.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq004](Images/c05eq004.png)'
- en: Here, we rewrote the phi on the righthand side as 1 + 1/phi. We could do that
    same substitution again; why not?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将右侧的 phi 重写为 1 + 1/phi。我们可以再次进行同样的代入，为什么不呢？
- en: '![c05eq005](Images/c05eq005.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq005](Images/c05eq005.png)'
- en: We can perform this substitution as many times as we like, with no end. As we
    continue, phi gets pushed more and more levels “in” to the corner of a growing
    fraction. [Listing 5-1](#listing5-1) shows an expression for phi with phi seven
    levels in.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以任意多次进行这种代入，没有终点。随着我们继续，phi 会被越来越多的层次“推入”一个不断增长的分数的角落。[清单 5-1](#listing5-1)显示了一个包含
    phi 的七级表达式。
- en: '![c05eq006](Images/c05eq006.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq006](Images/c05eq006.png)'
- en: '[Listing 5-1:](#listinganchor5-1) A continued fraction with seven levels expressing
    the value of phi'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-1:](#listinganchor5-1) 一个七级连分式，表示 phi 的值'
- en: If we imagine continuing this process, we can push phi infinity levels in. Then
    what we have left is shown in [Listing 5-2](#listing5-2).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想象继续这个过程，我们可以把 phi 推向无限层次。然后，剩下的部分在[清单 5-2](#listing5-2)中显示。
- en: '![c05eq007](Images/c05eq007.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq007](Images/c05eq007.png)'
- en: '[Listing 5-2:](#listinganchor5-2) An infinite continued fraction expressing
    the value of phi'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-2:](#listinganchor5-2) 一个表达 phi 值的无限连分式'
- en: In theory, after the infinity of 1s and plus signs and fraction bars represented
    by the ellipsis, we should insert a phi into [Listing 5-2](#listing5-2), just
    like it appears in the bottom right of [Listing 5-1](#listing5-1). But we will
    never get through all of those 1s (because there are an infinite number of them),
    so we are justified in forgetting entirely about the phi that’s supposed to be
    nested in the righthand side.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，在由省略号表示的无穷多个 1 和加号以及分数线之后，我们应该在[清单 5-2](#listing5-2)中插入一个 phi，就像它在[清单 5-1](#listing5-1)的右下角出现的那样。但我们永远无法完成所有的
    1（因为它们是无穷多个），因此我们完全可以忽略掉本应嵌套在右侧的 phi。
- en: More about Continued Fractions
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多关于连分式的内容
- en: 'The expressions just shown are called continued fractions.A *continued fraction*
    consists of sums and reciprocals nested in multiple layers. Continued fractions
    can be finite, like the one in [Listing 5-1](#listing5-1) that terminated after
    seven layers, or infinite, continuing forever without end like the one in [Listing
    5-2](#listing5-2). Continued fractions are especially useful for our purposes
    because they enable us to express the exact value of phi without needing to chop
    down an infinite forest to manufacture enough paper. In fact, mathematicians sometimes
    use an even more concise notation method that enables us to express a continued
    fraction in one simple line. Instead of writing all the fraction bars in a continued
    fraction, we can use square brackets ([ ]) to denote that we’re working with a
    continued fraction, and use a semicolon to separate the digit that’s “alone” from
    the digits that are together in a fraction. With this method, we can write the
    continued fraction for phi as the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才展示的表达式称为连分数。一个*连分数*由多个层次嵌套的和与倒数构成。连分数可以是有限的，比如[列表5-1](#listing5-1)中的那个，在七层后就结束，或者是无限的，像[列表5-2](#listing5-2)中的那个，无限延续下去。连分数特别适合我们的目的，因为它们让我们能够精确表示黄金比例的值，而无需砍伐无限的森林来制造足够的纸张。事实上，数学家有时会使用一种更简洁的表示法，让我们能够在一行中表示一个连分数。我们可以不写出所有连分数中的分数线，而使用方括号（[
    ]）来表示我们正在处理一个连分数，并用分号将“孤立”的数字与组成分数的其他数字分开。通过这种方法，我们可以将黄金比例的连分数写成如下形式：
- en: '![c05eq008](Images/c05eq008.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq008](Images/c05eq008.png)'
- en: 'In this case, the ellipses are no longer losing information, since the continued
    fraction for phi has a clear pattern: it’s all 1s, so we know its exact 100th
    or 1,000th element. This is one of those times when mathematics seems to deliver
    something miraculous to us: a way to concisely write down a number that we had
    thought was infinite, without pattern, and ineffable. But phi isn’t the only possible
    continued fraction. We could write another continued fraction as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，省略号不再丢失信息，因为黄金比例的连分数有一个明确的模式：全是1，所以我们知道它的第100项或第1000项是什么。这是数学向我们展示奇迹的一次：一种简洁地写下我们曾认为是无限的、没有规律的、难以言喻的数字的方法。但黄金比例并不是唯一可能的连分数。我们还可以写出另一个连分数，如下所示：
- en: '![c05eq009](Images/c05eq009.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq009](Images/c05eq009.png)'
- en: 'In this case, after the first few digits, we find a simple pattern: pairs of
    1s alternate with increasing even numbers. The next values will be 1, 1, 10, 1,
    1, 12, and so on. We can write the beginning of this continued fraction in a more
    conventional style as'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在前几个数字之后，我们找到了一个简单的模式：一对对的1与逐渐增大的偶数交替。接下来的值将是1、1、10、1、1、12，依此类推。我们可以用更常规的方式写出这个连分数的开头，如下所示：
- en: '![c05eq010](Images/c05eq010.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq010](Images/c05eq010.png)'
- en: 'In fact, this mystery number is none other than our old friend *e*, the base
    of the natural logarithm! The constant *e*, just like phi and other irrational
    numbers, has an infinite decimal expansion with no apparent pattern and cannot
    be represented by a finite fraction, and it seems like it’s impossible to express
    its exact numeric value concisely. But by using the new concept of continued fractions
    and a new concise notation, we can write these apparently intractable numbers
    in one line. There are also several remarkable ways to use continued fractions
    to represent pi. This is a victory for data compression. It’s also a victory in
    the perennial battle between order and chaos: where we thought there was nothing
    but encroaching chaos dominating the numbers we love, we find that there was always
    a deep order beneath the surface.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这个神秘数字不就是我们老朋友*e*吗？它是自然对数的底数！常数*e*就像黄金比例和其他无理数一样，具有无限的小数展开，没有明显的规律，并且无法用有限的分数表示，似乎不可能简洁地表示其准确的数值。但通过使用新的连分数概念和新的简洁表示法，我们可以在一行中写出这些看似不可处理的数字。实际上，还有几种独特的方式可以使用连分数表示圆周率π。这是数据压缩的胜利。这也是秩序与混乱之间长期斗争的胜利：我们曾以为数字背后只有无休止的混乱，但我们发现，表面下总有一股深邃的秩序存在。
- en: Our continued fraction for phi came from a special equation that works only
    for phi. But in fact, it is possible to generate a continued fraction representation
    of any number.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的黄金比例连分数来自一个只对黄金比例有效的特殊方程。但事实上，任何数字都可以生成连分数表示。
- en: An Algorithm for Generating Continued Fractions
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成连分数的算法
- en: To find a continued fraction expansion for any number, we’ll use an algorithm.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要为任何数字找到连分数展开式，我们将使用一个算法。
- en: 'It’s easiest to find continued fraction expansions for numbers that are integer
    fractions already. For example, consider the task of finding a continued fraction
    representation of 105/33\. Our goal is to express this number in a form that looks
    like the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于已经是整数分数的数字，最容易找到连分数展开。例如，考虑求 105/33 的连分数表示。我们的目标是将这个数字表示为如下形式：
- en: '![c05eq011](Images/c05eq011.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq011](Images/c05eq011.png)'
- en: where the ellipses could be referring to a finite rather than an infinite continuation.
    Our algorithm will generate *a* first, then *b*, then *c*, and proceed through
    terms of the alphabet sequentially until it reaches the final term or until we
    require it to stop.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 其中省略号可能指的是一个有限而非无限的延续。我们的算法将首先生成 *a*，然后是 *b*，再然后是 *c*，并依次处理字母表中的项，直到达到最终项或直到我们要求它停止。
- en: 'If we interpret our example 105/33 as a division problem instead of a fraction,
    we find that 105/33 is 3, remainder 6\. We can rewrite 105/33 as 3 + 6/33:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将我们的例子 105/33 解释为除法问题，而非分数，我们发现 105/33 等于 3，余数为 6。我们可以将 105/33 重新写成 3 +
    6/33：
- en: '![c05eq012](Images/c05eq012.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq012](Images/c05eq012.png)'
- en: The left and the right sides of this equation both consist of an integer (3
    and *a*) and a fraction (6/33 and the rest of the right side). We conclude that
    the integer parts are equal, so *a* = 3\. After this, we have to find a suitable
    *b*, *c*, and so on such that the whole fractional part of the expression will
    evaluate to 6/33.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 该方程的左右两边都由一个整数（3 和 *a*）和一个分数（6/33 以及右侧其余部分）组成。我们得出结论，整数部分相等，因此 *a* = 3。之后，我们需要找到合适的
    *b*、*c* 等，确保表达式的整个分数部分等于 6/33。
- en: 'To find the right *b*, *c*, and the rest, look at what we have to solve after
    concluding that *a* = 3:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到正确的 *b*、*c* 和其余部分，来看一下在得出 *a* = 3 后我们需要解决的内容：
- en: '![c05eq013](Images/c05eq013.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq013](Images/c05eq013.png)'
- en: 'If we take the reciprocal of both sides of this equation, we get the following
    equation:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对方程的两边取倒数，就得到以下方程：
- en: '![c05eq014](Images/c05eq014.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq014](Images/c05eq014.png)'
- en: 'Our task is now to find *b* and *c*. We can do a division again; 33 divided
    by 6 is 5, with remainder 3, so we can rewrite 33/6 as 5 + 3/6:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的任务是找到 *b* 和 *c*。我们可以再次进行除法；33 除以 6 等于 5，余数为 3，因此我们可以将 33/6 重新写成 5 + 3/6：
- en: '![c05eq015](Images/c05eq015.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq015](Images/c05eq015.png)'
- en: 'We can see that both sides of the equation have an integer (5 and *b*) and
    a fraction (3/6 and the rest of the right side). We can conclude that the integer
    parts are equal, so *b* = 5\. We have gotten another letter of the alphabet, and
    now we need to simplify 3/6 to progress further. If you can’t tell immediately
    that 3/6 is equal to 1/2, you could follow the same process we did for 6/33: say
    that 3/6 expressed as a reciprocal is 1/(6/3), and we find that 6/3 is 2 remainder
    0\. The algorithm we’re following is meant to complete when we have a remainder
    of 0, so we will realize that we’ve finished the process, and we can write our
    full continued fraction as in [Listing 5-3](#listing5-3).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，方程的两边都有一个整数（5 和 *b*）和一个分数（3/6 以及右侧其余部分）。我们可以得出结论，整数部分相等，因此 *b* = 5。我们已经得到了另一个字母，现在需要将
    3/6 简化，以便进一步推进。如果你不能立刻看出 3/6 等于 1/2，你可以按照我们之前对 6/33 的处理方法：说 3/6 的倒数是 1/(6/3)，然后我们会发现
    6/3 是 2，余数为 0。我们遵循的算法要求在余数为 0 时结束，因此我们会意识到过程已完成，并且可以像在 [Listing 5-3](#listing5-3)
    中那样写出完整的连分数。
- en: '![c05eq016](Images/c05eq016.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq016](Images/c05eq016.png)'
- en: '[Listing 5-3:](#listinganchor5-3) A continued fraction for 105/33'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 5-3:](#listinganchor5-3) 105/33 的连分数'
- en: 'If this process of repeatedly dividing two integers to get a quotient and a
    remainder felt familiar to you, it should have. In fact, it’s the same process
    we followed in Euclid’s algorithm in Chapter 2! We follow the same steps but record
    different answers: for Euclid’s algorithm, we recorded the final nonzero remainder
    as the final answer, and in the continued fraction generation algorithm, we recorded
    every quotient (every letter of the alphabet) along the way. As happens so often
    in math, we have found an unexpected connection—in this case, between the generation
    of a continued fraction and the discovery of a greatest common divisor.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得这个通过反复除以两个整数来得到商和余数的过程有些熟悉，那应该没错。事实上，这正是我们在第 2 章的欧几里得算法中所遵循的相同过程！我们遵循相同的步骤，但记录不同的答案：对于欧几里得算法，我们记录最终的非零余数作为最后的答案，而在连分数生成算法中，我们记录了沿途的每个商（每个字母）。正如数学中常常发生的那样，我们发现了一个意外的联系——在本例中，是连分数生成与最大公约数发现之间的联系。
- en: We can implement this continued fraction generation algorithm in Python as follows.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式在 Python 中实现这个连分数生成算法。
- en: 'We’ll assume that we’re starting with a fraction of the form *x*/*y*. First,
    we decide which of *x* and *y* is bigger and which is smaller:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设从一个 *x*/*y* 形式的分数开始。首先，我们决定 *x* 和 *y* 哪个更大，哪个更小：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we’ll take the quotient of the bigger divided by the smaller of the two,
    just as we did with 105/33\. When we found that the result was 3, remainder 6,
    we concluded that 3 was the first term (*a*) in the continued fraction. We can
    take this quotient and store the result as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将较大的数除以较小的数，正如我们处理 105/33 时所做的那样。当我们发现结果是 3，余数是 6 时，我们得出结论，3 是连分数的第一个项（*a*）。我们可以将这个商存储如下：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this case, we are ready to obtain a full alphabet of results (*a*, *b*, *c*,
    and so on), so we create an empty list called `output` and append our first result
    to it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们已经准备好获取完整的字母表结果（*a*、*b*、*c* 等），因此我们创建一个空列表 `output`，并将我们的第一个结果附加到其中。
- en: 'Finally, we have to repeat the process, just as we did for 33/6\. Remember
    that 33 was previously the `small` variable, but now it’s the `big` one, and the
    remainder of our division process is the new `small` variable. Since the remainder
    is always smaller than the divisor, `big` and `small` will always be correctly
    labeled. We accomplish this switcheroo in Python as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须重复该过程，就像我们对 33/6 执行的那样。记住，33之前是`small`变量，但现在它变成了`big`，而除法过程的余数是新的`small`变量。由于余数总是小于除数，`big`
    和 `small` 会始终正确标记。我们可以在 Python 中通过以下方式完成这一转换：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At this point, we have completed one round of the algorithm, and we need to
    repeat it for our next set of numbers (33 and 6). In order to accomplish the process
    concisely, we can put it all in a loop, as in [Listing 5-4](#listing5-4).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经完成了一轮算法，现在需要对下一组数字（33 和 6）重复执行。为了简洁地完成这个过程，我们可以将其放入一个循环中，如[清单 5-4](#listing5-4)所示。
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Listing 5-4:](#listinganchor5-4) An algorithm for expressing fractions as
    continued fractions'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-4:](#listinganchor5-4) 一个将分数表示为连分数的算法'
- en: Here, we took *x* and *y* as inputs, and we defined a `length_tolerance` variable.
    Remember that some continued fractions are infinite in length, and others are
    extremely long. By including a `length_tolerance` variable in the function, we
    can stop our process early if the output is getting unwieldy, and thereby avoid
    getting caught in an infinite loop.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 *x* 和 *y* 作为输入，并定义了一个`length_tolerance`变量。记住，某些连分数是无限长的，而其他一些则非常长。通过在函数中加入一个`length_tolerance`变量，如果输出变得过于复杂，我们可以提前停止过程，从而避免陷入无限循环。
- en: Remember that when we performed Euclid’s algorithm, we used a recursive solution.
    In this case, we used a `while` loop instead. Recursion is well suited to Euclid’s
    algorithm because it required only one final output number at the very end. Here,
    however, we want to collect a sequence of numbers in a list. A loop is better
    suited to that kind of sequential collection.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当我们执行欧几里得算法时，我们使用了递归解法。而在这种情况下，我们则使用了 `while` 循环。递归非常适合欧几里得算法，因为它只需要在最后得到一个最终输出结果。然而，在这里，我们希望将一系列数字收集到一个列表中。循环更适合这种按顺序收集的任务。
- en: 'We can run our new `continued_fraction` generation function as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式运行我们的新 `continued_fraction` 生成函数：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We’ll get the following simple output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下简单的输出：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can see that the numbers here are the same as the key integers on the right
    side of [Listing 5-3](#listing5-3).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这里的数字与[清单 5-3](#listing5-3)右侧的关键整数是相同的。
- en: We may want to check that a particular continued fraction correctly expresses
    a number we’re interested in. In order to do this, we should define a `get_number()`
    function that converts a continued fraction to a decimal number, as in [Listing
    5-5](#listing5-5).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要检查某个特定的连分数是否正确地表示了我们感兴趣的数字。为了做到这一点，我们应该定义一个`get_number()`函数，将连分数转换为十进制数，如[清单
    5-5](#listing5-5)所示。
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Listing 5-5:](#listinganchor5-5) Converting a continued fraction to a decimal
    representation of a number'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-5:](#listinganchor5-5) 将连分数转换为数字的十进制表示'
- en: We don’t need to worry about the details of this function since we’re just using
    it to check our continued fractions. We can check that the function works by running
    `get_number([3,5,2])` and seeing that we get 3.181818 . . . as the output, which
    is another way to write 105/33 (the number we started with).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要担心这个函数的细节，因为我们只是用它来检查我们的连分数。我们可以通过运行`get_number([3,5,2])`来检查该函数是否正常工作，看到输出结果是3.181818
    . . .，这就是另一种表示105/33（我们最初的数字）的方法。
- en: From Decimals to Continued Fractions
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从小数到连分数
- en: 'What if, instead of starting with some *x*/*y* as an input to our continued
    fraction algorithm, we start with a decimal number, like 1.4142135623730951? We’ll
    need to make a few adjustments, but we can more or less follow the same process
    we followed for fractions. Remember that our goal is to find *a*, *b*, *c*, and
    the rest of the alphabet in the following type of expression:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们不是从某个*x*/*y*开始作为输入进入我们的连分数算法，而是从一个小数开始，例如1.4142135623730951？我们需要做一些调整，但基本上可以沿用我们对分数所采取的相同过程。记住，我们的目标是找到*a*、*b*、*c*，以及接下来字母表中的其他字母，像下面这种类型的表达式：
- en: '![c05eq017](Images/c05eq017.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq017](Images/c05eq017.png)'
- en: 'Finding *a* is as simple as it gets—it’s just the part of the decimal number
    to the left of the decimal point. We can define this `first_term` (*a* in our
    equation) and the leftover as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 找到*a*是最简单的，它就是小数点左边的数字部分。我们可以将这个`first_term`（我们方程中的*a*）和剩余部分定义如下：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Just like before, we’re storing our successive answers in a list called `output`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们将连续的答案存储在一个名为`output`的列表中。
- en: 'After solving for *a*, we have a leftover, and we need to find a continued
    fraction representation for it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 解决了*a*后，我们会有一个剩余部分，需要为其找到一个连分数表示：
- en: '![c05eq018](Images/c05eq018.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq018](Images/c05eq018.png)'
- en: 'Again, we can take a reciprocal of this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以取这个数的倒数：
- en: '![c05eq019](Images/c05eq019.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq019](Images/c05eq019.png)'
- en: 'Our next term, *b*, will be the integer part to the left of the decimal point
    in this new term—in this case, 2\. And then we will repeat the process: taking
    a reciprocal of a decimal part, finding the integer part to the left of the decimal,
    and so on.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个项*b*将是这个新项的小数点左边的整数部分——在这个例子中是2。然后我们将重复这个过程：取倒数的小数部分，找到小数点左边的整数部分，以此类推。
- en: 'In Python, we accomplish each round of this as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以通过以下方式完成每一轮：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can put the whole process together into one function as in [Listing 5-6](#listing5-6).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将整个过程组合成一个函数，如[清单5-6](#listing5-6)所示。
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Listing 5-6:](#listinganchor5-6) Finding continued fractions from decimal
    numbers'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单5-6:](#listinganchor5-6) 从小数找到连分数'
- en: In this case, we include a `length_tolerance` term just like before. We also
    add an `error_tolerance` term, which allows us to exit the algorithm if we get
    an approximation that’s “close enough” to the exact answer. To find out whether
    we are close enough, we take the difference between `x`, the number we are trying
    to approximate, and the decimal value of the continued fraction terms we have
    calculated so far. To get that decimal value, we can use the same `get_number()`
    function we wrote in [Listing 5-5](#listing5-5).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们像之前一样包含一个`length_tolerance`项。我们还添加了一个`error_tolerance`项，这使得我们能够在得到一个“足够接近”精确答案的近似值时退出算法。为了判断我们是否足够接近，我们计算`x`（我们想要逼近的数字）与我们已经计算出的连分数项的小数值之间的差异。为了获得这个小数值，我们可以使用我们在[清单5-5](#listing5-5)中编写的`get_number()`函数。
- en: 'We can try our new function easily as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地尝试我们新的函数，方法如下：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We get the following output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can write this continued fraction as follows (using an approximate equal
    sign because our continued fraction is an approximation to within a tiny error
    and we don’t have the time to calculate every element of an infinite sequence
    of terms):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个连分数写成如下形式（使用近似等号，因为我们的连分数是一个近似值，存在微小误差，并且我们没有时间计算无限序列中每一项）：
- en: '![c05eq020](Images/c05eq020.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq020](Images/c05eq020.png)'
- en: Notice that there are 2s all along the diagonal in the fraction on the right.
    We’ve found the first seven terms of another infinite continued fraction whose
    infinite expansion consists of all 2s. We could write its continued fraction expansion
    as [1,2,2,2,2, . . .]. This is the continued fraction expansion of √2, another
    irrational number that can’t be represented as an integer fraction, has no pattern
    in its decimal digit, and yet has a convenient and easily memorable representation
    as a continued fraction.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在右边的分数中，沿对角线有2。我们已经找到了另一个无限连分数的前七项，其无限展开式由所有的2组成。我们可以将它的连分数展开式写为[1,2,2,2,2,...]。这是√2的连分数展开式，√2是另一个不能表示为整数分数的无理数，它的十进制数字没有规律，但却有一个方便且易于记忆的连分数表示。
- en: From Fractions to Radicals
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从分数到根式
- en: 'If you’re interested in continued fractions, I recommend that you read about
    Srinivasa Ramanujan, who during his short life traveled mentally to the edges
    of infinity and brought some gems back for us to treasure. In addition to continued
    fractions, Ramanujan was interested in *continued square roots* (also known as
    *nested radicals*)—for example, the following three infinitely nested radicals:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对连分数感兴趣，我推荐你阅读关于斯里尼瓦萨·拉马努金的资料，他在短暂的一生中，心灵穿越了无限的边缘，并为我们带回了一些宝贵的瑰宝。除了连分数，拉马努金还对*连根数*（也称为*嵌套根式*）感兴趣——例如，以下三个无限嵌套的根式：
- en: '![c05eq021](Images/c05eq021.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq021](Images/c05eq021.png)'
- en: and
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '![c05eq022](Images/c05eq022.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq022](Images/c05eq022.png)'
- en: and
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '![c05eq023](Images/c05eq023.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq023](Images/c05eq023.png)'
- en: It turns out that *x* = 2 (an old anonymous result), *y* = 3 (as proved by Ramanujan),
    and *z* is none other than phi, the golden ratio! I encourage you to try to think
    of a method for generating nested radical representations in Python. Square roots
    are obviously interesting if we take them to infinite lengths, but it turns out
    that they’re interesting even if we just consider them alone.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 结果发现，*x* = 2（这是一个古老的匿名结果），*y* = 3（拉马努金证明了这一点），而*z*不就是黄金比例phi吗！我鼓励你尝试在Python中构思一个生成嵌套根式表示的方法。平方根显然很有趣，如果我们将它们延伸到无限长，但实际上即使只考虑它们本身，它们也非常有趣。
- en: Square Roots
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平方根
- en: 'We take handheld calculators for granted, but when we think about what they
    can do, they’re actually quite impressive. For example, you may remember learning
    in geometry class that the sine is defined in terms of triangle lengths: the length
    of the angle’s opposite side divided by the length of the hypotenuse. But if that
    is the definition of a sine, how can a calculator have a sin button that performs
    this calculation instantaneously? Does the calculator draw a right triangle in
    its innards, get out a ruler and measure the lengths of the sides, and then divide
    them? We might ask a similar question for square roots: the square root is the
    inverse of a square, and there’s no straightforward, closed-form arithmetic formula
    for it that a calculator could use. I imagine that you can already guess the answer:
    there is an algorithm for quick calculations of square roots.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理所当然地认为手持计算器是理所应当的，但当我们思考它们能做什么时，实际上它们非常令人印象深刻。例如，你可能记得在几何课上学习过，正弦是通过三角形的边长来定义的：角的对边的长度除以斜边的长度。但如果正弦是如此定义的，计算器如何有一个sin按钮来瞬间完成这个计算呢？计算器是不是在内部画出一个直角三角形，拿出一把尺子，测量各边的长度，然后再进行除法运算？我们可能会对平方根提出类似的问题：平方根是平方的逆运算，并且没有简单的封闭形式的算术公式，计算器如何使用呢？我想你已经能猜到答案：计算平方根有一个快速计算的算法。
- en: The Babylonian Algorithm
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 巴比伦算法
- en: Suppose that we need to find the square root of a number *x*. As with any math
    problem, we can try a guess-and-check strategy. Let’s say that our best guess
    for the square root of *x* is some number *y*. We can calculate *y*², and if it’s
    equal to *x*, we’re done (having achieved a rare completion of the one-step “lucky
    guess algorithm”).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要找到一个数字*x*的平方根。像所有数学问题一样，我们可以尝试猜测并检查的策略。假设我们对*x*的平方根的最佳猜测是某个数字*y*。我们可以计算*y*²，如果它等于*x*，那么我们就完成了（成功实现了稀有的一步“幸运猜测算法”）。
- en: 'If our guess *y* is not exactly the square root of *x*, then we’ll want to
    guess again, and we’ll want our next guess to take us closer to the true value
    of the square root of *x*. The Babylonian algorithm provides a way to systematically
    improve our guesses until we converge on the right answer. It’s a simple algorithm
    and requires only division and averaging:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的猜测 *y* 不完全是 *x* 的平方根，那么我们就需要再猜一次，我们希望下一次的猜测能更接近 *x* 的真实平方根值。巴比伦算法提供了一种系统地改进猜测的方法，直到我们逼近正确答案。这个算法很简单，只需要除法和平均操作：
- en: Make a guess, *y*, for the value of the square root of *x*.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 *x* 的平方根值做一个猜测 *y*。
- en: Calculate *z* = *x*/*y*.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 *z* = *x*/*y*。
- en: Find the average of *z* and *y*. This average is your new value of *y,* or your
    new guess for the value of the square root of *x*.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 *z* 和 *y* 的平均值。这个平均值就是你新的 *y* 值，或者说你对 *x* 的平方根的新猜测值。
- en: Repeat steps 2 and 3 until *y*² – *x* is sufficiently small.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤 2 和 3，直到 *y*² – *x* 足够小。
- en: 'We described the Babylonian algorithm in four steps. A pure mathematician,
    by contrast, might express the entire thing in one equation:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将巴比伦算法描述为四个步骤。相反，一位纯粹的数学家可能会将整个过程用一个方程表示：
- en: '![c05eq024](Images/c05eq024.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq024](Images/c05eq024.png)'
- en: 'In this case, the mathematician would be relying on the common mathematical
    practice of describing infinite sequences by continued subscripts, as in: (*y*[1],
    *y*[2], . . . *y*[n], . . .). If you know the *n*th term of this infinite sequence,
    you can get the *n* + 1th term from the equation above. This sequence will converge
    to ![c05eqsqrtx](Images/c05eqsqrtx.png), or in other words y[∞]=![c05eqsqrtx](Images/c05eqsqrtx.png).
    Whether you prefer the clarity of the four-step description, the elegant concision
    of an equation, or the practicality of the code we will write is a matter of taste,
    but it helps to be familiar with all the possible ways to describe an algorithm.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，数学家会依赖于通过继续下标描述无限序列的常见数学做法，如：(*y*[1], *y*[2], . . . *y*[n], . . .)。如果你知道这个无限序列的第
    *n* 项，你就可以从上面的方程中得到第 *n* + 1 项。这个序列会收敛到 ![c05eqsqrtx](Images/c05eqsqrtx.png)，换句话说，y[∞]
    = ![c05eqsqrtx](Images/c05eqsqrtx.png)。无论你更喜欢四步描述的清晰，方程的优雅简洁，还是我们将要编写的代码的实用性，这都是个人口味的问题，但了解描述算法的所有可能方式是很有帮助的。
- en: 'You can understand why the Babylonian algorithm works if you consider these
    two simple cases:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑这两个简单的情况，你就能理解为什么巴比伦算法有效：
- en: '![c05eq025](Images/c05eq025.png) So ![c05eq026](Images/c05eq026.png) so ![c05eq028](Images/c05eq028.png).'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![c05eq025](Images/c05eq025.png) 所以 ![c05eq026](Images/c05eq026.png)，所以 ![c05eq028](Images/c05eq028.png)。'
- en: But notice that ![c05eq029](Images/c05eq029.png). So *z*² > *x*. **This means
    that** ![c05eq030](Images/c05eq030.png).
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但请注意 ![c05eq029](Images/c05eq029.png)。所以 *z*² > *x*。**这意味着** ![c05eq030](Images/c05eq030.png)。
- en: '*![c05eq031](Images/c05eq031.png) So ![c05eq032](Images/c05eq032.png), so ![c05eq033](Images/c05eq033.png).'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*![c05eq031](Images/c05eq031.png) 所以 ![c05eq032](Images/c05eq032.png)，所以 ![c05eq033](Images/c05eq033.png)。'
- en: But notice that ![c05eq034](Images/c05eq034.png). So *z*² < *x*. **This means
    that** ![c05eq035](Images/c05eq035.png).*
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但请注意 ![c05eq034](Images/c05eq034.png)。所以 *z*² < *x*。**这意味着** ![c05eq035](Images/c05eq035.png)。*
- en: '*We can write these cases more succintly by removing some text:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们可以通过去掉一些文本来简洁地表示这些情况：'
- en: '![c05eq036](Images/c05eq036.png)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![c05eq036](Images/c05eq036.png)'
- en: '![c05eq037](Images/c05eq037.png)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![c05eq037](Images/c05eq037.png)'
- en: If *y* is an underestimate for the correct value of ![c05eqsqrtx](Images/c05eqsqrtx.png),
    then *z* is an overestimate. If *y* is an overestimate for the correct value of
    ![c05eqsqrtx](Images/c05eqsqrtx.png), then *z* is an underestimate. Step 3 of
    the Babylonian algorithm asks us to average an overestimate and an underestimate
    of the truth. The average of the underestimate and the overestimate will be higher
    than the underestimate and lower than the overestimate, so it will be closer to
    the truth than whichever of *y* or *z* was a worse guess. Eventually, after many
    rounds of gradual improvement of our guesses, we arrive at the true value of ![c05eqsqrtx](Images/c05eqsqrtx.png).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *y* 是正确值的低估值 ![c05eqsqrtx](Images/c05eqsqrtx.png)，那么 *z* 就是高估值。如果 *y* 是正确值的高估值
    ![c05eqsqrtx](Images/c05eqsqrtx.png)，那么 *z* 就是低估值。巴比伦算法的步骤 3 要求我们计算一个高估值和一个低估值的平均值。低估值和高估值的平均值会比低估值高、比高估值低，因此它会比
    *y* 或 *z* 中任何一个较差的猜测更接近真实值。最终，在多轮逐步改进我们的猜测后，我们会得到 *![c05eqsqrtx](Images/c05eqsqrtx.png)*
    的真实值。
- en: Square Roots in Python
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python中的平方根
- en: The Babylonian algorithm is not hard to implement in Python. We can define a
    function that takes `x`, `y`, and an `error_tolerance` variable as its arguments.
    We create a `while` loop that runs repeatedly until our error is sufficiently
    small. At each iteration of the `while` loop, we calculate `z`, we update the
    value of `y` to be the average of `y` and `z` (just like steps 2 and 3 in the
    algorithm describe), and we update our error, which is *y*² – *x*. [Listing 5-7](#listing5-7)
    shows this function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 巴比伦算法在 Python 中并不难实现。我们可以定义一个函数，将`x`、`y`和一个`error_tolerance`变量作为参数。我们创建一个`while`循环，反复执行，直到我们的误差足够小。在每次`while`循环的迭代中，我们计算`z`，将`y`的值更新为`y`和`z`的平均值（就像算法中步骤2和步骤3描述的那样），并更新我们的误差，误差为*y*²
    – *x*。[列表 5-7](#listing5-7)展示了这个函数。
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[Listing 5-7:](#listinganchor5-7) A function to calculate square roots using
    the Babylonian algorithm'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-7：](#listinganchor5-7) 使用巴比伦算法计算平方根的函数'
- en: You may notice that the Babylonian algorithm shares some traits with gradient
    ascent and the outfielder algorithm. All consist of taking small, iterative steps
    until getting close enough to a final goal. This is a common structure for algorithms.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，巴比伦算法与梯度上升法和外场算法有一些相似之处。它们都由小而迭代的步骤组成，直到接近最终目标。这是算法的一种常见结构。
- en: 'We can check our square root function as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式检查我们的平方根函数：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can see that the number 2.23606797749979 is printed in the console. You
    can check whether this is the same number we get from the `math.sqrt()` method
    that’s standard in Python:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到数字2.23606797749979被打印在控制台中。你可以检查这是否与我们从Python标准的`math.sqrt()`方法中得到的相同数字：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We get exactly the same output: 2.23606797749979\. We’ve successfully written
    our own function that calculates square roots. If you’re ever stranded on a desert
    island with no ability to download Python modules like the `math` module, you
    can rest assured that you can write functions like `math.sqrt()` on your own,
    and you can thank the Babylonians for their help in giving us the algorithm for
    it.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了完全相同的输出：2.23606797749979。我们成功地编写了自己的平方根计算函数。如果你曾被困在荒岛上，无法下载像`math`模块这样的Python模块，你可以放心地知道，你可以自己编写类似`math.sqrt()`的函数，并且你可以感谢巴比伦人，他们为我们提供了这个算法。
- en: Random Number Generators
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机数生成器
- en: 'So far we’ve taken chaos and found order within it. Mathematics is good at
    that, but in this section, we’ll consider a quite opposite goal: finding chaos
    in order. In other words, we’re going to look at how to algorithmically create
    randomness.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已将混乱转化为秩序。数学擅长这一点，但在本节中，我们将考虑一个完全相反的目标：在秩序中寻找混乱。换句话说，我们将研究如何算法地创造随机性。
- en: There’s a constant need for random numbers. Video games depend on randomly selected
    numbers to keep gamers surprised by game characters’ positions and movements.
    Several of the most powerful machine learning methods (including random forests
    and neural networks) rely heavily on random selections to function properly. The
    same goes for powerful statistical methods, like bootstrapping, that use randomness
    to make a static dataset better resemble the chaotic world. Corporations and research
    scientists perform A/B tests that rely on randomly assigning subjects to conditions
    so that the conditions’ effects can be properly compared. The list goes on; there’s
    a huge, constant demand for randomness in most technological fields.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数的需求是常态。视频游戏依赖于随机选择的数字，以保持玩家对游戏角色的位置和移动感到惊讶。许多最强大的机器学习方法（包括随机森林和神经网络）在正常运作时都严重依赖随机选择。同样，强大的统计方法（如自助法）也依赖随机性，使得静态数据集更能像混乱的世界一样。公司和研究人员进行A/B测试，依赖随机分配被试者到不同条件，以便能够正确比较各条件的效果。这个清单还在继续；在大多数技术领域，对于随机性的需求巨大且持续。
- en: The Possibility of Randomness
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机性的可能性
- en: 'The only problem with the huge demand for random numbers is that we’re not
    quite certain that they actually exist. Some people believe that the universe
    is deterministic: that like colliding billiard balls, if something moves, its
    movement was caused by some other completely traceable movement, which was in
    turn caused by some other movement, and so on. If the universe behaved like billiard
    balls on a table, then by knowing the current state of every particle in the universe,
    we would be able to determine the complete past and future of the universe with
    certainty. If so, then any event—winning the lottery, running into a long-lost
    friend on the other side of the world, being hit by a meteor—is not actually random,
    as we might be tempted to think of it, but merely the fully predetermined consequence
    of the way the universe was set up around a dozen billion years ago. This would
    mean that there is no randomness, that we are stuck in a player piano’s melody
    and things appear random only because we don’t know enough about them.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数需求如此庞大的唯一问题是，我们不确定它们是否真正存在。有些人认为宇宙是决定论的：就像碰撞的台球一样，如果某物在运动，那么它的运动是由另一个完全可以追溯的运动引起的，而这个运动又是由另一个运动引起的，依此类推。如果宇宙像台球桌上的台球一样运作，那么通过了解宇宙中每个粒子的当前状态，我们就能确定宇宙的完整过去和未来。如果真是这样，那么任何事件——赢得彩票、在世界另一端偶遇失联多年的朋友、被陨石击中——实际上并非我们通常所认为的随机事件，而仅仅是宇宙在大约一百亿年前设定的完全预定结果。这意味着没有随机性，我们就像在一台玩家钢琴上听旋律，事情之所以看起来随机，只是因为我们对它们了解得不够多。
- en: The mathematical rules of physics as we understand them are consistent with
    a deterministic universe, but they are also consistent with a nondeterministic
    universe in which randomness really does exist and, as some have put it, God “plays
    dice.” They are also consistent with a “many worlds” scenario in which every possible
    version of an event occurs, but in different universes that are inaccessible from
    each other. All these interpretations of the laws of physics are further complicated
    if we try to find a place for free will in the cosmos. The interpretation of mathematical
    physics that we accept depends not on our mathematical understanding but rather
    on our philosophical inclinations—any position is acceptable mathematically.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们理解的物理学数学规则与决定论的宇宙是一致的，但它们也与一个非决定论的宇宙相符，在这个宇宙中确实存在随机性，正如一些人所说，神“掷骰子”。它们也与“多重宇宙”情景一致，在这种情景下，每一个事件的可能版本都会发生，但发生在不同的宇宙中，这些宇宙彼此不可接触。如果我们试图为自由意志在宇宙中找到一个位置，那么这些物理学定律的所有解释都会更加复杂。我们接受的数学物理学解释，并不取决于我们的数学理解，而是取决于我们的哲学倾向——任何立场在数学上都是可以接受的。
- en: 'Whether or not the universe itself contains randomness, your laptop doesn’t—or
    at least it isn’t supposed to. Computers are meant to be our perfectly obedient
    servants and do only what we explicitly command them to do, exactly when and how
    we command them to do it. To ask a computer to run a video game, perform machine
    learning via a random forest, or administer a randomized experiment is to ask
    a supposedly deterministic machine to generate something nondeterministic: a random
    number. This is an impossible request.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 无论宇宙本身是否包含随机性，你的笔记本电脑是没有的——或者至少它不应该有。计算机是我们完美服从的仆人，它们只做我们明确指令的事情，按照我们指令的时间和方式去做。让计算机运行一个视频游戏、通过随机森林执行机器学习，或者进行一个随机化实验，就是让一台本应是决定性的机器生成某些非决定性的东西：一个随机数。这是一个不可能的请求。
- en: 'Since a computer cannot deliver true randomness, we’ve designed algorithms
    that can deliver the next-best thing: *pseudorandomness*. Pseudo­random number
    generation algorithms are important for all the reasons that random numbers are
    important. Since true randomness is impossible on a computer (and may be impossible
    in the universe at large), pseudorandom number generation algorithms must be designed
    with great care so that their outputs resemble true randomness as closely as possible.
    The way we judge whether a pseudorandom number generation algorithm truly resembles
    randomness depends on mathematical definitions and theory that we’ll explore soon.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于计算机无法产生真正的随机性，我们设计了可以提供下一个最佳选择的算法：*伪随机性*。伪随机数生成算法之所以重要，是因为随机数的重要性。由于计算机上无法产生真正的随机性（而且在整个宇宙中也可能无法实现），伪随机数生成算法必须非常小心地设计，以便它们的输出尽可能地接近真正的随机性。我们判断一个伪随机数生成算法是否真正类似于随机性的标准，取决于我们将要探索的数学定义和理论。
- en: Let’s start by looking at a simple pseudorandom number generation algorithm
    and examine how much its outputs appear to resemble randomness.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从查看一个简单的伪随机数生成算法开始，检查它的输出在多大程度上看起来像随机。
- en: Linear Congruential Generators
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线性同余生成器
- en: 'One of the simplest examples of a *pseudorandom number generator**(PRNG)* is
    the *linear congruential generator**(LCG)*. To implement this algorithm, you’ll
    have to choose three numbers, which we’ll call *n*[1], *n*[2], and *n*[3]. The
    LCG starts with some natural number (like 1) and then simply applies the following
    equation to get the next number:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的*伪随机数生成器**(PRNG)*示例之一是*线性同余生成器**(LCG)*。要实现这个算法，你需要选择三个数字，我们将其称为*n*[1]、*n*[2]和*n*[3]。LCG从某个自然数（比如1）开始，然后简单地应用以下公式来得到下一个数字：
- en: '![c05eq038](Images/c05eq038.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![c05eq038](Images/c05eq038.png)'
- en: This is the whole algorithm, which you could say takes only one step. In Python,
    we’ll write `%` instead of *mod*, and we can write a full LCG function as in [Listing
    5-8](#listing5-8).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是整个算法，可以说只需要一步。在Python中，我们会使用`%`代替*模*，并且我们可以像[清单5-8](#listing5-8)中那样写出完整的LCG函数。
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Listing 5-8:](#listinganchor5-8) A linear congruential generator'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单5-8:](#listinganchor5-8) 一个线性同余生成器'
- en: Note that the `next_random()` function is deterministic, meaning that if we
    put the same input in, we’ll always get the same output. Once again, our PRNG
    has to be this way because computers are always deterministic. LCGs do not generate
    truly random numbers, but rather numbers that look random, or are *pseudorandom*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`next_random()`函数是确定性的，这意味着如果我们输入相同的内容，我们总是会得到相同的输出。再一次，我们的PRNG必须是这样，因为计算机总是确定性的。LCG并不会生成真正的随机数，而是生成看起来像随机数的数字，或者说是*伪随机数*。
- en: 'In order to judge this algorithm for its ability to generate pseudorandom numbers,
    it might help to look at many of its outputs together. Instead of getting one
    random number at a time, we could compile an entire list with a function that
    repeatedly calls the `next_random()` function we just created, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估这个算法生成伪随机数的能力，查看它的许多输出一起可能会有所帮助。我们可以通过编写一个函数，重复调用我们刚才创建的`next_random()`函数，来编译一个完整的列表，而不是一次得到一个随机数，代码如下：
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Consider the list we get by running `list_random(29,23,32)`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们通过运行`list_random(29,23,32)`得到的列表：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It’s not easy to detect a simple pattern in this list, which is exactly what
    we wanted. One thing we can notice is that it contains only numbers between 0
    and 32\. We may also notice that this list’s last element is 1, the same as its
    first element. If we wanted more random numbers, we could extend this list by
    calling the `next_random()` function on its last element, 1\. However, remember
    that the `next_random()` function is deterministic. If we extend our list, all
    we would get is repetition of the beginning of the list, since the next “random”
    number after 1 will always be 20, the next random number after 20 will always
    be 27, and so on. If we continued, we would eventually get to the number 1 again
    and repeat the whole list forever. The number of unique values that we obtain
    before they repeat is called the *period* of our PRNG. In this case, the period
    of our LCG is 32.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，很难检测到简单的模式，这正是我们想要的。我们能注意到的一件事是，它只包含介于0和32之间的数字。我们还可能注意到，这个列表的最后一个元素是1，与第一个元素相同。如果我们想要更多的随机数，可以通过在最后一个元素1上调用`next_random()`函数来扩展这个列表。然而，请记住，`next_random()`函数是确定性的。如果我们扩展列表，我们得到的只是列表开头的重复，因为1之后的下一个“随机”数总是20，20之后的下一个随机数总是27，依此类推。如果我们继续下去，最终会再次得到数字1，整个列表会永远重复。我们在它们重复之前得到的独特值的数量称为我们PRNG的*周期*。在这种情况下，我们LCG的周期是32。
- en: Judging a PRNG
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评估PRNG
- en: The fact that this random number generation method will eventually start to
    repeat is a potential weakness because it allows people to predict what’s coming
    next, which is exactly what we don’t want to happen in situations where we’re
    seeking randomness. Suppose that we used our LCG to govern an online roulette
    application for a roulette wheel with 32 slots. A savvy gambler who observed the
    roulette wheel long enough might notice that the winning numbers were following
    a regular pattern that repeated every 32 spins, and they may win all our money
    by placing bets on the number they now know with certainty will win in each round.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The idea of a savvy gambler trying to win at roulette is useful for evaluating
    any PRNG. If we are governing a roulette wheel with true randomness, no gambler
    will ever be able to win reliably. But any slight weakness, or deviation from
    true randomness, in the PRNG governing our roulette wheel could be exploited by
    a sufficiently savvy gambler. Even if we are creating a PRNG for a purpose that
    has nothing to do with roulette, we can ask ourselves, “If I use this PRNG to
    govern a roulette application, would I lose all my money?” This intuitive “roulette
    test” is a reasonable criterion for judging how good any PRNG is. Our LCG might
    pass the roulette test if we never do more than 32 spins, but after that, a gambler
    could notice the repeating pattern of outputs and start to place bets with perfect
    accuracy. The short period of our LCG has caused it to fail the roulette test.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this, it helps to ensure that a PRNG has a long period. But in a
    case like a roulette wheel with only 32 slots, no deterministic algorithm can
    have a period longer than 32\. That’s why we often judge a PRNG by whether it
    has a *full period* rather than a long period. Consider the PRNG that we get by
    generating `list_random(1,2,24)`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, the period is 12, which may be long enough for very simple purposes,
    but it is not a full period because it does not encompass every possible value
    in its range. Once again, a savvy gambler might notice that even numbers are never
    chosen by the roulette wheel (not to mention the simple pattern the chosen odd
    numbers follow) and thereby increase their winnings at our expense.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Related to the idea of a long, full period is the idea of *uniform distribution*,
    by which we mean that each number within the PRNG’s range has an equal likelihood
    of being output. If we run `list_random(1,18,36)`, we get:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, 1 and 19 each have a 50 percent likelihood of being output by the PRNG,
    while each other number has a likelihood of 0 percent. A roulette player would
    have a very easy time with this non-uniform PRNG. By contrast, in the case of
    `list_random(29,23,32)`, we find that every number has about a 3.1 percent likelihood
    of being output.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that these mathematical criteria for judging PRNGs have some relation
    to each other: the lack of a long or full period can be the cause of a lack of
    uniform distribution. From a more practical perspective, these mathematical properties
    are important only because they cause our roulette app to lose money. To state
    it more generally, the only important test of a PRNG is whether a pattern can
    be detected in it.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the ability to detect a pattern is hard to pin down concisely
    in mathematical or scientific language. So we look for long, full period and uniform
    distribution as markers that give us a hint about pattern detection. But of course,
    they’re not the only clues that enable us to detect a pattern. Consider the LCG
    denoted by `list_random(1,1,37)`. This outputs the following list:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This has a long period (37), a full period (37), and a uniform distribution
    (each number has likelihood 1/37 of being output). However, we can still detect
    a pattern in it (the number goes up by 1 every round until it gets to 36, and
    then it repeats from 0). It passes the mathematical tests we devised, but it definitely
    fails the roulette test.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The Diehard Tests for Randomness
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is no single silver-bullet test that indicates whether there’s an exploitable
    pattern in a PRNG. Researchers have devised many creative tests to evaluate the
    extent to which a collection of random numbers is resistant to pattern detection
    (or in other words can pass the roulette test). One collection of such tests is
    called the *Diehard* tests. There are 12 Diehard tests, each of which evaluates
    a collection of random numbers in a different way. Collections of numbers that
    pass every Diehard test are deemed to have a very strong resemblance to true randomness.
    One of the Diehard tests, called the *overlapping sums test,* takes the entire
    list of random numbers and finds sums of sections of consecutive numbers from
    the list. The collection of all these sums should follow the mathematical pattern
    colloquially called a *bell curve*. We can implement a function that generates
    a list of overlapping sums in Python as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can run this test on a new random list like so:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We created a new random list by running `list_random(211111,111112,300007)`.
    This new random list is long enough to make the overlapping sums test perform
    well. The output of this code is a histogram that records the frequency of the
    observed sums. If the list resembles a truly random collection, we expect some
    of the sums to be high and some to be low, but we expect most of them to be near
    the middle of the possible range of values. This is exactly what we see in the
    plot output ([Figure 5-2](#figure5-2)).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure_5-2](Images/figure_5-2.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: '[Figure 5-2:](#figureanchor5-2) The result of the overlapping sums test for
    an LCG'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: If you squint, you can see that this plot resembles a bell. Remember that the
    Diehard overlapping sums test says that our list passes if it closely resembles
    a bell curve, which is a specific mathematically important curve ([Figure 5-3](#figure5-3)).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure_5-3](Images/figure_5-3.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: '[Figure 5-3:](#figureanchor5-3) A bell curve, or Gaussian normal curve (source:
    Wikimedia Commons)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: The bell curve, like the golden ratio, appears in many sometimes surprising
    places in math and the universe. In this case, we interpret the close resemblance
    between our overlapping sums test results and the bell curve as evidence that
    our PRNG resembles true randomness.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge of the deep mathematics of randomness can help you as you design random
    number generators. However, you can do almost as well just by sticking with a
    commonsense idea of how to win at roulette.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Linear Feedback Shift Registers
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: LCGs are easy to implement but are not sophisticated enough for many applications
    of PRNGs; a savvy roulette player could crack an LCG in no time at all. Let’s
    look at a more advanced and reliable type of algorithm called *linear feedback
    shift registers**(LFSRs)*, which can serve as a jumping-off point for the advanced
    study of PRNG algorithms.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: LFSRs were designed with computer architecture in mind. At the lowest level,
    data in computers is stored as a series of 0s and 1s called *bits*. We can illustrate
    a potential string of 10 bits as shown in [Figure 5-4](#figure5-4).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure_5-4](Images/figure_5-4.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: '[Figure 5-4:](#figureanchor5-4) A string of 10 bits'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: After starting with these bits, we can proceed through a simple LFSR algorithm.
    We start by calculating a simple sum of a subset of the bits—for example, the
    sum of the 4th bit, 6th bit, 8th bit, and 10th bit (we could also choose other
    subsets). In this case, that sum is 3\. Our computer architecture can only store
    0s and 1s, so we take our sum mod 2, and end up with 1 as our final sum. Then
    we remove our rightmost bit and shift every remaining bit one position to the
    right ([Figure 5-5](#figure5-5)).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure_5-5](Images/figure_5-5.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: '[Figure 5-5:](#figureanchor5-5) Bits after removal and shifting'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Since we removed a bit and shifted everything, we have an empty space where
    we should insert a new bit. The bit we insert here is the sum we calculated before.
    After that insertion, we have the new state of our bits ([Figure 5-6](#figure5-6)).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure_5-6](Images/figure_5-6.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: '[Figure 5-6:](#figureanchor5-6) Bits after replacement with a sum of selected
    bits'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: We take the bit we removed from the right side as the output of the algorithm,
    the pseudorandom number that this algorithm is supposed to generate. And now that
    we have a new set of 10 ordered bits, we can run a new round of the algorithm
    and get a new pseudorandom bit just as before. We can repeat this process as long
    as we’d like.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, we can implement a feedback shift register relatively simply. Instead
    of directly overwriting individual bits on the hard drive, we will just create
    a list of bits like the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can define the sum of the bits in the specified locations with one line.
    We store it in a variable called `xor_result`, because taking a sum mod 2 is also
    called the *exclusive OR* or *XOR operation*. If you have studied formal logic,
    you may have encountered XOR before—it has a logical definition and an equivalent
    mathematical definition; here we will use the mathematical definition. Since we
    are working with a short bit-string, we don’t sum the 4th, 6th, 8th, and 10th
    bits (since those don’t exist), but instead sum the 2nd and 3rd bits:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we can take out the rightmost element of the bits easily with Python’s
    handy `pop()` function, storing the result in a variable called `output`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can then insert our sum with the `insert()` function, specifying position
    0 since we want it to be on the left side of our list:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now let’s put it all together into one function that will return two outputs:
    a pseudorandom bit and a new state for the `bits` series ([Listing 5-9](#listing5-9)).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[Listing 5-9:](#listinganchor5-9) A function that implements an LFSR, completing
    our goal for this section'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as we did with the LCG, we can create a function that will generate an
    entire list of our output bits:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this case, we run the `while` loop until we expect the series to repeat.
    Since there are 2³ = 8 possible states for our bits list, we can expect a period
    of at most 8\. Actually, LFSRs typically cannot output a full set of zeros, so
    in practice we expect a period of at most 2³ – 1 = 7\. We can run the following
    code to find all possible outputs and check the period:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Sure enough, the output that we stored in `bitslist` is
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can see that our LFSR outputs all seven possible bit-strings that are not
    all 0s. We have a full-period LFSR, and also one that shows a uniform distribution
    of outputs. If we use more input bits, the maximum possible period grows exponentially:
    with 10 bits, the maximum possible period is 2^(10)– 1 = 1023, and with only 20
    bits, it is 2^(20) – 1=1,048,575.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check the list of pseudorandom bits that our simple LFSR generates with
    the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output that we stored in `pseudorandom_bits` looks reasonably random given
    how simple our LFSR and its input are:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'LFSRs are used to generate pseudorandom numbers in a variety of applications,
    including white noise. We present them here to give you a taste of advanced PRNGs.
    The most widely used PRNG in practice today is the *Mersenne Twister*, which is
    a modified, generalized feedback shift register—essentially a much more convoluted
    version of the LFSR presented here. If you continue to progress in your study
    of PRNGs, you will find a great deal of convolution and advanced mathematics,
    but all of it will build on the ideas presented here: deterministic, mathematical
    formulas that can resemble randomness as evaluated by stringent mathematical tests.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mathematics and algorithms will always have a close relationship. The more
    deeply you dive into one field, the more ready you will be to take on advanced
    ideas in the other. Math may seem arcane and impractical, but it is a long game:
    theoretical advances in math sometimes lead to practical technologies only many
    centuries later. In this chapter we discussed continued fractions and an algorithm
    for generating continued fraction representations of any number. We also discussed
    square roots, and examined an algorithm that handheld calculators use to calculate
    them. Finally, we discussed randomness, including two algorithms for generating
    pseudorandom numbers, and mathematical principles that we can use to evaluate
    lists that claim to be random.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss optimization, including a powerful method
    you can use to travel the world or forge a sword.*
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
