<html><head></head><body>
<h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_127"/><span class="big">7</span><br/>COMPLEX NUMBERS</h2>&#13;
<p class="epigraph"><em>Imaginary numbers are a fine and wonderful refuge of the divine spirit, almost an amphibian between being and non-being. —Gottfried Leibniz</em></p>&#13;
<div class="image"><img alt="image" src="../images/fintro-01.jpg"/></div>&#13;
<p class="intro">Numbers containing the square root of –1 have been given a bad name in math classes. We call the square root of –1 an <em>imaginary number</em>, or <em>i</em>. Calling something “imaginary” makes it seem like it doesn’t exist or like there’s no real purpose for it. But imaginary numbers <em>do</em> exist, and they have a lot of real-world applications in fields such as electromagnetism, for instance.</p>&#13;
<p class="indent">In this chapter, you get a taste of the kinds of beautiful art you can create using <em>complex numbers</em>, which are numbers that have both a real and imaginary part written in the form of <em>a</em> + <em>bi</em>, where <em>a</em> and <em>b</em> are real numbers and <em>i</em> is the imaginary number. Because a complex number holds two different bits of information, real and imaginary, you can use it to turn one-dimensional objects into two-dimensional ones. Using Python, manipulating these numbers becomes easier, and we can use them for some very <span epub:type="pagebreak" id="page_128"/>magical purposes. In fact, we use complex numbers to explain behaviors of electrons and photons, and what we think of as natural, “normal” numbers are actually complex numbers whose imaginary parts equal zero!</p>&#13;
<p class="indent">We begin this chapter by reviewing how to plot complex numbers in the complex coordinate plane. You also learn how to express complex numbers as Python lists and then write functions to add and multiply them. Finally, you learn how to find the magnitude, or absolute value, of a complex number. Knowing how to manipulate complex numbers will come in handy when we write the programs for creating the Mandelbrot set and the Julia set later in this chapter.</p>&#13;
<h3 class="h3" id="ch07_1">THE COMPLEX COORDINATE SYSTEM</h3>&#13;
<p class="noindent">As Frank Farris summed up in his brilliant and beautifully illustrated book <em>Creating Symmetry</em>, “Complex numbers . . . are simply a way to express the Cartesian ordered pair of real numbers, (<em>x, y</em>), compactly as a single number <em>z</em> = <em>x</em> + <em>iy</em>.” We all know the Cartesian coordinate system uses <em>x</em> to represent the horizontal axis and <em>y</em> to represent the vertical axis, but we never add or multiply those numbers; they just represent a location.</p>&#13;
<p class="indent">In contrast, complex numbers not only can represent locations but they can also be operated on like any other numbers. It helps to look at complex numbers geometrically. Let’s change our coordinate system a little so that now the real numbers are on the horizontal axis and the imaginary numbers are on the vertical axis, as in <a href="ch07.xhtml#ch07fig1">Figure 7-1</a>.</p>&#13;
<div class="image"><a id="ch07fig1"/><img alt="image" src="../images/f128-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 7-1: The complex coordinate system</em></p>&#13;
<p class="indent">Here, you can see where <em>a</em> + <em>bi</em> and <em>a</em> – <em>bi</em> would be located on a complex coordinate system.</p>&#13;
<span epub:type="pagebreak" id="page_129"/>&#13;
<h3 class="h3" id="ch07_2">ADDING COMPLEX NUMBERS</h3>&#13;
<p class="noindent">Adding and subtracting complex numbers are the same as with real numbers: you start at one number and take the number of steps represented by the other number. For example, to add the numbers 2 + 3<em>i</em> and 4 + <em>i</em>, you would simply add the real parts and the imaginary parts of the numbers separately to get 6 + 4<em>i</em>, as shown in <a href="ch07.xhtml#ch07fig2">Figure 7-2</a>.</p>&#13;
<div class="image"><a id="ch07fig2"/><img alt="image" src="../images/f129-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 7-2: Adding two complex numbers</em></p>&#13;
<p class="indent">As you can see, we start at 4 + <em>i</em>. To add 2 + 3<em>i</em>, we move two units in the positive real direction and three units in the positive imaginary direction, and end up at 6 + 4<em>i</em>.</p>&#13;
<p class="indent">Let’s write the function for adding two complex numbers using the code in <a href="ch07.xhtml#ch07list1">Listing 7-1</a>. Open a new file in IDLE and name it <em>complex.py</em>.</p>&#13;
<p class="programs"><span class="pd_orange">def</span> <span class="pd_blue">cAdd</span>(a,b):<br/>    <span class="pd_green">'''adds two complex numbers'''</span><br/>    <span class="pd_orange">return</span> [a[0]+b[0],a[1]+b[1]]</p>&#13;
<p class="listing" id="ch07list1"><em>Listing 7-1: The function for adding two complex numbers</em></p>&#13;
<p class="indent">Here, we define the function called <span class="literal">cAdd()</span>, giving it two complex numbers in list form <span class="literal">[x,y]</span>, which returns another list. The first term of the list, <span class="literal">a[0]+b[0]</span>, is the sum of the first terms of the complex numbers (index 0) we provide. The second term, <span class="literal">a[1]+b[1]</span>, is the sum of the second terms (index 1) of the two complex numbers. Save and run this program.</p>&#13;
<p class="indent">Now let’s test the program using the complex numbers <span class="literal">u = 1 + 2i</span> and <span class="literal">v = 3 + 4i</span>. Plug them into our <span class="literal">cAdd()</span> function in the interactive shell, like this:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">u = [1,2]</span><br/>&gt;&gt;&gt; <span class="codestrong1">v = [3,4]</span><br/>&gt;&gt;&gt; <span class="codestrong1">cAdd(u,v)</span><br/><span class="pd_blue">[6, 4]</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_130"/>You should get 6 + 4<em>i</em>, which is the sum of the complex numbers 1 + 2<em>i</em> and 3 + 4<em>i</em>. Adding complex numbers is just like taking steps in the x-direction and then in the y-direction, and we’ll see this function again when we want to create beautiful designs like the Mandelbrot set and the Julia set.</p>&#13;
<h3 class="h3" id="ch07_3">MULTIPLYING A COMPLEX NUMBER BY I</h3>&#13;
<p class="noindent">But adding complex numbers isn’t the most useful thing. Multiplying them is. For example, multiplying a complex number by <em>i</em> rotates the complex number around the origin by 90 degrees. In the complex coordinate system, multiplying a real number by –1 would rotate it 180 degrees around the origin, as shown in <a href="ch07.xhtml#ch07fig3">Figure 7-3</a>.</p>&#13;
<div class="image"><a id="ch07fig3"/><img alt="image" src="../images/f130-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 7-3: Multiplying a number by –1 as a 180-degree rotation</em></p>&#13;
<p class="indent">As you can see, 1 times –1 equals –1, which rotates 1 over to the other side of zero.</p>&#13;
<p class="indent">Because multiplying a complex number by –1 is the same as a 180 degree rotation, the square root of –1 would represent a 90 degree rotation, as shown in <a href="ch07.xhtml#ch07fig4">Figure 7-4</a>.</p>&#13;
<div class="image"><a id="ch07fig4"/><img alt="image" src="../images/f130-02.jpg"/></div>&#13;
<p class="caption"><em>Figure 7-4: Multiplying a number by</em> i <em>as a 90-degree rotation</em></p>&#13;
<span epub:type="pagebreak" id="page_131"/>&#13;
<p class="indent">This means that <em>i</em> represents the square root of –1, the number that rotates us halfway to –1 when we multiply it by 1. Multiplying the result (<em>i</em>) by <em>i</em> again causes us to rotate 90 degrees more, and we end up with –1. This confirms the definition of the square root because we are able to get to the negative value of a number by multiplying it by the same number (<em>i</em>) twice.</p>&#13;
<h3 class="h3" id="ch07_4">MULTIPLYING TWO COMPLEX NUMBERS</h3>&#13;
<p class="noindent">Let’s see what happens when we multiply two complex numbers. Just like you would multiply two binomial expressions, you can multiply two complex numbers algebraically using the FOIL method:</p>&#13;
<div class="image1"><img alt="image" src="../images/e131-01.jpg"/></div>&#13;
<p class="indent">To make this easier, let’s translate this process into a <span class="literal">cMult()</span> function, as shown in <a href="ch07.xhtml#ch07list2">Listing 7-2</a>.</p>&#13;
<p class="programs"><span class="pd_orange">def</span> <span class="pd_blue">cMult</span>(u,v):<br/>    <span class="pd_green">'''Returns the product of two complex numbers'''</span><br/>    <span class="pd_orange">return</span> [u[0]*v[0]-u[1]*v[1],u[1]*v[0]+u[0]*v[1]]</p>&#13;
<p class="listing" id="ch07list2"><em>Listing 7-2: Writing the function for multiplying two complex numbers</em></p>&#13;
<p class="indent">To test the <span class="literal">cMult()</span> function, try multiplying u = 1 + 2<em>i</em> by v = 3 + 4<em>i</em>. Enter the following in the interactive shell:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">u = [1,2]</span><br/>&gt;&gt;&gt; <span class="codestrong1">v = [3,4]</span><br/>&gt;&gt;&gt; <span class="codestrong1">cMult(u,v)</span><br/><span class="literal1"><span class="pd_blue">[-5, 10]</span></span></p>&#13;
<p class="indent">As you can see, the product is –5 + 10<em>i</em>.</p>&#13;
<p class="indent">Recall from the previous section that multiplying a complex number by <em>i</em> is the same as performing a 90 degree rotation about the origin of the complex coordinate system. Let’s try it now with v = 3 + 4<em>i</em>:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">cMult([3,4],[0,1])</span><br/><span class="literal1"><span class="pd_blue">[-4, 3]</span></span></p>&#13;
<p class="indent">The result is –4 + 3<em>i</em>. When we graph 3 + 4<em>i</em> and –4 + 3<em>i</em>, you should see something like what’s shown in <a href="ch07.xhtml#ch07fig5">Figure 7-5</a>.</p>&#13;
<span epub:type="pagebreak" id="page_132"/>&#13;
<div class="image"><a id="ch07fig5"/><img alt="image" src="../images/f132-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 7-5: Rotating a complex number 90 degrees by multiplying by</em> i</p>&#13;
<p class="indent">As you can see, –4 + 3<em>i</em> is 90 degrees rotation from 3 + 4<em>i</em>.</p>&#13;
<p class="indent">Now that you know how to add and multiply complex numbers, let’s go over how to find the magnitude of a complex number, which you’ll use to create the Mandelbrot set and Julia set.</p>&#13;
<h3 class="h3" id="ch07_5">WRITING THE MAGNITUDE() FUNCTION</h3>&#13;
<p class="noindent">The <em>magnitude</em>, or <em>absolute value</em>, of a complex number is how far the complex number is away from the origin on the complex coordinate plane. Now let’s create a magnitude function using the Pythagorean theorem. Return to <em>complex.py</em> and make sure to import the square root function from Python’s <span class="literal">math</span> module at the top of the file:</p>&#13;
<p class="programs"><span class="pd_orange">from</span> math <span class="pd_orange">import</span> sqrt</p>&#13;
<p class="indent">The <span class="literal">magnitude()</span> function is just the Pythagorean theorem:</p>&#13;
<p class="programs"><span class="pd_orange">def</span> <span class="pd_blue">magnitude</span>(z):<br/>    <span class="pd_orange">return</span> sqrt(z[0]**2 + z[1]**2)</p>&#13;
<p class="indent">Let’s find the magnitude of the complex number 2 + i:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">magnitude([2,1])</span><br/><span class="literal1"><span class="pd_blue">2.23606797749979</span></span></p>&#13;
<p class="indent">Now you’re ready to write a Python program that colors the pixels on the display window according to how large the complex numbers get. The unexpected behavior of complex numbers will result in an infinitely complicated design that’s impossible to replicate without a computer!</p>&#13;
<h3 class="h3" id="ch07_6">CREATING THE MANDELBROT SET</h3>&#13;
<p class="noindent">To create the Mandelbrot set, we’re going to represent each pixel on our display window as a complex number, <em>z</em>, then repeatedly square the value, and add the original number <em>z</em>.</p>&#13;
<div class="image"><img alt="image" src="../images/e132-01.jpg"/></div>&#13;
<span epub:type="pagebreak" id="page_133"/>&#13;
<p class="indent">Then, we’re going to do the same to the output, again and again. If the number keeps getting larger, we’ll color the pixel corresponding to the original complex number according to how many iterations it takes for its magnitude to get bigger than a certain number, like 2. If the number keeps getting smaller, we’ll give it a different color.</p>&#13;
<p class="indent">You already know that multiplying a number by a number larger than 1 makes the original number larger. A number multiplied by 1 stays the same, and multiplying by a number smaller than 1 makes the original number smaller. Complex numbers follow a similar pattern, which you can represent on the complex plane as shown in <a href="ch07.xhtml#ch07fig6">Figure 7-6</a>.</p>&#13;
<div class="image"><a id="ch07fig6"/><img alt="image" src="../images/f133-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 7-6: Visualizing what happens when you multiply complex numbers</em></p>&#13;
<p class="indent">If we were only multiplying complex numbers, the Mandelbrot set would look like <a href="ch07.xhtml#ch07fig6">Figure 7-6</a>, a circle. But not only is the complex number squared, a number is added afterward. This will change the circle into an infinitely complicated and surprisingly beautiful figure. But before we can do that, we need to operate on every point on the grid!</p>&#13;
<p class="indent">Depending on the result of the operation, some will get smaller and <em>converge</em> to zero. Others will get bigger and <em>diverge</em>. Getting close to a number in math terms is called <em>converging</em>. Getting too big in math terms is called <em>diverging</em>. For our purposes, we’ll color every pixel on the grid according to how many iterations it takes it to get too big and fly off the grid. The formula we plug the number into is similar to our <span class="literal">cMult()</span> function from <a href="ch07.xhtml#ch07list2">Listing 7-2</a>, with an extra step. We square the number, add the original complex number to the square, and then repeat that process until it diverges. If the magnitude of the squared complex number gets larger than 2, it means it has diverged (we can pick any number we want to be the maximum). If it never gets bigger than 2, we’ll leave it black.</p>&#13;
<p class="indent">For example, let’s try the Mandelbrot set operation manually using the complex number <em>z</em> = 0.25 + 1.5<em>i</em>:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">z = [0.25,1.5]</span></p>&#13;
<span epub:type="pagebreak" id="page_134"/>&#13;
<p class="indent">We square <span class="literal">z</span> by multiplying it by itself and saving the result to the variable <span class="literal">z2</span>:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">z2 = cMult(z,z)</span><br/>&gt;&gt;&gt; <span class="codestrong1">z2</span><br/><span class="literal1"><span class="pd_blue">[-2.1875, 0.75]</span></span></p>&#13;
<p class="indent">Then we add <span class="literal">z2</span> and <span class="literal">z</span> using the <span class="literal">cAdd()</span> function:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">cAdd(z2,z)</span><br/><span class="literal1"><span class="pd_blue">[-1.9375, 2.25]</span></span></p>&#13;
<p class="indent">We have a function we can use to test if this complex number is more than two units away from the origin using the Pythagorean theorem. Let’s use our <span class="literal">magnitude()</span> function from earlier to check if the magnitude of the complex number we got is greater than 2:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">magnitude([-1.9375,2.25])</span><br/><span class="literal1"><span class="pd_blue">2.969243380054926</span></span></p>&#13;
<p class="indent">We set the rule as follows: “If a number gets more than two units away from the origin, it diverges.” Therefore, the complex number <em>z</em> = 0.25 + 1.5<em>i</em> diverges after only 1 iteration!</p>&#13;
<p class="indent">This time, let’s try with <em>z</em> = 0.25 + 0.75<em>i</em>, as shown next:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">z = [0.25,0.75]</span><br/>&gt;&gt;&gt; <span class="codestrong1">z2 = cMult(z,z)</span><br/>&gt;&gt;&gt; <span class="codestrong1">z3 = cAdd(z2,z)</span><br/>&gt;&gt;&gt; <span class="codestrong1">magnitude(z3)</span><br/><span class="literal1"><span class="pd_blue">1.1524430571616109</span></span></p>&#13;
<p class="indent">Here, we repeated the same process as before, except this time we need to add <span class="literal">z2</span> and <span class="literal">z</span> again, saving it as <span class="literal">z3</span>. It’s still within two units of the origin, so let’s replace <span class="literal">z</span> with this new value and put it back through the process again. First, we create a new variable, <span class="literal">z1</span>, that we can use to square the original <span class="literal">z</span>:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">z1 = z</span></p>&#13;
<p class="indent">Let’s repeat the process using the newest value of our complex number, <span class="literal">z3</span>. We’ll square it, add <span class="literal">z1</span>, and find the magnitude:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">z2 = cMult(z3,z3)</span><br/>&gt;&gt;&gt; <span class="codestrong1">z3 = cAdd(z2,z1)</span><br/>&gt;&gt;&gt; <span class="codestrong1">magnitude(z3)</span><br/><span class="literal1"><span class="pd_blue">0.971392565148097</span></span></p>&#13;
<p class="indent">Because 0.97 is smaller than 1.152, we might guess that the result is getting smaller and therefore doesn’t look like it’s going to diverge, but we’ve only repeated the process twice. Doing this by hand is laborious! Let’s automate the steps so that we can repeat the process quickly and easily. We’ll <span epub:type="pagebreak" id="page_135"/>use the squaring, adding, and finding the magnitude functions to write a function called <span class="literal">mandelbrot()</span> that automates the checking process so that we can visually separate the diverging numbers from the converging ones. What design do you think it’ll make? A circle? An ellipse? Let’s find out!</p>&#13;
<h4 class="h4" id="ch07_1_1">WRITING THE MANDELBROT() FUNCTION</h4>&#13;
<p class="noindent">Let’s open a Processing sketch and call it <em>mandelbrot.pyde</em>. The Mandelbrot set we’re trying to re-create here is named after the mathematician Benoit Mandelbrot, who first explored this process using computers in the 1970s. We’ll repeat the squaring and adding process a maximum number of times, or until the number diverges, as shown in <a href="ch07.xhtml#ch07list3">Listing 7-3</a>.</p>&#13;
<p class="programs"><span class="pd_green1">def</span> mandelbrot(z,num):<br/><span class="pd_purple">    '''runs the process num times</span><br/><span class="pd_purple">    and returns the diverge count '''</span><br/>  <span class="ent">➊</span> count=0<br/><span class="pd_gray">    #define z1 as z</span><br/>    z1=z<br/><span class="pd_gray">    #iterate num times</span><br/>  <span class="ent">➋</span> <span class="pd_lime">while</span> count &lt;= num:<br/><span class="pd_gray">        #check for divergence</span><br/>        <span class="pd_lime">if</span> magnitude(z1) &gt; 2.0:<br/><span class="pd_gray">        #return the step it diverged on</span><br/>            <span class="pd_lime">return</span> count<br/><span class="pd_gray">        #iterate z</span><br/>      <span class="ent">➌</span> z1=cAdd(cMult(z1,z1),z)<br/>        count+=1<br/><span class="pd_gray">    #if z hasn't diverged by the end</span><br/>    <span class="pd_lime">return</span> num</p>&#13;
<p class="listing" id="ch07list3"><em>Listing 7-3: Writing the <span class="literal">mandelbrot()</span> function to check how many steps a complex number takes to diverge</em></p>&#13;
<p class="indent">The <span class="literal">mandelbrot()</span> function takes a complex number, <span class="literal">z</span>, and a number of iterations as parameters. It returns the number of times it took for <span class="literal">z</span> to diverge, and if it never diverges, it returns <span class="literal">num</span> (at the end of the function). We create a <span class="literal">count</span> variable <span class="ent">➊</span> to keep track of the iterations, and we create a new complex number, <span class="literal">z1</span>, that gets squared and so on without changing <span class="literal">z</span>.</p>&#13;
<p class="indent">We start a loop to repeat the process while the <span class="literal">count</span> variable is less than <span class="literal">num</span> <span class="ent">➋</span>. Inside the loop we check the magnitude of <span class="literal">z1</span> to see whether <span class="literal">z1</span> has diverged, and if it has, we return <span class="literal">count</span> and stop the code. Otherwise, we square <span class="literal">z1</span> and add <span class="literal">z</span> to it <span class="ent">➌</span>, which is the definition of our operation on complex numbers. Finally, we increment the <span class="literal">count</span> variable by 1 and loop through the process again.</p>&#13;
<p class="indent">Using the <em>mandelbrot.pyde</em> program, we can plug in our complex number <em>z</em> = 0.25 + 0.75<em>i</em> and check the magnitude after every iteration. Here are the magnitudes after each loop:</p>&#13;
<p class="programs">0.7905694150420949<br/>1.1524430571616109<br/><span epub:type="pagebreak" id="page_136"/>&#13;
0.971392565148097<br/>1.1899160852817983<br/>2.122862368187107</p>&#13;
<p class="indent">The first number is the magnitude of z = 0.25 + 0.75<em>i</em> before any iterations:</p>&#13;
<div class="image1"><img alt="image" src="../images/e136-01.jpg"/></div>&#13;
<p class="indent">You can see that it diverges after four iterations because it gets bigger than two units away from the origin. <a href="ch07.xhtml#ch07fig7">Figure 7-7</a> graphs each step so you can visualize them.</p>&#13;
<div class="image"><a id="ch07fig7"/><img alt="image" src="../images/f136-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 7-7: Running the complex number 0.25 + 0.75</em> i <em>through the</em> mandelbrot() <em>function until it diverges</em></p>&#13;
<p class="indent">The red circle has a radius of two units and represents the limit we put on the complex number diverging. When squaring and adding in the original value of <span class="literal">z</span>, we cause the locations of the numbers to rotate and translate and eventually to get further away from the origin than our rule allows.</p>&#13;
<p class="indent">Let’s use some of the graphing tricks we learned in <a href="ch04.xhtml#ch04">Chapter 4</a> to graph points and functions in the Processing display. Copy and paste all the complex number functions from <em>complex.py</em> (<span class="literal">cAdd</span>, <span class="literal">cMult</span>, and <span class="literal">magnitude</span>) to the bottom of <em>mandelbrot.pyde</em>. We’ll use Processing’s <span class="literal">println()</span> function to print to the console the number of steps it takes a point to diverge. Add the code in <a href="ch07.xhtml#ch07list4">Listing 7-4</a> before the <span class="literal">mandelbrot()</span> code you wrote in <a href="ch07.xhtml#ch07list3">Listing 7-3</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>mandelbrot.pyde</em></span><br/><span class="pd_gray">#range of x-values</span><br/>xmin = -2<br/>xmax = 2<br/><br/><span class="pd_gray">#range of y-values</span><br/>ymin = -2<br/>ymax = 2<br/><span epub:type="pagebreak" id="page_137"/>&#13;
<br/><span class="pd_gray">#calculate the range</span><br/>rangex = xmax - xmin<br/>rangey = ymax - ymin<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_green1">global</span> xscl, yscl<br/>    <span class="pd_blue1">size</span>(600,600)<br/>    <span class="pd_blue1">noStroke</span>()<br/>    xscl = <span class="pd_blue1">float</span>(rangex)/<span class="pd_raspberry">width</span><br/>    yscl = <span class="pd_blue1">float</span>(rangey)/<span class="pd_raspberry">height</span><br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    z = [0.25,0.75]<br/>    <span class="pd_blue1">println</span>(mandelbrot(z,10))</p>&#13;
<p class="listing" id="ch07list4"><em>Listing 7-4: The beginning of the Mandelbrot code</em></p>&#13;
<p class="indent">We calculate the range of real values (<span class="literal">x</span>) and imaginary values (<span class="literal">y</span>) at the top of the program. Inside <span class="literal">setup()</span>, we calculate the scale factors (<span class="literal">xscl</span> and <span class="literal">yscl</span>) we need to multiply the pixels by (in this case, 0 to 600) in order to get the complex numbers (in this case, between –2 and 2). In the <span class="literal">draw()</span> function we define our complex number <span class="literal">z</span>, and then we feed it into the <span class="literal">mandelbrot()</span> function and print out what we get. Nothing will appear on the screen yet, but in the console, you’ll see the number 4 printed out. Now we’ll go through every pixel on the screen and put their location into the <span class="literal">mandelbrot()</span> function and display the results.</p>&#13;
<p class="indent">Let’s return to our <span class="literal">mandelbrot()</span> function in the <em>mandelbrot.pyde</em> program. Repeating the multiplication and addition operations on a pixel’s location returns a number, and if the number never diverges, we color the pixel black. The entire <span class="literal">draw()</span> function is shown in <a href="ch07.xhtml#ch07list5">Listing 7-5</a>.</p>&#13;
<br/><p class="programs"><span class="pd_g1"><em>mandelbrot.pyde</em></span><br/><span class="pd_green1">def</span><span class="pd_gray"/> <span class="pd_bluebold">draw</span>():<br/><span class="pd_gray">    #origin in center:</span><br/>    <span class="pd_blue1">translate</span>(<span class="pd_raspberry">width</span>/2,<span class="pd_raspberry">height</span>/2)<br/><span class="pd_gray">    #go over all x's and y's on the grid</span><br/>  <span class="ent">➊</span> <span class="pd_lime">for</span> x <span class="pd_blue1">in</span> <span class="pd_lime">range</span>(<span class="pd_raspberry">width</span>):<br/>        <span class="pd_lime">for</span> y <span class="pd_blue1">in</span> <span class="pd_lime">range</span>(<span class="pd_raspberry">height</span>):<br/>         <span class="ent">➋</span> z = [(xmin + x * xscl) ,<br/>                 (ymin + y * yscl) ]<br/>            <span class="pd_gray">#put it into the mandelbrot function</span><br/>         <span class="ent">➌</span> col=mandelbrot(z,100)<br/>            <span class="pd_gray">#if mandelbrot returns 0</span><br/>            <span class="pd_lime">if</span> col == 100:<br/>                <span class="pd_blue1">fill</span>(0) <span class="pd_gray">#make the rectangle black</span><br/>            <span class="pd_lime">else</span>:<br/>                <span class="pd_blue1">fill</span>(255) <span class="pd_gray">#make the rectangle white</span><br/>            <span class="pd_gray">#draw a tiny rectangle</span><br/>            <span class="pd_blue1">rect</span>(x,y,1,1)</p>&#13;
<p class="listing" id="ch07list5"><em>Listing 7-5: Looping over all the pixels in the display window</em></p>&#13;
<span epub:type="pagebreak" id="page_138"/>&#13;
<p class="indent">Going over all the pixels requires a nested loop for <span class="literal">x</span> and <span class="literal">y</span> <span class="ent">➊</span>. We declare complex number <span class="literal">z</span> to be x + <em>i</em>y <span class="ent">➋</span>. Calculating the complex number <span class="literal">z</span> from the window coordinates is a little tricky. We start at the <span class="literal">xmin</span> value, for instance, and add the number of steps we’re taking multiplied by the scale factor. We’re not going between 0 and 600, which is the size of the display window in pixels; we’re just going between –2 and 2. We run that through the <span class="literal">mandelbrot()</span> function <span class="ent">➌</span>.</p>&#13;
<p class="indent">The <span class="literal">mandelbrot()</span> function squares and adds the complex number 100 times and returns the number of iterations it took for the number to diverge. This number is saved to a variable called <span class="literal">col</span> since <span class="literal">color</span> is already a keyword in Processing. The number in <span class="literal">col</span> determines what color we make that pixel. For now, let’s just get a Mandelbrot set on the screen by making every pixel that never diverges black. Otherwise, we’ll make the rectangle white. Run this code and you should see the famous Mandelbrot set, like in <a href="ch07.xhtml#ch07fig8">Figure 7-8</a>.</p>&#13;
<div class="image"><a id="ch07fig8"/><img alt="image" src="../images/f138-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 7-8: The famous Mandelbrot set</em></p>&#13;
<p class="indent">Isn’t it amazing? And it’s definitely unexpected: just by squaring and adding complex numbers, and coloring the pixels according to how large the numbers get, we’ve drawn an infinitely complicated design that could never have been imagined without a computer! You can zoom in on specific spots in the design by changing the range of <span class="literal">x</span> and <span class="literal">y</span>, like in <a href="ch07.xhtml#ch07list6">Listing 7-6</a>.</p>&#13;
<p class="programs"><span class="pd_gray">#range of x-values</span><br/>xmin = -0.25<br/>xmax = 0.25<br/><br/><span class="pd_gray">#range of y-values</span><br/>ymin = -1<br/>ymax = -0.5</p>&#13;
<span epub:type="pagebreak" id="page_139"/>&#13;
<p class="listing" id="ch07list6"><em>Listing 7-6: Changing the range of values to zoom in on the Mandelbrot set</em></p>&#13;
<p class="indent">Now the output should look like <a href="ch07.xhtml#ch07fig9">Figure 7-9</a>.</p>&#13;
<div class="image"><a id="ch07fig9"/><img alt="image" src="../images/f139-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 7-9: Zooming in on the Mandelbrot set!</em></p>&#13;
<p class="indent">I highly recommend that you investigate videos people have posted on the internet of zooming in on the Mandelbrot set.</p>&#13;
<h4 class="h4" id="ch07_1_2">ADDING COLOR TO THE MANDELBROT SET</h4>&#13;
<p class="noindent">Now let’s add some color to your Mandelbrot design. Let Processing know you’re using the HSB (Hue, Saturation, Brightness) scale, not the RGB (Red, Green, Blue) scale, by adding the following code:</p>&#13;
<p class="programs"><span class="pd_gray">def setup():</span><br/>    <span class="pd_blue1">size</span>(600,600)<br/>    <span class="pd_blue1">colorMode</span>(<span class="pd_lime">HSB</span>)<br/>    <span class="pd_blue1">noStroke</span>()</p>&#13;
<p class="indent">Then color the rectangles according to the value returned by the <span class="literal">mandelbrot()</span> function:</p>&#13;
<p class="programs"><span class="pd_gray">            if col == 100:</span><br/>                <span class="pd_blue1">fill</span>(0)<br/>            <span class="pd_lime">else</span>:<br/>                <span class="pd_blue1">fill</span>(3*col,255,255)<br/><span class="pd_gray">            #draw a tiny rectangle</span><br/>            <span class="pd_blue1">rect</span>(x*xscl,y*yscl,1,1)</p>&#13;
<p class="indent">In the <span class="literal">fill</span> line, we multiply the <span class="literal">col</span> variable (the number of iterations it takes the complex number to diverge) by 3 and make that the H (hue) component of the HSB color mode. Run this code, and you should see a nicely colored Mandelbrot set like in <a href="ch07.xhtml#ch07fig10">Figure 7-10</a>.</p>&#13;
<span epub:type="pagebreak" id="page_140"/>&#13;
<div class="image"><a id="ch07fig10"/><img alt="image" src="../images/f140-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 7-10: Using divergence values to color the Mandelbrot set</em></p>&#13;
<p class="indent">You can see the points that diverge every step, from the dark orange circle to lighter orange ovals that become the black Mandelbrot set. You can experiment with other colors too. For example, change the fill line to the following:</p>&#13;
<p class="programs">                <span class="pd_blue1">fill</span>(255-15*col,255,255)</p>&#13;
<p class="indent">Run this update, and you’ll see more blue in the picture, as shown in <a href="ch07.xhtml#ch07fig11">Figure 7-11</a>.</p>&#13;
<div class="image"><a id="ch07fig11"/><img alt="image" src="../images/f140-02.jpg"/></div>&#13;
<p class="caption"><em><a href="ch07.xhtml#ch07fig11">Figure 7-11</a>: Experimenting with different colors in the Mandelbrot set</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_141"/>Next, we’ll explore a related design called the Julia set, which can change its appearance depending on the inputs we give it.</p>&#13;
<h3 class="h3" id="ch07_7">CREATING THE JULIA SET</h3>&#13;
<p class="noindent">In the Mandelbrot set, to determine the color of each point, we started with the point as a complex number z and then repeatedly squared the value and added the original number z. The Julia set is constructed just like the Mandelbrot set, but after squaring the complex number, instead of adding the original complex number of that point, we keep adding a constant complex number, <em>c</em>, which has the same value for all points. By starting with different values for <em>c</em>, we can create lots of different Julia sets.</p>&#13;
<h4 class="h4" id="ch07_1_3">WRITING THE JULIA() FUNCTION</h4>&#13;
<p class="noindent">The Wikipedia page for the Julia set gives a bunch of examples of beautiful Julia sets and the complex numbers to use to create them. Let’s try to create one using <em>c</em> = –0.8 + 0.156<em>i</em>. We can easily modify our <span class="literal">mandelbrot()</span> function to be a <span class="literal">julia()</span> function. Save your <em>mandelbrot.pyde</em> sketch as <em>julia.pyde</em> and change the code for the <span class="literal">mandelbrot()</span> function so it looks like <a href="ch07.xhtml#ch07list7">Listing 7-7</a>.</p>&#13;
<p class="programs"><span class="pd_g1"><em>julia.pyde</em></span><br/><span class="pd_green1">def</span> julia(z,c,num):<br/><span class="pd_purple">    '''runs the process num times</span><br/><span class="pd_purple">    and returns the diverge count'''</span><br/>    count = 0<br/><span class="pd_gray">    #define z1 as z</span><br/>    z1 = z<br/><span class="pd_gray">    #iterate num times</span><br/>    <span class="pd_lime">while</span> count &lt;= num:<br/><span class="pd_gray">        #check for divergence</span><br/>        <span class="pd_lime">if</span> magnitude(z1) &gt; 2.0:<br/><span class="pd_gray">            #return the step it diverged on</span><br/>            <span class="pd_lime">return</span> count<br/><span class="pd_gray">        #iterate z</span><br/>      <span class="ent">➊</span> z1 = cAdd(cMult(z1,z1),c)<br/>        count += 1</p>&#13;
<p class="listing" id="ch07list7"><em>Listing 7-7: Writing the <span class="literal">julia()</span> function</em></p>&#13;
<p class="indent">It’s pretty much the same as the Mandelbrot function. The only line of code that changed is <span class="ent">➊</span>, where <span class="literal">z</span> is changed to <span class="literal">c</span>. The complex number <span class="literal">c</span> will be different from <span class="literal">z</span>, so we’ll have to pass that to the <span class="literal">julia()</span> function in <span class="literal">draw()</span>, as shown in <a href="ch07.xhtml#ch07list8">Listing 7-8</a>.</p>&#13;
<p class="programs"><span class="pd_green1">def</span><span class="pd_gray"/> <span class="pd_bluebold">draw</span>():<br/><span class="pd_gray">    #origin in center:</span><br/>    <span class="pd_blue1">translate</span>(<span class="pd_raspberry">width</span>/2,<span class="pd_raspberry">height</span>/2)<br/><span class="pd_gray">    #go over all x's and y's on the grid</span><br/>    x = xmin<br/><span epub:type="pagebreak" id="page_142"/>&#13;
    <span class="pd_lime">while</span> x &lt; xmax:<br/>        y = ymin<br/>        <span class="pd_lime">while</span> y &lt; ymax:<br/>            z = [x,y]<br/>          <span class="ent">➊</span> c = [-0.8,0.156]<br/><span class="pd_gray">            #put it into the julia program</span><br/>            col = julia(z,c,100)<br/><span class="pd_gray">            #if julia returns 100</span><br/>            <span class="pd_lime">if</span> col == 100:<br/>                <span class="pd_blue1">fill</span>(0)<br/>            <span class="pd_lime">else</span>:<br/>                <span class="pd_gray">#map the color from 0 to 100</span><br/>                <span class="pd_gray">#to 0 to 255</span><br/>                <span class="pd_gray">#coll = map(col,0,100,0,300)</span><br/>                <span class="pd_blue1">fill</span>(3*col,255,255)<br/>            <span class="pd_blue1">rect</span>(x*xscl,y*yscl,1,1)<br/>            y += 0.01<br/>        x += 0.01</p>&#13;
<p class="listing" id="ch07list8"><em>Listing 7-8: Writing the <span class="literal">draw()</span> function for the Julia set</em></p>&#13;
<p class="indent">Everything is the same as in <em>mandelbrot.pyde</em> until we declare the complex number <span class="literal">c</span> <span class="ent">➊</span> we’ve chosen for this Julia set. Just below that we add <span class="literal">c</span> to the arguments in the call to the <span class="literal">julia()</span> function. When you run it, you get a design much different from the Mandelbrot set, as shown in <a href="ch07.xhtml#ch07fig12">Figure 7-12</a>.</p>&#13;
<div class="image"><a id="ch07fig12"/><img alt="image" src="../images/f142-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 7-12: The Julia set for</em> c <em>= –0.8 + 0.156</em> i</p>&#13;
<p class="indent">The great thing about the Julia set is you can change the input <span class="literal">c</span> and get a different output. For example, if you change <em>c</em> to 0.4 + 0.6<em>i</em>, you should see something like <a href="ch07.xhtml#ch07fig13">Figure 7-13</a>.</p>&#13;
<span epub:type="pagebreak" id="page_143"/>&#13;
<div class="image"><a id="ch07fig13"/><img alt="image" src="../images/f143-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 7-13: The Julia set for</em> c <em>= –0.4 + 0.6</em>i</p>&#13;
<div class="sidebar">&#13;
<p class="title">EXERCISE 7-1: DRAWING A JULIA SET</p>&#13;
<p class="noindent">Draw a Julia set with <em>c</em> = 0.285 + 0.01<em>i</em>.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch07_8">SUMMARY</h3>&#13;
<p class="noindent">In this chapter, you learned how complex numbers get plotted on the complex coordinate plane and how they allow you to perform rotations—and you followed their logic down the rabbit hole, learning how to add and multiply them. You used what you learned to write the <span class="literal">mandelbrot()</span> and <span class="literal">julia()</span> functions to transform complex numbers into incredible art that never would have been possible without the creation of complex numbers and the invention of computers.</p>&#13;
<p class="indent">As you’ve seen, these numbers are anything but imaginary! Hopefully, when you think of complex numbers now, they’ll remind you of the beautiful designs you can make with numbers and code.<span epub:type="pagebreak" id="page_144"/></p>&#13;
</body></html>