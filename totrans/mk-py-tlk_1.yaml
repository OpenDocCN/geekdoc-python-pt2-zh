- en: Part I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting Up Python, Anaconda, and Spyder
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
- en: Even if you’ve never coded before, this chapter will guide you through installing
    the Python software you need to start running Python scripts for this book. We’ll
    be using Anaconda and Spyder, so we’ll discuss the advantages of choosing this
    Python distribution and development environment, respectively. I’ll guide you
    through the installation process based on your operating system, whether that’s
    Windows, Mac, or Linux. Then you’ll learn how to start coding in the Spyder editor.
    We’ll discuss basic Python rules and operations at the end.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Before you begin, set up the folder */mpt/ch01/* for this chapter on your computer.
    All scripts in this chapter (and later chapters) are available at the book’s resources
    page, [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Anaconda and Spyder
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways to install Python and run scripts. In this book, we’ll use
    Anaconda and Spyder.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '*Anaconda* is an open source Python distribution, package, and environment
    manager. It is user friendly and provides for the easy installation of many useful
    Python modules that otherwise can be quite a pain to compile and install yourself.
    We’ll start by downloading the Anaconda distribution of Python that comes bundled
    with Spyder.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '*Spyder* is a full-featured integrated development environment (IDE) for writing
    scripts. It comes with many useful features such as automatic code completion,
    automatic debugging, code suggestions, and warnings.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Installing Anaconda and Spyder
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python is a cross-platform programming language, meaning you can run Python
    scripts whether you use Windows, Mac, or Linux. However, the installation of software
    and modules can be slightly different depending on your operating system. I’ll
    show you how to install various modules in your operating system. Once these are
    properly installed, Python code works the same in different operating systems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Install Anaconda and Spyder in Windows
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To install Anaconda in Windows, go to [https://www.anaconda.com/products/individual/](https://www.anaconda.com/products/individual/)
    and download the latest version of Python 3 for Windows.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: I recommend using the graphical installer instead of the command line installer,
    especially for beginners, to avoid mistakes. Make sure you download the appropriate
    32- or 64-bit package for your machine. Run the installer and follow the instructions
    all the way through.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Find and open the Anaconda navigator, and you should see a screen like [Figure
    1-1](#figure1-1) (if you need to, search for *Anaconda navigator* in the search
    bar).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![f01001](Images/f01001.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-1: The Anaconda navigator'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Launch** button under the Spyder icon. If Spyder is not already
    installed, click **Install** to install the Spyder development environment. After
    it finishes, click **Launch**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Install Anaconda and Spyder in macOS
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To install Python via Anaconda for macOS, go to [https://www.anaconda.com/products/individual/](https://www.anaconda.com/products/individual/),
    scroll down, and download the latest version of Python 3 for Mac. Choose the graphical
    installer and follow the instructions through.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 Anaconda 在 macOS 上安装 Python，请访问[https://www.anaconda.com/products/individual/](https://www.anaconda.com/products/individual/)，向下滚动并下载适用于
    Mac 的最新 Python 3 版本。选择图形安装程序并按照提示进行操作。
- en: Open the Anaconda navigator by searching for *Anaconda navigator* in Spotlight
    search. The screen for the Anaconda navigator in macOS should look similar to
    [Figure 1-1](#figure1-1), perhaps with slight differences.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 Spotlight 搜索中搜索*Anaconda navigator*来打开 Anaconda 导航器。macOS 中的 Anaconda 导航器界面应类似于[图
    1-1](#figure1-1)，可能会有一些小的差异。
- en: To launch Spyder, click **Launch** under the Spyder icon (if you see an **Install**
    button instead, click it to install Spyder first).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动 Spyder，请点击 Spyder 图标下的**启动**按钮（如果您看到的是**安装**按钮，请点击它先安装 Spyder）。
- en: Install Anaconda and Spyder in Linux
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Linux 上安装 Anaconda 和 Spyder
- en: The installation of Anaconda and Spyder in Linux involves more steps than for
    other operating systems. First, go to [https://www.anaconda.com/products/individual/](https://www.anaconda.com/products/individual/),
    scroll down, and find the latest Linux version. Choose the appropriate x86 or
    Power8 and Power9 package. Click and download the latest installer bash script.
    For example, the installer bash script during my installation was [https://repo.anaconda.com/archive/Anaconda3-2020.11-Linux-x86_64.sh](https://repo.anaconda.com/archive/Anaconda3-2020.11-Linux-x86_64.sh).
    This link will change over time, but we’ll use this version as our example.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 上安装 Anaconda 和 Spyder的步骤比其他操作系统更多。首先，访问[https://www.anaconda.com/products/individual/](https://www.anaconda.com/products/individual/)，向下滚动并找到最新的
    Linux 版本。选择适当的 x86 或 Power8 和 Power9 包。点击并下载最新的安装脚本。例如，在我的安装过程中，安装脚本的链接是[https://repo.anaconda.com/archive/Anaconda3-2020.11-Linux-x86_64.sh](https://repo.anaconda.com/archive/Anaconda3-2020.11-Linux-x86_64.sh)。此链接会随时间变化，但我们将以此版本作为示例。
- en: By default, the installer bash script is downloaded and saved to the *Downloads*
    folder on your computer. You should then install Anaconda as follows using the
    path for your bash script if it is different.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，安装脚本会下载并保存在您的计算机的*下载*文件夹中。如果您的 bash 脚本路径不同，您应按照以下方式安装 Anaconda。
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After pressing enter, you’ll be prompted to review and approve the license
    agreement. The last question in the installation process is this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 按下回车后，系统会提示您查看并同意许可协议。安装过程中的最后一个问题是：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You should type `yes` and press enter in order to use the `conda` command to
    open Anaconda in a terminal.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您应输入 `yes` 并按回车，以便在终端中使用 `conda` 命令打开 Anaconda。
- en: 'Now you need to activate the installation by executing this command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要通过执行以下命令来激活安装：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To open Anaconda navigator, enter the following command in a terminal:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开 Anaconda 导航器，请在终端中输入以下命令：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You should see the Anaconda navigator on your machine, similar to [Figure 1-1](#figure1-1).
    To launch Spyder, click the **Launch** button under the Spyder icon (if you see
    an **Install** button instead, click it to install Spyder first).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在您的计算机上看到 Anaconda 导航器，类似于[图 1-1](#figure1-1)。要启动 Spyder，请点击 Spyder 图标下的**启动**按钮（如果您看到的是**安装**按钮，请点击它先安装
    Spyder）。
- en: Using Spyder
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Spyder
- en: To get you up and running, we’ll build a really simple script in Spyder. Then
    I’ll run through a few basic concepts that’ll be useful to know before you start
    coding for real.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您快速上手，我们将在 Spyder 中创建一个非常简单的脚本。接着我将介绍一些在开始编写代码之前非常有用的基本概念。
- en: Write Python in Spyder
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Spyder 中编写 Python 代码
- en: As mentioned earlier, Spyder is a full-featured IDE. Let’s start with a simple
    script. After you launch the Spyder development environment, you should see a
    layout like [Figure 1-2](#figure1-2).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Spyder 是一个功能齐全的集成开发环境（IDE）。让我们从一个简单的脚本开始。在启动 Spyder 开发环境后，您应该会看到类似于[图 1-2](#figure1-2)的布局。
- en: '![f01002](Images/f01002.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![f01002](Images/f01002.png)'
- en: 'Figure 1-2: Spyder development environment'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-2：Spyder 开发环境
- en: Spyder comes with several predefined layouts, and you can customize layouts
    according to your preferences. The default layout has three panels. Let’s examine
    that default.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Spyder 带有几个预定义的布局，您可以根据个人喜好自定义布局。默认布局包含三个面板。让我们来看看这个默认布局。
- en: At the left is the *Spyder editor*, in which you can write Python code. At the
    top right is the *variable explorer*, which shows the details of the data generated
    by your script. As scripts become quite complicated, the variable explorer becomes
    a valuable asset in double-checking the values stored in your variables.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom right is the *interactive Python (IPython) console*, which shows
    the output of the script or executes snippets of Python code. The IPython console
    is also where you enter input for scripts that require user information. It also
    displays error messages if you make a mistake in your script.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s start coding. Go to the Spyder editor window (again, the default
    location is on the left) and enter this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Click **File**▶**Save As** and save the file as *my_first_script.py* in your
    chapter folder.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways to run scripts, and all lead to the same outcome:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Go to the **Run** menu and select **Run**.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press F5 on your keyboard.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the green triangle icon ► in the icons bar.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the script and you should see something like [Figure 1-3](#figure1-3).
    The output, shown in the IPython console, is a simple printed message: `This is
    my very first Python script!` Congratulations—you have written and successfully
    run your first Python script!'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![f01003](Images/f01003.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-3: Running a script in the Spyder development environment'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Inspect Code in Spyder
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besides running an entire script, Spyder has the ability to run code line by
    line or block by block. Running a piece of a script at a time is useful for carefully
    following the execution of a script, to verify that it does exactly what you intended
    it to do. Go back to the *my_first_script.py* example and add another line:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Place your cursor over this second line and press F9, and you should see the
    output shown in [Figure 1-4](#figure1-4).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![f01004](Images/f01004.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-4: Running just one line of code in the Spyder editor'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, only the highlighted line is executed. Here’s the output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now press F5, and you’ll see that every line in the script is executed:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To run a particular block of code, highlight those lines of code and press F9\.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Coding in Python
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we get into the coding concepts of Python, you need to understand a few
    general things. This section introduces Python syntax and basic mathematical operations.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Python Syntax
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, Python is case-sensitive. You should take great care when it comes to
    uppercase and lowercase letters. The variables *X* and *Y* are different from
    the variables *x* and *y*. The strings `"Hello"` and `"hello"` are also different
    from each other.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Second, indentations are significant in Python. Nonprinting characters like
    tabs must be consistently applied throughout a script. If you have experience
    with another programming language, like C or Java, you may notice the lack of
    brackets and semicolons in Python; this is by design. Blocks of code are defined
    by indentation. An unintended space in the code will likely betray your intentions,
    as we’ll see in Chapter 2 when we discuss indentations in conditional executions,
    loops, and functions.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Third, Python uses single quotation marks and double quotation marks (mostly)
    interchangeably. For example, placing a sequence of characters inside single quotes
    has the same effect as if we put them in double quotes (unless one of the characters
    is an escape character or a single quote).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Fourth, Python lets you make notes, known as *comments*. One popular way to
    write a comment uses the hash mark (`#`). Everything in the same line after `#`
    will not be executed. It’s good practice to make notes in your scripts so others
    can more easily understand what the code is doing—and to remind yourself of the
    decisions you’ve made when you revisit the code after a few weeks or a few months.
    For example, in the very first line in *my_first_script.py*, we have this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since this line starts with `#`, Python ignores it, understanding that it’s
    a comment and not code to execute.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have a comment that can’t fit on one line, you can place the comment
    in triple quotation marks (`"""`), and everything between the first set of quotes
    and the last set will not be executed by the Python script. For example, in lines
    2 to 6 in *my_first_script.py*, we have this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All those lines are ignored by Python.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Basic Operations in Python
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python is capable of basic math operations. For example, to calculate 7 multiplied
    by 123, you enter the following in the Spyder editor:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Place your cursor in this line, press F9, and you will get an output of 861.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 1-1](#table1-1) provides the other basic math operations in Python.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1-1: Basic Math Operators'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operators** | **Action** |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| `+` | Addition: `print(5+6)` will give you a result of `11`. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| `-` | Subtraction: `print(9-4)` will give you a result of `5`. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| `/` | Division: `print(9/3)` will give you a result of `3`. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| `**` | Exponent: `print(5**3)` will give you a result of `125`. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| `%` | Remainder: `print(13%5)` will give you a result of `3` because 13 =
    5 × 2 + 3. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: '| `//` | Integer quotient: `print(13//5)` will give you a result of `2` because
    13 = 5 × 2 + 3. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: 'These operations have *precedence*, meaning they will execute in a particular
    order. That order of operations is as follows: operations within parentheses have
    highest priority, followed by exponents, then multiplication and division, which
    have the same priority and are executed from left to right. Addition and subtraction
    have the least priority and are treated equally, so whichever comes first is executed
    first.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: For more complicated mathematical operations, such as cosine in trigonometry
    or the natural logarithm, we need to import modules, which I’ll cover in Chapter
    2.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的数学运算，比如三角学中的余弦函数或自然对数，我们需要导入模块，这部分内容我将在第二章讲解。
- en: Summary
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to install Python and Spyder via Anaconda.
    You also learned to run Python scripts by using Spyder.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何通过Anaconda安装Python和Spyder。你还学会了如何使用Spyder运行Python脚本。
- en: In Chapter 2, we’ll discuss the Python skills that you need for the rest of
    the book. You’ll learn the four main value types and how to convert one type to
    another. We’ll look at conditional execution and loops as well as how functions
    and modules work in Python, allowing you to accomplish more-complicated tasks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，我们将讨论你在本书其余部分需要掌握的Python技能。你将学习四种主要的值类型以及如何将一种类型转换为另一种类型。我们还将讨论条件执行和循环，以及函数和模块在Python中的工作原理，从而帮助你完成更复杂的任务。
- en: End-of-Chapter Exercises
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 章节末练习
- en: Add a line of code to *my_first_script.py* so that it prints out a third message
    that says `Here is a third message!`
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*my_first_script.py*中添加一行代码，使其打印出一条第三条消息，内容为`Here is a third message!`
- en: What is the output from each of the following Python statements? First write
    down the answers and then run the commands in Spyder to verify.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下每个Python语句的输出是什么？首先写下答案，然后在Spyder中运行命令来验证。
- en: '[PRE11]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: What is the command line in the Spyder editor if you want to find the result
    of 55 multiplied by 234?
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想计算55乘以234，Spyder编辑器中的命令行应该输入什么？
- en: '2'
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Python Refresher
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Python基础回顾
- en: '![](Images/chapterart.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: This chapter is a refresher on basic Python. The purpose of this chapter is
    not to comprehensively review all the basic commands in Python. Instead, I’ll
    provide you with the Python skills that are most important to the rest of the
    book.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是对基本Python知识的回顾。本章的目的不是全面回顾Python中的所有基本命令，而是向你提供对本书其余部分最重要的Python技能。
- en: Specifically, you’ll learn the four Python variable types (strings, integers,
    floats, and Booleans) and how to convert one type to another. Functions are useful
    tools in programming languages, and you’ll learn to use built-in functions in
    Python and to import modules in the Python Standard Library.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，你将学习四种Python变量类型（字符串、整数、浮点数和布尔值），以及如何将一种类型转换为另一种类型。函数是编程语言中的有用工具，你将学习如何使用Python内置函数以及如何导入Python标准库中的模块。
- en: You’ll also learn how functions work and how to define your own functions. Many
    modules we use in this book are not in the Python Standard Library, and you’ll
    learn different ways of installing these modules on your computer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将学习函数是如何工作的以及如何定义你自己的函数。本书中我们使用的许多模块不在Python标准库中，你将学习如何在你的计算机上安装这些模块。
- en: We’ll discuss how modules work and how to create your own self-made modules.
    You’ll then learn about a virtual environment, why it’s useful, and how to create
    and activate one.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论模块的工作原理以及如何创建你自己的自定义模块。然后你将学习虚拟环境，了解它为何有用，以及如何创建和激活它。
- en: Python uses strings, lists, dictionaries, and tuples as collections of elements
    to accomplish complicated tasks. In this chapter, you’ll learn these four types
    of collections, one by one. You’ll also see examples of their uses.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Python使用字符串、列表、字典和元组作为元素集合来完成复杂的任务。在这一章中，你将逐一学习这四种集合类型，并查看它们的使用示例。
- en: Before you begin, set up the folder */mpt/ch02*/ for this chapter. As in Chapter
    1, all scripts in this chapter are available at the book’s resources page, [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始之前，为本章设置文件夹*/mpt/ch02*。像第一章一样，本章的所有脚本可以在本书的资源页面找到，[https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/)。
- en: Variables and Values
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量和数值
- en: 'A *variable* is a reserved memory location to store values in Python (and in
    other programming languages). We can assign values to variables and use the variable
    name to recall the associated value. Python has four types of values: strings,
    floats, integers, and Booleans.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量*是一个保留的内存位置，用于在Python（以及其他编程语言）中存储值。我们可以将值赋给变量，并使用变量名来调用关联的值。Python有四种类型的值：字符串、浮点数、整数和布尔值。'
- en: Strings
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: 'A *string* is a sequence of characters inside quotation marks, often used to
    represent text. Here are some examples of strings:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串*是由引号括起来的一系列字符，通常用于表示文本。以下是一些字符串的示例：'
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can find out the type that a variable contains by using the `type()` function.
    Enter the following in the Spyder editor:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After execution, you’ll see the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This means both variables have string values. You can add or multiply strings,
    but not in the traditional mathematical sense; instead, you can join strings or
    repeat them. For example, say you run the following two lines of code in the Spyder
    editor:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You will see the following output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The plus sign joins two strings together, while multiplying a string by 3 means
    to repeat the characters in the string three times. Note that I’ve deliberately
    left an empty space at the end of the string `University of Kentucky`, so that
    when they join together, there is a space between the strings.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Floats
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Floating-point numbers*, also known as just *floats*, are a number type that’s
    equivalent to decimal numbers in mathematics. Here are two examples of floats:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can use the `round()` function to restrict a float to a certain number
    of digits after the decimal point. Floats can be positive, negative, or zero.
    Run the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You will have the following output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Floats are used to perform calculations.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Integers* are another number type; they can’t have decimal places and so must
    be whole numbers. Integers are used mainly for indexing purposes in Python. Integers
    can be positive, negative, or zero. Here are some examples of integers:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It is important to know that floats always have decimals, while integers do
    not. You never need to tell Python what type you want to use; instead, it can
    tell by the information you give it. Python knows you’re using an integer if you
    enter a number without any quote marks and without decimal places. Even if you
    round a float number to zero digits after a decimal, you would still get a decimal
    point and a 0 trailing the number. Run the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You will have the following output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The output shows that all three variables, `a`, `b`, and `c`, are integers.
    You will not get an output of `7` from `print(round(7.346,0))`, because using
    the decimal is Python’s way of telling an integer apart from a float.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Bools
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Booleans*, or *bools*, are binary variables that can take only the value of
    `True` or `False`. Note that the first letter in `True` or `False` must always
    be uppercase. We use bools to find out truths about our code and make logical
    statements. As an example, run these two lines of code that compare two numbers:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You will get the following output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The results show that the logic statement `4 > 5` is `False`, while the logic
    statement `10 >= 6` is `True`. The values `True` or `False` (without quotes) are
    not strings but are special values reserved by Python. Try the following commands:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here’s the output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, once you put `4 > 5` inside quotation marks, it becomes a string
    variable instead of a bool.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Bools can also be represented with `1` (or, in reality, anything that’s nonzero)
    for `True` and `0` for `False`. Run this code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It outputs the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `bool()` function converts any nonzero value to `True` and `0` to `False`.
    Run the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And you will get this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Convert Variable Types
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can convert the type of a variable by using the functions `str()`, `int()`,
    `bool()`, and `float()`, but only if the type you’re trying to convert is compatible
    with the resulting type. For example, you can convert the string variable `"17"`
    to an integer or a float by using `int("17")` or `float("17")`, because 17 is
    a number that can be recognized as an integer or float. However, you cannot convert
    the string `"Kentucky"` to either an integer or a float.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following lines of code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Bool values `True` and `False` can be converted to integers `1` and `0`, respectively,
    because `1` and `0` are often used to represent `True` and `False`. While the
    float number `17.0` and string variable `"88"` can be converted to integers, the
    string variable `"3.45"` can’t be converted to an integer because it has values
    after the decimal point.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'You can convert almost anything into a string variable; for example, the float
    number `17.0` can be converted to the string variable `"17.0"`. You can also convert
    any integer to a float: for example, the integer `–4` can be converted to the
    float `–4.0`.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Rules for Variable Names
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Certain rules exist for naming variables, and not everything can be used as
    a variable name. A variable name must start with a letter (either uppercase or
    lowercase) or an underscore (`_`). For example, you can’t use `8python` as a variable
    name because it starts with a number.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The only special character a variable name can have is the underscore, so special
    characters such as `@` or `&` are not allowed. See the Python naming conventions
    at [https://www.python.org/dev/peps/pep-0008/#id34/](https://www.python.org/dev/peps/pep-0008/#id34/)*.*
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Variable names can’t be Python keywords or Python built-in functions. To get
    the list of all keywords, run these two lines of code in the Spyder editor:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is a full list of Python keywords:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Variable names can, however, *contain* keywords. For example, `first_break`
    and `class1` are valid variable names, even though `break` and `class` are not.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Variable names should not be Python built-in functions. [Figure 2-1](#figure2-1)
    lists those functions, which are found in the Python documentation at [https://docs.python.org/3/library/functions.html](https://docs.python.org/3/library/functions.html)*.*
    You would do well to familiarize yourself with the list and avoid using these
    terms as variable names.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![f02001](Images/f02001.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-1: List of Python built-in functions'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Loops and Conditional Execution
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Loops and conditional statements let you make decisions in your code, so that
    certain code will run if a particular thing happens.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Execution
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `if` statement allows your code to take particular actions based on whether
    a condition is met. Consider the following lines of code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, `x > 0` is the condition. If the value of `x` is larger than 0, the condition
    is met, and the script prints the message `x is positive`. Conditionals in Python
    always need a colon (`:`) after the conditional statement. If the condition is
    not met, the script moves to the `else` branch and prints `x is nonpositive`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also have more than two conditions by using the `elif` keyword. Consider
    the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Python uses the double equal sign (`==`) as a comparison operator, to distinguish
    it from value assignments when we use a single equal sign (`=`). This script has
    three possible outcomes, depending on which condition is met: `x is positive`,
    `x is zero`, or `x is negative`.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'If we require more than three conditions, the first condition must follow the
    `if` statement, the last condition must come after the `else` statement, and all
    conditions between should have the `elif` keyword:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The script prints out the letter grade based on the value of the score: A if
    the score is greater or equal to 90; if not, B if the score is above 80, and so
    on.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One great advantage of computers is their ability to repeat the same tasks
    many times at a fast rate. This is known as *looping*, or *iterating*, in programming.
    Python has two types of loop: the `while` and the `for` loop.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The while Loop
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A `while` loop is used to execute a block of code as long as a certain condition
    is met. Here we use the `while` statement to create a loop that adds 1 to the
    variable `n` every time it loops until `n` reaches `3`. Then the loop exits, and
    the script prints `finished`. Save this as *whileloop.py*:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We first assign `n` a value of `0`. Then, the script starts the `while` loop
    with the condition `n < 3`. As long as the condition is met, the loop keeps running.
    Notice the colon, which tells Python to expect the indented lines that follow
    as part of the loop. Those lines will execute every time the loop runs. The last
    line, which is not indented, runs only after the loop exits.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first iteration, the value of `n` increases from `0` to `1`, and the
    updated value of `n` is printed out. In the second iteration, the value of `n`
    increases to `2`, and the updated value of `n` is printed out. In the third iteration,
    the value of `n` increases to `3`, and `3` is printed out. When the script goes
    to the fourth iteration, the condition `n < 3` is no longer met, and the loop
    stops. After that, the last line is executed. As a result, we see the following
    output from *whileloop.py*:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `while` loop is most useful when we don’t know the number of iterations
    we need beforehand, even though it can also be used to perform the same tasks
    as a `for` loop. Later in this book, we often use the statement `while True` to
    create an infinite loop that puts the script in standby mode.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The for Loop
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `for` loop is generally used when you want to execute a block of code a
    fixed number of times. The following script, *forloop.py*, is an example of a
    `for` loop that does the same as the `while` loop we just made, adding 1 to the
    variable `n` until `n` reaches `3`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We start by using `range()`, a built-in function in Python, to produce a range
    of values from 0 to 2 (Python always begins counting from 0). The line tells the
    script to loop through the three values, one value per loop, and execute the next
    two lines of code for each value, adding 1 to `n` per loop. When the range has
    been used up, the loop exits, and we print `finished`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The code in *forloop.py* produces the same output as *whileloop.py*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Loops in Loops
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can place a loop inside another loop. This is known as *nesting*. Nested
    loops are useful when, for each iteration in the outer loop, you need to repeat
    certain jobs for each iteration in the inner loop. The example script *loop_in_loop.py*
    loops through a list and a tuple, printing each member of the list with each member
    of the tuple, one pair per iteration:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'First, we start the outer loop with `for`, and then the first indented line
    starts the inner loop. The script takes the first value in the outer loop, goes
    through all iterations in the inner loop, and prints a message at each iteration.
    It repeats the process again with the second value of the outer loop. We need
    to indent the content of the inner loop twice so the script knows which lines
    belong to which loops. The final output from *loop_in_loop.py* is shown here:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notice that we use the `f"{}"` string-formatting approach. The string `f"this
    is {``letter``}{``num``}"` tells Python to replace whatever is in the curly brackets
    with the actual value of the variable mentioned.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: You can nest loops pretty much indefinitely, and the script will iterate through
    all values in the innermost loop for each combination of values in the medium
    and outer loops. However, nesting too many loops can make your code difficult
    to read and isn’t generally recommended practice.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Loop Commands
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Loops have a few commands that are useful for controlling the way your loops
    behave—namely, `continue`, `break`, and `pass`. These commands allow you to make
    decisions within a loop by using the `if` statement.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: continue
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `continue` command tells Python to stop executing the rest of the commands
    for the current iteration and to go to the next iteration. You use `continue`
    when you want to skip certain actions when certain conditions are met in a loop.
    For example, the script *forloop1.py* uses the `continue` command to skip printing
    the number 2 and go to the next iteration:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When the value of `n` is `2`, line 1 will not be executed because the `continue`
    command tells the script to skip it and go to the next iteration. The output from
    this script is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: break
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `break` command tells Python to break the loop and skip all remaining iterations.
    You use `break` when you want to exit the loop. The example script *forloop2.py*
    uses the `break` command to exit the `for` loop when the number reaches value
    `2`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When the value of `n` is `2`, the whole loop stops and the script goes to line
    1 directly. The output is therefore as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Later in this book, we’ll frequently use the `break` command to tell the script
    to stop the infinite loop generated by the statement `while True`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `pass` command tells Python to do nothing, and it is used when a command
    line is needed but no action needs to be taken. We often use it along with `try`
    and `except`, and we’ll revisit this command later in this book. The script *forloop3.py*
    uses a `pass` command to tell the script to take no action when the value of the
    number is `2`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'When the value of `n` is `2`, no action needs to be taken. Therefore, here’s
    the output from the preceding script:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is the same as the output from *forloop.py*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *string* is a sequence of characters inside single or double quotation marks.
    The characters in the string can be letters, numbers, whitespace, or special characters.
    We’ll discuss how elements in a string are indexed, how to slice them, and how
    to join multiple strings together.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: String Indexing
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The characters in strings are indexed from left to right, starting at 0\. This
    is because Python uses *zero-based indexing*, so the first element is always indexed
    as 0 instead of 1\.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access characters in a string by using the square bracket operator
    and the index of the character you want:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Since `e` is the second character in the string `"hello"`, the output is this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Python also uses *negative indexing*, which starts from the end of the string.
    The last character in the string can be indexed as `[-1]`, the second-to-last
    one as `[-2]`, and so on. This is useful when you have a long string and want
    to locate characters at the end of it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the third-to-last character of the string `msg`, you’d use this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here’s the output:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: String Slicing
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Slicing* a string means taking out a subset of characters. We again use the
    square bracket operator:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This will output the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The code `msg[``a``:``b``]` gives you the substring from position `a` to position
    `b` in the string `msg`, where the character in position `a` is included in the
    substring but the character in position *b* is not. Therefore, `msg[0:3]` produces
    a substring of the first three characters in the string `msg`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: String Methods
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ll cover a few common string methods we’ll use throughout this book.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: replace()
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `replace()` method replaces certain characters or substrings in the string
    with other characters. It takes two arguments: the character you want to replace
    and the character to replace it with. For example:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We use `replace()` to replace all whitespaces with the plus sign. The output
    from the preceding script is shown here:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This method will be useful later in the book, when we deal with the speech recognition
    feature. We’ll use `replace()` to change the voice text from the speech engine
    to a suitable format for the script.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: lower()
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `lower()` method converts all uppercase letters in a string to lowercase.
    Since Python strings are case-sensitive, converting all letters to lowercase when
    matching strings means we won’t miss uppercase substrings that should match.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we want to capture the spoken phrase “department of education” via a speech
    recognition module. We can’t be sure whether the phrase will be captured as `Department
    of Education` or not. You can use `lower()` to convert the phrase to an all lowercase
    string to avoid mismatches, like so:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The script tests whether the two strings `inp` and `inp1` are the same when
    we ignore case-sensitivity. Here’s the output:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: find()
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can use `find()` to locate the position of a character in a string. The
    method returns the index of the character in the string.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following lines of code into the Spyder editor and save it as *extract_last_name.py*;
    then run it:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The string variable `email` has a pattern: it consists of the first name, the
    dot, and the last name, followed by `@uky.edu`. We use this pattern to locate
    the positions of the dot and the at sign, then retrieve the last name based on
    those two positions.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: First, we get the position of `.` and define it as a variable `pos1`. Then,
    we find the position of `@` and define it as `pos2`. Finally, we slice the string
    and take the characters between the two positions, returning the substring as
    the variable `last_name`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the script should produce this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The indexes of `.` and `@` in the email are `4` and `10`, respectively, and
    the last name is `Smith`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the string method `find()` to locate a substring. The method
    returns the starting position of the substring in the original string. For example,
    if you run the following lines of code
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'you’ll get the following output:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The output says that the substring `uky.edu` starts with the 12th character
    in the email.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: split()
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `split()` method splits a string into multiple strings, using the specified
    separator. Enter the following code in Spyder and run it:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The output is as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The default *delimiter* (a fancy name for *separator*) is a whitespace (`' '`).
    You can also specify the delimiter when you use `split()`. Let’s revisit the example
    of extracting the last name from an email address, naming the new script *split_string.py*,
    as in [Listing 2-1](#listing2-1).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Listing 2-1: Using a delimiter to split up an email address'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'We first split the email into two parts by using `@` as the delimiter and assign
    the name and domain to a tuple. (We’ll discuss the definition of a *tuple* later
    in this chapter.) As a result, the first element in the tuple, the variable `name`,
    is a substring: `John.Smith`. The script then splits `John.Smith` into the first
    name and the last name, using `.` as the delimiter, and saves them in the tuple
    `(``first``,` `last``)`. Finally, we print out the second element in the tuple
    as the last name.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is shown here:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: join()
  id: totrans-288
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `join()` method joins several strings into one, as in this script, *join_string.py*:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We define `&` as the variable `mylink`, to be used as our separator. The `strlist`
    is a list of the three words that we want to join together. We use `join()` to
    combine the three words into one single string. Note that you need to put `join()`
    after the separator. Finally, we print out the joined string:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Lists
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *list* is a collection of values separated by commas. The values in a list
    are called *elements*, or *items*, and they can be values, variables, or other
    lists.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Create a List
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a new list, you simply put the elements in square brackets:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We define the list `lst` with three elements: an integer number `1` and two
    strings. Note that `list()` is a built-in function in Python, so you cannot use
    `list` as a variable name or list name. I suggest that you use a descriptive name
    to help future readers understand the code.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'You create an empty list by using a pair of square brackets with nothing in
    it:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Or you can use the `list()` function:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Access Elements in a List
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can access the elements of a list by using the bracket operator:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This will produce the following:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Here, `lst[2]` refers to the third element in the list, because Python is like
    most computer programming languages, which start counting at zero.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'You can traverse the elements of a list by using a loop:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This give us the following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We use the built-in function `len()` to return the length of the list, which
    is `3` in this case. The built-in function `range()` returns values `0`, `1`,
    and `2` here.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Use a List of Lists
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A list can use lists as its elements. This is useful for mapping element positions
    to coordinates in a two-dimensional space. Here is one example:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Here’s the output:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The list `llst` itself contains five lists. To find the value of `llst[1][2]`,
    the code first looks at the second item in the outer list `llst`, which is the
    list `[2, 2, 6, 8]`. The third element of that list is `6;` hence `llst[1][2]
    = 6`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s draw a corresponding picture in a two-dimensional space, as in [Figure
    2-2](#figure2-2).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '![f02002](Images/f02002.png)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-2: Map a list of lists to a two-dimensional space'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use this in Part III to create boards for our interactive games.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Add or Multiply Lists
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the plus (`+`) and multiplication (`*`) operators on lists, but
    not in the mathematical sense. For example, run the following lines of code:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You should see the following output:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The plus operator joins two lists into a larger list. The multiplication operator
    repeats the elements in the list. If you multiply a list by 3, the elements will
    appear three times.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: List Methods
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ll introduce several useful list methods here that we’ll use in later chapters
    of this book.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: enumerate()
  id: totrans-332
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `enumerate()` method prints out all elements in a list with their corresponding
    indexes. Assume we have the following list `names`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The following lines of code
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'will generate this output:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The first element at index `0` is Adam, the second at index `1` is Kate, and
    so on.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'You can choose the start value to be 1 instead of 0 with `start=1`, like so:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The output is as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: append()
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can append an element to the end of a list by using the `append()` method.
    Consider this script, *list_append.py*:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This code is appending the element `2` to the existing list `lst`, producing
    this:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The new `lst` now has four elements.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'You can append only one element at a time, and it is added to the end of the
    list by default. Appending two elements will lead to an error message. Change
    line 1 in the script *list_append.py* to the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'You’ll get the following error message:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'However, you can append multiple elements as a list. Add square brackets around
    the two numbers as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'You’ll get the following output:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The new list has four elements.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'To add two or more elements to the existing list, you should use the plus operator.
    For example, to add 2 and 3 as two separate elements to the list, you can use
    the following line of code:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The output will be as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: remove()
  id: totrans-363
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can remove an element from a list by using `remove()`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We remove the element that was at index 1, resulting in this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The new list no longer has element `a`. You can remove only one element at a
    time.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: index()
  id: totrans-369
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can find the position of an element in a list by using the `index()` method:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'From this we get the following:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The result tells you that the element `a` has an index of `1` in the list.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: count()
  id: totrans-375
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can count how many times an element appears in a list by using `count()`:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'This produces the following:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This tells us that the element `1` has appeared in the list twice, while the
    element `a` has appeared once.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: sort()
  id: totrans-381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can sort the elements in a list by using `sort()`. The elements must be
    the same type (or at least convertible to the same type). For example, if you
    have both integers and strings in a list, trying to sort the list will lead to
    the following error message:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Numbers are sorted from the smallest to the largest. Adding `reverse=True`
    inside the method as an option will reverse the ordering. Here’s an example:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'This will output the following:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Letters are sorted in alphabetic order, and they come after numbers. Consider
    this example:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The output is shown here:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Use Built-in Functions with Lists
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use several Python built-in functions on lists directly, including `min()`,
    `max()`, `sum()`, and `len()`. These produce the minimum value, the maximum value,
    the total sum, and the length of the list, respectively, like so:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Here’s the output:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: list()
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the `list()` function to convert a string to a list of characters:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The output is as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Interestingly enough, Python strings can be treated just like lists of characters.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *dictionary* is a collection of key-value pairs. We create a dictionary by
    placing the elements inside curly brackets, as shown in [Listing 2-2](#listing2-2).
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Listing 2-2: Creating a dictionary with two key-value pairs'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'The dictionary `scores` has two key-value elements, separated by a comma: the
    first element is the key `blue` and the value `10`, denoted by their position
    and separated by a colon. The second element is `''white'':12`.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an empty dictionary, you use `dict()` or a pair of curly brackets
    with nothing within them:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'You can add a new element to the existing dictionary as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The line `Dict3['yellow'] = 6` assigns a value of `6` to the key `yellow`. The
    new `Dict3` contains the element `6`, which is accessible by the key `yellow`.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Access Values in a Dictionary
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You access values in a dictionary by using the bracket operator. The key value
    in each pair acts as the index. For example, we can access the values in `scores`,
    built in [Listing 2-2](#listing2-2), as follows:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'This will give you the following results:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'We can also use the `get()` method. The advantage of using `get()` is that
    it uses `None` as a default value when a user requests a key that isn’t in the
    dictionary, rather than returning an error. Consider the following script, *get_score.py*:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'This produces the following:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Since the key `yellow` is not in `scores`, the method `get('yellow')` returns
    a value of `None`. Further, when you put the option `0` in the method, `get('yellow',
    0)` returns a value of `0`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Use Dictionary Methods
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the `keys()` method to produce a list of all keys in a dictionary:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'This gives us the following:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'We can use `values()` to produce a list of all values in a dictionary:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The output is shown here:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: We can use `items()` to get the list of each key-value pair as a tuple (see
    “Tuples” on page 37).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'This produces the following result:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: How to Use Dictionaries
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The values in a dictionary can be any type of variable, a list, or even another
    dictionary. Here we have a dictionary that uses lists as values:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The value for each key is a three-element list. The three values represent
    the scores each player got in the first half and second half of the game and the
    total score, respectively. To find out how many points the white team got in the
    second half, you can call this:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The advantage of a dictionary is that its key can be any value, not necessarily
    an integer. This makes dictionaries useful in many situations. For example, *most_freq_word.py*
    uses a dictionary to count words:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: We define `news` as a string variable with a short paragraph. We then create
    an empty dictionary `wdcnt`. Next, we split the string into a list of separate
    words. We then count the frequency of each word and store the information in the
    dictionary, with the word as the key and the word count as the value. Because
    we use `get()`, if a word is not already in the dictionary as a key, the second
    argument in `get()` assigns a value of `0` to the word.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we print out the words that have the highest frequency. The result
    is as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: It turns out that the most frequent word in the news article is `and`, which
    is used three times.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: Switch Keys and Values
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes you’ll want to switch the positions of keys and values. Now let’s
    take the term *dictionary* literally and suppose you have the following English-to-Spanish
    dictionary that uses the English word as the key and the Spanish translation as
    the value:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'You want to create a Spanish-to-English dictionary instead. You can accomplish
    this by using the following line of code:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The command `x,y in spanish.items()` retrieves all the key-value pairs in `spanish`.
    The command `y:x for x,y` switches the positions of the keys and values. You must
    put curly brackets around everything to the right of the equal sign so that the
    script treats it as a dictionary. To verify, enter this:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'You will have the following output:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Combine Two Dictionaries
  id: totrans-456
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To combine two dictionaries `x` and `y` into one large dictionary `z`, you
    assign `z = {**x, **y}`:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The result is a new dictionary called `spanishenglish` with six elements: three
    pairs from `spanish` and three pairs from `english`.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *tuple* is a collection of values separated by commas, similar to a list—with
    the big difference that a tuple cannot be changed after it’s defined (that is,
    tuples are immutable). Elements of a tuple exist inside parentheses instead of
    square brackets to distinguish the tuple from a list. Here we make a tuple and
    attempt to modify it:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'We get the following error message:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Because tuples are immutable, we cannot use methods like `append()` or `remove()`
    on them. We cannot sort the elements in a tuple either.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: 'The elements of a tuple are indexed by integers, and we can access them by
    using the bracket operator:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Our output is shown here:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: We saw examples of assigning values to a tuple in *split_string.py* ([Listing
    2-1](#listing2-1)).
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: You can compare two tuples. This process begins with comparing their first elements.
    If the first elements are the same, we check whether the second elements match.
    If the second elements are also the same, we go to the third elements, and so
    on, until we find a difference.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in your Spyder editor:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'And you’ll see this output:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Functions
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *function* is (ideally) a block of code designed to do a task. There are many
    functions that do many things, but it is commonly considered best practice to
    have a function that performs only one task (and does not make changes to other
    variables). Some functions have defined parameters (inputs). We can assign the
    function code to a variable name so we don’t have to repeat the same code every
    time we need that task done. Instead, we just call the function and enter the
    inputs.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: Functions also improve readability, making the code more organized, less cluttered,
    and less error-prone.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Use Built-in Python Functions
  id: totrans-479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python comes with many built-in functions that you can readily use, including
    `print()` from Chapter 1. Here I’ll discuss a couple of built-in functions we’ll
    use frequently in this book.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: The range() Function
  id: totrans-481
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `range()` function is used to produce a list of integers. We introduced
    `range()` when we discussed loops on page 21. We know that, for example, `range(5)`
    produces the values `[0, 1, 2, 3, 4]`. The default starting value generated by
    the function `range()` is `0`, because Python uses zero indexing, but you can
    also specify the starting value. For example, `range(3, 6)` produces the list
    of the following three values: `[3, 4, 5]`.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: The default increment value is `1`, but you can also specify the increment as
    the optional third argument. For example, the code
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'will give this output:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The third argument in `range(-5, 6, 2)` tells the script to increase the value
    by 2 for each element.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: If the increment value is a negative integer, the values in the list decrease.
    For example, `range(9, 0, -3)` produces the list `[9, 6, 3]`.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: The input() Function
  id: totrans-489
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Text-to-speech* is the process of converting written text into human voice,
    so it’s important to know how Python takes written text inputs, using a built-in
    function called `input()`.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following script in Spyder:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: You should see a screen similar to [Figure 2-3](#figure2-3).
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '![f02003](Images/f02003.png)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-3: A screenshot of what happens when Python is asking for input'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in [Figure 2-3](#figure2-3), the script asks for your input
    in the lower-right IPython console. It waits for you to type some text and press
    enter before it continues to run. If you enter `blue`, the script will output
    the following:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'You can ask for multiple inputs, like so:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: The script asks for two inputs. The sequence `\n` is an escape character, inserting
    a new line below the question “What is your first name?”
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: Define Your Own Functions
  id: totrans-501
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to using built-in functions, we can build our own. I’ll show you
    how to create a function, and this process will also show you how functions work.
    Functions can take one or more inputs, known as *arguments*, or no input at all.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: A Function with No Argument
  id: totrans-503
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ll start by building a function that prints the message `Finished printing`.
    This function takes no input:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: We use `def` to signify a function definition, give a function name, and follow
    it with empty parentheses and a colon. The colon tells Python to expect the body
    of the function. All indented lines that follow are considered part of the function.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: 'The script prints three numbers, after which we call the function. The output
    is as follows:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: As you can see, the command line in the function is executed only when the function
    is called, not when it is defined.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: A Function with One Argument
  id: totrans-510
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’ll write a function that takes one input. We need to write a thank-you
    note to 50 people. The message is the same except for the recipient’s name. We’ll
    define a function to print the message, and we need to supply only the name for
    each message when we call it. We first define a function called `msgs()` as follows:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The name of the function is `msgs`, with the variable `name` as its only input.
    If we call the function twice as follows:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'the output will be this:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'To write the 50 thank-you notes, you can call the function 50 times: once with
    each name.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: A Function with Multiple Arguments
  id: totrans-518
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Functions can have two or more arguments as inputs. Consider the script *team_sales.py*
    in [Listing 2-3](#listing2-3), which defines a function that needs three inputs.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Listing 2-3: Defining a function with three arguments'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: We define a function to calculate the total sales from a team with three members.
    The function uses the sales from individual members, `sales1`, `sales2`, and `sales3`,
    as the three arguments. We calculate the total team sales, `sales`, by summing
    the three individual sales numbers. We then tell the script the output of the
    function by using the `return` command. As a result, when the function `team_sales()`
    is called, you get the sum of the three sales.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: If the individual sales are 100, 150, and 120, when we call the function `team_sales()`,
    we’ll get an output of 370.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: A Function That Takes an Unknown Number of Arguments
  id: totrans-524
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes the number of inputs is unknown. For example, you want to define a
    function to calculate the total sales made by a group of salespeople, but different
    groups have different numbers of salespeople. You can define a single function
    for this purpose that works regardless of the size of the group by using the argument
    `*args`, which allows you to pass multiple values of variable length to a function.
    [Listing 2-4](#listing2-4), *total_sales.py*, accomplishes the job.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Listing 2-4: First part of *total_sales.py*'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: We start `total_sales()`, which takes `*args` as the argument. We set the value
    of the variable `total` to `0` and then loop through each element in the argument
    `args`. For each element in the argument, we add it to the variable `total`. We
    output the total sales of the group. Test it out with [Listing 2-5](#listing2-5).
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Listing 2-5: Second part of the script *t**otal_sales.py*'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: 'From this, we get the following:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: As you can see, the function takes the one argument, `*args`, but you can put
    as many elements in the function as you want.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  id: totrans-534
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are not limited to just the Python built-in functions. The Python Standard
    Library has many modules that provide other functions you can call from your own
    code.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: Import Modules
  id: totrans-536
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll discuss three ways of using a function from a module and the pros and
    cons of each approach.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: Import the Module
  id: totrans-538
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first way is to import the entire module. For example, to find the value
    of the cosine of a 30-degree angle, you can first import the *math* module. Then
    you can use the `cos()` function from the module by calling both the module name
    and the function name: `math.cos()`.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code in Spyder:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: You’ll have an output of `0.15425144988758405`.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to import the module before you call `math.cos()`*.* If you don’t
    import *math* and just run this command:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Python will give you an error message:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Also, you must always put the module name in front of the function name when
    you call the function. Enter the following two lines of code in Python:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'You’ll get this error message:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: This is because Python doesn’t know where to find the `cos()` function, even
    though you have imported the *math* module.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: Import the Functions
  id: totrans-552
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you want only one or two functions from a certain module, you can save time
    by importing just those one or two functions. This approach allows you to use
    the function name without having to append the module name. Enter the following
    two lines of code:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: You’ll get the correct output, `4.759421635875676`. We don’t need to use `math`
    because we told the script where to look for the two functions. This is particularly
    useful if you need to use the function dozens or hundreds of times in your script.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: Use Asterisk Import
  id: totrans-556
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If your script relies heavily on many functions in a module, you can potentially
    save time by importing all functions from the module by using asterisk import:
    `from module import *`. However, many in the Python community have cautioned against
    this approach because the `import *` statement can pollute your namespace, potentially
    interfering with functions you define (or functions from other modules). We won’t
    use this method in the book.'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: Create Your Own Modules
  id: totrans-558
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Listing 2-3](#listing2-3), we defined `team_sales()` in *team_sales.py*
    and then called the function. You might need to calculate the total sales in many
    scripts. You can do so without rewriting the code in each script by building the
    function into a module.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first create a script called *create_local_module.py,* as shown in [Listing
    2-6](#listing2-6).
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Listing 2-6: Code for the local module'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: This script defines `team_sales()` but does not call it. Next, create the new
    script *import_local_module.py* in [Listing 2-7](#listing2-7) and save it in the
    same folder as *create_local_module.py*.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Listing 2-7: Code to import the local module'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: When you import a module, Python first looks in the directory the importing
    script is stored in, so the module must be in the same folder. This kind of module
    is known as a *local module*.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the script, you’ll get the following results:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: The `team_sales()` function correctly calculates the total sales for three teams.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: Local modules work the same as modules in the Python Standard Library, but they
    need to be stored in the folder Python expects them to be in.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: 'For modules that you download, Python stores the file path of the downloaded
    module behind the scenes and follows that path when you import it. For example,
    the *tkinter* package is in the Python Standard Library we’ll use later in this
    book. When you install it, the files are placed under a specific path, which is
    something like the following on Windows:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: It’s buried like this so you don’t accidentally alter or misplace it, which
    would mean you could no longer use it.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: Use Third-Party Modules
  id: totrans-574
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the main advantages of Python is that programmers can share modules with
    one another for free. Many of these modules are not in the Python Standard Library,
    including the module we’ll rely on for the text-to-speech and the speech recognition
    functionality. These external modules, known as *third-party modules*, can be
    installed separately. Before you do that, you need to check that the module isn’t
    already installed.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: Check Installed Modules
  id: totrans-576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All modules in the Python Standard Library are automatically installed on your
    machine when you install Python. Other modules may also be installed when you
    download various software or modules. For example, when you install *pandas* in
    Chapter 14, about 23 other supporting modules will be installed because *pandas*
    depends on them.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check whether a module is installed on your computer already with the
    following in your Spyder editor:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: This will provide you with the list of all modules installed on your computer.
    However, it can take a long time for Python to list all the modules and for you
    to check them.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can check whether a module is installed by trying to import
    it:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: To check whether *pandas* is installed on your computer, run `import pandas`,
    and if you receive no error message, the module is already installed. If the output
    shows `ModuleNotFoundError`, you need to install it. Let’s see how.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: Pip Install Modules
  id: totrans-584
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *gTTS* module we’ll use in Chapter 4 is not included in Python Standard
    Library, so we’ll `pip` `install` it. Open the Anaconda prompt (in Windows) or
    a terminal (in Mac or Linux), and enter this:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Follow the onscreen instructions all the way through, and the *gTTS* module
    will be installed.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: Conda Install Modules
  id: totrans-588
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you can’t find the module you want through `pip` `install`, try `conda install`.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll install the *yt* module by using the following in the Anaconda prompt
    (in Windows) or a terminal (in Mac or Linux):'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Many people think `pip install` and `conda install` are the same, but they’re
    not. Pip is the Python packaging authority’s recommended tool for installing packages
    from the Python packaging index. You can install Python software only by using
    `pip install`. In contrast, Conda is a cross-platform package and environment
    manager that installs not only Python software but also packages in C or C++ libraries,
    R packages, or other software.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: As you build more and more projects in Python, you’ll install many modules.
    Some modules may interfere with other modules, and different projects may use
    different versions of the same module. To avoid problems of clashing modules,
    I recommend you build a virtual environment for each project. A *virtual environment*
    is a way to isolate projects from each other.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: Create a Virtual Environment
  id: totrans-594
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a virtual environment, open an Anaconda prompt (in Windows) or a
    terminal (in Mac or Linux). We’ll name the virtual environment for the projects
    in this book *chatting*. Enter the following command:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: After pressing enter, follow the instructions onscreen and press **y** when
    the prompt asks you `y/n`. Once you have created the virtual environment on your
    machine, you need to activate it.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: Activate the Virtual Environment in Windows
  id: totrans-598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the Anaconda prompt (in Windows) or a terminal (in Mac or Linux), type this:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'In Windows, you’ll see the following on your Anaconda prompt:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: You can see the `(chatting)` prompt, which indicates that the command line is
    now in the virtual environment *chatting* that you’ve just created.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: 'On a Mac, you should see something similar to the following in the terminal
    (the username will be different):'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'In Linux, you should see something similar to this on your terminal (the username
    will be different):'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Set Up Spyder in the Virtual Environment in Windows
  id: totrans-608
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we need to install Spyder in the new virtual environment. First make sure
    you’ve activated the virtual environment. Then run this command:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'To then launch Spyder, execute the following command in the same terminal with
    the virtual environment activated:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Summary
  id: totrans-613
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned the four variable types and how to convert one
    type to another. You also learned how functions work in Python. You learned three
    ways to import a module into a script and the pros and cons of each approach.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: You also created your own functions. You created a local module and imported
    it to a script to make clean and concise code. Finally, you created and activated
    a virtual environment in order to separate packages in different projects.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 3, you’ll learn how to install speech recognition–related modules
    to make Python understand the human voice.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  id: totrans-617
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assume:'
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-619
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: What is the output from each of the following Python statements? First write
    down the answer and then run the command in Spyder to verify.
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-621
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Assume:'
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-623
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: What is the result from each of the following Python statements?
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Here are some examples of integers:'
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-627
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: What is the result from each of the following Python statements?
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: What is the output from each of the following Python statements?
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-631
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: What is the output from each of the following Python statements?
  id: totrans-632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: What is the output from each of the following Python statements?
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: What is the output from each of the following Python statements?
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Are the following variable names valid, and why?
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-639
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: The loop command `break` is used in the following script. What should the output
    be? First write down the answer and then run the command in Spyder and verify.
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: The loop command `continue` is used in the following script. What should the
    output be? First write down the answer and then run the command in Spyder and
    verify.
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-643
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: The loop command `pass` is used in the following script. What should the output
    be? First write down the answer and then run the command in Spyder and verify.
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: What is the output from each of the following commands? First write down the
    answer and then run the command in Spyder to verify it.
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-647
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-648
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-649
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: What is the value of `team_sales(50, 100, 120)` according to the defined function
    in this chapter?
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the module import method in the script *import_local_module.py* from
    the `from` `module` `import` `function` method to the `import` `module` method.
    Name the new script *import_local_module1.py* and make sure it produces the same
    output.
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Grades for the midterm project of eight groups in a class are in a list `midterm
    = [95, 78, 77, 86, 90, 88, 81, 66]`. Use Python built-in functions on the list
    to calculate the range and the average of the grades.
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assume `inp = "University of Kentucky"`, and determine `inp[5:10]`, `inp[-1]`,
    `inp[:10]`, and `inp[5:]`.
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `email = John.Smith@uky.edu`, what is `email.find("y")`?
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assume `llst = [[1,2,3,5],[2,2,6,8],[2,3,5,9],[3,5,4,7],[1,3,5,0]]`. What are
    the values of `llst[2]`, `llst[2][2]`, and `llst[3][0]`?
  id: totrans-655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the output from each of the following Python statements?
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-657
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Assume `scores2 = {'blue':[5, 5, 10], 'white':[5, 7, 12]}`. What is `scores2['blue'][2]`?
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is an example of a tuple: `tpl = (1, 2, 3, 9, 0)`. What is `tpl[3:4]`?'
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You have a list `lst = [1, "a", "hello", 2]`. Create a dictionary with four
    key-value pairs: the key is the position of each element in `lst`, and the value
    is the element at that position.'
  id: totrans-660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
