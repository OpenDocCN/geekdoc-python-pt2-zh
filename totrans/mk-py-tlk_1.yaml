- en: Part I
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting Up Python, Anaconda, and Spyder
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Even if you’ve never coded before, this chapter will guide you through installing
    the Python software you need to start running Python scripts for this book. We’ll
    be using Anaconda and Spyder, so we’ll discuss the advantages of choosing this
    Python distribution and development environment, respectively. I’ll guide you
    through the installation process based on your operating system, whether that’s
    Windows, Mac, or Linux. Then you’ll learn how to start coding in the Spyder editor.
    We’ll discuss basic Python rules and operations at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Before you begin, set up the folder */mpt/ch01/* for this chapter on your computer.
    All scripts in this chapter (and later chapters) are available at the book’s resources
    page, [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Anaconda and Spyder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways to install Python and run scripts. In this book, we’ll use
    Anaconda and Spyder.
  prefs: []
  type: TYPE_NORMAL
- en: '*Anaconda* is an open source Python distribution, package, and environment
    manager. It is user friendly and provides for the easy installation of many useful
    Python modules that otherwise can be quite a pain to compile and install yourself.
    We’ll start by downloading the Anaconda distribution of Python that comes bundled
    with Spyder.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Spyder* is a full-featured integrated development environment (IDE) for writing
    scripts. It comes with many useful features such as automatic code completion,
    automatic debugging, code suggestions, and warnings.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Anaconda and Spyder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python is a cross-platform programming language, meaning you can run Python
    scripts whether you use Windows, Mac, or Linux. However, the installation of software
    and modules can be slightly different depending on your operating system. I’ll
    show you how to install various modules in your operating system. Once these are
    properly installed, Python code works the same in different operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Install Anaconda and Spyder in Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To install Anaconda in Windows, go to [https://www.anaconda.com/products/individual/](https://www.anaconda.com/products/individual/)
    and download the latest version of Python 3 for Windows.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend using the graphical installer instead of the command line installer,
    especially for beginners, to avoid mistakes. Make sure you download the appropriate
    32- or 64-bit package for your machine. Run the installer and follow the instructions
    all the way through.
  prefs: []
  type: TYPE_NORMAL
- en: Find and open the Anaconda navigator, and you should see a screen like [Figure
    1-1](#figure1-1) (if you need to, search for *Anaconda navigator* in the search
    bar).
  prefs: []
  type: TYPE_NORMAL
- en: '![f01001](Images/f01001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-1: The Anaconda navigator'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Launch** button under the Spyder icon. If Spyder is not already
    installed, click **Install** to install the Spyder development environment. After
    it finishes, click **Launch**.
  prefs: []
  type: TYPE_NORMAL
- en: Install Anaconda and Spyder in macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To install Python via Anaconda for macOS, go to [https://www.anaconda.com/products/individual/](https://www.anaconda.com/products/individual/),
    scroll down, and download the latest version of Python 3 for Mac. Choose the graphical
    installer and follow the instructions through.
  prefs: []
  type: TYPE_NORMAL
- en: Open the Anaconda navigator by searching for *Anaconda navigator* in Spotlight
    search. The screen for the Anaconda navigator in macOS should look similar to
    [Figure 1-1](#figure1-1), perhaps with slight differences.
  prefs: []
  type: TYPE_NORMAL
- en: To launch Spyder, click **Launch** under the Spyder icon (if you see an **Install**
    button instead, click it to install Spyder first).
  prefs: []
  type: TYPE_NORMAL
- en: Install Anaconda and Spyder in Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The installation of Anaconda and Spyder in Linux involves more steps than for
    other operating systems. First, go to [https://www.anaconda.com/products/individual/](https://www.anaconda.com/products/individual/),
    scroll down, and find the latest Linux version. Choose the appropriate x86 or
    Power8 and Power9 package. Click and download the latest installer bash script.
    For example, the installer bash script during my installation was [https://repo.anaconda.com/archive/Anaconda3-2020.11-Linux-x86_64.sh](https://repo.anaconda.com/archive/Anaconda3-2020.11-Linux-x86_64.sh).
    This link will change over time, but we’ll use this version as our example.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the installer bash script is downloaded and saved to the *Downloads*
    folder on your computer. You should then install Anaconda as follows using the
    path for your bash script if it is different.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After pressing enter, you’ll be prompted to review and approve the license
    agreement. The last question in the installation process is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You should type `yes` and press enter in order to use the `conda` command to
    open Anaconda in a terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you need to activate the installation by executing this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To open Anaconda navigator, enter the following command in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You should see the Anaconda navigator on your machine, similar to [Figure 1-1](#figure1-1).
    To launch Spyder, click the **Launch** button under the Spyder icon (if you see
    an **Install** button instead, click it to install Spyder first).
  prefs: []
  type: TYPE_NORMAL
- en: Using Spyder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get you up and running, we’ll build a really simple script in Spyder. Then
    I’ll run through a few basic concepts that’ll be useful to know before you start
    coding for real.
  prefs: []
  type: TYPE_NORMAL
- en: Write Python in Spyder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier, Spyder is a full-featured IDE. Let’s start with a simple
    script. After you launch the Spyder development environment, you should see a
    layout like [Figure 1-2](#figure1-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![f01002](Images/f01002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-2: Spyder development environment'
  prefs: []
  type: TYPE_NORMAL
- en: Spyder comes with several predefined layouts, and you can customize layouts
    according to your preferences. The default layout has three panels. Let’s examine
    that default.
  prefs: []
  type: TYPE_NORMAL
- en: At the left is the *Spyder editor*, in which you can write Python code. At the
    top right is the *variable explorer*, which shows the details of the data generated
    by your script. As scripts become quite complicated, the variable explorer becomes
    a valuable asset in double-checking the values stored in your variables.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom right is the *interactive Python (IPython) console*, which shows
    the output of the script or executes snippets of Python code. The IPython console
    is also where you enter input for scripts that require user information. It also
    displays error messages if you make a mistake in your script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s start coding. Go to the Spyder editor window (again, the default
    location is on the left) and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Click **File**▶**Save As** and save the file as *my_first_script.py* in your
    chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways to run scripts, and all lead to the same outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the **Run** menu and select **Run**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press F5 on your keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the green triangle icon ► in the icons bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the script and you should see something like [Figure 1-3](#figure1-3).
    The output, shown in the IPython console, is a simple printed message: `This is
    my very first Python script!` Congratulations—you have written and successfully
    run your first Python script!'
  prefs: []
  type: TYPE_NORMAL
- en: '![f01003](Images/f01003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-3: Running a script in the Spyder development environment'
  prefs: []
  type: TYPE_NORMAL
- en: Inspect Code in Spyder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besides running an entire script, Spyder has the ability to run code line by
    line or block by block. Running a piece of a script at a time is useful for carefully
    following the execution of a script, to verify that it does exactly what you intended
    it to do. Go back to the *my_first_script.py* example and add another line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Place your cursor over this second line and press F9, and you should see the
    output shown in [Figure 1-4](#figure1-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![f01004](Images/f01004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-4: Running just one line of code in the Spyder editor'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, only the highlighted line is executed. Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now press F5, and you’ll see that every line in the script is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To run a particular block of code, highlight those lines of code and press F9\.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Coding in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we get into the coding concepts of Python, you need to understand a few
    general things. This section introduces Python syntax and basic mathematical operations.
  prefs: []
  type: TYPE_NORMAL
- en: Python Syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, Python is case-sensitive. You should take great care when it comes to
    uppercase and lowercase letters. The variables *X* and *Y* are different from
    the variables *x* and *y*. The strings `"Hello"` and `"hello"` are also different
    from each other.
  prefs: []
  type: TYPE_NORMAL
- en: Second, indentations are significant in Python. Nonprinting characters like
    tabs must be consistently applied throughout a script. If you have experience
    with another programming language, like C or Java, you may notice the lack of
    brackets and semicolons in Python; this is by design. Blocks of code are defined
    by indentation. An unintended space in the code will likely betray your intentions,
    as we’ll see in Chapter 2 when we discuss indentations in conditional executions,
    loops, and functions.
  prefs: []
  type: TYPE_NORMAL
- en: Third, Python uses single quotation marks and double quotation marks (mostly)
    interchangeably. For example, placing a sequence of characters inside single quotes
    has the same effect as if we put them in double quotes (unless one of the characters
    is an escape character or a single quote).
  prefs: []
  type: TYPE_NORMAL
- en: 'Fourth, Python lets you make notes, known as *comments*. One popular way to
    write a comment uses the hash mark (`#`). Everything in the same line after `#`
    will not be executed. It’s good practice to make notes in your scripts so others
    can more easily understand what the code is doing—and to remind yourself of the
    decisions you’ve made when you revisit the code after a few weeks or a few months.
    For example, in the very first line in *my_first_script.py*, we have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since this line starts with `#`, Python ignores it, understanding that it’s
    a comment and not code to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have a comment that can’t fit on one line, you can place the comment
    in triple quotation marks (`"""`), and everything between the first set of quotes
    and the last set will not be executed by the Python script. For example, in lines
    2 to 6 in *my_first_script.py*, we have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: All those lines are ignored by Python.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Operations in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python is capable of basic math operations. For example, to calculate 7 multiplied
    by 123, you enter the following in the Spyder editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Place your cursor in this line, press F9, and you will get an output of 861.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 1-1](#table1-1) provides the other basic math operations in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 1-1: Basic Math Operators'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operators** | **Action** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | Addition: `print(5+6)` will give you a result of `11`. |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | Subtraction: `print(9-4)` will give you a result of `5`. |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | Division: `print(9/3)` will give you a result of `3`. |'
  prefs: []
  type: TYPE_TB
- en: '| `**` | Exponent: `print(5**3)` will give you a result of `125`. |'
  prefs: []
  type: TYPE_TB
- en: '| `%` | Remainder: `print(13%5)` will give you a result of `3` because 13 =
    5 × 2 + 3. |'
  prefs: []
  type: TYPE_TB
- en: '| `//` | Integer quotient: `print(13//5)` will give you a result of `2` because
    13 = 5 × 2 + 3. |'
  prefs: []
  type: TYPE_TB
- en: 'These operations have *precedence*, meaning they will execute in a particular
    order. That order of operations is as follows: operations within parentheses have
    highest priority, followed by exponents, then multiplication and division, which
    have the same priority and are executed from left to right. Addition and subtraction
    have the least priority and are treated equally, so whichever comes first is executed
    first.'
  prefs: []
  type: TYPE_NORMAL
- en: For more complicated mathematical operations, such as cosine in trigonometry
    or the natural logarithm, we need to import modules, which I’ll cover in Chapter
    2.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to install Python and Spyder via Anaconda.
    You also learned to run Python scripts by using Spyder.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 2, we’ll discuss the Python skills that you need for the rest of
    the book. You’ll learn the four main value types and how to convert one type to
    another. We’ll look at conditional execution and loops as well as how functions
    and modules work in Python, allowing you to accomplish more-complicated tasks.
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add a line of code to *my_first_script.py* so that it prints out a third message
    that says `Here is a third message!`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the output from each of the following Python statements? First write
    down the answers and then run the commands in Spyder to verify.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the command line in the Spyder editor if you want to find the result
    of 55 multiplied by 234?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python Refresher
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter is a refresher on basic Python. The purpose of this chapter is
    not to comprehensively review all the basic commands in Python. Instead, I’ll
    provide you with the Python skills that are most important to the rest of the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, you’ll learn the four Python variable types (strings, integers,
    floats, and Booleans) and how to convert one type to another. Functions are useful
    tools in programming languages, and you’ll learn to use built-in functions in
    Python and to import modules in the Python Standard Library.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also learn how functions work and how to define your own functions. Many
    modules we use in this book are not in the Python Standard Library, and you’ll
    learn different ways of installing these modules on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss how modules work and how to create your own self-made modules.
    You’ll then learn about a virtual environment, why it’s useful, and how to create
    and activate one.
  prefs: []
  type: TYPE_NORMAL
- en: Python uses strings, lists, dictionaries, and tuples as collections of elements
    to accomplish complicated tasks. In this chapter, you’ll learn these four types
    of collections, one by one. You’ll also see examples of their uses.
  prefs: []
  type: TYPE_NORMAL
- en: Before you begin, set up the folder */mpt/ch02*/ for this chapter. As in Chapter
    1, all scripts in this chapter are available at the book’s resources page, [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
  prefs: []
  type: TYPE_NORMAL
- en: Variables and Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *variable* is a reserved memory location to store values in Python (and in
    other programming languages). We can assign values to variables and use the variable
    name to recall the associated value. Python has four types of values: strings,
    floats, integers, and Booleans.'
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *string* is a sequence of characters inside quotation marks, often used to
    represent text. Here are some examples of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find out the type that a variable contains by using the `type()` function.
    Enter the following in the Spyder editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After execution, you’ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This means both variables have string values. You can add or multiply strings,
    but not in the traditional mathematical sense; instead, you can join strings or
    repeat them. For example, say you run the following two lines of code in the Spyder
    editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The plus sign joins two strings together, while multiplying a string by 3 means
    to repeat the characters in the string three times. Note that I’ve deliberately
    left an empty space at the end of the string `University of Kentucky`, so that
    when they join together, there is a space between the strings.
  prefs: []
  type: TYPE_NORMAL
- en: Floats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Floating-point numbers*, also known as just *floats*, are a number type that’s
    equivalent to decimal numbers in mathematics. Here are two examples of floats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `round()` function to restrict a float to a certain number
    of digits after the decimal point. Floats can be positive, negative, or zero.
    Run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You will have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Floats are used to perform calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Integers* are another number type; they can’t have decimal places and so must
    be whole numbers. Integers are used mainly for indexing purposes in Python. Integers
    can be positive, negative, or zero. Here are some examples of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to know that floats always have decimals, while integers do
    not. You never need to tell Python what type you want to use; instead, it can
    tell by the information you give it. Python knows you’re using an integer if you
    enter a number without any quote marks and without decimal places. Even if you
    round a float number to zero digits after a decimal, you would still get a decimal
    point and a 0 trailing the number. Run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You will have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that all three variables, `a`, `b`, and `c`, are integers.
    You will not get an output of `7` from `print(round(7.346,0))`, because using
    the decimal is Python’s way of telling an integer apart from a float.
  prefs: []
  type: TYPE_NORMAL
- en: Bools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Booleans*, or *bools*, are binary variables that can take only the value of
    `True` or `False`. Note that the first letter in `True` or `False` must always
    be uppercase. We use bools to find out truths about our code and make logical
    statements. As an example, run these two lines of code that compare two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The results show that the logic statement `4 > 5` is `False`, while the logic
    statement `10 >= 6` is `True`. The values `True` or `False` (without quotes) are
    not strings but are special values reserved by Python. Try the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, once you put `4 > 5` inside quotation marks, it becomes a string
    variable instead of a bool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bools can also be represented with `1` (or, in reality, anything that’s nonzero)
    for `True` and `0` for `False`. Run this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'It outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `bool()` function converts any nonzero value to `True` and `0` to `False`.
    Run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And you will get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Convert Variable Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can convert the type of a variable by using the functions `str()`, `int()`,
    `bool()`, and `float()`, but only if the type you’re trying to convert is compatible
    with the resulting type. For example, you can convert the string variable `"17"`
    to an integer or a float by using `int("17")` or `float("17")`, because 17 is
    a number that can be recognized as an integer or float. However, you cannot convert
    the string `"Kentucky"` to either an integer or a float.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Bool values `True` and `False` can be converted to integers `1` and `0`, respectively,
    because `1` and `0` are often used to represent `True` and `False`. While the
    float number `17.0` and string variable `"88"` can be converted to integers, the
    string variable `"3.45"` can’t be converted to an integer because it has values
    after the decimal point.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can convert almost anything into a string variable; for example, the float
    number `17.0` can be converted to the string variable `"17.0"`. You can also convert
    any integer to a float: for example, the integer `–4` can be converted to the
    float `–4.0`.'
  prefs: []
  type: TYPE_NORMAL
- en: Rules for Variable Names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Certain rules exist for naming variables, and not everything can be used as
    a variable name. A variable name must start with a letter (either uppercase or
    lowercase) or an underscore (`_`). For example, you can’t use `8python` as a variable
    name because it starts with a number.
  prefs: []
  type: TYPE_NORMAL
- en: The only special character a variable name can have is the underscore, so special
    characters such as `@` or `&` are not allowed. See the Python naming conventions
    at [https://www.python.org/dev/peps/pep-0008/#id34/](https://www.python.org/dev/peps/pep-0008/#id34/)*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Variable names can’t be Python keywords or Python built-in functions. To get
    the list of all keywords, run these two lines of code in the Spyder editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is a full list of Python keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Variable names can, however, *contain* keywords. For example, `first_break`
    and `class1` are valid variable names, even though `break` and `class` are not.
  prefs: []
  type: TYPE_NORMAL
- en: Variable names should not be Python built-in functions. [Figure 2-1](#figure2-1)
    lists those functions, which are found in the Python documentation at [https://docs.python.org/3/library/functions.html](https://docs.python.org/3/library/functions.html)*.*
    You would do well to familiarize yourself with the list and avoid using these
    terms as variable names.
  prefs: []
  type: TYPE_NORMAL
- en: '![f02001](Images/f02001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-1: List of Python built-in functions'
  prefs: []
  type: TYPE_NORMAL
- en: Loops and Conditional Execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Loops and conditional statements let you make decisions in your code, so that
    certain code will run if a particular thing happens.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `if` statement allows your code to take particular actions based on whether
    a condition is met. Consider the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, `x > 0` is the condition. If the value of `x` is larger than 0, the condition
    is met, and the script prints the message `x is positive`. Conditionals in Python
    always need a colon (`:`) after the conditional statement. If the condition is
    not met, the script moves to the `else` branch and prints `x is nonpositive`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also have more than two conditions by using the `elif` keyword. Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Python uses the double equal sign (`==`) as a comparison operator, to distinguish
    it from value assignments when we use a single equal sign (`=`). This script has
    three possible outcomes, depending on which condition is met: `x is positive`,
    `x is zero`, or `x is negative`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we require more than three conditions, the first condition must follow the
    `if` statement, the last condition must come after the `else` statement, and all
    conditions between should have the `elif` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The script prints out the letter grade based on the value of the score: A if
    the score is greater or equal to 90; if not, B if the score is above 80, and so
    on.'
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One great advantage of computers is their ability to repeat the same tasks
    many times at a fast rate. This is known as *looping*, or *iterating*, in programming.
    Python has two types of loop: the `while` and the `for` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: The while Loop
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A `while` loop is used to execute a block of code as long as a certain condition
    is met. Here we use the `while` statement to create a loop that adds 1 to the
    variable `n` every time it loops until `n` reaches `3`. Then the loop exits, and
    the script prints `finished`. Save this as *whileloop.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We first assign `n` a value of `0`. Then, the script starts the `while` loop
    with the condition `n < 3`. As long as the condition is met, the loop keeps running.
    Notice the colon, which tells Python to expect the indented lines that follow
    as part of the loop. Those lines will execute every time the loop runs. The last
    line, which is not indented, runs only after the loop exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first iteration, the value of `n` increases from `0` to `1`, and the
    updated value of `n` is printed out. In the second iteration, the value of `n`
    increases to `2`, and the updated value of `n` is printed out. In the third iteration,
    the value of `n` increases to `3`, and `3` is printed out. When the script goes
    to the fourth iteration, the condition `n < 3` is no longer met, and the loop
    stops. After that, the last line is executed. As a result, we see the following
    output from *whileloop.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `while` loop is most useful when we don’t know the number of iterations
    we need beforehand, even though it can also be used to perform the same tasks
    as a `for` loop. Later in this book, we often use the statement `while True` to
    create an infinite loop that puts the script in standby mode.
  prefs: []
  type: TYPE_NORMAL
- en: The for Loop
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `for` loop is generally used when you want to execute a block of code a
    fixed number of times. The following script, *forloop.py*, is an example of a
    `for` loop that does the same as the `while` loop we just made, adding 1 to the
    variable `n` until `n` reaches `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We start by using `range()`, a built-in function in Python, to produce a range
    of values from 0 to 2 (Python always begins counting from 0). The line tells the
    script to loop through the three values, one value per loop, and execute the next
    two lines of code for each value, adding 1 to `n` per loop. When the range has
    been used up, the loop exits, and we print `finished`.
  prefs: []
  type: TYPE_NORMAL
- en: The code in *forloop.py* produces the same output as *whileloop.py*.
  prefs: []
  type: TYPE_NORMAL
- en: Loops in Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can place a loop inside another loop. This is known as *nesting*. Nested
    loops are useful when, for each iteration in the outer loop, you need to repeat
    certain jobs for each iteration in the inner loop. The example script *loop_in_loop.py*
    loops through a list and a tuple, printing each member of the list with each member
    of the tuple, one pair per iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we start the outer loop with `for`, and then the first indented line
    starts the inner loop. The script takes the first value in the outer loop, goes
    through all iterations in the inner loop, and prints a message at each iteration.
    It repeats the process again with the second value of the outer loop. We need
    to indent the content of the inner loop twice so the script knows which lines
    belong to which loops. The final output from *loop_in_loop.py* is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we use the `f"{}"` string-formatting approach. The string `f"this
    is {``letter``}{``num``}"` tells Python to replace whatever is in the curly brackets
    with the actual value of the variable mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: You can nest loops pretty much indefinitely, and the script will iterate through
    all values in the innermost loop for each combination of values in the medium
    and outer loops. However, nesting too many loops can make your code difficult
    to read and isn’t generally recommended practice.
  prefs: []
  type: TYPE_NORMAL
- en: Loop Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Loops have a few commands that are useful for controlling the way your loops
    behave—namely, `continue`, `break`, and `pass`. These commands allow you to make
    decisions within a loop by using the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: continue
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `continue` command tells Python to stop executing the rest of the commands
    for the current iteration and to go to the next iteration. You use `continue`
    when you want to skip certain actions when certain conditions are met in a loop.
    For example, the script *forloop1.py* uses the `continue` command to skip printing
    the number 2 and go to the next iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'When the value of `n` is `2`, line 1 will not be executed because the `continue`
    command tells the script to skip it and go to the next iteration. The output from
    this script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: break
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `break` command tells Python to break the loop and skip all remaining iterations.
    You use `break` when you want to exit the loop. The example script *forloop2.py*
    uses the `break` command to exit the `for` loop when the number reaches value
    `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When the value of `n` is `2`, the whole loop stops and the script goes to line
    1 directly. The output is therefore as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Later in this book, we’ll frequently use the `break` command to tell the script
    to stop the infinite loop generated by the statement `while True`.
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `pass` command tells Python to do nothing, and it is used when a command
    line is needed but no action needs to be taken. We often use it along with `try`
    and `except`, and we’ll revisit this command later in this book. The script *forloop3.py*
    uses a `pass` command to tell the script to take no action when the value of the
    number is `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'When the value of `n` is `2`, no action needs to be taken. Therefore, here’s
    the output from the preceding script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This is the same as the output from *forloop.py*.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *string* is a sequence of characters inside single or double quotation marks.
    The characters in the string can be letters, numbers, whitespace, or special characters.
    We’ll discuss how elements in a string are indexed, how to slice them, and how
    to join multiple strings together.
  prefs: []
  type: TYPE_NORMAL
- en: String Indexing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The characters in strings are indexed from left to right, starting at 0\. This
    is because Python uses *zero-based indexing*, so the first element is always indexed
    as 0 instead of 1\.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access characters in a string by using the square bracket operator
    and the index of the character you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `e` is the second character in the string `"hello"`, the output is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Python also uses *negative indexing*, which starts from the end of the string.
    The last character in the string can be indexed as `[-1]`, the second-to-last
    one as `[-2]`, and so on. This is useful when you have a long string and want
    to locate characters at the end of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the third-to-last character of the string `msg`, you’d use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: String Slicing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Slicing* a string means taking out a subset of characters. We again use the
    square bracket operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The code `msg[``a``:``b``]` gives you the substring from position `a` to position
    `b` in the string `msg`, where the character in position `a` is included in the
    substring but the character in position *b* is not. Therefore, `msg[0:3]` produces
    a substring of the first three characters in the string `msg`.
  prefs: []
  type: TYPE_NORMAL
- en: String Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ll cover a few common string methods we’ll use throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: replace()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `replace()` method replaces certain characters or substrings in the string
    with other characters. It takes two arguments: the character you want to replace
    and the character to replace it with. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We use `replace()` to replace all whitespaces with the plus sign. The output
    from the preceding script is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This method will be useful later in the book, when we deal with the speech recognition
    feature. We’ll use `replace()` to change the voice text from the speech engine
    to a suitable format for the script.
  prefs: []
  type: TYPE_NORMAL
- en: lower()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `lower()` method converts all uppercase letters in a string to lowercase.
    Since Python strings are case-sensitive, converting all letters to lowercase when
    matching strings means we won’t miss uppercase substrings that should match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we want to capture the spoken phrase “department of education” via a speech
    recognition module. We can’t be sure whether the phrase will be captured as `Department
    of Education` or not. You can use `lower()` to convert the phrase to an all lowercase
    string to avoid mismatches, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The script tests whether the two strings `inp` and `inp1` are the same when
    we ignore case-sensitivity. Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: find()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can use `find()` to locate the position of a character in a string. The
    method returns the index of the character in the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following lines of code into the Spyder editor and save it as *extract_last_name.py*;
    then run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The string variable `email` has a pattern: it consists of the first name, the
    dot, and the last name, followed by `@uky.edu`. We use this pattern to locate
    the positions of the dot and the at sign, then retrieve the last name based on
    those two positions.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we get the position of `.` and define it as a variable `pos1`. Then,
    we find the position of `@` and define it as `pos2`. Finally, we slice the string
    and take the characters between the two positions, returning the substring as
    the variable `last_name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the script should produce this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The indexes of `.` and `@` in the email are `4` and `10`, respectively, and
    the last name is `Smith`.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the string method `find()` to locate a substring. The method
    returns the starting position of the substring in the original string. For example,
    if you run the following lines of code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'you’ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The output says that the substring `uky.edu` starts with the 12th character
    in the email.
  prefs: []
  type: TYPE_NORMAL
- en: split()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `split()` method splits a string into multiple strings, using the specified
    separator. Enter the following code in Spyder and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The default *delimiter* (a fancy name for *separator*) is a whitespace (`' '`).
    You can also specify the delimiter when you use `split()`. Let’s revisit the example
    of extracting the last name from an email address, naming the new script *split_string.py*,
    as in [Listing 2-1](#listing2-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-1: Using a delimiter to split up an email address'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first split the email into two parts by using `@` as the delimiter and assign
    the name and domain to a tuple. (We’ll discuss the definition of a *tuple* later
    in this chapter.) As a result, the first element in the tuple, the variable `name`,
    is a substring: `John.Smith`. The script then splits `John.Smith` into the first
    name and the last name, using `.` as the delimiter, and saves them in the tuple
    `(``first``,` `last``)`. Finally, we print out the second element in the tuple
    as the last name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: join()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `join()` method joins several strings into one, as in this script, *join_string.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We define `&` as the variable `mylink`, to be used as our separator. The `strlist`
    is a list of the three words that we want to join together. We use `join()` to
    combine the three words into one single string. Note that you need to put `join()`
    after the separator. Finally, we print out the joined string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *list* is a collection of values separated by commas. The values in a list
    are called *elements*, or *items*, and they can be values, variables, or other
    lists.
  prefs: []
  type: TYPE_NORMAL
- en: Create a List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a new list, you simply put the elements in square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the list `lst` with three elements: an integer number `1` and two
    strings. Note that `list()` is a built-in function in Python, so you cannot use
    `list` as a variable name or list name. I suggest that you use a descriptive name
    to help future readers understand the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You create an empty list by using a pair of square brackets with nothing in
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can use the `list()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Access Elements in a List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can access the elements of a list by using the bracket operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Here, `lst[2]` refers to the third element in the list, because Python is like
    most computer programming languages, which start counting at zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can traverse the elements of a list by using a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This give us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: We use the built-in function `len()` to return the length of the list, which
    is `3` in this case. The built-in function `range()` returns values `0`, `1`,
    and `2` here.
  prefs: []
  type: TYPE_NORMAL
- en: Use a List of Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A list can use lists as its elements. This is useful for mapping element positions
    to coordinates in a two-dimensional space. Here is one example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The list `llst` itself contains five lists. To find the value of `llst[1][2]`,
    the code first looks at the second item in the outer list `llst`, which is the
    list `[2, 2, 6, 8]`. The third element of that list is `6;` hence `llst[1][2]
    = 6`.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s draw a corresponding picture in a two-dimensional space, as in [Figure
    2-2](#figure2-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02002](Images/f02002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-2: Map a list of lists to a two-dimensional space'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use this in Part III to create boards for our interactive games.
  prefs: []
  type: TYPE_NORMAL
- en: Add or Multiply Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the plus (`+`) and multiplication (`*`) operators on lists, but
    not in the mathematical sense. For example, run the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The plus operator joins two lists into a larger list. The multiplication operator
    repeats the elements in the list. If you multiply a list by 3, the elements will
    appear three times.
  prefs: []
  type: TYPE_NORMAL
- en: List Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ll introduce several useful list methods here that we’ll use in later chapters
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: enumerate()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `enumerate()` method prints out all elements in a list with their corresponding
    indexes. Assume we have the following list `names`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The following lines of code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'will generate this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The first element at index `0` is Adam, the second at index `1` is Kate, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can choose the start value to be 1 instead of 0 with `start=1`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: append()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can append an element to the end of a list by using the `append()` method.
    Consider this script, *list_append.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is appending the element `2` to the existing list `lst`, producing
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The new `lst` now has four elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can append only one element at a time, and it is added to the end of the
    list by default. Appending two elements will lead to an error message. Change
    line 1 in the script *list_append.py* to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll get the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you can append multiple elements as a list. Add square brackets around
    the two numbers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The new list has four elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add two or more elements to the existing list, you should use the plus operator.
    For example, to add 2 and 3 as two separate elements to the list, you can use
    the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: remove()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can remove an element from a list by using `remove()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We remove the element that was at index 1, resulting in this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The new list no longer has element `a`. You can remove only one element at a
    time.
  prefs: []
  type: TYPE_NORMAL
- en: index()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can find the position of an element in a list by using the `index()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'From this we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The result tells you that the element `a` has an index of `1` in the list.
  prefs: []
  type: TYPE_NORMAL
- en: count()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can count how many times an element appears in a list by using `count()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: This tells us that the element `1` has appeared in the list twice, while the
    element `a` has appeared once.
  prefs: []
  type: TYPE_NORMAL
- en: sort()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can sort the elements in a list by using `sort()`. The elements must be
    the same type (or at least convertible to the same type). For example, if you
    have both integers and strings in a list, trying to sort the list will lead to
    the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Numbers are sorted from the smallest to the largest. Adding `reverse=True`
    inside the method as an option will reverse the ordering. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Letters are sorted in alphabetic order, and they come after numbers. Consider
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Use Built-in Functions with Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use several Python built-in functions on lists directly, including `min()`,
    `max()`, `sum()`, and `len()`. These produce the minimum value, the maximum value,
    the total sum, and the length of the list, respectively, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: list()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the `list()` function to convert a string to a list of characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly enough, Python strings can be treated just like lists of characters.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *dictionary* is a collection of key-value pairs. We create a dictionary by
    placing the elements inside curly brackets, as shown in [Listing 2-2](#listing2-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-2: Creating a dictionary with two key-value pairs'
  prefs: []
  type: TYPE_NORMAL
- en: 'The dictionary `scores` has two key-value elements, separated by a comma: the
    first element is the key `blue` and the value `10`, denoted by their position
    and separated by a colon. The second element is `''white'':12`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an empty dictionary, you use `dict()` or a pair of curly brackets
    with nothing within them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add a new element to the existing dictionary as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The line `Dict3['yellow'] = 6` assigns a value of `6` to the key `yellow`. The
    new `Dict3` contains the element `6`, which is accessible by the key `yellow`.
  prefs: []
  type: TYPE_NORMAL
- en: Access Values in a Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You access values in a dictionary by using the bracket operator. The key value
    in each pair acts as the index. For example, we can access the values in `scores`,
    built in [Listing 2-2](#listing2-2), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give you the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the `get()` method. The advantage of using `get()` is that
    it uses `None` as a default value when a user requests a key that isn’t in the
    dictionary, rather than returning an error. Consider the following script, *get_score.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Since the key `yellow` is not in `scores`, the method `get('yellow')` returns
    a value of `None`. Further, when you put the option `0` in the method, `get('yellow',
    0)` returns a value of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Use Dictionary Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the `keys()` method to produce a list of all keys in a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `values()` to produce a list of all values in a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: We can use `items()` to get the list of each key-value pair as a tuple (see
    “Tuples” on page 37).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: How to Use Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The values in a dictionary can be any type of variable, a list, or even another
    dictionary. Here we have a dictionary that uses lists as values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The value for each key is a three-element list. The three values represent
    the scores each player got in the first half and second half of the game and the
    total score, respectively. To find out how many points the white team got in the
    second half, you can call this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The advantage of a dictionary is that its key can be any value, not necessarily
    an integer. This makes dictionaries useful in many situations. For example, *most_freq_word.py*
    uses a dictionary to count words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: We define `news` as a string variable with a short paragraph. We then create
    an empty dictionary `wdcnt`. Next, we split the string into a list of separate
    words. We then count the frequency of each word and store the information in the
    dictionary, with the word as the key and the word count as the value. Because
    we use `get()`, if a word is not already in the dictionary as a key, the second
    argument in `get()` assigns a value of `0` to the word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we print out the words that have the highest frequency. The result
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: It turns out that the most frequent word in the news article is `and`, which
    is used three times.
  prefs: []
  type: TYPE_NORMAL
- en: Switch Keys and Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes you’ll want to switch the positions of keys and values. Now let’s
    take the term *dictionary* literally and suppose you have the following English-to-Spanish
    dictionary that uses the English word as the key and the Spanish translation as
    the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'You want to create a Spanish-to-English dictionary instead. You can accomplish
    this by using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The command `x,y in spanish.items()` retrieves all the key-value pairs in `spanish`.
    The command `y:x for x,y` switches the positions of the keys and values. You must
    put curly brackets around everything to the right of the equal sign so that the
    script treats it as a dictionary. To verify, enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'You will have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Combine Two Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To combine two dictionaries `x` and `y` into one large dictionary `z`, you
    assign `z = {**x, **y}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a new dictionary called `spanishenglish` with six elements: three
    pairs from `spanish` and three pairs from `english`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *tuple* is a collection of values separated by commas, similar to a list—with
    the big difference that a tuple cannot be changed after it’s defined (that is,
    tuples are immutable). Elements of a tuple exist inside parentheses instead of
    square brackets to distinguish the tuple from a list. Here we make a tuple and
    attempt to modify it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Because tuples are immutable, we cannot use methods like `append()` or `remove()`
    on them. We cannot sort the elements in a tuple either.
  prefs: []
  type: TYPE_NORMAL
- en: 'The elements of a tuple are indexed by integers, and we can access them by
    using the bracket operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Our output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: We saw examples of assigning values to a tuple in *split_string.py* ([Listing
    2-1](#listing2-1)).
  prefs: []
  type: TYPE_NORMAL
- en: You can compare two tuples. This process begins with comparing their first elements.
    If the first elements are the same, we check whether the second elements match.
    If the second elements are also the same, we go to the third elements, and so
    on, until we find a difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in your Spyder editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'And you’ll see this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *function* is (ideally) a block of code designed to do a task. There are many
    functions that do many things, but it is commonly considered best practice to
    have a function that performs only one task (and does not make changes to other
    variables). Some functions have defined parameters (inputs). We can assign the
    function code to a variable name so we don’t have to repeat the same code every
    time we need that task done. Instead, we just call the function and enter the
    inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Functions also improve readability, making the code more organized, less cluttered,
    and less error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: Use Built-in Python Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python comes with many built-in functions that you can readily use, including
    `print()` from Chapter 1. Here I’ll discuss a couple of built-in functions we’ll
    use frequently in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The range() Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `range()` function is used to produce a list of integers. We introduced
    `range()` when we discussed loops on page 21. We know that, for example, `range(5)`
    produces the values `[0, 1, 2, 3, 4]`. The default starting value generated by
    the function `range()` is `0`, because Python uses zero indexing, but you can
    also specify the starting value. For example, `range(3, 6)` produces the list
    of the following three values: `[3, 4, 5]`.'
  prefs: []
  type: TYPE_NORMAL
- en: The default increment value is `1`, but you can also specify the increment as
    the optional third argument. For example, the code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'will give this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: The third argument in `range(-5, 6, 2)` tells the script to increase the value
    by 2 for each element.
  prefs: []
  type: TYPE_NORMAL
- en: If the increment value is a negative integer, the values in the list decrease.
    For example, `range(9, 0, -3)` produces the list `[9, 6, 3]`.
  prefs: []
  type: TYPE_NORMAL
- en: The input() Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Text-to-speech* is the process of converting written text into human voice,
    so it’s important to know how Python takes written text inputs, using a built-in
    function called `input()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following script in Spyder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: You should see a screen similar to [Figure 2-3](#figure2-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![f02003](Images/f02003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-3: A screenshot of what happens when Python is asking for input'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in [Figure 2-3](#figure2-3), the script asks for your input
    in the lower-right IPython console. It waits for you to type some text and press
    enter before it continues to run. If you enter `blue`, the script will output
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'You can ask for multiple inputs, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: The script asks for two inputs. The sequence `\n` is an escape character, inserting
    a new line below the question “What is your first name?”
  prefs: []
  type: TYPE_NORMAL
- en: Define Your Own Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to using built-in functions, we can build our own. I’ll show you
    how to create a function, and this process will also show you how functions work.
    Functions can take one or more inputs, known as *arguments*, or no input at all.
  prefs: []
  type: TYPE_NORMAL
- en: A Function with No Argument
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ll start by building a function that prints the message `Finished printing`.
    This function takes no input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: We use `def` to signify a function definition, give a function name, and follow
    it with empty parentheses and a colon. The colon tells Python to expect the body
    of the function. All indented lines that follow are considered part of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script prints three numbers, after which we call the function. The output
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the command line in the function is executed only when the function
    is called, not when it is defined.
  prefs: []
  type: TYPE_NORMAL
- en: A Function with One Argument
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’ll write a function that takes one input. We need to write a thank-you
    note to 50 people. The message is the same except for the recipient’s name. We’ll
    define a function to print the message, and we need to supply only the name for
    each message when we call it. We first define a function called `msgs()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'The name of the function is `msgs`, with the variable `name` as its only input.
    If we call the function twice as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'the output will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'To write the 50 thank-you notes, you can call the function 50 times: once with
    each name.'
  prefs: []
  type: TYPE_NORMAL
- en: A Function with Multiple Arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Functions can have two or more arguments as inputs. Consider the script *team_sales.py*
    in [Listing 2-3](#listing2-3), which defines a function that needs three inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-3: Defining a function with three arguments'
  prefs: []
  type: TYPE_NORMAL
- en: We define a function to calculate the total sales from a team with three members.
    The function uses the sales from individual members, `sales1`, `sales2`, and `sales3`,
    as the three arguments. We calculate the total team sales, `sales`, by summing
    the three individual sales numbers. We then tell the script the output of the
    function by using the `return` command. As a result, when the function `team_sales()`
    is called, you get the sum of the three sales.
  prefs: []
  type: TYPE_NORMAL
- en: If the individual sales are 100, 150, and 120, when we call the function `team_sales()`,
    we’ll get an output of 370.
  prefs: []
  type: TYPE_NORMAL
- en: A Function That Takes an Unknown Number of Arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes the number of inputs is unknown. For example, you want to define a
    function to calculate the total sales made by a group of salespeople, but different
    groups have different numbers of salespeople. You can define a single function
    for this purpose that works regardless of the size of the group by using the argument
    `*args`, which allows you to pass multiple values of variable length to a function.
    [Listing 2-4](#listing2-4), *total_sales.py*, accomplishes the job.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-4: First part of *total_sales.py*'
  prefs: []
  type: TYPE_NORMAL
- en: We start `total_sales()`, which takes `*args` as the argument. We set the value
    of the variable `total` to `0` and then loop through each element in the argument
    `args`. For each element in the argument, we add it to the variable `total`. We
    output the total sales of the group. Test it out with [Listing 2-5](#listing2-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-5: Second part of the script *t**otal_sales.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'From this, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the function takes the one argument, `*args`, but you can put
    as many elements in the function as you want.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are not limited to just the Python built-in functions. The Python Standard
    Library has many modules that provide other functions you can call from your own
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Import Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll discuss three ways of using a function from a module and the pros and
    cons of each approach.
  prefs: []
  type: TYPE_NORMAL
- en: Import the Module
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first way is to import the entire module. For example, to find the value
    of the cosine of a 30-degree angle, you can first import the *math* module. Then
    you can use the `cos()` function from the module by calling both the module name
    and the function name: `math.cos()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code in Spyder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: You’ll have an output of `0.15425144988758405`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to import the module before you call `math.cos()`*.* If you don’t
    import *math* and just run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Python will give you an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, you must always put the module name in front of the function name when
    you call the function. Enter the following two lines of code in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll get this error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: This is because Python doesn’t know where to find the `cos()` function, even
    though you have imported the *math* module.
  prefs: []
  type: TYPE_NORMAL
- en: Import the Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you want only one or two functions from a certain module, you can save time
    by importing just those one or two functions. This approach allows you to use
    the function name without having to append the module name. Enter the following
    two lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: You’ll get the correct output, `4.759421635875676`. We don’t need to use `math`
    because we told the script where to look for the two functions. This is particularly
    useful if you need to use the function dozens or hundreds of times in your script.
  prefs: []
  type: TYPE_NORMAL
- en: Use Asterisk Import
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If your script relies heavily on many functions in a module, you can potentially
    save time by importing all functions from the module by using asterisk import:
    `from module import *`. However, many in the Python community have cautioned against
    this approach because the `import *` statement can pollute your namespace, potentially
    interfering with functions you define (or functions from other modules). We won’t
    use this method in the book.'
  prefs: []
  type: TYPE_NORMAL
- en: Create Your Own Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Listing 2-3](#listing2-3), we defined `team_sales()` in *team_sales.py*
    and then called the function. You might need to calculate the total sales in many
    scripts. You can do so without rewriting the code in each script by building the
    function into a module.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first create a script called *create_local_module.py,* as shown in [Listing
    2-6](#listing2-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-6: Code for the local module'
  prefs: []
  type: TYPE_NORMAL
- en: This script defines `team_sales()` but does not call it. Next, create the new
    script *import_local_module.py* in [Listing 2-7](#listing2-7) and save it in the
    same folder as *create_local_module.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 2-7: Code to import the local module'
  prefs: []
  type: TYPE_NORMAL
- en: When you import a module, Python first looks in the directory the importing
    script is stored in, so the module must be in the same folder. This kind of module
    is known as a *local module*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the script, you’ll get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: The `team_sales()` function correctly calculates the total sales for three teams.
  prefs: []
  type: TYPE_NORMAL
- en: Local modules work the same as modules in the Python Standard Library, but they
    need to be stored in the folder Python expects them to be in.
  prefs: []
  type: TYPE_NORMAL
- en: 'For modules that you download, Python stores the file path of the downloaded
    module behind the scenes and follows that path when you import it. For example,
    the *tkinter* package is in the Python Standard Library we’ll use later in this
    book. When you install it, the files are placed under a specific path, which is
    something like the following on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: It’s buried like this so you don’t accidentally alter or misplace it, which
    would mean you could no longer use it.
  prefs: []
  type: TYPE_NORMAL
- en: Use Third-Party Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the main advantages of Python is that programmers can share modules with
    one another for free. Many of these modules are not in the Python Standard Library,
    including the module we’ll rely on for the text-to-speech and the speech recognition
    functionality. These external modules, known as *third-party modules*, can be
    installed separately. Before you do that, you need to check that the module isn’t
    already installed.
  prefs: []
  type: TYPE_NORMAL
- en: Check Installed Modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All modules in the Python Standard Library are automatically installed on your
    machine when you install Python. Other modules may also be installed when you
    download various software or modules. For example, when you install *pandas* in
    Chapter 14, about 23 other supporting modules will be installed because *pandas*
    depends on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check whether a module is installed on your computer already with the
    following in your Spyder editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: This will provide you with the list of all modules installed on your computer.
    However, it can take a long time for Python to list all the modules and for you
    to check them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can check whether a module is installed by trying to import
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: To check whether *pandas* is installed on your computer, run `import pandas`,
    and if you receive no error message, the module is already installed. If the output
    shows `ModuleNotFoundError`, you need to install it. Let’s see how.
  prefs: []
  type: TYPE_NORMAL
- en: Pip Install Modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *gTTS* module we’ll use in Chapter 4 is not included in Python Standard
    Library, so we’ll `pip` `install` it. Open the Anaconda prompt (in Windows) or
    a terminal (in Mac or Linux), and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Follow the onscreen instructions all the way through, and the *gTTS* module
    will be installed.
  prefs: []
  type: TYPE_NORMAL
- en: Conda Install Modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you can’t find the module you want through `pip` `install`, try `conda install`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll install the *yt* module by using the following in the Anaconda prompt
    (in Windows) or a terminal (in Mac or Linux):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Many people think `pip install` and `conda install` are the same, but they’re
    not. Pip is the Python packaging authority’s recommended tool for installing packages
    from the Python packaging index. You can install Python software only by using
    `pip install`. In contrast, Conda is a cross-platform package and environment
    manager that installs not only Python software but also packages in C or C++ libraries,
    R packages, or other software.
  prefs: []
  type: TYPE_NORMAL
- en: As you build more and more projects in Python, you’ll install many modules.
    Some modules may interfere with other modules, and different projects may use
    different versions of the same module. To avoid problems of clashing modules,
    I recommend you build a virtual environment for each project. A *virtual environment*
    is a way to isolate projects from each other.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Virtual Environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a virtual environment, open an Anaconda prompt (in Windows) or a
    terminal (in Mac or Linux). We’ll name the virtual environment for the projects
    in this book *chatting*. Enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: After pressing enter, follow the instructions onscreen and press **y** when
    the prompt asks you `y/n`. Once you have created the virtual environment on your
    machine, you need to activate it.
  prefs: []
  type: TYPE_NORMAL
- en: Activate the Virtual Environment in Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the Anaconda prompt (in Windows) or a terminal (in Mac or Linux), type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, you’ll see the following on your Anaconda prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: You can see the `(chatting)` prompt, which indicates that the command line is
    now in the virtual environment *chatting* that you’ve just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a Mac, you should see something similar to the following in the terminal
    (the username will be different):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'In Linux, you should see something similar to this on your terminal (the username
    will be different):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Set Up Spyder in the Virtual Environment in Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we need to install Spyder in the new virtual environment. First make sure
    you’ve activated the virtual environment. Then run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'To then launch Spyder, execute the following command in the same terminal with
    the virtual environment activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned the four variable types and how to convert one
    type to another. You also learned how functions work in Python. You learned three
    ways to import a module into a script and the pros and cons of each approach.
  prefs: []
  type: TYPE_NORMAL
- en: You also created your own functions. You created a local module and imported
    it to a script to make clean and concise code. Finally, you created and activated
    a virtual environment in order to separate packages in different projects.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 3, you’ll learn how to install speech recognition–related modules
    to make Python understand the human voice.
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the output from each of the following Python statements? First write
    down the answer and then run the command in Spyder to verify.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the result from each of the following Python statements?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here are some examples of integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the result from each of the following Python statements?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the output from each of the following Python statements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the output from each of the following Python statements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the output from each of the following Python statements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the output from each of the following Python statements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Are the following variable names valid, and why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The loop command `break` is used in the following script. What should the output
    be? First write down the answer and then run the command in Spyder and verify.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The loop command `continue` is used in the following script. What should the
    output be? First write down the answer and then run the command in Spyder and
    verify.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The loop command `pass` is used in the following script. What should the output
    be? First write down the answer and then run the command in Spyder and verify.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the output from each of the following commands? First write down the
    answer and then run the command in Spyder to verify it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the value of `team_sales(50, 100, 120)` according to the defined function
    in this chapter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the module import method in the script *import_local_module.py* from
    the `from` `module` `import` `function` method to the `import` `module` method.
    Name the new script *import_local_module1.py* and make sure it produces the same
    output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Grades for the midterm project of eight groups in a class are in a list `midterm
    = [95, 78, 77, 86, 90, 88, 81, 66]`. Use Python built-in functions on the list
    to calculate the range and the average of the grades.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assume `inp = "University of Kentucky"`, and determine `inp[5:10]`, `inp[-1]`,
    `inp[:10]`, and `inp[5:]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `email = John.Smith@uky.edu`, what is `email.find("y")`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assume `llst = [[1,2,3,5],[2,2,6,8],[2,3,5,9],[3,5,4,7],[1,3,5,0]]`. What are
    the values of `llst[2]`, `llst[2][2]`, and `llst[3][0]`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the output from each of the following Python statements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Assume `scores2 = {'blue':[5, 5, 10], 'white':[5, 7, 12]}`. What is `scores2['blue'][2]`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is an example of a tuple: `tpl = (1, 2, 3, 9, 0)`. What is `tpl[3:4]`?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You have a list `lst = [1, "a", "hello", 2]`. Create a dictionary with four
    key-value pairs: the key is the position of each element in `lst`, and the value
    is the element at that position.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
