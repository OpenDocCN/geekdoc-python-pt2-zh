["```py\nimport RPi.GPIO as GPIO\nimport time\nimport argparse\nimport pyaudio\nimport wave\nimport numpy as np\n\n```", "```py\n# define pin numbers\n# uses TB6612FNG motor driver pin naming\nPWMA = 12\nPWMB = 13\nAIN1 = 7\nAIN2 = 8\nBIN1 = 5\nBIN2 = 6\nSTBY = 22\nLASER = 25\n\n```", "```py\n# global PWM objects\npwm_a = None\npwm_b = None\n# size of audio data read in\nCHUNK = 2048\n# FFT size\nN = CHUNK\n\n```", "```py\ndef init_pins():\n    \"\"\"set up pins\"\"\"\n  ❶ global pwm_a, pwm_b\n    # use BCM pin numbering\n  ❷ GPIO.setmode(GPIO.BCM)\n    # put pins into a list\n    pins = [PWMA, PWMB, AIN1, AIN2, BIN1, BIN2, STBY, LASER]\n    # set up pins as outputs\n  ❸ GPIO.setup(pins, GPIO.OUT)\n    # set PWM\n    pwm_a = GPIO.PWM(PWMA, 100)\n    pwm_b = GPIO.PWM(PWMB, 100)\n\n```", "```py\ndef laser_on(on):\n    # pin 25 controls laser ctrl mosfet\n    GPIO.output(LASER, on)\n\n```", "```py\ndef start_motors():\n    \"\"\"start both motors\"\"\"\n    # enable driver chip\n  ❶ GPIO.output(STBY, GPIO.HIGH)\n    # set motor direction for channel A\n  ❷ GPIO.output(AIN1, GPIO.HIGH)\n  ❸ GPIO.output(AIN2, GPIO.LOW)\n    # set motor direction for channel B\n    GPIO.output(BIN1, GPIO.HIGH)\n    GPIO.output(BIN2, GPIO.LOW)\n    # set PWM for channel A\n    duty_cycle = 10\n  ❹ pwm_a.start(duty_cycle)\n    # set PWM for channel B\n    pwm_b.start(duty_cycle)\n\n```", "```py\ndef stop_motors():\n    \"\"\"stop both motors\"\"\"\n    # stop PWM\n  ❶ pwm_a.stop()\n  ❷ pwm_b.stop()\n    # brake A\n    GPIO.output(AIN1, GPIO.HIGH)\n    GPIO.output(AIN2, GPIO.HIGH)\n    # brake B\n    GPIO.output(BIN1, GPIO.HIGH)\n    GPIO.output(BIN2, GPIO.HIGH)\n    # disable driver chip\n  ❸ GPIO.output(STBY, GPIO.LOW)\n\n```", "```py\ndef set_motor_speed_dir(dca, dcb, dira, dirb):\n    \"\"\"set speed and direction of motors\"\"\"\n    # set duty cycle\n  ❶ pwm_a.ChangeDutyCycle(dca)\n    pwm_b.ChangeDutyCycle(dcb)\n    # set direction A\n  ❷ if dira:\n        GPIO.output(AIN1, GPIO.HIGH)\n        GPIO.output(AIN2, GPIO.LOW)\n  ❸ else:\n        GPIO.output(AIN1, GPIO.LOW)\n        GPIO.output(AIN2, GPIO.HIGH)\n    if dirb:\n        GPIO.output(BIN1, GPIO.HIGH)\n        GPIO.output(BIN2, GPIO.LOW)\n    else:\n        GPIO.output(BIN1, GPIO.LOW)\n        GPIO.output(BIN2, GPIO.HIGH)\n\n```", "```py\ndef process_audio(filename):\n    print(\"opening {}...\".format(filename))\n    # open WAV file\n  ❶ wf = wave.open(filename, 'rb')\n    # print audio details\n  ❷ print(\"SW = {}, NCh = {}, SR = {}\".format(wf.getsampwidth(),\n        wf.getnchannels(), wf.getframerate()))\n    # check for supported format\n  ❸ if wf.getsampwidth() != 2 or wf.getnchannels() != 1:\n        print(\"Only single channel 16 bit WAV files are supported!\")\n        wf.close()\n        return\n    # create PyAudio object\n  ❹ p = pyaudio.PyAudio()\n    # open an output stream\n  ❺ stream = p.open(format=p.get_format_from_width(wf.getsampwidth()),\n                    channels=wf.getnchannels(),\n                    rate=wf.getframerate(),\n                    output=True)\n    # read first frame\n\n```", "```py\n  ❶ data = wf.readframes(CHUNK)\n  ❷ buf = np.frombuffer(data, dtype=np.int16)\n    # store sample rate\n  ❸ SR = wf.getframerate()\n    # start motors\n    start_motors()\n    # laser on\n    laser_on(True)\n\n```", "```py\n    # read audio data from WAV file\n    try:\n        # loop till there is no data to be read\n      ❶ while len(data) > 0:\n            # write stream to output\n          ❷ stream.write(data)\n            # ensure enough samples for FFT\n          ❸ if len(buf) == N:\n              ❹ buf = np.frombuffer(data, dtype=np.int16)\n                # do FFT\n              ❺ fft = np.fft.rfft(buf)\n              ❻ fft = np.abs(fft) * 2.0/N\n                # calc levels\n                # get average of 3 frequency bands\n                # 0-100 Hz, 100-1000 Hz, and 1000-2500 Hz\n              ❼ levels = [np.sum(fft[0:100])/100,\n                            np.sum(fft[100:1000])/900,\n                            np.sum(fft[1000:2500])/1500]\n\n```", "```py\n                # speed1\n              ❶ dca = int(5*levels[0])  percent 60\n                # speed2\n              ❷ dcb = int(100 + levels[1])  percent 60\n                # dir\n                dira = False\n                dirb = True\n              ❸ if levels[2] > 0.1:\n                    dira = True\n                # set motor direction and speed\n              ❹ set_motor_speed_dir(dca, dcb, dira, dirb)\n\n```", "```py\n            # read next\n          ❶ data = wf.readframes(CHUNK)\n  ❷ except BaseException as err:\n        print(\"Unexpected {}, type={}\".format(err, type(err)))\n  ❸ finally:\n            print(\"Finally: Pyaudio clean up...\")\n            stream.stop_stream()\n            stream.close()\n            # stop motors\n            stop_motors()\n\n```", "```py\ndef test_motors():\n    \"\"\"test motors by manually setting speed and direction\"\"\"\n    # turn laser on\n  ❶ laser_on(True)\n    # start motors\n  ❷ start_motors()\n    # read user input\n    try:\n        while True:\n          ❸ print(\"Enter dca dcb dira dirb (eg. 50 100 1 0):\")\n            # read input\n            str_in = input()\n            # parse values\n          ❹ vals = [int(val) for val in str_in.split()]\n            # sanity check\n            if len(vals) == 4:\n              ❺ set_motor_speed_dir(vals[0], vals[1], vals[2], vals[3])\n            else:\n                print(\"Input error!\")\n    except:\n        print(\"Exiting motor test!\")\n  ❻ finally:\n        # stop motors\n        stop_motors()\n        # turn laser off\n        laser_on(False)\n\n```", "```py\ndef main():\n    \"\"\"main calling function\"\"\"\n    # set up args parser\n  ❶ parser = argparse.ArgumentParser(description=\"A laser audio display.\")\n    # add arguments\n    parser.add_argument('--test_laser', action='store_true', required=False)\n    parser.add_argument('--test_motors', action='store_true', required=False)\n    parser.add_argument('--wav_file', dest='wav_file', required=False)\n    args = `parser`.`parse_args`()\n\n```", "```py\n    # initialize pins\n  ❶ init_pins()\n    # main loop\n    try:\n      ❷ if args.test_laser:\n            print(\"laser on...\")\n            laser_on(True)\n            try:\n                # wait in a loop\n                while True:\n                    time.sleep(0.1)\n            except:\n                # turn laser off\n                laser_on(False)\n      ❸ elif args.test_motors:\n            print(\"testing motors...\")\n            test_motors()\n      ❹ elif args.wav_file:\n            print(\"starting laser audio display...\")\n            process_audio(args.wav_file)\n    except (Exception) as e:\n        print(\"Exception: {}\".format(e))\n        print(\"Exiting.\")\n    # turn laser off\n  ❺ laser_on(False)\n    # call at the end\n  ❻ GPIO.cleanup()\n    print(\"Done.\")\n\n```", "```py\n$ `python laser_audio.py --test_motors`\ntesting motors...\nEnter dca dcb dira dirb (eg. 50 100 1 0):\n`30 40 0 1`\nEnter dca dcb dira dirb (eg. 50 100 1 0):\n`40 30 1 0`\n\n```", "```py\n`python3 laser_audio.py --wav_file bensound-allthat-16.wav`\n\n```", "```py\n    rms = np.sqrt(np.mean(x**2))\n\n    ```", "```py\n\"\"\"\nlaser_audio.py\nCreates a laser display that changes in time to music.\nUses Python on a Raspberry Pi.\nAuthor: Mahesh Venkitachalam\n\"\"\"\nimport RPi.GPIO as GPIO\nimport time\nimport argparse\nimport pyaudio\nimport wave\nimport numpy as np\n# define pin numbers\n# uses TB6612FNG motor driver pin naming\nPWMA = 12\nPWMB = 13\nAIN1 = 7\nAIN2 = 8\nBIN1 = 5\nBIN2 = 6\nSTBY = 22\nLASER = 25\n# global PWM objects\npwm_a = None\npwm_b = None\n# size of audio data read in\nCHUNK = 2048\n# FFT size\nN = CHUNK\ndef init_pins():\n    \"\"\"set up pins\"\"\"\n    global pwm_a, pwm_b\n    # use BCM pin numbering\n    GPIO.setmode(GPIO.BCM)\n    # put pins into a list\n    pins = [PWMA, PWMB, AIN1, AIN2, BIN1, BIN2, STBY, LASER]\n    # set up pins as outputs\n    GPIO.setup(pins, GPIO.OUT)\n    # set PWM\n    pwm_a = GPIO.PWM(PWMA, 100)\n    pwm_b = GPIO.PWM(PWMB, 100)\ndef laser_on(on):\n    \"\"\"turn laser MOSFET on/off\"\"\"\n    # pin 25 controls laser ctrl mosfet\n    GPIO.output(LASER, on)\ndef test_motors():\n    \"\"\"test motors by manually setting speed and direction\"\"\"\n    # turn laser on\n    laser_on(True)\n    # start motors\n    start_motors()\n    # read user input\n    try:\n        while True:\n            print(\"Enter dca dcb dira dirb (eg. 50 100 1 0):\")\n            # read input\n            str_in = input()\n            # parse values\n            vals = [int(val) for val in str_in.split()]\n            # sanity check\n            if len(vals) == 4:\n                set_motor_speed_dir(vals[0], vals[1], vals[2], vals[3])\n            else:\n                print(\"Input error!\")\n    except:\n        print(\"Exiting motor test!\")\n    finally:\n        # stop motors\n        stop_motors()\n        # turn laser off\n        laser_on(False)\ndef start_motors():\n    \"\"\"start both motors\"\"\"\n    # enable driver chip\n    GPIO.output(STBY, GPIO.HIGH)\n    # set motor direction for channel A\n    GPIO.output(AIN1, GPIO.HIGH)\n    GPIO.output(AIN2, GPIO.LOW)\n    # set motor direction for channel B\n    GPIO.output(BIN1, GPIO.HIGH)\n    GPIO.output(BIN2, GPIO.LOW)\n    # set PWM for channel A\n    duty_cycle = 0\n    pwm_a.start(duty_cycle)\n    # set PWM for channel B\n    pwm_b.start(duty_cycle)\ndef stop_motors():\n    \"\"\"stop both motors\"\"\"\n    # stop PWM\n    pwm_a.stop()\n    pwm_b.stop()\n    # brake A\n    GPIO.output(AIN1, GPIO.HIGH)\n    GPIO.output(AIN2, GPIO.HIGH)\n    # brake B\n    GPIO.output(BIN1, GPIO.HIGH)\n    GPIO.output(BIN2, GPIO.HIGH)\n    # disable driver chip\n    GPIO.output(STBY, GPIO.LOW)\ndef set_motor_speed_dir(dca, dcb, dira, dirb):\n    \"\"\"set speed and direction of motors\"\"\"\n    # set duty cycle\n    pwm_a.ChangeDutyCycle(dca)\n    pwm_b.ChangeDutyCycle(dcb)\n    # set direction A\n    if dira:\n        GPIO.output(AIN1, GPIO.HIGH)\n        GPIO.output(AIN2, GPIO.LOW)\n    else:\n        GPIO.output(AIN1, GPIO.LOW)\n        GPIO.output(AIN2, GPIO.HIGH)\n    if dirb:\n        GPIO.output(BIN1, GPIO.HIGH)\n        GPIO.output(BIN2, GPIO.LOW)\n    else:\n        GPIO.output(BIN1, GPIO.LOW)\n        GPIO.output(BIN2, GPIO.HIGH)\ndef process_audio(filename):\n    \"\"\"reads WAV file, does FFT and controls motors\"\"\"\n    print(\"opening {}...\".format(filename))\n    # open WAV file\n    wf = wave.open(filename, 'rb')\n    # print audio details\n    print(\"SW = {}, NCh = {}, SR = {}\".format(wf.getsampwidth(),\n        wf.getnchannels(), wf.getframerate()))\n    # check for supported format\n    if wf.getsampwidth() != 2 or wf.getnchannels() != 1:\n        print(\"Only single channel 16 bit WAV files are supported!\")\n        wf.close()\n        return\n    # create PyAudio object\n    p = pyaudio.PyAudio()\n    # open an output stream\n    stream = p.open(format=p.get_format_from_width(wf.getsampwidth()),\n                    channels=wf.getnchannels(),\n                    rate=wf.getframerate(),\n                    output=True)\n    # read first frame\n    data = wf.readframes(CHUNK)\n    buf = np.frombuffer(data, dtype=np.int16)\n    # store sample rate\n    SR = wf.getframerate()\n    # start motors\n    start_motors()\n    # laser on\n    laser_on(True)\n    # read audio data from WAV file\n    try:\n        # loop till there is no data to be read\n        while len(data) > 0:\n            # write stream to output\n            stream.write(data)\n            # ensure enough samples for FFT\n            if len(buf) == N:\n                buf = np.frombuffer(data, dtype=np.int16)\n                # do FFT\n                fft = np.fft.rfft(buf)\n                fft = np.abs(fft) * 2.0/N\n                # calc levels\n                # get average of 3 frequency bands\n                # 0-100 Hz, 100-1000 Hz, and 1000-2500 Hz\n                levels = [np.sum(fft[0:100])/100,\n                            np.sum(fft[100:1000])/900,\n                            np.sum(fft[1000:2500])/1500]\n                # speed1\n                dca = int(5*levels[0])  percent 60\n                # speed2\n                dcb = int(100 + levels[1])  percent 60\n                # dir\n                dira = False\n                dirb = True\n                if levels[2] > 0.1:\n                    dira = True\n                # set motor direction and speed\n                set_motor_speed_dir(dca, dcb, dira, dirb)\n            # read next\n            data = wf.readframes(CHUNK)\n    except BaseException as err:\n        print(\"Unexpected {}, type={}\".format(err, type(err)))\n    finally:\n            print(\"Finally: Pyaudio clean up...\")\n            stream.stop_stream()\n            stream.close()\n            # stop motors\n            stop_motors()\n            # close WAV file\n            wf.close()\ndef main():\n    \"\"\"main calling function\"\"\"\n    # set up args parser\n    parser = argparse.ArgumentParser(description=\"A laser audio display.\")\n    # add arguments\n    parser.add_argument('--test_laser', action='store_true', required=False)\n    parser.add_argument('--test_motors', action='store_true', required=False)\n    parser.add_argument('--wav_file', dest='wav_file', required=False)\n    args = parser.parse_args()\n    # initialize pins\n    init_pins()\n    # main loop\n    try:\n        if args.test_laser:\n            print(\"laser on...\")\n            laser_on(True)\n            try:\n                # wait in a loop\n                while True:\n                    time.sleep(1)\n            except:\n                # turn laser off\n                laser_on(False)\n        elif args.test_motors:\n            print(\"testing motors...\")\n            test_motors()\n        elif args.wav_file:\n            print(\"starting laser audio display...\")\n            process_audio(args.wav_file)\n    except (Exception) as e:\n        print(\"Exception: {}\".format(e))\n        print(\"Exiting.\")\n    # turn laser off\n    laser_on(False)\n    # call at the end\n    GPIO.cleanup()\n    print(\"Done.\")\n# call main\nif __name__ == '__main__':\n    main()\n\n```"]