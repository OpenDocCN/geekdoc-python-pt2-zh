- en: Part II
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning to Talk
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Speech Recognition
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll begin interacting with Python through speech. We’ll first
    install the *SpeechRecognition* module; the installation process can be a source
    of frustration and will therefore require some careful attention. You’ll then
    create a script to let Python recognize your speech and print it out to ensure
    that the voice recognition function works smoothly on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll use voice control to complete several tasks, including voice dictation,
    opening web browsers, opening files, and playing music on your computer. You’ll
    put all code related to speech recognition into a custom local module so the final
    script is concise and easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: Before you begin, set up the folder */mpt/ch03/* for this chapter. All scripts
    in this chapter are available at the book’s resources page, [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
  prefs: []
  type: TYPE_NORMAL
- en: Install the SpeechRecognition Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installing the *SpeechRecognition* module can be tricky, even to the point of
    frustration. Don’t panic; we’ll discuss how to install it in Windows, Mac, and
    Linux. Installing the *SpeechRecognition* module takes an extra step compared
    to most modules because it relies on the *pyaudio* module, which we’ll have to
    install manually. The *pyaudio* module provides bindings for the cross-platform
    audio input/output library *portaudio*.
  prefs: []
  type: TYPE_NORMAL
- en: You cannot `pip install` the *pyaudio* module in the Anaconda prompt either.
    Instead, you need to `conda install` it.
  prefs: []
  type: TYPE_NORMAL
- en: In Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, you need to activate the virtual environment *chatting* from Chapter
    2. Go to your Anaconda prompt and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a modified prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `(chatting)` in the prompt indicates that you are now in the virtual
    environment *chatting*. If the command hasn’t worked, return to Chapter 2 for
    full instructions on how to create and activate a virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, enter the following in the Anaconda prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you then try to import it and run a script, Spyder will tell you that you
    need the *pyaudio* module for the *SpeechRecognition* module to run correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the virtual environment *chatting* activated, run the following in your
    Anaconda prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Follow the instructions all the way through.
  prefs: []
  type: TYPE_NORMAL
- en: In Mac or Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, activate the virtual environment *chatting*. Open a terminal and enter
    and execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, execute the following in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now try to import *SpeechRecognition* and run a script, Spyder will
    tell you that you need *pyaudio* for *SpeechRecognition* to run correctly. With
    the virtual environment *chatting* activated, run the following command in your
    terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Follow the instructions all the way through.
  prefs: []
  type: TYPE_NORMAL
- en: Test and Fine-Tune SpeechRecognition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll next test and fine-tune the *SpeechRecognition* module so Python can take
    your voice commands.
  prefs: []
  type: TYPE_NORMAL
- en: Import SpeechRecognition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To import *SpeechRecognition* in your Python scripts, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there is a small difference in the module name when you install it
    and when you import it: one is *SpeechRecognition* and the other is *speech_recognition*.
    Make sure you don’t miss the underscore in the module name when you import it.'
  prefs: []
  type: TYPE_NORMAL
- en: You also need to have a microphone plugged into the computer if you’re using
    a desktop. Most laptops come with a built-in microphone, but sometimes having
    an external one is convenient so you can speak close to the microphone and avoid
    ambient noise.
  prefs: []
  type: TYPE_NORMAL
- en: Test SpeechRecognition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, let’s test the hardware and software. Enter [Listing 3-1](#listing3-1)
    into your Spyder editor and save it as *sr.py*, or you can download the file from
    the book’s resources.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-1: Testing *SpeechRecognition*'
  prefs: []
  type: TYPE_NORMAL
- en: We import the *SpeechRecognition* module. Next, we call `Recognizer()` to initiate
    a *Recognizer* instance from the module so that your script is ready to convert
    voice to text. We save it as the variable `speech`. We also print a message that
    lets you know the microphone is ready to receive speech input.
  prefs: []
  type: TYPE_NORMAL
- en: We tell the script that the source of the audio comes from the microphone using
    `Microphone()`. We use the `adjust_for_ambient_noise()` method to reduce the impact
    of the ambient noise on your voice input. The script captures the voice input
    from the defined microphone, converts it into text, and saves in `inp`. We print
    out the value of `inp`.
  prefs: []
  type: TYPE_NORMAL
- en: Note in this script, the *Recognizer* instance uses `recognize_google()`for
    recognizing speech from the audio source. This method uses the Google Web Speech
    application programming interface (API) and requires a good internet connection.
    Other methods available to the *Recognizer* instance in the *SpeechRecognition*
    module include `recognize_bing()`, which uses Microsoft Bing Speech; `recognize_ibm()`,
    which uses IBM Speech to Text; and so on. The only method that works offline is
    `recognize_sphinx()`, which uses the services of CMU Sphinx. However, the accuracy
    with `recognize_sphinx()` is not nearly as good as with `recognize_google()`,
    so we’ll use `recognize_google()` throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run *sr.py* and say something simple, like “Hello” or “How are you?”, to test
    if Python correctly prints out your voice input. You should see the following
    if you say, “How are you?”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If the script is working, you’ve successfully installed the speech recognition
    feature. If not, double-check the previous steps and make sure your microphone
    is connected properly. Also make sure that you are in a relatively quiet area
    with a good internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that Python converts almost all voice input as lowercase text, which
    can be a good feature since string variables are case-sensitive. This way, Python
    won’t miss a command because of capitalization.
  prefs: []
  type: TYPE_NORMAL
- en: Fine-Tune the Speech Recognition Feature
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you’ll fine-tune the speech recognition code to make it more user-friendly
    for the rest of the book. We’ll use `try` and `except` on a few common errors
    to allow the execution of the code to continue after encountering errors, instead
    of causing the script to crash.
  prefs: []
  type: TYPE_NORMAL
- en: The common error `UnknownValueError` happens when the Google speech recognition
    server cannot understand the audio, either because the speech isn’t clear or because
    of ambient noise. The error `RequestError` happens when the Google speech recognition
    request fails, either because of a bad internet connection or because the server
    is too busy. The error `WaitTimeoutError` happens when the script doesn’t detect
    any audio from the microphone for a long period.
  prefs: []
  type: TYPE_NORMAL
- en: Without using `try` and `except`, the script crashes, and you have to start
    the script all over again. By using the exception-handling constructs, the script
    will continue without crashing. The errors I mentioned aren’t harmful enough to
    be worth handling, so our scripts will just allow those errors to pass.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-2](#listing3-2), *stand_by.py*, uses an infinite loop to first stand
    by and then repeatedly take voice inputs and print them out. This way, we don’t
    have to rerun the script every time we want the script to take our voice inputs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-2: Code for *stand_by.py*'
  prefs: []
  type: TYPE_NORMAL
- en: We start a `while` loop to put the script in standby. This way, after taking
    your voice input, the script prints out what you said and starts listening again.
    At each iteration, the script prints `Python is listening` so you know it’s ready.
    We define the variable `inp` as an empty string at the beginning of each iteration.
    Otherwise, if the user doesn’t say anything for a while, the script will retrieve
    the `inp` value from the previous iteration. By clearing the string, we avoid
    any potential mix-ups.
  prefs: []
  type: TYPE_NORMAL
- en: We use exception handling when connecting to the Google speech-recognition server
    1. If there is an `UnknownValueError`, a `RequestError`, or a `WaitTimeoutError`,
    we let the script continue without crashing.
  prefs: []
  type: TYPE_NORMAL
- en: At each iteration, the script prints what you said so that you can check if
    the speech recognition software has correctly captured your voice 2.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we don’t want the script to run forever, so we add a condition to stop
    it. When you say, “Stop listening,” the `if` branch is activated, the script prints
    `Goodbye!`, and the `while` loop stops.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a sample output, with my voice input in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Next, you’ll put the speech recognition feature to use in several projects.
    Some are practical and useful, and others are for building up skills for later
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Perform a Voice-Controlled Web Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first project is a script to navigate the web by using voice. You’ll learn
    to use the *webbrowser* module to open a browser on your computer. Then you’ll
    add voice-control functionality to open the browser and perform various searches
    online.
  prefs: []
  type: TYPE_NORMAL
- en: Use the webbrowser Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *webbrowser* module gives you tools to open a website by using the default
    browser on your computer. The module is in the Python Standard Library, so no
    installation is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the *webbrowser* module on your computer, enter the following lines
    of code in your Spyder editor and run them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We use `"http://"+` inside the `open()` function so that you need to input only
    the main body of the web address instead of the full URL. This is to prepare you
    for voice activation in the next section. The web browser will automatically correct
    the URL if it uses *https://* instead of *http://* or if *www* is in the full
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: A new web browser window should open on the *Wall Street Journal* website. Microsoft
    Edge is the default browser on my computer, and the result is shown in [Figure
    3-1](#figure3-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03001](Images/f03001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-1: Result of using the `webbrowser.open("http://"+"wsj.com")` command'
  prefs: []
  type: TYPE_NORMAL
- en: Add Voice Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll add the speech recognition feature. Save [Listing 3-3](#listing3-3)
    as *voice_browse.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-3: Code for *voice_browse.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We import the two modules needed for this script: *webbrowser* and *SpeechRecognition*.
    At 1, we define the `voice_to_text()` function, which contains most of the steps
    in *stand_by.py*: it starts with the empty string `voice_input`, converts the
    audio from the microphone to text, and puts it in `voice_input`. It also makes
    exceptions for the `UnknownValueError`, the `RequestError`, and the `WaitTimeoutError`.
    Once called, the function will return the value stored in `voice_input`.'
  prefs: []
  type: TYPE_NORMAL
- en: The script starts an infinite loop to continuously take voice input 2. At each
    iteration, it prints `Python is listening...` so you know it’s ready.
  prefs: []
  type: TYPE_NORMAL
- en: We call `voice_to_text()` to capture your voice input and save the converted
    text in `inp`. Note that I intentionally use a different variable name for the
    local variable `voice_input` and the global variable `inp` to avoid confusion.
  prefs: []
  type: TYPE_NORMAL
- en: If you say, “Stop listening” to the microphone, the `if` branch is activated.
    The script prints `Goodbye!` and stops running. If the word *browser* is in your
    voice command, the `elif` branch is activated. The script then puts `http://`
    and whatever you say next in the address bar and opens the web browser. For example,
    if you say “browser abc.com,” the `replace()` method will change “browser” and
    the space after it to an empty string, which effectively changes `inp` to `abc.com`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one sample output, with my voice input in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The associated web browser pop-ups are as shown in [Figure 3-2](#figure3-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03002](Images/f03002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-2: One of the sample outputs from *voice_browse.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You use the word *browser* instead of *browse* to ensure that the script understands
    you: if you say “Browse” to your microphone, Python might convert it to `brows`
    instead. You may encounter several instances where slight adjustments will need
    to be made. Since everyone has a different voice, microphone, and diction (accent,
    inflection, and intonation), your adjustments will likely be different from mine.'
  prefs: []
  type: TYPE_NORMAL
- en: Perform a Google Search
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll now modify *voice_browse.py* so you can voice-activate a Google search.
    All you need to change is this one line of code from *voice_browse.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Then save the modified script as *voice_search.py*. (You can also download it
    from the book’s resources page.)
  prefs: []
  type: TYPE_NORMAL
- en: Here we are using the fact that whenever Google performs a search, it puts the
    search term after *http://google.com/search?q=* and uses it as the URL in the
    address bar. For example, when you search `how many liters are in a gallon` in
    Google, you get the same result as if you entered the URL *http://google.com/search?q=how
    many liters are in a gallon*.
  prefs: []
  type: TYPE_NORMAL
- en: Run *voice_search.py* in your Spyder editor. Ask a question, like “Browser yards
    in a mile,” into the microphone. The script should open your default browser,
    perform a Google search for `yards in a mile`, and show a result similar to [Figure
    3-3](#figure3-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03003](Images/f03003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-3: The result when you say “browser yards in a mile”'
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the script in any way you use Google, for example, as a voice-controlled
    dictionary. If you want to know the exact definition of the word *diligence*,
    you can say, “Browser define diligence.”
  prefs: []
  type: TYPE_NORMAL
- en: Open Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the capability of speech recognition in a Python script, you can do many
    things with voice control. We’ll build a script to open various types of files,
    including text files, PDF files, and music files.
  prefs: []
  type: TYPE_NORMAL
- en: Use the os and pathlib Modules to Access and Open Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the *os* and *pathlib* modules to access files and folders on your
    computer. The *os* module accesses operating system functionalities such as *go
    to a folder*, *open a file*, and so on. However, the commands differ across operating
    system. For example, to open a file, the command is `explorer` in Windows, `open`
    in Mac, and `xdg-open` in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: To make your scripts portable cross-platform, we’ll use the *platform* module,
    which lets the script automatically identify your operating system and then choose
    the appropriate command for you. The *pathlib* module allows you to find out the
    file paths and specify a file or folder path. Luckily, *pathlib* is cross-platform,
    so you don’t have to worry about a forward slash or backslash. All three modules—*os*,
    *pathlib*, and *platform*—are in the Python Standard Library, so no installation
    is needed.
  prefs: []
  type: TYPE_NORMAL
- en: In your chapter folder, create a subfolder called *files* and save a file *example.txt*
    in it. Then enter [Listing 3-4](#listing3-4) in your Spyder editor and save it
    as *os_platform.py.*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-4: Code for *os_platform.py*'
  prefs: []
  type: TYPE_NORMAL
- en: We import the modules, then use `Path.cwd()` from *pathlib* to find the current
    working directory of the script. We’ll use this as the starting path to navigate
    from.
  prefs: []
  type: TYPE_NORMAL
- en: We then specify the path and name of the file we want to open. In the *pathlib*
    module, we use a forward slash to denote subfolders no matter what operating system
    you are using. The command `/'files'` tells the script to go to the subfolder
    *files*, and `/'example.txt'` indicates which file to define as *myfile*.
  prefs: []
  type: TYPE_NORMAL
- en: The `system()` method from the *os* module executes the command in a subshell.
    The `explorer` command opens a folder or a file on your computer in Windows. However,
    if you’re using Mac, the `system()` method in the *os* module uses the `open`
    command, and in Linux, the command is `xdg-open`. Therefore, the script opens
    the file *example.txt* in the subfolder *files*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say you’re using Windows and have saved the script in your chapter
    folder *C:\chat\mpt\ch03*. After running the script, you’ll have the following
    output in the IPython console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: At the same time, the file *example.txt* should open.
  prefs: []
  type: TYPE_NORMAL
- en: Open Files via Voice Control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll now demonstrate how to open various file types, like MP3; Microsoft Word,
    PowerPoint, and Excel; and PDF files. Before running the following script, save
    an MP3 file, a Word file, a PowerPoint file, an Excel file, and a PDF file in
    the subfolder *files* you just created in your chapter folder. Name the five files
    *presentation.mp3, lessons.docx, graduation.pptx, book.xlsx,* and *desk.pdf*,
    respectively. It’s best if the files are not too large.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-5](#listing3-5) shows *voice_open_file.py*, which can also be downloaded
    from the book’s resources page.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-5: Code for *voice_open_file.py*'
  prefs: []
  type: TYPE_NORMAL
- en: As with *voice_browse.py*, we define `voice_to_text()` to convert your voice
    command to text 1. We also define `open_file()` to identify your operating system
    and use the proper command, `explorer`, `open`, or `xdg-open`, to open the file
    on your computer. Note that while the Windows operating system uses a backward
    slash (`\`) to go to a subfolder, Mac and Linux use a forward slash (`/`) for
    that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The script is then put in standby mode by using a `while` loop 2. Within the
    loop, the microphone first detects your voice and converts it into text. Since
    we put the `lower()` method after `voice_to_text()`, all letters in the variable
    `inp` will be lowercase to avoid mismatch due to capitalization.
  prefs: []
  type: TYPE_NORMAL
- en: If you say, “Stop listening,” the script prints `Goodbye!` and stops running.
    If the words *open pdf* are in your voice command, the first `elif` branch is
    activated. The script then replaces `open pdf` with an empty string so only the
    filename is left in `inp`. The script goes to the subfolder and opens the proper
    PDF file. For example, when you say, “Open PDF desk,” the file *desk.pdf* will
    open on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: When you say, “Open Word lessons,” the second `elif` branch is activated. The
    same principle works for Excel files and PowerPoint files. And when you say, “Open
    audio presentation,” the audio file *presentation.mp3* will start playing on your
    computer, using the default MP3 player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output from my interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Create and Import a Local Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you have probably noticed, the three scripts *voice_browse.py*, *voice_search.py*,
    and *voice_open_file.py* share a large chunk of the same code: the code to import
    the speech recognition module and define the `voice_to_text()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: To make our scripts more efficient, we’ll put all command lines related to speech
    recognition in a local module. We can then import the module in any script that
    uses the speech recognition feature.
  prefs: []
  type: TYPE_NORMAL
- en: Create the Local Module mysr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Enter [Listing 3-6](#listing3-6) in your Spyder editor and save it as *mysr.py*.
    Alternatively, you can download it from the book’s resources page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-6: Code for the self-made module *mysr*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can ignore the first part of the code 1 if you aren’t using Linux. The
    Advanced Linux Sound Architecture (ALSA) configuration, which is coded in the
    C programming language, spits out warning messages like these every time the *pyaudio*
    module is imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We create an error handler in Python 2 and pass it to C so that you won’t see
    any error messages when you import *pyaudio*. The details are beyond the scope
    of this book, so it’s okay if you don’t understand this part. Just leave the error
    handler in the module *mysr*, and it won’t affect your understanding for the rest
    of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Starting at 3, we import the *SpeechRecognition* module, initiate the `Recognizer()`
    class, and define the `voice_to_text()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you run *mysr.py*, nothing will happen. This is because we just
    define `voice_to_text()` in this script and don’t call it.
  prefs: []
  type: TYPE_NORMAL
- en: Import mysr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s revisit *stand_by.py* and modify it to use *mysr*. Save [Listing 3-7](#listing3-7)
    as *stand_by1.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-7: Code for *stand_by1.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve replaced all speech recognition–related code with just one line: `from
    mysr import voice_to_text`. This line tells the script to go to the local module
    *mysr* and import `voice_to_text()` to be used in the current script.'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you need to convert speech to text, you simply call `voice_to_text()`
    1.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, we installed the *SpeechRecognition* module and used `try`
    and `except` to handle potential errors. In this way, we prevent the script from
    closing when we would rather it continue. We tested the voice control functionality
    with a few projects: voice-controlled web surfing and voice-controlled web search.'
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to use the *os* module to open files and the *pathlib* module
    to navigate through the file path, as well as the *platform* module to make your
    Python code cross-platform.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you put all code related to speech recognition into a self-made local
    module so that your scripts look concise, short, and clean. We’ll use this module
    throughout the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify *stand_by.py* so that you end the `while` loop by saying, “Quit the script”
    instead of “Stop listening,” and when the `while` loop ends, the script prints
    `Have a great day!`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *voice_open_file.py* so that when you say, “Open text filename,” *filename.txt*
    will open on your computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *voice_open_file.py* so that it imports `voice_to_text()` from the local
    *mysr* module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make Python Talk
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll learn how to make Python talk back to you in a human
    voice. You’ll first install the text-to-speech module based on your operating
    system and then teach Python to speak aloud whatever you enter on your computer.
    You’ll also add the speech recognition feature you learned in Chapter 3 and get
    Python to repeat your own speech. Finally, you’ll build a real-world application
    to use voice inputs to ask Python to calculate the area of a rectangle and tell
    you the answer in a human voice.
  prefs: []
  type: TYPE_NORMAL
- en: To save space, you’ll put all text-to-speech-related code in a self-made module.
    Once you do that, you can import the module into any script that needs the text-to-speech
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also learn how to ask Python to read a long text file, such as a news
    article, aloud. Before you begin, set up the folder */mpt/ch04/* for this chapter.
    As in previous chapters, you can download the code for all the scripts from [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
  prefs: []
  type: TYPE_NORMAL
- en: Install the Text-to-Speech Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python has two commonly used text-to-speech modules: *pyttsx3* and *gTTS*.
    If you use Windows, you’ll install *pyttsx3* and use it throughout the book. In
    the Windows operating system, the *pyttsx3* module works offline, has a human-like
    voice, and lets you adjust the speech properties—namely, the speed, volume, and
    gender of the voice output.'
  prefs: []
  type: TYPE_NORMAL
- en: However, the *pyttsx3* module works differently in Mac and Linux. The voice
    sounds robotic, and the speech properties are not easily adjustable. Therefore,
    you’ll install *gTTS* if you use Mac or Linux. The *gTTS* module requires an internet
    connection since it uses the Google Translate text-to-speech API. Further, *gTTS*
    does not play the sound directly. It saves the voice as an audio file or file-like
    object. You’ll have to use your own audio player to hear the voice. The voice
    generated by *gTTS* is very human-like.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 2, you built a virtual environment called *chatting*, which you then
    used for speech recognition in Chapter 3. You’ll install the *pyttsx3* or *gTTS*
    module in the same virtual environment so your script will have both the speech
    recognition and text-to-speech features.
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using Windows, go to the “Install *pyttsx3* in Windows” section and
    skip the “Install *gTTS* in Mac or Linux” section. Otherwise, skip the “Install
    *pyttsx3* in Windows” section and go to the “Install *gTTS* in Mac or Linux” section.
  prefs: []
  type: TYPE_NORMAL
- en: Install pyttsx3 in Windows
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *pyttsx3* module is not in the Python standard library, so you’ll need to
    install it via pip.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven’t already set up your *chatting* virtual environment, go back
    to Chapter 2 now and follow the instructions to do so. Then activate the virtual
    environment *chatting* in the Anaconda prompt by executing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With your *chatting* virtual environment activated, enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Follow the instructions onscreen to finish the installation.
  prefs: []
  type: TYPE_NORMAL
- en: Install gTTS in Mac or Linux
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *gTTS* module is not in the Python standard library, so you’ll need to install
    it via pip.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven’t already set up your *chatting* virtual environment, go back
    to Chapter 2 now and follow the instructions to do so. Then activate the virtual
    environment *chatting* in a terminal by executing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With your *chatting* virtual environment activated in your terminal, enter
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Follow the instructions onscreen to finish the installation.
  prefs: []
  type: TYPE_NORMAL
- en: Test Your Text-to-Speech Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before beginning, you’ll check that your text-to-speech module is properly installed
    and working. Based on your operating system, skip the sections that don’t apply
    to you.
  prefs: []
  type: TYPE_NORMAL
- en: Run a Sample Script in Windows
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With your virtual environment activated and Spyder open, copy the script *test_pyttsx3.py*
    into your editor and save it in your chapter folder. If you prefer, you can download
    the file from the book’s resources through [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: First, import the *pyttsx3* module to the script. Then use `init()` to initiate
    a text-to-speech engine in the *pyttsx3* module and call it `engine`. The `say()`
    function in the *pyttsx3* module converts the text to a speech signal and prepares
    to send it to the speaker. The `runAndWait()` function then sends the actual speech
    signal to the speaker so you can hear the sound. The `runAndWait()` function also
    keeps the engine running so that when you want to convert text to speech later
    in the script, you don’t need to initiate the engine again.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how each line of code functions, run *test_pyttsx3.py* line by
    line by using the F9 key.
  prefs: []
  type: TYPE_NORMAL
- en: If the module is correctly installed, when you finish running the whole script,
    you should hear a voice saying, “Hello, how are you?” If not, recheck the instructions
    and make sure that the speaker on your computer is working properly at the right
    volume. I’ll discuss later in this chapter how to customize the speed, volume,
    and voice gender associated with the *pyttsx3* module.
  prefs: []
  type: TYPE_NORMAL
- en: Run a Sample Script in Mac or Linux
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ll use the gtts-cli tool (*cli* stands for *command line*) to convert text
    to speech, instead of converting text to an audio file, and then play it. The
    gtts-cli tool is faster than the alternative method. Once you install the *gTTS*
    module, the gtts-cli tool is available in the command line in your virtual environment.
    The gtts-cli tool converts the text to a file-like object, and you have to choose
    which audio player to play it. I find that the mpg123 player works well.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to install the mpg123 player on your computer. If you are using
    Mac, run the following command in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using Linux, run the following two commands on a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’re finished, with your virtual environment activated, run the following
    command in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If you have correctly installed everything, you should hear a voice saying,
    “Hello, how are you?” If not, recheck the instructions and make sure that the
    speaker on your computer is working properly at the right volume. Further, since
    you have installed the *gTTS* module in your virtual environment, you have to
    run the preceding command with your virtual environment activated. Otherwise,
    it won’t work.
  prefs: []
  type: TYPE_NORMAL
- en: The `nocheck` option in this command is to speed up execution. The `q` flag
    instructs the module not to display copyright and version messages, even in an
    interactive mode. Make sure you don’t miss the hyphen at the end of the command.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll use the *os* module in Python to execute commands in a subshell.
  prefs: []
  type: TYPE_NORMAL
- en: Copy the *test_gtts.py* script into your Spyder editor and save it in your chapter
    folder. The script is also available at the book’s resources through [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: First import the *os* module to the script. Then use `system()` to execute a
    command in a subshell to achieve the same effect as running the command in a terminal.
    As a result, the gtts-cli tool is used to convert text to a file-like object.
    After that, the mpg123 player plays the sound object so you can hear a human voice.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve done everything correctly, you should hear a voice saying, “Hello,
    how are you?”
  prefs: []
  type: TYPE_NORMAL
- en: Convert Text to Voice in Windows
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s practice converting written text input into a human voice in Windows.
    With your virtual environment activated and Spyder open, copy the script *tts_windows.py*,
    as shown in [Listing 4-1](#listing4-1), into your editor and save and run it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-1: Converting text to voice in Windows'
  prefs: []
  type: TYPE_NORMAL
- en: After importing the *pyttsx3* module and initiating a text-to-speech engine,
    start an infinite loop to take user text input 1. In each iteration, the script
    asks for text input at the IPython console. If you want to stop the script, enter
    `done`, and the script will print and say in a human voice, “You just typed in
    done; goodbye!” After that, the loop stops, and the script quits running.
  prefs: []
  type: TYPE_NORMAL
- en: If the text input is not `done`, the `else` branch runs 2, and the script speaks
    your text input out loud in a human voice. After that, the script goes to the
    next iteration and takes your text input again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is sample output from the script (user input is in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Convert Text to Voice in Mac or Linux
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we’ll practice converting written text input into a human voice in Mac or
    Linux. With your virtual environment activated and Spyder open, copy the script
    *tts_mac_linux.py* ([Listing 4-2](#listing4-2)) into your editor, and save and
    run it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-2: Converting text to voice in Mac and Linux'
  prefs: []
  type: TYPE_NORMAL
- en: After importing the *os* module so you can run commands in a subshell, start
    an infinite loop to take user text input 1. In each iteration, the script asks
    for text input at the IPython console. If you want to stop the script, enter `done`,
    and the script will print and say in a human voice, “You just typed in done; goodbye!”
    After that, the loop stops, and the script quits running.
  prefs: []
  type: TYPE_NORMAL
- en: If the text input is not `done`, the `else` branch runs 2, and the script speaks
    your text input out loud in a human voice. After that, the script goes to the
    next iteration and takes your text input again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is sample output from the script (user input is in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Repeat After Me
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll start with a simple script that hears what you say aloud and repeats it
    in a human voice. This script serves two purposes. First, you’ll learn how the
    script takes your voice inputs and which words are easiest for the script to understand—some
    uncommon words won’t be understood. Second, you’ll learn how to put both the speech
    recognition and text-to-speech features in the same script so you can communicate
    with the computer through human voices only.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also make the script portable cross-platform. The script will automatically
    choose the *pyttsx3* module if you are using Windows and the *gTTS* module otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new script, name it *repeat_me.py*, and enter the code in [Listing 4-3](#listing4-3).
    Make sure to save it in your chapter folder. You’ll also need to copy your *mysr.py*
    file from Chapter 3 and paste it into the same folder, as you’ll need `voice_to_text()`
    from that script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-3: Repeating aloud'
  prefs: []
  type: TYPE_NORMAL
- en: First, import the `voice_to_text()` function from the *mysr* module to convert
    voice commands into a string variable. Then, import the *platform* module, which
    lets the script automatically identify your operating system and choose the appropriate
    command for you 1. If you are using Windows, the script imports the *pyttsx3*
    module and initiates a text-to-speech engine. Otherwise, the script imports the
    *os* module so you can use the gtts-cli tool in a subshell.
  prefs: []
  type: TYPE_NORMAL
- en: You then start an infinite loop to take voice inputs. The script takes your
    voice command and converts it into a string variable called `inp` 2. If you say,
    “Stop listening” into the microphone, the script will say aloud, “You just said
    stop listening; goodbye!” After that, the script stops. The script uses either
    the *pyttsx3* module or the gtts-cli tool, depending on your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: If you say anything else into the microphone, the loop will keep running. At
    each iteration, the script will repeat what you said out loud 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output from the script after I said, “Hello,” “How are
    you,” and “Stop listening” into the microphone sequentially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Customize the Speech
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to customize the speech produced by your text-to-speech
    module. You can adjust the speed and volume of the speech as well as the identity
    of the voice in the *pyttsx3* module in Windows. If you are using Mac or Linux,
    the only thing you can customize is the speed of the voice in the *gTTS* module.
  prefs: []
  type: TYPE_NORMAL
- en: Skip any of the following subsections that don’t apply to your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve Default Settings in the pyttsx3 Module in Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you need to see the default values of the parameters for the speed, volume,
    and identity of the voice in the *pyttsx3* module in Windows.
  prefs: []
  type: TYPE_NORMAL
- en: This script will retrieve the default settings for your speech module. In Spyder,
    enter the code in [Listing 4-4](#listing4-4) and save it as *pyttsx3_property.py*
    in the chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-4: Retrieving the default settings'
  prefs: []
  type: TYPE_NORMAL
- en: At 1, you use `getProperty()` to obtain the properties of the voices used in
    the engine. You then iterate through all the voice objects in the list `voices`
    and print out individual voice objects.
  prefs: []
  type: TYPE_NORMAL
- en: You use `getProperty()` 2 to obtain the properties of the speed and print the
    default speed, then do the same for the default volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run this script in Windows, you’ll see the default settings for your
    speech script, similar to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see the two voices available to the *pyttsx3* module. The first
    voice, named *David*, has a male voice tone; the second voice, named *Zira*, has
    a female voice tone. The default voice tone is David—hence the male voice you
    hear in *test_pyttsx3.py*.
  prefs: []
  type: TYPE_NORMAL
- en: The default speech speed is 200 words per minute. The default volume is set
    at 1\. You’ll learn how to adjust the speed, volume, and ID in the *pyttsx3* module
    in Windows next.
  prefs: []
  type: TYPE_NORMAL
- en: Adjust Speech Properties in the pyttsx3 Module in Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This script will change the default settings so you can hear a voice with the
    speed, volume, and ID that you prefer. Save [Listing 4-5](#listing4-5) as *pyttsx3_adjust.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-5: Adjusting some settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose the second voice ID, which has a female voice. At 1, the script obtains
    the voice objects available in the text-to-speech engine and saves them in a list
    called `voices`. Choose the second object in the list `voices`, which has a female
    voice tone, by giving the index `[1]`. The `setProperty()` function takes two
    arguments: the property to set and the value to set it to. Set the value to `voices[voice_id].id`
    to choose the `id` value of the female voice object in Windows, which is *HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Speech\Voices\Tokens\TTS_MS_EN-US_ZIRA_11.0*.
    If you want to change to the male voice in Windows, you can use `voices[0].id`
    instead.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you set the speech speed to 150 words per minute. Most of us speak at
    a rate of about 125 words per minute in everyday conversation. For faster speech,
    set `rate` to a number greater than 125, and for slower speech, set it to a number
    below 125.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the volume is set to 1.2, which is louder than the default value of 1\.
    You can set this to higher or lower than 1 based on your preference and speakers.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the script converts the text in `say()` into speech by using the adjusted
    properties. Try running this script multiple times with different combinations
    of parameters until you find the best combination for you. You can always come
    back to this script and make adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: Customize the gTTS Module in Mac or Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can customize the speed, but not the volume or ID, of the voice in *gTTS*,
    according to the *gTTS* documentation; see, for example, [https://buildmedia.readthedocs.org/media/pdf/gtts/latest/gtts.pdf](https://buildmedia.readthedocs.org/media/pdf/gtts/latest/gtts.pdf).
    However, *gTTS* can convert text to speech in most major world languages including
    Spanish, French, German, and so on, which the *pyttsx3* module can’t do. You’ll
    use this feature of *gTTS* to build a voice translator in Chapter 16.
  prefs: []
  type: TYPE_NORMAL
- en: 'This script will change the default speed to slow for the *gTTS* module. In
    Spyder, enter the following code and save it as *gtts_slow.py* in the chapter
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The script is the same as *test_gtts.py* you’ve created before except that it
    adds the `--slow` option. This changes the voice output to slower than normal.
  prefs: []
  type: TYPE_NORMAL
- en: If you run this script in Mac or Linux, you’ll hear the computer saying, “Hello,
    how are you?” slowly.
  prefs: []
  type: TYPE_NORMAL
- en: Since the default setting for the speed is `slow=False`, and that’s what we
    prefer, we won’t customize the *gTTS* module.
  prefs: []
  type: TYPE_NORMAL
- en: Build the Local mysay Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Chapter 3, you put all commands related to speech recognition in a local
    module named *mysr*. You’ll do the same here and put all text-to-speech-related
    commands in a local module.
  prefs: []
  type: TYPE_NORMAL
- en: Create mysay
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll create a local module *mysay* and save it in the same folder as any script
    that uses the text-to-speech feature. That way, you can save space in the main
    script. This module has adjusted the properties for speed, volume, and gender
    of the speech set in *pyttsx3_adjust.py* if you are using Windows. If you are
    using Mac or Linux, the local module *mysay* will use the default properties in
    the *gTTS* module. You can modify these parameters based on your own preferences.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the code in [Listing 4-6](#listing4-6) and save it as *mysay.py* in your
    chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-6: Building the module'
  prefs: []
  type: TYPE_NORMAL
- en: You first import the platform module to identify your operating system. If you
    are using Windows 1, the *pyttsx3* module is imported. You use exception handling
    when initiating the text-to-speech engine 2 so that if you get an `ImportError`
    or `RuntimeError`, the script will keep running rather than crash. You then define
    `print_say()`, which prints the text and converts text to speech.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Mac or Linux 3, the *os* module is imported to use the gtts-cli
    tool to run the command in a subshell. You then define a different `print_say()`
    function that prints the text and converts text to speech.
  prefs: []
  type: TYPE_NORMAL
- en: Import mysay
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With *mysay* prepared, you can simply import the module to your script to use
    the text-to-speech features. Let’s revisit the script *repeat_me.py* and modify
    it to use the *mysay* module. Save the following as *repeat_me1.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You first import `print_say()` from *mysay*. You also import `voice_to_text()`
    from the *mysr* module created in Chapter 3. You use `voice_to_text()` to convert
    your voice command into a variable `inp`. When you want to covert text to speech,
    you use `print_say()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the script and speak into the microphone to test it out. I said, “Hello
    again,” “This one is using a text-to-speech module,” and “Stop listening,” to
    the script in that order. Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Build a Voice-Controlled Calculator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll use your text-to-voice and speech-parsing skills to build a calculator
    that you can speak commands to. The calculator finds the area of a rectangle and
    tells you the area in a human voice.
  prefs: []
  type: TYPE_NORMAL
- en: This script takes from you the width and length of a rectangle and speaks back
    its area. Save [Listing 4-7](#listing4-7) as *area_hs.py* in your chapter folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-7: Calculating the area of a rectangle'
  prefs: []
  type: TYPE_NORMAL
- en: You first import the text-to-speech and speech recognition functions from local
    modules. The script asks you about the length of the rectangle 1. Speak a number
    into the microphone, and the script converts your voice input into text and saves
    it as the variable `inp1`. The script then asks you for the width of the rectangle.
    When you speak your answer, the script saves your voice input in the variable
    `inp2`.
  prefs: []
  type: TYPE_NORMAL
- en: Based on your inputs, the script calculates the area of the rectangle 2 by converting
    your voice inputs into float variables and multiplying them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script will speak the result aloud as well as print the interactions to
    the screen. Here is one interaction with the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Once I told the script that the length of the rectangle was 5 and the width
    was 3, the script told me that the area was 15.0.
  prefs: []
  type: TYPE_NORMAL
- en: If you say something that isn’t a number, the script will not work. It’s safest
    to include the decimal in your response (for example, “five point zero”) so the
    script doesn’t accidentally convert your response into a string rather than a
    number type.
  prefs: []
  type: TYPE_NORMAL
- en: Read a File Aloud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to read a file into a script so Python can
    speak the text aloud.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-8](#listing4-8) contains the short news article you’ll use.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-8: Content for the text file'
  prefs: []
  type: TYPE_NORMAL
- en: Including this article as is in a script would clearly be inconvenient, so save
    it as a text file named *storm.txt* (you can download *storm.txt* with the rest
    of the book’s resources). You can first create a subfolder called *files* in your
    chapter folder and then save *storm.txt* in the subfolder.
  prefs: []
  type: TYPE_NORMAL
- en: Save [Listing 4-9](#listing4-9) as *newsfile.py* to have Python read the news
    article out loud.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-9: Reading out the text file'
  prefs: []
  type: TYPE_NORMAL
- en: You first let the script know where to find the news file 1. You use `open()`
    to access *storm.txt* from the subfolder *files.* You then read the content of
    the file into a string variable called `content` by using `read()`. At the end,
    the script reads the file content out loud in a human voice. Simple!
  prefs: []
  type: TYPE_NORMAL
- en: If you save *storm.txt* in the same folder as the preceding script, you don’t
    need to specify the file path. Python will automatically look in the folder the
    script is held in when a path is not specified.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to install the text-to-speech module to make
    Python talk. You moved crucial text-to-speech features into the module *mysay*
    to import into scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have also learned how to have Python repeat what you say. You applied your
    new skills to a real-world application: using voice inputs to ask Python to calculate
    the area of a rectangle and tell you the answer in a human voice.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to make Python talk and listen, in Chapter 5 you’ll learn
    how to apply both features to several interesting real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are using Windows, in *pyttsx3_adjust.py*, modify the code as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The voice is a male voice.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The speed of the speech is 160 words per minute.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The volume is 0.8.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the script *area_hs.py* to calculate the area of a triangle when you
    say the triangle’s height and base length.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Speaking Applications
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that you know how to make Python talk and listen, we’ll create several real-world
    applications that utilize those skills. But before that, you’ll create a local
    package. Since you’ll use the *mysr* and *mysay* local modules in every chapter
    for the reminder of the book, you’ll create a Python package to contain all local
    modules. This way, you don’t need to copy and paste these modules to the folders
    of individual chapters. This also helps keep the code consistent throughout the
    book. You’ll learn how a Python package works and how to create one yourself along
    the way.
  prefs: []
  type: TYPE_NORMAL
- en: In the first application, you’ll build a Guess the Number game that takes voice
    commands and talks back to you in a human voice.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll then learn how to parse text to extract news summaries from National
    Public Radio (NPR) and have Python read them out to you. You’ll also build a script
    to extract information from Wikipedia based on your voice inquiries and to speak
    the answers out.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you’ll learn how to traverse files in a folder with your voice, with
    the aim of building your very own Alexa. You’ll be able to say to the script,
    “Python, play Selena Gomez,” and a song by Selena Gomez that’s saved on your computer
    will start playing.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, you can download all the code for all the scripts from [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
    Before you begin, set up the folder */mpt/ch05/* for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Create Your Self-Made Local Python Package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Chapter 3, you built a self-made local module *mysr* to contain all speech
    recognition–related code. Whenever you need to use the speech-recognition feature,
    you import `voice_to_text()` from the module. Similarly, you built a self-made
    local module *mysay* in Chapter 4 to contain all text-to-speech-related code.
    You import `print_say()` from the module whenever you use the text-to-speech feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll use these two self-made local modules in this chapter and other chapters
    in this book. To make these modules work, you need to put the module files (namely,
    *mysr.py* and *mysay.py*) in the same directory as the script that uses these
    two modules. This means you’d potentially have to copy and paste these files into
    the directory of almost every chapter in this book. You may wonder: is there a
    more efficient way to do this?'
  prefs: []
  type: TYPE_NORMAL
- en: The answer is yes, and that’s what Python packages are for.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll first learn what a Python package is and how it works. You’ll then
    learn how to create your self-made local package. Finally, you’ll use a Python
    script to test and import your package.
  prefs: []
  type: TYPE_NORMAL
- en: What’s a Python Package?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many people think that Python modules and Python packages are the same. They’re
    not.
  prefs: []
  type: TYPE_NORMAL
- en: A Python *module* is a single file with the *.py* extension. In contrast, a
    Python *package* is a collection of Python modules contained in a single directory.
    The directory must have a file named *__init__.py* to distinguish it from a directory
    that happens to have *.py* extension files in it.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll guide you through the process of creating a local package step-by-step.
  prefs: []
  type: TYPE_NORMAL
- en: Create Your Own Python Package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create a local Python package, you need to create a separate directory for
    it and place all related files into it. In this section, you’ll create a local
    package to contain both our speech recognition and text-to-speech module files—namely,
    *mysr.py* and *mysay.py*.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Package Directory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, you need to create a directory for the package.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, you use a separate directory for each chapter. For example, all
    Python scripts and related files in this chapter are placed in the directory */mpt/ch05/*.
    Since you are creating a package to be used for all chapters in this book, you’ll
    create a directory parallel to all chapters. Specifically, you’ll use the directory
    */mpt/mptpkg/*, where *mptpkg* is the package name. The diagram in [Figure 5-1](#figure5-1)
    explains the position of the package relative to the book chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05001](Images/f05001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-1: The position of the *m**pt**pkg* package relative to the chapter
    folders'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the package directory is parallel to the chapter directories,
    which are all contained in the directory for the book, */mpt*, as in *Make Python
    Talk*.
  prefs: []
  type: TYPE_NORMAL
- en: Create Necessary Files for Your Package
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, you need to create and place necessary files in the package.
  prefs: []
  type: TYPE_NORMAL
- en: First, copy and paste the two modules you created in Chapters 3 and 4, *mysr.py*
    and *mysay.py*, in the package directory */mpt/mptpkg/*. Do not make any changes
    to the two files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then save the following script, *__init__.py*, in the package directory */mpt/mptpkg/*
    (or you can download it from the book’s resources):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The purpose of this file is twofold: it imports `voice_to_text()` and `print_say()`
    so you can use those functions at the package level, and it also tells Python
    that the directory is a package, not a folder that happens to have Python scripts
    in it.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, save the following script, *setup.py*, in the book directory */mpt*,
    one level above the package directory */mpt/mptpkg/*. The script is also available
    from the book’s resources.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The file provides information about the package, such as the package name, author,
    version, descriptions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll learn how to install this local package on your computer next.
  prefs: []
  type: TYPE_NORMAL
- en: Install Your Package
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because you’ll modify the local package and add more features to it later in
    the book, it’s better to install the package in editable mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your Anaconda prompt (Windows) or a terminal (Mac or Linux) and activate
    your virtual environment for this book, *chatting*. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace `path-to-mpt` with the actual directory path of */mpt*. For example,
    the book directory */mpt* is *C:\mpt* on my office computer that runs the Windows
    operating system, so I installed the local package using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'On my Linux machine, the path to the */mpt* directory is */home/mark/Desktop/mpt*,
    so I installed the local package using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `-e` option tells the Python to install the package in editable mode so
    that you can modify the package anytime you need to.
  prefs: []
  type: TYPE_NORMAL
- en: With that, the local package is installed on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Test Your Package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you have installed your self-made local package, you’ll learn how to
    import it.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll write a Python script to test the package you just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revisit the script *repeat_me1.py* from Chapter 4. Enter the following
    lines of code in your Spyder editor and save it as *repeat_me2.py* in your Chapter
    5 directory */mpt/ch05/*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: First, import the functions `voice_to_text()` and `print_say()` from the *mptpkg*
    package directly. Recall that in the script *__init__.py*, you’ve already imported
    the two functions from the modules *.mysr* and *.mysay* to the package. As a result,
    here you can directly import the two functions from the package.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the script is the same as that in *repeat_me1.py*. It repeats what
    you say. If you say, “Stop listening,” the script stops.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an interaction with *repeat_me2.py*, with my voice input in
    bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the script is working properly, which means you’ve successfully
    imported functions from the local package.
  prefs: []
  type: TYPE_NORMAL
- en: More on Python Packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you move on, I want to mention a couple of things about Python packages.
  prefs: []
  type: TYPE_NORMAL
- en: First, you can add more modules to your package. Later in this book, you’ll
    add more modules to the existing local package *mptpkg*. You’ll use just one local
    package for the whole book. This will reduce the number of directories and help
    organize your files.
  prefs: []
  type: TYPE_NORMAL
- en: Second, if you have an interesting package that you want to share with the rest
    of the world, you can easily do so. You just need to add a few more files, such
    as the license, a README file, and so on. For a tutorial on how to distribute
    your Python packages, see, for example, the Python Packaging Authority website,
    [https://packaging.python.org/tutorials/packaging-projects/](https://packaging.python.org/tutorials/packaging-projects/).
  prefs: []
  type: TYPE_NORMAL
- en: Interactive Guess the Number Game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Guess the Number* is a popular game in which one player writes down a number
    and asks the other player to guess it in a limited number of attempts. After each
    guess, the first player tells whether the guess is correct, too high, or too low.'
  prefs: []
  type: TYPE_NORMAL
- en: Various versions of the game are available online and in books, and we’ll look
    at our own version to guess a number between one and nine. Start a new script
    and save it as *guess_hs.py*; the *hs* stands for *hear and say*.
  prefs: []
  type: TYPE_NORMAL
- en: Because the script is relatively long, I’ll break it into three parts and explain
    them one by one. [Listing 5-1](#listing5-1) gives the first part.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-1: Part 1 of the Guess the Number game'
  prefs: []
  type: TYPE_NORMAL
- en: We start the script by importing needed modules 1. We import the *time* module
    so we can pause the script for a period of time. We also import the *sys* module
    to exit the script when it is finished.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in the previous section, we import `voice_to_text()` and `print_say()`
    from the local package *mptpkg* to convert voice to text as well as to print out
    and speak the text message.
  prefs: []
  type: TYPE_NORMAL
- en: The script then speaks and prints out the rules of the game 2. Since the instructions
    span several lines, we put them in triple quotation marks to make them more readable.
  prefs: []
  type: TYPE_NORMAL
- en: The script announces that you have five seconds to write down a number then
    pauses for five seconds by using `sleep()` to give you time to write your number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script then begins to guess; it will ask in a human voice whether the number
    is five. At 3, we start an infinite loop to take your voice input. When you speak
    into the microphone, the computer converts your voice input into a text string
    variable named `re1`. The script repeats what you said back to you. Your response
    needs to be one of three phrases: “too high,” “that is right,” or “too small.”
    If it isn’t, the script will keep asking you for a response until it matches one
    of the phrases. This gives you a chance to have a correct response before the
    script moves on to the next step.'
  prefs: []
  type: TYPE_NORMAL
- en: If your response is “that is right,” the computer will say, “Yay, lucky me!”
    and exit the script. We’ll enter the behavior for the response “too high” next.
    [Listing 5-2](#listing5-2) shows the middle part of the *guess_hs.py* script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-2: The “too high” behavior'
  prefs: []
  type: TYPE_NORMAL
- en: If your response is “too high,” the computer will keep guessing, this time a
    lower number. The second guess from the computer will be three because guessing
    three reduces the number of attempts the computer needs to find out the answer.
    The script will detect and catch your response to the second guess.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the options for your response to the second guess: If it’s “that is
    right,” the computer will say “Yay, lucky me!” and exit the script. If it’s “too
    small,” the computer will know that the number is four and say so. If it’s “too
    high,” the computer will make a third guess of one.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, the computer captures your response to the third guess. If your response
    is “too small,” the computer will know that the number is two. If your response
    is “that is right,” the computer will say, “Yay, lucky me!” and exit.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at the final section of *guess_hs.py*, which handles a “too small”
    response to the first guess. [Listing 5-3](#listing5-3) shows the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-3: The “too small” behavior'
  prefs: []
  type: TYPE_NORMAL
- en: The final section of the script is similar to the middle section. If you tell
    the computer that the first guess of five is “too small,” the computer will give
    you a second guess of seven. The script will then catch your response to the second
    guess.
  prefs: []
  type: TYPE_NORMAL
- en: If you respond “that is right,” the computer will say, “Yay, lucky me!” and
    exit the script. If you say “too high,” the computer will know that the number
    is six. If your response is “too small,” the computer will make a third guess
    of eight.
  prefs: []
  type: TYPE_NORMAL
- en: The computer then captures your response to the third guess. If your response
    is “too small,” the computer will know that the number is nine. If your response
    is “that is right,” the computer will say, “Yay, lucky me!” and exit the script.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a good internet connection in a fairly quiet environment, you can
    have close-to-perfect communication with the computer. The internet connection
    is important because we use the Google Web Speech API to convert voice input into
    text. The *SpeechRecognition* module has an offline method called `recognize_sphinx()`,
    but it makes a lot of mistakes, so we use the online method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the written output from the script when my number was 8 (my voice input
    is in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The script understood every word I said perfectly. This is, of course, partly
    because I chose certain words to avoid ambiguity. When building your own projects,
    you’ll want to use voice commands that are unique or put the words in context
    to get consistently correct results. Since each voice command is usually short,
    the Python script may have difficulty grasping the context of your voice input
    and returning the right words.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you say “too large” into the microphone, the script may return
    “two large,” which is a phrase that does make sense. That is why we use “too high”
    instead of “too large” in *guess_hs.py*.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when I spoke “too low” into the microphone, the script returned “tulo”
    from time to time. When I use “too small,” I get the correct response each time.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking Newscast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this project, we’ll scrape the NPR News website to collect the latest news
    summary and have Python read it out loud. This project is split into two scripts:
    one to scrape and organize the news, another to handle the speech recognition
    and text-to-speech features. Let’s start with the web scraping.'
  prefs: []
  type: TYPE_NORMAL
- en: Scrape the News Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we need to scrape the information from the news site and compile it into
    a clean and readable format.
  prefs: []
  type: TYPE_NORMAL
- en: Different news sites arrange their content differently, so the methods for scraping
    are often slightly different. You can refer to Chapter 6 for the basics of web
    scraping. If you’re interested in scraping other news sites, you’ll need to adjust
    this code based on the features of the website. Let’s first look at the site and
    the corresponding source code.
  prefs: []
  type: TYPE_NORMAL
- en: The news we’re interested in is on the front page of the NPR News website, shown
    in [Figure 5-2](#figure5-2).
  prefs: []
  type: TYPE_NORMAL
- en: One handy feature of this page is the short news summaries. As you can see,
    the front page lists the latest news with a short summary for each news article.
  prefs: []
  type: TYPE_NORMAL
- en: You want to extract the news title and the teaser of each news article and print
    them out. To do this, you need to locate the corresponding tags in the HTML program.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05002](Images/f05002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-2: News summaries on the NPR News front page'
  prefs: []
  type: TYPE_NORMAL
- en: While on the web page, press ctrl-U on your keyboard. The source code for the
    web page should appear. You can see that it’s almost 2,000 lines long. To locate
    the tags you need, press ctrl-F to open a search box at the top-right corner.
    Because the title of the first news article starts with “Answering Your Coronavirus
    Questions,” as shown in [Figure 5-2](#figure5-2), you should enter `Answering
    Your Coronavirus Questions` and click **Search**. Then skip to the corresponding
    HTML code, shown in [Listing 5-4](#listing5-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-4: Part of the source code for the NPR News front page'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that all the title and teaser information are encapsulated in a parent
    `<div>` tag with a `class` attribute of `item-info` 1. Information for the news
    title is held in a child `<h2>` tag with a `class` attribute of `title` 2. The
    information for the teaser is held in a child `<p>` tag with a `class` attribute
    of `teaser` 3.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use these patterns to write a Python script to extract the information
    we need. The script *news.py* will scrape the information and organize all titles
    and summaries in a clean and concise way. I’ve added comments in places that need
    more detailed explanations.
  prefs: []
  type: TYPE_NORMAL
- en: The script will compile the news summary and print it out in text. Enter [Listing
    5-5](#listing5-5) and save it as *news.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-5: Python code to scrape the NPR News front page'
  prefs: []
  type: TYPE_NORMAL
- en: We start by importing the needed modules *bs4* and *requests* (*bs4* is the
    newest version of the Beautiful Soup library). Follow the three steps in Chapter
    2 for installing these modules if you need to.
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we obtain the source code for the NPR News front page, which is in HTML
    format. We then use the *bs4* module to parse HTML files. Because the information
    we need is encapsulated in `<div>` tags with a `class` attribute of `item-info`,
    we find all such tags and put them in a list called *div_tags*. To separate different
    news summaries, we create a variable *news_index* to mark them 2.
  prefs: []
  type: TYPE_NORMAL
- en: We then go into each individual `<div>` tag we’ve collected 3. First, we print
    out the news summary index to separate out individual news items. Second, we extract
    the `<h2>` tag that contains the news title and print it out. Third, we extract
    the `<p>` tag that contains the news summary and print it out. Finally, we stop
    if the news index exceeds 10 so that we limit the printout to 10 news summaries.
  prefs: []
  type: TYPE_NORMAL
- en: If you run *news.py*, the output will look like [Listing 5-6](#listing5-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-6: News summary scraped from the NPR News front page'
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll get Python to read the news to us.
  prefs: []
  type: TYPE_NORMAL
- en: Add the Text-to-Speech Features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step is to have the text-to-speech module convert the news summary
    into spoken words. Add [Listing 5-7](#listing5-7) into a new file and save it
    as *news_hs.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-7: Python code for a voice-activated newscast'
  prefs: []
  type: TYPE_NORMAL
- en: We first import the usual modules, and we import `voice_to_text()` and `print_say()`
    from the self-made *mptpkg* package.
  prefs: []
  type: TYPE_NORMAL
- en: We then define a function called `news_teaser()` 1, which accomplishes whatever
    *news.py* does. The only exception is that instead of just printing out the news
    index, title, and teaser, it both prints and speaks them 2. We then set the script
    to ask, “Would you like to hear the NPR news summary?” The `voice_to_text()` function
    captures your voice response and converts it into a string variable with all lowercase
    letters. If you say yes, Python will start broadcasting the news. If you answer
    anything other than yes, the script will exit.
  prefs: []
  type: TYPE_NORMAL
- en: Voice-Controlled Wikipedia
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll build a talking Wikipedia in this section. Unlike with the newscaster
    project, we’ll use the *wikipedia* module to get the information we need directly.
    After that, we’ll get the script to understand questions you ask, retrieve the
    answer, and read it aloud.
  prefs: []
  type: TYPE_NORMAL
- en: Access Wikipedia
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python has a *wikipedia* module that does the work of delving into topics you
    want to know about, so we don’t have to code that part ourselves. The module is
    not in the Python standard library or the Anaconda navigator. You should install
    it with pip. Open the Anaconda prompt (in Windows) or a terminal (in Mac or Linux)
    and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the following script as *wiki.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: After the script is running, in the IPython console in the lower-right panel,
    enter the name of a topic you want to know about. The script will save your inquiry
    as the variable *my_query*. The `summary()` function will produce a summary answer
    to your question. Finally, the script prints out the answer from Wikipedia.
  prefs: []
  type: TYPE_NORMAL
- en: 'I entered `U.S. China trade war` and got the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This answer is relatively short. Most searches in Wikipedia will have a much
    longer result. If you want to limit the length of the responses to, say, the first
    200 characters, you can enter `[0:200]` after `answer`.
  prefs: []
  type: TYPE_NORMAL
- en: Add Speech Recognition and Text to Speech
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll now add the speech recognition and text-to-speech features to the script.
    Enter [Listing 5-8](#listing5-8) as *wiki_hs.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-8: Python code for a voice-controlled talking Wikipedia'
  prefs: []
  type: TYPE_NORMAL
- en: Once you start the script, a voice asks, “What do you want to know?” 1. At 2,
    the script calls `voice_to_text()` to convert your voice input into text. Then,
    the script retrieves the response to your question from Wikipedia, saves it as
    a string variable *ans*, and converts it to a human voice.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the script, if you say to the microphone, “US Federal Reserve
    Bank,” you’ll get a result similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: I’ve added the `[0:200]` character limit behind the variable `ans`, so only
    the first 200 characters of the result are printed and spoken.
  prefs: []
  type: TYPE_NORMAL
- en: And just like that, you have your own voice-controlled talking Wikipedia. Ask
    away!
  prefs: []
  type: TYPE_NORMAL
- en: Voice-Activated Music Player
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here you’ll learn how to get Python to play a certain artist or genre of music
    just by asking for it with a phrase like “Python, play Selena Gomez.” You’ll speak
    the name of the artist you want to listen to, and the script will receive that
    as keywords and then search for those keywords in a particular folder. To do this,
    you need to be able to traverse files and folders.
  prefs: []
  type: TYPE_NORMAL
- en: Traverse Files in a Folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose you have a subfolder *chat* in your chapter folder. If you want to
    list all files in the subfolder, you can use this *traverse.py* script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: First, the script imports the *os* module. This module gives the script access
    to functionalities that are dependent on the operating system, such as accessing
    all files in a folder.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you put all files in the subfolder *chat* into a list called *files*.
    The script goes through all items in the list, and prints out the name of each
    item.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from the preceding script is as follows after I run it on my computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can traverse all the files and subfolders in a folder and
    print out their names. Filenames include the file extension. Subfolders have no
    extension after the subfolder name. For example, I have two folders, *country*
    and *classic*, in the folder *chat*. As a result, you see `country` and `classic`
    in the preceding output.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll use this feature to select a song you want to play.
  prefs: []
  type: TYPE_NORMAL
- en: Python, Play Selena Gomez
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The script in [Listing 5-9](#listing5-9), *play_selena_gomez.py*, can pick out
    a song by whatever artist you name (for example, Selena Gomez) and play it. Either
    save your songs in the subfolder *chat* or replace the file path with a path to
    somewhere on your computer that you keep music.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-9: Python code to voice activate a song by an artist on your computer'
  prefs: []
  type: TYPE_NORMAL
- en: We first import the needed modules. In particular, we import the *os* module
    to traverse files and the *random* module to randomly select a song from a list
    the script will build. We use `mixer()` in the *pygame* module to play the music
    file.
  prefs: []
  type: TYPE_NORMAL
- en: We then start an infinite loop 1 to put the script in standby mode to wait for
    your voice commands. If the script detects the word *play* in your voice command,
    the music mode is activated 2. We then replace the word `play` and the whitespace
    behind it with an empty string 3 so that your command “Play Selena Gomez” becomes
    `Selena Gomez`. The next command separates the first name and the last name. For
    artists who are known by just their first names (such as Madonna, Prince, or Cher),
    we put their first name as a placeholder in the variable `lastname`.
  prefs: []
  type: TYPE_NORMAL
- en: We then traverse through all files in the subfolder *chat*. If a file has the
    *mp3* extension and contains either the first or the last name 4, it will be added
    to the list *mysongs*. We use `choice()` from the *random* module to randomly
    select a song in the list *mysongs* 5 and load it with `mixer.music.load()`. After
    that, we use `mixer.music.play()` to play it.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, once you say to the script, “Play Selena Gomez,” one of the two
    songs in the subfolder *chat*, *SelenaGomezWolves.mp3* or *TheHeartWantsWhatItWantsSelenaGomez.mp3*,
    will start playing.
  prefs: []
  type: TYPE_NORMAL
- en: Python, Play a Country Song
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What we’ll do now is similar to interacting with the script *play_selena_gomez.py*,
    but here you’ll learn how to access different subfolders by using the *os* module
    as well as a different way of playing music files.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you’ve organized your songs by genre. You put all classical music files
    in the subfolder *classic*, and all country music files in the folder *country*,
    and so on. You’ve placed these subfolders in the folder *chat* you just created.
  prefs: []
  type: TYPE_NORMAL
- en: We want to write a script so that when you say, “Python, play a country song,”
    the script will randomly select a song from the folder *country* and play it.
    Enter the code in [Listing 5-10](#listing5-10) and save it as *play_genre.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-10: Python code to voice activate a song by genre'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python checks for the terms *play a* and *song* in the voice command and activates
    the music mode if it finds them. The script then replaces `play a` 1 and `song`
    2 as well as the whitespace behind them with an empty string, leaving only the
    genre—`country`, in this case—in the voice command. This is used as the folder
    for the script to search: in this case, *./chat/country*. Finally, the script
    randomly selects a song from the folder 3 and plays it.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we use `lower()` after `voice_to_text()` in the script so that the
    voice command is all lowercase. We do this because the script sometimes converts
    the voice command into `play A Country Song`. We can avoid mismatch due to capitalization.
    On the other hand, the path and filenames are not case sensitive, so even if you
    have capital letters in your path or filenames, there will not be any mismatch.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you first learned to create a Python package to contain the
    local text-to-speech and speech recognition modules. After that, you built several
    real-world applications that can understand voice commands, react, and speak.
  prefs: []
  type: TYPE_NORMAL
- en: You created a voice-controlled, talking Guess the Number game. In the game,
    you pick a number between one and nine and interact with the script to let it
    guess. Then you learned how to parse text to extract a news summary from the NPR
    website, adding the speech recognition and text-to-speech features to make a voice-controlled
    newscast.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to use the *wikipedia* module to obtain answers to your inquiries.
  prefs: []
  type: TYPE_NORMAL
- en: You traversed files in a folder on your computer by using the *os* module, and
    then created a script that plays a genre or artist when you ask it to.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to make Python talk and listen, you’ll apply both features
    to many other interesting situations throughout the rest of the book so that you
    can interact with your computer via voice only.
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify *guess_hs.py* so that the third guess of the script is two instead of
    one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change *wiki.py* so that it prints out the first 300 characters of the result
    from Wikipedia.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *play_genre.py* so that the script plays music by using the *os* module
    and your default music player on your computer, instead of the *pygame* module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Suppose the music files on your computer are not in MP3 format but in WAV format.
    How can you modify *play_selena_gomez.py* so that the script still works?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web Scraping Podcasts, Radios, and Videos
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll build on the web-scraping basics from Chapter 5. You’ll
    use these skills to voice-activate podcasts, live radio broadcasts, and videos
    on different websites.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also learn how HyperText Markup Language (HTML) works and how the various
    types of HTML tags construct web pages. You’ll learn how to use Python’s Beautiful
    Soup library to parse HTML files and extract information.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all these skills, you’ll build three apps to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Parse the source file of online podcasts, locate an MP3 file, and play the podcast.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use voice control to play online live radio.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play online videos, such as NBC’s *Nightly News with Lester Holt*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before you begin, set up the folder */mpt/ch06/* for this chapter. As usual,
    you can download all the code for all the scripts from [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
  prefs: []
  type: TYPE_NORMAL
- en: A Primer on Web Scraping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Beautiful Soup library is designed to extract information from websites.
    We’ll use it often in this book, just as many Python programmers do in the real
    world.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll first discuss the basics of HTML markup and how different types of tags
    form various blocks on a website. You’ll then learn to use the Beautiful Soup
    library to extract information from websites by parsing their source code.
  prefs: []
  type: TYPE_NORMAL
- en: What Is HTML?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted at the start of the chapter, *HTML* stands for *HyperText Markup Language*,
    the programming language that tells browsers how to construct and display web
    page content. HTML uses various types of tags to build the structure of web pages.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of an HTML Tag
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Table 6-1](#table6-1) lists some of the commonly used tags and their main
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 6-1: Commonly Used HTML Tags'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tag name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `<html>` | The root-level tag of an HTML document. It encapsulates all other
    HTML tags. |'
  prefs: []
  type: TYPE_TB
- en: '| `<head>` | The head section of an HTML document that contains metadata about
    the page. |'
  prefs: []
  type: TYPE_TB
- en: '| `<title>` | The title of the web page, to be displayed on the tab of the
    browser. |'
  prefs: []
  type: TYPE_TB
- en: '| `<body>` | The body of an HTML document, with all displayed content. |'
  prefs: []
  type: TYPE_TB
- en: '| `<h1>` | A level-1 heading, for example, the title of a news article. |'
  prefs: []
  type: TYPE_TB
- en: '| `<p>` | A paragraph of displayed content. |'
  prefs: []
  type: TYPE_TB
- en: '| `<div>` | A container used for page elements that divide the HTML document
    into sections. |'
  prefs: []
  type: TYPE_TB
- en: '| `<a>` | A hyperlink to link one page to another. |'
  prefs: []
  type: TYPE_TB
- en: '| `<li>` | A list item. |'
  prefs: []
  type: TYPE_TB
- en: All tags start with `< >` and end with `</ >` so that the browser can identify
    separate tags. For example, paragraph tags start with `<p>` and close with `</p>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use `<a>` to illustrate the components of HTML tags. Here’s an example
    of creating a hyperlink by using an `<a>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This hyperlink has optional attributes in the opening tag: `<a class="suprablue"
    href="http://libraries.uky.edu">`. The `class` attribute tells the browser which
    style to use from the Cascading Style Sheets (CSS), where the class name `suprablue`
    is predefined (you’ll learn how to define a class in the following section). The
    `href` attribute specifies the destination of the hyperlink, [http://libraries.uky.edu/](http://libraries.uky.edu/).
    The content of the tag that will be displayed on the page is between the opening
    and closing tags: `Libraries`.'
  prefs: []
  type: TYPE_NORMAL
- en: From HTML Tags to Web Pages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To understand how HTML uses tags to construct a web page, let’s look at an extremely
    simplified example. Enter the script in [Listing 6-1](#listing6-1) and save it
    as *UKYexample.html* in your chapter folder, or you can download the file from
    the book’s resources page. All HTML files need the extension *.html* or *.htm*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-1: HTML code for a simple web page'
  prefs: []
  type: TYPE_NORMAL
- en: Before I explain the code, let’s see how the actual web page looks. Go to your
    chapter folder and open *UKYexample.html* with your preferred web browser. I use
    Google Chrome, and the web page comes out as in [Figure 6-1](#figure6-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06001](Images/f06001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-1: A simple web page'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s link the HTML code to the web page display.
  prefs: []
  type: TYPE_NORMAL
- en: 'At 1, we start an opening `<html>` tag to contain all the code in the script.
    Then, we have a `<title>` tag nested in a `<head>` tag. The `<head>` tag is usually
    used to contain metadata, such as the document title or CSS styles. The content
    of the `<title>` tag is `Example: University of Kentucky`, which sets the title
    of the web page shown in the browser tab at the top-left corner in [Figure 6-1](#figure6-1).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The content inside the `<style>` tag is to define two classes: `redtext` and
    `leftmargin`. The first one tells the HTML to display the content in red, while
    the second tells the HTML to leave a 10-pixel left margin. You can specify multiple
    styles such as background color, padding, or margins in one class.'
  prefs: []
  type: TYPE_NORMAL
- en: At 2, we start the body HTML that will be displayed on the page. Inside this
    we have three nested `<p>` tags. A `<p>` tag defines a separate paragraph in an
    HTML document; adding a new `<p>` tag starts a new paragraph. The first `<p>`
    tag contains the message `Below are some links:`.
  prefs: []
  type: TYPE_NORMAL
- en: We then provide two hyperlinks, each in in an `<a>` tag nested in a `<p>` tag.
    We put each `<a>` tag in a separate `<p>` tag so the links are displayed as two
    different paragraphs instead of side by side on the same line. If you click the
    first link, it will bring you to the University of Kentucky Libraries. If you
    click the second link, you’ll be directed to the University of Kentucky Directory.
    The first tag has a class attribute of `redtext`, displaying the text in red,
    as defined in the `<style>` tag previously. Similarly, the second tag has a class
    attribute of `leftmargin`, and as a result, a 10-pixel margin precedes the text
    `University of Kentucky Library`.
  prefs: []
  type: TYPE_NORMAL
- en: Extract Information with Beautiful Soup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you understand how a few basic HTML tags work, you’ll use the Beautiful
    Soup library to parse the HTML code and extract the information you want. I’ll
    first discuss how to parse a locally saved HTML file. Then you’ll learn how to
    extract information from a live web page.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s revisit the simple example *UKYexample.html* saved in your chapter folder.
    Suppose you want to extract some web addresses from a web page. You can use [Listing
    6-2](#listing6-2), *parse_local.py*, to accomplish the task.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-2: Parsing a local HTML file'
  prefs: []
  type: TYPE_NORMAL
- en: First, we import `BeautifulSoup()` from the *bs4* module, the latest version
    of Beautiful Soup. At 1, we open the local HTML file as a text file by using the
    built-in Python function `open()`. We then use `findAll()` to locate all `<p>`
    tags in the HTML file, and we put them in the list `ptags`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three `<p>` tags in the list `ptags`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s use the third tag as an example. At 2, we locate the `<a>` tag nested
    in the third `<p>` tag. We then print out the `href` attribute of the `<a>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we print out the content of the `<a>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the whole script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Scrape Live Web Pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s scrape a live web page. The HTML markup for a live web page is much
    more complicated than our simple static version and might be thousands of lines
    long, so you’ll need to learn to quickly locate the lines of code you want.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you want to extract the contact information from the University of Kentucky
    Libraries website. Go to [http://libraries.uky.edu/](http://libraries.uky.edu/)*.*
    Then scroll to the bottom of the page and you’ll see the contact information for
    various areas, as shown in [Figure 6-2](#figure6-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06002](Images/f06002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-2: Information you want from a live web page'
  prefs: []
  type: TYPE_NORMAL
- en: 'You want to extract the department name, phone number, and email address for
    each of the three departments shown in [Figure 6-2](#figure6-2): Circulation,
    Reference, and Interlibrary Loan. First you need to locate the corresponding tags
    in the HTML document.'
  prefs: []
  type: TYPE_NORMAL
- en: While on the web page, press ctrl-U on your keyboard (or right-click and choose
    **View**▶**Source**). The source code for the web page should appear. You can
    see that it’s more than 2,000 lines long. To locate the tags you need, press ctrl-F
    to access a search box at the top-right corner. Enter `Circulation` and click
    **Search** to skip to the corresponding HTML code, shown in [Listing 6-3](#listing6-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-3: Part of the source code for a live web page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that all the information is encapsulated in a parent `<div>` tag with
    `class` attribute of `sf-middle` 1. Information for the Circulation department
    (name, phone number, and email address) is held in a child `<div>` tag with class
    attribute of `dashing-li` 2. The information for the other two areas, Reference
    3 and Interlibrary Loan 4, is held in two other child `<div>` tags within the
    parent tag. Within each child tag, subtags each contain a piece of the following
    information: department name, phone number, and email address.'
  prefs: []
  type: TYPE_NORMAL
- en: These patterns are important to notice when writing a Python script to extract
    the information you need. Next, I’ll explain how to use these patterns to extract
    the information from the HTML file.
  prefs: []
  type: TYPE_NORMAL
- en: Download *scrape_live_web.py* from the book’s resources page and save it in
    your chapter folder. The first part of the script is shown in [Listing 6-4](#listing6-4),
    which locates the `<div>` tags for each of the three areas.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-4: Python code to scrape a live web page'
  prefs: []
  type: TYPE_NORMAL
- en: We import the *requests* module to obtain the source code from the live web
    page. The address of the web page is defined in the variable `url`. At 1, we use
    `get()` to fetch the HTML code. Then, we find the `<div>` tag with the class value
    of `sf-middle` and use it as the parent tag.
  prefs: []
  type: TYPE_NORMAL
- en: At 2, we locate the three child `<div>` tags with the class value of `dashing-li`
    and put them in the list `contacts`, because each child `<div>` tag contains all
    the contact information for one department. Each element in the list corresponds
    to one of the departments. For example, the first element contains all the information
    for the Circulation department, and we print it out in [Listing 6-5](#listing6-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-5: Source code for the Circulation department on the live web page'
  prefs: []
  type: TYPE_NORMAL
- en: The second part of *scrape_live_web.py* will print out the detailed information
    for each of the three areas. It is shown in [Listing 6-6](#listing6-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-6: Python code to print out the scraped information'
  prefs: []
  type: TYPE_NORMAL
- en: 'We go into each element in the list `contacts`. To print out the department
    name, we locate the `<span>` tag with the class attribute of `contact_area`. The
    content of the tag is the department name. The two `<a>` tags contain the phone
    number and the email address of each department, and we also print them out. The
    output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Voice-Activated Podcasts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, our goal is to write a script that enables you to say, “Python,
    tell me the latest news,” and the script will broadcast a brief from an NPR news
    podcast. You’ll first learn how to extract the MP3 file associated with the podcast
    and play it, and then you’ll add the speech recognition feature to the script
    so that you can voice-activate it. Because the news brief is about five minutes
    long, you’ll also learn how to stop the podcast via voice control while the news
    is playing.
  prefs: []
  type: TYPE_NORMAL
- en: Extract and Play Podcasts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, find a website with a newscast you like. For this, we’ll use *NPR News
    Now* because it’s free and updated every hour, 24/7\. The web address is [https://www.npr.org/podcasts/500005/npr-news-now/](https://www.npr.org/podcasts/500005/npr-news-now/).
  prefs: []
  type: TYPE_NORMAL
- en: Go to the site, and you should see something like [Figure 6-3](#figure6-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06003](Images/f06003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-3: Front page of *NPR News Now*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the latest news brief for me was updated at 7 am ET on Feb 9,
    2021\. Below it, you can also see news briefs from 6 am, 5 am, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: To locate the MP3 file that contains the news briefs, right-click anywhere on
    the page and, from the menu that appears, select the **View page source** option
    (or press ctrl-U). You should see the source code, as in [Figure 6-4](#figure6-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06004](Images/f06004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-4: Source code for *NPR News Now*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that the MP3 files are contained in `<a>` tags. We need to use
    the Beautiful Soup library to extract all `<a>` tags that contain MP3 files and
    then extract the link from the first tag, which will contain the latest news brief.
    If you wanted to, you could listen to previous news briefs as well; for example,
    the second and the third tags contain the news briefs from 6 am and 5 am in [Figure
    6-3](#figure6-3).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to extract the link, remove unwanted components, and use the *webbrowser*
    module to open the URL of the MP3 file so that the podcast can start playing.
    The script *npr_news.py*, in [Listing 6-7](#listing6-7), shows how to accomplish
    this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-7: A script to play online podcasts'
  prefs: []
  type: TYPE_NORMAL
- en: We first use `get()` from the *requests* module to obtain the source code of
    the *NPR News Now* website and save it in the variable `response`. At 1, we use
    the Beautiful Soup library to parse the text and the `html.parser` option to specify
    that the source code is in HTML. We saw in [Figure 6-4](#figure6-4) that the MP3
    files are held in `<a>` tags with a `class` attribute of `audio-module-listen`.
    Therefore, at 2 we use `findAll()` from Beautiful Soup to get all those tags and
    put them in the list `casts`. [Listing 6-8](#listing6-8) shows the content of
    `casts`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-8: All `<a>` tags with a `class` attribute of `audio-module-listen`'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, multiple `<a>` tags contain MP3 files. At 3, we extract the
    first `<a>` tag in the list and obtains the `href` attribute of the tag (the link
    to the MP3 file), saving it to `cast`. The link is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'We trim the link so that it ends with the *.mp3* extension. To do that, we
    use the fact that the *?* character is right after *.mp3* in the link and then
    use the string method `find()` to locate the position of *?* in the link 4. We
    then trim the link accordingly and print it out. The trimmed link is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we extract the link to the online MP3 file and use `open()` in the
    *webbrowser* module to open and play the MP3 file.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the script, you should hear the latest NPR news brief playing in
    your default web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Voice-Activate Podcasts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we’ll add speech recognition to the script so you can voice-activate the
    podcast. Further, since the podcast is about five minutes long, being able to
    stop it with your voice is useful. To achieve that, we need to install the *pygame*
    module because it allows the Python script to stop the audio file while the audio
    is playing. The *webbrowser* module does not have that functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing *pygame* is straightforward in Windows. Execute this line of code
    in an Anaconda prompt with your virtual environment activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Then follow the instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Mac, recent versions of macOS require the installation of
    Pygame 2\. To install it, execute this line of code in a terminal with your virtual
    environment activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Then follow the instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Linux, execute the following three lines of code in a terminal
    with your virtual environment activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: See Appendix A at the end of this book for further detail. If the installation
    is not successful, you can use the *vlc* module as an alternative.
  prefs: []
  type: TYPE_NORMAL
- en: The script *news_brief_hs.py* in [Listing 6-9](#listing6-9) shows how to use
    voice control to activate the *NPR News Now* podcast and stop it whenever you
    want.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-9: Python script to voice-activate *NPR News Now*'
  prefs: []
  type: TYPE_NORMAL
- en: We import needed modules first. In particular, we import `BytesIO()` from the
    *io* module to create a temporary file to contain the news brief audio file. This
    prevents crashes that could occur if the script had to overwrite the file when
    you rerun it.
  prefs: []
  type: TYPE_NORMAL
- en: We define `news_brief()` 1. This function accomplishes what we did in *npr_news.py*
    with a few exceptions. We download the MP3 file and save it to the temporary file
    *voice*. After that, we use the *pygame* module to play the latest news brief
    from *NPR News Now*.
  prefs: []
  type: TYPE_NORMAL
- en: At 2, we start an infinite loop. At each iteration, the script captures your
    voice. When the word *news* is in your voice command 3, the script will call `news_brief()`
    and start playing the latest NPR news brief. While the news is playing, the script
    is constantly listening to your voice command in the background. When you say,
    “Stop playing,” anytime while or after the news plays, the loop will break and
    go back to the main menu. If you want to end the script, simply say, “Stop listening.”
  prefs: []
  type: TYPE_NORMAL
- en: Voice-Activated Radio Player
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our goal in this project is to write a script to play online live radio using
    voice control. When you say, “Python, play online radio,” the script will go to
    the website and click the Play button so that the live radio starts playing on
    your computer.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be using the *selenium* module to automate web browser interaction from
    Python. We’ll then add voice control to the script to achieve voice activation.
  prefs: []
  type: TYPE_NORMAL
- en: Install the selenium Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *selenium* module is not in the Python standard library, so first we’ll
    install it. Open your Anaconda prompt (Windows) or a terminal (Mac or Linux),
    activate your virtual environment, and execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Follow the onscreen instructions to finish the installation.
  prefs: []
  type: TYPE_NORMAL
- en: Control Web Pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *selenium* module allows you to automate web browser interactions with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Online Radio Box (*https://onlineradiobox.com/us/*) will serve as our radio
    station platform. You can change this to any online radio station you like, such
    as Magic 106.7 or NPR online radio stations.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the website and you should see a screen similar to that shown in [Figure
    6-5](#figure6-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06005](Images/f06005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-5: Front page of Online Radio Box'
  prefs: []
  type: TYPE_NORMAL
- en: When the web page loads, live radio is not playing. You need to use *selenium*
    to interact with the web browser to click the Play button (the triangle-shaped
    white button at the bottom in [Figure 6-5](#figure6-5)).
  prefs: []
  type: TYPE_NORMAL
- en: Now you’ll learn how to locate the XPath of the Play button on the website.
    *XPath* is short for *Extensible Markup Language (XML) path*. It is the syntax
    for finding an element on the web page by using an XML path expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to find the XPath of the Play button:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the web page of Online Radio Box, shown in [Figure 6-5](#figure6-5), using
    the Chrome browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put your mouse cursor on the Play button (do not click). Then right-click and
    choose **Inspect** from the pop-up menu. The source code will show at the right
    side of the web page, as shown in [Figure 6-6](#figure6-6).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the highlighted line of code at the right side of the page and select
    **Copy**▶**XPath**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the XPath in a blank file to be used later. In this example, the XPath
    for the Play button is `//*[@id="b_top_play"]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![f06006](Images/f06006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-6: Locate the XPath of the Play button'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to download the web driver for a specific browser. If you’d like
    to learn more about the Selenium project, an abundance of information is on its
    website.
  prefs: []
  type: TYPE_NORMAL
- en: Follow the instructions at [https://chromedriver.chromium.org/downloads/](https://chromedriver.chromium.org/downloads/)
    and download the executable file appropriate to your operating system. In Windows,
    this is *chromedriver_win32.zip*; extract the ZIP file and place the executable
    file in the chapter folder. On Unix-based operating systems, the executable file
    is called *chromedriver*. On Windows, the executable file is *chromedriver.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: As the final step, save *play_live_radio.py* in your chapter folder and run
    it. The script, also available at the book’s resources page, is shown in [Listing
    6-10](#listing6-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-10: Python code to automate online live radio'
  prefs: []
  type: TYPE_NORMAL
- en: We first import `webdriver()` from the *selenium* module. First, the script
    launches the web browser. Then, the `get()` function brings us to the live radio
    site based on the web address provided. We then define the Play button as a variable
    button, using the XPath that we’ve generated . Finally, we use `click()` in the
    *selenium* module to activate the Play button on the website. Consequently, if
    everything is installed and configured correctly, when you run the script, the
    web browser will open and the online live radio will start playing.
  prefs: []
  type: TYPE_NORMAL
- en: It’s educational to run the script line by line by using the F9 key. You will
    see that after the first line is run, the Chrome browser opens on your computer,
    and after the second, the browser brings you to the Online Radio Box site. With
    the final two lines, the Play button is being activated. You will then hear the
    live radio playing.
  prefs: []
  type: TYPE_NORMAL
- en: Voice-Activate Live Radio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll add speech recognition and text-to-speech functionality to the script
    so you can voice-activate the online live radio. The script *voice_live_radio.py*
    in [Listing 6-11](#listing6-11) shows you how to accomplish that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-11: Python code to voice-activate online live radio'
  prefs: []
  type: TYPE_NORMAL
- en: We first import all needed modules. Since we need the speech recognition and
    text-to-speech features, we import `voice_to_text()` from the local `mptpkg` package
    to convert speech to text. We also import `print_say()` from the local `mptpkg`
    package to convert text to human speech.
  prefs: []
  type: TYPE_NORMAL
- en: We then define `live_radio()` to accomplish what *play_live_radio.py* does with
    a few modifications 1. When the function is activated, the script will go to the
    online live radio station and click the Play button so that live radio starts
    playing. We use the `headless` option so you won’t see a web browser pop up. We
    also make the variable `button` a global variable so we can use the variable later
    in the script.
  prefs: []
  type: TYPE_NORMAL
- en: At 2, an infinite loop begins. At each iteration, the script asks, “How may
    I help you?” After you speak into the microphone, `voice_to_text()` converts your
    speech to text and saves it as the string variable `inp`. The `lower()` function
    converts all characters to lowercase to avoid mismatch due to letter capitalization
    3.
  prefs: []
  type: TYPE_NORMAL
- en: When you say, “Stop listening,” the `if` branch of the code is activated 4.
    The script prints `Goodbye`, the loop breaks, and the script ends. When the word
    *radio* is in your voice command, the `elif` branch of the code is activated 5.
    As a result, `live_radio()` is called, and the online live radio starts playing.
    While the radio is playing, the script is quietly listening to you in the background.
    If you say, “Stop playing” anytime when the radio is playing, the button will
    click again and the radio will change from Play to Stop. After that, the script
    exits the radio mode and returns to the main menu.
  prefs: []
  type: TYPE_NORMAL
- en: Voice-Activated Videos
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can apply the method you learned in the preceding section to voice-activate
    prerecorded online videos or even online live TV.
  prefs: []
  type: TYPE_NORMAL
- en: NBC’s *Nightly News with Lester Holt* provides prerecorded videos at [https://www.nbcnews.com/nightly-news-full-episodes/](https://www.nbcnews.com/nightly-news-full-episodes/),
    shown in [Figure 6-7](#figure6-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![f06007](Images/f06007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-7: Front page of NBC’s *Nightly News*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use Python to interact with the web browser to click the Play button that
    activates the online video. You can see a triangle-shaped Play button on the video
    frame. Follow the steps in “Control Web Pages” on page 125 to find the XPath of
    the button.
  prefs: []
  type: TYPE_NORMAL
- en: The script *voice_online_video.py* in [Listing 6-12](#listing6-12) shows how
    to voice-activate the online video.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-12: A script to voice-activate online video'
  prefs: []
  type: TYPE_NORMAL
- en: The logic is the same as when dealing with live radio. We first define `online_video()`
    to be called later. When the function is activated, the script will go to the
    site, locate the XPath of the Play button 1, and click it so the video will start
    playing.
  prefs: []
  type: TYPE_NORMAL
- en: An infinite loop starts at 2. At each iteration, the script asks, “How may I
    help you?” After you speak into the microphone, `voice_to_text()` converts your
    speech to text and saves it as an all-lowercase string variable `inp`.
  prefs: []
  type: TYPE_NORMAL
- en: When you say, “Stop listening,” the `if` branch of the code is activated. The
    script prints `Goodbye!`, the loop breaks, and the script ends. When the word
    *video* is in your voice command, the `elif` branch of the code is activated.
    As a result, `online_video()` is called, and the online video starts playing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, you learned the basics of web scraping: how HTML works, including
    the different types and uses of HTML tags, and how to use the Beautiful Soup library
    to parse HTML files and scrape the information you need.'
  prefs: []
  type: TYPE_NORMAL
- en: Armed with these techniques, you learned how to parse a source file of the podcast
    *NPR News Now* and locate its MP3 file. You then used the *webbrowser* module
    to play the online MP3\. You also learned how to voice activate online podcasts,
    using the *pygame* module to play the audio file so that you can stop it anytime
    via voice commands.
  prefs: []
  type: TYPE_NORMAL
- en: You then learned to voice activate an Online Radio Box station. Specifically,
    you learned how to use the Selenium web driver to interact with a web browser.
    You directed Python to click the Play button to activate the live radio broadcast.
    You also learned to use voice control to accomplish these tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you applied the same idea to online videos, such as NBC’s *Nightly
    News with Lester Holt*.
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify *parse_local.py* to print out the `class` attribute value and the web
    address of the `<a>` tag for the University of Kentucky Libraries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *scrape_live_web.py* to print out the information for the site area All
    Other Questions & Comments, as shown in [Figure 6-2](#figure6-2).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This URL points to a podcast by Gwyneth Paltrow and Oprah Winfrey: *https://goop.com/the-goop-podcast/gwyneth-x-oprah-power-perception-soul-purpose/.*
    Write a script to voice activate the online podcast.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Virtual Personal Assistant
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this and the next chapter, you’ll learn how to create your own virtual personal
    assistant (VPA), similar to Amazon’s Alexa. You’ll first have an overview of your
    VPA and its functionalities. You’ll then import all needed modules at once so
    you can start to run your VPA right away. You’ll create a script to make your
    VPA stand by 24/7 without disturbing you. Whenever you need assistance, you can
    say, “Hello Python” to wake it up, and when you want it to stand by again, you
    can use a voice command to put it in standby mode.
  prefs: []
  type: TYPE_NORMAL
- en: After that, you’ll examine various functionalities to add to your VPA. The first
    two are a timer and an alarm clock.
  prefs: []
  type: TYPE_NORMAL
- en: The third functionality enables your VPA to tell jokes. When you say, “Tell
    me a joke,” the script will randomly select a joke from a list and speak it out
    loud to you.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth functionality sends email. If you say, “Send Jessica an email,” the
    script will activate the email feature, retrieve Jessica’s email address from
    your recipient list, and ask you for the subject line and content, which you can
    dictate before telling the VPA to send.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 8, you’ll learn how to make your VPA capable of answering (almost)
    any question. Before you begin, set up the folder */mpt/ch07/* for this chapter.
    As always, all scripts in this chapter are available at the book’s resources page,
    [https://www.nostarch.com/make-python-talk](https://www.nostarch.com/make-python-talk)/.
  prefs: []
  type: TYPE_NORMAL
- en: An Overview of Your VPA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you learn about the functionalities of your VPA, let’s explore its structure.
    You’ll start by downloading needed files and installing a third-party module.
  prefs: []
  type: TYPE_NORMAL
- en: Download VPA Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s download the needed files. Go to the book’s resources website [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/%20)
    and download the following files from the */mpt/mptpkg/* directory: *mywakeup.py*,
    *mytimer.py*, *myalarm.py*, *myjoke.py*, and *myemail.py*. Put them in the same
    directory on your computer where you place your self-made local package files.
    Refer to Chapter 5 for instructions. I’ll explain the purpose of these files later
    in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the script *__init__.py* in the package directory */mpt/mptpkg/*
    on your computer. As you may recall from Chapter 5, you’ve already placed the
    following two lines of code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Add the five lines of code in [Listing 7-1](#listing7-1) to the end of *__init__.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-1: Importing functions from local modules to the local package'
  prefs: []
  type: TYPE_NORMAL
- en: This code imports the five functions `wakeup()`, `timer()`, `alarm()`, `joke()`,
    and `email()` from the five modules to the local package so you can later import
    them at the package level. More on this point soon.
  prefs: []
  type: TYPE_NORMAL
- en: Next, go to the book’s resources website and download *vpa.py* from the chapter
    directory */mpt/ch07/*. Save it on your computer where you place this chapter’s
    Python scripts. The code for *vpa.py* is shown in [Listing 7-2](#listing7-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-2: Python code for a VPA'
  prefs: []
  type: TYPE_NORMAL
- en: We first import the seven functions (`voice_to_text()`, `print_say()`, `wakeup()`,
    and so on) from the local package *mptpkg*. The code in [Listing 7-1](#listing7-1)
    already imported the five functions (`wakeup()`, `timer()`, and so on) from the
    local modules to *mptpkg,* so here we import the functions at the package level
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start the script by creating an infinite loop 1. At each iteration, the
    VPA listens to your voice command quietly in the background. You can say, “Hello
    Python” to wake up the VPA. After it wakes up, the VPA asks, “How may I help you?”
    and takes your voice command. You can activate one of the four functionalities
    of the VPA 2: setting a timer, setting an alarm clock, telling a joke, or sending
    an email.'
  prefs: []
  type: TYPE_NORMAL
- en: You can put the VPA back on standby when you are finished by including “back”
    and “standby” in your voice input. While the script is in standby, you can terminate
    the script by saying, “Stop the script” or “Stop listening.”
  prefs: []
  type: TYPE_NORMAL
- en: Before running *vpa.py*, you need to install a third-party module.
  prefs: []
  type: TYPE_NORMAL
- en: Install the arrow Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll first install the *arrow* module to tell the time and date for the timer
    and alarm clock functionalities in the VPA.
  prefs: []
  type: TYPE_NORMAL
- en: The Python standard library has several modules that can tell the time and date,
    including the well-known *time* and *datetime*. However, they are not very user-friendly,
    with complicated formatting. Further, you need to use several modules in the Python
    standard library to achieve what we try to accomplish in this chapter. As a result,
    we’ll use the third-party module *arrow*, which offers a more convenient way to
    deal with times.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install *arrow* in your Anaconda prompt (Windows) or a terminal (Mac
    or Linux) by using the following command, with the virtual environment *chatting*
    activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Manage the Standby Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here you’ll set up the standby mode for your VPA. At the end of this section,
    you’ll be able to activate the VPA by saying, “Hello Python.” The VPA will respond,
    “How may I help you?”
  prefs: []
  type: TYPE_NORMAL
- en: If you then say, “Go back to standby,” the script will return to standby mode
    and keep quiet. While it’s in standby, you can even choose to end the script by
    including *stop* in your voice command.
  prefs: []
  type: TYPE_NORMAL
- en: Create the Local Module mywakeup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, you’ll set the script to recognize certain commands. Open *mywakeup.py*
    you just downloaded in your Spyder editor. This script is based on *mysr.py* from
    Chapter 3, with some significant modifications. [Listing 7-3](#listing7-3) highlights
    the differences.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-3: Python code for the *my**w**akeup* module'
  prefs: []
  type: TYPE_NORMAL
- en: We first import `speech_recognition` and define `wakeup()` 1. We create a variable
    `wakeup` and set the default value as `StandBy`. We then capture the voice input
    from the microphone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here I did a little tweaking to make the script more responsive: the `timeout=3`
    option in the `listen()` method tells the script to time out every three seconds
    and analyze the voice input 2, meaning it checks for a voice command every three
    seconds. Without this option, the script may wait too long to respond, and you
    may have to say, “Hello Python” a couple of times before you catch the script’s
    attention.'
  prefs: []
  type: TYPE_NORMAL
- en: We convert all text to lowercase to avoid mismatch due to capitalization. We
    also use exception handling to prevent the script from crashing.
  prefs: []
  type: TYPE_NORMAL
- en: When a voice command is captured, the script checks whether *hello* and *Python*
    are in the voice input. If yes, the variable `wakeup` changes its value to `Activated`.
    Similarly, if you say, “Stop listening” or “Stop the script,” the variable `wakeup`
    changes to `ToQuit`. When the function is called, it will return whatever value
    is stored in the variable `wakeup`.
  prefs: []
  type: TYPE_NORMAL
- en: Set Some Responses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you know how the *mywakeup* module works, let’s learn how to manage
    standby mode.
  prefs: []
  type: TYPE_NORMAL
- en: Run *vpa.py* in your Spyder editor. You’ll notice that when the script is running,
    nothing happens. However, your VPA is quietly listening in the background. You
    can activate the VPA by saying, “Hello Python.” Once the job is done, you can
    put it back to standby.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output is from one interaction with the script, with my voice
    input in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, I activated the VPA and then put it back to standby. I activated
    the VPA and then returned it to standby a second time. After that, I said, “Stop
    listening” to end the script.
  prefs: []
  type: TYPE_NORMAL
- en: Run the script several times to ensure that you can voice-activate the VPA,
    put it on standby, and end the script. Next, we’ll examine the individual functionalities
    of the VPA one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Ask Your VPA to Set a Timer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s explore the first feature: setting a timer. To do that, you’ll first
    learn how to tell time in Python. We’ll use the *arrow* module to tell time in
    Python and then create a timer that takes written commands. Finally, we’ll create
    a `timer()` function in the local module *mytimer* that we’ll import into the
    VPA script; this will allow us to set a timer by using voice commands.'
  prefs: []
  type: TYPE_NORMAL
- en: Tell the Time with Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s first learn how to tell time with Python.
  prefs: []
  type: TYPE_NORMAL
- en: The following script, *get_time.py,* shows how to retrieve the current time
    for your time zone in different formats. This is just an example so you can familiarize
    yourself with the *arrow* module; it’s not part of the VPA script.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: We first import the *arrow* module. Its `now()` function gives you the current
    local date and time, but you need to use `format()` to let the script know the
    format and level of detail of that information.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 7-1](#table7-1) lists some commonly used formats and the meanings associated
    with the `format()` function in *arrow*. For example, the uppercase `HH` and `H`
    generate the current hour value in a 24-hour clock, with and without a leading
    0, respectively, whereas `hh` and `h` do the same in a 12-hour clock.'
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we retrieve the current time in `H:m:s` format on a 24-hour clock and
    then print it out. At 2, we obtain the time on a 12-hour clock, followed by AM
    or PM, in the format `hh:mm:ss`. Finally we print out just the hour value of the
    current time 3. You can do the same for the minute value or the second value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run this script, you’ll have output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Table 7-1: Some Commonly Used Formats for the `format()` Method of the *arrow*
    Module'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Format code** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `dddd` | Full weekday name |'
  prefs: []
  type: TYPE_TB
- en: '| `ddd` | Abbreviated weekday name |'
  prefs: []
  type: TYPE_TB
- en: '| `MMM` | Abbreviated month name |'
  prefs: []
  type: TYPE_TB
- en: '| `MMMM` | Full month name |'
  prefs: []
  type: TYPE_TB
- en: '| `YYYY` | Year in normal form (for example, 2021) |'
  prefs: []
  type: TYPE_TB
- en: '| `HH` | Hour (24-hour clock) as a decimal number with leading zero |'
  prefs: []
  type: TYPE_TB
- en: '| `hh` | Hour (12-hour clock) as a decimal number with leading zero |'
  prefs: []
  type: TYPE_TB
- en: '| `A` | AM or PM |'
  prefs: []
  type: TYPE_TB
- en: '| `mm` | Minute as a decimal number with leading zero |'
  prefs: []
  type: TYPE_TB
- en: '| `ss` | Second as a decimal number with leading zero |'
  prefs: []
  type: TYPE_TB
- en: 'You can also use the *arrow* module to get today’s date and weekday information,
    shown here in the *get_date.py* script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: At 1, we use `now()` to generate the current date and time and save it in a
    string variable `today_date`. At 2, we print out the date in the format of January
    01, 2021, with an abbreviated form of the month name, and in numbers using the
    pattern MM/DD/YYYY. At 3, we print out the day of the week and then again in abbreviated
    form.
  prefs: []
  type: TYPE_NORMAL
- en: 'This script generates output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know how to tell time in Python, you’ll learn how to set a timer.
  prefs: []
  type: TYPE_NORMAL
- en: Build a Timer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll use our new *arrow* module skills with the `sleep()` function from the
    *time* module to build a timer that takes written commands. You won’t use this
    in your VPA script, but you’ll learn the skills needed to build a timer that takes
    voice commands.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll restrict the input to take hours only, minutes only, or hours and minutes
    (the script won’t take seconds). So you can set the timer to go off in 2 hours,
    or in 1 hour 30 minutes, or in 20 minutes—but not in 1 hour 30 minutes 20 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go into the details of the script, let’s understand the logic behind
    it. Your written command should be in the form of `set a timer for 1 hour 20 minutes`,
    `set a timer for 2 hours`, or `set a timer for 25 minutes`. The script then saves
    your written command in the string variable `inp`.
  prefs: []
  type: TYPE_NORMAL
- en: The string method `find()` returns a value of `-1` if the characters you’re
    looking for are not in the string. We’ll use this feature to extract the hour
    and minute values in `inp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three cases:'
  prefs: []
  type: TYPE_NORMAL
- en: The value of `inp.find("hour")` is not `-1`, while the value of `inp.find("minute")`
    is `-1`. This means `minute` is not in the variable `inp` but `hour` is. You’ve
    set the timer in the form of `set a timer for 2 hours`. We extract the hour value
    between `timer for` and `hour` and set the minute value to `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of `inp.find("hour")` is `-1`, and the value of `inp.find("minute")`
    is not `-1`. This means `minute` is in the variable `inp` but not `hour`. You’ve
    set the timer in the form of `set a timer for 25 minutes`. We extract the minute
    value between `timer for` and `minute` and set the hour value to `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neither the value of `inp.find("hour")` nor the value of `inp.find("minute")`
    is `-1`. This means both `hour` and `minute` are in the variable `inp`. You’ve
    set the timer in the form of `set a timer for 1 hour 20 minutes`. We extract the
    hour value between `timer for` and `hour` and the minute value between `hour`
    and `minute`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll add that amount of time to the current time to determine when the timer
    should go off. We then check the time every 0.5 seconds to make sure we don’t
    miss when the timer should go off. When the time reaches the preset time, the
    timer goes off.
  prefs: []
  type: TYPE_NORMAL
- en: The timer is set in *timer.py* in [Listing 7-4](#listing7-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-4: The script to set a timer'
  prefs: []
  type: TYPE_NORMAL
- en: We first print out the instructions. At 1, the script takes the user’s written
    input specifying how long to set the timer, then saves this to the variable `inp`.
  prefs: []
  type: TYPE_NORMAL
- en: We then check whether the input included `hour` and `minute`. If `minute` is
    not in the input 2, we set the value of `addminute` to `0` and set the value of
    `addhour` to whatever number is between `timer for` and `hour`. We use similar
    methods to handle cases when `hour` is not in the written command 3 or when both
    `hour` and `minute` are in the written command 4.
  prefs: []
  type: TYPE_NORMAL
- en: The function `now()` from the *arrow* module obtains the current time in hour,
    minute, and second values. We add the values of `addminute` and `addhour` to the
    current time to obtain the time when the timer should go off. At 5, we adjust
    for the cases when the minute value exceeds 59 or the hour value exceeds 23\.
    We then set the time the alarm should go off in the `H:m:s` format.
  prefs: []
  type: TYPE_NORMAL
- en: We start an infinite `while` loop to check the current time every 0.5 seconds.
    When the current time reaches the alarm time, we set off the alarm. The script
    prints `Your timer has gone off!` and the script ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example interaction with *timer.py*, with user input in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Create the mytimer Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll create a `timer()` function that’s similar to the *timer.py* script,
    but we’ll use a voice command instead of a written one.
  prefs: []
  type: TYPE_NORMAL
- en: Open the file *mytimer.py* you just downloaded from the book’s resources website
    and open it in your Spyder editor. The module will define the function `timer()`
    that your VPA will use, shown in [Listing 7-5](#listing7-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-5: The script for the local *mytimer* module'
  prefs: []
  type: TYPE_NORMAL
- en: Set the Timer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you’ll test the first functionality of your VPA. Let’s zoom in to the part
    where you can activate the timer in your VPA script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ve imported the `timer()` function to the script. Second, the `elif`
    branch between the `if` branch and `else` branch in the inner `while` loop is
    where you can set a timer.
  prefs: []
  type: TYPE_NORMAL
- en: If you run *vpa.py*, it will start in standby mode. You can wake it up by saying,
    “Hello Python.” Then you can set a timer by saying, “Set a timer for 1 hour 20
    minutes” or “Set a timer for 2 hours.”
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output is from one interaction with the script, with my voice
    input in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, I first activate the VPA and then set a timer for one minute.
    The VPA tells me, “Your timer will go off at 21:37:46.” After one minute, the
    timer goes off.
  prefs: []
  type: TYPE_NORMAL
- en: Ask Your VPA to Set an Alarm Clock
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you’ll learn how to ask your VPA to set an alarm clock. You’ll first use
    written commands to set the alarm clock. You’ll then create a *myalarm* module,
    in which you define an `alarm()` function. Finally, you’ll import `alarm()` to
    the VPA script to set the alarm clock by using voice commands.
  prefs: []
  type: TYPE_NORMAL
- en: Build an Alarm Clock
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Building an alarm clock is similar to setting a timer, except that we specify
    the time the alarm should go off rather than saying it should go off a certain
    time from now. You can either specify an hour value alone, such as 8 pm, or an
    hour and minute value, such as 7:25 am.
  prefs: []
  type: TYPE_NORMAL
- en: The script will take written commands for now. The script *alarm_clock.py* is
    shown in [Listing 7-6](#listing7-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-6: The script to set an alarm clock'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the script captures our written input and saves it as the string variable
    `inp`. We then look for the positions of the four indicators: `alarm for`, `a.m.`,
    `p.m.`, and `:` 1. If you include the colon in your input, the script knows to
    check for a minute value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on what you pass at 2, one of four scenarios results:'
  prefs: []
  type: TYPE_NORMAL
- en: You input `a.m.` and specify hour and minute values. We extract the preset time
    value between `set alarm for` and `a.m.`, convert it to a string, and add `AM`
    at the end. For example, if you input `set an alarm for 7:34 a.m.`, the returned
    string value is `7:34 AM`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You input `p.m.` and specify the hour and minute value. We extract the preset
    time value, convert it to a string, and add `PM` at the end. For example, if you
    input `set an alarm for 2:55 p.m.`, the returned string value is `2:55 PM`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You input `a.m.` but specify only an hour value. We extract the preset time
    value, convert it to a string, and add `:00 AM` at the end. For example, if you
    input `set an alarm for 7 a.m.`, the returned string value is `7:00 AM`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You input `p.m.` but specify only an hour value. We extract the preset time
    value, convert it to a string, and add `:00 PM` at the end. For example, if you
    input `set an alarm for 3 p.m.`, the returned string value is `3:00 PM`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we’ve extracted the time when the alarm should go off, we start an infinite
    loop 3. At each iteration, we check the current time every five seconds in the
    7:25 AM format.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we check whether the time we set for the alarm clock matches the current
    time. If the times match, the alarm clock goes off, and the script prints `Your
    alarm has gone off!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the script and use it to set an alarm clock for yourself. Try all four
    cases: with and without the minute value, with either `a.m.` or `p.m.` at the
    end. Next, we’ll create an alarm clock module based on this script.'
  prefs: []
  type: TYPE_NORMAL
- en: Create the Alarm Clock Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll create the `alarm()` function that will use the *alarm_clock.py* code.
    This code will take voice input instead of written input and give both voice and
    text output.
  prefs: []
  type: TYPE_NORMAL
- en: Open *myalarm.py*, which you just downloaded from the book’s resources website,
    and open it in your Spyder editor. The script will define the function `alarm()`
    that your VPA will use, shown in [Listing 7-7](#listing7-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-7: The script for the local *myalarm* module'
  prefs: []
  type: TYPE_NORMAL
- en: Set an Alarm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you can ask your VPA to set an alarm clock for you. Let’s zoom in on the
    part of *vpa.py* that can set an alarm clock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: First, we’ve imported the `alarm()` function in the local *myalarm* module to
    the script from the self-made package *mptpkg*. Second, an `elif` branch is in
    the inner `while` loop, where you can activate the alarm clock by including *alarm
    for* and either *a.m.* or *p.m.* in your voice command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run *vpa.py*. You can set an alarm clock after waking up your VPA. The following
    output is from one interaction with the script, with my voice input in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Ask Your VPA to Tell a Joke
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to ask your VPA to tell a joke. You’ll find
    a good joke list to pull from, then create a joke module and import it to your
    main script so that your VPA can tell you jokes in a human voice.
  prefs: []
  type: TYPE_NORMAL
- en: Create Your Joke List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can create a joke list from many resources. I’m using the Quick, Funny Jokes!
    website ([https://www.quickfunnyjokes.com/math.html](https://www.quickfunnyjokes.com/math.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'I selected 15 jokes and saved them in a file called *jokes.txt* in the chapter
    folder */mpt/ch07/* on my computer. You can use as many jokes as you like, as
    long as you also save them in a separate text file as we are doing here. Here
    are my 15 jokes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Next, you’ll learn in detail how to create the joke-telling module.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Joke Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, you’ll create a `joke()` function. When the function is called,
    it will go to the file *jokes.txt* on your computer, access its content, and break
    it into individual jokes and put them in a list. It will then randomly select
    a joke from the list and read it out loud to you.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll import the script *myjoke.py*, shown in [Listing 7-8](#listing7-8), as
    a local module in your VPA.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-8: The script to create a *joke* module'
  prefs: []
  type: TYPE_NORMAL
- en: First, we import the *random* module, which we’ll use to randomly select a joke
    from the list. At 1, we start the definition of `joke()`.
  prefs: []
  type: TYPE_NORMAL
- en: We then read the content from *jokes.txt* and put the content in the string
    variable `content` 2. Note that since we put *jokes.txt* in a different directory
    from the module script *myjoke.py*, we need to specify the path of the file, and
    `../ch07/` tells Python that the file is in a parallel folder called *mptpkg*.
    This way, we can use the joke-telling functionality in other chapters as well,
    which we will do in Chapter 17\.
  prefs: []
  type: TYPE_NORMAL
- en: We know that individual jokes are separated by double line breaks, so we use
    `split()` to separate the content of the file into individual strings and put
    them in the list `jokelist` 3. We then randomly select a joke by using `choice()`
    from the *random* module. Finally, the script prints out and speaks aloud the
    selected joke.
  prefs: []
  type: TYPE_NORMAL
- en: Tell a Joke
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you’ll import the joke module you just created to your VPA so that it can
    tell you jokes in a human voice. Let’s zoom in on the part of *vpa.py* that can
    tell a joke:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: We first import the `joke()` function in our newly made *myjoke* module from
    the local *mptpkg* package. In the inner `while` loop section of the VPA code
    is an `elif` branch, in which we tell the VPA that if *tell* and *joke* are in
    your voice command, the joke-telling functionality is activated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the outcome from one interaction with the script *vpa.py*, with my input
    in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Send Hands-Free Email
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll examine the functionality of sending email 100 percent
    hands-free. You’ll first learn how to send an email by using written commands
    in Python; this will give you the skill set to create an email module that takes
    voice commands. After that, you’ll import the email module to your VPA so you
    can send email with your voice.
  prefs: []
  type: TYPE_NORMAL
- en: Send Email with Written Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before moving on, you need to prepare a few things.
  prefs: []
  type: TYPE_NORMAL
- en: First, you need an email account from which to send email via Python. This example
    uses my Gmail account, [ukmarkliu@gmail.com](mailto:ukmarkliu@gmail.com), which
    you should replace with your own email address.
  prefs: []
  type: TYPE_NORMAL
- en: Gmail and many other email providers require you to apply for a separate application
    password, which is different from your regular email password. For example, the
    Google Account Help page shows how to set up your Gmail app password; see [https://support.google.com/accounts/answer/185833/](https://support.google.com/accounts/answer/185833/).
  prefs: []
  type: TYPE_NORMAL
- en: Sending email in Python requires a few steps. You’ll first need to connect to
    your email provider’s Simple Mail Transfer Protocol (SMTP) server. SMTP is an
    internet standard for sending email. Once the connection is established, you’ll
    need to log in using your email address and password. You’ll then provide the
    recipient’s email address, the subject line, and the email content. Finally, you’ll
    ask Python to send the actual email.
  prefs: []
  type: TYPE_NORMAL
- en: The *smtplib* module is in the Python standard library, so no installation is
    needed. You also need at least one email as the recipient’s address. You can use
    another one of your own email addresses or ask for a friend’s.
  prefs: []
  type: TYPE_NORMAL
- en: The script *emails.py* can take your written commands and send out email using
    Python, as shown in [Listing 7-9](#listing7-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-9: The script to send an email using Python'
  prefs: []
  type: TYPE_NORMAL
- en: We import the *smtplib* module and create a dictionary *emails* to match names
    with email addresses. This way, when you type in a person’s name, the script will
    retrieve the corresponding email from the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we connect to the Gmail SMTP. If you aren’t using Gmail, you’ll need to
    search for the domain name and port number of your email provider. No change is
    needed if you are using Gmail.
  prefs: []
  type: TYPE_NORMAL
- en: We then start the communication with your email server and the Transport Layer
    Security (TLS) encryption. The TLS encryption is needed by the script for security
    reasons. Once the connection is established, you need to log in using your email
    address and password, so make sure to replace `ukmarkliu@gmail.com` with your
    own email address. I’ve blocked out my Gmail password in the code.
  prefs: []
  type: TYPE_NORMAL
- en: The script then requests several pieces of information in order to send the
    email 2. It first requests the name of the recipient, which you must already have
    stored in the dictionary `emails` for the script to retrieve. With the name, the
    script retrieves the email from the dictionary. It will then also ask you for
    the email subject line and email content, which you enter in the IPython console
    at the lower-right corner of your computer screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'At 3, we send out the email with `sendmail()`, which takes three inputs: your
    email address; the recipient’s email address; and the subject line and the email
    content, separated by the line break escape character \`n`.'
  prefs: []
  type: TYPE_NORMAL
- en: Once done, the script will confirm that the email has been sent. Try this script
    yourself and make sure that you can send email using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll create the module to send email using Python and then add it to
    your VPA.
  prefs: []
  type: TYPE_NORMAL
- en: Create the Email Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We first need to create the script *myemail.py* to use as a local module in
    your VPA. In the module, we define an `email()` function. Once called, it will
    connect to your email server and ask you for voice inputs—the recipient’s name,
    the subject line, and the email content—before sending out the actual email.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of *myemail.py* is similar to that of *emails.py*, with a few differences:
    the script will ask you for input using voice as well as printed messages, and
    you need to use voice input instead of written input. The differences are highlighted
    in [Listing 7-10](#listing7-10).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-10: The script to create a local *myemail* module'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you need to import `voice_to_text()` from your local *mptpkg*
    package to capture your voice input to dictate the recipient’s name, email subject
    line, and content. You also need `print_say()` from your local *mptpkg* package
    to print and speak messages.
  prefs: []
  type: TYPE_NORMAL
- en: Now the module is ready to be imported to the VPA script.
  prefs: []
  type: TYPE_NORMAL
- en: Add the Email Functionality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, you need to import `email()` from *myemail.py* into your VPA so that
    you can send email 100 percent hands-free. Let’s zoom in to the part of *vpa.py*
    that can send an email:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: We import the `email()` function in the local *myemail* module from the local
    *mptpkg* package. There’s an `elif` branch in which you can activate the email-sending
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example interaction with *vpa.py*, with my voice input in bold. All
    output is printed as well as spoken out loud.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: First, you should wake up your VPA. After you say, “Send an email,” the email
    feature is activated. The VPA then asks you for the recipient’s name—I gave my
    own name, and my University of Kentucky (UKY) email address was matched to it.
    It also asks for the subject line and email content. Once the information is collected,
    the email is sent, and the script exits the email functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-1](#figure7-1) shows the email I received as a result in my UKY email
    account.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f07007](Images/f07007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-1: An email sent using a Python script 100 percent hands-free'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create a VPA that can set an alarm and timer,
    tell jokes, and even send email hands-free! You wake your VPA with “Hello Python”
    and then give it an instruction to activate one of the four functionalities. This
    chapter taught you how to create a new feature, make it into a local module, and
    use it in your main script.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn how to use the WolframAlpha API to tap into
    the vast knowledge space on the website so that your VPA will be able to answer
    (almost) any question.
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a script to print out a message and speak aloud today’s date and time,
    formatted as “Today is September 8, 2021, and the time now is 09:03:07 AM.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *mywakeup.py* so that the only way to end the script *vpa.py* is by saying,
    “Quit the script.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Know-It-All VPA
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: The VPA we created in Chapter 7 can set a timer or an alarm clock for you, tell
    you jokes, or send your email. Now we’ll upgrade it so you can ask it about nearly
    anything—including daily news and weather, gas prices, and travel information—and
    tap into its nearly unlimited knowledge of science, math, history, and society.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll access the storehouse of information in the computational
    engine WolframAlpha and use Wikipedia as a backup if WolframAlpha can’t provide
    an answer. If neither site can answer, your VPA will tell you, “I am still learning,
    and I don’t know the answer to that yet.” Your VPA will be complete and capable
    of answering almost any question.
  prefs: []
  type: TYPE_NORMAL
- en: Before you begin, set up the folder */mpt/ch08/* for this chapter. As always,
    all scripts in this chapter are available at the book’s resources page.
  prefs: []
  type: TYPE_NORMAL
- en: Get Answers from WolframAlpha
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*WolframAlpha* is a computational knowledge engine that provides an online
    service for factual queries, with a focus on numerical and computational capabilities,
    especially in the areas of science and technology. In this section, you’ll learn
    how to get answers from WolframAlpha through its API and then write a Python script
    to retrieve information.'
  prefs: []
  type: TYPE_NORMAL
- en: Apply for an API Key
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step is to apply for an API key. WolframAlpha gives you up to 2,000
    noncommercial API calls per month at no charge. Go to [https://account.wolfram.com/login/create/](https://account.wolfram.com/login/create/)
    and complete the steps to create an account, as shown in [Figure 8-1](#figure8-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f08001](Images/f08001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-1: Create your free Wolfram ID.'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Create Wolfram ID** and then log in. The Wolfram ID itself gives you
    only browser access, so you need to get an AppID to gain query access using Python.
    Apply for an API at [https://products.wolframalpha.com/api/](https://products.wolframalpha.com/api/)and
    click**Get API Access** in the bottom left, as shown in [Figure 8-2](#figure8-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![f08002](Images/f08002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-2: Apply for an API at WolframAlpha.'
  prefs: []
  type: TYPE_NORMAL
- en: A small dialog should pop up, as shown in [Figure 8-3](#figure8-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![f08003](Images/f08003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-3: The Get a New AppID window at WolframAlpha'
  prefs: []
  type: TYPE_NORMAL
- en: Fill in the Application name and Descriptioninformation, then click **Get AppID**.
    For example, you might enter `Virtual assistant` as the application name and `Learn
    to build my own virtual personal assistant in Python` in the description field.
  prefs: []
  type: TYPE_NORMAL
- en: After that, your AppID should appear in a pop-up window. You need to click **OK**
    to activate the AppID. The key will be a long, unique string of characters to
    distinguish you from other users, something like `HG**************YQ` (I’ve blocked
    out the middle characters). Save your AppID in a safe place; you’ll need it later.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve Information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have your WolframAlpha API, you can use a Python script to send queries
    and obtain answers from WolframAlpha. You must first install the third-party *wolframalpha*
    module on your computer. Go to your Anaconda prompt (Windows) or a terminal (Mac
    or Linux) and activate the virtual *chatting* environment; then run the following
    at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Follow the instructions to finish the installation.
  prefs: []
  type: TYPE_NORMAL
- en: The *wolfram.py* script in [Listing 8-1](#listing8-1) retrieves information
    from WolframAlpha by using text input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-1: Python code for the script *w**olfram**.**py*'
  prefs: []
  type: TYPE_NORMAL
- en: We first import the *wolframalpha* module. Enter the API key you retrieved earlier
    as the value of the `APIkey` variable. Without it, the script won’t work.
  prefs: []
  type: TYPE_NORMAL
- en: We then create the client with your AppID. At 1, the script asks the user for
    a query to send to WolframAlpha, which the user will enter in the IPython console
    at the lower-right panel of the Spyder IDE.
  prefs: []
  type: TYPE_NORMAL
- en: At 2, we send the query to WolframAlpha and retrieve the `result` object, saving
    it in the variable `response`. The `result` object contains a collection of results
    in a generator object. *Generator functions* are a convenient shortcut to building
    iterators, sometimes used to avoid keeping large amounts of data in short-term
    memory (RAM). You can learn more about generators from authoritative online sources
    (for example, [https://wiki.python.org/moin/Generators](https://wiki.python.org/moin/Generators)).
    This is why we use the built-in function `next()` to iterate through different
    answer groups from WolframAlpha in the `result` object and obtain the text part
    of the answer. For a detailed description of how the querying process works with
    the *wolframalpha* module, see [https://pypi.org/project/wolframalpha/](https://pypi.org/project/wolframalpha/).
    Finally, the extracted text is printed out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple exchange with *wolfram.py*, with my text input in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, WolframAlpha has given me a correct and succinct answer.
  prefs: []
  type: TYPE_NORMAL
- en: Explore Different Areas of Knowledge
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WolframAlpha can provide information on a variety of topics, so we’ll put *wolfram.py*
    through its paces with questions about weather, general knowledge, science, and
    math before adding the API to your VPA.
  prefs: []
  type: TYPE_NORMAL
- en: Real-Time Information
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'WolframAlpha provides real-time information, such as the current temperature
    in your area. Here’s one interaction with the script *wolfram.py*, with my written
    input in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: The script tells you the temperature in Fahrenheit and the length of time that
    has passed since the information was obtained. WolframAlpha gets your local information
    by looking at the location associated with your IP address. If you have an active
    virtual private network (VPN), your local information will be for the location
    of your VPN provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also obtain a weather forecast for a specific day in a certain location
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check other real-time information such as local gas price or US inflation
    rate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: General Questions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can ask general knowledge questions, such as how many teaspoons are in
    a cup, how to convert Fahrenheit to Celsius, the regional sales tax rate, a state
    capital, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'WolframAlpha has gathered information from various sources such as the CIA’s
    *The World Fact Book* and *The United States Geological Survey*, so it has comprehensive
    historical data. You can ask questions about events, people, or facts, such as
    when the vehicle airbag was invented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even use WolframAlpha as a dictionary by using *define*, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Math Calculations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: WolframAlpha can answer your questions in the fields of mathematics, science,
    and technology, ranging from elementary math to calculus to differential equations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want to convert 125 to binary, you can use *wolfram.py*
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The `2` at the end of the output indicates that the response is in binary format.
    Wolfram Alpha can also answer your personal finance questions on topics such as
    mortgage payments, credit card calculations, and state taxes. For example, to
    calculate your monthly mortgage payment, you just need to provide three pieces
    of information—loan amount, interest rate, and loan term—and you’ll get the answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Using the keyword `mortgage`, you tell the script the loan amount `$150,000`,
    the interest rate `6.5%`, and the term `30 years`. Know that the formatting of
    your query doesn’t really matter—you don’t need a comma in the number and you
    could provide the arguments in any order, and the script should understand.
  prefs: []
  type: TYPE_NORMAL
- en: Add a Know-It-All Functionality to Your VPA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our goal here is to add a know-it-all functionality to the VPA you created in
    Chapter 7. We will rely mainly on WolframAlpha to answer your questions, but there
    are questions WolframAlpha can’t answer. In that case, we’ll search in Wikipedia.
    If Wikipedia can’t provide an answer either, the VPA will let you know that it
    doesn’t have an answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make use of the next script, be sure to install the following package with
    your virtual environment activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: What WolframAlpha Cannot Answer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though WolframAlpha has a vast knowledge base, it doesn’t know the answers
    to all questions. Wikipedia can provide more answers than Wolfram Alpha in certain
    areas, especially for general reference questions. For example, if you enter `University
    of Kentucky` as a query in *wolfram.py*, the script will raise a `StopIteration`
    exception. This is because `next()` cannot find a result in any answer group.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if you run the script *wiki.py* from Chapter 5 and enter
    `University of Kentucky` as a query, you’ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Wikipedia can’t answer all your questions, either. For example, if you enter
    `how many people live outside the earth` as a query in *wiki.py*, the API will
    raise a `PageError` exception that causes this version of the script to abruptly
    end with an error status.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll improve our VPA by writing a script that queries WolframAlpha first and,
    if no results are found, will query Wikipedia. If you can’t get an answer there,
    the script will print out the message `I am still learning. I don't know the answer
    to your question yet.` We’ll handle the errors raised by these external APIs by
    enclosing the calls in a `try` block and handling the exceptions in an `except`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: Go to the book’s resources page, download *know_all.py*, and save it in your
    chapter folder. This script is shown in [Listing 8-2](#listing8-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-2: Python code for the script *k**now_all**.py*'
  prefs: []
  type: TYPE_NORMAL
- en: We first import the two modules *wolframalpha* and *wikipedia*. At 1, you should
    put your own WolframAlpha AppID in the script for it to work. We then put the
    script in an infinite `while` loop. At each iteration, it takes your text input
    as a query. If you key in the word `done`, the `while` loop stops and the script
    ends.
  prefs: []
  type: TYPE_NORMAL
- en: The script sends the query first to WolframAlpha. We use `try` and `except`
    to handle any errors that the API from WolframAlpha might raise. If Wolfram Alpha
    doesn’t return an answer, the script directs the same query to Wikipedia. If there’s
    no answer found from Wikipedia, the script prints `I am still learning. I don't
    know the answer to your question yet.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you run the script *know_all.py* and enter `University of Kentucky`
    and `How many people live outside the earth?` as the two queries, you’ll get the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the script never crashes, and it provides a result for the first
    query but not the second.
  prefs: []
  type: TYPE_NORMAL
- en: Create the myknowall Module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll create the `know_all()` function that will use the script *myknowall.py*,
    butthis time will take voice commands instead of written commands and will both
    print and speak the response instead of just printing out messages.
  prefs: []
  type: TYPE_NORMAL
- en: Download *myknowall.py* from the book’s resources and save it in your local
    package folder */mpt/mptpkg/*. Since we’ll use this as one of the local modules
    in the local package, be sure to save it in the local package folder instead of
    the chapter folder. The script will define the function `know_all()` that your
    VPA will use, shown in an abbreviated format in [Listing 8-3](#listing8-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 8-3: The script for the local *myk**nowall* module'
  prefs: []
  type: TYPE_NORMAL
- en: The content of `know_all()` is similar to the script *know_all.py* except that
    the input and output include voice.
  prefs: []
  type: TYPE_NORMAL
- en: A VPA That Can Answer (Almost) Any Question for You
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you’ll make your VPA capable of answering (almost) any question, using the
    *know_all.py* module.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open the script *__init__.py* in the package directory */mpt/mptpkg/*
    on your computer. Add the following line of code at the end of the file and save
    the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: This code imports `know_all()` from the *myknowall* module to the local package
    so you can later import it at the package level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open *vpa.py* from the previous chapter, add the following to the script,
    and save it as *vpa.py* in this chapter’s folder. You’ll need to delete the original
    `else` branch in the inner `while` loop and replace it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: We import `know_all()` from the local *mptpkg* package and replace the original
    `else` branch. In *vpa.py* in Chapter 7, if none of the four functionalities is
    activated, the script goes to the next iteration. In the new script *vpa.py*,
    if none of the four functionalities is activated, the know-it-all functionality
    is activated, and by default the script searches for answers in WolframAlpha and
    Wikipedia.
  prefs: []
  type: TYPE_NORMAL
- en: Note here that we’ve added a condition `if len(inp)>6` before we call `know_all()`.
    Without the condition, if you don’t say anything for a long period of time, the
    script treats the input as an empty string. As a result, you’ll keep hearing the
    answer `I am still learning. I don't know the answer to your question yet.` With
    the condition, if you don’t say anything, the script goes to the next iteration
    without doing anything because the length of an empty string is 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run *vpa.py* and wake it up by saying, “Hello Python.” After that, you can
    ask any question you want. Here’s the output from an example interaction with
    the script, with my voice input in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, after activating the VPA, I first asked who the US president
    was in 1981\. The answer includes two presidents, because the transition of power
    was in January 1981\. After that, I asked about the coronavirus. The VPA provided
    a detailed answer to the question.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you upgraded the VPA from Chapter 7 so you can ask it just
    about anything—including for up-to-date information about weather, gas prices,
    and travel conditions, as well as nearly unlimited facts about science, math,
    history, and society.
  prefs: []
  type: TYPE_NORMAL
- en: You learned to apply for an API and gain access to the vast knowledge base in
    the computational engine WolframAlpha, and you can use Wikipedia as a backup when
    WolframAlpha can’t provide an answer. If neither site can answer, your VPA tells
    you as much. With that, your VPA is complete and capable of answering almost any
    question for you. Using APIs like this is an incredibly powerful skill.
  prefs: []
  type: TYPE_NORMAL
- en: In the next couple of chapters, you’ll learn how to create your own voice-controlled
    graphical games that can speak to you.
  prefs: []
  type: TYPE_NORMAL
