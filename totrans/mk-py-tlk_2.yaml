- en: Part II
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分
- en: Learning to Talk
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 学习说话
- en: '3'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Speech Recognition
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 语音识别
- en: '![](Images/chapterart.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: In this chapter, we’ll begin interacting with Python through speech. We’ll first
    install the *SpeechRecognition* module; the installation process can be a source
    of frustration and will therefore require some careful attention. You’ll then
    create a script to let Python recognize your speech and print it out to ensure
    that the voice recognition function works smoothly on your computer.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过语音与Python互动。我们将首先安装*SpeechRecognition*模块；安装过程可能会让人感到沮丧，因此需要特别注意。然后，你将创建一个脚本，让Python识别你的语音并打印出来，确保语音识别功能在你的计算机上能够顺利运行。
- en: You’ll use voice control to complete several tasks, including voice dictation,
    opening web browsers, opening files, and playing music on your computer. You’ll
    put all code related to speech recognition into a custom local module so the final
    script is concise and easy to read.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用语音控制完成几个任务，包括语音听写、打开网页浏览器、打开文件和播放计算机上的音乐。你会把所有与语音识别相关的代码放入一个自定义本地模块中，这样最终的脚本简洁易读。
- en: Before you begin, set up the folder */mpt/ch03/* for this chapter. All scripts
    in this chapter are available at the book’s resources page, [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，为本章创建文件夹*/mpt/ch03/*。本章所有脚本都可以在本书的资源页面找到，[https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/)。
- en: Install the SpeechRecognition Module
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装SpeechRecognition模块
- en: Installing the *SpeechRecognition* module can be tricky, even to the point of
    frustration. Don’t panic; we’ll discuss how to install it in Windows, Mac, and
    Linux. Installing the *SpeechRecognition* module takes an extra step compared
    to most modules because it relies on the *pyaudio* module, which we’ll have to
    install manually. The *pyaudio* module provides bindings for the cross-platform
    audio input/output library *portaudio*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 安装*SpeechRecognition*模块可能会有些棘手，甚至让人感到沮丧。别慌，我们会讨论如何在Windows、Mac和Linux上安装它。安装*SpeechRecognition*模块比大多数模块多了一步，因为它依赖于*Pyaudio*模块，我们需要手动安装它。*Pyaudio*模块提供了跨平台音频输入/输出库*Portaudio*的绑定。
- en: You cannot `pip install` the *pyaudio* module in the Anaconda prompt either.
    Instead, you need to `conda install` it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你也不能在Anaconda提示符中使用`pip install`安装*Pyaudio*模块。相反，你需要使用`conda install`来安装它。
- en: In Windows
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Windows中
- en: 'First, you need to activate the virtual environment *chatting* from Chapter
    2. Go to your Anaconda prompt and enter the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要从第2章激活虚拟环境*chatting*。去你的Anaconda提示符，输入以下命令：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should see a modified prompt:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个修改过的提示符：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that the `(chatting)` in the prompt indicates that you are now in the virtual
    environment *chatting*. If the command hasn’t worked, return to Chapter 2 for
    full instructions on how to create and activate a virtual environment.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，提示符中的`(chatting)`表示你现在处于虚拟环境*chatting*中。如果命令没有成功，返回到第2章，查看如何创建和激活虚拟环境的完整说明。
- en: 'Next, enter the following in the Anaconda prompt:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在Anaconda提示符中输入以下命令：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you then try to import it and run a script, Spyder will tell you that you
    need the *pyaudio* module for the *SpeechRecognition* module to run correctly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试导入并运行脚本，Spyder会告诉你需要*Pyaudio*模块才能使*SpeechRecognition*模块正常运行。
- en: 'With the virtual environment *chatting* activated, run the following in your
    Anaconda prompt:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟环境*chatting*激活的情况下，在你的Anaconda提示符中运行以下命令：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Follow the instructions all the way through.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照说明完成所有步骤。
- en: In Mac or Linux
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Mac或Linux中
- en: 'First, activate the virtual environment *chatting*. Open a terminal and enter
    and execute the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，激活虚拟环境*chatting*。打开终端，输入并执行以下命令：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, execute the following in the terminal:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在终端中执行以下命令：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you now try to import *SpeechRecognition* and run a script, Spyder will
    tell you that you need *pyaudio* for *SpeechRecognition* to run correctly. With
    the virtual environment *chatting* activated, run the following command in your
    terminal:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试导入*SpeechRecognition*并运行脚本，Spyder会告诉你需要*Pyaudio*才能让*SpeechRecognition*正常工作。虚拟环境*chatting*激活后，在终端中运行以下命令：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Follow the instructions all the way through.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请按照说明完成所有步骤。
- en: Test and Fine-Tune SpeechRecognition
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试并微调SpeechRecognition
- en: We’ll next test and fine-tune the *SpeechRecognition* module so Python can take
    your voice commands.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将测试并微调*SpeechRecognition*模块，以便Python能够接受你的语音命令。
- en: Import SpeechRecognition
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入SpeechRecognition
- en: 'To import *SpeechRecognition* in your Python scripts, use the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的 Python 脚本中导入*SpeechRecognition*，请使用以下命令：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Note that there is a small difference in the module name when you install it
    and when you import it: one is *SpeechRecognition* and the other is *speech_recognition*.
    Make sure you don’t miss the underscore in the module name when you import it.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在安装模块和导入模块时，模块名称略有不同：一个是*SpeechRecognition*，另一个是*speech_recognition*。确保在导入时不要漏掉模块名中的下划线。
- en: You also need to have a microphone plugged into the computer if you’re using
    a desktop. Most laptops come with a built-in microphone, but sometimes having
    an external one is convenient so you can speak close to the microphone and avoid
    ambient noise.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是台式电脑，记得要插入麦克风。大多数笔记本电脑自带内置麦克风，但有时候使用外接麦克风会更方便，能让你靠近麦克风说话，避免环境噪音的干扰。
- en: Test SpeechRecognition
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试 SpeechRecognition
- en: Next, let’s test the hardware and software. Enter [Listing 3-1](#listing3-1)
    into your Spyder editor and save it as *sr.py*, or you can download the file from
    the book’s resources.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来测试硬件和软件。将[Listing 3-1](#listing3-1)输入到你的 Spyder 编辑器中，并将其保存为*sr.py*，或者你也可以从书籍的资源中下载该文件。
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 3-1: Testing *SpeechRecognition*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 3-1：测试*SpeechRecognition*
- en: We import the *SpeechRecognition* module. Next, we call `Recognizer()` to initiate
    a *Recognizer* instance from the module so that your script is ready to convert
    voice to text. We save it as the variable `speech`. We also print a message that
    lets you know the microphone is ready to receive speech input.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入*SpeechRecognition*模块。接下来，我们调用`Recognizer()`来从该模块创建一个*Recognizer*实例，这样脚本就准备好将语音转换为文本。我们将其保存为变量`speech`，并打印出一条消息，通知你麦克风已经准备好接收语音输入。
- en: We tell the script that the source of the audio comes from the microphone using
    `Microphone()`. We use the `adjust_for_ambient_noise()` method to reduce the impact
    of the ambient noise on your voice input. The script captures the voice input
    from the defined microphone, converts it into text, and saves in `inp`. We print
    out the value of `inp`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`Microphone()`告诉脚本音频来源来自麦克风。我们使用`adjust_for_ambient_noise()`方法来减少环境噪音对语音输入的影响。脚本从定义的麦克风捕获语音输入，将其转换为文本，并保存到`inp`变量中。我们打印出`inp`的值。
- en: Note in this script, the *Recognizer* instance uses `recognize_google()`for
    recognizing speech from the audio source. This method uses the Google Web Speech
    application programming interface (API) and requires a good internet connection.
    Other methods available to the *Recognizer* instance in the *SpeechRecognition*
    module include `recognize_bing()`, which uses Microsoft Bing Speech; `recognize_ibm()`,
    which uses IBM Speech to Text; and so on. The only method that works offline is
    `recognize_sphinx()`, which uses the services of CMU Sphinx. However, the accuracy
    with `recognize_sphinx()` is not nearly as good as with `recognize_google()`,
    so we’ll use `recognize_google()` throughout this book.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个脚本中，*Recognizer*实例使用`recognize_google()`来识别音频源中的语音。此方法使用 Google Web Speech
    应用程序编程接口（API），需要良好的互联网连接。*SpeechRecognition*模块中的*Recognizer*实例还提供了其他方法，如`recognize_bing()`（使用微软
    Bing 语音识别），`recognize_ibm()`（使用 IBM Speech to Text）等。唯一可以离线使用的方法是`recognize_sphinx()`，它使用
    CMU Sphinx 的服务。然而，`recognize_sphinx()`的识别准确度远不如`recognize_google()`，因此我们在本书中将使用`recognize_google()`。
- en: 'Run *sr.py* and say something simple, like “Hello” or “How are you?”, to test
    if Python correctly prints out your voice input. You should see the following
    if you say, “How are you?”:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行*sr.py*，并说一些简单的话，比如“Hello”或“How are you?”，来测试 Python 是否能正确打印出你的语音输入。如果你说了“How
    are you?”，应该会看到以下输出：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the script is working, you’ve successfully installed the speech recognition
    feature. If not, double-check the previous steps and make sure your microphone
    is connected properly. Also make sure that you are in a relatively quiet area
    with a good internet connection.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本正常运行，说明你已经成功安装了语音识别功能。如果没有，请仔细检查前面的步骤，并确保你的麦克风正确连接。同时，确保你处在一个相对安静的地方，并且网络连接良好。
- en: Notice that Python converts almost all voice input as lowercase text, which
    can be a good feature since string variables are case-sensitive. This way, Python
    won’t miss a command because of capitalization.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Python 会将几乎所有的语音输入转换为小写文本，这是一个不错的功能，因为字符串变量是区分大小写的。这样，Python 就不会因为大小写问题而错过某个命令。
- en: Fine-Tune the Speech Recognition Feature
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微调语音识别功能
- en: Now you’ll fine-tune the speech recognition code to make it more user-friendly
    for the rest of the book. We’ll use `try` and `except` on a few common errors
    to allow the execution of the code to continue after encountering errors, instead
    of causing the script to crash.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将微调语音识别代码，使其更适合本书的后续内容。我们将在一些常见错误上使用`try`和`except`，以便在遇到错误后，代码能够继续执行，而不是导致脚本崩溃。
- en: The common error `UnknownValueError` happens when the Google speech recognition
    server cannot understand the audio, either because the speech isn’t clear or because
    of ambient noise. The error `RequestError` happens when the Google speech recognition
    request fails, either because of a bad internet connection or because the server
    is too busy. The error `WaitTimeoutError` happens when the script doesn’t detect
    any audio from the microphone for a long period.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 常见错误`UnknownValueError`发生在 Google 语音识别服务器无法理解音频时，可能是因为语音不清晰或周围有噪音。`RequestError`错误发生在
    Google 语音识别请求失败时，可能是由于网络连接差或服务器过于繁忙。`WaitTimeoutError`错误发生在脚本长时间未检测到麦克风的音频时。
- en: Without using `try` and `except`, the script crashes, and you have to start
    the script all over again. By using the exception-handling constructs, the script
    will continue without crashing. The errors I mentioned aren’t harmful enough to
    be worth handling, so our scripts will just allow those errors to pass.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用`try`和`except`，脚本会崩溃，你需要重新启动脚本。通过使用异常处理结构，脚本会继续运行而不会崩溃。我提到的这些错误并没有足够严重到需要处理，所以我们的脚本会允许这些错误通过。
- en: '[Listing 3-2](#listing3-2), *stand_by.py*, uses an infinite loop to first stand
    by and then repeatedly take voice inputs and print them out. This way, we don’t
    have to rerun the script every time we want the script to take our voice inputs.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-2](#listing3-2)，*stand_by.py*，使用了一个无限循环，首先进入待命状态，然后反复接收语音输入并打印出来。这样，我们就不必每次都重新运行脚本才能让脚本接收我们的语音输入。'
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 3-2: Code for *stand_by.py*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-2：*stand_by.py* 的代码
- en: We start a `while` loop to put the script in standby. This way, after taking
    your voice input, the script prints out what you said and starts listening again.
    At each iteration, the script prints `Python is listening` so you know it’s ready.
    We define the variable `inp` as an empty string at the beginning of each iteration.
    Otherwise, if the user doesn’t say anything for a while, the script will retrieve
    the `inp` value from the previous iteration. By clearing the string, we avoid
    any potential mix-ups.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动一个`while`循环，使脚本处于待命状态。这样，在获取你的语音输入后，脚本会打印出你说的话，并重新开始监听。每次迭代时，脚本都会打印`Python
    is listening`，让你知道它已经准备好。我们在每次迭代开始时将变量`inp`定义为空字符串。否则，如果用户一段时间内没有说话，脚本会使用上次迭代的`inp`值。通过清空字符串，我们避免了潜在的混淆。
- en: We use exception handling when connecting to the Google speech-recognition server
    1. If there is an `UnknownValueError`, a `RequestError`, or a `WaitTimeoutError`,
    we let the script continue without crashing.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在连接到 Google 语音识别服务器时使用异常处理。如果出现`UnknownValueError`、`RequestError`或`WaitTimeoutError`，我们让脚本继续运行而不会崩溃。
- en: At each iteration, the script prints what you said so that you can check if
    the speech recognition software has correctly captured your voice 2.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代时，脚本会打印你说的话，以便你检查语音识别软件是否正确捕捉到你的声音。
- en: Finally, we don’t want the script to run forever, so we add a condition to stop
    it. When you say, “Stop listening,” the `if` branch is activated, the script prints
    `Goodbye!`, and the `while` loop stops.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不希望脚本永远运行下去，所以我们添加了一个停止条件。当你说“停止监听”时，`if`分支会被激活，脚本会打印`Goodbye!`，然后`while`循环停止。
- en: 'Here’s a sample output, with my voice input in bold:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例输出，我的语音输入以粗体显示：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next, you’ll put the speech recognition feature to use in several projects.
    Some are practical and useful, and others are for building up skills for later
    chapters.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将在多个项目中应用语音识别功能。它们中有些是实际且有用的，其他的则是为了为后续章节积累技能。
- en: Perform a Voice-Controlled Web Search
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行语音控制的网页搜索
- en: Our first project is a script to navigate the web by using voice. You’ll learn
    to use the *webbrowser* module to open a browser on your computer. Then you’ll
    add voice-control functionality to open the browser and perform various searches
    online.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个项目是编写一个脚本，使用语音控制浏览网页。你将学习使用*webbrowser*模块在计算机上打开浏览器。然后，你将添加语音控制功能，打开浏览器并执行各种在线搜索。
- en: Use the webbrowser Module
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 webbrowser 模块
- en: The *webbrowser* module gives you tools to open a website by using the default
    browser on your computer. The module is in the Python Standard Library, so no
    installation is needed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*webbrowser*模块为你提供了使用计算机默认浏览器打开网站的工具。该模块属于Python标准库，因此无需安装。'
- en: 'To test the *webbrowser* module on your computer, enter the following lines
    of code in your Spyder editor and run them:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的计算机上测试*webbrowser*模块，请在Spyder编辑器中输入以下代码行并运行：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We use `"http://"+` inside the `open()` function so that you need to input only
    the main body of the web address instead of the full URL. This is to prepare you
    for voice activation in the next section. The web browser will automatically correct
    the URL if it uses *https://* instead of *http://* or if *www* is in the full
    URL.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`open()`函数内部使用`"http://"+`，这样你只需要输入网站地址的主体部分，而不必输入完整的URL。这是为了为下一部分的语音激活做准备。如果使用*https://*代替*http://*或在完整URL中包含*www*，网页浏览器会自动纠正URL。
- en: A new web browser window should open on the *Wall Street Journal* website. Microsoft
    Edge is the default browser on my computer, and the result is shown in [Figure
    3-1](#figure3-1).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的网页浏览器窗口应该会在*华尔街日报*网站上打开。Microsoft Edge是我计算机上的默认浏览器，结果如[图 3-1](#figure3-1)所示。
- en: '![f03001](Images/f03001.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![f03001](Images/f03001.png)'
- en: 'Figure 3-1: Result of using the `webbrowser.open("http://"+"wsj.com")` command'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-1：使用`webbrowser.open("http://"+"wsj.com")`命令的结果
- en: Add Voice Control
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加语音控制
- en: Now we’ll add the speech recognition feature. Save [Listing 3-3](#listing3-3)
    as *voice_browse.py*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加语音识别功能。将[清单 3-3](#listing3-3)保存为*voice_browse.py*。
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 3-3: Code for *voice_browse.py*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-3：*voice_browse.py*代码
- en: 'We import the two modules needed for this script: *webbrowser* and *SpeechRecognition*.
    At 1, we define the `voice_to_text()` function, which contains most of the steps
    in *stand_by.py*: it starts with the empty string `voice_input`, converts the
    audio from the microphone to text, and puts it in `voice_input`. It also makes
    exceptions for the `UnknownValueError`, the `RequestError`, and the `WaitTimeoutError`.
    Once called, the function will return the value stored in `voice_input`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了该脚本所需的两个模块：*webbrowser*和*SpeechRecognition*。在1处，我们定义了`voice_to_text()`函数，该函数包含了*stand_by.py*中的大部分步骤：它以空字符串`voice_input`开始，将麦克风的音频转换为文本，并将其放入`voice_input`中。它还对`UnknownValueError`、`RequestError`和`WaitTimeoutError`进行异常处理。一旦调用，该函数将返回保存在`voice_input`中的值。
- en: The script starts an infinite loop to continuously take voice input 2. At each
    iteration, it prints `Python is listening...` so you know it’s ready.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本启动一个无限循环，持续接收语音输入2。在每次迭代时，它会打印`Python is listening...`，以便你知道它已准备好。
- en: We call `voice_to_text()` to capture your voice input and save the converted
    text in `inp`. Note that I intentionally use a different variable name for the
    local variable `voice_input` and the global variable `inp` to avoid confusion.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`voice_to_text()`来捕获你的语音输入，并将转换后的文本保存在`inp`中。请注意，我故意为局部变量`voice_input`和全局变量`inp`使用不同的变量名，以避免混淆。
- en: If you say, “Stop listening” to the microphone, the `if` branch is activated.
    The script prints `Goodbye!` and stops running. If the word *browser* is in your
    voice command, the `elif` branch is activated. The script then puts `http://`
    and whatever you say next in the address bar and opens the web browser. For example,
    if you say “browser abc.com,” the `replace()` method will change “browser” and
    the space after it to an empty string, which effectively changes `inp` to `abc.com`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对麦克风说“Stop listening”，则`if`分支会被激活。脚本会打印`Goodbye!`并停止运行。如果语音命令中包含*browser*这个词，`elif`分支会被激活。脚本随后会把`http://`和你接下来所说的内容放到地址栏，并打开网页浏览器。例如，如果你说“browser
    abc.com”，`replace()`方法会将“browser”及其后面的空格替换为空字符串，这样就有效地将`inp`修改为`abc.com`。
- en: 'Here’s one sample output, with my voice input in bold:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例输出，带有我用粗体显示的语音输入：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The associated web browser pop-ups are as shown in [Figure 3-2](#figure3-2).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的网页浏览器弹出窗口如[图 3-2](#figure3-2)所示。
- en: '![f03002](Images/f03002.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![f03002](Images/f03002.png)'
- en: 'Figure 3-2: One of the sample outputs from *voice_browse.py*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-2：*voice_browse.py*的一个示例输出
- en: 'You use the word *browser* instead of *browse* to ensure that the script understands
    you: if you say “Browse” to your microphone, Python might convert it to `brows`
    instead. You may encounter several instances where slight adjustments will need
    to be made. Since everyone has a different voice, microphone, and diction (accent,
    inflection, and intonation), your adjustments will likely be different from mine.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用*browser*而不是*browse*来确保脚本能够理解你的命令：如果你对着麦克风说“Browse”，Python可能会将其转换为`brows`。你可能会遇到一些需要微调的情况。由于每个人的声音、麦克风和发音（口音、语调、重音等）不同，你的调整可能与我的不同。
- en: Perform a Google Search
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行Google搜索
- en: 'We’ll now modify *voice_browse.py* so you can voice-activate a Google search.
    All you need to change is this one line of code from *voice_browse.py*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将修改*voice_browse.py*，使你能够通过语音激活Google搜索。你只需要修改*voice_browse.py*中的这一行代码：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Change it to this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then save the modified script as *voice_search.py*. (You can also download it
    from the book’s resources page.)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将修改后的脚本保存为*voice_search.py*。（你也可以从本书的资源页面下载它。）
- en: Here we are using the fact that whenever Google performs a search, it puts the
    search term after *http://google.com/search?q=* and uses it as the URL in the
    address bar. For example, when you search `how many liters are in a gallon` in
    Google, you get the same result as if you entered the URL *http://google.com/search?q=how
    many liters are in a gallon*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们利用了Google搜索时会将搜索词附加在*http://google.com/search?q=*后面，并作为地址栏中的URL。例如，当你在Google中搜索`how
    many liters are in a gallon`时，得到的结果与输入URL *http://google.com/search?q=how many
    liters are in a gallon*相同。
- en: Run *voice_search.py* in your Spyder editor. Ask a question, like “Browser yards
    in a mile,” into the microphone. The script should open your default browser,
    perform a Google search for `yards in a mile`, and show a result similar to [Figure
    3-3](#figure3-3).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spyder编辑器中运行*voice_search.py*。对着麦克风提问，比如“Browser yards in a mile”。脚本应打开默认浏览器，执行`yards
    in a mile`的Google搜索，并显示与[图3-3](#figure3-3)类似的结果。
- en: '![f03003](Images/f03003.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![f03003](Images/f03003.png)'
- en: 'Figure 3-3: The result when you say “browser yards in a mile”'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-3：当你说“browser yards in a mile”时的结果
- en: You can also use the script in any way you use Google, for example, as a voice-controlled
    dictionary. If you want to know the exact definition of the word *diligence*,
    you can say, “Browser define diligence.”
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以以任何使用Google的方式使用该脚本，例如作为语音控制的词典。如果你想知道单词*diligence*的准确定义，可以说：“Browser define
    diligence。”
- en: Open Files
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打开文件
- en: With the capability of speech recognition in a Python script, you can do many
    things with voice control. We’ll build a script to open various types of files,
    including text files, PDF files, and music files.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 利用Python脚本中的语音识别功能，你可以通过语音控制完成许多操作。我们将编写一个脚本来打开各种类型的文件，包括文本文件、PDF文件和音乐文件。
- en: Use the os and pathlib Modules to Access and Open Files
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用os和pathlib模块访问和打开文件
- en: You can use the *os* and *pathlib* modules to access files and folders on your
    computer. The *os* module accesses operating system functionalities such as *go
    to a folder*, *open a file*, and so on. However, the commands differ across operating
    system. For example, to open a file, the command is `explorer` in Windows, `open`
    in Mac, and `xdg-open` in Linux.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用*os*和*pathlib*模块访问计算机上的文件和文件夹。*os*模块用于访问操作系统的功能，比如*进入文件夹*、*打开文件*等等。然而，这些命令在不同操作系统上有所不同。例如，在Windows中打开文件的命令是`explorer`，在Mac中是`open`，在Linux中是`xdg-open`。
- en: To make your scripts portable cross-platform, we’ll use the *platform* module,
    which lets the script automatically identify your operating system and then choose
    the appropriate command for you. The *pathlib* module allows you to find out the
    file paths and specify a file or folder path. Luckily, *pathlib* is cross-platform,
    so you don’t have to worry about a forward slash or backslash. All three modules—*os*,
    *pathlib*, and *platform*—are in the Python Standard Library, so no installation
    is needed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你的脚本在跨平台上更具便携性，我们将使用*platform*模块，它允许脚本自动识别你的操作系统，并选择适合的命令。*pathlib*模块可以让你找到文件路径并指定文件或文件夹路径。幸运的是，*pathlib*是跨平台的，所以你不必担心正斜杠或反斜杠的问题。这三个模块——*os*、*pathlib*和*platform*——都在Python标准库中，因此无需额外安装。
- en: In your chapter folder, create a subfolder called *files* and save a file *example.txt*
    in it. Then enter [Listing 3-4](#listing3-4) in your Spyder editor and save it
    as *os_platform.py.*
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的章节文件夹中，创建一个名为*files*的子文件夹，并将一个名为*example.txt*的文件保存在其中。然后，在Spyder编辑器中输入[Listing
    3-4](#listing3-4)，并将其保存为*os_platform.py*。
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 3-4: Code for *os_platform.py*'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 3-4：*os_platform.py*的代码
- en: We import the modules, then use `Path.cwd()` from *pathlib* to find the current
    working directory of the script. We’ll use this as the starting path to navigate
    from.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入模块后，使用*pathlib*中的`Path.cwd()`找到脚本的当前工作目录。我们将以此作为导航的起始路径。
- en: We then specify the path and name of the file we want to open. In the *pathlib*
    module, we use a forward slash to denote subfolders no matter what operating system
    you are using. The command `/'files'` tells the script to go to the subfolder
    *files*, and `/'example.txt'` indicates which file to define as *myfile*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们指定要打开的文件的路径和名称。在*pathlib*模块中，我们使用正斜杠表示子文件夹，无论你使用的是哪个操作系统。命令`/'files'`指示脚本进入子文件夹*files*，`/'example.txt'`则表示将*example.txt*文件定义为*myfile*。
- en: The `system()` method from the *os* module executes the command in a subshell.
    The `explorer` command opens a folder or a file on your computer in Windows. However,
    if you’re using Mac, the `system()` method in the *os* module uses the `open`
    command, and in Linux, the command is `xdg-open`. Therefore, the script opens
    the file *example.txt* in the subfolder *files*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*os*模块中的`system()`方法在子shell中执行命令。`explorer`命令会在Windows中打开一个文件夹或文件。然而，如果你使用的是Mac，*os*模块中的`system()`方法会使用`open`命令，在Linux中，命令则是`xdg-open`。因此，脚本会在子文件夹*files*中打开文件*example.txt*。'
- en: 'For example, say you’re using Windows and have saved the script in your chapter
    folder *C:\chat\mpt\ch03*. After running the script, you’ll have the following
    output in the IPython console:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你使用的是Windows，并将脚本保存在章节文件夹*C:\chat\mpt\ch03*中。运行脚本后，你将在IPython控制台中看到以下输出：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: At the same time, the file *example.txt* should open.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，文件*example.txt*应该被打开。
- en: Open Files via Voice Control
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过语音控制打开文件
- en: We’ll now demonstrate how to open various file types, like MP3; Microsoft Word,
    PowerPoint, and Excel; and PDF files. Before running the following script, save
    an MP3 file, a Word file, a PowerPoint file, an Excel file, and a PDF file in
    the subfolder *files* you just created in your chapter folder. Name the five files
    *presentation.mp3, lessons.docx, graduation.pptx, book.xlsx,* and *desk.pdf*,
    respectively. It’s best if the files are not too large.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将演示如何打开各种文件类型，如MP3、Microsoft Word、PowerPoint和Excel文件，以及PDF文件。在运行以下脚本之前，请在你刚刚创建的章节文件夹中的*files*子文件夹中保存一个MP3文件、一个Word文件、一个PowerPoint文件、一个Excel文件和一个PDF文件。将这五个文件分别命名为*presentation.mp3*、*lessons.docx*、*graduation.pptx*、*book.xlsx*和*desk.pdf*。文件最好不要太大。
- en: '[Listing 3-5](#listing3-5) shows *voice_open_file.py*, which can also be downloaded
    from the book’s resources page.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-5](#listing3-5)显示了*voice_open_file.py*，该脚本也可以从书本的资源页面下载。'
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 3-5: Code for *voice_open_file.py*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-5：*voice_open_file.py*的代码
- en: As with *voice_browse.py*, we define `voice_to_text()` to convert your voice
    command to text 1. We also define `open_file()` to identify your operating system
    and use the proper command, `explorer`, `open`, or `xdg-open`, to open the file
    on your computer. Note that while the Windows operating system uses a backward
    slash (`\`) to go to a subfolder, Mac and Linux use a forward slash (`/`) for
    that purpose.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 和*voice_browse.py*一样，我们定义了`voice_to_text()`来将你的语音命令转换为文本。我们还定义了`open_file()`来识别你的操作系统并使用正确的命令，`explorer`、`open`或`xdg-open`，在你的计算机上打开文件。请注意，虽然Windows操作系统使用反斜杠(`\`)进入子文件夹，但Mac和Linux使用正斜杠(`/`)来实现这一目的。
- en: The script is then put in standby mode by using a `while` loop 2. Within the
    loop, the microphone first detects your voice and converts it into text. Since
    we put the `lower()` method after `voice_to_text()`, all letters in the variable
    `inp` will be lowercase to avoid mismatch due to capitalization.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，脚本通过使用`while`循环进入待机模式。在循环内，麦克风首先检测到你的声音并将其转换为文本。由于我们在`voice_to_text()`后面使用了`lower()`方法，变量`inp`中的所有字母都会变为小写，以避免因大小写不匹配而出错。
- en: If you say, “Stop listening,” the script prints `Goodbye!` and stops running.
    If the words *open pdf* are in your voice command, the first `elif` branch is
    activated. The script then replaces `open pdf` with an empty string so only the
    filename is left in `inp`. The script goes to the subfolder and opens the proper
    PDF file. For example, when you say, “Open PDF desk,” the file *desk.pdf* will
    open on your computer.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你说“停止监听”，脚本会打印`Goodbye!`并停止运行。如果语音命令中包含*open pdf*，第一个`elif`分支将被激活。然后，脚本将用空字符串替换`open
    pdf`，这样`inp`中就只剩下文件名。脚本会进入子文件夹并打开正确的PDF文件。例如，当你说“打开PDF桌面”时，文件*desk.pdf*将在你的计算机上打开。
- en: When you say, “Open Word lessons,” the second `elif` branch is activated. The
    same principle works for Excel files and PowerPoint files. And when you say, “Open
    audio presentation,” the audio file *presentation.mp3* will start playing on your
    computer, using the default MP3 player.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你说“打开 Word 课件”时，第二个`elif`分支会被激活。对于 Excel 文件和 PowerPoint 文件，同样的原理适用。当你说“打开音频演示”时，音频文件*presentation.mp3*会在你的计算机上播放，使用默认的
    MP3 播放器。
- en: 'Here is the output from my interaction:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我与系统交互的输出：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Create and Import a Local Module
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建并导入本地模块
- en: 'As you have probably noticed, the three scripts *voice_browse.py*, *voice_search.py*,
    and *voice_open_file.py* share a large chunk of the same code: the code to import
    the speech recognition module and define the `voice_to_text()` function.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，三个脚本*voice_browse.py*、*voice_search.py*和*voice_open_file.py*共享大量相同的代码：导入语音识别模块并定义`voice_to_text()`函数的代码。
- en: To make our scripts more efficient, we’ll put all command lines related to speech
    recognition in a local module. We can then import the module in any script that
    uses the speech recognition feature.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高脚本效率，我们将所有与语音识别相关的命令行放入本地模块中。然后，我们可以在任何使用语音识别功能的脚本中导入这个模块。
- en: Create the Local Module mysr
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建本地模块 mysr
- en: Enter [Listing 3-6](#listing3-6) in your Spyder editor and save it as *mysr.py*.
    Alternatively, you can download it from the book’s resources page.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Spyder 编辑器中输入[列表 3-6](#listing3-6)，并将其保存为*mysr.py*。或者，你可以从本书的资源页面下载它。
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 3-6: Code for the self-made module *mysr*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-6：自制模块*mysr*的代码
- en: 'You can ignore the first part of the code 1 if you aren’t using Linux. The
    Advanced Linux Sound Architecture (ALSA) configuration, which is coded in the
    C programming language, spits out warning messages like these every time the *pyaudio*
    module is imported:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不使用 Linux，可以忽略代码 1 的第一部分。高级 Linux 声音架构 (ALSA) 配置使用 C 编程语言编写，每次导入*pyaudio*模块时，都会输出如下警告信息：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We create an error handler in Python 2 and pass it to C so that you won’t see
    any error messages when you import *pyaudio*. The details are beyond the scope
    of this book, so it’s okay if you don’t understand this part. Just leave the error
    handler in the module *mysr*, and it won’t affect your understanding for the rest
    of the book.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Python 2 中创建了一个错误处理程序，并将其传递给 C，以便在导入*pyaudio*时不会显示任何错误信息。具体细节超出了本书的范围，所以如果你不理解这一部分也没关系。只需将错误处理程序保留在模块*mysr*中，它不会影响你对本书其他部分的理解。
- en: Starting at 3, we import the *SpeechRecognition* module, initiate the `Recognizer()`
    class, and define the `voice_to_text()` function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从第 3 行开始，我们导入了*SpeechRecognition*模块，初始化`Recognizer()`类，并定义了`voice_to_text()`函数。
- en: Note that if you run *mysr.py*, nothing will happen. This is because we just
    define `voice_to_text()` in this script and don’t call it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你运行*mysr.py*，什么也不会发生。这是因为我们只在这个脚本中定义了`voice_to_text()`，但没有调用它。
- en: Import mysr
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入 mysr
- en: Let’s revisit *stand_by.py* and modify it to use *mysr*. Save [Listing 3-7](#listing3-7)
    as *stand_by1.py*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视*stand_by.py*并修改它以使用*mysr*。将[列表 3-7](#listing3-7)保存为*stand_by1.py*。
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 3-7: Code for *stand_by1.py*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-7：*stand_by1.py*的代码
- en: 'We’ve replaced all speech recognition–related code with just one line: `from
    mysr import voice_to_text`. This line tells the script to go to the local module
    *mysr* and import `voice_to_text()` to be used in the current script.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用一行代码替代了所有与语音识别相关的代码：`from mysr import voice_to_text`。这行代码告诉脚本去本地模块*mysr*导入`voice_to_text()`，并在当前脚本中使用。
- en: Whenever you need to convert speech to text, you simply call `voice_to_text()`
    1.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你需要将语音转换为文本时，只需调用`voice_to_text()` 1。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小结
- en: 'In this chapter, we installed the *SpeechRecognition* module and used `try`
    and `except` to handle potential errors. In this way, we prevent the script from
    closing when we would rather it continue. We tested the voice control functionality
    with a few projects: voice-controlled web surfing and voice-controlled web search.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们安装了*SpeechRecognition*模块，并使用`try`和`except`来处理潜在的错误。通过这种方式，我们防止脚本关闭，而是让它继续运行。我们使用几个项目测试了语音控制功能：语音控制网页浏览和语音控制网页搜索。
- en: You learned how to use the *os* module to open files and the *pathlib* module
    to navigate through the file path, as well as the *platform* module to make your
    Python code cross-platform.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了如何使用*os*模块打开文件，如何使用*pathlib*模块在文件路径中导航，以及如何使用*platform*模块使你的 Python 代码跨平台。
- en: Finally, you put all code related to speech recognition into a self-made local
    module so that your scripts look concise, short, and clean. We’ll use this module
    throughout the rest of the book.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将所有与语音识别相关的代码放入一个自制的本地模块中，这样你的脚本看起来简洁、简短且清晰。我们将在本书的剩余部分使用这个模块。
- en: End-of-Chapter Exercises
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本章结束练习
- en: Modify *stand_by.py* so that you end the `while` loop by saying, “Quit the script”
    instead of “Stop listening,” and when the `while` loop ends, the script prints
    `Have a great day!`
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改*stand_by.py*，使得你可以通过说“Quit the script”来结束`while`循环，而不是说“Stop listening”。当`while`循环结束时，脚本会打印`Have
    a great day!`
- en: Modify *voice_open_file.py* so that when you say, “Open text filename,” *filename.txt*
    will open on your computer.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改*voice_open_file.py*，使得当你说“Open text filename”时，*filename.txt*文件将在你的电脑上打开。
- en: Modify *voice_open_file.py* so that it imports `voice_to_text()` from the local
    *mysr* module.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改*voice_open_file.py*，使其从本地*mysr*模块导入`voice_to_text()`。
- en: '4'
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Make Python Talk
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让Python发声
- en: '![](Images/chapterart.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: In this chapter, you’ll learn how to make Python talk back to you in a human
    voice. You’ll first install the text-to-speech module based on your operating
    system and then teach Python to speak aloud whatever you enter on your computer.
    You’ll also add the speech recognition feature you learned in Chapter 3 and get
    Python to repeat your own speech. Finally, you’ll build a real-world application
    to use voice inputs to ask Python to calculate the area of a rectangle and tell
    you the answer in a human voice.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何让Python用人类的声音回应你。你将首先根据操作系统安装文本转语音模块，然后教Python大声朗读你在电脑上输入的内容。你还将添加你在第三章中学到的语音识别功能，让Python重复你自己的话。最后，你将构建一个实际的应用程序，使用语音输入让Python计算矩形的面积，并用人类的声音告诉你答案。
- en: To save space, you’ll put all text-to-speech-related code in a self-made module.
    Once you do that, you can import the module into any script that needs the text-to-speech
    feature.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，你将所有与文本转语音相关的代码放入自制模块中。完成后，你可以将该模块导入到任何需要文本转语音功能的脚本中。
- en: You’ll also learn how to ask Python to read a long text file, such as a news
    article, aloud. Before you begin, set up the folder */mpt/ch04/* for this chapter.
    As in previous chapters, you can download the code for all the scripts from [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将学习如何让Python大声朗读一篇长的文本文件，例如新闻文章。在开始之前，为本章设置文件夹*/mpt/ch04/*。像之前的章节一样，你可以从[https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/)下载所有脚本的代码。
- en: Install the Text-to-Speech Module
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装文本转语音模块
- en: 'Python has two commonly used text-to-speech modules: *pyttsx3* and *gTTS*.
    If you use Windows, you’ll install *pyttsx3* and use it throughout the book. In
    the Windows operating system, the *pyttsx3* module works offline, has a human-like
    voice, and lets you adjust the speech properties—namely, the speed, volume, and
    gender of the voice output.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Python有两个常用的文本转语音模块：*pyttsx3*和*gTTS*。如果你使用Windows，你将安装*pyttsx3*并在本书中始终使用它。在Windows操作系统中，*pyttsx3*模块是离线工作的，语音听起来像人类，并且可以调整语音属性——即语音输出的速度、音量和性别。
- en: However, the *pyttsx3* module works differently in Mac and Linux. The voice
    sounds robotic, and the speech properties are not easily adjustable. Therefore,
    you’ll install *gTTS* if you use Mac or Linux. The *gTTS* module requires an internet
    connection since it uses the Google Translate text-to-speech API. Further, *gTTS*
    does not play the sound directly. It saves the voice as an audio file or file-like
    object. You’ll have to use your own audio player to hear the voice. The voice
    generated by *gTTS* is very human-like.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，*pyttsx3*模块在Mac和Linux上的工作方式不同。语音听起来很机械，而且语音属性不容易调整。因此，如果你使用Mac或Linux，需安装*gTTS*。*gTTS*模块需要互联网连接，因为它使用了Google翻译的文本转语音API。此外，*gTTS*不会直接播放声音，而是将语音保存为音频文件或类似文件的对象。你需要使用自己的音频播放器来播放语音。*gTTS*生成的语音非常像人类的声音。
- en: In Chapter 2, you built a virtual environment called *chatting*, which you then
    used for speech recognition in Chapter 3. You’ll install the *pyttsx3* or *gTTS*
    module in the same virtual environment so your script will have both the speech
    recognition and text-to-speech features.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章中，你创建了一个名为*chatting*的虚拟环境，并在第三章中使用它进行语音识别。你将在同一个虚拟环境中安装*pyttsx3*或*gTTS*模块，这样你的脚本就既能进行语音识别，又能实现文本转语音功能。
- en: Setup
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置
- en: If you are using Windows, go to the “Install *pyttsx3* in Windows” section and
    skip the “Install *gTTS* in Mac or Linux” section. Otherwise, skip the “Install
    *pyttsx3* in Windows” section and go to the “Install *gTTS* in Mac or Linux” section.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Windows，请前往“在Windows中安装*pyttsx3*”部分，并跳过“在Mac或Linux中安装*gTTS*”部分。否则，请跳过“在Windows中安装*pyttsx3*”部分，转到“在Mac或Linux中安装*gTTS*”部分。
- en: Install pyttsx3 in Windows
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在Windows中安装pyttsx3
- en: The *pyttsx3* module is not in the Python standard library, so you’ll need to
    install it via pip.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*pyttsx3*模块不在Python标准库中，因此你需要通过pip安装它。'
- en: 'If you haven’t already set up your *chatting* virtual environment, go back
    to Chapter 2 now and follow the instructions to do so. Then activate the virtual
    environment *chatting* in the Anaconda prompt by executing the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有设置*聊天*虚拟环境，请返回第2章并按照指示进行设置。然后在Anaconda提示符中通过执行以下命令激活*聊天*虚拟环境：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With your *chatting* virtual environment activated, enter this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 激活你的*聊天*虚拟环境后，输入以下命令：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Follow the instructions onscreen to finish the installation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 按照屏幕上的指示完成安装。
- en: Install gTTS in Mac or Linux
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在Mac或Linux中安装gTTS
- en: The *gTTS* module is not in the Python standard library, so you’ll need to install
    it via pip.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*gTTS*模块不在Python标准库中，因此你需要通过pip安装它。'
- en: 'If you haven’t already set up your *chatting* virtual environment, go back
    to Chapter 2 now and follow the instructions to do so. Then activate the virtual
    environment *chatting* in a terminal by executing the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有设置*聊天*虚拟环境，请返回第2章并按照指示进行设置。然后在终端中通过执行以下命令激活*聊天*虚拟环境：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With your *chatting* virtual environment activated in your terminal, enter
    this command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 激活你的*聊天*虚拟环境并在终端中输入以下命令：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Follow the instructions onscreen to finish the installation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 按照屏幕上的指示完成安装。
- en: Test Your Text-to-Speech Module
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试你的文本转语音模块
- en: Before beginning, you’ll check that your text-to-speech module is properly installed
    and working. Based on your operating system, skip the sections that don’t apply
    to you.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，你需要检查你的文本转语音模块是否正确安装并正常工作。根据你的操作系统，跳过不适用的部分。
- en: Run a Sample Script in Windows
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在Windows中运行示例脚本
- en: With your virtual environment activated and Spyder open, copy the script *test_pyttsx3.py*
    into your editor and save it in your chapter folder. If you prefer, you can download
    the file from the book’s resources through [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 激活虚拟环境并打开Spyder后，将脚本*test_pyttsx3.py*复制到编辑器中，并将其保存在你的章节文件夹中。如果你愿意，也可以通过[https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/)从书籍资源下载该文件。
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First, import the *pyttsx3* module to the script. Then use `init()` to initiate
    a text-to-speech engine in the *pyttsx3* module and call it `engine`. The `say()`
    function in the *pyttsx3* module converts the text to a speech signal and prepares
    to send it to the speaker. The `runAndWait()` function then sends the actual speech
    signal to the speaker so you can hear the sound. The `runAndWait()` function also
    keeps the engine running so that when you want to convert text to speech later
    in the script, you don’t need to initiate the engine again.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将*pyttsx3*模块导入脚本。然后使用`init()`启动一个文本转语音引擎，并将其命名为`engine`。*pyttsx3*模块中的`say()`函数将文本转换为语音信号，并准备将其发送到扬声器。接下来，`runAndWait()`函数将实际的语音信号发送到扬声器，这样你就能听到声音。`runAndWait()`函数还会保持引擎运行，以便在脚本的后续部分需要将文本转换为语音时，无需重新启动引擎。
- en: To understand how each line of code functions, run *test_pyttsx3.py* line by
    line by using the F9 key.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解每一行代码的功能，使用F9键逐行运行*test_pyttsx3.py*。
- en: If the module is correctly installed, when you finish running the whole script,
    you should hear a voice saying, “Hello, how are you?” If not, recheck the instructions
    and make sure that the speaker on your computer is working properly at the right
    volume. I’ll discuss later in this chapter how to customize the speed, volume,
    and voice gender associated with the *pyttsx3* module.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块正确安装，运行完整个脚本后，你应该听到一个声音说：“Hello, how are you？”如果没有，请重新检查指示并确保电脑扬声器工作正常且音量合适。本章稍后将讨论如何自定义与*pyttsx3*模块相关的语速、音量和语音性别。
- en: Run a Sample Script in Mac or Linux
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在Mac或Linux中运行示例脚本
- en: You’ll use the gtts-cli tool (*cli* stands for *command line*) to convert text
    to speech, instead of converting text to an audio file, and then play it. The
    gtts-cli tool is faster than the alternative method. Once you install the *gTTS*
    module, the gtts-cli tool is available in the command line in your virtual environment.
    The gtts-cli tool converts the text to a file-like object, and you have to choose
    which audio player to play it. I find that the mpg123 player works well.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用gtts-cli工具（*cli*代表*命令行*）将文本转换为语音，而不是先将文本转换为音频文件再播放。gtts-cli工具比另一种方法更快。一旦安装了*gTTS*模块，gtts-cli工具将在你的虚拟环境中的命令行中可用。gtts-cli工具将文本转换为类似文件的对象，你需要选择一个音频播放器来播放它。我发现mpg123播放器效果很好。
- en: 'First, you need to install the mpg123 player on your computer. If you are using
    Mac, run the following command in a terminal:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要在电脑上安装mpg123播放器。如果你使用的是Mac，请在终端运行以下命令：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you are using Linux, run the following two commands on a terminal:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Linux，请在终端运行以下两个命令：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once you’re finished, with your virtual environment activated, run the following
    command in a terminal:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，在虚拟环境激活的情况下，在终端运行以下命令：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you have correctly installed everything, you should hear a voice saying,
    “Hello, how are you?” If not, recheck the instructions and make sure that the
    speaker on your computer is working properly at the right volume. Further, since
    you have installed the *gTTS* module in your virtual environment, you have to
    run the preceding command with your virtual environment activated. Otherwise,
    it won’t work.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经正确安装了一切，你应该能听到一个声音说：“你好，你好吗？”如果没有，重新检查指令，确保你电脑上的扬声器正常工作并且音量合适。此外，既然你已经在虚拟环境中安装了*gTTS*模块，你需要在激活虚拟环境的情况下运行上述命令。否则，它将无法正常工作。
- en: The `nocheck` option in this command is to speed up execution. The `q` flag
    instructs the module not to display copyright and version messages, even in an
    interactive mode. Make sure you don’t miss the hyphen at the end of the command.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令中的`nocheck`选项是为了加速执行。`q`标志指示该模块即使在交互模式下也不显示版权和版本信息。确保你没有遗漏命令末尾的连字符。
- en: Next, you’ll use the *os* module in Python to execute commands in a subshell.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使用Python中的*os*模块在子shell中执行命令。
- en: Copy the *test_gtts.py* script into your Spyder editor and save it in your chapter
    folder. The script is also available at the book’s resources through [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 将*test_gtts.py*脚本复制到你的Spyder编辑器中，并保存在章节文件夹里。该脚本也可以通过[https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/)在本书的资源中获取。
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: First import the *os* module to the script. Then use `system()` to execute a
    command in a subshell to achieve the same effect as running the command in a terminal.
    As a result, the gtts-cli tool is used to convert text to a file-like object.
    After that, the mpg123 player plays the sound object so you can hear a human voice.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将*os*模块导入到脚本中。然后使用`system()`在子shell中执行命令，以达到与在终端中运行命令相同的效果。因此，gtts-cli工具被用来将文本转换为类似文件的对象。之后，mpg123播放器播放该声音对象，这样你就可以听到人声。
- en: If you’ve done everything correctly, you should hear a voice saying, “Hello,
    how are you?”
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做对了，你应该能听到一个声音说：“你好，你好吗？”
- en: Convert Text to Voice in Windows
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在Windows中将文本转换为语音
- en: Now let’s practice converting written text input into a human voice in Windows.
    With your virtual environment activated and Spyder open, copy the script *tts_windows.py*,
    as shown in [Listing 4-1](#listing4-1), into your editor and save and run it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们练习将输入的文本转换成Windows中的人声。在你的虚拟环境已激活并且Spyder已打开的情况下，将[Listing 4-1](#listing4-1)中显示的*tts_windows.py*脚本复制到编辑器中，保存并运行它。
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 4-1: Converting text to voice in Windows'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-1：在Windows中将文本转换为语音
- en: After importing the *pyttsx3* module and initiating a text-to-speech engine,
    start an infinite loop to take user text input 1. In each iteration, the script
    asks for text input at the IPython console. If you want to stop the script, enter
    `done`, and the script will print and say in a human voice, “You just typed in
    done; goodbye!” After that, the loop stops, and the script quits running.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入*pyttsx3*模块并初始化文本转语音引擎后，开始一个无限循环来接受用户的文本输入。在每次迭代中，脚本会在IPython控制台中请求文本输入。如果你想停止脚本，请输入`done`，然后脚本会用人声打印并说：“你刚刚输入了done；再见！”之后，循环停止，脚本退出运行。
- en: If the text input is not `done`, the `else` branch runs 2, and the script speaks
    your text input out loud in a human voice. After that, the script goes to the
    next iteration and takes your text input again.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文本输入不是`done`，`else`分支会执行 2，脚本会用人类的声音大声说出你的文本输入。之后，脚本会进入下一次迭代，再次接受你的文本输入。
- en: 'The following is sample output from the script (user input is in bold):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是脚本的示例输出（用户输入为**粗体**）：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Convert Text to Voice in Mac or Linux
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在 Mac 或 Linux 上将文本转换为语音
- en: Now we’ll practice converting written text input into a human voice in Mac or
    Linux. With your virtual environment activated and Spyder open, copy the script
    *tts_mac_linux.py* ([Listing 4-2](#listing4-2)) into your editor, and save and
    run it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将练习将书面文本输入转换为人类声音，在 Mac 或 Linux 上。激活你的虚拟环境并打开 Spyder后，将脚本*tts_mac_linux.py*（[清单
    4-2](#listing4-2)）复制到编辑器中，然后保存并运行。
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 4-2: Converting text to voice in Mac and Linux'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-2：在 Mac 和 Linux 上将文本转换为语音
- en: After importing the *os* module so you can run commands in a subshell, start
    an infinite loop to take user text input 1. In each iteration, the script asks
    for text input at the IPython console. If you want to stop the script, enter `done`,
    and the script will print and say in a human voice, “You just typed in done; goodbye!”
    After that, the loop stops, and the script quits running.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入*os*模块后，你可以在子shell中运行命令，开始一个无限循环来接收用户的文本输入 1。在每次迭代中，脚本会在 IPython 控制台上请求文本输入。如果你想停止脚本，输入`done`，脚本会打印并用人类的声音说：“你刚输入了done；再见！”之后，循环停止，脚本退出运行。
- en: If the text input is not `done`, the `else` branch runs 2, and the script speaks
    your text input out loud in a human voice. After that, the script goes to the
    next iteration and takes your text input again.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文本输入不是`done`，`else`分支会执行 2，脚本会用人类的声音大声说出你的文本输入。之后，脚本会进入下一次迭代，再次接受你的文本输入。
- en: 'The following is sample output from the script (user input is in bold):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是脚本的示例输出（用户输入为**粗体**）：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Repeat After Me
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟我念
- en: We’ll start with a simple script that hears what you say aloud and repeats it
    in a human voice. This script serves two purposes. First, you’ll learn how the
    script takes your voice inputs and which words are easiest for the script to understand—some
    uncommon words won’t be understood. Second, you’ll learn how to put both the speech
    recognition and text-to-speech features in the same script so you can communicate
    with the computer through human voices only.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的脚本开始，它可以听到你大声说的话，并用人类的声音重复出来。这个脚本有两个目的。首先，你将学习脚本如何接收你的语音输入，以及哪些词语是脚本最容易理解的——一些不常见的词语是无法理解的。其次，你将学会如何将语音识别和文本转语音功能放在同一个脚本中，这样你就可以仅通过人类的声音与计算机进行交流。
- en: We’ll also make the script portable cross-platform. The script will automatically
    choose the *pyttsx3* module if you are using Windows and the *gTTS* module otherwise.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使脚本具有跨平台可移植性。如果你使用的是 Windows，脚本会自动选择*pyttsx3*模块；如果不是，则选择*gTTS*模块。
- en: Start a new script, name it *repeat_me.py*, and enter the code in [Listing 4-3](#listing4-3).
    Make sure to save it in your chapter folder. You’ll also need to copy your *mysr.py*
    file from Chapter 3 and paste it into the same folder, as you’ll need `voice_to_text()`
    from that script.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个新的脚本，命名为*repeat_me.py*，并输入[清单 4-3](#listing4-3)中的代码。确保将其保存在你的章节文件夹中。你还需要将第
    3 章中的*mysr.py*文件复制到同一文件夹中，因为你将需要从该脚本中调用`voice_to_text()`。
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 4-3: Repeating aloud'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-3：大声重复
- en: First, import the `voice_to_text()` function from the *mysr* module to convert
    voice commands into a string variable. Then, import the *platform* module, which
    lets the script automatically identify your operating system and choose the appropriate
    command for you 1. If you are using Windows, the script imports the *pyttsx3*
    module and initiates a text-to-speech engine. Otherwise, the script imports the
    *os* module so you can use the gtts-cli tool in a subshell.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从*mysr*模块导入`voice_to_text()`函数，将语音命令转换为字符串变量。然后，导入*platform*模块，让脚本自动识别你的操作系统，并为你选择合适的命令
    1。如果你使用的是 Windows，脚本会导入*pyttsx3*模块并启动文本转语音引擎。否则，脚本会导入*os*模块，以便你在子shell中使用gtts-cli工具。
- en: You then start an infinite loop to take voice inputs. The script takes your
    voice command and converts it into a string variable called `inp` 2. If you say,
    “Stop listening” into the microphone, the script will say aloud, “You just said
    stop listening; goodbye!” After that, the script stops. The script uses either
    the *pyttsx3* module or the gtts-cli tool, depending on your operating system.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你开始一个无限循环以接收语音输入。脚本将你的语音命令转换为一个名为`inp` 2的字符串变量。如果你对着麦克风说“Stop listening”，脚本将大声说，“你刚才说的是停止监听；再见！”然后脚本停止。该脚本根据你的操作系统使用*pyttsx3*模块或gtts-cli工具。
- en: If you say anything else into the microphone, the loop will keep running. At
    each iteration, the script will repeat what you said out loud 3.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对着麦克风说任何其他话，循环将继续运行。在每次迭代中，脚本将重复你所说的话3。
- en: 'The following is the output from the script after I said, “Hello,” “How are
    you,” and “Stop listening” into the microphone sequentially:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我依次对着麦克风说“Hello”、“How are you”和“Stop listening”后脚本的输出：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Customize the Speech
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义语音
- en: In this section, you’ll learn how to customize the speech produced by your text-to-speech
    module. You can adjust the speed and volume of the speech as well as the identity
    of the voice in the *pyttsx3* module in Windows. If you are using Mac or Linux,
    the only thing you can customize is the speed of the voice in the *gTTS* module.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何自定义你的文本到语音模块所产生的语音。你可以调整语速、音量以及在Windows中*pyttsx3*模块的语音身份。如果你使用的是Mac或Linux，唯一可以自定义的就是*pyttsx3*模块中语音的语速。
- en: Skip any of the following subsections that don’t apply to your operating system.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过任何不适用于你操作系统的以下小节。
- en: Retrieve Default Settings in the pyttsx3 Module in Windows
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Windows中检索*pyttsx3*模块的默认设置
- en: First, you need to see the default values of the parameters for the speed, volume,
    and identity of the voice in the *pyttsx3* module in Windows.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要查看*pyttsx3*模块中语速、音量和语音身份的默认参数值。
- en: This script will retrieve the default settings for your speech module. In Spyder,
    enter the code in [Listing 4-4](#listing4-4) and save it as *pyttsx3_property.py*
    in the chapter folder.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本将检索你的语音模块的默认设置。在Spyder中，输入[Listing 4-4](#listing4-4)中的代码并将其保存为*pyttsx3_property.py*，并保存在章节文件夹中。
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 4-4: Retrieving the default settings'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-4：检索默认设置
- en: At 1, you use `getProperty()` to obtain the properties of the voices used in
    the engine. You then iterate through all the voice objects in the list `voices`
    and print out individual voice objects.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步，你使用`getProperty()`获取引擎中使用的语音的属性。然后，你遍历`voices`列表中的所有语音对象，并打印出每个语音对象。
- en: You use `getProperty()` 2 to obtain the properties of the speed and print the
    default speed, then do the same for the default volume.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`getProperty()` 2获取语速的属性并打印出默认语速，然后对默认音量做同样的操作。
- en: 'If you run this script in Windows, you’ll see the default settings for your
    speech script, similar to the following output:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Windows中运行这个脚本，你将看到类似以下的语音脚本默认设置输出：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here you can see the two voices available to the *pyttsx3* module. The first
    voice, named *David*, has a male voice tone; the second voice, named *Zira*, has
    a female voice tone. The default voice tone is David—hence the male voice you
    hear in *test_pyttsx3.py*.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到*pyttsx3*模块中提供的两种语音。第一种语音，名为*David*，具有男性音调；第二种语音，名为*Zira*，具有女性音调。默认的语音是David——因此你在*test_pyttsx3.py*中听到的是男性声音。
- en: The default speech speed is 200 words per minute. The default volume is set
    at 1\. You’ll learn how to adjust the speed, volume, and ID in the *pyttsx3* module
    in Windows next.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的语速为每分钟200个单词。默认的音量设置为1。接下来你将学习如何在Windows中调整*pyttsx3*模块的语速、音量和身份。
- en: Adjust Speech Properties in the pyttsx3 Module in Windows
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Windows中调整*pyttsx3*模块的语音属性
- en: This script will change the default settings so you can hear a voice with the
    speed, volume, and ID that you prefer. Save [Listing 4-5](#listing4-5) as *pyttsx3_adjust.py*.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本将改变默认设置，以便你可以听到具有你偏好的语速、音量和身份的语音。将[Listing 4-5](#listing4-5)保存为*pyttsx3_adjust.py*。
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Listing 4-5: Adjusting some settings'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 4-5：调整一些设置
- en: 'Choose the second voice ID, which has a female voice. At 1, the script obtains
    the voice objects available in the text-to-speech engine and saves them in a list
    called `voices`. Choose the second object in the list `voices`, which has a female
    voice tone, by giving the index `[1]`. The `setProperty()` function takes two
    arguments: the property to set and the value to set it to. Set the value to `voices[voice_id].id`
    to choose the `id` value of the female voice object in Windows, which is *HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Speech\Voices\Tokens\TTS_MS_EN-US_ZIRA_11.0*.
    If you want to change to the male voice in Windows, you can use `voices[0].id`
    instead.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 选择第二个语音ID，它有一个女性声音。在1的位置，脚本会获取文本到语音引擎中可用的语音对象，并将它们保存在名为`voices`的列表中。通过提供索引`[1]`，选择列表`voices`中的第二个对象，它有一个女性的声音。`setProperty()`函数需要两个参数：要设置的属性和要设置的值。将值设置为`voices[voice_id].id`，以选择Windows中女性语音对象的`id`值，即*HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Speech\Voices\Tokens\TTS_MS_EN-US_ZIRA_11.0*。如果你想切换到Windows中的男性语音，可以使用`voices[0].id`。
- en: Next, you set the speech speed to 150 words per minute. Most of us speak at
    a rate of about 125 words per minute in everyday conversation. For faster speech,
    set `rate` to a number greater than 125, and for slower speech, set it to a number
    below 125.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将语音速度设置为每分钟150个单词。我们大多数人在日常对话中的语速约为每分钟125个单词。对于更快的语速，将`rate`设置为大于125的数值；对于更慢的语速，将其设置为小于125的数值。
- en: Then, the volume is set to 1.2, which is louder than the default value of 1\.
    You can set this to higher or lower than 1 based on your preference and speakers.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，音量设置为1.2，比分贝默认值1更大。你可以根据自己的喜好和扬声器，将其设置为大于或小于1的值。
- en: Finally, the script converts the text in `say()` into speech by using the adjusted
    properties. Try running this script multiple times with different combinations
    of parameters until you find the best combination for you. You can always come
    back to this script and make adjustments.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，脚本使用调整后的属性将`'say()'`中的文本转换为语音。尝试多次运行这个脚本，使用不同的参数组合，直到找到最适合你的设置。你可以随时返回此脚本并进行调整。
- en: Customize the gTTS Module in Mac or Linux
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Mac或Linux中自定义gTTS模块
- en: You can customize the speed, but not the volume or ID, of the voice in *gTTS*,
    according to the *gTTS* documentation; see, for example, [https://buildmedia.readthedocs.org/media/pdf/gtts/latest/gtts.pdf](https://buildmedia.readthedocs.org/media/pdf/gtts/latest/gtts.pdf).
    However, *gTTS* can convert text to speech in most major world languages including
    Spanish, French, German, and so on, which the *pyttsx3* module can’t do. You’ll
    use this feature of *gTTS* to build a voice translator in Chapter 16.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据*gTTS*文档自定义语音的速度，但不能自定义音量或ID；例如，参见[https://buildmedia.readthedocs.org/media/pdf/gtts/latest/gtts.pdf](https://buildmedia.readthedocs.org/media/pdf/gtts/latest/gtts.pdf)。然而，*gTTS*可以将文本转换为大多数世界主要语言的语音，包括西班牙语、法语、德语等，而*pyttsx3*模块无法做到这一点。你将在第16章中使用*gTTS*的这个功能来构建语音翻译器。
- en: 'This script will change the default speed to slow for the *gTTS* module. In
    Spyder, enter the following code and save it as *gtts_slow.py* in the chapter
    folder:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本会将默认的语速改为慢速模式，适用于*gTTS*模块。在Spyder中，输入以下代码并将其保存为* gtts_slow.py*，放入章节文件夹中：
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The script is the same as *test_gtts.py* you’ve created before except that it
    adds the `--slow` option. This changes the voice output to slower than normal.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本与之前创建的*test_gtts.py*脚本相同，不同之处在于它添加了`--slow`选项。这会使语音输出比正常速度更慢。
- en: If you run this script in Mac or Linux, you’ll hear the computer saying, “Hello,
    how are you?” slowly.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Mac或Linux中运行这个脚本，你会听到计算机缓慢地说：“你好，你好吗？”
- en: Since the default setting for the speed is `slow=False`, and that’s what we
    prefer, we won’t customize the *gTTS* module.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 由于默认的速度设置是`slow=False`，而这是我们更倾向的设置，因此我们不会自定义*gTTS*模块。
- en: Build the Local mysay Module
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建本地mysay模块
- en: In Chapter 3, you put all commands related to speech recognition in a local
    module named *mysr*. You’ll do the same here and put all text-to-speech-related
    commands in a local module.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，你将所有与语音识别相关的命令放入一个名为*mysr*的本地模块。在这里你也会做同样的事，将所有与文本到语音相关的命令放入一个本地模块。
- en: Create mysay
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建mysay
- en: You’ll create a local module *mysay* and save it in the same folder as any script
    that uses the text-to-speech feature. That way, you can save space in the main
    script. This module has adjusted the properties for speed, volume, and gender
    of the speech set in *pyttsx3_adjust.py* if you are using Windows. If you are
    using Mac or Linux, the local module *mysay* will use the default properties in
    the *gTTS* module. You can modify these parameters based on your own preferences.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建一个本地模块*mysay*，并将其保存在与使用文本转语音功能的脚本相同的文件夹中。这样，你可以节省主脚本的空间。该模块已调整了*pyttsx3_adjust.py*中设置的语音速度、音量和性别属性（如果你使用的是Windows）。如果你使用的是Mac或Linux，本地模块*mysay*将使用*gTTS*模块中的默认属性。你可以根据自己的偏好修改这些参数。
- en: Enter the code in [Listing 4-6](#listing4-6) and save it as *mysay.py* in your
    chapter folder.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 输入[列表 4-6](#listing4-6)中的代码，并将其保存为*mysay.py*，放入你的章节文件夹中。
- en: '[PRE43]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Listing 4-6: Building the module'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-6：构建模块
- en: You first import the platform module to identify your operating system. If you
    are using Windows 1, the *pyttsx3* module is imported. You use exception handling
    when initiating the text-to-speech engine 2 so that if you get an `ImportError`
    or `RuntimeError`, the script will keep running rather than crash. You then define
    `print_say()`, which prints the text and converts text to speech.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先导入平台模块来识别你的操作系统。如果你使用的是Windows 1，*pyttsx3*模块会被导入。你在初始化文本转语音引擎时使用了异常处理2，以便如果遇到`ImportError`或`RuntimeError`，脚本会继续运行而不会崩溃。然后你定义了`print_say()`，该函数打印文本并将文本转换为语音。
- en: If you are using Mac or Linux 3, the *os* module is imported to use the gtts-cli
    tool to run the command in a subshell. You then define a different `print_say()`
    function that prints the text and converts text to speech.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Mac或Linux 3，*os*模块被导入以使用gtts-cli工具在子进程中运行命令。然后，你定义了一个不同的`print_say()`函数，该函数打印文本并将文本转为语音。
- en: Import mysay
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入mysay
- en: 'With *mysay* prepared, you can simply import the module to your script to use
    the text-to-speech features. Let’s revisit the script *repeat_me.py* and modify
    it to use the *mysay* module. Save the following as *repeat_me1.py*:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好*mysay*后，你可以直接将该模块导入到你的脚本中，使用文本转语音功能。让我们重新审视脚本*repeat_me.py*并修改它，使用*mysay*模块。将以下内容保存为*repeat_me1.py*：
- en: '[PRE44]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You first import `print_say()` from *mysay*. You also import `voice_to_text()`
    from the *mysr* module created in Chapter 3. You use `voice_to_text()` to convert
    your voice command into a variable `inp`. When you want to covert text to speech,
    you use `print_say()`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先从*mysay*导入`print_say()`。你还从第3章创建的*mysr*模块导入`voice_to_text()`。你使用`voice_to_text()`将语音命令转换为变量`inp`。当你想要将文本转换为语音时，你使用`print_say()`。
- en: 'Run the script and speak into the microphone to test it out. I said, “Hello
    again,” “This one is using a text-to-speech module,” and “Stop listening,” to
    the script in that order. Here is the output:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本并对着麦克风说话进行测试。我依次对着脚本说了“Hello again”，“这个使用的是文本转语音模块”，以及“Stop listening”。以下是输出结果：
- en: '[PRE45]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Build a Voice-Controlled Calculator
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个语音控制的计算器
- en: You’ll use your text-to-voice and speech-parsing skills to build a calculator
    that you can speak commands to. The calculator finds the area of a rectangle and
    tells you the area in a human voice.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用文本转语音和语音解析技巧，构建一个可以通过语音命令控制的计算器。计算器会找到矩形的面积，并用人声告诉你面积。
- en: This script takes from you the width and length of a rectangle and speaks back
    its area. Save [Listing 4-7](#listing4-7) as *area_hs.py* in your chapter folder.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本接受你输入的矩形宽度和长度，并语音播报其面积。将[列表 4-7](#listing4-7)保存为*area_hs.py*，放入你的章节文件夹中。
- en: '[PRE46]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Listing 4-7: Calculating the area of a rectangle'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4-7：计算矩形的面积
- en: You first import the text-to-speech and speech recognition functions from local
    modules. The script asks you about the length of the rectangle 1. Speak a number
    into the microphone, and the script converts your voice input into text and saves
    it as the variable `inp1`. The script then asks you for the width of the rectangle.
    When you speak your answer, the script saves your voice input in the variable
    `inp2`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先从本地模块导入文本转语音和语音识别函数。脚本会询问你矩形的长度1。对着麦克风说出一个数字，脚本将你的语音输入转换为文本并保存为变量`inp1`。然后脚本会询问你矩形的宽度。当你说出答案时，脚本会将你的语音输入保存在变量`inp2`中。
- en: Based on your inputs, the script calculates the area of the rectangle 2 by converting
    your voice inputs into float variables and multiplying them.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的输入，脚本通过将语音输入转换为浮动变量并进行相乘来计算矩形的面积。
- en: 'The script will speak the result aloud as well as print the interactions to
    the screen. Here is one interaction with the script:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本不仅会大声朗读结果，还会将互动内容打印到屏幕上。以下是与脚本的一个互动示例：
- en: '[PRE47]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Once I told the script that the length of the rectangle was 5 and the width
    was 3, the script told me that the area was 15.0.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当我告诉脚本矩形的长度为5，宽度为3时，脚本告诉我面积是15.0。
- en: If you say something that isn’t a number, the script will not work. It’s safest
    to include the decimal in your response (for example, “five point zero”) so the
    script doesn’t accidentally convert your response into a string rather than a
    number type.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你说的不是数字，脚本将无法工作。为了避免脚本意外将你的响应转换为字符串而不是数字类型，最安全的做法是包含小数点（例如，“五点零”）。
- en: Read a File Aloud
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大声朗读文件
- en: In this section, you’ll learn how to read a file into a script so Python can
    speak the text aloud.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，你将学习如何将文件读取到脚本中，让Python能够大声朗读文本。
- en: '[Listing 4-8](#listing4-8) contains the short news article you’ll use.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-8](#listing4-8)包含了你将使用的简短新闻文章。'
- en: '[PRE48]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Listing 4-8: Content for the text file'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-8：文本文件内容
- en: Including this article as is in a script would clearly be inconvenient, so save
    it as a text file named *storm.txt* (you can download *storm.txt* with the rest
    of the book’s resources). You can first create a subfolder called *files* in your
    chapter folder and then save *storm.txt* in the subfolder.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将这篇文章包含到脚本中显然不太方便，因此将其保存为名为*storm.txt*的文本文件（你可以通过本书的其他资源下载*storm.txt*）。你可以先在章节文件夹中创建一个名为*files*的子文件夹，然后将*storm.txt*保存在子文件夹中。
- en: Save [Listing 4-9](#listing4-9) as *newsfile.py* to have Python read the news
    article out loud.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 将[清单 4-9](#listing4-9)保存为*newsfile.py*，让Python大声朗读新闻文章。
- en: '[PRE49]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Listing 4-9: Reading out the text file'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-9：朗读文本文件
- en: You first let the script know where to find the news file 1. You use `open()`
    to access *storm.txt* from the subfolder *files.* You then read the content of
    the file into a string variable called `content` by using `read()`. At the end,
    the script reads the file content out loud in a human voice. Simple!
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先让脚本知道在哪里找到新闻文件1。你使用`open()`从子文件夹*files*访问*storm.txt*。然后，你使用`read()`将文件内容读取到一个名为`content`的字符串变量中。最后，脚本以人类的声音大声朗读文件内容。很简单！
- en: If you save *storm.txt* in the same folder as the preceding script, you don’t
    need to specify the file path. Python will automatically look in the folder the
    script is held in when a path is not specified.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将*storm.txt*保存在与前面脚本相同的文件夹中，那么无需指定文件路径。Python将在没有指定路径时自动查找脚本所在的文件夹。
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to install the text-to-speech module to make
    Python talk. You moved crucial text-to-speech features into the module *mysay*
    to import into scripts.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何安装文本转语音模块让Python说话。你将关键的文本转语音功能移入了模块*mysay*，以便在脚本中导入。
- en: 'You have also learned how to have Python repeat what you say. You applied your
    new skills to a real-world application: using voice inputs to ask Python to calculate
    the area of a rectangle and tell you the answer in a human voice.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了如何让Python重复你说的话。你将新学到的技能应用到一个实际的应用中：使用语音输入要求Python计算矩形的面积，并以人类声音告诉你答案。
- en: Now that you know how to make Python talk and listen, in Chapter 5 you’ll learn
    how to apply both features to several interesting real-world applications.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何让Python说话和听话了，在第五章中你将学习如何将这两项功能应用到多个有趣的实际应用中。
- en: End-of-Chapter Exercises
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 章节末练习
- en: 'If you are using Windows, in *pyttsx3_adjust.py*, modify the code as follows:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是Windows系统，请在*pyttsx3_adjust.py*中按如下方式修改代码：
- en: The voice is a male voice.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该语音为男性声音。
- en: The speed of the speech is 160 words per minute.
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 语速为每分钟160个单词。
- en: The volume is 0.8.
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 音量是0.8。
- en: Modify the script *area_hs.py* to calculate the area of a triangle when you
    say the triangle’s height and base length.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改脚本*area_hs.py*，让它在你说出三角形的高度和底边长度时计算三角形的面积。
- en: '5'
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Speaking Applications
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 语音应用
- en: '![](Images/chapterart.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: Now that you know how to make Python talk and listen, we’ll create several real-world
    applications that utilize those skills. But before that, you’ll create a local
    package. Since you’ll use the *mysr* and *mysay* local modules in every chapter
    for the reminder of the book, you’ll create a Python package to contain all local
    modules. This way, you don’t need to copy and paste these modules to the folders
    of individual chapters. This also helps keep the code consistent throughout the
    book. You’ll learn how a Python package works and how to create one yourself along
    the way.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何让 Python 说话和聆听，我们将创建几个利用这些技能的实际应用。但在此之前，你将创建一个本地包。由于你将在书中剩余的章节中使用 *mysr*
    和 *mysay* 本地模块，你将创建一个 Python 包来包含所有本地模块。这样，你就不需要将这些模块复制粘贴到每一章节的文件夹中。这还可以帮助保持全书代码的一致性。在这个过程中，你将学习如何创建一个
    Python 包以及它的工作原理。
- en: In the first application, you’ll build a Guess the Number game that takes voice
    commands and talks back to you in a human voice.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个应用中，你将创建一个“猜数字”游戏，该游戏能够接收语音命令并用人类的声音回应你。
- en: You’ll then learn how to parse text to extract news summaries from National
    Public Radio (NPR) and have Python read them out to you. You’ll also build a script
    to extract information from Wikipedia based on your voice inquiries and to speak
    the answers out.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何解析文本，从国家公共广播电台（NPR）中提取新闻摘要，并让 Python 朗读它们。你还将构建一个脚本，根据你的语音查询从 Wikipedia
    提取信息并读出答案。
- en: Finally, you’ll learn how to traverse files in a folder with your voice, with
    the aim of building your very own Alexa. You’ll be able to say to the script,
    “Python, play Selena Gomez,” and a song by Selena Gomez that’s saved on your computer
    will start playing.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将学习如何通过语音遍历文件夹中的文件，目标是构建你自己的 Alexa。你可以对脚本说：“Python，播放 Selena Gomez，”然后一首保存在你计算机中的
    Selena Gomez 歌曲将开始播放。
- en: As usual, you can download all the code for all the scripts from [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
    Before you begin, set up the folder */mpt/ch05/* for this chapter.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，你可以从 [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/)
    下载所有脚本的代码。在开始之前，为本章节创建文件夹 */mpt/ch05/*。
- en: Create Your Self-Made Local Python Package
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建你自己的本地 Python 包
- en: In Chapter 3, you built a self-made local module *mysr* to contain all speech
    recognition–related code. Whenever you need to use the speech-recognition feature,
    you import `voice_to_text()` from the module. Similarly, you built a self-made
    local module *mysay* in Chapter 4 to contain all text-to-speech-related code.
    You import `print_say()` from the module whenever you use the text-to-speech feature.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 章中，你创建了一个自定义的本地模块 *mysr* 来包含所有与语音识别相关的代码。每当你需要使用语音识别功能时，就从该模块导入 `voice_to_text()`。类似地，在第
    4 章中，你创建了一个自定义的本地模块 *mysay* 来包含所有与语音合成相关的代码。每当你使用语音合成功能时，就从该模块导入 `print_say()`。
- en: 'You’ll use these two self-made local modules in this chapter and other chapters
    in this book. To make these modules work, you need to put the module files (namely,
    *mysr.py* and *mysay.py*) in the same directory as the script that uses these
    two modules. This means you’d potentially have to copy and paste these files into
    the directory of almost every chapter in this book. You may wonder: is there a
    more efficient way to do this?'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章以及本书的其他章节中，你将使用这两个自定义的本地模块。为了使这些模块正常工作，你需要将模块文件（即 *mysr.py* 和 *mysay.py*）放在与使用这些模块的脚本相同的目录中。这意味着你可能需要将这些文件复制粘贴到本书几乎每一章的目录中。你可能会想：有没有更高效的方法来实现这一点？
- en: The answer is yes, and that’s what Python packages are for.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是肯定的，这正是 Python 包的用途。
- en: Next, you’ll first learn what a Python package is and how it works. You’ll then
    learn how to create your self-made local package. Finally, you’ll use a Python
    script to test and import your package.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将首先了解什么是 Python 包及其如何工作。然后，你将学习如何创建自定义的本地包。最后，你将使用 Python 脚本测试并导入你的包。
- en: What’s a Python Package?
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是 Python 包？
- en: Many people think that Python modules and Python packages are the same. They’re
    not.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人认为 Python 模块和 Python 包是一样的。其实它们并不相同。
- en: A Python *module* is a single file with the *.py* extension. In contrast, a
    Python *package* is a collection of Python modules contained in a single directory.
    The directory must have a file named *__init__.py* to distinguish it from a directory
    that happens to have *.py* extension files in it.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Python *模块*是一个具有*.py*扩展名的单个文件。与此不同，Python *包*是包含在单一目录中的多个 Python 模块集合。该目录必须有一个名为
    *__init__.py* 的文件，以便将其与其他仅包含*.py*扩展名文件的目录区分开来。
- en: I’ll guide you through the process of creating a local package step-by-step.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我将一步一步地引导你完成创建本地包的过程。
- en: Create Your Own Python Package
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建你自己的 Python 包
- en: To create a local Python package, you need to create a separate directory for
    it and place all related files into it. In this section, you’ll create a local
    package to contain both our speech recognition and text-to-speech module files—namely,
    *mysr.py* and *mysay.py*.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建本地 Python 包，你需要为其创建一个单独的目录，并将所有相关文件放入其中。在本节中，你将创建一个本地包来包含我们的语音识别和语音合成模块文件——即
    *mysr.py* 和 *mysay.py*。
- en: Create a Package Directory
  id: totrans-320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建包目录
- en: First, you need to create a directory for the package.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要为包创建一个目录。
- en: In this book, you use a separate directory for each chapter. For example, all
    Python scripts and related files in this chapter are placed in the directory */mpt/ch05/*.
    Since you are creating a package to be used for all chapters in this book, you’ll
    create a directory parallel to all chapters. Specifically, you’ll use the directory
    */mpt/mptpkg/*, where *mptpkg* is the package name. The diagram in [Figure 5-1](#figure5-1)
    explains the position of the package relative to the book chapters.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你为每一章使用一个单独的目录。例如，本章中的所有 Python 脚本和相关文件都放置在目录 */mpt/ch05/* 中。由于你正在创建一个将在本书所有章节中使用的包，你将创建一个与所有章节并列的目录。具体来说，你将使用目录
    */mpt/mptpkg/*，其中 *mptpkg* 是包名。[图 5-1](#figure5-1) 解释了包相对于书籍章节的位置。
- en: '![f05001](Images/f05001.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![f05001](Images/f05001.png)'
- en: 'Figure 5-1: The position of the *m**pt**pkg* package relative to the chapter
    folders'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-1：*mptpkg* 包相对于章节文件夹的位置
- en: As you can see, the package directory is parallel to the chapter directories,
    which are all contained in the directory for the book, */mpt*, as in *Make Python
    Talk*.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，包目录与章节目录并列，所有目录都包含在本书的目录 */mpt* 中，就像 *Make Python Talk* 一样。
- en: Create Necessary Files for Your Package
  id: totrans-326
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为你的包创建必要的文件
- en: Next, you need to create and place necessary files in the package.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要创建并放置包中所需的文件。
- en: First, copy and paste the two modules you created in Chapters 3 and 4, *mysr.py*
    and *mysay.py*, in the package directory */mpt/mptpkg/*. Do not make any changes
    to the two files.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将你在第 3 章和第 4 章创建的两个模块 *mysr.py* 和 *mysay.py* 复制并粘贴到包目录 */mpt/mptpkg/* 中。不要对这两个文件进行任何更改。
- en: 'Then save the following script, *__init__.py*, in the package directory */mpt/mptpkg/*
    (or you can download it from the book’s resources):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将以下脚本 *__init__.py* 保存在包目录 */mpt/mptpkg/* 中（你也可以从本书资源中下载它）：
- en: '[PRE50]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The purpose of this file is twofold: it imports `voice_to_text()` and `print_say()`
    so you can use those functions at the package level, and it also tells Python
    that the directory is a package, not a folder that happens to have Python scripts
    in it.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件的目的是双重的：它导入 `voice_to_text()` 和 `print_say()`，使你可以在包级别使用这些函数，并且它还告诉 Python
    该目录是一个包，而不是一个恰好有 Python 脚本的文件夹。
- en: Finally, save the following script, *setup.py*, in the book directory */mpt*,
    one level above the package directory */mpt/mptpkg/*. The script is also available
    from the book’s resources.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将以下脚本 *setup.py* 保存在书籍目录 */mpt* 中，位于包目录 */mpt/mptpkg/* 上一级。该脚本也可以从本书的资源中获得。
- en: '[PRE51]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The file provides information about the package, such as the package name, author,
    version, descriptions, and so on.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件提供关于包的信息，例如包名、作者、版本、描述等。
- en: You’ll learn how to install this local package on your computer next.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何在计算机上安装这个本地包。
- en: Install Your Package
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装你的包
- en: Because you’ll modify the local package and add more features to it later in
    the book, it’s better to install the package in editable mode.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你将在本书后续部分修改本地包并为其添加更多功能，所以最好以可编辑模式安装该包。
- en: 'Open your Anaconda prompt (Windows) or a terminal (Mac or Linux) and activate
    your virtual environment for this book, *chatting*. Run the following command:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Anaconda 提示符（Windows）或终端（Mac 或 Linux），激活本书的虚拟环境 *chatting*。运行以下命令：
- en: '[PRE52]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Replace `path-to-mpt` with the actual directory path of */mpt*. For example,
    the book directory */mpt* is *C:\mpt* on my office computer that runs the Windows
    operating system, so I installed the local package using this command:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `path-to-mpt` 替换为 */mpt* 目录的实际路径。例如，在我的办公电脑上，运行 Windows 操作系统的 */mpt* 目录是 *C:\mpt*，因此我使用以下命令安装本地包：
- en: '[PRE53]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'On my Linux machine, the path to the */mpt* directory is */home/mark/Desktop/mpt*,
    so I installed the local package using this command:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的 Linux 机器上，*/mpt* 目录的路径是 */home/mark/Desktop/mpt*，因此我使用以下命令安装本地包：
- en: '[PRE54]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `-e` option tells the Python to install the package in editable mode so
    that you can modify the package anytime you need to.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`-e`选项告诉Python以可编辑模式安装包，这样你就可以在需要时随时修改该包。'
- en: With that, the local package is installed on your computer.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，本地包已安装在你的计算机上。
- en: Test Your Package
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试你的包
- en: Now that you have installed your self-made local package, you’ll learn how to
    import it.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了自己制作的本地包，你将学习如何导入它。
- en: You’ll write a Python script to test the package you just created.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你将编写一个Python脚本来测试你刚刚创建的包。
- en: 'Let’s revisit the script *repeat_me1.py* from Chapter 4. Enter the following
    lines of code in your Spyder editor and save it as *repeat_me2.py* in your Chapter
    5 directory */mpt/ch05/*:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下第4章中的脚本*repeat_me1.py*。在你的Spyder编辑器中输入以下代码行，并将其保存在第5章目录*/mpt/ch05/*下，命名为*repeat_me2.py*：
- en: '[PRE55]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: First, import the functions `voice_to_text()` and `print_say()` from the *mptpkg*
    package directly. Recall that in the script *__init__.py*, you’ve already imported
    the two functions from the modules *.mysr* and *.mysay* to the package. As a result,
    here you can directly import the two functions from the package.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，直接从*mptpkg*包中导入`voice_to_text()`和`print_say()`函数。回想一下，在脚本`__init__.py`中，你已经将这两个函数从模块*.mysr*和*.mysay*导入到包中。因此，在这里你可以直接从包中导入这两个函数。
- en: The rest of the script is the same as that in *repeat_me1.py*. It repeats what
    you say. If you say, “Stop listening,” the script stops.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的脚本与*repeat_me1.py*中的相同。它会重复你说的内容。如果你说“停止监听”，脚本会停止。
- en: 'The following is an interaction with *repeat_me2.py*, with my voice input in
    bold:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与*repeat_me2.py*的交互，我的语音输入以粗体显示：
- en: '[PRE56]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see, the script is working properly, which means you’ve successfully
    imported functions from the local package.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，脚本正常工作，这意味着你已经成功从本地包中导入了函数。
- en: More on Python Packages
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多关于Python包的内容
- en: Before you move on, I want to mention a couple of things about Python packages.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我想提到关于Python包的几点事项。
- en: First, you can add more modules to your package. Later in this book, you’ll
    add more modules to the existing local package *mptpkg*. You’ll use just one local
    package for the whole book. This will reduce the number of directories and help
    organize your files.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以向你的包中添加更多模块。在本书的后续章节中，你将向现有的本地包*mptpkg*中添加更多模块。你将使用整个书籍中的唯一本地包。这将减少目录的数量并帮助组织文件。
- en: Second, if you have an interesting package that you want to share with the rest
    of the world, you can easily do so. You just need to add a few more files, such
    as the license, a README file, and so on. For a tutorial on how to distribute
    your Python packages, see, for example, the Python Packaging Authority website,
    [https://packaging.python.org/tutorials/packaging-projects/](https://packaging.python.org/tutorials/packaging-projects/).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果你有一个有趣的包，想要与全世界分享，你可以很容易做到。你只需要添加一些额外的文件，比如许可证、README文件等。关于如何分发你的Python包的教程，请参阅例如Python
    Packaging Authority网站，[https://packaging.python.org/tutorials/packaging-projects/](https://packaging.python.org/tutorials/packaging-projects/)。
- en: Interactive Guess the Number Game
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互动猜数字游戏
- en: '*Guess the Number* is a popular game in which one player writes down a number
    and asks the other player to guess it in a limited number of attempts. After each
    guess, the first player tells whether the guess is correct, too high, or too low.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '*猜数字*是一个流行的游戏，其中一个玩家写下一个数字，要求另一个玩家在有限的尝试次数内猜出这个数字。每次猜测后，第一个玩家会告诉第二个玩家猜测是否正确，还是太高或太低。'
- en: Various versions of the game are available online and in books, and we’ll look
    at our own version to guess a number between one and nine. Start a new script
    and save it as *guess_hs.py*; the *hs* stands for *hear and say*.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的各种版本可以在网上和书籍中找到，我们将查看我们自己的版本，猜一个1到9之间的数字。启动一个新脚本并将其保存为*guess_hs.py*；*hs*代表*听和说*。
- en: Because the script is relatively long, I’ll break it into three parts and explain
    them one by one. [Listing 5-1](#listing5-1) gives the first part.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 因为脚本相对较长，我将把它分成三部分并逐一解释。[列表5-1](#listing5-1)给出了第一部分。
- en: '[PRE57]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Listing 5-1: Part 1 of the Guess the Number game'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5-1：猜数字游戏的第一部分
- en: We start the script by importing needed modules 1. We import the *time* module
    so we can pause the script for a period of time. We also import the *sys* module
    to exit the script when it is finished.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过导入所需的模块来开始脚本。首先，我们导入*time*模块，以便在脚本中暂停一段时间。我们还导入*sys*模块，以便在脚本结束时退出。
- en: As discussed in the previous section, we import `voice_to_text()` and `print_say()`
    from the local package *mptpkg* to convert voice to text as well as to print out
    and speak the text message.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，我们从本地包*mptpkg*中导入`voice_to_text()`和`print_say()`，用以将语音转换为文本并打印出来，以及通过语音播报文本信息。
- en: The script then speaks and prints out the rules of the game 2. Since the instructions
    span several lines, we put them in triple quotation marks to make them more readable.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本接着会用语音和文本打印出游戏规则2。由于说明内容跨越多行，我们将它们放在三引号中，以使其更易读。
- en: The script announces that you have five seconds to write down a number then
    pauses for five seconds by using `sleep()` to give you time to write your number.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本宣布你有五秒钟的时间写下一个数字，然后通过使用`sleep()`暂停五秒钟，给你时间写下数字。
- en: 'The script then begins to guess; it will ask in a human voice whether the number
    is five. At 3, we start an infinite loop to take your voice input. When you speak
    into the microphone, the computer converts your voice input into a text string
    variable named `re1`. The script repeats what you said back to you. Your response
    needs to be one of three phrases: “too high,” “that is right,” or “too small.”
    If it isn’t, the script will keep asking you for a response until it matches one
    of the phrases. This gives you a chance to have a correct response before the
    script moves on to the next step.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本然后开始猜测，它会用人声问数字是否是五。在第3步，我们开始一个无限循环来接受你的语音输入。当你对着麦克风说话时，计算机会将你的语音输入转换为一个名为`re1`的文本字符串变量。脚本会把你说的内容重复给你听。你的回应必须是以下三种之一：“太高”，“正确”或“太小”。如果不是，脚本会继续要求你回应，直到它匹配其中一个短语。这给了你一个机会，在脚本继续进行下一步之前，做出正确的回应。
- en: If your response is “that is right,” the computer will say, “Yay, lucky me!”
    and exit the script. We’ll enter the behavior for the response “too high” next.
    [Listing 5-2](#listing5-2) shows the middle part of the *guess_hs.py* script.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的回应是“正确”，计算机会说：“耶，真幸运！”然后退出脚本。接下来我们进入“太高”回应的行为。[清单 5-2](#listing5-2)展示了*guess_hs.py*脚本的中间部分。
- en: '[PRE58]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Listing 5-2: The “too high” behavior'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-2： “太高”行为
- en: If your response is “too high,” the computer will keep guessing, this time a
    lower number. The second guess from the computer will be three because guessing
    three reduces the number of attempts the computer needs to find out the answer.
    The script will detect and catch your response to the second guess.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的回应是“太高”，计算机会继续猜测，这次猜一个更低的数字。计算机的第二次猜测将是三，因为猜三可以减少计算机需要的尝试次数，以便找到答案。脚本将检测并捕捉你对第二次猜测的回应。
- en: 'Here are the options for your response to the second guess: If it’s “that is
    right,” the computer will say “Yay, lucky me!” and exit the script. If it’s “too
    small,” the computer will know that the number is four and say so. If it’s “too
    high,” the computer will make a third guess of one.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你对第二次猜测的回应选项：如果是“正确”，计算机会说“耶，真幸运！”然后退出脚本。如果是“太小”，计算机会知道数字是四，并且会这么说。如果是“太高”，计算机会进行第三次猜测，猜数字一。
- en: Then, the computer captures your response to the third guess. If your response
    is “too small,” the computer will know that the number is two. If your response
    is “that is right,” the computer will say, “Yay, lucky me!” and exit.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，计算机会捕捉你对第三次猜测的回应。如果你的回应是“太小”，计算机会知道数字是二。如果你的回应是“正确”，计算机会说：“耶，真幸运！”然后退出。
- en: Now let’s look at the final section of *guess_hs.py*, which handles a “too small”
    response to the first guess. [Listing 5-3](#listing5-3) shows the code.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下*guess_hs.py*的最后一部分，它处理对第一个猜测的“太小”回应。[清单 5-3](#listing5-3)展示了代码。
- en: '[PRE59]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Listing 5-3: The “too small” behavior'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-3： “太小”行为
- en: The final section of the script is similar to the middle section. If you tell
    the computer that the first guess of five is “too small,” the computer will give
    you a second guess of seven. The script will then catch your response to the second
    guess.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的最后一部分类似于中间部分。如果你告诉计算机第一次猜测的五是“太小”，计算机会给你第二次猜测七。脚本将捕捉你对第二次猜测的回应。
- en: If you respond “that is right,” the computer will say, “Yay, lucky me!” and
    exit the script. If you say “too high,” the computer will know that the number
    is six. If your response is “too small,” the computer will make a third guess
    of eight.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回应“正确”，计算机会说：“耶，真幸运！”然后退出脚本。如果你说“太高”，计算机会知道数字是六。如果你的回应是“太小”，计算机会进行第三次猜测，猜八。
- en: The computer then captures your response to the third guess. If your response
    is “too small,” the computer will know that the number is nine. If your response
    is “that is right,” the computer will say, “Yay, lucky me!” and exit the script.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，计算机会捕捉到你对第三次猜测的回应。如果你的回答是“too small”，计算机将知道数字是九。如果你的回答是“that is right”，计算机将说：“耶，我真幸运！”然后退出脚本。
- en: If you have a good internet connection in a fairly quiet environment, you can
    have close-to-perfect communication with the computer. The internet connection
    is important because we use the Google Web Speech API to convert voice input into
    text. The *SpeechRecognition* module has an offline method called `recognize_sphinx()`,
    but it makes a lot of mistakes, so we use the online method.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个安静的环境中有良好的互联网连接，你就可以和计算机进行接近完美的沟通。互联网连接非常重要，因为我们使用Google Web Speech API将语音输入转换为文本。*SpeechRecognition*模块有一个离线方法叫做`recognize_sphinx()`，但它会出很多错误，所以我们使用在线方法。
- en: 'Here’s the written output from the script when my number was 8 (my voice input
    is in bold):'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这是脚本在我的数字是8时的输出（我的语音输入用**粗体**标注）：
- en: '[PRE60]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The script understood every word I said perfectly. This is, of course, partly
    because I chose certain words to avoid ambiguity. When building your own projects,
    you’ll want to use voice commands that are unique or put the words in context
    to get consistently correct results. Since each voice command is usually short,
    the Python script may have difficulty grasping the context of your voice input
    and returning the right words.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本完美地理解了我说的每一个字。当然，这部分原因是因为我选择了某些词汇来避免歧义。在构建你自己的项目时，你将需要使用独特的语音命令，或者将这些词语放在特定的语境中，以便获得一致且正确的结果。由于每个语音命令通常很短，Python脚本可能会在理解你的语音输入的上下文并返回正确的单词时遇到困难。
- en: For example, if you say “too large” into the microphone, the script may return
    “two large,” which is a phrase that does make sense. That is why we use “too high”
    instead of “too large” in *guess_hs.py*.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你对着麦克风说“too large”，脚本可能会返回“two large”，这虽然是一个有意义的短语。因此，我们在*guess_hs.py*中使用“too
    high”而不是“too large”。
- en: Similarly, when I spoke “too low” into the microphone, the script returned “tulo”
    from time to time. When I use “too small,” I get the correct response each time.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当我对着麦克风说“too low”时，脚本时不时会返回“tulo”。当我使用“too small”时，我每次都会得到正确的回应。
- en: Speaking Newscast
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语音播报新闻
- en: 'In this project, we’ll scrape the NPR News website to collect the latest news
    summary and have Python read it out loud. This project is split into two scripts:
    one to scrape and organize the news, another to handle the speech recognition
    and text-to-speech features. Let’s start with the web scraping.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将抓取NPR新闻网站，以收集最新的新闻摘要，并让Python将其朗读出来。这个项目分为两个脚本：一个用于抓取和整理新闻，另一个用于处理语音识别和文本转语音功能。我们先从网页抓取开始。
- en: Scrape the News Summary
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抓取新闻摘要
- en: First, we need to scrape the information from the news site and compile it into
    a clean and readable format.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从新闻网站抓取信息，并将其整理成一个干净且易读的格式。
- en: Different news sites arrange their content differently, so the methods for scraping
    are often slightly different. You can refer to Chapter 6 for the basics of web
    scraping. If you’re interested in scraping other news sites, you’ll need to adjust
    this code based on the features of the website. Let’s first look at the site and
    the corresponding source code.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的新闻网站内容排版方式不同，因此抓取的方法通常会有所不同。你可以参考第六章了解网页抓取的基础。如果你有兴趣抓取其他新闻网站，你需要根据该网站的特点调整此代码。我们首先来看一下这个网站和相应的源代码。
- en: The news we’re interested in is on the front page of the NPR News website, shown
    in [Figure 5-2](#figure5-2).
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的新闻出现在NPR新闻网站的首页，见[图5-2](#figure5-2)。
- en: One handy feature of this page is the short news summaries. As you can see,
    the front page lists the latest news with a short summary for each news article.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面的一个实用功能是简短的新闻摘要。正如你所看到的，首页列出了最新的新闻，每条新闻都有一个简短的摘要。
- en: You want to extract the news title and the teaser of each news article and print
    them out. To do this, you need to locate the corresponding tags in the HTML program.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要提取每篇新闻的标题和简短摘要并打印出来。为此，你需要在HTML程序中定位相应的标签。
- en: '![f05002](Images/f05002.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![f05002](Images/f05002.png)'
- en: 'Figure 5-2: News summaries on the NPR News front page'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-2：NPR新闻首页的新闻摘要
- en: While on the web page, press ctrl-U on your keyboard. The source code for the
    web page should appear. You can see that it’s almost 2,000 lines long. To locate
    the tags you need, press ctrl-F to open a search box at the top-right corner.
    Because the title of the first news article starts with “Answering Your Coronavirus
    Questions,” as shown in [Figure 5-2](#figure5-2), you should enter `Answering
    Your Coronavirus Questions` and click **Search**. Then skip to the corresponding
    HTML code, shown in [Listing 5-4](#listing5-4).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页上，按下键盘上的ctrl-U。网页的源代码应该会显示出来。你可以看到它有将近2000行长。要找到需要的标签，按下ctrl-F打开右上角的搜索框。由于第一篇新闻文章的标题是“Answering
    Your Coronavirus Questions”（回答您的冠状病毒问题），如[Figure 5-2](#figure5-2)所示，你应该输入`Answering
    Your Coronavirus Questions`并点击**Search**。然后跳转到相应的HTML代码，如[Listing 5-4](#listing5-4)所示。
- en: '[PRE61]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Listing 5-4: Part of the source code for the NPR News front page'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-4: NPR新闻首页部分源代码'
- en: Notice that all the title and teaser information are encapsulated in a parent
    `<div>` tag with a `class` attribute of `item-info` 1. Information for the news
    title is held in a child `<h2>` tag with a `class` attribute of `title` 2. The
    information for the teaser is held in a child `<p>` tag with a `class` attribute
    of `teaser` 3.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有的标题和摘要信息都被封装在一个父`<div>`标签中，该标签的`class`属性为`item-info`1。新闻标题的信息位于一个子`<h2>`标签中，该标签的`class`属性为`title`2。摘要的信息位于一个子`<p>`标签中，该标签的`class`属性为`teaser`3。
- en: We’ll use these patterns to write a Python script to extract the information
    we need. The script *news.py* will scrape the information and organize all titles
    and summaries in a clean and concise way. I’ve added comments in places that need
    more detailed explanations.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些模式编写一个Python脚本来提取所需的信息。脚本*news.py*将抓取信息并以简洁的方式整理所有标题和摘要。我已经在需要详细解释的地方添加了注释。
- en: The script will compile the news summary and print it out in text. Enter [Listing
    5-5](#listing5-5) and save it as *news.py*.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将编译新闻摘要并以文本形式打印出来。输入[Listing 5-5](#listing5-5)，并将其保存为*news.py*。
- en: '[PRE62]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Listing 5-5: Python code to scrape the NPR News front page'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-5: 抓取NPR新闻首页的Python代码'
- en: We start by importing the needed modules *bs4* and *requests* (*bs4* is the
    newest version of the Beautiful Soup library). Follow the three steps in Chapter
    2 for installing these modules if you need to.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入需要的模块*bs4*和*requests*（*bs4*是最新版本的Beautiful Soup库）。如果需要，按照第2章中的三步安装这些模块。
- en: At 1, we obtain the source code for the NPR News front page, which is in HTML
    format. We then use the *bs4* module to parse HTML files. Because the information
    we need is encapsulated in `<div>` tags with a `class` attribute of `item-info`,
    we find all such tags and put them in a list called *div_tags*. To separate different
    news summaries, we create a variable *news_index* to mark them 2.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步，我们获取NPR新闻首页的源代码，该代码是HTML格式的。然后，我们使用*bs4*模块解析HTML文件。因为我们需要的信息被封装在`class`属性为`item-info`的`<div>`标签中，所以我们找到所有这样的标签并将它们放入名为*div_tags*的列表中。为了区分不同的新闻摘要，我们创建了一个变量*news_index*来标记它们2。
- en: We then go into each individual `<div>` tag we’ve collected 3. First, we print
    out the news summary index to separate out individual news items. Second, we extract
    the `<h2>` tag that contains the news title and print it out. Third, we extract
    the `<p>` tag that contains the news summary and print it out. Finally, we stop
    if the news index exceeds 10 so that we limit the printout to 10 news summaries.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们进入每个收集到的单独`<div>`标签3。首先，我们打印出新闻摘要的索引以区分单独的新闻项目。其次，我们提取包含新闻标题的`<h2>`标签并打印出来。接着，我们提取包含新闻摘要的`<p>`标签并打印出来。最后，如果新闻索引超过10，我们就停止，以确保输出的新闻摘要数量不超过10条。
- en: If you run *news.py*, the output will look like [Listing 5-6](#listing5-6).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行*news.py*，输出将如下所示：[Listing 5-6](#listing5-6)。
- en: '[PRE63]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Listing 5-6: News summary scraped from the NPR News front page'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-6: 从NPR新闻首页抓取的新闻摘要'
- en: Now we’ll get Python to read the news to us.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们让Python给我们读新闻。
- en: Add the Text-to-Speech Features
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加文本转语音功能
- en: The next step is to have the text-to-speech module convert the news summary
    into spoken words. Add [Listing 5-7](#listing5-7) into a new file and save it
    as *news_hs.py*.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是让文本转语音模块将新闻摘要转换成语音。将[Listing 5-7](#listing5-7)添加到一个新文件中，并保存为*news_hs.py*。
- en: '[PRE64]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Listing 5-7: Python code for a voice-activated newscast'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-7: 语音激活新闻播报的Python代码'
- en: We first import the usual modules, and we import `voice_to_text()` and `print_say()`
    from the self-made *mptpkg* package.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入常用的模块，并从自制的*mptpkg*包中导入`voice_to_text()`和`print_say()`。
- en: We then define a function called `news_teaser()` 1, which accomplishes whatever
    *news.py* does. The only exception is that instead of just printing out the news
    index, title, and teaser, it both prints and speaks them 2. We then set the script
    to ask, “Would you like to hear the NPR news summary?” The `voice_to_text()` function
    captures your voice response and converts it into a string variable with all lowercase
    letters. If you say yes, Python will start broadcasting the news. If you answer
    anything other than yes, the script will exit.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们定义了一个名为`news_teaser()`的函数 1，它完成了*news.py*所做的所有工作。唯一的例外是，它不仅打印新闻索引、标题和摘要，还会同时朗读出来
    2。接着，我们设置脚本询问：“你想听NPR新闻摘要吗？”`voice_to_text()`函数捕捉到你的语音响应，并将其转换成一个全小写字母的字符串变量。如果你说“是”，Python将开始播放新闻。如果你说的不是“是”，脚本将退出。
- en: Voice-Controlled Wikipedia
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语音控制维基百科
- en: We’ll build a talking Wikipedia in this section. Unlike with the newscaster
    project, we’ll use the *wikipedia* module to get the information we need directly.
    After that, we’ll get the script to understand questions you ask, retrieve the
    answer, and read it aloud.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建一个会说话的维基百科。不同于新闻播报员项目，我们将使用*wikipedia*模块直接获取所需信息。之后，我们将使脚本理解你提出的问题，检索答案，并大声朗读出来。
- en: Access Wikipedia
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问维基百科
- en: 'Python has a *wikipedia* module that does the work of delving into topics you
    want to know about, so we don’t have to code that part ourselves. The module is
    not in the Python standard library or the Anaconda navigator. You should install
    it with pip. Open the Anaconda prompt (in Windows) or a terminal (in Mac or Linux)
    and run the following command:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个*wikipedia*模块，可以帮助你深入了解你想了解的主题，因此我们不需要自己编写这部分代码。这个模块不在Python标准库或Anaconda导航器中。你需要使用pip进行安装。在Windows中打开Anaconda提示符，或者在Mac或Linux中打开终端，然后运行以下命令：
- en: '[PRE65]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Next, run the following script as *wiki.py*:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行以下脚本作为*wiki.py*：
- en: '[PRE66]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: After the script is running, in the IPython console in the lower-right panel,
    enter the name of a topic you want to know about. The script will save your inquiry
    as the variable *my_query*. The `summary()` function will produce a summary answer
    to your question. Finally, the script prints out the answer from Wikipedia.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本运行后，在右下角的IPython控制台中，输入你想了解的主题。脚本会将你的查询保存为变量*my_query*。`summary()`函数将生成你的问题的摘要答案。最后，脚本会打印出来自维基百科的答案。
- en: 'I entered `U.S. China trade war` and got the following result:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我输入了`U.S. China trade war`并得到了以下结果：
- en: '[PRE67]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This answer is relatively short. Most searches in Wikipedia will have a much
    longer result. If you want to limit the length of the responses to, say, the first
    200 characters, you can enter `[0:200]` after `answer`.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这个答案相对较短。大多数维基百科的搜索结果会更长。如果你希望限制响应的长度，比如只显示前200个字符，你可以在`answer`后面输入`[0:200]`。
- en: Add Speech Recognition and Text to Speech
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加语音识别和语音合成
- en: We’ll now add the speech recognition and text-to-speech features to the script.
    Enter [Listing 5-8](#listing5-8) as *wiki_hs.py*.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将把语音识别和语音合成功能添加到脚本中。输入[Listing 5-8](#listing5-8)作为*wiki_hs.py*。
- en: '[PRE68]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Listing 5-8: Python code for a voice-controlled talking Wikipedia'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 5-8: 语音控制的会说话维基百科的Python代码'
- en: Once you start the script, a voice asks, “What do you want to know?” 1. At 2,
    the script calls `voice_to_text()` to convert your voice input into text. Then,
    the script retrieves the response to your question from Wikipedia, saves it as
    a string variable *ans*, and converts it to a human voice.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你启动脚本，系统会询问：“你想知道什么？” 1。2时，脚本调用`voice_to_text()`将你的语音输入转化为文本。然后，脚本从维基百科获取问题的答案，将其保存为字符串变量*ans*，并将其转化为人声朗读。
- en: 'After running the script, if you say to the microphone, “US Federal Reserve
    Bank,” you’ll get a result similar to this:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后，如果你对着麦克风说“美国联邦储备银行”，你将得到类似以下的结果：
- en: '[PRE69]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: I’ve added the `[0:200]` character limit behind the variable `ans`, so only
    the first 200 characters of the result are printed and spoken.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在变量`ans`后面添加了`[0:200]`字符限制，所以结果只会打印和朗读前200个字符。
- en: And just like that, you have your own voice-controlled talking Wikipedia. Ask
    away!
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，你拥有了自己的语音控制会说话的维基百科。尽管问吧！
- en: Voice-Activated Music Player
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语音激活的音乐播放器
- en: Here you’ll learn how to get Python to play a certain artist or genre of music
    just by asking for it with a phrase like “Python, play Selena Gomez.” You’ll speak
    the name of the artist you want to listen to, and the script will receive that
    as keywords and then search for those keywords in a particular folder. To do this,
    you need to be able to traverse files and folders.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将学习如何让 Python 通过一个简单的命令，比如“Python, play Selena Gomez”来播放某个艺术家或音乐类型的歌曲。你只需说出你想听的艺术家的名字，脚本会将其作为关键字，并在特定的文件夹中搜索这些关键字。为了实现这一点，你需要能够遍历文件和文件夹。
- en: Traverse Files in a Folder
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历文件夹中的文件
- en: 'Suppose you have a subfolder *chat* in your chapter folder. If you want to
    list all files in the subfolder, you can use this *traverse.py* script:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在章节文件夹中有一个子文件夹*chat*。如果你想列出子文件夹中的所有文件，可以使用这个*traverse.py*脚本：
- en: '[PRE70]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: First, the script imports the *os* module. This module gives the script access
    to functionalities that are dependent on the operating system, such as accessing
    all files in a folder.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，脚本导入了*os*模块。这个模块使脚本能够访问与操作系统相关的功能，比如访问文件夹中的所有文件。
- en: Next, you put all files in the subfolder *chat* into a list called *files*.
    The script goes through all items in the list, and prints out the name of each
    item.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将所有子文件夹*chat*中的文件放入一个名为*files*的列表中。脚本会遍历列表中的所有项目，并打印出每个项目的名称。
- en: 'The output from the preceding script is as follows after I run it on my computer:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我在我的电脑上运行上述脚本后的输出结果如下：
- en: '[PRE71]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: As you can see, we can traverse all the files and subfolders in a folder and
    print out their names. Filenames include the file extension. Subfolders have no
    extension after the subfolder name. For example, I have two folders, *country*
    and *classic*, in the folder *chat*. As a result, you see `country` and `classic`
    in the preceding output.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以遍历文件夹中的所有文件和子文件夹，并打印出它们的名称。文件名包括文件扩展名。子文件夹的名称后面没有扩展名。例如，我在*chat*文件夹中有两个子文件夹，*country*和*classic*。因此，你会在前面的输出中看到`country`和`classic`。
- en: Next, you’ll use this feature to select a song you want to play.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使用这个功能来选择你想播放的歌曲。
- en: Python, Play Selena Gomez
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python，播放 Selena Gomez
- en: The script in [Listing 5-9](#listing5-9), *play_selena_gomez.py*, can pick out
    a song by whatever artist you name (for example, Selena Gomez) and play it. Either
    save your songs in the subfolder *chat* or replace the file path with a path to
    somewhere on your computer that you keep music.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-9 中的脚本（*play_selena_gomez.py*）能够根据你指定的任何艺术家（例如，Selena Gomez）来挑选并播放歌曲。你可以将歌曲保存在子文件夹*chat*中，或者将文件路径替换为你电脑中存储音乐的路径。
- en: '[PRE72]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Listing 5-9: Python code to voice activate a song by an artist on your computer'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-9：Python 代码，用于通过语音激活计算机上某个艺术家的歌曲
- en: We first import the needed modules. In particular, we import the *os* module
    to traverse files and the *random* module to randomly select a song from a list
    the script will build. We use `mixer()` in the *pygame* module to play the music
    file.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入所需的模块。特别是，我们导入*os*模块来遍历文件，导入*random*模块来从脚本生成的列表中随机选择一首歌。我们使用*pygame*模块中的`mixer()`来播放音乐文件。
- en: We then start an infinite loop 1 to put the script in standby mode to wait for
    your voice commands. If the script detects the word *play* in your voice command,
    the music mode is activated 2. We then replace the word `play` and the whitespace
    behind it with an empty string 3 so that your command “Play Selena Gomez” becomes
    `Selena Gomez`. The next command separates the first name and the last name. For
    artists who are known by just their first names (such as Madonna, Prince, or Cher),
    we put their first name as a placeholder in the variable `lastname`.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们启动一个无限循环，将脚本置于待机模式，等待你的语音命令。如果脚本检测到语音命令中有*play*这个词，音乐模式就会被激活。然后，我们用空字符串替换命令中的`play`及其后面的空格，这样你的命令“Play
    Selena Gomez”就变成了`Selena Gomez`。接下来的命令将分离出名字和姓氏。对于只以名字为人熟知的艺术家（例如 Madonna、Prince
    或 Cher），我们将其名字作为占位符存入变量`lastname`中。
- en: We then traverse through all files in the subfolder *chat*. If a file has the
    *mp3* extension and contains either the first or the last name 4, it will be added
    to the list *mysongs*. We use `choice()` from the *random* module to randomly
    select a song in the list *mysongs* 5 and load it with `mixer.music.load()`. After
    that, we use `mixer.music.play()` to play it.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历子文件夹*chat*中的所有文件。如果一个文件具有*mp3*扩展名，并且包含艺术家的名字（无论是名字还是姓氏），它将被添加到列表*mysongs*中。我们使用*random*模块中的`choice()`来随机选择列表*mysongs*中的一首歌，并通过`mixer.music.load()`加载它。接着，我们使用`mixer.music.play()`来播放它。
- en: As a result, once you say to the script, “Play Selena Gomez,” one of the two
    songs in the subfolder *chat*, *SelenaGomezWolves.mp3* or *TheHeartWantsWhatItWantsSelenaGomez.mp3*,
    will start playing.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，一旦你对脚本说“播放Selena Gomez”，它会随机播放子文件夹*chat*中的两首歌曲之一，*SelenaGomezWolves.mp3*或*TheHeartWantsWhatItWantsSelenaGomez.mp3*。
- en: Python, Play a Country Song
  id: totrans-459
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python，播放一首乡村歌曲
- en: What we’ll do now is similar to interacting with the script *play_selena_gomez.py*,
    but here you’ll learn how to access different subfolders by using the *os* module
    as well as a different way of playing music files.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在做的事情类似于与脚本*play_selena_gomez.py*交互，但在这里你将学习如何通过使用*os*模块访问不同的子文件夹，以及另一种播放音乐文件的方法。
- en: Suppose you’ve organized your songs by genre. You put all classical music files
    in the subfolder *classic*, and all country music files in the folder *country*,
    and so on. You’ve placed these subfolders in the folder *chat* you just created.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经按音乐类型整理了你的歌曲。你将所有古典音乐文件放在子文件夹*classic*中，将所有乡村音乐文件放在*country*文件夹中，依此类推。这些子文件夹都被放置在你刚刚创建的*chat*文件夹中。
- en: We want to write a script so that when you say, “Python, play a country song,”
    the script will randomly select a song from the folder *country* and play it.
    Enter the code in [Listing 5-10](#listing5-10) and save it as *play_genre.py*.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要编写一个脚本，这样当你说“Python，播放一首乡村歌曲”时，脚本会从*country*文件夹中随机选择一首歌并播放。输入[列表 5-10](#listing5-10)中的代码并将其保存为*play_genre.py*。
- en: '[PRE73]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Listing 5-10: Python code to voice activate a song by genre'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-10：用于按音乐类型语音激活歌曲的Python代码
- en: 'Python checks for the terms *play a* and *song* in the voice command and activates
    the music mode if it finds them. The script then replaces `play a` 1 and `song`
    2 as well as the whitespace behind them with an empty string, leaving only the
    genre—`country`, in this case—in the voice command. This is used as the folder
    for the script to search: in this case, *./chat/country*. Finally, the script
    randomly selects a song from the folder 3 and plays it.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: Python检查语音命令中的*play a*和*song*，如果找到，就激活音乐模式。然后，脚本将`play a` 1 和 `song` 2 以及它们后面的空格替换为空字符串，只留下类型——此处为`country`——在语音命令中。这个类型会被用作脚本搜索的文件夹：在本例中为*./chat/country*。最后，脚本从该文件夹3中随机选择一首歌并播放。
- en: Note that we use `lower()` after `voice_to_text()` in the script so that the
    voice command is all lowercase. We do this because the script sometimes converts
    the voice command into `play A Country Song`. We can avoid mismatch due to capitalization.
    On the other hand, the path and filenames are not case sensitive, so even if you
    have capital letters in your path or filenames, there will not be any mismatch.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在脚本中使用`lower()`函数来处理`voice_to_text()`，这样语音命令就会变成全小写。这是因为脚本有时会将语音命令转换为`play
    A Country Song`。我们这样做是为了避免由于大小写不一致导致的匹配错误。另一方面，路径和文件名不区分大小写，因此即使路径或文件名中有大写字母，也不会出现匹配错误。
- en: Summary
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you first learned to create a Python package to contain the
    local text-to-speech and speech recognition modules. After that, you built several
    real-world applications that can understand voice commands, react, and speak.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你首先学会了创建一个Python包来包含本地的文本到语音和语音识别模块。之后，你构建了几个能够理解语音命令、做出反应并发声的真实应用。
- en: You created a voice-controlled, talking Guess the Number game. In the game,
    you pick a number between one and nine and interact with the script to let it
    guess. Then you learned how to parse text to extract a news summary from the NPR
    website, adding the speech recognition and text-to-speech features to make a voice-controlled
    newscast.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个语音控制的、能说话的“猜数字”游戏。在这个游戏中，你从1到9之间选择一个数字，并与脚本互动让它进行猜测。然后，你学习了如何解析文本，从NPR网站提取新闻摘要，加入语音识别和文本转语音功能，制作一个语音控制的新闻广播。
- en: You learned how to use the *wikipedia* module to obtain answers to your inquiries.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 你学会了如何使用*wikipedia*模块来获取你查询的答案。
- en: You traversed files in a folder on your computer by using the *os* module, and
    then created a script that plays a genre or artist when you ask it to.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用*os*模块遍历了计算机上的文件夹中的文件，然后创建了一个脚本，当你要求时，它会播放某个音乐类型或艺术家的歌曲。
- en: Now that you know how to make Python talk and listen, you’ll apply both features
    to many other interesting situations throughout the rest of the book so that you
    can interact with your computer via voice only.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何让Python说话和倾听，你将在本书的其余部分中将这两个功能应用到许多其他有趣的情境中，这样你就可以仅通过语音与计算机互动。
- en: End-of-Chapter Exercises
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 章节结束练习
- en: Modify *guess_hs.py* so that the third guess of the script is two instead of
    one.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改*guess_hs.py*，使得脚本的第三次猜测变为2而不是1。
- en: Change *wiki.py* so that it prints out the first 300 characters of the result
    from Wikipedia.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 *wiki.py*，使其打印出来自 Wikipedia 结果的前 300 个字符。
- en: Modify *play_genre.py* so that the script plays music by using the *os* module
    and your default music player on your computer, instead of the *pygame* module.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 *play_genre.py*，使脚本通过使用 *os* 模块和计算机上的默认音乐播放器播放音乐，而不是使用 *pygame* 模块。
- en: Suppose the music files on your computer are not in MP3 format but in WAV format.
    How can you modify *play_selena_gomez.py* so that the script still works?
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你计算机上的音乐文件不是 MP3 格式，而是 WAV 格式。你如何修改*play_selena_gomez.py*，使得脚本仍然能够正常工作？
- en: '6'
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Web Scraping Podcasts, Radios, and Videos
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: Web 爬取播客、电台和视频
- en: '![](Images/chapterart.png)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: In this chapter, you’ll build on the web-scraping basics from Chapter 5. You’ll
    use these skills to voice-activate podcasts, live radio broadcasts, and videos
    on different websites.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将基于第 5 章中的 Web 爬取基础知识，使用这些技能实现语音激活播客、直播电台和不同网站上的视频。
- en: You’ll also learn how HyperText Markup Language (HTML) works and how the various
    types of HTML tags construct web pages. You’ll learn how to use Python’s Beautiful
    Soup library to parse HTML files and extract information.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将学习超文本标记语言（HTML）是如何工作的，以及各种 HTML 标签如何构建网页。你将学习如何使用 Python 的 Beautiful Soup
    库来解析 HTML 文件并提取信息。
- en: 'With all these skills, you’ll build three apps to do the following:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 凭借这些技能，你将构建三个应用程序来执行以下操作：
- en: Parse the source file of online podcasts, locate an MP3 file, and play the podcast.
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析在线播客的源文件，找到 MP3 文件并播放播客。
- en: Use voice control to play online live radio.
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用语音控制播放在线直播电台。
- en: Play online videos, such as NBC’s *Nightly News with Lester Holt*.
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放在线视频，例如 NBC 的 *Nightly News with Lester Holt*。
- en: Before you begin, set up the folder */mpt/ch06/* for this chapter. As usual,
    you can download all the code for all the scripts from [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/).
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，为本章设置文件夹 */mpt/ch06/*。如同往常，你可以从 [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/)
    下载所有脚本的代码。
- en: A Primer on Web Scraping
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web 爬取入门
- en: The Beautiful Soup library is designed to extract information from websites.
    We’ll use it often in this book, just as many Python programmers do in the real
    world.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: Beautiful Soup 库旨在从网站中提取信息。在本书中，我们将经常使用它，正如许多 Python 程序员在现实世界中使用一样。
- en: I’ll first discuss the basics of HTML markup and how different types of tags
    form various blocks on a website. You’ll then learn to use the Beautiful Soup
    library to extract information from websites by parsing their source code.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先讨论 HTML 标记的基础知识以及不同类型的标签如何在网站上形成各种区块。然后，你将学习如何使用 Beautiful Soup 库通过解析源代码从网站中提取信息。
- en: What Is HTML?
  id: totrans-491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是 HTML？
- en: As noted at the start of the chapter, *HTML* stands for *HyperText Markup Language*,
    the programming language that tells browsers how to construct and display web
    page content. HTML uses various types of tags to build the structure of web pages.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开头所提到的，*HTML* 代表 *超文本标记语言*，是一种告诉浏览器如何构建和显示网页内容的编程语言。HTML 使用各种类型的标签来构建网页的结构。
- en: Anatomy of an HTML Tag
  id: totrans-493
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: HTML 标签的结构
- en: '[Table 6-1](#table6-1) lists some of the commonly used tags and their main
    functions.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-1](#table6-1) 列出了常用的一些标签及其主要功能。'
- en: 'Table 6-1: Commonly Used HTML Tags'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1：常用 HTML 标签
- en: '| **Tag name** | **Description** |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| **标签名称** | **描述** |'
- en: '| --- | --- |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `<html>` | The root-level tag of an HTML document. It encapsulates all other
    HTML tags. |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| `<html>` | HTML 文档的根级标签。它包含了所有其他 HTML 标签。 |'
- en: '| `<head>` | The head section of an HTML document that contains metadata about
    the page. |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| `<head>` | HTML 文档的头部部分，包含有关页面的元数据。 |'
- en: '| `<title>` | The title of the web page, to be displayed on the tab of the
    browser. |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| `<title>` | 网页的标题，将显示在浏览器的标签页上。 |'
- en: '| `<body>` | The body of an HTML document, with all displayed content. |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| `<body>` | HTML 文档的主体部分，包含所有显示的内容。 |'
- en: '| `<h1>` | A level-1 heading, for example, the title of a news article. |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| `<h1>` | 级别 1 标题，例如新闻文章的标题。 |'
- en: '| `<p>` | A paragraph of displayed content. |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '| `<p>` | 一段显示的内容。 |'
- en: '| `<div>` | A container used for page elements that divide the HTML document
    into sections. |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '| `<div>` | 用于页面元素的容器，将 HTML 文档分成不同的部分。 |'
- en: '| `<a>` | A hyperlink to link one page to another. |'
  id: totrans-505
  prefs: []
  type: TYPE_TB
  zh: '| `<a>` | 超链接，用于将一个页面链接到另一个页面。 |'
- en: '| `<li>` | A list item. |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
  zh: '| `<li>` | 一个列表项。 |'
- en: All tags start with `< >` and end with `</ >` so that the browser can identify
    separate tags. For example, paragraph tags start with `<p>` and close with `</p>`.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 所有标签以`< >`开头，以`</ >`结尾，以便浏览器能够识别不同的标签。例如，段落标签以`<p>`开始，以`</p>`结束。
- en: 'Let’s use `<a>` to illustrate the components of HTML tags. Here’s an example
    of creating a hyperlink by using an `<a>` tag:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`<a>`标签来说明HTML标签的组成部分。下面是使用`<a>`标签创建超链接的一个例子：
- en: '[PRE74]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This hyperlink has optional attributes in the opening tag: `<a class="suprablue"
    href="http://libraries.uky.edu">`. The `class` attribute tells the browser which
    style to use from the Cascading Style Sheets (CSS), where the class name `suprablue`
    is predefined (you’ll learn how to define a class in the following section). The
    `href` attribute specifies the destination of the hyperlink, [http://libraries.uky.edu/](http://libraries.uky.edu/).
    The content of the tag that will be displayed on the page is between the opening
    and closing tags: `Libraries`.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 这个超链接在开口标签中有可选的属性：`<a class="suprablue" href="http://libraries.uky.edu">`。`class`属性告诉浏览器从层叠样式表（CSS）中使用哪种样式，`suprablue`类名是预定义的（你将在接下来的部分学习如何定义一个类）。`href`属性指定了超链接的目标地址，[http://libraries.uky.edu/](http://libraries.uky.edu/)。标签的内容将在页面上显示，位于开口和闭合标签之间：`Libraries`。
- en: From HTML Tags to Web Pages
  id: totrans-511
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从HTML标签到网页
- en: To understand how HTML uses tags to construct a web page, let’s look at an extremely
    simplified example. Enter the script in [Listing 6-1](#listing6-1) and save it
    as *UKYexample.html* in your chapter folder, or you can download the file from
    the book’s resources page. All HTML files need the extension *.html* or *.htm*.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解HTML如何使用标签构建网页，让我们看一个极为简化的例子。输入[清单6-1](#listing6-1)中的脚本，并将其保存为*UKYexample.html*到你的章节文件夹中，或者你也可以从书籍的资源页面下载该文件。所有HTML文件都需要以*.html*或*.htm*为扩展名。
- en: '[PRE75]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Listing 6-1: HTML code for a simple web page'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 清单6-1：一个简单网页的HTML代码
- en: Before I explain the code, let’s see how the actual web page looks. Go to your
    chapter folder and open *UKYexample.html* with your preferred web browser. I use
    Google Chrome, and the web page comes out as in [Figure 6-1](#figure6-1).
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在我解释代码之前，让我们先看一下实际网页的样子。进入你的章节文件夹，用你喜欢的浏览器打开*UKYexample.html*。我使用的是谷歌浏览器，网页显示效果如[图6-1](#figure6-1)所示。
- en: '![f06001](Images/f06001.png)'
  id: totrans-516
  prefs: []
  type: TYPE_IMG
  zh: '![f06001](Images/f06001.png)'
- en: 'Figure 6-1: A simple web page'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-1：一个简单的网页
- en: Now let’s link the HTML code to the web page display.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将HTML代码链接到网页显示。
- en: 'At 1, we start an opening `<html>` tag to contain all the code in the script.
    Then, we have a `<title>` tag nested in a `<head>` tag. The `<head>` tag is usually
    used to contain metadata, such as the document title or CSS styles. The content
    of the `<title>` tag is `Example: University of Kentucky`, which sets the title
    of the web page shown in the browser tab at the top-left corner in [Figure 6-1](#figure6-1).'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '在1处，我们开始一个开口的`<html>`标签，用来包含脚本中的所有代码。接着，我们有一个嵌套在`<head>`标签中的`<title>`标签。`<head>`标签通常用于包含元数据，例如文档标题或CSS样式。`<title>`标签的内容是`Example:
    University of Kentucky`，这将设置网页标题，在浏览器标签的左上角显示，如[图6-1](#figure6-1)所示。'
- en: 'The content inside the `<style>` tag is to define two classes: `redtext` and
    `leftmargin`. The first one tells the HTML to display the content in red, while
    the second tells the HTML to leave a 10-pixel left margin. You can specify multiple
    styles such as background color, padding, or margins in one class.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '`<style>`标签中的内容是用来定义两个类：`redtext`和`leftmargin`。第一个类告诉HTML将内容以红色显示，而第二个类则告诉HTML留出10像素的左边距。你可以在一个类中指定多种样式，如背景颜色、内边距或边距等。'
- en: At 2, we start the body HTML that will be displayed on the page. Inside this
    we have three nested `<p>` tags. A `<p>` tag defines a separate paragraph in an
    HTML document; adding a new `<p>` tag starts a new paragraph. The first `<p>`
    tag contains the message `Below are some links:`.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在2处，我们开始了网页主体HTML部分，该部分将显示在页面上。在其中我们有三个嵌套的`<p>`标签。`<p>`标签定义了HTML文档中的一个独立段落；添加一个新的`<p>`标签将开始一个新段落。第一个`<p>`标签包含信息`以下是一些链接：`。
- en: We then provide two hyperlinks, each in in an `<a>` tag nested in a `<p>` tag.
    We put each `<a>` tag in a separate `<p>` tag so the links are displayed as two
    different paragraphs instead of side by side on the same line. If you click the
    first link, it will bring you to the University of Kentucky Libraries. If you
    click the second link, you’ll be directed to the University of Kentucky Directory.
    The first tag has a class attribute of `redtext`, displaying the text in red,
    as defined in the `<style>` tag previously. Similarly, the second tag has a class
    attribute of `leftmargin`, and as a result, a 10-pixel margin precedes the text
    `University of Kentucky Library`.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们提供两个超链接，每个都位于嵌套在`<p>`标签中的`<a>`标签里。我们将每个`<a>`标签放在单独的`<p>`标签中，这样链接会作为两个不同的段落显示，而不是并排显示在同一行。如果点击第一个链接，它将带你到肯塔基大学图书馆。如果点击第二个链接，它会将你引导到肯塔基大学目录。第一个标签具有`redtext`的类属性，按之前在`<style>`标签中定义的方式将文本显示为红色。类似地，第二个标签具有`leftmargin`类属性，因此文本`University
    of Kentucky Library`前会有10像素的边距。
- en: Extract Information with Beautiful Soup
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Beautiful Soup提取信息
- en: Now that you understand how a few basic HTML tags work, you’ll use the Beautiful
    Soup library to parse the HTML code and extract the information you want. I’ll
    first discuss how to parse a locally saved HTML file. Then you’ll learn how to
    extract information from a live web page.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了几个基本的HTML标签是如何工作的，接下来你将使用Beautiful Soup库来解析HTML代码并提取你需要的信息。我将首先讨论如何解析本地保存的HTML文件。然后你将学习如何从实时网页中提取信息。
- en: Let’s revisit the simple example *UKYexample.html* saved in your chapter folder.
    Suppose you want to extract some web addresses from a web page. You can use [Listing
    6-2](#listing6-2), *parse_local.py*, to accomplish the task.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新查看你在章节文件夹中保存的简单示例*UKYexample.html*。假设你想从网页中提取一些网址。你可以使用[列表6-2](#listing6-2)中的*parse_local.py*来完成此任务。
- en: '[PRE76]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Listing 6-2: Parsing a local HTML file'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-2：解析本地HTML文件
- en: First, we import `BeautifulSoup()` from the *bs4* module, the latest version
    of Beautiful Soup. At 1, we open the local HTML file as a text file by using the
    built-in Python function `open()`. We then use `findAll()` to locate all `<p>`
    tags in the HTML file, and we put them in the list `ptags`.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从*bs4*模块导入`BeautifulSoup()`，这是Beautiful Soup的最新版本。在步骤1中，我们通过使用Python内建的`open()`函数以文本文件的形式打开本地HTML文件。然后我们使用`findAll()`来定位HTML文件中的所有`<p>`标签，并将它们放入`ptags`列表中。
- en: 'There are three `<p>` tags in the list `ptags`:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 列表`ptags`中有三个`<p>`标签：
- en: '[PRE77]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Let’s use the third tag as an example. At 2, we locate the `<a>` tag nested
    in the third `<p>` tag. We then print out the `href` attribute of the `<a>` tag:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 以第三个标签为例。在步骤2中，我们定位到嵌套在第三个`<p>`标签中的`<a>`标签。然后我们打印出该`<a>`标签的`href`属性：
- en: '[PRE78]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Finally, we print out the content of the `<a>` tag:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们打印出`<a>`标签的内容：
- en: '[PRE79]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The output for the whole script is as follows:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 整个脚本的输出结果如下：
- en: '[PRE80]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Scrape Live Web Pages
  id: totrans-537
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抓取实时网页
- en: Now let’s scrape a live web page. The HTML markup for a live web page is much
    more complicated than our simple static version and might be thousands of lines
    long, so you’ll need to learn to quickly locate the lines of code you want.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们抓取一个实时网页。实时网页的HTML标记比我们简单的静态版本要复杂得多，可能有成千上万行，所以你需要学会快速定位你需要的代码行。
- en: Suppose you want to extract the contact information from the University of Kentucky
    Libraries website. Go to [http://libraries.uky.edu/](http://libraries.uky.edu/)*.*
    Then scroll to the bottom of the page and you’ll see the contact information for
    various areas, as shown in [Figure 6-2](#figure6-2).
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想从肯塔基大学图书馆网站提取联系信息。访问[http://libraries.uky.edu/](http://libraries.uky.edu/)。然后滚动到页面底部，你将看到不同区域的联系信息，如[图6-2](#figure6-2)所示。
- en: '![f06002](Images/f06002.png)'
  id: totrans-540
  prefs: []
  type: TYPE_IMG
  zh: '![f06002](Images/f06002.png)'
- en: 'Figure 6-2: Information you want from a live web page'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-2：你从一个实时网页中获取的信息
- en: 'You want to extract the department name, phone number, and email address for
    each of the three departments shown in [Figure 6-2](#figure6-2): Circulation,
    Reference, and Interlibrary Loan. First you need to locate the corresponding tags
    in the HTML document.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要提取[图6-2](#figure6-2)中显示的三个部门的信息：流通部、参考部和馆际借阅部的部门名称、电话号码和电子邮件地址。首先，你需要在HTML文档中找到相应的标签。
- en: While on the web page, press ctrl-U on your keyboard (or right-click and choose
    **View**▶**Source**). The source code for the web page should appear. You can
    see that it’s more than 2,000 lines long. To locate the tags you need, press ctrl-F
    to access a search box at the top-right corner. Enter `Circulation` and click
    **Search** to skip to the corresponding HTML code, shown in [Listing 6-3](#listing6-3).
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页上，按下键盘上的ctrl-U（或者右键点击并选择**查看**▶**源代码**）。网页的源代码应该会出现。你会看到它有超过2,000行长。为了定位你需要的标签，按ctrl-F在右上角打开搜索框。输入`Circulation`并点击**搜索**，这样就可以跳转到对应的HTML代码，如[清单6-3](#listing6-3)所示。
- en: '[PRE81]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Listing 6-3: Part of the source code for a live web page'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 清单6-3：实时网页源代码的一部分
- en: 'Notice that all the information is encapsulated in a parent `<div>` tag with
    `class` attribute of `sf-middle` 1. Information for the Circulation department
    (name, phone number, and email address) is held in a child `<div>` tag with class
    attribute of `dashing-li` 2. The information for the other two areas, Reference
    3 and Interlibrary Loan 4, is held in two other child `<div>` tags within the
    parent tag. Within each child tag, subtags each contain a piece of the following
    information: department name, phone number, and email address.'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有信息都被封装在一个`class`属性为`sf-middle`的父`<div>`标签中1。Circulation部门的信息（包括名称、电话号码和电子邮件地址）被存放在一个类属性为`dashing-li`的子`<div>`标签中2。其他两个区域的信息，Reference
    3和Interlibrary Loan 4，则存放在父标签中的两个其他子`<div>`标签里。在每个子标签内，子标签分别包含以下几项信息：部门名称、电话号码和电子邮件地址。
- en: These patterns are important to notice when writing a Python script to extract
    the information you need. Next, I’ll explain how to use these patterns to extract
    the information from the HTML file.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式在编写Python脚本以提取所需信息时非常重要。接下来，我将解释如何利用这些模式从HTML文件中提取信息。
- en: Download *scrape_live_web.py* from the book’s resources page and save it in
    your chapter folder. The first part of the script is shown in [Listing 6-4](#listing6-4),
    which locates the `<div>` tags for each of the three areas.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 从书籍的资源页面下载*scrape_live_web.py*并保存在你的章节文件夹中。脚本的第一部分如[清单6-4](#listing6-4)所示，定位了每个区域的`<div>`标签。
- en: '[PRE82]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Listing 6-4: Python code to scrape a live web page'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 清单6-4：爬取实时网页的Python代码
- en: We import the *requests* module to obtain the source code from the live web
    page. The address of the web page is defined in the variable `url`. At 1, we use
    `get()` to fetch the HTML code. Then, we find the `<div>` tag with the class value
    of `sf-middle` and use it as the parent tag.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了*requests*模块来获取来自实时网页的源代码。网页地址保存在变量`url`中。在第1步，我们使用`get()`来获取HTML代码。然后，我们找到类值为`sf-middle`的`<div>`标签，并将其作为父标签。
- en: At 2, we locate the three child `<div>` tags with the class value of `dashing-li`
    and put them in the list `contacts`, because each child `<div>` tag contains all
    the contact information for one department. Each element in the list corresponds
    to one of the departments. For example, the first element contains all the information
    for the Circulation department, and we print it out in [Listing 6-5](#listing6-5).
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步，我们定位到三个子`<div>`标签，它们的类值为`dashing-li`，并将它们放入列表`contacts`中，因为每个子`<div>`标签包含一个部门的所有联系信息。列表中的每个元素对应一个部门。例如，第一个元素包含了Circulation部门的所有信息，我们在[清单6-5](#listing6-5)中打印出来。
- en: '[PRE83]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Listing 6-5: Source code for the Circulation department on the live web page'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 清单6-5：Circulation部门的实时网页源代码
- en: The second part of *scrape_live_web.py* will print out the detailed information
    for each of the three areas. It is shown in [Listing 6-6](#listing6-6).
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '*scrape_live_web.py*的第二部分将打印出每个区域的详细信息。如[清单6-6](#listing6-6)所示。'
- en: '[PRE84]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Listing 6-6: Python code to print out the scraped information'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 清单6-6：打印出爬取信息的Python代码
- en: 'We go into each element in the list `contacts`. To print out the department
    name, we locate the `<span>` tag with the class attribute of `contact_area`. The
    content of the tag is the department name. The two `<a>` tags contain the phone
    number and the email address of each department, and we also print them out. The
    output is shown here:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历列表`contacts`中的每个元素。为了打印出部门名称，我们找到带有`contact_area`类属性的`<span>`标签。该标签的内容就是部门名称。两个`<a>`标签包含每个部门的电话号码和电子邮件地址，我们也将它们打印出来。输出结果如下所示：
- en: '[PRE85]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Voice-Activated Podcasts
  id: totrans-560
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语音激活的播客
- en: In this project, our goal is to write a script that enables you to say, “Python,
    tell me the latest news,” and the script will broadcast a brief from an NPR news
    podcast. You’ll first learn how to extract the MP3 file associated with the podcast
    and play it, and then you’ll add the speech recognition feature to the script
    so that you can voice-activate it. Because the news brief is about five minutes
    long, you’ll also learn how to stop the podcast via voice control while the news
    is playing.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: Extract and Play Podcasts
  id: totrans-562
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, find a website with a newscast you like. For this, we’ll use *NPR News
    Now* because it’s free and updated every hour, 24/7\. The web address is [https://www.npr.org/podcasts/500005/npr-news-now/](https://www.npr.org/podcasts/500005/npr-news-now/).
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: Go to the site, and you should see something like [Figure 6-3](#figure6-3).
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '![f06003](Images/f06003.png)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-3: Front page of *NPR News Now*'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the latest news brief for me was updated at 7 am ET on Feb 9,
    2021\. Below it, you can also see news briefs from 6 am, 5 am, and so on.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: To locate the MP3 file that contains the news briefs, right-click anywhere on
    the page and, from the menu that appears, select the **View page source** option
    (or press ctrl-U). You should see the source code, as in [Figure 6-4](#figure6-4).
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '![f06004](Images/f06004.png)'
  id: totrans-569
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-4: Source code for *NPR News Now*'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that the MP3 files are contained in `<a>` tags. We need to use
    the Beautiful Soup library to extract all `<a>` tags that contain MP3 files and
    then extract the link from the first tag, which will contain the latest news brief.
    If you wanted to, you could listen to previous news briefs as well; for example,
    the second and the third tags contain the news briefs from 6 am and 5 am in [Figure
    6-3](#figure6-3).
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to extract the link, remove unwanted components, and use the *webbrowser*
    module to open the URL of the MP3 file so that the podcast can start playing.
    The script *npr_news.py*, in [Listing 6-7](#listing6-7), shows how to accomplish
    this.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Listing 6-7: A script to play online podcasts'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: We first use `get()` from the *requests* module to obtain the source code of
    the *NPR News Now* website and save it in the variable `response`. At 1, we use
    the Beautiful Soup library to parse the text and the `html.parser` option to specify
    that the source code is in HTML. We saw in [Figure 6-4](#figure6-4) that the MP3
    files are held in `<a>` tags with a `class` attribute of `audio-module-listen`.
    Therefore, at 2 we use `findAll()` from Beautiful Soup to get all those tags and
    put them in the list `casts`. [Listing 6-8](#listing6-8) shows the content of
    `casts`.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Listing 6-8: All `<a>` tags with a `class` attribute of `audio-module-listen`'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, multiple `<a>` tags contain MP3 files. At 3, we extract the
    first `<a>` tag in the list and obtains the `href` attribute of the tag (the link
    to the MP3 file), saving it to `cast`. The link is as follows:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We trim the link so that it ends with the *.mp3* extension. To do that, we
    use the fact that the *?* character is right after *.mp3* in the link and then
    use the string method `find()` to locate the position of *?* in the link 4. We
    then trim the link accordingly and print it out. The trimmed link is as follows:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修剪链接，以使其以*.mp3*扩展名结尾。为此，我们利用链接中*.mp3*后面紧跟的*?*字符，并使用字符串方法`find()`来定位链接中*?*的位置
    4. 然后相应地修剪链接并打印出来。修剪后的链接如下所示：
- en: '[PRE89]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Finally, we extract the link to the online MP3 file and use `open()` in the
    *webbrowser* module to open and play the MP3 file.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们提取在线MP3文件的链接，并使用*webbrowser*模块中的`open()`打开和播放MP3文件。
- en: If you run the script, you should hear the latest NPR news brief playing in
    your default web browser.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行脚本，您应该听到最新的NPR新闻简报在您的默认网络浏览器中播放。
- en: Voice-Activate Podcasts
  id: totrans-584
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语音激活播客
- en: Next, we’ll add speech recognition to the script so you can voice-activate the
    podcast. Further, since the podcast is about five minutes long, being able to
    stop it with your voice is useful. To achieve that, we need to install the *pygame*
    module because it allows the Python script to stop the audio file while the audio
    is playing. The *webbrowser* module does not have that functionality.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在脚本中添加语音识别，以便您可以语音激活播客。此外，由于播客大约有五分钟长，能够用语音停止它非常有用。为了实现这一点，我们需要安装*pygame*模块，因为它允许Python脚本在音频播放时停止音频文件。*webbrowser*模块没有这个功能。
- en: 'Installing *pygame* is straightforward in Windows. Execute this line of code
    in an Anaconda prompt with your virtual environment activated:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中安装*pygame*非常简单。在Anaconda提示符下执行以下代码行，并确保虚拟环境已激活：
- en: '[PRE90]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Then follow the instructions.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照说明操作。
- en: 'If you are using Mac, recent versions of macOS require the installation of
    Pygame 2\. To install it, execute this line of code in a terminal with your virtual
    environment activated:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Mac，最新版本的macOS需要安装Pygame 2\. 要安装它，请在终端中执行以下代码，并确保虚拟环境已激活：
- en: '[PRE91]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Then follow the instructions.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按照说明操作。
- en: 'If you are using Linux, execute the following three lines of code in a terminal
    with your virtual environment activated:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Linux，请在终端中执行以下三行代码，并确保虚拟环境已激活：
- en: '[PRE92]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: See Appendix A at the end of this book for further detail. If the installation
    is not successful, you can use the *vlc* module as an alternative.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅本书结尾的附录A以获取更多详细信息。如果安装不成功，可以使用*vlc*模块作为替代。
- en: The script *news_brief_hs.py* in [Listing 6-9](#listing6-9) shows how to use
    voice control to activate the *NPR News Now* podcast and stop it whenever you
    want.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本*news_brief_hs.py*在[列表6-9](#listing6-9)中展示了如何使用语音控制激活*NPR News Now*播客并在需要时停止它。
- en: '[PRE93]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Listing 6-9: Python script to voice-activate *NPR News Now*'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-9：用于语音激活*NPR News Now*的Python脚本
- en: We import needed modules first. In particular, we import `BytesIO()` from the
    *io* module to create a temporary file to contain the news brief audio file. This
    prevents crashes that could occur if the script had to overwrite the file when
    you rerun it.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入所需的模块。特别是，我们从*io*模块导入`BytesIO()`来创建一个临时文件，用于保存新闻简报的音频文件。这可以防止在重新运行脚本时发生覆盖文件的崩溃。
- en: We define `news_brief()` 1. This function accomplishes what we did in *npr_news.py*
    with a few exceptions. We download the MP3 file and save it to the temporary file
    *voice*. After that, we use the *pygame* module to play the latest news brief
    from *NPR News Now*.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义`news_brief()` 1. 此函数完成了我们在*npr_news.py*中所做的事情，但有一些例外。我们下载MP3文件并将其保存到临时文件*voice*中。之后，我们使用*pygame*模块播放*NPR
    News Now*的最新新闻简报。
- en: At 2, we start an infinite loop. At each iteration, the script captures your
    voice. When the word *news* is in your voice command 3, the script will call `news_brief()`
    and start playing the latest NPR news brief. While the news is playing, the script
    is constantly listening to your voice command in the background. When you say,
    “Stop playing,” anytime while or after the news plays, the loop will break and
    go back to the main menu. If you want to end the script, simply say, “Stop listening.”
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 在2处，我们启动一个无限循环。在每次迭代中，脚本会捕捉您的语音。当您的语音命令中包含*news*时 3，脚本将调用`news_brief()`并开始播放最新的NPR新闻简报。当新闻播放时，脚本会在后台持续监听您的语音命令。当您说“停止播放”时，无论何时在或之后，循环将中断并返回主菜单。如果要结束脚本，只需说“停止监听”。
- en: Voice-Activated Radio Player
  id: totrans-601
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语音激活收音机播放器
- en: Our goal in this project is to write a script to play online live radio using
    voice control. When you say, “Python, play online radio,” the script will go to
    the website and click the Play button so that the live radio starts playing on
    your computer.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be using the *selenium* module to automate web browser interaction from
    Python. We’ll then add voice control to the script to achieve voice activation.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: Install the selenium Module
  id: totrans-604
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *selenium* module is not in the Python standard library, so first we’ll
    install it. Open your Anaconda prompt (Windows) or a terminal (Mac or Linux),
    activate your virtual environment, and execute this command:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Follow the onscreen instructions to finish the installation.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: Control Web Pages
  id: totrans-608
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *selenium* module allows you to automate web browser interactions with Python.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: Online Radio Box (*https://onlineradiobox.com/us/*) will serve as our radio
    station platform. You can change this to any online radio station you like, such
    as Magic 106.7 or NPR online radio stations.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: Go to the website and you should see a screen similar to that shown in [Figure
    6-5](#figure6-5).
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '![f06005](Images/f06005.png)'
  id: totrans-612
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-5: Front page of Online Radio Box'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: When the web page loads, live radio is not playing. You need to use *selenium*
    to interact with the web browser to click the Play button (the triangle-shaped
    white button at the bottom in [Figure 6-5](#figure6-5)).
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: Now you’ll learn how to locate the XPath of the Play button on the website.
    *XPath* is short for *Extensible Markup Language (XML) path*. It is the syntax
    for finding an element on the web page by using an XML path expression.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to find the XPath of the Play button:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: Open the web page of Online Radio Box, shown in [Figure 6-5](#figure6-5), using
    the Chrome browser.
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put your mouse cursor on the Play button (do not click). Then right-click and
    choose **Inspect** from the pop-up menu. The source code will show at the right
    side of the web page, as shown in [Figure 6-6](#figure6-6).
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the highlighted line of code at the right side of the page and select
    **Copy**▶**XPath**.
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Paste the XPath in a blank file to be used later. In this example, the XPath
    for the Play button is `//*[@id="b_top_play"]`.
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![f06006](Images/f06006.png)'
  id: totrans-621
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-6: Locate the XPath of the Play button'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to download the web driver for a specific browser. If you’d like
    to learn more about the Selenium project, an abundance of information is on its
    website.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: Follow the instructions at [https://chromedriver.chromium.org/downloads/](https://chromedriver.chromium.org/downloads/)
    and download the executable file appropriate to your operating system. In Windows,
    this is *chromedriver_win32.zip*; extract the ZIP file and place the executable
    file in the chapter folder. On Unix-based operating systems, the executable file
    is called *chromedriver*. On Windows, the executable file is *chromedriver.exe*.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: As the final step, save *play_live_radio.py* in your chapter folder and run
    it. The script, also available at the book’s resources page, is shown in [Listing
    6-10](#listing6-10).
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Listing 6-10: Python code to automate online live radio'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: We first import `webdriver()` from the *selenium* module. First, the script
    launches the web browser. Then, the `get()` function brings us to the live radio
    site based on the web address provided. We then define the Play button as a variable
    button, using the XPath that we’ve generated . Finally, we use `click()` in the
    *selenium* module to activate the Play button on the website. Consequently, if
    everything is installed and configured correctly, when you run the script, the
    web browser will open and the online live radio will start playing.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: It’s educational to run the script line by line by using the F9 key. You will
    see that after the first line is run, the Chrome browser opens on your computer,
    and after the second, the browser brings you to the Online Radio Box site. With
    the final two lines, the Play button is being activated. You will then hear the
    live radio playing.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: Voice-Activate Live Radio
  id: totrans-630
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll add speech recognition and text-to-speech functionality to the script
    so you can voice-activate the online live radio. The script *voice_live_radio.py*
    in [Listing 6-11](#listing6-11) shows you how to accomplish that.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Listing 6-11: Python code to voice-activate online live radio'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: We first import all needed modules. Since we need the speech recognition and
    text-to-speech features, we import `voice_to_text()` from the local `mptpkg` package
    to convert speech to text. We also import `print_say()` from the local `mptpkg`
    package to convert text to human speech.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: We then define `live_radio()` to accomplish what *play_live_radio.py* does with
    a few modifications 1. When the function is activated, the script will go to the
    online live radio station and click the Play button so that live radio starts
    playing. We use the `headless` option so you won’t see a web browser pop up. We
    also make the variable `button` a global variable so we can use the variable later
    in the script.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: At 2, an infinite loop begins. At each iteration, the script asks, “How may
    I help you?” After you speak into the microphone, `voice_to_text()` converts your
    speech to text and saves it as the string variable `inp`. The `lower()` function
    converts all characters to lowercase to avoid mismatch due to letter capitalization
    3.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: When you say, “Stop listening,” the `if` branch of the code is activated 4.
    The script prints `Goodbye`, the loop breaks, and the script ends. When the word
    *radio* is in your voice command, the `elif` branch of the code is activated 5.
    As a result, `live_radio()` is called, and the online live radio starts playing.
    While the radio is playing, the script is quietly listening to you in the background.
    If you say, “Stop playing” anytime when the radio is playing, the button will
    click again and the radio will change from Play to Stop. After that, the script
    exits the radio mode and returns to the main menu.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: Voice-Activated Videos
  id: totrans-638
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can apply the method you learned in the preceding section to voice-activate
    prerecorded online videos or even online live TV.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: NBC’s *Nightly News with Lester Holt* provides prerecorded videos at [https://www.nbcnews.com/nightly-news-full-episodes/](https://www.nbcnews.com/nightly-news-full-episodes/),
    shown in [Figure 6-7](#figure6-7).
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '![f06007](Images/f06007.png)'
  id: totrans-641
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-7: Front page of NBC’s *Nightly News*'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use Python to interact with the web browser to click the Play button that
    activates the online video. You can see a triangle-shaped Play button on the video
    frame. Follow the steps in “Control Web Pages” on page 125 to find the XPath of
    the button.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: The script *voice_online_video.py* in [Listing 6-12](#listing6-12) shows how
    to voice-activate the online video.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Listing 6-12: A script to voice-activate online video'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: The logic is the same as when dealing with live radio. We first define `online_video()`
    to be called later. When the function is activated, the script will go to the
    site, locate the XPath of the Play button 1, and click it so the video will start
    playing.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: An infinite loop starts at 2. At each iteration, the script asks, “How may I
    help you?” After you speak into the microphone, `voice_to_text()` converts your
    speech to text and saves it as an all-lowercase string variable `inp`.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: When you say, “Stop listening,” the `if` branch of the code is activated. The
    script prints `Goodbye!`, the loop breaks, and the script ends. When the word
    *video* is in your voice command, the `elif` branch of the code is activated.
    As a result, `online_video()` is called, and the online video starts playing.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-650
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, you learned the basics of web scraping: how HTML works, including
    the different types and uses of HTML tags, and how to use the Beautiful Soup library
    to parse HTML files and scrape the information you need.'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: Armed with these techniques, you learned how to parse a source file of the podcast
    *NPR News Now* and locate its MP3 file. You then used the *webbrowser* module
    to play the online MP3\. You also learned how to voice activate online podcasts,
    using the *pygame* module to play the audio file so that you can stop it anytime
    via voice commands.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: You then learned to voice activate an Online Radio Box station. Specifically,
    you learned how to use the Selenium web driver to interact with a web browser.
    You directed Python to click the Play button to activate the live radio broadcast.
    You also learned to use voice control to accomplish these tasks.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you applied the same idea to online videos, such as NBC’s *Nightly
    News with Lester Holt*.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  id: totrans-655
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify *parse_local.py* to print out the `class` attribute value and the web
    address of the `<a>` tag for the University of Kentucky Libraries.
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *scrape_live_web.py* to print out the information for the site area All
    Other Questions & Comments, as shown in [Figure 6-2](#figure6-2).
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This URL points to a podcast by Gwyneth Paltrow and Oprah Winfrey: *https://goop.com/the-goop-podcast/gwyneth-x-oprah-power-perception-soul-purpose/.*
    Write a script to voice activate the online podcast.'
  id: totrans-658
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '7'
  id: totrans-659
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Virtual Personal Assistant
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  id: totrans-661
  prefs: []
  type: TYPE_IMG
- en: In this and the next chapter, you’ll learn how to create your own virtual personal
    assistant (VPA), similar to Amazon’s Alexa. You’ll first have an overview of your
    VPA and its functionalities. You’ll then import all needed modules at once so
    you can start to run your VPA right away. You’ll create a script to make your
    VPA stand by 24/7 without disturbing you. Whenever you need assistance, you can
    say, “Hello Python” to wake it up, and when you want it to stand by again, you
    can use a voice command to put it in standby mode.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: After that, you’ll examine various functionalities to add to your VPA. The first
    two are a timer and an alarm clock.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: The third functionality enables your VPA to tell jokes. When you say, “Tell
    me a joke,” the script will randomly select a joke from a list and speak it out
    loud to you.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: The fourth functionality sends email. If you say, “Send Jessica an email,” the
    script will activate the email feature, retrieve Jessica’s email address from
    your recipient list, and ask you for the subject line and content, which you can
    dictate before telling the VPA to send.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 8, you’ll learn how to make your VPA capable of answering (almost)
    any question. Before you begin, set up the folder */mpt/ch07/* for this chapter.
    As always, all scripts in this chapter are available at the book’s resources page,
    [https://www.nostarch.com/make-python-talk](https://www.nostarch.com/make-python-talk)/.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: An Overview of Your VPA
  id: totrans-667
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you learn about the functionalities of your VPA, let’s explore its structure.
    You’ll start by downloading needed files and installing a third-party module.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: Download VPA Files
  id: totrans-669
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s download the needed files. Go to the book’s resources website [https://www.nostarch.com/make-python-talk/](https://www.nostarch.com/make-python-talk/%20)
    and download the following files from the */mpt/mptpkg/* directory: *mywakeup.py*,
    *mytimer.py*, *myalarm.py*, *myjoke.py*, and *myemail.py*. Put them in the same
    directory on your computer where you place your self-made local package files.
    Refer to Chapter 5 for instructions. I’ll explain the purpose of these files later
    in this chapter.'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the script *__init__.py* in the package directory */mpt/mptpkg/*
    on your computer. As you may recall from Chapter 5, you’ve already placed the
    following two lines of code in it:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Add the five lines of code in [Listing 7-1](#listing7-1) to the end of *__init__.py*.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Listing 7-1: Importing functions from local modules to the local package'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: This code imports the five functions `wakeup()`, `timer()`, `alarm()`, `joke()`,
    and `email()` from the five modules to the local package so you can later import
    them at the package level. More on this point soon.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: Next, go to the book’s resources website and download *vpa.py* from the chapter
    directory */mpt/ch07/*. Save it on your computer where you place this chapter’s
    Python scripts. The code for *vpa.py* is shown in [Listing 7-2](#listing7-2).
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Listing 7-2: Python code for a VPA'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: We first import the seven functions (`voice_to_text()`, `print_say()`, `wakeup()`,
    and so on) from the local package *mptpkg*. The code in [Listing 7-1](#listing7-1)
    already imported the five functions (`wakeup()`, `timer()`, and so on) from the
    local modules to *mptpkg,* so here we import the functions at the package level
    directly.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: 'We start the script by creating an infinite loop 1. At each iteration, the
    VPA listens to your voice command quietly in the background. You can say, “Hello
    Python” to wake up the VPA. After it wakes up, the VPA asks, “How may I help you?”
    and takes your voice command. You can activate one of the four functionalities
    of the VPA 2: setting a timer, setting an alarm clock, telling a joke, or sending
    an email.'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: You can put the VPA back on standby when you are finished by including “back”
    and “standby” in your voice input. While the script is in standby, you can terminate
    the script by saying, “Stop the script” or “Stop listening.”
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: Before running *vpa.py*, you need to install a third-party module.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: Install the arrow Module
  id: totrans-684
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll first install the *arrow* module to tell the time and date for the timer
    and alarm clock functionalities in the VPA.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: The Python standard library has several modules that can tell the time and date,
    including the well-known *time* and *datetime*. However, they are not very user-friendly,
    with complicated formatting. Further, you need to use several modules in the Python
    standard library to achieve what we try to accomplish in this chapter. As a result,
    we’ll use the third-party module *arrow*, which offers a more convenient way to
    deal with times.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install *arrow* in your Anaconda prompt (Windows) or a terminal (Mac
    or Linux) by using the following command, with the virtual environment *chatting*
    activated:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在 Anaconda 提示符（Windows）或终端（Mac 或 Linux）中使用以下命令安装 *arrow*，并激活虚拟环境 *chatting*：
- en: '[PRE101]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Manage the Standby Mode
  id: totrans-689
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理待机模式
- en: Here you’ll set up the standby mode for your VPA. At the end of this section,
    you’ll be able to activate the VPA by saying, “Hello Python.” The VPA will respond,
    “How may I help you?”
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将为您的 VPA 设置待机模式。在本节结束时，您将能够通过说，“Hello Python”来激活 VPA。VPA 将回应，“How may I
    help you?”
- en: If you then say, “Go back to standby,” the script will return to standby mode
    and keep quiet. While it’s in standby, you can even choose to end the script by
    including *stop* in your voice command.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果您说，“返回待机模式”，脚本将进入待机模式并保持安静。在待机模式下，您甚至可以选择通过在语音命令中包含 *stop* 来结束脚本。
- en: Create the Local Module mywakeup
  id: totrans-692
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建本地模块 mywakeup
- en: First, you’ll set the script to recognize certain commands. Open *mywakeup.py*
    you just downloaded in your Spyder editor. This script is based on *mysr.py* from
    Chapter 3, with some significant modifications. [Listing 7-3](#listing7-3) highlights
    the differences.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要设置脚本以识别某些命令。在您的 Spyder 编辑器中打开您刚刚下载的 *mywakeup.py*。此脚本基于第三章的 *mysr.py*，并进行了重大修改。[列表
    7-3](#listing7-3) 突出了这些差异。
- en: '[PRE102]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Listing 7-3: Python code for the *my**w**akeup* module'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-3：*my**w**akeup* 模块的 Python 代码
- en: We first import `speech_recognition` and define `wakeup()` 1. We create a variable
    `wakeup` and set the default value as `StandBy`. We then capture the voice input
    from the microphone.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入 `speech_recognition` 并定义 `wakeup()` 1。我们创建一个变量 `wakeup` 并将默认值设置为 `StandBy`。然后，我们从麦克风捕获语音输入。
- en: 'Here I did a little tweaking to make the script more responsive: the `timeout=3`
    option in the `listen()` method tells the script to time out every three seconds
    and analyze the voice input 2, meaning it checks for a voice command every three
    seconds. Without this option, the script may wait too long to respond, and you
    may have to say, “Hello Python” a couple of times before you catch the script’s
    attention.'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我做了一些调整，使脚本更具响应性：`listen()` 方法中的 `timeout=3` 选项告诉脚本每 3 秒超时并分析语音输入 2，这意味着它每
    3 秒检查一次语音命令。如果没有这个选项，脚本可能会等待太长时间才能响应，您可能需要多次说，“Hello Python”才能引起脚本的注意。
- en: We convert all text to lowercase to avoid mismatch due to capitalization. We
    also use exception handling to prevent the script from crashing.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有文本转换为小写字母，以避免由于大小写不匹配而导致的错误。我们还使用异常处理来防止脚本崩溃。
- en: When a voice command is captured, the script checks whether *hello* and *Python*
    are in the voice input. If yes, the variable `wakeup` changes its value to `Activated`.
    Similarly, if you say, “Stop listening” or “Stop the script,” the variable `wakeup`
    changes to `ToQuit`. When the function is called, it will return whatever value
    is stored in the variable `wakeup`.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 当捕获到语音命令时，脚本会检查语音输入中是否包含 *hello* 和 *Python*。如果包含，变量 `wakeup` 的值将更改为 `Activated`。类似地，如果您说，“停止监听”或“停止脚本”，变量
    `wakeup` 将更改为 `ToQuit`。当调用该函数时，它将返回变量 `wakeup` 中存储的任何值。
- en: Set Some Responses
  id: totrans-700
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置一些响应
- en: Now that you know how the *mywakeup* module works, let’s learn how to manage
    standby mode.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经了解了 *mywakeup* 模块的工作原理，让我们学习如何管理待机模式。
- en: Run *vpa.py* in your Spyder editor. You’ll notice that when the script is running,
    nothing happens. However, your VPA is quietly listening in the background. You
    can activate the VPA by saying, “Hello Python.” Once the job is done, you can
    put it back to standby.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 Spyder 编辑器中运行 *vpa.py*。您会注意到，当脚本正在运行时，什么都没有发生。然而，您的 VPA 正在静静地在后台监听。您可以通过说，“Hello
    Python”来激活 VPA。一旦完成任务，您可以将其返回待机模式。
- en: 'The following output is from one interaction with the script, with my voice
    input in bold:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出来自与脚本的一次交互，我的语音输入以粗体显示：
- en: '[PRE103]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: As you can see, I activated the VPA and then put it back to standby. I activated
    the VPA and then returned it to standby a second time. After that, I said, “Stop
    listening” to end the script.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我激活了 VPA 然后又将其返回待机模式。我激活了 VPA 然后第二次将其返回待机模式。之后，我说，“停止监听”以结束脚本。
- en: Run the script several times to ensure that you can voice-activate the VPA,
    put it on standby, and end the script. Next, we’ll examine the individual functionalities
    of the VPA one by one.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 多次运行脚本，确保您可以通过语音激活 VPA，将其置于待机模式，并结束脚本。接下来，我们将逐个查看 VPA 的各项功能。
- en: Ask Your VPA to Set a Timer
  id: totrans-707
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让您的 VPA 设置定时器
- en: 'Let’s explore the first feature: setting a timer. To do that, you’ll first
    learn how to tell time in Python. We’ll use the *arrow* module to tell time in
    Python and then create a timer that takes written commands. Finally, we’ll create
    a `timer()` function in the local module *mytimer* that we’ll import into the
    VPA script; this will allow us to set a timer by using voice commands.'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: Tell the Time with Python
  id: totrans-709
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s first learn how to tell time with Python.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: The following script, *get_time.py,* shows how to retrieve the current time
    for your time zone in different formats. This is just an example so you can familiarize
    yourself with the *arrow* module; it’s not part of the VPA script.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: We first import the *arrow* module. Its `now()` function gives you the current
    local date and time, but you need to use `format()` to let the script know the
    format and level of detail of that information.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 7-1](#table7-1) lists some commonly used formats and the meanings associated
    with the `format()` function in *arrow*. For example, the uppercase `HH` and `H`
    generate the current hour value in a 24-hour clock, with and without a leading
    0, respectively, whereas `hh` and `h` do the same in a 12-hour clock.'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we retrieve the current time in `H:m:s` format on a 24-hour clock and
    then print it out. At 2, we obtain the time on a 12-hour clock, followed by AM
    or PM, in the format `hh:mm:ss`. Finally we print out just the hour value of the
    current time 3. You can do the same for the minute value or the second value.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run this script, you’ll have output similar to the following:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Table 7-1: Some Commonly Used Formats for the `format()` Method of the *arrow*
    Module'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: '| **Format code** | **Meaning** |'
  id: totrans-719
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-720
  prefs: []
  type: TYPE_TB
- en: '| `dddd` | Full weekday name |'
  id: totrans-721
  prefs: []
  type: TYPE_TB
- en: '| `ddd` | Abbreviated weekday name |'
  id: totrans-722
  prefs: []
  type: TYPE_TB
- en: '| `MMM` | Abbreviated month name |'
  id: totrans-723
  prefs: []
  type: TYPE_TB
- en: '| `MMMM` | Full month name |'
  id: totrans-724
  prefs: []
  type: TYPE_TB
- en: '| `YYYY` | Year in normal form (for example, 2021) |'
  id: totrans-725
  prefs: []
  type: TYPE_TB
- en: '| `HH` | Hour (24-hour clock) as a decimal number with leading zero |'
  id: totrans-726
  prefs: []
  type: TYPE_TB
- en: '| `hh` | Hour (12-hour clock) as a decimal number with leading zero |'
  id: totrans-727
  prefs: []
  type: TYPE_TB
- en: '| `A` | AM or PM |'
  id: totrans-728
  prefs: []
  type: TYPE_TB
- en: '| `mm` | Minute as a decimal number with leading zero |'
  id: totrans-729
  prefs: []
  type: TYPE_TB
- en: '| `ss` | Second as a decimal number with leading zero |'
  id: totrans-730
  prefs: []
  type: TYPE_TB
- en: 'You can also use the *arrow* module to get today’s date and weekday information,
    shown here in the *get_date.py* script:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: At 1, we use `now()` to generate the current date and time and save it in a
    string variable `today_date`. At 2, we print out the date in the format of January
    01, 2021, with an abbreviated form of the month name, and in numbers using the
    pattern MM/DD/YYYY. At 3, we print out the day of the week and then again in abbreviated
    form.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: 'This script generates output similar to the following:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Now that you know how to tell time in Python, you’ll learn how to set a timer.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: Build a Timer
  id: totrans-737
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll use our new *arrow* module skills with the `sleep()` function from the
    *time* module to build a timer that takes written commands. You won’t use this
    in your VPA script, but you’ll learn the skills needed to build a timer that takes
    voice commands.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: We’ll restrict the input to take hours only, minutes only, or hours and minutes
    (the script won’t take seconds). So you can set the timer to go off in 2 hours,
    or in 1 hour 30 minutes, or in 20 minutes—but not in 1 hour 30 minutes 20 seconds.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: Before we go into the details of the script, let’s understand the logic behind
    it. Your written command should be in the form of `set a timer for 1 hour 20 minutes`,
    `set a timer for 2 hours`, or `set a timer for 25 minutes`. The script then saves
    your written command in the string variable `inp`.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: The string method `find()` returns a value of `-1` if the characters you’re
    looking for are not in the string. We’ll use this feature to extract the hour
    and minute values in `inp`.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three cases:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: The value of `inp.find("hour")` is not `-1`, while the value of `inp.find("minute")`
    is `-1`. This means `minute` is not in the variable `inp` but `hour` is. You’ve
    set the timer in the form of `set a timer for 2 hours`. We extract the hour value
    between `timer for` and `hour` and set the minute value to `0`.
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of `inp.find("hour")` is `-1`, and the value of `inp.find("minute")`
    is not `-1`. This means `minute` is in the variable `inp` but not `hour`. You’ve
    set the timer in the form of `set a timer for 25 minutes`. We extract the minute
    value between `timer for` and `minute` and set the hour value to `0`.
  id: totrans-744
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neither the value of `inp.find("hour")` nor the value of `inp.find("minute")`
    is `-1`. This means both `hour` and `minute` are in the variable `inp`. You’ve
    set the timer in the form of `set a timer for 1 hour 20 minutes`. We extract the
    hour value between `timer for` and `hour` and the minute value between `hour`
    and `minute`.
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll add that amount of time to the current time to determine when the timer
    should go off. We then check the time every 0.5 seconds to make sure we don’t
    miss when the timer should go off. When the time reaches the preset time, the
    timer goes off.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: The timer is set in *timer.py* in [Listing 7-4](#listing7-4).
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Listing 7-4: The script to set a timer'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: We first print out the instructions. At 1, the script takes the user’s written
    input specifying how long to set the timer, then saves this to the variable `inp`.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: We then check whether the input included `hour` and `minute`. If `minute` is
    not in the input 2, we set the value of `addminute` to `0` and set the value of
    `addhour` to whatever number is between `timer for` and `hour`. We use similar
    methods to handle cases when `hour` is not in the written command 3 or when both
    `hour` and `minute` are in the written command 4.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: The function `now()` from the *arrow* module obtains the current time in hour,
    minute, and second values. We add the values of `addminute` and `addhour` to the
    current time to obtain the time when the timer should go off. At 5, we adjust
    for the cases when the minute value exceeds 59 or the hour value exceeds 23\.
    We then set the time the alarm should go off in the `H:m:s` format.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: We start an infinite `while` loop to check the current time every 0.5 seconds.
    When the current time reaches the alarm time, we set off the alarm. The script
    prints `Your timer has gone off!` and the script ends.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example interaction with *timer.py*, with user input in bold:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Create the mytimer Module
  id: totrans-756
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll create a `timer()` function that’s similar to the *timer.py* script,
    but we’ll use a voice command instead of a written one.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: Open the file *mytimer.py* you just downloaded from the book’s resources website
    and open it in your Spyder editor. The module will define the function `timer()`
    that your VPA will use, shown in [Listing 7-5](#listing7-5).
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Listing 7-5: The script for the local *mytimer* module'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: Set the Timer
  id: totrans-761
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you’ll test the first functionality of your VPA. Let’s zoom in to the part
    where you can activate the timer in your VPA script:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: First, we’ve imported the `timer()` function to the script. Second, the `elif`
    branch between the `if` branch and `else` branch in the inner `while` loop is
    where you can set a timer.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: If you run *vpa.py*, it will start in standby mode. You can wake it up by saying,
    “Hello Python.” Then you can set a timer by saying, “Set a timer for 1 hour 20
    minutes” or “Set a timer for 2 hours.”
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output is from one interaction with the script, with my voice
    input in bold:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: As you can see, I first activate the VPA and then set a timer for one minute.
    The VPA tells me, “Your timer will go off at 21:37:46.” After one minute, the
    timer goes off.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: Ask Your VPA to Set an Alarm Clock
  id: totrans-769
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you’ll learn how to ask your VPA to set an alarm clock. You’ll first use
    written commands to set the alarm clock. You’ll then create a *myalarm* module,
    in which you define an `alarm()` function. Finally, you’ll import `alarm()` to
    the VPA script to set the alarm clock by using voice commands.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: Build an Alarm Clock
  id: totrans-771
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Building an alarm clock is similar to setting a timer, except that we specify
    the time the alarm should go off rather than saying it should go off a certain
    time from now. You can either specify an hour value alone, such as 8 pm, or an
    hour and minute value, such as 7:25 am.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: The script will take written commands for now. The script *alarm_clock.py* is
    shown in [Listing 7-6](#listing7-6).
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Listing 7-6: The script to set an alarm clock'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the script captures our written input and saves it as the string variable
    `inp`. We then look for the positions of the four indicators: `alarm for`, `a.m.`,
    `p.m.`, and `:` 1. If you include the colon in your input, the script knows to
    check for a minute value.'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on what you pass at 2, one of four scenarios results:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: You input `a.m.` and specify hour and minute values. We extract the preset time
    value between `set alarm for` and `a.m.`, convert it to a string, and add `AM`
    at the end. For example, if you input `set an alarm for 7:34 a.m.`, the returned
    string value is `7:34 AM`.
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You input `p.m.` and specify the hour and minute value. We extract the preset
    time value, convert it to a string, and add `PM` at the end. For example, if you
    input `set an alarm for 2:55 p.m.`, the returned string value is `2:55 PM`.
  id: totrans-779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You input `a.m.` but specify only an hour value. We extract the preset time
    value, convert it to a string, and add `:00 AM` at the end. For example, if you
    input `set an alarm for 7 a.m.`, the returned string value is `7:00 AM`.
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You input `p.m.` but specify only an hour value. We extract the preset time
    value, convert it to a string, and add `:00 PM` at the end. For example, if you
    input `set an alarm for 3 p.m.`, the returned string value is `3:00 PM`.
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we’ve extracted the time when the alarm should go off, we start an infinite
    loop 3. At each iteration, we check the current time every five seconds in the
    7:25 AM format.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we check whether the time we set for the alarm clock matches the current
    time. If the times match, the alarm clock goes off, and the script prints `Your
    alarm has gone off!`.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the script and use it to set an alarm clock for yourself. Try all four
    cases: with and without the minute value, with either `a.m.` or `p.m.` at the
    end. Next, we’ll create an alarm clock module based on this script.'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: Create the Alarm Clock Module
  id: totrans-785
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll create the `alarm()` function that will use the *alarm_clock.py* code.
    This code will take voice input instead of written input and give both voice and
    text output.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: Open *myalarm.py*, which you just downloaded from the book’s resources website,
    and open it in your Spyder editor. The script will define the function `alarm()`
    that your VPA will use, shown in [Listing 7-7](#listing7-7).
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Listing 7-7: The script for the local *myalarm* module'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: Set an Alarm
  id: totrans-790
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you can ask your VPA to set an alarm clock for you. Let’s zoom in on the
    part of *vpa.py* that can set an alarm clock:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: First, we’ve imported the `alarm()` function in the local *myalarm* module to
    the script from the self-made package *mptpkg*. Second, an `elif` branch is in
    the inner `while` loop, where you can activate the alarm clock by including *alarm
    for* and either *a.m.* or *p.m.* in your voice command.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: 'Run *vpa.py*. You can set an alarm clock after waking up your VPA. The following
    output is from one interaction with the script, with my voice input in bold:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Ask Your VPA to Tell a Joke
  id: totrans-796
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to ask your VPA to tell a joke. You’ll find
    a good joke list to pull from, then create a joke module and import it to your
    main script so that your VPA can tell you jokes in a human voice.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: Create Your Joke List
  id: totrans-798
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can create a joke list from many resources. I’m using the Quick, Funny Jokes!
    website ([https://www.quickfunnyjokes.com/math.html](https://www.quickfunnyjokes.com/math.html)).
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: 'I selected 15 jokes and saved them in a file called *jokes.txt* in the chapter
    folder */mpt/ch07/* on my computer. You can use as many jokes as you like, as
    long as you also save them in a separate text file as we are doing here. Here
    are my 15 jokes:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Next, you’ll learn in detail how to create the joke-telling module.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: Create a Joke Module
  id: totrans-803
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, you’ll create a `joke()` function. When the function is called,
    it will go to the file *jokes.txt* on your computer, access its content, and break
    it into individual jokes and put them in a list. It will then randomly select
    a joke from the list and read it out loud to you.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: We’ll import the script *myjoke.py*, shown in [Listing 7-8](#listing7-8), as
    a local module in your VPA.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Listing 7-8: The script to create a *joke* module'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: First, we import the *random* module, which we’ll use to randomly select a joke
    from the list. At 1, we start the definition of `joke()`.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: We then read the content from *jokes.txt* and put the content in the string
    variable `content` 2. Note that since we put *jokes.txt* in a different directory
    from the module script *myjoke.py*, we need to specify the path of the file, and
    `../ch07/` tells Python that the file is in a parallel folder called *mptpkg*.
    This way, we can use the joke-telling functionality in other chapters as well,
    which we will do in Chapter 17\.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: We know that individual jokes are separated by double line breaks, so we use
    `split()` to separate the content of the file into individual strings and put
    them in the list `jokelist` 3. We then randomly select a joke by using `choice()`
    from the *random* module. Finally, the script prints out and speaks aloud the
    selected joke.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: Tell a Joke
  id: totrans-811
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you’ll import the joke module you just created to your VPA so that it can
    tell you jokes in a human voice. Let’s zoom in on the part of *vpa.py* that can
    tell a joke:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: We first import the `joke()` function in our newly made *myjoke* module from
    the local *mptpkg* package. In the inner `while` loop section of the VPA code
    is an `elif` branch, in which we tell the VPA that if *tell* and *joke* are in
    your voice command, the joke-telling functionality is activated.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the outcome from one interaction with the script *vpa.py*, with my input
    in bold:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Send Hands-Free Email
  id: totrans-817
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll examine the functionality of sending email 100 percent
    hands-free. You’ll first learn how to send an email by using written commands
    in Python; this will give you the skill set to create an email module that takes
    voice commands. After that, you’ll import the email module to your VPA so you
    can send email with your voice.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: Send Email with Written Commands
  id: totrans-819
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before moving on, you need to prepare a few things.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: First, you need an email account from which to send email via Python. This example
    uses my Gmail account, [ukmarkliu@gmail.com](mailto:ukmarkliu@gmail.com), which
    you should replace with your own email address.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: Gmail and many other email providers require you to apply for a separate application
    password, which is different from your regular email password. For example, the
    Google Account Help page shows how to set up your Gmail app password; see [https://support.google.com/accounts/answer/185833/](https://support.google.com/accounts/answer/185833/).
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: Sending email in Python requires a few steps. You’ll first need to connect to
    your email provider’s Simple Mail Transfer Protocol (SMTP) server. SMTP is an
    internet standard for sending email. Once the connection is established, you’ll
    need to log in using your email address and password. You’ll then provide the
    recipient’s email address, the subject line, and the email content. Finally, you’ll
    ask Python to send the actual email.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: The *smtplib* module is in the Python standard library, so no installation is
    needed. You also need at least one email as the recipient’s address. You can use
    another one of your own email addresses or ask for a friend’s.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: The script *emails.py* can take your written commands and send out email using
    Python, as shown in [Listing 7-9](#listing7-9).
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Listing 7-9: The script to send an email using Python'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: We import the *smtplib* module and create a dictionary *emails* to match names
    with email addresses. This way, when you type in a person’s name, the script will
    retrieve the corresponding email from the dictionary.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: At 1, we connect to the Gmail SMTP. If you aren’t using Gmail, you’ll need to
    search for the domain name and port number of your email provider. No change is
    needed if you are using Gmail.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: We then start the communication with your email server and the Transport Layer
    Security (TLS) encryption. The TLS encryption is needed by the script for security
    reasons. Once the connection is established, you need to log in using your email
    address and password, so make sure to replace `ukmarkliu@gmail.com` with your
    own email address. I’ve blocked out my Gmail password in the code.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: The script then requests several pieces of information in order to send the
    email 2. It first requests the name of the recipient, which you must already have
    stored in the dictionary `emails` for the script to retrieve. With the name, the
    script retrieves the email from the dictionary. It will then also ask you for
    the email subject line and email content, which you enter in the IPython console
    at the lower-right corner of your computer screen.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: 'At 3, we send out the email with `sendmail()`, which takes three inputs: your
    email address; the recipient’s email address; and the subject line and the email
    content, separated by the line break escape character \`n`.'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: Once done, the script will confirm that the email has been sent. Try this script
    yourself and make sure that you can send email using Python.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll create the module to send email using Python and then add it to
    your VPA.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: Create the Email Module
  id: totrans-835
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We first need to create the script *myemail.py* to use as a local module in
    your VPA. In the module, we define an `email()` function. Once called, it will
    connect to your email server and ask you for voice inputs—the recipient’s name,
    the subject line, and the email content—before sending out the actual email.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of *myemail.py* is similar to that of *emails.py*, with a few differences:
    the script will ask you for input using voice as well as printed messages, and
    you need to use voice input instead of written input. The differences are highlighted
    in [Listing 7-10](#listing7-10).'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Listing 7-10: The script to create a local *myemail* module'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you need to import `voice_to_text()` from your local *mptpkg*
    package to capture your voice input to dictate the recipient’s name, email subject
    line, and content. You also need `print_say()` from your local *mptpkg* package
    to print and speak messages.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: Now the module is ready to be imported to the VPA script.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: Add the Email Functionality
  id: totrans-842
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, you need to import `email()` from *myemail.py* into your VPA so that
    you can send email 100 percent hands-free. Let’s zoom in to the part of *vpa.py*
    that can send an email:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: We import the `email()` function in the local *myemail* module from the local
    *mptpkg* package. There’s an `elif` branch in which you can activate the email-sending
    feature.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example interaction with *vpa.py*, with my voice input in bold. All
    output is printed as well as spoken out loud.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: First, you should wake up your VPA. After you say, “Send an email,” the email
    feature is activated. The VPA then asks you for the recipient’s name—I gave my
    own name, and my University of Kentucky (UKY) email address was matched to it.
    It also asks for the subject line and email content. Once the information is collected,
    the email is sent, and the script exits the email functionality.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-1](#figure7-1) shows the email I received as a result in my UKY email
    account.'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: '![f07007](Images/f07007.png)'
  id: totrans-850
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-1: An email sent using a Python script 100 percent hands-free'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-852
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create a VPA that can set an alarm and timer,
    tell jokes, and even send email hands-free! You wake your VPA with “Hello Python”
    and then give it an instruction to activate one of the four functionalities. This
    chapter taught you how to create a new feature, make it into a local module, and
    use it in your main script.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn how to use the WolframAlpha API to tap into
    the vast knowledge space on the website so that your VPA will be able to answer
    (almost) any question.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: End-of-Chapter Exercises
  id: totrans-855
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write a script to print out a message and speak aloud today’s date and time,
    formatted as “Today is September 8, 2021, and the time now is 09:03:07 AM.”
  id: totrans-856
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify *mywakeup.py* so that the only way to end the script *vpa.py* is by saying,
    “Quit the script.”
  id: totrans-857
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '8'
  id: totrans-858
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Know-It-All VPA
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  id: totrans-860
  prefs: []
  type: TYPE_IMG
- en: The VPA we created in Chapter 7 can set a timer or an alarm clock for you, tell
    you jokes, or send your email. Now we’ll upgrade it so you can ask it about nearly
    anything—including daily news and weather, gas prices, and travel information—and
    tap into its nearly unlimited knowledge of science, math, history, and society.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll access the storehouse of information in the computational
    engine WolframAlpha and use Wikipedia as a backup if WolframAlpha can’t provide
    an answer. If neither site can answer, your VPA will tell you, “I am still learning,
    and I don’t know the answer to that yet.” Your VPA will be complete and capable
    of answering almost any question.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: Before you begin, set up the folder */mpt/ch08/* for this chapter. As always,
    all scripts in this chapter are available at the book’s resources page.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: Get Answers from WolframAlpha
  id: totrans-864
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*WolframAlpha* is a computational knowledge engine that provides an online
    service for factual queries, with a focus on numerical and computational capabilities,
    especially in the areas of science and technology. In this section, you’ll learn
    how to get answers from WolframAlpha through its API and then write a Python script
    to retrieve information.'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: Apply for an API Key
  id: totrans-866
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step is to apply for an API key. WolframAlpha gives you up to 2,000
    noncommercial API calls per month at no charge. Go to [https://account.wolfram.com/login/create/](https://account.wolfram.com/login/create/)
    and complete the steps to create an account, as shown in [Figure 8-1](#figure8-1).
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: '![f08001](Images/f08001.png)'
  id: totrans-868
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-1: Create your free Wolfram ID.'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: Click **Create Wolfram ID** and then log in. The Wolfram ID itself gives you
    only browser access, so you need to get an AppID to gain query access using Python.
    Apply for an API at [https://products.wolframalpha.com/api/](https://products.wolframalpha.com/api/)and
    click**Get API Access** in the bottom left, as shown in [Figure 8-2](#figure8-2).
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: '![f08002](Images/f08002.png)'
  id: totrans-871
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-2: Apply for an API at WolframAlpha.'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: A small dialog should pop up, as shown in [Figure 8-3](#figure8-3).
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: '![f08003](Images/f08003.png)'
  id: totrans-874
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-3: The Get a New AppID window at WolframAlpha'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: Fill in the Application name and Descriptioninformation, then click **Get AppID**.
    For example, you might enter `Virtual assistant` as the application name and `Learn
    to build my own virtual personal assistant in Python` in the description field.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: After that, your AppID should appear in a pop-up window. You need to click **OK**
    to activate the AppID. The key will be a long, unique string of characters to
    distinguish you from other users, something like `HG**************YQ` (I’ve blocked
    out the middle characters). Save your AppID in a safe place; you’ll need it later.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve Information
  id: totrans-878
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have your WolframAlpha API, you can use a Python script to send queries
    and obtain answers from WolframAlpha. You must first install the third-party *wolframalpha*
    module on your computer. Go to your Anaconda prompt (Windows) or a terminal (Mac
    or Linux) and activate the virtual *chatting* environment; then run the following
    at the command line:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Follow the instructions to finish the installation.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: The *wolfram.py* script in [Listing 8-1](#listing8-1) retrieves information
    from WolframAlpha by using text input.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Listing 8-1: Python code for the script *w**olfram**.**py*'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: We first import the *wolframalpha* module. Enter the API key you retrieved earlier
    as the value of the `APIkey` variable. Without it, the script won’t work.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: We then create the client with your AppID. At 1, the script asks the user for
    a query to send to WolframAlpha, which the user will enter in the IPython console
    at the lower-right panel of the Spyder IDE.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: At 2, we send the query to WolframAlpha and retrieve the `result` object, saving
    it in the variable `response`. The `result` object contains a collection of results
    in a generator object. *Generator functions* are a convenient shortcut to building
    iterators, sometimes used to avoid keeping large amounts of data in short-term
    memory (RAM). You can learn more about generators from authoritative online sources
    (for example, [https://wiki.python.org/moin/Generators](https://wiki.python.org/moin/Generators)).
    This is why we use the built-in function `next()` to iterate through different
    answer groups from WolframAlpha in the `result` object and obtain the text part
    of the answer. For a detailed description of how the querying process works with
    the *wolframalpha* module, see [https://pypi.org/project/wolframalpha/](https://pypi.org/project/wolframalpha/).
    Finally, the extracted text is printed out.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple exchange with *wolfram.py*, with my text input in bold:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-889
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: As you can see, WolframAlpha has given me a correct and succinct answer.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: Explore Different Areas of Knowledge
  id: totrans-891
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WolframAlpha can provide information on a variety of topics, so we’ll put *wolfram.py*
    through its paces with questions about weather, general knowledge, science, and
    math before adding the API to your VPA.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: Real-Time Information
  id: totrans-893
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'WolframAlpha provides real-time information, such as the current temperature
    in your area. Here’s one interaction with the script *wolfram.py*, with my written
    input in bold:'
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The script tells you the temperature in Fahrenheit and the length of time that
    has passed since the information was obtained. WolframAlpha gets your local information
    by looking at the location associated with your IP address. If you have an active
    virtual private network (VPN), your local information will be for the location
    of your VPN provider.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also obtain a weather forecast for a specific day in a certain location
    like so:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'You can check other real-time information such as local gas price or US inflation
    rate:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: General Questions
  id: totrans-901
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can ask general knowledge questions, such as how many teaspoons are in
    a cup, how to convert Fahrenheit to Celsius, the regional sales tax rate, a state
    capital, and so on:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'WolframAlpha has gathered information from various sources such as the CIA’s
    *The World Fact Book* and *The United States Geological Survey*, so it has comprehensive
    historical data. You can ask questions about events, people, or facts, such as
    when the vehicle airbag was invented:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'You can even use WolframAlpha as a dictionary by using *define*, like so:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Math Calculations
  id: totrans-908
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: WolframAlpha can answer your questions in the fields of mathematics, science,
    and technology, ranging from elementary math to calculus to differential equations.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want to convert 125 to binary, you can use *wolfram.py*
    as follows:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The `2` at the end of the output indicates that the response is in binary format.
    Wolfram Alpha can also answer your personal finance questions on topics such as
    mortgage payments, credit card calculations, and state taxes. For example, to
    calculate your monthly mortgage payment, you just need to provide three pieces
    of information—loan amount, interest rate, and loan term—and you’ll get the answer:'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Using the keyword `mortgage`, you tell the script the loan amount `$150,000`,
    the interest rate `6.5%`, and the term `30 years`. Know that the formatting of
    your query doesn’t really matter—you don’t need a comma in the number and you
    could provide the arguments in any order, and the script should understand.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: Add a Know-It-All Functionality to Your VPA
  id: totrans-915
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our goal here is to add a know-it-all functionality to the VPA you created in
    Chapter 7. We will rely mainly on WolframAlpha to answer your questions, but there
    are questions WolframAlpha can’t answer. In that case, we’ll search in Wikipedia.
    If Wikipedia can’t provide an answer either, the VPA will let you know that it
    doesn’t have an answer.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: 'To make use of the next script, be sure to install the following package with
    your virtual environment activated:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: What WolframAlpha Cannot Answer
  id: totrans-919
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though WolframAlpha has a vast knowledge base, it doesn’t know the answers
    to all questions. Wikipedia can provide more answers than Wolfram Alpha in certain
    areas, especially for general reference questions. For example, if you enter `University
    of Kentucky` as a query in *wolfram.py*, the script will raise a `StopIteration`
    exception. This is because `next()` cannot find a result in any answer group.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if you run the script *wiki.py* from Chapter 5 and enter
    `University of Kentucky` as a query, you’ll get the following output:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Wikipedia can’t answer all your questions, either. For example, if you enter
    `how many people live outside the earth` as a query in *wiki.py*, the API will
    raise a `PageError` exception that causes this version of the script to abruptly
    end with an error status.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: We’ll improve our VPA by writing a script that queries WolframAlpha first and,
    if no results are found, will query Wikipedia. If you can’t get an answer there,
    the script will print out the message `I am still learning. I don't know the answer
    to your question yet.` We’ll handle the errors raised by these external APIs by
    enclosing the calls in a `try` block and handling the exceptions in an `except`
    block.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: Go to the book’s resources page, download *know_all.py*, and save it in your
    chapter folder. This script is shown in [Listing 8-2](#listing8-2).
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Listing 8-2: Python code for the script *k**now_all**.py*'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: We first import the two modules *wolframalpha* and *wikipedia*. At 1, you should
    put your own WolframAlpha AppID in the script for it to work. We then put the
    script in an infinite `while` loop. At each iteration, it takes your text input
    as a query. If you key in the word `done`, the `while` loop stops and the script
    ends.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: The script sends the query first to WolframAlpha. We use `try` and `except`
    to handle any errors that the API from WolframAlpha might raise. If Wolfram Alpha
    doesn’t return an answer, the script directs the same query to Wikipedia. If there’s
    no answer found from Wikipedia, the script prints `I am still learning. I don't
    know the answer to your question yet.`
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you run the script *know_all.py* and enter `University of Kentucky`
    and `How many people live outside the earth?` as the two queries, you’ll get the
    following output:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: As you can see, the script never crashes, and it provides a result for the first
    query but not the second.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: Create the myknowall Module
  id: totrans-933
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we’ll create the `know_all()` function that will use the script *myknowall.py*,
    butthis time will take voice commands instead of written commands and will both
    print and speak the response instead of just printing out messages.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: Download *myknowall.py* from the book’s resources and save it in your local
    package folder */mpt/mptpkg/*. Since we’ll use this as one of the local modules
    in the local package, be sure to save it in the local package folder instead of
    the chapter folder. The script will define the function `know_all()` that your
    VPA will use, shown in an abbreviated format in [Listing 8-3](#listing8-3).
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Listing 8-3: The script for the local *myk**nowall* module'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: The content of `know_all()` is similar to the script *know_all.py* except that
    the input and output include voice.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: A VPA That Can Answer (Almost) Any Question for You
  id: totrans-939
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you’ll make your VPA capable of answering (almost) any question, using the
    *know_all.py* module.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open the script *__init__.py* in the package directory */mpt/mptpkg/*
    on your computer. Add the following line of code at the end of the file and save
    the change:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: This code imports `know_all()` from the *myknowall* module to the local package
    so you can later import it at the package level.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open *vpa.py* from the previous chapter, add the following to the script,
    and save it as *vpa.py* in this chapter’s folder. You’ll need to delete the original
    `else` branch in the inner `while` loop and replace it with the following:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: We import `know_all()` from the local *mptpkg* package and replace the original
    `else` branch. In *vpa.py* in Chapter 7, if none of the four functionalities is
    activated, the script goes to the next iteration. In the new script *vpa.py*,
    if none of the four functionalities is activated, the know-it-all functionality
    is activated, and by default the script searches for answers in WolframAlpha and
    Wikipedia.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: Note here that we’ve added a condition `if len(inp)>6` before we call `know_all()`.
    Without the condition, if you don’t say anything for a long period of time, the
    script treats the input as an empty string. As a result, you’ll keep hearing the
    answer `I am still learning. I don't know the answer to your question yet.` With
    the condition, if you don’t say anything, the script goes to the next iteration
    without doing anything because the length of an empty string is 0.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: 'Run *vpa.py* and wake it up by saying, “Hello Python.” After that, you can
    ask any question you want. Here’s the output from an example interaction with
    the script, with my voice input in bold:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: As you can see, after activating the VPA, I first asked who the US president
    was in 1981\. The answer includes two presidents, because the transition of power
    was in January 1981\. After that, I asked about the coronavirus. The VPA provided
    a detailed answer to the question.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-951
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you upgraded the VPA from Chapter 7 so you can ask it just
    about anything—including for up-to-date information about weather, gas prices,
    and travel conditions, as well as nearly unlimited facts about science, math,
    history, and society.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: You learned to apply for an API and gain access to the vast knowledge base in
    the computational engine WolframAlpha, and you can use Wikipedia as a backup when
    WolframAlpha can’t provide an answer. If neither site can answer, your VPA tells
    you as much. With that, your VPA is complete and capable of answering almost any
    question for you. Using APIs like this is an incredibly powerful skill.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: In the next couple of chapters, you’ll learn how to create your own voice-controlled
    graphical games that can speak to you.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
