- en: '13'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MATRICES AND VECTORS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This part of the book will deal with solving systems of equations. We can conveniently
    represent a set of equations using its *matrix form*, where we store the unknown
    coefficients in a matrix and the free terms in a vector.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve been working with matrices and vectors with our affine transformations,
    but for the sake of completeness, let’s define them here. A *matrix* is a two-dimensional
    array of numbers arranged in rows and columns. Matrices are subject to some mathematical
    operations, including addition, subtraction, multiplication, and a few more. A
    *vector*, in this context, is a matrix with only one row or column (typically
    one column).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following system of equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f00337-p1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can conveniently write this in matrix form as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f00337-p2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note how the coefficients of the equation are represented in the 2 (rows) by
    3 (columns) matrix. According to the matrix multiplication rules, these coefficients
    multiplied by the unknowns *x*, *y*, and *z* yield our two equations, each of
    which needs to equal its corresponding right-side term stored in the ⟨1,–3⟩ vector.
  prefs: []
  type: TYPE_NORMAL
- en: It may not be obvious now, but matrices, and by extension vectors, will greatly
    simplify working with systems of equations. To use them, however, we’ll need to
    implement new classes for both matrices and vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new Vector class will represent a uni-dimensional array of numbers (a sequence)
    of any length. This type of vector should not be confused with the geometric vector
    we implemented in [Chapter 4](ch04.xhtml#ch04), which was made up of two coordinates
    (*u* and *v*). An instance of our new Vector class with a size of 2 could look
    similar to the geometric vector, but they are distinct: the numbers don’t necessarily
    represent coordinates that define a direction. We’ll have to deal with having
    two classes named the same: Vector. As you’ll see, since they’re defined in different
    modules, it shouldn’t be any problem to disambiguate them.'
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few operations we could implement for these two new classes,
    but we’ll be pragmatic and implement only those we need in the next chapter for
    solving systems of equations. For instance, we won’t need to implement the addition,
    subtraction, or multiplication operations, even though these are common.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by implementing two simple functions to help us fill newly instantiated
    vectors and matrices with zeros. We’ll use these functions when we instantiate
    a vector or matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '**List Utils**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Internally, an instance of this new Vector class will use a list of numbers
    to store its data. When an instance of the class is instantiated, we want to fill
    its internal list with zeros. This way, values that haven’t been explicitly set
    to some other value will be zero by default. Similarly, the Matrix class will
    store its data in a list of lists. We also want every position in the matrix initialized
    to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Python file inside the *utils* package, name it *lists.py*, and
    enter the code in [Listing 13-1](ch13.xhtml#ch13lis1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-1: Lists of zeros*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve defined two functions. The first one, list_of_zeros, takes in a length
    argument and creates a list of that size filled with zeros. The second, list_of_list_of_zeros,
    creates as many lists of zeros of size cols as the parameter rows instructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The funny syntax for [0] * length can be read as follows: “Create a list made
    up of zeros with the given length.” Give it a try in the Python console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is a neat way of initializing a list that contains the same repeating value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list_of_list_of_zeros function uses a list comprehension to create a list
    of size rows where each item is another list of size cols. The index in each iteration
    isn’t used, so an underscore is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try this function in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now set up the new package where we’ll add the new Matrix and Vector classes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Setup**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s now create a new package in our project where we’ll add the Vector and
    Matrix implementations. This package will also contain the equation-solving functions
    that we’ll implement in the next chapters and generally in any math or equation
    resolution algorithm we write. Create the new package at the project’s top level
    and name it *eqs*. Add another package inside it, and name it *tests*. Your project’s
    structure should now look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Mechanics
  prefs: []
  type: TYPE_NORMAL
- en: '|- apps'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- circle_from_points'
  prefs: []
  type: TYPE_NORMAL
- en: '|- eqs'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- tests'
  prefs: []
  type: TYPE_NORMAL
- en: '|- geom2d'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- tests'
  prefs: []
  type: TYPE_NORMAL
- en: '|- graphic'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- simulation'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- svg'
  prefs: []
  type: TYPE_NORMAL
- en: '|- utils'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should just have added the *eqs* directory and its *tests* subdirectory:'
  prefs: []
  type: TYPE_NORMAL
- en: Mechanics
  prefs: []
  type: TYPE_NORMAL
- en: '| ...'
  prefs: []
  type: TYPE_NORMAL
- en: '|- eqs'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- tests'
  prefs: []
  type: TYPE_NORMAL
- en: '| ...'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vectors**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we saw in the introduction of the chapter, a vector inside the *eqs* package
    will represent a sequence of numbers stored together in a list. We won’t confuse
    it with the Vector implementation from the *geom2d* package; it’s unfortunate
    they share a name, but remember that they are two different (although arguably
    related) concepts. Vectors here are a special kind of matrix; specifically, they
    are matrices with only one row or column. For instance, we may refer to a vector
    like
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f00340-p1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: as a *column vector*, highlighting the fact that it’s a matrix with only one
    column. Similarly, we call a vector like
  prefs: []
  type: TYPE_NORMAL
- en: '[2  –1  3]'
  prefs: []
  type: TYPE_NORMAL
- en: a *row vector*, as it’s nothing more than a matrix with only one row.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll implement matrices and vectors as separate classes (instead of using the
    Matrix class to represent both) just for the sake of readability. For example,
    to get a value from a matrix we indicate both the row and column indices. For
    a vector, we require just one index, so using the Matrix class to store a vector
    could make sense but would force us to pass two indices to get or set values when,
    conceptually, just one should be enough. Thus, when reading code like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: we can quickly identify that m is a matrix and v is a vector.
  prefs: []
  type: TYPE_NORMAL
- en: '***Implementing the Vector Class***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll use a list to store the vector’s data. We won’t be giving users access
    to this private list of numbers but instead will provide methods in the class
    to work with the vector. Create a new file, *vector.py*, inside *eqs* and enter
    the code in [Listing 13-2](ch13.xhtml#ch13lis2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-2: Vector class*'
  prefs: []
  type: TYPE_NORMAL
- en: When an instance of the Vector class is initialized, we pass in a length. This
    length is kept in a private attribute called __length of the class and is exposed
    as a property using the @property decorator. This ensures the length property
    won’t be modified once the Vector class has been instantiated. Recall that properties
    are read-only attributes.
  prefs: []
  type: TYPE_NORMAL
- en: The vector’s data is stored in the __data attribute, which is initialized using
    our list_of_zeros function from before.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement methods to set values in the vector. In the class, enter the
    new code in [Listing 13-3](ch13.xhtml#ch13lis3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-3: Setting vector values*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve added three new methods. The first one, set_value, is the simplest of
    all: it sets a value at the specified index inside the vector. Note that if the
    given index is either greater than or equal to the vector’s length, or smaller
    than zero, we raise what we commonly refer to as an *out of bounds* error, namely,
    an IndexError. We don’t need to check for this condition ourselves as long as
    we’re happy with how Python handles it. Note as well that the method returns self,
    that is, the instance of the class itself. We’ll keep using this pattern where
    we return the instance when setting values in our class. This is so that we can
    chain “set” operations or do things like'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'instead of having to do this less pretty equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The second method we’ve defined is add_to_value, which adds the given amount
    to a value inside the vector. This method will be convenient when working with
    structures in [Part V](part05.xhtml#part05) of the book, as you’ll see.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have set_data, which sets all the values in the vector from a source
    data list. To do so, it first checks that the provided list has the same length
    as the vector; then it copies each of the values to the private list __data.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now implement a method to retrieve values from the vector at given indices.
    In the *vector.py* file, enter the code in [Listing 13-4](ch13.xhtml#ch13lis4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-4: Getting vector values*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re almost done with the Vector class. We could implement many more methods
    to do things such as add or subtract vectors, but we won’t need them for the purposes
    of this book. The only method we’ll need and we haven’t implemented (or overridden)
    yet is __eq__, which we can use to check whether two Vector instances are equal.
    Let’s do so now. Start by adding the following import in *vector.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Then enter the new code in [Listing 13-5](ch13.xhtml#ch13lis5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-5: Vector class equality*'
  prefs: []
  type: TYPE_NORMAL
- en: We first check whether we’re comparing the same instance against itself, in
    which case the result is True and we don’t need to compare anything else. Then,
    if the passed-in other is not an instance of the Vector class, we know the comparison
    can’t succeed, so we return False. If we find out we’re comparing two instances
    of the Vector class, we start the actual check. First we make sure the lengths
    of the vectors are the same (vectors with different sizes cannot be equal). If
    the length check succeeds, we finally check the values one by one using our are_close_enough
    function.
  prefs: []
  type: TYPE_NORMAL
- en: When we implement potentially computationally expensive __eq__ methods, it’s
    important to check the less computationally intensive conditions first. Here,
    for example, we do a fast check on the lengths of the vectors before checking
    every pair of values for equality. Whereas the pairwise value comparison needs
    to perform *n* comparisons (where *n* is the length of the vectors), the length
    comparison requires only one comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Our finished Vector class should look like the one in [Listing 13-6](ch13.xhtml#ch13lis6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-6: Vector class result*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because this class will serve as the base for the resolution of systems of
    linear equations, we can’t afford to have any bugs in its implementation: that
    would render the resolution of such systems useless. Let’s add a few tests to
    make sure the class is bug-free.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Testing the Vector Class***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At the beginning of the chapter we created a *test* directory inside the *eqs*
    package. Inside that directory, create a new file named *vector_test.py* and enter
    the code in [Listing 13-7](ch13.xhtml#ch13lis7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-7: Vector class unit tests*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code defines a new test class, VectorTest, with four unit tests. Run all
    the tests to make sure they pass and our implementation is right. You can do so
    from the bash shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first test, test_length, checks that the vector’s length property returns
    the right number. Then comes test_unset_value_is_zero, which ensures that we properly
    initialize the vector, filling it with zeros. The test_set_get _value sets the
    value 10.0 at index 1 and checks that the vector returns that same value when
    asked for the item at index 1\. We also assert that the vector returns a zero
    for the item at index 0, just to make sure that set_value doesn’t modify any value
    other than the one it’s supposed to. Last, we have test_add_to_value to test the
    add_to_value method. The test initializes the vector with values [1, 2], adds
    10 units to the item at index 0, and asserts that the value at that index is updated
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that the test_set_get_value test may actually fail for
    two different reasons: an error in the implementation of the vector’s (1) set_value
    method or (2) value_at method. That’s mostly true, and you’d be right to point
    out that we broke our first rule for good testing here (see “Three Golden Rules
    for Unit Testing” on [page 97](ch04.xhtml#ch00lev2sec57)). But it’s hard to test
    set_value without using the value_at method in the assertion. We could get the
    value by somehow accessing the vector’s private __data instead of using value_at,
    but it’s preferable to test a class through its public API and not access its
    implementation details. We want to be able to change the internal implementation
    of our classes without altering their behavior, and that shouldn’t break any test.
    If we rely on the internals of a class to test it, we couple the test to the class’s
    implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, the private implementation of a class should always be kept
    secret to the outside world; only the class itself should know about it. This
    is called *encapsulation* in object-oriented parlance.
  prefs: []
  type: TYPE_NORMAL
- en: Our Vector class is now ready and tested. Let’s implement a class to represent
    matrices.
  prefs: []
  type: TYPE_NORMAL
- en: '**Matrices**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Matrices add an extra dimension to vectors. Matrices are an array of numbers
    distributed in rows and columns.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a new file *matrix.py* inside the *eqs* directory. Enter the initial
    definition for the Matrix class, as in [Listing 13-8](ch13.xhtml#ch13lis8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-8: Matrix class*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Matrix class is initialized with the number of rows and columns. These
    values are saved as private attributes of the class: __rows_count and __cols_count.
    They are exposed as public properties: rows_count and cols _count. A matrix is
    square if it has the same number of rows and columns. We exposed this as a property
    as well: is_square. Last, we initialize the private attribute __data with a list
    of lists of zeros using the function that we created at the beginning of the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Setting Values***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s add the methods to set the matrix’s values. In the Matrix class, enter
    the two methods in [Listing 13-9](ch13.xhtml#ch13lis9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-9: Setting matrix values*'
  prefs: []
  type: TYPE_NORMAL
- en: Like we did with our Vector class, we’ve implemented one method to set a value
    in the matrix given its position (given by row and col) and one method to add
    a given amount to an existing value in the matrix. Following our convention of
    returning the instance when a value is set, both set_value and add_to_value return
    self.
  prefs: []
  type: TYPE_NORMAL
- en: It’ll also be handy to have a way to fill the matrix given a list of values,
    so after what we’ve just written, enter the method in [Listing 13-10](ch13.xhtml#ch13lis10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-10: Setting data to the matrix*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can already tell, using the values in a list to set the matrix data
    is not as straightforward as it was for vectors. There’s a check we need to perform
    to make sure the data fits inside the matrix: the given data should have the same
    length as the number of rows times the number of columns ➊, the total number of
    values the matrix holds. If it doesn’t, we raise a ValueError.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we iterate through the matrix’s row indices. In the offset variable we
    store the offset to the beginning of the current’s row data inside the input list
    ➋. For the row at index 0, the offset is 0 as well. For the row at index 1, the
    offset will be the length of a row: the number of columns in the matrix, and so
    forth. [Figure 13-1](ch13.xhtml#ch13fig1) shows this offset. We iterate through
    the column’s indices and set each of the values in __data from the input data
    ➌.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/13fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: Setting matrix data from a list*'
  prefs: []
  type: TYPE_NORMAL
- en: As we’ll see in [Part V](part05.xhtml#part05) of the book, when we’re working
    with truss structures, one of the steps for computing the structure’s system of
    equations is accounting for the external constraints on nodes. We’ll get into
    all the details later, but for now it’s enough to know that this modification
    requires that we set a row and a column of the matrix as identity vectors. For
    example, if we had the following matrix,
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f00348-p1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'setting the row and column with indices 0 and 1, respectively, as identity
    vectors would result in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f00348-p2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s write two methods to do this in our Matrix class. Enter the code in [Listing
    13-11](ch13.xhtml#ch13lis11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-11: Setting identity rows and columns*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We implemented two new methods: set_identity_row and set_identity_col. Both
    are similar in implementation: they set all values in the row or column as 0 except
    for the position in the main diagonal, which is set to 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code, we’ve used a compact condition expression: a ternary operator.
    This operator’s syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It returns one of the two expressions depending on the condition value. In this
    particular case, our condition is row == col, which is True if the row and column
    indices are equal.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if the matrix is not square, it can happen that we set a row or column
    as the identity vector and it ends up filled with all zeros. For example, see
    [Figure 13-2](ch13.xhtml#ch13fig2). We have a matrix with three rows and two columns,
    and we set the third row (the row at index 2) as the identity. Since the matrix
    has only two columns, the value 1 would be outside the matrix, in the nonexistent
    third column.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/13fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: Setting an identity row in a nonsquare matrix*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now add two methods to get values from the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '***Getting Values***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to implement value_at to get a value at the given row and column indices.
    We also want another method, value_transposed_at, which pulls a value from the
    matrix as if the matrix had been transposed. Quick reminder: the transpose of
    a matrix [*M*] is another matrix [*M*]^′ where [*M*]’s rows are swapped with its
    columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f00349-p1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We’ll use this second method in [Chapter 14](ch14.xhtml#ch14) in our implementation
    of Cholesky’s factorization algorithm to solve linear systems of equations. We
    could also implement a method in our Matrix class that returned a new matrix resulting
    from transposing the current one and then withdraw the values from this matrix.
    That would be a good option indeed, but as matrices representing systems of equations
    are often enough very big, copying all the values into a new matrix is a computationally
    expensive operation. Being able to get values from the matrix as if it were transposed
    is a performance optimization we’ll use in our Cholesky implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In *matrix.py*, enter the code in [Listing 13-12](ch13.xhtml#ch13lis12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-12: Getting matrix values*'
  prefs: []
  type: TYPE_NORMAL
- en: First we implement value_at. This method returns a value in the given row and
    column indices from the private data storage. Then we have value _transposed_at.
    As you can see, this method is similar to value_at. The only difference is that
    instead of being
  prefs: []
  type: TYPE_NORMAL
- en: self.__data[row][col]
  prefs: []
  type: TYPE_NORMAL
- en: this time the value pulled from the matrix is
  prefs: []
  type: TYPE_NORMAL
- en: self.__data[col][row]
  prefs: []
  type: TYPE_NORMAL
- en: This retrieves the value of that matrix as if it were transposed simply by swapping
    the row and col indices. This method will bring us a big performance improvement
    later.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to keep in mind when using this method is that the row index we pass
    in should be no greater than the number of columns, and the column index should
    be no greater than the number of rows. Since we’re accessing the matrix’s data
    as if it were transposed, the actual number or rows is the number of columns from
    the original matrix. The same goes for the number of columns.
  prefs: []
  type: TYPE_NORMAL
- en: '***Scaling Values***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s implement one last useful method: scaling the matrix. The same way we
    can scale a vector, we can scale a matrix by multiplying all of its values by
    a scalar. Enter the method in [Listing 13-13](ch13.xhtml#ch13lis13).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-13: Scaling a matrix*'
  prefs: []
  type: TYPE_NORMAL
- en: This method iterates through all the row and column indices and multiplies the
    value stored in every position by the passed-in factor. We return self, as this
    is a method that sets data.
  prefs: []
  type: TYPE_NORMAL
- en: '***Matrix Equality***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To finish the implementation for our Matrix class, let’s include the __eq__
    method to compare matrices for equality. Start by adding the following import
    at the top of *matrix.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Then enter the implementation for the __eq__ method in [Listing 13-14](ch13.xhtml#ch13lis14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-14: Matrix class equality*'
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we start by checking the references for self and other, because if
    we’re comparing an instance against itself, there’s no need to compare anything
    else, and the comparison can safely return True. Then, we make sure the passed-in
    object is an instance of the Matrix class; otherwise, there’s not much we can
    compare.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start comparing values from the matrices one by one, we want to make
    sure we have matrices of the same size. If we detect that either the row or column
    lengths don’t match, we return False.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if all the previous checks haven’t returned a value, we compare the
    values of both matrices. As soon as we find a pair of values that aren’t equal
    (according to our are_close_enough function), we return False. If all values are
    equal, we exit the for loops and finally return True.
  prefs: []
  type: TYPE_NORMAL
- en: For reference, your *matrix.py* file should look like [Listing 13-15](ch13.xhtml#ch13lis15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-15: Matrix class result*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Matrix class is almost ready! We need to check for bugs. We may have made
    some small mistakes when writing the code. This could be problematic once we start
    using this class to solve systems of equations. These kinds of calculations are
    usually mission-critical in engineering applications. Thus, we can’t afford a
    single bug in our implementation. But that’s no problem for us. We know how to
    tackle this: let’s add some automated unit tests.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Testing the Matrix Class***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the *tests* folder, create a new file named *matrix_test.py*. Enter the initial
    code for the test in [Listing 13-16](ch13.xhtml#ch13lis16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-16: Matrix unit tests*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this file we define a new test class called MatrixTest, which inherits from
    TestCase. We created two tests for the is_square property, one to check if a matrix
    is actually square, and another to check if a matrix is not square. Run the tests;
    ideally they both pass, but if not, go back to the implementation of the property
    and ensure you have the implementation right. You can run the tests from the shell
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now check the methods that set or get values. After the two tests we just
    wrote, enter the tests in [Listing 13-17](ch13.xhtml#ch13lis17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-17: Testing setting and getting values*'
  prefs: []
  type: TYPE_NORMAL
- en: The first test ensures that values in the matrix that haven’t been set are zero
    upon instantiation. Then we test that both the set_value and value_at methods
    actually set and get matrix values. Lastly, we test the add_to_value method, making
    sure that it adds a given amount to an already set value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this last test, we’ve used an assertion method that doesn’t exist: assert
    _matrix_has_data. We need to implement this method ourselves inside the MatrixTest
    class, and we’ll use it when we need to ensure all values inside a matrix are
    as expected. By doing this, we can use only one assertion to check that the values
    in a matrix are the same as the values in a list passed in as the second parameter.
    Inside the test class, toward the end, enter the method definition shown in [Listing
    13-18](ch13.xhtml#ch13lis18).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-18: Custom assertion for matrix values*'
  prefs: []
  type: TYPE_NORMAL
- en: This assertion method has the same structure as set_data inside the Matrix class.
    This time, instead of setting values, we use assertEqual to test for equality.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to note that, by including an assertion method that has some logic
    of its own (the offset computation in this case), we introduce one more possible
    reason for the tests to fail: the assertion method itself being wrongly implemented.
    As always, if we want to be practical, we need to make trade-offs. We can use
    our engineering common sense to analyze the pros, cons, and alternatives. In this
    case, having a custom assertion to check matrix values is worth it: it facilitates
    the simple assertion of matrix values and makes writing new tests and checking
    matrix values painless. We just have to be extra sure that our logic in the assertion
    method is correct.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now test the set_data method. The test is in [Listing 13-19](ch13.xhtml#ch13lis19).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-19: Testing setting data from a list*'
  prefs: []
  type: TYPE_NORMAL
- en: In this test we’re using our custom assertion method, which makes the test quite
    short and concise. We create a matrix with two rows and three columns, set its
    data using a list with the numbers between 1 and 6, and then assert they’ve been
    correctly placed in their respective slots.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, our next tests should be for the methods that set identity rows and
    columns. Enter the tests in [Listing 13-20](ch13.xhtml#ch13lis20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-20: Testing setting identity rows and columns*'
  prefs: []
  type: TYPE_NORMAL
- en: In these two tests we start by specifying the expected values for the resulting
    matrix. Then, we create a new 2×2 matrix and set its values to the list of numbers
    between 2 and 5\. We set the identity row or column and assert that the values
    are as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'We avoided using 1 for any of the initial values in the matrix: the methods
    we’re testing will set one of the values inside the matrix with a 1\. Imagine
    that our implementation of the set_identity_row method wrongly set a value in
    the matrix as a 1 and that it chose to set the same value that we already initialized
    as 1\. Our tests wouldn’t be able to detect such an error because there’s no way
    to tell whether that 1 is the one we set ourselves in the beginning of the test
    or a value that the set_identity_row method set. By not using 1 as an input value,
    we avoid exposing our test to such a problem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one last method we implemented in our Matrix class that needs to be
    tested: scale. Enter the test in [Listing 13-21](ch13.xhtml#ch13lis21).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 13-21: Testing scaling matrices*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This test creates a 2×3 matrix, sets its data using the numbers from 1 to 6,
    and then scales everything by 2\. Using the custom assert_matrix_has_data assertion
    we check that all values have been scaled correctly. Make sure to run the tests
    in the test class. From the shell, this would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we implemented two classes that we’ll need to work with systems
    of equations: Vector and Matrix. In the next chapter, we’ll use these two classes
    to represent systems of equations that we’ll solve using numerical methods.'
  prefs: []
  type: TYPE_NORMAL
