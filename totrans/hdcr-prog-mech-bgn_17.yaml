- en: '13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '13'
- en: MATRICES AND VECTORS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵和向量
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common01.jpg)'
- en: This part of the book will deal with solving systems of equations. We can conveniently
    represent a set of equations using its *matrix form*, where we store the unknown
    coefficients in a matrix and the free terms in a vector.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的这一部分将处理方程组的求解。我们可以方便地使用 *矩阵形式* 来表示一组方程，其中将未知系数存储在矩阵中，将自由项存储在向量中。
- en: We’ve been working with matrices and vectors with our affine transformations,
    but for the sake of completeness, let’s define them here. A *matrix* is a two-dimensional
    array of numbers arranged in rows and columns. Matrices are subject to some mathematical
    operations, including addition, subtraction, multiplication, and a few more. A
    *vector*, in this context, is a matrix with only one row or column (typically
    one column).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在与矩阵和向量进行仿射变换工作，但为了完整性起见，我们在这里定义它们。*矩阵* 是一个按行和列排列的二维数字数组。矩阵可以进行一些数学运算，包括加法、减法、乘法等。此上下文中的
    *向量* 是一个只有一行或一列（通常为一列）的矩阵。
- en: 'Consider the following system of equations:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下方程组：
- en: '![Image](../images/f00337-p1.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f00337-p1.jpg)'
- en: 'We can conveniently write this in matrix form as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以方便地将其写成矩阵形式如下：
- en: '![Image](../images/f00337-p2.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f00337-p2.jpg)'
- en: Note how the coefficients of the equation are represented in the 2 (rows) by
    3 (columns) matrix. According to the matrix multiplication rules, these coefficients
    multiplied by the unknowns *x*, *y*, and *z* yield our two equations, each of
    which needs to equal its corresponding right-side term stored in the ⟨1,–3⟩ vector.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意方程中的系数是如何表示的，它们在 2（行）乘 3（列）的矩阵中。根据矩阵乘法规则，这些系数与未知数 *x*、*y* 和 *z* 相乘，得到我们的两个方程，每个方程的结果需要等于其对应的右边项，这些右边项存储在
    ⟨1,–3⟩ 向量中。
- en: It may not be obvious now, but matrices, and by extension vectors, will greatly
    simplify working with systems of equations. To use them, however, we’ll need to
    implement new classes for both matrices and vectors.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能不太明显，但矩阵，以及由此扩展的向量，将大大简化方程组的工作。然而，要使用它们，我们需要为矩阵和向量实现新的类。
- en: 'The new Vector class will represent a uni-dimensional array of numbers (a sequence)
    of any length. This type of vector should not be confused with the geometric vector
    we implemented in [Chapter 4](ch04.xhtml#ch04), which was made up of two coordinates
    (*u* and *v*). An instance of our new Vector class with a size of 2 could look
    similar to the geometric vector, but they are distinct: the numbers don’t necessarily
    represent coordinates that define a direction. We’ll have to deal with having
    two classes named the same: Vector. As you’ll see, since they’re defined in different
    modules, it shouldn’t be any problem to disambiguate them.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 Vector 类将表示一个任意长度的单维数组（序列）中的数字。这种类型的向量不应与我们在[第 4 章](ch04.xhtml#ch04)中实现的几何向量混淆，后者由两个坐标（*u*
    和 *v*）组成。我们新的 Vector 类的一个大小为 2 的实例看起来可能与几何向量相似，但它们是不同的：这些数字不一定表示定义方向的坐标。我们将不得不处理两个同名的类：Vector。如你所见，由于它们定义在不同的模块中，消除歧义应该不会有任何问题。
- en: There are quite a few operations we could implement for these two new classes,
    but we’ll be pragmatic and implement only those we need in the next chapter for
    solving systems of equations. For instance, we won’t need to implement the addition,
    subtraction, or multiplication operations, even though these are common.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为这两个新类实现很多操作，但我们将务实，只实现下一章中求解方程组所需的操作。例如，尽管加法、减法或乘法是常见的，我们并不需要实现这些操作。
- en: Let’s begin by implementing two simple functions to help us fill newly instantiated
    vectors and matrices with zeros. We’ll use these functions when we instantiate
    a vector or matrix.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先实现两个简单的函数，帮助我们将新实例化的向量和矩阵填充为零。我们将在实例化向量或矩阵时使用这些函数。
- en: '**List Utils**'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**列表工具**'
- en: Internally, an instance of this new Vector class will use a list of numbers
    to store its data. When an instance of the class is instantiated, we want to fill
    its internal list with zeros. This way, values that haven’t been explicitly set
    to some other value will be zero by default. Similarly, the Matrix class will
    store its data in a list of lists. We also want every position in the matrix initialized
    to zero.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，这个新的 Vector 类的实例将使用一个数字列表来存储数据。当实例化该类的一个实例时，我们希望将其内部列表填充为零。这样，未明确设置为其他值的值默认将为零。类似地，Matrix
    类将其数据存储在一个列表的列表中。我们还希望矩阵中的每个位置都初始化为零。
- en: Create a new Python file inside the *utils* package, name it *lists.py*, and
    enter the code in [Listing 13-1](ch13.xhtml#ch13lis1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在*utils*包中创建一个新的Python文件，命名为*lists.py*，并在其中输入[列表13-1](ch13.xhtml#ch13lis1)中的代码。
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 13-1: Lists of zeros*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-1：零列表*'
- en: We’ve defined two functions. The first one, list_of_zeros, takes in a length
    argument and creates a list of that size filled with zeros. The second, list_of_list_of_zeros,
    creates as many lists of zeros of size cols as the parameter rows instructs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个函数。第一个函数，list_of_zeros，接受一个长度参数，并创建一个填充零的指定长度的列表。第二个函数，list_of_list_of_zeros，创建多个大小为cols的零列表，数量由参数rows指定。
- en: 'The funny syntax for [0] * length can be read as follows: “Create a list made
    up of zeros with the given length.” Give it a try in the Python console:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[0] * length这种有趣的语法可以这样理解：“创建一个由零组成的列表，长度为给定值。”可以在Python控制台中试试：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a neat way of initializing a list that contains the same repeating value.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种初始化包含相同重复值的列表的简洁方式。
- en: 'The list_of_list_of_zeros function uses a list comprehension to create a list
    of size rows where each item is another list of size cols. The index in each iteration
    isn’t used, so an underscore is used:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: list_of_list_of_zeros函数使用列表推导创建一个大小为rows的列表，其中每个项目是一个大小为cols的零列表。在每次迭代中，索引并未使用，因此使用了下划线：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s try this function in the shell:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在终端中尝试这个函数：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let’s now set up the new package where we’ll add the new Matrix and Vector classes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们设置一个新包，在其中添加新的Matrix和Vector类。
- en: '**Setup**'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**设置**'
- en: 'Let’s now create a new package in our project where we’ll add the Vector and
    Matrix implementations. This package will also contain the equation-solving functions
    that we’ll implement in the next chapters and generally in any math or equation
    resolution algorithm we write. Create the new package at the project’s top level
    and name it *eqs*. Add another package inside it, and name it *tests*. Your project’s
    structure should now look something like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在项目中创建一个新包，里面添加Vector和Matrix的实现。这个包还将包含我们将在接下来的章节中实现的方程求解函数，通常也会包含我们编写的任何数学或方程求解算法。在项目的顶层创建一个新包，并命名为*eqs*。在其内部再添加一个包，并命名为*tests*。你项目的结构应该现在看起来像这样：
- en: Mechanics
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 力学
- en: '|- apps'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '|- apps'
- en: '|    |- circle_from_points'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- circle_from_points'
- en: '|- eqs'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '|- eqs'
- en: '|    |- tests'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- tests'
- en: '|- geom2d'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '|- geom2d'
- en: '|    |- tests'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- tests'
- en: '|- graphic'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '|- graphic'
- en: '|    |- simulation'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- simulation'
- en: '|    |- svg'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- svg'
- en: '|- utils'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '|- utils'
- en: 'You should just have added the *eqs* directory and its *tests* subdirectory:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经添加了*eqs*目录及其*tests*子目录：
- en: Mechanics
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 力学
- en: '| ...'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '| ...'
- en: '|- eqs'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '|- eqs'
- en: '|    |- tests'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- tests'
- en: '| ...'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '| ...'
- en: '**Vectors**'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**向量**'
- en: As we saw in the introduction of the chapter, a vector inside the *eqs* package
    will represent a sequence of numbers stored together in a list. We won’t confuse
    it with the Vector implementation from the *geom2d* package; it’s unfortunate
    they share a name, but remember that they are two different (although arguably
    related) concepts. Vectors here are a special kind of matrix; specifically, they
    are matrices with only one row or column. For instance, we may refer to a vector
    like
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章介绍中所看到的，*eqs*包中的向量将表示一个存储在列表中的数字序列。我们不会将其与*geom2d*包中的Vector实现混淆；它们共用一个名称，虽然这是不幸的，但记住它们是两个不同的（虽然有联系的）概念。这里的向量是一种特殊类型的矩阵；具体来说，它们是只有一行或一列的矩阵。例如，我们可以称一个向量为
- en: '![Image](../images/f00340-p1.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f00340-p1.jpg)'
- en: as a *column vector*, highlighting the fact that it’s a matrix with only one
    column. Similarly, we call a vector like
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个*列向量*，突出了它是一个只有一列的矩阵。同样地，我们称这样的向量为
- en: '[2  –1  3]'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[2  –1  3]'
- en: a *row vector*, as it’s nothing more than a matrix with only one row.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*行向量*，因为它只是一个只有一行的矩阵。
- en: We’ll implement matrices and vectors as separate classes (instead of using the
    Matrix class to represent both) just for the sake of readability. For example,
    to get a value from a matrix we indicate both the row and column indices. For
    a vector, we require just one index, so using the Matrix class to store a vector
    could make sense but would force us to pass two indices to get or set values when,
    conceptually, just one should be enough. Thus, when reading code like
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将矩阵和向量实现为两个独立的类（而不是使用Matrix类来表示两者），仅仅是为了提高可读性。例如，为了从矩阵中获取一个值，我们需要指明行和列的索引。而对于向量，我们只需要一个索引，因此使用Matrix类来存储向量是有意义的，但这将迫使我们在获取或设置值时传递两个索引，而从概念上讲，只需要一个索引即可。因此，在阅读像这样的代码时
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: we can quickly identify that m is a matrix and v is a vector.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速识别出m是一个矩阵，而v是一个向量。
- en: '***Implementing the Vector Class***'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实现向量类***'
- en: We’ll use a list to store the vector’s data. We won’t be giving users access
    to this private list of numbers but instead will provide methods in the class
    to work with the vector. Create a new file, *vector.py*, inside *eqs* and enter
    the code in [Listing 13-2](ch13.xhtml#ch13lis2).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个列表来存储向量的数据。我们不会让用户访问这个私有的数字列表，而是会在类中提供方法来操作向量。在*eqs*中创建一个新文件*vector.py*，并在[清单
    13-2](ch13.xhtml#ch13lis2)中输入代码。
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 13-2: Vector class*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-2：向量类*'
- en: When an instance of the Vector class is initialized, we pass in a length. This
    length is kept in a private attribute called __length of the class and is exposed
    as a property using the @property decorator. This ensures the length property
    won’t be modified once the Vector class has been instantiated. Recall that properties
    are read-only attributes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个向量类的实例被初始化时，我们传入一个长度。这个长度保存在一个名为__length的类的私有属性中，并通过@property装饰器作为属性暴露。这确保了向量类一旦被实例化，长度属性就不会被修改。回想一下，属性是只读的属性。
- en: The vector’s data is stored in the __data attribute, which is initialized using
    our list_of_zeros function from before.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 向量的数据存储在__data属性中，它是通过之前的list_of_zeros函数初始化的。
- en: Let’s implement methods to set values in the vector. In the class, enter the
    new code in [Listing 13-3](ch13.xhtml#ch13lis3).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现设置向量中值的方法。在类中，输入[清单 13-3](ch13.xhtml#ch13lis3)中的新代码。
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 13-3: Setting vector values*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-3：设置向量值*'
- en: 'We’ve added three new methods. The first one, set_value, is the simplest of
    all: it sets a value at the specified index inside the vector. Note that if the
    given index is either greater than or equal to the vector’s length, or smaller
    than zero, we raise what we commonly refer to as an *out of bounds* error, namely,
    an IndexError. We don’t need to check for this condition ourselves as long as
    we’re happy with how Python handles it. Note as well that the method returns self,
    that is, the instance of the class itself. We’ll keep using this pattern where
    we return the instance when setting values in our class. This is so that we can
    chain “set” operations or do things like'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了三个新方法。第一个方法set_value是最简单的：它在指定的索引处设置一个值。注意，如果给定的索引大于或等于向量的长度，或者小于零，我们会引发通常称为*越界*错误的异常，即IndexError。只要我们对Python如何处理这种情况满意，就不需要自己检查这个条件。同样需要注意的是，方法返回的是self，也就是类的实例。我们将继续使用这个模式，在类中设置值时返回实例。这样我们就可以链接“设置”操作或执行类似的操作。
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'instead of having to do this less pretty equivalent:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是做这个不太漂亮的等效方法：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The second method we’ve defined is add_to_value, which adds the given amount
    to a value inside the vector. This method will be convenient when working with
    structures in [Part V](part05.xhtml#part05) of the book, as you’ll see.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的第二种方法是add_to_value，它将给定的值加到向量中的一个值上。当你在本书的[第五部分](part05.xhtml#part05)中处理结构时，这个方法会很方便，正如你将看到的那样。
- en: Lastly, we have set_data, which sets all the values in the vector from a source
    data list. To do so, it first checks that the provided list has the same length
    as the vector; then it copies each of the values to the private list __data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有set_data方法，它将源数据列表中的所有值设置到向量中。为此，它首先检查提供的列表是否与向量的长度相同；然后将每个值复制到私有列表__data中。
- en: Let’s now implement a method to retrieve values from the vector at given indices.
    In the *vector.py* file, enter the code in [Listing 13-4](ch13.xhtml#ch13lis4).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现一个方法，从向量中获取给定索引的值。在*vector.py*文件中，输入[清单 13-4](ch13.xhtml#ch13lis4)中的代码。
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 13-4: Getting vector values*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-4：获取向量值*'
- en: 'We’re almost done with the Vector class. We could implement many more methods
    to do things such as add or subtract vectors, but we won’t need them for the purposes
    of this book. The only method we’ll need and we haven’t implemented (or overridden)
    yet is __eq__, which we can use to check whether two Vector instances are equal.
    Let’s do so now. Start by adding the following import in *vector.py*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快完成向量类的实现了。我们可以实现更多方法来执行如加法或减法向量等操作，但本书的目的不需要这些。我们唯一需要的一个方法是__eq__，它可以用来检查两个向量实例是否相等。现在我们来实现它。在*vector.py*文件中添加以下导入：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then enter the new code in [Listing 13-5](ch13.xhtml#ch13lis5).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在[清单 13-5](ch13.xhtml#ch13lis5)中输入新代码。
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 13-5: Vector class equality*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-5：向量类相等性*'
- en: We first check whether we’re comparing the same instance against itself, in
    which case the result is True and we don’t need to compare anything else. Then,
    if the passed-in other is not an instance of the Vector class, we know the comparison
    can’t succeed, so we return False. If we find out we’re comparing two instances
    of the Vector class, we start the actual check. First we make sure the lengths
    of the vectors are the same (vectors with different sizes cannot be equal). If
    the length check succeeds, we finally check the values one by one using our are_close_enough
    function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查是否正在比较同一个实例与它自己，在这种情况下，结果是 True，我们无需再比较其他内容。接着，如果传入的对象不是 Vector 类的实例，我们知道比较无法成功，因此返回
    False。如果我们发现正在比较两个 Vector 类的实例，那么我们开始进行实际的检查。首先确保两个向量的长度相同（不同大小的向量无法相等）。如果长度检查成功，我们最后通过
    our are_close_enough 函数逐一检查值是否相等。
- en: When we implement potentially computationally expensive __eq__ methods, it’s
    important to check the less computationally intensive conditions first. Here,
    for example, we do a fast check on the lengths of the vectors before checking
    every pair of values for equality. Whereas the pairwise value comparison needs
    to perform *n* comparisons (where *n* is the length of the vectors), the length
    comparison requires only one comparison.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现可能计算量大的 __eq__ 方法时，重要的是先检查计算量较小的条件。例如，在这里，我们首先快速检查向量的长度，再进行每对值的相等性比较。相比需要进行
    *n* 次比较（*n* 是向量的长度）的值比较，长度比较只需要一次比较。
- en: Our finished Vector class should look like the one in [Listing 13-6](ch13.xhtml#ch13lis6).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成的 Vector 类应与[第13-6段](ch13.xhtml#ch13lis6)中的示例类似。
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 13-6: Vector class result*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*第13-6段：向量类结果*'
- en: 'Because this class will serve as the base for the resolution of systems of
    linear equations, we can’t afford to have any bugs in its implementation: that
    would render the resolution of such systems useless. Let’s add a few tests to
    make sure the class is bug-free.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个类将作为解线性方程组的基础，所以我们不能容忍其实现中有任何错误：否则，解这些方程组将变得毫无意义。让我们添加一些测试，确保这个类没有漏洞。
- en: '***Testing the Vector Class***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***测试向量类***'
- en: At the beginning of the chapter we created a *test* directory inside the *eqs*
    package. Inside that directory, create a new file named *vector_test.py* and enter
    the code in [Listing 13-7](ch13.xhtml#ch13lis7).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开始时，我们在 *eqs* 包内创建了一个 *test* 目录。在该目录内，创建一个名为 *vector_test.py* 的新文件，并输入[第13-7段](ch13.xhtml#ch13lis7)中的代码。
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 13-7: Vector class unit tests*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*第13-7段：向量类单元测试*'
- en: 'This code defines a new test class, VectorTest, with four unit tests. Run all
    the tests to make sure they pass and our implementation is right. You can do so
    from the bash shell:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个新的测试类 VectorTest，包含四个单元测试。运行所有测试，确保它们通过，并且我们的实现是正确的。你可以通过 Bash Shell
    执行这些测试：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first test, test_length, checks that the vector’s length property returns
    the right number. Then comes test_unset_value_is_zero, which ensures that we properly
    initialize the vector, filling it with zeros. The test_set_get _value sets the
    value 10.0 at index 1 and checks that the vector returns that same value when
    asked for the item at index 1\. We also assert that the vector returns a zero
    for the item at index 0, just to make sure that set_value doesn’t modify any value
    other than the one it’s supposed to. Last, we have test_add_to_value to test the
    add_to_value method. The test initializes the vector with values [1, 2], adds
    10 units to the item at index 0, and asserts that the value at that index is updated
    correctly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试 test_length 检查向量的长度属性是否返回正确的值。接下来是 test_unset_value_is_zero，它确保我们正确地初始化了向量，并将其填充为零。test_set_get_value
    在索引 1 处设置值 10.0，并检查向量在请求索引 1 处的项时是否返回相同的值。我们还断言向量在索引 0 处返回零，以确保 set_value 不会修改任何它不应该修改的值。最后，我们有
    test_add_to_value 来测试 add_to_value 方法。此测试初始化向量为 [1, 2]，将 10 单位添加到索引 0 处的项，并断言该索引的值是否正确更新。
- en: 'You may have noticed that the test_set_get_value test may actually fail for
    two different reasons: an error in the implementation of the vector’s (1) set_value
    method or (2) value_at method. That’s mostly true, and you’d be right to point
    out that we broke our first rule for good testing here (see “Three Golden Rules
    for Unit Testing” on [page 97](ch04.xhtml#ch00lev2sec57)). But it’s hard to test
    set_value without using the value_at method in the assertion. We could get the
    value by somehow accessing the vector’s private __data instead of using value_at,
    but it’s preferable to test a class through its public API and not access its
    implementation details. We want to be able to change the internal implementation
    of our classes without altering their behavior, and that shouldn’t break any test.
    If we rely on the internals of a class to test it, we couple the test to the class’s
    implementation.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，test_set_get_value 测试可能会因为两种不同的原因失败：（1）vector 的 set_value 方法实现有误，或者（2）value_at
    方法实现有误。大部分情况都是这样，你指出我们在这里破坏了良好测试的第一条规则是对的（参见 [第 97 页](ch04.xhtml#ch00lev2sec57)的“三大单元测试黄金法则”）。但没有使用
    value_at 方法的断言来测试 set_value 方法是很难的。我们本可以通过某种方式访问 vector 的私有 __data 来获取值，而不使用 value_at，但更倾向于通过类的公共
    API 来测试，而不是访问它的实现细节。我们希望能够改变类的内部实现，而不改变它的行为，并且这不应该导致任何测试失败。如果我们依赖于类的内部结构来进行测试，那就会把测试与类的实现紧密耦合。
- en: As a rule of thumb, the private implementation of a class should always be kept
    secret to the outside world; only the class itself should know about it. This
    is called *encapsulation* in object-oriented parlance.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 作为经验法则，类的私有实现应该始终对外界保密；只有类本身才应该了解它。这在面向对象术语中叫做 *封装*。
- en: Our Vector class is now ready and tested. Let’s implement a class to represent
    matrices.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Vector 类现在已经准备好并经过测试。让我们实现一个类来表示矩阵。
- en: '**Matrices**'
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**矩阵**'
- en: Matrices add an extra dimension to vectors. Matrices are an array of numbers
    distributed in rows and columns.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵为向量增加了一个额外的维度。矩阵是按行和列分布的数字数组。
- en: Let’s create a new file *matrix.py* inside the *eqs* directory. Enter the initial
    definition for the Matrix class, as in [Listing 13-8](ch13.xhtml#ch13lis8).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *eqs* 目录下创建一个新的文件 *matrix.py*。输入 Matrix 类的初始定义，如 [清单 13-8](ch13.xhtml#ch13lis8)
    所示。
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 13-8: Matrix class*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-8：Matrix 类*'
- en: 'The Matrix class is initialized with the number of rows and columns. These
    values are saved as private attributes of the class: __rows_count and __cols_count.
    They are exposed as public properties: rows_count and cols _count. A matrix is
    square if it has the same number of rows and columns. We exposed this as a property
    as well: is_square. Last, we initialize the private attribute __data with a list
    of lists of zeros using the function that we created at the beginning of the chapter.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Matrix 类通过行数和列数进行初始化。这些值作为类的私有属性保存：__rows_count 和 __cols_count。它们作为公共属性公开：rows_count
    和 cols_count。一个矩阵如果行数和列数相同，则为方阵。我们也将其作为属性公开：is_square。最后，我们使用在本章开始时创建的函数，初始化私有属性
    __data，给它一个零填充的二维列表。
- en: '***Setting Values***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设置值***'
- en: Let’s add the methods to set the matrix’s values. In the Matrix class, enter
    the two methods in [Listing 13-9](ch13.xhtml#ch13lis9).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加设置矩阵值的方法。在 Matrix 类中，输入 [清单 13-9](ch13.xhtml#ch13lis9) 中的两个方法。
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 13-9: Setting matrix values*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-9：设置矩阵的值*'
- en: Like we did with our Vector class, we’ve implemented one method to set a value
    in the matrix given its position (given by row and col) and one method to add
    a given amount to an existing value in the matrix. Following our convention of
    returning the instance when a value is set, both set_value and add_to_value return
    self.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在 Vector 类中做的那样，我们实现了一个方法，用于根据位置（由行和列给定）在矩阵中设置值，并且实现了另一个方法，用于在现有值上加上给定的数值。遵循我们设置值时返回实例的约定，set_value
    和 add_to_value 方法都返回 self。
- en: It’ll also be handy to have a way to fill the matrix given a list of values,
    so after what we’ve just written, enter the method in [Listing 13-10](ch13.xhtml#ch13lis10).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能通过一个值列表来填充矩阵，那也会非常方便。所以在我们刚刚写的代码之后，输入 [清单 13-10](ch13.xhtml#ch13lis10)
    中的方法。
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 13-10: Setting data to the matrix*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-10：设置矩阵的值*'
- en: 'As you can already tell, using the values in a list to set the matrix data
    is not as straightforward as it was for vectors. There’s a check we need to perform
    to make sure the data fits inside the matrix: the given data should have the same
    length as the number of rows times the number of columns ➊, the total number of
    values the matrix holds. If it doesn’t, we raise a ValueError.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用列表中的值来设置矩阵数据并不像设置向量那样直接。我们需要执行一个检查，以确保数据适合矩阵：给定的数据应该具有与行数乘以列数 ➊ 相同的长度，也就是矩阵包含的总值数。如果不匹配，我们将抛出一个ValueError。
- en: 'Then, we iterate through the matrix’s row indices. In the offset variable we
    store the offset to the beginning of the current’s row data inside the input list
    ➋. For the row at index 0, the offset is 0 as well. For the row at index 1, the
    offset will be the length of a row: the number of columns in the matrix, and so
    forth. [Figure 13-1](ch13.xhtml#ch13fig1) shows this offset. We iterate through
    the column’s indices and set each of the values in __data from the input data
    ➌.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历矩阵的行索引。在偏移量变量中，我们存储输入列表中当前行数据的偏移量 ➋。对于索引为0的行，偏移量也是0。对于索引为1的行，偏移量将是行的长度：即矩阵中的列数，依此类推。[图13-1](ch13.xhtml#ch13fig1)展示了这个偏移量。接下来，我们遍历列的索引，并从输入数据
    ➌ 中设置__data中的每个值。
- en: '![Image](../images/13fig01.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/13fig01.jpg)'
- en: '*Figure 13-1: Setting matrix data from a list*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-1：从列表中设置矩阵数据*'
- en: As we’ll see in [Part V](part05.xhtml#part05) of the book, when we’re working
    with truss structures, one of the steps for computing the structure’s system of
    equations is accounting for the external constraints on nodes. We’ll get into
    all the details later, but for now it’s enough to know that this modification
    requires that we set a row and a column of the matrix as identity vectors. For
    example, if we had the following matrix,
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在[第V部分](part05.xhtml#part05)中看到的，当我们处理桁架结构时，计算结构方程组的一个步骤是考虑节点上的外部约束条件。我们稍后会详细讲解，但现在知道这一修改要求我们将矩阵的行和列设置为单位向量就足够了。例如，如果我们有以下矩阵，
- en: '![Image](../images/f00348-p1.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f00348-p1.jpg)'
- en: 'setting the row and column with indices 0 and 1, respectively, as identity
    vectors would result in the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将行和列分别设置为索引0和1的单位向量，结果如下所示：
- en: '![Image](../images/f00348-p2.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f00348-p2.jpg)'
- en: Let’s write two methods to do this in our Matrix class. Enter the code in [Listing
    13-11](ch13.xhtml#ch13lis11).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Matrix类中写两个方法来完成这个操作。输入代码见[列表13-11](ch13.xhtml#ch13lis11)。
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 13-11: Setting identity rows and columns*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表13-11：设置单位行和列*'
- en: 'We implemented two new methods: set_identity_row and set_identity_col. Both
    are similar in implementation: they set all values in the row or column as 0 except
    for the position in the main diagonal, which is set to 1.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了两个新方法：`set_identity_row`和`set_identity_col`。两者的实现类似：它们将行或列中的所有值设置为0，除了主对角线上的位置，它被设置为1。
- en: 'In this code, we’ve used a compact condition expression: a ternary operator.
    This operator’s syntax is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们使用了紧凑的条件表达式：三元运算符。该运算符的语法如下：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It returns one of the two expressions depending on the condition value. In this
    particular case, our condition is row == col, which is True if the row and column
    indices are equal.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它根据条件值返回两个表达式中的一个。在这个特定的案例中，我们的条件是`row == col`，当行索引和列索引相等时，该条件为True。
- en: Note that if the matrix is not square, it can happen that we set a row or column
    as the identity vector and it ends up filled with all zeros. For example, see
    [Figure 13-2](ch13.xhtml#ch13fig2). We have a matrix with three rows and two columns,
    and we set the third row (the row at index 2) as the identity. Since the matrix
    has only two columns, the value 1 would be outside the matrix, in the nonexistent
    third column.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果矩阵不是方阵，可能会出现设置某行或某列为单位向量时，它最终会被填充为全零的情况。例如，见[图13-2](ch13.xhtml#ch13fig2)。我们有一个三行两列的矩阵，并将第三行（索引为2的行）设置为单位行。由于矩阵只有两列，值1将超出矩阵范围，位于不存在的第三列中。
- en: '![Image](../images/13fig02.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/13fig02.jpg)'
- en: '*Figure 13-2: Setting an identity row in a nonsquare matrix*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*图13-2：在非方阵中设置单位行*'
- en: Let’s now add two methods to get values from the matrix.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加两个方法来从矩阵中获取值。
- en: '***Getting Values***'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***获取值***'
- en: 'We need to implement value_at to get a value at the given row and column indices.
    We also want another method, value_transposed_at, which pulls a value from the
    matrix as if the matrix had been transposed. Quick reminder: the transpose of
    a matrix [*M*] is another matrix [*M*]^′ where [*M*]’s rows are swapped with its
    columns:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现`value_at`方法，以便在给定的行和列索引处获取一个值。我们还需要另一个方法`value_transposed_at`，它能像矩阵已转置一样从矩阵中获取一个值。提醒一下：矩阵[*M*]的转置是另一个矩阵[*M*]^′，其中[*M*]的行和列互换：
- en: '![Image](../images/f00349-p1.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f00349-p1.jpg)'
- en: We’ll use this second method in [Chapter 14](ch14.xhtml#ch14) in our implementation
    of Cholesky’s factorization algorithm to solve linear systems of equations. We
    could also implement a method in our Matrix class that returned a new matrix resulting
    from transposing the current one and then withdraw the values from this matrix.
    That would be a good option indeed, but as matrices representing systems of equations
    are often enough very big, copying all the values into a new matrix is a computationally
    expensive operation. Being able to get values from the matrix as if it were transposed
    is a performance optimization we’ll use in our Cholesky implementation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第14章](ch14.xhtml#ch14)中使用这种第二种方法来实现Cholesky分解算法，用于求解线性方程组。我们也可以在Matrix类中实现一个方法，返回一个新矩阵，该矩阵是通过转置当前矩阵得到的，然后从这个矩阵中提取值。这个方法确实是一个不错的选择，但由于表示线性方程组的矩阵通常非常大，将所有值复制到新矩阵中是一个计算开销很大的操作。能够像访问转置矩阵一样获取值，是我们在Cholesky实现中用到的性能优化。
- en: In *matrix.py*, enter the code in [Listing 13-12](ch13.xhtml#ch13lis12).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在*matrix.py*中，输入[清单13-12](ch13.xhtml#ch13lis12)中的代码。
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 13-12: Getting matrix values*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单13-12：获取矩阵值*'
- en: First we implement value_at. This method returns a value in the given row and
    column indices from the private data storage. Then we have value _transposed_at.
    As you can see, this method is similar to value_at. The only difference is that
    instead of being
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先实现`value_at`。该方法从私有数据存储中返回给定行和列索引处的值。接着是`value_transposed_at`。正如你所见，这个方法与`value_at`类似，唯一的区别是它不是直接从矩阵中获取值，而是模拟转置后的矩阵获取。
- en: self.__data[row][col]
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: self.__data[row][col]
- en: this time the value pulled from the matrix is
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这次从矩阵中提取的值是
- en: self.__data[col][row]
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: self.__data[col][row]
- en: This retrieves the value of that matrix as if it were transposed simply by swapping
    the row and col indices. This method will bring us a big performance improvement
    later.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通过交换行和列索引，可以像访问转置矩阵一样获取该矩阵的值。这个方法稍后会带来显著的性能提升。
- en: One thing to keep in mind when using this method is that the row index we pass
    in should be no greater than the number of columns, and the column index should
    be no greater than the number of rows. Since we’re accessing the matrix’s data
    as if it were transposed, the actual number or rows is the number of columns from
    the original matrix. The same goes for the number of columns.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法时需要记住的一点是，我们传入的行索引不应大于列数，列索引也不应大于行数。由于我们是以矩阵转置的方式访问数据，实际的行数是原矩阵的列数，列数也是如此。
- en: '***Scaling Values***'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***缩放值***'
- en: 'Let’s implement one last useful method: scaling the matrix. The same way we
    can scale a vector, we can scale a matrix by multiplying all of its values by
    a scalar. Enter the method in [Listing 13-13](ch13.xhtml#ch13lis13).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现最后一个有用的方法：缩放矩阵。就像我们可以缩放向量一样，我们也可以通过将矩阵的所有值乘以标量来缩放矩阵。请在[清单13-13](ch13.xhtml#ch13lis13)中输入此方法。
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 13-13: Scaling a matrix*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单13-13：缩放矩阵*'
- en: This method iterates through all the row and column indices and multiplies the
    value stored in every position by the passed-in factor. We return self, as this
    is a method that sets data.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法遍历所有的行列索引，并将每个位置存储的值乘以传入的因子。由于这是一个设置数据的方法，我们返回self。
- en: '***Matrix Equality***'
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***矩阵相等性***'
- en: 'To finish the implementation for our Matrix class, let’s include the __eq__
    method to compare matrices for equality. Start by adding the following import
    at the top of *matrix.py*:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成Matrix类的实现，让我们加入`__eq__`方法来比较矩阵是否相等。首先，在*matrix.py*的顶部添加以下导入：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then enter the implementation for the __eq__ method in [Listing 13-14](ch13.xhtml#ch13lis14).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在[清单13-14](ch13.xhtml#ch13lis14)中输入`__eq__`方法的实现。
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 13-14: Matrix class equality*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单13-14：矩阵类相等性*'
- en: As usual, we start by checking the references for self and other, because if
    we’re comparing an instance against itself, there’s no need to compare anything
    else, and the comparison can safely return True. Then, we make sure the passed-in
    object is an instance of the Matrix class; otherwise, there’s not much we can
    compare.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们首先检查`self`和`other`的引用，因为如果我们正在将一个实例与它自己进行比较，就不需要再比较其他任何东西，比较可以安全地返回
    True。然后，我们确保传入的对象是`Matrix`类的实例；否则，我们就没有太多可以比较的内容。
- en: Before we start comparing values from the matrices one by one, we want to make
    sure we have matrices of the same size. If we detect that either the row or column
    lengths don’t match, we return False.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始逐一比较矩阵值之前，我们要确保矩阵的大小相同。如果检测到行数或列数不匹配，我们返回 False。
- en: Finally, if all the previous checks haven’t returned a value, we compare the
    values of both matrices. As soon as we find a pair of values that aren’t equal
    (according to our are_close_enough function), we return False. If all values are
    equal, we exit the for loops and finally return True.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果所有前面的检查都没有返回值，我们比较两个矩阵的值。一旦找到一对不相等的值（根据我们的`are_close_enough`函数），我们返回 False。如果所有值都相等，我们退出
    for 循环，并最终返回 True。
- en: For reference, your *matrix.py* file should look like [Listing 13-15](ch13.xhtml#ch13lis15).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，你的*matrix.py*文件应该如下所示：[清单 13-15](ch13.xhtml#ch13lis15)。
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 13-15: Matrix class result*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-15：矩阵类结果*'
- en: 'Our Matrix class is almost ready! We need to check for bugs. We may have made
    some small mistakes when writing the code. This could be problematic once we start
    using this class to solve systems of equations. These kinds of calculations are
    usually mission-critical in engineering applications. Thus, we can’t afford a
    single bug in our implementation. But that’s no problem for us. We know how to
    tackle this: let’s add some automated unit tests.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的矩阵类差不多完成了！我们需要检查是否有 bug。在编写代码时，我们可能犯了一些小错误。一旦开始使用这个类来求解方程组，这些错误可能会引发问题。这类计算通常在工程应用中至关重要，因此我们不能容忍实现中的任何
    bug。不过这对我们来说没问题。我们知道该怎么做：让我们添加一些自动化单元测试。
- en: '***Testing the Matrix Class***'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***测试矩阵类***'
- en: In the *tests* folder, create a new file named *matrix_test.py*. Enter the initial
    code for the test in [Listing 13-16](ch13.xhtml#ch13lis16).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在*tests*文件夹中，创建一个新的文件，命名为*matrix_test.py*。在[清单 13-16](ch13.xhtml#ch13lis16)中输入测试的初始代码。
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 13-16: Matrix unit tests*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-16：矩阵单元测试*'
- en: 'In this file we define a new test class called MatrixTest, which inherits from
    TestCase. We created two tests for the is_square property, one to check if a matrix
    is actually square, and another to check if a matrix is not square. Run the tests;
    ideally they both pass, but if not, go back to the implementation of the property
    and ensure you have the implementation right. You can run the tests from the shell
    using the following command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们定义了一个新的测试类叫做`MatrixTest`，它继承自`TestCase`。我们为`is_square`属性创建了两个测试，一个检查矩阵是否是方阵，另一个检查矩阵是否不是方阵。运行测试，理想情况下它们都能通过，但如果没有，回到属性的实现中，确保实现正确。你可以使用以下命令从命令行运行测试：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should get output similar to the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到类似下面的输出：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let’s now check the methods that set or get values. After the two tests we just
    wrote, enter the tests in [Listing 13-17](ch13.xhtml#ch13lis17).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查设置或获取值的方法。在我们刚刚编写的两个测试之后，在[清单 13-17](ch13.xhtml#ch13lis17)中输入测试。
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 13-17: Testing setting and getting values*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13-17：测试设置和获取值*'
- en: The first test ensures that values in the matrix that haven’t been set are zero
    upon instantiation. Then we test that both the set_value and value_at methods
    actually set and get matrix values. Lastly, we test the add_to_value method, making
    sure that it adds a given amount to an already set value.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试确保在实例化时，矩阵中尚未设置的值为零。接着，我们测试`set_value`和`value_at`方法，确保它们能够正确设置和获取矩阵值。最后，我们测试`add_to_value`方法，确保它能够将给定的数值加到已经设置的值上。
- en: 'In this last test, we’ve used an assertion method that doesn’t exist: assert
    _matrix_has_data. We need to implement this method ourselves inside the MatrixTest
    class, and we’ll use it when we need to ensure all values inside a matrix are
    as expected. By doing this, we can use only one assertion to check that the values
    in a matrix are the same as the values in a list passed in as the second parameter.
    Inside the test class, toward the end, enter the method definition shown in [Listing
    13-18](ch13.xhtml#ch13lis18).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最后的测试中，我们使用了一个不存在的断言方法：assert _matrix_has_data。我们需要在MatrixTest类中自己实现这个方法，并在需要确保矩阵中所有值符合预期时使用它。通过这样做，我们可以只用一个断言来检查矩阵中的值是否与作为第二个参数传入的列表中的值相同。在测试类的最后部分，输入[Listing
    13-18](ch13.xhtml#ch13lis18)中显示的方法定义。
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 13-18: Custom assertion for matrix values*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-18: 自定义矩阵值断言*'
- en: This assertion method has the same structure as set_data inside the Matrix class.
    This time, instead of setting values, we use assertEqual to test for equality.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个断言方法与Matrix类中的set_data结构相同。这一次，我们不是设置值，而是使用assertEqual来测试是否相等。
- en: 'We have to note that, by including an assertion method that has some logic
    of its own (the offset computation in this case), we introduce one more possible
    reason for the tests to fail: the assertion method itself being wrongly implemented.
    As always, if we want to be practical, we need to make trade-offs. We can use
    our engineering common sense to analyze the pros, cons, and alternatives. In this
    case, having a custom assertion to check matrix values is worth it: it facilitates
    the simple assertion of matrix values and makes writing new tests and checking
    matrix values painless. We just have to be extra sure that our logic in the assertion
    method is correct.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须注意，加入一个具有自己逻辑（此处为偏移计算）的断言方法，给测试引入了另一个失败的可能原因：断言方法本身实现错误。和往常一样，如果我们想要务实，就必须进行权衡。我们可以运用工程常识来分析利弊和替代方案。在这种情况下，拥有一个自定义的断言来检查矩阵值是值得的：它简化了矩阵值的断言，并使编写新测试和检查矩阵值变得轻松无忧。我们只需要特别确保断言方法中的逻辑是正确的。
- en: Let’s now test the set_data method. The test is in [Listing 13-19](ch13.xhtml#ch13lis19).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试set_data方法。测试代码在[Listing 13-19](ch13.xhtml#ch13lis19)中。
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 13-19: Testing setting data from a list*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-19: 测试从列表设置数据*'
- en: In this test we’re using our custom assertion method, which makes the test quite
    short and concise. We create a matrix with two rows and three columns, set its
    data using a list with the numbers between 1 and 6, and then assert they’ve been
    correctly placed in their respective slots.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们使用了自定义的断言方法，使得测试变得非常简短和简洁。我们创建了一个有两行三列的矩阵，使用一个包含1到6之间数字的列表设置数据，然后断言这些数据是否已经正确地放置在各自的位置。
- en: Moving on, our next tests should be for the methods that set identity rows and
    columns. Enter the tests in [Listing 13-20](ch13.xhtml#ch13lis20).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的测试应该是针对设置身份行和列的方法。请输入[Listing 13-20](ch13.xhtml#ch13lis20)中的测试。
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 13-20: Testing setting identity rows and columns*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 13-20: 测试设置身份行和列*'
- en: In these two tests we start by specifying the expected values for the resulting
    matrix. Then, we create a new 2×2 matrix and set its values to the list of numbers
    between 2 and 5\. We set the identity row or column and assert that the values
    are as expected.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个测试中，我们首先指定结果矩阵的预期值。然后，我们创建一个新的2×2矩阵，并将其值设置为介于2到5之间的数字列表。接着，我们设置身份行或身份列，并断言这些值是否符合预期。
- en: 'We avoided using 1 for any of the initial values in the matrix: the methods
    we’re testing will set one of the values inside the matrix with a 1\. Imagine
    that our implementation of the set_identity_row method wrongly set a value in
    the matrix as a 1 and that it chose to set the same value that we already initialized
    as 1\. Our tests wouldn’t be able to detect such an error because there’s no way
    to tell whether that 1 is the one we set ourselves in the beginning of the test
    or a value that the set_identity_row method set. By not using 1 as an input value,
    we avoid exposing our test to such a problem.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们避免在矩阵的任何初始值中使用1：我们正在测试的方法会将矩阵中的某个值设置为1。假设我们实现的set_identity_row方法错误地将矩阵中的一个值设置为1，并且它选择将已经初始化为1的值再次设置为1。如果是这样，我们的测试将无法检测到这个错误，因为无法判断这个1是我们在测试开始时自己设置的，还是set_identity_row方法设置的。通过不使用1作为输入值，我们避免了暴露测试中的这个问题。
- en: 'There’s one last method we implemented in our Matrix class that needs to be
    tested: scale. Enter the test in [Listing 13-21](ch13.xhtml#ch13lis21).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Matrix类中实现的最后一个需要测试的方法是：scale。测试代码见[示例 13-21](ch13.xhtml#ch13lis21)。
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 13-21: Testing scaling matrices*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 13-21：测试缩放矩阵*'
- en: 'This test creates a 2×3 matrix, sets its data using the numbers from 1 to 6,
    and then scales everything by 2\. Using the custom assert_matrix_has_data assertion
    we check that all values have been scaled correctly. Make sure to run the tests
    in the test class. From the shell, this would be as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 该测试创建了一个2×3的矩阵，使用1到6的数字设置其数据，然后将所有数值都缩放为2。通过自定义的assert_matrix_has_data断言，我们检查所有的数值是否正确缩放。确保运行测试类中的测试。在shell中，运行方式如下：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You should get an output similar to the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到类似下面的输出：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Summary**'
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'In this chapter, we implemented two classes that we’ll need to work with systems
    of equations: Vector and Matrix. In the next chapter, we’ll use these two classes
    to represent systems of equations that we’ll solve using numerical methods.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们实现了两个类，它们将帮助我们处理方程组：Vector（向量）和Matrix（矩阵）。在下一章，我们将使用这两个类来表示我们将通过数值方法求解的方程组。
