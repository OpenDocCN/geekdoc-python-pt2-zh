- en: '13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MATRICES AND VECTORS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: This part of the book will deal with solving systems of equations. We can conveniently
    represent a set of equations using its *matrix form*, where we store the unknown
    coefficients in a matrix and the free terms in a vector.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: We’ve been working with matrices and vectors with our affine transformations,
    but for the sake of completeness, let’s define them here. A *matrix* is a two-dimensional
    array of numbers arranged in rows and columns. Matrices are subject to some mathematical
    operations, including addition, subtraction, multiplication, and a few more. A
    *vector*, in this context, is a matrix with only one row or column (typically
    one column).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following system of equations:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f00337-p1.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
- en: 'We can conveniently write this in matrix form as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f00337-p2.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
- en: Note how the coefficients of the equation are represented in the 2 (rows) by
    3 (columns) matrix. According to the matrix multiplication rules, these coefficients
    multiplied by the unknowns *x*, *y*, and *z* yield our two equations, each of
    which needs to equal its corresponding right-side term stored in the ⟨1,–3⟩ vector.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: It may not be obvious now, but matrices, and by extension vectors, will greatly
    simplify working with systems of equations. To use them, however, we’ll need to
    implement new classes for both matrices and vectors.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'The new Vector class will represent a uni-dimensional array of numbers (a sequence)
    of any length. This type of vector should not be confused with the geometric vector
    we implemented in [Chapter 4](ch04.xhtml#ch04), which was made up of two coordinates
    (*u* and *v*). An instance of our new Vector class with a size of 2 could look
    similar to the geometric vector, but they are distinct: the numbers don’t necessarily
    represent coordinates that define a direction. We’ll have to deal with having
    two classes named the same: Vector. As you’ll see, since they’re defined in different
    modules, it shouldn’t be any problem to disambiguate them.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few operations we could implement for these two new classes,
    but we’ll be pragmatic and implement only those we need in the next chapter for
    solving systems of equations. For instance, we won’t need to implement the addition,
    subtraction, or multiplication operations, even though these are common.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin by implementing two simple functions to help us fill newly instantiated
    vectors and matrices with zeros. We’ll use these functions when we instantiate
    a vector or matrix.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '**List Utils**'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Internally, an instance of this new Vector class will use a list of numbers
    to store its data. When an instance of the class is instantiated, we want to fill
    its internal list with zeros. This way, values that haven’t been explicitly set
    to some other value will be zero by default. Similarly, the Matrix class will
    store its data in a list of lists. We also want every position in the matrix initialized
    to zero.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Python file inside the *utils* package, name it *lists.py*, and
    enter the code in [Listing 13-1](ch13.xhtml#ch13lis1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 13-1: Lists of zeros*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: We’ve defined two functions. The first one, list_of_zeros, takes in a length
    argument and creates a list of that size filled with zeros. The second, list_of_list_of_zeros,
    creates as many lists of zeros of size cols as the parameter rows instructs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'The funny syntax for [0] * length can be read as follows: “Create a list made
    up of zeros with the given length.” Give it a try in the Python console:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a neat way of initializing a list that contains the same repeating value.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'The list_of_list_of_zeros function uses a list comprehension to create a list
    of size rows where each item is another list of size cols. The index in each iteration
    isn’t used, so an underscore is used:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s try this function in the shell:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let’s now set up the new package where we’ll add the new Matrix and Vector classes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**Setup**'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s now create a new package in our project where we’ll add the Vector and
    Matrix implementations. This package will also contain the equation-solving functions
    that we’ll implement in the next chapters and generally in any math or equation
    resolution algorithm we write. Create the new package at the project’s top level
    and name it *eqs*. Add another package inside it, and name it *tests*. Your project’s
    structure should now look something like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Mechanics
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '|- apps'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- circle_from_points'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '|- eqs'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- tests'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '|- geom2d'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- tests'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '|- graphic'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- simulation'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- svg'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '|- utils'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'You should just have added the *eqs* directory and its *tests* subdirectory:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Mechanics
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '| ...'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '|- eqs'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- tests'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '| ...'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '**Vectors**'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we saw in the introduction of the chapter, a vector inside the *eqs* package
    will represent a sequence of numbers stored together in a list. We won’t confuse
    it with the Vector implementation from the *geom2d* package; it’s unfortunate
    they share a name, but remember that they are two different (although arguably
    related) concepts. Vectors here are a special kind of matrix; specifically, they
    are matrices with only one row or column. For instance, we may refer to a vector
    like
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f00340-p1.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: as a *column vector*, highlighting the fact that it’s a matrix with only one
    column. Similarly, we call a vector like
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[2  –1  3]'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: a *row vector*, as it’s nothing more than a matrix with only one row.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: We’ll implement matrices and vectors as separate classes (instead of using the
    Matrix class to represent both) just for the sake of readability. For example,
    to get a value from a matrix we indicate both the row and column indices. For
    a vector, we require just one index, so using the Matrix class to store a vector
    could make sense but would force us to pass two indices to get or set values when,
    conceptually, just one should be enough. Thus, when reading code like
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: we can quickly identify that m is a matrix and v is a vector.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '***Implementing the Vector Class***'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll use a list to store the vector’s data. We won’t be giving users access
    to this private list of numbers but instead will provide methods in the class
    to work with the vector. Create a new file, *vector.py*, inside *eqs* and enter
    the code in [Listing 13-2](ch13.xhtml#ch13lis2).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 13-2: Vector class*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: When an instance of the Vector class is initialized, we pass in a length. This
    length is kept in a private attribute called __length of the class and is exposed
    as a property using the @property decorator. This ensures the length property
    won’t be modified once the Vector class has been instantiated. Recall that properties
    are read-only attributes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The vector’s data is stored in the __data attribute, which is initialized using
    our list_of_zeros function from before.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement methods to set values in the vector. In the class, enter the
    new code in [Listing 13-3](ch13.xhtml#ch13lis3).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 13-3: Setting vector values*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve added three new methods. The first one, set_value, is the simplest of
    all: it sets a value at the specified index inside the vector. Note that if the
    given index is either greater than or equal to the vector’s length, or smaller
    than zero, we raise what we commonly refer to as an *out of bounds* error, namely,
    an IndexError. We don’t need to check for this condition ourselves as long as
    we’re happy with how Python handles it. Note as well that the method returns self,
    that is, the instance of the class itself. We’ll keep using this pattern where
    we return the instance when setting values in our class. This is so that we can
    chain “set” operations or do things like'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'instead of having to do this less pretty equivalent:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The second method we’ve defined is add_to_value, which adds the given amount
    to a value inside the vector. This method will be convenient when working with
    structures in [Part V](part05.xhtml#part05) of the book, as you’ll see.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have set_data, which sets all the values in the vector from a source
    data list. To do so, it first checks that the provided list has the same length
    as the vector; then it copies each of the values to the private list __data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now implement a method to retrieve values from the vector at given indices.
    In the *vector.py* file, enter the code in [Listing 13-4](ch13.xhtml#ch13lis4).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 13-4: Getting vector values*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re almost done with the Vector class. We could implement many more methods
    to do things such as add or subtract vectors, but we won’t need them for the purposes
    of this book. The only method we’ll need and we haven’t implemented (or overridden)
    yet is __eq__, which we can use to check whether two Vector instances are equal.
    Let’s do so now. Start by adding the following import in *vector.py*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then enter the new code in [Listing 13-5](ch13.xhtml#ch13lis5).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 13-5: Vector class equality*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: We first check whether we’re comparing the same instance against itself, in
    which case the result is True and we don’t need to compare anything else. Then,
    if the passed-in other is not an instance of the Vector class, we know the comparison
    can’t succeed, so we return False. If we find out we’re comparing two instances
    of the Vector class, we start the actual check. First we make sure the lengths
    of the vectors are the same (vectors with different sizes cannot be equal). If
    the length check succeeds, we finally check the values one by one using our are_close_enough
    function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查是否正在比较同一个实例与它自己，在这种情况下，结果是 True，我们无需再比较其他内容。接着，如果传入的对象不是 Vector 类的实例，我们知道比较无法成功，因此返回
    False。如果我们发现正在比较两个 Vector 类的实例，那么我们开始进行实际的检查。首先确保两个向量的长度相同（不同大小的向量无法相等）。如果长度检查成功，我们最后通过
    our are_close_enough 函数逐一检查值是否相等。
- en: When we implement potentially computationally expensive __eq__ methods, it’s
    important to check the less computationally intensive conditions first. Here,
    for example, we do a fast check on the lengths of the vectors before checking
    every pair of values for equality. Whereas the pairwise value comparison needs
    to perform *n* comparisons (where *n* is the length of the vectors), the length
    comparison requires only one comparison.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现可能计算量大的 __eq__ 方法时，重要的是先检查计算量较小的条件。例如，在这里，我们首先快速检查向量的长度，再进行每对值的相等性比较。相比需要进行
    *n* 次比较（*n* 是向量的长度）的值比较，长度比较只需要一次比较。
- en: Our finished Vector class should look like the one in [Listing 13-6](ch13.xhtml#ch13lis6).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成的 Vector 类应与[第13-6段](ch13.xhtml#ch13lis6)中的示例类似。
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 13-6: Vector class result*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*第13-6段：向量类结果*'
- en: 'Because this class will serve as the base for the resolution of systems of
    linear equations, we can’t afford to have any bugs in its implementation: that
    would render the resolution of such systems useless. Let’s add a few tests to
    make sure the class is bug-free.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个类将作为解线性方程组的基础，所以我们不能容忍其实现中有任何错误：否则，解这些方程组将变得毫无意义。让我们添加一些测试，确保这个类没有漏洞。
- en: '***Testing the Vector Class***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***测试向量类***'
- en: At the beginning of the chapter we created a *test* directory inside the *eqs*
    package. Inside that directory, create a new file named *vector_test.py* and enter
    the code in [Listing 13-7](ch13.xhtml#ch13lis7).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开始时，我们在 *eqs* 包内创建了一个 *test* 目录。在该目录内，创建一个名为 *vector_test.py* 的新文件，并输入[第13-7段](ch13.xhtml#ch13lis7)中的代码。
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 13-7: Vector class unit tests*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*第13-7段：向量类单元测试*'
- en: 'This code defines a new test class, VectorTest, with four unit tests. Run all
    the tests to make sure they pass and our implementation is right. You can do so
    from the bash shell:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个新的测试类 VectorTest，包含四个单元测试。运行所有测试，确保它们通过，并且我们的实现是正确的。你可以通过 Bash Shell
    执行这些测试：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first test, test_length, checks that the vector’s length property returns
    the right number. Then comes test_unset_value_is_zero, which ensures that we properly
    initialize the vector, filling it with zeros. The test_set_get _value sets the
    value 10.0 at index 1 and checks that the vector returns that same value when
    asked for the item at index 1\. We also assert that the vector returns a zero
    for the item at index 0, just to make sure that set_value doesn’t modify any value
    other than the one it’s supposed to. Last, we have test_add_to_value to test the
    add_to_value method. The test initializes the vector with values [1, 2], adds
    10 units to the item at index 0, and asserts that the value at that index is updated
    correctly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试 test_length 检查向量的长度属性是否返回正确的值。接下来是 test_unset_value_is_zero，它确保我们正确地初始化了向量，并将其填充为零。test_set_get_value
    在索引 1 处设置值 10.0，并检查向量在请求索引 1 处的项时是否返回相同的值。我们还断言向量在索引 0 处返回零，以确保 set_value 不会修改任何它不应该修改的值。最后，我们有
    test_add_to_value 来测试 add_to_value 方法。此测试初始化向量为 [1, 2]，将 10 单位添加到索引 0 处的项，并断言该索引的值是否正确更新。
- en: 'You may have noticed that the test_set_get_value test may actually fail for
    two different reasons: an error in the implementation of the vector’s (1) set_value
    method or (2) value_at method. That’s mostly true, and you’d be right to point
    out that we broke our first rule for good testing here (see “Three Golden Rules
    for Unit Testing” on [page 97](ch04.xhtml#ch00lev2sec57)). But it’s hard to test
    set_value without using the value_at method in the assertion. We could get the
    value by somehow accessing the vector’s private __data instead of using value_at,
    but it’s preferable to test a class through its public API and not access its
    implementation details. We want to be able to change the internal implementation
    of our classes without altering their behavior, and that shouldn’t break any test.
    If we rely on the internals of a class to test it, we couple the test to the class’s
    implementation.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, the private implementation of a class should always be kept
    secret to the outside world; only the class itself should know about it. This
    is called *encapsulation* in object-oriented parlance.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Our Vector class is now ready and tested. Let’s implement a class to represent
    matrices.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '**Matrices**'
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Matrices add an extra dimension to vectors. Matrices are an array of numbers
    distributed in rows and columns.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a new file *matrix.py* inside the *eqs* directory. Enter the initial
    definition for the Matrix class, as in [Listing 13-8](ch13.xhtml#ch13lis8).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 13-8: Matrix class*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'The Matrix class is initialized with the number of rows and columns. These
    values are saved as private attributes of the class: __rows_count and __cols_count.
    They are exposed as public properties: rows_count and cols _count. A matrix is
    square if it has the same number of rows and columns. We exposed this as a property
    as well: is_square. Last, we initialize the private attribute __data with a list
    of lists of zeros using the function that we created at the beginning of the chapter.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '***Setting Values***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s add the methods to set the matrix’s values. In the Matrix class, enter
    the two methods in [Listing 13-9](ch13.xhtml#ch13lis9).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 13-9: Setting matrix values*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Like we did with our Vector class, we’ve implemented one method to set a value
    in the matrix given its position (given by row and col) and one method to add
    a given amount to an existing value in the matrix. Following our convention of
    returning the instance when a value is set, both set_value and add_to_value return
    self.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: It’ll also be handy to have a way to fill the matrix given a list of values,
    so after what we’ve just written, enter the method in [Listing 13-10](ch13.xhtml#ch13lis10).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 13-10: Setting data to the matrix*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can already tell, using the values in a list to set the matrix data
    is not as straightforward as it was for vectors. There’s a check we need to perform
    to make sure the data fits inside the matrix: the given data should have the same
    length as the number of rows times the number of columns ➊, the total number of
    values the matrix holds. If it doesn’t, we raise a ValueError.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we iterate through the matrix’s row indices. In the offset variable we
    store the offset to the beginning of the current’s row data inside the input list
    ➋. For the row at index 0, the offset is 0 as well. For the row at index 1, the
    offset will be the length of a row: the number of columns in the matrix, and so
    forth. [Figure 13-1](ch13.xhtml#ch13fig1) shows this offset. We iterate through
    the column’s indices and set each of the values in __data from the input data
    ➌.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/13fig01.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-1: Setting matrix data from a list*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: As we’ll see in [Part V](part05.xhtml#part05) of the book, when we’re working
    with truss structures, one of the steps for computing the structure’s system of
    equations is accounting for the external constraints on nodes. We’ll get into
    all the details later, but for now it’s enough to know that this modification
    requires that we set a row and a column of the matrix as identity vectors. For
    example, if we had the following matrix,
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f00348-p1.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: 'setting the row and column with indices 0 and 1, respectively, as identity
    vectors would result in the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f00348-p2.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: Let’s write two methods to do this in our Matrix class. Enter the code in [Listing
    13-11](ch13.xhtml#ch13lis11).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 13-11: Setting identity rows and columns*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'We implemented two new methods: set_identity_row and set_identity_col. Both
    are similar in implementation: they set all values in the row or column as 0 except
    for the position in the main diagonal, which is set to 1.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code, we’ve used a compact condition expression: a ternary operator.
    This operator’s syntax is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It returns one of the two expressions depending on the condition value. In this
    particular case, our condition is row == col, which is True if the row and column
    indices are equal.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Note that if the matrix is not square, it can happen that we set a row or column
    as the identity vector and it ends up filled with all zeros. For example, see
    [Figure 13-2](ch13.xhtml#ch13fig2). We have a matrix with three rows and two columns,
    and we set the third row (the row at index 2) as the identity. Since the matrix
    has only two columns, the value 1 would be outside the matrix, in the nonexistent
    third column.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/13fig02.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: '*Figure 13-2: Setting an identity row in a nonsquare matrix*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now add two methods to get values from the matrix.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '***Getting Values***'
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We need to implement value_at to get a value at the given row and column indices.
    We also want another method, value_transposed_at, which pulls a value from the
    matrix as if the matrix had been transposed. Quick reminder: the transpose of
    a matrix [*M*] is another matrix [*M*]^′ where [*M*]’s rows are swapped with its
    columns:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f00349-p1.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: We’ll use this second method in [Chapter 14](ch14.xhtml#ch14) in our implementation
    of Cholesky’s factorization algorithm to solve linear systems of equations. We
    could also implement a method in our Matrix class that returned a new matrix resulting
    from transposing the current one and then withdraw the values from this matrix.
    That would be a good option indeed, but as matrices representing systems of equations
    are often enough very big, copying all the values into a new matrix is a computationally
    expensive operation. Being able to get values from the matrix as if it were transposed
    is a performance optimization we’ll use in our Cholesky implementation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: In *matrix.py*, enter the code in [Listing 13-12](ch13.xhtml#ch13lis12).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 13-12: Getting matrix values*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: First we implement value_at. This method returns a value in the given row and
    column indices from the private data storage. Then we have value _transposed_at.
    As you can see, this method is similar to value_at. The only difference is that
    instead of being
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: self.__data[row][col]
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: this time the value pulled from the matrix is
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: self.__data[col][row]
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: This retrieves the value of that matrix as if it were transposed simply by swapping
    the row and col indices. This method will bring us a big performance improvement
    later.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: One thing to keep in mind when using this method is that the row index we pass
    in should be no greater than the number of columns, and the column index should
    be no greater than the number of rows. Since we’re accessing the matrix’s data
    as if it were transposed, the actual number or rows is the number of columns from
    the original matrix. The same goes for the number of columns.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '***Scaling Values***'
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s implement one last useful method: scaling the matrix. The same way we
    can scale a vector, we can scale a matrix by multiplying all of its values by
    a scalar. Enter the method in [Listing 13-13](ch13.xhtml#ch13lis13).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 13-13: Scaling a matrix*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: This method iterates through all the row and column indices and multiplies the
    value stored in every position by the passed-in factor. We return self, as this
    is a method that sets data.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '***Matrix Equality***'
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To finish the implementation for our Matrix class, let’s include the __eq__
    method to compare matrices for equality. Start by adding the following import
    at the top of *matrix.py*:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then enter the implementation for the __eq__ method in [Listing 13-14](ch13.xhtml#ch13lis14).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 13-14: Matrix class equality*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we start by checking the references for self and other, because if
    we’re comparing an instance against itself, there’s no need to compare anything
    else, and the comparison can safely return True. Then, we make sure the passed-in
    object is an instance of the Matrix class; otherwise, there’s not much we can
    compare.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Before we start comparing values from the matrices one by one, we want to make
    sure we have matrices of the same size. If we detect that either the row or column
    lengths don’t match, we return False.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if all the previous checks haven’t returned a value, we compare the
    values of both matrices. As soon as we find a pair of values that aren’t equal
    (according to our are_close_enough function), we return False. If all values are
    equal, we exit the for loops and finally return True.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: For reference, your *matrix.py* file should look like [Listing 13-15](ch13.xhtml#ch13lis15).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 13-15: Matrix class result*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Matrix class is almost ready! We need to check for bugs. We may have made
    some small mistakes when writing the code. This could be problematic once we start
    using this class to solve systems of equations. These kinds of calculations are
    usually mission-critical in engineering applications. Thus, we can’t afford a
    single bug in our implementation. But that’s no problem for us. We know how to
    tackle this: let’s add some automated unit tests.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '***Testing the Matrix Class***'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the *tests* folder, create a new file named *matrix_test.py*. Enter the initial
    code for the test in [Listing 13-16](ch13.xhtml#ch13lis16).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 13-16: Matrix unit tests*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'In this file we define a new test class called MatrixTest, which inherits from
    TestCase. We created two tests for the is_square property, one to check if a matrix
    is actually square, and another to check if a matrix is not square. Run the tests;
    ideally they both pass, but if not, go back to the implementation of the property
    and ensure you have the implementation right. You can run the tests from the shell
    using the following command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should get output similar to the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let’s now check the methods that set or get values. After the two tests we just
    wrote, enter the tests in [Listing 13-17](ch13.xhtml#ch13lis17).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 13-17: Testing setting and getting values*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The first test ensures that values in the matrix that haven’t been set are zero
    upon instantiation. Then we test that both the set_value and value_at methods
    actually set and get matrix values. Lastly, we test the add_to_value method, making
    sure that it adds a given amount to an already set value.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'In this last test, we’ve used an assertion method that doesn’t exist: assert
    _matrix_has_data. We need to implement this method ourselves inside the MatrixTest
    class, and we’ll use it when we need to ensure all values inside a matrix are
    as expected. By doing this, we can use only one assertion to check that the values
    in a matrix are the same as the values in a list passed in as the second parameter.
    Inside the test class, toward the end, enter the method definition shown in [Listing
    13-18](ch13.xhtml#ch13lis18).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 13-18: Custom assertion for matrix values*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: This assertion method has the same structure as set_data inside the Matrix class.
    This time, instead of setting values, we use assertEqual to test for equality.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to note that, by including an assertion method that has some logic
    of its own (the offset computation in this case), we introduce one more possible
    reason for the tests to fail: the assertion method itself being wrongly implemented.
    As always, if we want to be practical, we need to make trade-offs. We can use
    our engineering common sense to analyze the pros, cons, and alternatives. In this
    case, having a custom assertion to check matrix values is worth it: it facilitates
    the simple assertion of matrix values and makes writing new tests and checking
    matrix values painless. We just have to be extra sure that our logic in the assertion
    method is correct.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now test the set_data method. The test is in [Listing 13-19](ch13.xhtml#ch13lis19).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 13-19: Testing setting data from a list*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: In this test we’re using our custom assertion method, which makes the test quite
    short and concise. We create a matrix with two rows and three columns, set its
    data using a list with the numbers between 1 and 6, and then assert they’ve been
    correctly placed in their respective slots.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, our next tests should be for the methods that set identity rows and
    columns. Enter the tests in [Listing 13-20](ch13.xhtml#ch13lis20).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 13-20: Testing setting identity rows and columns*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: In these two tests we start by specifying the expected values for the resulting
    matrix. Then, we create a new 2×2 matrix and set its values to the list of numbers
    between 2 and 5\. We set the identity row or column and assert that the values
    are as expected.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'We avoided using 1 for any of the initial values in the matrix: the methods
    we’re testing will set one of the values inside the matrix with a 1\. Imagine
    that our implementation of the set_identity_row method wrongly set a value in
    the matrix as a 1 and that it chose to set the same value that we already initialized
    as 1\. Our tests wouldn’t be able to detect such an error because there’s no way
    to tell whether that 1 is the one we set ourselves in the beginning of the test
    or a value that the set_identity_row method set. By not using 1 as an input value,
    we avoid exposing our test to such a problem.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one last method we implemented in our Matrix class that needs to be
    tested: scale. Enter the test in [Listing 13-21](ch13.xhtml#ch13lis21).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 13-21: Testing scaling matrices*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'This test creates a 2×3 matrix, sets its data using the numbers from 1 to 6,
    and then scales everything by 2\. Using the custom assert_matrix_has_data assertion
    we check that all values have been scaled correctly. Make sure to run the tests
    in the test class. From the shell, this would be as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You should get an output similar to the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Summary**'
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we implemented two classes that we’ll need to work with systems
    of equations: Vector and Matrix. In the next chapter, we’ll use these two classes
    to represent systems of equations that we’ll solve using numerical methods.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
