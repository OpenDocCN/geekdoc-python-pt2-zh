- en: '**1**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**1**'
- en: '**STARTING YOUR PROJECT**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**启动你的项目**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: In this first chapter, we’ll look at a few aspects of starting a project and
    what you should think about before you begin, such as which Python version to
    use, how to structure your modules, how to effectively number software versions,
    and how to ensure best coding practices with automatic error checking.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨启动项目的几个方面，以及在开始之前应该考虑的一些事项，比如使用哪个 Python 版本、如何构建模块结构、如何有效地标记软件版本、以及如何通过自动错误检查确保最佳的编码实践。
- en: '**Versions of Python**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Python 版本**'
- en: Before beginning a project, you’ll need to decide what version(s) of Python
    it will support. This is not as simple a decision as it may seem.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始一个项目之前，你需要决定该项目将支持哪个版本的 Python。这并不是一个看起来那么简单的决定。
- en: It’s no secret that Python supports several versions at the same time. Each
    minor version of the interpreter gets bug-fix support for 18 months and security
    support for 5 years. For example, Python 3.7, released on June 27, 2018, will
    be supported until Python 3.8 is released, which should be around October 2019\.
    Around December 2019, a last bug-fix release of Python 3.7 will occur, and everyone
    will be expected to switch to Python 3.8\. Each new version of Python introduces
    new features and deprecates old ones. [Figure 1-1](ch01.xhtml#ch1fig1) illustrates
    this timeline.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Python 支持多个版本这一点早已不是什么秘密。每个小版本的解释器都会获得 18 个月的 bug 修复支持和 5 年的安全支持。例如，Python 3.7
    于 2018 年 6 月 27 日发布，将支持到 Python 3.8 发布为止，预计大约在 2019 年 10 月左右。2019 年 12 月左右，Python
    3.7 会发布最后一个 bug 修复版本，届时所有人都应切换到 Python 3.8。每个新的 Python 版本都会引入新特性并弃用旧特性。[图 1-1](ch01.xhtml#ch1fig1)
    展示了这一时间线。
- en: '![image](../images/f01-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f01-01.jpg)'
- en: '*Figure 1-1: Python release timeline*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-1：Python 发布时间线*'
- en: On top of that, we should take into consideration the Python 2 versus Python
    3 problem. People working with (very) old platforms may still require Python 2
    support because Python 3 has not been made available on those platforms, but the
    rule of thumb is to forget Python 2 if you can.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还应该考虑 Python 2 与 Python 3 的问题。使用（非常）老旧平台的人们可能仍然需要 Python 2 的支持，因为这些平台尚未提供
    Python 3，但一般的经验法则是，如果可以的话，忘记 Python 2。
- en: 'Here is a quick way to figure out which version you need:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快速的方法来确定你需要支持哪个版本：
- en: Versions 2.6 and older are now obsolete, so I do not recommend you worry about
    supporting them at all. If you do intend to support these older versions for whatever
    reason, be warned that you’ll have a hard time ensuring that your program supports
    Python 3.x as well. Having said that, you might still run into Python 2.6 on some
    older systems—if that’s the case, sorry!
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 2.6 及更早版本现在已经过时，因此我不建议你去担心支持这些版本。如果你确实因为某些原因需要支持这些旧版本，请注意你将很难确保你的程序也支持 Python
    3.x。话虽如此，你可能仍然会在一些旧系统上遇到 Python 2.6——如果是这种情况，抱歉！
- en: Version 2.7 is and will remain the last version of Python 2.x. Every system
    is basically running or able to run Python 3 one way or the other nowadays, so
    unless you’re doing archeology, you shouldn’t need to worry about supporting Python
    2.7 in new programs. Python 2.7 will cease to be supported after the year 2020,
    so the last thing you want to do is build a new software based on it.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 2.7 是 Python 2.x 的最后一个版本，并将保持为最后的版本。如今每个系统基本上都能运行或能够运行 Python 3，因此除非你在做考古学工作，否则不必担心在新程序中支持
    Python 2.7。Python 2.7 将在 2020 年后停止支持，所以你最不想做的事就是基于它来构建新的软件。
- en: Version 3.7 is the most recent version of the Python 3 branch as of this writing,
    and that’s the one that you should target. However, if your operating system ships
    version 3.6 (most operating systems, except Windows, ship with 3.6 or later),
    make sure your application will also work with 3.6.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，Python 3.7 是 Python 3 分支中最新的版本，也是你应该使用的版本。然而，如果你的操作系统提供的是 3.6（除了 Windows，其他大多数操作系统都提供
    3.6 或更高版本），确保你的应用程序也能在 3.6 上正常运行。
- en: Techniques for writing programs that support both Python 2.7 and 3.x will be
    discussed in [Chapter 13](ch13.xhtml#ch13).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 Python 2.7 和 3.x 的编程技巧将在[第 13 章](ch13.xhtml#ch13)中讨论。
- en: Finally, note that this book has been written with Python 3 in mind.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注意这本书是基于 Python 3 编写的。
- en: '**Laying Out Your Project**'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**规划你的项目**'
- en: Starting a new project is always a bit of a puzzle. You can’t be sure how your
    project will be structured, so you might not know how to organize your files.
    However, once you have a proper understanding of best practices, you’ll understand
    which basic structure to start with. Here I’ll give some tips on dos and don’ts
    for laying out your project.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个新项目总是有点复杂。你无法确定项目将如何结构化，因此可能不知道如何组织文件。然而，一旦你对最佳实践有了正确的理解，你就会知道应该从哪种基本结构开始。这里我将提供一些关于项目布局的注意事项。
- en: '***What to Do***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***应该做的***'
- en: 'First, consider your project structure, which should be fairly simple. Use
    packages and hierarchy wisely: a deep hierarchy can be a nightmare to navigate,
    while a flat hierarchy tends to become bloated.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑你的项目结构，应该相对简单。明智地使用包和层次结构：深层次的层级可能会让导航变得非常困难，而扁平化的层次结构往往会变得臃肿。
- en: Then, avoid making the common mistake of storing unit tests outside the package
    directory. These tests should definitely be included in a subpackage of your software
    so that they aren’t automatically installed as a *tests* top-level module by setuptools
    (or some other packaging library) by accident. By placing them in a subpackage,
    you ensure they can be installed and eventually used by other packages so users
    can build their own unit tests.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，避免将单元测试存储在包目录外的常见错误。这些测试应当包含在你的软件的子包中，这样就不会被 setuptools（或其他打包库）误操作成 *tests*
    顶级模块。将它们放在子包中，可以确保它们可以被安装，并最终被其他包使用，从而允许用户编写自己的单元测试。
- en: '[Figure 1-2](ch01.xhtml#ch1fig2) illustrates what a standard file hierarchy
    should look like.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-2](ch01.xhtml#ch1fig2) 展示了标准文件层级应该是什么样的。'
- en: '![image](../images/f01-02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f01-02.jpg)'
- en: '*Figure 1-2: Standard package directory*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-2：标准包目录*'
- en: The standard name for a Python installation script is *setup.py*. It comes with
    its companion *setup.cfg*, which should contain the installation script configuration
    details. When run, *setup.py* will install your package using the Python distribution
    utilities.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Python 安装脚本的标准名称是 *setup.py*。它配有 *setup.cfg* 文件，该文件应包含安装脚本的配置详情。当运行 *setup.py*
    时，它将使用 Python 分发工具安装你的包。
- en: You can also provide important information to users in *README.rst* (or *README.txt*,
    or whatever filename suits your fancy). Finally, the *docs* directory should contain
    the package’s documentation in *reStructuredText* format, which will be consumed
    by Sphinx (see [Chapter 3](ch03.xhtml#ch03)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过 *README.rst*（或 *README.txt*，或任何你喜欢的文件名）向用户提供重要信息。最后，*docs* 目录应包含以 *reStructuredText*
    格式编写的包文档，Sphinx 将使用它（参见 [第3章](ch03.xhtml#ch03)）。
- en: Packages will often have to provide extra data for the software to use, such
    as images, shell scripts, and so forth. Unfortunately, there’s no universally
    accepted standard for where these files should be stored, so you should just put
    them wherever makes the most sense for your project depending on their functions.
    For example, web application templates could go in a *templates* directory in
    your package root directory.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 包通常需要提供额外的数据供软件使用，例如图像、shell 脚本等。不幸的是，对于这些文件应该存放在哪里，并没有一个被普遍接受的标准，因此你应根据它们的功能将它们放在对你的项目最有意义的位置。例如，Web
    应用程序的模板可以放在包根目录下的 *templates* 目录中。
- en: 'The following top-level directories also frequently appear:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下顶级目录也经常出现：
- en: '*etc* for sample configuration files'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*etc* 用于示例配置文件'
- en: '*tools* for shell scripts or related tools'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 shell 脚本或相关工具的 *tools*
- en: '*bin* for binary scripts you’ve written that will be installed by *setup.py*'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*bin* 用于你编写的二进制脚本，这些脚本将通过 *setup.py* 安装'
- en: '***What Not to Do***'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***什么是禁止做的***'
- en: 'There is a particular design issue that I often encounter in project structures
    that have not been fully thought out: some developers will create files or modules
    based on the type of code they will store. For example, they might create *functions.py*
    or *exceptions.py* files. This is a *terrible* approach and doesn’t help any developer
    when navigating the code. When reading a codebase, the developer expects a functional
    area of a program to be confined in a particular file. The code organization doesn’t
    benefit from this approach, which forces readers to jump between files for no
    good reason.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目结构中，我经常遇到一个特定的设计问题，尤其是在没有完全考虑清楚的情况下：一些开发者会根据存储代码的类型来创建文件或模块。例如，他们可能会创建 *functions.py*
    或 *exceptions.py* 文件。这是一种*糟糕的*做法，并且在开发者浏览代码时没有任何帮助。在阅读代码库时，开发者期望程序的功能区域被限定在特定的文件中。这种代码组织方式并没有带来好处，反而迫使读者在文件间跳来跳去，毫无意义。
- en: Organize your code based on *features*, not on types.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 *功能* 而不是类型来组织你的代码。
- en: It is also a bad idea to create a module directory that contains only an *__init__.py*
    file, because it’s unnecessary nesting. For example, you shouldn’t create a directory
    named *hooks* with a single file named *hooks/__init__.py* in it, where *hooks.py*
    would have been enough. If you create a directory, it should contain several other
    Python files that belong to the category the directory represents. Building a
    deep hierarchy unnecessarily is confusing.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个仅包含 *__init__.py* 文件的模块目录也是一个不好的主意，因为这是不必要的嵌套。例如，你不应该创建一个名为 *hooks* 的目录，里面只有一个名为
    *hooks/__init__.py* 的文件，而应该使用 *hooks.py*。如果你创建一个目录，它应该包含多个属于该目录代表的类别的其他 Python
    文件。不必要地构建深层次的层级结构会让人困惑。
- en: 'You should also be very careful about the code that you put in the *__init__.py*
    file. This file will be called and executed the first time that a module contained
    in the directory is loaded. Placing the wrong things in your *__init__.py* can
    have unwanted side effects. In fact, *__init__.py* files should be empty most
    of the time, unless you know what you’re doing. Don’t try to remove *__init__.py*
    files altogether though, or you won’t be able to import your Python module at
    all: Python requires an *__init__.py* file to be present for the directory to
    be considered a submodule.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该非常小心你放入 *__init__.py* 文件中的代码。这个文件会在第一次加载目录中包含的模块时被调用和执行。将错误的内容放入 *__init__.py*
    可能会产生不良的副作用。实际上，除非你知道自己在做什么，否则 *__init__.py* 文件应该大多数时候是空的。不过，不要尝试完全删除 *__init__.py*
    文件，否则你将无法导入你的 Python 模块：Python 要求目录中存在一个 *__init__.py* 文件，才会将该目录视为子模块。
- en: '**Version Numbering**'
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**版本号**'
- en: Software versions need to be stamped so users know which is the more recent
    version. For every project, users must be able to organize the timeline of the
    evolving code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 软件版本需要进行标记，以便用户知道哪个版本是最新的。对于每个项目，用户必须能够组织代码演变的时间线。
- en: There is an infinite number of ways to organize your version numbers. However,
    PEP 440 introduces a version format that every Python package, and ideally every
    application, should follow so that other programs and packages can easily and
    reliably identify which versions of your package they require.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有无数种方式来组织你的版本号。然而，PEP 440 引入了一种版本格式，所有 Python 包，理想情况下每个应用程序，都应该遵循这种格式，以便其他程序和包能够轻松、可靠地识别它们需要的包版本。
- en: 'PEP 440 defines the following regular expression format for version numbering:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 440 定义了以下的版本号格式的正则表达式：
- en: N[.N]+[{a|b|c|rc}N][.postN][.devN]
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: N[.N]+[{a|b|c|rc}N][.postN][.devN]
- en: 'This allows for standard numbering such as 1.2 or 1.2.3. There are a few further
    details to note:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许使用标准的版本编号，如 1.2 或 1.2.3。还有一些细节需要注意：
- en: Version 1.2 is equivalent to 1.2.0, 1.3.4 is equivalent to 1.3.4.0, and so forth.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 1.2 等同于 1.2.0，版本 1.3.4 等同于 1.3.4.0，以此类推。
- en: Versions matching N[.N]+ are considered *final* releases.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配 N[.N]+ 的版本被认为是 *正式* 版本。
- en: Date-based versions such as 2013.06.22 are considered invalid. Automated tools
    designed to detect PEP 440–format version numbers will (or should) raise an error
    if they detect a version number greater than or equal to 1980.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于日期的版本号，例如 2013.06.22，被认为是无效的。设计用来检测 PEP 440 格式版本号的自动化工具，如果检测到版本号大于或等于 1980，将会（或应该）抛出错误。
- en: 'Final components can also use the following format:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终组件也可以使用以下格式：
- en: N[.N]+aN (for example, 1.2a1) denotes an alpha release; this is a version that
    might be unstable and missing features.
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: N[.N]+aN（例如，1.2a1）表示 alpha 版本；这是一个可能不稳定且缺少功能的版本。
- en: N[.N]+bN (for example, 2.3.1b2) denotes a beta release, a version that might
    be feature complete but still buggy.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: N[.N]+bN（例如，2.3.1b2）表示 beta 版本，即可能已经完成功能但仍有 bug 的版本。
- en: N[.N]+cN or N[.N]+rcN (for example, 0.4rc1) denotes a (release) candidate. This
    is a version that might be released as the final product unless significant bugs
    emerge. The rc and c suffixes have the same meaning, but if both are used, rc
    releases are considered newer than c releases.
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: N[.N]+cN 或 N[.N]+rcN（例如，0.4rc1）表示（发布）候选版本。它是一个可能会作为最终产品发布的版本，除非出现重大 bug。rc 和
    c 后缀具有相同含义，但如果两者都使用，rc 发布版本被认为比 c 发布版本更新。
- en: 'The following suffixes can also be used:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还可以使用以下后缀：
- en: The suffix *.postN* (for example, 1.4.post2) indicates a post release. Post
    releases are typically used to address minor errors in the publication process,
    such as mistakes in release notes. You shouldn’t use the *.postN* suffix when
    releasing a bug-fix version; instead, increment the minor version number.
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后缀 *.postN*（例如，1.4.post2）表示发布后的版本。发布后版本通常用于解决发布过程中出现的小错误，比如发布说明中的错误。当发布一个修复
    bug 的版本时，不应该使用 *.postN* 后缀；而是应该增加次版本号。
- en: 'The suffix*.devN* (for example, 2.3.4.dev3) indicates a developmental release.
    It indicates a prerelease of the version that it qualifies: for example, *2.3.4.dev3*
    indicates the third developmental version of the *2.3.4* release, prior to any
    alpha, beta, candidate, or final release. This suffix is discouraged because it
    is harder for humans to parse.'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后缀*.devN*（例如，2.3.4.dev3）表示开发版本。它表示该版本的预发布版：例如，*2.3.4.dev3* 表示 *2.3.4* 发布的第三个开发版本，在任何
    alpha、beta、候选版本或最终版本之前。这个后缀不推荐使用，因为它对于人类解析比较困难。
- en: This scheme should be sufficient for most common use cases.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方案对于大多数常见的用例应该足够了。
- en: '**NOTE**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You might have heard of Semantic Versioning, which provides its own guidelines
    for version numbering. This specification partially overlaps with PEP 440, but
    unfortunately, they’re not entirely compatible. For example, Semantic Versioning’s
    recommendation for prerelease versioning uses a scheme such as 1.0.0-alpha+001
    that is not compliant with PEP 440.*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能听说过语义版本控制，它为版本号命名提供了自己的指导原则。这个规范与 PEP 440 部分重叠，但不完全兼容。例如，语义版本控制推荐的预发布版本使用类似
    1.0.0-alpha+001 的方案，而这与 PEP 440 不兼容。*'
- en: 'Many *distributed version control system (DVCS)* platforms, such as Git and
    Mercurial, are able to generate version numbers using an identifying hash (for
    Git, refer to git describe). Unfortunately, this system isn’t compatible with
    the scheme defined by PEP 440: for one thing, identifying hashes aren’t orderable.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 许多*分布式版本控制系统（DVCS）*平台，如 Git 和 Mercurial，能够通过标识哈希生成版本号（对于 Git，请参考 git describe）。不幸的是，这个系统与
    PEP 440 定义的方案不兼容：其中一个原因是标识哈希无法排序。
- en: '**Coding Style and Automated Checks**'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编码风格和自动化检查**'
- en: 'Coding style is a touchy subject, but one we should talk about before we dive
    further into Python. Unlike many programming languages, Python uses *indentation*
    to define blocks. While this offers a simple solution to the age-old question
    “Where should I put my braces?” it introduces a new question: “How should I indent?”'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 编码风格是一个敏感的话题，但我们应该在深入讨论 Python 之前先谈论一下。与许多编程语言不同，Python 使用*缩进*来定义代码块。虽然这为解决“我应该在哪里放置大括号？”这一历史性问题提供了简单的解决方案，但也带来了一个新问题：“我应该如何缩进？”
- en: 'That was one of the first questions raised in the community, so the Python
    folks, in their vast wisdom, came up with the *PEP 8: Style Guide for Python Code*
    (*[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)*).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '这是社区最早提出的问题之一，因此 Python 开发者们凭借其深厚的智慧，提出了*PEP 8: Python 代码风格指南*（*[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)*）。'
- en: 'This document defines the standard style for writing Python code. The list
    of guidelines boils down to:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档定义了编写 Python 代码的标准风格。指导原则的清单归结为：
- en: Use four spaces per indentation level.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个缩进级别使用四个空格。
- en: Limit all lines to a maximum of 79 characters.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制所有行的最大字符数为 79。
- en: Separate top-level function and class definitions with two blank lines.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用两个空行分隔顶级函数和类定义。
- en: Encode files using ASCII or UTF-8.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ASCII 或 UTF-8 编码文件。
- en: Use one module import per import statement and per line. Place import statements
    at the top of the file, after comments and docstrings, grouped first by standard,
    then by third party, and finally by local library imports.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个导入语句和每行只能导入一个模块。将导入语句放在文件的顶部，位于注释和文档字符串之后，按照顺序首先导入标准库，然后是第三方库，最后是本地库。
- en: Do not use extraneous whitespaces between parentheses, square brackets, or braces
    or before commas.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在圆括号、方括号或大括号之间，以及逗号之前，不要使用多余的空格。
- en: Write class names in camel case (e.g., CamelCase), suffix exceptions with Error
    (if applicable), and name functions in lowercase with words and underscores (e.g.,
    separated_by_underscores). Use a leading underscore for _private attributes or
    methods.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名使用驼峰命名法（例如，CamelCase），异常类以Error结尾（如果适用），函数名使用小写字母，并且单词之间用下划线分隔（例如，separated_by_underscores）。使用前导下划线表示_私有属性或方法。
- en: These guidelines really aren’t hard to follow, and they make a lot of sense.
    Most Python programmers have no trouble sticking to them as they write code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指南真的不难遵循，而且它们非常合理。大多数Python程序员在编写代码时并不难遵守这些规则。
- en: 'However, *errare humanum est*, and it’s still a pain to look through your code
    to make sure it fits the PEP 8 guidelines. Luckily, there’s a pep8 tool (found
    at *[https://pypi.org/project/pep8/](https://pypi.org/project/pep8/)*) that can
    automatically check any Python file you send its way. Install pep8 with pip, and
    then you can use it on a file like so:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，*人非圣贤，孰能无过*，查看你的代码以确保它符合PEP 8指南仍然是件痛苦的事情。幸运的是，有一个pep8工具（可在 *[https://pypi.org/project/pep8/](https://pypi.org/project/pep8/)*
    上找到），它可以自动检查你发送的任何Python文件。使用pip安装pep8，然后你可以像下面这样在文件上使用它：
- en: $ pep8 hello.py
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: $ pep8 hello.py
- en: 'hello.py:4:1: E302 expected 2 blank lines, found 1 $ echo $?'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 'hello.py:4:1: E302 期望2个空行，但发现1个 $ echo $?'
- en: '1'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: Here I use pep8 on my file *hello.py*, and the output indicates which lines
    and columns do not conform to PEP 8 and reports each issue with a code—here it’s
    line 4 and column 1\. Violations of *MUST* statements in the specification are
    reported as *errors*, and their error codes start with an *E*. Minor issues are
    reported as *warnings*, and their error codes start with a *W*. The three-digit
    code following that first letter indicates the exact kind of error or warning.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我在我的文件*hello.py*上使用pep8，输出结果显示哪些行和列不符合PEP 8，并报告每个问题的代码——这里是第4行和第1列。违反规范中*必须*语句的将被报告为*错误*，错误代码以*E*开头。轻微问题会被报告为*警告*，错误代码以*W*开头。紧跟其后的三位数字代码表示错误或警告的具体类型。
- en: 'The hundreds digit tells you the general category of an error code: for example,
    errors starting with E2 indicate issues with whitespace, errors starting with
    E3 indicate issues with blank lines, and warnings starting with W6 indicate deprecated
    features being used. These codes are all listed in the pep8 readthedocs documentation
    (*[https://pep8.readthedocs.io/](https://pep8.readthedocs.io/)*).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 百位数字告诉你错误代码的一般类别：例如，错误代码以E2开头表示空格问题，错误代码以E3开头表示空行问题，警告代码以W6开头表示使用了废弃的特性。这些代码都列在pep8的readthedocs文档中（*
    [https://pep8.readthedocs.io/](https://pep8.readthedocs.io/)*）。
- en: '***Tools to Catch Style Errors***'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***捕捉样式错误的工具***'
- en: The community still debates whether validating against PEP 8 code, which is
    not part of the Standard Library, is good practice. My advice is to consider running
    a PEP 8 validation tool against your source code on a regular basis. You can do
    this easily by integrating it into your continuous integration system. While this
    approach may seem a bit extreme, it’s a good way to ensure that you continue to
    respect the PEP 8 guidelines in the long term. We’ll discuss in “Using virtualenv
    with tox” on [page 92](ch06.xhtml#page_92) how you can integrate pep8 with tox
    to automate these checks.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 社区仍然在争论是否对不属于标准库的PEP 8代码进行验证是良好的实践。我的建议是定期使用PEP 8验证工具检查源代码。你可以通过将其集成到持续集成系统中来轻松实现。虽然这种方法看起来有点极端，但它是确保长期遵守PEP
    8指南的好方法。在“使用virtualenv与tox”中，我们将在[第92页](ch06.xhtml#page_92)讨论如何将pep8与tox集成来自动化这些检查。
- en: Most open source projects enforce PEP 8 conformance through automatic checks.
    Using these automatic checks from the very beginning of the project might frustrate
    newcomers, but it also ensures that the codebase always looks the same in every
    part of the project. This is very important for a project of any size where there
    are multiple developers with differing opinions on, for example, whitespace ordering.
    You know what I mean.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开源项目通过自动检查强制执行PEP 8一致性。从项目一开始就使用这些自动检查可能会让新手感到沮丧，但它也确保了代码库在项目的每个部分始终保持一致。这对于有多个开发者参与的大型项目来说尤为重要，因为开发者们可能在空格排序等方面有不同的看法。你懂我的意思。
- en: 'It’s also possible to set your code to ignore certain kinds of errors and warnings
    by using the --ignore option, like so:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用--ignore选项设置让代码忽略某些类型的错误和警告，像这样：
- en: $ pep8 --ignore=E3 hello.py
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: $ pep8 --ignore=E3 hello.py
- en: $ echo $?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: $ echo $?
- en: '0'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: This will ignore any code E3 errors inside my *hello.py* file. The --ignore
    option allows you to effectively ignore parts of the PEP 8 specification that
    you don’t want to follow. If you’re running pep8 on an existing codebase, it also
    allows you to ignore certain kinds of problems so you can focus on fixing issues
    one category at a time.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这将忽略我在*hello.py*文件中的任何代码 E3 错误。--ignore 选项允许你有效地忽略你不想遵循的 PEP 8 规范部分。如果你在现有的代码库上运行
    pep8，它还允许你忽略某些类型的问题，这样你就可以一次集中精力修复一个类别的问题。
- en: '**NOTE**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you write C code for Python (e.g., modules), the PEP 7 standard describes
    the coding style that you should follow.*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你为 Python 编写 C 代码（例如，模块），PEP 7 标准描述了你应该遵循的编码风格。*'
- en: '***Tools to Catch Coding Errors***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***捕获编码错误的工具***'
- en: 'Python also has tools that check for actual coding errors rather than style
    errors. Here are some notable examples:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Python 还提供了一些检查实际编码错误的工具，而非风格错误。以下是一些值得注意的例子：
- en: '*Pyflakes* (*[https://launchpad.net/pyflakes/](https://launchpad.net/pyflakes/)*):
    Extendable via plugins.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pyflakes* (*[https://launchpad.net/pyflakes/](https://launchpad.net/pyflakes/)*):
    可通过插件扩展。'
- en: '*Pylint* (*[https://pypi.org/project/pylint/](https://pypi.org/project/pylint/)*):
    Checks PEP 8 conformance while performing code error checks by default; can be
    extended via plugins.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pylint* (*[https://pypi.org/project/pylint/](https://pypi.org/project/pylint/)*):
    默认检查 PEP 8 合规性，并进行代码错误检查；可以通过插件扩展。'
- en: These tools all make use of static analysis—that is, they parse the code and
    analyze it rather than running it outright.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具都使用静态分析——也就是说，它们解析代码并进行分析，而不是直接运行代码。
- en: If you choose to use Pyflakes, note that it doesn’t check PEP 8 conformance
    on its own, so you’d need the second pep8 tool to cover both.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择使用 Pyflakes，请注意它本身不检查 PEP 8 合规性，因此你需要使用第二个 pep8 工具来涵盖两者。
- en: 'To simplify things, Python has a project named flake8 (*[https://pypi.org/project/flake8/](https://pypi.org/project/flake8/)*)
    that combines pyflakes and pep8 into a single command. It also adds some new fancy
    features: for example, it can skip checks on lines containing # noqa and is extensible
    via plugins.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '为了简化事情，Python 有一个名为 flake8 的项目 (*[https://pypi.org/project/flake8/](https://pypi.org/project/flake8/)*)，它将
    pyflakes 和 pep8 合并为一个命令。它还添加了一些新的功能：例如，它可以跳过包含 # noqa 的行，并且可以通过插件扩展。'
- en: There are a large number of plugins available for flake8 that you can use out
    of the box. For example, installing *flake8-import-order* (with pip install flake8-import-order)
    will extend flake8 so that it also checks whether your import statements are sorted
    alphabetically in your source code. Yes, some projects want that.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量的插件可以供 flake8 使用，你可以开箱即用。例如，安装*flake8-import-order*（使用 `pip install flake8-import-order`）将扩展
    flake8，使其检查你的导入语句是否在源代码中按字母顺序排序。是的，一些项目确实需要这样做。
- en: In most open source projects, flake8 is heavily used for code style verification.
    Some large open source projects have even written their own plugins for flake8,
    adding checks for errors such as odd usage of except, Python 2/3 portability issues,
    import style, dangerous string formatting, possible localization issues, and more.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数开源项目中，flake8 被广泛用于代码风格验证。一些大型开源项目甚至为 flake8 编写了自己的插件，增加了对一些错误的检查，比如异常使用不当、Python
    2/3 兼容性问题、导入风格、危险的字符串格式化、可能的本地化问题等。
- en: If you’re starting a new project, I strongly recommend that you use one of these
    tools for automatic checking of your code quality and style. If you already have
    a codebase that didn’t implement automatic code checking, a good approach is to
    run your tool of choice with most of the warnings disabled and fix issues one
    category at a time.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开始一个新项目，我强烈建议你使用这些工具之一来自动检查代码质量和风格。如果你已经有一个没有实现自动代码检查的代码库，一个好的方法是先用你选择的工具运行，并禁用大部分警告，逐一修复每个类别的问题。
- en: Though none of these tools may be a *perfect* fit for your project or your preferences,
    flake8 is a good way to improve the quality of your code and make it more durable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些工具中没有一个*完美*适合你的项目或偏好，flake8 依然是提高代码质量并使代码更具耐用性的好方法。
- en: '**NOTE**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Many text editors, including the famous GNU Emacs and vim, have plugins available
    (such as Flycheck) that can run tools such as pep8 or flake8 directly in your
    code buffer, interactively highlighting any part of your code that isn’t PEP 8
    compliant. This is a handy way to fix most style errors as you write your code.*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*许多文本编辑器，包括著名的GNU Emacs和vim，都有插件（如Flycheck），可以直接在代码缓冲区中运行工具，如pep8或flake8，互动式地高亮显示任何不符合PEP
    8规范的代码部分。这是一种在写代码时修复大多数风格错误的方便方式。*'
- en: We’ll talk about extending this toolset in [Chapter 9](ch09.xhtml#ch09) with
    our own plugin to verify correct method declaration.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章](ch09.xhtml#ch09)中讨论如何通过自定义插件扩展这个工具集，以验证正确的方法声明。
- en: '**Joshua Harlow on Python**'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Joshua Harlow谈Python**'
- en: Joshua Harlow is a Python developer. He was one of the technical leads on the
    OpenStack team at Yahoo! between 2012 and 2016 and now works at GoDaddy. Josh
    is the author of several Python libraries such as *Taskflow*, *automaton,* and
    *Zake*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 约书亚·哈洛（Joshua Harlow）是一位Python开发者。他曾在2012到2016年间担任雅虎OpenStack团队的技术负责人，现在在GoDaddy工作。Josh是多个Python库的作者，如*Taskflow*、*automaton*和*Zake*。
- en: '**What got you into using Python?**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**是什么让你开始使用Python的？**'
- en: I started programming in Python 2.3 or 2.4 back in about 2004 during an internship
    at IBM near Poughkeepsie, New York (most of my relatives and family are from upstate
    NY, shout out to them!). I forget exactly what I was doing there, but it involved
    wxPython and some Python code that they were working on to automate some system.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我大约在2004年左右，在IBM位于纽约州波基普西的实习期间开始编程，使用的是Python 2.3或2.4（我大多数亲戚和家人都来自纽约上州，向他们致敬！）。我忘了当时具体做什么了，但它涉及到wxPython和一些他们用来自动化某些系统的Python代码。
- en: After that internship I returned to school, went on to graduate school at the
    Rochester Institute of Technology, and ended up working at Yahoo!.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在那次实习之后，我回到学校，继续在罗切斯特理工学院攻读研究生，并最终在雅虎工作。
- en: I eventually ended up in the CTO team, where I and a few others were tasked
    with figuring out which open source cloud platform to use. We landed on OpenStack,
    which is written almost entirely in Python.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我最终加入了CTO团队，我和其他几位同事的任务是找出应该使用哪个开源云平台。我们选择了OpenStack，它几乎完全用Python编写。
- en: '**What do you love and hate about the Python language?**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**你喜欢和讨厌Python语言的哪些方面？**'
- en: 'Some of the things I love (not a comprehensive listing):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢的一些事情（不是一个全面的列表）：
- en: Its simplicity—Python is really easy for beginners to engage with and for experienced
    developers to stay engaged with.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的简洁性——Python对于初学者来说非常容易上手，对有经验的开发者来说也能保持兴趣。
- en: Style checking—reading code you wrote later on is a big part of developing software
    and having consistency that can be enforced by tools such as flake8, pep8, and
    Pylint really helps.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 风格检查——以后阅读自己写的代码是开发软件的一个重要部分，拥有一致性并通过flake8、pep8和Pylint等工具强制执行，这真的很有帮助。
- en: The ability to pick and choose programming styles and mix them up as you see
    fit.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够选择和混合编程风格，按需组合使用。
- en: 'Some of the things I dislike (not a comprehensive listing):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我不喜欢的一些事情（不是一个全面的列表）：
- en: The somewhat painful Python 2 to 3 transition (version 3.6 has paved over most
    of the issues here).
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Python 2到Python 3的过渡有点痛苦（版本3.6已经解决了大部分问题）。
- en: Lambdas are too simplistic and should be made more powerful.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda表达式过于简单，应该让它们更强大。
- en: The lack of a decent package installer—I feel pip needs some work, like developing
    a real dependency resolver.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏一个体面的包管理器——我觉得pip需要改进，比如开发一个真正的依赖解决器。
- en: The global interpreter lock (GIL) and the need for it. It makes me sad . . .
    [more on the GIL in [Chapter 11](ch11.xhtml#ch11)].
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局解释器锁（GIL）及其必要性。它让我感到难过……[更多关于GIL的内容在[第11章](ch11.xhtml#ch11)中]。
- en: The lack of native support for multithreading—currently you need the addition
    of an explicit asyncio model.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏对多线程的原生支持——目前你需要额外的显式asyncio模型来实现。
- en: The fracturing of the Python community; this is mainly around the split between
    CPython and PyPy (and other variants).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python社区的分裂；这主要是指CPython和PyPy（以及其他变体）之间的分歧。
- en: '**You work on debtcollector, a Python module for managing deprecation warnings.
    How is the process of starting a new library?**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**你在debtcollector上工作，这是一个用于管理弃用警告的Python模块。启动一个新库的过程是怎样的？**'
- en: The simplicity mentioned above makes it really easy to get a new library going
    and to publish it so others can use it. Since that code came out of one of the
    other libraries that I work on (taskflow^([1](footnote.xhtml#foot1))) it was relatively
    easy to transplant and extend that code without having to worry about the API
    being badly designed. I am very glad others (inside the OpenStack community or
    outside of it) have found a need/use for it, and I hope that library grows to
    accommodate more styles of deprecation patterns that other libraries (and applications?)
    find useful.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的简洁性使得创建新库并将其发布供他人使用变得非常容易。由于这段代码来自我参与的另一个库（taskflow^([1](footnote.xhtml#foot1)))，所以将这段代码移植并扩展起来相对简单，且无需担心
    API 设计不佳。我非常高兴其他人（无论是 OpenStack 社区内外）发现了它的需求/用途，并且我希望这个库能够成长，适应更多其他库（和应用程序？）可能需要的废弃模式。
- en: '**What is Python missing, in your opinion?**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**你认为 Python 缺少什么？**'
- en: Python could perform better under just-in-time (JIT) compilation. Most newer
    languages being created (such as Rust, Node.js using the Chrome V8 JavaScript
    engine, and others) have many of Python’s capabilities but are also JIT compiled.
    It would be really be great if the default CPython could also be JIT compiled
    so that Python could compete with these newer languages on performance.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在即时编译（JIT）下的性能可能会更好。大多数新兴语言（如 Rust、使用 Chrome V8 JavaScript 引擎的 Node.js
    等）具备 Python 的许多功能，但也都支持 JIT 编译。如果默认的 CPython 也能进行 JIT 编译，那就太好了，这样 Python 就能在性能上与这些新兴语言竞争。
- en: Python also really needs a strong set of concurrency patterns; not just the
    low level asyncio and threading styles of patterns, but higher-level concepts
    that help make applications that work performantly at larger scale. The Python
    library goless does port over some of the concepts from Go, which does provide
    a built-in concurrency model. I believe these higher-level patterns need to be
    available as first-class patterns that are built in to the Standard Library and
    maintained so that developers can use them where they see fit. Without these,
    I don’t see how Python can compete with other languages that do provide them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Python 也非常需要一套强大的并发模式；不仅仅是低级的 asyncio 和线程模式，而是更高层次的概念，帮助开发出在大规模应用中表现出色的程序。Python
    库 goless 移植了一些来自 Go 的概念，Go 提供了内建的并发模型。我认为这些更高层次的模式需要作为一等公民被内建到标准库中并得到维护，以便开发者在需要时使用。没有这些，我看不到
    Python 如何与提供这些功能的其他语言竞争。
- en: Until next time, keep coding and be happy!
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下次再见，保持编程并保持快乐！
