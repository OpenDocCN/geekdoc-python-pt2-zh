["```py\nimport math\nimport turtle\n# draw the circle using turtle\ndef drawCircleTurtle(x, y, r):\n    # move to the start of circle\n    turtle.up()\n  ❶ turtle.setpos(x + r, y)\n    turtle.down()\n    # draw the circle\n  ❷ for i in range(0, 365, 5):\n      ❸ a = math.radians(i)\n      ❹ turtle.setpos(x + r*math.cos(a), y + r*math.sin(a))\n❺ drawCircleTurtle(100, 100, 50)\nturtle.mainloop()\n\n```", "```py\nclass Spiro:\n    # constructor\n    def __init__(self, xc, yc, col, R, r, l):\n        # create the turtle object\n      ❶ self.t = turtle.Turtle()\n        # set the cursor shape\n      ❷ self.t.shape('turtle')\n        # set the step in degrees\n      ❸ self.step = 5\n        # set the drawing complete flag\n      ❹ self.drawingComplete = False\n        # set the parameters\n        self.setparams(xc, yc, col, R, r, l)\n        # initialize the drawing\n        self.restart()\n\n```", "```py\ndef setparams(self, xc, yc, col, R, r, l):\n    # the Spirograph parameters\n    self.xc = xc\n    self.yc = yc\n    self.R = int(R)\n    self.r = int(r)\n    self.l = l\n    self.col = col\n    # reduce r/R to its smallest form by dividing with the GCD\n  ❶ gcdVal = math.gcd(self.r, self.R)\n  ❷ self.nRot = self.r//gcdVal\n    # get ratio of radii\n    self.k = r/float(R)\n    # set the color\n    self.t.color(*col)\n    # store the current angle\n  ❸ self.a = 0\n\n```", "```py\ndef restart(self):\n    # set the flag\n    self.drawingComplete = False\n    # show the turtle\n    self.t.showturtle()\n    # go to the first point\n  ❶ self.t.up()\n  ❷ R, k, l = self.R, self.k, self.l\n    a = 0.0\n  ❸ x = R*((1-k)*math.cos(a) + l*k*math.cos((1-k)*a/k))\n    y = R*((1-k)*math.sin(a) - l*k*math.sin((1-k)*a/k))\n  ❹ self.t.setpos(self.xc + x, self.yc + y)\n  ❺ self.t.down()\n\n```", "```py\ndef draw(self):\n    # draw the rest of the points\n    R, k, l = self.R, self.k, self.l\n  ❶ for i in range(0, 360*self.nRot + 1, self.step):\n        a = math.radians(i)\n      ❷ x = R*((1-k)*math.cos(a) + l*k*math.cos((1-k)*a/k))\n        y = R*((1-k)*math.sin(a) - l*k*math.sin((1-k)*a/k))\n        try:\n          ❸ self.t.setpos(self.xc + x, self.yc + y)\n        except:\n            print(\"Exception, exiting.\")\n            exit(0)\n    # drawing is now done so hide the turtle cursor\n  ❹ self.t.hideturtle()\n\n```", "```py\ndef update(self):\n    # skip the rest of the steps if done\n  ❶ if self.drawingComplete:\n        return\n    # increment the angle\n  ❷ self.a += self.step\n    # draw a step\n    R, k, l = self.R, self.k, self.l\n    # set the angle\n  ❸ a = math.radians(self.a)\n    x = self.R*((1-k)*math.cos(a) + l*k*math.cos((1-k)*a/k))\n    y = self.R*((1-k)*math.sin(a) - l*k*math.sin((1-k)*a/k))\n    try:\n      ❹ self.t.setpos(self.xc + x, self.yc + y)\n    except:\n        print(\"Exception, exiting.\")\n        exit(0)\n    # if drawing is complete, set the flag\n  ❺ if self.a >= 360*self.nRot:\n        self.drawingComplete = True\n        # drawing is now done so hide the turtle cursor\n        self.t.hideturtle()\n\n```", "```py\nclass SpiroAnimator:\n    # constructor\n    def __init__(self, N):\n        # set the timer value in milliseconds\n      ❶ self.deltaT = 10\n        # get the window dimensions\n      ❷ self.width = turtle.window_width()\n        self.height = turtle.window_height()\n        # restarting\n      ❸ self.restarting = False\n        # create the Spiro objects\n        self.spiros = []\n        for i in range(N):\n            # generate random parameters\n          ❹ rparams = self.genRandomParams()\n            # set the spiro parameters\n          ❺ spiro = Spiro(*rparams)\n            self.spiros.append(spiro)\n        # call timer\n      ❻ turtle.ontimer(self.update, self.deltaT)\n\n```", "```py\ndef genRandomParams(self):\n    width, height = self.width, self.height\n    R = random.randint(50, min(width, height)//2)\n    r = random.randint(10, 9*R//10)\n    l = random.uniform(0.1, 0.9)\n    xc = random.randint(-width//2, width//2)\n    yc = random.randint(-height//2, height//2)\n    col = (random.random(),\n           random.random(),\n           random.random())\n  ❶ return (xc, yc, col, R, r, l)\n\n```", "```py\ndef restart(self):\n    # ignore restart if already in the middle of restarting\n  ❶ if self.restarting:\n        return\n    else:\n        self.restarting = True\n    for spiro in self.spiros:\n        # clear\n        spiro.clear()\n        # generate random parameters\n        rparams = self.genRandomParams()\n        # set the spiro parameters\n        spiro.setparams(*rparams)\n        # restart drawing\n        spiro.restart()\n    # done restarting\n  ❷ self.restarting = False\n\n```", "```py\ndef update(self):\n    # update all spiros\n  ❶ nComplete = 0\n    for spiro in self.spiros:\n        # update\n      ❷ spiro.update()\n        # count completed spiros\n      ❸ if spiro.drawingComplete:\n            nComplete += 1\n    # restart if all spiros are complete\n  ❹ if nComplete == len(self.spiros):\n        self.restart()\n    # call the timer\n    try:\n      ❺ turtle.ontimer(self.update, self.deltaT)\n    except:\n        print(\"Exception, exiting.\")\n        exit(0)\n\n```", "```py\ndef toggleTurtles(self):\n    for spiro in self.spiros:\n        if spiro.t.isvisible():\n            spiro.t.hideturtle()\n        else:\n            spiro.t.showturtle()\n\n```", "```py\ndef saveDrawing():\n    # hide the turtle cursor\n      ❶ turtle.hideturtle()\n        # generate unique filenames\n      ❷ dateStr = (datetime.now()).strftime(\"%d%b%Y-%H%M%S\")\n        fileName = 'spiro-' + dateStr\n        print('saving drawing to {}.eps/png'.format(fileName))\n        # get the tkinter canvas\n        canvas = turtle.getcanvas()\n        # save the drawing as a postscript image\n      ❸ canvas.postscript(file = fileName + '.eps')\n        # use the Pillow module to convert the postscript image file to PNG\n      ❹ img = Image.open(fileName + '.eps')\n      ❺ img.save(fileName + '.png', 'png')\n        # show the turtle cursor\n        turtle.showturtle()\n\n```", "```py\ndef main():\n  ❶ parser = argparse.ArgumentParser(description=descStr)\n    # add expected arguments\n  ❷ parser.add_argument('--sparams', nargs=3, dest='sparams', required=False,\n                        help=\"The three arguments in sparams: R, r, l.\")\n    # parse args\n  ❸ args = parser.parse_args()\n\n```", "```py\n    # set the width of the drawing window to 80 percent of the screen width\n  ❶ turtle.setup(width=0.8)\n    # set the cursor shape to turtle\n    turtle.shape('turtle')\n    # set the title to Spirographs!\n    turtle.title(\"Spirographs!\")\n    # add the key handler to save our drawings\n  ❷ turtle.onkey(saveDrawing, \"s\")\n    # start listening\n  ❸ turtle.listen()\n    # hide the main turtle cursor\n  ❹ turtle.hideturtle()\n\n```", "```py\n    # check for any arguments sent to --sparams and draw the Spirograph\n  ❶ if args.sparams:\n      ❷ params = [float(x) for x in args.sparams]\n        # draw the Spirograph with the given parameters\n        col = (0.0, 0.0, 0.0)\n      ❸ spiro = Spiro(0, 0, col, *params)\n      ❹ spiro.draw()\n    else:\n        # create the animator object\n      ❺ spiroAnim = SpiroAnimator(4)\n        # add a key handler to toggle the turtle cursor\n        turtle.onkey(spiroAnim.toggleTurtles, \"t\")\n        # add a key handler to restart the animation\n        turtle.onkey(spiroAnim.restart, \"space\")\n    # start the turtle main loop\n  ❻ turtle.mainloop()\n\n```", "```py\n$ `python spiro.py`\n\n```", "```py\n$ `python spiro.py --sparams 300 100 0.9`\n\n```", "```py\n\"\"\"\nspiro.py\nA Python program that simulates a Spirograph.\nAuthor: Mahesh Venkitachalam\n\"\"\"\nimport random, argparse\nimport numpy as np\nimport math\nimport turtle\nimport random\nfrom PIL import Image\nfrom datetime import datetime\n# a class that draws a spiro\nclass Spiro:\n    # constructor\n    def __init__(self, xc, yc, col, R, r, l):\n        # create own turtle\n        self.t = turtle.Turtle()\n        # set cursor shape\n        self.t.shape('turtle')\n        # set step in degrees\n        self.step = 5\n        # set drawing complete flag\n        self.drawingComplete = False\n        # set parameters\n        self.setparams(xc, yc, col, R, r, l)\n        # initialize drawing\n        self.restart()\n    # set parameters\n    def setparams(self, xc, yc, col, R, r, l):\n        # spirograph parameters\n        self.xc = xc\n        self.yc = yc\n        self.R = int(R)\n        self.r = int(r)\n        self.l = l\n        self.col = col\n        # reduce r/R to smallest form by dividing with GCD\n        gcdVal = math.gcd(self.r, self.R)\n        self.nRot = self.r//gcdVal\n        # get ratio of radii\n        self.k = r/float(R)\n        # set color\n        self.t.color(*col)\n        # current angle\n        self.a = 0\n    # restart drawing\n    def restart(self):\n        # set flag\n        self.drawingComplete = False\n        # show turtle\n        self.t.showturtle()\n        # go to first point\n        self.t.up()\n        R, k, l = self.R, self.k, self.l\n        a = 0.0\n        x = R*((1-k)*math.cos(a) + l*k*math.cos((1-k)*a/k))\n        y = R*((1-k)*math.sin(a) - l*k*math.sin((1-k)*a/k))\n        try:\n            self.t.setpos(self.xc + x, self.yc + y)\n        except:\n            print(\"Exception, exiting.\")\n            exit(0)\n        self.t.down()\n    # draw the whole thing\n    def draw(self):\n        # draw rest of points\n        R, k, l = self.R, self.k, self.l\n        for i in range(0, 360*self.nRot + 1, self.step):\n            a = math.radians(i)\n            x = R*((1-k)*math.cos(a) + l*k*math.cos((1-k)*a/k))\n            y = R*((1-k)*math.sin(a) - l*k*math.sin((1-k)*a/k))\n            try:\n                self.t.setpos(self.xc + x, self.yc + y)\n            except:\n                print(\"Exception, exiting.\")\n                exit(0)\n        # done - hide turtle\n        self.t.hideturtle()\n    # update by one step\n    def update(self):\n        # skip if done\n        if self.drawingComplete:\n            return\n        # increment angle\n        self.a += self.step\n        # draw step\n        R, k, l = self.R, self.k, self.l\n        # set angle\n        a = math.radians(self.a)\n        x = self.R*((1-k)*math.cos(a) + l*k*math.cos((1-k)*a/k))\n        y = self.R*((1-k)*math.sin(a) - l*k*math.sin((1-k)*a/k))\n        try:\n            self.t.setpos(self.xc + x, self.yc + y)\n        except:\n            print(\"Exception, exiting.\")\n            exit(0)\n        # check if drawing is complete and set flag\n        if self.a >= 360*self.nRot:\n            self.drawingComplete = True\n            # done - hide turtle\n            self.t.hideturtle()\n    # clear everything\n    def clear(self):\n        # pen up\n        self.t.up()\n        # clear turtle\n        self.t.clear()\n# a class for animating spiros\nclass SpiroAnimator:\n    # constructor\n    def __init__(self, N):\n        # timer value in milliseconds\n        self.deltaT = 10\n        # get window dimensions\n        self.width = turtle.window_width()\n        self.height = turtle.window_height()\n        # restarting\n        self.restarting = False\n        # create spiro objects\n        self.spiros = []\n        for i in range(N):\n            # generate random parameters\n            rparams = self.genRandomParams()\n            # set spiro params\n            spiro = Spiro(*rparams)\n            self.spiros.append(spiro)\n        # call timer\n        turtle.ontimer(self.update, self.deltaT)\n    # restart spiro drawing\n    def restart(self):\n        # ignore restart if already in the middle of restarting\n        if self.restarting:\n            return\n        else:\n            self.restarting = True\n        # restart\n        for spiro in self.spiros:\n            # clear\n            spiro.clear()\n            # generate random parameters\n            rparams = self.genRandomParams()\n            # set spiro params\n            spiro.setparams(*rparams)\n            # restart drawing\n            spiro.restart()\n        # done restarting\n        self.restarting = False\n    # generate random parameters\n    def genRandomParams(self):\n        width, height = self.width, self.height\n        R = random.randint(50, min(width, height)//2)\n        r = random.randint(10, 9*R//10)\n        l = random.uniform(0.1, 0.9)\n        xc = random.randint(-width//2, width//2)\n        yc = random.randint(-height//2, height//2)\n        col = (random.random(),\n               random.random(),\n               random.random())\n        return (xc, yc, col, R, r, l)\n    def update(self):\n        # update all spiros\n        nComplete = 0\n        for spiro in self.spiros:\n            # update\n            spiro.update()\n            # count completed ones\n            if spiro.drawingComplete:\n                nComplete+= 1\n        # if all spiros are complete, restart\n        if nComplete == len(self.spiros):\n            self.restart()\n        # call timer\n        try:\n            turtle.ontimer(self.update, self.deltaT)\n        except:\n            print(\"Exception, exiting.\")\n            exit(0)\n    # toggle turtle on/off\n    def toggleTurtles(self):\n        for spiro in self.spiros:\n            if spiro.t.isvisible():\n                spiro.t.hideturtle()\n            else:\n                spiro.t.showturtle()\n# save spiros to image\ndef saveDrawing():\n    # hide turtle\n    turtle.hideturtle()\n    # generate unique filename\n    dateStr = (datetime.now()).strftime(\"%d%b%Y-%H%M%S\")\n    fileName = 'spiro-' + dateStr\n    print('saving drawing to {}.eps/png'.format(fileName))\n    # get tkinter canvas\n    canvas = turtle.getcanvas()\n    # save postscript image\n    canvas.postscript(file = fileName + '.eps')\n    # use PIL to convert to PNG\n    img = Image.open(fileName + '.eps')\n    img.save(fileName + '.png', 'png')\n    # show turtle\n    turtle.showturtle()\n# main() function\ndef main():\n    # use sys.argv if needed\n    print('generating spirograph...')\n    # create parser\n    descStr = \"\"\"This program draws spirographs using the Turtle module.\n    When run with no arguments, this program draws random spirographs.\n    Terminology:\n    R: radius of outer circle.\n    r: radius of inner circle.\n    l: ratio of hole distance to r.\n    \"\"\"\n    parser = argparse.ArgumentParser(description=descStr)\n    # add expected arguments\n    parser.add_argument('--sparams', nargs=3, dest='sparams', required=False,\n                        help=\"The three arguments in sparams: R, r, l.\")\n    # parse args\n    args = parser.parse_args()\n    # set to 80% screen width\n    turtle.setup(width=0.8)\n    # set cursor shape\n    turtle.shape('turtle')\n    # set title\n    turtle.title(\"Spirographs!\")\n    # add key handler for saving images\n    turtle.onkey(saveDrawing, \"s\")\n    # start listening\n    turtle.listen()\n    # hide main turtle cursor\n    turtle.hideturtle()\n    # check args and draw\n    if args.sparams:\n        params = [float(x) for x in args.sparams]\n        # draw spirograph with given parameters\n        # black by default\n        col = (0.0, 0.0, 0.0)\n        spiro = Spiro(0, 0, col, *params)\n        spiro.draw()\n    else:\n        # create animator object\n        spiroAnim = SpiroAnimator(4)\n        # add key handler to toggle turtle cursor\n        turtle.onkey(spiroAnim.toggleTurtles, \"t\")\n        # add key handler to restart animation\n        turtle.onkey(spiroAnim.restart, \"space\")\n    # start turtle main loop\n    turtle.mainloop()\n# call main\nif __name__ == '__main__':\n    main()\n\n```"]