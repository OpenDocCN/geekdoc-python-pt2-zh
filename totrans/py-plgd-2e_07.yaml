- en: '[5](nsp-venkitachalam503045-0008.xhtml#rch05)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[5](nsp-venkitachalam503045-0008.xhtml#rch05)'
- en: Flocking Boids
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鸟群聚集
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: Look closely at a flock of birds or a school of fish, and you’ll notice that
    although the group is composed of individual creatures, the group as a whole seems
    to have a life of its own. The birds in a flock align with each other as they
    move and flow over and around obstacles. They break formation when disturbed or
    startled, but then they regroup, as if controlled by some larger force.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察一群鸟或一群鱼，你会发现尽管群体由独立的个体组成，但整个群体似乎拥有自己的生命。当鸟群移动时，它们会与彼此保持一致，并且能够绕过障碍物。它们在受到惊扰时会打乱队形，但随即会重新聚集，就好像受到某种更大力量的控制。
- en: In 1986, Craig Reynolds created a realistic-looking simulation of the flocking
    behavior of birds called the *Boids model*. One remarkable thing about the Boids
    model (named after the stereotypical New Yorker’s pronunciation of the word *birds*)
    is that only three simple rules govern the interaction between individuals in
    the flock, yet the model produces remarkably realistic flocking behavior. The
    Boids model is widely studied and has even been used to animate computer-generated
    swarms like the marching penguins in the movie *Batman Returns* (1992).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 1986年，克雷格·雷诺兹创造了一个逼真的鸟群行为模拟，名为 *Boids 模型*。Boids 模型的一个显著特点是，尽管鸟群个体之间的交互只受到三条简单规则的支配，但该模型却能生成非常逼真的鸟群行为。Boids
    模型被广泛研究，甚至被用于动画制作，例如电影《蝙蝠侠归来》（1992）中的行进企鹅。
- en: In this project, you’ll use Reynolds’s three rules to create a Boids simulation
    of the flocking behavior of *N* birds and plot their positions and directions
    of movement over time. You’ll also provide a method to add a bird to the flock,
    as well as a scatter effect that you can use to study the impact of a local disturbance
    on the flock. Boids is called an *N*-body simulation because it models a dynamic
    system of *N* particles that exert forces on each other.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用雷诺兹的三条规则来创建一个模拟鸟群行为的 Boids 模型，模拟*N*只鸟并绘制它们随时间变化的位置信息和运动方向。你还将提供一个方法，用于将鸟加入鸟群，并且设计一个分散效果，供你研究局部干扰对鸟群的影响。Boids
    被称为 *N* 体模拟，因为它模拟了一个由 *N* 个粒子组成的动态系统，这些粒子之间会相互施加力。
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah0701)'
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[工作原理](nsp-venkitachalam503045-0008.xhtml#rah0701)'
- en: 'The three core rules of the Boids simulation are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Boids 模拟的三条核心规则如下：
- en: Separation Keep a minimum distance between the boids.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 分离力保持鸟群之间的最小距离。
- en: Alignment Point each boid in the average direction of movement of its local
    flockmates.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐点让每只鸟保持与其局部鸟群成员平均运动方向的一致性。
- en: Cohesion Move each boid toward the center of mass of its local flockmates.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 凝聚力使每只鸟朝向其局部鸟群成员的质心移动。
- en: 'Boids simulations can add other rules too, such as ones to avoid obstacles
    or scatter the flock when it’s disturbed, as you’ll learn in the following sections.
    To create the Boids animation, you’ll do the following for every time step in
    the simulation:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Boids 模拟还可以加入其他规则，例如避免障碍物或在鸟群受到干扰时使鸟群分散，正如你在接下来的章节中将会学习的那样。为了创建 Boids 动画，你需要在每一个模拟时间步长中执行以下操作：
- en: '1\. For all boids in the flock:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 对于鸟群中的所有鸟：
- en: a. Apply the three core rules.
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 应用三条核心规则。
- en: b. Apply any additional rules.
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 应用任何附加规则。
- en: c. Apply all boundary conditions.
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: c. 应用所有边界条件。
- en: 2\. Update the positions and velocities of the boids.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 更新鸟群的位置信息和速度。
- en: 3\. Plot the new positions and velocities.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 绘制新的位置和速度。
- en: As you’ll see, these simple steps create a flock with evolving, complex behavior.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将看到的，这些简单的步骤能够创建一个具有演变复杂行为的鸟群。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah0702)'
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[要求](nsp-venkitachalam503045-0008.xhtml#rah0702)'
- en: 'These are the Python modules you’ll be using in this simulation:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你在模拟中将使用的 Python 模块：
- en: • `numpy` arrays to store the positions and velocities of the boids
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`numpy`数组来存储鸟群的位置信息和速度
- en: • The `matplotlib` library to animate the boids
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`matplotlib`库来对鸟群进行动画处理
- en: • `argparse` to process command line options
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`argparse`来处理命令行选项
- en: • The `scipy.spatial.distance` module, which has some really neat methods for
    calculating distances between points
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`scipy.spatial.distance`模块，它包含一些非常方便的方法用于计算点之间的距离
- en: I chose to use `matplotlib` for boids as a matter of simplicity and convenience.
    To draw a huge number of boids as quickly as possible, you might use something
    like the OpenGL library. We’ll explore graphics in more detail in [Part III](nsp-venkitachalam503045-0018.xhtml#pt03)
    of this book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择使用`matplotlib`来绘制boid，因为它简单方便。为了尽可能快速地绘制大量boid，你可能会使用像OpenGL这样的库。在本书的[第三部分](nsp-venkitachalam503045-0018.xhtml#pt03)中，我们将更详细地探讨图形学。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah0703)'
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah0703)'
- en: You’ll encapsulate the behavior of a group of boids in a class called `Boids`.
    First you’ll set the initial positions and velocities of the boids. Next, you’ll
    set up the boundary conditions for the simulation, look at how the boids are drawn,
    and implement the Boids simulation rules discussed earlier. Finally, you’ll add
    some interesting events to the simulation by allowing the user to add boids and
    scatter the flock. To see the full project code, skip ahead to [“The Complete
    Code”](nsp-venkitachalam503045-0017.xhtml#ah0707) on [page 96](nsp-venkitachalam503045-0017.xhtml#p96).
    You can also download it from the book’s GitHub repository at [https://github.com/mkvenkit/pp2e/blob/main/boids/boids.py](https://github.com/mkvenkit/pp2e/blob/main/boids/boids.py).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过一个名为`Boids`的类来封装一组boid的行为。首先，你会设置boid的初始位置和速度。接着，你会设置仿真的边界条件，查看boid的绘制方式，并实现之前讨论的Boids仿真规则。最后，你将通过允许用户添加boid并散播群体，来为仿真增添一些有趣的事件。要查看完整的项目代码，请跳到[“完整代码”](nsp-venkitachalam503045-0017.xhtml#ah0707)，位于[第96页](nsp-venkitachalam503045-0017.xhtml#p96)。你也可以从本书的GitHub仓库下载它：[https://github.com/mkvenkit/pp2e/blob/main/boids/boids.py](https://github.com/mkvenkit/pp2e/blob/main/boids/boids.py)。
- en: '[Initializing the Simulation](nsp-venkitachalam503045-0008.xhtml#rbh0701)'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[初始化仿真](nsp-venkitachalam503045-0008.xhtml#rbh0701)'
- en: The Boids simulation needs to compute the position and velocities of the boids
    at each step by pulling information from `numpy` arrays. At the beginning of the
    simulation, you use the `Boids` class’s `__init__()` method to create those arrays
    and initialize all boids in approximately the center of the screen, with their
    velocities set in random directions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Boids仿真需要在每一步计算boid的位置和速度，通过从`numpy`数组中获取信息。在仿真的开始，你使用`Boids`类的`__init__()`方法来创建这些数组，并将所有boid初始化在屏幕的中央，速度随机设定。
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'First you import the modules required for the program and set the width and
    height of the simulation window on the screen ❶. Then you begin declaring the
    `Boids` class. Within the class’s `__init__()` method, you create a `numpy` array
    called `pos` to store the x- and y-coordinates of all the boids ❷. For the initial
    value of each pair of coordinates, you start with the center of the window, `[width/2.0,
    height/2.0]`, and add a random displacement of up to 10 units. The code `np.random.rand(2*N)`
    creates a one-dimensional array of 2*N* random numbers in the range [0, 1], which
    you multiply by 10 to scale to a range of [0, 10]. The `reshape()` call converts
    the one-dimensional array into a two-dimensional array of shape (*N*, 2), perfect
    for storing *N* pairs of x- and y-coordinates. Notice, too, the `numpy` broadcasting
    rules in action here: the 1×2 array `[width/2.0, height/2.0]` representing the
    center of the window is added to each element in the *N*×2 array to randomly offset
    each boid’s position from the center.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导入程序所需的模块，并设置仿真窗口在屏幕上的宽度和高度 ❶。接着，开始声明`Boids`类。在该类的`__init__()`方法中，创建一个名为`pos`的`numpy`数组，用于存储所有boid的x和y坐标
    ❷。对于每一对坐标的初始值，你从窗口的中心`[width/2.0, height/2.0]`开始，并加入最大10个单位的随机偏移。代码`np.random.rand(2*N)`会创建一个包含2*N个随机数的一维数组，范围是[0,
    1]，你再将其乘以10，将范围缩放到[0, 10]。`reshape()`方法将一维数组转换为形状为(*N*, 2)的二维数组，完美地用于存储*N*对x和y坐标。同时，注意到`numpy`的广播规则：代表窗口中心的1×2数组`[width/2.0,
    height/2.0]`被加到*N*×2数组的每个元素上，从而随机偏移每个boid的位置。
- en: 'Next, you create an array of random unit velocity vectors (these are vectors
    of magnitude 1.0, pointing in random directions) for each boid using the following
    method: given an angle *t*, the pair of numbers (cos(*t*), sin(*t*)) lie on a
    circle of radius 1.0, centered at the origin (0, 0). If you draw a line from the
    origin to a point on this circle, it becomes a unit vector that depends on the
    angle *t*. So if you choose *t* at random, you end up with a random velocity vector.
    [Figure 5-1](nsp-venkitachalam503045-0017.xhtml#fig5-1) illustrates this scheme.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你为每个boid创建一个随机的单位速度向量数组（这些向量的大小为1.0，指向随机方向），使用以下方法：给定一个角度*t*，一对数字（cos(*t*),
    sin(*t*)）位于半径为1.0的圆上，圆心在原点（0, 0）。如果你从原点画一条线到圆上的某一点，那么这条线就成为一个单位向量，取决于角度*t*。所以如果你随机选择*t*，你最终会得到一个随机的速度向量。[图
    5-1](nsp-venkitachalam503045-0017.xhtml#fig5-1)展示了这一方案。
- en: '![](images/nsp-venkitachalam503045-f05001.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f05001.jpg)'
- en: 'Figure 5-1: Generating random unit velocity vectors'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-1：生成随机单位速度向量
- en: Returning to the code, you put this method into action by first generating an
    array of *N* random angles in the range [0, 2π] ❸. Then you create an array of
    random unit velocity vectors by calculating the cosine and sine of those angles
    ❹. You group the coordinates of each vector using Python’s built-in `zip()` method.
    The following is a simple example of `zip()`. This joins two lists into a list
    of tuples. The `list()` is needed because just calling `zip` will create only
    an iterator—you need all the elements in the list.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 回到代码中，你首先生成一个在[0, 2π]范围内的*N*个随机角度数组❸。然后通过计算这些角度的余弦和正弦，创建一个随机单位速度向量数组❹。你使用Python内置的`zip()`方法将每个向量的坐标分组。以下是`zip()`的一个简单示例。它将两个列表合并成一个包含元组的列表。因为直接调用`zip()`只会生成一个迭代器，所以需要使用`list()`来将其转换为列表，这样才能获取所有元素。
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In summary, you’ve generated two arrays that will be useful throughout the simulation,
    `pos` and `vel`. The first contains random positions clustered within a 10-pixel
    radius around the center of the screen, and the second contains unit velocities
    pointing in random directions. This means that at the start of the simulation,
    the boids will all hover around the center of the screen, pointed in random directions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，你已经生成了两个在整个模拟过程中都很有用的数组，`pos`和`vel`。第一个数组包含聚集在屏幕中心10像素半径范围内的随机位置，第二个数组包含指向随机方向的单位速度向量。这意味着在模拟开始时，所有boid都将悬停在屏幕中心，朝随机方向指向。
- en: 'The `__init__()` method continues by declaring some constant values that will
    help govern the simulation:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()`方法继续声明一些常量值，这些常量值将帮助管理模拟：'
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here you define the minimum distance of approach between two boids ❶. You’ll
    use this value later to apply the separation rule. Then you define `maxRuleVel`,
    which limits how much a boid’s velocity can be changed each time one of the simulation
    rules is applied ❷. You also define `maxVel`, which sets an overall limit on the
    boids’ velocities ❸.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你定义了两个boid之间的最小接近距离❶。稍后你将使用这个值来应用分离规则。接着你定义了`maxRuleVel`，它限制了每次应用模拟规则时boid的速度变化量❷。你还定义了`maxVel`，它为boid的速度设定了一个总体限制❸。
- en: '[Setting Boundary Conditions](nsp-venkitachalam503045-0008.xhtml#rbh0702)'
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[设置边界条件](nsp-venkitachalam503045-0008.xhtml#rbh0702)'
- en: Birds fly in a boundless sky, but the boids must play in limited space. To create
    that space, you’ll set boundary conditions, as you did with the toroidal boundary
    condition in the Game of Life simulation in [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03).
    In this case, you’ll apply a *tiled boundary condition* (actually the continuous
    space version of the boundary condition you used in [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03)).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 鸟儿飞翔在广阔的天空中，但boid必须在有限的空间内活动。为了创建这个空间，你需要设置边界条件，正如你在[第3章](nsp-venkitachalam503045-0015.xhtml#ch03)的生命游戏模拟中使用环形边界条件一样。在这种情况下，你将应用*平铺边界条件*（实际上是你在[第3章](nsp-venkitachalam503045-0015.xhtml#ch03)中使用的边界条件的连续空间版本）。
- en: 'Think of the Boids simulation as taking place in a tiled space: when a boid
    moves out of a tile, it moves in from the opposite direction to an identical tile.
    The main difference between the toroidal and tiled boundary conditions is that
    this Boids simulation won’t take place on a discrete grid; instead, the birds
    move over a continuous region. [Figure 5-2](nsp-venkitachalam503045-0017.xhtml#fig5-2)
    shows what those tiled boundary conditions look like.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Boids 仿真看作是在一个瓷砖空间中进行：当一个 boid 移出一个瓷砖时，它将从对面方向进入一个相同的瓷砖。环形和瓷砖边界条件的主要区别在于，这个
    Boids 仿真不会在一个离散的网格上进行；相反，鸟类将在一个连续的区域上移动。[图 5-2](nsp-venkitachalam503045-0017.xhtml#fig5-2)
    显示了这些瓷砖边界条件的样子。
- en: '![](images/nsp-venkitachalam503045-f05002.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f05002.jpg)'
- en: 'Figure 5-2: Tiled boundary conditions'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-2：瓷砖边界条件
- en: Look at the tile in the middle. The birds flying out to the right are entering
    the tile on the right, but the boundary conditions ensure that they actually come
    right back into the center tile through the tile at the left. You can see the
    same thing happening at the top and bottom tiles.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 看看中间的瓷砖。飞出右侧的鸟类正进入右侧的瓷砖，但边界条件确保它们实际上会通过左侧的瓷砖重新进入中央瓷砖。你可以看到同样的情况发生在顶部和底部的瓷砖上。
- en: 'You implement the tiled boundary conditions for the Boids simulation as a method
    on the `Boids` class:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你将 Boids 仿真的瓷砖边界条件作为 `Boids` 类中的一个方法来实现：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method applies the tiled boundary conditions to each set of boid coordinates
    in the `pos` array. For example, if an x-coordinate is greater than the width
    of the window ❶, you set it back to the left edge of the window. The `deltaR`
    in this line provides a slight buffer, which allows the boid to move slightly
    outside the window before it starts coming back in from the opposite direction,
    thus producing a better visual effect. You perform a similar check at the left,
    top, and bottom edges of the window.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将瓷砖边界条件应用于 `pos` 数组中的每组 boid 坐标。例如，如果 x 坐标大于窗口的宽度 ❶，你将其重新设置到窗口的左边缘。该行中的
    `deltaR` 提供了一个轻微的缓冲区，允许 boid 稍微超出窗口边界，然后从对面方向重新进入，从而产生更好的视觉效果。你会在窗口的左边、顶部和底部执行类似的检查。
- en: '[Drawing a Boid](nsp-venkitachalam503045-0008.xhtml#rbh0703)'
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[绘制一个 Boid](nsp-venkitachalam503045-0008.xhtml#rbh0703)'
- en: To build the animation, you need to know each boid’s position and velocity and
    have a way to indicate both the position and direction of motion at each time
    step.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建动画，你需要知道每个 boid 的位置和速度，并且有一种方法来在每个时间步长上表示位置和运动方向。
- en: Plotting the Boid’s Body and Head
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制 Boid 的身体和头部
- en: To animate the boids, you use `matplotlib` and a little trick to plot both the
    position and velocity. Draw each boid as two circles, as shown in [Figure 5-3](nsp-venkitachalam503045-0017.xhtml#fig5-3).
    The larger circle represents the body, and the smaller one represents the head.
    Point *P* marks the center of the body. For our purposes, you can consider *P*
    to be the position of the boid, and you’ll set it using coordinates from the `pos`
    array discussed earlier. Point *H* is the center of the head. You calculate the
    position of *H* according to the formula *H* = *P* + *k* × *V*, where *V* is the
    velocity of the boid and *k* is a constant representing the distance from the
    center of the body to the center of the head. This way, the boid’s head will be
    aligned with its direction of motion at any given time, which visually communicates
    the boid’s direction of movement more clearly than just drawing the body alone.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给 boids 动画化，你使用 `matplotlib` 和一个小技巧来绘制位置和速度。将每个 boid 绘制为两个圆形，如 [图 5-3](nsp-venkitachalam503045-0017.xhtml#fig5-3)
    所示。较大的圆表示身体，较小的圆表示头部。点 *P* 标记身体的中心位置。为了我们的目的，你可以将 *P* 视为 boid 的位置，并使用前面讨论过的 `pos`
    数组中的坐标来设置它。点 *H* 是头部的中心。你根据公式 *H* = *P* + *k* × *V* 计算 *H* 的位置，其中 *V* 是 boid 的速度，*k*
    是一个常数，表示从身体中心到头部中心的距离。这样，boid 的头部将在任何给定时刻与其运动方向对齐，这比单独绘制身体更清晰地传达了 boid 的运动方向。
- en: '![](images/nsp-venkitachalam503045-f05003.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f05003.jpg)'
- en: 'Figure 5-3: Representing a boid'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-3：表示一个 boid
- en: 'In the following snippet from the program’s `main()` function, you draw the
    boid’s body and head as circular markers using `matplotlib`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的 `main()` 函数中的以下代码片段中，你使用 `matplotlib` 以圆形标记的方式绘制 boid 的身体和头部：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You set the size and shape of the markers for the boid’s body (`pts`) ❶ and
    head (`head`) ❷. The `'k'` and `'r'` strings specify the colors black and red,
    respectively, and `'o'` produces a circular marker. The `ax.plot()` method returns
    a list of `matplotlib.lines.Line2D` objects. The `,` syntax in these lines picks
    up the first and only element in this list.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你设置了鸟群身体（`pts`） ❶ 和头部（`head`） ❷ 的标记大小和形状。`'k'` 和 `'r'` 字符串分别指定了黑色和红色，而 `'o'`
    会生成圆形标记。`ax.plot()` 方法返回一个 `matplotlib.lines.Line2D` 对象的列表。这些行中的 `,` 语法提取了列表中的第一个也是唯一一个元素。
- en: You next initialize a `matplotlib animation.FuncAnimation()` object ❸, which
    sets up a callback function `tick()` to be called for every frame of the animation
    (we’ll look at this function later in the chapter). The `fargs` parameter lets
    you specify the arguments of the callback function, and you also set the time
    interval (50 milliseconds in this case) at which this function will be called.
    Now that you know how to draw the body and the head, let’s see how to update their
    positions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你初始化一个 `matplotlib animation.FuncAnimation()` 对象 ❸，它设置了一个回调函数 `tick()`，该函数将在每一帧动画中被调用（我们稍后将在本章中讨论这个函数）。`fargs`
    参数允许你指定回调函数的参数，同时你还设置了时间间隔（在此为 50 毫秒），即该函数被调用的时间间隔。现在你已经知道如何绘制身体和头部，接下来我们来看如何更新它们的位置。
- en: Updating the Boid’s Position
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新鸟群的位置
- en: 'Once the animation starts, you need to update both the boid’s position and
    the location of the head, which tells you the direction in which the boid is moving.
    You do so with this code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 动画开始后，你需要更新鸟群的位置和头部位置，后者告诉你鸟群的移动方向。你可以使用以下代码实现：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First you calculate the position of the head by applying the *H* = *P* + *k* × *V*
    formula discussed earlier. You use a *k* value of 10 units in the direction of
    the velocity (`vel`). You then update (`reshape`) the `matplotlib` axis (`set_data`)
    with the new values of the head position. The `[::2]` picks out the even-numbered
    elements (x-axis values) from the velocity list, and the `[1::2]` picks out the
    odd-numbered elements (y-axis values).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你通过应用前面讨论的公式 *H* = *P* + *k* × *V* 来计算头部的位置。你在速度 (`vel`) 方向上使用 *k* 值为 10
    单位。然后，你用新的头部位置更新 (`reshape`) `matplotlib` 轴 (`set_data`)。`[::2]` 从速度列表中挑选出偶数编号的元素（x
    轴值），而 `[1::2]` 则挑选出奇数编号的元素（y 轴值）。
- en: '[Applying the Rules of the Boids](nsp-venkitachalam503045-0008.xhtml#rbh0704)'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[应用鸟群规则](nsp-venkitachalam503045-0008.xhtml#rbh0704)'
- en: 'In this section, we’ll look at how to implement the three rules of the Boids
    simulation—separation, alignment, and cohesion—to recalculate the boids’ velocities
    at each time step. We’ll start by focusing just on the separation rule. The goal
    is to generate a new velocity vector for each boid that pushes it away from its
    nearby flockmates, defined as all the boids within a certain radius *R*. Given
    two boids *i* and *j* with positions *P*[i] and *P*[j], *P*[i] − *P*[j] produces
    a new velocity vector for boid *i* that points away from boid *j*. We’ll call
    this a *displacement vector*. To calculate a new velocity vector *V*[i] for boid
    *i* that on average pushes it away from *all* its nearby flockmates, simply sum
    all the displacement vectors between boid *i* and each boid within radius *R*.
    In other words, *V*[i] = (*P*[i] − *P*[1]) + (*P*[i] − *P*[2]) + . . . (*P*[i]
    − *P*[N]), provided the distance between boids *i* and *j* is less than *R*. You
    can write this more formally as:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何实现鸟群仿真中的三条规则——分离、对齐和聚合——以便在每个时间步重新计算鸟群的速度。我们首先将重点放在分离规则上。目标是为每只鸟群生成一个新的速度向量，使其远离附近的群体伙伴，这些伙伴被定义为位于某个半径
    *R* 内的所有鸟群。给定两只鸟群 *i* 和 *j*，它们的位置分别为 *P*[i] 和 *P*[j]，则 *P*[i] − *P*[j] 会生成一个新的速度向量，使得鸟群
    *i* 向远离鸟群 *j* 的方向移动。我们将其称为 *位移向量*。为了计算鸟群 *i* 的新速度向量 *V*[i]，该速度向量会将其平均推离所有附近的群体伙伴，只需将鸟群
    *i* 与半径 *R* 内每只鸟群的位移向量相加即可。换句话说，*V*[i] = (*P*[i] − *P*[1]) + (*P*[i] − *P*[2])
    + . . . (*P*[i] − *P*[N])，前提是鸟群 *i* 和 *j* 之间的距离小于 *R*。你可以更正式地写成：
- en: '![](images/nsp-venkitachalam503045-m05001.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m05001.jpg)'
- en: Notice that implementing this rule—and, indeed, implementing the other Boids
    rules as well—involves calculating the distance between each boid and every other
    boid to determine which boids are local flockmates. The traditional way to do
    this in Python would be to use a pair of nested loops to iterate through the boids.
    As you’ll see, however, `numpy` arrays provide more efficient methods that bypass
    the need for loops. We’ll implement both approaches and compare the results and
    then apply what we’ve learned to the actual simulation code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，实施这个规则——实际上，实施其他Boids规则——涉及到计算每个boid与每个其他boid之间的距离，以确定哪些boid是局部的群体成员。然而，传统的方法是在Python中使用一对嵌套循环来遍历boids。正如你将看到的，`numpy`数组提供了更高效的方法，可以绕过使用循环的需求。我们将实现两种方法并比较结果，然后将我们学到的应用到实际的仿真代码中。
- en: Using Nested Loops
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用嵌套循环
- en: 'First, let’s define a function `test1()` that implements the separation rule
    in a straightforward way, using loops:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个函数`test1()`，它以一种直接的方式实现分离规则，使用循环：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code uses a nested pair of loops. The outer loop ❶ goes through each boid
    in the `pos` array. The inner loop ❷ computes the distance between the current
    boid and each other boid in the array. If the distance is less than the threshold
    defined as the function’s `radius` parameter ❸, you calculate the displacement
    vector as discussed earlier and add the result to `val` ❹. At the end of each
    cycle of the inner loop, `val` holds a new velocity that will push the current
    boid away from its neighbors. You store that velocity back in the `vel` array.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了一对嵌套的循环。外循环❶遍历`pos`数组中的每个boid。内循环❷计算当前boid与数组中每个其他boid之间的距离。如果距离小于作为函数`radius`参数定义的阈值❸，你就按之前讨论的方式计算位移向量，并将结果添加到`val`❹中。在每次内循环的末尾，`val`保存了一个新的速度，该速度将推动当前boid远离其邻居。你将该速度重新存储回`vel`数组中。
- en: Using numpy Methods
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用numpy方法
- en: 'Now let’s define a function `test2()` that does the same thing “the `numpy`
    way,” avoiding loops and using highly optimized `numpy` methods. You’ll also use
    methods from the `scipy.spatial.distance` module to efficiently calculate the
    distance between points:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个函数`test2()`，它以“`numpy`方式”实现相同的功能，避免使用循环，并利用高度优化的`numpy`方法。你还会使用`scipy.spatial.distance`模块中的方法来高效地计算点之间的距离：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You use the `squareform()` and `pdist()` methods (defined in the `scipy` library)
    to calculate the distances between every possible pair of points in the `pos`
    array ❶. For an array of *N* points, `squareform()` gives you an *N*×*N* matrix,
    where any given entry *M*[ij] is the distance between points *P*[i] and *P*[j].
    Let’s consider a quick example of how that looks. In this code, you call the methods
    on an array of three points:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`scipy`库中的`squareform()`和`pdist()`方法来计算`pos`数组中每一对点之间的距离 ❶。对于一个包含*N*个点的数组，`squareform()`会给出一个*N*×*N*矩阵，其中任意给定的条目*M*[ij]表示点*P*[i]和*P*[j]之间的距离。让我们看一个简单的例子，看看它是如何工作的。在这段代码中，你对包含三个点的数组调用这些方法：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since you provide an array of three points, the result is a 3×3 matrix of distance
    calculations. The values in the first row, for example, tell you the distance
    between the first point (`[0.0, 0.0]`) and each point in the array. The zeros
    running diagonally down the array correspond to the distance between each point
    and itself.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你提供了一个包含三个点的数组，结果是一个3×3的距离计算矩阵。例如，第一行的值告诉你第一个点（`[0.0, 0.0]`）与数组中每个点之间的距离。沿对角线的零值对应于每个点与自身之间的距离。
- en: 'Returning to the `test2()` function, you next filter the matrix based on whether
    the distance is less than the specified `radius` ❷. Using the same example array
    of three points, you have the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`test2()`函数，你接下来根据距离是否小于指定的`radius` ❷来筛选矩阵。以包含三个点的示例数组为例，结果如下：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `<` comparison creates a Boolean matrix of `True/False` values corresponding
    to the original distance matrix—`True` if a distance is less than the given threshold
    (in this example, 1.4).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`<`比较生成一个布尔矩阵，`True/False`值对应于原始距离矩阵——如果距离小于给定阈值（在本例中为1.4），则为`True`。'
- en: 'Back in `test2()`, you use a modified version of the equation for *V*[i] discussed
    earlier, broadcast over the entire `pos` array ❸. That equation can be rewritten
    as:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`test2()`，你使用之前讨论过的*V*[i]方程的修改版，广播到整个`pos`数组 ❸。该方程可以重写为：
- en: '![](images/nsp-venkitachalam503045-m05002.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m05002.jpg)'
- en: 'Here, the second summation term on the right includes only the points *P* that
    satisfy the distance criteria. The number of elements in the summation term is
    *m*. This equation can again be written as:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，右侧的第二个求和项只包括满足距离条件的点 *P*。求和项中的元素个数是 *m*。这个方程可以重新写成：
- en: '![](images/nsp-venkitachalam503045-m05003.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m05003.jpg)'
- en: where *D*[ij] is row *i* of the Boolean matrix you generated ❷, *m* is the number
    of `True` values in that row, and *P*[j] is all the points *P* that fall within
    the specified radius of the current boid.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *D*[ij] 是你生成的布尔矩阵的第 *i* 行 ❷，*m* 是该行中 `True` 值的个数，*P*[j] 是所有在当前鸟群指定半径内的点 *P*。
- en: The `D.sum` method ❸ adds up the `True` values in the Boolean matrix in a column-wise
    fashion, giving you *m* from the equation. The reshape is required because the
    result of the sum is a one-dimensional array of *N* values (shape (*N*, )), and
    you want it to be of shape (*N*, 1) so it’s compatible for multiplication with
    the position array. The `D.dot(pos)` part of the line ❸ is taking the dot product
    (multiplication) of the Boolean matrix and the array of boid positions, which
    corresponds to the *D*[ij]*P*[j] part of the equation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`D.sum` 方法 ❸ 按列的方式将布尔矩阵中的 `True` 值加总，得到方程中的 *m*。之所以需要 reshape，是因为求和的结果是一个一维数组，包含
    *N* 个值（形状为 (*N*, )），而你希望它的形状为 (*N*, 1)，以便与位置数组进行乘法运算。该行的 `D.dot(pos)` 部分则是对布尔矩阵和鸟群位置数组进行点积（乘法），对应方程中的
    *D*[ij]*P*[j] 部分。'
- en: Comparing Approaches
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 比较方法
- en: 'Comparing the two approaches, `test2()` is much more compact than `test1()`,
    but its real advantage is speed. Let’s use the Python `timeit` module to evaluate
    the performance of the two functions. First, enter the code for the functions
    `test1()` and `test2()` in a file named *test.py*, as shown here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 比较这两种方法，`test2()` 比 `test1()` 更紧凑，但它的真正优势在于速度。我们使用 Python 的 `timeit` 模块来评估这两个函数的性能。首先，将
    `test1()` 和 `test2()` 函数的代码输入到名为 *test.py* 的文件中，如下所示：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now use the `timeit` module in a Python interpreter session to compare the
    performance of the two functions:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 Python 解释器会话中使用 `timeit` 模块来比较这两个函数的性能：
- en: '>>> `from` `timeit import timeit`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `from` `timeit import timeit`'
- en: '>>> `timeit(''test1(pos, 100)'', ''from test import test1, N, pos, width, height'',
    number=100)`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `timeit(''test1(pos, 100)'', ''from test import test1, N, pos, width, height'',
    number=100)`'
- en: '7.880876064300537'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '7.880876064300537'
- en: '>>> `timeit(''test2(pos, 100)'', ''from test import test2, N, pos, width, height'',
    number=100)`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `timeit(''test2(pos, 100)'', ''from test import test2, N, pos, width, height'',
    number=100)`'
- en: '0.036969900131225586'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '0.036969900131225586'
- en: On my computer, the `numpy` code without loops runs about 200 times faster than
    the code that uses explicit loops! But why? Aren’t they both doing more or less
    the same thing?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的计算机上，`numpy` 的无循环代码比使用显式循环的代码运行速度快大约 200 倍！但为什么呢？它们不都是在做差不多的事情吗？
- en: As an interpreted language, Python is inherently slower than compiled languages
    like C. The `numpy` library brings the convenience of Python and performance nearly
    equal to that of C by providing highly optimized methods that operate on arrays
    of data. In general, you’ll find that `numpy` works best when you reorganize your
    algorithm as steps that operate on entire arrays at once, without looping through
    individual elements to perform computations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种解释性语言，Python 本身的运行速度比 C 等编译语言慢。`numpy` 库通过提供高效优化的数组操作方法，使 Python 既保持了便利性，又几乎达到了
    C 的性能。通常，当你将算法重新组织成对整个数组一次性操作的步骤，而不是对单独元素进行逐一循环计算时，`numpy` 的效果最好。
- en: Writing the Final Method
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写最终方法
- en: Now that you’ve compared the two approaches, you’re ready to use what you’ve
    learned to write a final version of the method that applies all three rules of
    the simulation and returns updated velocities for all the boids. The `applyRules()`
    method, part of the `Boids` class, uses the optimized `numpy` techniques discussed
    earlier.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经比较了这两种方法，你可以利用所学知识编写一个最终版本的方法，应用模拟的所有三个规则，并返回所有鸟群的更新速度。`applyRules()` 方法是
    `Boids` 类的一部分，采用了前面讨论的优化 `numpy` 技术。
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You compute the pairwise distance matrix between the boids using the `squareform()`
    and `pdist()` methods from the `scipy` library, as discussed earlier ❶. When you
    apply the separation rule using `numpy` methods ❷, each boid is pushed away from
    neighboring boids within a distance of `minDist` (25 pixels). The calculated velocities
    are clamped, or restricted, to a certain maximum value using the `Boids` class’s
    `limit()` method ❸, which we’ll look at later. Without this restriction, the velocities
    would increase with each time step, and the simulation would go haywire.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 `scipy` 库中的 `squareform()` 和 `pdist()` 方法计算 boids 之间的成对距离矩阵，如前所述❶。当你使用 `numpy`
    方法应用分离规则❷时，每个 boid 会被推离距离小于 `minDist`（25 像素）范围内的相邻 boid。计算出的速度会被限制到一个最大值，使用 `Boids`
    类的 `limit()` 方法❸来实现，这部分我们稍后会介绍。如果没有这种限制，速度会随着每个时间步的进行而增加，仿真将会失控。
- en: You next generate a new Boolean matrix using a distance threshold of 50 pixels
    rather than 25 ❹. You’ll use this broader definition of neighboring flockmates
    to apply the alignment and cohesion rules. The alignment rule is implemented so
    that each boid is influenced by and aligns itself with the average velocity of
    its neighbors. You get that average simply by taking the dot product of `D` (the
    Boolean matrix) and the velocity array ❺. Once again, you restrict the calculated
    velocities to a maximum so they don’t increase indefinitely. (Using the compact
    `numpy` syntax makes all these computations simple and fast.)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你生成一个新的布尔矩阵，使用 50 像素的距离阈值，而不是 25 像素❹。你将使用这个更广泛的邻居群体定义来应用对齐和凝聚规则。对齐规则的实现方式是让每个
    boid 受到其邻居平均速度的影响，并与其对齐。你通过将 `D`（布尔矩阵）与速度数组做点积来计算平均速度❺。再次强调，你会限制计算出的速度的最大值，以防它们无限增加。（使用简洁的
    `numpy` 语法让所有这些计算变得既简单又快速。）
- en: Finally, you apply the cohesion rule by adding the positions of all the neighboring
    boids and then subtracting the position of the current boid ❼. This produces a
    velocity vector for each boid that points to the *centroid* or geometric center
    of its neighbors. Again, you limit the velocities to keep them from getting out
    of control.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你通过将所有邻近 boid 的位置加起来，再减去当前 boid 的位置❼来应用凝聚规则。这会产生一个指向邻居 *质心* 或几何中心的速度向量。再次强调，你会限制速度以防它们失控。
- en: Each of the three rules produces its own velocity vector for each boid. At ❻
    and ❽, you add these vectors together, producing an overall velocity vector for
    each boid that reflects the influence of all three simulation rules. You store
    the final velocity vectors in the `vel` array.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每一条规则都会为每个 boid 产生自己的速度向量。在 ❻ 和 ❽ 处，你将这些向量相加，为每个 boid 产生一个整体速度向量，反映所有三个仿真规则的影响。你将最终的速度向量存储在
    `vel` 数组中。
- en: Limiting the Velocities
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 限制速度
- en: 'In the previous section, you saw how the `limit()` method was called after
    applying each rule to keep the boids’ velocities from getting out of control.
    Here’s that method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你看到了在应用每个规则后如何调用 `limit()` 方法，以防止 boids 的速度失控。下面是该方法：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This method is designed to take in an array of velocity vectors, extract each
    individual vector ❶, and pass it along to the `limitVec()` method, which looks
    like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法旨在接受一个速度向量数组，提取每个独立的向量❶，并将其传递给 `limitVec()` 方法，方法如下：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You use the `norm()` function from the `numpy` library to calculate the magnitude
    of the vector ❶. If it exceeds the maximum, you scale the x and y portions of
    the vector in proportion to the vector’s magnitude ❷. The maximum value was defined
    as `self.maxRuleVel = 0.03` as part of the initialization of the `Boids` class.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 `numpy` 库中的 `norm()` 函数计算向量的大小❶。如果它超过最大值，你会按照向量的大小比例缩放向量的 x 和 y 分量❷。最大值被定义为
    `self.maxRuleVel = 0.03`，这是在 `Boids` 类初始化时设置的。
- en: '[Influencing the Simulation](nsp-venkitachalam503045-0008.xhtml#rbh0705)'
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[影响仿真](nsp-venkitachalam503045-0008.xhtml#rbh0705)'
- en: The core rules in the Boids simulation will cause the boids to automatically
    exhibit flocking behavior. But let’s make things more interesting by allowing
    the user to influence the simulation as it runs. Specifically, you’ll create the
    ability to add boids to the flock or make the flock scatter with the click of
    your mouse.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Boids 仿真中的核心规则会导致 boids 自动表现出群聚行为。但为了让事情更有趣，我们允许用户在仿真进行时进行干预。具体来说，你将创建一个功能，允许用户通过点击鼠标向群体中添加
    boids 或让群体散开。
- en: 'The first step to inject events into the simulation while it’s running is to
    add an *event handler* to the `matplotlib` canvas. This is a piece of code that
    calls a function every time a certain event, such as a mouse click, happens. Here’s
    how to do it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 向正在运行的仿真中注入事件的第一步是向 `matplotlib` 画布添加一个 *事件处理程序*。这是一段代码，每当发生某个特定事件（如鼠标点击）时就会调用一个函数。以下是如何操作的：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You use the `mpl_connect()` method to add a button press event handler to the
    `matplotlib` canvas. This handler will call the `buttonPress()` method of the
    `Boids` class every time a mouse button is pressed in the simulation window. Next,
    you need to define the `buttonPress()` method.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用 `mpl_connect()` 方法向 `matplotlib` 画布添加一个按钮按下事件处理程序。每次在仿真窗口中按下鼠标按钮时，这个处理程序都会调用
    `Boids` 类的 `buttonPress()` 方法。接下来，你需要定义 `buttonPress()` 方法。
- en: Adding a Boid
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加一个 Boid
- en: The first part of the `buttonPress()` method adds a boid to the simulation at the
    location of your cursor and assigns that boid a random velocity, when the *left*
    mouse button is pressed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`buttonPress()` 方法的第一部分是在鼠标光标所在的位置将一个 Boid 添加到仿真中，并在按下 *左* 键时为该 Boid 分配一个随机速度。'
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First you ensure that the mouse event is a left-click ❶. Then you append the
    mouse location given by (`event.xdata, event.ydata`) to the array of boid positions
    ❷. You also generate a random velocity vector, add it to the array of boid velocities
    ❸, and increment the count of boids by 1 ❹.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要确保鼠标事件是一次左键点击 ❶。然后，你将鼠标位置（由 `event.xdata, event.ydata` 提供）添加到 Boid 位置数组中
    ❷。你还会生成一个随机速度向量，将其添加到 Boid 速度数组中 ❸，并将 Boid 的数量增加 1 ❹。
- en: Scattering the Boids
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 散开 Boid
- en: 'The three simulation rules keep the boids in a flock as they move around. But
    what happens when the flock is disturbed? To simulate this situation, you can
    introduce a “scatter” effect: when you right-click in the simulation window, the
    flock will scatter from the location of the click. You can think of this as how
    the flock might respond to the sudden appearance of a predator or a loud noise
    that spooks the birds. You implement this effect as a continuation of the `buttonPress()`
    method:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个仿真规则保证 Boid 在移动过程中保持成群。然而，当群体受到干扰时会发生什么呢？为了模拟这种情况，你可以引入一个“散开”效果：当你在仿真窗口右键点击时，群体会从点击位置散开。你可以将其想象为群体如何应对捕食者的突然出现或吓到鸟群的巨响。你可以将这个效果作为
    `buttonPress()` 方法的延续来实现：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here you check whether the mouse button press is a right-click event ❶. If so,
    you change the velocity for every boid by adding a vector that points away from
    the point where the disturbance arose (that is, where the mouse was clicked).
    You calculate this vector much like you calculated the displacement vectors for
    the separation rule. If *P*[i] is the position of a boid and *P*[m] is the point
    where the mouse was clicked, *P*[i] − *P*[m] is a vector that points away from
    the mouse click. You multiply this vector by `0.1` to keep the magnitude of the
    disturbance small. Initially, the boids will fly away from that point, but as
    you’ll see, the three rules prevail, and the boids will coalesce again as a flock.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你检查鼠标按钮按下事件是否是右键点击事件 ❶。如果是，你会通过添加一个指向干扰发生点（即鼠标点击位置）的向量来改变每个 Boid 的速度。你可以像计算分离规则的位移向量那样计算这个向量。如果
    *P*[i] 是一个 Boid 的位置，而 *P*[m] 是鼠标点击的点，那么 *P*[i] − *P*[m] 就是一个指向鼠标点击位置的向量。你将这个向量乘以
    `0.1` 来保持干扰的幅度较小。最初，Boid 会飞离那个点，但正如你将看到的，三个规则仍然占主导地位，Boid 将重新聚集成一个群体。
- en: '[Incrementing the Simulation](nsp-venkitachalam503045-0008.xhtml#rbh0706)'
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[增加仿真事件](nsp-venkitachalam503045-0008.xhtml#rbh0706)'
- en: At each time step in the simulation, you need to apply the rules to calculate
    the boids’ new velocities, update the boids’ positions based on those velocities,
    enforce the boundary conditions, and redraw everything in the display window.
    You can coordinate all this activity from the `tick()` function, which will be
    called at each frame of the `matplotlib` animation.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个仿真步骤中，你需要应用这些规则来计算 Boid 的新速度，根据这些速度更新 Boid 的位置，强制执行边界条件，并在显示窗口中重新绘制所有内容。你可以通过
    `tick()` 函数来协调所有这些活动，它将在每帧 `matplotlib` 动画中被调用。
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The stand-alone `tick()` function simply calls the `tick()` method of the `Boids`
    class. The latter is defined as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 独立的 `tick()` 函数只是调用 `Boids` 类的 `tick()` 方法。后者定义如下：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This method is where everything comes together. You apply the boid rules using
    the `applyRules()` method that we already looked at ❶. Then you limit the computed
    velocities of the boids using the `self.maxVel` threshold ❷. (Even though you
    limited the velocity vector generated by each individual rule, the overall velocity
    determined by adding all three rules together may still be too large.) You next
    compute the updated positions of the boids by adding the new velocity vectors
    to the old array of positions ❸. For example, if a boid was at position [0, 0]
    and has a velocity vector of [1, 1], its new position after one time step would
    be [1, 1]. You apply the boundary conditions for the simulation by calling `applyBC()`
    ❹.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是将一切整合在一起的地方。你使用我们之前看过的 `applyRules()` 方法来应用 boid 规则 ❶。然后，使用 `self.maxVel`
    阈值限制计算出的 boid 速度 ❷。（即使你限制了每个单独规则生成的速度向量，通过将所有三个规则加在一起得到的整体速度可能仍然过大。）接下来，你通过将新的速度向量加到旧的位置信息数组中来计算
    boids 的更新位置 ❸。例如，如果一个 boid 的位置是 [0, 0]，并且它的速度向量是 [1, 1]，那么在一个时间步之后，它的新位置将是 [1,
    1]。你通过调用 `applyBC()` 来应用仿真的边界条件 ❹。
- en: The call to `pts.set_data()` ❺ updates the `matplotlib` axis with the boids’
    new positions. The `[::2]` picks out the even-numbered elements (x-axis values)
    from the `pos` array, and the `[1::2]` picks out the odd-numbered elements (y-axis
    values). This will redraw the larger circles representing the boids’ bodies. Next,
    you need to draw the smaller circles representing the boids’ heads. You calculate
    the position of each boid’s head so it will point in the boid’s direction of motion
    by applying the *H* = *P* + *k* × *V* formula discussed earlier ❻. Recall that
    *P* is the center of a boid’s body, *k* is a constant representing the distance
    from the center of the body to the center of the head (you use a value of 10 units),
    and *V* is the boid’s velocity. Once you have the new head positions, you draw
    them via the same technique you used to draw the bodies ❼.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `pts.set_data()` ❺ 会使用 boids 的新位置更新 `matplotlib` 坐标轴。`[::2]` 从 `pos` 数组中选择偶数索引的元素（x
    轴值），而 `[1::2]` 选择奇数索引的元素（y 轴值）。这将重新绘制表示 boids 身体的较大圆圈。接下来，你需要绘制表示 boids 头部的较小圆圈。你通过应用之前讨论的
    *H* = *P* + *k* × *V* 公式来计算每个 boid 头部的位置，使其指向 boid 的运动方向 ❻。回想一下，*P* 是 boid 身体的中心，*k*
    是一个常数，表示从身体中心到头部中心的距离（你使用 10 个单位的值），*V* 是 boid 的速度。一旦你获得了新的头部位置，就可以通过与绘制身体时相同的技巧来绘制它们
    ❼。
- en: '[Parsing Arguments and Instantiating the Boids](nsp-venkitachalam503045-0008.xhtml#rbh0707)'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[解析参数并实例化 Boids 类](nsp-venkitachalam503045-0008.xhtml#rbh0707)'
- en: 'The program’s `main()` function begins by handling command line arguments and
    instantiating the `Boids` class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的 `main()` 函数首先处理命令行参数，并实例化 `Boids` 类：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You use the familiar `argparse` module to create a command line option for setting
    the initial number of boids in the simulation ❶. If no argument is provided at
    the command line, the simulation defaults to 100 boids ❷. You set the simulation
    in motion by creating an object of the `Boids` class ❸.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用熟悉的 `argparse` 模块创建命令行选项，用于设置仿真中的初始 boid 数量 ❶。如果命令行没有提供参数，则仿真默认使用 100 个 boid
    ❷。通过创建一个 `Boids` 类的对象，你可以启动仿真 ❸。
- en: The `main()` function continues with the code to create and animate a `matplotlib`
    plot. We’ve already discussed this code in [“Plotting the Boid’s Body and Head”](nsp-venkitachalam503045-0017.xhtml#ch0701)
    on [page 84](nsp-venkitachalam503045-0017.xhtml#p84).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数继续执行创建和动画化 `matplotlib` 图表的代码。我们已经在 [“绘制 Boid 的身体和头部”](nsp-venkitachalam503045-0017.xhtml#ch0701)
    这一节中讨论过这些代码，详见 [第 84 页](nsp-venkitachalam503045-0017.xhtml#p84)。'
- en: '[Running the Boids Simulation](nsp-venkitachalam503045-0008.xhtml#rah0704)'
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行 Boids 仿真](nsp-venkitachalam503045-0008.xhtml#rah0704)'
- en: 'Let’s see what happens when you run the simulation. Enter the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看运行仿真时会发生什么。输入以下命令：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The Boids simulation should start with all the boids clustered around the center
    of the window. Let the simulation run for a while, and the boids should start
    to flock as they form a pattern similar to the one shown in [Figure 5-4](nsp-venkitachalam503045-0017.xhtml#fig5-4).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Boids 仿真应该以所有 boid 集中在窗口中心的状态开始。让仿真运行一段时间，boid 会开始聚集成群，形成类似于 [图 5-4](nsp-venkitachalam503045-0017.xhtml#fig5-4)
    所示的图案。
- en: '![](images/nsp-venkitachalam503045-f05004.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f05004.jpg)'
- en: 'Figure 5-4: A sample run of the Boids simulation'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-4：Boids 仿真的一次示例运行
- en: Left-click the simulation window. A new boid should appear at that location,
    and its velocity should change as it encounters the flock. Now right-click. The
    flock should initially scatter from your cursor but then recoalesce.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 左键单击模拟窗口。新的 boid 应该出现在该位置，并且当它遇到鸟群时，它的速度应该发生变化。现在右键单击。鸟群应该最初从光标散开，但随后重新聚集。
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah0705)'
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[总结](nsp-venkitachalam503045-0008.xhtml#rah0705)'
- en: In this project, you simulated the flocking of birds (or boids) using the three
    rules proposed by Craig Reynolds. You looked at how operating on an entire `numpy`
    array at once is much faster than performing the same operations inside an explicit
    loop. You used the `scipy.spatial` module to perform fast and convenient distance
    calculations, and you implemented a `matplotlib` trick that uses two markers to
    represent both the position and the direction of points. Finally, you added interactivity
    to the simulation in the form of an event handler to respond to button presses
    within the `matplotlib` plot.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你使用 Craig Reynolds 提出的三条规则模拟了鸟群（或 boids）的聚集。你观察到一次性操作整个 `numpy` 数组比在显式循环中执行相同的操作要快得多。你使用了
    `scipy.spatial` 模块来执行快速且方便的距离计算，并实现了一个 `matplotlib` 技巧，使用两个标记表示点的位置和方向。最后，你通过在
    `matplotlib` 图形中添加事件处理程序，增加了与按钮按下的交互性。
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah0706)'
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实验！](nsp-venkitachalam503045-0008.xhtml#rah0706)'
- en: 'Here are some ways you might further explore flocking behavior:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些方法可以进一步探索群体行为：
- en: '1\. Implement obstacle avoidance for your flock of boids by writing a new method
    called `avoidObstacle()` and applying it right after you apply the three rules,
    as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 通过编写一个新的方法 `avoidObstacle()` 来实现你的 boid 群体的障碍物回避功能，并在应用三条规则后立即应用该方法，如下所示：
- en: '[PRE21]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `avoidObstacle()` method should use a predefined tuple (*x*, *y*, *R*) to
    add an additional velocity term to a boid, pushing it away from the obstacle location
    (*x*, *y*), but only when the boid is within radius *R* of the obstacle. Think
    of this as the distance at which a boid sees the obstacle and steers away from
    it. You can specify the (*x*, *y*, *R*) tuple using a command line option.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`avoidObstacle()` 方法应该使用预定义的元组 (*x*, *y*, *R*)，为 boid 添加一个额外的速度项，将其推离障碍物位置
    (*x*, *y*)，但仅当 boid 位于障碍物半径 *R* 内时才有效。可以将其视为 boid 看到障碍物并从其方向偏移的距离。你可以通过命令行选项指定
    (*x*, *y*, *R*) 元组。'
- en: 2\. What happens when the boids fly through a strong gust of wind? Simulate
    this by adding a global velocity component to all the boids at random time steps
    in the simulation. The boids should temporarily be affected by the wind but return
    to the flock once the wind stops.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 当 boids 穿越强风时会发生什么？通过在模拟中的随机时间步骤为所有 boid 添加一个全局速度分量来模拟这一点。boids 应该暂时受到风的影响，但一旦风停了，它们应该恢复到原来的聚集状态。
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah0707)'
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整代码](nsp-venkitachalam503045-0008.xhtml#rah0707)'
- en: 'Here’s the complete code for the Boids simulation:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Boids 模拟的完整代码：
- en: '"""'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: boids.py
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: boids.py
- en: An implementation of Craig Reynolds's Boids simulation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Craig Reynolds 的 Boids 模拟实现。
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：Mahesh Venkitachalam
- en: '"""'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: import argparse
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: import argparse
- en: import math
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: import math
- en: import numpy as np
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: import matplotlib.pyplot as plt
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.pyplot as plt
- en: import matplotlib.animation as animation
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.animation as animation
- en: from scipy.spatial.distance import squareform, pdist
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: from scipy.spatial.distance import squareform, pdist
- en: from numpy.linalg import norm
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: from numpy.linalg import norm
- en: width, height = 640, 480
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度，高度 = 640, 480
- en: 'class Boids:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Boids:'
- en: '"""class that represents Boids simulation"""'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '"""表示 Boids 模拟的类"""'
- en: 'def __init__(self, N):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, N):'
- en: '"""initialize the Boids simulation"""'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '"""初始化 Boids 模拟"""'
- en: '# init position & velocities'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化位置和速度'
- en: self.pos = [width/2.0, height/2.0] +
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: self.pos = [width/2.0, height/2.0] +
- en: 10*np.random.rand(2*N).reshape(N, 2)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 10*np.random.rand(2*N).reshape(N, 2)
- en: '# normalized random velocities'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '# 标准化的随机速度'
- en: angles = 2*math.pi*np.random.rand(N)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: angles = 2*math.pi*np.random.rand(N)
- en: self.vel = np.array(list(zip(np.cos(angles), np.sin(angles))))
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: self.vel = np.array(list(zip(np.cos(angles), np.sin(angles))))
- en: self.N = N
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: self.N = N
- en: '# min dist of approach'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '# 最小接近距离'
- en: self.minDist = 25.0
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: self.minDist = 25.0
- en: '# max magnitude of velocities calculated by "rules"'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '# 通过“规则”计算的速度最大大小'
- en: self.maxRuleVel = 0.03
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: self.maxRuleVel = 0.03
- en: '# max magnitude of final velocity'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '# 最终速度的最大大小'
- en: self.maxVel = 2.0
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: self.maxVel = 2.0
- en: 'def tick(self, frameNum, pts, head):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 'def tick(self, frameNum, pts, head):'
- en: '"""update the simulation by one time step"""'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '"""通过一个时间步长更新模拟"""'
- en: '# apply rules'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用规则'
- en: self.vel += self.applyRules()
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: self.vel += self.applyRules()
- en: self.limit(self.vel, self.maxVel)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: self.limit(self.vel, self.maxVel)
- en: self.pos += self.vel
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: self.pos += self.vel
- en: self.applyBC()
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: self.applyBC()
- en: '# update data'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '# 更新数据'
- en: pts.set_data(self.pos.reshape(2*self.N)[::2],
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: pts.set_data(self.pos.reshape(2*self.N)[::2],
- en: self.pos.reshape(2*self.N)[1::2])
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: self.pos.reshape(2*self.N)[1::2])
- en: vec = self.pos + 10*self.vel/self.maxVel
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: vec = self.pos + 10*self.vel/self.maxVel
- en: head.set_data(vec.reshape(2*self.N)[::2],
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: head.set_data(vec.reshape(2*self.N)[::2],
- en: vec.reshape(2*self.N)[1::2])
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: vec.reshape(2*self.N)[1::2])
- en: 'def limitVec(self, vec, maxVal):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 'def limitVec(self, vec, maxVal):'
- en: '"""limit magnitude of 2D vector"""'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '"""限制二维向量的大小"""'
- en: mag = norm(vec)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: mag = norm(vec)
- en: 'if mag > maxVal:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'if mag > maxVal:'
- en: vec[0], vec[1] = vec[0]*maxVal/mag, vec[1]*maxVal/mag
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: vec[0], vec[1] = vec[0]*maxVal/mag, vec[1]*maxVal/mag
- en: 'def limit(self, X, maxVal):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 'def limit(self, X, maxVal):'
- en: '"""limit magnitude of 2D vectors in array X to maxValue"""'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '"""限制数组 X 中二维向量的大小至 maxValue"""'
- en: 'for vec in X:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 'for vec in X:'
- en: self.limitVec(vec, maxVal)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: self.limitVec(vec, maxVal)
- en: 'def applyBC(self):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 'def applyBC(self):'
- en: '"""apply boundary conditions"""'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '"""应用边界条件"""'
- en: deltaR = 2.0
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: deltaR = 2.0
- en: 'for coord in self.pos:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'for coord in self.pos:'
- en: 'if coord[0] > width + deltaR:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 'if coord[0] > width + deltaR:'
- en: coord[0] = - deltaR
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: coord[0] = - deltaR
- en: 'if coord[0] < - deltaR:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 'if coord[0] < - deltaR:'
- en: coord[0] = width + deltaR
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: coord[0] = width + deltaR
- en: 'if coord[1] > height + deltaR:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 'if coord[1] > height + deltaR:'
- en: coord[1] = - deltaR
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: coord[1] = - deltaR
- en: 'if coord[1] < - deltaR:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 'if coord[1] < - deltaR:'
- en: coord[1] = height + deltaR
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: coord[1] = height + deltaR
- en: 'def applyRules(self):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 'def applyRules(self):'
- en: '# get pairwise distances'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取成对的距离'
- en: self.distMatrix = squareform(pdist(self.pos))
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: self.distMatrix = squareform(pdist(self.pos))
- en: '# apply rule #1 - separation'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用规则 #1 - 分离'
- en: D = self.distMatrix < self.minDist
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: D = self.distMatrix < self.minDist
- en: vel = self.pos*D.sum(axis=1).reshape(self.N, 1) - D.dot(self.pos)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: vel = self.pos*D.sum(axis=1).reshape(self.N, 1) - D.dot(self.pos)
- en: self.limit(vel, self.maxRuleVel)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: self.limit(vel, self.maxRuleVel)
- en: '# different distance threshold'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '# 不同的距离阈值'
- en: D = self.distMatrix < 50.0
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: D = self.distMatrix < 50.0
- en: '# apply rule #2 - alignment'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用规则 #2 - 对齐'
- en: vel2 = D.dot(self.vel)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: vel2 = D.dot(self.vel)
- en: self.limit(vel2, self.maxRuleVel)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: self.limit(vel2, self.maxRuleVel)
- en: vel += vel2;
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: vel += vel2;
- en: '# apply rule #1 - cohesion'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用规则 #1 - 凝聚'
- en: vel3 = D.dot(self.pos) - self.pos
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: vel3 = D.dot(self.pos) - self.pos
- en: self.limit(vel3, self.maxRuleVel)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: self.limit(vel3, self.maxRuleVel)
- en: vel += vel3
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: vel += vel3
- en: return vel
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: return vel
- en: 'def buttonPress(self, event):'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 'def buttonPress(self, event):'
- en: '"""event handler for matplotlib button presses"""'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '"""matplotlib 按钮点击事件处理器"""'
- en: '# left-click - add a boid'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '# 左键点击 - 添加一个 Boid'
- en: 'if event.button == 1:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'if event.button == 1:'
- en: self.pos = np.concatenate((self.pos,
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: self.pos = np.concatenate((self.pos,
- en: np.array([[event.xdata, event.ydata]])),
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: np.array([[event.xdata, event.ydata]])),
- en: axis=0)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: axis=0)
- en: '# random velocity'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '# 随机速度'
- en: angles = 2*math.pi*np.random.rand(1)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: angles = 2*math.pi*np.random.rand(1)
- en: v = np.array(list(zip(np.sin(angles), np.cos(angles))))
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: v = np.array(list(zip(np.sin(angles), np.cos(angles))))
- en: self.vel = np.concatenate((self.vel, v), axis=0)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: self.vel = np.concatenate((self.vel, v), axis=0)
- en: self.N += 1
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: self.N += 1
- en: '# right-click - scatter'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '# 右键点击 - 散布'
- en: 'elif event.button == 3:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif event.button == 3:'
- en: '# add scattering velocity'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加散布速度'
- en: self.vel += 0.1*(self.pos - np.array([[event.xdata, event.ydata]]))
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: self.vel += 0.1*(self.pos - np.array([[event.xdata, event.ydata]]))
- en: 'def tick(frameNum, pts, head, boids):'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 'def tick(frameNum, pts, head, boids):'
- en: '"""update function for animation"""'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '"""动画更新函数"""'
- en: boids.tick(frameNum, pts, head)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: boids.tick(frameNum, pts, head)
- en: return pts, head
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: return pts, head
- en: main() function
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: main() function
- en: 'def main():'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '# use sys.argv if needed'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果需要，使用 sys.argv'
- en: print('starting boids...')
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: print('启动 Boids...')
- en: parser = argparse.ArgumentParser(description=
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: parser = argparse.ArgumentParser(description=
- en: '"Implementing Craig Reynolds''s Boids...")'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '"实现 Craig Reynolds 的 Boids...")'
- en: '# add arguments'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加参数'
- en: parser.add_argument('--num-boids', dest='N', required=False)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--num-boids', dest='N', required=False)
- en: args = parser.parse_args()
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: args = parser.parse_args()
- en: '# number of boids'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '# Boid 数量'
- en: N = 100
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: N = 100
- en: 'if args.N:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.N:'
- en: N = int(args.N)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: N = int(args.N)
- en: '# create boids'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建 Boids'
- en: boids = Boids(N)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: boids = Boids(N)
- en: '# setup plot'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置图表'
- en: fig = plt.figure()
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: fig = plt.figure()
- en: ax = plt.axes(xlim=(0, width), ylim=(0, height))
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ax = plt.axes(xlim=(0, width), ylim=(0, height))
- en: pts = ax.plot([], [], markersize=10,
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: pts = ax.plot([], [], markersize=10,
- en: c='k', marker='o', ls='None')
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: c='k', marker='o', ls='None')
- en: head, = ax.plot([], [], markersize=4,
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: head, = ax.plot([], [], markersize=4,
- en: c='r', marker='o', ls='None')
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: c='r', marker='o', ls='None')
- en: anim = animation.FuncAnimation(fig, tick, fargs=(pts[0], head, boids),
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: anim = animation.FuncAnimation(fig, tick, fargs=(pts[0], head, boids),
- en: interval=50)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: interval=50)
- en: '# add a "button press" event handler'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加 "按钮点击" 事件处理器'
- en: cid = fig.canvas.mpl_connect('button_press_event', boids.buttonPress)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: cid = fig.canvas.mpl_connect('button_press_event', boids.buttonPress)
- en: plt.show()
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: call main
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: call main
- en: 'if __name__ == ''__main__'':'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: main()
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: main()
