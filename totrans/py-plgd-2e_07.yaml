- en: '[5](nsp-venkitachalam503045-0008.xhtml#rch05)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[5](nsp-venkitachalam503045-0008.xhtml#rch05)'
- en: Flocking Boids
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鸟群行为
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: Look closely at a flock of birds or a school of fish, and you’ll notice that
    although the group is composed of individual creatures, the group as a whole seems
    to have a life of its own. The birds in a flock align with each other as they
    move and flow over and around obstacles. They break formation when disturbed or
    startled, but then they regroup, as if controlled by some larger force.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察一群鸟或一群鱼，你会注意到，尽管这个群体由个体组成，但整体看起来似乎有一种生命力。鸟群中的鸟儿在移动时会彼此对齐，并绕过障碍物。它们在受到干扰或惊吓时会打破队形，但随后会重新聚集，仿佛被某种更大的力量控制。
- en: In 1986, Craig Reynolds created a realistic-looking simulation of the flocking
    behavior of birds called the *Boids model*. One remarkable thing about the Boids
    model (named after the stereotypical New Yorker’s pronunciation of the word *birds*)
    is that only three simple rules govern the interaction between individuals in
    the flock, yet the model produces remarkably realistic flocking behavior. The
    Boids model is widely studied and has even been used to animate computer-generated
    swarms like the marching penguins in the movie *Batman Returns* (1992).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 1986 年，克雷格·雷诺兹创造了一个逼真的鸟群行为模拟，称为 *Boids 模型*。Boids 模型（其名称源于典型纽约人对“birds”一词的发音）的一大亮点是，群体个体之间的互动只受三条简单规则的控制，但模型却能产生极为真实的鸟群行为。Boids
    模型被广泛研究，甚至被用来为计算机生成的群体动画，如电影 *蝙蝠侠归来*（1992）中的行进企鹅，提供动画效果。
- en: In this project, you’ll use Reynolds’s three rules to create a Boids simulation
    of the flocking behavior of *N* birds and plot their positions and directions
    of movement over time. You’ll also provide a method to add a bird to the flock,
    as well as a scatter effect that you can use to study the impact of a local disturbance
    on the flock. Boids is called an *N*-body simulation because it models a dynamic
    system of *N* particles that exert forces on each other.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用雷诺兹的三条规则，创建一个模拟鸟群行为的 Boids 模拟，展示 *N* 只鸟的群体行为，并绘制它们的位置和运动方向随时间变化的图像。你还将提供一种方法来向群体中添加一只鸟，以及一种散射效果，帮助你研究局部干扰对群体的影响。Boids
    被称为 *N* 体模拟，因为它模拟了一个由 *N* 个粒子相互作用的动态系统。
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah0701)'
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[它是如何工作的](nsp-venkitachalam503045-0008.xhtml#rah0701)'
- en: 'The three core rules of the Boids simulation are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Boids 模拟的三条核心规则如下：
- en: Separation Keep a minimum distance between the boids.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 分离：保持群体成员之间的最小距离。
- en: Alignment Point each boid in the average direction of movement of its local
    flockmates.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐：将每只鸟指向其本地群体成员的平均运动方向。
- en: Cohesion Move each boid toward the center of mass of its local flockmates.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 凝聚力：将每只鸟移向其本地群体的质心。
- en: 'Boids simulations can add other rules too, such as ones to avoid obstacles
    or scatter the flock when it’s disturbed, as you’ll learn in the following sections.
    To create the Boids animation, you’ll do the following for every time step in
    the simulation:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Boids 模拟还可以添加其他规则，例如避开障碍物的规则，或当群体受到干扰时将其分散的规则，正如你在接下来的章节中将学到的。为了创建 Boids 动画，你将在每个时间步长中执行以下操作：
- en: '1\. For all boids in the flock:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 对所有群体中的鸟类执行以下操作：
- en: a. Apply the three core rules.
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: a. 应用三条核心规则。
- en: b. Apply any additional rules.
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: b. 应用任何附加规则。
- en: c. Apply all boundary conditions.
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: c. 应用所有边界条件。
- en: 2\. Update the positions and velocities of the boids.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 更新鸟群的位置和速度。
- en: 3\. Plot the new positions and velocities.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 绘制新的位置和速度。
- en: As you’ll see, these simple steps create a flock with evolving, complex behavior.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将看到的，这些简单的步骤创造了一个群体，展现出不断演变的复杂行为。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah0702)'
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[需求](nsp-venkitachalam503045-0008.xhtml#rah0702)'
- en: 'These are the Python modules you’ll be using in this simulation:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你将在此模拟中使用的 Python 模块：
- en: • `numpy` arrays to store the positions and velocities of the boids
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `numpy` 数组，用于存储鸟群的位置和速度
- en: • The `matplotlib` library to animate the boids
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `matplotlib` 库，用于对群体进行动画处理
- en: • `argparse` to process command line options
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `argparse` 用于处理命令行选项
- en: • The `scipy.spatial.distance` module, which has some really neat methods for
    calculating distances between points
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • `scipy.spatial.distance` 模块，它具有一些非常巧妙的方法来计算点之间的距离
- en: I chose to use `matplotlib` for boids as a matter of simplicity and convenience.
    To draw a huge number of boids as quickly as possible, you might use something
    like the OpenGL library. We’ll explore graphics in more detail in [Part III](nsp-venkitachalam503045-0018.xhtml#pt03)
    of this book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择使用`matplotlib`来实现 boids，主要是出于简单性和方便性考虑。如果你想尽可能快速地绘制大量 boids，可能会使用类似 OpenGL
    的库。我们将在本书的[第三部分](nsp-venkitachalam503045-0018.xhtml#pt03)中详细探讨图形部分。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah0703)'
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah0703)'
- en: You’ll encapsulate the behavior of a group of boids in a class called `Boids`.
    First you’ll set the initial positions and velocities of the boids. Next, you’ll
    set up the boundary conditions for the simulation, look at how the boids are drawn,
    and implement the Boids simulation rules discussed earlier. Finally, you’ll add
    some interesting events to the simulation by allowing the user to add boids and
    scatter the flock. To see the full project code, skip ahead to [“The Complete
    Code”](nsp-venkitachalam503045-0017.xhtml#ah0707) on [page 96](nsp-venkitachalam503045-0017.xhtml#p96).
    You can also download it from the book’s GitHub repository at [https://github.com/mkvenkit/pp2e/blob/main/boids/boids.py](https://github.com/mkvenkit/pp2e/blob/main/boids/boids.py).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你将把一群 boids 的行为封装在一个名为 `Boids` 的类中。首先，你会设置 boids 的初始位置和速度。接着，你将设置仿真的边界条件，查看
    boids 是如何绘制的，并实现之前讨论过的 Boids 仿真规则。最后，你会通过允许用户添加 boids 和散布鸟群来给仿真增添一些有趣的事件。要查看完整的项目代码，可以跳到[“完整代码”](nsp-venkitachalam503045-0017.xhtml#ah0707)部分，位于[第96页](nsp-venkitachalam503045-0017.xhtml#p96)。你也可以从本书的
    GitHub 仓库下载代码：[https://github.com/mkvenkit/pp2e/blob/main/boids/boids.py](https://github.com/mkvenkit/pp2e/blob/main/boids/boids.py)。
- en: '[Initializing the Simulation](nsp-venkitachalam503045-0008.xhtml#rbh0701)'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[初始化仿真](nsp-venkitachalam503045-0008.xhtml#rbh0701)'
- en: The Boids simulation needs to compute the position and velocities of the boids
    at each step by pulling information from `numpy` arrays. At the beginning of the
    simulation, you use the `Boids` class’s `__init__()` method to create those arrays
    and initialize all boids in approximately the center of the screen, with their
    velocities set in random directions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Boids 仿真需要在每一步中计算 boids 的位置和速度，方法是从 `numpy` 数组中获取信息。在仿真开始时，你会使用 `Boids` 类的 `__init__()`
    方法来创建这些数组，并将所有 boids 初始化在屏幕的中央，速度则随机设置。
- en: import argparse
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: import argparse
- en: import math
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: import math
- en: import numpy as np
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: import matplotlib.pyplot as plt
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.pyplot as plt
- en: import matplotlib.animation as animation
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.animation as animation
- en: from scipy.spatial.distance import squareform, pdist
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: from scipy.spatial.distance import squareform, pdist
- en: from numpy.linalg import norm
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: from numpy.linalg import norm
- en: ❶ width, height = 640, 480
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ width, height = 640, 480
- en: 'class Boids:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Boids:'
- en: '"""class that represents Boids simulation"""'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '"""表示 Boids 仿真的类"""'
- en: 'def __init__(self, N):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, N):'
- en: '"""initialize the Boids simulation"""'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '"""初始化 Boids 仿真"""'
- en: '# init position & velocities'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化位置和速度'
- en: ❷ self.pos = [width/2.0, height/2.0] +
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ self.pos = [width/2.0, height/2.0] +
- en: 10*np.random.rand(2*N).reshape(N, 2)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 10*np.random.rand(2*N).reshape(N, 2)
- en: '# normalized random velocities'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '# 标准化随机速度'
- en: ❸ angles = 2*math.pi*np.random.rand(N)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ angles = 2*math.pi*np.random.rand(N)
- en: ❹ self.vel = np.array(list(zip(np.cos(angles), np.sin(angles))))
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ self.vel = np.array(list(zip(np.cos(angles), np.sin(angles))))
- en: self.N = N
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: self.N = N
- en: 'First you import the modules required for the program and set the width and
    height of the simulation window on the screen ❶. Then you begin declaring the
    `Boids` class. Within the class’s `__init__()` method, you create a `numpy` array
    called `pos` to store the x- and y-coordinates of all the boids ❷. For the initial
    value of each pair of coordinates, you start with the center of the window, `[width/2.0,
    height/2.0]`, and add a random displacement of up to 10 units. The code `np.random.rand(2*N)`
    creates a one-dimensional array of 2*N* random numbers in the range [0, 1], which
    you multiply by 10 to scale to a range of [0, 10]. The `reshape()` call converts
    the one-dimensional array into a two-dimensional array of shape (*N*, 2), perfect
    for storing *N* pairs of x- and y-coordinates. Notice, too, the `numpy` broadcasting
    rules in action here: the 1×2 array `[width/2.0, height/2.0]` representing the
    center of the window is added to each element in the *N*×2 array to randomly offset
    each boid’s position from the center.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你导入程序所需的模块，并设置屏幕上仿真窗口的宽度和高度❶。然后，你开始声明`Boids`类。在类的`__init__()`方法内，你创建一个名为`pos`的`numpy`数组，用于存储所有鸟群个体的x和y坐标❷。对于每对坐标的初始值，你从窗口的中心`[width/2.0,
    height/2.0]`开始，并添加一个最大为10个单位的随机位移。代码`np.random.rand(2*N)`生成一个包含2*N个随机数字的一维数组，数字范围在[0,
    1]之间，你将其乘以10来调整范围至[0, 10]。`reshape()`调用将一维数组转换为形状为(*N*, 2)的二维数组，非常适合存储*N*对x和y坐标。请注意这里`numpy`广播规则的应用：表示窗口中心的1×2数组`[width/2.0,
    height/2.0]`被添加到*N*×2数组中的每个元素中，从而随机偏移每个鸟群个体的位置。
- en: 'Next, you create an array of random unit velocity vectors (these are vectors
    of magnitude 1.0, pointing in random directions) for each boid using the following
    method: given an angle *t*, the pair of numbers (cos(*t*), sin(*t*)) lie on a
    circle of radius 1.0, centered at the origin (0, 0). If you draw a line from the
    origin to a point on this circle, it becomes a unit vector that depends on the
    angle *t*. So if you choose *t* at random, you end up with a random velocity vector.
    [Figure 5-1](nsp-venkitachalam503045-0017.xhtml#fig5-1) illustrates this scheme.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你使用以下方法为每个鸟群个体（boid）创建一个随机单位速度向量（这些向量的大小为1.0，指向随机方向）：给定一个角度*t*，数字对(cos(*t*),
    sin(*t*))位于以原点(0, 0)为圆心，半径为1.0的圆上。如果你从原点画一条线到圆上的某个点，它就变成一个单位向量，依赖于角度*t*。因此，如果你随机选择*t*，最终就会得到一个随机速度向量。[图5-1](nsp-venkitachalam503045-0017.xhtml#fig5-1)说明了这一方案。
- en: '![](images/nsp-venkitachalam503045-f05001.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f05001.jpg)'
- en: 'Figure 5-1: Generating random unit velocity vectors'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-1：生成随机单位速度向量
- en: Returning to the code, you put this method into action by first generating an
    array of *N* random angles in the range [0, 2π] ❸. Then you create an array of
    random unit velocity vectors by calculating the cosine and sine of those angles
    ❹. You group the coordinates of each vector using Python’s built-in `zip()` method.
    The following is a simple example of `zip()`. This joins two lists into a list
    of tuples. The `list()` is needed because just calling `zip` will create only
    an iterator—you need all the elements in the list.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到代码中，你通过首先生成一个包含*N*个随机角度的数组，角度范围在[0, 2π]之间，来启动此方法❸。然后，你通过计算这些角度的余弦和正弦，创建一个随机单位速度向量的数组❹。你使用
    Python 内置的`zip()`方法将每个向量的坐标组合在一起。以下是`zip()`的一个简单示例，它将两个列表合并成一个元组列表。因为仅调用`zip`会创建一个迭代器，所以需要使用`list()`来将其转化为列表，确保你得到所有元素。
- en: '>>> list(`zip([0, 1, 2], [3, 4, 5]))`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> list(`zip([0, 1, 2], [3, 4, 5]))`'
- en: '[(0, 3), (1, 4), (2, 5)]'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[(0, 3), (1, 4), (2, 5)]'
- en: In summary, you’ve generated two arrays that will be useful throughout the simulation,
    `pos` and `vel`. The first contains random positions clustered within a 10-pixel
    radius around the center of the screen, and the second contains unit velocities
    pointing in random directions. This means that at the start of the simulation,
    the boids will all hover around the center of the screen, pointed in random directions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，你已经生成了两个将在整个仿真中有用的数组，`pos`和`vel`。第一个包含随机位置，集中在屏幕中心10像素的半径范围内，第二个包含指向随机方向的单位速度。这意味着在仿真开始时，所有的鸟群个体都会围绕屏幕中心悬停，并朝着随机方向飞行。
- en: 'The `__init__()` method continues by declaring some constant values that will
    help govern the simulation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()`方法继续声明一些常量值，这些值将有助于控制仿真：'
- en: '# min dist of approach'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '# 最小接近距离'
- en: ❶ self.minDist = 25.0
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ self.minDist = 25.0
- en: '# max magnitude of velocities calculated by "rules"'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '# "规则"计算的最大速度大小'
- en: ❷ self.maxRuleVel = 0.03
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ self.maxRuleVel = 0.03
- en: '# max magnitude of final velocity'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '# 最终速度的最大大小'
- en: ❸ self.maxVel = 2.0
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ self.maxVel = 2.0
- en: Here you define the minimum distance of approach between two boids ❶. You’ll
    use this value later to apply the separation rule. Then you define `maxRuleVel`,
    which limits how much a boid’s velocity can be changed each time one of the simulation
    rules is applied ❷. You also define `maxVel`, which sets an overall limit on the
    boids’ velocities ❸.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你定义了两个 boid 之间的最小接近距离 ❶。你将在稍后的分离规则中使用这个值。然后，你定义了 `maxRuleVel`，它限制了每次应用仿真规则时
    boid 速度变化的最大值 ❷。你还定义了 `maxVel`，它设置了 boid 速度的总体限制 ❸。
- en: '[Setting Boundary Conditions](nsp-venkitachalam503045-0008.xhtml#rbh0702)'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[设置边界条件](nsp-venkitachalam503045-0008.xhtml#rbh0702)'
- en: Birds fly in a boundless sky, but the boids must play in limited space. To create
    that space, you’ll set boundary conditions, as you did with the toroidal boundary
    condition in the Game of Life simulation in [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03).
    In this case, you’ll apply a *tiled boundary condition* (actually the continuous
    space version of the boundary condition you used in [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 鸟儿飞翔在无限的天空中，但 boids 必须在有限的空间中玩耍。为了创建这个空间，你将设置边界条件，就像在[第 3 章](nsp-venkitachalam503045-0015.xhtml#ch03)的《生命游戏》仿真中使用环形边界条件一样。在这种情况下，你将应用
    *平铺边界条件*（实际上是你在[第 3 章](nsp-venkitachalam503045-0015.xhtml#ch03)中使用的边界条件的连续空间版本）。
- en: 'Think of the Boids simulation as taking place in a tiled space: when a boid
    moves out of a tile, it moves in from the opposite direction to an identical tile.
    The main difference between the toroidal and tiled boundary conditions is that
    this Boids simulation won’t take place on a discrete grid; instead, the birds
    move over a continuous region. [Figure 5-2](nsp-venkitachalam503045-0017.xhtml#fig5-2)
    shows what those tiled boundary conditions look like.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 Boids 仿真想象成发生在一个平铺空间中：当一个 boid 移出一个平铺区域时，它会从相反方向进入一个相同的平铺区域。环形边界条件和平铺边界条件的主要区别在于，这个
    Boids 仿真不会发生在离散网格上；相反，鸟类在一个连续区域内移动。[图 5-2](nsp-venkitachalam503045-0017.xhtml#fig5-2)
    展示了这些平铺边界条件的样子。
- en: '![](images/nsp-venkitachalam503045-f05002.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f05002.jpg)'
- en: 'Figure 5-2: Tiled boundary conditions'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-2：平铺边界条件
- en: Look at the tile in the middle. The birds flying out to the right are entering
    the tile on the right, but the boundary conditions ensure that they actually come
    right back into the center tile through the tile at the left. You can see the
    same thing happening at the top and bottom tiles.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 看看中间的平铺区域。飞向右侧的鸟儿正在进入右侧的平铺区域，但边界条件确保它们实际上会通过左侧的平铺区域重新回到中心平铺区域。你可以看到在顶部和底部的平铺区域也发生了相同的事情。
- en: 'You implement the tiled boundary conditions for the Boids simulation as a method
    on the `Boids` class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 `Boids` 类中实现了用于 Boids 仿真的平铺边界条件方法：
- en: 'def applyBC(self):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 'def applyBC(self):'
- en: '"""apply boundary conditions"""'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '"""应用边界条件"""'
- en: deltaR = 2.0
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: deltaR = 2.0
- en: 'for coord in self.pos:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '对于 self.pos 中的每个 coord:'
- en: '❶ if coord[0] > width + deltaR:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ 如果 coord[0] > 宽度 + deltaR:'
- en: coord[0] = - deltaR
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: coord[0] = - deltaR
- en: 'if coord[0] < - deltaR:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 coord[0] < - deltaR:'
- en: coord[0] = width + deltaR
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: coord[0] = 宽度 + deltaR
- en: 'if coord[1] > height + deltaR:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 coord[1] > 高度 + deltaR:'
- en: coord[1] = - deltaR
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: coord[1] = - deltaR
- en: 'if coord[1] < - deltaR:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 coord[1] < - deltaR:'
- en: coord[1] = height + deltaR
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: coord[1] = 高度 + deltaR
- en: This method applies the tiled boundary conditions to each set of boid coordinates
    in the `pos` array. For example, if an x-coordinate is greater than the width
    of the window ❶, you set it back to the left edge of the window. The `deltaR`
    in this line provides a slight buffer, which allows the boid to move slightly
    outside the window before it starts coming back in from the opposite direction,
    thus producing a better visual effect. You perform a similar check at the left,
    top, and bottom edges of the window.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将平铺边界条件应用于 `pos` 数组中每组 boid 的坐标。例如，如果 x 坐标大于窗口的宽度 ❶，你会将其设置回窗口的左边缘。该行中的 `deltaR`
    提供了一个微小的缓冲区，使得 boid 可以稍微超出窗口边缘，之后从相反方向进入窗口，从而产生更好的视觉效果。你在窗口的左、顶、底边缘执行类似的检查。
- en: '[Drawing a Boid](nsp-venkitachalam503045-0008.xhtml#rbh0703)'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[绘制一个 Boid](nsp-venkitachalam503045-0008.xhtml#rbh0703)'
- en: To build the animation, you need to know each boid’s position and velocity and
    have a way to indicate both the position and direction of motion at each time
    step.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建动画，你需要知道每个 boid 的位置和速度，并且需要一种方法来指示每个时间步骤中位置和运动方向。
- en: Plotting the Boid’s Body and Head
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制 Boid 的身体和头部
- en: To animate the boids, you use `matplotlib` and a little trick to plot both the
    position and velocity. Draw each boid as two circles, as shown in [Figure 5-3](nsp-venkitachalam503045-0017.xhtml#fig5-3).
    The larger circle represents the body, and the smaller one represents the head.
    Point *P* marks the center of the body. For our purposes, you can consider *P*
    to be the position of the boid, and you’ll set it using coordinates from the `pos`
    array discussed earlier. Point *H* is the center of the head. You calculate the
    position of *H* according to the formula *H* = *P* + *k* × *V*, where *V* is the
    velocity of the boid and *k* is a constant representing the distance from the
    center of the body to the center of the head. This way, the boid’s head will be
    aligned with its direction of motion at any given time, which visually communicates
    the boid’s direction of movement more clearly than just drawing the body alone.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给群体成员添加动画效果，你使用 `matplotlib` 和一个小技巧来同时绘制位置和速度。将每个群体成员画成两个圆圈，如[图 5-3](nsp-venkitachalam503045-0017.xhtml#fig5-3)所示。较大的圆圈代表身体，较小的圆圈代表头部。点
    *P* 标记了身体的中心。为了本项目的目的，你可以将 *P* 视为群体成员的位置，并通过之前讨论过的 `pos` 数组来设置它。点 *H* 是头部的中心。你根据公式
    *H* = *P* + *k* × *V* 计算 *H* 的位置，其中 *V* 是群体成员的速度，*k* 是表示身体中心到头部中心距离的常数。这样，群体成员的头部将在任何时刻与其运动方向对齐，这比单纯绘制身体更清晰地传达了群体成员的运动方向。
- en: '![](images/nsp-venkitachalam503045-f05003.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f05003.jpg)'
- en: 'Figure 5-3: Representing a boid'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-3：表示一个群体成员
- en: 'In the following snippet from the program’s `main()` function, you draw the
    boid’s body and head as circular markers using `matplotlib`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的 `main()` 函数中的以下代码片段中，你使用 `matplotlib` 将群体成员的身体和头部绘制为圆形标记：
- en: fig = plt.figure()
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: fig = plt.figure()
- en: ax = plt.axes(xlim=(0, width), ylim=(0, height))
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ax = plt.axes(xlim=(0, width), ylim=(0, height))
- en: ❶ pts, = ax.plot([], [], markersize=10, c='k', marker='o', ls='None')
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ pts, = ax.plot([], [], markersize=10, c='k', marker='o', ls='None')
- en: ❷ head, = ax.plot([], [], markersize=4, c='r', marker='o', ls='None')
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ head, = ax.plot([], [], markersize=4, c='r', marker='o', ls='None')
- en: ❸ anim = animation.FuncAnimation(fig, tick, fargs=(pts[0], head, boids),
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ anim = animation.FuncAnimation(fig, tick, fargs=(pts[0], head, boids),
- en: interval=50)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: interval=50)
- en: You set the size and shape of the markers for the boid’s body (`pts`) ❶ and
    head (`head`) ❷. The `'k'` and `'r'` strings specify the colors black and red,
    respectively, and `'o'` produces a circular marker. The `ax.plot()` method returns
    a list of `matplotlib.lines.Line2D` objects. The `,` syntax in these lines picks
    up the first and only element in this list.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你设置了群体成员的身体（`pts`）❶和头部（`head`）❷的标记大小和形状。`'k'` 和 `'r'` 字符串分别指定了黑色和红色，`'o'` 生成一个圆形标记。`ax.plot()`
    方法返回一个 `matplotlib.lines.Line2D` 对象的列表。这些代码行中的`,` 语法提取了列表中的第一个且唯一的元素。
- en: You next initialize a `matplotlib animation.FuncAnimation()` object ❸, which
    sets up a callback function `tick()` to be called for every frame of the animation
    (we’ll look at this function later in the chapter). The `fargs` parameter lets
    you specify the arguments of the callback function, and you also set the time
    interval (50 milliseconds in this case) at which this function will be called.
    Now that you know how to draw the body and the head, let’s see how to update their
    positions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你初始化一个 `matplotlib.animation.FuncAnimation()` 对象 ❸，该对象设置了一个回调函数 `tick()`，该函数将在动画的每一帧调用（我们稍后会在本章中看到这个函数）。`fargs`
    参数允许你指定回调函数的参数，你还可以设置调用该函数的时间间隔（本例中为 50 毫秒）。现在你已经知道如何绘制身体和头部，接下来我们来看看如何更新它们的位置。
- en: Updating the Boid’s Position
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新群体成员的位置
- en: 'Once the animation starts, you need to update both the boid’s position and
    the location of the head, which tells you the direction in which the boid is moving.
    You do so with this code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 动画开始后，你需要更新群体成员的位置和头部的位置，头部的位置指示了群体成员的运动方向。你可以使用以下代码来实现：
- en: vec = self.pos + 10*self.vel/self.maxVel
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: vec = self.pos + 10*self.vel/self.maxVel
- en: head.set_data(vec.reshape(2*self.N)[::2], vec.reshape(2*self.N)[1::2])
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: head.set_data(vec.reshape(2*self.N)[::2], vec.reshape(2*self.N)[1::2])
- en: First you calculate the position of the head by applying the *H* = *P* + *k* × *V*
    formula discussed earlier. You use a *k* value of 10 units in the direction of
    the velocity (`vel`). You then update (`reshape`) the `matplotlib` axis (`set_data`)
    with the new values of the head position. The `[::2]` picks out the even-numbered
    elements (x-axis values) from the velocity list, and the `[1::2]` picks out the
    odd-numbered elements (y-axis values).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过应用之前讨论过的 *H* = *P* + *k* × *V* 公式，计算头部的位置。你使用的 *k* 值是沿速度方向（`vel`）的 10 个单位。然后，使用新的头部位置值更新（`reshape`）`matplotlib`
    坐标轴（`set_data`）。`[::2]` 从速度列表中选择偶数索引的元素（x 轴值），`[1::2]` 选择奇数索引的元素（y 轴值）。
- en: '[Applying the Rules of the Boids](nsp-venkitachalam503045-0008.xhtml#rbh0704)'
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[应用 Boids 规则](nsp-venkitachalam503045-0008.xhtml#rbh0704)'
- en: 'In this section, we’ll look at how to implement the three rules of the Boids
    simulation—separation, alignment, and cohesion—to recalculate the boids’ velocities
    at each time step. We’ll start by focusing just on the separation rule. The goal
    is to generate a new velocity vector for each boid that pushes it away from its
    nearby flockmates, defined as all the boids within a certain radius *R*. Given
    two boids *i* and *j* with positions *P*[i] and *P*[j], *P*[i] − *P*[j] produces
    a new velocity vector for boid *i* that points away from boid *j*. We’ll call
    this a *displacement vector*. To calculate a new velocity vector *V*[i] for boid
    *i* that on average pushes it away from *all* its nearby flockmates, simply sum
    all the displacement vectors between boid *i* and each boid within radius *R*.
    In other words, *V*[i] = (*P*[i] − *P*[1]) + (*P*[i] − *P*[2]) + . . . (*P*[i]
    − *P*[N]), provided the distance between boids *i* and *j* is less than *R*. You
    can write this more formally as:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何实现 Boids 模拟中的三条规则——分离、对齐和聚合——以便在每个时间步重新计算 Boids 的速度。我们将首先专注于分离规则。目标是为每个
    Boid 生成一个新的速度向量，将其推离附近的群体成员，群体成员定义为在一定半径 *R* 内的所有 Boid。给定两个 Boid *i* 和 *j*，它们的位置分别为
    *P*[i] 和 *P*[j]，*P*[i] − *P*[j]* 会生成一个新的速度向量，指向远离 Boid *j* 的方向。我们将其称为 *位移向量*。为了计算
    Boid *i* 的新速度向量 *V*[i]，它会平均将其推离所有附近的群体成员，只需将 Boid *i* 与半径 *R* 内的每个 Boid 之间的所有位移向量相加即可。换句话说，*V*[i]
    = (*P*[i] − *P*[1]) + (*P*[i] − *P*[2]) + … (*P*[i] − *P*[N])，前提是 Boid *i* 和 *j*
    之间的距离小于 *R*。你可以更正式地写成：
- en: '![](images/nsp-venkitachalam503045-m05001.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m05001.jpg)'
- en: Notice that implementing this rule—and, indeed, implementing the other Boids
    rules as well—involves calculating the distance between each boid and every other
    boid to determine which boids are local flockmates. The traditional way to do
    this in Python would be to use a pair of nested loops to iterate through the boids.
    As you’ll see, however, `numpy` arrays provide more efficient methods that bypass
    the need for loops. We’ll implement both approaches and compare the results and
    then apply what we’ve learned to the actual simulation code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，实现这个规则——实际上，也包括实现其他 Boids 规则——涉及计算每个 Boid 与其他所有 Boid 之间的距离，以确定哪些 Boid 是局部群体成员。传统上在
    Python 中做法是使用一对嵌套循环来迭代 Boids。然而，正如你将看到的，`numpy` 数组提供了更高效的方法，能够绕过循环的需求。我们将实现这两种方法，并比较结果，接着将学到的内容应用于实际的模拟代码中。
- en: Using Nested Loops
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用嵌套循环
- en: 'First, let’s define a function `test1()` that implements the separation rule
    in a straightforward way, using loops:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个函数`test1()`，以简单的方式实现分离规则，使用循环：
- en: 'def test1(pos, radius):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test1(pos, radius):'
- en: '# fill output with zeros'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '# 用零填充输出'
- en: vel = np.zeros(2*N).reshape(N, 2)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: vel = np.zeros(2*N).reshape(N, 2)
- en: '# for each pos'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '# 对每个位置'
- en: '❶ for (i1, p1) in enumerate(pos):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ for (i1, p1) in enumerate(pos):'
- en: '# velocity contribution'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '# 速度贡献'
- en: val = np.array([0.0, 0.0])
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: val = np.array([0.0, 0.0])
- en: '# for each other pos'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '# 对每个其他位置'
- en: '❷ for (i2, p2) in enumerate(pos):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ for (i2, p2) in enumerate(pos):'
- en: 'if i1 != i2:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 i1 != i2:'
- en: '# calculate distance from p1'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算 p1 的距离'
- en: dist = math.sqrt((p2[0]-p1[0])*(p2[0]-p1[0]) +
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: dist = math.sqrt((p2[0]-p1[0])*(p2[0]-p1[0]) +
- en: (p2[1]-p1[1])*(p2[1]-p1[1]))
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: (p2[1]-p1[1])*(p2[1]-p1[1]))
- en: '# apply threshold'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用阈值'
- en: '❸ if dist < radius:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ if dist < radius:'
- en: ❹ val += (p2 - p1)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ val += (p2 - p1)
- en: '# set velocity'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置速度'
- en: vel[i1] = val
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: vel[i1] = val
- en: '# return computed velocity'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '# 返回计算后的速度'
- en: return vel
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 返回速度
- en: This code uses a nested pair of loops. The outer loop ❶ goes through each boid
    in the `pos` array. The inner loop ❷ computes the distance between the current
    boid and each other boid in the array. If the distance is less than the threshold
    defined as the function’s `radius` parameter ❸, you calculate the displacement
    vector as discussed earlier and add the result to `val` ❹. At the end of each
    cycle of the inner loop, `val` holds a new velocity that will push the current
    boid away from its neighbors. You store that velocity back in the `vel` array.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了嵌套的循环。外层循环❶遍历`pos`数组中的每一个boid。内层循环❷计算当前boid与数组中每个其他boid之间的距离。如果距离小于函数的`radius`参数所定义的阈值❸，你将如前所述计算位移向量，并将结果添加到`val`中❹。在内层循环的每个周期结束时，`val`将包含一个新的速度，推动当前boid远离其邻居。你将该速度存储回`vel`数组中。
- en: Using numpy Methods
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用numpy方法
- en: 'Now let’s define a function `test2()` that does the same thing “the `numpy`
    way,” avoiding loops and using highly optimized `numpy` methods. You’ll also use
    methods from the `scipy.spatial.distance` module to efficiently calculate the
    distance between points:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个`test2()`函数，使用“`numpy`方式”实现相同的功能，避免使用循环，并利用高度优化的`numpy`方法。你还将使用来自`scipy.spatial.distance`模块的方法来高效计算点之间的距离：
- en: 'def test2(pos, radius):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test2(pos, radius):'
- en: '# get distance matrix'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取距离矩阵'
- en: ❶ distMatrix = squareform(pdist(pos))
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ distMatrix = squareform(pdist(pos))
- en: '# apply threshold'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用阈值'
- en: ❷ D = distMatrix < radius
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ D = distMatrix < radius
- en: '# compute velocity'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算速度'
- en: ❸ vel = pos*D.sum(axis=1).reshape(N, 1) - D.dot(pos)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ vel = pos*D.sum(axis=1).reshape(N, 1) - D.dot(pos)
- en: return vel
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: return vel
- en: 'You use the `squareform()` and `pdist()` methods (defined in the `scipy` library)
    to calculate the distances between every possible pair of points in the `pos`
    array ❶. For an array of *N* points, `squareform()` gives you an *N*×*N* matrix,
    where any given entry *M*[ij] is the distance between points *P*[i] and *P*[j].
    Let’s consider a quick example of how that looks. In this code, you call the methods
    on an array of three points:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`squareform()`和`pdist()`方法（定义在`scipy`库中）来计算`pos`数组中每一对点之间的距离❶。对于一个包含*N*个点的数组，`squareform()`会给你一个*N*×*N*的矩阵，其中任何给定的元素*M*[ij]表示点*P*[i]和*P*[j]之间的距离。我们来看一个简单的例子来说明这个过程。在这段代码中，你对一个包含三个点的数组调用这些方法：
- en: '>>> `import numpy as np`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `import numpy as np`'
- en: '>>> `from scipy.spatial.distance import squareform, pdist`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `from scipy.spatial.distance import squareform, pdist`'
- en: '>>> `x = np.array([[0.0, 0.0], [1.0, 1.0], [2.0, 2.0]])`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `x = np.array([[0.0, 0.0], [1.0, 1.0], [2.0, 2.0]])`'
- en: '>>> `squareform(pdist(x))`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `squareform(pdist(x))`'
- en: array([[0.        , 1.41421356, 2.82842712],
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: array([[0.        , 1.41421356, 2.82842712],
- en: '[1.41421356, 0.        , 1.41421356],'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[1.41421356, 0.        , 1.41421356],'
- en: '[2.82842712, 1.41421356, 0.        ]])'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[2.82842712, 1.41421356, 0.        ]])'
- en: Since you provide an array of three points, the result is a 3×3 matrix of distance
    calculations. The values in the first row, for example, tell you the distance
    between the first point (`[0.0, 0.0]`) and each point in the array. The zeros
    running diagonally down the array correspond to the distance between each point
    and itself.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你提供了一个包含三个点的数组，结果是一个3×3的距离计算矩阵。比如第一行的值，告诉你第一个点（`[0.0, 0.0]`）与数组中每个点的距离。沿对角线的零值表示每个点与自身的距离。
- en: 'Returning to the `test2()` function, you next filter the matrix based on whether
    the distance is less than the specified `radius` ❷. Using the same example array
    of three points, you have the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`test2()`函数，你接下来会根据距离是否小于指定的`radius`来过滤矩阵❷。使用同样的三个点的示例数组，结果如下：
- en: '>>> `squareform(``pdist(x)) < 1.4`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `squareform(``pdist(x)) < 1.4`'
- en: array([[ True, False, False],
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: array([[ True, False, False],
- en: '[False,  True, False],'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[False,  True, False],'
- en: '[False, False,  True]])'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[False, False,  True]])'
- en: The `<` comparison creates a Boolean matrix of `True/False` values corresponding
    to the original distance matrix—`True` if a distance is less than the given threshold
    (in this example, 1.4).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`<`比较运算会创建一个布尔矩阵，`True/False`值与原始距离矩阵对应——如果距离小于给定的阈值（在这个例子中是1.4），则为`True`。'
- en: 'Back in `test2()`, you use a modified version of the equation for *V*[i] discussed
    earlier, broadcast over the entire `pos` array ❸. That equation can be rewritten
    as:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`test2()`中，你使用了前面讨论过的*V*[i]方程的修改版，并将其广播到整个`pos`数组上❸。该方程可以重新写为：
- en: '![](images/nsp-venkitachalam503045-m05002.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m05002.jpg)'
- en: 'Here, the second summation term on the right includes only the points *P* that
    satisfy the distance criteria. The number of elements in the summation term is
    *m*. This equation can again be written as:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，右侧第二项求和仅包括满足距离标准的点*P*。求和项中的元素数量是*m*。这个方程可以再次写成：
- en: '![](images/nsp-venkitachalam503045-m05003.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m05003.jpg)'
- en: where *D*[ij] is row *i* of the Boolean matrix you generated ❷, *m* is the number
    of `True` values in that row, and *P*[j] is all the points *P* that fall within
    the specified radius of the current boid.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，*D*[ij]是你生成的布尔矩阵的第*i*行❷，*m*是该行中`True`值的数量，*P*[j]是所有位于当前boid指定半径内的点*P*。
- en: The `D.sum` method ❸ adds up the `True` values in the Boolean matrix in a column-wise
    fashion, giving you *m* from the equation. The reshape is required because the
    result of the sum is a one-dimensional array of *N* values (shape (*N*, )), and
    you want it to be of shape (*N*, 1) so it’s compatible for multiplication with
    the position array. The `D.dot(pos)` part of the line ❸ is taking the dot product
    (multiplication) of the Boolean matrix and the array of boid positions, which
    corresponds to the *D*[ij]*P*[j] part of the equation.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`D.sum`方法❸按列方式对布尔矩阵中的`True`值进行求和，给出方程中的*m*。由于求和结果是一个*N*值的单维数组（形状为(*N*, )），所以需要reshape操作，将其转变为形状为(*N*,
    1)，以便与位置数组进行乘法运算。该行的`D.dot(pos)`部分❸表示布尔矩阵和boid位置数组的点积（乘法），这对应于方程中的*D*[ij]*P*[j]部分。'
- en: Comparing Approaches
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 比较方法
- en: 'Comparing the two approaches, `test2()` is much more compact than `test1()`,
    but its real advantage is speed. Let’s use the Python `timeit` module to evaluate
    the performance of the two functions. First, enter the code for the functions
    `test1()` and `test2()` in a file named *test.py*, as shown here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 比较这两种方法，`test2()`比`test1()`更加简洁，但它的真正优势在于速度。让我们使用 Python 的`timeit`模块来评估这两个函数的性能。首先，在一个名为*test.py*的文件中输入`test1()`和`test2()`的代码，如下所示：
- en: import math
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: import math
- en: import numpy as np
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: from scipy.spatial.distance import squareform, pdist, cdist
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: from scipy.spatial.distance import squareform, pdist, cdist
- en: N = 100
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: N = 100
- en: width, height = 640, 480
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: width, height = 640, 480
- en: pos = np.array(list(zip(width*np.random.rand(N), height*np.random.rand(N))))
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: pos = np.array(list(zip(width*np.random.rand(N), height*np.random.rand(N))))
- en: 'def test1(pos, radius):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test1(pos, radius):'
- en: --`snip`--
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: --`snip`--
- en: 'def test2(post, radius):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 'def test2(post, radius):'
- en: --`snip`--
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: --`snip`--
- en: 'Now use the `timeit` module in a Python interpreter session to compare the
    performance of the two functions:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 Python 解释器会话中使用`timeit`模块来比较这两个函数的性能：
- en: '>>> `from` `timeit import timeit`'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `from` `timeit import timeit`'
- en: '>>> `timeit(''test1(pos, 100)'', ''from test import test1, N, pos, width, height'',
    number=100)`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `timeit(''test1(pos, 100)'', ''from test import test1, N, pos, width, height'',
    number=100)`'
- en: '7.880876064300537'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '7.880876064300537'
- en: '>>> `timeit(''test2(pos, 100)'', ''from test import test2, N, pos, width, height'',
    number=100)`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `timeit(''test2(pos, 100)'', ''from test import test2, N, pos, width, height'',
    number=100)`'
- en: '0.036969900131225586'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '0.036969900131225586'
- en: On my computer, the `numpy` code without loops runs about 200 times faster than
    the code that uses explicit loops! But why? Aren’t they both doing more or less
    the same thing?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的计算机上，`numpy`代码没有使用循环时比使用显式循环的代码快大约200倍！但是为什么？难道它们做的不是差不多一样的事情吗？
- en: As an interpreted language, Python is inherently slower than compiled languages
    like C. The `numpy` library brings the convenience of Python and performance nearly
    equal to that of C by providing highly optimized methods that operate on arrays
    of data. In general, you’ll find that `numpy` works best when you reorganize your
    algorithm as steps that operate on entire arrays at once, without looping through
    individual elements to perform computations.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种解释性语言，Python 天生比 C 等编译型语言要慢。`numpy`库通过提供高度优化的方法来操作数据数组，结合 Python 的便利性，几乎达到了
    C 的性能。通常，你会发现当你将算法重组为操作整个数组的步骤，而不是通过循环逐个元素进行计算时，`numpy`效果最好。
- en: Writing the Final Method
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写最终方法
- en: Now that you’ve compared the two approaches, you’re ready to use what you’ve
    learned to write a final version of the method that applies all three rules of
    the simulation and returns updated velocities for all the boids. The `applyRules()`
    method, part of the `Boids` class, uses the optimized `numpy` techniques discussed
    earlier.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经比较了这两种方法，准备利用学到的内容编写最终版本的方法，该方法应用了模拟中的所有三个规则，并返回所有boid的更新速度。`applyRules()`方法是`Boids`类的一部分，使用了前面讨论的优化过的`numpy`技术。
- en: 'def applyRules(self):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 'def applyRules(self):'
- en: '# get pairwise distances'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取成对的距离'
- en: ❶ self.distMatrix = squareform(pdist(self.pos))
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ self.distMatrix = squareform(pdist(self.pos))
- en: '# apply rule #1: separation'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用规则#1：分离'
- en: D = self.distMatrix < self.minDist
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: D = self.distMatrix < self.minDist
- en: ❷ vel = self.pos*D.sum(axis=1).reshape(self.N, 1) - D.dot(self.pos)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ vel = self.pos*D.sum(axis=1).reshape(self.N, 1) - D.dot(self.pos)
- en: ❸ self.limit(vel, self.maxRuleVel)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ self.limit(vel, self.maxRuleVel)
- en: '# distance threshold for alignment (different from separation)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '# 对齐的距离阈值（与分离不同）'
- en: ❹ D = self.distMatrix < 50.0
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ D = self.distMatrix < 50.0
- en: '# apply rule #2: alignment'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用规则#2：对齐'
- en: ❺ vel2 = D.dot(self.vel)
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ vel2 = D.dot(self.vel)
- en: self.limit(vel2, self.maxRuleVel)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: self.limit(vel2, self.maxRuleVel)
- en: ❻ vel += vel2
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ vel += vel2
- en: '# apply rule #3: cohesion'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用规则#3：凝聚'
- en: ❼ vel3 = D.dot(self.pos) - self.pos
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ vel3 = D.dot(self.pos) - self.pos
- en: self.limit(vel3, self.maxRuleVel)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: self.limit(vel3, self.maxRuleVel)
- en: ❽ vel += vel3
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ vel += vel3
- en: return vel
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: return vel
- en: You compute the pairwise distance matrix between the boids using the `squareform()`
    and `pdist()` methods from the `scipy` library, as discussed earlier ❶. When you
    apply the separation rule using `numpy` methods ❷, each boid is pushed away from
    neighboring boids within a distance of `minDist` (25 pixels). The calculated velocities
    are clamped, or restricted, to a certain maximum value using the `Boids` class’s
    `limit()` method ❸, which we’ll look at later. Without this restriction, the velocities
    would increase with each time step, and the simulation would go haywire.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`scipy`库中的`squareform()`和`pdist()`方法计算群体之间的成对距离矩阵，如前所述❶。当你使用`numpy`方法应用分离规则时❷，每个群体成员都会被推离距离`minDist`（25像素）以内的邻近成员。计算得到的速度将通过`Boids`类的`limit()`方法❸进行限制或约束，稍后我们将详细讨论。没有这个限制，速度会随着每个时间步长的推进不断增加，导致模拟失控。
- en: You next generate a new Boolean matrix using a distance threshold of 50 pixels
    rather than 25 ❹. You’ll use this broader definition of neighboring flockmates
    to apply the alignment and cohesion rules. The alignment rule is implemented so
    that each boid is influenced by and aligns itself with the average velocity of
    its neighbors. You get that average simply by taking the dot product of `D` (the
    Boolean matrix) and the velocity array ❺. Once again, you restrict the calculated
    velocities to a maximum so they don’t increase indefinitely. (Using the compact
    `numpy` syntax makes all these computations simple and fast.)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你使用50像素的距离阈值而不是25像素来生成一个新的布尔矩阵❹。你将使用这个更广泛的邻近群体定义来应用对齐和凝聚规则。对齐规则的实现使得每个群体成员都会受到其邻居平均速度的影响并与之对齐。你通过对`D`（布尔矩阵）和速度数组进行点积来简单地获得这个平均值❺。再次强调，你将计算得到的速度限制在最大值，以避免其无限增大。（使用紧凑的`numpy`语法使得所有这些计算变得简单且快速。）
- en: Finally, you apply the cohesion rule by adding the positions of all the neighboring
    boids and then subtracting the position of the current boid ❼. This produces a
    velocity vector for each boid that points to the *centroid* or geometric center
    of its neighbors. Again, you limit the velocities to keep them from getting out
    of control.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你通过将所有邻近群体成员的位置相加，然后减去当前群体成员的位置❼，来应用凝聚规则。这会产生一个指向其邻居的*质心*或几何中心的速度向量。再次强调，你会限制这些速度，以防止它们失控。
- en: Each of the three rules produces its own velocity vector for each boid. At ❻
    and ❽, you add these vectors together, producing an overall velocity vector for
    each boid that reflects the influence of all three simulation rules. You store
    the final velocity vectors in the `vel` array.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 每个规则都会为每个群体成员生成一个速度向量。在❻和❽处，你将这些向量相加，生成每个群体成员的总体速度向量，这个速度向量反映了所有三个模拟规则的影响。你将最终的速度向量存储在`vel`数组中。
- en: Limiting the Velocities
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 限制速度
- en: 'In the previous section, you saw how the `limit()` method was called after
    applying each rule to keep the boids’ velocities from getting out of control.
    Here’s that method:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，你已经看到了如何在应用每个规则后调用`limit()`方法，以防群体成员的速度失控。下面是该方法：
- en: 'def limit(self, X, maxVal):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 'def limit(self, X, maxVal):'
- en: '"""limit the magnitude of 2D vectors in array X to maxValue"""'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '"""限制数组X中2D向量的大小为maxValue"""'
- en: '❶ for vec in X:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ for vec in X:'
- en: self.limitVec(vec, maxVal)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: self.limitVec(vec, maxVal)
- en: 'This method is designed to take in an array of velocity vectors, extract each
    individual vector ❶, and pass it along to the `limitVec()` method, which looks
    like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法旨在接收一个速度向量数组，提取每个单独的向量❶，并将其传递给`limitVec()`方法，该方法如下所示：
- en: 'def limitVec(self, vec, maxVal):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'def limitVec(self, vec, maxVal):'
- en: '"""limit the magnitude of the 2D vector"""'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '"""限制2D向量的大小"""'
- en: ❶ mag = norm(vec)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ mag = norm(vec)
- en: 'if mag > maxVal:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 'if mag > maxVal:'
- en: ❷ vec[0], vec[1] = vec[0]*maxVal/mag, vec[1]*maxVal/mag
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ vec[0], vec[1] = vec[0]*maxVal/mag, vec[1]*maxVal/mag
- en: You use the `norm()` function from the `numpy` library to calculate the magnitude
    of the vector ❶. If it exceeds the maximum, you scale the x and y portions of
    the vector in proportion to the vector’s magnitude ❷. The maximum value was defined
    as `self.maxRuleVel = 0.03` as part of the initialization of the `Boids` class.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`numpy`库中的`norm()`函数计算向量的大小 ❶。如果它超过最大值，你将按向量的大小比例缩放向量的 x 和 y 部分 ❷。最大值被定义为`self.maxRuleVel
    = 0.03`，这是`Boids`类初始化的一部分。
- en: '[Influencing the Simulation](nsp-venkitachalam503045-0008.xhtml#rbh0705)'
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[影响仿真](nsp-venkitachalam503045-0008.xhtml#rbh0705)'
- en: The core rules in the Boids simulation will cause the boids to automatically
    exhibit flocking behavior. But let’s make things more interesting by allowing
    the user to influence the simulation as it runs. Specifically, you’ll create the
    ability to add boids to the flock or make the flock scatter with the click of
    your mouse.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Boids仿真中的核心规则将使鸟群自动表现出群体行为。但让我们更有趣一些，允许用户在仿真运行时影响仿真。具体来说，你将创建能够通过鼠标点击将鸟群个体添加到群体中或使鸟群散开功能。
- en: 'The first step to inject events into the simulation while it’s running is to
    add an *event handler* to the `matplotlib` canvas. This is a piece of code that
    calls a function every time a certain event, such as a mouse click, happens. Here’s
    how to do it:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 向仿真中注入事件的第一步是在`matplotlib`画布上添加一个*事件处理器*。这是一个每当发生某个特定事件（如鼠标点击）时调用一个函数的代码片段。下面是如何实现的方法：
- en: cid = fig.canvas.mpl_connect('button_press_event', boids.buttonPress)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: cid = fig.canvas.mpl_connect('button_press_event', boids.buttonPress)
- en: You use the `mpl_connect()` method to add a button press event handler to the
    `matplotlib` canvas. This handler will call the `buttonPress()` method of the
    `Boids` class every time a mouse button is pressed in the simulation window. Next,
    you need to define the `buttonPress()` method.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`mpl_connect()`方法将按钮点击事件处理器添加到`matplotlib`画布。每当鼠标按钮在仿真窗口中被按下时，这个处理器将调用`Boids`类的`buttonPress()`方法。接下来，你需要定义`buttonPress()`方法。
- en: Adding a Boid
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加一个鸟群个体
- en: The first part of the `buttonPress()` method adds a boid to the simulation at the
    location of your cursor and assigns that boid a random velocity, when the *left*
    mouse button is pressed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`buttonPress()`方法的第一部分是在你按下*左*鼠标按钮时，在光标位置将一个鸟群个体添加到仿真中，并为该个体分配一个随机速度。'
- en: 'def buttonPress(self, event):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 'def buttonPress(self, event):'
- en: '"""event handler for matplotlib button presses"""'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '"""matplotlib按钮点击事件处理器"""'
- en: left-click to add a boid
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 左键单击以添加一个鸟群个体
- en: '❶ if event.button is 1:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果事件按钮是 1：
- en: ❷ self.pos = np.concatenate((self.pos,
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ self.pos = np.concatenate((self.pos,
- en: np.array([[event.xdata, event.ydata]])),
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: np.array([[event.xdata, event.ydata]])),
- en: axis=0)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: axis=0)
- en: '# generate a random velocity'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '# 生成一个随机速度'
- en: angles = 2*math.pi*np.random.rand(1)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: angles = 2*math.pi*np.random.rand(1)
- en: v = np.array(list(zip(np.sin(angles), np.cos(angles))))
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: v = np.array(list(zip(np.sin(angles), np.cos(angles))))
- en: ❸ self.vel = np.concatenate((self.vel, v), axis=0)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ self.vel = np.concatenate((self.vel, v), axis=0)
- en: ❹ self.N += 1
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ self.N += 1
- en: First you ensure that the mouse event is a left-click ❶. Then you append the
    mouse location given by (`event.xdata, event.ydata`) to the array of boid positions
    ❷. You also generate a random velocity vector, add it to the array of boid velocities
    ❸, and increment the count of boids by 1 ❹.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你确保鼠标事件是左键单击 ❶。然后，你将由（`event.xdata, event.ydata`）给出的鼠标位置追加到鸟群位置数组 ❷ 中。你还生成一个随机速度向量，将其添加到鸟群速度数组
    ❸，并将鸟群数量增加 1 ❹。
- en: Scattering the Boids
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 散射鸟群
- en: 'The three simulation rules keep the boids in a flock as they move around. But
    what happens when the flock is disturbed? To simulate this situation, you can
    introduce a “scatter” effect: when you right-click in the simulation window, the
    flock will scatter from the location of the click. You can think of this as how
    the flock might respond to the sudden appearance of a predator or a loud noise
    that spooks the birds. You implement this effect as a continuation of the `buttonPress()`
    method:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 三个仿真规则会在鸟群移动时保持鸟群在一群中。但是，当鸟群受到干扰时会发生什么呢？为了模拟这种情况，你可以引入一个“散射”效果：当你在仿真窗口右键单击时，鸟群将从点击位置散开。你可以把这个看作是鸟群如何应对捕食者的突然出现或吓到鸟群的响声。你将这个效果实现为`buttonPress()`方法的延续：
- en: '# right-click to scatter boids'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '# 右键点击以散射鸟群'
- en: '❶ elif event.button is 3:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果事件按钮是 3：
- en: '# add scattering velocity'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加散射速度'
- en: self.vel += 0.1*(self.pos - np.array([[event.xdata, event.ydata]]))
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: self.vel += 0.1*(self.pos - np.array([[event.xdata, event.ydata]]))
- en: Here you check whether the mouse button press is a right-click event ❶. If so,
    you change the velocity for every boid by adding a vector that points away from
    the point where the disturbance arose (that is, where the mouse was clicked).
    You calculate this vector much like you calculated the displacement vectors for
    the separation rule. If *P*[i] is the position of a boid and *P*[m] is the point
    where the mouse was clicked, *P*[i] − *P*[m] is a vector that points away from
    the mouse click. You multiply this vector by `0.1` to keep the magnitude of the
    disturbance small. Initially, the boids will fly away from that point, but as
    you’ll see, the three rules prevail, and the boids will coalesce again as a flock.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你检查鼠标按钮按下是否是右键单击事件❶。如果是，你会通过添加一个指向扰动源（即鼠标点击位置）的向量来改变每个鸟群的速度。你计算这个向量的方式和计算分离规则的位移向量类似。如果*P*[i]是一个鸟群的位置，*P*[m]是鼠标点击的位置，那么*P*[i]
    − *P*[m]就是一个指向鼠标点击位置的向量。你将这个向量乘以`0.1`以保持扰动的幅度较小。最初，鸟群会飞离那个点，但正如你所见，三个规则依然占主导，鸟群最终会重新聚集成一群。
- en: '[Incrementing the Simulation](nsp-venkitachalam503045-0008.xhtml#rbh0706)'
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[递增仿真](nsp-venkitachalam503045-0008.xhtml#rbh0706)'
- en: At each time step in the simulation, you need to apply the rules to calculate
    the boids’ new velocities, update the boids’ positions based on those velocities,
    enforce the boundary conditions, and redraw everything in the display window.
    You can coordinate all this activity from the `tick()` function, which will be
    called at each frame of the `matplotlib` animation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在仿真的每个时间步，你需要应用规则来计算鸟群的新速度，基于这些速度更新鸟群的位置，执行边界条件，并重新绘制显示窗口中的一切。你可以通过`tick()`函数来协调这些活动，该函数会在`matplotlib`动画的每一帧被调用。
- en: 'def tick(frameNum, pts, head, boids):'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 'def tick(frameNum, pts, head, boids):'
- en: '"""update function for animation"""'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '"""动画更新函数"""'
- en: boids.tick(frameNum, pts, head)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: boids.tick(frameNum, pts, head)
- en: return pts, head
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: return pts, head
- en: 'The stand-alone `tick()` function simply calls the `tick()` method of the `Boids`
    class. The latter is defined as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 独立的`tick()`函数仅仅调用`Boids`类的`tick()`方法。后者定义如下：
- en: 'def tick(self, frameNum, pts, head):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 'def tick(self, frameNum, pts, head):'
- en: '"""update the simulation by one time step"""'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '"""更新仿真状态，时间步进一次"""'
- en: '# apply rules'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用规则'
- en: ❶ self.vel += self.applyRules()
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ self.vel += self.applyRules()
- en: ❷ self.limit(self.vel, self.maxVel)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ self.limit(self.vel, self.maxVel)
- en: ❸ self.pos += self.vel
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ self.pos += self.vel
- en: ❹ self.applyBC()
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ self.applyBC()
- en: '# update data'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '# 更新数据'
- en: ❺ pts.set_data(self.pos.reshape(2*self.N)[::2],
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ pts.set_data(self.pos.reshape(2*self.N)[::2],
- en: self.pos.reshape(2*self.N)[1::2])
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: self.pos.reshape(2*self.N)[1::2])
- en: ❻ vec = self.pos + 10*self.vel/self.maxVel
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ vec = self.pos + 10*self.vel/self.maxVel
- en: ❼ head.set_data(vec.reshape(2*self.N)[::2],
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ head.set_data(vec.reshape(2*self.N)[::2],
- en: vec.reshape(2*self.N)[1::2])
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: vec.reshape(2*self.N)[1::2])
- en: This method is where everything comes together. You apply the boid rules using
    the `applyRules()` method that we already looked at ❶. Then you limit the computed
    velocities of the boids using the `self.maxVel` threshold ❷. (Even though you
    limited the velocity vector generated by each individual rule, the overall velocity
    determined by adding all three rules together may still be too large.) You next
    compute the updated positions of the boids by adding the new velocity vectors
    to the old array of positions ❸. For example, if a boid was at position [0, 0]
    and has a velocity vector of [1, 1], its new position after one time step would
    be [1, 1]. You apply the boundary conditions for the simulation by calling `applyBC()`
    ❹.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是所有内容的汇集点。你通过调用我们之前看过的`applyRules()`方法来应用鸟群规则❶。接着，你使用`self.maxVel`阈值限制鸟群的计算速度❷。（即使你已经限制了每个规则生成的速度向量，由所有三个规则合成的总速度可能仍然太大。）然后，你通过将新的速度向量添加到旧的位置信息数组中来计算鸟群的更新位置❸。例如，如果一只鸟群在[0,
    0]的位置，速度向量为[1, 1]，那么在一个时间步长后，它的新位置将是[1, 1]。你通过调用`applyBC()`来应用仿真边界条件❹。
- en: The call to `pts.set_data()` ❺ updates the `matplotlib` axis with the boids’
    new positions. The `[::2]` picks out the even-numbered elements (x-axis values)
    from the `pos` array, and the `[1::2]` picks out the odd-numbered elements (y-axis
    values). This will redraw the larger circles representing the boids’ bodies. Next,
    you need to draw the smaller circles representing the boids’ heads. You calculate
    the position of each boid’s head so it will point in the boid’s direction of motion
    by applying the *H* = *P* + *k* × *V* formula discussed earlier ❻. Recall that
    *P* is the center of a boid’s body, *k* is a constant representing the distance
    from the center of the body to the center of the head (you use a value of 10 units),
    and *V* is the boid’s velocity. Once you have the new head positions, you draw
    them via the same technique you used to draw the bodies ❼.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `pts.set_data()` ❺ 更新 `matplotlib` 轴上鸟群的新位置。`[::2]` 选择 `pos` 数组中的偶数元素（x 轴值），`[1::2]`
    选择奇数元素（y 轴值）。这将重新绘制代表鸟群身体的较大圆圈。接下来，您需要绘制代表鸟群头部的较小圆圈。您根据之前讨论的 *H* = *P* + *k* ×
    *V* 公式计算每只鸟群头部的位置 ❻。请记住，*P* 是鸟群身体的中心，*k* 是表示从身体中心到头部中心的距离的常数（使用 10 单位），*V* 是鸟群的速度。一旦您有了新的头部位置，就可以通过与绘制身体相同的技术来绘制它们
    ❼。
- en: '[Parsing Arguments and Instantiating the Boids](nsp-venkitachalam503045-0008.xhtml#rbh0707)'
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[解析参数和实例化Boids](nsp-venkitachalam503045-0008.xhtml#rbh0707)'
- en: 'The program’s `main()` function begins by handling command line arguments and
    instantiating the `Boids` class:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的 `main()` 函数开始处理命令行参数并实例化 `Boids` 类：
- en: 'def main():'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '# use sys.argv if needed'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如有需要可使用 sys.argv'
- en: print('starting boids...')
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: print('starting boids...')
- en: parser = argparse.ArgumentParser(description="Implementing Craig
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: parser = argparse.ArgumentParser(description="实现Craig")
- en: Reynolds's Boids...")
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 雷诺兹的 Boids...")
- en: '# add arguments'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加参数'
- en: ❶ parser.add_argument('--num-boids', dest='N', required=False)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ parser.add_argument('--num-boids', dest='N', required=False)
- en: args = parser.parse_args()
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: args = parser.parse_args()
- en: '# set the initial number of boids'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置初始鸟群数量'
- en: ❷ N = 100
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ N = 100
- en: 'if args.N:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.N:'
- en: N = int(args.N)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: N = int(args.N)
- en: '# create boids'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建鸟群'
- en: ❸ boids = Boids(N)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ boids = Boids(N)
- en: You use the familiar `argparse` module to create a command line option for setting
    the initial number of boids in the simulation ❶. If no argument is provided at
    the command line, the simulation defaults to 100 boids ❷. You set the simulation
    in motion by creating an object of the `Boids` class ❸.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用熟悉的 `argparse` 模块创建命令行选项，用于设置模拟中初始鸟群数量 ❶。如果未在命令行提供参数，则模拟默认为 100 只鸟群 ❷。通过创建
    `Boids` 类的对象来启动模拟 ❸。
- en: The `main()` function continues with the code to create and animate a `matplotlib`
    plot. We’ve already discussed this code in [“Plotting the Boid’s Body and Head”](nsp-venkitachalam503045-0017.xhtml#ch0701)
    on [page 84](nsp-venkitachalam503045-0017.xhtml#p84).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数继续执行代码以创建和动画化 `matplotlib` 绘图。我们已经在 [“绘制Boid的身体和头部”](nsp-venkitachalam503045-0017.xhtml#ch0701)
    第 84 页中讨论了这部分代码。'
- en: '[Running the Boids Simulation](nsp-venkitachalam503045-0008.xhtml#rah0704)'
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行Boids模拟](nsp-venkitachalam503045-0008.xhtml#rah0704)'
- en: 'Let’s see what happens when you run the simulation. Enter the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看当您运行模拟时会发生什么。输入以下内容：
- en: $ `python boids.py`
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: $ `python boids.py`
- en: The Boids simulation should start with all the boids clustered around the center
    of the window. Let the simulation run for a while, and the boids should start
    to flock as they form a pattern similar to the one shown in [Figure 5-4](nsp-venkitachalam503045-0017.xhtml#fig5-4).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Boids 模拟应该从窗口中心开始，所有鸟群都聚集在一起。让模拟运行一段时间，鸟群应开始形成与 [图 5-4](nsp-venkitachalam503045-0017.xhtml#fig5-4)
    中类似的模式。
- en: '![](images/nsp-venkitachalam503045-f05004.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f05004.jpg)'
- en: 'Figure 5-4: A sample run of the Boids simulation'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-4：Boids 模拟的示例运行
- en: Left-click the simulation window. A new boid should appear at that location,
    and its velocity should change as it encounters the flock. Now right-click. The
    flock should initially scatter from your cursor but then recoalesce.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 单击模拟窗口。一个新的鸟群应该出现在那个位置，并且它的速度应随着遇到鸟群而改变。现在右键点击。鸟群应该首先从光标处分散，但然后重新聚集。
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah0705)'
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[总结](nsp-venkitachalam503045-0008.xhtml#rah0705)'
- en: In this project, you simulated the flocking of birds (or boids) using the three
    rules proposed by Craig Reynolds. You looked at how operating on an entire `numpy`
    array at once is much faster than performing the same operations inside an explicit
    loop. You used the `scipy.spatial` module to perform fast and convenient distance
    calculations, and you implemented a `matplotlib` trick that uses two markers to
    represent both the position and the direction of points. Finally, you added interactivity
    to the simulation in the form of an event handler to respond to button presses
    within the `matplotlib` plot.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你使用了 Craig Reynolds 提出的三条规则模拟了鸟群（或鸟群模型，boids）的行为。你发现一次性对整个 `numpy` 数组进行操作比在显式循环中执行相同操作要快得多。你使用了
    `scipy.spatial` 模块进行快速且方便的距离计算，并实现了一个 `matplotlib` 技巧，利用两个标记来表示点的位置和方向。最后，你还为模拟增加了交互性，通过事件处理程序响应
    `matplotlib` 图表中的按钮点击。
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah0706)'
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实验！](nsp-venkitachalam503045-0008.xhtml#rah0706)'
- en: 'Here are some ways you might further explore flocking behavior:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可能会用来进一步探索鸟群行为的方法：
- en: '1\. Implement obstacle avoidance for your flock of boids by writing a new method
    called `avoidObstacle()` and applying it right after you apply the three rules,
    as follows:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 通过编写一个新的方法 `avoidObstacle()` 来实现鸟群的避障功能，并在应用完三条规则后立即应用它，具体如下：
- en: self.vel += self.applyRules()
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.vel += self.applyRules()
- en: self.vel += self.avoidObstacle()
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: self.vel += self.avoidObstacle()
- en: The `avoidObstacle()` method should use a predefined tuple (*x*, *y*, *R*) to
    add an additional velocity term to a boid, pushing it away from the obstacle location
    (*x*, *y*), but only when the boid is within radius *R* of the obstacle. Think
    of this as the distance at which a boid sees the obstacle and steers away from
    it. You can specify the (*x*, *y*, *R*) tuple using a command line option.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`avoidObstacle()` 方法应该使用一个预定义的元组 (*x*, *y*, *R*)，为鸟群添加一个额外的速度项，将其推离障碍物的位置 (*x*,
    *y*)，但仅当鸟群在障碍物的半径 *R* 内时才有效。可以将其理解为鸟群看到障碍物并避开它的距离。你可以使用命令行选项来指定 (*x*, *y*, *R*)
    元组。'
- en: 2\. What happens when the boids fly through a strong gust of wind? Simulate
    this by adding a global velocity component to all the boids at random time steps
    in the simulation. The boids should temporarily be affected by the wind but return
    to the flock once the wind stops.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 当鸟群飞过强烈的风口时会发生什么？通过在模拟中随机时间步长添加一个全局速度分量到所有鸟群来模拟这一情况。鸟群应该会暂时受到风的影响，但当风停时，应该返回到群体中。
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah0707)'
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整代码](nsp-venkitachalam503045-0008.xhtml#rah0707)'
- en: 'Here’s the complete code for the Boids simulation:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Boids 模拟的完整代码：
- en: '"""'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: boids.py
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: boids.py
- en: An implementation of Craig Reynolds's Boids simulation.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Craig Reynolds 的 Boids 模拟实现。
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：Mahesh Venkitachalam
- en: '"""'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: import argparse
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: import argparse
- en: import math
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: import math
- en: import numpy as np
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: import matplotlib.pyplot as plt
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.pyplot as plt
- en: import matplotlib.animation as animation
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.animation as animation
- en: from scipy.spatial.distance import squareform, pdist
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: from scipy.spatial.distance import squareform, pdist
- en: from numpy.linalg import norm
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: from numpy.linalg import norm
- en: width, height = 640, 480
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: width, height = 640, 480
- en: 'class Boids:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Boids:'
- en: '"""class that represents Boids simulation"""'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '"""表示 Boids 模拟的类"""'
- en: 'def __init__(self, N):'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, N):'
- en: '"""initialize the Boids simulation"""'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '"""初始化 Boids 模拟"""'
- en: '# init position & velocities'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化位置和速度'
- en: self.pos = [width/2.0, height/2.0] +
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: self.pos = [width/2.0, height/2.0] +
- en: 10*np.random.rand(2*N).reshape(N, 2)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 10*np.random.rand(2*N).reshape(N, 2)
- en: '# normalized random velocities'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '# 标准化随机速度'
- en: angles = 2*math.pi*np.random.rand(N)
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: angles = 2*math.pi*np.random.rand(N)
- en: self.vel = np.array(list(zip(np.cos(angles), np.sin(angles))))
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: self.vel = np.array(list(zip(np.cos(angles), np.sin(angles))))
- en: self.N = N
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: self.N = N
- en: '# min dist of approach'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '# 最小接近距离'
- en: self.minDist = 25.0
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: self.minDist = 25.0
- en: '# max magnitude of velocities calculated by "rules"'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '# "规则" 计算出的速度的最大大小'
- en: self.maxRuleVel = 0.03
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: self.maxRuleVel = 0.03
- en: '# max magnitude of final velocity'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '# 最终速度的最大大小'
- en: self.maxVel = 2.0
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: self.maxVel = 2.0
- en: 'def tick(self, frameNum, pts, head):'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 'def tick(self, frameNum, pts, head):'
- en: '"""update the simulation by one time step"""'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '"""通过一步时间更新模拟"""'
- en: '# apply rules'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用规则'
- en: self.vel += self.applyRules()
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: self.vel += self.applyRules()
- en: self.limit(self.vel, self.maxVel)
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: self.limit(self.vel, self.maxVel)
- en: self.pos += self.vel
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: self.pos += self.vel
- en: self.applyBC()
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: self.applyBC()
- en: '# update data'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '# 更新数据'
- en: pts.set_data(self.pos.reshape(2*self.N)[::2],
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: pts.set_data(self.pos.reshape(2*self.N)[::2],
- en: self.pos.reshape(2*self.N)[1::2])
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: self.pos.reshape(2*self.N)[1::2])
- en: vec = self.pos + 10*self.vel/self.maxVel
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: vec = self.pos + 10*self.vel/self.maxVel
- en: head.set_data(vec.reshape(2*self.N)[::2],
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: head.set_data(vec.reshape(2*self.N)[::2],
- en: vec.reshape(2*self.N)[1::2])
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: vec.reshape(2*self.N)[1::2])
- en: 'def limitVec(self, vec, maxVal):'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 'def limitVec(self, vec, maxVal):'
- en: '"""limit magnitude of 2D vector"""'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '"""限制2D向量的大小"""'
- en: mag = norm(vec)
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: mag = norm(vec)
- en: 'if mag > maxVal:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 'if mag > maxVal:'
- en: vec[0], vec[1] = vec[0]*maxVal/mag, vec[1]*maxVal/mag
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: vec[0], vec[1] = vec[0]*maxVal/mag, vec[1]*maxVal/mag
- en: 'def limit(self, X, maxVal):'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 'def limit(self, X, maxVal):'
- en: '"""limit magnitude of 2D vectors in array X to maxValue"""'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '"""限制数组X中2D向量的大小不超过maxVal"""'
- en: 'for vec in X:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 'for vec in X:'
- en: self.limitVec(vec, maxVal)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: self.limitVec(vec, maxVal)
- en: 'def applyBC(self):'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 'def applyBC(self):'
- en: '"""apply boundary conditions"""'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '"""应用边界条件"""'
- en: deltaR = 2.0
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: deltaR = 2.0
- en: 'for coord in self.pos:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 'for coord in self.pos:'
- en: 'if coord[0] > width + deltaR:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 'if coord[0] > width + deltaR:'
- en: coord[0] = - deltaR
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: coord[0] = - deltaR
- en: 'if coord[0] < - deltaR:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 'if coord[0] < - deltaR:'
- en: coord[0] = width + deltaR
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: coord[0] = width + deltaR
- en: 'if coord[1] > height + deltaR:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 'if coord[1] > height + deltaR:'
- en: coord[1] = - deltaR
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: coord[1] = - deltaR
- en: 'if coord[1] < - deltaR:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 'if coord[1] < - deltaR:'
- en: coord[1] = height + deltaR
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: coord[1] = height + deltaR
- en: 'def applyRules(self):'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 'def applyRules(self):'
- en: '# get pairwise distances'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取成对距离'
- en: self.distMatrix = squareform(pdist(self.pos))
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: self.distMatrix = squareform(pdist(self.pos))
- en: '# apply rule #1 - separation'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用规则#1 - 分离'
- en: D = self.distMatrix < self.minDist
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: D = self.distMatrix < self.minDist
- en: vel = self.pos*D.sum(axis=1).reshape(self.N, 1) - D.dot(self.pos)
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: vel = self.pos*D.sum(axis=1).reshape(self.N, 1) - D.dot(self.pos)
- en: self.limit(vel, self.maxRuleVel)
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: self.limit(vel, self.maxRuleVel)
- en: '# different distance threshold'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '# 不同的距离阈值'
- en: D = self.distMatrix < 50.0
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: D = self.distMatrix < 50.0
- en: '# apply rule #2 - alignment'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用规则#2 - 对齐'
- en: vel2 = D.dot(self.vel)
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: vel2 = D.dot(self.vel)
- en: self.limit(vel2, self.maxRuleVel)
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: self.limit(vel2, self.maxRuleVel)
- en: vel += vel2;
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: vel += vel2;
- en: '# apply rule #1 - cohesion'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '# 应用规则#1 - 凝聚'
- en: vel3 = D.dot(self.pos) - self.pos
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: vel3 = D.dot(self.pos) - self.pos
- en: self.limit(vel3, self.maxRuleVel)
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: self.limit(vel3, self.maxRuleVel)
- en: vel += vel3
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: vel += vel3
- en: return vel
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: return vel
- en: 'def buttonPress(self, event):'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 'def buttonPress(self, event):'
- en: '"""event handler for matplotlib button presses"""'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '"""matplotlib按钮按下事件处理函数"""'
- en: '# left-click - add a boid'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '# 左键点击 - 添加一个boid'
- en: 'if event.button == 1:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 'if event.button == 1:'
- en: self.pos = np.concatenate((self.pos,
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: self.pos = np.concatenate((self.pos,
- en: np.array([[event.xdata, event.ydata]])),
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: np.array([[event.xdata, event.ydata]])),
- en: axis=0)
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: axis=0)
- en: '# random velocity'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '# 随机速度'
- en: angles = 2*math.pi*np.random.rand(1)
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: angles = 2*math.pi*np.random.rand(1)
- en: v = np.array(list(zip(np.sin(angles), np.cos(angles))))
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: v = np.array(list(zip(np.sin(angles), np.cos(angles))))
- en: self.vel = np.concatenate((self.vel, v), axis=0)
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: self.vel = np.concatenate((self.vel, v), axis=0)
- en: self.N += 1
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: self.N += 1
- en: '# right-click - scatter'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '# 右键点击 - 扫描'
- en: 'elif event.button == 3:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif event.button == 3:'
- en: '# add scattering velocity'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加散射速度'
- en: self.vel += 0.1*(self.pos - np.array([[event.xdata, event.ydata]]))
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: self.vel += 0.1*(self.pos - np.array([[event.xdata, event.ydata]]))
- en: 'def tick(frameNum, pts, head, boids):'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 'def tick(frameNum, pts, head, boids):'
- en: '"""update function for animation"""'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '"""动画更新函数"""'
- en: boids.tick(frameNum, pts, head)
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: boids.tick(frameNum, pts, head)
- en: return pts, head
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: return pts, head
- en: main() function
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: main()函数
- en: 'def main():'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '# use sys.argv if needed'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如有需要，可使用sys.argv'
- en: print('starting boids...')
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: print('启动boids...')
- en: parser = argparse.ArgumentParser(description=
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: parser = argparse.ArgumentParser(description=
- en: '"Implementing Craig Reynolds''s Boids...")'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '"实现Craig Reynolds的Boids算法..."'
- en: '# add arguments'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加参数'
- en: parser.add_argument('--num-boids', dest='N', required=False)
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--num-boids', dest='N', required=False)
- en: args = parser.parse_args()
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: args = parser.parse_args()
- en: '# number of boids'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '# boids的数量'
- en: N = 100
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: N = 100
- en: 'if args.N:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.N:'
- en: N = int(args.N)
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: N = int(args.N)
- en: '# create boids'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建boids'
- en: boids = Boids(N)
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: boids = Boids(N)
- en: '# setup plot'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置绘图'
- en: fig = plt.figure()
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: fig = plt.figure()
- en: ax = plt.axes(xlim=(0, width), ylim=(0, height))
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: ax = plt.axes(xlim=(0, width), ylim=(0, height))
- en: pts = ax.plot([], [], markersize=10,
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: pts = ax.plot([], [], markersize=10,
- en: c='k', marker='o', ls='None')
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: c='k', marker='o', ls='None')
- en: head, = ax.plot([], [], markersize=4,
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: head, = ax.plot([], [], markersize=4,
- en: c='r', marker='o', ls='None')
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: c='r', marker='o', ls='None')
- en: anim = animation.FuncAnimation(fig, tick, fargs=(pts[0], head, boids),
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: anim = animation.FuncAnimation(fig, tick, fargs=(pts[0], head, boids),
- en: interval=50)
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: interval=50)
- en: '# add a "button press" event handler'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加“按钮按下”事件处理函数'
- en: cid = fig.canvas.mpl_connect('button_press_event', boids.buttonPress)
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: cid = fig.canvas.mpl_connect('button_press_event', boids.buttonPress)
- en: plt.show()
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show()
- en: call main
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用 main
- en: 'if __name__ == ''__main__'':'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: main()
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: main()
