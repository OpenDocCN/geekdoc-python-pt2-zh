["```py\nBTree {\n    BTreeNode: root\n    Integer: k\n}\n\nBTreeNode {\n    Integer: k\n    Integer: size\n    Boolean: is_leaf\n    Array of Type: keys\n    Array of BTreeNodes: children\n}\n```", "```py\nBTreeSearch(BTree: tree, Type: target):\n    return BTreeNodeSearch(tree.root, target)\n\nBTreeNodeSearch(BTreeNode: node, Type: target):\n    # Search the node's key list for the target.\n    Integer: i = 0\n  ❶ WHILE i < node.size AND target >= node.keys[i]:\n      ❷ IF target == node.keys[i]:\n            return node.keys[i]\n        i = i + 1\n\n    # Descend to the correct child.\n  ❸ IF node.is_leaf:\n        return null\n  ❹ return BTreeNodeSearch(node.children[i], target)\n```", "```py\nBTreeNodeAddKey(BTreeNode: node, Type: key, \n                BTreeNode: next_child):\n  ❶ Integer: i = node.size - 1\n    WHILE i >= 0 AND key < node.keys[i]:\n        node.keys[i+1] = node.keys[i]\n        IF NOT node.is_leaf:\n            node.children[i+2] = node.children[i+1]\n        i = i - 1\n\n # Insert both the key and the pointer to the child node.\n  ❷ node.keys[i+1] = key\n    IF NOT node.is_leaf:\n        node.children[i+2] = next_child\n  ❸ node.size = node.size + 1\n```", "```py\nBTreeNodeIsOverFull(BTreeNode: node):\n    return node.size == (2 * node.k + 1)\n```", "```py\nBTreeNodeSplit(BTreeNode: node, Integer: child_index): \n  ❶ BTreeNode: old_child = node.children[child_index]\n    BTreeNode: new_child = BTreeNode(node.k)\n    new_child.is_leaf = old_child.is_leaf\n\n    # Get the index and key used for the split.\n  ❷ Integer: split_index = Floor(old_child.size / 2.0)\n    Type: split_key = old_child.keys[split_index]    \n\n    # Copy the larger half of the keys (and their children) to \n    # new_child and erase them from old_child.\n    Integer: new_index = 0\n    Integer: old_index = split_index + 1\n  ❸ WHILE old_index < old_child.size:\n        new_child.keys[new_index] = old_child.keys[old_index]\n        old_child.keys[old_index] = null\n\n        IF NOT old_child.is_leaf:\n            new_child.children[new_index] = old_child.children[old_index]\n            old_child.children[old_index] = null\n        new_index = new_index + 1\n        old_index = old_index + 1\n\n    # Copy the remaining child (after the last key).\n  ❹ IF NOT old_child.is_leaf:\n        new_child.children[new_index] = old_child.children[old_child.size]\n        old_child.children[old_child.size] = null\n\n    # Remove the key at index and add it to the current node.\n  ❺ old_child.keys[split_index] = null\n  ❻ BTreeNodeAddKey(node, split_key, new_child)\n\n    # Update the sizes of the nodes.\n  ❼ new_child.size = old_child.size - split_index - 1\n    old_child.size = split_index\n```", "```py\nBTreeNodeInsert(BTreeNode: node, Type: key):\n    Integer: i = 0\n  ❶ WHILE i < node.size AND key >= node.keys[i]:\n      ❷ IF key == node.keys[i]:\n            Update data.\n            return\n        i = i + 1\n\n    IF node.is_leaf:\n      ❸ BTreeNodeAddKey(node, key, null)\n    ELSE:\n      ❹ BTreeNodeInsert(node.children[i], key)\n      ❺ IF BTreeNodeIsOverFull(node.children[i]):\n          ❻ BTreeNodeSplit(node, i)\n```", "```py\nBTreeInsert(BTree: tree, Type: key): \n  ❶ BTreeNodeInsert(tree.root, key)\n\n  ❷ IF BTreeNodeIsOverFull(tree.root):\n      ❸ BTreeNode: new_root = BTreeNode(tree.k)\n        new_root.is_leaf = False\n        new_root.size = 0\n\n      ❹ new_root.children[0] = tree.root\n      ❺ BTreeNodeSplit(new_root, 0)\n      ❻ tree.root = new_root\n```", "```py\nBTreeNodeIsUnderFull(BTreeNode: node):\n    return node.size < node.k\n```", "```py\nBTreeNodeMerge(BTreeNode: node, Integer: index):\n  ❶ BTreeNode: childL = node.children[index]\n    BTreeNode: childR = node.children[index + 1]\n\n    # Copy over the parent's key and the right child's first child pointer.\n  ❷ Integer: loc = childL.size\n    childL.keys[loc] = node.keys[index]\n    IF NOT childL.is_leaf:\n        childL.children[loc + 1] = childR.children[0]\n    loc = loc + 1\n\n  ❸ # Copy over the right child's keys and children.\n    Integer: i = 0\n    WHILE i < childR.size:\n        childL.keys[loc + i] = childR.keys[i]\n        IF NOT childL.is_leaf:\n            childL.children[loc + i + 1] = childR.children[i + 1]\n        i = i + 1\n    childL.size = childL.size + childR.size + 1\n\n    # Remove the key from the current node.\n    i = index\n  ❹ WHILE i < node.size - 1:\n        node.keys[i] = node.keys[i + 1]\n        node.children[i + 1] = node.children[i + 2]\n        i = i + 1\n    node.keys[i] = null\n    node.children[i + 1] = null\n    node.size = node.size – 1\n```", "```py\nBTreeNodeTransferLeft(BTreeNode: node, Integer: index):\n  ❶ BTreeNode: childL = node.children[index]\n    BTreeNode: childR = node.children[index + 1]\n    Type: middle_key = node.keys[index]\n\n  ❷ node.keys[index] = childR.keys[0]\n  ❸ childL.keys[childL.size] = middle_key\n    IF NOT childR.is_leaf:\n        childL.children[childL.size + 1] = childR.children[0]\n    childL.size = childL.size + 1\n\n  ❹ Integer: i = 0\n    WHILE i < childR.size - 1:\n        childR.keys[i] = childR.keys[i + 1]\n        IF NOT childR.is_leaf:\n            childR.children[i] = childR.children[i + 1]\n        i = i + 1\n\n  ❺ childR.keys[i] = null\n    IF NOT childR.is_leaf:\n        childR.children[i] = childR.children[i + 1]\n        childR.children[i + 1] = null\n  ❻ childR.size = childR.size – 1\n```", "```py\nBTreeNodeTransferRight(BTreeNode: node, Integer: index):\n  ❶ BTreeNode: childL = node.children[index]\n    BTreeNode: childR = node.children[index + 1]\n    Type: middle_key = node.keys[index]\n\n    # Make space in childR for the new key and pointer.\n  ❷ Integer: i = childR.size - 1\n    WHILE i >= 0:\n        childR.keys[i+1] = childR.keys[i]\n IF NOT childR.is_leaf:\n            childR.children[i+2] = childR.children[i+1]\n        i = i – 1\n    IF NOT childR.is_leaf:\n        childR.children[1] = childR.children[0]\n\n  ❸ childR.keys[0] = middle_key\n    IF NOT childR.is_leaf:\n        childR.children[0] = childL.children[childL.size]\n    childR.size = childR.size + 1\n\n  ❹ node.keys[index] = childL.keys[childL.size – 1]\n\n  ❺ childL.keys[childL.size - 1] = null\n    IF NOT childL.is_leaf:\n        childL.children[childL.size] = null\n    childL.size = childL.size – 1\n```", "```py\nBTreeNodeRepairUnderFull(BTreeNode: node, Integer: child):\n  ❶ IF child == node.size:\n        child = child - 1\n  ❷ Integer: total = (node.children[child].size + \n                      node.children[child + 1].size)\n\n    IF total < 2 * node.k:\n      ❸ BTreeNodeMerge(node, child)\n        return\n\n ❹ IF node.children[child].size < node.children[child + 1].size:\n        BTreeNodeTransferLeft(node, child)\n    ELSE:\n        BTreeNodeTransferRight(node, child)\n```", "```py\nBTreeNodeFindMin(BTreeNode: node):\n  ❶ IF node.size == 0:\n        return null\n  ❷ IF node.is_leaf:\n        return node.keys[0]\n    ELSE:\n      ❸ return BTreeNodeFindMin(node.children[0])\n```", "```py\nBTreeDelete(BTree: tree, Type: key):\n    BTreeNodeDelete(tree.root, key)\n\n    IF tree.root.size == 0 AND NOT tree.root.is_leaf:\n        tree.root = tree.root.children[0]\n```", "```py\nBTreeNodeDelete(BTreeNode: node, Type: key):\n  ❶ Integer: i = 0\n    WHILE i < node.size AND key > node.keys[i]:\n        i = i + 1\n\n    # Deletion from a leaf node.\n    IF node.is_leaf:\n        IF i < node.size AND key == node.keys[i]:\n          ❷ WHILE i < node.size - 1:\n                node.keys[i] = node.keys[i + 1]\n                i = i + 1\n            node.keys[i] = null\n            node.size = node.size - 1\n        return\n\n    # Deletion at an internal node.\n    IF i < node.size AND key == node.keys[i]:\n      ❸ Type: min_key = BTreeNodeFindMin(node.children[i+1])\n        node.keys[i] = min_key\n\n      ❹ BTreeNodeDelete(node.children[i+1], min_key)\n        IF BTreeNodeIsUnderFull(node.children[i+1]):\n            BTreeNodeRepairUnderFull(node, i+1)\n    ELSE:\n      ❺ BTreeNodeDelete(node.children[i], key)\n        IF BTreeNodeIsUnderFull(node.children[i]):\n            BTreeNodeRepairUnderFull(node, i)\n```"]