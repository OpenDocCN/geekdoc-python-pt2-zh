<html><head></head><body>
<h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_23"/><span class="big">2</span><br/>TWO PYTHON PARADIGMS</h2>&#13;
<div class="image1"><img src="../images/common01.jpg" alt="Image"/></div>&#13;
<p class="noindent">Now that we’ve explored some topics in the Python programming language, let’s learn about the two main paradigms we can use to write code. In this second chapter on Python, we’ll discuss the functional and object-oriented programming paradigms and the benefits each brings. We’ll wrap up with a brief look at type hints. Let’s get started.</p>&#13;
<h3 class="h3" id="ch00lev1sec17"><strong>Functional Programming</strong></h3>&#13;
<p class="noindent">Functional programming is a programming paradigm, which means that it’s a style of writing code we can decide to adhere to. For us to say “we’re writing functional-style code” we have to follow some simple rules that define what functional programming is about.</p>&#13;
<p class="indent">The central elements of the functional programming paradigm are pure functions and the immutability of data. We’ll break these concepts down in the next sections.</p>&#13;
<p class="indent">Not all programming languages have good support for writing functional-style code. For example, languages like C have no good support for it. On <span epub:type="pagebreak" id="page_24"/>the other hand, there are languages, like Haskell, that are purely functional, meaning you can only write functional-style code. By design, Python isn’t a functional language, but it does have support for the functional programming style.</p>&#13;
<p class="indent">Let’s learn about pure functions.</p>&#13;
<h4 class="h4" id="ch00lev2sec17"><strong><em>Pure Functions</em></strong></h4>&#13;
<p class="noindent">Let’s quickly review the syntax for a Python function:</p>&#13;
<pre>def <span class="codeitalic1">function_name</span>(<span class="codeitalic1">parameters</span>):&#13;
    &lt;<span class="codeitalic1">function body</span>&gt;</pre>&#13;
<p class="noindent">The definition of a function starts with the <span class="literal">def</span> keyword followed by the name of the function and the input parameters inside parentheses. A colon (:) marks the end of the function header. The code in the body of the function is indented one level.</p>&#13;
<p class="indent">A function, in the functional programming paradigm, is similar to the mathematical concept of a function: a mapping of some input to some output. We say a function is <em>pure</em> if</p>&#13;
<ul>&#13;
<li class="noindent">It consistently returns the same outputs for the same set of inputs.</li>&#13;
<li class="noindent">It doesn’t have side effects.</li>&#13;
</ul>&#13;
<p class="indent">A <em>side effect</em> happens when something outside the body of the function is mutated by the function. A side effect also occurs when the function’s inputs are modified by the function, because a pure function never modifies its inputs. For example, the following function is pure:</p>&#13;
<pre>def make_vector_between(p, q):&#13;
    u = q['x'] - p['x']&#13;
    v = q['y'] - p['y']&#13;
&#13;
    return {'u': u, 'v': v}</pre>&#13;
<p class="noindent">Given the same input points <span class="literal">p</span> and <span class="literal">q</span>, the output is always the same vector, and nothing outside the function’s body is modified. In contrast, the following code is an impure version of <span class="literal">make_vector</span>:</p>&#13;
<pre>last_point = {'x': 10, 'y': 20}&#13;
&#13;
def make_vector(q):&#13;
    u = q['x'] - last_point['x']&#13;
    v = q['y'] - last_point['y']&#13;
    new_vector = {'u': u, 'v': v}&#13;
    last_point = q&#13;
&#13;
    return new_vector</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_25"/>The previous snippet uses the shared state of <span class="literal">last_point</span>, which is mutated every time <span class="literal">make_vector</span> is called. This mutation is a side effect of the function. The returned vector depends on the <span class="literal">last_point</span> shared state, so the function doesn’t return the same vector consistently for the same input point.</p>&#13;
<h4 class="h4" id="ch00lev2sec18"><strong><em>Immutability</em></strong></h4>&#13;
<p class="noindent">As you saw in the previous example, one key aspect of functional programming is <em>immutability</em>. Something is immutable if it doesn’t change with time. If we decide to write code in the functional programming style, we make the firm decision of avoiding data mutations and modeling our programs using pure functions.</p>&#13;
<p class="indent">Let’s take a look at an example. Imagine we had defined a point and a vector in the plane using dictionaries:</p>&#13;
<pre>point = {'x': 5, 'y': 2}&#13;
vector = {'u': 10, 'v': 20}</pre>&#13;
<p class="noindent">If we wanted to compute the point resulting from displacing the existing point by the vector, we could do it in a functional way by creating a new point using a function. Here’s an example:</p>&#13;
<pre>def displaced_point(point, vector):&#13;
    x = point['x'] + vector['u']&#13;
    y = point['y'] + vector['v']&#13;
&#13;
    return {'x': x, 'y': y}</pre>&#13;
<p class="noindent">This function is pure: given the same <span class="literal">point</span> and <span class="literal">vector</span> inputs, the resulting displaced point is consistently the same, and there is nothing that escapes the function’s body that is mutated in any sense, not even the function parameters.</p>&#13;
<p class="indent">If we run this function, passing in the <span class="literal">point</span> and <span class="literal">vector</span> defined earlier, we get the following:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">displaced_point(point, vector)</span>&#13;
{'x': 15, 'y': 22}&#13;
&#13;
# let's check the state of point (shouldn't have been mutated)&#13;
&gt;&gt;&gt; <span class="codestrong1">point</span>&#13;
{'x': 5, 'y': 2}</pre>&#13;
<p class="indent">Conversely, a nonfunctional way of solving this case could involve mutating the original point using a function like the following:</p>&#13;
<pre>def displace_point_in_place(point, vector):&#13;
    point['x'] += vector['u']&#13;
    point['y'] += vector['v']</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_26"/>This function mutates the point it receives as an argument, which violates one of the key rules of the functional style.</p>&#13;
<p class="indent">Note the use of <span class="literal">in_place</span> in the function name. This is a commonly used naming convention that implies that the changes will happen by mutating the original object. We’ll adhere to this naming convention throughout the book.</p>&#13;
<p class="indent">Now let’s see how we’d go about using this <span class="literal">displace_point_in_place</span> function:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">displace_point_in_place(point, vector)</span>&#13;
# nothing gets returned from the function, so let's check the point&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">point</span>&#13;
{'x': 15, 'y': 22}&#13;
# the original point has been mutated!</pre>&#13;
<p class="noindent">As you can see, the function isn’t returning anything, which is a sign that the function isn’t pure, because to do some kind of useful operation it must have mutated something somewhere. In this case, that “something” is our point, whose coordinates have been updated.</p>&#13;
<p class="indent">An important benefit of the functional style is that by respecting the immutability of data structures, we avoid unintended side effects. When you mutate an object, you may not be aware of all the places in your code where that object is referenced. If there are other parts in the code relying on that object’s state, there may be side effects you are not aware of. So, after the object was mutated, your program may behave differently than expected. These kinds of errors are extremely hard to hunt down and can require hours of debugging.</p>&#13;
<p class="indent">If we minimize the number of mutations in our project, we make it more reliable and less error prone.</p>&#13;
<p class="indent">Let’s now take a look at a special kind of function that has a central role in functional programming: the lambda function.</p>&#13;
<h4 class="h4" id="ch00lev2sec19"><strong><em>Lambdas</em></strong></h4>&#13;
<p class="noindent">Back in the 1930s, a mathematician named Alonzo Church invented lambda calculus, a theory about functions and how they are applied to their arguments. Lambda calculus is the core of functional programming.</p>&#13;
<p class="indent">In Python, a <em>lambda function</em>, or <em>lambda</em>, is an anonymous, typically short function defined on a single line. We’ll find lambdas to be useful when passing functions as parameters to other functions, for instance.</p>&#13;
<p class="indent">We define a lambda function in Python using the <span class="literal">lambda</span> keyword followed by the arguments (separated by commas), a colon, and the function’s expression body:</p>&#13;
<pre>    lambda &lt;<span class="codeitalic1">arg1</span>&gt;, &lt;<span class="codeitalic1">arg2</span>&gt;, ...: &lt;<span class="codeitalic1">expression body</span>&gt;</pre>&#13;
<p class="noindent">The expression’s result is the returned value.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_27"/>A lambda function to sum two numbers can be written as follows:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">sum = lambda x, y: x + y</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">sum(1, 2)</span>&#13;
3</pre>&#13;
<p class="indent">This is equivalent to the regular Python function:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">def sum(x, y):</span>&#13;
...     <span class="codestrong1">return x + y</span>&#13;
...&#13;
&gt;&gt;&gt; <span class="codestrong1">sum(1, 2)</span>&#13;
3</pre>&#13;
<p class="indent">Lambdas are going to appear in the next sections; we’ll see there how they’re used in several contexts. The place we’ll be using lambdas the most is as arguments to the <span class="literal">filter</span>, <span class="literal">map</span>, and <span class="literal">reduce</span> functions, as we’ll discuss in “Filter, Map, and Reduce” on <a href="ch02.xhtml#ch00lev2sec22">page 29</a>.</p>&#13;
<h4 class="h4" id="ch00lev2sec20"><strong><em>Higher-Order Functions</em></strong></h4>&#13;
<p class="noindent">A <em>higher-order</em> function is a function that either receives a function (or functions) as input parameters or returns a function as its result.</p>&#13;
<p class="indent">Let’s take a look at examples for both cases.</p>&#13;
<h5 class="h5" id="ch00lev3sec10"><strong>Functions As Function Arguments</strong></h5>&#13;
<p class="noindent">Imagine we want to write a function that can run a function a given number of times. We could implement this as follows:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">def repeat_fn(fn, times):</span>&#13;
...     <span class="codestrong1">for _ in range(times):</span>&#13;
...         <span class="codestrong1">fn()</span>&#13;
...&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">def say_hi():</span>&#13;
...     <span class="codestrong1">print('Hi there!')</span>&#13;
...&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">repeat_fn(say_hi, 5)</span>&#13;
Hi there!&#13;
Hi there!&#13;
Hi there!&#13;
Hi there!&#13;
Hi there!</pre>&#13;
<p class="indent">As you can see, the <span class="literal">repeat_fn</span> function’s first parameter is another function, which is executed as many times as the second argument <span class="literal">times</span> dictates. Then, we define another function to simply print the string <span class="literal">"Hi</span> <span class="literal">there!"</span> <span epub:type="pagebreak" id="page_28"/>to the screen: <span class="literal">say_hi</span>. The result of calling the <span class="literal">repeat_fn</span> function and passing it <span class="literal">say_hi</span> is those five greetings.</p>&#13;
<p class="indent">We could rewrite the previous example using an anonymous lambda function:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">def repeat_fn(fn, times):</span>&#13;
...     <span class="codestrong1">for _ in range(times):</span>&#13;
...         <span class="codestrong1">fn()</span>&#13;
...&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">repeat_fn(lambda: print("Hello!"), 5)</span>&#13;
Hello!&#13;
Hello!&#13;
Hello!&#13;
Hello!&#13;
Hello!</pre>&#13;
<p class="noindent">This spares us from having to define a named function to print the message.</p>&#13;
<h5 class="h5" id="ch00lev3sec11"><strong>Functions As Function Return Values</strong></h5>&#13;
<p class="noindent">Let’s take a look at a function that returns another function. Imagine we want to define validation functions that validate if a given string contains a sequence of characters. We can write a function named <span class="literal">make_contains_validator</span> that takes a sequence and returns a function to validate strings that contain that sequence:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">def make_contains_validator(sequence):</span>&#13;
...     <span class="codestrong1">return lambda string: sequence in string</span></pre>&#13;
<p class="noindent">We can use this function to generate validation functions, like the following one,</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">validate_contains_at = make_contains_validator('@')</span></pre>&#13;
<p class="noindent">which can be used to check whether the passed-in strings contain the <span class="literal">@</span> character:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">validate_contains_at('foo@bar.com')</span>&#13;
True&#13;
&gt;&gt;&gt; <span class="codestrong1">validate_contains_at('not this one')</span>&#13;
False</pre>&#13;
<p class="indent">Higher-order functions are a useful resource we’ll use throughout the book.</p>&#13;
<h4 class="h4" id="ch00lev2sec21"><strong><em>Functions Inside Other Functions</em></strong></h4>&#13;
<p class="noindent">Another convenient technique we’ll use throughout this book is defining a function inside another function. There are two good reasons we may want to do this: for one, it gives the inner function access to everything inside the <span epub:type="pagebreak" id="page_29"/>outer function, without needing to pass that information as parameters; and also, the inner function may define some logic that we don’t want to expose to the outside world.</p>&#13;
<p class="indent">A function can be defined inside another function using the regular syntax. Let’s take a look at an example:</p>&#13;
<pre>def outer_fn(a, b):&#13;
    c = a + b&#13;
&#13;
    def inner_fn():&#13;
        # we have access to a, b and c here&#13;
        print(a, b, c)&#13;
&#13;
    inner_fn()</pre>&#13;
<p class="indent">Here, the <span class="literal">inner_fn</span> function is defined inside the <span class="literal">outer_fn</span> function, and thus, it can’t be accessed from outside this host function, only from within its body. The <span class="literal">inner_fn</span> function has access to everything defined inside <span class="literal">outer_fn</span>, including the function parameters.</p>&#13;
<p class="indent">Defining subfunctions inside of functions is useful when a function’s logic grows complex and it can be broken down into smaller tasks. Of course, we could also split the function into smaller functions all defined at the same level. In this case, to signal that those subfunctions are not meant to be imported and consumed from outside the module, we’ll follow Python’s standard and name those functions starting with two underscores:</p>&#13;
<pre>def public_fn():&#13;
    # this function can be imported&#13;
&#13;
def __private_fn():&#13;
    # this function should only be accessed from inside the module</pre>&#13;
<p class="indent">Note that Python has no access modifiers (public, private, . . .); thus, all the code written at the top level of a module, that is, a Python file, can be imported and used.</p>&#13;
<p class="indent">Remember that the two underscores are just a convention that we have to respect. Nothing really prevents us from importing and using that code. If we import a function that starts with two underscores, we have to understand that the function was not written by its authors to be used from the outside, and we may get unexpected results if we call that function. By defining our subfunctions within the functions that call them, we prevent this behavior.</p>&#13;
<h4 class="h4" id="ch00lev2sec22"><strong><em>Filter, Map, and Reduce</em></strong></h4>&#13;
<p class="noindent">In functional programming, we never mutate a collection’s items, but instead always create a new collection to reflect the changes of an operation over that collection. There are three operations that form the cornerstone <span epub:type="pagebreak" id="page_30"/>of functional programming and can accomplish every modification to a collection we can ever think of: <span class="literal">filter</span>, <span class="literal">map</span>, and <span class="literal">reduce</span>.</p>&#13;
<h5 class="h5" id="ch00lev3sec12"><strong>Filter</strong></h5>&#13;
<p class="noindent">The <em>filter</em> operation takes a collection and creates a new collection where some items may have been left out. The items are filtered according to a <em>predicate function</em>, which is a function that accepts one argument and returns either <span class="literal">True</span> or <span class="literal">False</span> depending on whether that argument passes a given test.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2fig1">Figure 2-1</a> illustrates the filter operation.</p>&#13;
<div class="image"><img src="../images/02fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch2fig1"><em>Figure 2-1: Filtering a collection</em></p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2fig1">Figure 2-1</a> shows a source collection made of four elements: A, B, C, and D. Below the collection is a box representing the predicate function, which determines which elements to keep and which to discard. Each element in the collection is passed to the predicate, and only those that pass the test are included in the resulting collection.</p>&#13;
<p class="indent">There are two ways we can filter collections in Python: using the <span class="literal">filter</span> global function and, if the collection is a list, using list comprehensions. We’ll focus on the <span class="literal">filter</span> function here; we’ll cover list comprehensions in the next section. Python’s <span class="literal">filter</span> function receives a function (the predicate) and collection as parameters:</p>&#13;
<pre>    filter(&lt;<span class="codeitalic1">predicate_fn</span>&gt;, &lt;<span class="codeitalic1">collection</span>&gt;)</pre>&#13;
<p class="indent">Let’s write a predicate lambda function to test whether a number is even:</p>&#13;
<pre>lambda n: n % 2 == 0</pre>&#13;
<p class="indent">Now let’s use our lambda function to filter a list of numbers and obtain a new collection with only even numbers:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">numbers = [1, 2, 3, 4, 5, 6, 7, 8]</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">evens = filter(lambda n: n % 2 == 0, numbers)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">list(evens)</span>&#13;
[2, 4, 6, 8]</pre>&#13;
<p class="noindent">One thing to note is that the <span class="literal">filter</span> function doesn’t return a list, but rather an iterator. Iterators allow for iteration over a collection of items, one at a time. If you want to know more about Python iterators and how they work under the hood, please refer to the documentation at <a href="https://docs.python.org/3/library/stdtypes.html#typeiter"><em>https://docs.python.org/3/library/stdtypes.html#typeiter</em></a> <span epub:type="pagebreak" id="page_31"/>and <a href="https://docs.python.org/3/glossary.html#term-iterator"><em>https://docs.python.org/3/glossary.html#term-iterator</em></a>.</p>&#13;
<p class="indent">We can consume all the iterator values and put them into a list using the <span class="literal">list</span> function we saw earlier. We can also consume the iterator using a <span class="literal">for</span> loop:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">for number in evens:</span>&#13;
...     <span class="codestrong1">print(number)</span>&#13;
...&#13;
2&#13;
4&#13;
6&#13;
8</pre>&#13;
<h5 class="h5" id="ch00lev3sec13"><strong>Map</strong></h5>&#13;
<p class="noindent">The <em>map</em> operation creates a new collection by taking each item in the source collection and running it through a function, storing the results in a new collection. The new collection is the same size as the source collection.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2fig2">Figure 2-2</a> illustrates the map operation.</p>&#13;
<div class="image"><img src="../images/02fig02.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch2fig2"><em>Figure 2-2: Mapping a collection</em></p>&#13;
<p class="indent">We run our source collection made of items A, B, C, and D through a mapping function, illustrated within a rectangle in <a href="ch02.xhtml#ch2fig2">Figure 2-2</a>; the result of the mapping is stored in a new collection.</p>&#13;
<p class="indent">We can map a collection either using the global <span class="literal">map</span> function or, if we have a list, using list comprehensions. We’ll discuss list comprehensions in a moment; for now, let’s study how to map collections using the <span class="literal">map</span> function.</p>&#13;
<p class="indent">The <span class="literal">map</span> global function receives two parameters: a mapping function and a source collection:</p>&#13;
<pre>    map(&lt;<span class="codeitalic1">mapping_fn</span>&gt;, &lt;<span class="codeitalic1">collection</span>&gt;)</pre>&#13;
<p class="indent">This is how we would map a list of names to their length:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">names = ['Angel', 'Alvaro', 'Mery', 'Paul', 'Isabel']</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">lengths = map(lambda name: len(name), names)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">list(lengths)</span>&#13;
[5, 6, 4, 4, 6]</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_32"/>As with the <span class="literal">filter</span> function, <span class="literal">map</span> returns an iterator that can be consumed into a list using the <span class="literal">list</span> function. In the previous example, the resulting list contains the number of letters in each of the names in the <span class="literal">names</span> list: five letters in <em>Angel</em>, six letters in <em>Alvaro</em>, and so on. We’ve mapped each name into a number representing its length.</p>&#13;
<h5 class="h5" id="ch00lev3sec14"><strong>Reduce</strong></h5>&#13;
<p class="noindent">The <em>reduce</em> operation is the most complex, but at the same time, it’s the most versatile of the three. It creates a new collection that can have fewer items than, more items than, or the same number of items as the original. To construct this new collection, it first applies a reducer function to the first and second elements. It then applies the reducer function to the third element <em>and</em> the result of the first application. It then applies the reducer function to the fourth element and the result of the second application. In this way, the results accumulate. A figure will help here. Take a look at <a href="ch02.xhtml#ch2fig3">Figure 2-3</a>.</p>&#13;
<div class="image"><img src="../images/02fig03.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch2fig3"><em>Figure 2-3: Reducing a collection</em></p>&#13;
<p class="indent">The reduction function in this example concatenates every element in the collection (A, B, C, and D) into a single element: ABCD.</p>&#13;
<p class="indent">The reducer function takes two parameters: the accumulated result and an item in the collection:</p>&#13;
<pre>    reducer_fn(&lt;<span class="codeitalic1">accumulated_result</span>&gt;, &lt;<span class="codeitalic1">item</span>&gt;)</pre>&#13;
<p class="noindent">The function is expected to return the accumulated result after the new item has been processed.</p>&#13;
<p class="indent">There’s no global <span class="literal">reduce</span> function provided by Python, but there is a package named <em>functools</em> with some useful operations for working with higher-order functions, including a <span class="literal">reduce</span> function. This function doesn’t return an iterator, but rather it returns the resulting collection or item directly. The function’s signature looks like this:</p>&#13;
<pre>    reduce(&lt;<span class="codeitalic1">reducer_fn</span>&gt;, &lt;<span class="codeitalic1">collection</span>&gt;)</pre>&#13;
<p class="indent">Let’s work with an example:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from functools import reduce</span>&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">letters = ['A', 'B', 'C', 'D']</span>&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">reduce(lambda result, letter: result + letter, letters)</span>&#13;
'ABCD'</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_33"/>In this example, the <span class="literal">reduce</span> function returned a single item: ’<span class="literal">ABCD</span>’, the result of concatenating each letter in the collection. To start the reduction process, the <span class="literal">reduce</span> function takes the first two letters, <em>A</em> and <em>B</em>, and concatenates them into <em>AB</em>. For this first step, Python uses the initial item of the collection (<em>A</em>) as the accumulated result and applies the reducer to it and the second item. Then, it moves to the third letter, <em>C</em>, and concatenates it with the current accumulated result <em>AB</em>, thus producing the new result: <em>ABC</em>. The last step does the same with the <em>D</em> letter to produce the result <em>ABCD</em>.</p>&#13;
<p class="indent">What happens when the accumulated result and the items of the collection have different types? In that case, we can’t take the first item as the accumulated result, and thus the <span class="literal">reduce</span> function expects us to provide a third argument to use as the starting accumulated result:</p>&#13;
<pre>    reduce(&lt;<span class="codeitalic1">reducer_fn</span>&gt;, &lt;<span class="codeitalic1">collection</span>&gt;, &lt;<span class="codeitalic1">start_result</span>&gt;)</pre>&#13;
<p class="indent">For example, imagine that we have the collection of names from earlier and we want to reduce it to obtain the total sum of the lengths of those names. In this case, the accumulated result is numeric, whereas the items in the collection are strings; we can’t use the first item as the accumulated length. If we forget to provide <span class="literal">reduce</span> with the start result, Python is nice enough to remind us by raising an error:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">reduce(lambda total_length, name: total_length + len(name), names)</span>&#13;
Traceback (most recent call last):&#13;
  File "&lt;input&gt;", line 1, in &lt;module&gt;&#13;
  File "&lt;input&gt;", line 1, in &lt;lambda&gt;&#13;
TypeError: can only concatenate str (not "int") to str</pre>&#13;
<p class="noindent">For this case, we should pass <span class="literal">0</span> as the initial accumulated length:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">reduce(lambda total_length, name: total_length + len(name), names, 0)</span>&#13;
25</pre>&#13;
<p class="indent">One interesting note here is that if the accumulated result and the items of the collection have different types, you can always concatenate a <span class="literal">map</span> with a <span class="literal">reduce</span> to obtain the same result. For example, in the previous exercise we could have also done the following:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from functools import reduce</span>&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">names = ['Angel', 'Alvaro', 'Mery', 'Paul', 'Isabel']</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">lengths = map(lambda name: len(name), names)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">reduce(lambda total_length, length: total_length + length, lengths)</span>&#13;
25</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_34"/>In this code we first map the <span class="literal">names</span> list into a list of the name lengths: <span class="literal">lengths</span>. Then, we reduce the <span class="literal">lengths</span> list to sum all the values, with no starting value necessary.</p>&#13;
<p class="indent">When reducing items using a common operation—like a sum of two numbers or a concatenation of two strings—we don’t need to write a lambda function ourselves; we can simply pass the <span class="literal">reduce</span> function an existing Python function. For example, when reducing numbers, there’s a useful module provided by Python named <em>operator.py</em>. This module defines functions to operate with numbers, among others. Using this module, we can simplify our previous example to the following:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from functools import reduce</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">import operator</span>&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">names = ['Angel', 'Alvaro', 'Mery', 'Paul', 'Isabel']</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">lengths = map(lambda name: len(name), names)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">reduce(operator.add, lengths)</span>&#13;
25</pre>&#13;
<p class="noindent">This code is shorter and more readable, so we’ll prefer this form throughout the book.</p>&#13;
<p class="indent">The <span class="literal">operator.add</span> function is defined by Python as follows:</p>&#13;
<pre>def add(a, b):&#13;
    "Same as a + b."&#13;
    return a + b</pre>&#13;
<p class="noindent">As you can see, this function is equivalent to the lambda function we defined to sum two numbers. We’ll see more examples of functions defined by Python that can be used with <span class="literal">reduce</span> throughout the book.</p>&#13;
<p class="indent">So far, all of our examples have reduced collections to a single value, but the reduce operation can do much more. In fact, both the filter and map operations are specializations of the reduce operation. We can filter and map a collection using only a reduce operation. But this isn’t something we’ll stop to analyze here; try to figure it out on your own if you feel motivated.</p>&#13;
<p class="indent">Let’s see an example where we want to create a new collection based on the <span class="literal">names</span> list, where every item is the concatenation of all the previous names with the current name separated by the hyphen character (-). The result we’re looking for should be something like this:</p>&#13;
<pre>['Angel', 'Angel-Alvaro', 'Angel-Alvaro-Mery', ...]</pre>&#13;
<p class="indent">We can do this using the following code:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from functools import reduce</span>&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">names = ['Angel', 'Alvaro', 'Mery', 'Paul', 'Isabel']</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">def compute_next_name(names, name):</span>&#13;
...     <span class="codestrong1">if len(names) &lt; 1:</span>&#13;
...         <span class="codestrong1">return name</span>&#13;
<span epub:type="pagebreak" id="page_35"/>...     <span class="codestrong1">return names[-1] + '-' + name</span>&#13;
...&#13;
&gt;&gt;&gt; <span class="codestrong1">reduce(</span>&#13;
...    <span class="codestrong1">lambda result, name: result + [compute_next_name(result, name)],</span>&#13;
...    <span class="codestrong1">names,</span>&#13;
...    <span class="codestrong1">[])</span>&#13;
['Angel', 'Angel-Alvaro', 'Angel-Alvaro-Mery', 'Angel-Alvaro-Mery-Paul', ...]</pre>&#13;
<p class="indent">Here, we use <span class="literal">compute_next_name</span> to determine the next item in the sequence. The lambda used inside <span class="literal">reduce</span> concatenates the accumulated result, which is the list of stitched-together names, with a new list consisting of the new item. The initial solution, an empty list, needs to be provided, since once again the type of each item in the list (string) is different from the result (list of strings).</p>&#13;
<p class="indent">As you can see, the reduce operation is very versatile.</p>&#13;
<h4 class="h4" id="ch00lev2sec23"><strong><em>List Comprehensions</em></strong></h4>&#13;
<p class="noindent">As mentioned earlier, we can filter and map lists in Python using list comprehensions. This form is typically preferred over the <span class="literal">filter</span> and <span class="literal">map</span> functions when dealing with lists, as its syntax is more concise and readable.</p>&#13;
<p class="indent">A list comprehension to map items has the following structure:</p>&#13;
<pre>    [&lt;<span class="codeitalic1">expression</span>&gt; for &lt;<span class="codeitalic1">item</span>&gt; in &lt;<span class="codeitalic1">list</span>&gt;]</pre>&#13;
<p class="indent">There are two parts to it:</p>&#13;
<ul>&#13;
<li class="noindent"><span class="literal">for</span> <em>&lt;item&gt;</em> <span class="literal">in</span> <em>&lt;list&gt;</em> is the <span class="literal">for</span> loop that iterates over the items  in <em>&lt;list&gt;</em>.</li>&#13;
<li class="noindent"><em>&lt;expression&gt;</em> is a mapping expression to map <em>&lt;item&gt;</em> into something else.</li>&#13;
</ul>&#13;
<p class="indent">Let’s repeat the exercise we did earlier where we mapped a list of names to a list of the lengths of each name, this time using a list comprehension:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">names = ['Angel', 'Alvaro', 'Mery', 'Paul', 'Isabel']</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">[len(name) for name in names]</span>&#13;
[5, 6, 4, 4, 6]</pre>&#13;
<p class="noindent">I hope you see why Python programmers favor list comprehensions over the <span class="literal">map</span> function; the example almost reads like plain English: “length of name for (each) name in names.” In the example, <span class="literal">for name in names</span> iterates over the names in the original list and then uses the length of each name (<span class="literal">len(name)</span>) as the result.</p>&#13;
<p class="indent">To filter a list using a list comprehension we can add an <span class="literal">if</span> clause at the end of the comprehension:</p>&#13;
<pre>    [&lt;<span class="codeitalic1">expression</span>&gt; for &lt;<span class="codeitalic1">item</span>&gt; in &lt;<span class="codeitalic1">list</span>&gt; if &lt;<span class="codeitalic1">condition</span>&gt;]</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_36"/>If we wanted to, for example, filter a list of names, this time keeping only those that start with <em>A</em>, we could write the following list comprehension:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">[name for name in names if name.startswith('A')]</span>&#13;
['Angel', 'Alvaro']</pre>&#13;
<p class="noindent">Note two things from this example: the mapping expression is the <span class="literal">name</span> itself (an identity mapping, which is the same as no mapping), and the filter uses the string <span class="literal">startswith</span> method. This method returns <span class="literal">True</span> only if the string has the given argument as a prefix.</p>&#13;
<p class="indent">We can filter and map in the same list comprehension. For example, let’s say we want to take our list of names and filter out those that have more than five letters and then construct a new list whose elements are a tuple of the original name and its length. We could do this easily:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">[(name, len(name)) for name in names if len(name) &lt; 6]</span>&#13;
[('Angel', 5), ('Mery', 4), ('Paul', 4)]</pre>&#13;
<p class="indent">For comparison’s sake, let’s see what this would look like if we decided to use the <span class="literal">filter</span> and <span class="literal">map</span> functions:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">names_with_length = map(lambda name: (name, len(name)), names)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">result = filter(lambda name_length: name_length[1] &lt; 6, names_with_length)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">list(result)</span>&#13;
[('Angel', 5), ('Mery', 4), ('Paul', 4)]</pre>&#13;
<p class="noindent">As you can see, the result is the same, but the list comprehension version is simpler and more readable. What’s easier to read is easier to maintain, so list comprehensions are going to be our preferred way of filtering and mapping lists.</p>&#13;
<p class="indent">Let’s now turn our attention to the second paradigm we’ll be exploring in this chapter: object-oriented programming.</p>&#13;
<h3 class="h3" id="ch00lev1sec18"><strong>Object-Oriented Programming</strong></h3>&#13;
<p class="noindent">In the previous section, we talked about functional programming and some functional patterns. Now we’ll learn about another paradigm: the <em>object-oriented paradigm</em>. As the function is to functional programming, the object is to object-oriented programming. So, first things first: What’s an object?</p>&#13;
<p class="indent">There are several ways we could describe what an object is. I’m going to deviate from the standard academic definition of an object in object-oriented programming theory and try a rather unconventional explanation.</p>&#13;
<p class="indent">From a practical standpoint, we can think of objects as experts on a given subject. We can ask them questions, and they will give us information; or we can request that they do things for us, and they will do them. Our questions or requests may require complex operations, but these experts hide the complexity from us so that we don’t need to worry about the details—we just care about getting the job done.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_37"/>For example, think of a dentist. When you go to the dentist, you don’t need to know anything about dentistry yourself. You rely on the dentist’s expertise to get your cavities fixed. You can also ask the dentist questions about your teeth, and the dentist will respond using a language that you can understand, hiding the real complexity of the subject. In this example, the dentist would be an object you’d rely on for odontology-related tasks or queries.</p>&#13;
<p class="indent">To request things from an object, we call one of the object’s <em>methods</em>. Methods are functions that belong to a given object and have access to the object’s internals. The object itself has some memory that contains data that is typically hidden to the outside world, although the object may decide to expose some of this data in the form of <em>properties</em>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>A method is a function that belongs to a class: it’s part of the class definition. It needs to be called (executed) on the instance of the class where it’s defined. By contrast, a function doesn’t belong to any class; it works on its own.</em></p>&#13;
</div>&#13;
<p class="indent">In Python’s parlance, any function or variable in an object is called an <em>attribute</em>. Both properties and methods are attributes. We’ll be using these equivalent terms throughout this chapter and the rest of the book.</p>&#13;
<p class="indent">Let’s now get practical and see how we can define and work with objects in Python.</p>&#13;
<h4 class="h4" id="ch00lev2sec24"><strong><em>Classes</em></strong></h4>&#13;
<p class="noindent">A <em>class</em> defines how objects are constructed and what characteristics and knowledge they have. Some people like to compare classes to blueprints; they are general descriptions of what information the object holds and what it can do. Objects and classes are related but distinct; if the class is the blueprint, the object is the finished building.</p>&#13;
<p class="indent">We define a new class in Python using the reserved <span class="literal">class</span> keyword. By convention, class names start with an uppercase letter and use an uppercase letter at the start of every new word (this case is commonly known as <em>Pascal case</em>). Let’s create a class that models a coffee machine:</p>&#13;
<pre>class CoffeeMachine:&#13;
    def __init__(self):&#13;
        self.__coffees_brewed = 0</pre>&#13;
<p class="indent">In this listing we define a new class representing a coffee machine. We can use this class to generate new coffee machine objects, in a process referred to as <em>instantiation</em>. When we instantiate a class, we create a new object of that class. A class is instantiated by calling its name as if it were a function that’s returning the instantiated object:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">machine = CoffeeMachine()</span></pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_38"/>Now we have the <span class="literal">machine</span> object whose functionality is defined by the <span class="literal">Coffee</span> <span class="literal">Machine</span> class (which is still empty, but we’ll complete it in the following sections). When a class is instantiated, its <span class="literal">__init__</span> function is called. Inside this <span class="literal">__init__</span> function, we can perform one-time initialization tasks. For example, here we add a count of the number of brewed coffees and set it to zero:</p>&#13;
<pre>def __init__(self):&#13;
    self.__coffees_brewed = 0</pre>&#13;
<p class="indent">Notice the two underscores at the beginning of <span class="literal">__coffees_brewed</span>. If you remember from our discussion on access levels earlier, in Python, by default, everything is visible to the outside. The double underscore naming pattern is used to signify that something is private and no one is expected to access it directly.</p>&#13;
<pre># Don't do this!&#13;
&gt;&gt;&gt; <span class="codestrong1">machine.__coffees_brewed</span>&#13;
0</pre>&#13;
<p class="indent">In this case, we don’t want the outside world to access <span class="literal">__coffees_brewed</span>; they could change the coffees brewed count at will!</p>&#13;
<pre># Don't do this!&#13;
&gt;&gt;&gt; <span class="codestrong1">machine.__coffees_brewed = 5469</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">machine.__coffees_brewed</span>&#13;
5469</pre>&#13;
<p class="indent">So if we can’t access <span class="literal">__coffees_brewed</span>, how do we know how many coffees our machine has brewed? The answer is properties. Properties are a class’s read-only attributes. Before we can discuss properties, however, we have some syntax to cover.</p>&#13;
<h5 class="h5" id="ch00lev3sec15"><strong>self</strong></h5>&#13;
<p class="noindent">If you look at the previous example, you’ll see that we make frequent use of a variable named <span class="literal">self</span>. We could use any other name for this variable, but <span class="literal">self</span> is used by convention. As you saw earlier, we pass it to the definition of every function inside the class, including the initializer. Thanks to this first parameter, <span class="literal">self</span>, we gain access to whatever is defined in the class. In the <span class="literal">__init__</span> function, for example, we append the <span class="literal">__coffees_brewed</span> variable to <span class="literal">self</span>; from that point on, this variable exists in the object.</p>&#13;
<p class="indent">The variable <span class="literal">self</span> needs to appear as the first parameter in the definition of every function inside the class, but it doesn’t need to be passed as the first argument when we call those functions on instances of the class. For example, to instantiate the <span class="literal">CoffeeMachine</span> class, we wrote the following:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">machine = CoffeeMachine()</span></pre>&#13;
<p class="noindent">The initializer was called without parameters (no <span class="literal">self</span> here). If you think about it, how could we possibly pass the initializer as <span class="literal">self</span> in this case if we haven’t yet initialized the object? As it turns out, Python takes care of that <span epub:type="pagebreak" id="page_39"/>for us: we’ll never need to pass <span class="literal">self</span> to the initializer or any of the object’s methods or properties.</p>&#13;
<p class="indent">The <span class="literal">self</span> reference is how different attributes of a class have access to the other definitions in the class. For example, in the <span class="literal">brew_coffee</span> method we’ll write later, we use <span class="literal">self</span> to access the <span class="literal">__coffees_brewed</span> count:</p>&#13;
<pre>def brew_coffee(self):&#13;
    # we need 'self' here to access the class' __coffees_brewed count&#13;
    self.__coffees_brewed += 1</pre>&#13;
<p class="indent">With an understanding of <span class="literal">self</span>, we can move on to properties.</p>&#13;
<h5 class="h5" id="ch00lev3sec16"><strong>Class Properties</strong></h5>&#13;
<p class="noindent">An object’s <em>property</em> is a read-only attribute that returns some data. A property of an object is accessed using <em>dot notation</em>: <em>object.property</em>. Following our coffee machine example, we could add a <span class="literal">coffees_brewed</span> property (the number of coffees brewed by the machine), like so:</p>&#13;
<pre>class CoffeeMachine:&#13;
    def __init__(self):&#13;
        self.__coffees_brewed = 0&#13;
&#13;
    <span class="codestrong1">@property&#13;
    def coffees_brewed(self):&#13;
        return self.__coffees_brewed</span></pre>&#13;
<p class="noindent">Then we could access it:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">machine = CoffeeMachine()</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">machine.coffees_brewed</span>&#13;
0</pre>&#13;
<p class="indent">Properties are defined as functions using the <span class="literal">@property</span> decorator:</p>&#13;
<pre>@property&#13;
def coffees_brewed(self):&#13;
    return self.__coffees_brewed</pre>&#13;
<p class="indent">Properties shouldn’t accept any parameter (except for the customary <span class="literal">self</span>), and they should return something. A property that doesn’t return anything or expects parameters is conceptually wrong: properties should just be read-only data we request the object to give us.</p>&#13;
<p class="indent">We mentioned that <span class="literal">@property</span> is an example of a decorator. Python decorators allow us to modify a function’s behavior. The <span class="literal">@property</span> modifies the function of a class so that it can be consumed as if it were an attribute of the class. We won’t use any other decorators in this book, so we won’t cover them here, but I encourage you to read up on them if you’re interested.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_40"/>Properties get us information about an object. For instance, if we wanted to know whether a given instance of a <span class="literal">CoffeeMachine</span> has brewed at least one coffee, we could include a property like the following:</p>&#13;
<pre>class CoffeeMachine:&#13;
    def __init__(self):&#13;
        self.__coffees_brewed&#13;
&#13;
    <span class="codestrong1">@property&#13;
    def has_brewed(self):&#13;
        return self.__coffees_brewed &gt; 0</span>&#13;
&#13;
    <span class="codeitalic1">--snip--</span></pre>&#13;
<p class="noindent">We can now ask instances of the <span class="literal">CoffeeMachine</span> class whether they’ve brewed at all:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">machine.has_brewed</span>&#13;
False</pre>&#13;
<p class="indent">This machine hasn’t prepared any coffee yet, so how can we ask a <span class="literal">CoffeeMachine</span> instance to brew a coffee for us? We use methods.</p>&#13;
<h5 class="h5" id="ch00lev3sec17"><strong>Class Methods</strong></h5>&#13;
<p class="noindent">Properties allow us to know something about an object: they answer our queries. To request an object to perform some task for us, we use methods. A <em>method</em> is nothing more than a function that belongs to a class and has access to the attributes defined in that class. In our <span class="literal">CoffeeMachine</span> class example, let’s write a method to request it to brew some coffee:</p>&#13;
<pre>class CoffeeMachine:&#13;
    def __init__(self):&#13;
        self.__coffees_brewed = 0&#13;
&#13;
    @property&#13;
    def coffees_brewed(self):&#13;
        return self.__coffees_brewed&#13;
&#13;
    @property&#13;
    def has_brewed(self):&#13;
        return self.__coffees_brewed &gt; 0&#13;
&#13;
    <span class="codestrong1">def brew_coffee(self):&#13;
        self.__coffees_brewed += 1</span></pre>&#13;
<p class="noindent">Methods get <span class="literal">self</span> as their first parameter, which gives them access to everything defined inside the class. As we discussed earlier, when calling a method on an object, we never pass <span class="literal">self</span> ourselves; Python does it for us.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><span epub:type="pagebreak" id="page_41"/><em>Note that properties are like methods decorated with</em> <span class="literal">@property</span><em>. Both properties and methods expect</em> <span class="literal">self</span> <em>as their first argument. When calling a method, we use parentheses and optionally pass it arguments, but properties are accessed without parentheses.</em></p>&#13;
</div>&#13;
<p class="indent">We can call the <span class="literal">brew_coffee</span> method on an instance of the class:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">machine = CoffeeMachine()</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">machine.brew_coffee()</span></pre>&#13;
<p class="noindent">Now that we’ve brewed our first coffee, we can ask the instance this:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">machine.coffees_brewed</span>&#13;
1&#13;
&gt;&gt;&gt; <span class="codestrong1">machine.has_brewed</span>&#13;
True</pre>&#13;
<p class="noindent">As you see, methods have to be called on a particular instance of a class (an object). This object will be the one responding to the request. So, whereas functions are called without a particular receiver, like</p>&#13;
<pre><span class="codeitalic1">a_function</span>()</pre>&#13;
<p class="noindent">methods have to be called on an object, like</p>&#13;
<pre>machine.brew_coffee()</pre>&#13;
<p class="indent">Objects can only respond to the methods defined in the class that created them. If a method (or any attribute for that matter) is called on an object but this method wasn’t defined in the class, an <span class="literal">AttributeError</span> is raised. Let’s try this. Let’s order our coffee machine to brew tea even though we never gave it the instructions on how to do so:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">machine.brew_tea()</span>&#13;
Traceback (most recent call last):&#13;
  File "&lt;input&gt;", line 1, in &lt;module&gt;&#13;
AttributeError: 'CoffeeMachine' object has no attribute 'brew_tea'</pre>&#13;
<p class="noindent">Okay, our object complained: we never told it we expected it to know how to prepare tea. Here’s the key to its complaint:</p>&#13;
<p class="pre2">    'CoffeeMachine' object has no attribute 'brew_tea'</p>&#13;
<p class="indent">Lesson learned: don’t ever request an object to do something it wasn’t taught; it’ll just freak out and make your program fail.</p>&#13;
<p class="indent">Methods can accept any number of parameters, which in our class have to be defined after the first mandatory argument: <span class="literal">self</span>. For example, let’s add a method to our <span class="literal">CoffeeMachine</span> class that allows us to fill it with a given amount of water.<span epub:type="pagebreak" id="page_42"/></p>&#13;
<pre>class CoffeeMachine:&#13;
&#13;
    def __init__(self):&#13;
        self.__coffees_brewed = 0&#13;
        self.__liters_of_water = 0&#13;
&#13;
    <span class="codestrong1">def fill_water_tank(self, liters):&#13;
        self.__liters_of_water += liters</span></pre>&#13;
<p class="noindent">We can fill the coffee machine instance by calling our new method:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">machine = CoffeeMachine()</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">machine.fill_water_tank(5)</span></pre>&#13;
<p class="indent">One last thing to know about methods before we move on is how powerful their dynamic dispatch nature is. When a method is called on an object, Python will check whether the object responds to that method or not, but, and here’s the key, Python doesn’t care about the object’s class as long as this class has the requested method defined.</p>&#13;
<p class="indent">We can use this feature to define different objects that respond to the same method (by same method we mean same name and arguments) and use them interchangeably. For instance, we could define a new, more modern coffee-producer entity:</p>&#13;
<pre>class CoffeeHipster:&#13;
    def __init__(self, skill_level):&#13;
        self.__skill_level = skill_level&#13;
&#13;
    def brew_coffee(self):&#13;
        # depending on the __skill_level, this method&#13;
        # may take a long time to complete.&#13;
        # But apparently the result will be worth it?&#13;
        <span class="codeitalic1">--snip--</span></pre>&#13;
<p class="noindent">Now we can write a function that expects a coffee producer (any object whose class defines a <span class="literal">brew_cofee()</span> method) and does something with it:</p>&#13;
<pre>def keep_programmer_awake(programmer, coffee_producer):&#13;
    while programmer.wants_to_sleep:&#13;
        # give the coder some wakey juice&#13;
        coffee_producer.brew_coffee()&#13;
        <span class="codeitalic1">--snip--</span></pre>&#13;
<p class="noindent">This function works with both an instance of <span class="literal">CoffeeMachine</span> and <span class="literal">CoffeeHipster</span>:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">machine = CoffeeMachine()</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">hipster = CoffeeHipster()</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">programmer = SleepyProgrammer('Angel')</span>&#13;
&#13;
<span epub:type="pagebreak" id="page_43"/># works!&#13;
&gt;&gt;&gt; <span class="codestrong1">keep_programmer_awake(programmer, machine)</span>&#13;
&#13;
# also works!&#13;
&gt;&gt;&gt; <span class="codestrong1">keep_programmer_awake(programmer, hipster)</span></pre>&#13;
<p class="indent">For this technique to work, we need to make sure that the methods have the same signature, that is, they’re called the same and expect exactly the same parameters with the same names.</p>&#13;
<h4 class="h4" id="ch00lev2sec25"><strong><em>Magic Methods</em></strong></h4>&#13;
<p class="noindent">There are some special methods our classes may define that are known as <em>magic methods</em> or <em>dunder methods</em> (short for <em>double underscore</em>). These methods aren’t typically called by us directly, but Python uses them under the hood, as we’ll see in the following examples.</p>&#13;
<p class="indent">We’ve already used one such method: <span class="literal">__init__</span>, which we used as the initializer when instantiating objects. This <span class="literal">__init__</span> method defines the code that’s executed when a new instance of a class is created.</p>&#13;
<p class="indent">One prominent use case for magic methods (which we’ll use a lot throughout the book) is overloading operators. Let’s see this through an example. Imagine we implement a class to represent complex numbers:</p>&#13;
<pre>class ComplexNum:&#13;
    def __init__(self, re, im):&#13;
        self.__re = re&#13;
        self.__im = im&#13;
&#13;
    @property&#13;
    def real(self):&#13;
        return self.__re&#13;
&#13;
    @property&#13;
    def imaginary(self):&#13;
        return self.__im</pre>&#13;
<p class="noindent">How would we go about implementing the addition operation on <span class="literal">ComplexNum</span> instances? A first option could be including a method called <span class="literal">plus</span>:</p>&#13;
<pre>class ComplexNum:&#13;
&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def plus(self, addend):&#13;
        return ComplexNum(&#13;
            self.__re + addend.__re,&#13;
            self.__im + addend.__im&#13;
        )</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_44"/>which we could use like so:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">c1 = ComplexNum(2, 3)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">c2 = ComplexNum(5, 7)</span>&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">c1.plus(c2)</span>&#13;
# the result is: 7 + 10i</pre>&#13;
<p class="noindent">This is okay, but it would be nicer if we could instead use the <span class="literal">+</span> operator like we do with any other number:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">c1 + c2</span></pre>&#13;
<p class="indent">Python includes a magic method, <span class="literal">__add__</span>; if we implement that method, then we can use the <span class="literal">+</span> operator as shown earlier, and Python will call this <span class="literal">__add__</span> method under the hood. So if we rename our <span class="literal">plus</span> method <span class="literal">__add__</span>, we can automatically add <span class="literal">ComplexNum</span>s using the <span class="literal">+</span> operator:</p>&#13;
<pre>class ComplexNum:&#13;
&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def __add__(self, addend):&#13;
        return ComplexNum(&#13;
            self.__re + addend.__re,&#13;
            self.__im + addend.__im&#13;
        )</pre>&#13;
<p class="indent">There are more magic methods we can implement in our classes to perform subtraction, division, comparisons, and more. You can take a brief look at <a href="ch04.xhtml#ch4tab1">Table 4-1</a> on <a href="ch04.xhtml#ch4tab1">page 70</a> for a reference of the operations we can implement with magic methods. For example, subtracting two of our complex numbers using the <span class="literal">-</span> operator would be as simple as implementing the <span class="literal">__sub__</span> method:</p>&#13;
<pre>class ComplexNum:&#13;
&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def __sub__(self, subtrahend):&#13;
        return ComplexNum(&#13;
            self.__re - subtrahend.__re,&#13;
            self.__im - subtrahend.__im&#13;
        )</pre>&#13;
<p class="noindent">Now we can use the <span class="literal">-</span> operator:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">c1 - c2</span>&#13;
# yields: -3 - 4i</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_45"/>What about comparing two instances for equality using the <span class="literal">==</span> operator? Simply implement the <span class="literal">__eq__</span> magic method:</p>&#13;
<pre>class ComplexNum:&#13;
&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def __eq__(self, other):&#13;
        return (self.__re == other.__re) and (self.__im == other.__im)</pre>&#13;
<p class="noindent">Now we can easily compare complex numbers:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">c1 == c2</span>&#13;
False</pre>&#13;
<p class="indent">We’ll be using some magic methods throughout the book; they really improve the readability of the code.</p>&#13;
<p class="indent">Let’s now change topics and learn about type hints.</p>&#13;
<h3 class="h3" id="ch00lev1sec19"><strong>Type Hints</strong></h3>&#13;
<p class="noindent">Python <em>type hints</em> are a small help we can use when writing code to make sure we don’t mistype the name of a method or property of a class.</p>&#13;
<p class="indent">For example, let’s use the implementation of a complex number from the previous section:</p>&#13;
<pre>class ComplexNum:&#13;
&#13;
    def __init__(self, re, im):&#13;
        self.__re = re&#13;
        self.__im = im&#13;
&#13;
    @property&#13;
    def real(self):&#13;
        return self.__re&#13;
&#13;
    @property&#13;
    def imaginary(self):&#13;
        return self.__im</pre>&#13;
<p class="noindent">Now say that we write a function that takes an instance of <span class="literal">ComplexNum</span> as an argument, and we want to extract the imaginary part of the number, but we’re a bit sleepy and mistakenly write the following:</p>&#13;
<pre>def defrangulate(complex):&#13;
    <span class="codeitalic1">--snip--</span>&#13;
    im = complex.imaginry</pre>&#13;
<p class="noindent">Did you spot the typo? Well, since we know nothing about the <span class="literal">complex</span> argument, there’s no visual clue our IDE can give us. As far as the IDE knows, <span epub:type="pagebreak" id="page_46"/><span class="literal">imaginry</span> is a perfectly valid attribute name, and it won’t be until we run the program and pass a complex number that we get an error.</p>&#13;
<p class="indent">Python is a dynamically typed language: it uses type information at runtime. For example, it checks whether a given type of object responds to a method at runtime, and if it doesn’t, an error is raised:</p>&#13;
<p class="pre2">    AttributeError: 'ComplexNum' object has no attribute 'imaginry'</p>&#13;
<p class="indent">A bit unfortunate, isn’t it? In this case, we know that this function only expects instances of the <span class="literal">ComplexNum</span> class, so it would be nice if our IDE warned us about that property being mistyped. And in fact, we can do this using type hints.</p>&#13;
<p class="indent">In a function or method definition, a type hint goes after the argument name, separated by a colon:</p>&#13;
<pre>def defrangulate(complex: ComplexNum):&#13;
    <span class="codeitalic1">--snip--</span>&#13;
    im = complex.imaginry&#13;
    -------------^-------&#13;
    <span class="codeitalic1">'ComplexNum' object has no attribute 'imaginry'</span></pre>&#13;
<p class="indent">As you can see, the IDE has signaled to us that <span class="literal">ComplexNum</span> has no attribute named <span class="literal">imaginry</span>.</p>&#13;
<p class="indent">In addition to the types we define using classes, we can use Python’s built-in types as type hints. For instance, the complex-number initializer expecting two floating-point numbers could be written like so:</p>&#13;
<pre>class ComplexNum:&#13;
    def __init__(self, re: float, im: float):&#13;
        self.__re = re&#13;
        self.__im = im</pre>&#13;
<p class="noindent">And now our IDE would warn us if we tried to instantiate the class with the wrong parameter types:</p>&#13;
<pre>i = ComplexNumber('one', 'two')&#13;
------------------^------------&#13;
Expected type 'float', got 'str' instead.</pre>&#13;
<p class="noindent">We can use <span class="literal">float</span> for floating-point numbers, <span class="literal">int</span> for integers, and <span class="literal">str</span> for strings.</p>&#13;
<p class="indent">These type hints help us during development but have no effect at runtime. We’ll be using type hints in many places throughout the book: it takes no time to add them, and we get a bit of extra safety.</p>&#13;
<h3 class="h3" id="ch00lev1sec20"><span epub:type="pagebreak" id="page_47"/><strong>Summary</strong></h3>&#13;
<p class="noindent">We discussed two programming paradigms in this chapter: functional programming and object-oriented programming. Of course, both of these are huge topics, and whole books could be, and have been, written about them. We only scratched the surface.</p>&#13;
<p class="indent">We also talked about magic methods and type hints, two techniques we’ll use extensively throughout the book.</p>&#13;
<p class="indent">In the next chapter, we’ll discuss the command line. After that, we’ll start writing code.<span epub:type="pagebreak" id="page_48"/></p>&#13;
</body></html>