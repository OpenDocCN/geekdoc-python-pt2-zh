- en: '**9'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UNPACKING YOUR PERSONAL ITEMS**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that the space station is operational, it’s time to unpack your personal
    items and the various tools and pieces of equipment you’ll need as you carry out
    your work.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll build the code for objects that can move between rooms
    (*props*). When you play the game, you’ll be able to discover new items, pick
    them up, move them around, and use them to solve puzzles.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE PROPS INFORMATION**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve already added some information about props in [Chapter 5](ch05.xhtml#ch05)
    when you added the image filenames and descriptions to the `objects` dictionary.
    The `objects` dictionary contains information about *what* an item is. In this
    chapter, we’ll add information to tell the game *where* the props go.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be wondering why we’re handling the props separately from the scenery.
    We do this because their information is used in different ways: the `scenery`
    dictionary stores information using the room as the key. This makes sense, because
    the program needs to get information about all the scenery in a room at the same
    time. After the scenery information is added to the room map, the `scenery` dictionary
    is not needed again until the player enters a new room.'
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, props move around, so the information for a prop might be needed
    at any time in any room. If that information is buried in a list of scenery items,
    it’s harder to find and change.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll create a new dictionary called `props` to store information about props.
    We’ll use the object number as a key, and each entry will be a list that contains
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of the room the prop is in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *y* position of the prop in the room (in tiles)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *x* position of the prop in the room (in tiles)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, here’s the entry for the hammer, which is object 65:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It’s in room 50, at *y* position 1 and *x* position 7.
  prefs: []
  type: TYPE_NORMAL
- en: Objects that are not in the game world or that are being carried by the player
    will have a room number of 0, which is not a real location in the game. Some objects
    aren’t in the game world until they’ve been created or after they’ve been destroyed,
    for example. These would be stored in room 0.
  prefs: []
  type: TYPE_NORMAL
- en: '**TIP**'
  prefs: []
  type: TYPE_NORMAL
- en: The `props` and `objects` dictionaries use the same keys. If you want to know
    what item 65 is in the `props` dictionary, read its details in the `objects` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-1](ch09.xhtml#ch09list1) shows the code for adding the props information
    to the game. Open *listing8-10.py*, your final program from the previous chapter.
    Add the new `PROPS` section after the `show_text()` function in the `DISPLAY`
    section and before the `START` section. Only add the new lines, and save the new
    program as *listing9-1.py*. If you want to avoid typing the data, you can copy
    and paste it from the *data-chapter9.py* file.'
  prefs: []
  type: TYPE_NORMAL
- en: You can run the program with pgzrun listing9-1.py. It won’t do anything new
    yet, but you can check whether there are any error messages in the command line
    window.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing9-1.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-1: Adding the props information to* Escape'
  prefs: []
  type: TYPE_NORMAL
- en: We start the new `PROPS` section by creating the dictionary to store the information
    about the props ➊. This dictionary lists the position locations for all the props,
    starting with some doors (20 to 24) and including a rescue ship (40) and the carryable
    items starting at 53.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is just one oddity to draw your attention to. We count doors as props
    rather than scenery, because they’re not always there: when they’re open, they’re
    removed from the room. Most doors stay open when they’re opened until the game
    ends. However, the door that connects rooms 27 and 32 can also shut, meaning players
    can see it from both sides. As a result, we need two props to represent this door
    ➋, showing it in the top of room 27 and the bottom of room 32\. These two doors
    are object numbers 25 and 26.'
  prefs: []
  type: TYPE_NORMAL
- en: Prop 71 is the Poodle lander, which crash-landed on the planet surface before
    the game began. We use the `LANDER_Y` and `LANDER_X` variables from the `VARIABLES`
    part of the program ➌ to position the lander, because its location will change
    with each new game. The Poodle landed with such force that it might have become
    covered with Martian soil. It lives in room 0 until the player can dig it up.
  prefs: []
  type: TYPE_NORMAL
- en: As with the scenery information (see [Chapter 6](ch06.xhtml#ch06)), I’ve used
    a checksum here to help you spot whether you made an error entering the data.
    It might not be possible to play the game all the way to the end if a mistake
    is made here. The only prop missing from the checksum calculation is number 71,
    because its position uses different random numbers in each game ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to change the props data, the easiest thing to do is to comment
    out the two checksum instructions ➏ like this to turn them off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The program shows the checksum total and number of data items in the command
    line window ➎, so if you change the props data, you can use this information to
    update the numbers in the two `assert` instructions so they are correct for your
    customized data. If you do this, you can continue using these lines rather than
    commenting them out.
  prefs: []
  type: TYPE_NORMAL
- en: The program also sets up two new variables and a list we’ll need later in the
    chapter. The `in_my_pockets` ➐ list stores all the items the player has picked
    up, also known as their *inventory*. One of these items is always selected, so
    the player is ready to do something with it. The `selected_item` variable stores
    its index number in the `in_my_pockets` list. The `item_carrying` variable stores
    the object number of the item the player has selected. You can think of the `item_carrying`
    variable as being the number of the object in their hands. I’ll tell you more
    about these variables later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING PROPS TO THE ROOM MAP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve added the information about where the props are located, so now let’s
    display the props. We’ll make it so that when props are located in the current
    room, they’re put into the `room_map` list as the player enters the room. Then
    the `draw()` function uses that list to draw the room.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll place the instructions to add the props to the room map into the `MAKE
    MAP` part of the program, inside the `generate_map()` function. We’ll simply add
    these instructions after the instructions you added in [Chapter 8](ch08.xhtml#ch08)
    for working out the `top_left_x` and `top_left_y` variables, just above the start
    of the `GAME LOOP` section.
  prefs: []
  type: TYPE_NORMAL
- en: Because the new instructions are all part of the `generate_map()` function,
    you need to indent them by at least four spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Add the new instructions shown in [Listing 9-2](ch09.xhtml#ch09list2) to your
    program, and save it as *listing9-2.py*. Run the program with pgzrun listing9-2.py.
    You should see that new objects have appeared in some of the rooms, as shown in
    [Figure 9-1](ch09.xhtml#ch09fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig9-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-1: That door wasn’t there a minute ago! That air canister might come
    in handy, though.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*listing9-2.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-2: Adding the props to the room map for the current room*'
  prefs: []
  type: TYPE_NORMAL
- en: In the new code, we start by setting up a loop to go through the items in the
    `props` dictionary ➊. For each item, the dictionary key goes into the variable
    `prop_number`, and the list with the position information goes into the list `prop_info`.
  prefs: []
  type: TYPE_NORMAL
- en: To make the program easier to read, I’ve set up some variables to store the
    information from the `prop_info` list ➋. The program extracts the information
    for the room number (and puts it into `prop_room`) and the *y* and *x* positions
    (which go into the `prop_y` and `prop_x` variables).
  prefs: []
  type: TYPE_NORMAL
- en: We add a check to see whether the `prop_room` matches the room the player is
    in ➌ and whether the prop is sitting on the floor ➍. The floor check puts the
    three different floor types in a list (0 for inside, 2 for soil, and 39 for the
    pressure pad in room 26). The program checks the prop’s position to see what’s
    in that location in the room map. If it’s one of these floor types, it means the
    object is sitting on the floor in full view. If not, the prop is hidden inside
    an item of scenery and shouldn’t be visible yet. For example, if a cabinet is
    in the prop’s location instead of the floor, the prop won’t be shown onscreen.
    The player can still find the prop by examining the cabinet at that location,
    though.
  prefs: []
  type: TYPE_NORMAL
- en: If the prop is in the room and on the floor, the room map is updated with the
    prop number ➎.
  prefs: []
  type: TYPE_NORMAL
- en: Some props, like doors, are wider than one tile. So we add the number 255 to
    any tiles that the prop covers other than the first one ➐. This is similar to
    the code we used to mark wide scenery earlier in the `generate_map()` function
    (see [Listing 6-4](ch06.xhtml#ch06list4) on [page 106](ch06.xhtml#page_106)).
  prefs: []
  type: TYPE_NORMAL
- en: '**GETTING INFORMATION FROM A FUNCTION: ROLLING DICE**'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](ch08.xhtml#ch08), you learned how to send information (or *arguments*)
    to a function. Let’s look more closely at how to get information *back* from a
    function. We’ll use this skill to create a function that tells us what object
    the player is standing on.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-3](ch09.xhtml#ch09list3) shows a simple program that sends a number
    back from a function and puts it into a variable. This isn’t part of the *Escape*
    game, so create a new file by clicking **File** ▸ **New** first.'
  prefs: []
  type: TYPE_NORMAL
- en: Save the program as *listing9-3.py*. This program doesn’t use Pygame Zero, so
    you can run it using **Run** ▸ **Run Module** in the script window. The program
    simulates a 10-sided die.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing9-3.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-3: A 10-sided die simulator shows how to send a number back from
    a function.*'
  prefs: []
  type: TYPE_NORMAL
- en: This program starts by telling Python to use the `random` module ➊, which gives
    Python new functions for making random choices. We then create a new function
    called `get_number()` ➋, which generates a random number between 1 and 10 ➌ and
    puts the result into a variable called `dice_number`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, when you start a function (known as *calling* a function in Python
    jargon), you use its name, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This time, we not only start the function, but tell Python to put the result
    from the function into a variable called `random_number` ➎. When the function
    sends its result back using the `return` command ➍, the result goes into the `random_number`
    variable. The main part of the program can then print out its value ➏.
  prefs: []
  type: TYPE_NORMAL
- en: This code shows that the way to get information from a function is to set up
    a variable to store the information when the function is started ➎ and to use
    the `return` instruction to send that information back when the function finishes
    ➍. You can send strings and lists back too, not just numbers. Where possible,
    this is the best way to enable other parts of the program to use information from
    a function. This technique enables the main part of the program to get information
    from a function’s local variable (in this case `dice_number`), which would usually
    only be visible inside that function.
  prefs: []
  type: TYPE_NORMAL
- en: You won’t need this program again, so you can close it when you’ve finished
    experimenting with it.
  prefs: []
  type: TYPE_NORMAL
- en: '**FINDING AN OBJECT NUMBER FROM THE ROOM MAP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shortly, we’ll add the code to enable you to pick up objects in the space station.
    First we need a way to find out which object is being picked up.
  prefs: []
  type: TYPE_NORMAL
- en: When the player interacts with scenery or props, we need to find the number
    of the object they’re using. Normally, this is simple. If the room map shows that
    the object number of the prop at the player’s location is 65, that’s a hammer.
    The program can show a description of the hammer, and let the player pick it up
    or use it.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the object number gets tricky with wide objects that span multiple
    tiles. We use the number 255 to mark tiles covered by a wide object, but that
    number doesn’t correspond to a prop. The program needs to work out what the real
    object number is by moving left in the room map until it finds a number that isn’t
    255.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the player examines the rightmost third of a door, the program
    would see that this position contains 255, so it would check the position to the
    left. That position also contains 255, so the program would check farther left.
    If that tile contains a number other than 255, the program knows it’s found the
    real object number, which might be 20 (one of the doors), for example. Using the
    object number 20, the program can then let the player examine or open the door.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create two functions that will work out the object number, shown in [Listing
    9-4](ch09.xhtml#ch09list4). You need to add these to [Listing 9-2](ch09.xhtml#ch09list2),
    so click **File** ▸ **Open** to open *listing9-2.py* again if necessary. We’ll
    start a new section of the program called `PROP INTERACTIONS`. Put this after
    the `PROPS` section. This new section will be where we put the code for picking
    up and dropping props.
  prefs: []
  type: TYPE_NORMAL
- en: Save the updated program as *listing9-4.py*. It won’t do anything new yet, but
    you can run it using pgzrun listing9-4.py to check that you haven’t added any
    mistakes. Look in the command line window for any error messages.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing9-4.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-4: Finding the real object number*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into how this code works, I’ll explain how the game loop lets
    players interact with props and scenery:'
  prefs: []
  type: TYPE_NORMAL
- en: When the player presses a movement key, the program changes the player’s position
    (even if that puts them somewhere impossible, like inside a wall).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The program carries out any actions the player requires using the object at
    the player’s location. This means the player and the object are in the same position
    in the room at this time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the player is standing somewhere they’re not allowed to be (such as inside
    a wall), the program moves them back to where they were.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The entire process happens so fast you never see the player go inside the wall
    or other piece of scenery. This way, the player can use a movement key plus an
    action key to examine or use the scenery. For example, you can walk into a wall
    and press the spacebar to examine the wall and see a description of it. This process
    also works with an object the player is standing on, such as a prop on the floor.
  prefs: []
  type: TYPE_NORMAL
- en: The first new function we added in [Listing 9-4](ch09.xhtml#ch09list4) is `find_object_start_x()`
    ➊. This function finds the start position of whatever object is at the player’s
    position, going left to find the real object number if the location contains 255.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, the function sets the variable `checker_x` to be the same as the
    player’s *x* position ➋. We use a loop that keeps going for as long as the room
    map contains 255 at the *x* position of `checker_x` and at the player’s *y* position
    ➌. Inside that loop is a single instruction to reduce `checker_x` by 1 ➍, moving
    1 tile to the left. When the loop finishes, `checker_x` contains the left position
    where the object begins. That number is then sent back ➎ to the instruction that
    started the function.
  prefs: []
  type: TYPE_NORMAL
- en: The second new function is `get_item_under_player()` ➏, which works out which
    object is at the player’s position. It uses the first function to find out where
    the object starts and stores the *x* position in the variable `item_x` ➐. Then
    it looks at the room map data for that position to see what object is there ➑
    and sends that number back to the instruction that started the function ➒.
  prefs: []
  type: TYPE_NORMAL
- en: '**PICKING UP OBJECTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that these functions are in place, we can create a couple of functions for
    picking up objects and then storing them in a player’s inventory. Then we’ll add
    some keyboard controls.
  prefs: []
  type: TYPE_NORMAL
- en: '**PICKING UP PROPS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Add the two functions shown in [Listing 9-5](ch09.xhtml#ch09list5) to the end
    of the `PROP INTERACTIONS` section of the program, just after where you added
    the code in [Listing 9-4](ch09.xhtml#ch09list4).
  prefs: []
  type: TYPE_NORMAL
- en: Save this program as *listing9-5.py*. You can check for any errors by running
    it using pgzrun listing9-5.py, but you won’t see any difference yet. This code
    adds some new functions but doesn’t include any key controls to enable the player
    to use them.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing9-5.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-5: Adding the functions to pick up objects*'
  prefs: []
  type: TYPE_NORMAL
- en: The function `pick_up_object()` will start when the player presses the *get*
    key (G) to pick up an item. It begins by putting the object number for the item
    at the player’s position into the variable `item_player_is_on` ➊. If the item
    is carryable ➋, the rest of the function picks it up.
  prefs: []
  type: TYPE_NORMAL
- en: To remove the item from the floor, the program replaces the room map at the
    player’s position with the object number for the floor (either soil or floor tiles)
    ➌. The `get_floor_type()` function is used to find out what the floor type should
    be in this room. When the room is redrawn, the item will disappear from the floor,
    so it looks like it’s been picked up. The item is then added to the list of items
    the player is carrying, using the `add_object()` function ➍.
  prefs: []
  type: TYPE_NORMAL
- en: We then show a message onscreen telling the player they picked up an item and
    play a sound effect. We add a short delay of half a second using the `time.sleep(0.5)`
    instruction to make sure the confirmation message isn’t overwritten if the player
    holds down the key too long.
  prefs: []
  type: TYPE_NORMAL
- en: If the item isn’t carryable, we show a message telling them they can’t carry
    it ➎. For example, scenery can’t be carried, so we need to tell players that.
    Otherwise, they might just think they’re pressing the wrong key or the program
    isn’t working.
  prefs: []
  type: TYPE_NORMAL
- en: The `add_object()` function adds an item to the `in_my_pockets` list, which
    stores the items the player is carrying (their inventory). At the start of the
    function, the object number this function receives is put into the local variable
    `item` ➏. The item is added to the end of the `in_my_pockets_list` using `append()`
    ➐.
  prefs: []
  type: TYPE_NORMAL
- en: We use the global variable `item_carrying` to store the object number of whatever’s
    in the player’s hands, so it is set to be the object number of this item ➑. We
    set the `selected_item` variable as the last item in the list, meaning the item
    the player just picked up is selected ➒. These variables will be important when
    objects are used later on, and when the `display_inventory()` function shows the
    list of items on the screen. For now, that function just prints out the list in
    the command line window.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set the item’s position in the `props` dictionary to be room 0 ➓.
    This means the item just picked up is not shown in the game map anywhere. If we
    didn’t do this, the item would reappear in the room again when the player next
    entered it.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE KEYBOARD CONTROLS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To enable the new functions to work their magic, we need to add the keyboard
    control too. We’ll use the G key as our get key.
  prefs: []
  type: TYPE_NORMAL
- en: Place the new instructions, shown in [Listing 9-6](ch09.xhtml#ch09list6), in
    the `game_loop()` function in the `GAME LOOP` section of the program. The new
    instruction belongs after the exit checks have been made and before the player
    is moved back if they’re standing somewhere they shouldn’t be.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing9-6.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-6: Adding the keyboard control*'
  prefs: []
  type: TYPE_NORMAL
- en: You need to indent the first new instruction by four spaces ➊, because it’s
    inside the `game_loop()` function. Indent the second one ➋ by four more spaces,
    because it belongs to the `if` instruction above. These instructions run the `pick_up_object()`
    function ➋ when the player presses the G key ➊.
  prefs: []
  type: TYPE_NORMAL
- en: Save the listing as *listing9-6.py*. When you run pgzrun listing9-6.py, you
    should be able to pick up objects.
  prefs: []
  type: TYPE_NORMAL
- en: Test it starting with the air canister in the first room. Just walk onto it
    and press G. You’ll hear a sound and see a message, and the object will disappear
    from the room.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command line window (where you entered the `pgzrun` instruction) will also
    show the inventory list every time you pick up an object, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Each time, you’ll see a new item added to the end of the list. Item 55, the
    yoyo, is in your pocket at the start of the game.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE INVENTORY FUNCTIONALITY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you can pick up props that you find around the space station. We should
    add an easy way to see what you’re carrying and to choose different items to use.
    We’ll make a new `display_inventory()` function that displays a strip at the top
    of the game window showing the items the player is carrying.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll then add controls so the player can press the TAB key to select the next
    item in the list. The selected item has a box drawn around it, and its description
    is shown underneath. [Figure 9-2](ch09.xhtml#ch09fig2) shows you what it will
    look like.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig9-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-2:* The inventory at the top of the game window'
  prefs: []
  type: TYPE_NORMAL
- en: '**DISPLAYING THE INVENTORY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 9-7](ch09.xhtml#ch09list7) shows you the code to add. [Listing 9-5](ch09.xhtml#ch09list5)
    included some code for the `display_inventory()` function. Replace that with the
    new code. Save this listing as *listing9-7.py*. When you run the program using
    pgzrun listing9-7.py, you’ll be able to see items added to your inventory at the
    top of the screen as you collect them.'
  prefs: []
  type: TYPE_NORMAL
- en: '*listing9-7.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-7: Displaying the inventory*'
  prefs: []
  type: TYPE_NORMAL
- en: The new `display_inventory()` function starts by drawing a black box over the
    inventory area to clear it ➊. If the player isn’t carrying anything, the function
    returns without taking any further action because there are no items to display
    ➋.
  prefs: []
  type: TYPE_NORMAL
- en: There is only room to show 16 items on the screen, but the player could carry
    many more items than that. If the `in_my_pockets` list is too long to fit on the
    screen, the program shows it 16 items at a time. The player can select any of
    the items shown on the screen by pressing the TAB key to move through them, from
    left to right. If the last item displayed is selected and they press TAB, the
    next chunk of the list is shown. If the player presses TAB on the final item in
    the list, the start of the list appears again.
  prefs: []
  type: TYPE_NORMAL
- en: We store the part of the `in_my_pockets` list currently displayed on the screen
    in another list called `list_to_show` and use a loop to display it ➏. The loop
    puts numbers into a variable called `item_counter`, which is used to extract the
    right image to draw each time, and also work out where to draw it ➐.
  prefs: []
  type: TYPE_NORMAL
- en: The clever bit is working out which items should go into `list_to_show`. In
    the `start_display` variable, we store the index number for the first item in
    `in_my_pockets` that the program should draw ➌. The `//` operator divides the
    selected item number by 16, rounding down. The result is then multiplied by 16
    to get the index number for the first item in the batch. For example, if the selected
    item is number 9, you’d divide 9 by 16 (0.5625), round down (0), and multiply
    by 16 (still 0), getting a result of 0\. That’s the start of the list, which makes
    sense, because we know there’s room for 16 items onscreen and that 9 is less than
    16\. If you wanted to see the group of items that includes item 22, you’d divide
    22 by 16 (1.375), round down (1), and multiply by 16, getting a result of 16\.
    That’s the start of the next batch, because the first batch has index numbers
    that range from 0 to 15.
  prefs: []
  type: TYPE_NORMAL
- en: We create the `list_to_show` list using a technique called *list slicing*, which
    is simply using just a part of a list. When you give Python two list indexes with
    a colon between them, the program will cut out that part of the list. The section
    we’re using starts at the `start_display` index and finishes 15 items later ➍.
    A list slice leaves out the last item, so we use `start_display + 16` as the end
    point.
  prefs: []
  type: TYPE_NORMAL
- en: We also need another calculation to work out which item to highlight as the
    selected item from the new list ➎. The item will have an index between 0 and 15,
    and we’ll store it in `selected_marker`. We calculate it as the remainder after
    we divide the selected item number by 16\. For example, if the selected item is
    number 18, it will be at index number 2 when the second group of items is displayed.
    (The first item is at index 0, remember.) Python has the modulo operator `%`,
    which you can use to get the remainder after a division.
  prefs: []
  type: TYPE_NORMAL
- en: To highlight the selected item on the screen, we draw a box around it using
    a Rect positioned at its left edge ➑. Unlike the filled rectangles you’ve seen
    (for example ➊), this instruction draws a hollow box with a white edge.
  prefs: []
  type: TYPE_NORMAL
- en: The description for the selected item is displayed underneath the inventory
    ➒, so players can TAB through their items to read their descriptions again.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when the program first runs, it needs to display the inventory. This
    is scheduled with a slight delay ➓ to avoid any problems that are caused by trying
    to use a `screen.blit()` instruction before Pygame Zero has finished starting
    up. While `clock.schedule_interval()` is used to run a function regularly, `clock.schedule_unique()`
    is used to run a function just once, after a delay.
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING THE TAB KEYBOARD CONTROL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you run the program, you can see the inventory, but you have no way to
    cycle between items yet, so the latest item you collected is always selected.
    Let’s add the keyboard control that enables you to TAB through the inventory to
    select different items.
  prefs: []
  type: TYPE_NORMAL
- en: Place the new instructions in [Listing 9-8](ch09.xhtml#ch09list8) into the `game_loop()`
    function, just after where you added the keyboard control to get items in [Listing
    9-6](ch09.xhtml#ch09list6). You need to indent them by at least four spaces because
    they’re inside the `game_loop()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Save this listing as *listing9-8.py*. When you run the program using pgzrun
    listing9-8.py, you’ll be able to press the TAB key to select different items in
    your inventory. (The TAB key is usually on the left side of the keyboard and might
    have a picture of two arrows on it.)
  prefs: []
  type: TYPE_NORMAL
- en: Pick up a few items before testing the new keyboard control, or skip ahead to
    the next section to fill up your inventory with more items to test with.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing9-8.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-8: Enabling the TAB key to select items in the inventory*'
  prefs: []
  type: TYPE_NORMAL
- en: The first chunk of instructions runs when the player presses the TAB key, but
    only if the `in_my_pockets` list contains some items (so its length is more than
    0) ➊.
  prefs: []
  type: TYPE_NORMAL
- en: To select the next item in the inventory, we increase the `selected_item` variable
    by 1 ➋ when the TAB key is pressed. This variable stores an index number (which
    starts at 0), so the program subtracts 1 from the length of the list to see whether
    the `selected_item` is now past the end of the list ➌. If it is, the selected
    item is reset to be the first item again, at 0.
  prefs: []
  type: TYPE_NORMAL
- en: We set the variable `item_carrying` as the object number of the selected item
    (which is taken from the `in_my_pockets` list) ➍. For example, if the `in_my_pockets`
    list contained the object numbers 55 and 65, and the `selected_item` was 0, `item_carrying`
    would contain 55 (the first item from `in_my_pockets`). Finally, the inventory
    is displayed using the `display_``inventory()` function you created earlier ➎.
  prefs: []
  type: TYPE_NORMAL
- en: While we’re working with this part of the program, we’ve added the keyboard
    controls for dropping and examining items too. When the player presses the D key
    and the `item_carrying` variable is not `False`, the `drop_object()` function
    runs ➏. This function is sent the player’s old *y* and *x* positions as the location
    for dropping the item ➐. Remember that the player’s current location might be
    inside a wall because of where we are in the game loop. We know that their most
    recent position before any movement is a safe place to drop something.
  prefs: []
  type: TYPE_NORMAL
- en: We also added the instructions to start the `examine_object()` function ➒ when
    the spacebar is pressed ➑.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t press D or the spacebar in the game yet: pressing them will cause the
    program to crash because we haven’t added the functions for them. We’ll add them
    shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**TESTING THE INVENTORY**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We want to test the program properly, but at the moment you don’t have many
    items in your inventory. To save time, we’ll tweak the code to give you a fuller
    inventory so you can test the display and the TAB control.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll fill the `in_my_pockets` list with items when the game begins. The quickest
    way to do this is to change the instruction that sets up that list in the `PROPS`
    section of the program, like this (but don’t do this yet!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: That would mean you start the game carrying all the items it’s possible to carry.
    If you do that, it might spoil your enjoyment of the game, though. You’ll be carrying
    some items you might prefer not to see until later in the game. It’ll make some
    of the puzzle solutions obvious.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, I recommend you create a test list like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This line creates a list that contains that sequence of items three times. You’ll
    end up with an inventory that contains three of each item (which is impossible
    in the real game), but it will enable you to test that the inventory works correctly
    when it contains more than 16 items.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’ve finished testing, change the code back again. Otherwise, you might
    get unexpected results when playing the game. Here’s what that line should look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**DROPPING OBJECTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Being able to collect stuff strewn all over the space station is great fun,
    but sometimes you’ll want to put it down, so you can either work with it or leave
    it somewhere. We’ll need two new functions for dropping items that will work a
    bit like the opposites of the functions for picking up items.
  prefs: []
  type: TYPE_NORMAL
- en: The `drop_object()` function (the opposite of the `pick_up_object()` function)
    will let you drop an object on the floor where the player was most recently standing.
    You added the keyboard control to start this function in [Listing 9-8](ch09.xhtml#ch09list8).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `remove_object()` function is like the `add_object()` function in reverse:
    it takes items out of the inventory and updates it.'
  prefs: []
  type: TYPE_NORMAL
- en: Add the new functions, shown in [Listing 9-9](ch09.xhtml#ch09list9), to the
    end of the `PROP INTERACTIONS` part of the program. Save the new program as *listing9-9.py*.
  prefs: []
  type: TYPE_NORMAL
- en: When you run the program using pgzrun listing9-9.py, you’ll be able to drop
    objects. That includes the yoyo you start the game carrying and any new objects
    you pick up as you explore the space station.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing9-9.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-9: Adding the functions for dropping objects*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `drop_object()` function needs two pieces of information: the player’s
    old *y* and *x* positions. If the player moved this time through the `game_loop()`
    function, this will be the position they were in before they tried to move. If
    not, these numbers will be the same position as where they currently are. We know
    this is a sensible place to drop an item that won’t put the object inside a wall.
    The player’s old position goes into the variables `old_y` and `old_x` within this
    function ➊.'
  prefs: []
  type: TYPE_NORMAL
- en: The program checks whether the room map at the player’s old position is a type
    of floor. If so, it’s okay to drop a prop here, so the drop instructions are used.
    If not ➏, the player sees a message telling them they can’t drop objects there.
    This will happen, for example, if there is already a prop in that position.
  prefs: []
  type: TYPE_NORMAL
- en: If the player can drop the item, we need to update the `props` dictionary. The
    variable `item_carrying` contains the number of the object the player is carrying.
    Its entry in the `props` dictionary is a list. The first list item (index 0) is
    the room the prop is in, the second item (index 1) is its *y* position, and the
    third item is its *x* position (index 2). These values are set to be the current
    room and the player’s old position ➌.
  prefs: []
  type: TYPE_NORMAL
- en: The room map for the current room also needs to be updated, so the room contains
    the dropped item ➍. The game will show a message and play a sound to tell the
    player that they’ve successfully dropped something and then the item is removed
    from the inventory using the `remove_object()` function ➎.
  prefs: []
  type: TYPE_NORMAL
- en: The `remove_object()` function takes an item from the player’s inventory and
    updates the `selected_item` variable. The object number sent to this function
    is stored in the variable `item`, and then `remove()` ➐ removes it from the `in_my_pockets`
    list. Now that the selected item has been removed, the number of the selected
    item is reduced by 1 ➑, so the previous item in the list is now selected. If this
    means the selected item is now less than 0, the selected item is reset to 0 ➒.
    This happens if the player drops the first item from their inventory.
  prefs: []
  type: TYPE_NORMAL
- en: If the player’s hands are now empty, the `item_carrying` variable is set to
    `False` ➓. Otherwise, it’s set to the number of their selected item. Finally,
    `display``_inventory()` redraws the inventory to show the item has been removed.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRAINING MISSION #1**'
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to do a safety drill. Can you pick up the air canister and deliver
    it to the sick bay? Drop it near the middle bed. To test whether the program is
    working correctly, leave the room after your delivery and come back to make sure
    it’s still there.
  prefs: []
  type: TYPE_NORMAL
- en: '**EXAMINING OBJECTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you explore the space station, you’ll want to study objects closely to see
    how they might help with your mission. The *examine* instruction shows the long
    description for an object and works for scenery and props. By examining an object,
    you can also sometimes find other objects. For example, when you examine a cupboard,
    you might find something inside it.
  prefs: []
  type: TYPE_NORMAL
- en: Pressing the spacebar triggers the `examine_object()` function. (You added the
    keyboard control in [Listing 9-8](ch09.xhtml#ch09list8).) Place the new function,
    shown in [Listing 9-10](ch09.xhtml#ch09list10), after the `remove_object()` function
    you added in [Listing 9-9](ch09.xhtml#ch09list9).
  prefs: []
  type: TYPE_NORMAL
- en: Save your program as *listing9-10.py*. Run the program using pgzrun listing9-10.py.
    You can now examine objects by walking up to or onto them and pressing the spacebar.
    For example, if you press the up arrow key and the spacebar when you’re against
    the wall at the back of the room, you can examine the wall.
  prefs: []
  type: TYPE_NORMAL
- en: '*listing9-10.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 9-10: Adding the code to examine objects*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 9-10](ch09.xhtml#ch09list10) builds on the work you’ve already done
    adding functions in this chapter. We start by getting the number of the object
    the player wants to examine and storing it in `item_player_is_on` ➊. At this point
    in the `game_loop()` function, the player’s position will be on or possibly inside
    the item they want to examine, if it’s a piece of scenery. We put the starting
    *x* position of the item into the variable `left_tile_of_item` ➋. If there isn’t
    an object to examine at the player’s location, the function finishes without taking
    any further action ➌. Ignoring an empty space feels more natural than describing
    the floor, especially if you make a mistake with the controls. If there is an
    item at the player’s location, the description of the object goes into the `description`
    variable, taken from the long description from the `objects` dictionary ➍.'
  prefs: []
  type: TYPE_NORMAL
- en: The program then checks whether there’s an item hidden *inside* the item the
    player is examining. We use a loop to go through all the items in the props dictionary
    ➎. If an item is in the current room at the player’s position, but the room map
    at that position doesn’t contain the prop number ➏, it means the item is hidden.
    We therefore add the hidden object to the player’s inventory ➐, and give the player
    a message that tells them they found something. This message uses the object’s
    short description to tell them what they’ve found ➑.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the function, the description is shown ➒, and we’ve put a short
    pause here to stop it being immediately overwritten if the player holds the key
    down ➓.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to hide props inside scenery in your own game design, make sure
    you give players a strong hint about where you’ve hidden something. In *Escape*,
    you might find objects in cupboards. If you see something unusual, it’s usually
    a good idea to examine it to learn about it, and you might find something else
    of interest. You won’t need to search every chair, bed, and wall panel though.
  prefs: []
  type: TYPE_NORMAL
- en: If you decide to hide props in wide scenery (such as a bed), make sure you hide
    your prop in the *x* position of the scenery item, not in a space that would be
    covered by 255 in the room map.
  prefs: []
  type: TYPE_NORMAL
- en: '**TRAINING MISSION #2**'
  prefs: []
  type: TYPE_NORMAL
- en: Can you find the MP3 player? It’s in the sleeping quarters that belong to the
    person you named `FRIEND2` in [Chapter 4](ch04.xhtml#ch04). If you’re using my
    code, it’s in Leo’s sleeping quarters.
  prefs: []
  type: TYPE_NORMAL
- en: Now that all the props are unpacked, you can relax with your yoyo and see what
    else you can find. In the next chapter, you’ll add a new section to the program
    that enables you to use the props you come across.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARE YOU FIT TO FLY?**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Check the following boxes to confirm that you’ve learned the key lessons in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  Information about the position of props is stored
    in the `props` dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  The prop number is the dictionary key, and each
    entry contains a list with the room number and *y* and *x* positions of the prop.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  To receive a number from a function, set up a
    variable to store that information when you call the function. For example, variable_name
    `=` function_name`()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  To send a number (or anything else) back from
    a function, use the `return` instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  The `//` operator is used for division and rounds
    the result down, removing any decimal in the answer.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  The `%` operator gives you the remainder after
    dividing two numbers: `5 % 2` is `1`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  You can change the value of variables and lists
    to help test the program, for example, creating a full inventory at the start.
    Remember to change them back afterward!'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/box.jpg)  You can hide props inside scenery, but make sure
    they’re in the position where the scenery starts, and give players a strong hint
    about where it’s worth searching.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0170-01.jpg)'
  prefs: []
  type: TYPE_IMG
