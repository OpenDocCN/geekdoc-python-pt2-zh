- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Files and Exceptions
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that you’ve mastered the basic skills you need to write organized programs
    that are easy to use, it’s time to think about making your programs even more
    relevant and usable. In this chapter, you’ll learn to work with files so your
    programs can quickly analyze lots of data.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll learn to handle errors so your programs don’t crash when they encounter
    unexpected situations. You’ll learn about *exceptions*, which are special objects
    Python creates to manage errors that arise while a program is running. You’ll
    also learn about the `json` module, which allows you to save user data so it isn’t
    lost when your program stops running.
  prefs: []
  type: TYPE_NORMAL
- en: Learning to work with files and save data will make your programs easier for
    people to use. Users will be able to choose what data to enter and when to enter
    it. People will be able to run your program, do some work, and then close the
    program and pick up where they left off. Learning to handle exceptions will help
    you deal with situations in which files don’t exist and deal with other problems
    that can cause your programs to crash. This will make your programs more robust
    when they encounter bad data, whether it comes from innocent mistakes or from
    malicious attempts to break your programs. With the skills you’ll learn in this
    chapter, you’ll make your programs more applicable, usable, and stable.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from a File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An incredible amount of data is available in text files. Text files can contain
    weather data, traffic data, socioeconomic data, literary works, and more. Reading
    from a file is particularly useful in data analysis applications, but it’s also
    applicable to any situation in which you want to analyze or modify information
    stored in a file. For example, you can write a program that reads in the contents
    of a text file and rewrites the file with formatting that allows a browser to
    display it.
  prefs: []
  type: TYPE_NORMAL
- en: When you want to work with the information in a text file, the first step is
    to read the file into memory. You can then work through all of the file’s contents
    at once or work through the contents line by line.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the Contents of a File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To begin, we need a file with a few lines of text in it. Let’s start with a
    file that contains *pi* to 30 decimal places, with 10 decimal places per line:'
  prefs: []
  type: TYPE_NORMAL
- en: '**pi_digits.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To try the following examples yourself, you can enter these lines in an editor
    and save the file as *pi_digits.txt*, or you can download the file from the book’s
    resources through [https://ehmatthes.github.io/pcc_3e](https://ehmatthes.github.io/pcc_3e).
    Save the file in the same directory where you’ll store this chapter’s programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a program that opens this file, reads it, and prints the contents of
    the file to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**file_reader.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To work with the contents of a file, we need to tell Python the path to the
    file. A *path* is the exact location of a file or folder on a system. Python provides
    a module called `pathlib` that makes it easier to work with files and directories,
    no matter which operating system you or your program’s users are working with.
    A module that provides specific functionality like this is often called a *library*,
    hence the name `pathlib`.
  prefs: []
  type: TYPE_NORMAL
- en: We start by importing the `Path` class from `pathlib`. There’s a lot you can
    do with a `Path` object that points to a file. For example, you can check that
    the file exists before working with it, read the file’s contents, or write new
    data to the file. Here, we build a `Path` object representing the file *pi_digits.txt*,
    which we assign to the variable `path` ❶. Since this file is saved in the same
    directory as the *.py* file we’re writing, the filename is all that `Path` needs
    to access the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a `Path` object representing *pi_digits.txt*, we use the `read_text()`
    method to read the entire contents of the file ❷. The contents of the file are
    returned as a single string, which we assign to the variable `contents`. When
    we print the value of `contents`, we see the entire contents of the text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between this output and the original file is the extra blank
    line at the end of the output. The blank line appears because `read_text()` returns
    an empty string when it reaches the end of the file; this empty string shows up
    as a blank line.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can remove the extra blank line by using `rstrip()` on the `contents` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall from Chapter 2 that Python’s `rstrip()` method removes, or strips, any
    whitespace characters from the right side of a string. Now the output matches
    the contents of the original file exactly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can strip the trailing newline character when we read the contents of the
    file, by applying the `rstrip()` method immediately after calling `read_text()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This line tells Python to call the `read_text()` method on the file we’re working
    with. Then it applies the `rstrip()` method to the string that `read_text()` returns.
    The cleaned-up string is then assigned to the variable `contents`. This approach
    is called *method chaining*, and you’ll see it used often in programming.
  prefs: []
  type: TYPE_NORMAL
- en: Relative and Absolute File Paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you pass a simple filename like *pi_digits.txt* to `Path`, Python looks
    in the directory where the file that’s currently being executed (that is, your
    *.py* program file) is stored.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, depending on how you organize your work, the file you want to open
    won’t be in the same directory as your program file. For example, you might store
    your program files in a folder called *python_work*; inside *python_work*, you
    might have another folder called *text_files* to distinguish your program files
    from the text files they’re manipulating. Even though *text_files* is in *python_work*,
    just passing `Path` the name of a file in *text_files* won’t work, because Python
    will only look in *python_work* and stop there; it won’t go on and look in *text_files.*
    To get Python to open files from a directory other than the one where your program
    file is stored, you need to provide the correct path.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main ways to specify paths in programming. A *relative file path*
    tells Python to look for a given location relative to the directory where the
    currently running program file is stored. Since *text_files* is inside *python_work*,
    we need to build a path that starts with the directory *text_files*, and ends
    with the filename. Here’s how to build this path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can also tell Python exactly where the file is on your computer, regardless
    of where the program that’s being executed is stored. This is called an *absolute
    file path*. You can use an absolute path if a relative path doesn’t work. For
    instance, if you’ve put *text_files* in some folder other than *python_work*,
    then just passing `Path` the path `'text_files/``filename``.txt'` won’t work because
    Python will only look for that location inside *python_work*. You’ll need to write
    out an absolute path to clarify where you want Python to look.
  prefs: []
  type: TYPE_NORMAL
- en: 'Absolute paths are usually longer than relative paths, because they start at
    your system’s root folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using absolute paths, you can read files from any location on your system. For
    now it’s easiest to store files in the same directory as your program files, or
    in a folder such as *text_files* within the directory that stores your program
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a File’s Lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you’re working with a file, you’ll often want to examine each line of the
    file. You might be looking for certain information in the file, or you might want
    to modify the text in the file in some way. For example, you might want to read
    through a file of weather data and work with any line that includes the word *sunny*
    in the description of that day’s weather. In a news report, you might look for
    any line with the tag `<headline>` and rewrite that line with a specific kind
    of formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `splitlines()` method to turn a long string into a set of lines,
    and then use a `for` loop to examine each line from a file, one at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '**file_reader.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We start out by reading the entire contents of the file, as we did earlier
    ❶. If you’re planning to work with the individual lines in a file, you don’t need
    to strip any whitespace when reading the file. The `splitlines()` method returns
    a list of all lines in the file, and we assign this list to the variable `lines`
    ❷. We then loop over these lines and print each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Since we haven’t modified any of the lines, the output matches the original
    text file exactly.
  prefs: []
  type: TYPE_NORMAL
- en: Working with a File’s Contents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After you’ve read the contents of a file into memory, you can do whatever you
    want with that data, so let’s briefly explore the digits of *pi*. First, we’ll
    attempt to build a single string containing all the digits in the file with no
    whitespace in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**pi_string.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by reading the file and storing each line of digits in a list, just
    as we did in the previous example. We then create a variable, `pi_string`, to
    hold the digits of *pi*. We write a loop that adds each line of digits to `pi_string`
    ❶. We print this string, and also show how long the string is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable `pi_string` contains the whitespace that was on the left side
    of the digits in each line, but we can get rid of that by using `lstrip()` on
    each line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a string containing *pi* to 30 decimal places. The string is 32
    characters long because it also includes the leading `3` and a decimal point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Large Files: One Million Digits'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we’ve focused on analyzing a text file that contains only three lines,
    but the code in these examples would work just as well on much larger files. If
    we start with a text file that contains *pi* to 1,000,000 decimal places, instead
    of just 30, we can create a single string containing all these digits. We don’t
    need to change our program at all, except to pass it a different file. We’ll also
    print just the first 50 decimal places, so we don’t have to watch a million digits
    scroll by in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '**pi_string.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows that we do indeed have a string containing *pi* to 1,000,000
    decimal places:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Python has no inherent limit to how much data you can work with; you can work
    with as much data as your system’s memory can handle.
  prefs: []
  type: TYPE_NORMAL
- en: Is Your Birthday Contained in Pi?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I’ve always been curious to know if my birthday appears anywhere in the digits
    of *pi*. Let’s use the program we just wrote to find out if someone’s birthday
    appears anywhere in the first million digits of *pi*. We can do this by expressing
    each birthday as a string of digits and seeing if that string appears anywhere
    in `pi_string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**pi_birthday.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We first prompt for the user’s birthday, and then check if that string is in
    `pi_string`. Let’s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: My birthday does appear in the digits of *pi*! Once you’ve read from a file,
    you can analyze its contents in just about any way you can imagine.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to a File
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the simplest ways to save data is to write it to a file. When you write
    text to a file, the output will still be available after you close the terminal
    containing your program’s output. You can examine output after a program finishes
    running, and you can share the output files with others as well. You can also
    write programs that read the text back into memory and work with it again later.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Single Line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have a path defined, you can write to a file using the `write_text()`
    method. To see how this works, let’s write a simple message and store it in a
    file instead of printing it to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**write_message.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `write_text()` method takes a single argument: the string that you want
    to write to the file. This program has no terminal output, but if you open the
    file *programming.txt*, you’ll see one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '**programming.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This file behaves like any other file on your computer. You can open it, write
    new text in it, copy from it, paste to it, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Multiple Lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `write_text()` method does a few things behind the scenes. If the file that
    `path` points to doesn’t exist, it creates that file. Also, after writing the
    string to the file, it makes sure the file is closed properly. Files that aren’t
    closed properly can lead to missing or corrupted data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write more than one line to a file, you need to build a string containing
    the entire contents of the file, and then call `write_text()` with that string.
    Let’s write several lines to the *programming.txt* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We define a variable called `contents` that will hold the entire contents of
    the file. On the next line, we use the `+=` operator to add to this string. You
    can do this as many times as you need, to build strings of any length. In this
    case we include newline characters at the end of each line, to make sure each
    statement appears on its own line.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run this and then open *programming.txt*, you’ll see each of these lines
    in the text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can also use spaces, tab characters, and blank lines to format your output,
    just as you’ve been doing with terminal-based output. There’s no limit to the
    length of your strings, and this is how many computer-generated documents are
    created.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python uses special objects called *exceptions* to manage errors that arise
    during a program’s execution. Whenever an error occurs that makes Python unsure
    of what to do next, it creates an exception object. If you write code that handles
    the exception, the program will continue running. If you don’t handle the exception,
    the program will halt and show a *traceback*, which includes a report of the exception
    that was raised.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions are handled with `try`-`except` blocks. A *try*-*except* block asks
    Python to do something, but it also tells Python what to do if an exception is
    raised. When you use `try`-`except` blocks, your programs will continue running
    even if things start to go wrong. Instead of tracebacks, which can be confusing
    for users to read, users will see friendly error messages that you’ve written.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the ZeroDivisionError Exception
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at a simple error that causes Python to raise an exception. You
    probably know that it’s impossible to divide a number by zero, but let’s ask Python
    to do it anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '**division_calculator.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Python can’t do this, so we get a traceback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The error reported in the traceback, `ZeroDivisionError`, is an exception object
    ❶. Python creates this kind of object in response to a situation where it can’t
    do what we ask it to. When this happens, Python stops the program and tells us
    the kind of exception that was raised. We can use this information to modify our
    program. We’ll tell Python what to do when this kind of exception occurs; that
    way, if it happens again, we’ll be prepared.
  prefs: []
  type: TYPE_NORMAL
- en: Using try-except Blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you think an error may occur, you can write a `try`-`except` block to handle
    the exception that might be raised. You tell Python to try running some code,
    and you tell it what to do if the code results in a particular kind of exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what a `try`-`except` block for handling the `ZeroDivisionError` exception
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We put `print(5/0)`, the line that caused the error, inside a `try` block. If
    the code in a `try` block works, Python skips over the `except` block. If the
    code in the `try` block causes an error, Python looks for an `except` block whose
    error matches the one that was raised, and runs the code in that block.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the code in the `try` block produces a `ZeroDivisionError`,
    so Python looks for an `except` block telling it how to respond. Python then runs
    the code in that block, and the user sees a friendly error message instead of
    a traceback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If more code followed the `try`-`except` block, the program would continue running
    because we told Python how to handle the error. Let’s look at an example where
    catching an error can allow a program to continue running.
  prefs: []
  type: TYPE_NORMAL
- en: Using Exceptions to Prevent Crashes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Handling errors correctly is especially important when the program has more
    work to do after the error occurs. This happens often in programs that prompt
    users for input. If the program responds to invalid input appropriately, it can
    prompt for more valid input instead of crashing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a simple calculator that does only division:'
  prefs: []
  type: TYPE_NORMAL
- en: '**division_calculator.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This program prompts the user to input a `first_number` ❶ and, if the user
    does not enter `q` to quit, a `second_number` ❷. We then divide these two numbers
    to get an `answer` ❸. This program does nothing to handle errors, so asking it
    to divide by zero causes it to crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It’s bad that the program crashed, but it’s also not a good idea to let users
    see tracebacks. Nontechnical users will be confused by them, and in a malicious
    setting, attackers will learn more than you want them to. For example, they’ll
    know the name of your program file, and they’ll see a part of your code that isn’t
    working properly. A skilled attacker can sometimes use this information to determine
    which kind of attacks to use against your code.
  prefs: []
  type: TYPE_NORMAL
- en: The else Block
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can make this program more error resistant by wrapping the line that might
    produce errors in a `try`-`except` block. The error occurs on the line that performs
    the division, so that’s where we’ll put the `try`-`except` block. This example
    also includes an `else` block. Any code that depends on the `try` block executing
    successfully goes in the `else` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We ask Python to try to complete the division operation in a `try` block ❶,
    which includes only the code that might cause an error. Any code that depends
    on the `try` block succeeding is added to the `else` block. In this case, if the
    division operation is successful, we use the `else` block to print the result
    ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `except` block tells Python how to respond when a `ZeroDivisionError` arises
    ❷. If the `try` block doesn’t succeed because of a division-by-zero error, we
    print a friendly message telling the user how to avoid this kind of error. The
    program continues to run, and the user never sees a traceback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The only code that should go in a `try` block is code that might cause an exception
    to be raised. Sometimes you’ll have additional code that should run only if the
    `try` block was successful; this code goes in the `else` block. The `except` block
    tells Python what to do in case a certain exception arises when it tries to run
    the code in the `try` block.
  prefs: []
  type: TYPE_NORMAL
- en: By anticipating likely sources of errors, you can write robust programs that
    continue to run even when they encounter invalid data and missing resources. Your
    code will be resistant to innocent user mistakes and malicious attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the FileNotFoundError Exception
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One common issue when working with files is handling missing files. The file
    you’re looking for might be in a different location, the filename might be misspelled,
    or the file might not exist at all. You can handle all of these situations with
    a `try`-`except` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to read a file that doesn’t exist. The following program tries to
    read in the contents of *Alice in Wonderland*, but I haven’t saved the file *alice.txt*
    in the same directory as *alice.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alice.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note that we’re using `read_text()` in a slightly different way here than what
    you saw earlier. The `encoding` argument is needed when your system’s default
    encoding doesn’t match the encoding of the file that’s being read. This is most
    likely to happen when reading from a file that wasn’t created on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python can’t read from a missing file, so it raises an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is a longer traceback than the ones we’ve seen previously, so let’s look
    at how you can make sense of more complex tracebacks. It’s often best to start
    at the very end of the traceback. On the last line, we can see that a `FileNotFoundError`
    exception was raised ❸. This is important because it tells us what kind of exception
    to use in the `except` block that we’ll write.
  prefs: []
  type: TYPE_NORMAL
- en: Looking back near the beginning of the traceback ❶, we can see that the error
    occurred at line 4 in the file *alice.py*. The next line shows the line of code
    that caused the error ❷. The rest of the traceback shows some code from the libraries
    that are involved in opening and reading from files. You don’t usually need to
    read through or understand all of these lines in a traceback.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle the error that’s being raised, the `try` block will begin with the
    line that was identified as problematic in the traceback. In our example, this
    is the line that contains `read_text()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the code in the `try` block produces a `FileNotFoundError`,
    so we write an `except` block that matches that error ❶. Python then runs the
    code in that block when the file can’t be found, and the result is a friendly
    error message instead of a traceback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The program has nothing more to do if the file doesn’t exist, so this is all
    the output we see. Let’s build on this example and see how exception handling
    can help when you’re working with more than one file.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing Text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can analyze text files containing entire books. Many classic works of literature
    are available as simple text files because they are in the public domain. The
    texts used in this section come from Project Gutenberg ([https://gutenberg.org](https://gutenberg.org)).
    Project Gutenberg maintains a collection of literary works that are available
    in the public domain, and it’s a great resource if you’re interested in working
    with literary texts in your programming projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s pull in the text of *Alice in Wonderland* and try to count the number
    of words in the text. To do this, we’ll use the string method `split()`, which
    by default splits a string wherever it finds any whitespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: I moved the file *alice.txt* to the correct directory, so the `try` block will
    work this time. We take the string `contents`, which now contains the entire text
    of *Alice in Wonderland* as one long string, and use `split()` to produce a list
    of all the words in the book ❶. Using `len()` on this list ❷ gives us a good approximation
    of the number of words in the original text. Lastly, we print a statement that
    reports how many words were found in the file. This code is placed in the `else`
    block because it only works if the code in the `try` block was executed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output tells us how many words are in *alice.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The count is a little high because extra information is provided by the publisher
    in the text file used here, but it’s a good approximation of the length of *Alice
    in Wonderland*.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Multiple Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s add more books to analyze, but before we do, let’s move the bulk of this
    program to a function called `count_words()`. This will make it easier to run
    the analysis for multiple books:'
  prefs: []
  type: TYPE_NORMAL
- en: '**word_count.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Most of this code is unchanged. It’s only been indented, and moved into the
    body of `count_words()`. It’s a good habit to keep comments up to date when you’re
    modifying a program, so the comment has also been changed to a docstring and reworded
    slightly ❶.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can write a short loop to count the words in any text we want to analyze.
    We do this by storing the names of the files we want to analyze in a list, and
    then we call `count_words()` for each file in the list. We’ll try to count the
    words for *Alice in Wonderland*, *Siddhartha*, *Moby Dick*, and *Little Women*,
    which are all available in the public domain. I’ve intentionally left *siddhartha.txt*
    out of the directory containing *word_count.py*, so we can see how well our program
    handles a missing file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The names of the files are stored as simple strings. Each string is then converted
    to a `Path` object ❶, before the call to `count_words()`. The missing *siddhartha.txt*
    file has no effect on the rest of the program’s execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Using the `try`-`except` block in this example provides two significant advantages.
    We prevent our users from seeing a traceback, and we let the program continue
    analyzing the texts it’s able to find. If we don’t catch the `FileNotFoundError`
    that *siddhartha.txt* raises, the user would see a full traceback, and the program
    would stop running after trying to analyze *Siddhartha*. It would never analyze
    *Moby Dick* or *Little Women*.
  prefs: []
  type: TYPE_NORMAL
- en: Failing Silently
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous example, we informed our users that one of the files was unavailable.
    But you don’t need to report every exception you catch. Sometimes, you’ll want
    the program to fail silently when an exception occurs and continue on as if nothing
    happened. To make a program fail silently, you write a `try` block as usual, but
    you explicitly tell Python to do nothing in the `except` block. Python has a `pass`
    statement that tells it to do nothing in a block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference between this listing and the previous one is the `pass`
    statement in the `except` block. Now when a `FileNotFoundError` is raised, the
    code in the `except` block runs, but nothing happens. No traceback is produced,
    and there’s no output in response to the error that was raised. Users see the
    word counts for each file that exists, but they don’t see any indication that
    a file wasn’t found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `pass` statement also acts as a placeholder. It’s a reminder that you’re
    choosing to do nothing at a specific point in your program’s execution and that
    you might want to do something there later. For example, in this program we might
    decide to write any missing filenames to a file called *missing_files.txt*. Our
    users wouldn’t see this file, but we’d be able to read the file and deal with
    any missing texts.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding Which Errors to Report
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How do you know when to report an error to your users and when to let your program
    fail silently? If users know which texts are supposed to be analyzed, they might
    appreciate a message informing them why some texts were not analyzed. If users
    expect to see some results but don’t know which books are supposed to be analyzed,
    they might not need to know that some texts were unavailable. Giving users information
    they aren’t looking for can decrease the usability of your program. Python’s error-handling
    structures give you fine-grained control over how much to share with users when
    things go wrong; it’s up to you to decide how much information to share.
  prefs: []
  type: TYPE_NORMAL
- en: Well-written, properly tested code is not very prone to internal errors, such
    as syntax or logical errors. But every time your program depends on something
    external such as user input, the existence of a file, or the availability of a
    network connection, there is a possibility of an exception being raised. A little
    experience will help you know where to include exception-handling blocks in your
    program and how much to report to users about errors that arise.
  prefs: []
  type: TYPE_NORMAL
- en: Storing Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many of your programs will ask users to input certain kinds of information.
    You might allow users to store preferences in a game or provide data for a visualization.
    Whatever the focus of your program is, you’ll store the information users provide
    in data structures such as lists and dictionaries. When users close a program,
    you’ll almost always want to save the information they entered. A simple way to
    do this involves storing your data using the `json` module.
  prefs: []
  type: TYPE_NORMAL
- en: The `json` module allows you to convert simple Python data structures into JSON-formatted
    strings, and then load the data from that file the next time the program runs.
    You can also use `json` to share data between different Python programs. Even
    better, the JSON data format is not specific to Python, so you can share data
    you store in the JSON format with people who work in many other programming languages.
    It’s a useful and portable format, and it’s easy to learn.
  prefs: []
  type: TYPE_NORMAL
- en: Using json.dumps() and json.loads()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s write a short program that stores a set of numbers and another program
    that reads these numbers back into memory. The first program will use `json.dumps()`
    to store the set of numbers, and the second program will use `json.loads()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `json.dumps()` function takes one argument: a piece of data that should
    be converted to the JSON format. The function returns a string, which we can then
    write to a data file:'
  prefs: []
  type: TYPE_NORMAL
- en: '**number_writer.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We first import the `json` module, and then create a list of numbers to work
    with. Then we choose a filename in which to store the list of numbers ❶. It’s
    customary to use the file extension *.json* to indicate that the data in the file
    is stored in the JSON format. Next, we use the `json.dumps()` ❷ function to generate
    a string containing the JSON representation of the data we’re working with. Once
    we have this string, we write it to the file using the same `write_text()` method
    we used earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'This program has no output, but let’s open the file *numbers.json* and look
    at it. The data is stored in a format that looks just like Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’ll write a separate program that uses `json.loads()` to read the list
    back into memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '**number_reader.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We make sure to read from the same file we wrote to ❶. Since the data file
    is just a text file with specific formatting, we can read it with the `read_text()`
    method ❷. We then pass the contents of the file to `json.loads()` ❸. This function
    takes in a JSON-formatted string and returns a Python object (in this case, a
    list), which we assign to `numbers`. Finally, we print the recovered list of numbers
    and see that it’s the same list created in *number_writer.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple way to share data between two programs.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and Reading User-Generated Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Saving data with `json` is useful when you’re working with user-generated data,
    because if you don’t store your user’s information somehow, you’ll lose it when
    the program stops running. Let’s look at an example where we prompt the user for
    their name the first time they run a program and then remember their name when
    they run the program again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by storing the user’s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '**remember_me.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We first prompt for a username to store ❶. Next, we write the data we just
    collected to a file called *username.json* ❷. Then we print a message informing
    the user that we’ve stored their information ❸:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s write a new program that greets a user whose name has already been
    stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '**greet_user.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We read the contents of the data file ❶ and then use `json.loads()` to assign
    the recovered data to the variable `username` ❷. Since we’ve recovered the username,
    we can welcome the user back with a personalized greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to combine these two programs into one file. When someone runs *remember_me.py*,
    we want to retrieve their username from memory if possible; if not, we’ll prompt
    for a username and store it in *username.json* for next time. We could write a
    `try`-`except` block here to respond appropriately if *username.json* doesn’t
    exist, but instead we’ll use a handy method from the `pathlib` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '**remember_me.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: There are many helpful methods you can use with `Path` objects. The `exists()`
    method returns `True` if a file or folder exists and `False` if it doesn’t. Here
    we use `path.exists()` to find out if a username has already been stored ❶. If
    *username.json* exists, we load the username and print a personalized greeting
    to the user.
  prefs: []
  type: TYPE_NORMAL
- en: If the file *username.json* doesn’t exist ❷, we prompt for a username and store
    the value that the user enters. We also print the familiar message that we’ll
    remember them when they come back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whichever block executes, the result is a username and an appropriate greeting.
    If this is the first time the program runs, this is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This is the output you see if the program was already run at least once. Even
    though the data in this section is just a single string, the program would work
    just as well with any data that can be converted to a JSON-formatted string.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often, you’ll come to a point where your code will work, but you’ll recognize
    that you could improve the code by breaking it up into a series of functions that
    have specific jobs. This process is called *refactoring*. Refactoring makes your
    code cleaner, easier to understand, and easier to extend.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can refactor *remember_me.py* by moving the bulk of its logic into one or
    more functions. The focus of *remember_me.py* is on greeting the user, so let’s
    move all of our existing code into a function called `greet_user()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**remember_me.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Because we’re using a function now, we rewrite the comments as a docstring that
    reflects how the program currently works ❶. This file is a little cleaner, but
    the function `greet_user()` is doing more than just greeting the user—it’s also
    retrieving a stored username if one exists and prompting for a new username if
    one doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s refactor `greet_user()` so it’s not doing so many different tasks. We’ll
    start by moving the code for retrieving a stored username to a separate function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The new function `get_stored_username()` ❶ has a clear purpose, as stated in
    the docstring. This function retrieves a stored username and returns the username
    if it finds one. If the path that’s passed to `get_stored_username()` doesn’t
    exist, the function returns `None` ❷. This is good practice: a function should
    either return the value you’re expecting, or it should return `None`. This allows
    us to perform a simple test with the return value of the function. We print a
    welcome back message to the user if the attempt to retrieve a username is successful
    ❸, and if it isn’t, we prompt for a new username.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We should factor one more block of code out of `greet_user()`. If the username
    doesn’t exist, we should move the code that prompts for a new username to a function
    dedicated to that purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Each function in this final version of *remember_me.py* has a single, clear
    purpose. We call `greet_user()`, and that function prints an appropriate message:
    it either welcomes back an existing user or greets a new user. It does this by
    calling `get_stored_username()` ❶, which is responsible only for retrieving a
    stored username if one exists. Finally, if necessary, `greet_user()` calls `get_new_username()`❷,
    which is responsible only for getting a new username and storing it. This compartmentalization
    of work is an essential part of writing clear code that will be easy to maintain
    and extend.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to work with files. You learned to read the
    entire contents of a file, and then work through the contents one line at a time
    if you need to. You learned to write as much text as you want to a file. You also
    read about exceptions and how to handle the exceptions you’re likely to see in
    your programs. Finally, you learned how to store Python data structures so you
    can save information your users provide, preventing them from having to start
    over each time they run a program.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 11, you’ll learn efficient ways to test your code. This will help
    you trust that the code you develop is correct, and it will help you identify
    bugs that are introduced as you continue to build on the programs you’ve written.
  prefs: []
  type: TYPE_NORMAL
