<html><head></head><body>
<h2 class="h2" id="ch16"><span epub:type="pagebreak" id="page_347"/><strong><span class="big">16</span><br/>FINDING FRAUDS WITH BENFORD’S LAW</strong></h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">Prior to the invention of electronic calculators, if you needed to take the log of a number, you looked it up in a table. Astronomer Simon Newcomb used such tables, and in 1881, he noticed that the pages in the front, used for numbers beginning with the lowest digits, were more worn than those in the back. From this mundane observation, he realized that—at least for measurements and constants in nature—the leading digits were much more likely to be small than large. He published a short article about it and moved on.</p>
<p class="indent">For decades, this statistical curiosity, like Tolkien’s One Ring, “passed out of all knowledge.” Then, in 1938, physicist Frank Benford rediscovered and confirmed the phenomenon by collecting over 20,000 samples of real-world numbers, using data sources as diverse as the measurements of rivers, street addresses, numbers contained in <em>Reader’s Digest</em> magazine, molecular weights, baseball statistics, death rates, and more. As the person who popularized this scientific discovery, he got all the credit.</p>
<p class="indent"><span epub:type="pagebreak" id="page_348"/>According to <em>Benford’s law</em>, also known as the <em>first-digit law</em>, the frequency of occurrence of the leading digits in naturally occurring numerical distributions is predictable and nonuniform. In fact, a given number is six times more likely to start with a 1 than a 9! This is very counterintuitive, as most people would expect a uniform distribution, with each number having a one in nine (11.1 percent) chance of occupying the first slot. Due to this cognitive disconnect, Benford’s law has become a useful tool for fraud detection in financial, scientific, and election data.</p>
<p class="indent">In this chapter, you’ll write a Python program that compares real-life datasets to Benford’s law and determines whether they appear fraudulent or not. You’ll also dust off <span class="literal">matplotlib</span> one last time to add a useful visual component to the analysis. For a dataset, you’ll use votes cast in the contentious 2016 US presidential election.</p>
<h3 class="h3a" id="lev378"><strong>Project #24: Benford’s Law of Leading Digits</strong></h3>
<p class="noindent"><a href="ch16.xhtml#ch16fig1">Figure 16-1</a> depicts a bar chart of the leading significant digits in a set of numbers following Benford’s law. Surprisingly, scale doesn’t matter. A tabulation of the length of Australian roads will follow Benford’s law whether it is in miles, kilometers, or cubits! As a statistical principle, it is <em>scale invariant</em>.</p>
<div class="image"><a id="ch16fig1"/><img src="../images/f0348-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 16-1: The frequency of occurrence of leading digits according to Benford’s law</em></p>
<p class="indent">It took mathematicians about a hundred years to come up with an explanation for Benford’s law that <em>they</em> found satisfactory. For the rest of us, let’s just say that there are more little things in the universe than large things. Frank Benford used the analogy that owning <em>one</em> acre of land is easier than owning <em>nine</em> acres. In fact, you can closely duplicate the frequency produced by Benford’s law by simply assuming that there are twice as many 1s as 2s, three times as many 1s as 3s, and so on. You just take <span epub:type="pagebreak" id="page_349"/>the inverse of each of the nine digits (1 / <em>d</em>) and divide by the sum of all the inverses (2.83). Then multiply the results by 100 to get the percentage (see <a href="ch16.xhtml#ch16fig2">Figure 16-2</a>).</p>
<div class="image"><a id="ch16fig2"/><img src="../images/f0349-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 16-2: Comparison of Benford’s law with an approximation proportional to the inverse of the first digit</em></p>
<p class="indent">Because of the size relationships just discussed, Benford’s law can be visualized with a <em>logarithmic</em> scale, which is used to graph data that are related according to an exponential relationship. In <em>semilogarithmic</em> (“semilog”) plots, one variable tends to be restricted, like the set of leading digits (1–9), while the other covers a wide range of values that includes several orders of magnitude.</p>
<p class="indent">On semilog graph paper, the horizontal x-axis values are log values, and the vertical y-axis values, represented by horizontal lines, are not (see <a href="ch16.xhtml#ch16fig3">Figure 16-3</a>). On the x-axis, the horizontal divisions aren’t regular, and this nonlinear pattern repeats with powers of 10. For every <em>decade</em> on the log paper, such as 1 through 10 or 10 through 100, the <em>width</em> of the divisions between numbers is proportional to the <em>length</em> of the bars in <a href="ch16.xhtml#ch16fig1">Figure 16-1</a>. For example, the distance between the 1 and 2 in <a href="ch16.xhtml#ch16fig3">Figure 16-3</a> is 30.1 percent of the distance between 1 and 10. As one author put it, you could derive Benford’s law by simply throwing darts at a piece of log paper!</p>
<div class="image"><a id="ch16fig3"/><img src="../images/f0349-02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 16-3: Example of two-decade semilogarithmic graph paper</em></p>
<p class="indent">For a collection of numeric data to conform to Benford’s law, certain conditions have to be met. The numbers need to be random and not assigned, with no imposed minimums or maximums. The numbers should <span epub:type="pagebreak" id="page_350"/>cover several orders of magnitude, and the dataset should be large; recommendations in the literature call for 100 to 1,000 samples as a minimum, though Benford’s law has been shown to hold true for datasets containing as few as 50 numbers. Examples of distributions that won’t follow Benford’s law are the heights of professional basketball players, US telephone numbers (for which only the last four digits are truly random), prices influenced by psychological barriers ($1.99 versus $2.00), and medical copayments.</p>
<h4 class="h4" id="lev379"><strong><em>Applying Benford’s Law</em></strong></h4>
<p class="noindent">Most financial and accounting data conform to naturally occurring numbers and are thus subject to Benford’s law. For example, assume you own a stock mutual fund with a value of $1,000. For your fund to reach $2,000 in value, it would have to double by growing 100 percent. To increase from $2,000 to $3,000, it would only need to grow by 50 percent. For the first digit to be a 4, it needs to grow by another 33 percent. As Benford’s law predicts, for the leading digit 1 to become 2, there needs to be more growth than for the 3 to become 4, and so on. Because a Benford distribution is a “distribution of distributions,” financial datasets tend to conform, as they result from combining numbers—though exceptions do occur.</p>
<p class="indent">Because people are generally unaware of Benford’s law, they don’t account for it when falsifying numerical records. This gives forensic accountants a powerful tool for quickly identifying datasets that may be fraudulent. In fact, comparisons to Benford’s law are legally admissible as evidence in US criminal cases at the federal, state, and local levels.</p>
<p class="indent">In the 1993 case of <em>State of Arizona v. Nelson</em>, the accused diverted nearly $2 million to bogus vendors in an attempt to defraud the state. Despite taking care to make the fake checks look legitimate, the first-digit distribution clearly violated Benford’s law (<a href="ch16.xhtml#ch16fig4">Figure 16-4</a>), leading to a conviction.</p>
<div class="image"><a id="ch16fig4"/><img src="../images/f0350-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 16-4: Comparison of the frequency of first digits in fraudulent checks to anticipated Benford’s law frequency, State of Arizona v. Wayne James Nelson (CV92-18841)</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_351"/>Benford’s law is also useful for internal business audits. Imagine a case where any travel and entertainment expenses over $10,000 must be approved by the company vice president. This type of financial threshold can tempt employees to do things like split invoices to game the system. <a href="ch16.xhtml#ch16fig5">Figure 16-5</a> is based on a group of expenses ranging from $100 to $12,000, where all values greater than $9,999 were split into two equal halves. As you can guess, there is a spike in first-digit frequencies around 5 and 6, in clear violation of Benford’s law.</p>
<div class="image"><a id="ch16fig5"/><img src="../images/f0351-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 16-5: Splitting invoices over $9,999 for a dataset ranging from $100 to $12,000 violates Benford’s law.</em></p>
<p class="indent">On a grander scale, Benford’s law has revealed irregularities in the financial data—such as revenue numbers—of large corporations. An example from Enron, which practiced institutionalized accounting fraud, is shown in <a href="ch16.xhtml#ch16fig6">Figure 16-6</a>. Enron’s bankruptcy in 2001 was the largest in history at the time, and it resulted in the jailing of several top executives. The scandal also brought about the dissolution of Arthur Andersen, a “Big Five” accounting firm and one of the world’s largest multinational corporations.</p>
<div class="image"><a id="ch16fig6"/><img src="../images/f0351-02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 16-6: Frequency of first digits from Enron’s year 2000 financial data versus anticipated frequency based on Benford’s law (after the</em> Wall Street Journal<em>)</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_352"/>Obviously, Benford’s law works best for fraud detection when the criminals are unaware of it. If you know how the law works, you can fool it, which we’ll do in a practice project at the end of this chapter. As a result, you can use Benford’s law to flag datasets that might be fraudulent, but you can’t use it to prove the opposite.</p>
<h4 class="h4" id="lev380"><strong><em>Performing the Chi-Square Test</em></strong></h4>
<p class="noindent">Auditors and investigators use multiple statistical methods to verify that a dataset obeys Benford’s law. In this project, you’ll use the <em>chi-square goodness-of-fit test</em>, which is a commonly used method for determining whether an empirical (observed) distribution differs significantly from a theoretical (expected) distribution. A significance level, or p<em>-value</em>, is used as the discriminator. The most common significance level is 0.05, but other common ones include 0.01 and 0.10. A significance level of 0.05 indicates a 5 percent risk of erroneously concluding that a difference exists when it doesn’t.</p>
<p class="indent">Here are the steps for performing a chi-square goodness-of-fit test:</p>
<ol>
<li class="noindent"><p class="list">Find the <em>degrees of freedom</em> (<em>df</em>), defined as the number of categories (<em>k</em>) minus 1:</p>
<p class="center"><em>df</em> = <em>k</em> – 1</p>
<p class="indent">For Benford’s law, the categorical levels are the first digits (1–9), so <em>df</em> = 8.</p></li>
<li class="noindent"><p class="list">Calculate the expected frequency count at each level by multiplying the sample size by the theoretical proportions at each level:</p>
<p class="center"><em>E<sub>i</sub></em> = <em>np</em><sub><em>i</em></sub></p>
<p class="noindent">where <em>E</em> is the expected frequency at the <em>i</em>th level, <em>n</em> is the sample size, and <em>p</em> is the theoretical probability at the <em>i</em>th level. For 1,000 samples, the number of samples expected to start with 1 in a Benford’s law distribution would be 1,000 × 0.301 = 301 (see <a href="ch16.xhtml#ch16fig1">Figure 16-1</a>).</p></li>
<li class="noindent"><p class="list">Calculate the chi-square random variable (<em>X</em><sup>2</sup>), also known as the <em>test statistic</em>, which will allow you to judge whether the two distributions are the same:</p>
<div class="imagec"><img src="../images/f0352-01.jpg" alt="image"/></div>
<p class="noindent">where <em>O</em> is the observed frequency count for the <em>i</em>th level of the categorical variable, <em>E</em> is the expected frequency count for the <em>i</em>th level of the categorical variable, and <em>df</em> represents the <em>degrees of freedom</em>.</p></li>
<li class="noindent">Refer to the <em>chi-square distribution table</em> (<a href="ch16.xhtml#ch16tab1">Table 16-1</a>), reading across the row corresponding to the calculated degrees of freedom. If the test statistic is <em>less than</em> the value shown in the <em>p</em>-value column considered significant, then you can’t reject the hypothesis that the observed and theoretical distributions are the same.</li>
</ol>
<p class="tabcap" id="ch16tab1"><span epub:type="pagebreak" id="page_353"/><strong>Table 16-1:</strong> Chi-Square Distribution Table</p>
<table class="topbot-d">
<thead>
<tr>
<td style="vertical-align: middle;" class="table-hb" rowspan="2"><p class="tab_th"><strong>Degrees of<br/>freedom</strong></p></td>
<td style="vertical-align: top;" class="table-h" colspan="9"><p class="tab_th"><strong>Probability of exceeding the critical value</strong></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tabd"><strong>0.99</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tabd"><strong>0.95</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tabd"><strong>0.90</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tabd"><strong>0.75</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tabd"><strong>0.50</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tabd"><strong>0.25</strong></p></td>
<td style="vertical-align: top;" class="table-hb"><p class="tabd"><strong>0.10</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tabd"><strong>0.05</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tabd"><strong>0.01</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-e"><p class="tabd">1</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">0.000</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">0.004</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">0.016</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">0.102</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">0.455</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">1.32</p></td>
<td style="vertical-align: top;" class="table-e"><p class="tabd">2.71</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">3.84</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">6.63</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-e"><p class="tabd">2</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">0.020</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">0.103</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">0.211</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">0.575</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">1.386</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">2.77</p></td>
<td style="vertical-align: top;" class="table-e"><p class="tabd">4.61</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">5.99</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">9.21</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-e"><p class="tabd">3</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">0.115</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">0.352</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">0.584</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">1.212</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">2.366</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">4.11</p></td>
<td style="vertical-align: top;" class="table-e"><p class="tabd">6.25</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">7.81</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">11.34</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-e"><p class="tabd">4</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">0.297</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">0.711</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">1.064</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">1.923</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">3.357</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">5.39</p></td>
<td style="vertical-align: top;" class="table-e"><p class="tabd">7.78</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">9.49</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">13.28</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-e"><p class="tabd">5</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">0.554</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">1.145</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">1.610</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">2.675</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">4.351</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">6.63</p></td>
<td style="vertical-align: top;" class="table-e"><p class="tabd">9.24</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">11.07</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">15.09</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-e"><p class="tabd">6</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">0.872</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">1.635</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">2.204</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">3.455</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">5.348</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">7.84</p></td>
<td style="vertical-align: top;" class="table-e"><p class="tabd">10.64</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">12.59</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">16.81</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-e"><p class="tabd">7</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">1.239</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">2.167</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">2.833</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">4.255</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">6.346</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">9.04</p></td>
<td style="vertical-align: top;" class="table-e"><p class="tabd">12.02</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">14.07</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">18.48</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-e"><p class="tabd">8</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">1.647</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">2.733</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">3.490</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">5.071</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">7.344</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">10.22</p></td>
<td style="vertical-align: top;" class="table-e"><p class="tabd">13.36</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">15.51</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">20.09</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-e"><p class="tabd">9</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">2.088</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">3.325</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">4.168</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">5.899</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">8.343</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">11.39</p></td>
<td style="vertical-align: top;" class="table-e"><p class="tabd">14.68</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">16.92</p></td>
<td style="vertical-align: top;" class="table-b"><p class="tabd">21.67</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ea"><p class="tabd">10</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="tabd">2.558</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="tabd">3.940</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="tabd">4.865</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="tabd">6.737</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="tabd">9.342</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="tabd">12.55</p></td>
<td style="vertical-align: top;" class="table-ea"><p class="tabd">15.99</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="tabd">18.31</p></td>
<td style="vertical-align: top;" class="table-ba"><p class="tabd">23.21</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ea"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-ea" colspan="7"><p class="taba">Not significant</p></td>
<td style="vertical-align: top;" class="table-ba" colspan="2"><p class="taba">Significant</p></td>
</tr>
</tbody>
</table>
<p class="indent">In Table 16-2, the critical value for a <em>p</em>-value of 0.05—at 8 degrees of freedom—is 15.51. If your calculated test statistic is less than 15.51, then the corresponding <em>p</em>-value is greater than 0.05, and you would conclude that there is <em>no statistically significant difference</em> between the observed distribution and the one predicted by Benford’s law. The <em>p</em>-value here is the probability that a test statistic having 8 degrees of freedom is more extreme than 15.51.</p>
<p class="indent">Note that you should perform the chi-square test on <em>counts</em>. If your data is in percentages, averages, ratios, or so on, then you’ll need to convert the values to counts before running the test.</p>
<div class="sidebar">
<p class="sidebart"><strong>THE OBJECTIVE</strong></p>
<p class="spara">Write a Python program that loads numerical data, records the frequency of occurrence of the first digits, compares these to Benford’s law using the chi-square goodness-of-fit test, and presents the comparison in both tabular and graphical form.</p>
</div>
<h3 class="h3" id="lev381"><strong>The Dataset</strong></h3>
<p class="noindent">The 2016 US presidential election was rife with allegations of voter fraud. Most famously, the Russians were accused of supporting Donald Trump, and the Democratic National Committee was accused of favoring Hillary Clinton over Bernie Sanders in that party’s nomination process. President Trump also alleged that 5 to 6 million people voted illegally, and in May 2017, he signed an executive order that launched a commission to review voter fraud and voter suppression.</p>
<p class="indent">For this project, you’ll use a dataset of voting records from the 2016 presidential election. This consists of the final <em>by-county</em> votes for the <span epub:type="pagebreak" id="page_354"/>102 counties in the state of Illinois, which was won by Hillary Clinton. Starting in June 2016, the Illinois Voter Registration System database was the victim of a malicious cyberattack of unknown origin. Illinois election officials confirmed that hackers had accessed thousands of records but apparently didn’t alter any data.</p>
<p class="indent">There were a surprising number of candidates on the Illinois ballot for president, so the dataset has been parsed to include only Hillary Clinton, Donald Trump, Gary Johnson, and Jill Stein. Votes for these candidates have been lumped together in a 408-line text file, with these first 5 lines:</p>
<p class="programs">962<br/>997<br/>1020<br/>1025<br/>1031</p>
<p class="indent">You can find the complete tally of candidates and votes online at <em><a href="https://www.elections.il.gov/ElectionInformation/DownloadVoteTotals.aspx">https://www.elections.il.gov/ElectionInformation/DownloadVoteTotals.aspx</a></em>.</p>
<p class="indent">For this project, you need only the votes, which can be downloaded from <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em> as <em>Illinois_votes.txt</em>. You’ll need to keep this file in the same folder as your Python code.</p>
<h3 class="h3" id="lev382"><strong>The Strategy</strong></h3>
<p class="noindent">Let’s pretend you’re an investigator looking into allegations of voter fraud in the 2016 presidential election and you’ve been assigned the state of Illinois. Before doing a deep dive into the data, you’ll want to flag any obvious anomalies. Benford’s law can’t help you determine whether people are voting illegally, but it’s a good place to start for detecting vote <em>tampering</em>—that is, changing votes after they are cast.</p>
<p class="indent">In cases like this, the ability to communicate the results is every bit as important as the quantitative analysis. Voting commissions don’t just include experts but also many laypeople with limited knowledge of statistics. And juries probably will not include a single expert. To convince yourself—and others—that the vote counts are valid (or not), you’ll want to show multiple comparisons, like a table, a graph, and the quantitative chi-square variable (test statistic).</p>
<p class="indent">The individual steps involved in the analysis lend themselves well to encapsulation in functions. So, instead of pseudocode, let’s look at what functions you may need:</p>
<p class="hang"><span class="codestrong">load_data()</span> Load the data as a list.</p>
<p class="hang"><span class="codestrong">count_first_digits()</span> Tabulate the first digits in each county’s observed vote total.</p>
<p class="hang"><span class="codestrong">get_expected_counts()</span> Determine the counts for each first digit as predicted by Benford.</p>
<p class="hang"><span class="codestrong">chi_square_test()</span> Run a chi-square goodness-of-fit test on the observed versus expected counts.</p>
<p class="hang"><span epub:type="pagebreak" id="page_355"/><span class="codestrong">bar_chart()</span> Generate a bar chart to compare observed first-digit percentages to those expected.</p>
<p class="hang"><span class="codestrong">main()</span> Get the dataset filename, call the functions, and print the statistics.</p>
<h3 class="h3" id="lev383"><strong>The Code</strong></h3>
<p class="noindent">You’ll use the <em>benford.py</em> code in this section to investigate voter fraud, but it’s flexible enough to be used on <em>any</em> dataset where categorical values have been counted, such as medical test results, income tax revenues, or customer refunds. Non-fraud-related applications are also possible, such as detecting process inefficiencies caused by a large number of low-value transactions; problems with data collection and handling, such as missing data, truncated values, or typos; and bias in measurement strategies or surveys, such as favoring best-case or worst-case sampling.</p>
<p class="indent">You can download the code from <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>. You’ll also need the <em>Illinois_votes.txt</em> text file described in “<a href="ch16.xhtml#lev381">The Dataset</a>” on <a href="ch16.xhtml#page_353">page 353</a>.</p>
<h4 class="h4" id="lev384"><strong><em>Importing Modules and Loading Data</em></strong></h4>
<p class="noindent"><a href="ch16.xhtml#ch16list1">Listing 16-1</a> imports modules and defines a function to load data. For this project, you’ll use data in the form of a tab-delimited text file exported from Microsoft Excel, which you load as a list of strings.</p>
<p class="margin"><em>benford.py,</em> part 1</p>
<p class="programs">   import sys<br/>   import math<br/><span class="ent">➊</span> from collections import defaultdict<br/><span class="ent">➋</span> import matplotlib.pyplot as plt<br/><br/>   # Benford's law percentages for leading digits 1-9<br/><span class="ent">➌</span> BENFORD = [30.1, 17.6, 12.5, 9.7, 7.9, 6.7, 5.8, 5.1, 4.6]<br/><br/><span class="ent">➍</span> def load_data(filename):<br/>       """Open a text file &amp; return a list of strings."""<br/>    <span class="ent">➎</span> with open(filename) as f:<br/>           return f.read().strip().split('\n')</p>
<p class="listing" id="ch16list1"><em>Listing 16-1: Imports modules and defines a function for loading data</em></p>
<p class="indent">Most of the imports should be familiar at this point. The <span class="literal">collections</span> module provides specialized alternatives to standard Python containers like sets, tuples, lists, and dictionaries <span class="ent">➊</span>. For counting first-digit frequencies, you’ll need <span class="literal">defaultdict</span>, which is a <span class="literal">dict</span> subclass that calls a factory function to supply missing values. With <span class="literal">defaultdict</span>, you can build a dictionary using a loop, and it will automatically create new keys rather than throwing an error. It returns a dictionary object.</p>
<p class="indent">The final import is for plotting with <span class="literal">matplotlib</span> <span class="ent">➋</span>. For more information on <span class="literal">matplotlib</span> and how to install it, see “<a href="ch10.xhtml#lev226">The Probability-of-Detection Code</a>” on <a href="ch10.xhtml#page_194">page 194</a>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_356"/>Now, assign a variable to a list containing the Benford’s law percentages, ordered from 1 to 9 <span class="ent">➌</span>. Then, define a function to read a text file and return a list <span class="ent">➍</span>. As you’ve done before, use <span class="literal">with</span>, as it will automatically close the file when done <span class="ent">➎</span>.</p>
<h4 class="h4" id="lev385"><strong><em>Counting First Digits</em></strong></h4>
<p class="noindent"><a href="ch16.xhtml#ch16list2">Listing 16-2</a> defines a function to count the first digits and store the results in a dictionary data structure. The final counts, and the frequency of each count as a percentage, are returned as lists to use in subsequent functions. The function will also run quality control on the data.</p>
<p class="margin"><em>benford.py,</em> part 2</p>
<p class="programs"><span class="ent">➊</span> def count_first_digits(data_list):<br/>
       """Count 1st digits in list of numbers; return counts &amp; frequency."""<br/>
    <span class="ent">➋</span> first_digits = defaultdict(int)  # default value of int is 0<br/>
    <span class="ent">➌</span> for sample in data_list:<br/>
        <span class="ent">➍</span> if sample == '':<br/>
               continue<br/>
           try:<br/>
               int(sample)<br/>
           except ValueError as e:<br/>
               print(e, file=sys.stderr)<br/>
               print("Samples must be integers. Exiting", file=sys.stderr)<br/>
               sys.exit(1)<br/>
        <span class="ent">➎</span> first_digits[sample[0]] += 1<br/>
       # check for missing digits<br/>
       keys = [str(digit) for digit in range(1, 10)]<br/>
       for key in keys:<br/>
           if key not in first_digits:<br/>
               first_digits[key] = 0<br/>
    <span class="ent">➏</span> data_count = [v for (k, v) in sorted(first_digits.items())]<br/>
       total_count = sum(data_count)<br/>
       data_pct = [(i / total_count) * 100 for i in data_count]<br/>
    <span class="ent">➐</span> return data_count, data_pct, total_count</p>
<p class="listing" id="ch16list2"><em>Listing 16-2: Defines a function to count first digits and return counts and frequency</em></p>
<p class="indent">The <span class="literal">count_first_digits()</span> function takes the list of strings returned from the <span class="literal">load_data()</span> function as an argument <span class="ent">➊</span>. You’ll call it in <span class="literal">main()</span>.</p>
<p class="indent">Start a dictionary, named <span class="literal">first_digits</span>, using <span class="literal">defaultdict</span> <span class="ent">➋</span>. This step just sets up the dictionary for later population. The first argument for <span class="literal">defaultdict</span> is any callable (with no arguments). In this case, the callable is the type constructor for <span class="literal">int</span>, as you want to count integers. With <span class="literal">defaultdict</span>, whenever an operation encounters a missing key, a function named <span class="literal">default_factory</span> is called with no arguments, and the output is used as the value. Nonexistent keys get the value returned by <span class="literal">default_factory</span>.</p>
<p class="indent">Now start a <span class="literal">for</span> loop and go through the samples in <span class="literal">data_list</span> <span class="ent">➌</span>. If the sample is empty—that is, if the text file contains a blank line <span class="ent">➍</span>—skip it with <span class="literal">continue</span>. Otherwise, use <span class="literal">try</span> to convert the sample to an integer. If an exception occurs, the sample isn’t a proper count value, so let the user know and exit the program. In the following output example, the input file contains a float value (<span class="literal">0.01</span>) and the <span class="literal">main()</span> function prints the filename.</p>
<p class="programs"><span epub:type="pagebreak" id="page_357"/>Name of file with COUNT data: bad_data.txt<br/>invalid literal for int() with base 10: '0.01'<br/>Samples must be integers. Exiting.</p>
<p class="indent">If the sample passes the test, make its first element (leading digit) the dictionary key and add 1 to the value <span class="ent">➎</span>. Because you used <span class="literal">defaultdict</span> with <span class="literal">int</span>, the key is initially assigned a default value of <span class="literal">0</span> on the fly.</p>
<p class="indent">To compare the counts to a Benford’s law distribution, you need the keys listed in numerical order, so use list comprehension and <span class="literal">sorted</span> to make a new version of <span class="literal">first_digits</span>, named <span class="literal">data_count</span> <span class="ent">➏</span>. This will yield the values sorted by key, as shown here:</p>
<p class="programs">[129, 62, 45, 48, 40, 25, 23, 21, 15]</p>
<p class="indent">Next, sum the counts, then make a new list and convert the counts to percentages. End the function by returning these two lists and the summed counts <span class="ent">➐</span>. Because the counts in the lists are sorted from 1 to 9, you don’t need the associated first digit—it is implicit in the ordering.</p>
<h4 class="h4" id="lev386"><strong><em>Getting the Expected Counts</em></strong></h4>
<p class="noindent"><a href="ch16.xhtml#ch16list3">Listing 16-3</a> defines the <span class="literal">get_expected_counts()</span> function that takes the observed data and calculates what the expected counts should be for the leading digits, based on Benford’s law. These expected counts are returned as a list that you’ll use later with the chi-square goodness-of-fit test to see how well the observed data conform to Benford’s law.</p>
<p class="margin"><em>benford.py,</em> part 3</p>
<p class="programs"><span class="ent">➊</span> def get_expected_counts(total_count):<br/>       """Return list of expected Benford's law counts for a total sample count."""<br/>    <span class="ent">➋</span> return [round(p * total_count / 100) for p in BENFORD]</p>
<p class="listing" id="ch16list3"><em>Listing 16-3: Defines a function to calculate expected Benford’s law counts for a dataset</em></p>
<p class="indent">The argument for this function is the summed count that you returned from the <span class="literal">count_first_digits()</span> function in <a href="ch16.xhtml#ch16list2">Listing 16-2</a> <span class="ent">➊</span>. To get the counts you would expect for Benford’s law, you’ll need to use the frequency <em>probability</em> of each digit, so convert the percentages in the <span class="literal">BENFORD</span> list by dividing by 100. Then multiply the <span class="literal">total_count</span> variable by this probability. You can do all this with list comprehension as part of the <span class="literal">return</span> statement <span class="ent">➋</span>.</p>
<h4 class="h4" id="lev387"><strong><em>Determining Goodness of Fit</em></strong></h4>
<p class="noindent"><a href="ch16.xhtml#ch16list4">Listing 16-4</a> defines a function to implement the chi-square test described in “<a href="ch16.xhtml#lev380">Performing the Chi-Square Test</a>” on <a href="ch16.xhtml#page_352">page 352</a>. This test calculates the goodness of fit of the observed counts to the expected counts predicted by Benford’s law. The function will first calculate the chi-square test statistic, then compare it to the chi-square distribution table entry at a <em>p</em>-value of 0.05 for 8 degrees of freedom. Based on the comparison, the function returns either <span class="literal">True</span> or <span class="literal">False</span>.</p>
<p class="margin"><span epub:type="pagebreak" id="page_358"/><em>benford.py,</em> part 4</p>
<p class="programs"><span class="ent">➊</span> def chi_square_test(data_count, expected_counts):<br/>       """Return boolean on chi-square test (8 degrees of freedom &amp; P-val=0.05)."""<br/>    <span class="ent">➋</span> chi_square_stat = 0  # chi-square test statistic<br/>    <span class="ent">➌</span> for data, expected in zip(data_count, expected_counts):<br/>        <span class="ent">➍</span> chi_square = math.pow(data - expected, 2)<br/>           chi_square_stat += chi_square / expected<br/>    <span class="ent">➎</span> print("\nChi Squared Test Statistic = {:.3f}".format(chi_square_stat))<br/>       print("Critical value at a P-value of 0.05 is 15.51.")<br/><br/>    <span class="ent">➏</span> return chi_square_stat &lt; 15.51</p>
<p class="listing" id="ch16list4"><em>Listing 16-4: Defines a function to measure goodness of fit of observed data versus Benford’s law</em></p>
<p class="indent">The chi-square test works on counts, so the function needs the lists of data counts and expected counts that the <span class="literal">count_first_digits()</span> and <span class="literal">get</span><span class="literal">_expected_counts</span><span class="literal">()</span> functions returned <span class="ent">➊</span>. Assign a variable, named <span class="literal">chi_square</span><span class="literal">_stat</span>, to hold the chi-square test statistic, and assign it a value of <span class="literal">0</span> <span class="ent">➋</span>.</p>
<p class="indent">Use <span class="literal">zip</span> to loop through the nine values in <span class="literal">data_count</span> and <span class="literal">expected_counts</span>; <span class="literal">zip</span> will pair the first item in one list with the first item in the second list, and so on <span class="ent">➌</span>. To calculate the chi-square statistic, first subtract the counts for each digit and square the result <span class="ent">➍</span>. Then, divide this value by the expected count for the digit and add the result to the <span class="literal">chi_square_stat</span> variable. Then print the result to three decimal places <span class="ent">➎</span>.</p>
<p class="indent">Return the boolean test for the <span class="literal">chi_square_stat</span> variable versus 15.51, which is the critical value corresponding to a <em>p</em>-value of 0.05 at 8 degrees of freedom (see <a href="ch16.xhtml#ch16tab1">Table 16-1</a>) <span class="ent">➏</span>. If <span class="literal">chi_square_stat</span> is less than this value, the function will return <span class="literal">True</span>; otherwise, it will return <span class="literal">False</span>.</p>
<h4 class="h4" id="lev388"><strong><em>Defining the Bar Chart Function</em></strong></h4>
<p class="noindent"><a href="ch16.xhtml#ch16list5">Listing 16-5</a> defines the first part of a function to display the observed count percentages as a <span class="literal">matplotlib</span> bar chart. You used similar code in <a href="ch12.xhtml#ch12">Chapter 12</a> to graph the outcomes of the retirement nest-egg simulations. This function will also plot the Benford’s law percentages as red dots, so you can visually estimate how well the observed data fit the expected distribution.</p>
<p class="indent">The <span class="literal">matplotlib</span> website contains many code examples for building a wide variety of plots. This code is partly based on the demo example at <em><a href="https://matplotlib.org/examples/api/barchart_demo.html">https://matplotlib.org/examples/api/barchart_demo.html</a></em>.</p>
<p class="margin"><em>benford.py,</em> part 5</p>
<p class="programs"><span class="ent">➊</span> def bar_chart(data_pct):<br/>       """Make bar chart of observed vs expected 1st-digit frequency (%)."""<br/>    <span class="ent">➋</span> fig, ax = plt.subplots()<br/><br/>    <span class="ent">➌</span> index = [i + 1 for i in range(len(data_pct))]  # 1st digits for x-axis<br/><br/>       # text for labels, title, and ticks<br/>    <span class="ent">➍</span> fig.canvas.set_window_title('Percentage First Digits')<br/>    <span class="ent">➎</span> ax.set_title('Data vs. Benford Values', fontsize=15)<br/>    <span class="ent">➏</span> ax.set_ylabel('Frequency (%)', fontsize=16)<br/><span epub:type="pagebreak" id="page_359"/>    <span class="ent">➐</span> ax.set_xticks(index)<br/>       ax.set_xticklabels(index, fontsize=14)</p>
<p class="listing" id="ch16list5"><em>Listing 16-5: Defines the first part of the</em> <span class="codeitalic">bar_chart()</span> <em>function</em></p>
<p class="indent">Define the <span class="literal">bar_chart()</span> function that takes as an argument the list of frequencies—as percentages—of the first digits in the observed data <span class="ent">➊</span>. The <span class="literal">plt.subplots()</span> function returns a tuple of figure and axes objects; unpack this tuple into variables named <span class="literal">fig</span> and <span class="literal">ax</span> <span class="ent">➋</span>.</p>
<p class="indent">Next, use list comprehension to make a list of digits from 1 to 9 <span class="ent">➌</span>. This <span class="literal">index</span> variable will define the x-axis location of each of the nine vertical bars in the chart.</p>
<p class="indent">Set up the plot’s title, labels, and so on. Name the plot <em>window</em> <span class="literal">'Percentage</span> <span class="literal">First Digits'</span> <span class="ent">➍</span>, then display a title <em>within</em> the plot <span class="ent">➎</span>. I am using generic titles, but you can customize these to be more specific. Use the <span class="literal">fontsize</span> keyword argument to set the text size to <span class="literal">15</span>. Note that the window title is an attribute of <span class="literal">fig</span>, but the other labels will be attributes of <span class="literal">ax</span>.</p>
<p class="indent">Use <span class="literal">set_ylabel()</span> to name the y-axis “Frequency (%)” <span class="ent">➏</span>, then set the x-axis tick marks based on the <span class="literal">index</span> variable <span class="ent">➐</span>. The tick labels will be the numbers 1 through 9, so use the index variable again and set the font size to <span class="literal">14</span>.</p>
<h4 class="h4" id="lev389"><strong><em>Completing the Bar Chart Function</em></strong></h4>
<p class="noindent"><a href="ch16.xhtml#ch16list6">Listing 16-6</a> completes the <span class="literal">bar_chart()</span> function by defining the bars, annotating the top of each bar with its frequency value, and plotting the Benford distribution values as red-filled circles.</p>
<p class="margin"><em>benford.py,</em> part 6</p>
<p class="programs">       # build bars<br/>    <span class="ent">➊</span> rects = ax.bar(index, data_pct, width=0.95, color='black', label='Data')<br/><br/>       # attach a text label above each bar displaying its height<br/>    <span class="ent">➋</span> for rect in rects:<br/>        <span class="ent">➌</span> height = rect.get_height()<br/>        <span class="ent">➍</span> ax.text(rect.get_x() + rect.get_width()/2, height,<br/>                   '{:0.1f}'.format(height), ha='center', va='bottom',<br/>                   fontsize=13)<br/><br/>       # plot Benford values as red dots<br/>    <span class="ent">➎</span> ax.scatter(index, BENFORD, s=150, c='red', zorder=2, label='Benford')<br/><br/>       # Hide the right and top spines &amp; add legend<br/>    <span class="ent">➏</span> ax.spines['right'].set_visible(False)<br/>       ax.spines['top'].set_visible(False)<br/>    <span class="ent">➐</span> ax.legend(prop={'size':15}, frameon=False)<br/><br/>    <span class="ent">➑</span> plt.show()</p>
<p class="listing" id="ch16list6"><em>Listing 16-6: Completes the function for generating a bar chart</em></p>
<p class="indent">Name a variable, called <span class="literal">rects</span>, for rectangles, and use it to hold the bars for the bar chart <span class="ent">➊</span>. You generate these with the <span class="literal">bar()</span> method, which returns a container with all the bars. Pass it the index variable and list of <span epub:type="pagebreak" id="page_360"/>frequency counts as percentages, set the width of each bar to 0.95, fill them with black, and set the <span class="literal">label</span> argument to <span class="literal">'Data'</span>. The last parameter is a very handy way to autogenerate a legend. You’ll take advantage of this near the end of the function.</p>
<p class="indent">I’m a fan of plotting the actual bar value just above the bar so you don’t have to squint over at the y-axis and try to guess it. To do this, start by looping through each bar (<span class="literal">rect</span>) in <span class="literal">rects</span> <span class="ent">➋</span> and get its height <span class="ent">➌</span>, which is its y-axis value. Then, call the <span class="literal">ax</span> object’s <span class="literal">text()</span> method <span class="ent">➍</span> and pass it the x-location of the left-hand side of the bar—obtained with the <span class="literal">get_x()</span> method—and add to it half the width of the bar in order to center the label over the bar. Because you use the <span class="literal">get_width()</span> method, you only have to assign the bar width once, which you did in step <span class="ent">➊</span>. Next comes the bar height—formatted to one decimal place—followed by the horizontal and vertical alignments. Set these to the center and the bottom of the text bounding box, respectively. Finish by assigning the text size.</p>
<p class="indent">Now, start building the <span class="literal">matplotlib</span> “markers”—in this case, dots—that will flag the location of the Benford distribution frequencies for each first digit. Do this using the <span class="literal">scatter()</span> method, which builds scatterplots <span class="ent">➎</span>.</p>
<p class="indent">The first two arguments for <span class="literal">scatter()</span> are the x-y locations for each marker, represented by consecutive pairs from the <span class="literal">index</span> and <span class="literal">BENFORD</span> lists. Next is the marker size, set at <span class="literal">150</span>, followed by a color. Both <span class="literal">red</span> and <span class="literal">DodgerBlue</span> work well. You want the markers to post on top of the bars, so set the <span class="literal">zorder</span> to <span class="literal">2</span>. Elements in the figure are referred to as <span class="literal">matplotlib</span> “artists,” and artists with higher <span class="literal">zorder</span> values will plot over those with lower values. Finish with the <span class="literal">label</span> argument used to make a legend.</p>
<p class="indent">The next two statements are for aesthetics. By default, <span class="literal">matplotlib</span> will draw a box around the interior of the plot, and the upper border may interfere with the labels posted at the top of each bar. So, remove the top and right borders by setting their visibility to <span class="literal">False</span> <span class="ent">➏</span>.</p>
<p class="indent">Use <span class="literal">legend()</span> to build a legend for the plot <span class="ent">➐</span>. This will work with no arguments, but set its size attribute to <span class="literal">15</span> and turn off the frame around the legend for an arguably more attractive result. End by calling <span class="literal">plt.show()</span> to display the chart <span class="ent">➑</span>. An example bar chart is shown in <a href="ch16.xhtml#ch16fig7">Figure 16-7</a>.</p>
<div class="image"><a id="ch16fig7"/><img src="../images/f0360-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 16-7: Example output of the</em> <span class="codeitalic">bar_chart()</span> <em>function</em></p>
<p class="indent">In the <span class="literal">main()</span> function, you will display additional information as text in the interpreter window. This will include the value of the chi-square test statistic.</p>
<h4 class="h4" id="lev390"><span epub:type="pagebreak" id="page_361"/><strong><em>Defining and Running the main() Function</em></strong></h4>
<p class="noindent"><a href="ch16.xhtml#ch16list7">Listing 16-7</a> defines the <span class="literal">main()</span> function and runs the program as a module or stand-alone. Since most of the work is done in the individual functions, <span class="literal">main()</span> “mainly” calls these functions and prints some statistics.</p>
<p class="margin"><em>benford.py,</em> part 7</p>
<p class="programs">   def main():<br/>       """Call functions and print stats."""<br/>       # load data<br/>       while True:<br/>        <span class="ent">➊</span> filename = input("\nName of file with COUNT data: ")<br/>           try:<br/>               data_list = load_data(filename)<br/>           except IOError as e:<br/>               print("{}. Try again.".format(e), file=sys.stderr)<br/>           else:<br/>               break<br/>    <span class="ent">➋</span> data_count, data_pct, total_count = count_first_digits(data_list)<br/>    <span class="ent">➌</span> expected_counts = get_expected_counts(total_count)<br/>       print("\nobserved counts = {}".format(data_count))<br/>       print("expected counts = {}".format(expected_counts), "\n")<br/><br/>    <span class="ent">➍</span> print("First Digit Probabilities:")<br/>    <span class="ent">➎</span> for i in range(1, 10):<br/>           print("{}: observed: {:.3f}  expected: {:.3f}".<br/>                 format(i, data_pct[i - 1] / 100, BENFORD[i - 1] / 100))<br/><br/>    <span class="ent">➏</span> if chi_square_test(data_count, expected_counts):<br/>           print("Observed distribution matches expected distribution.")<br/>       else:<br/>           print("Observed distribution does not match expected.",<br/>                 file=sys.stderr)<br/><br/>    <span class="ent">➐</span> bar_chart(data_pct)<br/><br/><span class="ent">➑</span> if __name__ == '__main__':<br/>       main()</p>
<p class="listing" id="ch16list7"><em>Listing 16-7: Defines the</em> <span class="codeitalic">main()</span> <em>function and runs the program as a module or stand-alone</em></p>
<p class="indent">Start by asking the user to input the name of the file with the count data to be analyzed <span class="ent">➊</span>; embed this request in a <span class="literal">while</span> loop that will continue until the user enters a valid filename or closes the window. The user can enter a filename or a full pathname if they want to load a dataset that isn’t stored in the current working directory. For example, in Windows:</p>
<p class="programs">Name of file with COUNT data: <span class="codestrong1">C:\Python35\Benford\Illinois_votes.txt</span></p>
<p class="indent">Use a <span class="literal">try</span> statement to call the <span class="literal">load_data()</span> function you built earlier and pass the function the filename. If the filename is valid, the returned list is assigned to the <span class="literal">data_list</span> variable. If an exception occurs, catch it and print the error. Otherwise, <span class="literal">break</span> from the <span class="literal">while</span> loop.</p>
<p class="indent"><span epub:type="pagebreak" id="page_362"/>Next, pass the returned list of data counts to the <span class="literal">count_first_digits()</span> function and unpack the results as the variables <span class="literal">data_count</span>, <span class="literal">data_pct</span>, and <span class="literal">total_count</span>, which are lists of the first-digit counts, percentages, and total number of counts, respectively <span class="ent">➋</span>. Then, generate a list of the counts expected for a Benford’s law distribution by calling the <span class="literal">get_expected_counts()</span> function and passing it the <span class="literal">total_count</span> variable <span class="ent">➌</span>. Print the lists of observed and expected counts.</p>
<p class="indent">Now, make a table that compares the first-digit frequency in the data with the expected values. Use probabilities, as decimal values are easy to keep attractively aligned in the shell. Start with a header <span class="literal">print</span> statement <span class="ent">➍</span>, then loop through the numbers 1 to 9, printing the results for the observed counts (data), followed by the expected counts, each to three decimal places <span class="ent">➎</span>. Note that the indexes in the two lists start with zero, so you have to subtract 1 from <span class="literal">i</span>.</p>
<p class="indent">Pass the two count lists to the <span class="literal">chi_square_test()</span> function in order to calculate how well the observed data fit the expected distribution <span class="ent">➏</span>. If the function returns <span class="literal">True</span>, use a <span class="literal">print</span> statement to let the user know the observed distribution matches Benford’s law (or, more technically, <em>there is no significant difference</em> between the two). Otherwise, report that they don’t match, and for shell users, color the font red.</p>
<p class="indent">The <span class="literal">chi_square_test()</span> function will display its results in the interpreter window, so call the <span class="literal">bar_chart()</span> function to generate a bar chart <span class="ent">➐</span>. Pass it the list of data counts as percentages.</p>
<p class="indent">Back in the global space, end the program with the code for running it as a module or in stand-alone mode <span class="ent">➑</span>.</p>
<p class="indent">If you run the program on the <em>Illinois_votes.txt</em> dataset, you will see the output shown in <a href="ch16.xhtml#ch16fig8">Figure 16-8</a>. There is no apparent anomaly in the voting results, based on Benford’s law.</p>
<div class="image"><a id="ch16fig8"/><img src="../images/f0362-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 16-8: Output of</em> benford.py <em>for the dataset</em> Illinois_votes.txt</p>
<p class="indent"><span epub:type="pagebreak" id="page_363"/>If you run the program using only the Trump votes, then only the Clinton votes, you get the results shown in <a href="ch16.xhtml#ch16fig9">Figure 16-9</a>. Trump’s distribution, with a test statistic of 15.129, barely passes the chi-square test.</p>
<div class="image"><a id="ch16fig9"/><img src="../images/f0363-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 16-9: Comparison of Trump results (left) versus Clinton results (right) for the state of Illinois</em></p>
<p class="indent">In cases like this, you should be careful about drawing immediate conclusions. The dataset is small—only 102 samples per candidate—and the results may be influenced by things like demographic and voter turnout differences between rural and urban areas. An interesting article on this urban-rural divide can be found at <em><a href="http://www.chicagotribune.com/news/data/ct-illinois-election-urban-rural-divide-2016-htmlstory.html">http://www.chicagotribune.com/news/data/ct-illinois-election-urban-rural-divide-2016-htmlstory.html</a></em>.</p>
<p class="indent">In “<a href="ch16.xhtml#lev393">Practice Project: Beating Benford</a>” on <a href="ch16.xhtml#page_364">page 364</a>, you’ll get a chance to tamper with the Illinois vote counts and alter the outcome. You’ll then use the preceding code to see how well the results conform to Benford’s law.</p>
<h3 class="h3" id="lev391"><strong>Summary</strong></h3>
<p class="noindent">Way back in <a href="ch01.xhtml#ch01">Chapter 1</a>, we used the “<a href="ch01.xhtml#lev28">Poor Man’s Bar Chart</a>” practice project on <a href="ch01.xhtml#page_15">page 15</a> and the “<a href="ch01.xhtml#lev30">Poor Foreign Man’s Bar Chart</a>” challenge project on <a href="ch01.xhtml#page_16">page 16</a> to look at how the frequency of occurrence of letters in a language is both irregular and predictable. This provides a powerful tool for cryptanalysis. Here at the end of the book, we’ve come full circle and found that even numbers share this trait, resulting in a powerful tool for fraud detection. With a short and simple Python program, you can shake the very pillars of heaven and bring the high and mighty crashing down to earth—all because someone noticed that the front pages of a book were dirty.</p>
<p class="indent">Well, that does it for <em>Impractical Python Projects</em>. I hope you had fun, learned something new, and were inspired to create your own set of impractical projects!</p>
<h3 class="h3" id="lev392"><span epub:type="pagebreak" id="page_364"/><strong>Further Reading</strong></h3>
<p class="noindent"><em>Benford’s Law: Applications for Forensic Accounting, Auditing, and Fraud Detection</em> (John Wiley &amp; Sons, 2012) by Mark Nigrini covers the mathematics, theory, and testing of Benford’s law together with example applications, including fraud, tax evasion, and Ponzi schemes.</p>
<h3 class="h3" id="lev393"><strong>Practice Project: Beating Benford</strong></h3>
<p class="noindent">Test your skill at rigging an election using this practice project. You can find a solution, <em>beat_benford_practice.py</em>, in the appendix or download it from <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>.</p>
<p class="indent">A dataset shouldn’t be considered valid just because it follows Benford’s law. The reason is simple: if you know about Benford’s law, then you can beat it.</p>
<p class="indent">To prove this, pretend you’re a high-level hacker for a nefarious foreign government with access to all the voting records in the state of Illinois. Write a Python program that tampers with county-wide votes so that Donald Trump wins the state, but the vote counts still obey Benford’s law. Be careful; Illinois is a “blue” state, so you don’t want to engineer a landslide victory (loosely defined as a 10–15 percentage point advantage in the popular vote). To avoid suspicion, Trump should squeak by with a few percentage points.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>States have rules regarding the recount of votes. Before manipulating an election, a fraudster would want to be aware of these to avoid the scrutiny a recount would bring. The actual statutory rules for each state are no fun to read, but the Citizens for Election Integrity Minnesota provides approachable summaries. The one for Illinois can be found at</em> <a href="https://ceimn.org/searchable-databases/recount-database/illinois/">https://ceimn.org/searchable-databases/recount-database/illinois/</a>.</p>
</div>
<p class="indent">Your program should steal votes from the other candidates, while preserving the by-county totals; that way, the total number of votes cast doesn’t change. As a quality-control step, print out the old and new vote totals by county for Trump and Clinton, as well as their old and new statewide totals. Then, write out a text file that you can input into <em>benford.py</em> so you can check how you did with respect to Benford’s law.</p>
<p class="indent">Datasets for each candidate are already prepared and listed here; you can download them from <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>. Each of these datasets is just a column of numbers, representing votes, that has been sorted alphabetically by county (so don’t change the order!).</p>
<p class="hang"><em>Clinton_votes_Illinois.txt</em></p>
<p class="hang"><em>Johnson_votes_Illinois.txt</em></p>
<p class="hang"><em>Stein_votes_Illinois.txt</em></p>
<p class="hang"><em>Trump_votes_Illinois.txt</em></p>
<p class="indentt"><span epub:type="pagebreak" id="page_365"/><a href="ch16.xhtml#ch16fig10">Figure 16-10</a> shows the results of running <em>benford.py</em> on the output from my attempt, <em>beat_benford_practice.py</em>, which used the preceding datasets. The distribution passes the chi-square test and yields a visually convincing—but plausibly imperfect—fit to the values predicted by Benford’s law.</p>
<div class="image"><a id="ch16fig10"/><img src="../images/f0365-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 16-10: Results of running the distribution from</em> beat_benford_practice.py <em>in</em> benford.py<em>. Mischief managed!</em></p>
<p class="indent">Shown here are a few lines of output from <em>beat_benford_practice.py</em>, with the old and new vote totals by county:</p>
<div class="image"><img src="../images/f0365-02.jpg" alt="image"/></div>
<p class="indent">The third line from the top represents Cook County, which contains Chicago. Note that Clinton still wins here, but by a lower margin. For Trump to win this blue county outright would be a tremendous red flag that vote tampering had occurred, even if he won the whole state by only a small margin!</p>
<h3 class="h3" id="lev394"><span epub:type="pagebreak" id="page_366"/><strong>Challenge Projects</strong></h3>
<p class="noindent">Try your hand at these challenge projects. No solutions are provided.</p>
<h4 class="h4" id="lev395"><strong><em>Benfording the Battlegrounds</em></strong></h4>
<p class="noindent">No candidate needs to cheat in a state they’re guaranteed to win. If you’re an investigator looking into voter fraud, you would most likely start with the battleground states. These could swing either way, and candidates spend much of their war chest—and time—on these places. According to Ballotpedia (<em><a href="https://ballotpedia.org">https://ballotpedia.org</a></em>), Trump’s battleground states in 2016 were Arizona, Iowa, Michigan, Wisconsin, Ohio, Pennsylvania, North Carolina, and Florida. Clinton’s were Colorado, Nevada, New Hampshire, and Virginia.</p>
<p class="indent">The online voting records for states are commonly provided in a number of formats, such as Microsoft Excel spreadsheets. Gather the ones for the battleground states, convert them to text files, and run them through <em>benford.py</em>. To get you started, you can find the Ohio records here: <em><a href="https://www.sos.state.oh.us/elections/">https://www.sos.state.oh.us/elections/</a></em>.</p>
<h4 class="h4" id="lev396"><strong><em>While No One Was Looking</em></strong></h4>
<p class="noindent">Former Speaker of the US House of Representatives Tip O’Neill was famous for saying, “All politics is local.” Take this to heart and use the <em>benford.py</em> program to check out some of your local area races, such as for judges, mayors, county supervisors, sheriffs, and city council members. These events generally attract less scrutiny than do races for Senate seats, governor, or president. If you find an irregularity, make sure the voting dataset is a valid application for Benford’s law before raising a stink!</p>
</body></html>