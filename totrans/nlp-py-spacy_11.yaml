- en: '**11'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DEPLOYING YOUR OWN CHATBOT**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../Images/comm1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In previous chapters, you hardcoded all the input to your NLP scripts by manually
    assigning text to a doc object. But when you build chatbots for tasks like taking
    orders, things get more complicated. You’ll need to deploy your app to a *bot
    channel*, such as Telegram, which facilitates communication between a bot and
    a user.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter begins with an overview of how to organize a chatbot app. You’ll
    be guided through the process of preparing a platform for your chatbot with Telegram
    and then deploying the bot to that platform. You’ll learn how to process multiple
    kinds of user input with the Telegram API and hold the state of a conversation
    to keep track of which questions have already been asked.
  prefs: []
  type: TYPE_NORMAL
- en: '**How Implementing and Deploying a Chatbot Works**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section looks closely at how information is transmitted between a typical
    chatbot and a user, as well as at the structure this transmission needs.
  prefs: []
  type: TYPE_NORMAL
- en: A typical chatbot app consists of multiple tiers. After you’ve implemented the
    logic for processing user input on your machine, you’ll need a messenger app that
    allows you to create accounts that programs operate. Users won’t interact with
    the bot implementation on your machine directly; instead, they’ll chat with the
    bot through the messenger. Apart from a messenger, your chatbot might require
    some additional services, such as a database or other storage.
  prefs: []
  type: TYPE_NORMAL
- en: The diagram in [Figure 11-1](../Text/ch11.xhtml#ch11fig01) represents how a
    typical chatbot application combines these tiers.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/fig11-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: Typical interactions between a user and a bot integrated to a
    messenger*'
  prefs: []
  type: TYPE_NORMAL
- en: The bot application first sends requests to the messenger in an infinite loop,
    checking whether a user has started a conversation. These requests include an
    authentication token generated when the developer created the bot in the messenger.
    An *authentication token* (also called an access token or API key) is unique to
    the bot that allows the messenger to recognize requests coming from this particular
    bot.
  prefs: []
  type: TYPE_NORMAL
- en: When a user sends a message to the bot, the messenger processes it and then
    forwards it to the addressee. The bot chooses an appropriate *handler—*a routine
    that generates responses to a certain type of user messages—and sends the generated
    reply to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The intermediary program that the chatbot uses to interact with users is often
    a bot platform provided by a messenger app, such as Skype, Facebook Messenger,
    or Telegram. From the messenger’s standpoint, the bot is a third-party application
    that runs inside the messenger.
  prefs: []
  type: TYPE_NORMAL
- en: The next section guides you through the process of deploying a chatbot implemented
    in Python to the Telegram’s bot platform. You’ll see some bot implementation details
    that are specific to the Telegram’s bot platform and will learn to use its features
    to make bot development easy.
  prefs: []
  type: TYPE_NORMAL
- en: I chose the Telegram bot platform for this example because it provides comprehensive
    resources for Python developers, including the Python Telegram Bot documentation,
    guides and tutorials, and examples on GitHub. That is, Telegram provides everything
    you need to build a chatbot in Python. In other messaging apps, like Facebook
    Messenger for example, you’d need to use third-party tools, such as Flask or Ngrok,
    complicating a bot’s implementation and not strictly focusing on NLP tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Telegram as a Platform for Your Bot**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Telegram is a cloud-based messenger and one of the top messenger apps in the
    world. Among other features, it provides a platform for creating bots along with
    a Python library that offers an easy-to-use interface. You can use Telegram on
    Android, iOS, Windows, Linux, and macOS platforms. But it’s primarily designed
    for smartphones.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a Telegram Account and Authorizing Your Bot***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before you can create a bot in Telegram, you must sign up for a Telegram account.
    To do so, you’ll need a smartphone or tablet that runs either iOS or Android.
    A PC version of Telegram won’t work for this operation. However, once you create
    a Telegram account, you can use it on a PC.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll find steps that guide you through the process of creating a Telegram
    account at *[https://telegramguide.com/create-a-telegram-account/](https://telegramguide.com/create-a-telegram-account/)*.
    Once you have a Telegram account, you can create a bot. You can do this from either
    a smartphone or a PC, as described in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Telegram app, perform a search for @BotFather or open the URL *[https://telegram.me/botfather/](https://telegram.me/botfather/)*.
    BotFather is a Telegram bot that manages all the other bots in your account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the BotFather page, click the **Start** button to see the list of commands
    that you can use to set up your Telegram bots.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create a new bot, enter the `/newbot` command in the **Write a message**
    box. You’ll be prompted for a name and a username for your bot. Then you’ll be
    given an authorization token for the new bot. [Figure 11-2](../Text/ch11.xhtml#ch11fig02)
    shows a screenshot of this process on a smartphone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../Images/fig11-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: Creating a new bot in Telegram using a smartphone*'
  prefs: []
  type: TYPE_NORMAL
- en: Now you can integrate the bot functionality implemented on your machine in a
    Python file with the bot you just created in Telegram, as discussed in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*It’s important to know that a bot you just created in Telegram doesn’t implement
    the logic for handling user input. In fact, it’s just a wrapper for the actual
    bot you need to implement on your own.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Getting Started with the python-telegram-bot Library***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To connect chatbot functionality implemented in Python, you’ll need the `python-telegram-bot`
    library, which is built on top of the Telegram Bot API. The library provides an
    easy-to-use interface for bot programmers developing apps for Telegram. It allows
    you to focus on coding the bot rather than on the details related to the interactions
    between the messenger and the bot implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `python-telegram-bot` library is free software distributed under an LGPLv3
    license. You can install or upgrade it via `pip` using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The examples provided throughout the rest of this chapter assume that you’re
    using `python-telegram-bot` version 12.0 or later.*'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve installed the library, use the following lines of code to perform
    a quick test to verify that you can access your Telegram bot from Python. You
    must have an internet connection for this test to work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In place of `''XXXXX''`, include the token you were given when creating the
    bot. Then check your credentials using this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If the `bot.get_me()` function returns your credentials, the bot’s authentication
    token you specified previously is valid.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using the telegram.ext Objects***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To build a real bot, you’ll need to use the `telegram.ext` objects, including
    `telegram.ext.Updater` and `telegram.ext.Dispatcher`. These are two of the most
    important objects in the library, because they’re required in every implementation.
    In a nutshell, an `Updater` object receives the messages from Telegram and delivers
    them to a `Dispatcher`. In turn, the `Dispatcher` passes the data to an appropriate
    handler for processing. The following code illustrates how to use these objects
    in a simple echo bot that replies to each message with a message that has the
    same text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We start by importing the `Updater` and `MessageHandler` modules from the `telegram.ext`
    package. Then we define the `echo()` function, which takes two objects as parameters:
    `update` and `context` ➊. The `update` object represents an incoming message,
    which can be text, a photo, a sticker, and so on. The `context` object contains
    attributes that can hold data from the same chat and user. Both `update` and `context`
    are generated for you behind the scenes and passed to the *callback*—a message
    processing function assigned to a certain handler. In this example, the text message
    handler’s callback function is `echo()`; it contains a single line of code that
    instructs Telegram to return a user’s text message without any change.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create an `Updater` object ➋, which we’ll use to orchestrate the bot
    execution process throughout the script. When we create an `Updater` object, a
    `Dispatcher` object is created automatically for us, allowing us to register handlers
    for different types of input data, such as text and photo. In this example, we
    register a single handler designed to handle only text messages, passing it the
    callback function implemented earlier in this script. Now the chatbot will call
    the callback function every time it receives a Telegram message that contains
    text.
  prefs: []
  type: TYPE_NORMAL
- en: Then we start the bot by invoking the `start_polling()` method of the `Updater`,
    which launches the process of polling new messages from the messenger. Because
    `start_polling()` is a non-blocking method, we also have to call the `idle()`
    method of the `Updater`, which blocks our script until a message is received or
    a user enters an exit shortcut (CTRL-C). For further details on the classes and
    methods available in the `python-telegram-bot` library, read the Python Telegram
    Bot’s documentation.
  prefs: []
  type: TYPE_NORMAL
- en: To test the script, run it on an internet-connected machine. Once it’s running,
    any Telegram user can start a conversation with your chatbot. In the Telegram
    app, search for @*<username>*, entering the username you gave your bot when you
    created it; then select it. To start a conversation, click the **/start** button
    or enter the `/start` command. You can then start sending messages to your bot.
    Because you’ve implemented an echo bot, any reply message from the bot should
    contain the same text you sent it.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a Telegram Chatbot That Uses spaCy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the preceding section, we used the `python-telegram-bot` library and built
    a simple script integrated into Telegram. Let’s now enhance our implementation
    and add spaCy to make sure the bot created in Telegram is fully operational.
  prefs: []
  type: TYPE_NORMAL
- en: The following code creates a simple bot that processes a user’s utterance and
    determines whether or not it contains a direct object. Based on that information,
    it generates a reply message for the user. This code isn’t very useful on its
    own, but it should show you how to connect text-processing code implemented with
    spaCy to the code implemented with the `python-``telegram-bot` library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the code responsible for interactions with Telegram is the same
    as in the preceding script. The only difference here is the implementation of
    the callback function ➊. In this case, the `utterance()` function uses spaCy to
    process a user’s input.
  prefs: []
  type: TYPE_NORMAL
- en: In that function, we first extract the message text from the `update` object
    passed to the function. Next, we convert it into a spaCy Doc object and then check
    whether the utterance in the doc includes a direct object. If the utterance doesn’t
    include a direct object, we ask the user to be more specific. For example, a user
    might say “I am hungry,” which implies they want to order some food. But to place
    an order, we need them to be more specific; for example, “I want a pizza.”
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most interesting aspect of this example is that it illustrates where
    utterances that spaCy will process can come from in a bot application. In the
    examples in previous chapters, we used utterances hardcoded in scripts. This is
    the first time you can see how real chatbots obtain their input.
  prefs: []
  type: TYPE_NORMAL
- en: '***Expanding the Chatbot***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you generally know how to integrate a chatbot that uses spaCy into
    Telegram, let’s create a more interesting bot. For example, you might enhance
    the bot’s functionality in the previous section so it extracts the intent from
    a user’s message rather than just printing a message that the request is being
    processed. To accomplish this, you could recycle a script from one of the previous
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the script in “[Recognizing Synonyms Using Predefined Lists](../Text/ch08.xhtml#lev110)”
    on [page 117](../Text/ch08.xhtml#page_117) in [Chapter 8](../Text/ch08.xhtml#ch08),
    which uses lists of synonyms to extract the intent from a submitted utterance.
    Put the code from this script into a separate function, say, `extract_intent()`,
    which should take a single parameter—the text of a user’s message as a Doc object
    (be sure to exclude the line of code with the hardcoded utterance at the beginning
    of the script as well as the line that prints the intent at the end). Additionally,
    the function you’re creating must return a recognized intent as a string. In the
    script you’re creating, place the new function above the callback function and
    revise the callback so it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We call the newly created `extract_intent()` function from within the utterance
    callback to obtain the user’s intent ➊. Then we take an appropriate action, depending
    on the intent obtained. In this example, we simply send the user a relevant message
    ➋.
  prefs: []
  type: TYPE_NORMAL
- en: Although we could put the code from [Chapter 8](../Text/ch08.xhtml#ch08) into
    the callback function directly, doing so would decrease the overall readability
    of the code, so it’s considered bad practice.
  prefs: []
  type: TYPE_NORMAL
- en: '***Holding the State of the Current Chat***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The bot you have now does more than simply evaluate a user’s message; it can
    recognize a user’s intent. Still, this isn’t enough to take orders from users.
    The primary flaw is that the chatbot will use the same utterance callback function
    for each user input, even when the intent has been recognized and it’s time to
    ask the user additional questions.
  prefs: []
  type: TYPE_NORMAL
- en: To address this problem, you need to *hold the state* of the current chat so
    your bot knows what questions have already been answered and what it still has
    to ask. Then you’ll need to modify the callback so it can process user messages
    according to the chat’s current state.
  prefs: []
  type: TYPE_NORMAL
- en: 'This bot could work as follows: if the chatbot hasn’t yet discovered an intent,
    it should ask the user to express it. After finding the intent, the bot should
    switch to another question that is relevant to the conversation’s current state.'
  prefs: []
  type: TYPE_NORMAL
- en: To help you simplify this kind of implementation, the `python-telegram-bot`
    library includes the `ConversationHandler` object; it allows you to define entry
    points and states of the conversation by tying them to a handler.
  prefs: []
  type: TYPE_NORMAL
- en: An entry point—for example, a Telegram command like `/start`—is attached to
    a handler that can trigger the start of a chat. The handler’s callback must return
    the initial state of conversation; this action determines what handler to use
    for the user message that follows. To change the state of conversation, the handler’s
    callback returns a new state after replying to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code includes fragments of a script that illustrates how to change
    the conversation’s state between a chatbot and a user using `ConversationHandler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using `ConversationHandler` lets us define several callback functions and the
    order in which they should be called. A callback processes the user’s message,
    and depending on the processing results, might change the state of the conversation
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the callback for the `/start` command switches the conversation
    to the `ORDERING` state ➊, which means that the next message coming in from the
    user will be processed by the `intent_ext()` function. The reason is that the
    `intent_ext()` function is the callback that belongs to the `ORDERING` state’s
    handler ➌, as defined in the `ConversationHandler` object’s `states` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the chatbot can switch between states based on a conditional logic,
    as illustrated in the `intent_ext()` function: there, the conversation’s state
    will change to `ADD_INFO` (the state in which you collect additional information)
    only if the intent has been recognized ➋.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Putting All the Pieces Together***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you have a cursory understanding of how to structure a Telegram bot
    that follows a predefined conversation flow, let’s look at what a full implementation
    of such a script might look like. This bot needs to ask the user a series of questions,
    one after another, to complete an order form. Because this is a simplified example,
    the chatbot can process only one intent, `orderPizza`, and ask a user to specify
    only the type of pizza when completing the order form.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script is broken into chunks representing each function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `extract_intent()` function extracts the intent from a submitted utterance.
    We’ll call this function from within the `intent_ext()` callback function defined
    next. The code for `extract_intent()` isn’t provided here, but you can use the
    code described earlier in “[Expanding the Chatbot](../Text/ch11.xhtml#lev152)”
    on [page 161](../Text/ch11.xhtml#page_161).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `details_to_str()` function simply converts the content of the `user_data`
    dictionary to a string. The `user_data` dictionary contains information that the
    chatbot will extract from the conversation, such as the kind of pizza and number
    of pizzas the user wants. The bot includes this information in the final message
    sent to the user.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have defined the helper functions that will be invoked—either directly
    or indirectly—from within the bot’s callback functions. Let’s now define the callback
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `start()` function is the callback for the `/start` Telegram command. In
    other words, the chatbot calls this function upon starting a chat. The function
    returns the `ORDERING` state, which means that the next message received will
    be processed by the callback attached to the `ORDERING` state’s handler (the `intent_ext()`
    function in this example).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For simplicity, the `intent_ext()` function used here can recognize only one
    intent: `orderPizza`. If it detects this intent, it returns the `ADD_INFO` state.
    Otherwise, it returns the `ORDERING` state, which will cause the `intent_ext()`
    function to be invoked again to process the next user message. The `ADD_INFO`
    state’s handler can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `add_info()` function is the callback for the `ADD_INFO` state handler.
    In this implementation, it expects that a user ordering pizza will specify the
    type of pizza they want, then switches the state to `ConversationHandler.END`,
    the last state, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `cancel()` function used here simply sends a goodbye message to the user
    and switches the state to `ConversationHandler.END`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `main()` function should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As usual, a bot script’s `main()` function orchestrates the bot execution process.
  prefs: []
  type: TYPE_NORMAL
- en: You can test the script using either the Telegram web app on a computer or the
    Telegram app on a smartphone. [Figure 11-3](../Text/ch11.xhtml#ch11fig03) shows
    a screenshot from the Telegram web app when it’s running the script.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../Images/fig11-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: Testing your bot using the Telegram web app*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Try This***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Modify the script in the preceding section so it can recognize and process more
    intents than just `orderPizza`. Another relevant intent could be `showPizza`,
    meaning the user wants to look at the menu. To implement this, you’ll need to
    modify the `intent_ext()` function, adding an `if intent ==` `'showPizza'` condition
    in the doc processing loop. Also, you’ll need to add a new state to the `states`
    dictionary in the `ConversationHandler` object—say, `SHOW_MENU`—and implement
    the callback for it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how to implement and deploy a simple chatbot app
    using the Telegram bot platform, a popular messenger app. You learned how to define
    and hold states in a conversation. Notably, you also saw an example of where the
    user messages that you’d process with spaCy might actually come from.
  prefs: []
  type: TYPE_NORMAL
