- en: '**11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11'
- en: DEPLOYING YOUR OWN CHATBOT**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 部署你自己的聊天机器人**
- en: '![Image](../Images/comm1.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../Images/comm1.jpg)'
- en: In previous chapters, you hardcoded all the input to your NLP scripts by manually
    assigning text to a doc object. But when you build chatbots for tasks like taking
    orders, things get more complicated. You’ll need to deploy your app to a *bot
    channel*, such as Telegram, which facilitates communication between a bot and
    a user.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，你通过手动将文本分配给文档对象来硬编码所有输入到你的 NLP 脚本中。但当你为类似接受订单这样的任务构建聊天机器人时，事情会变得更复杂。你将需要将应用部署到*机器人频道*，例如
    Telegram，它促进了机器人与用户之间的通信。
- en: This chapter begins with an overview of how to organize a chatbot app. You’ll
    be guided through the process of preparing a platform for your chatbot with Telegram
    and then deploying the bot to that platform. You’ll learn how to process multiple
    kinds of user input with the Telegram API and hold the state of a conversation
    to keep track of which questions have already been asked.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先概述了如何组织一个聊天机器人应用。你将被引导通过在 Telegram 上为你的聊天机器人准备平台并将机器人部署到该平台的过程。你将学习如何使用
    Telegram API 处理多种类型的用户输入，并保持对话状态，以便跟踪已问过的问题。
- en: '**How Implementing and Deploying a Chatbot Works**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实现和部署聊天机器人的工作原理**'
- en: This section looks closely at how information is transmitted between a typical
    chatbot and a user, as well as at the structure this transmission needs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将深入探讨典型聊天机器人与用户之间如何传输信息，以及这种传输所需的结构。
- en: A typical chatbot app consists of multiple tiers. After you’ve implemented the
    logic for processing user input on your machine, you’ll need a messenger app that
    allows you to create accounts that programs operate. Users won’t interact with
    the bot implementation on your machine directly; instead, they’ll chat with the
    bot through the messenger. Apart from a messenger, your chatbot might require
    some additional services, such as a database or other storage.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的聊天机器人应用由多个层次组成。在你完成了处理用户输入的逻辑后，你需要一个允许创建程序账户的消息应用。用户不会直接与机器上的机器人实现交互；相反，他们会通过消息应用与机器人聊天。除了消息应用之外，你的聊天机器人可能还需要一些额外的服务，例如数据库或其他存储。
- en: The diagram in [Figure 11-1](../Text/ch11.xhtml#ch11fig01) represents how a
    typical chatbot application combines these tiers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-1](../Text/ch11.xhtml#ch11fig01)中的示意图展示了典型聊天机器人应用如何结合这些层次。'
- en: '![image](../Images/fig11-1.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig11-1.jpg)'
- en: '*Figure 11-1: Typical interactions between a user and a bot integrated to a
    messenger*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-1：用户与集成到消息应用中的机器人之间的典型交互*'
- en: The bot application first sends requests to the messenger in an infinite loop,
    checking whether a user has started a conversation. These requests include an
    authentication token generated when the developer created the bot in the messenger.
    An *authentication token* (also called an access token or API key) is unique to
    the bot that allows the messenger to recognize requests coming from this particular
    bot.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人应用首先向消息应用发送请求，进入一个无限循环，检查用户是否已经开始对话。这些请求包括开发者在消息应用中创建机器人时生成的身份验证令牌。*身份验证令牌*（也叫访问令牌或
    API 密钥）是唯一的，用于让消息应用识别来自特定机器人的请求。
- en: When a user sends a message to the bot, the messenger processes it and then
    forwards it to the addressee. The bot chooses an appropriate *handler—*a routine
    that generates responses to a certain type of user messages—and sends the generated
    reply to the user.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户向机器人发送消息时，消息应用处理该消息，并将其转发给收件人。机器人选择一个合适的*处理程序*——一个针对特定类型用户消息生成响应的例程——并将生成的回复发送给用户。
- en: The intermediary program that the chatbot uses to interact with users is often
    a bot platform provided by a messenger app, such as Skype, Facebook Messenger,
    or Telegram. From the messenger’s standpoint, the bot is a third-party application
    that runs inside the messenger.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天机器人用来与用户交互的中介程序通常是由消息应用提供的机器人平台，如 Skype、Facebook Messenger 或 Telegram。从消息应用的角度看，机器人是运行在消息应用中的第三方应用。
- en: The next section guides you through the process of deploying a chatbot implemented
    in Python to the Telegram’s bot platform. You’ll see some bot implementation details
    that are specific to the Telegram’s bot platform and will learn to use its features
    to make bot development easy.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将引导你完成将用 Python 实现的聊天机器人部署到 Telegram 机器人平台的过程。你将看到一些特定于 Telegram 机器人平台的实现细节，并学会利用其功能简化机器人开发。
- en: I chose the Telegram bot platform for this example because it provides comprehensive
    resources for Python developers, including the Python Telegram Bot documentation,
    guides and tutorials, and examples on GitHub. That is, Telegram provides everything
    you need to build a chatbot in Python. In other messaging apps, like Facebook
    Messenger for example, you’d need to use third-party tools, such as Flask or Ngrok,
    complicating a bot’s implementation and not strictly focusing on NLP tasks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择 Telegram 机器人平台作为这个示例，因为它为 Python 开发者提供了全面的资源，包括 Python Telegram Bot 文档、指南和教程，以及
    GitHub 上的示例。也就是说，Telegram 提供了您构建 Python 聊天机器人的一切所需资源。在其他消息应用中，例如 Facebook Messenger，您需要使用第三方工具，如
    Flask 或 Ngrok，这样会让机器人的实现变得更复杂，并且无法专注于 NLP 任务。
- en: '**Using Telegram as a Platform for Your Bot**'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**将 Telegram 作为您机器人平台的使用**'
- en: Telegram is a cloud-based messenger and one of the top messenger apps in the
    world. Among other features, it provides a platform for creating bots along with
    a Python library that offers an easy-to-use interface. You can use Telegram on
    Android, iOS, Windows, Linux, and macOS platforms. But it’s primarily designed
    for smartphones.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Telegram 是一个基于云的消息应用，是全球最顶尖的消息应用之一。除了其他功能外，它还提供了一个平台来创建机器人，并且提供了一个易于使用的 Python
    库接口。您可以在 Android、iOS、Windows、Linux 和 macOS 平台上使用 Telegram。但它主要是为智能手机设计的。
- en: '***Creating a Telegram Account and Authorizing Your Bot***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建 Telegram 账户并授权您的机器人***'
- en: Before you can create a bot in Telegram, you must sign up for a Telegram account.
    To do so, you’ll need a smartphone or tablet that runs either iOS or Android.
    A PC version of Telegram won’t work for this operation. However, once you create
    a Telegram account, you can use it on a PC.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以在 Telegram 中创建机器人之前，您必须先注册一个 Telegram 账户。为此，您需要一部运行 iOS 或 Android 系统的智能手机或平板电脑。PC
    版本的 Telegram 不支持此操作。不过，一旦您创建了 Telegram 账户，就可以在 PC 上使用它。
- en: 'You’ll find steps that guide you through the process of creating a Telegram
    account at *[https://telegramguide.com/create-a-telegram-account/](https://telegramguide.com/create-a-telegram-account/)*.
    Once you have a Telegram account, you can create a bot. You can do this from either
    a smartphone or a PC, as described in the following steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 *[https://telegramguide.com/create-a-telegram-account/](https://telegramguide.com/create-a-telegram-account/)*
    找到指导您创建 Telegram 账户的步骤。一旦您拥有了 Telegram 账户，就可以创建一个机器人。您可以通过智能手机或 PC 来完成此操作，具体步骤如下所示：
- en: In the Telegram app, perform a search for @BotFather or open the URL *[https://telegram.me/botfather/](https://telegram.me/botfather/)*.
    BotFather is a Telegram bot that manages all the other bots in your account.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Telegram 应用中，搜索 @BotFather 或打开 URL *[https://telegram.me/botfather/](https://telegram.me/botfather/)*。BotFather
    是一个 Telegram 机器人，用于管理您账户中的所有其他机器人。
- en: On the BotFather page, click the **Start** button to see the list of commands
    that you can use to set up your Telegram bots.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 BotFather 页面，点击**开始**按钮，查看您可以使用的命令列表，以设置您的 Telegram 机器人。
- en: To create a new bot, enter the /newbot command in the **Write a message** box.
    You’ll be prompted for a name and a username for your bot. Then you’ll be given
    an authorization token for the new bot. [Figure 11-2](../Text/ch11.xhtml#ch11fig02)
    shows a screenshot of this process on a smartphone.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新机器人，在**写消息**框中输入 /newbot 命令。系统将提示您为机器人设置一个名称和用户名。然后，您将获得新机器人的授权令牌。[图 11-2](../Text/ch11.xhtml#ch11fig02)展示了在智能手机上进行此过程的截图。
- en: '![image](../Images/fig11-2.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig11-2.jpg)'
- en: '*Figure 11-2: Creating a new bot in Telegram using a smartphone*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-2：在 Telegram 中使用智能手机创建新机器人*'
- en: Now you can integrate the bot functionality implemented on your machine in a
    Python file with the bot you just created in Telegram, as discussed in the next
    section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以将您在机器上实现的机器人功能集成到 Telegram 中刚创建的机器人中，正如下一节所讨论的那样。
- en: '**NOTE**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*It’s important to know that a bot you just created in Telegram doesn’t implement
    the logic for handling user input. In fact, it’s just a wrapper for the actual
    bot you need to implement on your own.*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*需要注意的是，您在 Telegram 中刚创建的机器人并不包含处理用户输入的逻辑。事实上，它只是您需要自己实现的实际机器人的外壳。*'
- en: '***Getting Started with the python-telegram-bot Library***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 python-telegram-bot 库入门***'
- en: To connect chatbot functionality implemented in Python, you’ll need the python-telegram-bot
    library, which is built on top of the Telegram Bot API. The library provides an
    easy-to-use interface for bot programmers developing apps for Telegram. It allows
    you to focus on coding the bot rather than on the details related to the interactions
    between the messenger and the bot implementation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接用 Python 实现的聊天机器人功能，你需要使用 python-telegram-bot 库，该库基于 Telegram Bot API 构建。该库为开发
    Telegram 应用的机器人程序员提供了一个易于使用的接口，使你可以专注于编写机器人的代码，而不必关注与消息传递应用程序和机器人实现之间的交互细节。
- en: 'The python-telegram-bot library is free software distributed under an LGPLv3
    license. You can install or upgrade it via pip using the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: python-telegram-bot 库是一个免费的软件，按照 LGPLv3 许可证分发。你可以通过以下命令使用 pip 安装或升级它：
- en: $ pip install python-telegram-bot --upgrade
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: $ pip install python-telegram-bot --upgrade
- en: '**NOTE**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The examples provided throughout the rest of this chapter assume that you’re
    using python-telegram-bot version 12.0 or later.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章后续提供的示例假设你正在使用 python-telegram-bot 版本 12.0 或更高版本。*'
- en: Once you’ve installed the library, use the following lines of code to perform
    a quick test to verify that you can access your Telegram bot from Python. You
    must have an internet connection for this test to work.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 安装该库后，使用以下代码进行快速测试，验证你是否能够从 Python 访问你的 Telegram 机器人。进行此测试时，你必须有一个互联网连接。
- en: import telegram
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: import telegram
- en: bot = telegram.Bot(token='XXXXXX...')
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: bot = telegram.Bot(token='XXXXXX...')
- en: 'In place of ''XXXXX'', include the token you were given when creating the bot.
    Then check your credentials using this line:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 'XXXXX' 位置，填写在创建机器人时获得的 token。然后使用以下代码检查你的凭证：
- en: print(bot.get_me())
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: print(bot.get_me())
- en: If the bot.get_me() function returns your credentials, the bot’s authentication
    token you specified previously is valid.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 bot.get_me() 函数返回了你的凭证，那么你之前指定的机器人认证 token 是有效的。
- en: '***Using the telegram.ext Objects***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 telegram.ext 对象***'
- en: 'To build a real bot, you’ll need to use the telegram.ext objects, including
    telegram.ext.Updater and telegram.ext.Dispatcher. These are two of the most important
    objects in the library, because they’re required in every implementation. In a
    nutshell, an Updater object receives the messages from Telegram and delivers them
    to a Dispatcher. In turn, the Dispatcher passes the data to an appropriate handler
    for processing. The following code illustrates how to use these objects in a simple
    echo bot that replies to each message with a message that has the same text:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个真正的机器人，你需要使用 telegram.ext 对象，包括 telegram.ext.Updater 和 telegram.ext.Dispatcher。这是库中最重要的两个对象，因为每个实现都需要使用它们。简而言之，Updater
    对象接收来自 Telegram 的消息，并将其传递给 Dispatcher。然后，Dispatcher 将数据传递给适当的处理器进行处理。以下代码演示了如何在一个简单的回声机器人中使用这些对象，该机器人会用相同的文本回复每一条消息：
- en: from telegram.ext import Updater, MessageHandler, Filters
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: from telegram.ext import Updater, MessageHandler, Filters
- en: '#function that implements the message handler'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '#实现消息处理器的函数'
- en: '➊ def echo(update, context):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def echo(update, context):'
- en: update.message.reply_text(update.message.text)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: update.message.reply_text(update.message.text)
- en: '#creating an Updater instance'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '#创建一个 Updater 实例'
- en: ➋ updater = Updater('TOKEN', use_context=True)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ updater = Updater('TOKEN', use_context=True)
- en: '#registering a handler to handle input text messages'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '#注册一个处理器来处理输入的文本消息'
- en: updater.dispatcher.add_handler(MessageHandler(Filters.text, echo))
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: updater.dispatcher.add_handler(MessageHandler(Filters.text, echo))
- en: '#starting polling updates from the messenger'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '#开始从消息传递应用程序轮询更新'
- en: updater.start_polling()
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: updater.start_polling()
- en: updater.idle()
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: updater.idle()
- en: 'We start by importing the Updater and MessageHandler modules from the telegram.ext
    package. Then we define the echo() function, which takes two objects as parameters:
    update and context ➊. The update object represents an incoming message, which
    can be text, a photo, a sticker, and so on. The context object contains attributes
    that can hold data from the same chat and user. Both update and context are generated
    for you behind the scenes and passed to the *callback*—a message processing function
    assigned to a certain handler. In this example, the text message handler’s callback
    function is echo(); it contains a single line of code that instructs Telegram
    to return a user’s text message without any change.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从 telegram.ext 包中导入 Updater 和 MessageHandler 模块。然后定义 echo() 函数，它接受两个对象作为参数：update
    和 context ➊。update 对象代表传入的消息，可以是文本、照片、贴纸等。context 对象包含可以保存来自同一聊天和用户的数据的属性。update
    和 context 都是在后台为你生成的，并传递给 *回调函数*——一个分配给特定处理程序的消息处理函数。在这个例子中，文本消息处理程序的回调函数是 echo()；它包含一行代码，指示
    Telegram 返回用户的文本消息，而不做任何更改。
- en: Next, we create an Updater object ➋, which we’ll use to orchestrate the bot
    execution process throughout the script. When we create an Updater object, a Dispatcher
    object is created automatically for us, allowing us to register handlers for different
    types of input data, such as text and photo. In this example, we register a single
    handler designed to handle only text messages, passing it the callback function
    implemented earlier in this script. Now the chatbot will call the callback function
    every time it receives a Telegram message that contains text.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个 Updater 对象 ➋，我们将使用它来在整个脚本中协调机器人执行过程。当我们创建 Updater 对象时，会自动为我们创建一个
    Dispatcher 对象，允许我们注册不同类型输入数据的处理程序，例如文本和照片。在这个例子中，我们注册了一个只处理文本消息的处理程序，并将之前实现的回调函数传递给它。现在，每次聊天机器人收到包含文本的
    Telegram 消息时，它都会调用回调函数。
- en: Then we start the bot by invoking the start_polling() method of the Updater,
    which launches the process of polling new messages from the messenger. Because
    start_polling() is a non-blocking method, we also have to call the idle() method
    of the Updater, which blocks our script until a message is received or a user
    enters an exit shortcut (CTRL-C). For further details on the classes and methods
    available in the python-telegram-bot library, read the Python Telegram Bot’s documentation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过调用 Updater 的 start_polling() 方法来启动机器人，这个方法会启动从消息传递者拉取新消息的过程。因为 start_polling()
    是一个非阻塞方法，我们还需要调用 Updater 的 idle() 方法，它会阻塞脚本，直到收到消息或用户输入退出快捷键（CTRL-C）。有关 python-telegram-bot
    库中可用的类和方法的更多详细信息，请阅读 Python Telegram Bot 的文档。
- en: To test the script, run it on an internet-connected machine. Once it’s running,
    any Telegram user can start a conversation with your chatbot. In the Telegram
    app, search for @*<username>*, entering the username you gave your bot when you
    created it; then select it. To start a conversation, click the **/start** button
    or enter the /start command. You can then start sending messages to your bot.
    Because you’ve implemented an echo bot, any reply message from the bot should
    contain the same text you sent it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试脚本，将其运行在一台连接到互联网的机器上。一旦它运行，任何 Telegram 用户都可以与你的聊天机器人开始对话。在 Telegram 应用中，搜索
    @*<username>*，输入你在创建机器人时给它的用户名，然后选择它。要开始对话，点击 **/start** 按钮或输入 /start 命令。然后你可以开始向你的机器人发送消息。因为你实现了一个回音机器人，所以机器人回复的任何消息应该包含你发送的相同文本。
- en: '***Creating a Telegram Chatbot That Uses spaCy***'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建一个使用 spaCy 的 Telegram 聊天机器人***'
- en: In the preceding section, we used the python-telegram-bot library and built
    a simple script integrated into Telegram. Let’s now enhance our implementation
    and add spaCy to make sure the bot created in Telegram is fully operational.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一部分中，我们使用了 python-telegram-bot 库，并构建了一个简单的脚本，集成到 Telegram 中。现在让我们增强我们的实现，并加入
    spaCy，以确保在 Telegram 中创建的机器人能够完全正常工作。
- en: The following code creates a simple bot that processes a user’s utterance and
    determines whether or not it contains a direct object. Based on that information,
    it generates a reply message for the user. This code isn’t very useful on its
    own, but it should show you how to connect text-processing code implemented with
    spaCy to the code implemented with the python-telegram-bot library.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个简单的机器人，它处理用户的言论，并判断是否包含直接宾语。根据这些信息，它生成一个回复消息给用户。这个代码本身并没有太大用处，但它应该能展示如何将使用
    spaCy 实现的文本处理代码与使用 python-telegram-bot 库实现的代码连接起来。
- en: import spacy
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: import spacy
- en: from telegram.ext import Updater, MessageHandler, Filters
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: from telegram.ext import Updater, MessageHandler, Filters
- en: '#the callback function that uses spaCy'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '#使用 spaCy 的回调函数'
- en: '➊ def utterance(update, context):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def utterance(update, context):'
- en: msg = update.message.text
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: msg = update.message.text
- en: nlp = spacy.load('en')
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: nlp = spacy.load('en')
- en: doc = nlp(msg)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: doc = nlp(msg)
- en: 'for token in doc:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 'for token in doc:'
- en: 'if token.dep_ == ''dobj'':'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 'if token.dep_ == ''dobj'':'
- en: update.message.reply_text('We are processing your request...')
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: update.message.reply_text('我们正在处理您的请求...')
- en: return
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: update.message.reply_text('Please rephrase your request. Be as specific as
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: update.message.reply_text('请重新表述您的请求。请尽量具体一些。')
- en: possible!')
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: possible!')
- en: '#the code responsible for interactions with Telegram'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '#负责与 Telegram 交互的代码'
- en: updater = Updater('TOKEN', use_context=True)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: updater = Updater('TOKEN', use_context=True)
- en: updater.dispatcher.add_handler(MessageHandler(Filters.text, utterance))
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: updater.dispatcher.add_handler(MessageHandler(Filters.text, utterance))
- en: updater.start_polling()
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: updater.start_polling()
- en: updater.idle()
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: updater.idle()
- en: Notice that the code responsible for interactions with Telegram is the same
    as in the preceding script. The only difference here is the implementation of
    the callback function ➊. In this case, the utterance() function uses spaCy to
    process a user’s input.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，负责与 Telegram 交互的代码与前面的脚本相同。唯一的不同之处在于回调函数 ➊ 的实现。在这种情况下，utterance() 函数使用 spaCy
    来处理用户的输入。
- en: In that function, we first extract the message text from the update object passed
    to the function. Next, we convert it into a spaCy Doc object and then check whether
    the utterance in the doc includes a direct object. If the utterance doesn’t include
    a direct object, we ask the user to be more specific. For example, a user might
    say “I am hungry,” which implies they want to order some food. But to place an
    order, we need them to be more specific; for example, “I want a pizza.”
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在该函数中，我们首先从传递给函数的 update 对象中提取消息文本。接下来，我们将其转换为 spaCy Doc 对象，然后检查该语句中是否包含直接宾语。如果语句中没有直接宾语，我们会请求用户提供更具体的信息。例如，用户可能会说“我饿了”，这意味着他们想订些食物。但要下单，我们需要他们提供更具体的信息；例如，“我想要一个比萨”。
- en: Perhaps the most interesting aspect of this example is that it illustrates where
    utterances that spaCy will process can come from in a bot application. In the
    examples in previous chapters, we used utterances hardcoded in scripts. This is
    the first time you can see how real chatbots obtain their input.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 也许这个例子最有趣的部分在于，它展示了 spaCy 处理的语句可以来自聊天应用程序中的哪里。在前几章的例子中，我们使用的是硬编码在脚本中的语句。这是第一次，您可以看到真实的聊天机器人是如何获取它们的输入的。
- en: '***Expanding the Chatbot***'
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***扩展聊天机器人功能***'
- en: Now that you generally know how to integrate a chatbot that uses spaCy into
    Telegram, let’s create a more interesting bot. For example, you might enhance
    the bot’s functionality in the previous section so it extracts the intent from
    a user’s message rather than just printing a message that the request is being
    processed. To accomplish this, you could recycle a script from one of the previous
    chapters.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您大致了解了如何将一个使用 spaCy 的聊天机器人集成到 Telegram 中，让我们创建一个更有趣的机器人。例如，您可以增强上一节中机器人的功能，使其从用户的消息中提取意图，而不仅仅是打印一个“请求正在处理中”的消息。为此，您可以重复使用前几章中的一个脚本。
- en: 'Go back to the script in “[Recognizing Synonyms Using Predefined Lists](../Text/ch08.xhtml#lev110)”
    on [page 117](../Text/ch08.xhtml#page_117) in [Chapter 8](../Text/ch08.xhtml#ch08),
    which uses lists of synonyms to extract the intent from a submitted utterance.
    Put the code from this script into a separate function, say, extract_intent(),
    which should take a single parameter—the text of a user’s message as a Doc object
    (be sure to exclude the line of code with the hardcoded utterance at the beginning
    of the script as well as the line that prints the intent at the end). Additionally,
    the function you’re creating must return a recognized intent as a string. In the
    script you’re creating, place the new function above the callback function and
    revise the callback so it looks as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到脚本 “[使用预定义列表识别同义词](../Text/ch08.xhtml#lev110)” 中，位于[第117页](../Text/ch08.xhtml#page_117)的[第8章](../Text/ch08.xhtml#ch08)，该脚本使用同义词列表从提交的语句中提取意图。将此脚本中的代码放入一个单独的函数中，比如
    `extract_intent()`，该函数应该接受一个参数——用户消息的文本作为一个 Doc 对象（确保排除脚本开头的硬编码语句以及打印意图的代码行）。此外，您创建的函数必须返回一个被识别的意图作为字符串。在您创建的脚本中，将新函数放置在回调函数之上，并修改回调函数，使其如下所示：
- en: '...'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'def extract_intent(doc):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'def extract_intent(doc):'
- en: '#Put the code from [Chapter 8](../Text/ch08.xhtml#ch08) here'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '#将来自[第8章](../Text/ch08.xhtml#ch08)的代码放在这里'
- en: 'def utterance(update, context):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 'def utterance(update, context):'
- en: msg = update.message.text
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: msg = update.message.text
- en: nlp = spacy.load('en')
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: nlp = spacy.load('en')
- en: doc = nlp(msg)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: doc = nlp(msg)
- en: 'for token in doc:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文档中的每个token：
- en: 'if token.dep_ == ''dobj'':'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 token.dep_ == ''dobj'':'
- en: ➊ intent = extract_intent(doc)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ intent = extract_intent(doc)
- en: '➋ if intent == ''orderPizza'':'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 如果意图是'orderPizza'：
- en: update.message.reply_text('We need some more information to place your
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: update.message.reply_text('我们需要更多的信息才能完成您的订单。')
- en: order.')
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 订单。')
- en: 'elif intent == ''showPizza'':'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif intent == ''showPizza'':'
- en: update.message.reply_text('Would you like to look at our menu?')
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: update.message.reply_text('你想看看我们的菜单吗？')
- en: 'else:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: update.message.reply_text('Your intent is not recognized.')
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: update.message.reply_text('无法识别您的意图。')
- en: return
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: update.message.reply_text('Please rephrase your request. Be as specific as
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: update.message.reply_text('请重新表述您的请求。尽量具体一些。')
- en: possible!')
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的！'
- en: '...'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: We call the newly created extract_intent() function from within the utterance
    callback to obtain the user’s intent ➊. Then we take an appropriate action, depending
    on the intent obtained. In this example, we simply send the user a relevant message
    ➋.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在发言回调函数中调用新创建的 extract_intent() 函数，以获取用户的意图 ➊。然后根据获得的意图采取相应的行动。在这个例子中，我们简单地发送一个相关的消息给用户
    ➋。
- en: Although we could put the code from [Chapter 8](../Text/ch08.xhtml#ch08) into
    the callback function directly, doing so would decrease the overall readability
    of the code, so it’s considered bad practice.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以将[第8章](../Text/ch08.xhtml#ch08)中的代码直接放入回调函数中，但这样做会降低代码的整体可读性，因此被认为是一个不好的实践。
- en: '***Holding the State of the Current Chat***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***保持当前聊天的状态***'
- en: The bot you have now does more than simply evaluate a user’s message; it can
    recognize a user’s intent. Still, this isn’t enough to take orders from users.
    The primary flaw is that the chatbot will use the same utterance callback function
    for each user input, even when the intent has been recognized and it’s time to
    ask the user additional questions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你拥有的机器人不仅仅是评估用户消息；它还能识别用户的意图。不过，这还不足以接收用户的订单。主要的缺陷是即便意图已经被识别，聊天机器人仍会使用相同的发言回调函数处理每个用户输入，而这是时候该询问用户更多问题了。
- en: To address this problem, you need to *hold the state* of the current chat so
    your bot knows what questions have already been answered and what it still has
    to ask. Then you’ll need to modify the callback so it can process user messages
    according to the chat’s current state.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你需要*保持当前聊天的状态*，这样你的机器人才能知道哪些问题已经回答，哪些问题仍然需要问。然后你需要修改回调函数，以便它能够根据聊天的当前状态处理用户消息。
- en: 'This bot could work as follows: if the chatbot hasn’t yet discovered an intent,
    it should ask the user to express it. After finding the intent, the bot should
    switch to another question that is relevant to the conversation’s current state.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个机器人可以这样工作：如果聊天机器人尚未识别意图，它应该要求用户表达意图。在找到意图后，机器人应该切换到与当前对话状态相关的下一个问题。
- en: To help you simplify this kind of implementation, the python-telegram-bot library
    includes the ConversationHandler object; it allows you to define entry points
    and states of the conversation by tying them to a handler.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你简化这种实现，python-telegram-bot 库包括了 ConversationHandler 对象；它允许你通过将入口点和对话的状态与处理程序关联来定义这些入口点和状态。
- en: An entry point—for example, a Telegram command like /start—is attached to a
    handler that can trigger the start of a chat. The handler’s callback must return
    the initial state of conversation; this action determines what handler to use
    for the user message that follows. To change the state of conversation, the handler’s
    callback returns a new state after replying to the user.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 入口点——例如，像/start这样的Telegram命令——会附加到一个处理程序上，触发聊天的开始。处理程序的回调必须返回对话的初始状态；这个操作决定了后续用户消息使用哪个处理程序。为了改变对话的状态，处理程序的回调会在回复用户后返回一个新的状态。
- en: 'The following code includes fragments of a script that illustrates how to change
    the conversation’s state between a chatbot and a user using ConversationHandler:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用 ConversationHandler 在聊天机器人和用户之间改变对话状态：
- en: 'def start(update, context):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 'def start(update, context):'
- en: '...'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: ➊ return 'ORDERING'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ return 'ORDERING'
- en: 'def intent_ext(update, context):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 'def intent_ext(update, context):'
- en: '...'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '➋ if context.user_data.has_key(''intent''):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ 如果 context.user_data.has_key(''intent''):'
- en: return 'ADD_INFO'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: return 'ADD_INFO'
- en: 'else:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: update.message.reply_text('Please rephrase your request.')
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: update.message.reply_text('请重新表述您的请求。')
- en: return 'ORDERING'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: return 'ORDERING'
- en: 'def add_info(update, context):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 'def add_info(update, context):'
- en: '...'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: return ConversationHandler.END
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: return ConversationHandler.END
- en: 'def cancel(update, context):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 'def cancel(update, context):'
- en: '...'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: return ConversationHandler.END
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: return ConversationHandler.END
- en: '...'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'def main():'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '...'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: disp = updater.dispatcher
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: disp = updater.dispatcher
- en: conv_handler = ConversationHandler(
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: conv_handler = ConversationHandler(
- en: entry_points=[CommandHandler('start', start)],
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: entry_points=[CommandHandler('start', start)],
- en: states={
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: states={
- en: '➌ ''ORDERING'': [MessageHandler(Filters.text,'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ ''ORDERING'': [MessageHandler(Filters.text,'
- en: intent_ext)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: intent_ext)
- en: '],'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: '''ADD_INFO'': [MessageHandler(Filters.text,'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '''ADD_INFO'': [MessageHandler(Filters.text,'
- en: add_info)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: add_info)
- en: '],'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: '},'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: fallbacks=[CommandHandler('cancel', cancel)]
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: fallbacks=[CommandHandler('cancel', cancel)]
- en: )
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: disp.add_handler(conv_handler)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: disp.add_handler(conv_handler)
- en: '...'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: Using ConversationHandler lets us define several callback functions and the
    order in which they should be called. A callback processes the user’s message,
    and depending on the processing results, might change the state of the conversation
    flow.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ConversationHandler 允许我们定义多个回调函数，并且指定它们应该被调用的顺序。回调函数处理用户的消息，并根据处理结果，可能会改变对话流的状态。
- en: In this example, the callback for the /start command switches the conversation
    to the ORDERING state ➊, which means that the next message coming in from the
    user will be processed by the intent_ext() function. The reason is that the intent_ext()
    function is the callback that belongs to the ORDERING state’s handler ➌, as defined
    in the ConversationHandler object’s states dictionary.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，/start 命令的回调将对话切换到 ORDERING 状态 ➊，这意味着来自用户的下一条消息将由 intent_ext() 函数处理。原因是，intent_ext()
    函数是属于 ORDERING 状态处理程序 ➌ 的回调函数，正如在 ConversationHandler 对象的 states 字典中所定义的那样。
- en: 'Note that the chatbot can switch between states based on a conditional logic,
    as illustrated in the intent_ext() function: there, the conversation’s state will
    change to ADD_INFO (the state in which you collect additional information) only
    if the intent has been recognized ➋.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，聊天机器人可以根据条件逻辑在状态之间切换，如 intent_ext() 函数中所示：在那里，只有当意图被识别时，才会将对话状态切换到 ADD_INFO（收集附加信息的状态）
    ➋。
- en: '***Putting All the Pieces Together***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将所有部分组合在一起***'
- en: Now that you have a cursory understanding of how to structure a Telegram bot
    that follows a predefined conversation flow, let’s look at what a full implementation
    of such a script might look like. This bot needs to ask the user a series of questions,
    one after another, to complete an order form. Because this is a simplified example,
    the chatbot can process only one intent, orderPizza, and ask a user to specify
    only the type of pizza when completing the order form.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对如何构建一个遵循预定义对话流程的 Telegram 机器人有了初步了解，让我们看看一个完整实现的脚本应该是什么样的。这个机器人需要询问用户一系列问题，逐个进行，以完成一个订单表单。因为这是一个简化的示例，聊天机器人只能处理一个意图——orderPizza，并要求用户在填写订单表单时只指定披萨的类型。
- en: 'The following script is broken into chunks representing each function definition:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本被分为多个块，每个块代表一个函数定义：
- en: import logging
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: import logging
- en: import sys
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: import spacy
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: import spacy
- en: from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, ConversationHandler
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: from telegram.ext import Updater, CommandHandler, MessageHandler, Filters, ConversationHandler
- en: '#allows you to obtain generic debug info'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '# 允许你获取通用的调试信息'
- en: logger = logging.getLogger(__name__)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: logger = logging.getLogger(__name__)
- en: logging.basicConfig(stream=sys.stdout, level=logging.DEBUG)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: logging.basicConfig(stream=sys.stdout, level=logging.DEBUG)
- en: 'def extract_intent(doc):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 'def extract_intent(doc):'
- en: '#Here should be the code created as suggested in the Expanding the Chatbot
    section earlier'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '# 这里应该是早期在“扩展聊天机器人”部分建议的代码'
- en: '...'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: return intent
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: return intent
- en: The extract_intent() function extracts the intent from a submitted utterance.
    We’ll call this function from within the intent_ext() callback function defined
    next. The code for extract_intent() isn’t provided here, but you can use the code
    described earlier in “[Expanding the Chatbot](../Text/ch11.xhtml#lev152)” on [page
    161](../Text/ch11.xhtml#page_161).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: extract_intent() 函数从用户提交的语句中提取意图。我们将在下一个定义的 intent_ext() 回调函数中调用这个函数。extract_intent()
    函数的代码在此未提供，但你可以参考早些时候在 “[扩展聊天机器人](../Text/ch11.xhtml#lev152)” 一节中的代码，见 [第161页](../Text/ch11.xhtml#page_161)。
- en: 'def details_to_str(user_data):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 'def details_to_str(user_data):'
- en: details = list()
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: details = list()
- en: 'for key, value in user_data.items():'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户数据中的每个键值对，使用 `for key, value in user_data.items():`
- en: details.append('{} - {}'.format(key, value))
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: details.append('{} - {}'.format(key, value))
- en: return "\n".join(details).join(['\n', '\n'])
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: return "\n".join(details).join(['\n', '\n'])
- en: The details_to_str() function simply converts the content of the user_data dictionary
    to a string. The user_data dictionary contains information that the chatbot will
    extract from the conversation, such as the kind of pizza and number of pizzas
    the user wants. The bot includes this information in the final message sent to
    the user.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: details_to_str()函数仅仅是将user_data字典的内容转换为字符串。user_data字典包含了聊天机器人从对话中提取的信息，例如用户想要的披萨种类和数量。机器人将在最终发送给用户的消息中包含这些信息。
- en: So far, we have defined the helper functions that will be invoked—either directly
    or indirectly—from within the bot’s callback functions. Let’s now define the callback
    functions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定义了将被调用的辅助函数——这些函数将直接或间接地从机器人的回调函数中被调用。现在让我们定义回调函数。
- en: 'def start(update, context):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 'def start(update, context):'
- en: update.message.reply_text('Hi! This is a pizza ordering app. Do you want to
    order something?')
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: update.message.reply_text('嗨！这是一个披萨订购应用。你想点点什么吗？')
- en: return 'ORDERING'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: return 'ORDERING'
- en: The start() function is the callback for the /start Telegram command. In other
    words, the chatbot calls this function upon starting a chat. The function returns
    the ORDERING state, which means that the next message received will be processed
    by the callback attached to the ORDERING state’s handler (the intent_ext() function
    in this example).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: start()函数是/start Telegram命令的回调函数。换句话说，聊天机器人在开始聊天时会调用此函数。该函数返回ORDERING状态，这意味着接收到的下一条消息将由附加到ORDERING状态处理器的回调函数（在本示例中是intent_ext()函数）处理。
- en: 'def intent_ext(update, context):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 'def intent_ext(update, context):'
- en: msg = update.message.text
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: msg = update.message.text
- en: nlp = spacy.load('en')
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: nlp = spacy.load('en')
- en: doc = nlp(msg)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: doc = nlp(msg)
- en: 'for token in doc:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 'for token in doc:'
- en: 'if token.dep_ == ''dobj'':'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 'if token.dep_ == ''dobj'':'
- en: intent = extract_intent(doc)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: intent = extract_intent(doc)
- en: 'if intent == ''orderPizza'':'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 'if intent == ''orderPizza'':'
- en: context.user_data['product'] = 'pizza'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: context.user_data['product'] = 'pizza'
- en: update.message.reply_text('We need some more information to place your order.
    What type
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: update.message.reply_text('我们需要更多的信息来完成您的订单。请问您想要什么类型的披萨？')
- en: of pizza do you want?')
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要多少个披萨？')
- en: return 'ADD_INFO'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: return 'ADD_INFO'
- en: 'else:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: update.message.reply_text('Your intent is not recognized. Please rephrase your
    request.')
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: update.message.reply_text('无法识别您的意图。请重新表述您的请求。')
- en: return 'ORDERING'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: return 'ORDERING'
- en: return
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: return
- en: update.message.reply_text('Please rephrase your request. Be as specific as possible!')
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: update.message.reply_text('请重新表述您的请求。尽量具体一些！')
- en: 'For simplicity, the intent_ext() function used here can recognize only one
    intent: orderPizza. If it detects this intent, it returns the ADD_INFO state.
    Otherwise, it returns the ORDERING state, which will cause the intent_ext() function
    to be invoked again to process the next user message. The ADD_INFO state’s handler
    can be implemented as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，intent_ext()函数在这里仅能识别一个意图：orderPizza。如果它检测到该意图，则返回ADD_INFO状态。否则，它返回ORDERING状态，这将导致intent_ext()函数再次被调用以处理下一个用户消息。ADD_INFO状态的处理器可以如下实现：
- en: 'def add_info(update, context):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 'def add_info(update, context):'
- en: msg = update.message.text
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: msg = update.message.text
- en: nlp = spacy.load('en')
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: nlp = spacy.load('en')
- en: doc = nlp(msg)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: doc = nlp(msg)
- en: 'for token in doc:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'for token in doc:'
- en: 'if token.dep_ == ''dobj'':'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 'if token.dep_ == ''dobj'':'
- en: dobj = token
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: dobj = token
- en: 'for child in dobj.lefts:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 'for child in dobj.lefts:'
- en: 'if child.dep_ == ''amod'' or child.dep_ == ''compound'':'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 'if child.dep_ == ''amod'' or child.dep_ == ''compound'':'
- en: context.user_data['type'] = child.text
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: context.user_data['type'] = child.text
- en: user_data = context.user_data
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: user_data = context.user_data
- en: update.message.reply_text("Your order has been placed."
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: update.message.reply_text("您的订单已提交。")
- en: '"{}"'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '"{}"'
- en: '"Have a nice day!".format(details_to_str(user_data)))'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '"祝你有个愉快的一天！".format(details_to_str(user_data)))'
- en: return ConversationHandler.END
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: return ConversationHandler.END
- en: update.message.reply_text("Cannot extract necessary info. Please try again.")
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: update.message.reply_text("无法提取必要的信息。请再试一次。")
- en: return 'ADD_INFO'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: return 'ADD_INFO'
- en: 'The add_info() function is the callback for the ADD_INFO state handler. In
    this implementation, it expects that a user ordering pizza will specify the type
    of pizza they want, then switches the state to ConversationHandler.END, the last
    state, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: add_info()函数是ADD_INFO状态处理器的回调函数。在这个实现中，它期望用户在点披萨时会指定他们想要的披萨类型，然后将状态切换到ConversationHandler.END，即最后一个状态，具体如下：
- en: 'def cancel(update, context):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'def cancel(update, context):'
- en: update.message.reply_text("Have a nice day!")
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: update.message.reply_text("祝你有个愉快的一天！")
- en: return ConversationHandler.END
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: return ConversationHandler.END
- en: The cancel() function used here simply sends a goodbye message to the user and
    switches the state to ConversationHandler.END.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的cancel()函数仅仅是向用户发送一条告别消息，并将状态切换到ConversationHandler.END。
- en: 'Finally, the main() function should look like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，main() 函数应如下所示：
- en: 'def main():'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '#Replace TOKEN with a real token'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '#将 TOKEN 替换为实际的令牌'
- en: updater = Updater("TOKEN", use_context=True)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: updater = Updater("TOKEN", use_context=True)
- en: disp = updater.dispatcher
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: disp = updater.dispatcher
- en: conv_handler = ConversationHandler(
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: conv_handler = ConversationHandler(
- en: entry_points=[CommandHandler('start', start)],
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: entry_points=[CommandHandler('start', start)],
- en: states={
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: states={
- en: '''ORDERING'': [MessageHandler(Filters.text,'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '''ORDERING'': [MessageHandler(Filters.text,'
- en: intent_ext)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: intent_ext)
- en: '],'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: '''ADD_INFO'': [MessageHandler(Filters.text,'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '''ADD_INFO'': [MessageHandler(Filters.text,'
- en: add_info)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: add_info)
- en: '],'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: '},'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: fallbacks=[CommandHandler('cancel', cancel)]
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: fallbacks=[CommandHandler('cancel', cancel)]
- en: )
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: disp.add_handler(conv_handler)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: disp.add_handler(conv_handler)
- en: updater.start_polling()
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: updater.start_polling()
- en: updater.idle()
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: updater.idle()
- en: 'if __name__ == ''__main__'':'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: main()
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: As usual, a bot script’s main() function orchestrates the bot execution process.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，机器人脚本的 main() 函数负责协调机器人的执行过程。
- en: You can test the script using either the Telegram web app on a computer or the
    Telegram app on a smartphone. [Figure 11-3](../Text/ch11.xhtml#ch11fig03) shows
    a screenshot from the Telegram web app when it’s running the script.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过计算机上的 Telegram 网页应用或智能手机上的 Telegram 应用来测试该脚本。[图 11-3](../Text/ch11.xhtml#ch11fig03)
    显示了运行脚本时，Telegram 网页应用的屏幕截图。
- en: '![image](../Images/fig11-3.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/fig11-3.jpg)'
- en: '*Figure 11-3: Testing your bot using the Telegram web app*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-3：使用 Telegram 网页应用测试你的机器人*'
- en: '***Try This***'
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***试试这个***'
- en: Modify the script in the preceding section so it can recognize and process more
    intents than just orderPizza. Another relevant intent could be showPizza, meaning
    the user wants to look at the menu. To implement this, you’ll need to modify the
    intent_ext() function, adding an if intent == 'showPizza' condition in the doc
    processing loop. Also, you’ll need to add a new state to the states dictionary
    in the ConversationHandler object—say, SHOW_MENU—and implement the callback for
    it.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 修改前面的脚本，使其能够识别和处理比 orderPizza 更多的意图。另一个相关的意图可以是 showPizza，表示用户想查看菜单。为了实现这一点，你需要修改
    intent_ext() 函数，在文档处理循环中添加 `if intent == 'showPizza'` 条件。同时，你还需要在 ConversationHandler
    对象的 states 字典中添加一个新状态——比如 SHOW_MENU——并为其实现回调函数。
- en: '**Summary**'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you learned how to implement and deploy a simple chatbot app
    using the Telegram bot platform, a popular messenger app. You learned how to define
    and hold states in a conversation. Notably, you also saw an example of where the
    user messages that you’d process with spaCy might actually come from.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用 Telegram 机器人平台（一个流行的消息应用）实现和部署一个简单的聊天机器人应用。你学会了如何定义和保持对话中的状态。特别地，你还看到了一个例子，其中用户消息的处理方式，可能来自你使用
    spaCy 处理的地方。
