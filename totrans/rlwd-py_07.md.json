["```py\nsite_selector.py, part 1\nimport tkinter as tk\nfrom PIL import Image, ImageTk\nimport numpy as np\nimport cv2 as cv\n\n# CONSTANTS: User Input:\nIMG_GRAY = cv.imread('mola_1024x501.png', cv.IMREAD_GRAYSCALE)\nIMG_COLOR = cv.imread('mola_color_1024x506.png')\nRECT_WIDTH_KM = 670  \nRECT_HT_KM = 335  \nMAX_ELEV_LIMIT = 55  \nNUM_CANDIDATES = 20  \nMARS_CIRCUM = 21344\n```", "```py\nsite_selector.py, part 2\n   # CONSTANTS: Derived:\n   IMG_HT, IMG_WIDTH = IMG_GRAY.shape\n   PIXELS_PER_KM = IMG_WIDTH / MARS_CIRCUM\n   RECT_WIDTH = int(PIXELS_PER_KM * RECT_WIDTH_KM)\n   RECT_HT = int(PIXELS_PER_KM * RECT_HT_KM)\n➊ LAT_30_N = int(IMG_HT / 3)\n   LAT_30_S = LAT_30_N * 2\n   STEP_X = int(RECT_WIDTH / 2)\n   STEP_Y = int(RECT_HT / 2)\n\n➋ screen = tk.Tk()\n   canvas = tk.Canvas(screen, width=IMG_WIDTH, height=IMG_HT + 130)\n```", "```py\nsite_selector.py, part 3\nclass Search():\n    \"\"\"Read image and identify landing rectangles based on input criteria.\"\"\" \n\n   def __init__(self, name):\n       self.name = name\n    ➊ self.rect_coords = {}\n       self.rect_means = {}\n       self.rect_ptps = {}\n       self.rect_stds = {}\n    ➋ self.ptp_filtered = []\n       self.std_filtered = []\n       self.high_graded_rects = []\n```", "```py\nsite_selector.py, part 4\ndef run_rect_stats(self):\n    \"\"\"Define rectangular search areas and calculate internal stats.\"\"\"\n    ul_x, ul_y = 0, LAT_30_N\n    lr_x, lr_y = RECT_WIDTH, LAT_30_N + RECT_HT\n    rect_num = 1\n\n    while True:\n     ➊ rect_img = IMG_GRAY[ul_y : lr_y, ul_x : lr_x]\n        self.rect_coords[rect_num] = [ul_x, ul_y, lr_x, lr_y]\n        if np.mean(rect_img) <= MAX_ELEV_LIMIT:\n            self.rect_means[rect_num] = np.mean(rect_img)\n            self.rect_ptps[rect_num] = np.ptp(rect_img)\n            self.rect_stds[rect_num] = np.std(rect_img)\n        rect_num += 1\n\n        ul_x += STEP_X\n        lr_x = ul_x + RECT_WIDTH\n      ➋ if lr_x > IMG_WIDTH:\n            ul_x = 0\n            ul_y += STEP_Y\n            lr_x = RECT_WIDTH\n            lr_y += STEP_Y\n      ➌ if lr_y > LAT_30_S + STEP_Y:\n            break\n```", "```py\nsite_selector.py, part 5\ndef draw_qc_rects(self):\n        \"\"\"Draw overlapping search rectangles on image as a check.\"\"\"\n        img_copy = IMG_GRAY.copy()\n        rects_sorted = sorted(self.rect_coords.items(), key=lambda x: x[0])\n        print(\"\\nRect Number and Corner Coordinates (ul_x, ul_y, lr_x, lr_y):\")\n        for k, v in rects_sorted:\n            print(\"rect: {}, coords: {}\".format(k, v))\n            cv.rectangle(img_copy,\n                         (self.rect_coords[k][0], self.rect_coords[k][1]),\n                         (self.rect_coords[k][2], self.rect_coords[k][3]),\n                         (255, 0, 0), 1)\n        cv.imshow('QC Rects {}'.format(self.name), img_copy)\n        cv.waitKey(3000)\n        cv.destroyAllWindows()\n```", "```py\nRect Number and Corner Coordinates (ul_x, ul_y, lr_x, lr_y):\nrect: 1, coords: [0, 167, 32, 183]\nrect: 2, coords: [16, 167, 48, 183]\n\n--snip--\n\nrect: 1259, coords: [976, 319, 1008, 335]\nrect: 1260, coords: [992, 319, 1024, 335]\n```", "```py\nsite_selector.py, part 6\ndef sort_stats(self): \n    \"\"\"Sort dictionaries by values and create lists of top N keys.\"\"\"\n    ptp_sorted = (sorted(self.rect_ptps.items(), key=lambda x: x[1]))\n    self.ptp_filtered = [x[0] for x in ptp_sorted[:NUM_CANDIDATES]]\n    std_sorted = (sorted(self.rect_stds.items(), key=lambda x: x[1]))\n    self.std_filtered = [x[0] for x in std_sorted[:NUM_CANDIDATES]]    \n    for rect in self.std_filtered:\n        if rect in self.ptp_filtered:\n            self.high_graded_rects.append(rect)\n```", "```py\nsite_selector.py, part 7 \ndef draw_filtered_rects(self, image, filtered_rect_list):\n    \"\"\"Draw rectangles in list on image and return image.\"\"\"\n    img_copy = image.copy()\n    for k in filtered_rect_list: \n        cv.rectangle(img_copy,\n                     (self.rect_coords[k][0], self.rect_coords[k][1]),\n                     (self.rect_coords[k][2], self.rect_coords[k][3]),\n                     (255, 0, 0), 1)\n        cv.putText(img_copy, str(k),\n                   (self.rect_coords[k][0] + 1, self.rect_coords[k][3]- 1),\n                   cv.FONT_HERSHEY_PLAIN, 0.65, (255, 0, 0), 1)\n\n ➊ cv.putText(img_copy, '30 N', (10, LAT_30_N - 7),\n               cv.FONT_HERSHEY_PLAIN, 1, 255)\n    cv.line(img_copy, (0, LAT_30_N), (IMG_WIDTH, LAT_30_N),\n            (255, 0, 0), 1)\n    cv.line(img_copy, (0, LAT_30_S), (IMG_WIDTH, LAT_30_S),\n            (255, 0, 0), 1)\n    cv.putText(img_copy, '30 S', (10, LAT_30_S + 16),\n               cv.FONT_HERSHEY_PLAIN, 1, 255)\n\n    return img_copy\n```", "```py\nsite_selector.py, part 8\ndef make_final_display(self):\n    \"\"\"Use Tk to show map of final rects & printout of their statistics.\"\"\"\n    screen.title('Sites by MOLA Gray STD & PTP {} Rect'.format(self.name))\n\n    img_color_rects = self.draw_filtered_rects(IMG_COLOR,\n                                               self.high_graded_rects)\n\n ➊ img_converted = cv.cvtColor(img_color_rects, cv.COLOR_BGR2RGB)\n    img_converted = ImageTk.PhotoImage(Image.fromarray(img_converted)) \n    canvas.create_image(0, 0, image=img_converted, anchor=tk.NW)\n\n ➋ txt_x = 5\n    txt_y = IMG_HT + 20\n    for k in self.high_graded_rects:\n        canvas.create_text(txt_x, txt_y, anchor='w', font=None,\n                           text=\"rect={} mean elev={:.1f} std={:.2f} ptp={}\"\n                           .format(k, self.rect_means[k], self.rect_stds[k],\n                                   self.rect_ptps[k]))\n        txt_y += 15\n     ➌ if txt_y >= int(canvas.cget('height')) - 10:\n            txt_x += 300\n            txt_y = IMG_HT + 20        \n    canvas.pack()\n    screen.mainloop()\n```", "```py\nsite_selector.py, part 9\n   def main():\n       app = Search('670x335 km')\n       app.run_rect_stats()\n       app.draw_qc_rects()\n       app.sort_stats()\n       ptp_img = app.draw_filtered_rects(IMG_GRAY, app.ptp_filtered)\n       std_img = app.draw_filtered_rects(IMG_GRAY, app.std_filtered)\n\n    ➊ cv.imshow('Sorted by ptp for {} rect'.format(app.name), ptp_img)\n       cv.waitKey(3000)\n       cv.imshow('Sorted by std for {} rect'.format(app.name), std_img)\n       cv.waitKey(3000)\n\n       app.make_final_display()  # Includes call to mainloop().\n\n➋ if __name__ == '__main__':\n      main()\n```"]