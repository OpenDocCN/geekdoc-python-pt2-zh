- en: '**2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: USING PYTHON**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you’re already familiar with Python, you can skip this chapter. This summary
    is for those who are comfortable with programming but who aren’t familiar with
    Python. We’ll cover only enough of the language to be able to read and understand
    the code examples in this book. If you have little to no experience with computer
    programming, you should first read a more complete text like *Python Crash Course*,
    2nd Edition, by Eric Matthes (No Starch Press, 2019).
  prefs: []
  type: TYPE_NORMAL
- en: Python is, at its simplest, sequential statements grouped into blocks via indentation;
    data structures like numbers, strings, tuples, lists, and dictionaries; control
    structures including `if-elif-else`, for loops, while loops, with statements,
    and try-except blocks; functions with optional nested functions; and a large library
    of importable modules. We’ll cover each of these features.
  prefs: []
  type: TYPE_NORMAL
- en: The Python Interpreter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On a Linux system, Python is typically used in one of two ways. You can run
    the Python interpreter from the command line and enter commands interactively,
    or you can run a script of Python commands. Simply enter `python3` in your console
    to use Python interactively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Python opens a prompt for you to enter commands into, beginning
    with `>>>`. Type an expression like `1+2` and hit `ENTER`. Python will respond
    immediately by evaluating the equation and passing you the result. When you want
    to exit the console, use `CTRL`-D.
  prefs: []
  type: TYPE_NORMAL
- en: Statements and Whitespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As in almost every other programming language, unless modified by a control
    flow structure, statements in Python are executed one after the other in the order
    in which they appear in the code. Consider, for example, this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here `statement1` will be executed first, followed by `statement2`, and then,
    finally, `statement3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple statements can be grouped into units called *blocks*. For example,
    the condition of an `if` statement evaluating to `True` could trigger a block
    to run. Syntactically, the statements that go with the `if` need to be marked
    in some way so that the computer knows which statements to execute. Classic languages
    like Pascal used bulky `BEGIN` and `END` keywords. The C family of languages,
    which includes most of the languages in current widespread use, uses curly brackets:
    “{" and “}".'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, we use indentation. This makes reading Python code somewhat elegant
    as it follows the format of a traditional outline. It also makes the code more
    visually consistent across authors and leaves less room for confusion. In Python,
    when we use an `if else` statement, we can easily see which statements should
    run with which part of the condition, even if we have not yet understood the format
    of the `if` statement. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The indentation makes it clear that `statement1` and `statement2` are executed
    when `condition1` (whatever it is) is true. Similarly, we see that `statement3`
    is executed when `condition1` is not true.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the colons in the preceding `if` example. Python uses these to designate
    blocks of code. You must place a colon after any control statement, and then the
    next line should always be indented one level. If you try to use a control structure
    but don’t provide any statements in the body of the control structure, Python
    will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `else:` clause cannot be present without at least one statement
    in the block. If there is no need for the `else`, just don’t include it. (If you
    really want to include it, use the `pass` keyword to indicate to Python that you
    know a statement needs to be there, but you really don’t want that condition to
    do anything.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Indentation can seem intimidating to people new to Python, but you can make
    it easier on yourself by properly configuring your text editor. Python convention
    says that you should tell your text editor to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Insert spaces in place of tab characters. Shun tab characters like the plague.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert four spaces every time you hit the T A B key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Automatically indent when you hit the E N T E R key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With these settings, when you enter the “:” of a control statement, just hit
    ENTER, and Python will indent the block automatically.
  prefs: []
  type: TYPE_NORMAL
- en: The way to configure these settings depends on the text editor used, of course,
    but any text editor worth its salt will be able to do all of these, and many have
    automatic indentation set as standard. If you use integrated development environments
    (IDEs), then it’s probable that once the IDE recognizes that you’re coding in
    Python, most of these conventions will just happen.
  prefs: []
  type: TYPE_NORMAL
- en: Variables and Basic Data Structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python’s native data structures are simple and elegant. In this section, we’ll
    cover number representation, variables, strings, lists, and dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Representing Numbers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Numbers in Python are of two kinds: integers or floating-point. *Integers*
    are whole numbers like 42 and 66\. *Floating-point numbers* are those with a decimal
    point like 3.1415 and 2.718\. We’ll ignore complex numbers in this book, although
    Python supports them.'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t include a decimal point, Python will assume you mean an integer;
    otherwise, it will use floating-point numbers. Floating-point numbers can also
    be specified using scientific notation, where `6.022e23` means 6.023 × 10^(23).
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages can represent only numbers in a certain range, but
    Python does not have this restriction for integers, which can be as large as there
    is memory to hold them. For fun, enter **`2**2001`** and see what happens. The
    many ways in which computers store and operate on numbers is quite fascinating.
    Those who are curious might want to look further.^([1](ch02.xhtml#ch02fn1))
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Variables* provide a useful place to store data for reuse. Fortunately, using
    Python variables is straightforward. Python is *dynamically typed*, which means
    we don’t need to declare the type of data a variable will store in advance. We
    simply assign data to a variable, and Python figures out the type for us.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even change the type of data stored in a variable by assigning a new
    value, regardless of its type. For example, all of these are valid assignments
    in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The code assigns integer 123 to `v` ❶, the floating-point value 3.141592 to
    `n` ❷, and then reassigns a floating-point value to `v`: 6.022 × 10^(23) ❸.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python variable names are case-sensitive, must start with a letter, and can
    include letters, numbers, and “_” (underscore) characters. Many Python programmers
    follow the camel-case convention of Java, shown here, but this is not strictly
    required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Python supports textual data with strings. You mark the beginning and end of
    *strings* with quotes, either single (’), double (’’), or triple (’’’), as long
    as you use the same for both opening and closing. The triple-quoted string is
    special: it can span multiple lines of text, and you would often use it immediately
    after defining a function to implement a simple documentation string. All of these
    are valid Python strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, `thing1` is a simple string; `thing2` is also a simple string, but note
    that it has a single quote embedded in it to act as an apostrophe. We can do this
    because we started the string with a double quote character; if we wanted to use
    double quotes inside the string, then we would have to enclose it with single
    quotes.
  prefs: []
  type: TYPE_NORMAL
- en: The last string, `thing3`, spans multiple lines. The newline characters typed
    to move from `one` to `two` are also part of the string, and when printed, they
    will be shown. Note, if you actually enter the assignment to `thing3` in the Python
    interpreter, you will see that the interpreter inserts an ellipsis (`...`). We
    ignored those in the example as they would be confusing and are not really part
    of the string.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Strings and numbers are *primitive data types*, meaning they are not made up
    of grouped collections of data. Think of them as atoms. They can be combined into
    more sophisticated data structures by using tuples and lists. A *list* is an ordered
    collection of other data, which could be primitive data or any other collection
    of data. A list can hold lists, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Basic List Operations
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Unlike with some other data types, the order in which items are appended to
    a list matters. Let’s just jump in with some examples of lists and then talk about
    what’s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First, we define a list ❶. We use a “`[`” character to start the list, enter
    the items, and end with a “`]`” character. Items in the list are separated by
    commas (`,`). This list has three items, as we see when we ask Python to evaluate
    the expression `t`, which is the list itself.
  prefs: []
  type: TYPE_NORMAL
- en: We can index into lists by using a number and square brackets, just as we would
    an array. Here we ask for the first item in the list using bracket notation ❷.
    We do the same for the second and the third.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add to a list by using the `append` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here we see that the list, `t`, now has a fourth member, `3.14`. Note that appending
    an item to a list adds it to the *end* of the list.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a few more examples with lists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These examples show us how to use a negative index ❶, which will start at the
    *end* of the list and count backward, so that `-1` will always return the last
    item in the list. We also see how to use a range to select a subset of the list
    ❷.
  prefs: []
  type: TYPE_NORMAL
- en: To use Python ranges, follow the format `[a:b]` to return all items from index
    `a` to *one less than* `b`. Mathematically this is [*a*,*b*), where the *b*-th
    item is not included. So, asking for `t[0:2]` will return items 0 and 1 only.
    Note, if you skip the beginning part or ending part of the range, it defaults
    to the first item (if the beginning is skipped) or the last item (if the ending
    is skipped).
  prefs: []
  type: TYPE_NORMAL
- en: If you use an index on the left side of an assignment statement, that element
    of the list is modified ❸. We now see that the second element of the list has
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use the `index` method to search the list for an item ❹. If the
    item is found, `index` returns the index of the item. If the item is not in the
    list, Python will raise an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to know if an item is in the list but do not care *where* it is,
    use `in`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here the returned values are Booleans, `True` and `False`. Note the uppercase
    on `True` and `False`. Booleans can be assigned to variables as well. We should
    also mention `None`, which is Python’s version of `NULL` as found in other languages
    (at least to a first approximation). We’ll see a good use for `None` when we talk
    about Python functions in “Functions– on [page 39](ch03.xhtml#page_39).
  prefs: []
  type: TYPE_NORMAL
- en: Copying Lists
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'One last thing to note about lists is that Python does not copy lists when
    you assign them to new variables; instead, it points the new variable to the location
    in memory where the list already exists. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here we define `a` as a list of five numbers. We then assign that list to a
    new variable, `b`, and see that `b` is, indeed, the same as `a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, so good. However, what if we decide to change an element of `a` like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We see that `a` has updated as we desired, but, perhaps surprisingly, so has
    `b`. This is because assigning `a` to `b` points `b` to the same place in memory
    as `a`. It does not actually copy the contents of `a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to copy `a` when we assign it to `b`, we need to explicitly select
    all the elements of `a` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here we define a list, `a`, and then assign `a` to `b` by selecting all of the
    elements of `a` ❶. We see that `b` now looks like `a`. Next, we update the *third*
    item in `a` and see that `a` now looks as we expect, with its third item now `2`
    instead of `3`. However, `b` has not been altered in this case because the original
    assignment created a new list in memory by selecting all the elements of `a`.
  prefs: []
  type: TYPE_NORMAL
- en: The reason Python doesn’t automatically copy lists is that lists can be large,
    so copying them unnecessarily would waste a lot of memory. Completely copying
    a list made up of other, nested, lists can be nontrivial. The selecting everything
    method ❶ makes only a shallow copy—nested elements are still aliased. Use the
    `deepcopy` function of the `copy` module to recursively copy all levels of a list
    with nested elements.
  prefs: []
  type: TYPE_NORMAL
- en: Python has another data type similar to a list called a *tuple*. Tuples, defined
    with parentheses rather than square brackets, are just like lists except that
    once defined, they cannot be modified. In general, we will stick with lists, but
    NumPy uses tuples from time to time (see [Chapter 3](ch03.xhtml#ch03)).
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last data type we’ll look at is the *dictionary*. A dictionary is made
    up of a set of keys, each associated with a value. You define dictionaries with
    “`{`” and “`}`” characters. As with a list, the value can be anything, including
    another dictionary. They key is typically a string but can be a number or other
    object as well. You define a dictionary like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This example shows how to define the dictionary by directly listing its contents.
    The elements of the dictionary are given as key:value pairs. Here, the keys are
    all strings, and the value associated with each key is an integer. The `keys`
    method returns all the keys in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax above is useful when the contents of the dictionary are already
    known. Typically, this isn’t the case. Most of the time, the dictionary is defined,
    and we add elements individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here we define an empty dictionary `d`, and individually assign values for a
    new set of keys. If the key already exists in the dictionary `d`, its value is
    updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the value associated with a particular key, just index the dictionary
    with the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If the key doesn’t exist in that dictionary, Python will raise an error. To
    test if a key is in the dictionary, use `in`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Between lists and dictionaries, you can conveniently store almost any data.
    This is one of the benefits of a language like Python: programmers can devote
    energy to completing the task at hand instead of implementing complicated data
    structures. Lists and dictionaries are fast to use and generally all you’ll need
    unless you’re doing scientific programming, in which case we have NumPy, as discussed
    in [Chapter 3](ch03.xhtml#ch03).'
  prefs: []
  type: TYPE_NORMAL
- en: Control Structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python implements several *control structures* to allow you to alter program
    flow using syntax. We’ll look at these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if`-`elif`-`else`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`while` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`with` statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`try`-`except` blocks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if-elif-else Statements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An `if` statement makes a decision. You give it a condition that must result
    in a Boolean value, `True` or `False`. If the condition is true, the first block
    of the `if` statement is executed. If the condition is false, nothing happens
    and the code moves past the `if` statement, unless you include an `else`, in which
    case the body of the `else` will be executed. You can test multiple conditions
    in one statement by using the `elif` keyword, which adds additional conditions
    with their own blocks of code to run. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This checks the discriminant of a quadratic polynomial, *ax*² + *bx* + *c*,
    to identify the number and type of solution: a real number, a pair of real numbers,
    or imaginary numbers. The solutions are the values of *x* that make the polynomial
    equal to zero.'
  prefs: []
  type: TYPE_NORMAL
- en: First, the code calculates the discriminant value (`disc`) ❶. It then asks if
    the value is less than zero ❷. If it is, it means there are two imaginary solutions.
    If the discriminant is exactly zero ❸, there’s only one solution, a real number.
    Finally, the `else` executes if neither of the conditions is true; in this case,
    it means there are two real-number solutions ❹. The parentheses around the conditions
    are not required but can help with readability. Also note that Python uses “`**`”
    for exponentiation so that `b**2-4*a*c` = *b*² *–* 4*ac*. You can use as many
    `elif` clauses as needed, including none, followed by an optional final `else`.
    Python lacks the `case` or `switch` statements found in other common programming
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: for Loops
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Almost all structured programming languages have loops to run a particular block
    of code repeatedly. In this section, we’ll cover a few kinds in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Python’s primary looping construct is the `for` loop. In other languages, typically
    `for` loops are counted loops from some starting value to an ending value that
    increments by some fixed amount. In Python, loops run over objects that can be
    iterated through, things that have a `next` method. This includes the characters
    of a string, the elements of a list or tuple, or the elements of a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has two built-in functions that are quite handy with loops. The first
    is `range`, which creates a generator object that produces integers in order,
    starting with `0` unless otherwise specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `range` function ❶ returns the values `0...5`, and the `for` statement assigns
    the values one at a time to `i` for each iteration of the loop. Here we simply
    print the current value of `i` using the built-in Python function, `print`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful function to use with `for` loops is `enumerate`. This function
    returns two values. The first is the index of the current element of its argument
    and the second is the element itself. An example will clarify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first loop over just the list `x` ❶, we get each element of `x` assigned
    to `i` for each iteration. The second loop uses `enumerate` and gives us *two*
    values for each iteration: the current index, stored in `i`, and the current element
    of the list `x`, stored in `v` ❷. Python is capable of assigning multiple parts
    to multiple variables at the same time. In this case, the loop body prints the
    index followed by the element at that index.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens when we use a `for` loop with a dictionary? Let’s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here we first define a dictionary, `d`, with three keys ❶. If we simply loop
    over the dictionary variable, we will be given the keys ❷. However, if we then
    use the key to return the associated value, as in the second loop ❸, we’ll iterate
    over the entire dictionary, accessing each value exactly once.
  prefs: []
  type: TYPE_NORMAL
- en: 'One particularly attractive feature of Python is that we can combine a `for`
    loop with a list in a *list comprehension*. A list comprehension starts out as
    a list with a leading “`[`”, but instead of listing the individual elements, the
    body of the list is actually code that generates the list. This shorthand takes
    a bit of getting used to, but once you’re familiar with it, you’ll see that it’s
    an efficient replacement for many `for` loops. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We first import the standard random number library ❶ and then fill the list
    `a` with 10,000 random numbers in the range [0,1) (meaning 0 is included, 1 is
    not) ❷. Next, we also fill `b` with 10,000 random numbers but do so using a list
    comprehension ❸. Note that the syntax is the same as when we define a list with
    values, but here the body of the list is something that *returns* a value. In
    this case, it’s a call to `random.random()` and a `for` loop over 10,000 elements.
  prefs: []
  type: TYPE_NORMAL
- en: The last example creates a list, `m3`, of all multiples of 3, including 0, less
    than 10,000 ❹. The `if` clause is the test that decides whether a particular `i`
    value will be in the list. The percent operator is *modulo*, which gives the remainder
    after division. In this case, it’s asking if the remainder after dividing `i`
    by 3, using integer division, is zero. If it is, there is no remainder, which
    means `i` is a multiple of 3 (or 0).
  prefs: []
  type: TYPE_NORMAL
- en: while Loops
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Many programming languages include both top-tested and bottom-tested loops.
    A *top-tested loop* tests the loop condition at the beginning, before executing
    any of the body, and if the test is not true, the body is never executed. A *bottom-tested
    loop* executes the body at least once and *then* tests to see if the loop should
    execute again. The `while` loop in C is a top-tested loop and the `do...while`
    loop is a bottom-tested loop. Python has only a top-tested `while` loop with the
    following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We have to initialize the loop control variable (`i`) with a 0 *before* we start
    the loop ❶ so that the condition `i < 4` is true to begin with ❷. Also note that
    we explicitly increment `i` at the end of the body of the loop ❸. The expression
    `i += 1` is shorthand for `i = i + 1` and increments `i` by 1\. Python doesn’t
    support C-style increment and decrement such as `i ++`. If you try it, Python
    will kindly let you know with a `SyntaxError`.
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop repeats as long as the condition evaluates to `True`. It’s
    up to the programmer to do things in the loop body that will eventually make the
    condition `False` so the loop will end. You can also manually exit the loop, as
    you’ll see in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: break and continue Statements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `for` and `while` loops work with two other Python statements: to immediately
    exit the loop, use the `break` statement; to immediately move to the next iteration,
    use `continue`. One common use of `break` is to leave an infinite loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This produces the same output as the earlier `while` loop example, but exits
    the loop explicitly via `break` when the termination condition is met ❶; here,
    that’s when `i` is incremented up to 4\. Using `break` for this toy example does
    not really make sense since there are other, clearer ways to do this, but often
    the loop might need to execute until the program ends or until some other rare
    situation or error occurs. For example, the command line interpreter will keep
    checking for keyboard input. As each character comes in, it is added to a buffer.
    However, if the character is a “newline,” it breaks out of the loop and interprets
    the contents of the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `continue` statement iterates the loop without executing any body statements
    after it. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here the presence of `continue` ❶ ensures that the second `print` statement
    is never executed.
  prefs: []
  type: TYPE_NORMAL
- en: with Statement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Python `with` statement is useful when dealing with files. For example,
    the following code uses a `with` statement to open a file on disk and read its
    contents into a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `with` statement opens a file called *sesame* and assigns the file object
    to `f`. We then use the `read` method to read the entire file as a string and
    assign it to `s`. Evaluating `s` shows us that the file contains the string “this
    is a file” with a newline character at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the example above uses `open` and `read` but doesn’t explicitly close
    the file when done. This is because when the `with` statement exits, the `close`
    method is called automatically as `f` leaves scope (meaning `f` is defined only
    within the body of the `with` statement).
  prefs: []
  type: TYPE_NORMAL
- en: Handling Errors with try-except Blocks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, let’s take a quick look at Python’s ability to trap and process errors,
    rather than let errors halt our programs. Again, we’ll just look at a quick skeleton
    of Python’s error-control abilities as an aid to debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'To capture an error instead of letting it stop program execution, we can encapsulate
    the statements that might cause the error with a `try...except` block. If an error
    is raised by any of the statements after the `try` and before the `except`, it
    will be caught and execution will pass to the statements of the `except` clause.
    The example here shows how to catch *any* error that happens within the statements
    enclosed by the `try` block; though it’s useful to know that Python has a rich
    set of error types, and users can define their own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here we first attempt to assign the result of a division by zero to `x`. This
    fails with the given error message from Python. However, if we wrap the assignment
    in a `try` block, Python will move to the `x = 0` line of the `except` block and
    assign `x = 0` as shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re not using a sophisticated Python programming environment that supports
    breaks while executing code, the following construct is useful, as it halts execution
    when encountered. Here it halts execution immediately after the divide-by-zero
    error occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When an error occurs, the `pdb` module will be imported, if it hasn’t been already,
    and the `set_trace` function will be called to enter into a debugging environment.
    Of course, `pdb.set_trace()` can be called at any point in the code—it need not
    be inside of a `try...except` block.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You define a function in Python with the `def` keyword followed by the function
    name and a list of arguments the function will take in parentheses. Even if you
    include no arguments, you must include a pair of parentheses. Since Python is
    dynamically typed, you list the parameters of the function but no type information.
    You can, if necessary, also include default values. Again, we are ignoring Python’s
    object-oriented abilities and just focusing on a small section of what we can
    do with functions. Let’s define a simple function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This function is called `product` and it accepts two arguments that we will
    refer to in the function as `a` and `b`. The body of this function consists of
    a single statement—a `return` statement, which returns to the point in the code
    where `product` was called with the given value, here the product of the two arguments.
    If we test this function, then we see that it does indeed multiply its arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s redefine `product` and supply a default value for the second argument
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We supply default values in the argument list of the function. If we use two
    arguments, Python will assign the value of the second argument inside the function
    as before. However, if we do not supply a second argument, Python will use the
    given default value of 3, giving us a meaningful return value of 3 × 3 = 9\. Supplying
    a default value to a function argument makes it a keyword parameter, and, as we
    see above, we do not need to supply a value for that argument when we invoke the
    function. This technique is particularly handy, and we will see it in our code
    examples from time to time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final example below shows how to define a function that accepts no arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The function `pp` has an empty argument list. The only statement in the body
    of the function prints the word *plugh*. There is no return value.
  prefs: []
  type: TYPE_NORMAL
- en: Python allows you to nest function definitions so that a function can itself
    have functions defined within it. The inner functions are accessible to only the
    outer function. There is seldom a need to do this, and if you find yourself doing
    it often, you might want to think about refactoring to an object-oriented design;
    but, on occasion, it makes sense, so we mention it here.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, one helpful thing to do is to make the default value `None`, enabling
    us inside the function to check whether the value was given by testing if the
    argument is `None`. Any variable holding any type of data can be tested against
    `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We conclude our whirlwind review of Python with a look at the module system.
    This is akin to the C standard library, and it provides Python with a rich set
    of tools out of the box, all defined as modules. Naturally, users can create their
    own modules as well. A *module*, then, is a collection of functions that can be
    imported into your program. You can also import specific functions from a specific
    module into your own program, rather than the whole module, as long as you’re
    aware of the possibility that the imported function might have the same name as
    a function from another namespace.
  prefs: []
  type: TYPE_NORMAL
- en: By *namespace*, we mean a bag of functions, sort of like a family, where the
    functions are the names of the individuals in the family. All the functions that
    our program knows about are in our namespace. If we import a function from a module,
    that function is now also in our namespace. If we import the entire module and
    refer to the function by prefixing the module name, we get to use the function,
    but it’s not in our namespace. We’ll see shortly why this distinction matters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see some examples using the modules of the Python library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We first import the `time` module. This means that we now have access to all
    the functions in the `time` module as long as we prefix the function name with
    `time.`. The `time` function of the `time` module returns the current time as
    the number of seconds since January 1, 1970\. Known as the *epoch time*, this
    is useful for timing how long code takes to execute. Because the value returned
    only increases, the difference in epoch time at the start of the code to the end
    of the code indicates the length of time for code execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, instead of importing the entire `time` module, we import only two functions
    from it. Doing this puts the functions in our namespace so that we can call them
    directly. The `ctime` function returns a string showing the current date and time,
    while the `localtime` function returns the sections of the current time broken
    down by date and time part. Here we show the year at the time of this writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our last example shows us why it is often best to import a module directly
    instead of importing functions from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: First, we define a function we call `sqrt`. This function always returns 4 no
    matter what the argument is. Not particularly useful, of course, but still a valid
    Python function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s import the entire `math` library of functions. This syntax takes
    all the functions in the module and places them in our namespace so we can refer
    to them without using the module name as well. After doing this, we see that `sqrt`
    now returns the actual square root.
  prefs: []
  type: TYPE_NORMAL
- en: What happened to our dubious implementation of `sqrt`? It was masked when we
    imported the entire `math` library because the `math` library also contains a
    function called `sqrt` and, since the `math` library was imported after our `sqrt`
    was defined, the `math` library’s version of `sqrt` takes precedence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python’s module library is one of the key strengths of the language in terms
    of utility. The standard library has extensive documentation. For a quick look
    at the list of available Python 3.*X* modules, see *[https://docs.python.org/3/py-modindex.html](https://docs.python.org/3/py-modindex.html)*.
    The main Python site is here: [http://www.python.org/](http://www.python.org/).
    I strongly recommend that you spend some time at these links and really learn
    all that Python has to offer.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the fundamentals of Python to give us the background
    we need to understand the code examples in the remainder of this book. We learned
    about Python syntax and statements. We also examined Python variables and data
    structures, and then explored Python’s suite of control structures and functions,
    ending with a look at Python’s module library.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll dive into NumPy to see how to make Python even more
    useful to us. NumPy is a core piece of the machine learning toolkit used by virtually
    all machine learning libraries, including the ones we will use in this book.
  prefs: []
  type: TYPE_NORMAL
- en: '[1.](ch02.xhtml#Rch02fn1) See *Numbers and Computers* by Ronald T. Kneusel
    (Springer-Verlag, 2017).'
  prefs: []
  type: TYPE_NORMAL
