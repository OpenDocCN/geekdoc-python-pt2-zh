- en: '**2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2'
- en: USING PYTHON**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python**
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: If you’re already familiar with Python, you can skip this chapter. This summary
    is for those who are comfortable with programming but who aren’t familiar with
    Python. We’ll cover only enough of the language to be able to read and understand
    the code examples in this book. If you have little to no experience with computer
    programming, you should first read a more complete text like *Python Crash Course*,
    2nd Edition, by Eric Matthes (No Starch Press, 2019).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉 Python，可以跳过这一章。本章节是为那些已经熟悉编程，但不熟悉 Python 的读者准备的。我们只会介绍足够的 Python 知识，帮助你理解本书中的代码示例。如果你对计算机编程几乎没有经验，建议你先阅读更为全面的书籍，例如
    Eric Matthes 的《Python Crash Course》第二版（No Starch Press, 2019）。
- en: Python is, at its simplest, sequential statements grouped into blocks via indentation;
    data structures like numbers, strings, tuples, lists, and dictionaries; control
    structures including `if-elif-else`, for loops, while loops, with statements,
    and try-except blocks; functions with optional nested functions; and a large library
    of importable modules. We’ll cover each of these features.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Python 最简单的形式是通过缩进将顺序语句分组为块；包括数字、字符串、元组、列表和字典等数据结构；控制结构，包括`if-elif-else`、for
    循环、while 循环、with 语句以及 try-except 块；具有可选嵌套函数的函数；以及一个庞大的可导入模块库。我们将逐一介绍这些特性。
- en: The Python Interpreter
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 解释器
- en: 'On a Linux system, Python is typically used in one of two ways. You can run
    the Python interpreter from the command line and enter commands interactively,
    or you can run a script of Python commands. Simply enter `python3` in your console
    to use Python interactively:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 系统中，Python 通常有两种使用方式。你可以从命令行运行 Python 解释器并交互式地输入命令，或者运行一个 Python 命令脚本。只需在控制台中输入`python3`即可以交互方式使用
    Python：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, Python opens a prompt for you to enter commands into, beginning
    with `>>>`. Type an expression like `1+2` and hit `ENTER`. Python will respond
    immediately by evaluating the equation and passing you the result. When you want
    to exit the console, use `CTRL`-D.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Python 会为你打开一个提示符，你可以在其中输入命令，提示符以`>>>`开始。输入类似`1+2`的表达式并按下`ENTER`键，Python
    会立即评估该表达式并返回结果。当你想退出控制台时，使用`CTRL`-D。
- en: Statements and Whitespace
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语句和空白
- en: 'As in almost every other programming language, unless modified by a control
    flow structure, statements in Python are executed one after the other in the order
    in which they appear in the code. Consider, for example, this code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与几乎所有其他编程语言一样，除非通过控制流结构进行修改，否则 Python 中的语句按出现的顺序依次执行。举个例子，考虑以下代码：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here `statement1` will be executed first, followed by `statement2`, and then,
    finally, `statement3`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`statement1`会首先执行，然后是`statement2`，最后是`statement3`。
- en: 'Multiple statements can be grouped into units called *blocks*. For example,
    the condition of an `if` statement evaluating to `True` could trigger a block
    to run. Syntactically, the statements that go with the `if` need to be marked
    in some way so that the computer knows which statements to execute. Classic languages
    like Pascal used bulky `BEGIN` and `END` keywords. The C family of languages,
    which includes most of the languages in current widespread use, uses curly brackets:
    “{" and “}".'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 多个语句可以被组合成叫做*块*的单元。例如，当`if`语句的条件为`True`时，可以触发一个块的执行。从语法上讲，与`if`语句相关联的语句需要以某种方式标记，以便计算机知道哪些语句需要执行。经典语言如
    Pascal 使用笨重的`BEGIN`和`END`关键字。C 系列语言，包括当前广泛使用的大多数语言，则使用花括号：“{”和“}”。
- en: 'In Python, we use indentation. This makes reading Python code somewhat elegant
    as it follows the format of a traditional outline. It also makes the code more
    visually consistent across authors and leaves less room for confusion. In Python,
    when we use an `if else` statement, we can easily see which statements should
    run with which part of the condition, even if we have not yet understood the format
    of the `if` statement. For example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们使用缩进。这使得 Python 代码的阅读变得优雅，因为它遵循传统大纲的格式。它还使代码在不同作者之间更加视觉一致，减少了混淆的空间。在
    Python 中，当我们使用`if else`语句时，即使我们尚未完全理解`if`语句的格式，也可以轻松看到哪些语句应当与条件的哪一部分一起执行。例如：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The indentation makes it clear that `statement1` and `statement2` are executed
    when `condition1` (whatever it is) is true. Similarly, we see that `statement3`
    is executed when `condition1` is not true.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进清晰地表明，只有当`condition1`（无论是什么）为真时，`statement1`和`statement2`才会被执行。同样，我们看到`statement3`会在`condition1`不为真时执行。
- en: Notice the colons in the preceding `if` example. Python uses these to designate
    blocks of code. You must place a colon after any control statement, and then the
    next line should always be indented one level. If you try to use a control structure
    but don’t provide any statements in the body of the control structure, Python
    will throw an error.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面 `if` 示例中的冒号。Python 使用这些冒号来标记代码块。你必须在任何控制语句后面加上冒号，然后下一行应该始终缩进一级。如果你尝试使用控制结构，但在控制结构的主体中没有任何语句，Python
    会抛出一个错误。
- en: For example, the `else:` clause cannot be present without at least one statement
    in the block. If there is no need for the `else`, just don’t include it. (If you
    really want to include it, use the `pass` keyword to indicate to Python that you
    know a statement needs to be there, but you really don’t want that condition to
    do anything.)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`else:` 子句不能在没有至少一个语句的代码块中出现。如果没有 `else` 的需求，就不要包含它。（如果你真的想包含它，可以使用 `pass`
    关键字告诉 Python 你知道代码块中需要一个语句，但你真的不希望那个条件执行任何操作。）
- en: 'Indentation can seem intimidating to people new to Python, but you can make
    it easier on yourself by properly configuring your text editor. Python convention
    says that you should tell your text editor to do the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进可能会让初学 Python 的人感到害怕，但你可以通过正确配置文本编辑器来简化这个过程。Python 的约定是，你应该告诉你的文本编辑器执行以下操作：
- en: Insert spaces in place of tab characters. Shun tab characters like the plague.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用空格代替制表符。像避瘟疫一样避开制表符。
- en: Insert four spaces every time you hit the T A B key.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次按下 TAB 键时，插入四个空格。
- en: Automatically indent when you hit the E N T E R key.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 ENTER 键时自动缩进。
- en: With these settings, when you enter the “:” of a control statement, just hit
    ENTER, and Python will indent the block automatically.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些设置下，当你输入控制语句的“：”时，只需按 ENTER 键，Python 会自动缩进代码块。
- en: The way to configure these settings depends on the text editor used, of course,
    but any text editor worth its salt will be able to do all of these, and many have
    automatic indentation set as standard. If you use integrated development environments
    (IDEs), then it’s probable that once the IDE recognizes that you’re coding in
    Python, most of these conventions will just happen.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 配置这些设置的方法取决于使用的文本编辑器，当然，但任何值得一提的文本编辑器都能完成这些操作，许多编辑器默认启用自动缩进。如果你使用集成开发环境（IDE），那么一旦
    IDE 识别到你在使用 Python 编写代码，许多这些约定将自动生效。
- en: Variables and Basic Data Structures
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量和基本数据结构
- en: Python’s native data structures are simple and elegant. In this section, we’ll
    cover number representation, variables, strings, lists, and dictionaries.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的原生数据结构简洁优雅。在这一节中，我们将介绍数字表示、变量、字符串、列表和字典。
- en: Representing Numbers
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数字表示
- en: 'Numbers in Python are of two kinds: integers or floating-point. *Integers*
    are whole numbers like 42 and 66\. *Floating-point numbers* are those with a decimal
    point like 3.1415 and 2.718\. We’ll ignore complex numbers in this book, although
    Python supports them.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的数字分为两种类型：整数和浮点数。*整数*是像 42 和 66 这样的整数。*浮点数*是带小数点的数字，例如 3.1415 和 2.718。在本书中我们将忽略复数，尽管
    Python 是支持复数的。
- en: If you don’t include a decimal point, Python will assume you mean an integer;
    otherwise, it will use floating-point numbers. Floating-point numbers can also
    be specified using scientific notation, where `6.022e23` means 6.023 × 10^(23).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不包括小数点，Python 会默认你指的是整数；否则，它会使用浮点数。浮点数也可以使用科学计数法表示，其中 `6.022e23` 意味着 6.023
    × 10^(23)。
- en: Most programming languages can represent only numbers in a certain range, but
    Python does not have this restriction for integers, which can be as large as there
    is memory to hold them. For fun, enter **`2**2001`** and see what happens. The
    many ways in which computers store and operate on numbers is quite fascinating.
    Those who are curious might want to look further.^([1](ch02.xhtml#ch02fn1))
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言只能表示一定范围内的数字，但 Python 对整数没有这样的限制，整数可以大到只要内存足够存储它们。为了好玩，输入**`2**2001`**并看看会发生什么。计算机存储和操作数字的方式非常有趣。那些好奇的人可能会想进一步探究。^([1](ch02.xhtml#ch02fn1))
- en: Variables
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变量
- en: '*Variables* provide a useful place to store data for reuse. Fortunately, using
    Python variables is straightforward. Python is *dynamically typed*, which means
    we don’t need to declare the type of data a variable will store in advance. We
    simply assign data to a variable, and Python figures out the type for us.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量*提供了一个有用的存储数据的地方以供重用。幸运的是，使用 Python 变量非常简单。Python 是*动态类型*的，这意味着我们不需要提前声明变量将存储的数据类型。我们只需将数据赋值给变量，Python
    会自动推断出类型。'
- en: 'We can even change the type of data stored in a variable by assigning a new
    value, regardless of its type. For example, all of these are valid assignments
    in Python:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以通过赋值一个新值来改变变量存储的数据类型，而不管原来的数据类型是什么。例如，下面的赋值在 Python 中都是有效的：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The code assigns integer 123 to `v` ❶, the floating-point value 3.141592 to
    `n` ❷, and then reassigns a floating-point value to `v`: 6.022 × 10^(23) ❸.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将整数 123 赋值给变量`v` ❶，将浮点值 3.141592 赋值给变量`n` ❷，然后将浮点值重新赋值给`v`：6.022 × 10^(23)
    ❸。
- en: 'Python variable names are case-sensitive, must start with a letter, and can
    include letters, numbers, and “_” (underscore) characters. Many Python programmers
    follow the camel-case convention of Java, shown here, but this is not strictly
    required:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Python 变量名是区分大小写的，必须以字母开头，并且可以包含字母、数字和“_”字符。许多 Python 程序员遵循 Java 的驼峰命名法，在这里也有体现，但这并不是强制要求的：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Strings
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Python supports textual data with strings. You mark the beginning and end of
    *strings* with quotes, either single (’), double (’’), or triple (’’’), as long
    as you use the same for both opening and closing. The triple-quoted string is
    special: it can span multiple lines of text, and you would often use it immediately
    after defining a function to implement a simple documentation string. All of these
    are valid Python strings:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Python 支持使用字符串处理文本数据。你可以用引号标记*字符串*的开始和结束，可以是单引号（’）、双引号（“”）或三引号（’’’），只要开头和结尾使用相同的引号。三引号字符串是特别的：它可以跨越多行文本，通常在定义函数后紧接着使用它来实现简单的文档字符串。以下这些都是有效的
    Python 字符串：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, `thing1` is a simple string; `thing2` is also a simple string, but note
    that it has a single quote embedded in it to act as an apostrophe. We can do this
    because we started the string with a double quote character; if we wanted to use
    double quotes inside the string, then we would have to enclose it with single
    quotes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`thing1`是一个简单的字符串；`thing2`也是一个简单字符串，但注意它包含一个单引号作为撇号。我们能这么做是因为我们使用了双引号来开始这个字符串；如果想在字符串中使用双引号，那么就需要用单引号来包围整个字符串。
- en: The last string, `thing3`, spans multiple lines. The newline characters typed
    to move from `one` to `two` are also part of the string, and when printed, they
    will be shown. Note, if you actually enter the assignment to `thing3` in the Python
    interpreter, you will see that the interpreter inserts an ellipsis (`...`). We
    ignored those in the example as they would be confusing and are not really part
    of the string.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个字符串`thing3`跨越了多行。从`one`到`two`之间的换行符也是字符串的一部分，打印时会显示出来。注意，如果你在 Python 解释器中实际输入赋值给`thing3`，你会看到解释器会插入省略号（`...`）。我们在示例中忽略了这些，因为它们可能会造成混淆，实际上也不是字符串的一部分。
- en: Lists
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列表
- en: Strings and numbers are *primitive data types*, meaning they are not made up
    of grouped collections of data. Think of them as atoms. They can be combined into
    more sophisticated data structures by using tuples and lists. A *list* is an ordered
    collection of other data, which could be primitive data or any other collection
    of data. A list can hold lists, for example.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串和数字是*原始数据类型*，这意味着它们不是由一组数据构成的。可以把它们看作是原子。通过使用元组和列表，它们可以组合成更复杂的数据结构。*列表*是一个有序的其他数据集合，里面可以是原始数据或任何其他数据集合。例如，列表里也可以包含列表。
- en: Basic List Operations
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基本列表操作
- en: 'Unlike with some other data types, the order in which items are appended to
    a list matters. Let’s just jump in with some examples of lists and then talk about
    what’s happening:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他一些数据类型不同，添加到列表中的项目顺序是重要的。我们直接通过一些列表示例来跳入讨论，然后再讲解发生了什么：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, we define a list ❶. We use a “`[`” character to start the list, enter
    the items, and end with a “`]`” character. Items in the list are separated by
    commas (`,`). This list has three items, as we see when we ask Python to evaluate
    the expression `t`, which is the list itself.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个列表 ❶。我们使用“`[`”字符开始列表，输入项目，并用“`]`”字符结束。列表中的项目由逗号（`,`）分隔。这个列表有三个项目，当我们让
    Python 评估表达式`t`时，会看到这个列表。
- en: We can index into lists by using a number and square brackets, just as we would
    an array. Here we ask for the first item in the list using bracket notation ❷.
    We do the same for the second and the third.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像处理数组一样，通过使用数字和方括号来索引列表。在这里，我们使用方括号表示法❷来请求列表中的第一个元素。对于第二个和第三个元素，我们也是一样操作。
- en: 'We can add to a list by using the `append` method:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`append`方法向列表添加元素：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here we see that the list, `t`, now has a fourth member, `3.14`. Note that appending
    an item to a list adds it to the *end* of the list.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到列表`t`现在有了第四个成员`3.14`。请注意，向列表追加元素会将其添加到列表的*末尾*。
- en: Let’s look at a few more examples with lists.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看几个使用列表的例子。
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These examples show us how to use a negative index ❶, which will start at the
    *end* of the list and count backward, so that `-1` will always return the last
    item in the list. We also see how to use a range to select a subset of the list
    ❷.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子展示了如何使用负索引❶，负索引从列表的*末尾*开始并向前计数，因此`-1`总是返回列表中的最后一个元素。我们还展示了如何使用范围来选择列表的子集❷。
- en: To use Python ranges, follow the format `[a:b]` to return all items from index
    `a` to *one less than* `b`. Mathematically this is [*a*,*b*), where the *b*-th
    item is not included. So, asking for `t[0:2]` will return items 0 and 1 only.
    Note, if you skip the beginning part or ending part of the range, it defaults
    to the first item (if the beginning is skipped) or the last item (if the ending
    is skipped).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Python的范围，可以遵循`[a:b]`的格式，从索引`a`返回到*小于*`b`的所有元素。在数学上，这就是[*a*, *b*)，其中`b`-th元素不包括在内。因此，要求`t[0:2]`将只返回元素0和1。请注意，如果你跳过了范围的开始部分或结束部分，它将默认从第一个元素开始（如果跳过了开始部分），或从最后一个元素开始（如果跳过了结束部分）。
- en: If you use an index on the left side of an assignment statement, that element
    of the list is modified ❸. We now see that the second element of the list has
    changed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在赋值语句的左侧使用索引，则会修改该列表的元素❸。现在我们看到列表的第二个元素已经改变。
- en: Finally, we use the `index` method to search the list for an item ❹. If the
    item is found, `index` returns the index of the item. If the item is not in the
    list, Python will raise an error.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`index`方法来搜索列表中的元素❹。如果找到了该元素，`index`将返回该元素的索引。如果元素不在列表中，Python会抛出一个错误。
- en: 'If you want to know if an item is in the list but do not care *where* it is,
    use `in`, like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道某个元素是否在列表中，但不关心它的位置，可以使用`in`，如下所示：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here the returned values are Booleans, `True` and `False`. Note the uppercase
    on `True` and `False`. Booleans can be assigned to variables as well. We should
    also mention `None`, which is Python’s version of `NULL` as found in other languages
    (at least to a first approximation). We’ll see a good use for `None` when we talk
    about Python functions in “Functions– on [page 39](ch03.xhtml#page_39).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里返回的值是布尔值`True`和`False`。请注意，`True`和`False`的首字母是大写的。布尔值也可以赋值给变量。我们还应该提到`None`，它是Python版本的`NULL`（至少从第一印象来看）。我们将在讨论Python函数时介绍`None`的实际应用，详见“函数”章节—在[第39页](ch03.xhtml#page_39)。
- en: Copying Lists
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 复制列表
- en: 'One last thing to note about lists is that Python does not copy lists when
    you assign them to new variables; instead, it points the new variable to the location
    in memory where the list already exists. For example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 关于列表，最后需要注意的一点是，Python在将列表赋值给新变量时，并不会复制列表；相反，它将新变量指向列表已存在的内存位置。例如：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here we define `a` as a list of five numbers. We then assign that list to a
    new variable, `b`, and see that `b` is, indeed, the same as `a`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们定义了一个包含五个数字的列表`a`。然后我们将该列表赋值给一个新变量`b`，并且看到`b`确实和`a`相同。
- en: 'So far, so good. However, what if we decide to change an element of `a` like
    so:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切正常。然而，如果我们决定像这样更改`a`的某个元素会怎样：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We see that `a` has updated as we desired, but, perhaps surprisingly, so has
    `b`. This is because assigning `a` to `b` points `b` to the same place in memory
    as `a`. It does not actually copy the contents of `a`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`a`已经如预期那样更新了，但可能令人惊讶的是，`b`也发生了变化。这是因为将`a`赋值给`b`时，`b`指向了与`a`相同的内存位置，它并没有实际复制`a`的内容。
- en: 'If we want to copy `a` when we assign it to `b`, we need to explicitly select
    all the elements of `a` like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在将`a`赋值给`b`时复制`a`，我们需要显式地选择`a`中的所有元素，如下所示：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we define a list, `a`, and then assign `a` to `b` by selecting all of the
    elements of `a` ❶. We see that `b` now looks like `a`. Next, we update the *third*
    item in `a` and see that `a` now looks as we expect, with its third item now `2`
    instead of `3`. However, `b` has not been altered in this case because the original
    assignment created a new list in memory by selecting all the elements of `a`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个列表`a`，然后通过选择`a`的所有元素❶将`a`赋值给`b`。我们看到`b`现在看起来像`a`。接下来，我们更新`a`中的*第三*项，并看到`a`现在看起来如我们所预期，第三项从`3`变成了`2`。然而，`b`在这种情况下没有被改变，因为最初的赋值通过选择`a`的所有元素创建了一个新的列表在内存中。
- en: The reason Python doesn’t automatically copy lists is that lists can be large,
    so copying them unnecessarily would waste a lot of memory. Completely copying
    a list made up of other, nested, lists can be nontrivial. The selecting everything
    method ❶ makes only a shallow copy—nested elements are still aliased. Use the
    `deepcopy` function of the `copy` module to recursively copy all levels of a list
    with nested elements.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Python不自动复制列表的原因是列表可能非常大，复制它们会浪费大量内存。完全复制由其他嵌套列表构成的列表可能不是一件简单的事情。通过选择所有元素的方法❶只会进行浅拷贝——嵌套元素仍然是别名。如果需要递归地复制包含嵌套元素的所有列表层级，可以使用`copy`模块中的`deepcopy`函数。
- en: Python has another data type similar to a list called a *tuple*. Tuples, defined
    with parentheses rather than square brackets, are just like lists except that
    once defined, they cannot be modified. In general, we will stick with lists, but
    NumPy uses tuples from time to time (see [Chapter 3](ch03.xhtml#ch03)).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Python有另一种类似于列表的数据类型，叫做*元组*。元组使用圆括号定义，而不是方括号，它们与列表非常相似，除了定义后无法修改。通常，我们会使用列表，但NumPy会偶尔使用元组（参见[第3章](ch03.xhtml#ch03)）。
- en: Dictionaries
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字典
- en: 'The last data type we’ll look at is the *dictionary*. A dictionary is made
    up of a set of keys, each associated with a value. You define dictionaries with
    “`{`” and “`}`” characters. As with a list, the value can be anything, including
    another dictionary. They key is typically a string but can be a number or other
    object as well. You define a dictionary like so:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要看的最后一种数据类型是*字典*。字典由一组键组成，每个键都与一个值相关联。你可以通过“`{`”和“`}`”字符来定义字典。与列表类似，值可以是任何类型的对象，包括另一个字典。键通常是字符串，但也可以是数字或其他对象。你可以这样定义一个字典：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This example shows how to define the dictionary by directly listing its contents.
    The elements of the dictionary are given as key:value pairs. Here, the keys are
    all strings, and the value associated with each key is an integer. The `keys`
    method returns all the keys in the dictionary.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了如何通过直接列出字典的内容来定义字典。字典的元素是按键:值对给出的。在这里，所有的键都是字符串，每个键所关联的值是一个整数。`keys`方法返回字典中的所有键。
- en: 'The syntax above is useful when the contents of the dictionary are already
    known. Typically, this isn’t the case. Most of the time, the dictionary is defined,
    and we add elements individually:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的语法在字典的内容已经知道的情况下很有用。通常，情况并非如此。大多数时候，字典已经被定义，我们会单独添加元素：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here we define an empty dictionary `d`, and individually assign values for a
    new set of keys. If the key already exists in the dictionary `d`, its value is
    updated.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个空字典`d`，并为一组新键单独赋值。如果键已经存在于字典`d`中，则其值会被更新。
- en: 'To get the value associated with a particular key, just index the dictionary
    with the key:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取与特定键关联的值，只需使用该键索引字典：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If the key doesn’t exist in that dictionary, Python will raise an error. To
    test if a key is in the dictionary, use `in`, like so:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键在字典中不存在，Python会抛出一个错误。要测试一个键是否在字典中，可以使用`in`，像这样：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Between lists and dictionaries, you can conveniently store almost any data.
    This is one of the benefits of a language like Python: programmers can devote
    energy to completing the task at hand instead of implementing complicated data
    structures. Lists and dictionaries are fast to use and generally all you’ll need
    unless you’re doing scientific programming, in which case we have NumPy, as discussed
    in [Chapter 3](ch03.xhtml#ch03).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表和字典之间，你可以方便地存储几乎任何数据。这是像Python这样的语言的一个好处：程序员可以将精力集中在完成当前任务上，而不必实现复杂的数据结构。列表和字典的使用非常快速，通常情况下，它们是你所需要的，除非你在做科学计算，这时我们会使用NumPy，如在[第3章](ch03.xhtml#ch03)中讨论的那样。
- en: Control Structures
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制结构
- en: 'Python implements several *control structures* to allow you to alter program
    flow using syntax. We’ll look at these:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Python实现了几种*控制结构*，允许你使用语法来改变程序流。我们将看看这些：
- en: '`if`-`elif`-`else`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`-`elif`-`else`'
- en: '`for` loops'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环'
- en: '`while` loops'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while` 循环'
- en: '`with` statements'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`with`语句'
- en: '`try`-`except` blocks'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try`-`except`语句块'
- en: if-elif-else Statements
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: if-elif-else 语句
- en: 'An `if` statement makes a decision. You give it a condition that must result
    in a Boolean value, `True` or `False`. If the condition is true, the first block
    of the `if` statement is executed. If the condition is false, nothing happens
    and the code moves past the `if` statement, unless you include an `else`, in which
    case the body of the `else` will be executed. You can test multiple conditions
    in one statement by using the `elif` keyword, which adds additional conditions
    with their own blocks of code to run. For example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句用于做出决策。你给它一个条件，该条件必须返回布尔值`True`或`False`。如果条件为真，第一个代码块将被执行。如果条件为假，什么也不会发生，代码将跳过`if`语句，除非你添加了`else`，此时`else`的代码块将被执行。你还可以通过使用`elif`关键字在一个语句中测试多个条件，它会为每个条件添加自己的代码块。示例如下：'
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This checks the discriminant of a quadratic polynomial, *ax*² + *bx* + *c*,
    to identify the number and type of solution: a real number, a pair of real numbers,
    or imaginary numbers. The solutions are the values of *x* that make the polynomial
    equal to zero.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这检查一个二次多项式的判别式，*ax*² + *bx* + *c*，以确定解的数量和类型：实数、两个实数，还是虚数。解是使多项式等于零的*x*值。
- en: First, the code calculates the discriminant value (`disc`) ❶. It then asks if
    the value is less than zero ❷. If it is, it means there are two imaginary solutions.
    If the discriminant is exactly zero ❸, there’s only one solution, a real number.
    Finally, the `else` executes if neither of the conditions is true; in this case,
    it means there are two real-number solutions ❹. The parentheses around the conditions
    are not required but can help with readability. Also note that Python uses “`**`”
    for exponentiation so that `b**2-4*a*c` = *b*² *–* 4*ac*. You can use as many
    `elif` clauses as needed, including none, followed by an optional final `else`.
    Python lacks the `case` or `switch` statements found in other common programming
    languages.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码计算判别式值(`disc`)❶。然后检查该值是否小于零❷。如果是，表示有两个虚数解。如果判别式恰好为零❸，则只有一个解，是实数。最后，如果以上条件都不成立，`else`代码块将执行；在这种情况下，表示有两个实数解❹。条件周围的括号并非必需，但可以提高可读性。另外，请注意，Python使用“`**`”表示指数运算，因此`b**2-4*a*c`
    = *b*² *–* 4*ac*。你可以根据需要使用任意多个`elif`语句，也可以不使用，最后可以有一个可选的`else`语句。Python没有像其他常见编程语言中那样的`case`或`switch`语句。
- en: for Loops
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: Almost all structured programming languages have loops to run a particular block
    of code repeatedly. In this section, we’ll cover a few kinds in Python.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有结构化编程语言都有循环来重复运行特定的代码块。在本节中，我们将讨论Python中的几种类型。
- en: Python’s primary looping construct is the `for` loop. In other languages, typically
    `for` loops are counted loops from some starting value to an ending value that
    increments by some fixed amount. In Python, loops run over objects that can be
    iterated through, things that have a `next` method. This includes the characters
    of a string, the elements of a list or tuple, or the elements of a dictionary.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Python的主要循环结构是`for`循环。在其他编程语言中，通常`for`循环是从某个起始值到结束值的计数循环，循环每次增加一个固定的量。而在Python中，循环遍历的是可以被迭代的对象，即具有`next`方法的对象。这包括字符串中的字符、列表或元组中的元素，或者字典中的元素。
- en: 'Python has two built-in functions that are quite handy with loops. The first
    is `range`, which creates a generator object that produces integers in order,
    starting with `0` unless otherwise specified:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Python有两个内置函数，在循环中非常方便。第一个是`range`，它创建一个生成器对象，按顺序生成整数，默认从`0`开始，除非另行指定：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `range` function ❶ returns the values `0...5`, and the `for` statement assigns
    the values one at a time to `i` for each iteration of the loop. Here we simply
    print the current value of `i` using the built-in Python function, `print`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`range`函数❶返回值`0...5`，`for`语句将每次把这些值依次赋给`i`，直到循环结束。在这里，我们只是使用Python的内置函数`print`打印当前`i`的值。'
- en: 'Another useful function to use with `for` loops is `enumerate`. This function
    returns two values. The first is the index of the current element of its argument
    and the second is the element itself. An example will clarify:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与`for`循环一起使用的另一个有用的函数是`enumerate`。该函数返回两个值，第一个是当前元素的索引，第二个是该元素本身。一个示例将会更清楚地说明：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the first loop over just the list `x` ❶, we get each element of `x` assigned
    to `i` for each iteration. The second loop uses `enumerate` and gives us *two*
    values for each iteration: the current index, stored in `i`, and the current element
    of the list `x`, stored in `v` ❷. Python is capable of assigning multiple parts
    to multiple variables at the same time. In this case, the loop body prints the
    index followed by the element at that index.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次仅遍历列表 `x` ❶ 时，我们在每次迭代中将 `x` 的每个元素赋值给 `i`。第二个循环使用 `enumerate`，并为每次迭代提供 *两个*
    值：当前索引，存储在 `i` 中，以及当前列表 `x` 中的元素，存储在 `v` 中 ❷。Python 能够同时将多个部分赋值给多个变量。在这种情况下，循环体打印出索引，后跟该索引对应的元素。
- en: 'What happens when we use a `for` loop with a dictionary? Let’s see:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `for` 循环遍历字典时会发生什么呢？我们来看看：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here we first define a dictionary, `d`, with three keys ❶. If we simply loop
    over the dictionary variable, we will be given the keys ❷. However, if we then
    use the key to return the associated value, as in the second loop ❸, we’ll iterate
    over the entire dictionary, accessing each value exactly once.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们首先定义了一个字典 `d`，它有三个键 ❶。如果我们简单地遍历字典变量，我们将得到键 ❷。然而，如果我们随后使用键来返回关联的值，如第二个循环
    ❸ 所示，我们将遍历整个字典，每个值访问一次。
- en: 'One particularly attractive feature of Python is that we can combine a `for`
    loop with a list in a *list comprehension*. A list comprehension starts out as
    a list with a leading “`[`”, but instead of listing the individual elements, the
    body of the list is actually code that generates the list. This shorthand takes
    a bit of getting used to, but once you’re familiar with it, you’ll see that it’s
    an efficient replacement for many `for` loops. For example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的一个特别吸引人的特点是我们可以将 `for` 循环与列表结合使用，形成 *列表推导式*。列表推导式开始时是一个以“`[`”为开头的列表，但与列出单独的元素不同，列表的主体实际上是生成列表的代码。这个简写方式需要一点时间来适应，但一旦熟悉了，你会发现它是许多
    `for` 循环的高效替代方案。例如：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We first import the standard random number library ❶ and then fill the list
    `a` with 10,000 random numbers in the range [0,1) (meaning 0 is included, 1 is
    not) ❷. Next, we also fill `b` with 10,000 random numbers but do so using a list
    comprehension ❸. Note that the syntax is the same as when we define a list with
    values, but here the body of the list is something that *returns* a value. In
    this case, it’s a call to `random.random()` and a `for` loop over 10,000 elements.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入标准的随机数库 ❶，然后用 10,000 个在区间 [0,1) 内的随机数填充列表 `a`（表示 0 包含，1 不包含）❷。接下来，我们也用列表推导式将
    `b` 填充为 10,000 个随机数 ❸。请注意，语法与我们定义带有值的列表时相同，但这里列表的主体是一个 *返回* 值的表达式。在这种情况下，它是调用
    `random.random()` 和一个遍历 10,000 个元素的 `for` 循环。
- en: The last example creates a list, `m3`, of all multiples of 3, including 0, less
    than 10,000 ❹. The `if` clause is the test that decides whether a particular `i`
    value will be in the list. The percent operator is *modulo*, which gives the remainder
    after division. In this case, it’s asking if the remainder after dividing `i`
    by 3, using integer division, is zero. If it is, there is no remainder, which
    means `i` is a multiple of 3 (or 0).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的例子创建了一个列表 `m3`，包含所有小于 10,000 的 3 的倍数，包括 0 ❹。`if` 子句是决定特定 `i` 值是否在列表中的测试条件。百分号运算符是
    *取模* 运算符，返回除法后的余数。在这里，它是判断将 `i` 除以 3 后的余数是否为零。如果余数为零，则说明 `i` 是 3 的倍数（或 0）。
- en: while Loops
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: while 循环
- en: 'Many programming languages include both top-tested and bottom-tested loops.
    A *top-tested loop* tests the loop condition at the beginning, before executing
    any of the body, and if the test is not true, the body is never executed. A *bottom-tested
    loop* executes the body at least once and *then* tests to see if the loop should
    execute again. The `while` loop in C is a top-tested loop and the `do...while`
    loop is a bottom-tested loop. Python has only a top-tested `while` loop with the
    following syntax:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言包括顶端测试和底端测试的循环。*顶端测试循环* 会在执行循环体之前测试循环条件，如果条件不成立，则循环体永远不会执行。*底端测试循环* 会至少执行一次循环体，然后才测试是否需要再次执行循环。C
    语言中的 `while` 循环是顶端测试循环，而 `do...while` 循环是底端测试循环。Python 只有顶端测试的 `while` 循环，语法如下：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have to initialize the loop control variable (`i`) with a 0 *before* we start
    the loop ❶ so that the condition `i < 4` is true to begin with ❷. Also note that
    we explicitly increment `i` at the end of the body of the loop ❸. The expression
    `i += 1` is shorthand for `i = i + 1` and increments `i` by 1\. Python doesn’t
    support C-style increment and decrement such as `i ++`. If you try it, Python
    will kindly let you know with a `SyntaxError`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在开始循环之前初始化循环控制变量（`i`）为 0 ❶，以确保条件 `i < 4` 一开始为真 ❷。还要注意，我们在循环体的末尾显式地增加 `i`
    ❸。表达式 `i += 1` 是 `i = i + 1` 的简写，表示 `i` 增加 1。Python 不支持 C 风格的递增和递减操作，比如 `i ++`。如果你尝试使用，Python
    会友好地提示你 `SyntaxError`。
- en: The `while` loop repeats as long as the condition evaluates to `True`. It’s
    up to the programmer to do things in the loop body that will eventually make the
    condition `False` so the loop will end. You can also manually exit the loop, as
    you’ll see in the following section.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环只要条件评估为 `True` 就会一直重复。程序员需要在循环体中做些事情，使条件最终为 `False`，从而结束循环。你还可以手动退出循环，正如你将在下一部分看到的那样。'
- en: break and continue Statements
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`break` 和 `continue` 语句'
- en: 'The `for` and `while` loops work with two other Python statements: to immediately
    exit the loop, use the `break` statement; to immediately move to the next iteration,
    use `continue`. One common use of `break` is to leave an infinite loop:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 和 `while` 循环与另外两个 Python 语句配合使用：要立即退出循环，使用 `break` 语句；要立即跳到下一个迭代，使用 `continue`。`break`
    的一个常见用法是跳出无限循环：'
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This produces the same output as the earlier `while` loop example, but exits
    the loop explicitly via `break` when the termination condition is met ❶; here,
    that’s when `i` is incremented up to 4\. Using `break` for this toy example does
    not really make sense since there are other, clearer ways to do this, but often
    the loop might need to execute until the program ends or until some other rare
    situation or error occurs. For example, the command line interpreter will keep
    checking for keyboard input. As each character comes in, it is added to a buffer.
    However, if the character is a “newline,” it breaks out of the loop and interprets
    the contents of the buffer.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的 `while` 循环示例产生相同的输出，但是当满足终止条件时，通过 `break` 显式地退出循环 ❶；在这里，就是当 `i` 增加到 4
    时。对于这个示例，使用 `break` 并没有太大意义，因为有其他更清晰的方法来实现这一点，但通常情况下，循环可能需要一直执行直到程序结束，或者直到某些罕见的情况或错误发生。例如，命令行解释器会不断检查键盘输入。每当一个字符输入时，它会被添加到缓冲区中。然而，如果字符是“换行符”，则会跳出循环并解释缓冲区的内容。
- en: 'The `continue` statement iterates the loop without executing any body statements
    after it. For example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue` 语句会跳过循环体中 `continue` 后的所有语句，直接进入下一个迭代。例如：'
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here the presence of `continue` ❶ ensures that the second `print` statement
    is never executed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`continue` ❶ 确保了第二个 `print` 语句永远不会被执行。
- en: with Statement
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`with` 语句'
- en: 'The Python `with` statement is useful when dealing with files. For example,
    the following code uses a `with` statement to open a file on disk and read its
    contents into a string:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `with` 语句在处理文件时非常有用。例如，下面的代码使用 `with` 语句打开一个磁盘上的文件，并将其内容读取到一个字符串中：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `with` statement opens a file called *sesame* and assigns the file object
    to `f`. We then use the `read` method to read the entire file as a string and
    assign it to `s`. Evaluating `s` shows us that the file contains the string “this
    is a file” with a newline character at the end.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`with` 语句打开一个名为 *sesame* 的文件，并将文件对象赋值给 `f`。然后我们使用 `read` 方法读取整个文件内容作为字符串，并将其赋值给
    `s`。评估 `s` 后我们看到文件包含字符串“this is a file”，并且末尾有一个换行符。'
- en: Note that the example above uses `open` and `read` but doesn’t explicitly close
    the file when done. This is because when the `with` statement exits, the `close`
    method is called automatically as `f` leaves scope (meaning `f` is defined only
    within the body of the `with` statement).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上面的示例使用了 `open` 和 `read`，但是在完成后没有显式关闭文件。这是因为当 `with` 语句退出时，`close` 方法会自动调用，因为
    `f` 离开作用域（这意味着 `f` 只在 `with` 语句体内定义）。
- en: Handling Errors with try-except Blocks
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理错误的 `try-except` 语句块
- en: Finally, let’s take a quick look at Python’s ability to trap and process errors,
    rather than let errors halt our programs. Again, we’ll just look at a quick skeleton
    of Python’s error-control abilities as an aid to debugging.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们快速了解 Python 捕获和处理错误的能力，而不是让错误停止我们的程序。我们将简单地了解 Python 错误控制的一个框架，以便调试。
- en: 'To capture an error instead of letting it stop program execution, we can encapsulate
    the statements that might cause the error with a `try...except` block. If an error
    is raised by any of the statements after the `try` and before the `except`, it
    will be caught and execution will pass to the statements of the `except` clause.
    The example here shows how to catch *any* error that happens within the statements
    enclosed by the `try` block; though it’s useful to know that Python has a rich
    set of error types, and users can define their own:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获错误而不是让它停止程序执行，我们可以用`try...except`块将可能引发错误的语句进行封装。如果在`try`之后、`except`之前的任何语句引发了错误，它将被捕获，执行将转到`except`块中的语句。这里的示例展示了如何捕获`try`块中包含的语句中发生的*任何*错误；不过，值得注意的是，Python
    提供了丰富的错误类型，用户也可以自定义错误类型：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here we first attempt to assign the result of a division by zero to `x`. This
    fails with the given error message from Python. However, if we wrap the assignment
    in a `try` block, Python will move to the `x = 0` line of the `except` block and
    assign `x = 0` as shown.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先尝试将除以零的结果赋值给`x`。这会失败，并显示来自 Python 的错误信息。然而，如果我们将赋值操作放入`try`块中，Python
    会跳转到`except`块中的`x = 0`行，并将`x = 0`赋值，如示所示。
- en: 'If you’re not using a sophisticated Python programming environment that supports
    breaks while executing code, the following construct is useful, as it halts execution
    when encountered. Here it halts execution immediately after the divide-by-zero
    error occurs:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用支持代码执行中断的高级 Python 编程环境，下面的结构会很有用，因为它在遇到时会停止执行。这里它在除零错误发生后立即停止执行：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When an error occurs, the `pdb` module will be imported, if it hasn’t been already,
    and the `set_trace` function will be called to enter into a debugging environment.
    Of course, `pdb.set_trace()` can be called at any point in the code—it need not
    be inside of a `try...except` block.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生错误时，如果`pdb`模块尚未导入，它将被导入，并调用`set_trace`函数进入调试环境。当然，`pdb.set_trace()`可以在代码中的任何地方调用——它不一定要在`try...except`块内。
- en: Functions
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: 'You define a function in Python with the `def` keyword followed by the function
    name and a list of arguments the function will take in parentheses. Even if you
    include no arguments, you must include a pair of parentheses. Since Python is
    dynamically typed, you list the parameters of the function but no type information.
    You can, if necessary, also include default values. Again, we are ignoring Python’s
    object-oriented abilities and just focusing on a small section of what we can
    do with functions. Let’s define a simple function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你使用`def`关键字来定义一个函数，后面跟着函数名和括号内的参数列表。即使你不包含任何参数，也必须包括一对括号。由于 Python
    是动态类型语言，你只列出函数的参数，而没有类型信息。必要时，你还可以为参数提供默认值。同样，我们这里忽略了 Python 的面向对象能力，仅关注函数的一小部分功能。让我们定义一个简单的函数：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This function is called `product` and it accepts two arguments that we will
    refer to in the function as `a` and `b`. The body of this function consists of
    a single statement—a `return` statement, which returns to the point in the code
    where `product` was called with the given value, here the product of the two arguments.
    If we test this function, then we see that it does indeed multiply its arguments.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数被称为`product`，它接受两个参数，我们将在函数中将它们称为`a`和`b`。该函数的主体由一个语句组成——一个`return`语句，它将返回到调用`product`时的代码位置，并返回给定的值，这里是两个参数的乘积。如果我们测试这个函数，就会发现它确实会将两个参数相乘。
- en: 'Next, let’s redefine `product` and supply a default value for the second argument
    using the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们重新定义`product`函数，并为第二个参数提供一个默认值，代码如下：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We supply default values in the argument list of the function. If we use two
    arguments, Python will assign the value of the second argument inside the function
    as before. However, if we do not supply a second argument, Python will use the
    given default value of 3, giving us a meaningful return value of 3 × 3 = 9\. Supplying
    a default value to a function argument makes it a keyword parameter, and, as we
    see above, we do not need to supply a value for that argument when we invoke the
    function. This technique is particularly handy, and we will see it in our code
    examples from time to time.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数的参数列表中提供了默认值。如果我们使用两个参数，Python 会像之前一样将第二个参数的值赋给函数内部的参数。然而，如果我们没有提供第二个参数，Python
    将使用给定的默认值 3，从而返回有意义的结果 3 × 3 = 9。为函数参数提供默认值使其成为关键字参数，正如我们上面所见，我们在调用函数时不需要为该参数提供值。这种技术特别方便，我们在代码示例中时常会用到。
- en: 'Our final example below shows how to define a function that accepts no arguments:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下面的最终示例展示了如何定义一个不接受任何参数的函数：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The function `pp` has an empty argument list. The only statement in the body
    of the function prints the word *plugh*. There is no return value.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`pp`的参数列表为空。函数体中的唯一语句打印出单词*plugh*。该函数没有返回值。
- en: Python allows you to nest function definitions so that a function can itself
    have functions defined within it. The inner functions are accessible to only the
    outer function. There is seldom a need to do this, and if you find yourself doing
    it often, you might want to think about refactoring to an object-oriented design;
    but, on occasion, it makes sense, so we mention it here.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许你嵌套定义函数，这样一个函数内部就可以定义其他函数。内部函数仅对外部函数可访问。通常不需要这样做，如果你经常这么做，可能需要考虑重构为面向对象设计；不过在某些情况下，这样做是有意义的，所以我们在这里提一下。
- en: Finally, one helpful thing to do is to make the default value `None`, enabling
    us inside the function to check whether the value was given by testing if the
    argument is `None`. Any variable holding any type of data can be tested against
    `None`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个有用的做法是将默认值设置为`None`，这样我们可以在函数内部检查是否提供了该值，通过测试参数是否为`None`来判断。任何类型的数据变量都可以与`None`进行比较测试。
- en: Modules
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块
- en: We conclude our whirlwind review of Python with a look at the module system.
    This is akin to the C standard library, and it provides Python with a rich set
    of tools out of the box, all defined as modules. Naturally, users can create their
    own modules as well. A *module*, then, is a collection of functions that can be
    imported into your program. You can also import specific functions from a specific
    module into your own program, rather than the whole module, as long as you’re
    aware of the possibility that the imported function might have the same name as
    a function from another namespace.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过快速回顾 Python 来结束本部分，接着了解模块系统。这类似于 C 标准库，它为 Python 提供了丰富的开箱即用工具，所有工具都定义为模块。当然，用户也可以创建自己的模块。那么，*模块*就是一组可以导入到程序中的函数。你也可以只从特定模块导入特定的函数到你的程序中，而不是导入整个模块，但前提是你要意识到导入的函数可能与另一个命名空间中的函数同名。
- en: By *namespace*, we mean a bag of functions, sort of like a family, where the
    functions are the names of the individuals in the family. All the functions that
    our program knows about are in our namespace. If we import a function from a module,
    that function is now also in our namespace. If we import the entire module and
    refer to the function by prefixing the module name, we get to use the function,
    but it’s not in our namespace. We’ll see shortly why this distinction matters.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在*命名空间*中，我们指的是一组函数，类似于一个家庭，其中函数是家庭成员的名字。我们程序中所知道的所有函数都在我们的命名空间中。如果我们从一个模块导入函数，这个函数现在也在我们的命名空间中。如果我们导入整个模块，并通过模块名前缀来引用函数，那么我们可以使用这个函数，但它不在我们的命名空间中。我们很快会看到为什么这个区别很重要。
- en: 'Let’s see some examples using the modules of the Python library:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些示例来看看如何使用 Python 库的模块：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We first import the `time` module. This means that we now have access to all
    the functions in the `time` module as long as we prefix the function name with
    `time.`. The `time` function of the `time` module returns the current time as
    the number of seconds since January 1, 1970\. Known as the *epoch time*, this
    is useful for timing how long code takes to execute. Because the value returned
    only increases, the difference in epoch time at the start of the code to the end
    of the code indicates the length of time for code execution.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`time`模块。这意味着我们现在可以访问`time`模块中的所有函数，只要我们在函数名前加上`time.`前缀即可。`time`模块中的`time`函数返回自1970年1月1日以来的秒数，这个值被称为*纪元时间*，它对于计算代码执行所需时间非常有用。因为返回的值只会增加，所以从代码开始到结束的纪元时间差值可以表示代码执行的时长。
- en: 'Let’s look at another example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看另一个例子：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, instead of importing the entire `time` module, we import only two functions
    from it. Doing this puts the functions in our namespace so that we can call them
    directly. The `ctime` function returns a string showing the current date and time,
    while the `localtime` function returns the sections of the current time broken
    down by date and time part. Here we show the year at the time of this writing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们没有导入整个`time`模块，而是仅导入了其中的两个函数。这样做将这些函数放入我们的命名空间中，以便我们可以直接调用它们。`ctime`函数返回一个字符串，显示当前的日期和时间，而`localtime`函数则返回当前时间按日期和时间部分拆分后的各部分。这里我们显示了写作时的年份。
- en: 'Our last example shows us why it is often best to import a module directly
    instead of importing functions from it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最后一个例子展示了为什么通常最好直接导入模块，而不是从中导入函数：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First, we define a function we call `sqrt`. This function always returns 4 no
    matter what the argument is. Not particularly useful, of course, but still a valid
    Python function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个名为`sqrt`的函数。无论传入什么参数，这个函数总是返回4。当然，这并不是特别有用，但它仍然是一个有效的Python函数。
- en: Next, let’s import the entire `math` library of functions. This syntax takes
    all the functions in the module and places them in our namespace so we can refer
    to them without using the module name as well. After doing this, we see that `sqrt`
    now returns the actual square root.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们导入整个`math`库的函数。这个语法将模块中的所有函数放入我们的命名空间，这样我们就可以在不使用模块名的情况下直接引用它们。导入后，我们看到`sqrt`现在返回实际的平方根。
- en: What happened to our dubious implementation of `sqrt`? It was masked when we
    imported the entire `math` library because the `math` library also contains a
    function called `sqrt` and, since the `math` library was imported after our `sqrt`
    was defined, the `math` library’s version of `sqrt` takes precedence.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`sqrt`函数实现出了问题吗？当我们导入整个`math`库时，它被覆盖了，因为`math`库中也有一个名为`sqrt`的函数，而由于`math`库在我们的`sqrt`定义之后被导入，因此`math`库中的`sqrt`函数优先被调用。
- en: 'Python’s module library is one of the key strengths of the language in terms
    of utility. The standard library has extensive documentation. For a quick look
    at the list of available Python 3.*X* modules, see *[https://docs.python.org/3/py-modindex.html](https://docs.python.org/3/py-modindex.html)*.
    The main Python site is here: [http://www.python.org/](http://www.python.org/).
    I strongly recommend that you spend some time at these links and really learn
    all that Python has to offer.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Python的模块库是该语言在实用性方面的一个关键优势。标准库有详尽的文档。要快速查看可用的Python 3.*X*模块列表，请访问*[https://docs.python.org/3/py-modindex.html](https://docs.python.org/3/py-modindex.html)*。Python的官方网站是：[http://www.python.org/](http://www.python.org/)。我强烈建议你花一些时间浏览这些链接，真正了解Python所提供的所有功能。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we reviewed the fundamentals of Python to give us the background
    we need to understand the code examples in the remainder of this book. We learned
    about Python syntax and statements. We also examined Python variables and data
    structures, and then explored Python’s suite of control structures and functions,
    ending with a look at Python’s module library.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了Python的基础知识，以便为我们理解本书余下部分的代码示例打下基础。我们学习了Python的语法和语句，还检查了Python的变量和数据结构，接着探索了Python的控制结构和函数，最后了解了Python的模块库。
- en: In the next chapter, we’ll dive into NumPy to see how to make Python even more
    useful to us. NumPy is a core piece of the machine learning toolkit used by virtually
    all machine learning libraries, including the ones we will use in this book.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨NumPy，看看如何让Python对我们更加有用。NumPy是几乎所有机器学习库中使用的核心工具之一，包括本书中我们将使用的库。
- en: '[1.](ch02.xhtml#Rch02fn1) See *Numbers and Computers* by Ronald T. Kneusel
    (Springer-Verlag, 2017).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[1.](ch02.xhtml#Rch02fn1) 参见罗纳德·T·克内塞尔（Ronald T. Kneusel）所著的《*数字与计算机*》（Springer-Verlag，2017年）。'
