- en: '**2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2'
- en: USING PYTHON**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python**
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: If you’re already familiar with Python, you can skip this chapter. This summary
    is for those who are comfortable with programming but who aren’t familiar with
    Python. We’ll cover only enough of the language to be able to read and understand
    the code examples in this book. If you have little to no experience with computer
    programming, you should first read a more complete text like *Python Crash Course*,
    2nd Edition, by Eric Matthes (No Starch Press, 2019).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉 Python，可以跳过本章。本总结是为那些对编程有一定了解但不熟悉 Python 的人准备的。我们只会介绍足够的语言知识，以便能读懂和理解本书中的代码示例。如果你几乎没有计算机编程经验，建议先阅读更完整的书籍，例如
    Eric Matthes 编写的《*Python 编程快速上手*》第二版（No Starch Press，2019）。
- en: Python is, at its simplest, sequential statements grouped into blocks via indentation;
    data structures like numbers, strings, tuples, lists, and dictionaries; control
    structures including if-elif-else, for loops, while loops, with statements, and
    try-except blocks; functions with optional nested functions; and a large library
    of importable modules. We’ll cover each of these features.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的基本构成是：通过缩进将顺序语句组织成块；包括数字、字符串、元组、列表和字典在内的数据结构；包括 if-elif-else、for 循环、while
    循环、with 语句和 try-except 块在内的控制结构；带有可选嵌套函数的函数；以及大量可导入的模块库。我们将逐一介绍这些特性。
- en: The Python Interpreter
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 解释器
- en: 'On a Linux system, Python is typically used in one of two ways. You can run
    the Python interpreter from the command line and enter commands interactively,
    or you can run a script of Python commands. Simply enter python3 in your console
    to use Python interactively:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 系统中，Python 通常以两种方式之一使用。你可以从命令行运行 Python 解释器并交互式地输入命令，或者你可以运行一个 Python
    命令脚本。只需在控制台中输入 python3 来交互式地使用 Python：
- en: $ python3
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: $ python3
- en: Python 3.6.7 (default, Oct 22 2018, 11:32:17)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.6.7（默认，2018年10月22日，11:32:17）
- en: '[GCC 8.2.0] on linux'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[GCC 8.2.0] 在 Linux 上'
- en: Type "help", "copyright", "credits" or "license" for more information.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 输入“help”、“copyright”、“credits”或“license”以获取更多信息。
- en: '>>>'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '>>>'
- en: As you can see, Python opens a prompt for you to enter commands into, beginning
    with >>>. Type an expression like 1+2 and hit ENTER. Python will respond immediately
    by evaluating the equation and passing you the result. When you want to exit the
    console, use CTRL-D.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Python 会为你打开一个提示符，你可以在其中输入命令，提示符以 >>> 开头。输入像 1+2 这样的表达式并按回车键。Python 会立即通过求值该方程并返回结果。当你想退出控制台时，使用
    CTRL-D。
- en: Statements and Whitespace
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语句与空白
- en: 'As in almost every other programming language, unless modified by a control
    flow structure, statements in Python are executed one after the other in the order
    in which they appear in the code. Consider, for example, this code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 和几乎所有其他编程语言一样，除非被控制流结构修改，否则 Python 中的语句按照它们在代码中出现的顺序依次执行。例如，考虑以下代码：
- en: statement1
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: statement1
- en: statement2
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: statement2
- en: statement3
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: statement3
- en: Here statement1 will be executed first, followed by statement2, and then, finally,
    statement3.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，statement1 会首先执行，接着是 statement2，最后是 statement3。
- en: 'Multiple statements can be grouped into units called *blocks*. For example,
    the condition of an if statement evaluating to True could trigger a block to run.
    Syntactically, the statements that go with the if need to be marked in some way
    so that the computer knows which statements to execute. Classic languages like
    Pascal used bulky BEGIN and END keywords. The C family of languages, which includes
    most of the languages in current widespread use, uses curly brackets: “{" and
    “}".'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 多个语句可以组合成称为 *块* 的单元。例如，if 语句的条件为 True 时，可能触发一个块的执行。在语法上，和 if 语句一起使用的语句需要以某种方式标记，以便计算机知道哪些语句需要执行。经典的语言如
    Pascal 使用冗长的 BEGIN 和 END 关键字。C 语言及其衍生语言（包括当前广泛使用的大多数语言）使用大括号：“{” 和 “}”。
- en: 'In Python, we use indentation. This makes reading Python code somewhat elegant
    as it follows the format of a traditional outline. It also makes the code more
    visually consistent across authors and leaves less room for confusion. In Python,
    when we use an if else statement, we can easily see which statements should run
    with which part of the condition, even if we have not yet understood the format
    of the if statement. For example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们使用缩进。这使得 Python 代码在阅读时显得优雅，因为它遵循传统大纲的格式。它还使得不同作者的代码在视觉上保持一致，减少了混淆的空间。在
    Python 中，当我们使用 if else 语句时，即使我们还未完全理解 if 语句的格式，也能很容易地看到哪些语句应当在条件的哪一部分下运行。例如：
- en: 'if condition1:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 'if condition1:'
- en: statement1
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: statement1
- en: statement2
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: statement2
- en: 'else:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: statement3
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: statement3
- en: The indentation makes it clear that statement1 and statement2 are executed when
    condition1 (whatever it is) is true. Similarly, we see that statement3 is executed
    when condition1 is not true.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进清晰地表明，当 condition1（无论是什么）为真时，statement1 和 statement2 会被执行。同样，我们看到当 condition1
    为假时，statement3 会被执行。
- en: Notice the colons in the preceding if example. Python uses these to designate
    blocks of code. You must place a colon after any control statement, and then the
    next line should always be indented one level. If you try to use a control structure
    but don’t provide any statements in the body of the control structure, Python
    will throw an error.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面 if 语句中的冒号。Python 使用冒号来标记代码块。你必须在任何控制语句后加上冒号，然后下一行应该总是缩进一个级别。如果你尝试使用控制结构，但在控制结构的主体中没有提供任何语句，Python
    会抛出一个错误。
- en: 'For example, the else: clause cannot be present without at least one statement
    in the block. If there is no need for the else, just don’t include it. (If you
    really want to include it, use the pass keyword to indicate to Python that you
    know a statement needs to be there, but you really don’t want that condition to
    do anything.)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，else: 子句在块中至少需要有一个语句。如果不需要 else，就不要包括它。（如果你真的想包括它，可以使用 pass 关键字告诉 Python
    你知道这里需要一个语句，但你不希望这个条件做任何事。）'
- en: 'Indentation can seem intimidating to people new to Python, but you can make
    it easier on yourself by properly configuring your text editor. Python convention
    says that you should tell your text editor to do the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进对于新接触 Python 的人来说可能会让人感到害怕，但你可以通过正确配置文本编辑器来让自己更轻松。Python 的约定是，你应该告诉文本编辑器执行以下操作：
- en: Insert spaces in place of tab characters. Shun tab characters like the plague.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用空格代替制表符。像避开瘟疫一样避开制表符。
- en: Insert four spaces every time you hit the T A B key.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次按下 TAB 键时插入四个空格。
- en: Automatically indent when you hit the E N T E R key.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下回车键时会自动缩进。
- en: With these settings, when you enter the “:” of a control statement, just hit
    ENTER, and Python will indent the block automatically.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些设置，当你输入控制语句的 “:” 后，直接按回车，Python 会自动缩进代码块。
- en: The way to configure these settings depends on the text editor used, of course,
    but any text editor worth its salt will be able to do all of these, and many have
    automatic indentation set as standard. If you use integrated development environments
    (IDEs), then it’s probable that once the IDE recognizes that you’re coding in
    Python, most of these conventions will just happen.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 配置这些设置的方式当然取决于所使用的文本编辑器，但任何值得信赖的文本编辑器都能做到这些，许多编辑器将自动缩进设置为标准。如果你使用集成开发环境（IDE），那么一旦
    IDE 识别出你在编写 Python 代码，这些约定大多数会自动生效。
- en: Variables and Basic Data Structures
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量与基本数据结构
- en: Python’s native data structures are simple and elegant. In this section, we’ll
    cover number representation, variables, strings, lists, and dictionaries.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的原生数据结构简单而优雅。在本节中，我们将介绍数字表示、变量、字符串、列表和字典。
- en: Representing Numbers
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 表示数字
- en: 'Numbers in Python are of two kinds: integers or floating-point. *Integers*
    are whole numbers like 42 and 66\. *Floating-point numbers* are those with a decimal
    point like 3.1415 and 2.718\. We’ll ignore complex numbers in this book, although
    Python supports them.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的数字有两种类型：整数或浮点数。*整数*是像 42 和 66 这样的整数。*浮点数*是带小数点的数字，如 3.1415 和 2.718。本书将忽略复数，尽管
    Python 支持复数。
- en: If you don’t include a decimal point, Python will assume you mean an integer;
    otherwise, it will use floating-point numbers. Floating-point numbers can also
    be specified using scientific notation, where 6.022e23 means 6.023 × 10^(23).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不包含小数点，Python 会认为你指的是整数；否则，它会使用浮点数。浮点数也可以使用科学计数法表示，其中 6.022e23 表示 6.023 ×
    10^(23)。
- en: Most programming languages can represent only numbers in a certain range, but
    Python does not have this restriction for integers, which can be as large as there
    is memory to hold them. For fun, enter **2**2001** and see what happens. The many
    ways in which computers store and operate on numbers is quite fascinating. Those
    who are curious might want to look further.^([1](ch02.xhtml#ch02fn1))
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言只能表示一定范围内的数字，但 Python 对整数没有这个限制，整数的大小可以大到计算机内存能够容纳的程度。为了好玩，输入 **2**2001**
    看看会发生什么。计算机存储和操作数字的多种方式相当令人着迷。那些好奇的人可能会想进一步了解。[^(1)](ch02.xhtml#ch02fn1)
- en: Variables
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 变量
- en: '*Variables* provide a useful place to store data for reuse. Fortunately, using
    Python variables is straightforward. Python is *dynamically typed*, which means
    we don’t need to declare the type of data a variable will store in advance. We
    simply assign data to a variable, and Python figures out the type for us.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量* 提供了一个有用的地方来存储数据以便重用。幸运的是，使用 Python 变量非常简单。Python 是 *动态类型* 的，这意味着我们不需要提前声明一个变量将存储的数据类型。我们只需要将数据赋值给一个变量，Python
    会自动推断出数据的类型。'
- en: 'We can even change the type of data stored in a variable by assigning a new
    value, regardless of its type. For example, all of these are valid assignments
    in Python:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以通过赋予新值来改变变量中存储的数据类型，无论新值的数据类型是什么。例如，以下所有赋值在 Python 中都是有效的：
- en: ❶ >>> v = 123
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ >>> v = 123
- en: ❷ >>> n = 3.141592
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ >>> n = 3.141592
- en: ❸ >>> v = 6.022e23
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ >>> v = 6.022e23
- en: 'The code assigns integer 123 to v ❶, the floating-point value 3.141592 to n
    ❷, and then reassigns a floating-point value to v: 6.022 × 10^(23) ❸.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码将整数 123 赋值给 v ❶，将浮点值 3.141592 赋值给 n ❷，然后将一个浮点值赋值给 v：6.022 × 10^(23) ❸。
- en: 'Python variable names are case-sensitive, must start with a letter, and can
    include letters, numbers, and “_” (underscore) characters. Many Python programmers
    follow the camel-case convention of Java, shown here, but this is not strictly
    required:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Python 变量名区分大小写，必须以字母开头，并且可以包含字母、数字和“_”（下划线）字符。许多 Python 程序员遵循 Java 的驼峰命名法，如此例所示，但这不是严格要求的：
- en: '>>> myVariableName=123'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> myVariableName=123'
- en: Strings
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Python supports textual data with strings. You mark the beginning and end of
    *strings* with quotes, either single (’), double (’’), or triple (’’’), as long
    as you use the same for both opening and closing. The triple-quoted string is
    special: it can span multiple lines of text, and you would often use it immediately
    after defining a function to implement a simple documentation string. All of these
    are valid Python strings:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Python 支持使用字符串来处理文本数据。你可以用引号（单引号（’）、双引号（’’）或三引号（’’’））来标记 *字符串* 的开始和结束，只要开头和结尾使用的引号一致。三引号字符串是特殊的：它可以跨越多行文本，通常在定义一个函数后，你会立刻使用它来实现简单的文档字符串。以下所有的都是有效的
    Python 字符串：
- en: '>>> thing1 = ''how now brown cow?'''
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> thing1 = ''how now brown cow?'''
- en: '>>> thing2 = "I don''t think; therefore I am not."'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> thing2 = "I don''t think; therefore I am not."'
- en: '>>> thing3 = """'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> thing3 = """'
- en: one
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: one
- en: two
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: two
- en: three
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: three
- en: '"""'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: Here, thing1 is a simple string; thing2 is also a simple string, but note that
    it has a single quote embedded in it to act as an apostrophe. We can do this because
    we started the string with a double quote character; if we wanted to use double
    quotes inside the string, then we would have to enclose it with single quotes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，thing1 是一个简单的字符串；thing2 也是一个简单的字符串，但注意它内部嵌入了一个单引号，用作撇号。我们之所以能够这样做，是因为我们用双引号字符开始了字符串；如果我们想在字符串内部使用双引号，那么我们就需要用单引号将其括起来。
- en: The last string, thing3, spans multiple lines. The newline characters typed
    to move from one to two are also part of the string, and when printed, they will
    be shown. Note, if you actually enter the assignment to thing3 in the Python interpreter,
    you will see that the interpreter inserts an ellipsis (...). We ignored those
    in the example as they would be confusing and are not really part of the string.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个字符串 thing3 跨越了多行。为了从一行到二行而输入的换行符也属于字符串的一部分，当打印时，它们会被显示出来。请注意，如果你在 Python
    解释器中实际输入对 thing3 的赋值，你会看到解释器插入了省略号（...）。我们在示例中忽略了这些符号，因为它们会让人困惑，且并不真正是字符串的一部分。
- en: Lists
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列表
- en: Strings and numbers are *primitive data types*, meaning they are not made up
    of grouped collections of data. Think of them as atoms. They can be combined into
    more sophisticated data structures by using tuples and lists. A *list* is an ordered
    collection of other data, which could be primitive data or any other collection
    of data. A list can hold lists, for example.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串和数字是 *原始数据类型*，意味着它们不是由一组数据集合组成的。可以把它们想象为原子。它们可以通过使用元组和列表，组合成更复杂的数据结构。*列表*
    是其他数据的有序集合，这些数据可以是原始数据，也可以是任何其他数据集合。例如，一个列表可以包含另一个列表。
- en: Basic List Operations
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 基本的列表操作
- en: 'Unlike with some other data types, the order in which items are appended to
    a list matters. Let’s just jump in with some examples of lists and then talk about
    what’s happening:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他某些数据类型不同，向列表中添加项目的顺序是很重要的。我们先来看看一些列表的例子，再讨论发生了什么：
- en: ❶ >>> t = ["Quednoe","Biggles",39]
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ >>> t = ["Quednoe","Biggles",39]
- en: '>>> t'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t'
- en: '[''Quednoe'', ''Biggles'', 39]'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[''Quednoe'', ''Biggles'', 39]'
- en: ❷ >>> t[0]
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ >>> t[0]
- en: '''Quednoe'''
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '''Quednoe'''
- en: '>>> t[1]'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t[1]'
- en: '''Biggles'''
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '''Biggles'''
- en: '>>> t[2]'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t[2]'
- en: '39'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '39'
- en: First, we define a list ❶. We use a “[” character to start the list, enter the
    items, and end with a “]” character. Items in the list are separated by commas
    (,). This list has three items, as we see when we ask Python to evaluate the expression
    t, which is the list itself.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个列表❶。我们使用“[”字符来开始列表，输入元素，最后用“]”字符结束。列表中的元素由逗号（,）分隔。这个列表有三个元素，当我们要求Python评估表达式t时，我们会看到它的内容。
- en: We can index into lists by using a number and square brackets, just as we would
    an array. Here we ask for the first item in the list using bracket notation ❷.
    We do the same for the second and the third.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用数字和方括号来索引列表，就像操作数组一样。在这里，我们使用括号表示法❷来请求列表中的第一个元素。对于第二个和第三个元素，我们也是一样做的。
- en: 'We can add to a list by using the append method:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用append方法向列表中添加元素：
- en: '>>> t.append(3.14)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t.append(3.14)'
- en: '>>> t'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t'
- en: '[''Quednoe'', ''Biggles'', 39, 3.14]'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[''Quednoe'', ''Biggles'', 39, 3.14]'
- en: Here we see that the list, t, now has a fourth member, 3.14. Note that appending
    an item to a list adds it to the *end* of the list.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们看到列表t现在有了第四个成员3.14。请注意，将元素附加到列表中会将其添加到列表的*末尾*。
- en: Let’s look at a few more examples with lists.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看几个关于列表的例子。
- en: ❶ >>> t[-1]
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ >>> t[-1]
- en: '3.14'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '3.14'
- en: ❷ >>> t[0:2]
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ >>> t[0:2]
- en: '[''Quednoe'', ''Biggles'']'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[''Quednoe'', ''Biggles'']'
- en: ❸ >>> t[1] = 'Melvin'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ >>> t[1] = 'Melvin'
- en: '>>> t'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> t'
- en: '[''Quednoe'', ''Melvin'', 39, 3.14]'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[''Quednoe'', ''Melvin'', 39, 3.14]'
- en: ❹ >>> t.index("Melvin")
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ >>> t.index("Melvin")
- en: '1'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: These examples show us how to use a negative index ❶, which will start at the
    *end* of the list and count backward, so that -1 will always return the last item
    in the list. We also see how to use a range to select a subset of the list ❷.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子展示了如何使用负索引❶，它从列表的*末尾*开始计数，并向后数，因此-1将始终返回列表中的最后一个元素。我们还展示了如何使用范围来选择列表的一个子集❷。
- en: To use Python ranges, follow the format [a:b] to return all items from index
    a to *one less than* b. Mathematically this is [*a*,*b*), where the *b*-th item
    is not included. So, asking for t[0:2] will return items 0 and 1 only. Note, if
    you skip the beginning part or ending part of the range, it defaults to the first
    item (if the beginning is skipped) or the last item (if the ending is skipped).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python的范围时，遵循格式[a:b]来返回从索引a到*比b小1*的所有元素。在数学上，这是[*a*,*b*)，其中*b*索引的元素不包括在内。因此，要求t[0:2]将只返回索引0和1的元素。请注意，如果你跳过了范围的开始部分或结束部分，它会默认到第一个元素（如果跳过开始部分）或最后一个元素（如果跳过结束部分）。
- en: If you use an index on the left side of an assignment statement, that element
    of the list is modified ❸. We now see that the second element of the list has
    changed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在赋值语句的左侧使用索引，则该列表的元素会被修改❸。现在我们看到列表的第二个元素已经改变。
- en: Finally, we use the index method to search the list for an item ❹. If the item
    is found, index returns the index of the item. If the item is not in the list,
    Python will raise an error.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用索引方法来搜索列表中的某个元素❹。如果找到了该元素，index方法会返回元素的索引。如果该元素不在列表中，Python会抛出一个错误。
- en: 'If you want to know if an item is in the list but do not care *where* it is,
    use in, like so:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道某个元素是否在列表中，但不关心它*在哪里*，可以使用in，像这样：
- en: '>>> b = [1,2,3,4]'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = [1,2,3,4]'
- en: '>>> 2 in b'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 2 in b'
- en: 'True'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: '>>> 5 in b'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> 5 in b'
- en: 'False'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: Here the returned values are Booleans, True and False. Note the uppercase on
    True and False. Booleans can be assigned to variables as well. We should also
    mention None, which is Python’s version of NULL as found in other languages (at
    least to a first approximation). We’ll see a good use for None when we talk about
    Python functions in “Functions– on [page 39](ch03.xhtml#page_39).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里返回的值是布尔值，True和False。注意True和False的首字母大写。布尔值也可以赋给变量。我们还应该提到None，它是Python中类似于其他语言中的NULL的版本（至少在初步理解上是如此）。当我们在讲解Python函数时，"Functions–
    on [page 39](ch03.xhtml#page_39)"会看到None的一个好用例子。
- en: Copying Lists
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 复制列表
- en: 'One last thing to note about lists is that Python does not copy lists when
    you assign them to new variables; instead, it points the new variable to the location
    in memory where the list already exists. For example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 关于列表的最后一点需要注意的是，Python在将列表赋值给新变量时并不会复制列表；而是将新变量指向列表已经存在的内存位置。例如：
- en: '>>> a = [0,1,2,3,4]'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = [0,1,2,3,4]'
- en: '>>> a'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a'
- en: '[0, 1, 2, 3, 4]'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 1, 2, 3, 4]'
- en: '>>> b = a'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b = a'
- en: '>>> b'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b'
- en: '[0, 1, 2, 3, 4]'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 1, 2, 3, 4]'
- en: Here we define a as a list of five numbers. We then assign that list to a new
    variable, b, and see that b is, indeed, the same as a.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们将a定义为一个包含五个数字的列表。然后我们将这个列表赋给一个新变量b，发现b确实和a相同。
- en: 'So far, so good. However, what if we decide to change an element of a like
    so:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。然而，如果我们决定像这样更改列表中的某个元素呢：
- en: '>>> a[2] = 3'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a[2] = 3'
- en: '>>> a'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a'
- en: '[0, 1, 3, 3, 4]'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 1, 3, 3, 4]'
- en: '>>> b'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b'
- en: '[0, 1, 3, 3, 4]'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 1, 3, 3, 4]'
- en: We see that a has updated as we desired, but, perhaps surprisingly, so has b.
    This is because assigning a to b points b to the same place in memory as a. It
    does not actually copy the contents of a.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到a如预期已更新，但或许出乎意料的是，b也更新了。这是因为将a赋值给b时，b指向了与a相同的内存位置。它并没有真正复制a的内容。
- en: 'If we want to copy a when we assign it to b, we need to explicitly select all
    the elements of a like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在将a赋值给b时复制a，我们需要像这样显式选择a的所有元素：
- en: ❶ >>> b = a[:]
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ >>> b = a[:]
- en: '>>> a'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a'
- en: '[0, 1, 3, 3, 4]'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 1, 3, 3, 4]'
- en: '>>> b'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b'
- en: '[0, 1, 3, 3, 4]'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 1, 3, 3, 4]'
- en: '>>> a[2] = 2'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a[2] = 2'
- en: '>>> a'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a'
- en: '[0, 1, 2, 3, 4]'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 1, 2, 3, 4]'
- en: '>>> b'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> b'
- en: '[0, 1, 3, 3, 4]'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[0, 1, 3, 3, 4]'
- en: Here we define a list, a, and then assign a to b by selecting all of the elements
    of a ❶. We see that b now looks like a. Next, we update the *third* item in a
    and see that a now looks as we expect, with its third item now 2 instead of 3.
    However, b has not been altered in this case because the original assignment created
    a new list in memory by selecting all the elements of a.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个列表a，然后通过选择a的所有元素将a赋值给b❶。我们看到b现在看起来像a。接下来，我们更新a中的*第三*项，看到a现在看起来如我们所预期，第三项从3变成了2。然而，b并没有被改变，因为最初的赋值通过选择a的所有元素在内存中创建了一个新的列表。
- en: The reason Python doesn’t automatically copy lists is that lists can be large,
    so copying them unnecessarily would waste a lot of memory. Completely copying
    a list made up of other, nested, lists can be nontrivial. The selecting everything
    method ❶ makes only a shallow copy—nested elements are still aliased. Use the
    deepcopy function of the copy module to recursively copy all levels of a list
    with nested elements.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Python不自动复制列表的原因是列表可能很大，因此不必要的复制会浪费大量内存。完全复制由其他嵌套列表组成的列表可能并不简单。选择一切的方法❶只会进行浅拷贝——嵌套元素仍然是别名。使用copy模块的deepcopy函数可以递归地复制具有嵌套元素的列表的所有级别。
- en: Python has another data type similar to a list called a *tuple*. Tuples, defined
    with parentheses rather than square brackets, are just like lists except that
    once defined, they cannot be modified. In general, we will stick with lists, but
    NumPy uses tuples from time to time (see [Chapter 3](ch03.xhtml#ch03)).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Python还有一种与列表类似的数据类型，叫做*元组*。元组用圆括号定义，而不是方括号，它们与列表非常相似，只是一旦定义后，元组不能被修改。通常情况下，我们会使用列表，但NumPy偶尔也会使用元组（参见[第3章](ch03.xhtml#ch03)）。
- en: Dictionaries
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字典
- en: 'The last data type we’ll look at is the *dictionary*. A dictionary is made
    up of a set of keys, each associated with a value. You define dictionaries with
    “{” and “}” characters. As with a list, the value can be anything, including another
    dictionary. They key is typically a string but can be a number or other object
    as well. You define a dictionary like so:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要看的最后一种数据类型是*字典*。字典由一组键组成，每个键都与一个值关联。你可以用“{”和“}”字符定义字典。与列表类似，字典的值可以是任何类型，包括另一个字典。键通常是字符串，但也可以是数字或其他对象。你可以这样定义字典：
- en: '>>> d = {"a":1, "b":2, "c":3}'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d = {"a":1, "b":2, "c":3}'
- en: '>>> d.keys()'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d.keys()'
- en: dict_keys(['a', 'b', 'c'])
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: dict_keys(['a', 'b', 'c'])
- en: This example shows how to define the dictionary by directly listing its contents.
    The elements of the dictionary are given as key:value pairs. Here, the keys are
    all strings, and the value associated with each key is an integer. The keys method
    returns all the keys in the dictionary.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了如何通过直接列出字典的内容来定义字典。字典的元素是键:值对。在这里，所有键都是字符串，与每个键关联的值是整数。keys方法返回字典中的所有键。
- en: 'The syntax above is useful when the contents of the dictionary are already
    known. Typically, this isn’t the case. Most of the time, the dictionary is defined,
    and we add elements individually:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语法在字典内容已知的情况下非常有用。但通常并非如此。大多数情况下，字典已经定义，我们会逐个添加元素：
- en: '>>> d = {}'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d = {}'
- en: '>>> d["a"] = 1'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d["a"] = 1'
- en: '>>> d["b"] = 2'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d["b"] = 2'
- en: '>>> d["c"] = 3'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d["c"] = 3'
- en: Here we define an empty dictionary d, and individually assign values for a new
    set of keys. If the key already exists in the dictionary d, its value is updated.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们定义了一个空字典d，并为一组新键逐个赋值。如果键在字典d中已存在，它的值会被更新。
- en: 'To get the value associated with a particular key, just index the dictionary
    with the key:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取与特定键关联的值，只需用该键索引字典：
- en: '>>> d["b"]'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> d["b"]'
- en: '2'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: 'If the key doesn’t exist in that dictionary, Python will raise an error. To
    test if a key is in the dictionary, use in, like so:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字典中没有该键，Python会抛出一个错误。要测试一个键是否在字典中，可以使用in，像这样：
- en: '>>> "c" in d'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> "c" in d'
- en: 'True'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: 'Between lists and dictionaries, you can conveniently store almost any data.
    This is one of the benefits of a language like Python: programmers can devote
    energy to completing the task at hand instead of implementing complicated data
    structures. Lists and dictionaries are fast to use and generally all you’ll need
    unless you’re doing scientific programming, in which case we have NumPy, as discussed
    in [Chapter 3](ch03.xhtml#ch03).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表和字典之间，你几乎可以方便地存储任何数据。这是像Python这样的语言的一个优点：程序员可以将精力集中在完成手头的任务上，而不是实现复杂的数据结构。列表和字典使用起来非常迅速，通常情况下它们是你所需要的，除非你在做科学编程，在这种情况下，我们有NumPy，正如在[第3章](ch03.xhtml#ch03)中讨论的那样。
- en: Control Structures
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制结构
- en: 'Python implements several *control structures* to allow you to alter program
    flow using syntax. We’ll look at these:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Python实现了几种*控制结构*，允许你通过语法改变程序的执行流程。我们将介绍这些结构：
- en: if-elif-else
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: if-elif-else语句
- en: for loops
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: for循环
- en: while loops
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: while循环
- en: with statements
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: with语句
- en: try-except blocks
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: try-except块
- en: if-elif-else Statements
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: if-elif-else语句
- en: 'An if statement makes a decision. You give it a condition that must result
    in a Boolean value, True or False. If the condition is true, the first block of
    the if statement is executed. If the condition is false, nothing happens and the
    code moves past the if statement, unless you include an else, in which case the
    body of the else will be executed. You can test multiple conditions in one statement
    by using the elif keyword, which adds additional conditions with their own blocks
    of code to run. For example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: if语句用于做决策。你给它一个必须返回布尔值True或False的条件。如果条件为真，if语句的第一个代码块就会执行。如果条件为假，则什么都不会发生，代码会跳过if语句，除非你包含了else语句，在这种情况下，else语句的代码块会被执行。你可以通过使用elif关键字在一个语句中测试多个条件，它会添加额外的条件及其自己的代码块。举个例子：
- en: ❶ >>> disc = b**2 - 4*a*c
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ >>> disc = b**2 - 4*a*c
- en: '❷ >>> if (disc < 0):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ >>> if (disc < 0):'
- en: print("imaginary")
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: print("虚数")
- en: '❸ elif (disc == 0):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ elif (disc == 0):'
- en: print("single real")
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: print("实数")
- en: 'else:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: ❹ print("two real")
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ print("两个实数")
- en: 'This checks the discriminant of a quadratic polynomial, *ax*² + *bx* + *c*,
    to identify the number and type of solution: a real number, a pair of real numbers,
    or imaginary numbers. The solutions are the values of *x* that make the polynomial
    equal to zero.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码检查二次多项式*ax*² + *bx* + *c*的判别式，以确定解的数量和类型：实数解、一对实数解或虚数解。解是使多项式等于零的*x*值。
- en: First, the code calculates the discriminant value (disc) ❶. It then asks if
    the value is less than zero ❷. If it is, it means there are two imaginary solutions.
    If the discriminant is exactly zero ❸, there’s only one solution, a real number.
    Finally, the else executes if neither of the conditions is true; in this case,
    it means there are two real-number solutions ❹. The parentheses around the conditions
    are not required but can help with readability. Also note that Python uses “**”
    for exponentiation so that b**2-4*a*c = *b*² *–* 4*ac*. You can use as many elif
    clauses as needed, including none, followed by an optional final else. Python
    lacks the case or switch statements found in other common programming languages.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码计算判别式值（disc）❶。然后它检查该值是否小于零❷。如果是，说明有两个虚数解。如果判别式恰好为零❸，则只有一个解，即一个实数。最后，如果两个条件都不成立，else语句就会执行；在这种情况下，意味着有两个实数解❹。条件周围的括号并不是必须的，但有助于提高可读性。还要注意，Python使用“**”进行幂运算，因此b**2-4*a*c等于*b*²
    *–* 4*ac*。你可以根据需要使用任意数量的elif语句（可以没有），后面跟一个可选的else语句。Python没有其他常见编程语言中的case或switch语句。
- en: for Loops
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: for 循环
- en: Almost all structured programming languages have loops to run a particular block
    of code repeatedly. In this section, we’ll cover a few kinds in Python.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有结构化编程语言都有循环，可以反复执行某个特定的代码块。在这一节中，我们将介绍Python中的几种循环。
- en: Python’s primary looping construct is the for loop. In other languages, typically
    for loops are counted loops from some starting value to an ending value that increments
    by some fixed amount. In Python, loops run over objects that can be iterated through,
    things that have a next method. This includes the characters of a string, the
    elements of a list or tuple, or the elements of a dictionary.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Python的主要循环结构是for循环。在其他语言中，for循环通常是从某个起始值到结束值的计数循环，按固定的增量递增。在Python中，循环遍历可以迭代的对象，即具有next方法的事物。这包括字符串的字符、列表或元组的元素，或字典的元素。
- en: 'Python has two built-in functions that are quite handy with loops. The first
    is range, which creates a generator object that produces integers in order, starting
    with 0 unless otherwise specified:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有两个内建函数，和循环一起使用时非常方便。第一个是 `range`，它创建一个生成器对象，按顺序生成整数，默认从 0 开始，除非另有指定：
- en: '❶ >>> for i in range(6):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ >>> for i in range(6):'
- en: print(i)
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: print(i)
- en: '0'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '5'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: The range function ❶ returns the values 0...5, and the for statement assigns
    the values one at a time to i for each iteration of the loop. Here we simply print
    the current value of i using the built-in Python function, print.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`range` 函数 ❶ 返回 0...5 的值，`for` 语句将这些值逐一赋给 i，直到循环结束。这里我们简单地使用内建的 `print` 函数打印当前的
    i 值。'
- en: 'Another useful function to use with for loops is enumerate. This function returns
    two values. The first is the index of the current element of its argument and
    the second is the element itself. An example will clarify:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在 `for` 循环中非常有用的函数是 `enumerate`。这个函数返回两个值，第一个是当前元素的索引，第二个是该元素本身。一个例子会更清楚地说明：
- en: '>>> x = ["how","now","brown","cow"]'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = ["how","now","brown","cow"]'
- en: '>>> for i in x: ❶'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for i in x: ❶'
- en: print(i)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: print(i)
- en: how
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: how
- en: now
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: now
- en: brown
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: brown
- en: cow
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: cow
- en: '>>> for i,v in enumerate(x): ❷'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for i,v in enumerate(x): ❷'
- en: print(i,v)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: print(i,v)
- en: 0 how
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 0 how
- en: 1 now
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 1 now
- en: 2 brown
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 2 brown
- en: 3 cow
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 3 cow
- en: 'In the first loop over just the list x ❶, we get each element of x assigned
    to i for each iteration. The second loop uses enumerate and gives us *two* values
    for each iteration: the current index, stored in i, and the current element of
    the list x, stored in v ❷. Python is capable of assigning multiple parts to multiple
    variables at the same time. In this case, the loop body prints the index followed
    by the element at that index.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个只遍历列表 x 的循环 ❶ 中，我们将列表 x 的每个元素按顺序赋值给 i。第二个循环使用 `enumerate`，每次迭代时返回 *两个* 值：当前的索引存储在
    i 中，当前列表元素存储在 v 中 ❷。Python 能够同时将多个部分赋值给多个变量。在这个例子中，循环体打印的是索引后跟着该索引对应的元素。
- en: 'What happens when we use a for loop with a dictionary? Let’s see:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对字典使用 `for` 循环时会发生什么？让我们来看看：
- en: ❶ >>> d = {"a":1, "b":2, "c":2.718}
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ >>> d = {"a":1, "b":2, "c":2.718}
- en: '❷ >>> for i in d:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ >>> for i in d:'
- en: print(i)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: print(i)
- en: a
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: a
- en: b
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: b
- en: c
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: c
- en: '❸ >>> for i in d:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ >>> for i in d:'
- en: print(i, d[i])
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: print(i, d[i])
- en: a 1
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: a 1
- en: b 2
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: b 2
- en: c 2.718
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: c 2.718
- en: Here we first define a dictionary, d, with three keys ❶. If we simply loop over
    the dictionary variable, we will be given the keys ❷. However, if we then use
    the key to return the associated value, as in the second loop ❸, we’ll iterate
    over the entire dictionary, accessing each value exactly once.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先定义了一个字典 d，包含三个键 ❶。如果我们简单地遍历字典变量，我们会得到这些键 ❷。但是，如果我们使用键来返回相关的值，如第二个循环
    ❸ 所示，我们就能遍历整个字典，每次只访问一个值。
- en: 'One particularly attractive feature of Python is that we can combine a for
    loop with a list in a *list comprehension*. A list comprehension starts out as
    a list with a leading “[”, but instead of listing the individual elements, the
    body of the list is actually code that generates the list. This shorthand takes
    a bit of getting used to, but once you’re familiar with it, you’ll see that it’s
    an efficient replacement for many for loops. For example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的一个特别吸引人的特性是我们可以将 `for` 循环与列表结合使用，形成 *列表推导式*。列表推导式开始时是一个以“[”为开头的列表，但它的主体实际上是生成该列表的代码，而不是列出单个元素。这种简写法需要一些时间来适应，但一旦熟悉后，你会发现它是许多
    `for` 循环的高效替代方法。例如：
- en: ❶ >>> import random
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ >>> import random
- en: '>>> a = []'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> a = []'
- en: '>>> for i in range(10000):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for i in range(10000):'
- en: ❷         a.append(random.random())
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: ❷         a.append(random.random())
- en: ❸ >>> b = [random.random() for i in range(10000)]
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ >>> b = [random.random() for i in range(10000)]
- en: ❹ >>> m3 = [i for i in range(10000) if (i % 3) == 0]
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ >>> m3 = [i for i in range(10000) if (i % 3) == 0]
- en: We first import the standard random number library ❶ and then fill the list
    a with 10,000 random numbers in the range [0,1) (meaning 0 is included, 1 is not)
    ❷. Next, we also fill b with 10,000 random numbers but do so using a list comprehension
    ❸. Note that the syntax is the same as when we define a list with values, but
    here the body of the list is something that *returns* a value. In this case, it’s
    a call to random.random() and a for loop over 10,000 elements.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入标准的随机数库 ❶，然后用范围 [0,1) 内的 10,000 个随机数填充列表 a（表示包括 0，但不包括 1） ❷。接着，我们也用列表推导式填充
    b，生成 10,000 个随机数 ❸。注意，语法与定义值的列表相同，但这里列表的主体是一个 *返回* 值的代码块。在这个例子中，它是对 `random.random()`
    的调用，并对 10,000 个元素执行 `for` 循环。
- en: The last example creates a list, m3, of all multiples of 3, including 0, less
    than 10,000 ❹. The if clause is the test that decides whether a particular i value
    will be in the list. The percent operator is *modulo*, which gives the remainder
    after division. In this case, it’s asking if the remainder after dividing i by
    3, using integer division, is zero. If it is, there is no remainder, which means
    i is a multiple of 3 (or 0).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例创建了一个列表 m3，包含所有小于 10,000 且是 3 的倍数的数值❹。if 子句是用于测试某个 i 值是否会包含在列表中的条件。百分号操作符是
    *取模运算*，它返回除法后的余数。在这种情况下，它是在判断 i 除以 3（使用整数除法）的余数是否为零。如果是零，表示没有余数，也就是说 i 是 3 的倍数（或者是
    0）。
- en: while Loops
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: while 循环
- en: 'Many programming languages include both top-tested and bottom-tested loops.
    A *top-tested loop* tests the loop condition at the beginning, before executing
    any of the body, and if the test is not true, the body is never executed. A *bottom-tested
    loop* executes the body at least once and *then* tests to see if the loop should
    execute again. The while loop in C is a top-tested loop and the do...while loop
    is a bottom-tested loop. Python has only a top-tested while loop with the following
    syntax:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言包括顶测循环和底测循环。*顶测循环* 在执行循环体之前先测试循环条件，如果测试不为真，循环体将永远不会执行。*底测循环* 至少执行一次循环体，然后才测试是否应该再次执行循环。在
    C 中，while 循环是顶测循环，而 do...while 循环是底测循环。Python 只有顶测的 while 循环，其语法如下：
- en: ❶ >>> i = 0
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ >>> i = 0
- en: '❷ >>> while (i < 4):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ >>> while (i < 4):'
- en: print(i)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: print(i)
- en: ❸ i += 1
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ i += 1
- en: '0'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: We have to initialize the loop control variable (i) with a 0 *before* we start
    the loop ❶ so that the condition i < 4 is true to begin with ❷. Also note that
    we explicitly increment i at the end of the body of the loop ❸. The expression
    i += 1 is shorthand for i = i + 1 and increments i by 1\. Python doesn’t support
    C-style increment and decrement such as i ++. If you try it, Python will kindly
    let you know with a SyntaxError.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在开始循环❶之前初始化循环控制变量 (i)，以确保条件 i < 4 一开始就为真❷。还要注意，我们显式地在循环体的末尾递增 i❸。表达式 i +=
    1 是 i = i + 1 的简写，并将 i 增加 1。Python 不支持 C 风格的递增和递减运算符，例如 i ++。如果你尝试这么做，Python 会亲切地告诉你一个语法错误（SyntaxError）。
- en: The while loop repeats as long as the condition evaluates to True. It’s up to
    the programmer to do things in the loop body that will eventually make the condition
    False so the loop will end. You can also manually exit the loop, as you’ll see
    in the following section.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: while 循环会一直重复执行，只要条件评估为 True。程序员需要在循环体内做些事情，使得条件最终变为 False，从而结束循环。你也可以手动退出循环，如下文所示。
- en: break and continue Statements
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: break 和 continue 语句
- en: 'The for and while loops work with two other Python statements: to immediately
    exit the loop, use the break statement; to immediately move to the next iteration,
    use continue. One common use of break is to leave an infinite loop:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: for 和 while 循环与另外两条 Python 语句一起使用：要立即退出循环，使用 break 语句；要立即跳到下一次迭代，使用 continue。break
    的一个常见用法是跳出一个无限循环：
- en: '>>> i = 0'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> i = 0'
- en: '>>> while True:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> while True:'
- en: print(i)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: print(i)
- en: i += 1
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: i += 1
- en: 'if (i == 4):'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 'if (i == 4):'
- en: ❶ break
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ break
- en: '0'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: This produces the same output as the earlier while loop example, but exits the
    loop explicitly via break when the termination condition is met ❶; here, that’s
    when i is incremented up to 4\. Using break for this toy example does not really
    make sense since there are other, clearer ways to do this, but often the loop
    might need to execute until the program ends or until some other rare situation
    or error occurs. For example, the command line interpreter will keep checking
    for keyboard input. As each character comes in, it is added to a buffer. However,
    if the character is a “newline,” it breaks out of the loop and interprets the
    contents of the buffer.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生与之前的 while 循环示例相同的输出，但当满足终止条件时，通过 break 显式退出循环❶；在这里，当 i 增加到 4 时终止。使用 break
    对这个示例来说并不完全合适，因为有其他更清晰的方式来实现这个功能，但通常循环可能需要一直执行，直到程序结束，或者直到某些其他罕见的情况或错误发生。例如，命令行解释器会不断检查键盘输入。每次输入字符时，它都会添加到缓冲区。然而，如果字符是“换行符”，它会跳出循环并解释缓冲区的内容。
- en: 'The continue statement iterates the loop without executing any body statements
    after it. For example:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: continue 语句会跳过循环体中它后面的所有语句，继续执行下一次循环。例如：
- en: '>>> for i in range(4):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for i in range(4):'
- en: print(i)
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: print(i)
- en: ❶ continue
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ continue
- en: print("xyzzy")
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: print("xyzzy")
- en: '0'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: Here the presence of continue ❶ ensures that the second print statement is never
    executed.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，continue 语句❶ 确保了第二个 print 语句永远不会被执行。
- en: with Statement
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: with 语句
- en: 'The Python with statement is useful when dealing with files. For example, the
    following code uses a with statement to open a file on disk and read its contents
    into a string:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`with`语句在处理文件时非常有用。例如，以下代码使用`with`语句打开磁盘上的一个文件，并将其内容读取到一个字符串中：
- en: '>>> with open("sesame") as f:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> with open("sesame") as f:'
- en: s = f.read()
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: s = f.read()
- en: '>>> s'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> s'
- en: '''this is a file\n'''
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '''this is a file\n'''
- en: The with statement opens a file called *sesame* and assigns the file object
    to f. We then use the read method to read the entire file as a string and assign
    it to s. Evaluating s shows us that the file contains the string “this is a file”
    with a newline character at the end.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`语句打开了一个名为*sesame*的文件，并将文件对象赋值给f。然后我们使用`read`方法读取整个文件并将其作为字符串赋值给s。评估s时，我们看到文件包含字符串“this
    is a file”，并且末尾有一个换行符。'
- en: Note that the example above uses open and read but doesn’t explicitly close
    the file when done. This is because when the with statement exits, the close method
    is called automatically as f leaves scope (meaning f is defined only within the
    body of the with statement).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上面的示例使用了`open`和`read`，但在完成后并没有显式关闭文件。这是因为当`with`语句退出时，`close`方法会自动调用，因为f超出了作用域（意味着f仅在`with`语句的代码块内定义）。
- en: Handling Errors with try-except Blocks
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`try-except`块处理错误
- en: Finally, let’s take a quick look at Python’s ability to trap and process errors,
    rather than let errors halt our programs. Again, we’ll just look at a quick skeleton
    of Python’s error-control abilities as an aid to debugging.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们快速看一下Python如何捕获和处理错误，而不是让错误停止我们的程序。同样，我们只会看一下Python错误控制能力的简要框架，作为调试的辅助工具。
- en: 'To capture an error instead of letting it stop program execution, we can encapsulate
    the statements that might cause the error with a try...except block. If an error
    is raised by any of the statements after the try and before the except, it will
    be caught and execution will pass to the statements of the except clause. The
    example here shows how to catch *any* error that happens within the statements
    enclosed by the try block; though it’s useful to know that Python has a rich set
    of error types, and users can define their own:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获错误而不是让它停止程序执行，我们可以将可能导致错误的语句封装在`try...except`块中。如果在`try`和`except`之间的任何语句引发了错误，它将被捕获，执行会跳到`except`语句块中的内容。这里的示例展示了如何捕获`try`块内任何可能发生的*错误*；虽然值得注意的是，Python有丰富的错误类型，并且用户可以定义自己的错误类型：
- en: '>>> x = 1.0/0.0'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x = 1.0/0.0'
- en: 'Traceback (most recent call last):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 'Traceback (most recent call last):'
- en: File "<stdin>", line 1, in <module>
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: File "<stdin>", line 1, in <module>
- en: 'ZeroDivisionError: float division by zero'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 'ZeroDivisionError: 浮点数除以零'
- en: '>>> try:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> try:'
- en: x = 1.0/0.0
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: x = 1.0/0.0
- en: 'except:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 'except:'
- en: x = 0
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: x = 0
- en: '>>> x'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> x'
- en: '0'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: Here we first attempt to assign the result of a division by zero to x. This
    fails with the given error message from Python. However, if we wrap the assignment
    in a try block, Python will move to the x = 0 line of the except block and assign
    x = 0 as shown.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们首先尝试将除以零的结果赋值给x。这个操作会失败，并返回Python给出的错误信息。然而，如果我们将赋值操作包裹在一个`try`块内，Python会跳转到`except`块中的x
    = 0语句，并将x赋值为0，如下所示。
- en: 'If you’re not using a sophisticated Python programming environment that supports
    breaks while executing code, the following construct is useful, as it halts execution
    when encountered. Here it halts execution immediately after the divide-by-zero
    error occurs:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用支持在执行代码时跳出执行的高级Python编程环境，那么下面的结构很有用，因为它会在遇到时停止执行。在这里，它会在发生除零错误后立即停止执行：
- en: '>>> try:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> try:'
- en: x = 1.0/0.0
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: x = 1.0/0.0
- en: 'except:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 'except:'
- en: import pdb; pdb.set_trace()
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: import pdb; pdb.set_trace()
- en: When an error occurs, the pdb module will be imported, if it hasn’t been already,
    and the set_trace function will be called to enter into a debugging environment.
    Of course, pdb.set_trace() can be called at any point in the code—it need not
    be inside of a try...except block.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生错误时，`pdb`模块会被导入（如果尚未导入），并调用`set_trace`函数进入调试环境。当然，`pdb.set_trace()`可以在代码的任何位置调用——它不一定要在`try...except`块内部。
- en: Functions
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: 'You define a function in Python with the def keyword followed by the function
    name and a list of arguments the function will take in parentheses. Even if you
    include no arguments, you must include a pair of parentheses. Since Python is
    dynamically typed, you list the parameters of the function but no type information.
    You can, if necessary, also include default values. Again, we are ignoring Python’s
    object-oriented abilities and just focusing on a small section of what we can
    do with functions. Let’s define a simple function:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你使用 `def` 关键字定义一个函数，后跟函数名以及函数将接受的参数列表，参数放在括号中。即使你不包括任何参数，也必须包含一对括号。由于
    Python 是动态类型的，你列出函数的参数，但不包含类型信息。如果有必要，你也可以提供默认值。同样，我们忽略 Python 的面向对象能力，只关注我们可以用函数做的一小部分。让我们定义一个简单的函数：
- en: '>>> def product(a,b):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> def product(a,b):'
- en: return a*b
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: return a*b
- en: '>>> product(4,5)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> product(4,5)'
- en: '20'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: This function is called product and it accepts two arguments that we will refer
    to in the function as a and b. The body of this function consists of a single
    statement—a return statement, which returns to the point in the code where product
    was called with the given value, here the product of the two arguments. If we
    test this function, then we see that it does indeed multiply its arguments.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数叫做 `product`，它接受两个参数，我们将在函数内部将其称为 `a` 和 `b`。这个函数的主体由一个语句组成——一个 `return`
    语句，它将返回到调用 `product` 时的代码位置，并返回给定的值，这里是两个参数的乘积。如果我们测试这个函数，我们会看到它确实会将两个参数相乘。
- en: 'Next, let’s redefine product and supply a default value for the second argument
    using the following code:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们重新定义 `product` 函数，并为第二个参数提供一个默认值，使用以下代码：
- en: '>>> def product(a,b=3):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> def product(a,b=3):'
- en: return a*b
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: return a*b
- en: '>>> product(4,5)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> product(4,5)'
- en: '20'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '20'
- en: '>>> product(3)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> product(3)'
- en: '9'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: We supply default values in the argument list of the function. If we use two
    arguments, Python will assign the value of the second argument inside the function
    as before. However, if we do not supply a second argument, Python will use the
    given default value of 3, giving us a meaningful return value of 3 × 3 = 9\. Supplying
    a default value to a function argument makes it a keyword parameter, and, as we
    see above, we do not need to supply a value for that argument when we invoke the
    function. This technique is particularly handy, and we will see it in our code
    examples from time to time.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数的参数列表中提供默认值。如果我们使用两个参数，Python 会像以前一样在函数内部分配第二个参数的值。然而，如果我们不提供第二个参数，Python
    会使用给定的默认值 `3`，从而给我们返回一个有意义的结果 `3 × 3 = 9`。为函数参数提供默认值使其成为关键字参数，正如我们上面看到的那样，在调用函数时我们不需要为该参数提供值。这种技巧非常方便，我们将在我们的代码示例中不时看到它。
- en: 'Our final example below shows how to define a function that accepts no arguments:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下面的最终示例展示了如何定义一个不接受任何参数的函数：
- en: '>>> def pp():'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> def pp():'
- en: print("plugh")
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: print("plugh")
- en: '>>> pp()'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> pp()'
- en: plugh
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: plugh
- en: The function pp has an empty argument list. The only statement in the body of
    the function prints the word *plugh*. There is no return value.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`pp` 函数有一个空的参数列表。函数主体中的唯一语句是打印单词 *plugh*。没有返回值。'
- en: Python allows you to nest function definitions so that a function can itself
    have functions defined within it. The inner functions are accessible to only the
    outer function. There is seldom a need to do this, and if you find yourself doing
    it often, you might want to think about refactoring to an object-oriented design;
    but, on occasion, it makes sense, so we mention it here.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许你嵌套函数定义，这样一个函数本身可以在内部定义其他函数。内部函数仅对外部函数可访问。通常情况下，不需要这样做，如果你发现自己经常这么做，可能需要考虑重构为面向对象设计；但偶尔这种做法是有意义的，所以我们在这里提到它。
- en: Finally, one helpful thing to do is to make the default value None, enabling
    us inside the function to check whether the value was given by testing if the
    argument is None. Any variable holding any type of data can be tested against
    None.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一个有用的做法是将默认值设为 `None`，使得我们可以在函数内部检查是否提供了值，通过测试参数是否为 `None`。任何持有任何类型数据的变量都可以与
    `None` 进行测试。
- en: Modules
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块
- en: We conclude our whirlwind review of Python with a look at the module system.
    This is akin to the C standard library, and it provides Python with a rich set
    of tools out of the box, all defined as modules. Naturally, users can create their
    own modules as well. A *module*, then, is a collection of functions that can be
    imported into your program. You can also import specific functions from a specific
    module into your own program, rather than the whole module, as long as you’re
    aware of the possibility that the imported function might have the same name as
    a function from another namespace.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: By *namespace*, we mean a bag of functions, sort of like a family, where the
    functions are the names of the individuals in the family. All the functions that
    our program knows about are in our namespace. If we import a function from a module,
    that function is now also in our namespace. If we import the entire module and
    refer to the function by prefixing the module name, we get to use the function,
    but it’s not in our namespace. We’ll see shortly why this distinction matters.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see some examples using the modules of the Python library:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '>>> import time'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '>>> time.time()'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '1524693601.402852'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: We first import the time module. This means that we now have access to all the
    functions in the time module as long as we prefix the function name with time..
    The time function of the time module returns the current time as the number of
    seconds since January 1, 1970\. Known as the *epoch time*, this is useful for
    timing how long code takes to execute. Because the value returned only increases,
    the difference in epoch time at the start of the code to the end of the code indicates
    the length of time for code execution.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at another example:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '>>> from time import ctime, localtime'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '>>> ctime()'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '''Wed Apr 25 16:00:21 2020'''
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '>>> localtime().tm_year'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '2018'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Here, instead of importing the entire time module, we import only two functions
    from it. Doing this puts the functions in our namespace so that we can call them
    directly. The ctime function returns a string showing the current date and time,
    while the localtime function returns the sections of the current time broken down
    by date and time part. Here we show the year at the time of this writing.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Our last example shows us why it is often best to import a module directly
    instead of importing functions from it:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '>>> def sqrt(x):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: return 4
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '>>> sqrt(2)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '>>> from math import *'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '>>> sqrt(2)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '1.4142135623730951'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: First, we define a function we call sqrt. This function always returns 4 no
    matter what the argument is. Not particularly useful, of course, but still a valid
    Python function.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s import the entire math library of functions. This syntax takes all
    the functions in the module and places them in our namespace so we can refer to
    them without using the module name as well. After doing this, we see that sqrt
    now returns the actual square root.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: What happened to our dubious implementation of sqrt? It was masked when we imported
    the entire math library because the math library also contains a function called
    sqrt and, since the math library was imported after our sqrt was defined, the
    math library’s version of sqrt takes precedence.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的sqrt实现出了什么问题？当我们导入整个数学库时，它被覆盖了，因为数学库中也包含一个叫做sqrt的函数，而由于数学库是在我们定义sqrt之后导入的，因此数学库中的sqrt版本优先使用。
- en: 'Python’s module library is one of the key strengths of the language in terms
    of utility. The standard library has extensive documentation. For a quick look
    at the list of available Python 3.*X* modules, see *[https://docs.python.org/3/py-modindex.html](https://docs.python.org/3/py-modindex.html)*.
    The main Python site is here: [http://www.python.org/](http://www.python.org/).
    I strongly recommend that you spend some time at these links and really learn
    all that Python has to offer.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Python的模块库是该语言在实用性方面的一个关键优势。标准库有着丰富的文档。想要快速查看Python 3.*X*模块的列表，请访问 *[https://docs.python.org/3/py-modindex.html](https://docs.python.org/3/py-modindex.html)*。Python的官方网站是：[http://www.python.org/](http://www.python.org/)。我强烈建议你花些时间浏览这些链接，真正了解Python能提供的所有功能。
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we reviewed the fundamentals of Python to give us the background
    we need to understand the code examples in the remainder of this book. We learned
    about Python syntax and statements. We also examined Python variables and data
    structures, and then explored Python’s suite of control structures and functions,
    ending with a look at Python’s module library.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了Python的基础知识，为理解本书其余部分的代码示例打下了基础。我们学习了Python的语法和语句，接着研究了Python的变量和数据结构，并探索了Python的控制结构和函数，最后了解了Python的模块库。
- en: In the next chapter, we’ll dive into NumPy to see how to make Python even more
    useful to us. NumPy is a core piece of the machine learning toolkit used by virtually
    all machine learning libraries, including the ones we will use in this book.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨NumPy，看看如何使Python对我们更有用。NumPy是几乎所有机器学习库中都使用的核心工具，也是我们在本书中将要使用的库之一。
- en: '[1.](ch02.xhtml#Rch02fn1) See *Numbers and Computers* by Ronald T. Kneusel
    (Springer-Verlag, 2017).'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '[1.](ch02.xhtml#Rch02fn1) 请参阅**罗纳德·T·克努瑟尔**的《*数字与计算机*》（Springer-Verlag，2017）。'
