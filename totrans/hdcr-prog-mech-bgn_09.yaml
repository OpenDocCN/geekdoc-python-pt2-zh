- en: '7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AFFINE TRANSFORMATIONS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If I had to choose my favorite topic from this book, it would be affine transformations.
    There’s something oddly beautiful about affine transformations, as you’ll see
    for yourself in [Chapter 12](ch12.xhtml#ch12) when we animate them.
  prefs: []
  type: TYPE_NORMAL
- en: Affine transformations are crucial to 2D graphic applications; they determine
    how to pan, zoom, and rotate what you see on the screen. If you’ve used AutoCAD,
    you’re pretty much used to zooming in to a portion of the drawing, which is done
    with an affine transformation. Whenever you scale and rotate your pics in Instagram,
    an affine transformation does the trick. Mastering this topic is essential for
    writing any piece of software involving graphics, even more so for those where
    the user is allowed to interact with them.
  prefs: []
  type: TYPE_NORMAL
- en: The math behind affine transformations is quite simple, yet the concept is stunningly
    powerful. By the end of this chapter, you’ll have a class representing these transformations
    with methods to apply them to geometric primitives. We’ll also learn how to combine
    transformations to compute compound transformations and take a look at some useful
    transformations, such as one that zooms a drawing around a concrete point.
  prefs: []
  type: TYPE_NORMAL
- en: '**Affine Transformations**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since affine transformations apply to affine spaces, let’s first try to understand
    what an affine space is. You can think of an *affine space* as being a vector
    space where the origin point can be moved around. The linear transformations used
    in vector spaces preserve the position of the space’s origin, whereas in an affine
    space, as we stop caring about a fixed origin, translations are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: An *affine transformation*, then, is a mapping between two affine spaces that
    preserves points, straight lines, and planes. Points after an affine transformation
    stay as points, straight lines continue to be straight, and planes remain plane.
    One interesting property of these transformations is that parallelism between
    lines is preserved. We’ll see this in action in [Chapter 12](ch12.xhtml#ch12)
    when we animate affine transformations. In that exercise, we’ll see how the sides
    of polygons that were originally parallel remain parallel during the whole simulation.
  prefs: []
  type: TYPE_NORMAL
- en: Affine transformations are similar to *linear transformations*. The only difference
    is that the latter preserves the origin; that is, the point (0, 0) doesn’t move.
    Affine transformations can alter the position of the origin. [Figure 7-1](ch07.xhtml#ch7fig1)
    depicts both a linear transformation and an affine transformation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: Linear versus affine transformation*'
  prefs: []
  type: TYPE_NORMAL
- en: Each pair of axes *x,y* in [Figure 7-1](ch07.xhtml#ch7fig1) shows how the space
    was before the transformation; each *x*^′, *y*^′ pair shows what the space looks
    like after the transformation. In the case of the linear transformation, the origin
    of coordinates *O* is preserved; the affine transformation, in addition to scaling
    and rotating the axes, translated the origin *O* to *O*^′.
  prefs: []
  type: TYPE_NORMAL
- en: Given a point *P*, we can define an affine transformation using the expression
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f00172-p1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *M* is a linear transformation, ![Image](../images/tvictorit.jpg) is a
    translation vector, and *P*^′ is the resulting point after applying the transformation.
    An affine transformation is thus a linear transformation *M* plus a translation
    ![Image](../images/tvictorit.jpg). This expression can be written with all its
    terms as shown in [Equation 7.1](ch07.xhtml#ch07eqa01).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07eqa01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The linear transformation matrix *M* has the items
  prefs: []
  type: TYPE_NORMAL
- en: '*s*[*x*]    Scale in the x direction'
  prefs: []
  type: TYPE_NORMAL
- en: '*s*[*y*]    Scale in the y direction'
  prefs: []
  type: TYPE_NORMAL
- en: '*sh*[*x*]    Shear in the x direction'
  prefs: []
  type: TYPE_NORMAL
- en: '*sh*[*y*]    Shear in the y direction'
  prefs: []
  type: TYPE_NORMAL
- en: and the translation ![Image](../images/tvictorit.jpg) has the terms
  prefs: []
  type: TYPE_NORMAL
- en: '*t*[*x*]    Translation in the x direction'
  prefs: []
  type: TYPE_NORMAL
- en: '*t*[*y*]    Translation in the y direction'
  prefs: []
  type: TYPE_NORMAL
- en: '[Equation 7.2](ch07.xhtml#ch07eqa02) shows an equivalent form using what is
    known as the *augmented matrix*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07eqa02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This version reduces the transformation to one matrix multiplication by extending
    the size of the input and output vectors, appending a 1, which serves as an auxiliary
    value and can be discarded once the transformation has taken place. It’s usually
    preferred as it requires only one step compared to the extra addition involved
    in the former. You can observe how in both cases, [Equations 7.1](ch07.xhtml#ch07eqa01)
    and [7.2](ch07.xhtml#ch07eqa02), the resulting coordinates are as shown in [Equation
    7.3](ch07.xhtml#ch07eqa03).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07eqa03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each of the values in the matrix from [Equation 7.2](ch07.xhtml#ch07eqa02) contributes
    differently in the transformation process. [Figure 7-2](ch07.xhtml#ch7fig2) showcases
    the transformation that each of the components produces. A generic affine transformation
    is therefore a combination of those unitary transformations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Components of affine transformations*'
  prefs: []
  type: TYPE_NORMAL
- en: There is a special affine transformation that maps each point to itself, the
    *identity transformation*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0174-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can observe, this is an identity matrix: whatever point you multiply
    this matrix by will stay the same.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Examples of Affine Transformations***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s look at a few examples of affine transformations in action. For this section,
    leave your computer aside and take out your pen and paper. If you can work through
    the operations to transform spaces using affine transformations by hand, coding
    them will be straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 1: Scaling**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Given a point (2, 3), what point results after applying a horizontal scale of
    2 and a vertical scale of 5?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the terms in the affine transformation matrix are all zero except
    for *s*[*x*] = 2 and *s*[*y*] = 5\. Plugging these values into [Equation 7.2](ch07.xhtml#ch07eqa02),
    we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0174-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The resulting point is therefore (4, 15). [Figure 7-3](ch07.xhtml#ch7fig3) depicts
    this transformation’s effect on the point.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Example of a scale transformation*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 2: Scaling and Translating**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Given a point (2, 3), what point results after applying a horizontal scale of
    2, vertical scale of 5, and translation of ⟨10, 15⟩?
  prefs: []
  type: TYPE_NORMAL
- en: 'This case has the same values for the scale as the previous one, plus a displacement
    vector. Let’s plug those values into our affine transformation equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0175-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This time, the resulting point is (14, 30). We’ll take a look at this later,
    but it’s interesting to note how we could achieve the same effect with two sequential
    affine transformations, the first one scaling the point and the second one translating
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0175-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that transformations are applied from right to left. In the previous case,
    the scaling goes first and then the translation. If you were to switch the order
    of transformations, the result would be different, which we can check by multiplying
    both transformation matrices in both directions and comparing the results. This
    yields our original matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0175-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'But switching the order yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0175-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[Figure 7-4](ch07.xhtml#ch7fig4) depicts the effect of applying the scale first
    and then the translation.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: A scale plus a translation*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 3: Vertical Reflection**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Reflections can be achieved by using affine transformations with negative scale
    values. To reflect a point (2, 3) in the vertical direction, use *s*[*y*] = –1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0176-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This yields the vertical reflection of the original point: (2,–3). [Figure
    7-5](ch07.xhtml#ch7fig5) represents this vertical reflection.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: An example of a vertical reflection*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example 4: Horizontal Shear**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: What is the result of applying a horizontal shear of *sh*[*x*] = 2 to a rectangle
    with its lower-left point located at the origin, a width of 10 units, and a height
    of 5 units?
  prefs: []
  type: TYPE_NORMAL
- en: 'This time we’ll have to apply the same transformation to all four vertices
    of the rectangle: (0, 0), (10, 0), (10, 5), and (0, 5). The affine transformation
    matrix is then as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0176-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using [Equation 7.2](ch07.xhtml#ch07eqa02) with this matrix to transform the
    vertices yields the following: (0, 0), (10, 0), (20, 5), and (10, 5). Draw the
    resulting rectangle. It should look something like [Figure 7-6](ch07.xhtml#ch7fig6).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: An example of a shear*'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Affine Transformation Class**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Without further ado, let’s create a new class to represent affine transformations.
    We want to use a class so that the transformation scale, translation, and shear
    values are part of its inner state and don’t need to be passed to every transformation
    method we use. If we used functions to transform geometric primitives instead,
    we’d need to pass all these values to every function, but that would be a lot
    of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In the *geom2d* package, create a new file named *affine_transf.py* and enter
    the code in [Listing 7-1](ch07.xhtml#ch7lis1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-1: The AffineTransform class*'
  prefs: []
  type: TYPE_NORMAL
- en: The affine transformation stores values for the scales *s*[*x*] and *s*[*y*],
    the translations *t*[*x*] and *t*[*y*], and the shears *sh*[*x*] and *sh*[*y*].
    All values are given a default value of zero, except for the scales, which are
    initialized to one, in case they are omitted in the initializer. This is for convenience,
    as we’ll create many transformations where the shear or translation values are
    zero.
  prefs: []
  type: TYPE_NORMAL
- en: With these values at hand we can already implement a method to apply the transformation
    to a point with the help of [Equation 7.3](ch07.xhtml#ch07eqa03). Enter the code
    in [Listing 7-2](ch07.xhtml#ch7lis2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-2: Applying an affine transformation to a point*'
  prefs: []
  type: TYPE_NORMAL
- en: To apply the affine transformation to a point, we create a new Point where the
    projections are calculated using [Equation 7.3](ch07.xhtml#ch07eqa03). Let’s test
    this method using several different transformations.
  prefs: []
  type: TYPE_NORMAL
- en: '***Testing the Transformation of Points***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Create a new file in the *geom2d* package named *affine_transf_test.py* and
    enter the code in [Listing 7-3](ch07.xhtml#ch7lis3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-3: Testing the affine transformation application*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The test file contains the TestAffineTransform class, inheriting from unittest.TestCase
    as usual. Inside the class we define a point that is used in all tests as well
    as all three affine transformations, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: scale    A scaling transformation
  prefs: []
  type: TYPE_NORMAL
- en: trans    A translation transformation
  prefs: []
  type: TYPE_NORMAL
- en: shear    A shear transformation
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we have our first test ensure the scale is correctly applied to the point
    ➊. The second test applies the translation to the point and asserts that the result
    is as expected ➋. The third does the same with the shear transformation ➌. Run
    the tests. You can do so from the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Great! Now that we’re confident we’re correctly applying affine transformations
    to points, let’s extend the logic to other more complex primitives.
  prefs: []
  type: TYPE_NORMAL
- en: '***Transform Segments and Polygons***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can harness the implementation for transforming Points to transform any shape
    as long as it’s defined using points or vectors. The next logical step is implementing
    the transformation of segments, so after the apply_to _point method, enter the
    method in [Listing 7-4](ch07.xhtml#ch7lis4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-4: Applying affine transformations to segments*'
  prefs: []
  type: TYPE_NORMAL
- en: That was easy, wasn’t it? To transform a segment, we simply create a new segment
    with both end points transformed using the previous method. We can apply a similar
    logic to polygons (in [Listing 7-5](ch07.xhtml#ch7lis5)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-5: Applying affine transformations to polygons*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we return a new polygon where all vertices have been transformed.
    What about rectangles and circles? The idea is similar, with a caveat: after scaling,
    shearing, and rotating these primitives, the results may no longer be rectangles
    or circles. This is why, in the previous chapter, we provided Rect and Circle
    with a method to_polygon that creates a generic polygon representation for the
    primitive. The code is therefore quite simple. Enter the code from [Listing 7-6](ch07.xhtml#ch7lis6):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-6: Applying affine transformations to rectangles and circles*'
  prefs: []
  type: TYPE_NORMAL
- en: The procedure consists of obtaining the polygon representation of the rectangle
    or circle and delegating the rest of the process to apply_to_polygon. In the case
    of circles, the number of divisions must be chosen, which is given a value of
    30 by default. Both methods return a Polygon instance, even if the affine transformation
    being applied is the identity, which wouldn’t transform the geometries at all.
    Once a rectangle or a circle goes through an affine transformation, it turns into
    a generic polygon, no matter what transformation.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t do so here for space reasons, but feel free to add unit tests for these
    three new methods.
  prefs: []
  type: TYPE_NORMAL
- en: '***Concatenating Transformations***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One interesting property of affine transformations is that any complex transformation
    can be expressed as a sequence of simpler transformations. In fact, when you work
    with a 2D graphics application such as Sketch or Photoshop, every zoom or pan
    on the canvas is a combination, or concatenation, of a new affine transformation
    with the current one, which defines the projection of what you see on your screen
    at that particular moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given two affine transformations [*T*[1]] and [*T*[2]] and input point *P*,
    the result of applying [*T*[1]] to the point is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*P′* = [*T*[1]]*P*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, applying the second transformation [*T*[2]] to the previous result, we
    get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*P*^″ = [*T*[2]]*P*^′'
  prefs: []
  type: TYPE_NORMAL
- en: If we substitute *P*^′ from the first expression into the second, we obtain
    the result of applying both transformations to input point *P* ([Equation 7.4](ch07.xhtml#ch07eqa04)),
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07eqa04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where [*T*[*r*]] is the affine transformation equivalent to applying [*T*[1]]
    first and [*T*[2]] second. Notice how the order of the original transformations
    appears in reverse if you read from left to right?
  prefs: []
  type: TYPE_NORMAL
- en: '[*T*[r]] = [*T*[2]][*T*[1]]'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous equation, reading from left to right [*T*[2]] appears first,
    but the effect of applying [*T*[*r*]] is equivalent to applying [*T*[1]] first
    and [*T*[2]] second. We need to be careful with the order, as matrix multiplication
    is noncommutative. If we swap the order of the operands, we obtain a different
    transformation, which was already proved in a previous exercise. The resulting
    transformation is then expressed mathematically as the product of matrices (see
    [Equation 7.5](ch07.xhtml#ch07eqa05)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07eqa05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s provide the AffineTransform class with a method to concatenate affine
    transformations using [Equation 7.5](ch07.xhtml#ch07eqa05). We’ll call the method
    then(), receiving parameters self and other. The first argument, self, is transformation
    [*T*[1]], and other is [*T*[2]]. Inside *affine_transf.py*, toward the end of
    the class, enter the code in [Listing 7-7](ch07.xhtml#ch7lis7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-7: Method to concatenate transformations*'
  prefs: []
  type: TYPE_NORMAL
- en: The name then is chosen so that it’s absolutely clear that self is applied before
    other (the method’s argument).
  prefs: []
  type: TYPE_NORMAL
- en: Since this is such an important method, we’ll want it covered by unit tests;
    that means we need a way of knowing whether two given affine transformations are
    equal. Let’s implement the special __eq__ method in AffineTransform ([Listing
    7-8](ch07.xhtml#ch7lis8)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-8: Checking affine transformation equality*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing the Concatenation of Transformations**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let’s now enter two new tests in *affine_transf_test.py*; both are listed in
    [Listing 7-9](ch07.xhtml#ch7lis9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-9: Testing affine transformation concatenation*'
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve probably realized, these two tests are repeating the operations we
    did by hand in one of the exercises at the beginning of the chapter. Run them
    to make sure you have the implementation of then right.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There is a lot of adding and multiplying between self and other, so it’s easy
    to get the code wrong. If the tests aren’t passing, well, that means they’re doing
    their work by pointing out that something in the code is not right. Go back to
    your implementation and make sure you have everything right line by line.
  prefs: []
  type: TYPE_NORMAL
- en: '***Inverting Affine Transformations***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To undo a transformation or apply the inverse of a known transformation [*T*],
    we want to be able to compute a transformation [*T*[*I*]] such that
  prefs: []
  type: TYPE_NORMAL
- en: '[*T*][*T*[I]] = [*T*[I]][*T*] = [*I*]'
  prefs: []
  type: TYPE_NORMAL
- en: 'where [*I*] is the identity matrix of size 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f00184-p1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'An interesting property of these pairs of transformations [*T*] and [*T*[*I*]]
    is that they cancel each other out. For example, here is the result of applying
    the transformations one after the other (in whichever order) to a point *P*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*T*[I]]([*T*]*P*) = ([*T*[I]][*T*])*P* = [*I*]*P* = *P*'
  prefs: []
  type: TYPE_NORMAL
- en: Another reason the inverse affine transformation is interesting is that it maps
    a point on the screen back to our “model space,” that is, the affine space where
    our model is defined. The direct transformation is used to compute how the geometry
    is projected onto the screen, that is, where each point of the model needs to
    be drawn—but what about the other way around? Knowing where a given point on the
    screen lies in the model requires the inverse transformation, the one that transforms
    the “screen space” into the model space. This is useful, for example, when trying
    to figure out whether the user’s mouse pointer on the screen maps to something
    in the model that could potentially be selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at [Figure 7-7](ch07.xhtml#ch7fig7). There’s our model space with
    just a triangle defined in it. To draw the model to the user’s screen, we have
    to apply an affine transformation that projects every point from model space to
    screen space. Now imagine the user has the mouse at point *P*^′ on the screen,
    and we want to know whether that point lies inside our triangle. Since the triangle
    is a geometry defined in the model space, we want to apply that point in the screen
    the inverse transformation: that which transforms screen space into model space.
    Recall that, to project our model geometry into the screen, we applied the direct
    affine transformation, so to map that geometry back into its original model space,
    the inverse of that transformation needs to be applied. With the point mapped
    to our model space (*P*), we can do the calculations to determine whether *P*
    is inside the triangle.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Model and screen spaces*'
  prefs: []
  type: TYPE_NORMAL
- en: You can try to compute the inverse affine transformation matrix by yourself,
    which is a great exercise, but inverting matrices by hand is a tedious task, so
    [Equation 7.6](ch07.xhtml#ch07eqa06) shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07eqa06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the transformation from [Equation 7.6](ch07.xhtml#ch07eqa06), computing
    the inverse requires only a few lines of code. In AffineTransform and after then,
    enter the code in [Listing 7-10](ch07.xhtml#ch7lis10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-10: Inverse affine transformation*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s also add a test to make sure the inverse is properly computed. In *affine_transf_test.py*,
    add a new method to class TestAffineTransform with the test in [Listing 7-11](ch07.xhtml#ch7lis11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-11: Testing the inverse affine transformation*'
  prefs: []
  type: TYPE_NORMAL
- en: In this test, we create a new affine transformation, transf, with all values
    set to nonzero values. Then we store the transformation result of concatenating
    transf and its inverse in actual, which, if you recall, should be the identity
    matrix if the inverse is properly constructed. Lastly, we compare the obtained
    result with the actual identity matrix. Run all tests in the file to make sure
    they succeed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try an example. We’ll apply a translation to a point and then apply the
    inverse translation to the resulting point, which should yield the original point.
    In the Python shell, write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We know if we apply the ⟨10, 20⟩ translation to point (5, 7), the resulting
    point should be (15, 27). Let’s test it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using the str function, we get the string representation of translated, the
    point after applying the translation. Let’s now apply the inverse translation
    transformation to that point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Applying the inverse transformation to the translated point yields the original
    point, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '***Scaling***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Whenever you zoom in or out using a graphics application such as AutoCAD or
    Illustrator, a scaling affine transformation is applied to the geometric model
    so that it’s drawn on your screen with a different size than the real one. Architects
    draw blueprints for buildings hundreds of meters tall that need to fit inside
    a laptop screen a few inches wide. Inside the computer’s memory lives the geometric
    model with the real dimensions, but to draw it to the screen, a scale is applied:
    a scaling affine transformation.'
  prefs: []
  type: TYPE_NORMAL
- en: To get a visual intuition of what happens in this kind of affine transformation,
    let’s look at [Figure 7-8](ch07.xhtml#ch7fig8). Given a point *P*, let’s imagine
    a vector ![Image](../images/vvictorit.jpg) starting at the origin and with its
    tip on *P*. Applying scales *S*[*x*] and *S*[*y*] to point *P* transforms it into
    a point *P*^′ whose vector ![Image](../images/vivictorit.jpg) horizontal projection
    is *S*[*x*] ⋅ *v*[*x*] and vertical projection is *S*[*y*] ⋅ *v*[*y*]. As you
    see, a scale is a measure of how far or close points get to the origin with respect
    to their original distance to it. The origin, in fact, doesn’t move with pure
    scaling transformations. Scales with absolute value smaller than the unit pull
    points closer to the origin, whereas scales greater than one push points away
    from it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-8: A scale affine transformation*'
  prefs: []
  type: TYPE_NORMAL
- en: This is useful, but often we want to apply a scale with respect to a point other
    than the origin. Imagine, for example, working with AutoCAD and wanting to zoom
    in to the drawing. If instead of zooming in around the center of your screen or
    mouse position it zoomed with respect to the origin (assuming it’s located in
    the lower-left corner of the app’s window), you’d feel like the drawing moved
    away, as depicted in the left diagram of [Figure 7-9](ch07.xhtml#ch7fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-9: Zooming in around the origin (left) and around the center of the
    screen (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: You’re probably much more used to a zoom in function that scales the drawing
    around a point somewhere in the middle of your screen, or even the position of
    your mouse as it actually happens most of the time. Many graphic design programs
    work like this, and it makes things more convenient for the user, but the way
    we defined a pure scaling transformation, it can only happen with respect to the
    origin. So, how is this scaling around an arbitrary point achieved? Well, now
    that we know about constructing compound transformations, obtaining this transformation
    is actually a piece of cake.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*It took me quite some time to fully understand how to use affine transformations
    effectively and how to create compound transformations out of simpler ones. I
    had a really hard time trying to implement a proper “zoom in” option in my software
    InkStructure, and that’s why the original versions felt a bit buggy when trying
    to zoom in to the drawing and not have it randomly move around the screen. So
    when I say “a piece of cake,” I should probably qualify: it becomes easy only
    once you understand affine transformations.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s quickly state the problem we want to solve: we want to find an affine
    transformation that applies scales *S*[*x*] and *S*[*y*] with respect to a center
    point *C*. Defining *O* as the origin of the coordinate system, we can build such
    a transformation by combining the following simpler transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*T*[1]]: Translate so that *C* coincides with the origin *O* (![Image](../images/tvictorit.jpg)
    = ![Image](../images/coline.jpg) = ⟨–*C*[x], –*C*[y]⟩).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[*T*[2]]: Scale with factors *S*[*x*] and *S*[*y*].'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[*T*[3]]: Translate *C* back to where it was (![Image](../images/tivictor.jpg)
    = ![Image](../images/ocline.jpg) = ⟨*C*[x], *C*[y]⟩).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since scales can be applied only with respect to the origin, we move the whole
    space so that our point *C* lies exactly on the origin, and then we apply the
    scale and translate things back to where they were initially. Beautiful, isn’t
    it? Thus, [*T*[*r*]] can be computed as shown in [Equation 7.7](ch07.xhtml#ch07eqa07).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07eqa07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s create a factory function to generate these kinds of transformations.
    Start by creating a new file named *affine_transforms.py*; in it, enter the function
    in [Listing 7-12](ch07.xhtml#ch7lis12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-12: Creating a scale transformation*'
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea to add a few test cases checking the behavior of this function.
    For brevity, I’ll leave that as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: '***Rotating***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Similar to scales, rotations always take place around the origin. Just like
    before, by using a clever sequence of transformations, we can produce a rotation
    around any point we want. You may have rotated a drawing in Sketch, Illustrator,
    or a similar application, in which case you’re used to choosing the *rotation
    pivot*, a point around which you then rotate using the square handles, something
    similar to [Figure 7-10](ch07.xhtml#ch7fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-10: Rotation around the center*'
  prefs: []
  type: TYPE_NORMAL
- en: The pivot point can be moved so the rotation happens around a different point.
    For example, moving it near the bottom-left corner of the bounding box, the rotation
    may look like [Figure 7-11](ch07.xhtml#ch7fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-11: Rotation around a corner*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by learning how to construct a rotation affine transformation around
    the origin; this will serve as the basis for constructing a more complex rotation
    around any point. [Equation 7.8](ch07.xhtml#ch07eqa08) shows how to rotate points
    *θ* radians around the origin.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07eqa08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With this in mind, let’s find an affine transformation that rotates points
    *θ* radians around a center point *C*. With *O* as the origin of the coordinate
    system, the transformation is the combination of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*T*[1]]: Translate *C* to the origin *O* so the rotation center is *C* (![Image](../images/tvictorit.jpg)
    = ![Image](../images/coline.jpg) = ⟨–*C*[x], –*C*[y]⟩).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[*T*[2]]: Rotate *θ* radians.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[*T*[3]]: Translate *C* back to where it was (![Image](../images/tivictor.jpg)
    = ![Image](../images/ocline.jpg) = ⟨*C*[x], *C*[y]⟩).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It’s the same algorithm as before, but this time we’ll use a rotation instead
    of a scale. [*T*[*r*]] is now computed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0190-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This yields the affine transformation in [Equation 7.9](ch07.xhtml#ch07eqa09).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07eqa09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let’s create a new factory function to generate rotations around a center point.
    In *affine_transforms.py*, with the help of [Equation 7.9](ch07.xhtml#ch07eqa09),
    implement the new function in [Listing 7-13](ch07.xhtml#ch7lis13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-13: Creating a rotation transformation*'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, you want to come up with at least one unit test to make sure our
    implementation is bug free.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give it a try in the shell: let’s create two rotations of *π*/4 radians,
    one around the origin and another one around the point (10, 10). Then, we’ll apply
    both rotations to the point (15, 15) to see where it lands in both cases. Reload
    the Python shell and write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now try with the rotation around the origin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The resulting point has an x-coordinate that is effectively zero (note the exponent
    e-15) and a y-coordinate of 21.2132..., which is the length of the vector going
    from the origin to the original point ![Image](../images/f00192.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try the second rotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The resulting point is (10, 17.071...) this time. To help us make sense of the
    exercise we’ve just done, [Figure 7-12](ch07.xhtml#ch7fig12) illustrates the two
    rotation transformations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-12: Example of a rotation around the origin (left) and around the
    point (10, 10) (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interpolating Transformations**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you zoom in or out, most graphics programs don’t apply the scale all at
    once, but they typically produce a quick and smooth animation of the zooming process.
    This helps you, the user, better understand how the drawing is being transformed.
    To achieve this, graphics programs typically use a transformation interpolation.
    Later in the book we’ll animate affine transformations, that is, we’ll create
    a kind of movie where we can appreciate how a given geometry is transformed one
    step at a time. Each frame in the animation will depict the geometry after applying
    a fraction of the affine transformation, and this is where we’ll first use *interpolations*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Motivating Interpolation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we dive into the concept of interpolating transformations, take a look
    at [Figure 7-13](ch07.xhtml#ch7fig13).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-13: Animating an affine transformation*'
  prefs: []
  type: TYPE_NORMAL
- en: In the figure, there’s a triangle originally in the bottom left of the window
    that ends up in the top middle after passing through some middle positions drawn
    in a lighter gray. Each of the triangles represents the result we’d see at a given
    point in time, a concrete frame in the animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want our animation to have *n* frames, where *n* > 1, there needs to
    be *n* affine transformations [*T*[0]], [*T*[1]],..., [*T*[n–1]] such that each
    frame is the result of applying the corresponding transformation to the input
    geometry. It’s clear that the last transformation, [*T*[*n–*1]], needs to be the
    target affine transformation, as the final frame should depict the geometry after
    applying such a transformation. What should [*T*[0]] be then? Let’s give it some
    thought. What transformation applied to the input geometry results in the geometry
    itself? Well, there’s only one such transformation that we know doesn’t move things
    around, the identity transformation. So, our start and end transformations are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0193-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'How do we go about computing [*T*[1]],...,[*T*[n–2]]? It’s easy: we can interpolate
    each of the start and end values to obtain as many intermediate values as we need.
    For example, a linear interpolation from 0 to 5 using five steps would yield [0,
    1, 2, 3, 4, 5]. Note that five steps produce six values, so to obtain *n* frames,
    we’ll use *n –* 1 steps.'
  prefs: []
  type: TYPE_NORMAL
- en: To interpolate from a start value *v*[*s*] to an end value *v*[*e*], we can
    use any function that passes through them. A straight line (linear function) is
    the simplest one, and the resulting values are uniformly spaced. This is a linear
    interpolation. If we used such interpolation to produce the frames of an animation,
    the result would move at constant speed from the beginning to the end (the slope
    of the interpolating function is constant), which looks unnatural to the eye.
    Why is that? Well, it’s because we’re not used to seeing things in real life abruptly
    accelerating, moving at the same speed, and stopping all of a sudden. This may
    look fine for projectiles or bullets, but it’s strange for most real-life objects
    in motion. We can try a more natural-looking interpolating function such as an
    *ease-in-out*, plotted in the right-side graph of [Figure 7-14](ch07.xhtml#ch7fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-14: Two interpolation functions*'
  prefs: []
  type: TYPE_NORMAL
- en: In an ease-in-out function, values at the beginning and end vary slowly, which
    gives the sensation of things accelerating as they start to move and softly decelerating
    when reaching the end of their motion. This function defines motion in a much
    more natural way, and animations following this variation of the position with
    respect to time look nice to the human eye.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain a value between *v*[*s*] and *v*[*e*], we use a parameter *t* such
    that 0 ≤ *t* ≤ 1 (see [Equation 7.10](ch07.xhtml#ch07eqa10)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07eqa10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can easily observe that [Equation 7.10](ch07.xhtml#ch07eqa10) yields a result
    of *v*[*s*] for *t* = 0 and *v*[*e*] for *t* = 1\. For any intermediate value
    of *t*, the value varies between those two values. If we want to obtain a sequence
    of values starting with *v*[*s*] all the way to *v*[*e*] that follow a linear
    distribution, we just need to use equally spaced values for *t*, like, for example,
    [0, 0.25, 0.5, 0.75, 1].
  prefs: []
  type: TYPE_NORMAL
- en: To produce an ease-in-out distribution of interpolated values, we need a sequence
    of *t* values from 0 to 1 with uneven spacing, with small steps near the extreme
    values and greater steps around the middle. If we represent the values of *t*
    by circles in a horizontal line starting at *t* = 0 and ending at *t* = 1, we
    can get a sense of how uniform and ease-in-out values are distributed from [Figure
    7-15](ch07.xhtml#ch7fig15).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-15: Interpolating t values*'
  prefs: []
  type: TYPE_NORMAL
- en: To build the sequence of *t* values distributed according to the right-side
    plot in [Figure 7-14](ch07.xhtml#ch7fig14), we can plug a sequence of evenly spaced
    *t* values into [Equation 7.11](ch07.xhtml#ch07eqa11).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07eqa11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This alters their spacing so that more of them lie near the extremes 0 and 1
    and fewer are located in the middle.
  prefs: []
  type: TYPE_NORMAL
- en: We have all the ingredients that we need; let’s get our hands dirty!
  prefs: []
  type: TYPE_NORMAL
- en: '***Implementing Interpolation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Create a new file named *interpolation.py* inside *geom2d* and enter the code
    in [Listing 7-14](ch07.xhtml#ch7lis14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-14: Interpolated t values*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting from the bottom, we have the function ease_in_out_t, which is simply
    the implementation of [Equation 7.11](ch07.xhtml#ch07eqa11). The first function
    builds a sequence of uniformly distributed *t* values using the given number of
    steps, thus producing as many values as steps plus one. We can test that in the
    shell. Reload it and try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Function ease_in_out_t_sequence, on the other hand, creates sequences following
    an ease-in-out distribution. To do so, it applies [Equation 7.11](ch07.xhtml#ch07eqa11)
    to values of a uniform sequence. Let’s try it as well in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: See how values near 0 and 1 are closer together while values in the middle (near
    0.5) are farther apart? Great, so we’re just missing a function to interpolate
    between two values for a given *t*, just as [Equation 7.10](ch07.xhtml#ch07eqa10)
    defines. Add [Listing 7-15](ch07.xhtml#ch7lis15) in *interpolation.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-15: Interpolating between two values given t*'
  prefs: []
  type: TYPE_NORMAL
- en: If you recall from [Chapter 5](ch05.xhtml#ch05), when we operate using a passed-in
    *t* parameter value, we want to check that it’s inside its expected range, for
    which the ensure_valid function is used. We’re now ready for the last step, and
    I hope you followed along, because here’s the actual interpolation of affine transformations
    we’ve been pursuing. Open your file *affine_transforms.py*, where we defined factory
    functions to create several special types of affine transformations, and enter
    the code in [Listing 7-16](ch07.xhtml#ch7lis16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-16: Sequence of interpolated affine transformations*'
  prefs: []
  type: TYPE_NORMAL
- en: To help generate a sequence of interpolated affine transformations, we define
    a private function __interpolated, which, given two transformations and a value
    for *t*, returns the interpolation for that *t* ➌. Each value for the new transformation
    is the result of interpolating the values of both start and end transformations.
    Then we build a sequence of *t* values following the ease-in-out distribution
    ➊, each of which is mapped to the interpolated transformation using a list comprehension
    ➋.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll leave this for now until [Chapter 12](ch12.xhtml#ch12), where we’ll be
    using the sequences of interpolated affine transformations to produce animations.
    Don’t worry if the concepts explored in this last part of the chapter seem a little
    abstract. We’ll build the foundations of animating motion in the next part of
    the book, and until then it may be hard to make sense out of this interpolation
    thing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Geom2D Final Touches**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our *geom2d* package is tested and ready to be used throughout the rest of the
    book. We made it robust, but we can add a few small improvements before concluding
    this part of the book.
  prefs: []
  type: TYPE_NORMAL
- en: '***Test Files***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first thing we want to do is separate implementation and test files, which
    are all in the same folder at the moment. This is so that the *geom2d* package
    folder appears less cluttered and you can find implementation files easier. In
    the package, create a new folder named *tests*, and then select all test files,
    which we conveniently named ending in *_test.py*, and drag them to the folder.
    Your folder structure and files should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Mechanics
  prefs: []
  type: TYPE_NORMAL
- en: '|- geom2d'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- tests'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |    |- affine_transf_test.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |    |- affine_transforms_test.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |    |- circle_test.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |    |- ...'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |    |- vector_test.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- __init__.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- affine_transf.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- affine_transforms.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- circle.py'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- ...'
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- vectors.py'
  prefs: []
  type: TYPE_NORMAL
- en: '***Running All Tests***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that all our test files live in the same folder, what about running all
    test cases at once? It may happen that you changed part of the code and want to
    make sure you didn’t break anything, for which you decide to run every test in
    the package. The way we’ve been doing it would take you some time, as you’d have
    to open the test files one by one and click the green play button beside each
    of the class names. There’s a better way!
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Terminal view inside PyCharm. If you can’t see it, from the menu select
    **View** ▸ **Tool Windows** ▸ **Terminal**. By default, the shell opens right
    in the root directory of the project, which is exactly what we want. In the shell,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This command tells Python to discover and run all unit tests in *geom2d/tests/*
    inside files matching the pattern **_test.py*, that is, all files ending in *_test.py*.
    Running the command should result in something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can save this command in a bash file at the project’s root level so you
    can execute it whenever you want without needing to memorize it.
  prefs: []
  type: TYPE_NORMAL
- en: '***Package Imports***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we want to do is include all modules in the package’s exports
    so that they can be loaded like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare this to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The latter requires the user to type the path where each module lives in *geom2d*,
    but the former doesn’t: everything inside the package can be imported directly
    from the package itself. This style of exporting modules of a package is convenient
    for two reasons: (1) because it allows us to change the directory structure within
    the module without breaking the user’s imports and (2) because users don’t need
    to know where each module is located within the package and import everything
    from the package itself. As you can guess, this greatly reduces the cognitive
    load for using the package.'
  prefs: []
  type: TYPE_NORMAL
- en: When PyCharm created the package *geom2d*, it included an empty file inside
    it named *__init__.py*. Can you spot it? Files with this name inside packages
    are loaded when the package itself is imported. We can use them to import what
    is defined inside the package.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If for whatever reason the file* __init__.py *doesn’t exist in your* geom2d
    *package, simply create it. Maybe you created the package as a normal directory
    inside PyCharm so the IDE didn’t add it for you.*'
  prefs: []
  type: TYPE_NORMAL
- en: So, open the file, which should be empty, and import all of the primitives we
    defined (see [Listing 7-17](ch07.xhtml#ch7lis17)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-17: The geom2d package init file*'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s all! To understand what we achieve with this change, you can try the
    following in the shell (Python’s shell, not the shell we just used to run commands):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This will prove convenient in future chapters, as we can import any module from
    *geom2d* directly from the package.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we explored a core concept in computer graphics: affine transformations.
    They allow us to transform geometry by scaling, rotating, translating, and shearing
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We started by taking a look at their mathematical definition and how they differ
    from linear transformations. The takeaway is that affine transformations can move
    the origin point, while linear transformations cannot. Affine transformations
    can be expressed as the combination of a linear transformation with a translation,
    but we saw a more convenient representation: the augmented matrix. Next, we implemented
    methods in the AffineTransform class to transform our geometric primitives: points,
    segments, and polygons.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then learned how transformations can be concatenated to achieve complex
    transformations out of simpler ones. Thanks to that powerful idea, we were able
    to construct two essential affine transformations that happen in almost every
    graphics application we know: scaling and rotating around a point other than the
    origin.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we implemented a function to interpolate between two affine transformations,
    yielding a couple intermediate transformations that we’ll soon be using to produce
    animations.
  prefs: []
  type: TYPE_NORMAL
