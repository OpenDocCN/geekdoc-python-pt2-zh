- en: '7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '7'
- en: AFFINE TRANSFORMATIONS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 仿射变换
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common01.jpg)'
- en: If I had to choose my favorite topic from this book, it would be affine transformations.
    There’s something oddly beautiful about affine transformations, as you’ll see
    for yourself in [Chapter 12](ch12.xhtml#ch12) when we animate them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我必须从本书中选择我最喜欢的主题，那就是仿射变换。仿射变换有某种奇异的美感，正如你在[第12章](ch12.xhtml#ch12)中看到我们为其制作动画时所见。
- en: Affine transformations are crucial to 2D graphic applications; they determine
    how to pan, zoom, and rotate what you see on the screen. If you’ve used AutoCAD,
    you’re pretty much used to zooming in to a portion of the drawing, which is done
    with an affine transformation. Whenever you scale and rotate your pics in Instagram,
    an affine transformation does the trick. Mastering this topic is essential for
    writing any piece of software involving graphics, even more so for those where
    the user is allowed to interact with them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 仿射变换对于二维图形应用至关重要；它们决定了如何在屏幕上平移、缩放和旋转所看到的内容。如果你使用过AutoCAD，你应该已经习惯了对图纸的某一部分进行缩放，这就是通过仿射变换实现的。每当你在Instagram上缩放和旋转图片时，也是通过仿射变换来完成的。掌握这一主题对于编写任何涉及图形的软件都是必不可少的，尤其是那些允许用户与图形互动的软件。
- en: The math behind affine transformations is quite simple, yet the concept is stunningly
    powerful. By the end of this chapter, you’ll have a class representing these transformations
    with methods to apply them to geometric primitives. We’ll also learn how to combine
    transformations to compute compound transformations and take a look at some useful
    transformations, such as one that zooms a drawing around a concrete point.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 仿射变换背后的数学原理非常简单，但其概念却异常强大。在本章结束时，你将拥有一个表示这些变换的类，并具备应用这些变换到几何原始图形的能力。我们还将学习如何组合变换以计算复合变换，并了解一些有用的变换，例如围绕某个具体点缩放图形的变换。
- en: '**Affine Transformations**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**仿射变换**'
- en: Since affine transformations apply to affine spaces, let’s first try to understand
    what an affine space is. You can think of an *affine space* as being a vector
    space where the origin point can be moved around. The linear transformations used
    in vector spaces preserve the position of the space’s origin, whereas in an affine
    space, as we stop caring about a fixed origin, translations are allowed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于仿射变换应用于仿射空间，首先我们需要理解什么是仿射空间。你可以把*仿射空间*看作是一个向量空间，其中原点可以移动。在向量空间中使用的线性变换保持空间原点的位置，而在仿射空间中，由于我们不再关心固定的原点，平移是允许的。
- en: An *affine transformation*, then, is a mapping between two affine spaces that
    preserves points, straight lines, and planes. Points after an affine transformation
    stay as points, straight lines continue to be straight, and planes remain plane.
    One interesting property of these transformations is that parallelism between
    lines is preserved. We’ll see this in action in [Chapter 12](ch12.xhtml#ch12)
    when we animate affine transformations. In that exercise, we’ll see how the sides
    of polygons that were originally parallel remain parallel during the whole simulation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，*仿射变换*是指两个仿射空间之间的一种映射，它保持点、直线和平面的不变。仿射变换后的点依然是点，直线仍然是直线，平面依然是平面。这些变换的一个有趣特性是，直线之间的平行性被保持。我们将在[第12章](ch12.xhtml#ch12)中通过动画展示仿射变换时看到这一点。在那个练习中，我们将看到原本平行的多边形的边在整个模拟过程中保持平行。
- en: Affine transformations are similar to *linear transformations*. The only difference
    is that the latter preserves the origin; that is, the point (0, 0) doesn’t move.
    Affine transformations can alter the position of the origin. [Figure 7-1](ch07.xhtml#ch7fig1)
    depicts both a linear transformation and an affine transformation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 仿射变换类似于*线性变换*。唯一的区别是，后者保持原点不变；也就是说，点（0，0）不会移动。仿射变换则可以改变原点的位置。[图7-1](ch07.xhtml#ch7fig1)展示了线性变换和仿射变换。
- en: '![Image](../images/07fig01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig01.jpg)'
- en: '*Figure 7-1: Linear versus affine transformation*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-1：线性变换与仿射变换*'
- en: Each pair of axes *x,y* in [Figure 7-1](ch07.xhtml#ch7fig1) shows how the space
    was before the transformation; each *x*^′, *y*^′ pair shows what the space looks
    like after the transformation. In the case of the linear transformation, the origin
    of coordinates *O* is preserved; the affine transformation, in addition to scaling
    and rotating the axes, translated the origin *O* to *O*^′.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每一对坐标轴*x, y*在[图7-1](ch07.xhtml#ch7fig1)中显示了变换前空间的状态；每一对*x*^′, *y*^′则展示了变换后空间的状态。在线性变换的情况下，坐标原点*O*得以保留；而在仿射变换中，除了对坐标轴进行缩放和旋转外，还将原点*O*平移到了*O*^′。
- en: Given a point *P*, we can define an affine transformation using the expression
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个点*P*，我们可以使用以下表达式定义仿射变换
- en: '![Image](../images/f00172-p1.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f00172-p1.jpg)'
- en: where *M* is a linear transformation, ![Image](../images/tvictorit.jpg) is a
    translation vector, and *P*^′ is the resulting point after applying the transformation.
    An affine transformation is thus a linear transformation *M* plus a translation
    ![Image](../images/tvictorit.jpg). This expression can be written with all its
    terms as shown in [Equation 7.1](ch07.xhtml#ch07eqa01).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，*M*是一个线性变换，![Image](../images/tvictorit.jpg)是一个平移向量，而*P*^′是应用变换后的结果点。因此，仿射变换是线性变换*M*加上平移![Image](../images/tvictorit.jpg)。这个表达式可以按照[方程7.1](ch07.xhtml#ch07eqa01)所示写出所有项。
- en: '![Image](../images/07eqa01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07eqa01.jpg)'
- en: The linear transformation matrix *M* has the items
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 线性变换矩阵*M*包含以下项目
- en: '*s*[*x*]    Scale in the x direction'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*s*[*x*]    在x方向上的缩放'
- en: '*s*[*y*]    Scale in the y direction'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*s*[*y*]    在y方向上的缩放'
- en: '*sh*[*x*]    Shear in the x direction'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*sh*[*x*]    在x方向上的剪切变换'
- en: '*sh*[*y*]    Shear in the y direction'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*sh*[*y*]    在y方向上的剪切变换'
- en: and the translation ![Image](../images/tvictorit.jpg) has the terms
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 平移![Image](../images/tvictorit.jpg)的项为
- en: '*t*[*x*]    Translation in the x direction'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*t*[*x*]    在x方向上的平移'
- en: '*t*[*y*]    Translation in the y direction'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*t*[*y*]    在y方向上的平移'
- en: '[Equation 7.2](ch07.xhtml#ch07eqa02) shows an equivalent form using what is
    known as the *augmented matrix*.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[方程7.2](ch07.xhtml#ch07eqa02)展示了使用所谓的*增广矩阵*的等效形式。'
- en: '![Image](../images/07eqa02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07eqa02.jpg)'
- en: This version reduces the transformation to one matrix multiplication by extending
    the size of the input and output vectors, appending a 1, which serves as an auxiliary
    value and can be discarded once the transformation has taken place. It’s usually
    preferred as it requires only one step compared to the extra addition involved
    in the former. You can observe how in both cases, [Equations 7.1](ch07.xhtml#ch07eqa01)
    and [7.2](ch07.xhtml#ch07eqa02), the resulting coordinates are as shown in [Equation
    7.3](ch07.xhtml#ch07eqa03).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种版本通过扩展输入和输出向量的大小，并附加一个1来简化变换为一次矩阵乘法，这个1作为辅助值，在变换完成后可以丢弃。与前一种方法相比，这通常更受偏爱，因为它只需要一步，而不需要额外的加法。你可以观察到，在[方程7.1](ch07.xhtml#ch07eqa01)和[7.2](ch07.xhtml#ch07eqa02)中，结果坐标如[方程7.3](ch07.xhtml#ch07eqa03)所示。
- en: '![Image](../images/07eqa03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07eqa03.jpg)'
- en: Each of the values in the matrix from [Equation 7.2](ch07.xhtml#ch07eqa02) contributes
    differently in the transformation process. [Figure 7-2](ch07.xhtml#ch7fig2) showcases
    the transformation that each of the components produces. A generic affine transformation
    is therefore a combination of those unitary transformations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[方程7.2](ch07.xhtml#ch07eqa02)矩阵中的每个值，在变换过程中都有不同的贡献。[图7-2](ch07.xhtml#ch7fig2)展示了每个组件产生的变换效果。因此，通用的仿射变换是这些单位变换的组合。
- en: '![Image](../images/07fig02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig02.jpg)'
- en: '*Figure 7-2: Components of affine transformations*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7-2：仿射变换的组件*'
- en: There is a special affine transformation that maps each point to itself, the
    *identity transformation*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊的仿射变换，它将每个点映射到自身，即*恒等变换*。
- en: '![Image](../images/f0174-01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0174-01.jpg)'
- en: 'As you can observe, this is an identity matrix: whatever point you multiply
    this matrix by will stay the same.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是一个恒等矩阵：无论将这个矩阵乘以哪个点，结果都将保持不变。
- en: '***Examples of Affine Transformations***'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***仿射变换的例子***'
- en: Let’s look at a few examples of affine transformations in action. For this section,
    leave your computer aside and take out your pen and paper. If you can work through
    the operations to transform spaces using affine transformations by hand, coding
    them will be straightforward.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看几个仿射变换的实际例子。在本节中，请放下你的电脑，拿出笔和纸。如果你能手工完成使用仿射变换转换空间的运算，那么编码实现这些变换就会变得很简单。
- en: '**Example 1: Scaling**'
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**例子1：缩放**'
- en: Given a point (2, 3), what point results after applying a horizontal scale of
    2 and a vertical scale of 5?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个点 (2, 3)，在应用水平缩放 2 和垂直缩放 5 后，结果会是什么点？
- en: 'In this case, the terms in the affine transformation matrix are all zero except
    for *s*[*x*] = 2 and *s*[*y*] = 5\. Plugging these values into [Equation 7.2](ch07.xhtml#ch07eqa02),
    we get the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，仿射变换矩阵中的项除了*s*[*x*] = 2 和 *s*[*y*] = 5 之外，其他都是零。将这些值代入[方程 7.2](ch07.xhtml#ch07eqa02)，我们得到如下结果：
- en: '![Image](../images/f0174-02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0174-02.jpg)'
- en: The resulting point is therefore (4, 15). [Figure 7-3](ch07.xhtml#ch7fig3) depicts
    this transformation’s effect on the point.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，结果点为 (4, 15)。[图 7-3](ch07.xhtml#ch7fig3)展示了此变换对点的影响。
- en: '![Image](../images/07fig03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig03.jpg)'
- en: '*Figure 7-3: Example of a scale transformation*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：缩放变换的示例*'
- en: '**Example 2: Scaling and Translating**'
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例 2：缩放和平移**'
- en: Given a point (2, 3), what point results after applying a horizontal scale of
    2, vertical scale of 5, and translation of ⟨10, 15⟩?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个点 (2, 3)，在应用水平缩放 2、垂直缩放 5 和平移 ⟨10, 15⟩ 后，结果会是什么点？
- en: 'This case has the same values for the scale as the previous one, plus a displacement
    vector. Let’s plug those values into our affine transformation equation:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个案例与前一个案例具有相同的缩放值，外加一个位移向量。我们将这些值代入仿射变换方程：
- en: '![Image](../images/f0175-01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0175-01.jpg)'
- en: 'This time, the resulting point is (14, 30). We’ll take a look at this later,
    but it’s interesting to note how we could achieve the same effect with two sequential
    affine transformations, the first one scaling the point and the second one translating
    it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，结果点为 (14, 30)。稍后我们将进一步探讨这一点，但值得注意的是，我们可以通过两个连续的仿射变换来实现相同的效果，第一个变换是缩放点，第二个变换是平移它：
- en: '![Image](../images/f0175-02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0175-02.jpg)'
- en: 'Note that transformations are applied from right to left. In the previous case,
    the scaling goes first and then the translation. If you were to switch the order
    of transformations, the result would be different, which we can check by multiplying
    both transformation matrices in both directions and comparing the results. This
    yields our original matrix:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，变换是从右到左应用的。在前面的案例中，首先是缩放，然后是平移。如果交换变换的顺序，结果会不同，我们可以通过分别在两个方向上相乘变换矩阵并比较结果来验证这一点。这将得到我们的原始矩阵：
- en: '![Image](../images/f0175-03.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0175-03.jpg)'
- en: 'But switching the order yields:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，交换顺序后得到的是：
- en: '![Image](../images/f0175-04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0175-04.jpg)'
- en: '[Figure 7-4](ch07.xhtml#ch7fig4) depicts the effect of applying the scale first
    and then the translation.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-4](ch07.xhtml#ch7fig4)展示了先应用缩放然后应用平移的效果。'
- en: '![Image](../images/07fig04.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig04.jpg)'
- en: '*Figure 7-4: A scale plus a translation*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：缩放加平移*'
- en: '**Example 3: Vertical Reflection**'
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例 3：垂直反射**'
- en: 'Reflections can be achieved by using affine transformations with negative scale
    values. To reflect a point (2, 3) in the vertical direction, use *s*[*y*] = –1:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 反射可以通过使用具有负缩放值的仿射变换来实现。要将点 (2, 3) 在垂直方向上进行反射，可以使用 *s*[*y*] = –1：
- en: '![Image](../images/f0176-01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0176-01.jpg)'
- en: 'This yields the vertical reflection of the original point: (2,–3). [Figure
    7-5](ch07.xhtml#ch7fig5) represents this vertical reflection.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这会得到原始点的垂直反射：(2,–3)。[图 7-5](ch07.xhtml#ch7fig5)表示了这个垂直反射。
- en: '![Image](../images/07fig05.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig05.jpg)'
- en: '*Figure 7-5: An example of a vertical reflection*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：垂直反射的示例*'
- en: '**Example 4: Horizontal Shear**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例 4：水平剪切**'
- en: What is the result of applying a horizontal shear of *sh*[*x*] = 2 to a rectangle
    with its lower-left point located at the origin, a width of 10 units, and a height
    of 5 units?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将水平剪切 *sh*[*x*] = 2 应用于一个矩形，矩形的左下角位于原点，宽度为 10 单位，高度为 5 单位，结果会怎样？
- en: 'This time we’ll have to apply the same transformation to all four vertices
    of the rectangle: (0, 0), (10, 0), (10, 5), and (0, 5). The affine transformation
    matrix is then as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们需要将相同的变换应用到矩形的四个顶点：(0, 0)、(10, 0)、(10, 5) 和 (0, 5)。仿射变换矩阵如下：
- en: '![Image](../images/f0176-02.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0176-02.jpg)'
- en: 'Using [Equation 7.2](ch07.xhtml#ch07eqa02) with this matrix to transform the
    vertices yields the following: (0, 0), (10, 0), (20, 5), and (10, 5). Draw the
    resulting rectangle. It should look something like [Figure 7-6](ch07.xhtml#ch7fig6).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[方程 7.2](ch07.xhtml#ch07eqa02)并用这个矩阵来变换顶点，得到以下结果：(0, 0)、(10, 0)、(20, 5) 和
    (10, 5)。绘制出结果矩形，应该像[图 7-6](ch07.xhtml#ch7fig6)那样。
- en: '![Image](../images/07fig06.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig06.jpg)'
- en: '*Figure 7-6: An example of a shear*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '**The Affine Transformation Class**'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Without further ado, let’s create a new class to represent affine transformations.
    We want to use a class so that the transformation scale, translation, and shear
    values are part of its inner state and don’t need to be passed to every transformation
    method we use. If we used functions to transform geometric primitives instead,
    we’d need to pass all these values to every function, but that would be a lot
    of parameters.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: In the *geom2d* package, create a new file named *affine_transf.py* and enter
    the code in [Listing 7-1](ch07.xhtml#ch7lis1).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 7-1: The AffineTransform class*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: The affine transformation stores values for the scales *s*[*x*] and *s*[*y*],
    the translations *t*[*x*] and *t*[*y*], and the shears *sh*[*x*] and *sh*[*y*].
    All values are given a default value of zero, except for the scales, which are
    initialized to one, in case they are omitted in the initializer. This is for convenience,
    as we’ll create many transformations where the shear or translation values are
    zero.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: With these values at hand we can already implement a method to apply the transformation
    to a point with the help of [Equation 7.3](ch07.xhtml#ch07eqa03). Enter the code
    in [Listing 7-2](ch07.xhtml#ch7lis2).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 7-2: Applying an affine transformation to a point*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: To apply the affine transformation to a point, we create a new Point where the
    projections are calculated using [Equation 7.3](ch07.xhtml#ch07eqa03). Let’s test
    this method using several different transformations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '***Testing the Transformation of Points***'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Create a new file in the *geom2d* package named *affine_transf_test.py* and
    enter the code in [Listing 7-3](ch07.xhtml#ch7lis3).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 7-3: Testing the affine transformation application*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'The test file contains the TestAffineTransform class, inheriting from unittest.TestCase
    as usual. Inside the class we define a point that is used in all tests as well
    as all three affine transformations, namely:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: scale    A scaling transformation
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: trans    A translation transformation
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: shear    A shear transformation
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we have our first test ensure the scale is correctly applied to the point
    ➊. The second test applies the translation to the point and asserts that the result
    is as expected ➋. The third does the same with the shear transformation ➌. Run
    the tests. You can do so from the shell:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This should produce the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Great! Now that we’re confident we’re correctly applying affine transformations
    to points, let’s extend the logic to other more complex primitives.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '***Transform Segments and Polygons***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can harness the implementation for transforming Points to transform any shape
    as long as it’s defined using points or vectors. The next logical step is implementing
    the transformation of segments, so after the apply_to _point method, enter the
    method in [Listing 7-4](ch07.xhtml#ch7lis4).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 7-4: Applying affine transformations to segments*'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: That was easy, wasn’t it? To transform a segment, we simply create a new segment
    with both end points transformed using the previous method. We can apply a similar
    logic to polygons (in [Listing 7-5](ch07.xhtml#ch7lis5)).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，不是吗？要变换一个线段，我们只需使用前面的方法将两个端点都进行变换，创建一个新的线段。我们可以将类似的逻辑应用于多边形（见[列表 7-5](ch07.xhtml#ch7lis5)）。
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 7-5: Applying affine transformations to polygons*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-5：将仿射变换应用于多边形*'
- en: 'In this case, we return a new polygon where all vertices have been transformed.
    What about rectangles and circles? The idea is similar, with a caveat: after scaling,
    shearing, and rotating these primitives, the results may no longer be rectangles
    or circles. This is why, in the previous chapter, we provided Rect and Circle
    with a method to_polygon that creates a generic polygon representation for the
    primitive. The code is therefore quite simple. Enter the code from [Listing 7-6](ch07.xhtml#ch7lis6):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们返回一个新的多边形，其中所有的顶点都已经被变换。那矩形和圆形呢？思路类似，但有一个警告：在缩放、错切和旋转这些原始图形后，结果可能不再是矩形或圆形。这就是为什么在前一章中，我们为矩形和圆形提供了一个
    `to_polygon` 方法，用于为这些原始图形创建一个通用的多边形表示。代码因此非常简单。请从[列表 7-6](ch07.xhtml#ch7lis6)输入代码：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 7-6: Applying affine transformations to rectangles and circles*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-6：将仿射变换应用于矩形和圆形*'
- en: The procedure consists of obtaining the polygon representation of the rectangle
    or circle and delegating the rest of the process to apply_to_polygon. In the case
    of circles, the number of divisions must be chosen, which is given a value of
    30 by default. Both methods return a Polygon instance, even if the affine transformation
    being applied is the identity, which wouldn’t transform the geometries at all.
    Once a rectangle or a circle goes through an affine transformation, it turns into
    a generic polygon, no matter what transformation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程包括获取矩形或圆形的多边形表示，并将其余过程委托给 `apply_to_polygon`。对于圆形，需要选择分割数，默认值为 30。即使应用的仿射变换是恒等变换（不会改变几何形状），这两个方法也会返回一个
    `Polygon` 实例。一旦矩形或圆形经过仿射变换，它就会变成一个通用的多边形，无论是什么变换。
- en: We won’t do so here for space reasons, but feel free to add unit tests for these
    three new methods.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 由于空间原因，我们在这里不会这么做，但你可以随时为这三个新方法添加单元测试。
- en: '***Concatenating Transformations***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***连接变换***'
- en: One interesting property of affine transformations is that any complex transformation
    can be expressed as a sequence of simpler transformations. In fact, when you work
    with a 2D graphics application such as Sketch or Photoshop, every zoom or pan
    on the canvas is a combination, or concatenation, of a new affine transformation
    with the current one, which defines the projection of what you see on your screen
    at that particular moment.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 仿射变换的一个有趣性质是，任何复杂的变换都可以表示为一系列简单变换的组合。事实上，当你使用像 Sketch 或 Photoshop 这样的 2D 图形应用程序时，每一次画布的缩放或平移，都是当前变换与新的仿射变换的组合或连接，这决定了你在特定时刻在屏幕上看到的投影。
- en: 'Given two affine transformations [*T*[1]] and [*T*[2]] and input point *P*,
    the result of applying [*T*[1]] to the point is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个仿射变换 [*T*[1]] 和 [*T*[2]] 以及输入点 *P*，将 [*T*[1]] 应用到该点的结果如下：
- en: '*P′* = [*T*[1]]*P*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*P′* = [*T*[1]]*P*'
- en: 'Then, applying the second transformation [*T*[2]] to the previous result, we
    get this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将第二个变换 [*T*[2]] 应用到先前的结果，我们得到：
- en: '*P*^″ = [*T*[2]]*P*^′'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*^″ = [*T*[2]]*P*^′'
- en: If we substitute *P*^′ from the first expression into the second, we obtain
    the result of applying both transformations to input point *P* ([Equation 7.4](ch07.xhtml#ch07eqa04)),
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将第一个表达式中的 *P*^′ 代入第二个表达式，就得到应用这两次变换到输入点 *P* 的结果（[方程 7.4](ch07.xhtml#ch07eqa04)），
- en: '![Image](../images/07eqa04.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07eqa04.jpg)'
- en: where [*T*[*r*]] is the affine transformation equivalent to applying [*T*[1]]
    first and [*T*[2]] second. Notice how the order of the original transformations
    appears in reverse if you read from left to right?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，[*T*[*r*]] 是等同于先应用[*T*[1]]再应用[*T*[2]]的仿射变换。注意，如果从左到右阅读，原始变换的顺序是如何反过来的？
- en: '[*T*[r]] = [*T*[2]][*T*[1]]'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[*T*[r]] = [*T*[2]][*T*[1]]'
- en: In the previous equation, reading from left to right [*T*[2]] appears first,
    but the effect of applying [*T*[*r*]] is equivalent to applying [*T*[1]] first
    and [*T*[2]] second. We need to be careful with the order, as matrix multiplication
    is noncommutative. If we swap the order of the operands, we obtain a different
    transformation, which was already proved in a previous exercise. The resulting
    transformation is then expressed mathematically as the product of matrices (see
    [Equation 7.5](ch07.xhtml#ch07eqa05)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的公式中，从左到右[*T*[2]]首先出现，但应用[*T*[*r*]]的效果相当于先应用[*T*[1]]，再应用[*T*[2]]。我们需要小心顺序，因为矩阵乘法是不交换的。如果我们交换操作数的顺序，我们将得到一个不同的变换，这在之前的一个练习中已经证明过了。结果变换随后用矩阵的乘积表示（参见[方程
    7.5](ch07.xhtml#ch07eqa05)）。
- en: '![Image](../images/07eqa05.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07eqa05.jpg)'
- en: Let’s provide the AffineTransform class with a method to concatenate affine
    transformations using [Equation 7.5](ch07.xhtml#ch07eqa05). We’ll call the method
    then(), receiving parameters self and other. The first argument, self, is transformation
    [*T*[1]], and other is [*T*[2]]. Inside *affine_transf.py*, toward the end of
    the class, enter the code in [Listing 7-7](ch07.xhtml#ch7lis7).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为AffineTransform类提供一个方法，用[方程 7.5](ch07.xhtml#ch07eqa05)来串联仿射变换。我们将这个方法命名为then()，接受参数self和other。第一个参数self是变换[*T*[1]]，而other是[*T*[2]]。在*affine_transf.py*中，类的末尾输入[列表
    7-7](ch07.xhtml#ch7lis7)中的代码。
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 7-7: Method to concatenate transformations*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-7：串联变换的方法*'
- en: The name then is chosen so that it’s absolutely clear that self is applied before
    other (the method’s argument).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后选择这个名称是为了确保完全清楚地表明self在other之前应用（即方法的参数）。
- en: Since this is such an important method, we’ll want it covered by unit tests;
    that means we need a way of knowing whether two given affine transformations are
    equal. Let’s implement the special __eq__ method in AffineTransform ([Listing
    7-8](ch07.xhtml#ch7lis8)).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个非常重要的方法，我们希望它能通过单元测试覆盖；这意味着我们需要一种方法来判断两个给定的仿射变换是否相等。让我们在AffineTransform中实现特殊的__eq__方法（参见[列表
    7-8](ch07.xhtml#ch7lis8)）。
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 7-8: Checking affine transformation equality*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-8：检查仿射变换相等性*'
- en: '**Testing the Concatenation of Transformations**'
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**测试变换的串联**'
- en: Let’s now enter two new tests in *affine_transf_test.py*; both are listed in
    [Listing 7-9](ch07.xhtml#ch7lis9).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在*affine_transf_test.py*中输入两个新测试；它们都列在[列表 7-9](ch07.xhtml#ch7lis9)中。
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 7-9: Testing affine transformation concatenation*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-9：测试仿射变换串联*'
- en: As you’ve probably realized, these two tests are repeating the operations we
    did by hand in one of the exercises at the beginning of the chapter. Run them
    to make sure you have the implementation of then right.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经意识到的，这两个测试重复了我们在本章开头的某个练习中手动进行的操作。运行它们，以确保你正确实现了这些操作。
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There is a lot of adding and multiplying between self and other, so it’s easy
    to get the code wrong. If the tests aren’t passing, well, that means they’re doing
    their work by pointing out that something in the code is not right. Go back to
    your implementation and make sure you have everything right line by line.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于self和other之间有很多加法和乘法运算，很容易把代码写错。如果测试未通过，那就意味着它们通过指出代码中的问题来完成它们的工作。返回你的实现并逐行确保你一切都做对了。
- en: '***Inverting Affine Transformations***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***反转仿射变换***'
- en: To undo a transformation or apply the inverse of a known transformation [*T*],
    we want to be able to compute a transformation [*T*[*I*]] such that
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了撤销一个变换或应用已知变换[*T*]的逆，我们希望能够计算一个变换[*T*[*I*]]，使得
- en: '[*T*][*T*[I]] = [*T*[I]][*T*] = [*I*]'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[*T*][*T*[I]] = [*T*[I]][*T*] = [*I*]'
- en: 'where [*I*] is the identity matrix of size 3:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 其中[*I*]是3x3的单位矩阵：
- en: '![Image](../images/f00184-p1.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f00184-p1.jpg)'
- en: 'An interesting property of these pairs of transformations [*T*] and [*T*[*I*]]
    is that they cancel each other out. For example, here is the result of applying
    the transformations one after the other (in whichever order) to a point *P*:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变换对[*T*]和[*T*[*I*]]的一个有趣属性是它们相互抵消。例如，以下是将这些变换按顺序（无论顺序如何）作用于一个点*P*的结果：
- en: '[*T*[I]]([*T*]*P*) = ([*T*[I]][*T*])*P* = [*I*]*P* = *P*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[*T*[I]]([*T*]*P*) = ([*T*[I]][*T*])*P* = [*I*]*P* = *P*'
- en: Another reason the inverse affine transformation is interesting is that it maps
    a point on the screen back to our “model space,” that is, the affine space where
    our model is defined. The direct transformation is used to compute how the geometry
    is projected onto the screen, that is, where each point of the model needs to
    be drawn—but what about the other way around? Knowing where a given point on the
    screen lies in the model requires the inverse transformation, the one that transforms
    the “screen space” into the model space. This is useful, for example, when trying
    to figure out whether the user’s mouse pointer on the screen maps to something
    in the model that could potentially be selected.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 逆仿射变换之所以有趣的另一个原因是，它将屏幕上的点映射回我们的“模型空间”，即定义我们模型的仿射空间。直接变换用于计算几何图形如何投影到屏幕上，也就是说，模型中的每个点应该绘制到哪里——但反过来呢？要知道屏幕上某个给定点在模型中的位置，需要逆变换，即将“屏幕空间”转换为模型空间的变换。这在某些情况下很有用，例如当试图弄清楚屏幕上用户的鼠标指针是否映射到模型中的某个可选项时。
- en: 'Take a look at [Figure 7-7](ch07.xhtml#ch7fig7). There’s our model space with
    just a triangle defined in it. To draw the model to the user’s screen, we have
    to apply an affine transformation that projects every point from model space to
    screen space. Now imagine the user has the mouse at point *P*^′ on the screen,
    and we want to know whether that point lies inside our triangle. Since the triangle
    is a geometry defined in the model space, we want to apply that point in the screen
    the inverse transformation: that which transforms screen space into model space.
    Recall that, to project our model geometry into the screen, we applied the direct
    affine transformation, so to map that geometry back into its original model space,
    the inverse of that transformation needs to be applied. With the point mapped
    to our model space (*P*), we can do the calculations to determine whether *P*
    is inside the triangle.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下[图 7-7](ch07.xhtml#ch7fig7)。这是我们的模型空间，其中只定义了一个三角形。为了将模型绘制到用户的屏幕上，我们必须应用一个仿射变换，将模型空间中的每个点投影到屏幕空间。现在，假设用户的鼠标位于屏幕上的*P*^′点，我们想知道该点是否位于我们的三角形内部。由于三角形是定义在模型空间中的几何图形，我们希望对屏幕上的该点应用逆变换：即将屏幕空间转换回模型空间的变换。回想一下，为了将我们的模型几何图形投影到屏幕上，我们应用了直接的仿射变换，因此要将几何图形映射回原始的模型空间，需要应用该变换的逆变换。通过将该点映射到我们的模型空间(*P*)，我们可以进行计算，以确定*P*是否在三角形内部。
- en: '![Image](../images/07fig07.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07fig07.jpg)'
- en: '*Figure 7-7: Model and screen spaces*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-7：模型和屏幕空间*'
- en: You can try to compute the inverse affine transformation matrix by yourself,
    which is a great exercise, but inverting matrices by hand is a tedious task, so
    [Equation 7.6](ch07.xhtml#ch07eqa06) shows the result.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试自己计算逆仿射变换矩阵，这是一个很好的练习，但手动求逆矩阵是一个繁琐的任务，因此[方程 7.6](ch07.xhtml#ch07eqa06)展示了结果。
- en: '![Image](../images/07eqa06.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/07eqa06.jpg)'
- en: Using the transformation from [Equation 7.6](ch07.xhtml#ch07eqa06), computing
    the inverse requires only a few lines of code. In AffineTransform and after then,
    enter the code in [Listing 7-10](ch07.xhtml#ch7lis10).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[方程 7.6](ch07.xhtml#ch07eqa06)中的变换，计算逆变换只需要几行代码。在AffineTransform类中，之后输入[清单
    7-10](ch07.xhtml#ch7lis10)中的代码。
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 7-10: Inverse affine transformation*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-10：逆仿射变换*'
- en: Let’s also add a test to make sure the inverse is properly computed. In *affine_transf_test.py*,
    add a new method to class TestAffineTransform with the test in [Listing 7-11](ch07.xhtml#ch7lis11).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加一个测试，确保逆变换能够正确计算。在*affine_transf_test.py*中，向TestAffineTransform类中添加一个新方法，测试内容参见[清单
    7-11](ch07.xhtml#ch7lis11)。
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 7-11: Testing the inverse affine transformation*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-11：测试逆仿射变换*'
- en: In this test, we create a new affine transformation, transf, with all values
    set to nonzero values. Then we store the transformation result of concatenating
    transf and its inverse in actual, which, if you recall, should be the identity
    matrix if the inverse is properly constructed. Lastly, we compare the obtained
    result with the actual identity matrix. Run all tests in the file to make sure
    they succeed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们创建了一个新的仿射变换transf，并将所有值设置为非零值。然后，我们将连接transf及其逆变换的结果存储在实际结果中，如果你记得的话，如果逆变换正确构造，结果应该是单位矩阵。最后，我们将得到的结果与实际的单位矩阵进行比较。运行文件中的所有测试，确保它们都能成功通过。
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s try an example. We’ll apply a translation to a point and then apply the
    inverse translation to the resulting point, which should yield the original point.
    In the Python shell, write the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一个例子。我们将对一个点应用平移，然后对得到的点应用反向平移，最终应该得到原始点。在Python shell中，写下以下代码：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We know if we apply the ⟨10, 20⟩ translation to point (5, 7), the resulting
    point should be (15, 27). Let’s test it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，如果我们将⟨10, 20⟩的平移应用到点（5, 7），则得到的点应该是（15, 27）。让我们来验证一下。
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Using the str function, we get the string representation of translated, the
    point after applying the translation. Let’s now apply the inverse translation
    transformation to that point.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用str函数，我们可以获得平移后的点的字符串表示。现在，让我们对这个点应用反向平移变换。
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Applying the inverse transformation to the translated point yields the original
    point, as expected.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对平移后的点应用反向变换，得到原始点，正如预期的那样。
- en: '***Scaling***'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***缩放***'
- en: 'Whenever you zoom in or out using a graphics application such as AutoCAD or
    Illustrator, a scaling affine transformation is applied to the geometric model
    so that it’s drawn on your screen with a different size than the real one. Architects
    draw blueprints for buildings hundreds of meters tall that need to fit inside
    a laptop screen a few inches wide. Inside the computer’s memory lives the geometric
    model with the real dimensions, but to draw it to the screen, a scale is applied:
    a scaling affine transformation.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你使用AutoCAD或Illustrator等图形应用程序进行缩放时，都会对几何模型应用一个缩放仿射变换，使得模型在屏幕上显示的大小与真实大小不同。建筑师绘制的建筑蓝图可能有几百米高，而这些蓝图需要适应几英寸宽的笔记本电脑屏幕。在计算机的内存中存储着具有真实尺寸的几何模型，但为了在屏幕上绘制它，需要应用一个缩放：一个缩放仿射变换。
- en: To get a visual intuition of what happens in this kind of affine transformation,
    let’s look at [Figure 7-8](ch07.xhtml#ch7fig8). Given a point *P*, let’s imagine
    a vector ![Image](../images/vvictorit.jpg) starting at the origin and with its
    tip on *P*. Applying scales *S*[*x*] and *S*[*y*] to point *P* transforms it into
    a point *P*^′ whose vector ![Image](../images/vivictorit.jpg) horizontal projection
    is *S*[*x*] ⋅ *v*[*x*] and vertical projection is *S*[*y*] ⋅ *v*[*y*]. As you
    see, a scale is a measure of how far or close points get to the origin with respect
    to their original distance to it. The origin, in fact, doesn’t move with pure
    scaling transformations. Scales with absolute value smaller than the unit pull
    points closer to the origin, whereas scales greater than one push points away
    from it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得这种仿射变换的视觉直觉，让我们看一下[图 7-8](ch07.xhtml#ch7fig8)。给定一个点*P*，我们可以想象有一个从原点出发的向量![Image](../images/vvictorit.jpg)，其尖端在*P*上。对点*P*应用缩放*S*[*x*]和*S*[*y*]，将其转换为点*P*^′，其向量![Image](../images/vivictorit.jpg)的水平投影为*S*[*x*]
    ⋅ *v*[*x*]，垂直投影为*S*[*y*] ⋅ *v*[*y*]。正如你所看到的，缩放是衡量点相对于其原始距离与原点之间的远近。事实上，纯粹的缩放变换并不会移动原点。绝对值小于1的缩放会将点拉近原点，而大于1的缩放则会把点推远原点。
- en: '![Image](../images/07fig08.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig08.jpg)'
- en: '*Figure 7-8: A scale affine transformation*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-8：一个尺度仿射变换*'
- en: This is useful, but often we want to apply a scale with respect to a point other
    than the origin. Imagine, for example, working with AutoCAD and wanting to zoom
    in to the drawing. If instead of zooming in around the center of your screen or
    mouse position it zoomed with respect to the origin (assuming it’s located in
    the lower-left corner of the app’s window), you’d feel like the drawing moved
    away, as depicted in the left diagram of [Figure 7-9](ch07.xhtml#ch7fig9).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有用的，但通常我们希望相对于原点以外的某个点应用缩放。例如，假设你正在使用AutoCAD并想放大图纸。如果缩放是相对于原点（假设它位于应用窗口的左下角）而不是围绕屏幕的中心或鼠标位置进行的，那么你会觉得图纸被移远了，如[图
    7-9](ch07.xhtml#ch7fig9)左图所示。
- en: '![Image](../images/07fig09.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig09.jpg)'
- en: '*Figure 7-9: Zooming in around the origin (left) and around the center of the
    screen (right)*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-9：围绕原点缩放（左）与围绕屏幕中心缩放（右）*'
- en: You’re probably much more used to a zoom in function that scales the drawing
    around a point somewhere in the middle of your screen, or even the position of
    your mouse as it actually happens most of the time. Many graphic design programs
    work like this, and it makes things more convenient for the user, but the way
    we defined a pure scaling transformation, it can only happen with respect to the
    origin. So, how is this scaling around an arbitrary point achieved? Well, now
    that we know about constructing compound transformations, obtaining this transformation
    is actually a piece of cake.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能更习惯使用一个在屏幕中间某个点或甚至鼠标位置周围缩放绘图的功能，这种功能实际上在大多数情况下都会发生。许多图形设计程序都像这样工作，这样对用户来说更方便，但按照我们定义的纯缩放变换，它只能相对于原点发生。那么，如何在任意点周围进行缩放呢？好吧，现在我们知道了如何构造复合变换，实际上，获得这个变换就是轻而易举的事了。
- en: '**NOTE**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*It took me quite some time to fully understand how to use affine transformations
    effectively and how to create compound transformations out of simpler ones. I
    had a really hard time trying to implement a proper “zoom in” option in my software
    InkStructure, and that’s why the original versions felt a bit buggy when trying
    to zoom in to the drawing and not have it randomly move around the screen. So
    when I say “a piece of cake,” I should probably qualify: it becomes easy only
    once you understand affine transformations.*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*我花了相当长的时间才完全理解如何有效地使用仿射变换，以及如何从简单的变换中创建复合变换。我在尝试在我的软件 InkStructure 中实现一个正确的“放大”选项时遇到了很大的困难，这也是为什么原始版本在尝试放大绘图时感觉有些
    bug，当时图形会随机移动到屏幕的其他位置。所以，当我说“轻而易举”时，我应该加上一些说明：只有在理解了仿射变换之后，它才变得简单。*'
- en: 'Let’s quickly state the problem we want to solve: we want to find an affine
    transformation that applies scales *S*[*x*] and *S*[*y*] with respect to a center
    point *C*. Defining *O* as the origin of the coordinate system, we can build such
    a transformation by combining the following simpler transformations:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速说明我们想解决的问题：我们想找到一个仿射变换，它相对于中心点 *C* 应用缩放 *S*[*x*] 和 *S*[*y*]。定义 *O* 为坐标系的原点，我们可以通过组合以下更简单的变换来构建这样的变换：
- en: '[*T*[1]]: Translate so that *C* coincides with the origin *O* (![Image](../images/tvictorit.jpg)
    = ![Image](../images/coline.jpg) = ⟨–*C*[x], –*C*[y]⟩).'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[*T*[1]]: 移动 *C* 使其与原点 *O* 重合 (![Image](../images/tvictorit.jpg) = ![Image](../images/coline.jpg)
    = ⟨–*C*[x], –*C*[y]⟩)。'
- en: '[*T*[2]]: Scale with factors *S*[*x*] and *S*[*y*].'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[*T*[2]]: 使用缩放因子 *S*[*x*] 和 *S*[*y*] 进行缩放。'
- en: '[*T*[3]]: Translate *C* back to where it was (![Image](../images/tivictor.jpg)
    = ![Image](../images/ocline.jpg) = ⟨*C*[x], *C*[y]⟩).'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[*T*[3]]: 将 *C* 移动回原来的位置 (![Image](../images/tivictor.jpg) = ![Image](../images/ocline.jpg)
    = ⟨*C*[x], *C*[y]⟩)。'
- en: Since scales can be applied only with respect to the origin, we move the whole
    space so that our point *C* lies exactly on the origin, and then we apply the
    scale and translate things back to where they were initially. Beautiful, isn’t
    it? Thus, [*T*[*r*]] can be computed as shown in [Equation 7.7](ch07.xhtml#ch07eqa07).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缩放只能相对于原点应用，我们将整个空间移动，使得我们的点 *C* 恰好位于原点，然后应用缩放并将其移动回原来的位置。漂亮吧？因此，[*T*[*r*]]
    可以通过[方程 7.7](ch07.xhtml#ch07eqa07)计算得出。
- en: '![Image](../images/07eqa07.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07eqa07.jpg)'
- en: Let’s create a factory function to generate these kinds of transformations.
    Start by creating a new file named *affine_transforms.py*; in it, enter the function
    in [Listing 7-12](ch07.xhtml#ch7lis12).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个工厂函数来生成这些类型的变换。首先，创建一个名为 *affine_transforms.py* 的新文件；在其中输入[列表 7-12](ch07.xhtml#ch7lis12)中的函数。
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 7-12: Creating a scale transformation*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-12：创建一个缩放变换*'
- en: It is a good idea to add a few test cases checking the behavior of this function.
    For brevity, I’ll leave that as an exercise for you.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最好添加一些测试用例，检查该函数的行为。为了简洁起见，我会把这个留给你作为练习。
- en: '***Rotating***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***旋转***'
- en: Similar to scales, rotations always take place around the origin. Just like
    before, by using a clever sequence of transformations, we can produce a rotation
    around any point we want. You may have rotated a drawing in Sketch, Illustrator,
    or a similar application, in which case you’re used to choosing the *rotation
    pivot*, a point around which you then rotate using the square handles, something
    similar to [Figure 7-10](ch07.xhtml#ch7fig10).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于缩放，旋转总是围绕原点进行。就像之前一样，通过使用巧妙的变换序列，我们可以围绕任何我们想要的点进行旋转。你可能在 Sketch、Illustrator
    或类似应用程序中旋转过图形，在这种情况下，你已经习惯选择*旋转中心*，一个围绕它旋转的点，你可以使用方框控制柄，类似于[图 7-10](ch07.xhtml#ch7fig10)。
- en: '![Image](../images/07fig10.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/07fig10.jpg)'
- en: '*Figure 7-10: Rotation around the center*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The pivot point can be moved so the rotation happens around a different point.
    For example, moving it near the bottom-left corner of the bounding box, the rotation
    may look like [Figure 7-11](ch07.xhtml#ch7fig11).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig11.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-11: Rotation around a corner*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by learning how to construct a rotation affine transformation around
    the origin; this will serve as the basis for constructing a more complex rotation
    around any point. [Equation 7.8](ch07.xhtml#ch07eqa08) shows how to rotate points
    *θ* radians around the origin.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07eqa08.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: 'With this in mind, let’s find an affine transformation that rotates points
    *θ* radians around a center point *C*. With *O* as the origin of the coordinate
    system, the transformation is the combination of the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[*T*[1]]: Translate *C* to the origin *O* so the rotation center is *C* (![Image](../images/tvictorit.jpg)
    = ![Image](../images/coline.jpg) = ⟨–*C*[x], –*C*[y]⟩).'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[*T*[2]]: Rotate *θ* radians.'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[*T*[3]]: Translate *C* back to where it was (![Image](../images/tivictor.jpg)
    = ![Image](../images/ocline.jpg) = ⟨*C*[x], *C*[y]⟩).'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It’s the same algorithm as before, but this time we’ll use a rotation instead
    of a scale. [*T*[*r*]] is now computed as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0190-01.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: This yields the affine transformation in [Equation 7.9](ch07.xhtml#ch07eqa09).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07eqa09.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: Let’s create a new factory function to generate rotations around a center point.
    In *affine_transforms.py*, with the help of [Equation 7.9](ch07.xhtml#ch07eqa09),
    implement the new function in [Listing 7-13](ch07.xhtml#ch7lis13).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 7-13: Creating a rotation transformation*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Once again, you want to come up with at least one unit test to make sure our
    implementation is bug free.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give it a try in the shell: let’s create two rotations of *π*/4 radians,
    one around the origin and another one around the point (10, 10). Then, we’ll apply
    both rotations to the point (15, 15) to see where it lands in both cases. Reload
    the Python shell and write the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s now try with the rotation around the origin:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The resulting point has an x-coordinate that is effectively zero (note the exponent
    e-15) and a y-coordinate of 21.2132..., which is the length of the vector going
    from the origin to the original point ![Image](../images/f00192.jpg).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try the second rotation:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The resulting point is (10, 17.071...) this time. To help us make sense of the
    exercise we’ve just done, [Figure 7-12](ch07.xhtml#ch7fig12) illustrates the two
    rotation transformations.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig12.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-12: Example of a rotation around the origin (left) and around the
    point (10, 10) (right)*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '**Interpolating Transformations**'
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you zoom in or out, most graphics programs don’t apply the scale all at
    once, but they typically produce a quick and smooth animation of the zooming process.
    This helps you, the user, better understand how the drawing is being transformed.
    To achieve this, graphics programs typically use a transformation interpolation.
    Later in the book we’ll animate affine transformations, that is, we’ll create
    a kind of movie where we can appreciate how a given geometry is transformed one
    step at a time. Each frame in the animation will depict the geometry after applying
    a fraction of the affine transformation, and this is where we’ll first use *interpolations*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '***Motivating Interpolation***'
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we dive into the concept of interpolating transformations, take a look
    at [Figure 7-13](ch07.xhtml#ch7fig13).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig13.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-13: Animating an affine transformation*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: In the figure, there’s a triangle originally in the bottom left of the window
    that ends up in the top middle after passing through some middle positions drawn
    in a lighter gray. Each of the triangles represents the result we’d see at a given
    point in time, a concrete frame in the animation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want our animation to have *n* frames, where *n* > 1, there needs to
    be *n* affine transformations [*T*[0]], [*T*[1]],..., [*T*[n–1]] such that each
    frame is the result of applying the corresponding transformation to the input
    geometry. It’s clear that the last transformation, [*T*[*n–*1]], needs to be the
    target affine transformation, as the final frame should depict the geometry after
    applying such a transformation. What should [*T*[0]] be then? Let’s give it some
    thought. What transformation applied to the input geometry results in the geometry
    itself? Well, there’s only one such transformation that we know doesn’t move things
    around, the identity transformation. So, our start and end transformations are
    as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0193-01.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: 'How do we go about computing [*T*[1]],...,[*T*[n–2]]? It’s easy: we can interpolate
    each of the start and end values to obtain as many intermediate values as we need.
    For example, a linear interpolation from 0 to 5 using five steps would yield [0,
    1, 2, 3, 4, 5]. Note that five steps produce six values, so to obtain *n* frames,
    we’ll use *n –* 1 steps.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: To interpolate from a start value *v*[*s*] to an end value *v*[*e*], we can
    use any function that passes through them. A straight line (linear function) is
    the simplest one, and the resulting values are uniformly spaced. This is a linear
    interpolation. If we used such interpolation to produce the frames of an animation,
    the result would move at constant speed from the beginning to the end (the slope
    of the interpolating function is constant), which looks unnatural to the eye.
    Why is that? Well, it’s because we’re not used to seeing things in real life abruptly
    accelerating, moving at the same speed, and stopping all of a sudden. This may
    look fine for projectiles or bullets, but it’s strange for most real-life objects
    in motion. We can try a more natural-looking interpolating function such as an
    *ease-in-out*, plotted in the right-side graph of [Figure 7-14](ch07.xhtml#ch7fig14).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig14.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-14: Two interpolation functions*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: In an ease-in-out function, values at the beginning and end vary slowly, which
    gives the sensation of things accelerating as they start to move and softly decelerating
    when reaching the end of their motion. This function defines motion in a much
    more natural way, and animations following this variation of the position with
    respect to time look nice to the human eye.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: To obtain a value between *v*[*s*] and *v*[*e*], we use a parameter *t* such
    that 0 ≤ *t* ≤ 1 (see [Equation 7.10](ch07.xhtml#ch07eqa10)).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07eqa10.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: You can easily observe that [Equation 7.10](ch07.xhtml#ch07eqa10) yields a result
    of *v*[*s*] for *t* = 0 and *v*[*e*] for *t* = 1\. For any intermediate value
    of *t*, the value varies between those two values. If we want to obtain a sequence
    of values starting with *v*[*s*] all the way to *v*[*e*] that follow a linear
    distribution, we just need to use equally spaced values for *t*, like, for example,
    [0, 0.25, 0.5, 0.75, 1].
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: To produce an ease-in-out distribution of interpolated values, we need a sequence
    of *t* values from 0 to 1 with uneven spacing, with small steps near the extreme
    values and greater steps around the middle. If we represent the values of *t*
    by circles in a horizontal line starting at *t* = 0 and ending at *t* = 1, we
    can get a sense of how uniform and ease-in-out values are distributed from [Figure
    7-15](ch07.xhtml#ch7fig15).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07fig15.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-15: Interpolating t values*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: To build the sequence of *t* values distributed according to the right-side
    plot in [Figure 7-14](ch07.xhtml#ch7fig14), we can plug a sequence of evenly spaced
    *t* values into [Equation 7.11](ch07.xhtml#ch07eqa11).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/07eqa11.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: This alters their spacing so that more of them lie near the extremes 0 and 1
    and fewer are located in the middle.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: We have all the ingredients that we need; let’s get our hands dirty!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '***Implementing Interpolation***'
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Create a new file named *interpolation.py* inside *geom2d* and enter the code
    in [Listing 7-14](ch07.xhtml#ch7lis14).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 7-14: Interpolated t values*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting from the bottom, we have the function ease_in_out_t, which is simply
    the implementation of [Equation 7.11](ch07.xhtml#ch07eqa11). The first function
    builds a sequence of uniformly distributed *t* values using the given number of
    steps, thus producing as many values as steps plus one. We can test that in the
    shell. Reload it and try the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Function ease_in_out_t_sequence, on the other hand, creates sequences following
    an ease-in-out distribution. To do so, it applies [Equation 7.11](ch07.xhtml#ch07eqa11)
    to values of a uniform sequence. Let’s try it as well in the shell:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See how values near 0 and 1 are closer together while values in the middle (near
    0.5) are farther apart? Great, so we’re just missing a function to interpolate
    between two values for a given *t*, just as [Equation 7.10](ch07.xhtml#ch07eqa10)
    defines. Add [Listing 7-15](ch07.xhtml#ch7lis15) in *interpolation.py*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 7-15: Interpolating between two values given t*'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: If you recall from [Chapter 5](ch05.xhtml#ch05), when we operate using a passed-in
    *t* parameter value, we want to check that it’s inside its expected range, for
    which the ensure_valid function is used. We’re now ready for the last step, and
    I hope you followed along, because here’s the actual interpolation of affine transformations
    we’ve been pursuing. Open your file *affine_transforms.py*, where we defined factory
    functions to create several special types of affine transformations, and enter
    the code in [Listing 7-16](ch07.xhtml#ch7lis16).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 7-16: Sequence of interpolated affine transformations*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: To help generate a sequence of interpolated affine transformations, we define
    a private function __interpolated, which, given two transformations and a value
    for *t*, returns the interpolation for that *t* ➌. Each value for the new transformation
    is the result of interpolating the values of both start and end transformations.
    Then we build a sequence of *t* values following the ease-in-out distribution
    ➊, each of which is mapped to the interpolated transformation using a list comprehension
    ➋.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: We’ll leave this for now until [Chapter 12](ch12.xhtml#ch12), where we’ll be
    using the sequences of interpolated affine transformations to produce animations.
    Don’t worry if the concepts explored in this last part of the chapter seem a little
    abstract. We’ll build the foundations of animating motion in the next part of
    the book, and until then it may be hard to make sense out of this interpolation
    thing.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '**Geom2D Final Touches**'
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our *geom2d* package is tested and ready to be used throughout the rest of the
    book. We made it robust, but we can add a few small improvements before concluding
    this part of the book.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '***Test Files***'
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first thing we want to do is separate implementation and test files, which
    are all in the same folder at the moment. This is so that the *geom2d* package
    folder appears less cluttered and you can find implementation files easier. In
    the package, create a new folder named *tests*, and then select all test files,
    which we conveniently named ending in *_test.py*, and drag them to the folder.
    Your folder structure and files should look like the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Mechanics
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '|- geom2d'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- tests'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '|    |    |- affine_transf_test.py'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '|    |    |- affine_transforms_test.py'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '|    |    |- circle_test.py'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '|    |    |- ...'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '|    |    |- vector_test.py'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- __init__.py'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- affine_transf.py'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- affine_transforms.py'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- circle.py'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- ...'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- vectors.py'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '***Running All Tests***'
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that all our test files live in the same folder, what about running all
    test cases at once? It may happen that you changed part of the code and want to
    make sure you didn’t break anything, for which you decide to run every test in
    the package. The way we’ve been doing it would take you some time, as you’d have
    to open the test files one by one and click the green play button beside each
    of the class names. There’s a better way!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Terminal view inside PyCharm. If you can’t see it, from the menu select
    **View** ▸ **Tool Windows** ▸ **Terminal**. By default, the shell opens right
    in the root directory of the project, which is exactly what we want. In the shell,
    run the following command:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This command tells Python to discover and run all unit tests in *geom2d/tests/*
    inside files matching the pattern **_test.py*, that is, all files ending in *_test.py*.
    Running the command should result in something similar to the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can save this command in a bash file at the project’s root level so you
    can execute it whenever you want without needing to memorize it.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '***Package Imports***'
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last thing we want to do is include all modules in the package’s exports
    so that they can be loaded like so:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Compare this to the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The latter requires the user to type the path where each module lives in *geom2d*,
    but the former doesn’t: everything inside the package can be imported directly
    from the package itself. This style of exporting modules of a package is convenient
    for two reasons: (1) because it allows us to change the directory structure within
    the module without breaking the user’s imports and (2) because users don’t need
    to know where each module is located within the package and import everything
    from the package itself. As you can guess, this greatly reduces the cognitive
    load for using the package.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: When PyCharm created the package *geom2d*, it included an empty file inside
    it named *__init__.py*. Can you spot it? Files with this name inside packages
    are loaded when the package itself is imported. We can use them to import what
    is defined inside the package.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '*If for whatever reason the file* __init__.py *doesn’t exist in your* geom2d
    *package, simply create it. Maybe you created the package as a normal directory
    inside PyCharm so the IDE didn’t add it for you.*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: So, open the file, which should be empty, and import all of the primitives we
    defined (see [Listing 7-17](ch07.xhtml#ch7lis17)).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 7-17: The geom2d package init file*'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s all! To understand what we achieve with this change, you can try the
    following in the shell (Python’s shell, not the shell we just used to run commands):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will prove convenient in future chapters, as we can import any module from
    *geom2d* directly from the package.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, we explored a core concept in computer graphics: affine transformations.
    They allow us to transform geometry by scaling, rotating, translating, and shearing
    it.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'We started by taking a look at their mathematical definition and how they differ
    from linear transformations. The takeaway is that affine transformations can move
    the origin point, while linear transformations cannot. Affine transformations
    can be expressed as the combination of a linear transformation with a translation,
    but we saw a more convenient representation: the augmented matrix. Next, we implemented
    methods in the AffineTransform class to transform our geometric primitives: points,
    segments, and polygons.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'We then learned how transformations can be concatenated to achieve complex
    transformations out of simpler ones. Thanks to that powerful idea, we were able
    to construct two essential affine transformations that happen in almost every
    graphics application we know: scaling and rotating around a point other than the
    origin.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we implemented a function to interpolate between two affine transformations,
    yielding a couple intermediate transformations that we’ll soon be using to produce
    animations.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
