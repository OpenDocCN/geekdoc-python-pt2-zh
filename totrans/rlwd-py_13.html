<html><head></head><body>
<h2 class="h2" id="app01"><span epub:type="pagebreak" id="page_283"/><strong>APPENDIX<br/>PRACTICE PROJECT SOLUTIONS</strong></h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">This appendix contains solutions to the practice projects in each chapter. Digital versions are available on the bookâ€™s website at <em><a href="https://nostarch.com/real-world-python/">https://nostarch.com/real-world-python/</a></em>.</p>&#13;
<h3 class="h3" id="ch00lev1sec103"><strong><a href="ch02.xhtml">Chapter 2</a>: Attributing Authorship with Stylometry</strong></h3>&#13;
<h4 class="h4" id="ch00lev2sec69"><strong><em>Hunting the Hound with Dispersion</em></strong></h4>&#13;
<pre><span class="codeitalic1">practice_hound_dispersion.py</span>&#13;
"""Use NLP (nltk) to make dispersion plot."""&#13;
import nltk&#13;
import file_loader&#13;
&#13;
corpus = file_loader.text_to_string('hound.txt')&#13;
tokens = nltk.word_tokenize(corpus)&#13;
tokens = nltk.Text(tokens)  # NLTK wrapper for automatic text analysis.&#13;
<span epub:type="pagebreak" id="page_284"/>dispersion = tokens.dispersion_plot(['Holmes',&#13;
                                     'Watson',&#13;
                                     'Mortimer',&#13;
                                     'Henry',&#13;
                                     'Barrymore', &#13;
                                     'Stapleton',&#13;
                                     'Selden',&#13;
                                     'hound'])</pre>&#13;
<h4 class="h4" id="ch00lev2sec70"><strong><em>Punctuation Heatmap</em></strong></h4>&#13;
<pre><span class="codeitalic1">practice_heatmap_semicolon.py</span>&#13;
"""Make a heatmap of punctuation."""&#13;
import math&#13;
from string import punctuation&#13;
import nltk&#13;
import numpy as np&#13;
import matplotlib.pyplot as plt&#13;
from matplotlib.colors import ListedColormap&#13;
import seaborn as sns&#13;
&#13;
# Install seaborn using: pip install seaborn.&#13;
&#13;
PUNCT_SET = set(punctuation)&#13;
&#13;
def main():  &#13;
    # Load text files into dictionary by author.&#13;
    strings_by_author = dict()&#13;
    strings_by_author['doyle'] = text_to_string('hound.txt')&#13;
    strings_by_author['wells'] = text_to_string('war.txt')&#13;
    strings_by_author['unknown'] = text_to_string('lost.txt')&#13;
&#13;
    # Tokenize text strings preserving only punctuation marks.&#13;
    punct_by_author = make_punct_dict(strings_by_author)&#13;
&#13;
    # Convert punctuation marks to numerical values and plot heatmaps.&#13;
    plt.ion()&#13;
    for author in punct_by_author:&#13;
        heat = convert_punct_to_number(punct_by_author, author)&#13;
        arr = np.array((heat[:6561])) # trim to largest size for square array&#13;
        arr_reshaped = arr.reshape(int(math.sqrt(len(arr))),&#13;
                                   int(math.sqrt(len(arr))))&#13;
        fig, ax = plt.subplots(figsize=(7, 7))&#13;
        sns.heatmap(arr_reshaped,&#13;
                    cmap=ListedColormap(['blue', 'yellow']),&#13;
                    square=True,&#13;
                    ax=ax)&#13;
        ax.set_title('Heatmap Semicolons {}'.format(author))&#13;
    plt.show()    &#13;
&#13;
<span epub:type="pagebreak" id="page_285"/>def text_to_string(filename):&#13;
    """Read a text file and return a string."""&#13;
    with open(filename) as infile:&#13;
        return infile.read()&#13;
&#13;
def make_punct_dict(strings_by_author):&#13;
    """Return dictionary of tokenized punctuation by corpus by author."""&#13;
    punct_by_author = dict()&#13;
    for author in strings_by_author:&#13;
        tokens = nltk.word_tokenize(strings_by_author[author])&#13;
        punct_by_author[author] = ([token for token in tokens&#13;
                                    if token in PUNCT_SET])&#13;
        print("Number punctuation marks in {} = {}"&#13;
              .format(author, len(punct_by_author[author])))&#13;
    return punct_by_author  &#13;
&#13;
def convert_punct_to_number(punct_by_author, author):&#13;
    """Return list of punctuation marks converted to numerical values."""&#13;
    heat_vals = []&#13;
    for char in punct_by_author[author]:&#13;
        if char == ';':&#13;
            value = 1&#13;
        else:&#13;
            value = 2&#13;
        heat_vals.append(value)&#13;
    return heat_vals&#13;
&#13;
if __name__ == '__main__':&#13;
    main()</pre>&#13;
<h3 class="h3" id="ch00lev1sec104"><strong><a href="ch04.xhtml">Chapter 4</a>: Sending Super-Secret Messages with a Book Cipher</strong></h3>&#13;
<h4 class="h4" id="ch00lev2sec71"><strong><em>Charting the Characters</em></strong></h4>&#13;
<pre><span class="codeitalic1">practice_barchart.py</span>&#13;
"""Plot barchart of characters in text file."""&#13;
import sys&#13;
import os&#13;
import operator&#13;
from collections import Counter&#13;
import matplotlib.pyplot as plt&#13;
&#13;
def load_file(infile):&#13;
    """Read and return text file as string of lowercase characters."""&#13;
    with open(infile) as f:&#13;
        text = f.read().lower()&#13;
    return text&#13;
<span epub:type="pagebreak" id="page_286"/>def main():&#13;
    infile = 'lost.txt'&#13;
    if not os.path.exists(infile):&#13;
        print("File {} not found. Terminating.".format(infile),&#13;
              file=sys.stderr)&#13;
        sys.exit(1)&#13;
       &#13;
    text = load_file(infile)&#13;
    &#13;
    # Make bar chart of characters in text and their frequency.&#13;
    char_freq = Counter(text)&#13;
    char_freq_sorted = sorted(char_freq.items(),&#13;
                              key=operator.itemgetter(1), reverse=True)&#13;
    x, y = zip(*char_freq_sorted)  # * unpacks iterable.&#13;
    fig, ax = plt.subplots()&#13;
    ax.bar(x, y)&#13;
    fig.show()&#13;
&#13;
if __name__ == '__main__':&#13;
    main()</pre>&#13;
<h4 class="h4" id="ch00lev2sec72"><strong><em>Sending Secrets the WWII Way</em></strong></h4>&#13;
<pre><span class="codeitalic1">practice_WWII_words.py</span>&#13;
"""Book code using the novel The Lost World&#13;
&#13;
For words not in book, spell-out with first letter of words.&#13;
Flag 'first letter mode' by bracketing between alternating&#13;
'a a' and 'the the'.&#13;
&#13;
credit: Eric T. Mortenson&#13;
"""&#13;
import sys&#13;
import os&#13;
import random&#13;
import string&#13;
from collections import defaultdict, Counter&#13;
&#13;
def main():&#13;
    message = input("Enter plaintext or ciphertext: ") &#13;
    process = input("Enter 'encrypt' or 'decrypt': ")  &#13;
    shift = int(input("Shift value (1-365) = "))&#13;
    infile = input("Enter filename with extension: ")&#13;
    &#13;
    if not os.path.exists(infile):&#13;
        print("File {} not found. Terminating.".format(infile), file=sys.stderr)&#13;
        sys.exit(1)        &#13;
    word_list = load_file(infile)&#13;
    word_dict = make_dict(word_list, shift)&#13;
    letter_dict = make_letter_dict(word_list)&#13;
&#13;
    if process == 'encrypt':&#13;
        ciphertext = encrypt(message, word_dict, letter_dict)          &#13;
        count = Counter(ciphertext)        &#13;
        <span epub:type="pagebreak" id="page_287"/>encryptedWordList = []&#13;
        for number in ciphertext:&#13;
            encryptedWordList.append(word_list[number - shift])&#13;
        &#13;
        print("\nencrypted word list = \n {} \n"&#13;
              .format(' '.join(encryptedWordList)))           &#13;
        print("encrypted ciphertext = \n {}\n".format(ciphertext))&#13;
        &#13;
        # Check the encryption by decrypting the ciphertext.&#13;
        print("decrypted plaintext = ")&#13;
        singleFirstCheck = False&#13;
        for cnt, i in enumerate(ciphertext):&#13;
            if word_list[ciphertext[cnt]-shift] == 'a' and \&#13;
               word_list[ciphertext[cnt+1]-shift] == 'a':&#13;
                continue&#13;
            if word_list[ciphertext[cnt]-shift] == 'a' and \&#13;
               word_list[ciphertext[cnt-1]-shift] == 'a':&#13;
                singleFirstCheck = True&#13;
                continue&#13;
            if singleFirstCheck == True and cnt&lt;len(ciphertext)-1 and \&#13;
               word_list[ciphertext[cnt]-shift] == 'the' and \&#13;
                             word_list[ciphertext[cnt+1]-shift] == 'the':&#13;
                continue&#13;
            if singleFirstCheck == True and \&#13;
               word_list[ciphertext[cnt]-shift] == 'the' and \&#13;
                             word_list[ciphertext[cnt-1]-shift] == 'the':&#13;
                singleFirstCheck = False&#13;
                print(' ', end='', flush=True)&#13;
                continue&#13;
            if singleFirstCheck == True:&#13;
                print(word_list[i - shift][0], end = '', flush=True)&#13;
            if singleFirstCheck == False:&#13;
                print(word_list[i - shift], end=' ', flush=True)&#13;
&#13;
    elif process == 'decrypt':&#13;
        plaintext = decrypt(message, word_list, shift)&#13;
        print("\ndecrypted plaintext = \n {}".format(plaintext))&#13;
&#13;
def load_file(infile):&#13;
    """Read and return text file as a list of lowercase words."""&#13;
    with open(infile, encoding='utf-8') as file:&#13;
        words = [word.lower() for line in file for word in line.split()]&#13;
        words_no_punct = ["".join(char for char in word if char not in \&#13;
                                 string.punctuation) for word in words]&#13;
    return words_no_punct&#13;
&#13;
def make_dict(word_list, shift):&#13;
    """Return dictionary of characters as keys and shifted indexes as values."""&#13;
    word_dict = defaultdict(list)&#13;
    for index, word in enumerate(word_list):&#13;
        word_dict[word].append(index + shift)&#13;
    return word_dict&#13;
&#13;
def make_letter_dict(word_list):&#13;
    firstLetterDict = defaultdict(list)&#13;
    <span epub:type="pagebreak" id="page_288"/>for word in word_list:&#13;
        if len(word) &gt; 0:&#13;
            if word[0].isalpha():&#13;
                firstLetterDict[word[0]].append(word)&#13;
    return firstLetterDict&#13;
&#13;
def encrypt(message, word_dict, letter_dict):&#13;
    """Return list of indexes representing characters in a message."""&#13;
    encrypted = []&#13;
    # remove punctuation from message words&#13;
    messageWords = message.lower().split()&#13;
    messageWordsNoPunct = ["".join(char for char in word if char not in \&#13;
                                 string.punctuation) for word in messageWords]    &#13;
    for word in messageWordsNoPunct:&#13;
        if len(word_dict[word]) &gt; 1:&#13;
            index = random.choice(word_dict[word])&#13;
        elif len(word_dict[word]) == 1:  # Random.choice fails if only 1 choice.&#13;
            index = word_dict[word][0]&#13;
        elif len(word_dict[word]) == 0:  # Word not in word_dict.&#13;
            encrypted.append(random.choice(word_dict['a']))&#13;
            encrypted.append(random.choice(word_dict['a']))&#13;
&#13;
            for letter in word:&#13;
                if letter not in letter_dict.keys():&#13;
                    print('\nLetter {} not in letter-to-word dictionary.'&#13;
                          .format(letter), file=sys.stderr)&#13;
                    continue&#13;
                if len(letter_dict[letter])&gt;1:&#13;
                    newWord =random.choice(letter_dict[letter])&#13;
                else:&#13;
                    newWord = letter_dict[letter][0]&#13;
                if len(word_dict[newWord])&gt;1:&#13;
                    index = random.choice(word_dict[newWord])&#13;
                else:&#13;
                    index = word_dict[newWord][0]&#13;
                encrypted.append(index)&#13;
                &#13;
            encrypted.append(random.choice(word_dict['the']))&#13;
            encrypted.append(random.choice(word_dict['the']))&#13;
            continue&#13;
        encrypted.append(index)&#13;
    return encrypted&#13;
&#13;
def decrypt(message, word_list, shift):&#13;
    """Decrypt ciphertext string and return plaintext word string.&#13;
    This shows how plaintext looks before extracting first letters.&#13;
    """&#13;
    plaintextList = []&#13;
    indexes = [s.replace(',', '').replace('[', '').replace(']', '')&#13;
               for s in message.split()]&#13;
    for count, i in enumerate(indexes):&#13;
        plaintextList.append(word_list[int(i) - shift])&#13;
    return ' '.join(plaintextList)&#13;
&#13;
<span epub:type="pagebreak" id="page_289"/>def check_for_fail(ciphertext):&#13;
    """Return True if ciphertext contains any duplicate keys."""&#13;
    check = [k for k, v in Counter(ciphertext).items() if v &gt; 1]&#13;
    if len(check) &gt; 0:&#13;
        print(check)&#13;
        return True&#13;
&#13;
if __name__ == '__main__':&#13;
    main()</pre>&#13;
<h3 class="h3" id="ch00lev1sec105"><strong><a href="ch05.xhtml">Chapter 5</a>: Finding Pluto</strong></h3>&#13;
<h4 class="h4" id="ch00lev2sec73"><strong><em>Plotting the Orbital Path</em></strong></h4>&#13;
<pre><span class="codeitalic1">practice_orbital_path.py</span>&#13;
import os&#13;
from pathlib import Path&#13;
import cv2 as cv&#13;
&#13;
PAD = 5  # Ignore pixels this distance from edge&#13;
&#13;
def find_transient(image, diff_image, pad):&#13;
    """Takes image, difference image, and pad value in pixels and returns&#13;
       boolean and location of maxVal in difference image excluding an edge&#13;
       rind. Draws circle around maxVal on image."""&#13;
    transient = False&#13;
    height, width = diff_image.shape&#13;
    cv.rectangle(image, (PAD, PAD), (width - PAD, height - PAD), 255, 1)&#13;
    minVal, maxVal, minLoc, maxLoc = cv.minMaxLoc(diff_image)&#13;
    if pad &lt; maxLoc[0] &lt; width - pad and pad &lt; maxLoc[1] &lt; height - pad:&#13;
        cv.circle(image, maxLoc, 10, 255, 0)&#13;
        transient = True&#13;
    return transient, maxLoc&#13;
&#13;
def main():&#13;
    night1_files = sorted(os.listdir('night_1_registered_transients'))&#13;
    night2_files = sorted(os.listdir('night_2'))             &#13;
    path1 = Path.cwd() / 'night_1_registered_transients'&#13;
    path2 = Path.cwd() / 'night_2'&#13;
    path3 = Path.cwd() / 'night_1_2_transients'&#13;
    &#13;
    # Images should all be the same size and similar exposures.    &#13;
    for i, _ in enumerate(night1_files[:-1]):  # Leave off negative image   &#13;
        img1 = cv.imread(str(path1 / night1_files[i]), cv.IMREAD_GRAYSCALE)&#13;
        img2 = cv.imread(str(path2 / night2_files[i]), cv.IMREAD_GRAYSCALE)&#13;
        # Get absolute difference between images.&#13;
        diff_imgs1_2 = cv.absdiff(img1, img2)&#13;
        cv.imshow('Difference', diff_imgs1_2)&#13;
        cv.waitKey(2000)        &#13;
&#13;
        <span epub:type="pagebreak" id="page_290"/># Copy difference image and find and circle brightest pixel.&#13;
        temp = diff_imgs1_2.copy()&#13;
        transient1, transient_loc1 = find_transient(img1, temp, PAD)&#13;
&#13;
        # Draw black circle on temporary image to obliterate brightest spot.&#13;
        cv.circle(temp, transient_loc1, 10, 0, -1)&#13;
&#13;
        # Get location of new brightest pixel and circle it on input image.        &#13;
        transient2, transient_loc2 = find_transient(img1, temp, PAD)&#13;
&#13;
        if transient1 or transient2:&#13;
            print('\nTRANSIENT DETECTED between {} and {}\n'&#13;
                  .format(night1_files[i], night2_files[i]))&#13;
            font = cv.FONT_HERSHEY_COMPLEX_SMALL&#13;
            cv.putText(img1, night1_files[i], (10, 25),&#13;
                       font, 1, (255, 255, 255), 1, cv.LINE_AA)&#13;
            cv.putText(img1, night2_files[i], (10, 55),&#13;
                       font, 1, (255, 255, 255), 1, cv.LINE_AA)&#13;
            if transient1 and transient2:&#13;
                cv.line(img1, transient_loc1, transient_loc2, (255, 255, 255),&#13;
                        1, lineType=cv.LINE_AA)&#13;
                &#13;
            blended = cv.addWeighted(img1, 1, diff_imgs1_2, 1, 0)&#13;
            cv.imshow('Surveyed', blended)&#13;
            cv.waitKey(2500)  # Keeps window open 2.5 seconds.&#13;
            out_filename = '{}_DECTECTED.png'.format(night1_files[i][:-4])&#13;
            cv.imwrite(str(path3 / out_filename), blended)  # Will overwrite!&#13;
        else:&#13;
            print('\nNo transient detected between {} and {}\n'&#13;
                  .format(night1_files[i], night2_files[i]))&#13;
&#13;
if __name__ == '__main__':&#13;
    main()</pre>&#13;
<h4 class="h4" id="ch00lev2sec74"><strong><em>Whatâ€™s the Difference?</em></strong></h4>&#13;
<p class="noindent">This practice project uses two programs, <em>practice_montage_aligner.py</em> and <em>practice_montage_difference_finder.py</em>. The programs should be run in the order presented.</p>&#13;
<h5 class="h5"><strong>practice_montage_aligner.py</strong></h5>&#13;
<pre><span class="codeitalic1">practice_montage_aligner.py</span>&#13;
import numpy as np&#13;
import cv2 as cv&#13;
&#13;
MIN_NUM_KEYPOINT_MATCHES = 150&#13;
&#13;
img1 = cv.imread('montage_left.JPG', cv.IMREAD_COLOR)  # queryImage&#13;
img2 = cv.imread('montage_right.JPG', cv.IMREAD_COLOR) # trainImage&#13;
<span epub:type="pagebreak" id="page_291"/>img1 = cv.cvtColor(img1, cv.COLOR_BGR2GRAY)  # Convert to grayscale.&#13;
img2 = cv.cvtColor(img2, cv.COLOR_BGR2GRAY)&#13;
&#13;
orb = cv.ORB_create(nfeatures=700) &#13;
&#13;
# Find the keypoints and descriptions with ORB.&#13;
kp1, desc1 = orb.detectAndCompute(img1, None)&#13;
kp2, desc2 = orb.detectAndCompute(img2, None)&#13;
&#13;
# Find keypoint matches using Brute Force Matcher.&#13;
bf = cv.BFMatcher(cv.NORM_HAMMING, crossCheck=True)&#13;
matches = bf.match(desc1, desc2, None)&#13;
&#13;
# Sort matches in ascending order of distance.&#13;
matches = sorted(matches, key=lambda x: x.distance)&#13;
          &#13;
# Draw best matches.&#13;
img3 = cv.drawMatches(img1, kp1, img2, kp2, &#13;
                       matches[:MIN_NUM_KEYPOINT_MATCHES],&#13;
                       None)&#13;
&#13;
cv.namedWindow('Matches', cv.WINDOW_NORMAL)&#13;
img3_resize = cv.resize(img3, (699, 700))&#13;
cv.imshow('Matches', img3_resize)&#13;
cv.waitKey(7000)  # Keeps window open 7 seconds.&#13;
cv.destroyWindow('Matches')&#13;
&#13;
# Keep only best matches.&#13;
best_matches = matches[:MIN_NUM_KEYPOINT_MATCHES]&#13;
&#13;
if len(best_matches) &gt;= MIN_NUM_KEYPOINT_MATCHES:&#13;
    src_pts = np.zeros((len(best_matches), 2), dtype=np.float32)&#13;
    dst_pts = np.zeros((len(best_matches), 2), dtype=np.float32)&#13;
&#13;
    for i, match in enumerate(best_matches):&#13;
        src_pts[i, :] = kp1[match.queryIdx].pt&#13;
        dst_pts[i, :] = kp2[match.trainIdx].pt&#13;
        &#13;
    M, mask = cv.findHomography(src_pts, dst_pts, cv.RANSAC)&#13;
&#13;
    # Get dimensions of image 2.&#13;
    height, width = img2.shape&#13;
    img1_warped = cv.warpPerspective(img1, M, (width, height))&#13;
&#13;
    cv.imwrite('montage_left_registered.JPG', img1_warped)&#13;
    cv.imwrite('montage_right_gray.JPG', img2)&#13;
&#13;
else:&#13;
    print("\n{}\n".format('WARNING: Number of keypoint matches &lt; 10!'))</pre>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_292"/><strong>practice_montage_difference_finder.py</strong></h5>&#13;
<pre><span class="codeitalic1">practice_montage_difference_finder.py</span>&#13;
import cv2 as cv&#13;
&#13;
filename1 = 'montage_left.JPG'&#13;
filename2 = 'montage_right_gray.JPG'&#13;
&#13;
img1 = cv.imread(filename1, cv.IMREAD_GRAYSCALE)&#13;
img2 = cv.imread(filename2, cv.IMREAD_GRAYSCALE)&#13;
&#13;
# Absolute difference between image 2 &amp; 3:&#13;
diff_imgs1_2 = cv.absdiff(img1, img2)&#13;
&#13;
cv.namedWindow('Difference', cv.WINDOW_NORMAL)&#13;
diff_imgs1_2_resize = cv.resize(diff_imgs1_2, (699, 700))&#13;
cv.imshow('Difference', diff_imgs1_2_resize)&#13;
&#13;
crop_diff = diff_imgs1_2[10:2795, 10:2445]  # x, y, w, h = 10, 10, 2790, 2440&#13;
&#13;
# Blur to remove extraneous noise.&#13;
blurred = cv.GaussianBlur(crop_diff, (5, 5), 0)&#13;
&#13;
(minVal, maxVal, minLoc, maxLoc2) = cv.minMaxLoc(blurred)&#13;
cv.circle(img2, maxLoc2, 100, 0, 3)&#13;
x, y = int(img2.shape[1]/4), int(img2.shape[0]/4)&#13;
img2_resize = cv.resize(img2, (x, y))&#13;
cv.imshow('Change', img2_resize)</pre>&#13;
<h3 class="h3" id="ch00lev1sec106"><strong><a href="ch06.xhtml">Chapter 6</a>: Winning the Moon Race with Apollo 8</strong></h3>&#13;
<h4 class="h4" id="ch00lev2sec75"><strong><em>Simulating a Search Pattern</em></strong></h4>&#13;
<pre><span class="codeitalic1">practice_search_pattern.py</span>&#13;
import time&#13;
import random&#13;
import turtle&#13;
   &#13;
SA_X = 600  # Search area width.&#13;
SA_Y = 480  # Search area height.&#13;
TRACK_SPACING = 40  # Distance between search tracks.&#13;
  &#13;
# Setup screen. &#13;
screen = turtle.Screen()&#13;
screen.setup(width=SA_X, height=SA_Y)&#13;
turtle.resizemode('user')&#13;
screen.title("Search Pattern")&#13;
rand_x = random.randint(0, int(SA_X / 2)) * random.choice([-1, 1])&#13;
rand_y = random.randint(0, int(SA_Y / 2)) * random.choice([-1, 1])&#13;
&#13;
<span epub:type="pagebreak" id="page_293"/># Set up turtle images.&#13;
seaman_image = 'seaman.gif'&#13;
screen.addshape(seaman_image)&#13;
copter_image_left = 'helicopter_left.gif'&#13;
copter_image_right = 'helicopter_right.gif'&#13;
screen.addshape(copter_image_left)&#13;
screen.addshape(copter_image_right)&#13;
&#13;
# Instantiate seaman turtle.&#13;
seaman = turtle.Turtle(seaman_image)&#13;
seaman.hideturtle()&#13;
seaman.penup()&#13;
seaman.setpos(rand_x, rand_y)&#13;
seaman.showturtle()&#13;
&#13;
# Instantiate copter turtle.&#13;
turtle.shape(copter_image_right)&#13;
turtle.hideturtle()&#13;
turtle.pencolor('black')&#13;
turtle.penup()&#13;
turtle.setpos(-(int(SA_X / 2) - TRACK_SPACING), int(SA_Y / 2) - TRACK_SPACING)&#13;
turtle.showturtle()&#13;
turtle.pendown()&#13;
&#13;
# Run search pattern and announce discovery of seaman.&#13;
for i in range(int(SA_Y / TRACK_SPACING)):     &#13;
    turtle.fd(SA_X - TRACK_SPACING * 2)&#13;
    turtle.rt(90)&#13;
    turtle.fd(TRACK_SPACING / 2)&#13;
    turtle.rt(90)&#13;
    turtle.shape(copter_image_left)&#13;
    turtle.fd(SA_X - TRACK_SPACING * 2)&#13;
    turtle.lt(90)&#13;
    turtle.fd(TRACK_SPACING / 2)&#13;
    turtle.lt(90)&#13;
    turtle.shape(copter_image_right)&#13;
    if turtle.ycor() - seaman.ycor() &lt;= 10:&#13;
        turtle.write("      Seaman found!",&#13;
                     align='left',&#13;
                     font=("Arial", 15, 'normal', 'bold', 'italic'))&#13;
        time.sleep(3)&#13;
&#13;
        break</pre>&#13;
<h4 class="h4" id="ch00lev2sec76"><strong><em>Start Me Up!</em></strong></h4>&#13;
<pre>practice_grav _assist_stationary.py&#13;
"""gravity_assist_stationary.py&#13;
&#13;
Moon approaches stationary ship, which is swung around and flung away.&#13;
&#13;
Credit: Eric T. Mortenson&#13;
"""&#13;
<span epub:type="pagebreak" id="page_294"/>from turtle import Shape, Screen, Turtle, Vec2D as Vec&#13;
import turtle&#13;
import math&#13;
&#13;
# User input:&#13;
G = 8  # Gravitational constant used for the simulation.&#13;
NUM_LOOPS = 4100  # Number of time steps in simulation.&#13;
Ro_X = 0  # Ship starting position x coordinate.&#13;
Ro_Y = -50  # Ship starting position y coordinate.&#13;
Vo_X = 0  # Ship velocity x component.&#13;
Vo_Y = 0  # Ship velocity y component.&#13;
&#13;
MOON_MASS = 1_250_000&#13;
&#13;
class GravSys():&#13;
    """Runs a gravity simulation on n-bodies."""&#13;
&#13;
    def __init__(self):&#13;
        self.bodies = []&#13;
        self.t = 0&#13;
        self.dt = 0.001&#13;
&#13;
    def sim_loop(self):&#13;
        """Loop bodies in a list through time steps."""&#13;
        for _ in range(NUM_LOOPS):&#13;
            self.t += self.dt&#13;
            for body in self.bodies:&#13;
                body.step()&#13;
                &#13;
class Body(Turtle):&#13;
    """Celestial object that orbits and projects gravity field."""&#13;
    def __init__(self, mass, start_loc, vel, gravsys, shape):&#13;
        super().__init__(shape=shape)&#13;
        self.gravsys = gravsys&#13;
        self.penup()&#13;
        self.mass=mass&#13;
        self.setpos(start_loc)&#13;
        self.vel = vel&#13;
        gravsys.bodies.append(self)&#13;
        self.pendown()  # uncomment to draw path behind object&#13;
        &#13;
        &#13;
    def acc(self):&#13;
        """Calculate combined force on body and return vector components."""&#13;
        a = Vec(0,0)&#13;
        for body in self.gravsys.bodies:&#13;
            if body != self:&#13;
                r = body.pos() - self.pos()&#13;
                a += (G * body.mass / abs(r)**3) * r  # units dist/time^2&#13;
        return a&#13;
    <span epub:type="pagebreak" id="page_295"/>def step(self):&#13;
        """Calculate position, orientation, and velocity of a body."""&#13;
        dt = self.gravsys.dt&#13;
        a = self.acc()&#13;
        self.vel = self.vel + dt * a&#13;
        xOld, yOld = self.pos()  # for orienting ship&#13;
        self.setpos(self.pos() + dt * self.vel)&#13;
        xNew, yNew = self.pos()  # for orienting ship&#13;
        if self.gravsys.bodies.index(self) == 1: # the CSM&#13;
            dir_radians = math.atan2(yNew-yOld,xNew-xOld)  # for orienting ship&#13;
            dir_degrees = dir_radians * 180 / math.pi  # for orienting ship&#13;
            self.setheading(dir_degrees+90)  # for orienting ship&#13;
&#13;
def main():&#13;
    # Setup screen&#13;
    screen = Screen()&#13;
    screen.setup(width=1.0, height=1.0)  # for fullscreen&#13;
    screen.bgcolor('black')&#13;
    screen.title("Gravity Assist Example")&#13;
&#13;
    # Instantiate gravitational system&#13;
    gravsys = GravSys()&#13;
    &#13;
    # Instantiate Planet&#13;
    image_moon = 'moon_27x27.gif'&#13;
    screen.register_shape(image_moon)&#13;
    moon = Body(MOON_MASS, (500, 0), Vec(-500, 0), gravsys, image_moon)&#13;
    moon.pencolor('gray')&#13;
&#13;
    # Build command-service-module (csm) shape&#13;
    csm = Shape('compound')&#13;
    cm = ((0, 30), (0, -30), (30, 0))&#13;
    csm.addcomponent(cm, 'red', 'red')&#13;
    sm = ((-60,30), (0, 30), (0, -30), (-60, -30))&#13;
    csm.addcomponent(sm, 'red', 'black')&#13;
    nozzle = ((-55, 0), (-90, 20), (-90, -20))&#13;
    csm.addcomponent(nozzle, 'red', 'red')&#13;
    screen.register_shape('csm', csm)&#13;
&#13;
    # Instantiate Apollo 8 CSM turtle&#13;
    ship = Body(1, (Ro_X, Ro_Y), Vec(Vo_X, Vo_Y), gravsys, "csm")&#13;
    ship.shapesize(0.2)&#13;
    ship.color('red') # path color&#13;
    ship.getscreen().tracer(1, 0)&#13;
    ship.setheading(90)&#13;
&#13;
    gravsys.sim_loop()&#13;
&#13;
if __name__=='__main__':&#13;
    main()</pre>&#13;
<h4 class="h4" id="ch00lev2sec77"><span epub:type="pagebreak" id="page_296"/><strong><em>Shut Me Down!</em></strong></h4>&#13;
<pre><span class="codeitalic1">practice_grav_assist_intersecting.py</span>&#13;
"""gravity_assist_intersecting.py&#13;
&#13;
Moon and ship cross orbits and moon slows and turns ship.&#13;
&#13;
Credit: Eric T. Mortenson&#13;
"""&#13;
&#13;
from turtle import Shape, Screen, Turtle, Vec2D as Vec&#13;
import turtle&#13;
import math&#13;
import sys&#13;
&#13;
# User input:&#13;
G = 8  # Gravitational constant used for the simulation.&#13;
NUM_LOOPS = 7000  # Number of time steps in simulation.&#13;
Ro_X = -152.18  # Ship starting position x coordinate.&#13;
Ro_Y = 329.87  # Ship starting position y coordinate.&#13;
Vo_X = 423.10  # Ship translunar injection velocity x component.&#13;
Vo_Y = -512.26  # Ship translunar injection velocity y component.&#13;
&#13;
MOON_MASS = 1_250_000&#13;
&#13;
class GravSys():&#13;
    """Runs a gravity simulation on n-bodies."""&#13;
    &#13;
    def __init__(self):&#13;
        self.bodies = []&#13;
        self.t = 0&#13;
        self.dt = 0.001&#13;
&#13;
    def sim_loop(self):&#13;
        """Loop bodies in a list through time steps."""&#13;
        for index in range(NUM_LOOPS): # stops simulation after while &#13;
            self.t += self.dt&#13;
            for body in self.bodies:&#13;
                body.step()&#13;
&#13;
class Body(Turtle):&#13;
    """Celestial object that orbits and projects gravity field."""&#13;
    def __init__(self, mass, start_loc, vel, gravsys, shape):&#13;
        super().__init__(shape=shape)&#13;
        self.gravsys = gravsys&#13;
        self.penup()&#13;
        self.mass=mass&#13;
        self.setpos(start_loc)&#13;
        self.vel = vel&#13;
        gravsys.bodies.append(self)&#13;
        self.pendown()  # uncomment to draw path behind object&#13;
        &#13;
    <span epub:type="pagebreak" id="page_297"/>def acc(self):&#13;
        """Calculate combined force on body and return vector components."""&#13;
        a = Vec(0,0)&#13;
        for body in self.gravsys.bodies:&#13;
            if body != self:&#13;
                r = body.pos() - self.pos()&#13;
                a += (G * body.mass / abs(r)**3) * r  # units dist/time^2&#13;
        return a&#13;
&#13;
    def step(self):&#13;
        """Calculate position, orientation, and velocity of a body."""&#13;
        dt = self.gravsys.dt&#13;
        a = self.acc()&#13;
        self.vel = self.vel + dt * a&#13;
        xOld, yOld = self.pos()  # for orienting ship&#13;
        self.setpos(self.pos() + dt * self.vel)&#13;
        xNew, yNew = self.pos()  # for orienting ship&#13;
        if self.gravsys.bodies.index(self) == 1:  # the CSM&#13;
            dir_radians = math.atan2(yNew-yOld,xNew-xOld)  # for orienting ship&#13;
            dir_degrees = dir_radians * 180 / math.pi  # for orienting ship&#13;
            self.setheading(dir_degrees+90)  # for orienting ship&#13;
            &#13;
def main():&#13;
    # Setup screen&#13;
    screen = Screen()&#13;
    screen.setup(width=1.0, height=1.0)  # for fullscreen&#13;
    screen.bgcolor('black')&#13;
    screen.title("Gravity Assist Example")&#13;
    # Instantiate gravitational system&#13;
    gravsys = GravSys()&#13;
    &#13;
    # Instantiate Planet&#13;
    image_moon = 'moon_27x27.gif'&#13;
    screen.register_shape(image_moon)&#13;
    moon = Body(MOON_MASS, (-250, 0), Vec(500, 0), gravsys, image_moon)&#13;
    moon.pencolor('gray')&#13;
&#13;
    # Build command-service-module (csm) shape&#13;
    csm = Shape('compound')&#13;
    cm = ((0, 30), (0, -30), (30, 0))&#13;
    csm.addcomponent(cm, 'red', 'red')&#13;
    sm = ((-60,30), (0, 30), (0, -30), (-60, -30))&#13;
    csm.addcomponent(sm, 'red', 'black')&#13;
    nozzle = ((-55, 0), (-90, 20), (-90, -20))&#13;
    csm.addcomponent(nozzle, 'red', 'red')&#13;
    screen.register_shape('csm', csm)&#13;
&#13;
    # Instantiate Apollo 8 CSM turtle&#13;
    ship = Body(1, (Ro_X, Ro_Y), Vec(Vo_X, Vo_Y), gravsys, "csm")&#13;
    ship.shapesize(0.2)&#13;
    ship.color('red')  # path color&#13;
    ship.getscreen().tracer(1, 0)&#13;
    ship.setheading(90)&#13;
    <span epub:type="pagebreak" id="page_298"/>gravsys.sim_loop()&#13;
&#13;
if __name__=='__main__':&#13;
    main()</pre>&#13;
<h3 class="h3" id="ch00lev1sec107"><strong><a href="ch07.xhtml">Chapter 7</a>: Selecting Martian Landing Sites</strong></h3>&#13;
<h4 class="h4" id="ch00lev2sec78"><strong><em>Confirming That Drawings Become Part of an Image</em></strong></h4>&#13;
<pre><span class="codeitalic1">practice_confirm_drawing_part_of_image.py</span>&#13;
"""Test that drawings become part of an image in OpenCV."""&#13;
import numpy as np&#13;
import cv2 as cv&#13;
&#13;
IMG = cv.imread('mola_1024x501.png', cv.IMREAD_GRAYSCALE)&#13;
&#13;
ul_x, ul_y = 0, 167&#13;
lr_x, lr_y = 32, 183&#13;
rect_img = IMG[ul_y : lr_y, ul_x : lr_x]&#13;
&#13;
def run_stats(image):&#13;
    """Run stats on a numpy array made from an image."""&#13;
    print('mean = {}'.format(np.mean(image)))&#13;
    print('std = {}'.format(np.std(image)))&#13;
    print('ptp = {}'.format(np.ptp(image)))&#13;
    print()&#13;
    cv.imshow('img', IMG)&#13;
    cv.waitKey(1000)    &#13;
&#13;
# Stats with no drawing on screen:&#13;
print("No drawing")&#13;
run_stats(rect_img)&#13;
&#13;
# Stats with white rectangle outline:&#13;
print("White outlined rectangle")&#13;
cv.rectangle(IMG, (ul_x, ul_y), (lr_x, lr_y), (255, 0, 0), 1)&#13;
run_stats(rect_img)&#13;
&#13;
# Stats with rectangle filled with white:&#13;
print("White-filled rectangle")&#13;
cv.rectangle(IMG, (ul_x, ul_y), (lr_x, lr_y), (255, 0, 0), -1)&#13;
run_stats(rect_img)</pre>&#13;
<h4 class="h4" id="ch00lev2sec79"><strong><em>Extracting an Elevation Profile</em></strong></h4>&#13;
<pre><span class="codeitalic1">practice_profile_olympus.py</span>&#13;
"""West-East elevation profile through Olympus Mons."""&#13;
from PIL import Image, ImageDraw&#13;
from matplotlib import pyplot as plt&#13;
&#13;
<span epub:type="pagebreak" id="page_299"/># Load image and get x and z values along horiz profile parallel to y _coord.&#13;
y_coord = 202&#13;
im = Image.open('mola_1024x512_200mp.jpg').convert('L')&#13;
width, height = im.size&#13;
x_vals = [x for x in range(width)]&#13;
z_vals = [im.getpixel((x, y_coord)) for x in x_vals]&#13;
&#13;
# Draw profile on MOLA image.&#13;
draw = ImageDraw.Draw(im)&#13;
draw.line((0, y_coord, width, y_coord), fill=255, width=3)&#13;
draw.text((100, 165), 'Olympus Mons', fill=255)&#13;
im.show()    &#13;
&#13;
# Make profile plot.&#13;
fig, ax = plt.subplots(figsize=(9, 4))&#13;
axes = plt.gca()&#13;
axes.set_ylim(0, 400)&#13;
ax.plot(x_vals, z_vals, color='black')&#13;
ax.set(xlabel='x-coordinate',&#13;
       ylabel='Intensity (height)',&#13;
       title="Mars Elevation Profile (y = 202)")&#13;
ratio = 0.15  # Reduces vertical exaggeration in profile.&#13;
xleft, xright = ax.get_xlim()&#13;
ybase, ytop = ax.get_ylim()&#13;
ax.set_aspect(abs((xright-xleft)/(ybase-ytop)) * ratio)&#13;
plt.text(0, 310, 'WEST', fontsize=10)&#13;
plt.text(980, 310, 'EAST', fontsize=10)&#13;
plt.text(100, 280, 'Olympus Mons', fontsize=8)&#13;
##ax.grid()&#13;
plt.show()</pre>&#13;
<h4 class="h4" id="ch00lev2sec80"><strong><em>Plotting in 3D</em></strong></h4>&#13;
<pre><span class="codeitalic1">practice_3d_plotting.py</span>&#13;
"""Plot Mars MOLA map image in 3D.  Credit Eric T. Mortenson."""&#13;
import numpy as np&#13;
import cv2 as cv&#13;
import matplotlib.pyplot as plt&#13;
from mpl_toolkits import mplot3d&#13;
&#13;
IMG_GRAY = cv.imread('mola_1024x512_200mp.jpg', cv.IMREAD_GRAYSCALE)&#13;
&#13;
x = np.linspace(1023, 0, 1024)&#13;
y = np.linspace(0, 511, 512)&#13;
&#13;
X, Y = np.meshgrid(x, y)&#13;
Z = IMG_GRAY[0:512, 0:1024]&#13;
&#13;
fig = plt.figure()&#13;
ax = plt.axes(projection='3d')&#13;
ax.contour3D(X, Y, Z, 150, cmap='gist_earth')  # 150=number of contours&#13;
ax.auto_scale_xyz([1023, 0], [0, 511], [0, 500])&#13;
plt.show()</pre>&#13;
<h4 class="h4" id="ch00lev2sec81"><strong><em>Mixing Maps</em></strong></h4>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_300"/>This practice project uses two programs, <em>practice_geo_map_step_1of2.py</em> and <em>practice_geo_map_step_2of2.py</em>, that must be run in order.</p>&#13;
<h5 class="h5"><strong>practice_geo_map_step_1of2.py</strong></h5>&#13;
<pre><span class="codeitalic1">practice_geo_map_step_1of2.py</span>&#13;
"""Threshold a grayscale image using pixel values and save to file."""&#13;
import cv2 as cv&#13;
&#13;
IMG_GEO = cv.imread('Mars_Global_Geology_Mariner9_1024.jpg', &#13;
                     cv.IMREAD_GRAYSCALE)&#13;
cv.imshow('map', IMG_GEO)&#13;
cv.waitKey(1000)&#13;
img_copy = IMG_GEO.copy()&#13;
lower_limit = 170  # Lowest grayscale value for volcanic deposits&#13;
upper_limit = 185  # Highest grayscale value for volcanic deposits&#13;
&#13;
# Using 1024 x 512 image&#13;
for x in range(1024):&#13;
    for y in range(512):&#13;
        if lower_limit &lt;= img_copy[y, x] &lt;= upper_limit:&#13;
            img_copy[y, x] = 1  # Set to 255 to visualize results.&#13;
        else:&#13;
            img_copy[y, x] = 0&#13;
&#13;
cv.imwrite('geo_thresh.jpg', img_copy)&#13;
cv.imshow('thresh', img_copy)&#13;
cv.waitKey(0)</pre>&#13;
<h5 class="h5"><strong>practice_geo_map_step_2of2.py</strong></h5>&#13;
<pre><span class="codeitalic1">practice_geo_map_step_2of2.py</span>&#13;
"""Select Martian landing sites based on surface smoothness and geology."""&#13;
import tkinter as tk&#13;
from PIL import Image, ImageTk&#13;
import numpy as np&#13;
import cv2 as cv&#13;
&#13;
# CONSTANTS: User Input:&#13;
IMG_GRAY = cv.imread('mola_1024x512_200mp.jpg', cv.IMREAD_GRAYSCALE)&#13;
IMG_GEO = cv.imread('geo_thresh.jpg', cv.IMREAD_GRAYSCALE)&#13;
IMG_COLOR = cv.imread('mola_color_1024x506.png')&#13;
RECT_WIDTH_KM = 670  # Site rectangle width in kilometers.&#13;
RECT_HT_KM = 335  # Site rectangle height in kilometers.&#13;
MIN_ELEV_LIMIT = 60  # Intensity values (0-255).&#13;
MAX_ELEV_LIMIT = 255&#13;
NUM_CANDIDATES = 20  # Number of candidate landing sites to display.&#13;
&#13;
#------------------------------------------------------------------------------&#13;
<span epub:type="pagebreak" id="page_301"/># CONSTANTS: Derived and fixed:&#13;
IMG_GRAY_GEO = IMG_GRAY * IMG_GEO&#13;
IMG_HT, IMG_WIDTH = IMG_GRAY.shape&#13;
MARS_CIRCUM = 21344  # Circumference in kilometers.&#13;
PIXELS_PER_KM = IMG_WIDTH / MARS_CIRCUM&#13;
RECT_WIDTH = int(PIXELS_PER_KM * RECT_WIDTH_KM)&#13;
RECT_HT = int(PIXELS_PER_KM * RECT_HT_KM)&#13;
LAT_30_N = int(IMG_HT / 3)&#13;
LAT_30_S = LAT_30_N * 2&#13;
STEP_X = int(RECT_WIDTH / 2)  # Dividing by 4 yields more rect choices&#13;
STEP_Y = int(RECT_HT / 2)  # Dividing by 4 yields more rect choices&#13;
&#13;
# Create tkinter screen and drawing canvas&#13;
screen = tk.Tk()&#13;
canvas = tk.Canvas(screen, width=IMG_WIDTH, height=IMG_HT + 130)&#13;
&#13;
class Search():&#13;
    """Read image and identify landing sites based on input criteria."""   &#13;
&#13;
    def __init__(self, name):&#13;
        self.name = name&#13;
        self.rect_coords = {}&#13;
        self.rect_means = {}&#13;
        self.rect_ptps = {}&#13;
        self.rect_stds = {}&#13;
        self.ptp_filtered = []&#13;
        self.std_filtered = []&#13;
        self.high_graded_rects = []&#13;
        &#13;
    def run_rect_stats(self):&#13;
        """Define rectangular search areas and calculate internal stats."""&#13;
        ul_x, ul_y = 0, LAT_30_N &#13;
        lr_x, lr_y = RECT_WIDTH, LAT_30_N + RECT_HT&#13;
        rect_num = 1&#13;
     &#13;
        while True:&#13;
            rect_img = IMG_GRAY_GEO[ul_y : lr_y, ul_x : lr_x]&#13;
            self.rect_coords[rect_num] = [ul_x, ul_y, lr_x, lr_y]&#13;
            if MAX_ELEV_LIMIT &gt;= np.mean(rect_img) &gt;= MIN_ELEV_LIMIT:&#13;
                self.rect_means[rect_num] = np.mean(rect_img)&#13;
                self.rect_ptps[rect_num] = np.ptp(rect_img)&#13;
                self.rect_stds[rect_num] = np.std(rect_img)&#13;
            rect_num += 1&#13;
&#13;
           # Move the rectangle.&#13;
            ul_x += STEP_X&#13;
            lr_x = ul_x + RECT_WIDTH&#13;
            if lr_x &gt; IMG_WIDTH:&#13;
                ul_x = 0&#13;
                <span epub:type="pagebreak" id="page_302"/>ul_y += STEP_Y&#13;
                lr_x = RECT_WIDTH&#13;
                lr_y += STEP_Y&#13;
            if lr_y &gt; LAT_30_S + STEP_Y:&#13;
                break&#13;
&#13;
    def draw_qc_rects(self):&#13;
        """Draw overlapping search rectangles on image as a check."""&#13;
        img_copy = IMG_GRAY_GEO.copy()&#13;
        rects_sorted = sorted(self.rect_coords.items(), key=lambda x: x[0])&#13;
        print("\nRect Number and Corner Coordinates (ul_x, ul_y, lr_x, lr_y):")&#13;
        for k, v in rects_sorted:&#13;
            print("rect: {}, coords: {}".format(k, v))&#13;
            cv.rectangle(img_copy,&#13;
                         (self.rect_coords[k][0], self.rect_coords[k][1]),&#13;
                         (self.rect_coords[k][2], self.rect_coords[k][3]),&#13;
                         (255, 0, 0), 1)&#13;
        cv.imshow('QC Rects {}'.format(self.name), img_copy)&#13;
        cv.waitKey(3000)&#13;
        cv.destroyAllWindows()        &#13;
&#13;
    def sort_stats(self):  &#13;
        """Sort dictionaries by values and create lists of top N keys."""&#13;
        ptp_sorted = (sorted(self.rect_ptps.items(), key=lambda x: x[1]))&#13;
        self.ptp_filtered = [x[0] for x in ptp_sorted[:NUM_CANDIDATES]]&#13;
        std_sorted = (sorted(self.rect_stds.items(), key=lambda x: x[1]))&#13;
        self.std_filtered = [x[0] for x in std_sorted[:NUM_CANDIDATES]]&#13;
        &#13;
        # Make list of rects where filtered std &amp; ptp coincide.&#13;
        for rect in self.std_filtered:&#13;
            if rect in self.ptp_filtered:&#13;
                self.high_graded_rects.append(rect)   &#13;
&#13;
    def draw_filtered_rects(self, image, filtered_rect_list):&#13;
        """Draw rectangles in list on image and return image."""&#13;
        img_copy = image.copy()&#13;
        for k in filtered_rect_list: &#13;
            cv.rectangle(img_copy,&#13;
                         (self.rect_coords[k][0], self.rect_coords[k][1]),&#13;
                         (self.rect_coords[k][2], self.rect_coords[k][3]),&#13;
                         (255, 0, 0), 1)&#13;
            <span epub:type="pagebreak" id="page_303"/>cv.putText(img_copy, str(k),&#13;
                       (self.rect_coords[k][0] + 1, self.rect_coords[k][3]- 1),&#13;
                       cv.FONT_HERSHEY_PLAIN, 0.65, (255, 0, 0), 1)&#13;
            &#13;
        # Draw latitude limits.&#13;
        cv.putText(img_copy, '30 N', (10, LAT_30_N - 7),&#13;
                   cv.FONT_HERSHEY_PLAIN, 1, 255)&#13;
        cv.line(img_copy, (0, LAT_30_N), (IMG_WIDTH, LAT_30_N),&#13;
                (255, 0, 0), 1)&#13;
        cv.line(img_copy, (0, LAT_30_S), (IMG_WIDTH, LAT_30_S),&#13;
                (255, 0, 0), 1)&#13;
        cv.putText(img_copy, '30 S', (10, LAT_30_S + 16),&#13;
                   cv.FONT_HERSHEY_PLAIN, 1, 255)&#13;
&#13;
        return img_copy&#13;
&#13;
    def make_final_display(self):&#13;
        """Use Tk to show map of final rects &amp; printout of their statistics."""&#13;
        screen.title('Sites by MOLA Gray STD &amp; PTP {} Rect'.format(self.name))&#13;
        # Draw the high-graded rects on the colored elevation map.        &#13;
        img_color_rects = self.draw_filtered_rects(IMG_COLOR,&#13;
                                                   self.high_graded_rects)&#13;
        # Convert image from CV BGR to RGB for use with Tkinter.&#13;
        img_converted = cv.cvtColor(img_color_rects, cv.COLOR_BGR2RGB)&#13;
        img_converted = ImageTk.PhotoImage(Image.fromarray(img_converted))    &#13;
        canvas.create_image(0, 0, image=img_converted, anchor=tk.NW)&#13;
        # Add stats for each rectangle at bottom of canvas.&#13;
        txt_x = 5&#13;
        txt_y = IMG_HT + 15&#13;
        for k in self.high_graded_rects:&#13;
            canvas.create_text(txt_x, txt_y, anchor='w', font=None,&#13;
                               text=&#13;
                               "rect={}  mean elev={:.1f}  std={:.2f}  ptp={}"&#13;
                               .format(k, self.rect_means[k], &#13;
                                       self.rect_stds[k],&#13;
                                       self.rect_ptps[k]))&#13;
            txt_y += 15&#13;
            if txt_y &gt;= int(canvas.cget('height')) - 10:&#13;
                txt_x += 300&#13;
                txt_y = IMG_HT + 15                &#13;
        canvas.pack()&#13;
        screen.mainloop()&#13;
        &#13;
def main():&#13;
    app = Search('670x335 km')&#13;
    app.run_rect_stats()&#13;
    app.draw_qc_rects()&#13;
    app.sort_stats()&#13;
    ptp_img = app.draw_filtered_rects(IMG_GRAY_GEO, app.ptp_filtered)&#13;
    std_img = app.draw_filtered_rects(IMG_GRAY_GEO, app.std_filtered)&#13;
    # Display filtered rects on grayscale map.&#13;
    cv.imshow('Sorted by ptp for {} rect'.format(app.name), ptp_img)&#13;
    cv.waitKey(3000)&#13;
    cv.imshow('Sorted by std for {} rect'.format(app.name), std_img)&#13;
    cv.waitKey(3000)&#13;
&#13;
    app.make_final_display()  # includes call to mainloop()&#13;
&#13;
if __name__ == '__main__':&#13;
    main()</pre>&#13;
<h3 class="h3" id="ch00lev1sec108"><strong><a href="ch08.xhtml">Chapter 8</a>: Detecting Distant Exoplanets</strong></h3>&#13;
<h4 class="h4" id="ch00lev2sec82"><span epub:type="pagebreak" id="page_304"/><strong><em>Detecting Alien Megastructures</em></strong></h4>&#13;
<pre><span class="codeitalic1">practice_tabbys_star.py</span>&#13;
"""Simulate transit of alien array and plot light curve."""&#13;
import numpy as np&#13;
import cv2 as cv&#13;
import matplotlib.pyplot as plt&#13;
&#13;
IMG_HT = 400&#13;
IMG_WIDTH = 500&#13;
BLACK_IMG = np.zeros((IMG_HT, IMG_WIDTH), dtype='uint8')&#13;
STAR_RADIUS = 165&#13;
EXO_START_X = -250&#13;
EXO_START_Y = 150 &#13;
EXO_DX = 3&#13;
NUM_FRAMES = 500&#13;
&#13;
def main():&#13;
    intensity_samples = record_transit(EXO_START_X, EXO_START_Y)&#13;
    rel_brightness = calc_rel_brightness(intensity_samples)&#13;
    plot_light_curve(rel_brightness)&#13;
    &#13;
def record_transit(exo_x, exo_y):&#13;
    """Draw array transiting star and return list of intensity changes."""&#13;
    intensity_samples = []&#13;
    for _ in range(NUM_FRAMES):&#13;
        temp_img = BLACK_IMG.copy()&#13;
        # Draw star:&#13;
        cv.circle(temp_img, (int(IMG_WIDTH / 2), int(IMG_HT / 2)),&#13;
                  STAR_RADIUS, 255, -1)&#13;
        # Draw alien array:&#13;
        cv.rectangle(temp_img, (exo_x, exo_y),&#13;
                     (exo_x + 20, exo_y + 140), 0, -1)&#13;
        cv.rectangle(temp_img, (exo_x - 360, exo_y),&#13;
                     (exo_x + 10, exo_y + 140), 0, 5)&#13;
        cv.rectangle(temp_img, (exo_x - 380, exo_y),&#13;
                     (exo_x - 310, exo_y + 140), 0, -1)&#13;
        intensity = temp_img.mean()&#13;
        cv.putText(temp_img, 'Mean Intensity = {}'.format(intensity), (5, 390),&#13;
                   cv.FONT_HERSHEY_PLAIN, 1, 255)&#13;
        cv.imshow('Transit', temp_img)&#13;
        cv.waitKey(10)&#13;
        intensity_samples.append(intensity)&#13;
        exo_x += EXO_DX&#13;
    return intensity_samples&#13;
&#13;
def calc_rel_brightness(intensity_samples):&#13;
    """Return list of relative brightness from list of intensity values."""&#13;
    rel_brightness = []&#13;
    max_brightness = max(intensity_samples)&#13;
    for intensity in intensity_samples:&#13;
        rel_brightness.append(intensity / max_brightness)&#13;
    <span epub:type="pagebreak" id="page_305"/>return rel_brightness&#13;
&#13;
def plot_light_curve(rel_brightness):&#13;
    """Plot changes in relative brightness vs. time."""&#13;
    plt.plot(rel_brightness, color='red', linestyle='dashed',&#13;
             linewidth=2)&#13;
    plt.title('Relative Brightness vs. Time')&#13;
    plt.xlim(-150, 500)&#13;
    plt.show()&#13;
&#13;
if __name__ == '__main__':&#13;
    main()</pre>&#13;
<h4 class="h4" id="ch00lev2sec83"><strong><em>Detecting Asteroid Transits</em></strong></h4>&#13;
<pre>practice _asteroids.py&#13;
"""Simulate transit of asteroids and plot light curve."""&#13;
import random&#13;
import numpy as np&#13;
import cv2 as cv&#13;
import matplotlib.pyplot as plt&#13;
&#13;
STAR_RADIUS = 165&#13;
BLACK_IMG = np.zeros((400, 500, 1), dtype="uint8")&#13;
NUM_ASTEROIDS = 15&#13;
NUM_LOOPS = 170&#13;
&#13;
class Asteroid():&#13;
    """Draws a circle on an image that represents an asteroid."""&#13;
&#13;
    def __init__(self, number):&#13;
        self.radius = random.choice((1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 3))&#13;
        self.x = random.randint(-30, 60)&#13;
        self.y = random.randint(220, 230)&#13;
        self.dx = 3  &#13;
&#13;
    def move_asteroid(self, image):&#13;
        """Draw and move asteroid object."""&#13;
        cv.circle(image, (self.x, self.y), self.radius, 0, -1)&#13;
        self.x += self.dx&#13;
        &#13;
def record_transit(start_image):&#13;
    """Simulate transit of asteroids over star and return intensity list."""&#13;
    asteroid_list = []&#13;
    intensity_samples = []&#13;
    &#13;
    for i in range(NUM_ASTEROIDS):&#13;
        asteroid_list.append(Asteroid(i))&#13;
        &#13;
    for _ in range(NUM_LOOPS):&#13;
        temp_img = start_image.copy()&#13;
        # Draw star.  &#13;
        <span epub:type="pagebreak" id="page_306"/>cv.circle(temp_img, (250, 200), STAR_RADIUS, 255, -1)&#13;
        for ast in asteroid_list:&#13;
            ast.move_asteroid(temp_img)&#13;
        intensity = temp_img.mean()&#13;
        cv.putText(temp_img, 'Mean Intensity = {}'.format(intensity),&#13;
                   (5, 390), cv.FONT_HERSHEY_PLAIN, 1, 255)&#13;
        cv.imshow('Transit', temp_img)&#13;
        <span epub:type="pagebreak" id="page_307"/>intensity_samples.append(intensity)&#13;
        cv.waitKey(50)&#13;
    cv.destroyAllWindows()&#13;
    return intensity_samples&#13;
&#13;
def calc_rel_brightness(image):&#13;
    """Calculate and return list of relative brightness samples."""&#13;
    rel_brightness = record_transit(image)&#13;
    max_brightness = max(rel_brightness)&#13;
    for i, j in enumerate(rel_brightness):&#13;
        rel_brightness[i] = j / max_brightness&#13;
    return rel_brightness&#13;
&#13;
def plot_light_curve(rel_brightness):&#13;
    "Plot light curve from relative brightness list."""&#13;
    plt.plot(rel_brightness, color='red', linestyle='dashed',&#13;
             linewidth=2, label='Relative Brightness')&#13;
    plt.legend(loc='upper center')&#13;
    plt.title('Relative Brightness vs. Time')&#13;
    plt.show()&#13;
    &#13;
relative_brightness = calc_rel_brightness(BLACK_IMG)&#13;
plot_light_curve(relative_brightness)</pre>&#13;
<h4 class="h4" id="ch00lev2sec84"><strong><em>Incorporating Limb Darkening</em></strong></h4>&#13;
<pre><span class="codeitalic1">practice_limb_darkening.py</span>&#13;
"""Simulate transit of exoplanet, plot light curve, estimate planet radius."""&#13;
import cv2 as cv&#13;
import matplotlib.pyplot as plt&#13;
&#13;
IMG_HT = 400&#13;
IMG_WIDTH = 500&#13;
BLACK_IMG = cv.imread('limb_darkening.png', cv.IMREAD_GRAYSCALE)&#13;
EXO_RADIUS = 7&#13;
EXO_START_X = 40&#13;
EXO_START_Y = 230 &#13;
EXO_DX = 3&#13;
NUM_FRAMES = 145&#13;
&#13;
def main():&#13;
    intensity_samples = record_transit(EXO_START_X, EXO_START_Y)&#13;
    relative_brightness = calc_rel_brightness(intensity_samples)&#13;
    plot_light_curve(relative_brightness)&#13;
    &#13;
def record_transit(exo_x, exo_y):&#13;
    """Draw planet transiting star and return list of intensity changes."""&#13;
    intensity_samples = []&#13;
    for _ in range(NUM_FRAMES):&#13;
        temp_img = BLACK_IMG.copy()&#13;
        # Draw exoplanet:&#13;
        cv.circle(temp_img, (exo_x, exo_y), EXO_RADIUS, 0, -1)&#13;
        intensity = temp_img.mean()&#13;
        cv.putText(temp_img, 'Mean Intensity = {}'.format(intensity), (5, 390),&#13;
                   cv.FONT_HERSHEY_PLAIN, 1, 255)&#13;
        cv.imshow('Transit', temp_img)&#13;
        cv.waitKey(30)&#13;
        intensity_samples.append(intensity)&#13;
        exo_x += EXO_DX&#13;
    return intensity_samples&#13;
&#13;
def calc_rel_brightness(intensity_samples):&#13;
    """Return list of relative brightness from list of intensity values."""&#13;
    rel_brightness = []&#13;
    max_brightness = max(intensity_samples)&#13;
    for intensity in intensity_samples:&#13;
        rel_brightness.append(intensity / max_brightness)&#13;
    return rel_brightness&#13;
&#13;
def plot_light_curve(rel_brightness):&#13;
    """Plot changes in relative brightness vs. time."""&#13;
    plt.plot(rel_brightness, color='red', linestyle='dashed',&#13;
             linewidth=2, label='Relative Brightness')&#13;
    plt.legend(loc='upper center')&#13;
    plt.title('Relative Brightness vs. Time')&#13;
##    plt.ylim(0.995, 1.001)&#13;
    plt.show()&#13;
&#13;
if __name__ == '__main__':&#13;
    main()</pre>&#13;
<h4 class="h4" id="ch00lev2sec85"><strong><em>Detecting an Alien Armada</em></strong></h4>&#13;
<pre><span class="codeitalic1">practice_alien_armada.py</span>&#13;
"""Simulate transit of alien armada with light curve."""&#13;
import random&#13;
import numpy as np&#13;
import cv2 as cv&#13;
import matplotlib.pyplot as plt&#13;
&#13;
STAR_RADIUS = 165&#13;
BLACK_IMG = np.zeros((400, 500, 1), dtype="uint8")&#13;
NUM_SHIPS = 5&#13;
NUM_LOOPS = 300  # Number of simulation frames to run&#13;
&#13;
class Ship():&#13;
    """Draws and moves a ship object on an image."""&#13;
    def __init__(self, number):&#13;
        self.number = number&#13;
        <span epub:type="pagebreak" id="page_308"/>self.shape = random.choice(['&gt;&gt;&gt;|==H[X)',&#13;
                                    '&gt;&gt;|==H[XX}=))-',&#13;
                                    '&gt;&gt;|==H[XX]=(-'])&#13;
        self.size = random.choice([0.7, 0.8, 1])&#13;
        self.x = random.randint(-180, -80)&#13;
        self.y = random.randint(80, 350)&#13;
        self.dx = random.randint(2, 4)&#13;
&#13;
    def move_ship(self, image):&#13;
        """Draws and moves ship object."""&#13;
        font = cv.FONT_HERSHEY_PLAIN&#13;
        cv.putText(img=image, &#13;
                   text=self.shape,&#13;
                   org=(self.x, self.y),&#13;
                   fontFace=font,&#13;
                   fontScale=self.size,&#13;
                   color=0,&#13;
                   thickness=5) &#13;
        self.x += self.dx&#13;
        &#13;
def record_transit(start_image):&#13;
    """Runs simulation and returns list of intensity measurements per frame."""&#13;
    ship_list = []&#13;
    intensity_samples = []&#13;
    &#13;
    for i in range(NUM_SHIPS):&#13;
        ship_list.append(Ship(i))&#13;
        &#13;
    for _ in range(NUM_LOOPS):&#13;
        temp_img = start_image.copy()&#13;
        cv.circle(temp_img, (250, 200), STAR_RADIUS, 255, -1)  # The star.&#13;
        for ship in ship_list:&#13;
            ship.move_ship(temp_img)&#13;
        intensity = temp_img.mean()&#13;
        cv.putText(temp_img, 'Mean Intensity = {}'.format(intensity),&#13;
                   (5, 390), cv.FONT_HERSHEY_PLAIN, 1, 255)&#13;
        cv.imshow('Transit', temp_img)&#13;
        intensity_samples.append(intensity)&#13;
        cv.waitKey(50)&#13;
    cv.destroyAllWindows()&#13;
    return intensity_samples&#13;
&#13;
def calc_rel_brightness(image):&#13;
    """Return list of relative brightness measurments for planetary transit."""&#13;
    rel_brightness = record_transit(image)&#13;
    max_brightness = max(rel_brightness)&#13;
    for i, j in enumerate(rel_brightness):&#13;
        rel_brightness[i] = j / max_brightness&#13;
    return rel_brightness&#13;
&#13;
def plot_light_curve(rel_brightness):&#13;
    """Plots curve of relative brightness vs. time."""&#13;
    plt.plot(rel_brightness, color='red', linestyle='dashed',&#13;
             linewidth=2, label='Relative Brightness')&#13;
    <span epub:type="pagebreak" id="page_309"/>plt.legend(loc='upper center')&#13;
    plt.title('Relative Brightness vs. Time')&#13;
    plt.show()&#13;
    &#13;
relative_brightness = calc_rel_brightness(BLACK_IMG)&#13;
plot_light_curve(relative_brightness)</pre>&#13;
<h4 class="h4" id="ch00lev2sec86"><strong><em>Detecting a Planet with a Moon</em></strong></h4>&#13;
<pre><span class="codeitalic1">practice_planet_moon.py</span>&#13;
"""Moon animation credit Eric T. Mortenson."""&#13;
import math&#13;
import numpy as np&#13;
import cv2 as cv&#13;
import matplotlib.pyplot as plt&#13;
&#13;
IMG_HT = 500&#13;
IMG_WIDTH = 500&#13;
BLACK_IMG = np.zeros((IMG_HT, IMG_WIDTH, 1), dtype='uint8')&#13;
STAR_RADIUS = 200&#13;
EXO_RADIUS = 20&#13;
EXO_START_X = 20&#13;
EXO_START_Y = 250&#13;
MOON_RADIUS = 5&#13;
NUM_DAYS = 200  # number days in year&#13;
&#13;
def main():&#13;
    intensity_samples = record_transit(EXO_START_X, EXO_START_Y)&#13;
    relative_brightness = calc_rel_brightness(intensity_samples)&#13;
    print('\nestimated exoplanet radius = {:.2f}\n'&#13;
          .format(STAR_RADIUS * math.sqrt(max(relative_brightness)&#13;
                                          -min(relative_brightness))))&#13;
    plot_light_curve(relative_brightness)&#13;
&#13;
def record_transit(exo_x, exo_y):&#13;
    """Draw planet transiting star and return list of intensity changes."""&#13;
    intensity_samples = []&#13;
    for dt in range(NUM_DAYS):&#13;
        temp_img = BLACK_IMG.copy()&#13;
        # Draw star:&#13;
        cv.circle(temp_img, (int(IMG_WIDTH / 2), int(IMG_HT/2)),&#13;
                  STAR_RADIUS, 255, -1)&#13;
        # Draw exoplanet&#13;
        cv.circle(temp_img, (int(exo_x), int(exo_y)), EXO_RADIUS, 0, -1)&#13;
        # Draw moon&#13;
        if dt != 0:&#13;
            cv.circle(temp_img, (int(moon_x), int(moon_y)), MOON_RADIUS, 0, -1)&#13;
        intensity = temp_img.mean()&#13;
        cv.putText(temp_img, 'Mean Intensity = {}'.format(intensity), (5, 10),&#13;
                   cv.FONT_HERSHEY_PLAIN, 1, 255)&#13;
        cv.imshow('Transit', temp_img)&#13;
        cv.waitKey(10)        &#13;
        intensity_samples.append(intensity)&#13;
        exo_x = IMG_WIDTH / 2 - (IMG_WIDTH / 2 - 20) * \&#13;
                <span epub:type="pagebreak" id="page_310"/>math.cos(2 * math.pi * dt / (NUM_DAYS)*(1 / 2))&#13;
        moon_x = exo_x + \&#13;
                 3 * EXO_RADIUS * math.sin(2 * math.pi * dt / NUM_DAYS *(5))&#13;
        moon_y = IMG_HT / 2 - \&#13;
                 0.25 * EXO_RADIUS * \&#13;
                 math.sin(2 * math.pi * dt / NUM_DAYS * (5))&#13;
    cv.destroyAllWindows()&#13;
    &#13;
    return intensity_samples&#13;
&#13;
def calc_rel_brightness(intensity_samples):&#13;
    """Return list of relative brightness from list of intensity values."""&#13;
    rel_brightness = []&#13;
    max_brightness = max(intensity_samples)&#13;
    for intensity in intensity_samples:&#13;
        rel_brightness.append(intensity / max_brightness)&#13;
    return rel_brightness&#13;
&#13;
def plot_light_curve(rel_brightness):&#13;
    """Plot changes in relative brightness vs. time."""&#13;
    plt.plot(rel_brightness, color='red', linestyle='dashed',&#13;
             linewidth=2, label='Relative Brightness')&#13;
    plt.legend(loc='upper center')&#13;
    plt.title('Relative Brightness vs. Time')&#13;
    plt.show()&#13;
&#13;
if __name__ == '__main__':&#13;
    main()</pre>&#13;
<p class="indent"><a href="app01.xhtml#app01fig1">Figure A-1</a> summarizes the output from the <em>practice_planet_moon.py</em> program.</p>&#13;
<div class="image"><img src="../images/f0310-01.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="app01fig1"/>Figure A-1: Light curve for planet and moon where moon passes behind planet</p>&#13;
<h4 class="h4" id="ch00lev2sec87"><span epub:type="pagebreak" id="page_311"/><strong><em>Measuring the Length of an Exoplanetâ€™s Day</em></strong></h4>&#13;
<pre>practice_length _of_day.py&#13;
"""Read-in images, calculate mean intensity, plot relative intensity vs time."""&#13;
import os&#13;
from statistics import mean&#13;
import cv2 as cv&#13;
import numpy as np&#13;
import matplotlib.pyplot as plt&#13;
from scipy import signal  # See Chap. 1 to install scipy.&#13;
&#13;
# Switch to the folder containing images.&#13;
os.chdir('br549_pixelated')&#13;
images = sorted(os.listdir())&#13;
intensity_samples = []&#13;
&#13;
# Convert images to grayscale and make a list of mean intensity values.&#13;
for image in images:&#13;
    img = cv.imread(image, cv.IMREAD_GRAYSCALE)    &#13;
    intensity = img.mean()&#13;
    intensity_samples.append(intensity)&#13;
&#13;
# Generate a list of relative intensity values.&#13;
rel_intensity = intensity_samples[:]&#13;
max_intensity = max(rel_intensity)&#13;
for i, j in enumerate(rel_intensity):&#13;
    rel_intensity[i] = j / max_intensity&#13;
&#13;
# Plot relative intensity values vs frame number (time proxy).&#13;
plt.plot(rel_intensity, color='red', marker='o', linestyle='solid',&#13;
         linewidth=2, markersize=0, label='Relative Intensity')&#13;
plt.legend(loc='upper center')&#13;
plt.title('Exoplanet BR549 Relative Intensity vs. Time')&#13;
plt.ylim(0.8, 1.1)&#13;
plt.xticks(np.arange(0, 50, 5))&#13;
plt.grid()&#13;
print("\nManually close plot window after examining to continue program.")&#13;
plt.show()&#13;
&#13;
# Find period / length of day.&#13;
# Estimate peak height and separation (distance) limits from plot.&#13;
# height and distance parameters represent &gt;= limits.&#13;
peaks = signal.find_peaks(rel_intensity, height=0.95, distance=5)&#13;
print(f"peaks = {peaks}")&#13;
print("Period = {}".format(mean(np.diff(peaks[0]))))</pre>&#13;
<h3 class="h3" id="ch00lev1sec109"><strong><a href="ch09.xhtml">Chapter 9</a>: Identifying Friend or Foe</strong></h3>&#13;
<h4 class="h4" id="ch00lev2sec88"><span epub:type="pagebreak" id="page_312"/><strong><em>Blurring Faces</em></strong></h4>&#13;
<pre><span class="codeitalic1">practice_blur.py</span>&#13;
import cv2 as cv&#13;
&#13;
path = "C:/Python372/Lib/site-packages/cv2/data/"&#13;
face_cascade = cv.CascadeClassifier(path + 'haarcascade_frontalface_alt.xml')&#13;
&#13;
cap = cv.VideoCapture(0)&#13;
&#13;
while True:&#13;
    _, frame = cap.read()&#13;
    face_rects = face_cascade.detectMultiScale(frame, scaleFactor=1.2,&#13;
                                               minNeighbors=3)    &#13;
    for (x, y, w, h) in face_rects:&#13;
        face = cv.blur(frame[y:y + h, x:x + w], (25, 25))&#13;
        frame[y:y + h, x: x + w] = face&#13;
        cv.rectangle(frame, (x,y), (x+w, y+h), (0, 255, 0), 2)&#13;
        &#13;
    cv.imshow('frame', frame)&#13;
    if cv.waitKey(1) &amp; 0xFF == ord('q'):&#13;
        break&#13;
&#13;
cap.release()&#13;
cv.destroyAllWindows()</pre>&#13;
<h3 class="h3" id="ch00lev1sec110"><strong><a href="ch10.xhtml">Chapter 10</a>: Restricting Access with Face Recognition</strong></h3>&#13;
<h4 class="h4" id="ch00lev2sec89"><strong><em>Challenge Project: Adding a Password and Video Capture</em></strong></h4>&#13;
<p class="noindent">The following snippet addresses the part of the challenge project concerned with recognizing faces from a video stream.</p>&#13;
<pre><span class="codeitalic1">challenge_video_recognize.py</span>&#13;
"""Recognize Capt. Demming's face in video frame."""&#13;
import cv2 as cv&#13;
&#13;
names = {1: "Demming"}&#13;
&#13;
# Set up path to OpenCV's Haar Cascades&#13;
path = "C:/Python372/Lib/site-packages/cv2/data/"&#13;
detector = cv.CascadeClassifier(path + 'haarcascade_frontalface_default.xml')&#13;
&#13;
# Set up face recognizer and load trained data.&#13;
recognizer = cv.face.LBPHFaceRecognizer_create()&#13;
recognizer.read('lbph_trainer.yml')&#13;
&#13;
<span epub:type="pagebreak" id="page_313"/># Prepare webcam.&#13;
cap = cv.VideoCapture(0)&#13;
if not cap.isOpened(): &#13;
    print("Could not open video device.")&#13;
##cap.set(3, 320)  # Frame width.&#13;
##cap.set(4, 240)  # Frame height.&#13;
&#13;
while True:&#13;
    _, frame = cap.read()&#13;
    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)&#13;
    face_rects = detector.detectMultiScale(gray, &#13;
                                           scaleFactor=1.2,&#13;
                                           minNeighbors=5)&#13;
&#13;
    for (x, y, w, h) in face_rects:&#13;
        # Resize input so it's closer to training image size.&#13;
        gray_resize = cv.resize(gray[y:y + h, x:x + w],&#13;
                                (100, 100),&#13;
                                cv.INTER_LINEAR)&#13;
        predicted_id, dist = recognizer.predict(gray_resize)&#13;
        if predicted_id == 1 and dist &lt;= 110:&#13;
            name = names[predicted_id]&#13;
        else:&#13;
            name = 'unknown'    &#13;
        cv.rectangle(frame, (x, y), (x + w, y + h), (255, 255, 0), 2)&#13;
        cv.putText(frame, name, (x + 1, y + h -5),&#13;
                   cv.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 1)&#13;
        cv.imshow('frame', frame)&#13;
&#13;
    if cv.waitKey(1) &amp; 0xFF == ord('q'):&#13;
        break&#13;
&#13;
cap.release()&#13;
cv.destroyAllWindows()</pre>&#13;
</body></html>