- en: '10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '10'
- en: GRAPHICAL USER INTERFACES AND THE CANVAS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 图形用户界面与画布
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common01.jpg)'
- en: Before we dive into simulations, we need to understand the basics of graphical
    user interfaces (GUIs). This is a massive topic, and we’ll barely scratch the
    surface, but we’ll see enough for us to present our simulations to the user.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入仿真之前，我们需要了解图形用户界面（GUIs）的基础知识。这个话题非常广泛，我们只能略微触及皮毛，但我们会了解足够的信息来将我们的仿真展示给用户。
- en: GUIs typically consist of a parent window (or windows) containing *widgets*
    the user can interact with, such as buttons or text fields. For our goal of drawing
    simulations, the widget we’re most interested in is the *canvas*. In a canvas
    we can draw geometric primitives, and we can redraw them many times per second,
    something that we’ll use to create the perception of motion.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 图形用户界面（GUIs）通常由一个父窗口（或多个窗口）组成，其中包含用户可以交互的*控件*，例如按钮或文本框。对于我们绘制仿真图形的目标，我们最感兴趣的控件是*画布*。在画布上，我们可以绘制几何图形原语，并且可以每秒重绘它们多次，这将帮助我们创造运动的感觉。
- en: In this chapter, we’ll cover how to lay out a GUI using Tkinter, a package shipped
    with Python’s Standard Library. Once we’ve got that down, we’ll implement a class
    that will make drawing our geometric primitives to the canvas convenient. This
    class will also include an affine transformation as part of its state. We’ll use
    this to affect how all primitives are drawn to the canvas, which will allow us
    to do things such as flip the drawing vertically so that the y-axis points up.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将介绍如何使用Tkinter布局图形用户界面，Tkinter是Python标准库中自带的一个包。掌握这一点后，我们将实现一个类，方便我们将几何原语绘制到画布上。这个类还将包含一个仿射变换，作为其状态的一部分。我们将使用这个变换来影响所有原语的绘制方式，从而实现一些效果，例如将绘制内容垂直翻转，使得y轴指向上方。
- en: '**Tkinter**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Tkinter**'
- en: Tkinter is a package that ships with Python’s Standard Library. It’s used for
    building graphical user interfaces. It provides the visual components, in other
    words, the widgets, such as buttons, text fields, and windows. It also provides
    the canvas, which we’ll use to draw the frames of our simulations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter是Python标准库中自带的一个包，用于构建图形用户界面。它提供了视觉组件，换句话说，就是控件，比如按钮、文本框和窗口。它还提供了画布，我们将用它来绘制仿真图形的框架。
- en: Tkinter is a feature-rich library; there are entire books written on it (see,
    for example, [7]). We’ll only cover what we need for our purposes, but if you
    enjoy creating GUIs, I recommend you spend some time looking through Tkinter’s
    documentation online; there’s a lot you can learn that will help you build fancy
    GUIs for your programs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter是一个功能丰富的库；甚至有整本书专门讲解它（例如，参见[7]）。我们只会讲解对于我们的目标而言需要的内容，但如果你喜欢创建GUI，我建议你花些时间浏览Tkinter的在线文档；你可以学到很多东西，这些都能帮助你为程序构建精美的GUI。
- en: '***Our First GUI Program***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***我们的第一个GUI程序***'
- en: 'Let’s create a new package in the *graphic* folder where we’ll place our simulation
    code. Right-click *graphic*, choose **New** ▸ **Python Package**, name it *simulation*,
    and click **OK**. The folder structure in your project should look like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在*graphic*文件夹中创建一个新包，将我们的仿真代码放入其中。右键单击*graphic*，选择**新建** ▸ **Python包**，命名为*simulation*，然后点击**确定**。你项目中的文件夹结构应该如下所示：
- en: Mechanics
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Mechanics
- en: '|- apps'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '|- apps'
- en: '|    |- circle_from_points'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- circle_from_points'
- en: '|- geom2d'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '|- geom2d'
- en: '|    |- tests'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- tests'
- en: '|- graphic'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '|- graphic'
- en: '|    |- simulation'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- simulation'
- en: '|    |- svg'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- svg'
- en: '|- utils'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '|- utils'
- en: Let’s now create our first GUI program to get acquainted with Tkinter. In the
    newly created *simulation* folder, add a new Python file named *hello_tkinter.py*.
    Enter the code in [Listing 10-1](ch10.xhtml#ch10lis1).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建第一个GUI程序来熟悉Tkinter。在新创建的*simulation*文件夹中，添加一个名为*hello_tkinter.py*的新Python文件。输入[清单10-1](ch10.xhtml#ch10lis1)中的代码。
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 10-1: Hello Tkinter*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单10-1：Hello Tkinter*'
- en: To execute the code in the file, right-click it in the Project tree panel and
    choose **Run ‘hello_tkinter’** from the menu that appears. When you execute the
    code, an empty window with the title “Hello Tkinter” opens, as shown in [Figure
    10-1](ch10.xhtml#ch10fig1).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行文件中的代码，请在项目树面板中右键单击该文件，然后从弹出的菜单中选择**运行 ‘hello_tkinter’**。当你执行代码时，一个标题为“Hello
    Tkinter”的空窗口将会打开，如[图10-1](ch10.xhtml#ch10fig1)所示。
- en: '![Image](../images/10fig01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/10fig01.jpg)'
- en: '*Figure 10-1: The empty Tkinter window*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-1：空的Tkinter窗口*'
- en: Let’s review the code we’ve just written. We start by importing the Tk class
    from tkinter. The tk variable holds an instance of Tk, which represents the main
    window in a Tkinter program. This window is also referred to as *root* in the
    documentation and examples online.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们刚刚写的代码。我们首先从tkinter中导入Tk类。tk变量保存了一个Tk实例，代表Tkinter程序中的主窗口。这个窗口在文档和在线示例中也被称为*root*。
- en: 'We then set the title of the window to Hello Tkinter and run the *main loop*.
    Notice that the main window won’t appear on the screen until the main loop starts.
    In a GUI program, the main loop is an infinite loop: it runs the entire time the
    program is being executed; as it runs, it collects user events in its windows
    and reacts to them.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将窗口的标题设置为Hello Tkinter，并运行*主循环*。注意，主窗口不会在屏幕上显示，直到主循环开始。在图形界面程序中，主循环是一个无限循环：它在程序执行时一直运行；在运行过程中，它会收集窗口中的用户事件并做出反应。
- en: Graphical user interfaces are different than the other programs we’ve been writing
    so far in that they’re *event driven*. This means that graphic components can
    be configured to run some code whenever they receive an event of the desired type.
    For example, we can tell a button to write a message when it receives a click
    event, that is, when it gets clicked. The code that reacts to an event is commonly
    known as an *event handler*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图形用户界面与我们之前编写的其他程序不同，因为它们是*事件驱动的*。这意味着可以配置图形组件，在接收到期望的事件类型时运行某些代码。例如，我们可以告诉按钮在接收到点击事件时显示一条消息，也就是当它被点击时。反应事件的代码通常称为*事件处理程序*。
- en: Let’s add a text field where the user can write their name, and let’s add a
    button to greet them by name. Modify your *hello_tkinter.py* file to include the
    code in [Listing 10-2](ch10.xhtml#ch10lis2). Pay attention to the new imports
    on top of the file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个文本字段，供用户输入名字，并添加一个按钮，通过名字向用户打招呼。修改你的*hello_tkinter.py*文件，包含[清单10-2](ch10.xhtml#ch10lis2)中的代码。注意文件顶部新增的导入部分。
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 10-2: Hello Tkinter widgets*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单10-2：Hello Tkinter小部件*'
- en: 'To add the label “Enter your name:” we’ve instantiated the Label class from
    tkinter ➊. We pass the constructor the reference to the program’s main window
    (tk) and a named argument with the text to display: text=’Enter your name:’. Before
    the label can appear in the window, we need to tell it where to place itself in
    the window.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加标签“Enter your name:”，我们从tkinter实例化了Label类 ➊。我们将构造函数传递给程序主窗口（tk）的引用，并传递一个带有要显示文本的命名参数：text='Enter
    your name:’。在标签出现在窗口之前，我们需要告诉它在窗口中的位置。
- en: On the created instance of Label, we call grid with the named arguments row
    and column. This method places the widget in an invisible grid in the window,
    in the given row and column indices. Cells in the grid adapt their size to fit
    their contents. As you can see in the code, we call this method on every widget
    to assign them a position in the window. [Figure 10-2](ch10.xhtml#ch10fig2) shows
    our UI’s grid. There are other ways of placing components in windows, but we’ll
    use this one for now because it’s flexible enough for us to easily arrange components.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建的Label实例上，我们调用带有命名参数row和column的grid方法。此方法将小部件放置在窗口中一个不可见的网格里，按照给定的行和列索引。网格中的单元格会根据内容自动调整大小。正如代码中所示，我们在每个小部件上调用此方法，以便将它们定位到窗口中。[图10-2](ch10.xhtml#ch10fig2)展示了我们UI的网格。还有其他方式可以在窗口中放置组件，但我们现在将使用这种方式，因为它足够灵活，能够轻松地排列组件。
- en: '![Image](../images/10fig02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig02.jpg)'
- en: '*Figure 10-2: Tkinter grid*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-2：Tkinter网格*'
- en: The input field in Tkinter is known as Entry ➌. To have access to the contents
    of the field (the text written to it), we must first create a StringVar, which
    we’ll call name ➋. This variable is passed to the Entry component using the textvariable
    argument. We can get the string written in the field by invoking get on the instance,
    as we’ll do shortly. Lastly, we create a button with the text “Greet me” ➍; this
    button does nothing if clicked (we’ll add that functionality shortly).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter中的输入字段被称为Entry ➌。为了访问该字段的内容（即输入的文本），我们必须首先创建一个StringVar变量，称为name ➋。这个变量通过textvariable参数传递给Entry组件。我们可以通过在实例上调用get来获取字段中写入的字符串，稍后我们将这样做。最后，我们创建一个按钮，文本为“Greet
    me” ➍；这个按钮点击时不会做任何事情（我们稍后会添加功能）。
- en: Run the file. You should now see a label, a text field, and a button, as in
    [Figure 10-3](ch10.xhtml#ch10fig3).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该文件。现在你应该能看到一个标签、一个文本字段和一个按钮，如[图10-3](ch10.xhtml#ch10fig3)所示。
- en: '![Image](../images/10fig03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig03.jpg)'
- en: '*Figure 10-3: Some Tkinter widgets*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-3：一些Tkinter小部件*'
- en: Let’s finish our program by adding an event handler to the button’s click, which
    opens a new dialog with a greeting message. Modify your code so that it looks
    like [Listing 10-3](ch10.xhtml#ch10lis3).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过为按钮点击事件添加一个事件处理程序来完成我们的程序，点击按钮后会弹出一个新对话框，显示问候信息。修改你的代码，使其看起来像[清单 10-3](ch10.xhtml#ch10lis3)。
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 10-3: Hello Tkinter that greets users*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-3：问候用户的 Hello Tkinter*'
- en: We’ve added a function named greet_user ➊. This function opens an information
    dialog with the title “Greetings” and a message saying hello to the name the user
    entered in the text field. Note that we import messagebox from tkinter to call
    the showinfo function. This function does the actual work of opening the dialog.
    To connect the button click event to our greet_user function, we need to pass
    it to Button’s constructor in a parameter named command ➋.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个名为 greet_user ➊ 的函数。这个函数会打开一个标题为“Greetings”的信息对话框，显示一条问候信息，内容是向用户在文本框中输入的名字打招呼。请注意，我们从
    tkinter 导入了 messagebox 来调用 showinfo 函数，这个函数实际执行打开对话框的工作。为了将按钮点击事件与 greet_user
    函数连接，我们需要通过参数 command 将其传递给 Button 的构造函数 ➋。
- en: Run the file now. Don’t forget to close our application’s window and rerun the
    program every time you want your new code to be executed. Enter your name in the
    text field and click the button. The program should open a new dialog with a personalized
    greeting, something similar to [Figure 10-4](ch10.xhtml#ch10fig4).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行文件。别忘了每次想要执行新代码时，先关闭应用程序的窗口，然后重新运行程序。在文本框中输入你的名字并点击按钮。程序应该会弹出一个新对话框，显示个性化的问候信息，类似于[图
    10-4](ch10.xhtml#ch10fig4)。
- en: '![Image](../images/10fig04.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig04.jpg)'
- en: '*Figure 10-4: Our Tkinter greeter program*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-4：我们的 Tkinter 问候程序*'
- en: There’s much more Tkinter can do, but we won’t need that much for this book.
    We’re mostly interested in using its canvas component, which we’ll explore in
    the next section. If you want to learn more about Tkinter, you have lots of great
    resources online. You can also refer to [7], as mentioned earlier.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 还能做很多事情，但在本书中我们不需要使用那么多功能。我们主要关注的是它的画布组件，接下来我们将深入探索这一部分。如果你想了解更多关于 Tkinter
    的信息，网上有很多优秀的资源。你也可以参考之前提到的[7]。
- en: '***The Canvas***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***画布***'
- en: A canvas is a surface to paint on. In Tkinter’s digital world, it’s the same.
    The canvas component is represented by the Canvas class in tkinter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 画布是一个可以绘制的区域。在 Tkinter 的数字世界中，情况也是如此。Tkinter 的画布组件由 tkinter 中的 Canvas 类表示。
- en: Let’s create a new Tkinter application where we can experiment with drawing
    to the canvas. In the *simulation* folder, create a new file named *hello_canvas.py*
    and enter the code in [Listing 10-4](ch10.xhtml#ch10lis4).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的 Tkinter 应用程序，在其中尝试绘制画布内容。在 *simulation* 文件夹中，创建一个名为 *hello_canvas.py*
    的新文件，并输入[清单 10-4](ch10.xhtml#ch10lis4)中的代码。
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 10-4: Hello Canvas*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-4：Hello Canvas*'
- en: The code creates a Tkinter application with its main window and a 600 by 600–pixel
    canvas. If you run the file, you should see an empty window with the title “Hello
    Canvas.” The canvas is there; it’s just that there’s nothing drawn yet.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个 Tkinter 应用程序，包含了一个主窗口和一个 600x600 像素的画布。如果你运行这个文件，应该会看到一个空的窗口，标题为“Hello
    Canvas”。画布已经存在，只是暂时还没有绘制任何内容。
- en: '**Drawing Lines**'
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**绘制线条**'
- en: 'Let’s start easy and draw a line on the canvas. Just between creating the canvas
    and starting the main loop, add the following line:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从简单的开始，在画布上画一条线。只需要在创建画布和启动主循环之间，添加以下这一行：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The arguments passed to create_line are, respectively, the x- and y-coordinates
    of the start point and the x- and y-coordinates of the end point.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 create_line 的参数分别是起点的 x 和 y 坐标，以及终点的 x 和 y 坐标。
- en: Run the file again. There should be a line segment going from the upper-left
    corner, (0, 0), to the center of the screen, (300, 300). As you can guess, the
    origin of coordinates is in the upper-left corner of the screen with the y-axis
    pointing downward. Later when we’re animating simulations, we’ll use affine transformations
    to fix this.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次运行文件。应该会看到一条从屏幕左上角（0, 0）到屏幕中央（300, 300）的线段。正如你所猜测的那样，坐标原点在屏幕的左上角，y 轴朝下。稍后当我们进行动画模拟时，我们将使用仿射变换来修正这一点。
- en: 'By default, lines are drawn with a width of 1 pixel and painted in black, but
    we can change this. Try the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，线条的宽度是 1 像素，颜色是黑色，但我们可以进行更改。试试以下代码：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The line is now thicker and has a reddish color. Your result should look like
    [Figure 10-5](ch10.xhtml#ch10fig5).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这条线变得更粗，而且呈现出红色。你的结果应该和[图 10-5](ch10.xhtml#ch10fig5)类似。
- en: '![Image](../images/10fig05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig05.jpg)'
- en: '*Figure 10-5: A line on a Tkinter canvas*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-5：Tkinter 画布上的一条线*'
- en: '**Drawing Ovals**'
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**绘制椭圆**'
- en: 'Let’s draw a circle in the middle of our application’s window using the same
    color as the previous line:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用与前一条线相同的颜色，在应用程序窗口的中央绘制一个圆形：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The arguments passed to create_oval are the x- and y-coordinates of the upper-left
    vertex of the rectangle that contains the oval, and the x- and y-coordinates of
    the lower-right vertex. These are followed by the named arguments used to determine
    the line’s width and color: width and outline.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `create_oval` 的参数是包含椭圆的矩形左上角的 x 和 y 坐标，以及右下角的 x 和 y 坐标。接着是用于确定线条宽度和颜色的命名参数：`width`
    和 `outline`。
- en: 'If you run the file, you’ll see a circle in the center of the window. Let’s
    turn it into a proper oval by making it 100 pixels wider, maintaining its height
    of 400 pixels:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行文件，你会看到一个位于窗口中心的圆形。让我们通过将它的宽度增加 100 像素，保持高度为 400 像素，将其变成一个正确的椭圆：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By changing the x-coordinate of the lower-right corner from 400 to 500, the
    circle turns into an oval. The application now has a canvas with both a line and
    an oval, as in [Figure 10-6](ch10.xhtml#ch10fig6).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将右下角的 x 坐标从 400 改为 500，圆形变成了椭圆。现在应用程序有了一个同时包含线条和椭圆的画布，如 [图 10-6](ch10.xhtml#ch10fig6)
    所示。
- en: '![Image](../images/10fig06.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig06.jpg)'
- en: '*Figure 10-6: An oval added to our Tkinter canvas*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-6：添加到 Tkinter 画布上的椭圆*'
- en: 'If we wanted to add a fill color to the oval, we could do so using the named
    argument fill=’...’. Here’s an example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想为椭圆添加填充颜色，可以使用命名参数 `fill='...'`。以下是一个示例：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There’s one limitation, though: Tkinter doesn’t support transparency, which
    means all of our fills and strokes will be completely opaque. The color format
    #rrggbbaa where aa is the value for the *alpha* (transparency) is not supported
    in Tkinter.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '不过有一个限制：Tkinter 不支持透明度，这意味着我们的填充和描边将完全不透明。Tkinter 不支持格式为 #rrggbbaa 的颜色，其中 aa
    是 *alpha*（透明度）值。'
- en: '**Drawing Rectangles**'
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**绘制矩形**'
- en: 'Drawing rectangles is also pretty straightforward. Enter this code in the file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制矩形也相当简单。在文件中输入以下代码：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The mandatory arguments to create_rectangle are the x- and y-coordinates of
    the upper-left corner of the rectangle and the x- and y-coordinates of the lower-right
    corner.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_rectangle` 的必需参数是矩形左上角的 x 和 y 坐标，以及右下角的 x 和 y 坐标。'
- en: Run the file; the result should look like [Figure 10-7](ch10.xhtml#ch10fig7).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 运行文件，结果应该类似于 [图 10-7](ch10.xhtml#ch10fig7)。
- en: '![Image](../images/10fig07.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig07.jpg)'
- en: '*Figure 10-7: A rectangle added to our Tkinter canvas*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-7：添加到 Tkinter 画布上的矩形*'
- en: Nice! The resulting image is getting weirder, but isn’t it easy and fun to draw
    on the canvas?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 不错！结果图像变得越来越奇怪，但在画布上绘制图形是不是既简单又有趣？
- en: '**Drawing Polygons**'
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**绘制多边形**'
- en: 'The last geometric primitive we need to know how to draw is a generic polygon.
    After the code you added to draw the rectangle, write the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要了解的最后一个几何原始图形是通用多边形。在你添加了绘制矩形的代码之后，写入以下内容：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first parameter to create_polygon is a list of vertex coordinates. The rest
    are the named parameters that affect its style. Notice that we pass an empty string
    to the fill parameter; by default polygons get filled, but we want ours to be
    only an outline. Run the file to see the result. It should resemble [Figure 10-8](ch10.xhtml#ch10fig8).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_polygon` 的第一个参数是一个顶点坐标的列表。其余的是影响样式的命名参数。请注意，我们将空字符串传递给 `fill` 参数；默认情况下，多边形是填充的，但我们希望它只有轮廓。运行文件查看结果。它应该类似于
    [图 10-8](ch10.xhtml#ch10fig8)。'
- en: '![Image](../images/10fig08.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig08.jpg)'
- en: '*Figure 10-8: A polygon added to our Tkinter canvas*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-8：添加到 Tkinter 画布上的多边形*'
- en: We created a triangle with vertices (40, 200), (300, 450), and (600, 0). Try
    adding a fill color and seeing what results.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个顶点为 (40, 200)、(300, 450) 和 (600, 0) 的三角形。尝试添加填充颜色并查看结果。
- en: '**Drawing Text**'
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**绘制文本**'
- en: 'It isn’t a geometric primitive, but we may also need to draw some text to the
    canvas. Doing so is easy using the create_text method. Add the following to *hello_canvas.py*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它不是一个几何原始图形，但我们可能还需要在画布上绘制一些文本。使用 `create_text` 方法可以轻松做到这一点。将以下内容添加到 *hello_canvas.py*：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first two parameters are the x and y position for the center of the text.
    The named parameter text is where we set the actual text we want to draw; we can
    change its font using font. Run the file one last time to see the complete drawing,
    as shown in [Figure 10-9](ch10.xhtml#ch10fig9).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个参数是文本中心的 x 和 y 坐标。命名参数 `text` 是我们设置实际文本的地方；我们可以使用 `font` 来更改字体。最后运行文件一次，查看完整的绘图，如
    [图 10-9](ch10.xhtml#ch10fig9) 所示。
- en: If we can draw lines, circles, rectangles, generic polygons, and text, we can
    draw pretty much anything. We could also use arcs and splines, but we’ll manage
    to do our simulations using only these simple primitives.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以绘制线条、圆形、矩形、通用多边形和文本，我们几乎可以绘制任何东西。我们也可以使用弧线和样条曲线，但我们将通过仅使用这些简单的原语来完成我们的仿真。
- en: '![Image](../images/10fig09.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/10fig09.jpg)'
- en: '*Figure 10-9: Text added to our Tkinter canvas*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-9: 添加到我们的Tkinter画布上的文本*'
- en: Your final code should look like [Listing 10-5](ch10.xhtml#ch10lis5).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你的最终代码应该如下所示，参考[清单 10-5](ch10.xhtml#ch10lis5)。
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 10-5: Final drawing code*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-5: 最终绘图代码*'
- en: Now that we know how to draw simple primitives to the canvas, let’s come up
    with a way of drawing our *geom2d* library’s geometric primitives directly to
    the canvas.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何将简单的原语绘制到画布上，让我们想出一种方法，直接将我们的*geom2d*库的几何原语绘制到画布上。
- en: '**Drawing Our Geometric Primitives**'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**绘制我们的几何原语**'
- en: 'Drawing a circle to the canvas was easy using its create_oval method. This
    method is, nevertheless, not convenient; to define the circle, you need to pass
    the coordinates of two vertices that define a rectangle where the circle or oval
    is inscribed. On the other hand, our class Circle is defined by its center point
    and radius, and it has some useful methods and can be transformed using instances
    of AffineTransform. It would be nice if we could directly draw our circles like
    so:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用画布的create_oval方法绘制圆形非常简单。然而，这个方法并不方便；为了定义圆形，你需要传递定义一个矩形的两个顶点的坐标，该矩形内接圆形或椭圆。另一方面，我们的Circle类通过它的中心点和半径来定义，并且具有一些有用的方法，可以使用AffineTransform的实例进行变换。如果我们能像这样直接绘制我们的圆形，那就太好了：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We definitely want to work with our geometry primitives. Similar to how we created
    SVG representations of them in [Chapter 8](ch08.xhtml#ch08), we’ll need a way
    to draw them to the canvas.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定希望与我们的几何原语一起工作。类似于我们在[第8章](ch08.xhtml#ch08)中创建它们的SVG表示方式，我们需要一种方法将它们绘制到画布上。
- en: 'Here’s the plan: we’ll create a wrapper for Tkinter’s Canvas widget. We’ll
    create a class that contains an instance of the canvas where we want to draw but
    whose methods allow us to pass our own geometric primitives. To leverage our powerful
    affine transformation implementation, we’ll associate a transformation to our
    drawing so that all primitives we pass will first be transformed.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 计划如下：我们将为Tkinter的Canvas小部件创建一个包装类。我们将创建一个包含我们希望绘制的画布实例的类，但它的方法允许我们传递自己的几何原语。为了利用我们强大的仿射变换实现，我们将把变换与绘图关联，这样我们传递的所有原语将首先经过变换。
- en: '***The Canvas Wrapper Class***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***画布包装类***'
- en: A wrapper class is simply a class that contains an instance of another class
    (what it’s wrapping) and is used to provide a similar functionality as the wrapped
    class, but with a different interface and some added functionality. It’s a simple
    yet powerful concept.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 包装类就是一个包含另一个类（它所包装的类）实例的类，并用于提供与被包装类相似的功能，但具有不同的接口和一些附加的功能。这是一个简单却强大的概念。
- en: 'In this case, we’re wrapping a Tkinter canvas. Our canvas wrapper goal is to
    allow us to draw our geometric primitives with a simple and clean interface: we
    want methods that directly accept instances of our primitives. This wrapper will
    save us from the repetitive task of adapting the representation of the geometric
    classes to the inputs expected by the Tkinter canvas’s drawing methods. Not only
    that, but we’ll also apply an affine transformation to everything that we draw.
    [Figure 10-10](ch10.xhtml#ch10fig10) depicts this process.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在包装一个Tkinter画布。我们的画布包装类的目标是让我们以简单、干净的接口绘制我们的几何原语：我们希望方法能够直接接受我们的原语实例。这个包装类将帮助我们避免重复的任务，即将几何类的表示适配为Tkinter画布绘图方法所期望的输入。不仅如此，我们还会对我们绘制的所有内容应用仿射变换。[图
    10-10](ch10.xhtml#ch10fig10)描述了这个过程。
- en: In the *simulation* package, create a new file named *draw.py*. Enter the code
    in [Listing 10-6](ch10.xhtml#ch10lis6).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在*simulation*包中，创建一个名为*draw.py*的新文件。输入[清单 10-6](ch10.xhtml#ch10lis6)中的代码。
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 10-6: Canvas wrapper class*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-6: 画布包装类*'
- en: The class CanvasDrawing is defined as a wrapper to the Tkinter canvas. An instance
    of the canvas is passed to the initializer and stored in a private variable, __canvas.
    Making __canvas private means we don’t want anyone using CanvasDrawing to access
    it directly. It now belongs to the wrapper class instance, and it should only
    be used with its methods.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: CanvasDrawing类被定义为Tkinter画布的包装类。一个画布实例被传递给初始化函数并存储在一个私有变量__canvas中。将__canvas设为私有意味着我们不希望任何使用CanvasDrawing的人直接访问它。它现在属于包装类实例，应该仅通过其方法使用。
- en: 'An instance of AffineTransform is also passed to the initializer. We’ll apply
    this affine transformation to all geometric primitives before we draw them to
    Tkinter’s canvas. The transformation is stored in a public variable: transform.
    This means we’re allowing users of CanvasDrawing instances to directly manipulate
    and edit this property, which is part of the state of the instance. We do this
    so that it’s simple to alter the affine transformation applied to the drawing,
    by reassigning the transform property to a different transformation.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个AffineTransform实例也被传递给初始化函数。我们将在绘制到Tkinter画布之前，将这个仿射变换应用到所有几何原件。变换存储在一个公共变量中：transform。这意味着我们允许CanvasDrawing实例的用户直接操作和编辑这个属性，它是实例状态的一部分。我们这样做是为了让改变绘制时应用的仿射变换变得简单，通过将transform属性重新赋值为一个不同的变换。
- en: 'The state of an instance defines its behavior: if the state changes, the instance’s
    behavior changes as well. In this case, it’s clear that if the property transform
    is reassigned a different affine transformation, all subsequent drawing commands
    will produce results in accordance with it.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实例的状态定义了它的行为：如果状态发生变化，实例的行为也会随之变化。在这种情况下，很明显，如果属性transform被重新分配为一个不同的仿射变换，所有后续的绘图命令将会根据这个变换产生结果。
- en: '[Figure 10-10](ch10.xhtml#ch10fig10) is a diagram representing the behavior
    of our canvas wrapper class. It’ll receive draw requests for different geometric
    primitives, apply the affine transformation to them, and then call the Tkinter’s
    canvas methods to draw into it.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-10](ch10.xhtml#ch10fig10)是一个表示我们画布包装类行为的图示。它将接收不同几何原件的绘制请求，应用仿射变换，并调用Tkinter的画布方法将其绘制到画布上。'
- en: '![Image](../images/10fig10.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/10fig10.jpg)'
- en: '*Figure 10-10: The canvas wrapper class*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-10：画布包装类*'
- en: 'There are other state variables defined in the initializer: outline_color,
    which defines the color used for the outline of geometries, outline_width for
    the width of the outlines, and fill_color for the color used to fill the geometries.
    These are given default values in the initializer (those used in our example in
    the previous section) but are also public and accessible for users of the instance
    to change them. Like before, it should be clear that these properties are part
    of the state of the instance: if we edit outline_color, for example, all subsequent
    drawings will use that color for the outlines.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化函数中还定义了其他状态变量：outline_color，用于定义几何体轮廓的颜色，outline_width用于轮廓的宽度，fill_color用于填充几何体的颜色。这些在初始化函数中有默认值（在前一节示例中使用的那些），但它们也是公共的，实例的用户可以更改它们。如同之前一样，应该清楚这些属性是实例状态的一部分：如果我们编辑outline_color，例如，所有后续的绘图都会使用该颜色作为轮廓色。
- en: 'We’ve defined only one method in the class: clear_drawing. This method will
    clean the canvas for us before drawing each of the frames. Let’s now focus on
    the drawing commands.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个类中只定义了一个方法：clear_drawing。这个方法将清除画布，在每次绘制每个帧之前使用。现在让我们聚焦于绘图命令。
- en: '***Drawing Segments***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制线段***'
- en: 'Let’s start with the simplest primitive to draw: the segment. In the Canvas
    Drawing class, enter the method in [Listing 10-7](ch10.xhtml#ch10lis7). For this
    code you first need to update the imports from *geom2d* to include the Segment
    class.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最简单的几何原件开始绘制：线段。在Canvas Drawing类中，输入[清单 10-7](ch10.xhtml#ch10lis7)中的方法。对于这段代码，你需要先更新*geom2d*的导入，包含Segment类。
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 10-7: Drawing a segment*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-7：绘制线段*'
- en: '**NOTE**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Note how we’re passing the* self.outline_color *value to the* fill *parameter.
    That looks like an error, but unfortunately, Tkinter picked a bad name. The* fill
    *attribute is used for the stroke’s color in a* create_line *command. A better
    name would have been* outline *or, even better,* stroke-color.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意我们是如何将* self.outline_color *值传递给* fill *参数的。这看起来像是一个错误，但不幸的是，Tkinter选择了一个不好的名字。*
    fill *属性用于* create_line *命令中的笔触颜色。更好的名字应该是* outline *或者，更好的是，* stroke-color。'
- en: 'The draw_segment method does two things: first it transforms the given segment
    using the current affine transformation and stores the result in segment_t. Then
    it calls the create_line method from the canvas instance. For the outline color
    and width, we use the state variables of the instance.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw_segment` 方法做了两件事：首先，它使用当前仿射变换转换给定的段，并将结果存储在 `segment_t` 中。然后，它调用画布实例的
    `create_line` 方法。对于轮廓颜色和宽度，我们使用实例的状态变量。'
- en: Let’s move on to polygons, circles, and rectangles.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论多边形、圆形和矩形。
- en: '***Drawing Polygons***'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制多边形***'
- en: If you recall from “Transform Segments and Polygons” on [page 179](ch07.xhtml#ch00lev2sec82),
    once an affine transformation is applied to a circle or rectangle, the result
    is a generic polygon. This means that all three polygons will be drawn using the
    create_polygon method from the canvas.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得在[第179页](ch07.xhtml#ch00lev2sec82)的“转换段和多边形”中提到的内容，一旦仿射变换应用到圆形或矩形上，结果将是一个通用的多边形。这意味着所有三个多边形都将使用画布的
    `create_polygon` 方法进行绘制。
- en: Let’s create a private method that draws a polygon to the canvas, forgetting
    about the affine transformation; that part will be handled by each of the public
    drawing methods.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个私有方法，将多边形绘制到画布上，忽略仿射变换；这一部分将由每个公共绘图方法来处理。
- en: In your CanvasDrawing class, enter the private method in [Listing 10-8](ch10.xhtml#ch10lis8).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `CanvasDrawing` 类中，输入[清单10-8](ch10.xhtml#ch10lis8)中的私有方法。
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 10-8: Drawing a polygon to the canvas*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单10-8：将多边形绘制到画布上*'
- en: For this code you need to add the following import,
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这段代码，你需要添加以下导入：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'and update the imports from geom2d:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 并更新来自 geom2d 的导入：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The __draw_polygon method first prepares the vertex coordinates of the polygon
    to meet the expectations of the canvas widget’s create_polygon method. This is
    done by reducing a list of lists of vertex coordinates with Python’s list __add__
    method, which, if you recall, is the method that overloads the + operator.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`__draw_polygon` 方法首先准备多边形的顶点坐标，以符合画布小部件的 `create_polygon` 方法的期望。这是通过使用 Python
    的列表 `__add__` 方法来减少多个顶点坐标列表实现的，正如你回忆的那样，`__add__` 方法重载了 `+` 操作符。'
- en: 'Let’s break this down. First, the polygon’s vertices are mapped using a list
    comprehension:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下。首先，通过列表推导式将多边形的顶点映射出来：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This creates a list with the x- and y-coordinates from each vertex. If the
    vertices of the polygon were (0, 10), (10, 0), and (10, 10), the list comprehension
    shown earlier would result in the following list:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含每个顶点的 x 和 y 坐标的列表。如果多边形的顶点是 (0, 10)、(10, 0) 和 (10, 10)，之前展示的列表推导式将生成如下列表：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This list then needs to be *flattened*: all values in the inner lists (the
    numeric coordinates) have to be concatenated into a single list. The result of
    flattening the previous list would be as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表接下来需要被 *扁平化*：内嵌列表中的所有值（数值坐标）必须连接成一个单一的列表。扁平化之前的列表的结果将如下所示：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is the list of vertex coordinates the method create_polygon expects. This
    final flattening step is achieved by the reduce function; we pass it the list
    .__add__ operator, and it produces a new list that results from concatenating
    both list operands. To see that in action, you can test the following in Python’s
    shell:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是方法 `create_polygon` 所期望的顶点坐标列表。最终的扁平化步骤是通过 `reduce` 函数实现的；我们传递给它列表的 `.__add__`
    操作符，它生成一个新的列表，该列表由连接两个列表操作数的结果组成。要查看这个过程的实际效果，你可以在 Python 的交互式命令行中测试以下内容：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once the list of vertex coordinates is ready, drawing it to the canvas is straightforward:
    we simply pass the list to the canvas’s create_polygon method. Now that the hardest
    part is done, drawing our polygons should be easier. Enter the code in [Listing
    10-9](ch10.xhtml#ch10lis9) to your class.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦顶点坐标列表准备好，将其绘制到画布上就变得简单了：我们只需将该列表传递给画布的 `create_polygon` 方法。现在最困难的部分已经完成，绘制多边形应该会更容易。将[清单10-9](ch10.xhtml#ch10lis9)中的代码输入到你的类中。
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 10-9: Drawing circles, rectangles, and generic polygons*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单10-9：绘制圆形、矩形和通用多边形*'
- en: 'Don’t forget to add the missing imports from *geom2d*:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记添加来自 *geom2d* 的缺失导入：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In all three methods, the process is the same: call the private method __draw_polygon
    and pass it the result of applying the current affine transformation to the geometry.
    Don’t forget that in the case of a circle, we need to pass the number of divisions
    we’ll use to approximate it to the transform method.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三种方法中，过程是相同的：调用私有方法 `__draw_polygon`，并将当前仿射变换应用到几何形状后的结果传递给它。不要忘了，在圆形的情况下，我们需要将用来近似圆形的分割数传递给变换方法。
- en: '***Drawing Arrows***'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制箭头***'
- en: Let’s now draw arrows following the same approach we used in [Chapter 8](ch08.xhtml#ch08)
    for SVG images.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们按照我们在[第 8 章](ch08.xhtml#ch08)中为SVG图像使用的方法来绘制箭头。
- en: 'The arrow’s head will be drawn on the end point *E* of a segment and will be
    made of two segments at an angle meeting at such an end point. To allow some flexibility,
    we’ll use two dimensions to define the arrow’s geometry: a length and a height
    (see [Figure 10-11](ch10.xhtml#ch10fig11)).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头的头部将绘制在线段的端点*E*上，由两条线段在该端点成角度相交组成。为了提供一些灵活性，我们将使用二维来定义箭头的几何形状：长度和高度（参见[图 10-11](ch10.xhtml#ch10fig11)）。
- en: As you can see in [Figure 10-11](ch10.xhtml#ch10fig11) (repeated from [Chapter
    8](ch08.xhtml#ch08)), to draw the arrow’s head, we need to figure out points *C*[1]
    and *C*[2]. With those two points, we can easily draw the segments between *C*[1]
    and *E* and between *C*[2] and *E*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在[图 10-11](ch10.xhtml#ch10fig11)（从[第 8 章](ch08.xhtml#ch08)重复）中看到的，要绘制箭头的头部，我们需要弄清楚点*C*[1]和*C*[2]的位置。有了这两个点，我们就可以轻松绘制从*C*[1]到*E*以及从*C*[2]到*E*的线段。
- en: '![Image](../images/10fig11.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig11.jpg)'
- en: '*Figure 10-11: Key points in an arrow*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-11：箭头中的关键点*'
- en: 'To find out where those points lie in the plane, we’ll be computing three vectors:
    ![Image](../images/vlvictorit.jpg), which has the same length as the arrow’s head
    and is going in the opposite direction of the segment’s direction vector, and
    ![Image](../images/vh1victorit.jpg) and ![Image](../images/vh2victorit.jpg), which
    are perpendicular to the segment and both have a length equal to half the arrow’s
    head height. [Figure 10-11](ch10.xhtml#ch10fig11) shows these vectors. The point
    *C*[1] can be computed by creating a displaced version of *E* (the segment’s end
    point),'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出这些点在平面中的位置，我们将计算三个向量：![Image](../images/vlvictorit.jpg)，它的长度与箭头头部相同，并且方向与线段的方向向量相反，另外两个是![Image](../images/vh1victorit.jpg)和![Image](../images/vh2victorit.jpg)，它们与线段垂直，且长度都等于箭头头部高度的一半。[图
    10-11](ch10.xhtml#ch10fig11)展示了这些向量。点*C*[1]可以通过创建一个*E*（线段的端点）的平移版本来计算，
- en: '![Image](../images/f00282-p1.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f00282-p1.jpg)'
- en: 'and similarly, *C*[2]:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，*C*[2]：
- en: '![Image](../images/f00282-p2.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f00282-p2.jpg)'
- en: Let’s write the method. In the CanvasDrawing class, enter the code in [Listing
    10-10](ch10.xhtml#ch10lis10).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写这个方法。在CanvasDrawing类中，输入[清单 10-10](ch10.xhtml#ch10lis10)中的代码。
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 10-10: Drawing an arrow*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-10：绘制箭头*'
- en: We start by computing the three vectors we need to figure out points *C*[1]
    and *C*[2] using the previous equations. As you can see, this is pretty straightforward
    thanks to the methods we implemented in our Vector class. For example, to obtain
    ![Image](../images/vlvictorit.jpg), we use the opposite vector of the segment’s
    direction vector and scale it to have the desired length. We use similar operations
    to calculate the remaining elements of our equations.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先计算出需要的三个向量，利用之前的公式找出点*C*[1]和*C*[2]的位置。正如你所看到的，由于我们在Vector类中实现的方法，这一过程相当直接。例如，为了获得![Image](../images/vlvictorit.jpg)，我们使用线段方向向量的相反向量，并将其缩放到所需的长度。我们使用类似的操作来计算我们方程式中的其余元素。
- en: 'Then we three segments: the base line, which is the segment passed as the argument;
    the segment going from *E* to *C*[1] ➊ ; and the one going from *E* to *C*[2]
    ➋.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有三个线段：基准线，即作为参数传递的线段；从*E*到*C*[1] ➊ 的线段；以及从*E*到*C*[2] ➋ 的线段。
- en: For reference, your *drawing.py* file should look like [Listing 10-11](ch10.xhtml#ch10lis11).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，你的*drawing.py*文件应该如下所示：[清单 10-11](ch10.xhtml#ch10lis11)。
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 10-11: CanvasDrawing class result*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-11：CanvasDrawing 类结果*'
- en: We now have a convenient way of drawing our geometric primitives, but they’re
    not moving at all, and we need motion to produce simulations. What’s the missing
    ingredient to bring those geometries to life? That’s the topic of the next chapter.
    Matters are getting more and more exciting!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种方便的方式来绘制几何图形，但它们完全没有运动，我们需要运动来生成模拟。让这些几何图形栩栩如生的缺失成分是什么呢？这就是下一章的主题。事情变得越来越激动人心！
- en: '**Summary**'
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we covered the basics of creating graphical user interfaces
    using Python’s Tkinter package. We saw how to lay widgets on the main window using
    the grid system. We also learned how to make a button respond to being clicked
    and how to read the contents of a text field. Most importantly, we learned about
    the Canvas class and its methods that we can use to draw simple primitives to
    it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用Python的Tkinter包创建图形用户界面的基础知识。我们学习了如何使用网格系统将小部件放置到主窗口中。我们还了解了如何让按钮响应点击事件，以及如何读取文本框的内容。最重要的是，我们学习了Canvas类及其方法，利用这些方法我们可以在画布上绘制简单的原始图形。
- en: We finished the chapter by creating a class of our own that wraps Tkinter’s
    canvas and allows us to draw our geometric primitives directly. The class also
    includes an affine transformation that applies to the primitives before being
    drawn. The class has properties that define the stroke width and color as well
    as the fill color. These are the width and colors applied to the primitives we
    draw with it. Now it’s time to put those static geometries into motion.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建自己的类来结束这一章节，该类封装了Tkinter的画布，并允许我们直接绘制几何原始图形。这个类还包括一个仿射变换，在图形绘制之前应用于原始图形。该类具有定义笔触宽度和颜色以及填充颜色的属性。这些属性决定了我们用它绘制的几何图形的宽度和颜色。现在是时候让这些静态几何图形动起来了。
