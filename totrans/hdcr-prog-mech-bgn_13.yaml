- en: '10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GRAPHICAL USER INTERFACES AND THE CANVAS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Before we dive into simulations, we need to understand the basics of graphical
    user interfaces (GUIs). This is a massive topic, and we’ll barely scratch the
    surface, but we’ll see enough for us to present our simulations to the user.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: GUIs typically consist of a parent window (or windows) containing *widgets*
    the user can interact with, such as buttons or text fields. For our goal of drawing
    simulations, the widget we’re most interested in is the *canvas*. In a canvas
    we can draw geometric primitives, and we can redraw them many times per second,
    something that we’ll use to create the perception of motion.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll cover how to lay out a GUI using Tkinter, a package shipped
    with Python’s Standard Library. Once we’ve got that down, we’ll implement a class
    that will make drawing our geometric primitives to the canvas convenient. This
    class will also include an affine transformation as part of its state. We’ll use
    this to affect how all primitives are drawn to the canvas, which will allow us
    to do things such as flip the drawing vertically so that the y-axis points up.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '**Tkinter**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tkinter is a package that ships with Python’s Standard Library. It’s used for
    building graphical user interfaces. It provides the visual components, in other
    words, the widgets, such as buttons, text fields, and windows. It also provides
    the canvas, which we’ll use to draw the frames of our simulations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter is a feature-rich library; there are entire books written on it (see,
    for example, [7]). We’ll only cover what we need for our purposes, but if you
    enjoy creating GUIs, I recommend you spend some time looking through Tkinter’s
    documentation online; there’s a lot you can learn that will help you build fancy
    GUIs for your programs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '***Our First GUI Program***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s create a new package in the *graphic* folder where we’ll place our simulation
    code. Right-click *graphic*, choose **New** ▸ **Python Package**, name it *simulation*,
    and click **OK**. The folder structure in your project should look like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Mechanics
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '|- apps'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- circle_from_points'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '|- geom2d'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- tests'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '|- graphic'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- simulation'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '|    |- svg'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '|- utils'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now create our first GUI program to get acquainted with Tkinter. In the
    newly created *simulation* folder, add a new Python file named *hello_tkinter.py*.
    Enter the code in [Listing 10-1](ch10.xhtml#ch10lis1).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 10-1: Hello Tkinter*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: To execute the code in the file, right-click it in the Project tree panel and
    choose **Run ‘hello_tkinter’** from the menu that appears. When you execute the
    code, an empty window with the title “Hello Tkinter” opens, as shown in [Figure
    10-1](ch10.xhtml#ch10fig1).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-1: The empty Tkinter window*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Let’s review the code we’ve just written. We start by importing the Tk class
    from tkinter. The tk variable holds an instance of Tk, which represents the main
    window in a Tkinter program. This window is also referred to as *root* in the
    documentation and examples online.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'We then set the title of the window to Hello Tkinter and run the *main loop*.
    Notice that the main window won’t appear on the screen until the main loop starts.
    In a GUI program, the main loop is an infinite loop: it runs the entire time the
    program is being executed; as it runs, it collects user events in its windows
    and reacts to them.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Graphical user interfaces are different than the other programs we’ve been writing
    so far in that they’re *event driven*. This means that graphic components can
    be configured to run some code whenever they receive an event of the desired type.
    For example, we can tell a button to write a message when it receives a click
    event, that is, when it gets clicked. The code that reacts to an event is commonly
    known as an *event handler*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a text field where the user can write their name, and let’s add a
    button to greet them by name. Modify your *hello_tkinter.py* file to include the
    code in [Listing 10-2](ch10.xhtml#ch10lis2). Pay attention to the new imports
    on top of the file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 10-2: Hello Tkinter widgets*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the label “Enter your name:” we’ve instantiated the Label class from
    tkinter ➊. We pass the constructor the reference to the program’s main window
    (tk) and a named argument with the text to display: text=’Enter your name:’. Before
    the label can appear in the window, we need to tell it where to place itself in
    the window.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: On the created instance of Label, we call grid with the named arguments row
    and column. This method places the widget in an invisible grid in the window,
    in the given row and column indices. Cells in the grid adapt their size to fit
    their contents. As you can see in the code, we call this method on every widget
    to assign them a position in the window. [Figure 10-2](ch10.xhtml#ch10fig2) shows
    our UI’s grid. There are other ways of placing components in windows, but we’ll
    use this one for now because it’s flexible enough for us to easily arrange components.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-2: Tkinter grid*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The input field in Tkinter is known as Entry ➌. To have access to the contents
    of the field (the text written to it), we must first create a StringVar, which
    we’ll call name ➋. This variable is passed to the Entry component using the textvariable
    argument. We can get the string written in the field by invoking get on the instance,
    as we’ll do shortly. Lastly, we create a button with the text “Greet me” ➍; this
    button does nothing if clicked (we’ll add that functionality shortly).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Run the file. You should now see a label, a text field, and a button, as in
    [Figure 10-3](ch10.xhtml#ch10fig3).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig03.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-3: Some Tkinter widgets*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Let’s finish our program by adding an event handler to the button’s click, which
    opens a new dialog with a greeting message. Modify your code so that it looks
    like [Listing 10-3](ch10.xhtml#ch10lis3).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过为按钮点击事件添加一个事件处理程序来完成我们的程序，点击按钮后会弹出一个新对话框，显示问候信息。修改你的代码，使其看起来像[清单 10-3](ch10.xhtml#ch10lis3)。
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 10-3: Hello Tkinter that greets users*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-3：问候用户的 Hello Tkinter*'
- en: We’ve added a function named greet_user ➊. This function opens an information
    dialog with the title “Greetings” and a message saying hello to the name the user
    entered in the text field. Note that we import messagebox from tkinter to call
    the showinfo function. This function does the actual work of opening the dialog.
    To connect the button click event to our greet_user function, we need to pass
    it to Button’s constructor in a parameter named command ➋.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个名为 greet_user ➊ 的函数。这个函数会打开一个标题为“Greetings”的信息对话框，显示一条问候信息，内容是向用户在文本框中输入的名字打招呼。请注意，我们从
    tkinter 导入了 messagebox 来调用 showinfo 函数，这个函数实际执行打开对话框的工作。为了将按钮点击事件与 greet_user
    函数连接，我们需要通过参数 command 将其传递给 Button 的构造函数 ➋。
- en: Run the file now. Don’t forget to close our application’s window and rerun the
    program every time you want your new code to be executed. Enter your name in the
    text field and click the button. The program should open a new dialog with a personalized
    greeting, something similar to [Figure 10-4](ch10.xhtml#ch10fig4).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行文件。别忘了每次想要执行新代码时，先关闭应用程序的窗口，然后重新运行程序。在文本框中输入你的名字并点击按钮。程序应该会弹出一个新对话框，显示个性化的问候信息，类似于[图
    10-4](ch10.xhtml#ch10fig4)。
- en: '![Image](../images/10fig04.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig04.jpg)'
- en: '*Figure 10-4: Our Tkinter greeter program*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-4：我们的 Tkinter 问候程序*'
- en: There’s much more Tkinter can do, but we won’t need that much for this book.
    We’re mostly interested in using its canvas component, which we’ll explore in
    the next section. If you want to learn more about Tkinter, you have lots of great
    resources online. You can also refer to [7], as mentioned earlier.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 还能做很多事情，但在本书中我们不需要使用那么多功能。我们主要关注的是它的画布组件，接下来我们将深入探索这一部分。如果你想了解更多关于 Tkinter
    的信息，网上有很多优秀的资源。你也可以参考之前提到的[7]。
- en: '***The Canvas***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***画布***'
- en: A canvas is a surface to paint on. In Tkinter’s digital world, it’s the same.
    The canvas component is represented by the Canvas class in tkinter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 画布是一个可以绘制的区域。在 Tkinter 的数字世界中，情况也是如此。Tkinter 的画布组件由 tkinter 中的 Canvas 类表示。
- en: Let’s create a new Tkinter application where we can experiment with drawing
    to the canvas. In the *simulation* folder, create a new file named *hello_canvas.py*
    and enter the code in [Listing 10-4](ch10.xhtml#ch10lis4).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的 Tkinter 应用程序，在其中尝试绘制画布内容。在 *simulation* 文件夹中，创建一个名为 *hello_canvas.py*
    的新文件，并输入[清单 10-4](ch10.xhtml#ch10lis4)中的代码。
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 10-4: Hello Canvas*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-4：Hello Canvas*'
- en: The code creates a Tkinter application with its main window and a 600 by 600–pixel
    canvas. If you run the file, you should see an empty window with the title “Hello
    Canvas.” The canvas is there; it’s just that there’s nothing drawn yet.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个 Tkinter 应用程序，包含了一个主窗口和一个 600x600 像素的画布。如果你运行这个文件，应该会看到一个空的窗口，标题为“Hello
    Canvas”。画布已经存在，只是暂时还没有绘制任何内容。
- en: '**Drawing Lines**'
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**绘制线条**'
- en: 'Let’s start easy and draw a line on the canvas. Just between creating the canvas
    and starting the main loop, add the following line:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从简单的开始，在画布上画一条线。只需要在创建画布和启动主循环之间，添加以下这一行：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The arguments passed to create_line are, respectively, the x- and y-coordinates
    of the start point and the x- and y-coordinates of the end point.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 create_line 的参数分别是起点的 x 和 y 坐标，以及终点的 x 和 y 坐标。
- en: Run the file again. There should be a line segment going from the upper-left
    corner, (0, 0), to the center of the screen, (300, 300). As you can guess, the
    origin of coordinates is in the upper-left corner of the screen with the y-axis
    pointing downward. Later when we’re animating simulations, we’ll use affine transformations
    to fix this.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次运行文件。应该会看到一条从屏幕左上角（0, 0）到屏幕中央（300, 300）的线段。正如你所猜测的那样，坐标原点在屏幕的左上角，y 轴朝下。稍后当我们进行动画模拟时，我们将使用仿射变换来修正这一点。
- en: 'By default, lines are drawn with a width of 1 pixel and painted in black, but
    we can change this. Try the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，线条的宽度是 1 像素，颜色是黑色，但我们可以进行更改。试试以下代码：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The line is now thicker and has a reddish color. Your result should look like
    [Figure 10-5](ch10.xhtml#ch10fig5).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这条线变得更粗，而且呈现出红色。你的结果应该和[图 10-5](ch10.xhtml#ch10fig5)类似。
- en: '![Image](../images/10fig05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/10fig05.jpg)'
- en: '*Figure 10-5: A line on a Tkinter canvas*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-5：Tkinter 画布上的一条线*'
- en: '**Drawing Ovals**'
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s draw a circle in the middle of our application’s window using the same
    color as the previous line:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The arguments passed to create_oval are the x- and y-coordinates of the upper-left
    vertex of the rectangle that contains the oval, and the x- and y-coordinates of
    the lower-right vertex. These are followed by the named arguments used to determine
    the line’s width and color: width and outline.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the file, you’ll see a circle in the center of the window. Let’s
    turn it into a proper oval by making it 100 pixels wider, maintaining its height
    of 400 pixels:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By changing the x-coordinate of the lower-right corner from 400 to 500, the
    circle turns into an oval. The application now has a canvas with both a line and
    an oval, as in [Figure 10-6](ch10.xhtml#ch10fig6).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig06.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-6: An oval added to our Tkinter canvas*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to add a fill color to the oval, we could do so using the named
    argument fill=’...’. Here’s an example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There’s one limitation, though: Tkinter doesn’t support transparency, which
    means all of our fills and strokes will be completely opaque. The color format
    #rrggbbaa where aa is the value for the *alpha* (transparency) is not supported
    in Tkinter.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '**Drawing Rectangles**'
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Drawing rectangles is also pretty straightforward. Enter this code in the file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The mandatory arguments to create_rectangle are the x- and y-coordinates of
    the upper-left corner of the rectangle and the x- and y-coordinates of the lower-right
    corner.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Run the file; the result should look like [Figure 10-7](ch10.xhtml#ch10fig7).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig07.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-7: A rectangle added to our Tkinter canvas*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Nice! The resulting image is getting weirder, but isn’t it easy and fun to draw
    on the canvas?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '**Drawing Polygons**'
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The last geometric primitive we need to know how to draw is a generic polygon.
    After the code you added to draw the rectangle, write the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first parameter to create_polygon is a list of vertex coordinates. The rest
    are the named parameters that affect its style. Notice that we pass an empty string
    to the fill parameter; by default polygons get filled, but we want ours to be
    only an outline. Run the file to see the result. It should resemble [Figure 10-8](ch10.xhtml#ch10fig8).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig08.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-8: A polygon added to our Tkinter canvas*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: We created a triangle with vertices (40, 200), (300, 450), and (600, 0). Try
    adding a fill color and seeing what results.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '**Drawing Text**'
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'It isn’t a geometric primitive, but we may also need to draw some text to the
    canvas. Doing so is easy using the create_text method. Add the following to *hello_canvas.py*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first two parameters are the x and y position for the center of the text.
    The named parameter text is where we set the actual text we want to draw; we can
    change its font using font. Run the file one last time to see the complete drawing,
    as shown in [Figure 10-9](ch10.xhtml#ch10fig9).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: If we can draw lines, circles, rectangles, generic polygons, and text, we can
    draw pretty much anything. We could also use arcs and splines, but we’ll manage
    to do our simulations using only these simple primitives.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以绘制线条、圆形、矩形、通用多边形和文本，我们几乎可以绘制任何东西。我们也可以使用弧线和样条曲线，但我们将通过仅使用这些简单的原语来完成我们的仿真。
- en: '![Image](../images/10fig09.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/10fig09.jpg)'
- en: '*Figure 10-9: Text added to our Tkinter canvas*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-9: 添加到我们的Tkinter画布上的文本*'
- en: Your final code should look like [Listing 10-5](ch10.xhtml#ch10lis5).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你的最终代码应该如下所示，参考[清单 10-5](ch10.xhtml#ch10lis5)。
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 10-5: Final drawing code*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-5: 最终绘图代码*'
- en: Now that we know how to draw simple primitives to the canvas, let’s come up
    with a way of drawing our *geom2d* library’s geometric primitives directly to
    the canvas.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何将简单的原语绘制到画布上，让我们想出一种方法，直接将我们的*geom2d*库的几何原语绘制到画布上。
- en: '**Drawing Our Geometric Primitives**'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**绘制我们的几何原语**'
- en: 'Drawing a circle to the canvas was easy using its create_oval method. This
    method is, nevertheless, not convenient; to define the circle, you need to pass
    the coordinates of two vertices that define a rectangle where the circle or oval
    is inscribed. On the other hand, our class Circle is defined by its center point
    and radius, and it has some useful methods and can be transformed using instances
    of AffineTransform. It would be nice if we could directly draw our circles like
    so:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用画布的create_oval方法绘制圆形非常简单。然而，这个方法并不方便；为了定义圆形，你需要传递定义一个矩形的两个顶点的坐标，该矩形内接圆形或椭圆。另一方面，我们的Circle类通过它的中心点和半径来定义，并且具有一些有用的方法，可以使用AffineTransform的实例进行变换。如果我们能像这样直接绘制我们的圆形，那就太好了：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We definitely want to work with our geometry primitives. Similar to how we created
    SVG representations of them in [Chapter 8](ch08.xhtml#ch08), we’ll need a way
    to draw them to the canvas.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定希望与我们的几何原语一起工作。类似于我们在[第8章](ch08.xhtml#ch08)中创建它们的SVG表示方式，我们需要一种方法将它们绘制到画布上。
- en: 'Here’s the plan: we’ll create a wrapper for Tkinter’s Canvas widget. We’ll
    create a class that contains an instance of the canvas where we want to draw but
    whose methods allow us to pass our own geometric primitives. To leverage our powerful
    affine transformation implementation, we’ll associate a transformation to our
    drawing so that all primitives we pass will first be transformed.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 计划如下：我们将为Tkinter的Canvas小部件创建一个包装类。我们将创建一个包含我们希望绘制的画布实例的类，但它的方法允许我们传递自己的几何原语。为了利用我们强大的仿射变换实现，我们将把变换与绘图关联，这样我们传递的所有原语将首先经过变换。
- en: '***The Canvas Wrapper Class***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***画布包装类***'
- en: A wrapper class is simply a class that contains an instance of another class
    (what it’s wrapping) and is used to provide a similar functionality as the wrapped
    class, but with a different interface and some added functionality. It’s a simple
    yet powerful concept.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 包装类就是一个包含另一个类（它所包装的类）实例的类，并用于提供与被包装类相似的功能，但具有不同的接口和一些附加的功能。这是一个简单却强大的概念。
- en: 'In this case, we’re wrapping a Tkinter canvas. Our canvas wrapper goal is to
    allow us to draw our geometric primitives with a simple and clean interface: we
    want methods that directly accept instances of our primitives. This wrapper will
    save us from the repetitive task of adapting the representation of the geometric
    classes to the inputs expected by the Tkinter canvas’s drawing methods. Not only
    that, but we’ll also apply an affine transformation to everything that we draw.
    [Figure 10-10](ch10.xhtml#ch10fig10) depicts this process.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在包装一个Tkinter画布。我们的画布包装类的目标是让我们以简单、干净的接口绘制我们的几何原语：我们希望方法能够直接接受我们的原语实例。这个包装类将帮助我们避免重复的任务，即将几何类的表示适配为Tkinter画布绘图方法所期望的输入。不仅如此，我们还会对我们绘制的所有内容应用仿射变换。[图
    10-10](ch10.xhtml#ch10fig10)描述了这个过程。
- en: In the *simulation* package, create a new file named *draw.py*. Enter the code
    in [Listing 10-6](ch10.xhtml#ch10lis6).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在*simulation*包中，创建一个名为*draw.py*的新文件。输入[清单 10-6](ch10.xhtml#ch10lis6)中的代码。
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 10-6: Canvas wrapper class*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-6: 画布包装类*'
- en: The class CanvasDrawing is defined as a wrapper to the Tkinter canvas. An instance
    of the canvas is passed to the initializer and stored in a private variable, __canvas.
    Making __canvas private means we don’t want anyone using CanvasDrawing to access
    it directly. It now belongs to the wrapper class instance, and it should only
    be used with its methods.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'An instance of AffineTransform is also passed to the initializer. We’ll apply
    this affine transformation to all geometric primitives before we draw them to
    Tkinter’s canvas. The transformation is stored in a public variable: transform.
    This means we’re allowing users of CanvasDrawing instances to directly manipulate
    and edit this property, which is part of the state of the instance. We do this
    so that it’s simple to alter the affine transformation applied to the drawing,
    by reassigning the transform property to a different transformation.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'The state of an instance defines its behavior: if the state changes, the instance’s
    behavior changes as well. In this case, it’s clear that if the property transform
    is reassigned a different affine transformation, all subsequent drawing commands
    will produce results in accordance with it.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-10](ch10.xhtml#ch10fig10) is a diagram representing the behavior
    of our canvas wrapper class. It’ll receive draw requests for different geometric
    primitives, apply the affine transformation to them, and then call the Tkinter’s
    canvas methods to draw into it.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig10.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-10: The canvas wrapper class*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other state variables defined in the initializer: outline_color,
    which defines the color used for the outline of geometries, outline_width for
    the width of the outlines, and fill_color for the color used to fill the geometries.
    These are given default values in the initializer (those used in our example in
    the previous section) but are also public and accessible for users of the instance
    to change them. Like before, it should be clear that these properties are part
    of the state of the instance: if we edit outline_color, for example, all subsequent
    drawings will use that color for the outlines.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve defined only one method in the class: clear_drawing. This method will
    clean the canvas for us before drawing each of the frames. Let’s now focus on
    the drawing commands.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '***Drawing Segments***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s start with the simplest primitive to draw: the segment. In the Canvas
    Drawing class, enter the method in [Listing 10-7](ch10.xhtml#ch10lis7). For this
    code you first need to update the imports from *geom2d* to include the Segment
    class.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 10-7: Drawing a segment*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '*Note how we’re passing the* self.outline_color *value to the* fill *parameter.
    That looks like an error, but unfortunately, Tkinter picked a bad name. The* fill
    *attribute is used for the stroke’s color in a* create_line *command. A better
    name would have been* outline *or, even better,* stroke-color.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'The draw_segment method does two things: first it transforms the given segment
    using the current affine transformation and stores the result in segment_t. Then
    it calls the create_line method from the canvas instance. For the outline color
    and width, we use the state variables of the instance.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to polygons, circles, and rectangles.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '***Drawing Polygons***'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you recall from “Transform Segments and Polygons” on [page 179](ch07.xhtml#ch00lev2sec82),
    once an affine transformation is applied to a circle or rectangle, the result
    is a generic polygon. This means that all three polygons will be drawn using the
    create_polygon method from the canvas.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a private method that draws a polygon to the canvas, forgetting
    about the affine transformation; that part will be handled by each of the public
    drawing methods.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: In your CanvasDrawing class, enter the private method in [Listing 10-8](ch10.xhtml#ch10lis8).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 10-8: Drawing a polygon to the canvas*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: For this code you need to add the following import,
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'and update the imports from geom2d:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The __draw_polygon method first prepares the vertex coordinates of the polygon
    to meet the expectations of the canvas widget’s create_polygon method. This is
    done by reducing a list of lists of vertex coordinates with Python’s list __add__
    method, which, if you recall, is the method that overloads the + operator.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break this down. First, the polygon’s vertices are mapped using a list
    comprehension:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This creates a list with the x- and y-coordinates from each vertex. If the
    vertices of the polygon were (0, 10), (10, 0), and (10, 10), the list comprehension
    shown earlier would result in the following list:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This list then needs to be *flattened*: all values in the inner lists (the
    numeric coordinates) have to be concatenated into a single list. The result of
    flattening the previous list would be as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is the list of vertex coordinates the method create_polygon expects. This
    final flattening step is achieved by the reduce function; we pass it the list
    .__add__ operator, and it produces a new list that results from concatenating
    both list operands. To see that in action, you can test the following in Python’s
    shell:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Once the list of vertex coordinates is ready, drawing it to the canvas is straightforward:
    we simply pass the list to the canvas’s create_polygon method. Now that the hardest
    part is done, drawing our polygons should be easier. Enter the code in [Listing
    10-9](ch10.xhtml#ch10lis9) to your class.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 10-9: Drawing circles, rectangles, and generic polygons*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t forget to add the missing imports from *geom2d*:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In all three methods, the process is the same: call the private method __draw_polygon
    and pass it the result of applying the current affine transformation to the geometry.
    Don’t forget that in the case of a circle, we need to pass the number of divisions
    we’ll use to approximate it to the transform method.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '***Drawing Arrows***'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s now draw arrows following the same approach we used in [Chapter 8](ch08.xhtml#ch08)
    for SVG images.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'The arrow’s head will be drawn on the end point *E* of a segment and will be
    made of two segments at an angle meeting at such an end point. To allow some flexibility,
    we’ll use two dimensions to define the arrow’s geometry: a length and a height
    (see [Figure 10-11](ch10.xhtml#ch10fig11)).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 10-11](ch10.xhtml#ch10fig11) (repeated from [Chapter
    8](ch08.xhtml#ch08)), to draw the arrow’s head, we need to figure out points *C*[1]
    and *C*[2]. With those two points, we can easily draw the segments between *C*[1]
    and *E* and between *C*[2] and *E*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/10fig11.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-11: Key points in an arrow*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out where those points lie in the plane, we’ll be computing three vectors:
    ![Image](../images/vlvictorit.jpg), which has the same length as the arrow’s head
    and is going in the opposite direction of the segment’s direction vector, and
    ![Image](../images/vh1victorit.jpg) and ![Image](../images/vh2victorit.jpg), which
    are perpendicular to the segment and both have a length equal to half the arrow’s
    head height. [Figure 10-11](ch10.xhtml#ch10fig11) shows these vectors. The point
    *C*[1] can be computed by creating a displaced version of *E* (the segment’s end
    point),'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f00282-p1.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: 'and similarly, *C*[2]:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f00282-p2.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: Let’s write the method. In the CanvasDrawing class, enter the code in [Listing
    10-10](ch10.xhtml#ch10lis10).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 10-10: Drawing an arrow*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: We start by computing the three vectors we need to figure out points *C*[1]
    and *C*[2] using the previous equations. As you can see, this is pretty straightforward
    thanks to the methods we implemented in our Vector class. For example, to obtain
    ![Image](../images/vlvictorit.jpg), we use the opposite vector of the segment’s
    direction vector and scale it to have the desired length. We use similar operations
    to calculate the remaining elements of our equations.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we three segments: the base line, which is the segment passed as the argument;
    the segment going from *E* to *C*[1] ➊ ; and the one going from *E* to *C*[2]
    ➋.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: For reference, your *drawing.py* file should look like [Listing 10-11](ch10.xhtml#ch10lis11).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 10-11: CanvasDrawing class result*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: We now have a convenient way of drawing our geometric primitives, but they’re
    not moving at all, and we need motion to produce simulations. What’s the missing
    ingredient to bring those geometries to life? That’s the topic of the next chapter.
    Matters are getting more and more exciting!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of creating graphical user interfaces
    using Python’s Tkinter package. We saw how to lay widgets on the main window using
    the grid system. We also learned how to make a button respond to being clicked
    and how to read the contents of a text field. Most importantly, we learned about
    the Canvas class and its methods that we can use to draw simple primitives to
    it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: We finished the chapter by creating a class of our own that wraps Tkinter’s
    canvas and allows us to draw our geometric primitives directly. The class also
    includes an affine transformation that applies to the primitives before being
    drawn. The class has properties that define the stroke width and color as well
    as the fill color. These are the width and colors applied to the primitives we
    draw with it. Now it’s time to put those static geometries into motion.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
