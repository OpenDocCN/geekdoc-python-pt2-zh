- en: '3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'REPEATING CODE: DEFINITE LOOPS'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Computers shine when we have them repeat a process over and over. They tirelessly
    do exactly what we ask, whether it involves doing something 10, 100, or a billion
    times. In this chapter, we’ll learn about loops, statements that instruct the
    computer to repeat the execution of part of our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use loops to solve three problems: tracking the location of a ball under
    a cup, counting the number of occupied parking spaces, and determining how much
    data is available on a cell phone plan.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #5: Three Cups'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this problem, we’ll track the location of a ball under a cup as the cups
    move. But the cups can move many times, so we won’t be able to write code for
    each move separately. Instead, we’ll learn about and use the `for` loop, which
    allows us to more easily run code for each move.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `coci06c5p1`.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Borko has a row of three opaque cups: one at the left (location 1), one at
    the middle (location 2), and one at the right (location 3). There is a ball under
    the cup at the left. It’s our job to keep track of the location of the ball as
    Borko swaps the locations of the cups.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Borko can make three types of swap:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A** Swap the left and middle cups'
  prefs: []
  type: TYPE_NORMAL
- en: '**B** Swap the middle and right cups'
  prefs: []
  type: TYPE_NORMAL
- en: '**C** Swap the left and right cups'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if Borko’s first swap is type A, then he swaps the left and middle
    cups; because the ball starts at the left, this swap moves it to the middle. If
    instead his first swap is type B, then he swaps the middle and right cups; the
    left cup stays where it is, so the ball doesn’t change locations.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The input is one line of at most 50 characters. Each character specifies a
    type of swap that Borko makes: `A`, `B`, or `C`.'
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Output the final location of the ball:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1` if the ball is at the left'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2` if the ball is at the middle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3` if the ball is at the right'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Loops?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider this test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There are four swaps here. To determine the final location of the ball, we need
    to carry out each one.
  prefs: []
  type: TYPE_NORMAL
- en: The first swap is type `A`, which swaps the cups at the left and middle. Since
    the ball starts at the left, this results in the ball moving to the middle. The
    second swap is type `C`, which swaps the cups at the left and right. Since the
    ball is currently at the middle, this has no effect on the location of the ball.
    The third swap is type `B`, which swaps the cups at the middle and right. This
    moves the ball from the middle to the right. The fourth swap is type `A`, which
    swaps the cups at the left and middle. This has no effect on the ball. The correct
    output is therefore `3`, because the ball ends up at the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that for each swap, we have to make a decision to determine whether
    the ball moves and, if it does, to move the ball appropriately. Making decisions
    is something we know how to do from [Chapter 2](ch02.xhtml#ch02). For example,
    if the swap type is `A` and the ball is at the left, then the ball moves to the
    middle. That looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We could add an `elif` for each other case where the ball moves: swap type
    `A` and ball is at the middle, swap type `B` and ball is at the middle, swap type
    `B` and ball is at the right, and so on. This big `if` statement would be enough
    to handle one swap. But that’s not enough to solve the Three Cups problem, because
    we could have a test case of up to 50 swaps. We’d need to repeat the `if` statement
    logic for each swap. And we certainly wouldn’t want to copy and paste the same
    code 50 times. Imagine if you had made a typo and had to fix it 50 times. Or if
    you suddenly became interested in test cases with up to a million swaps. No, what
    we have learned so far is not going to cut it. We need a way to walk through the
    swaps, performing the same logic for each one. We need a loop.'
  prefs: []
  type: TYPE_NORMAL
- en: for Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python’s `for` statement produces *for loops*. `for` loops allow us to process
    each element of a sequence. The only sequence type we’ve seen so far is the string.
    We’ll learn others as we go; `for` loops work on all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our first example of a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Following the keyword `for`, we write the name of a *loop variable*. A loop
    variable is one that refers to different values as a loop progresses. In a `for`
    loop on a string, the loop variable refers to each of the string’s characters.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve chosen the variable name `char` (for “character”) to remind us that the
    variable refers to a character from the string. Sometimes, it’s clearer if we
    use a contextual variable name. For example, in Three Cups, we could instead use
    the name `swap_type` to remind us that it refers to a type of swap.
  prefs: []
  type: TYPE_NORMAL
- en: After the variable name, we have the keyword `in` and then the string that we
    want to loop over. In our example, we’re looping over the string referred to by
    `secret_word`, which is `'olive'`.
  prefs: []
  type: TYPE_NORMAL
- en: Like the `if`, `elif`, and `else` lines of an `if` statement, the `for` line
    ends with a colon (`:`). And, also like an `if` statement, a `for` statement has
    an indented block of one or more statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'An execution of the indented statements is referred to as an *iteration* of
    the loop. Here’s a walk-through of what our loop does on each iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the first iteration, Python sets `char` to refer to `''o''`, the first character
    of `''olive''`. It then runs the loop block, which consists only of the call to
    `print`. As `char` refers to `''o''`, the output produced is `Letter: o`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the second iteration, Python sets `char` to refer to `''l''`, the second
    character of `''olive''`. It then calls `print`, outputting `Letter: l`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This process repeats three more times, once for each remaining character in
    `'olive'`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loop then terminates. We have no code after the loop, so our program has
    finished running. If there was additional code after the loop, then execution
    would continue with that code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can put multiple statements in the block of a `for` loop. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have two statements executing on each iteration of the loop: one that
    outputs the current letter of the string, and one that outputs a `*` character.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `for` loop loops through the elements of a sequence, so the sequence’s length
    tells us how many iterations there will be. The `len` function takes a string
    and returns its length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `for` loop on `''olive''` will therefore consist of five iterations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: I called `print` with multiple arguments ❶, rather than using concatenation,
    to avoid having to convert the length to a string.
  prefs: []
  type: TYPE_NORMAL
- en: A `for` loop is what’s called a *definite loop*, referring to the idea that
    the number of iterations is predetermined. There are also *indefinite loops*,
    whose iterations depend on the vagaries of what happens when your program runs.
    We’ll study those in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of the following code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A. `6`
  prefs: []
  type: TYPE_NORMAL
- en: B. `10`
  prefs: []
  type: TYPE_NORMAL
- en: C. `12`
  prefs: []
  type: TYPE_NORMAL
- en: D. `36`
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: B. For each character in `''garage''`, we add its count to `total`.
    There are two `g`’s, two `a`’s, one `r`, two `a`’s (again!), two `g`’s (again!),
    and 1 `e`.'
  prefs: []
  type: TYPE_NORMAL
- en: Nesting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `for` loop block is one or more statements. Those statements can include
    one-line statements such as function calls and assignment statements. But they
    can also include multiline statements such as `if` statements and loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with an example of an `if` statement inside a `for` loop. Suppose
    we wanted to output only the uppercase characters from a string. Strings have
    an `isupper` method that we can use to determine whether a character is uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `isupper` in an `if` statement to control what happens on each iteration
    of a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Be careful with the indentation here. We need one level of indentation for the
    `for` loop, and an extra level of indentation for the nested `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the first iteration, `char` refers to `''T''`. Since `''T''` is uppercase,
    the `isupper` test returns `True`, and the `if` statement block runs. That results
    in the output of `T`. On the second iteration, `char` refers to `''h''`. This
    time, the `isupper` test returns `False`, so the `if` statement block doesn’t
    run. Overall, the `for` loop loops through each character of the string, but the
    nested `if` statement fires only twice: on the `''T''` at the beginning of the
    string and on the `''E''` at the beginning of `''Escape''`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What about a `for` loop nested in a `for` loop? We can do that! Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code produces all two-character strings whose first character is from `letters`
    and whose second character is from `digits`.
  prefs: []
  type: TYPE_NORMAL
- en: On the first iteration of the outer (`letters`) loop, `letter` refers to `'A'`.
    This iteration involves completely running the inner (`digits`) loop. The whole
    time the inner loop runs, `letter` refers to `'A'`. On the first iteration of
    the inner loop, `digit` refers to `1`, which explains the `A1` output. On the
    second iteration of the inner loop, `digit` refers to `2`, and `A2` is output.
    On the third and final iteration of the inner loop, `digit` refers to `3`, and
    `A3` is output.
  prefs: []
  type: TYPE_NORMAL
- en: We’re not done! We’ve gone through only one iteration of the outer loop. On
    the second iteration of the outer loop, `letter` refers to `'B'`. Now the three
    iterations of the inner loop run again, this time with `letter` referring to `'B'`.
    This accounts for the `B1`, `B2`, and `B3` outputs. Finally, on the third iteration
    of the outer loop, `letter` refers to `'C'`, and the inner loop produces `C1`,
    `C2`, and `C3`.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of the following code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A. `10`
  prefs: []
  type: TYPE_NORMAL
- en: B. `20`
  prefs: []
  type: TYPE_NORMAL
- en: C. `100`
  prefs: []
  type: TYPE_NORMAL
- en: D. This code produces a syntax error because two nested loops cannot both use
    `title`
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: C. `total` starts off as `0` and is increased by 1 on each iteration
    of the inner loop. The length of `''The Escape''` is 10\. The outer loop therefore
    has 10 iterations. For each of those iterations, the inner loop has 10 iterations.
    The inner loop therefore has 10*10 = 100 iterations in all.'
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Back to Three Cups. The structure we need is a `for` loop to go through each
    swap, and a nested `if` statement to keep track of where the ball is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three types of swaps (A, B, and C) and three possible locations for
    the ball, so it’s tempting to conclude that we have to write an `if` statement
    with 3 * 3 = 9 Boolean expressions (one after the `if` and one after each of eight
    `elif`s). In fact, we need only six Boolean expressions. Three of the nine don’t
    move the ball at all: swap type A when the ball is at the right, swap type B when
    the ball is at the left, and swap type C when the ball is at the middle.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-1](ch03.xhtml#ch03ex01) has a solution to Three Cups.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-1: Solving Three Cups*'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve used `input` to assign the string of swaps to the `swaps` variable. The
    `for` loop ❶ loops through these swaps. Each swap is processed by the nested `if`
    statement ❷. The `if` and `elif` branches each encode what happens with a given
    type of swap and a given ball location and then move the ball accordingly. For
    example, if the swap type is `A` and the ball is at location 1 ❷, then the ball
    ends up at location 2 ❸.
  prefs: []
  type: TYPE_NORMAL
- en: This is a code example where it matters whether we use multiple `elif`s (one
    big `if` statement) or multiple `if`s (multiple `if` statements). If we change
    the `elif`s to `if`s, then our code is no longer correct. [Listing 3-2](ch03.xhtml#ch03ex02)
    shows the incorrect code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-2: Solving Three Cups incorrectly*'
  prefs: []
  type: TYPE_NORMAL
- en: If we say that the code is incorrect, we’re claiming that it fails at least
    one test case. Can you find a test case where this code produces the wrong answer?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one such test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It may make sense to us that the ball can move at most once per swap. But Python
    robotically runs the code you have written, whether it matches what we expect
    or not. In this case, we have only one swap, so the ball should move at most once.
    On the first and only iteration of the `for` loop, Python checks the expression
    ❶. It’s `True`, so Python sets `ball_location` to `2`. Then, Python checks the
    expression ❷. Because we just changed `ball_location` to `2`, this expression
    is `True`! Python therefore sets `ball_location` to `1`. The output of the program
    is `1` when it should be `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of a *logic error*: an error that causes a program to follow
    the wrong logic and produce the wrong answer. A common term for logic error is
    a *bug*. When programmers work through their code to fix bugs, it’s called *debugging*.'
  prefs: []
  type: TYPE_NORMAL
- en: It often takes only a simple test case to demonstrate when a program is incorrect.
    When you’re trying to narrow down what’s going wrong with your code, don’t start
    with long test cases. Such test case results are hard to verify by hand and often
    set in motion complex execution paths from which we may learn very little. A small
    test case, by contrast, doesn’t cause our program to do much; if what it does
    is wrong, then we don’t have far to look for the culprit. Devising small, targeted
    test cases is not always easy. It’s a skill that you can hone through practice.
  prefs: []
  type: TYPE_NORMAL
- en: Submit our correct code to the judge, and then let’s move on.
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing, you might like to try solving exercises 1 and 2 from “Chapter
    Exercises” on [page 67](ch03.xhtml#ch03lev1sec16).
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #6: Occupied Spaces'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We know how to loop through the characters of a string. But sometimes we need
    to know where we are in the string, not just the character that’s stored there.
    This problem is one such example.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `ccc18j2`.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You supervise a parking lot with *n* parking spaces. Yesterday, you recorded
    whether each parking space was occupied by a car or was empty. Today, you again
    recorded whether each parking space was occupied by a car or was empty. Indicate
    the number of parking spaces that were occupied on both days.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The input consists of three lines.
  prefs: []
  type: TYPE_NORMAL
- en: The first line contains integer *n*, the number of parking spaces. *n* is between
    1 and 100.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second line contains a string of *n* characters for yesterday’s information,
    one character for each parking space. A `C` indicates an occupied parking space
    (C for car), and a `.` indicates an empty parking space. For example, `CC.` means
    that the first two parking spaces were occupied and the third was empty.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third line contains a string of *n* characters for today’s information,
    in the same format as the second line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Output the number of parking spaces that were occupied on both days.
  prefs: []
  type: TYPE_NORMAL
- en: A New Kind of Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We could have up to 100 parking spaces, so you may not be surprised that a
    loop will show up here somewhere. The kind of `for` loop we learned when solving
    Three Cups can certainly loop through a string of parking-space information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That tells us whether each space was occupied yesterday. But we also need to
    know whether each space was also occupied today.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first parking space was occupied yesterday. Was that parking space occupied
    on both days? To answer that, we need to look at the corresponding character in
    today’s string. It’s a `.` (empty), so this parking space was not occupied on
    both days.
  prefs: []
  type: TYPE_NORMAL
- en: What about the second parking space? That one was also occupied yesterday. And,
    looking at the second character of today’s string, it was also occupied today.
    So this *is* a parking space that was occupied on both days. (This is the only
    such parking space; the correct output for this test case is `1`.)
  prefs: []
  type: TYPE_NORMAL
- en: Looping through the characters of one string doesn’t help us find the corresponding
    characters in the other string. But if we could keep track of where we were in
    the string—we’re at the first parking space, we’re at the second parking space,
    and so on—we could look up the corresponding character from each string. The `for`
    loops we’ve learned so far are not the way to do this. The way to do this is using
    indexing and a new type of `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each character in a string has an *index*, which indicates its location. The
    first character is at index 0, the second character is at index 1, and so on.
    In natural language, we often start counting at 1\. In English, no one says “the
    character at position 0 of *hello* is *h*.” But most programming languages, Python
    included, start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use indexing, we follow a string by an index in square brackets. Here are
    some examples of indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If we like, we can use variables in an index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The highest index that we can use on a nonempty string is its length minus
    1\. (There is no valid index for an empty string.) For example, `''splore''` is
    length 6, so index 5 is its highest index. Any bigger and we get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'How can we access the second character from the right of a string? This will
    do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'But there’s an easier way. Python supports negative indices as another option
    for accessing characters. Index `-1` is the rightmost character, index `-2` is
    the second character from the right, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The plan is to use indexing to access corresponding positions of yesterday’s
    and today’s parking information. We can use index 0 of each string to access information
    about the first parking space, index 1 to access information about the second
    parking space, and so on. But before we can carry out that plan, we need to learn
    a new kind of `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of the following code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: A. `aaa`
  prefs: []
  type: TYPE_NORMAL
- en: B. `aae`
  prefs: []
  type: TYPE_NORMAL
- en: C. `aee`
  prefs: []
  type: TYPE_NORMAL
- en: D. This code produces an error
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: A. Each of the three indices refers to the first character in `''abcde''`.
    First, `s[0]` refers to `''a''` because `''a''` is at index 0 of the string. Second,
    `s[-5]` refers to `''a''` because `''a''` is the fifth character from the right.
    Third, `s[len(s) - 5]` refers to `''a''` because the index evaluates to 0: 5 (the
    length of the string) minus 5.'
  prefs: []
  type: TYPE_NORMAL
- en: Range for loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python’s `range` function generates ranges of integers, and we can use those
    ranges to control `for` loops. Rather than looping through the characters of a
    string, a range `for` loop loops through integers. If we provide one argument
    to `range`, we get a range from 0 to 1 less than that argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `5` is not output.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we provide two arguments to `range`, we get a sequence from the first argument
    up to but not including the second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can count up by a different *step size* by including a third argument. The
    default step size is `1`, which counts up by one. Let’s try a couple of other
    step sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can count backward, too, but *not* like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'That doesn’t work, because by default `range` counts up. A step size of `-1`
    lets us go backward, one at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To count down from `6` to `0`, including `0`, we need a value of `-1` for the
    second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s sometimes helpful to quickly look at the numbers in a range without coding
    a loop. Unfortunately, the `range` function doesn’t directly show us those numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can pass that result to the `list` function to get what we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When called with a range, the `list` function produces a list of the range’s
    integers. We’ll learn all about lists later; for now, keep `list` in mind as an
    aid to diagnosing errors with ranges.
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  prefs: []
  type: TYPE_NORMAL
- en: How many iterations are performed by the following loop?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: A. 9
  prefs: []
  type: TYPE_NORMAL
- en: B. 10
  prefs: []
  type: TYPE_NORMAL
- en: C. 11
  prefs: []
  type: TYPE_NORMAL
- en: D. 20
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: B. The range goes through the numbers 10, 11, 12, 13, 14, 15, 16, 17,
    18, and 19\. There are 10 numbers and hence 10 iterations.'
  prefs: []
  type: TYPE_NORMAL
- en: Range for Loops Through Indices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose we have strings giving yesterday’s and today’s parking-space information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Given an index, we can look at yesterday’s and today’s information for that
    index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use a range `for` loop through the indices to process each pair of corresponding
    characters. We know that `yesterday` and `today` are the same length. But that
    length could be anything from 1 to 100, so we can’t write something like `range(3)`.
    We want to iterate with indices 0, 1, 2, and so on, all the way up to the length
    of the string minus 1\. We can do that by using the length of one of the strings
    as the argument to `range`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: I’ve called the loop variable `index`. Other popular names include `i` (the
    first letter of `index`) and `ind`. I’ll use `i` from here on out.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t call this loop variable `status` or `information`. Those names imply that
    it takes on `'C'` and `'.'` values, when really it takes on integers.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With our range `for` loops, we’re ready to solve Occupied Spaces. Our strategy
    is to loop through each index from the beginning of the strings to the end. We
    can check what’s at each index in both yesterday’s information and today’s information.
    Using a nested `if` statement, we’ll determine whether the parking space was occupied
    on both days.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-3](ch03.xhtml#ch03ex03) has our solution.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-3: Solving Occupied Spaces*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The program starts by reading the three lines of input: `n` refers to the number
    of parking spaces; and `yesterday` and `today` refer to yesterday’s and today’s
    parking-space information, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we don’t refer to the number of parking spaces (`n`) again. We could
    make use of it to tell us the length of the strings, but I’ve chosen to ignore
    it because it’s often not provided in real-life scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `occupied` variable to count the number of parking spaces that were
    occupied both yesterday and today. We start that variable off at `0` ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Now we reach the range `for` loop, which loops through the valid indices of
    `yesterday` and `today` ❷. For each such index, we check whether the parking space
    was occupied yesterday and occupied today ❸. If it was, then we include this parking
    space in our total by increasing `occupied` by `1` ❹.
  prefs: []
  type: TYPE_NORMAL
- en: When the range `for` loop terminates, we’ll have gone through all parking spaces.
    The total number of parking spaces that were occupied yesterday and today can
    be accessed through the `occupied` variable. All that’s left is to output that
    total.
  prefs: []
  type: TYPE_NORMAL
- en: That’ll do it for this problem. Time to submit your code to the judge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #7: Data Plan'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve learned that `for` loops are useful for processing data after we’ve read
    it from the input. They’re also often useful for reading the data itself. In this
    problem, we’ll tackle data that’s spread over many lines and use a `for` loop
    to help us read it all.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `coci16c1p1`.
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pero has a data plan with his cell phone provider that offers him *x* megabytes
    of data per month. In addition, any data he doesn’t use in a given month carries
    over to the next month. For example, if *x* is 10 and Pero uses only 4MB in a
    given month, the remaining 6MB carry over to the next month (in which he’d now
    have 10 + 6 = 16MB available).
  prefs: []
  type: TYPE_NORMAL
- en: We’re given the number of megabytes of data that Pero uses in each of the first
    *n* months. Our task is to determine the number of megabytes available for the
    following month.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The input consists of the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: A line containing integer *x*, the number of megabytes given to Pero per month.
    *x* is between 1 and 100.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing integer *n*, the number of months that Pero has had the data
    plan. *n* is between 1 and 100.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* lines, one for each month, giving the integer number of megabytes that
    Pero uses in that month. Each number is at least 0 and will never outstrip the
    number of available megabytes. (For example, if *x* is 10 and Pero currently has
    30MB available, the next number will be at most 30.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Output the number of megabytes available for the next month.
  prefs: []
  type: TYPE_NORMAL
- en: Looping to Read Input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In all of our problems so far, we’ve known exactly how many lines to read from
    the input. For example, in Three Cups, we read one line; in Occupied Spaces, we
    read three lines. Here in Data Plan, we don’t know in advance how many lines to
    read, because it depends on the number that we read from the second line.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can read the first line of input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: (I’ve used variable name `monthly_mb` rather than `x` to imbue it with some
    meaning.)
  prefs: []
  type: TYPE_NORMAL
- en: 'And we can read the second line of input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can’t read any more without a loop. A range `for` loop is perfect here,
    because we can use it to loop exactly `n` times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Solving the Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: My strategy for solving the problem is to keep track of the number of megabytes
    that are carried over from previous months. I call this the *excess*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In each month, Pero is given 10MB of data, and we have to process the data that
    he used in the provided three months. In the first month, Pero is given 10MB and
    uses 4MB, so the excess that carries forward is 6MB. In the second month, Pero
    is given 10MB more, so now he has 16MB total. He uses 12MB this month, so the
    excess that carries forward is 16 – 12 = 4MB. In the third month, Pero is given
    10MB more, so now he has 14MB total. He uses 1MB this month, so the excess that
    carries forward is 14 – 1 = 13MB.
  prefs: []
  type: TYPE_NORMAL
- en: We need to know the number of megabytes that Pero has available for the next
    (that is, fourth) month. He has 13MB that carry over from the first three months,
    and he’s given his usual 10MB for this month, so he has a total of 13 + 10 = 23MB
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: When I went to write the code based on this explanation, I neglected to add
    this final 10, so my output was 13 instead of 23\. I was focusing exclusively
    on the excess and forgot that what we need is not the excess going into the next
    month, but the total number of megabytes available. That total is the excess plus
    whatever Pero is given per month.
  prefs: []
  type: TYPE_NORMAL
- en: See [Listing 3-4](ch03.xhtml#ch03ex04) for the (corrected!) code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-4: Solving Data Plan*'
  prefs: []
  type: TYPE_NORMAL
- en: The `excess` variable begins at `0`. On each iteration of the range `for` loop,
    we assign a value to `excess` that considers the number of megabytes given per
    month and the number of megabytes used in that month.
  prefs: []
  type: TYPE_NORMAL
- en: The range `for` loop loops `n` times, once for each month that Pero has had
    the data plan ❶. The values that `i` takes on—`0`, `1`, and so on—aren’t of interest
    to us, because we have no reason to care about which month we’re processing. For
    that reason, we don’t use the value of `i` anywhere in the program. You can replace
    `i` with `_` (an underscore) to be explicit about the variable’s “don’t care”
    status, but I’ll leave it as `i` for consistency with other examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the range `for` loop, we read the number of megabytes used in this month.
    Then, we update the number of excess megabytes ❷: it’s what it was before, plus
    the number of megabytes that Pero gets per month, minus the number of megabytes
    that Pero uses this month.'
  prefs: []
  type: TYPE_NORMAL
- en: Having computed the excess number of megabytes after `n` months, we report the
    number of megabytes available for the next month ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are always multiple ways to solve a problem. Programming is creative,
    and I enjoy observing the range of solution strategies that people come up with.
    Even if you’ve succeeded in solving a problem, you might like to Google the problem
    to learn from how others have solved it. In addition, some online judges, like
    DMOJ, allow you to view other people’s submissions once you’ve solved the problem.
    For submissions that pass all of the test cases: did those programmers do things
    differently from you? For submissions that fail some test cases: what’s wrong
    with the code? Reading other people’s code is a great way to improve your own
    programming skill!'
  prefs: []
  type: TYPE_NORMAL
- en: Can you think of another way to solve Data Plan?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a hint: you can start by calculating the total number of megabytes that
    Pero is given and then subtracting the number of megabytes that he uses. I encourage
    you to take some time to work out how to do this before continuing!'
  prefs: []
  type: TYPE_NORMAL
- en: The total number of megabytes given to Pero, including those given in the next
    month, is *x* * (*n* + 1), where *x* is the number of megabytes given per month.
    To determine the number of megabytes available for the next month, we can start
    with that total and subtract what Pero uses each month. That strategy is coded
    in [Listing 3-5](ch03.xhtml#ch03ex05).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-5: Solving Data Plan, alternate approach*'
  prefs: []
  type: TYPE_NORMAL
- en: Choose whichever solution is your favorite, and submit to the judge.
  prefs: []
  type: TYPE_NORMAL
- en: What’s intuitive to one person may not be intuitive to another. You might read
    an explanation or code and not be able to make sense of it. This doesn’t mean
    that you’re not smart enough. It just means you need a different presentation,
    one that aligns more closely to your current thinking. You might also flag difficult
    explanations and examples for later review. They may prove to be surprisingly
    useful once you’ve gained further practice.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we learned about `for` loops. Standard `for` loops loop through
    the characters of a sequence; range `for` loops loop through integers in a range.
    Each problem that we solved required us to process many pieces of input, and we
    wouldn’t have been able to manage that without a loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for` loop is the loop of choice whenever you need to repeat code a specified
    number of times. Python has one other type of loop, and we’ll learn how to use
    it in the next chapter. Why do we need anything besides `for` loops? What can’t
    `for` loops do? Good questions! I’ll tell you this for now: practicing with `for`
    loops is a wonderful way to prepare for what’s to come.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are some exercises for you to try.
  prefs: []
  type: TYPE_NORMAL
- en: DMOJ problem `wc17c3j3`, Uncrackable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `coci18c3p1`, Magnus
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `ccc11s1`, English or French
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `ccc11s2`, Multiple Choice
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `coci12c5p1`, Ljestvica
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `coci13c3p1`, Rijeci
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem `coci18c4p1`, Elder
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Three Cups is originally from the 2006/2007 Croatian Open Competition in Informatics,
    Contest 5\. Occupied Spaces is originally from the 2018 Canadian Computing Competition,
    Junior Level. Data Plan is originally from the 2016/2017 Croatian Open Competition
    in Informatics, Contest 1.
  prefs: []
  type: TYPE_NORMAL
