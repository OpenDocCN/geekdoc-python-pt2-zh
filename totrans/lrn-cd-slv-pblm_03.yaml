- en: '3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'REPEATING CODE: DEFINITE LOOPS'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Computers shine when we have them repeat a process over and over. They tirelessly
    do exactly what we ask, whether it involves doing something 10, 100, or a billion
    times. In this chapter, we’ll learn about loops, statements that instruct the
    computer to repeat the execution of part of our program.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use loops to solve three problems: tracking the location of a ball under
    a cup, counting the number of occupied parking spaces, and determining how much
    data is available on a cell phone plan.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #5: Three Cups'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this problem, we’ll track the location of a ball under a cup as the cups
    move. But the cups can move many times, so we won’t be able to write code for
    each move separately. Instead, we’ll learn about and use the for loop, which allows
    us to more easily run code for each move.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem coci06c5p1.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Borko has a row of three opaque cups: one at the left (location 1), one at
    the middle (location 2), and one at the right (location 3). There is a ball under
    the cup at the left. It’s our job to keep track of the location of the ball as
    Borko swaps the locations of the cups.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Borko can make three types of swap:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**A** Swap the left and middle cups'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '**B** Swap the middle and right cups'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '**C** Swap the left and right cups'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: For example, if Borko’s first swap is type A, then he swaps the left and middle
    cups; because the ball starts at the left, this swap moves it to the middle. If
    instead his first swap is type B, then he swaps the middle and right cups; the
    left cup stays where it is, so the ball doesn’t change locations.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The input is one line of at most 50 characters. Each character specifies a
    type of swap that Borko makes: A, B, or C.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Output
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Output the final location of the ball:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 1 if the ball is at the left
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 if the ball is at the middle
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3 if the ball is at the right
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why Loops?
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider this test case:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: ACBA
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: There are four swaps here. To determine the final location of the ball, we need
    to carry out each one.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The first swap is type A, which swaps the cups at the left and middle. Since
    the ball starts at the left, this results in the ball moving to the middle. The
    second swap is type C, which swaps the cups at the left and right. Since the ball
    is currently at the middle, this has no effect on the location of the ball. The
    third swap is type B, which swaps the cups at the middle and right. This moves
    the ball from the middle to the right. The fourth swap is type A, which swaps
    the cups at the left and middle. This has no effect on the ball. The correct output
    is therefore 3, because the ball ends up at the right.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that for each swap, we have to make a decision to determine whether
    the ball moves and, if it does, to move the ball appropriately. Making decisions
    is something we know how to do from [Chapter 2](ch02.xhtml#ch02). For example,
    if the swap type is A and the ball is at the left, then the ball moves to the
    middle. That looks like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'if swap_type == ''A'' and ball_location == 1:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: ball_location = 2
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'We could add an elif for each other case where the ball moves: swap type A
    and ball is at the middle, swap type B and ball is at the middle, swap type B
    and ball is at the right, and so on. This big if statement would be enough to
    handle one swap. But that’s not enough to solve the Three Cups problem, because
    we could have a test case of up to 50 swaps. We’d need to repeat the if statement
    logic for each swap. And we certainly wouldn’t want to copy and paste the same
    code 50 times. Imagine if you had made a typo and had to fix it 50 times. Or if
    you suddenly became interested in test cases with up to a million swaps. No, what
    we have learned so far is not going to cut it. We need a way to walk through the
    swaps, performing the same logic for each one. We need a loop.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: for Loops
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python’s for statement produces *for loops*. for loops allow us to process each
    element of a sequence. The only sequence type we’ve seen so far is the string.
    We’ll learn others as we go; for loops work on all of them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our first example of a for loop:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '>>> secret_word = ''olive'''
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for char in secret_word:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''Letter: '' + char)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Letter: o'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Letter: l'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Letter: i'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Letter: v'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Letter: e'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Following the keyword for, we write the name of a *loop variable*. A loop variable
    is one that refers to different values as a loop progresses. In a for loop on
    a string, the loop variable refers to each of the string’s characters.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: I’ve chosen the variable name char (for “character”) to remind us that the variable
    refers to a character from the string. Sometimes, it’s clearer if we use a contextual
    variable name. For example, in Three Cups, we could instead use the name swap_type
    to remind us that it refers to a type of swap.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: After the variable name, we have the keyword in and then the string that we
    want to loop over. In our example, we’re looping over the string referred to by
    secret_word, which is 'olive'.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Like the if, elif, and else lines of an if statement, the for line ends with
    a colon (:). And, also like an if statement, a for statement has an indented block
    of one or more statements.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'An execution of the indented statements is referred to as an *iteration* of
    the loop. Here’s a walk-through of what our loop does on each iteration:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'On the first iteration, Python sets char to refer to ''o'', the first character
    of ''olive''. It then runs the loop block, which consists only of the call to
    print. As char refers to ''o'', the output produced is Letter: o.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the second iteration, Python sets char to refer to ''l'', the second character
    of ''olive''. It then calls print, outputting Letter: l.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This process repeats three more times, once for each remaining character in
    'olive'.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The loop then terminates. We have no code after the loop, so our program has
    finished running. If there was additional code after the loop, then execution
    would continue with that code.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can put multiple statements in the block of a for loop. Here’s an example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 'You can put multiple statements in the block of a for loop. Here’s an example:'
- en: '>>> secret_word = ''olive'''
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> secret_word = ''olive'''
- en: '>>> for char in secret_word:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for char in secret_word:'
- en: '...     print(''Letter: '' + char)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''Letter: '' + char)'
- en: '...     print(''*'')'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''*'')'
- en: '...'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 'Letter: o'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 'Letter: o'
- en: '*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*'
- en: 'Letter: l'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 'Letter: l'
- en: '*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*'
- en: 'Letter: i'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 'Letter: i'
- en: '*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*'
- en: 'Letter: v'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 'Letter: v'
- en: '*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*'
- en: 'Letter: e'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 'Letter: e'
- en: '*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*'
- en: 'Now we have two statements executing on each iteration of the loop: one that
    outputs the current letter of the string, and one that outputs a * character.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 'Now we have two statements executing on each iteration of the loop: one that
    outputs the current letter of the string, and one that outputs a * character.'
- en: 'A for loop loops through the elements of a sequence, so the sequence’s length
    tells us how many iterations there will be. The len function takes a string and
    returns its length:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 'A for loop loops through the elements of a sequence, so the sequence’s length
    tells us how many iterations there will be. The len function takes a string and
    returns its length:'
- en: '>>> len(''olive'')'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> len(''olive'')'
- en: '5'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: 'Our for loop on ''olive'' will therefore consist of five iterations:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 'Our for loop on ''olive'' will therefore consist of five iterations:'
- en: '>>> secret_word = ''olive'''
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> secret_word = ''olive'''
- en: ❶ >>> print(len(secret_word), 'iterations, coming right up!')
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ >>> print(len(secret_word), 'iterations, coming right up!')
- en: '>>> for char in secret_word:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for char in secret_word:'
- en: '...     print(''Letter: '' + char)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '...     print(''Letter: '' + char)'
- en: '...'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: 5 iterations, coming right up!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 5 iterations, coming right up!
- en: 'Letter: o'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 'Letter: o'
- en: 'Letter: l'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'Letter: l'
- en: 'Letter: i'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 'Letter: i'
- en: 'Letter: v'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 'Letter: v'
- en: 'Letter: e'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 'Letter: e'
- en: I called print with multiple arguments ❶, rather than using concatenation, to
    avoid having to convert the length to a string.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: I called print with multiple arguments ❶, rather than using concatenation, to
    avoid having to convert the length to a string.
- en: A for loop is what’s called a *definite loop*, referring to the idea that the
    number of iterations is predetermined. There are also *indefinite loops*, whose
    iterations depend on the vagaries of what happens when your program runs. We’ll
    study those in the next chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: A for loop is what’s called a *definite loop*, referring to the idea that the
    number of iterations is predetermined. There are also *indefinite loops*, whose
    iterations depend on the vagaries of what happens when your program runs. We’ll
    study those in the next chapter.
- en: '**CONCEPT CHECK**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**CONCEPT CHECK**'
- en: What is the output of the following code?
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: What is the output of the following code?
- en: s = 'garage'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: s = 'garage'
- en: total = 0
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: total = 0
- en: 'for char in s:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'for char in s:'
- en: total = total + s.count(char)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: total = total + s.count(char)
- en: print(total)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: print(total)
- en: A. 6
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: A. 6
- en: B. 10
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: B. 10
- en: C. 12
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: C. 12
- en: D. 36
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: D. 36
- en: 'Answer: B. For each character in ''garage'', we add its count to total. There
    are two g’s, two a’s, one r, two a’s (again!), two g’s (again!), and 1 e.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 'Answer: B. For each character in ''garage'', we add its count to total. There
    are two g’s, two a’s, one r, two a’s (again!), two g’s (again!), and 1 e.'
- en: Nesting
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Nesting
- en: The for loop block is one or more statements. Those statements can include one-line
    statements such as function calls and assignment statements. But they can also
    include multiline statements such as if statements and loops.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: The for loop block is one or more statements. Those statements can include one-line
    statements such as function calls and assignment statements. But they can also
    include multiline statements such as if statements and loops.
- en: 'Let’s start with an example of an if statement inside a for loop. Suppose we
    wanted to output only the uppercase characters from a string. Strings have an
    isupper method that we can use to determine whether a character is uppercase:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 'Let’s start with an example of an if statement inside a for loop. Suppose we
    wanted to output only the uppercase characters from a string. Strings have an
    isupper method that we can use to determine whether a character is uppercase:'
- en: '>>> ''q''.isupper()'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''q''.isupper()'
- en: 'False'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: '>>> ''Q''.isupper()'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> ''Q''.isupper()'
- en: 'True'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 'True'
- en: 'We can use isupper in an if statement to control what happens on each iteration
    of a for loop:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 'We can use isupper in an if statement to control what happens on each iteration
    of a for loop:'
- en: '>>> title = ''The Escape'''
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> title = ''The Escape'''
- en: '>>> for char in title:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for char in title:'
- en: '...     if char.isupper():'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '...     if char.isupper():'
- en: '...         print(char)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '...         print(char)'
- en: '...'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: T
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: T
- en: E
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: E
- en: Be careful with the indentation here. We need one level of indentation for the
    for loop, and an extra level of indentation for the nested if statement.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Be careful with the indentation here. We need one level of indentation for the
    for loop, and an extra level of indentation for the nested if statement.
- en: 'On the first iteration, char refers to ''T''. Since ''T'' is uppercase, the
    isupper test returns True, and the if statement block runs. That results in the
    output of T. On the second iteration, char refers to ''h''. This time, the isupper
    test returns False, so the if statement block doesn’t run. Overall, the for loop
    loops through each character of the string, but the nested if statement fires
    only twice: on the ''T'' at the beginning of the string and on the ''E'' at the
    beginning of ''Escape''.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 'On the first iteration, char refers to ''T''. Since ''T'' is uppercase, the
    isupper test returns True, and the if statement block runs. That results in the
    output of T. On the second iteration, char refers to ''h''. This time, the isupper
    test returns False, so the if statement block doesn’t run. Overall, the for loop
    loops through each character of the string, but the nested if statement fires
    only twice: on the ''T'' at the beginning of the string and on the ''E'' at the
    beginning of ''Escape''.'
- en: 'What about a for loop nested in a for loop? We can do that! Here’s an example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，嵌套的 for 循环呢？我们可以这样做！这里有一个示例：
- en: '>>> letters = ''ABC'''
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> letters = ''ABC'''
- en: '>>> digits = ''123'''
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> digits = ''123'''
- en: '>>> for letter in letters:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for letter in letters:'
- en: '...     for digit in digits:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '...     for digit in digits:'
- en: '...         print(letter + digit)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '...         print(letter + digit)'
- en: '...'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: A1
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: A1
- en: A2
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: A2
- en: A3
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: A3
- en: B1
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: B1
- en: B2
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: B2
- en: B3
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: B3
- en: C1
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: C1
- en: C2
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: C2
- en: C3
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: C3
- en: The code produces all two-character strings whose first character is from letters
    and whose second character is from digits.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成所有由两个字符组成的字符串，第一个字符来自字母表，第二个字符来自数字。
- en: On the first iteration of the outer (letters) loop, letter refers to 'A'. This
    iteration involves completely running the inner (digits) loop. The whole time
    the inner loop runs, letter refers to 'A'. On the first iteration of the inner
    loop, digit refers to 1, which explains the A1 output. On the second iteration
    of the inner loop, digit refers to 2, and A2 is output. On the third and final
    iteration of the inner loop, digit refers to 3, and A3 is output.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在外层（字母）循环的第一次迭代中，letter 指向 'A'。这次迭代完全运行内层（数字）循环。在内层循环运行的整个过程中，letter 都指向 'A'。在内层循环的第一次迭代中，digit
    为 1，这就解释了 A1 的输出。在内层循环的第二次迭代中，digit 为 2，输出 A2。在内层循环的第三次也是最后一次迭代中，digit 为 3，输出
    A3。
- en: We’re not done! We’ve gone through only one iteration of the outer loop. On
    the second iteration of the outer loop, letter refers to 'B'. Now the three iterations
    of the inner loop run again, this time with letter referring to 'B'. This accounts
    for the B1, B2, and B3 outputs. Finally, on the third iteration of the outer loop,
    letter refers to 'C', and the inner loop produces C1, C2, and C3.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没完成！我们只进行了外层循环的一次迭代。在外层循环的第二次迭代中，letter 变量指向 'B'。现在，内层循环的三次迭代再次运行，这次 letter
    是 'B'。这就解释了 B1、B2 和 B3 的输出。最后，在外层循环的第三次迭代中，letter 是 'C'，内层循环生成了 C1、C2 和 C3。
- en: '**CONCEPT CHECK**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the output of the following code?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: title = 'The Escape'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: title = 'The Escape'
- en: total = 0
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: total = 0
- en: 'for char1 in title:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 'for char1 in title:'
- en: 'for char2 in title:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 'for char2 in title:'
- en: total = total + 1
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: total = total + 1
- en: print(total)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: print(total)
- en: A. 10
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: A. 10
- en: B. 20
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: B. 20
- en: C. 100
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: C. 100
- en: D. This code produces a syntax error because two nested loops cannot both use
    title
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: D. 这段代码会产生语法错误，因为两个嵌套循环不能都使用 title
- en: 'Answer: C. total starts off as 0 and is increased by 1 on each iteration of
    the inner loop. The length of ''The Escape'' is 10\. The outer loop therefore
    has 10 iterations. For each of those iterations, the inner loop has 10 iterations.
    The inner loop therefore has 10*10 = 100 iterations in all.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：C。total 初始值为 0，并在内层循环的每次迭代中增加 1。'The Escape' 的长度是 10。外层循环因此进行 10 次迭代。每次迭代，内层循环都会进行
    10 次迭代。内层循环总共会进行 10 * 10 = 100 次迭代。
- en: Solving the Problem
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: 'Back to Three Cups. The structure we need is a for loop to go through each
    swap, and a nested if statement to keep track of where the ball is:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 回到三杯问题。我们需要的结构是一个 for 循环来遍历每次交换，一个嵌套的 if 语句来跟踪球的位置：
- en: 'for swap_type in swaps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 'for swap_type in swaps:'
- en: '# Big if statement to keep track of the ball'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '# 大的 if 语句来跟踪球的位置'
- en: 'There are three types of swaps (A, B, and C) and three possible locations for
    the ball, so it’s tempting to conclude that we have to write an if statement with
    3 * 3 = 9 Boolean expressions (one after the if and one after each of eight elifs).
    In fact, we need only six Boolean expressions. Three of the nine don’t move the
    ball at all: swap type A when the ball is at the right, swap type B when the ball
    is at the left, and swap type C when the ball is at the middle.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种交换类型（A、B 和 C）和三种可能的位置，因此很容易得出结论，必须写一个包含 3 * 3 = 9 个布尔表达式的 if 语句（每个 elif 后面跟一个）。事实上，我们只需要六个布尔表达式。九个中有三个不会移动球的位置：当球在右边时是交换类型
    A，球在左边时是交换类型 B，球在中间时是交换类型 C。
- en: '[Listing 3-1](ch03.xhtml#ch03ex01) has a solution to Three Cups.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-1](ch03.xhtml#ch03ex01) 解决了三杯问题。'
- en: swaps = input()
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: swaps = input()
- en: ball_location = 1
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ball_location = 1
- en: '❶ for swap_type in swaps:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ for swap_type in swaps:'
- en: '❷ if swap_type == ''A'' and ball_location == 1:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ if swap_type == ''A'' and ball_location == 1:'
- en: ❸ ball_location = 2
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ ball_location = 2
- en: 'elif swap_type == ''A'' and ball_location == 2:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif swap_type == ''A'' and ball_location == 2:'
- en: ball_location = 1
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ball_location = 1
- en: 'elif swap_type == ''B'' and ball_location == 2:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif swap_type == ''B'' and ball_location == 2:'
- en: ball_location = 3
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ball_location = 3
- en: 'elif swap_type == ''B'' and ball_location == 3:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif swap_type == ''B'' and ball_location == 3:'
- en: ball_location = 2
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ball_location = 2
- en: 'elif swap_type == ''C'' and ball_location == 1:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif swap_type == ''C'' and ball_location == 1:'
- en: ball_location = 3
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ball_location = 3
- en: 'elif swap_type == ''C'' and ball_location == 3:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif swap_type == ''C'' and ball_location == 3:'
- en: ball_location = 1
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ball_location = 1
- en: print(ball_location)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-1: Solving Three Cups*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: I’ve used input to assign the string of swaps to the swaps variable. The for
    loop ❶ loops through these swaps. Each swap is processed by the nested if statement
    ❷. The if and elif branches each encode what happens with a given type of swap
    and a given ball location and then move the ball accordingly. For example, if
    the swap type is A and the ball is at location 1 ❷, then the ball ends up at location
    2 ❸.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: This is a code example where it matters whether we use multiple elifs (one big
    if statement) or multiple ifs (multiple if statements). If we change the elifs
    to ifs, then our code is no longer correct. [Listing 3-2](ch03.xhtml#ch03ex02)
    shows the incorrect code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: This code is incorrect
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: swaps = input()
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: ball_location = 1
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'for swap_type in swaps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '❶ if swap_type == ''A'' and ball_location == 1:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: ball_location = 2
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '❷ if swap_type == ''A'' and ball_location == 2:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: ball_location = 1
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'if swap_type == ''B'' and ball_location == 2:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: ball_location = 3
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'if swap_type == ''B'' and ball_location == 3:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: ball_location = 2
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'if swap_type == ''C'' and ball_location == 1:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: ball_location = 3
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'if swap_type == ''C'' and ball_location == 3:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: ball_location = 1
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: print(ball_location)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-2: Solving Three Cups incorrectly*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: If we say that the code is incorrect, we’re claiming that it fails at least
    one test case. Can you find a test case where this code produces the wrong answer?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one such test case:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: A
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: It may make sense to us that the ball can move at most once per swap. But Python
    robotically runs the code you have written, whether it matches what we expect
    or not. In this case, we have only one swap, so the ball should move at most once.
    On the first and only iteration of the for loop, Python checks the expression
    ❶. It’s True, so Python sets ball_location to 2. Then, Python checks the expression
    ❷. Because we just changed ball_location to 2, this expression is True! Python
    therefore sets ball_location to 1. The output of the program is 1 when it should
    be 2.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of a *logic error*: an error that causes a program to follow
    the wrong logic and produce the wrong answer. A common term for logic error is
    a *bug*. When programmers work through their code to fix bugs, it’s called *debugging*.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: It often takes only a simple test case to demonstrate when a program is incorrect.
    When you’re trying to narrow down what’s going wrong with your code, don’t start
    with long test cases. Such test case results are hard to verify by hand and often
    set in motion complex execution paths from which we may learn very little. A small
    test case, by contrast, doesn’t cause our program to do much; if what it does
    is wrong, then we don’t have far to look for the culprit. Devising small, targeted
    test cases is not always easy. It’s a skill that you can hone through practice.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Submit our correct code to the judge, and then let’s move on.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing, you might like to try solving exercises 1 and 2 from “Chapter
    Exercises” on [page 67](ch03.xhtml#ch03lev1sec16).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #6: Occupied Spaces'
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We know how to loop through the characters of a string. But sometimes we need
    to know where we are in the string, not just the character that’s stored there.
    This problem is one such example.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem ccc18j2.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You supervise a parking lot with *n* parking spaces. Yesterday, you recorded
    whether each parking space was occupied by a car or was empty. Today, you again
    recorded whether each parking space was occupied by a car or was empty. Indicate
    the number of parking spaces that were occupied on both days.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The input consists of three lines.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The first line contains integer *n*, the number of parking spaces. *n* is between
    1 and 100.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second line contains a string of *n* characters for yesterday’s information,
    one character for each parking space. A C indicates an occupied parking space
    (C for car), and a . indicates an empty parking space. For example, CC. means
    that the first two parking spaces were occupied and the third was empty.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third line contains a string of *n* characters for today’s information,
    in the same format as the second line.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Output the number of parking spaces that were occupied on both days.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: A New Kind of Loop
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We could have up to 100 parking spaces, so you may not be surprised that a
    loop will show up here somewhere. The kind of for loop we learned when solving
    Three Cups can certainly loop through a string of parking-space information:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '>>> yesterday = ''CC.'''
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for parking_space in yesterday:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(''The space is '' + parking_space)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The space is C
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The space is C
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: The space is .
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: That tells us whether each space was occupied yesterday. But we also need to
    know whether each space was also occupied today.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this test case:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: CC.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: .C.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The first parking space was occupied yesterday. Was that parking space occupied
    on both days? To answer that, we need to look at the corresponding character in
    today’s string. It’s a . (empty), so this parking space was not occupied on both
    days.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: What about the second parking space? That one was also occupied yesterday. And,
    looking at the second character of today’s string, it was also occupied today.
    So this *is* a parking space that was occupied on both days. (This is the only
    such parking space; the correct output for this test case is 1.)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Looping through the characters of one string doesn’t help us find the corresponding
    characters in the other string. But if we could keep track of where we were in
    the string—we’re at the first parking space, we’re at the second parking space,
    and so on—we could look up the corresponding character from each string. The for
    loops we’ve learned so far are not the way to do this. The way to do this is using
    indexing and a new type of for loop.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Indexing
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each character in a string has an *index*, which indicates its location. The
    first character is at index 0, the second character is at index 1, and so on.
    In natural language, we often start counting at 1\. In English, no one says “the
    character at position 0 of *hello* is *h*.” But most programming languages, Python
    included, start at 0.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'To use indexing, we follow a string by an index in square brackets. Here are
    some examples of indexing:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '>>> word = ''splore'''
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '>>> word[0]'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '''s'''
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '>>> word[3]'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '''o'''
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '>>> word[5]'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '''e'''
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'If we like, we can use variables in an index:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '>>> where = 2'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '>>> word[where]'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '''l'''
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '>>> word[where + 2]'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '''r'''
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'The highest index that we can use on a nonempty string is its length minus
    1\. (There is no valid index for an empty string.) For example, ''splore'' is
    length 6, so index 5 is its highest index. Any bigger and we get an error:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '>>> word[len(word)]'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: File "<stdin>", line 1, in <module>
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'IndexError: string index out of range'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '>>> word[len(word) - 1]'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '''e'''
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we access the second character from the right of a string? This will
    do it:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '>>> word[len(word) - 2]'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '''r'''
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'But there’s an easier way. Python supports negative indices as another option
    for accessing characters. Index -1 is the rightmost character, index -2 is the
    second character from the right, and so on:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '>>> word[-2]'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '''r'''
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '>>> word[-1]'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '''e'''
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '>>> word[-5]'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '''p'''
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '>>> word[-6]'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '''s'''
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '>>> word[-7]'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Traceback (most recent call last):'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: File "<stdin>", line 1, in <module>
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'IndexError: string index out of range'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: The plan is to use indexing to access corresponding positions of yesterday’s
    and today’s parking information. We can use index 0 of each string to access information
    about the first parking space, index 1 to access information about the second
    parking space, and so on. But before we can carry out that plan, we need to learn
    a new kind of for loop.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: What is the output of the following code?
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: s = 'abcde'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: t = s[0] + s[-5] + s[len(s) - 5]
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: print(t)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: A. aaa
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: B. aae
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: C. aee
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: D. This code produces an error
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: A. Each of the three indices refers to the first character in ''abcde''.
    First, s[0] refers to ''a'' because ''a'' is at index 0 of the string. Second,
    s[-5] refers to ''a'' because ''a'' is the fifth character from the right. Third,
    s[len(s) - 5] refers to ''a'' because the index evaluates to 0: 5 (the length
    of the string) minus 5.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Range for loops
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python’s range function generates ranges of integers, and we can use those
    ranges to control for loops. Rather than looping through the characters of a string,
    a range for loop loops through integers. If we provide one argument to range,
    we get a range from 0 to 1 less than that argument:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for num in range(5):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(num)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Notice that 5 is not output.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'If we provide two arguments to range, we get a sequence from the first argument
    up to but not including the second argument:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for num in range(3, 7):'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(num)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'We can count up by a different *step size* by including a third argument. The
    default step size is 1, which counts up by one. Let’s try a couple of other step
    sizes:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for num in range(0, 10, 2):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(num)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for num in range(0, 10, 3):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(num)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'We can count backward, too, but *not* like this:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for num in range(6, 2):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(num)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'That doesn’t work, because by default range counts up. A step size of -1 lets
    us go backward, one at a time:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for num in range(6, 2, -1):'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(num)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'To count down from 6 to 0, including 0, we need a value of -1 for the second
    argument:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for num in range(6, -1, -1):'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(num)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s sometimes helpful to quickly look at the numbers in a range without coding
    a loop. Unfortunately, the range function doesn’t directly show us those numbers:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '>>> range(3, 7)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: range(3, 7)
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pass that result to the list function to get what we want:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '>>> list(range(3, 7))'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[3, 4, 5, 6]'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: When called with a range, the list function produces a list of the range’s integers.
    We’ll learn all about lists later; for now, keep list in mind as an aid to diagnosing
    errors with ranges.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '**CONCEPT CHECK**'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: How many iterations are performed by the following loop?
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(10, 20):'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '# Some code here'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: A. 9
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: B. 10
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: C. 11
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: D. 20
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer: B. The range goes through the numbers 10, 11, 12, 13, 14, 15, 16, 17,
    18, and 19\. There are 10 numbers and hence 10 iterations.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Range for Loops Through Indices
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Suppose we have strings giving yesterday’s and today’s parking-space information:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '>>> yesterday = ''CC.'''
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '>>> today = ''.C.'''
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an index, we can look at yesterday’s and today’s information for that
    index:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '>>> yesterday[0]'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '''C'''
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '>>> today[0]'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '''.'''
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a range for loop through the indices to process each pair of corresponding
    characters. We know that yesterday and today are the same length. But that length
    could be anything from 1 to 100, so we can’t write something like range(3). We
    want to iterate with indices 0, 1, 2, and so on, all the way up to the length
    of the string minus 1\. We can do that by using the length of one of the strings
    as the argument to range:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '>>> for index in range(len(yesterday)):'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '...     print(yesterday[index], today[index])'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: C .
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: C C
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: . .
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: I’ve called the loop variable index. Other popular names include i (the first
    letter of index) and ind. I’ll use i from here on out.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Don’t call this loop variable status or information. Those names imply that
    it takes on 'C' and '.' values, when really it takes on integers.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With our range for loops, we’re ready to solve Occupied Spaces. Our strategy
    is to loop through each index from the beginning of the strings to the end. We
    can check what’s at each index in both yesterday’s information and today’s information.
    Using a nested if statement, we’ll determine whether the parking space was occupied
    on both days.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-3](ch03.xhtml#ch03ex03) has our solution.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: n = int(input())
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: yesterday = input()
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: today = input()
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: ❶ occupied = 0
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '❷ for i in range(len(yesterday)):'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '❸ if yesterday[i] == ''C'' and today[i] == ''C'':'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: ❹ occupied = occupied + 1
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: print(occupied)
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-3: Solving Occupied Spaces*'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'The program starts by reading the three lines of input: n refers to the number
    of parking spaces; and yesterday and today refer to yesterday’s and today’s parking-space
    information, respectively.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we don’t refer to the number of parking spaces (n) again. We could
    make use of it to tell us the length of the strings, but I’ve chosen to ignore
    it because it’s often not provided in real-life scenarios.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: We use the occupied variable to count the number of parking spaces that were
    occupied both yesterday and today. We start that variable off at 0 ❶.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Now we reach the range for loop, which loops through the valid indices of yesterday
    and today ❷. For each such index, we check whether the parking space was occupied
    yesterday and occupied today ❸. If it was, then we include this parking space
    in our total by increasing occupied by 1 ❹.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: When the range for loop terminates, we’ll have gone through all parking spaces.
    The total number of parking spaces that were occupied yesterday and today can
    be accessed through the occupied variable. All that’s left is to output that total.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: That’ll do it for this problem. Time to submit your code to the judge.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'Problem #7: Data Plan'
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve learned that for loops are useful for processing data after we’ve read
    it from the input. They’re also often useful for reading the data itself. In this
    problem, we’ll tackle data that’s spread over many lines and use a for loop to
    help us read it all.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem coci16c1p1.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: The Challenge
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pero has a data plan with his cell phone provider that offers him *x* megabytes
    of data per month. In addition, any data he doesn’t use in a given month carries
    over to the next month. For example, if *x* is 10 and Pero uses only 4MB in a
    given month, the remaining 6MB carry over to the next month (in which he’d now
    have 10 + 6 = 16MB available).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: We’re given the number of megabytes of data that Pero uses in each of the first
    *n* months. Our task is to determine the number of megabytes available for the
    following month.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Input
  id: totrans-393
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The input consists of the following lines:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: A line containing integer *x*, the number of megabytes given to Pero per month.
    *x* is between 1 and 100.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing integer *n*, the number of months that Pero has had the data
    plan. *n* is between 1 and 100.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*n* lines, one for each month, giving the integer number of megabytes that
    Pero uses in that month. Each number is at least 0 and will never outstrip the
    number of available megabytes. (For example, if *x* is 10 and Pero currently has
    30MB available, the next number will be at most 30.)'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  id: totrans-398
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Output the number of megabytes available for the next month.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Looping to Read Input
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In all of our problems so far, we’ve known exactly how many lines to read from
    the input. For example, in Three Cups, we read one line; in Occupied Spaces, we
    read three lines. Here in Data Plan, we don’t know in advance how many lines to
    read, because it depends on the number that we read from the second line.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'We can read the first line of input:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: monthly_mb = int(input())
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: (I’ve used variable name monthly_mb rather than x to imbue it with some meaning.)
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'And we can read the second line of input:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: n = int(input())
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can’t read any more without a loop. A range for loop is perfect here,
    because we can use it to loop exactly n times:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '# Process month'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Problem
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: My strategy for solving the problem is to keep track of the number of megabytes
    that are carried over from previous months. I call this the *excess*.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this test case:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: In each month, Pero is given 10MB of data, and we have to process the data that
    he used in the provided three months. In the first month, Pero is given 10MB and
    uses 4MB, so the excess that carries forward is 6MB. In the second month, Pero
    is given 10MB more, so now he has 16MB total. He uses 12MB this month, so the
    excess that carries forward is 16 – 12 = 4MB. In the third month, Pero is given
    10MB more, so now he has 14MB total. He uses 1MB this month, so the excess that
    carries forward is 14 – 1 = 13MB.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: We need to know the number of megabytes that Pero has available for the next
    (that is, fourth) month. He has 13MB that carry over from the first three months,
    and he’s given his usual 10MB for this month, so he has a total of 13 + 10 = 23MB
    to use.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: When I went to write the code based on this explanation, I neglected to add
    this final 10, so my output was 13 instead of 23\. I was focusing exclusively
    on the excess and forgot that what we need is not the excess going into the next
    month, but the total number of megabytes available. That total is the excess plus
    whatever Pero is given per month.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: See [Listing 3-4](ch03.xhtml#ch03ex04) for the (corrected!) code.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: monthly_mb = int(input())
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: n = int(input())
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: excess = 0
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '❶ for i in range(n):'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: used = int(input())
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: ❷ excess = excess + monthly_mb - used
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: ❸ print(excess + monthly_mb)
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-4: Solving Data Plan*'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: The excess variable begins at 0. On each iteration of the range for loop, we
    assign a value to excess that considers the number of megabytes given per month
    and the number of megabytes used in that month.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: The range for loop loops n times, once for each month that Pero has had the
    data plan ❶. The values that i takes on—0, 1, and so on—aren’t of interest to
    us, because we have no reason to care about which month we’re processing. For
    that reason, we don’t use the value of i anywhere in the program. You can replace
    i with _ (an underscore) to be explicit about the variable’s “don’t care” status,
    but I’ll leave it as i for consistency with other examples.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'In the range for loop, we read the number of megabytes used in this month.
    Then, we update the number of excess megabytes ❷: it’s what it was before, plus
    the number of megabytes that Pero gets per month, minus the number of megabytes
    that Pero uses this month.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Having computed the excess number of megabytes after n months, we report the
    number of megabytes available for the next month ❸.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'There are always multiple ways to solve a problem. Programming is creative,
    and I enjoy observing the range of solution strategies that people come up with.
    Even if you’ve succeeded in solving a problem, you might like to Google the problem
    to learn from how others have solved it. In addition, some online judges, like
    DMOJ, allow you to view other people’s submissions once you’ve solved the problem.
    For submissions that pass all of the test cases: did those programmers do things
    differently from you? For submissions that fail some test cases: what’s wrong
    with the code? Reading other people’s code is a great way to improve your own
    programming skill!'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Can you think of another way to solve Data Plan?
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a hint: you can start by calculating the total number of megabytes that
    Pero is given and then subtracting the number of megabytes that he uses. I encourage
    you to take some time to work out how to do this before continuing!'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: The total number of megabytes given to Pero, including those given in the next
    month, is *x* * (*n* + 1), where *x* is the number of megabytes given per month.
    To determine the number of megabytes available for the next month, we can start
    with that total and subtract what Pero uses each month. That strategy is coded
    in [Listing 3-5](ch03.xhtml#ch03ex05).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: monthly_mb = int(input())
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: n = int(input())
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: total_mb = monthly_mb * (n + 1)
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(n):'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: used = int(input())
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: total_mb = total_mb - used
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: print(total_mb)
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 3-5: Solving Data Plan, alternate approach*'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Choose whichever solution is your favorite, and submit to the judge.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: What’s intuitive to one person may not be intuitive to another. You might read
    an explanation or code and not be able to make sense of it. This doesn’t mean
    that you’re not smart enough. It just means you need a different presentation,
    one that aligns more closely to your current thinking. You might also flag difficult
    explanations and examples for later review. They may prove to be surprisingly
    useful once you’ve gained further practice.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we learned about for loops. Standard for loops loop through
    the characters of a sequence; range for loops loop through integers in a range.
    Each problem that we solved required us to process many pieces of input, and we
    wouldn’t have been able to manage that without a loop.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'The for loop is the loop of choice whenever you need to repeat code a specified
    number of times. Python has one other type of loop, and we’ll learn how to use
    it in the next chapter. Why do we need anything besides for loops? What can’t
    for loops do? Good questions! I’ll tell you this for now: practicing with for
    loops is a wonderful way to prepare for what’s to come.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Exercises
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are some exercises for you to try.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: DMOJ problem wc17c3j3, Uncrackable
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem coci18c3p1, Magnus
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem ccc11s1, English or French
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem ccc11s2, Multiple Choice
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem coci12c5p1, Ljestvica
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem coci13c3p1, Rijeci
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DMOJ problem coci18c4p1, Elder
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notes
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Three Cups is originally from the 2006/2007 Croatian Open Competition in Informatics,
    Contest 5\. Occupied Spaces is originally from the 2018 Canadian Computing Competition,
    Junior Level. Data Plan is originally from the 2016/2017 Croatian Open Competition
    in Informatics, Contest 1.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
