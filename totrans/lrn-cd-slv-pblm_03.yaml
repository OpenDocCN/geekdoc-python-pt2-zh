- en: '3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '3'
- en: 'REPEATING CODE: DEFINITE LOOPS'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 重复代码：确定性循环
- en: '![image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common.jpg)'
- en: Computers shine when we have them repeat a process over and over. They tirelessly
    do exactly what we ask, whether it involves doing something 10, 100, or a billion
    times. In this chapter, we’ll learn about loops, statements that instruct the
    computer to repeat the execution of part of our program.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机在重复执行一个过程时表现得非常出色。它们会不知疲倦地按照我们的要求执行，无论是执行 10 次、100 次，还是 10 亿次。在这一章中，我们将学习循环，它是指示计算机重复执行程序部分代码的语句。
- en: 'We’ll use loops to solve three problems: tracking the location of a ball under
    a cup, counting the number of occupied parking spaces, and determining how much
    data is available on a cell phone plan.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用循环来解决三个问题：追踪球在杯子下的位置，计算占用的停车位数，以及确定手机套餐上的可用数据量。
- en: 'Problem #5: Three Cups'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #5：三只杯子'
- en: In this problem, we’ll track the location of a ball under a cup as the cups
    move. But the cups can move many times, so we won’t be able to write code for
    each move separately. Instead, we’ll learn about and use the `for` loop, which
    allows us to more easily run code for each move.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，我们将追踪球在杯子下的位置，随着杯子移动而变化。但杯子可能会移动多次，因此我们不能为每次移动单独编写代码。相反，我们将学习并使用 `for`
    循环，它可以让我们更轻松地为每次移动执行代码。
- en: This is DMOJ problem `coci06c5p1`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 `coci06c5p1`。
- en: The Challenge
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: 'Borko has a row of three opaque cups: one at the left (location 1), one at
    the middle (location 2), and one at the right (location 3). There is a ball under
    the cup at the left. It’s our job to keep track of the location of the ball as
    Borko swaps the locations of the cups.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Borko 有一排三只不透明的杯子：一个在左边（位置 1），一个在中间（位置 2），一个在右边（位置 3）。球在左边的杯子下。我们的任务是随着 Borko
    交换杯子的顺序，追踪球的位置。
- en: 'Borko can make three types of swap:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Borko 可以进行三种类型的交换：
- en: '**A** Swap the left and middle cups'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**A** 交换左杯和中杯'
- en: '**B** Swap the middle and right cups'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**B** 交换中杯和右杯'
- en: '**C** Swap the left and right cups'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**C** 交换左杯和右杯'
- en: For example, if Borko’s first swap is type A, then he swaps the left and middle
    cups; because the ball starts at the left, this swap moves it to the middle. If
    instead his first swap is type B, then he swaps the middle and right cups; the
    left cup stays where it is, so the ball doesn’t change locations.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果 Borko 的第一次交换是 A 类型，那么他交换左杯和中杯；因为球最初在左边，这个交换将球移动到中间。如果他的第一次交换是 B 类型，那么他交换中杯和右杯；左杯保持原位，所以球的位置不变。
- en: Input
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input is one line of at most 50 characters. Each character specifies a
    type of swap that Borko makes: `A`, `B`, or `C`.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 输入是一行最多 50 个字符的字符串。每个字符表示 Borko 进行的一种交换类型：`A`、`B` 或 `C`。
- en: Output
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: 'Output the final location of the ball:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 输出球的最终位置：
- en: '`1` if the ball is at the left'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1` 如果球在左边'
- en: '`2` if the ball is at the middle'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2` 如果球在中间'
- en: '`3` if the ball is at the right'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3` 如果球在右边'
- en: Why Loops?
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么要用循环？
- en: 'Consider this test case:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下测试案例：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are four swaps here. To determine the final location of the ball, we need
    to carry out each one.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有四次交换。为了确定球的最终位置，我们需要执行每一次交换。
- en: The first swap is type `A`, which swaps the cups at the left and middle. Since
    the ball starts at the left, this results in the ball moving to the middle. The
    second swap is type `C`, which swaps the cups at the left and right. Since the
    ball is currently at the middle, this has no effect on the location of the ball.
    The third swap is type `B`, which swaps the cups at the middle and right. This
    moves the ball from the middle to the right. The fourth swap is type `A`, which
    swaps the cups at the left and middle. This has no effect on the ball. The correct
    output is therefore `3`, because the ball ends up at the right.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次交换是 A 类型，交换左杯和中杯。因为球最初在左边，这将球移动到中间。第二次交换是 C 类型，交换左杯和右杯。由于球目前在中间，所以这次交换对球的位置没有影响。第三次交换是
    B 类型，交换中杯和右杯。这个交换将球从中间移动到右边。第四次交换是 A 类型，交换左杯和中杯。这个交换对球没有影响。因此，正确的输出是 `3`，因为球最终在右边。
- en: 'Notice that for each swap, we have to make a decision to determine whether
    the ball moves and, if it does, to move the ball appropriately. Making decisions
    is something we know how to do from [Chapter 2](ch02.xhtml#ch02). For example,
    if the swap type is `A` and the ball is at the left, then the ball moves to the
    middle. That looks like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于每次交换，我们需要做出决策，判断球是否移动，如果移动了，如何正确地移动球。做决策是我们在[第2章](ch02.xhtml#ch02)中学过的内容。例如，如果交换类型是`A`，且球在左侧，则球移动到中间。看起来是这样的：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We could add an `elif` for each other case where the ball moves: swap type
    `A` and ball is at the middle, swap type `B` and ball is at the middle, swap type
    `B` and ball is at the right, and so on. This big `if` statement would be enough
    to handle one swap. But that’s not enough to solve the Three Cups problem, because
    we could have a test case of up to 50 swaps. We’d need to repeat the `if` statement
    logic for each swap. And we certainly wouldn’t want to copy and paste the same
    code 50 times. Imagine if you had made a typo and had to fix it 50 times. Or if
    you suddenly became interested in test cases with up to a million swaps. No, what
    we have learned so far is not going to cut it. We need a way to walk through the
    swaps, performing the same logic for each one. We need a loop.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为每个其他球移动的情况添加一个`elif`分支：交换类型`A`且球在中间，交换类型`B`且球在中间，交换类型`B`且球在右侧，等等。这个大的`if`语句可以处理一次交换。但这还不足以解决三杯问题，因为我们可能会有最多50次交换的测试案例。我们需要为每次交换重复`if`语句逻辑。而且我们当然不希望复制粘贴相同的代码50次。想象一下如果你写错了一个地方，需要修正50次。或者如果你突然对最多有百万次交换的测试案例产生兴趣。不会的，我们到目前为止学到的东西还远远不够。我们需要一种方法，能够遍历这些交换，为每个交换执行相同的逻辑。我们需要一个循环。
- en: for Loops
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for 循环
- en: Python’s `for` statement produces *for loops*. `for` loops allow us to process
    each element of a sequence. The only sequence type we’ve seen so far is the string.
    We’ll learn others as we go; `for` loops work on all of them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`for`语句生成*for循环*。`for`循环让我们可以处理序列中的每个元素。到目前为止，我们所见的唯一序列类型是字符串。我们将会学习其他类型；`for`循环适用于所有这些类型。
- en: 'Here’s our first example of a `for` loop:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一个`for`循环的示例：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Following the keyword `for`, we write the name of a *loop variable*. A loop
    variable is one that refers to different values as a loop progresses. In a `for`
    loop on a string, the loop variable refers to each of the string’s characters.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在关键字`for`后，我们写上一个*循环变量*的名字。循环变量是在循环进行时，引用不同值的变量。在字符串的`for`循环中，循环变量指向字符串中的每个字符。
- en: I’ve chosen the variable name `char` (for “character”) to remind us that the
    variable refers to a character from the string. Sometimes, it’s clearer if we
    use a contextual variable name. For example, in Three Cups, we could instead use
    the name `swap_type` to remind us that it refers to a type of swap.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择了变量名`char`（表示“字符”），提醒我们这个变量指代字符串中的一个字符。有时候，如果使用一个有上下文的变量名会更清晰。例如，在“三杯”问题中，我们可以使用`swap_type`这个名字，提醒我们它代表的是一种交换类型。
- en: After the variable name, we have the keyword `in` and then the string that we
    want to loop over. In our example, we’re looping over the string referred to by
    `secret_word`, which is `'olive'`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量名后面，我们有关键字`in`，然后是我们想要循环的字符串。在我们的例子中，我们正在循环遍历由`secret_word`表示的字符串，值为`'olive'`。
- en: Like the `if`, `elif`, and `else` lines of an `if` statement, the `for` line
    ends with a colon (`:`). And, also like an `if` statement, a `for` statement has
    an indented block of one or more statements.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 像`if`、`elif`和`else`语句中的`if`行一样，`for`行以冒号（`:`）结束。而且，和`if`语句类似，`for`语句也有一个缩进的语句块，里面可以包含一个或多个语句。
- en: 'An execution of the indented statements is referred to as an *iteration* of
    the loop. Here’s a walk-through of what our loop does on each iteration:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这个缩进语句块的过程称为*迭代*。以下是我们循环在每次迭代时的执行步骤：
- en: 'On the first iteration, Python sets `char` to refer to `''o''`, the first character
    of `''olive''`. It then runs the loop block, which consists only of the call to
    `print`. As `char` refers to `''o''`, the output produced is `Letter: o`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在第一次迭代时，Python将`char`设置为指向`''olive''`的第一个字符`''o''`。然后它执行循环块，循环块中只有对`print`的调用。由于`char`指向`''o''`，所以输出结果是`Letter:
    o`。'
- en: 'On the second iteration, Python sets `char` to refer to `''l''`, the second
    character of `''olive''`. It then calls `print`, outputting `Letter: l`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在第二次迭代时，Python将`char`设置为指向`''olive''`的第二个字符`''l''`。然后它调用`print`，输出`Letter:
    l`。'
- en: This process repeats three more times, once for each remaining character in
    `'olive'`.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个过程会再重复三次，每次处理`'olive'`中的剩余字符。
- en: The loop then terminates. We have no code after the loop, so our program has
    finished running. If there was additional code after the loop, then execution
    would continue with that code.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后循环终止。我们在循环后没有其他代码，所以程序已经运行完毕。如果循环后有额外的代码，执行将继续进行。
- en: 'You can put multiple statements in the block of a `for` loop. Here’s an example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `for` 循环的代码块中放入多个语句。这里有一个示例：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we have two statements executing on each iteration of the loop: one that
    outputs the current letter of the string, and one that outputs a `*` character.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在每次迭代时有两个语句执行：一个输出字符串的当前字母，另一个输出 `*` 字符。
- en: 'A `for` loop loops through the elements of a sequence, so the sequence’s length
    tells us how many iterations there will be. The `len` function takes a string
    and returns its length:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环遍历序列的元素，因此序列的长度告诉我们会有多少次迭代。`len` 函数接受一个字符串并返回其长度：'
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our `for` loop on `''olive''` will therefore consist of five iterations:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `'olive'` 的 `for` 循环因此会进行五次迭代：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I called `print` with multiple arguments ❶, rather than using concatenation,
    to avoid having to convert the length to a string.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我调用了带有多个参数的 `print` ❶，而不是使用字符串拼接，目的是避免将长度转换为字符串。
- en: A `for` loop is what’s called a *definite loop*, referring to the idea that
    the number of iterations is predetermined. There are also *indefinite loops*,
    whose iterations depend on the vagaries of what happens when your program runs.
    We’ll study those in the next chapter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环是所谓的*确定性循环*，即迭代次数是预定的。还有*不确定性循环*，它们的迭代次数依赖于程序运行时发生的随机情况。我们将在下一章学习这些。'
- en: '**CONCEPT CHECK**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the output of the following code?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A. `6`
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: A. `6`
- en: B. `10`
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: B. `10`
- en: C. `12`
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: C. `12`
- en: D. `36`
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: D. `36`
- en: 'Answer: B. For each character in `''garage''`, we add its count to `total`.
    There are two `g`’s, two `a`’s, one `r`, two `a`’s (again!), two `g`’s (again!),
    and 1 `e`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B。对于 `'garage'` 中的每个字符，我们将其计数加到 `total` 中。这里有两个 `g`，两个 `a`，一个 `r`，两个 `a`（再次出现！），两个
    `g`（再次出现！），以及一个 `e`。
- en: Nesting
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套
- en: The `for` loop block is one or more statements. Those statements can include
    one-line statements such as function calls and assignment statements. But they
    can also include multiline statements such as `if` statements and loops.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环块是一个或多个语句。这些语句可以包括一行语句，如函数调用和赋值语句。但它们也可以包含多行语句，如 `if` 语句和循环。'
- en: 'Let’s start with an example of an `if` statement inside a `for` loop. Suppose
    we wanted to output only the uppercase characters from a string. Strings have
    an `isupper` method that we can use to determine whether a character is uppercase:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个 `for` 循环中的 `if` 语句示例开始。假设我们只想输出字符串中的大写字符。字符串有一个 `isupper` 方法，我们可以用它来判断一个字符是否是大写字母：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can use `isupper` in an `if` statement to control what happens on each iteration
    of a `for` loop:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `if` 语句中使用 `isupper` 来控制每次 `for` 循环的迭代过程：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Be careful with the indentation here. We need one level of indentation for the
    `for` loop, and an extra level of indentation for the nested `if` statement.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里的缩进。我们需要一个缩进层级来表示 `for` 循环，另一个额外的缩进层级用来表示嵌套的 `if` 语句。
- en: 'On the first iteration, `char` refers to `''T''`. Since `''T''` is uppercase,
    the `isupper` test returns `True`, and the `if` statement block runs. That results
    in the output of `T`. On the second iteration, `char` refers to `''h''`. This
    time, the `isupper` test returns `False`, so the `if` statement block doesn’t
    run. Overall, the `for` loop loops through each character of the string, but the
    nested `if` statement fires only twice: on the `''T''` at the beginning of the
    string and on the `''E''` at the beginning of `''Escape''`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次迭代时，`char` 表示 `'T'`。由于 `'T'` 是大写字母，`isupper` 测试返回 `True`，于是 `if` 语句块执行。这导致输出
    `T`。在第二次迭代时，`char` 表示 `'h'`。这次，`isupper` 测试返回 `False`，所以 `if` 语句块不执行。总体来说，`for`
    循环遍历字符串中的每个字符，但嵌套的 `if` 语句只会在两个地方触发：一个是字符串开头的 `'T'`，另一个是 `'Escape'` 开头的 `'E'`。
- en: 'What about a `for` loop nested in a `for` loop? We can do that! Here’s an example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`for` 循环嵌套在另一个 `for` 循环中怎么办？我们可以这么做！这里有一个示例：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The code produces all two-character strings whose first character is from `letters`
    and whose second character is from `digits`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成所有由两个字符组成的字符串，第一个字符来自 `letters`，第二个字符来自 `digits`。
- en: On the first iteration of the outer (`letters`) loop, `letter` refers to `'A'`.
    This iteration involves completely running the inner (`digits`) loop. The whole
    time the inner loop runs, `letter` refers to `'A'`. On the first iteration of
    the inner loop, `digit` refers to `1`, which explains the `A1` output. On the
    second iteration of the inner loop, `digit` refers to `2`, and `A2` is output.
    On the third and final iteration of the inner loop, `digit` refers to `3`, and
    `A3` is output.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在外循环（`letters`）的第一次迭代中，`letter` 为 `'A'`。这次迭代完全运行内循环（`digits`）。内循环运行的整个时间，`letter`
    都为 `'A'`。在内循环的第一次迭代中，`digit` 为 `1`，这就解释了 `A1` 的输出。在内循环的第二次迭代中，`digit` 为 `2`，并输出
    `A2`。在内循环的第三次也是最后一次迭代中，`digit` 为 `3`，并输出 `A3`。
- en: We’re not done! We’ve gone through only one iteration of the outer loop. On
    the second iteration of the outer loop, `letter` refers to `'B'`. Now the three
    iterations of the inner loop run again, this time with `letter` referring to `'B'`.
    This accounts for the `B1`, `B2`, and `B3` outputs. Finally, on the third iteration
    of the outer loop, `letter` refers to `'C'`, and the inner loop produces `C1`,
    `C2`, and `C3`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没完成！我们只走了一遍外循环。在外循环的第二次迭代中，`letter` 变为 `'B'`。现在，内循环的三次迭代再次运行，这时 `letter`
    指向 `'B'`。这就解释了 `B1`、`B2` 和 `B3` 的输出。最后，在外循环的第三次迭代中，`letter` 指向 `'C'`，内循环产生 `C1`、`C2`
    和 `C3`。
- en: '**CONCEPT CHECK**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the output of the following code?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A. `10`
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: A. `10`
- en: B. `20`
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: B. `20`
- en: C. `100`
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: C. `100`
- en: D. This code produces a syntax error because two nested loops cannot both use
    `title`
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: D. 这段代码会产生语法错误，因为两个嵌套的循环不能同时使用 `title`。
- en: 'Answer: C. `total` starts off as `0` and is increased by 1 on each iteration
    of the inner loop. The length of `''The Escape''` is 10\. The outer loop therefore
    has 10 iterations. For each of those iterations, the inner loop has 10 iterations.
    The inner loop therefore has 10*10 = 100 iterations in all.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：C. `total` 最初为 `0`，并在每次内循环迭代时增加 1。`'The Escape'` 的长度为 10。因此外循环有 10 次迭代。每次迭代时，内循环都会有
    10 次迭代。因此内循环一共会有 10*10 = 100 次迭代。
- en: Solving the Problem
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: 'Back to Three Cups. The structure we need is a `for` loop to go through each
    swap, and a nested `if` statement to keep track of where the ball is:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 回到三杯问题。我们需要的结构是一个 `for` 循环遍历每个交换，并嵌套一个 `if` 语句来跟踪球的位置：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There are three types of swaps (A, B, and C) and three possible locations for
    the ball, so it’s tempting to conclude that we have to write an `if` statement
    with 3 * 3 = 9 Boolean expressions (one after the `if` and one after each of eight
    `elif`s). In fact, we need only six Boolean expressions. Three of the nine don’t
    move the ball at all: swap type A when the ball is at the right, swap type B when
    the ball is at the left, and swap type C when the ball is at the middle.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种类型的交换（A、B 和 C）和三种可能的位置，因此我们可能会得出结论，必须编写一个包含 3 * 3 = 9 个布尔表达式的 `if` 语句（一个在
    `if` 后面，另外八个在每个 `elif` 后面）。实际上，我们只需要六个布尔表达式。九个表达式中有三个根本不移动球：当球在右侧时交换类型 A，当球在左侧时交换类型
    B，当球在中间时交换类型 C。
- en: '[Listing 3-1](ch03.xhtml#ch03ex01) has a solution to Three Cups.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-1](ch03.xhtml#ch03ex01) 提供了三杯问题的解决方案。'
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 3-1: Solving Three Cups*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-1：解决三杯问题*'
- en: I’ve used `input` to assign the string of swaps to the `swaps` variable. The
    `for` loop ❶ loops through these swaps. Each swap is processed by the nested `if`
    statement ❷. The `if` and `elif` branches each encode what happens with a given
    type of swap and a given ball location and then move the ball accordingly. For
    example, if the swap type is `A` and the ball is at location 1 ❷, then the ball
    ends up at location 2 ❸.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 `input` 将交换字符串赋值给 `swaps` 变量。`for` 循环❶遍历这些交换。每个交换都由嵌套的 `if` 语句 ❷ 处理。`if`
    和 `elif` 分支分别编码了给定交换类型和给定球位置时发生的情况，并根据情况移动球。例如，如果交换类型是 `A` 且球的位置是 1 ❷，则球最终会到达位置
    2 ❸。
- en: This is a code example where it matters whether we use multiple `elif`s (one
    big `if` statement) or multiple `if`s (multiple `if` statements). If we change
    the `elif`s to `if`s, then our code is no longer correct. [Listing 3-2](ch03.xhtml#ch03ex02)
    shows the incorrect code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个代码示例，展示了我们使用多个 `elif`（一个大的 `if` 语句）或多个 `if`（多个 `if` 语句）时的区别。如果我们将 `elif`
    改为 `if`，那么我们的代码就不再正确了。[列表 3-2](ch03.xhtml#ch03ex02) 显示了错误的代码。
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 3-2: Solving Three Cups incorrectly*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-2：错误地解决三杯问题*'
- en: If we say that the code is incorrect, we’re claiming that it fails at least
    one test case. Can you find a test case where this code produces the wrong answer?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们说代码不正确，那么我们声称它至少在一个测试用例中失败了。你能找到一个测试用例，其中这个代码输出了错误的答案吗？
- en: 'Here’s one such test case:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个这样的测试用例：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It may make sense to us that the ball can move at most once per swap. But Python
    robotically runs the code you have written, whether it matches what we expect
    or not. In this case, we have only one swap, so the ball should move at most once.
    On the first and only iteration of the `for` loop, Python checks the expression
    ❶. It’s `True`, so Python sets `ball_location` to `2`. Then, Python checks the
    expression ❷. Because we just changed `ball_location` to `2`, this expression
    is `True`! Python therefore sets `ball_location` to `1`. The output of the program
    is `1` when it should be `2`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能认为球每次交换最多只能移动一次。但Python会机械地执行你编写的代码，无论它是否符合我们的预期。在这种情况下，我们只有一次交换，所以球最多应移动一次。在`for`循环的第一次也是唯一一次迭代中，Python检查表达式❶。它为`True`，因此Python将`ball_location`设置为`2`。然后，Python检查表达式❷。因为我们刚刚将`ball_location`设置为`2`，这个表达式也为`True`！因此，Python将`ball_location`设置为`1`。程序的输出是`1`，而它应该是`2`。
- en: 'This is an example of a *logic error*: an error that causes a program to follow
    the wrong logic and produce the wrong answer. A common term for logic error is
    a *bug*. When programmers work through their code to fix bugs, it’s called *debugging*.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个*逻辑错误*的例子：导致程序遵循错误逻辑并产生错误答案的错误。逻辑错误的常见术语是*bug*。当程序员修复代码中的bug时，这个过程称为*调试*。
- en: It often takes only a simple test case to demonstrate when a program is incorrect.
    When you’re trying to narrow down what’s going wrong with your code, don’t start
    with long test cases. Such test case results are hard to verify by hand and often
    set in motion complex execution paths from which we may learn very little. A small
    test case, by contrast, doesn’t cause our program to do much; if what it does
    is wrong, then we don’t have far to look for the culprit. Devising small, targeted
    test cases is not always easy. It’s a skill that you can hone through practice.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通常只需要一个简单的测试用例，就能演示程序何时不正确。当你试图缩小问题范围时，不要从长的测试用例开始。这类测试用例的结果很难手动验证，并且常常会触发复杂的执行路径，我们可能从中学到的东西很少。相反，一个小的测试用例不会让程序做太多事；如果它做的事情是错误的，那么我们查找错误的范围就不大了。设计小而有针对性的测试用例并不总是容易的。这是一个可以通过练习来磨练的技能。
- en: Submit our correct code to the judge, and then let’s move on.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 提交我们正确的代码给评测系统，然后继续。
- en: Before continuing, you might like to try solving exercises 1 and 2 from “Chapter
    Exercises” on [page 67](ch03.xhtml#ch03lev1sec16).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你可以尝试解决“章节练习”中第1和第2题，见[第67页](ch03.xhtml#ch03lev1sec16)。
- en: 'Problem #6: Occupied Spaces'
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #6：占用的停车位'
- en: We know how to loop through the characters of a string. But sometimes we need
    to know where we are in the string, not just the character that’s stored there.
    This problem is one such example.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何遍历字符串的字符。但有时我们需要知道在字符串中的位置，而不仅仅是存储在那里字符。这就是一个这样的例子。
- en: This is DMOJ problem `ccc18j2`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题`ccc18j2`。
- en: The Challenge
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: You supervise a parking lot with *n* parking spaces. Yesterday, you recorded
    whether each parking space was occupied by a car or was empty. Today, you again
    recorded whether each parking space was occupied by a car or was empty. Indicate
    the number of parking spaces that were occupied on both days.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你管理一个有*n*个停车位的停车场。昨天，你记录了每个停车位是否被车占用，或者是空的。今天，你再次记录了每个停车位是否被车占用，或者是空的。请指出在两个日期中都被占用的停车位数量。
- en: Input
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: The input consists of three lines.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 输入由三行组成。
- en: The first line contains integer *n*, the number of parking spaces. *n* is between
    1 and 100.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行包含整数*n*，表示停车位的数量。*n*的范围是1到100之间。
- en: The second line contains a string of *n* characters for yesterday’s information,
    one character for each parking space. A `C` indicates an occupied parking space
    (C for car), and a `.` indicates an empty parking space. For example, `CC.` means
    that the first two parking spaces were occupied and the third was empty.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行包含一个长度为*n*的字符串，表示昨天的信息，每个字符对应一个停车位。`C`表示占用的停车位（C代表车），`.`表示空的停车位。例如，`CC.`表示前两个停车位被占用，第三个停车位为空。
- en: The third line contains a string of *n* characters for today’s information,
    in the same format as the second line.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行包含一个长度为*n*的字符串，表示今天的信息，格式与第二行相同。
- en: Output
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Output the number of parking spaces that were occupied on both days.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 输出两个日期中被占用的停车位数量。
- en: A New Kind of Loop
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一种新的循环方式
- en: 'We could have up to 100 parking spaces, so you may not be surprised that a
    loop will show up here somewhere. The kind of `for` loop we learned when solving
    Three Cups can certainly loop through a string of parking-space information:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最多可以有 100 个停车位，所以你可能不会惊讶地发现这里会有一个循环。我们在解决“三杯问题”时学到的那种 `for` 循环当然可以遍历停车位信息的字符串：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That tells us whether each space was occupied yesterday. But we also need to
    know whether each space was also occupied today.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们每个停车位昨天是否被占用。但我们还需要知道每个停车位今天是否也被占用。
- en: 'Consider this test case:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个测试用例：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first parking space was occupied yesterday. Was that parking space occupied
    on both days? To answer that, we need to look at the corresponding character in
    today’s string. It’s a `.` (empty), so this parking space was not occupied on
    both days.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个停车位昨天被占用了。那个停车位在两天都有被占用吗？为了回答这个问题，我们需要查看今天字符串中对应的字符。它是一个 `.`（空的），所以这个停车位并没有在两天都被占用。
- en: What about the second parking space? That one was also occupied yesterday. And,
    looking at the second character of today’s string, it was also occupied today.
    So this *is* a parking space that was occupied on both days. (This is the only
    such parking space; the correct output for this test case is `1`.)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 那么第二个停车位呢？那个昨天也被占用了。而且，看看今天字符串中的第二个字符，今天它也被占用了。所以这个*确实*是一个在两天都被占用的停车位。（这是唯一一个这样的停车位；该测试用例的正确输出是`1`。）
- en: Looping through the characters of one string doesn’t help us find the corresponding
    characters in the other string. But if we could keep track of where we were in
    the string—we’re at the first parking space, we’re at the second parking space,
    and so on—we could look up the corresponding character from each string. The `for`
    loops we’ve learned so far are not the way to do this. The way to do this is using
    indexing and a new type of `for` loop.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历一个字符串中的字符并不能帮助我们找到另一个字符串中对应的字符。但如果我们能够追踪我们在字符串中的位置——我们在第一个停车位，我们在第二个停车位，依此类推——我们就可以查找每个字符串中的对应字符。到目前为止我们学过的
    `for` 循环并不是这种操作的方式。正确的方式是使用索引和一种新的 `for` 循环。
- en: Indexing
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引
- en: Each character in a string has an *index*, which indicates its location. The
    first character is at index 0, the second character is at index 1, and so on.
    In natural language, we often start counting at 1\. In English, no one says “the
    character at position 0 of *hello* is *h*.” But most programming languages, Python
    included, start at 0.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串中的每个字符都有一个*索引*，它表示字符的位置。第一个字符的索引是 0，第二个字符的索引是 1，以此类推。在自然语言中，我们通常从 1 开始计数。在英语中，没有人会说“*hello*
    中位置 0 的字符是 *h*。”但大多数编程语言，包括 Python，都从 0 开始计数。
- en: 'To use indexing, we follow a string by an index in square brackets. Here are
    some examples of indexing:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用索引，我们在字符串后面加上方括号中的索引。以下是一些索引的示例：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If we like, we can use variables in an index:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，可以在索引中使用变量：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The highest index that we can use on a nonempty string is its length minus
    1\. (There is no valid index for an empty string.) For example, `''splore''` is
    length 6, so index 5 is its highest index. Any bigger and we get an error:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在非空字符串上可以使用的最高索引是其长度减去 1。（空字符串没有有效的索引。）例如，`'splore'`的长度是 6，因此索引 5 是它的最高索引。再大就会报错：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'How can we access the second character from the right of a string? This will
    do it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如何访问字符串从右数的第二个字符呢？这样就可以做到：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'But there’s an easier way. Python supports negative indices as another option
    for accessing characters. Index `-1` is the rightmost character, index `-2` is
    the second character from the right, and so on:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一个更简单的方法。Python 支持负数索引作为访问字符的另一种选项。索引`-1`表示最右边的字符，索引`-2`表示从右数第二个字符，以此类推：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The plan is to use indexing to access corresponding positions of yesterday’s
    and today’s parking information. We can use index 0 of each string to access information
    about the first parking space, index 1 to access information about the second
    parking space, and so on. But before we can carry out that plan, we need to learn
    a new kind of `for` loop.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 计划是使用索引来访问昨天和今天停车信息的对应位置。我们可以使用每个字符串的索引 0 来访问第一个停车位的信息，索引 1 来访问第二个停车位的信息，依此类推。但在我们可以实施这个计划之前，我们需要学习一种新的
    `for` 循环。
- en: '**CONCEPT CHECK**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: What is the output of the following code?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A. `aaa`
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: A. `aaa`
- en: B. `aae`
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: B. `aae`
- en: C. `aee`
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: C. `aee`
- en: D. This code produces an error
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: D. 这段代码会产生错误
- en: 'Answer: A. Each of the three indices refers to the first character in `''abcde''`.
    First, `s[0]` refers to `''a''` because `''a''` is at index 0 of the string. Second,
    `s[-5]` refers to `''a''` because `''a''` is the fifth character from the right.
    Third, `s[len(s) - 5]` refers to `''a''` because the index evaluates to 0: 5 (the
    length of the string) minus 5.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：A. 三个索引中的每一个都指向 `'abcde'` 中的第一个字符。首先，`s[0]` 指向 `'a'`，因为 `'a'` 在字符串中的索引是 0。其次，`s[-5]`
    指向 `'a'`，因为 `'a'` 是从右数第五个字符。第三，`s[len(s) - 5]` 指向 `'a'`，因为索引计算结果为 0：5（字符串的长度）减去
    5。
- en: Range for loops
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 范围循环
- en: 'Python’s `range` function generates ranges of integers, and we can use those
    ranges to control `for` loops. Rather than looping through the characters of a
    string, a range `for` loop loops through integers. If we provide one argument
    to `range`, we get a range from 0 to 1 less than that argument:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `range` 函数生成整数范围，我们可以使用这些范围来控制 `for` 循环。与其循环遍历字符串的字符，不如使用范围 `for` 循环来遍历整数。如果我们向
    `range` 提供一个参数，我们将得到一个从 0 到比该参数小 1 的范围：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that `5` is not output.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`5` 没有被输出。
- en: 'If we provide two arguments to `range`, we get a sequence from the first argument
    up to but not including the second argument:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向 `range` 提供两个参数，我们将得到一个从第一个参数到但不包括第二个参数的序列：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can count up by a different *step size* by including a third argument. The
    default step size is `1`, which counts up by one. Let’s try a couple of other
    step sizes:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过包含第三个参数来按不同的 *步长* 递增。默认的步长是 `1`，即每次递增 1。让我们试试其他几个步长：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can count backward, too, but *not* like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以倒数，但 *不是*这样：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'That doesn’t work, because by default `range` counts up. A step size of `-1`
    lets us go backward, one at a time:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这样行不通，因为默认情况下，`range` 是递增的。步长为 `-1` 让我们可以逐步递减：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To count down from `6` to `0`, including `0`, we need a value of `-1` for the
    second argument:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 `6` 递减到 `0`（包括 0），我们需要将第二个参数设置为 `-1`：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It’s sometimes helpful to quickly look at the numbers in a range without coding
    a loop. Unfortunately, the `range` function doesn’t directly show us those numbers:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有时快速查看范围中的数字而不编写循环是很有帮助的。不幸的是，`range` 函数并不会直接显示这些数字：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can pass that result to the `list` function to get what we want:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将该结果传递给 `list` 函数来获取我们想要的结果：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When called with a range, the `list` function produces a list of the range’s
    integers. We’ll learn all about lists later; for now, keep `list` in mind as an
    aid to diagnosing errors with ranges.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当与范围一起调用时，`list` 函数会生成一个包含该范围内整数的列表。我们稍后会详细学习列表；现在，请将 `list` 保留在脑海中，作为诊断范围错误的辅助工具。
- en: '**CONCEPT CHECK**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**概念检查**'
- en: How many iterations are performed by the following loop?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下循环执行了多少次迭代？
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: A. 9
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: A. 9
- en: B. 10
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: B. 10
- en: C. 11
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: C. 11
- en: D. 20
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: D. 20
- en: 'Answer: B. The range goes through the numbers 10, 11, 12, 13, 14, 15, 16, 17,
    18, and 19\. There are 10 numbers and hence 10 iterations.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：B. 范围遍历了数字 10、11、12、13、14、15、16、17、18 和 19，共有 10 个数字，因此执行了 10 次迭代。
- en: Range for Loops Through Indices
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过索引的范围循环
- en: 'Suppose we have strings giving yesterday’s and today’s parking-space information:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有表示昨天和今天停车位信息的字符串：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Given an index, we can look at yesterday’s and today’s information for that
    index:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个索引，我们可以查看昨天和今天的该索引信息：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can use a range `for` loop through the indices to process each pair of corresponding
    characters. We know that `yesterday` and `today` are the same length. But that
    length could be anything from 1 to 100, so we can’t write something like `range(3)`.
    We want to iterate with indices 0, 1, 2, and so on, all the way up to the length
    of the string minus 1\. We can do that by using the length of one of the strings
    as the argument to `range`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过索引使用范围 `for` 循环来处理每一对对应的字符。我们知道 `yesterday` 和 `today` 的长度是相同的。但是这个长度可以是从
    1 到 100 之间的任何值，所以我们不能写类似 `range(3)` 的东西。我们想要的迭代索引是 0、1、2，依此类推，一直到字符串长度减去 1。我们可以通过使用其中一个字符串的长度作为
    `range` 的参数来实现：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: I’ve called the loop variable `index`. Other popular names include `i` (the
    first letter of `index`) and `ind`. I’ll use `i` from here on out.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将循环变量命名为 `index`。其他常用的名称包括 `i`（`index` 的首字母）和 `ind`。从现在起，我将使用 `i`。
- en: Don’t call this loop variable `status` or `information`. Those names imply that
    it takes on `'C'` and `'.'` values, when really it takes on integers.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将这个循环变量命名为 `status` 或 `information`。这些名称暗示它取值 `'C'` 和 `'.'`，而实际上它取值的是整数。
- en: Solving the Problem
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: With our range `for` loops, we’re ready to solve Occupied Spaces. Our strategy
    is to loop through each index from the beginning of the strings to the end. We
    can check what’s at each index in both yesterday’s information and today’s information.
    Using a nested `if` statement, we’ll determine whether the parking space was occupied
    on both days.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的 `for` 循环，我们准备好解决占用空间问题。我们的策略是从字符串的开头循环到结尾。我们可以检查每个索引在昨天和今天的停车位信息中对应的内容。使用嵌套的
    `if` 语句，我们将判断该停车位在两天内是否都被占用。
- en: '[Listing 3-3](ch03.xhtml#ch03ex03) has our solution.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-3](ch03.xhtml#ch03ex03) 是我们的解决方案。'
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 3-3: Solving Occupied Spaces*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-3：解决占用空间问题*'
- en: 'The program starts by reading the three lines of input: `n` refers to the number
    of parking spaces; and `yesterday` and `today` refer to yesterday’s and today’s
    parking-space information, respectively.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 程序首先读取三行输入：`n` 表示停车位数量；`yesterday` 和 `today` 分别表示昨天和今天的停车位信息。
- en: Notice that we don’t refer to the number of parking spaces (`n`) again. We could
    make use of it to tell us the length of the strings, but I’ve chosen to ignore
    it because it’s often not provided in real-life scenarios.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有再次提到停车位的数量（`n`）。我们本可以利用它来告诉我们字符串的长度，但我选择忽略它，因为在实际情况中它通常没有提供。
- en: We use the `occupied` variable to count the number of parking spaces that were
    occupied both yesterday and today. We start that variable off at `0` ❶.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `occupied` 变量来统计昨天和今天都被占用的停车位数量。我们将这个变量初始化为 `0` ❶。
- en: Now we reach the range `for` loop, which loops through the valid indices of
    `yesterday` and `today` ❷. For each such index, we check whether the parking space
    was occupied yesterday and occupied today ❸. If it was, then we include this parking
    space in our total by increasing `occupied` by `1` ❹.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们进入 `for` 循环，循环遍历 `yesterday` 和 `today` 的有效索引 ❷。对于每个这样的索引，我们检查该停车位是否在昨天和今天都被占用
    ❸。如果是，那么我们通过将 `occupied` 增加 `1` 来把这个停车位计入总数 ❹。
- en: When the range `for` loop terminates, we’ll have gone through all parking spaces.
    The total number of parking spaces that were occupied yesterday and today can
    be accessed through the `occupied` variable. All that’s left is to output that
    total.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `for` 循环结束时，我们将已经遍历了所有停车位。昨天和今天被占用的停车位总数可以通过 `occupied` 变量来访问。剩下的就是输出这个总数。
- en: That’ll do it for this problem. Time to submit your code to the judge.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本题的解决方法。现在是时候将你的代码提交给评测系统了。
- en: 'Problem #7: Data Plan'
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '问题 #7：数据计划'
- en: We’ve learned that `for` loops are useful for processing data after we’ve read
    it from the input. They’re also often useful for reading the data itself. In this
    problem, we’ll tackle data that’s spread over many lines and use a `for` loop
    to help us read it all.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了 `for` 循环对于处理从输入读取的数据非常有用。它们通常也非常适合用于读取数据本身。在这个问题中，我们将处理分布在多行的数据，并使用
    `for` 循环帮助我们读取所有数据。
- en: This is DMOJ problem `coci16c1p1`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 DMOJ 问题 `coci16c1p1`。
- en: The Challenge
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战
- en: Pero has a data plan with his cell phone provider that offers him *x* megabytes
    of data per month. In addition, any data he doesn’t use in a given month carries
    over to the next month. For example, if *x* is 10 and Pero uses only 4MB in a
    given month, the remaining 6MB carry over to the next month (in which he’d now
    have 10 + 6 = 16MB available).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Pero 与他的手机服务商有一个数据计划，每月提供 *x* 兆字节的数据。此外，任何未使用的数据会转到下个月。例如，如果 *x* 是 10 而 Pero
    只使用了 4MB，那么剩余的 6MB 将会转到下个月（那时他将有 10 + 6 = 16MB 可用）。
- en: We’re given the number of megabytes of data that Pero uses in each of the first
    *n* months. Our task is to determine the number of megabytes available for the
    following month.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给定了 Pero 在前 *n* 个月中每个月使用的兆字节数据。我们的任务是确定下个月可用的数据量。
- en: Input
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入
- en: 'The input consists of the following lines:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含以下几行：
- en: A line containing integer *x*, the number of megabytes given to Pero per month.
    *x* is between 1 and 100.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含整数 *x*，表示 Pero 每月获得的兆字节数。*x* 在 1 到 100 之间。
- en: A line containing integer *n*, the number of months that Pero has had the data
    plan. *n* is between 1 and 100.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行包含整数 *n*，表示 Pero 拥有数据计划的月数。*n* 在 1 到 100 之间。
- en: '*n* lines, one for each month, giving the integer number of megabytes that
    Pero uses in that month. Each number is at least 0 and will never outstrip the
    number of available megabytes. (For example, if *x* is 10 and Pero currently has
    30MB available, the next number will be at most 30.)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* 行，每行代表 Pero 在那个月使用的兆字节数。每个数字至少为 0，并且永远不会超过可用的兆字节数。（例如，如果 *x* 是 10，且 Pero
    当前有 30MB 可用，那么下一个数字最多为 30。）'
- en: Output
  id: totrans-200
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输出
- en: Output the number of megabytes available for the next month.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 输出下个月可用的兆字节数。
- en: Looping to Read Input
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环读取输入
- en: In all of our problems so far, we’ve known exactly how many lines to read from
    the input. For example, in Three Cups, we read one line; in Occupied Spaces, we
    read three lines. Here in Data Plan, we don’t know in advance how many lines to
    read, because it depends on the number that we read from the second line.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们至今处理的所有问题中，我们都确切知道需要从输入中读取多少行。例如，在“三个杯子”问题中，我们读取了一行；在“被占用的空间”问题中，我们读取了三行。在数据计划问题中，我们无法提前知道需要读取多少行，因为这取决于我们从第二行读取的数字。
- en: 'We can read the first line of input:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以读取第一行的输入：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: (I’ve used variable name `monthly_mb` rather than `x` to imbue it with some
    meaning.)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: （我用了变量名 `monthly_mb`，而不是 `x`，以便赋予它一些意义。）
- en: 'And we can read the second line of input:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以读取第二行的输入：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'But we can’t read any more without a loop. A range `for` loop is perfect here,
    because we can use it to loop exactly `n` times:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不能不使用循环而继续读取。一个 `for` 循环在这里非常合适，因为我们可以用它循环读取恰好 `n` 次：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Solving the Problem
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解题过程
- en: My strategy for solving the problem is to keep track of the number of megabytes
    that are carried over from previous months. I call this the *excess*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我解决问题的策略是追踪从前几个月结转过来的兆字节数。我称之为 *结转*。
- en: 'Consider this test case:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个测试用例：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In each month, Pero is given 10MB of data, and we have to process the data that
    he used in the provided three months. In the first month, Pero is given 10MB and
    uses 4MB, so the excess that carries forward is 6MB. In the second month, Pero
    is given 10MB more, so now he has 16MB total. He uses 12MB this month, so the
    excess that carries forward is 16 – 12 = 4MB. In the third month, Pero is given
    10MB more, so now he has 14MB total. He uses 1MB this month, so the excess that
    carries forward is 14 – 1 = 13MB.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 每个月，Pero 会得到 10MB 的数据，我们需要处理他在提供的三个月内使用的数据。在第一个月，Pero 得到 10MB 并使用了 4MB，因此结转的剩余数据为
    6MB。第二个月，Pero 又得到 10MB，总共有 16MB。他这月使用了 12MB，因此结转的剩余数据为 16 - 12 = 4MB。第三个月，Pero
    再得到 10MB，总共有 14MB。他这月使用了 1MB，因此结转的剩余数据为 14 - 1 = 13MB。
- en: We need to know the number of megabytes that Pero has available for the next
    (that is, fourth) month. He has 13MB that carry over from the first three months,
    and he’s given his usual 10MB for this month, so he has a total of 13 + 10 = 23MB
    to use.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要知道 Pero 下个月（即第四个月）可用的兆字节数。他有 13MB 的结转数据，再加上本月常规的 10MB，因此他总共有 13 + 10 = 23MB
    可用。
- en: When I went to write the code based on this explanation, I neglected to add
    this final 10, so my output was 13 instead of 23\. I was focusing exclusively
    on the excess and forgot that what we need is not the excess going into the next
    month, but the total number of megabytes available. That total is the excess plus
    whatever Pero is given per month.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当我根据这个解释编写代码时，我忘记加上最后的 10，所以输出是 13，而不是 23。我专注于结转数据，忘记了我们需要的不是进入下个月的结转数据，而是可用的总兆字节数。总数应该是结转数据加上每个月给予的
    10MB。
- en: See [Listing 3-4](ch03.xhtml#ch03ex04) for the (corrected!) code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [清单 3-4](ch03.xhtml#ch03ex04) 查看（修正过的！）代码。
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '*Listing 3-4: Solving Data Plan*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-4：解决数据计划*'
- en: The `excess` variable begins at `0`. On each iteration of the range `for` loop,
    we assign a value to `excess` that considers the number of megabytes given per
    month and the number of megabytes used in that month.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`excess` 变量初始化为 `0`。在每次 `for` 循环迭代中，我们根据每个月给定的兆字节数和该月使用的兆字节数来更新 `excess`。'
- en: The range `for` loop loops `n` times, once for each month that Pero has had
    the data plan ❶. The values that `i` takes on—`0`, `1`, and so on—aren’t of interest
    to us, because we have no reason to care about which month we’re processing. For
    that reason, we don’t use the value of `i` anywhere in the program. You can replace
    `i` with `_` (an underscore) to be explicit about the variable’s “don’t care”
    status, but I’ll leave it as `i` for consistency with other examples.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环会循环 `n` 次，每次对应 Pero 使用数据计划的每个月 ❶。`i` 的值——`0`、`1` 等等——我们并不关心，因为我们不需要关心我们正在处理的是哪个月。因此，我们在程序中并没有使用
    `i` 的值。你可以将 `i` 替换成 `_`（下划线），以明确表示该变量的“无关”状态，但为了与其他示例保持一致，我会保留 `i`。'
- en: 'In the range `for` loop, we read the number of megabytes used in this month.
    Then, we update the number of excess megabytes ❷: it’s what it was before, plus
    the number of megabytes that Pero gets per month, minus the number of megabytes
    that Pero uses this month.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for` 循环中，我们读取本月使用的兆字节数。然后，我们更新剩余的多余兆字节数 ❷：它等于之前的值，再加上 Pero 每月获得的兆字节数，减去 Pero
    本月使用的兆字节数。
- en: Having computed the excess number of megabytes after `n` months, we report the
    number of megabytes available for the next month ❸.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 计算出 `n` 个月后剩余的多余兆字节数，我们报告下个月可用的兆字节数 ❸。
- en: 'There are always multiple ways to solve a problem. Programming is creative,
    and I enjoy observing the range of solution strategies that people come up with.
    Even if you’ve succeeded in solving a problem, you might like to Google the problem
    to learn from how others have solved it. In addition, some online judges, like
    DMOJ, allow you to view other people’s submissions once you’ve solved the problem.
    For submissions that pass all of the test cases: did those programmers do things
    differently from you? For submissions that fail some test cases: what’s wrong
    with the code? Reading other people’s code is a great way to improve your own
    programming skill!'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 解决问题的方式总是有多种。编程是创造性的，我喜欢观察人们提出的各种解决策略。即使你已经成功解决了问题，你也可以通过 Google 查找该问题，了解其他人是如何解决的。另外，一些在线评测平台，比如
    DMOJ，允许你在解决问题后查看其他人的提交。对于通过所有测试用例的提交：那些程序员是否做了不同的处理？对于某些测试用例失败的提交：代码出了什么问题？阅读他人的代码是提高自己编程技能的好方法！
- en: Can you think of another way to solve Data Plan?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到另一种解决数据计划问题的方法吗？
- en: 'Here’s a hint: you can start by calculating the total number of megabytes that
    Pero is given and then subtracting the number of megabytes that he uses. I encourage
    you to take some time to work out how to do this before continuing!'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有个提示：你可以先计算 Pero 获得的总兆字节数，然后减去他使用的兆字节数。我鼓励你在继续之前，花点时间想想如何做这道题！
- en: The total number of megabytes given to Pero, including those given in the next
    month, is *x* * (*n* + 1), where *x* is the number of megabytes given per month.
    To determine the number of megabytes available for the next month, we can start
    with that total and subtract what Pero uses each month. That strategy is coded
    in [Listing 3-5](ch03.xhtml#ch03ex05).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 给 Pero 的总兆字节数，包括下个月的，是 *x* * (*n* + 1)，其中 *x* 是每月分配的兆字节数。为了确定下个月可用的兆字节数，我们可以从这个总数开始，减去
    Pero 每月使用的兆字节数。这个策略在 [列表 3-5](ch03.xhtml#ch03ex05) 中有代码实现。
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '*Listing 3-5: Solving Data Plan, alternate approach*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-5：解决数据计划，另一种方法*'
- en: Choose whichever solution is your favorite, and submit to the judge.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 选择你最喜欢的解法，并提交给评测系统。
- en: What’s intuitive to one person may not be intuitive to another. You might read
    an explanation or code and not be able to make sense of it. This doesn’t mean
    that you’re not smart enough. It just means you need a different presentation,
    one that aligns more closely to your current thinking. You might also flag difficult
    explanations and examples for later review. They may prove to be surprisingly
    useful once you’ve gained further practice.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对一个人来说直观的东西，对另一个人可能不直观。你可能会读到某个解释或代码，完全无法理解。这并不意味着你不够聪明，而是意味着你需要一种不同的展示方式，更贴近你当前的思维方式。你还可以标记那些难懂的解释和例子，留待以后复习。一旦你积累了更多的实践，它们可能会出乎意料地变得有用。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about `for` loops. Standard `for` loops loop through
    the characters of a sequence; range `for` loops loop through integers in a range.
    Each problem that we solved required us to process many pieces of input, and we
    wouldn’t have been able to manage that without a loop.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 `for` 循环。标准的 `for` 循环用于遍历一个序列中的字符；范围 `for` 循环用于遍历一个范围内的整数。我们解决的每一个问题都需要处理许多输入，如果没有循环，我们是无法完成这些操作的。
- en: 'The `for` loop is the loop of choice whenever you need to repeat code a specified
    number of times. Python has one other type of loop, and we’ll learn how to use
    it in the next chapter. Why do we need anything besides `for` loops? What can’t
    `for` loops do? Good questions! I’ll tell you this for now: practicing with `for`
    loops is a wonderful way to prepare for what’s to come.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环是当你需要重复执行指定次数的代码时的首选循环。Python 还有另一种类型的循环，我们将在下一章学习如何使用它。为什么除了 `for`
    循环之外，我们还需要其他的循环？`for` 循环做不了什么呢？好问题！现在告诉你的是：练习 `for` 循环是为接下来的内容做准备的一个绝佳方式。'
- en: Chapter Exercises
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 章节习题
- en: Here are some exercises for you to try.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些习题供你尝试。
- en: DMOJ problem `wc17c3j3`, Uncrackable
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `wc17c3j3`，无法破解
- en: DMOJ problem `coci18c3p1`, Magnus
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `coci18c3p1`，Magnus
- en: DMOJ problem `ccc11s1`, English or French
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `ccc11s1`，英语或法语
- en: DMOJ problem `ccc11s2`, Multiple Choice
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `ccc11s2`，选择题
- en: DMOJ problem `coci12c5p1`, Ljestvica
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `coci12c5p1`，Ljestvica
- en: DMOJ problem `coci13c3p1`, Rijeci
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `coci13c3p1`，Rijeci
- en: DMOJ problem `coci18c4p1`, Elder
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DMOJ 问题 `coci18c4p1`，Elder
- en: Notes
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Three Cups is originally from the 2006/2007 Croatian Open Competition in Informatics,
    Contest 5\. Occupied Spaces is originally from the 2018 Canadian Computing Competition,
    Junior Level. Data Plan is originally from the 2016/2017 Croatian Open Competition
    in Informatics, Contest 1.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: “三杯”最初出自 2006/2007 年克罗地亚信息学公开赛，第 5 题。占用空间最初出自 2018 年加拿大计算机竞赛，初级组。数据计划最初出自 2016/2017
    年克罗地亚信息学公开赛，第 1 题。
