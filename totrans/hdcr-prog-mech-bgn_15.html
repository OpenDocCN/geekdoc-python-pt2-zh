<html><head></head><body>
<h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_307"/><span class="big">12</span><br/>ANIMATING AFFINE TRANSFORMATIONS</h2>&#13;
<div class="image1"><img src="../images/common01.jpg" alt="Image"/></div>&#13;
<p class="noindent">You just learned the basics of animation and GUI design. In this chapter, we’ll combine the two and build an application that animates affine transformations. This will help build your visual intuition for this potentially confusing topic and strengthen your programming skills.</p>&#13;
<p class="indent">The application will first read a text file defining the affine transformation and the geometries to transform. Then, it’ll compute a sequence of affine transformations, interpolating from the identity to the given transformation. Each of the transformations in this sequence will be used to draw a frame of the animation.</p>&#13;
<p class="indent">As with the circle building application we built in <a href="ch09.xhtml#ch09">Chapter 9</a>, we’ll use regular expressions to read the primitives from the text file. We’ll be using some more advanced ones here, which we’ll analyze in detail. There will be a lot of code in this chapter. We’re building a larger application, and it’s a great opportunity to learn about how to distribute responsibilities in your code.</p>&#13;
<p class="indent">As always, we’ll try to keep the architecture and design as clean as possible, explaining the reasoning behind each decision we encounter. Let’s get started!</p>&#13;
<h3 class="h3" id="ch00lev1sec72"><span epub:type="pagebreak" id="page_308"/><strong>Application Architecture and Visibility Diagrams</strong></h3>&#13;
<p class="noindent">To discuss this application’s architecture, we’ll introduce a new kind of diagram: a <em>visibility diagram</em>. Visibility diagrams display the components of an application using arrows to indicate what each part of the program knows—in other words, who can see whom. Take a look at the diagram from <a href="ch12.xhtml#ch12fig1">Figure 12-1</a>.</p>&#13;
<div class="image"><img src="../images/12fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch12fig1"><em>Figure 12-1: Our application architecture</em></p>&#13;
<p class="indent">At the top of the diagram is <em>Main</em>, the executing script. The circle around it signifies that it’s the entry point to the application. There are three arrows starting from <em>Main</em>, which means <em>Main</em> knows about three other modules: <em>Config</em>, <em>Input</em>, and <em>Simulation</em>. Modules are represented with rectangles.</p>&#13;
<p class="indent">Note the arrows go one way. <em>Main</em> knows these modules exist, and depends on them, but these modules know nothing about the existence of <em>Main</em>. This is critical: we want to minimize what the components of our application know about each other. This ensures the modules are as <em>decoupled</em> as possible, meaning that they can live on their own.</p>&#13;
<p class="indent">The benefits of a decoupled design are mainly simplicity, which allows us to easily grow and maintain our software, and reusability. The fewer dependencies a module has, the easier it is to use it somewhere else.</p>&#13;
<p class="indent">Going back to the diagram in <a href="ch12.xhtml#ch12fig1">Figure 12-1</a>, we said that <em>Main</em> uses three modules: <em>Config</em>, <em>Input</em>, and <em>Simulation</em>. The <em>Config</em> module will be in charge of loading the configuration for the application stored in <em>config.json</em>—indicated by the arrow.</p>&#13;
<p class="indent">The <em>Input</em> module will read the input file given by the user and define both an affine transformation and geometric primitives. Thus, this module will use two more modules: <em>Geometry</em>, to parse the primitives, and <em>Transformation</em>, to parse the affine transformation. Again, the fact that the arrows go from <em>Input</em> toward the other two modules means these other two modules have no clue about <em>Input</em>: they could be used perfectly by another module.</p>&#13;
<p class="indent">Lastly, we have the <em>Simulation</em> module, which will be in charge of performing the actual simulation.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_309"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>I can’t stress the importance of decoupled architectures enough. Applications should be made of small submodules that expose a straightforward, concise interface and hide their inner working from the rest of the world. These modules are simpler to maintain when they have as few dependencies of their own as possible. Applications that don’t respect this simple principle end up doomed more often than not, and trust me when I say that you’ll feel hopeless when you fix a small bug in a module and it breaks some apparently unrelated piece of another module.</em></p>&#13;
</div>&#13;
<p class="indent">Let’s move on and set up the project.</p>&#13;
<h3 class="h3" id="ch00lev1sec73"><strong>Setting Up</strong></h3>&#13;
<p class="noindent">In the <em>apps</em> folder, create a new Python package named <em>aff_transf_motion</em>. In it, add all the files shown in the following tree. If you created the new package by right-clicking <em>apps</em> and choosing <strong>New</strong> ▸ <strong>Python Package</strong>, <em>__init__.py</em> will already be in the directory; the IDE created it for us. If you created the package in another way, don’t forget to add this file.</p>&#13;
<p class="pre2">    apps<br/>      |- aff_transf_motion<br/>           |- __init__.py<br/>           |- config.json<br/>           |- config.py<br/>           |- input.py<br/>           |- main.py<br/>           |- parse_geom.py<br/>           |- parse_transform.py<br/>           |- simulation.py<br/>           |- test.txt</p>&#13;
<p class="indent">All your files are empty for now, but we’ll be filling them with code soon.</p>&#13;
<p class="indent">Before we do that, though, we want to have a run configuration or bash script to run the project as we develop, just like we did in <a href="ch09.xhtml#ch09">Chapter 9</a>. We first need to define the script it will execute in <em>main.py</em>. For now, we’ll simply print a message to the shell to make sure things are working properly. Open the file and enter the code in <a href="ch12.xhtml#ch12lis1">Listing 12-1</a>.</p>&#13;
<pre>if __name__ == '__main__':&#13;
   print('Ready!')</pre>&#13;
<p class="caption"><a id="ch12lis1"/><em>Listing 12-1: Main file</em></p>&#13;
<p class="indent">Let’s now explore our two options for executing the project: a run configuration and a bash script. You don’t need to set up both; you can choose the one that works best for you and skip the other.</p>&#13;
<h4 class="h4" id="ch00lev2sec134"><span epub:type="pagebreak" id="page_310"/><strong><em>Creating a Run Configuration</em></strong></h4>&#13;
<p class="noindent">In the menu choose <strong>Run</strong> ▸ <strong>Edit Configurations</strong>. Click the <strong>+</strong> icon at the top left and choose <strong>Python</strong> to create the run configuration. Name it <em>aff-transf-motion</em>. Similar to what we did in <a href="ch09.xhtml#ch09">Chapter 9</a>, choose <em>main.py</em> as the script path and <em>aff_transform_motion</em> as the working directory. Lastly, check the <strong>Redirect input from</strong> option, and choose <em>test.txt</em>. Your configuration should look similar to <a href="ch12.xhtml#ch12fig2">Figure 12-2</a>.</p>&#13;
<div class="image"><img src="../images/12fig02.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch12fig2"><em>Figure 12-2: The run configuration</em></p>&#13;
<p class="indent">To make sure the run configuration is properly set up, choose it from the run configuration navigation bar and click the green play button. The shell should display the message <span class="literal">Ready!</span>. If you had any trouble setting this up, refer to <a href="ch09.xhtml#ch09">Chapter 9</a> where we covered this process in detail.</p>&#13;
<h4 class="h4" id="ch00lev2sec135"><strong><em>Creating a Bash Script</em></strong></h4>&#13;
<p class="noindent">To run the app from the command line, we’ll use the technique we explored in <a href="ch09.xhtml#ch09">Chapter 9</a>: creating a bash script wrapper that uses our project root as the workspace for Python to resolve our dependencies. Create a new file in the root of the project (under <em>Mechanics</em>): <em>aff_motion.sh</em>. In the file, enter the code in <a href="ch12.xhtml#ch12lis2">Listing 12-2</a>.<span epub:type="pagebreak" id="page_311"/></p>&#13;
<pre>#!/usr/bin/env bash&#13;
PYTHONPATH=$PWD python3 apps/aff_transf_motion/main.py</pre>&#13;
<p class="caption"><a id="ch12lis2"/><em>Listing 12-2: Bash script to execute the project</em></p>&#13;
<p class="indent">Using this bash script, we can now execute the application from the command line like so:</p>&#13;
<pre>$ <span class="codestrong1">bash ./aff_motion.sh &lt; apps/aff_transf_motion/test.txt</span></pre>&#13;
<p class="noindent">We can make this bash script executable:</p>&#13;
<pre>$ <span class="codestrong1">chmod +x aff_motion.sh</span></pre>&#13;
<p class="noindent">then run it like so:</p>&#13;
<pre>$ <span class="codestrong1">./aff_motion.sh &lt; apps/aff_transf_motion/test.txt</span></pre>&#13;
<h3 class="h3" id="ch00lev1sec74"><strong>Reading the Configuration File</strong></h3>&#13;
<p class="noindent">Because we want to separate configuration values from the code, we’ll keep them in a JSON file. This allows us to change the behavior of our application without needing to touch the code. Open <em>config.json</em> and enter the content in <a href="ch12.xhtml#ch12lis3">Listing 12-3</a>.</p>&#13;
<pre>{&#13;
  "frames": 200,&#13;
  "axes": {&#13;
    "length": 100,&#13;
    "arrow-length": 20,&#13;
    "arrow-height": 15,&#13;
    "stroke-width": 2,&#13;
    "x-color": "#D53636",&#13;
    "y-color": "#33FF86"&#13;
  },&#13;
  "geometry": {&#13;
    "stroke-color": "#3F4783",&#13;
    "stroke-width": 3&#13;
  }&#13;
}</pre>&#13;
<p class="caption"><a id="ch12lis3"/><em>Listing 12-3: Configuration JSON file</em></p>&#13;
<p class="indent">This configuration first defines the number of frames to use for the simulation. Then comes the dimensions and the color of the coordinate axes, which we’ll draw to help us visualize how the space is transformed. Lastly, we have configuration values for the geometry that will be transformed. Here we’re defining stroke color and width.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_312"/>We now need a way to read this configuration JSON file and transform its contents into a Python dictionary. Let’s use the same approach we used in <a href="ch09.xhtml#ch09">Chapter 9</a>. In <em>config.py</em>, enter the code in <a href="ch12.xhtml#ch12lis4">Listing 12-4</a>.</p>&#13;
<pre>import json&#13;
&#13;
import pkg_resources as res&#13;
&#13;
&#13;
def read_config():&#13;
    config = res.resource_string(__name__, 'config.json')&#13;
    return json.loads(config)</pre>&#13;
<p class="caption"><a id="ch12lis4"/><em>Listing 12-4: Reading the configuration file</em></p>&#13;
<p class="indent">That’s it for the configuration; let’s turn our attention to reading and parsing input.</p>&#13;
<h3 class="h3" id="ch00lev1sec75"><strong>Reading Input</strong></h3>&#13;
<p class="noindent">We’re expecting the user to pass our program a file containing the definition of an affine transformation and a list of the geometric primitives to transform. Let’s define how these files should be formatted. We can start by reading the affine transformation values since we know beforehand how many values we’re expecting. Because there can be any number of geometric primitives, we’ll put those at the end.</p>&#13;
<h4 class="h4" id="ch00lev2sec136"><strong><em>Formatting the Input</em></strong></h4>&#13;
<p class="noindent">Here’s a nice way of formatting the affine transformation values:</p>&#13;
<pre>sx &lt;<span class="codeitalic1">value</span>&gt;&#13;
sy &lt;<span class="codeitalic1">value</span>&gt;&#13;
shx &lt;<span class="codeitalic1">value</span>&gt;&#13;
shy &lt;<span class="codeitalic1">value</span>&gt;&#13;
tx &lt;<span class="codeitalic1">value</span>&gt;&#13;
ty &lt;<span class="codeitalic1">value</span>&gt;</pre>&#13;
<p class="indent">Here each value is defined in its own line and has a tag indicating which term it is. We could use a more condensed format and simply have all those values in a single line, like so:</p>&#13;
<pre>transformation: &lt;<span class="codeitalic1">value</span>&gt; &lt;<span class="codeitalic1">value</span>&gt; &lt;<span class="codeitalic1">value</span>&gt; &lt;<span class="codeitalic1">value</span>&gt; &lt;<span class="codeitalic1">value</span>&gt; &lt;<span class="codeitalic1">value</span>&gt;</pre>&#13;
<p class="noindent">But this has the downside of being less clear for the user. What’s the order of the values? Was the third number the shear in the x direction or the translation in the y direction? To answer this question, you’d need to open the source code and find out how those values are parsed. I tend to favor clarity over compactness in cases where the size of the input isn’t too big, so we’ll stick to the first approach.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_313"/>So what about the geometric primitives? For each kind of geometric primitive, we’ll use a different four-letter code: <span class="literal">circ</span> for circle, for example. This code will be followed by a bunch of numbers that define the primitive’s properties.</p>&#13;
<p class="indent">For a circle, the definition will look like</p>&#13;
<pre>circ &lt;<span class="codeitalic1">cx</span>&gt; &lt;<span class="codeitalic1">cy</span>&gt; &lt;<span class="codeitalic1">r</span>&gt;</pre>&#13;
<p class="noindent">where <span class="literal">&lt;</span><em>cx</em><span class="literal">&gt;</span> and <span class="literal">&lt;</span><em>cy</em><span class="literal">&gt;</span> are the coordinates of the center point and <span class="literal">&lt;</span><em>r</em><span class="literal">&gt;</span> is the value for the radius.</p>&#13;
<p class="indent">A rectangle will look like</p>&#13;
<pre>rect &lt;<span class="codeitalic1">ox</span>&gt; &lt;<span class="codeitalic1">oy</span>&gt; &lt;<span class="codeitalic1">w</span>&gt; &lt;<span class="codeitalic1">h</span>&gt;</pre>&#13;
<p class="noindent">with <span class="literal">&lt;</span><em>ox</em><span class="literal">&gt;</span> and <span class="literal">&lt;</span><em>oy</em><span class="literal">&gt;</span> defining the coordinates of its origin, <span class="literal">&lt;</span><em>w</em><span class="literal">&gt;</span> its width, and <span class="literal">&lt;</span><em>h</em><span class="literal">&gt;</span> its height.</p>&#13;
<p class="indent">A polygon will look like</p>&#13;
<pre>poly [&lt;<span class="codeitalic1">x1</span>&gt; &lt;<span class="codeitalic1">y1</span>&gt; &lt;<span class="codeitalic1">x2</span>&gt; &lt;<span class="codeitalic1">y2</span>&gt; &lt;<span class="codeitalic1">x3</span>&gt; &lt;<span class="codeitalic1">y3</span>&gt; ...]</pre>&#13;
<p class="noindent">where [<span class="literal">&lt;</span><em>x</em><span class="literal">&gt;</span> <span class="literal">&lt;</span><em>y</em><span class="literal">&gt;</span>] means a sequence of <span class="literal">x</span> and <span class="literal">y</span> values representing the coordinates of a vertex. Bear in mind that the minimum number of vertices to build a polygon is three; therefore, we need at least six values here.</p>&#13;
<p class="indent">Lastly, a segment is defined like</p>&#13;
<pre>segm &lt;<span class="codeitalic1">sx</span>&gt; &lt;<span class="codeitalic1">sy</span>&gt; &lt;<span class="codeitalic1">ex</span>&gt; &lt;<span class="codeitalic1">ey</span>&gt;</pre>&#13;
<p class="noindent">where <span class="literal">&lt;</span><em>sx</em><span class="literal">&gt;</span> and <span class="literal">&lt;</span><em>sy</em><span class="literal">&gt;</span> are the coordinates of the start point, and <span class="literal">&lt;</span><em>ex</em><span class="literal">&gt;</span> and <span class="literal">&lt;</span><em>ey</em><span class="literal">&gt;</span> are the coordinates of the end point.</p>&#13;
<h4 class="h4" id="ch00lev2sec137"><strong><em>Adding Example Input</em></strong></h4>&#13;
<p class="noindent">Let’s fill our <em>test.txt</em> file with an example input. Remember that we redirected the standard input in our program to read from <em>test.txt</em>, so we’ll be using it to test our code. Open the file and enter the definition in <a href="ch12.xhtml#ch12lis5">Listing 12-5</a>.</p>&#13;
<pre>sx 1.2&#13;
sy 1.4&#13;
shx 2.0&#13;
shy 3.0&#13;
tx 50.0&#13;
ty 25.0&#13;
&#13;
circ 150 40 20&#13;
rect 70 60 40 100&#13;
rect 100 90 40 100&#13;
poly 30 10 80 10 30 90&#13;
segm 10 20 200 240</pre>&#13;
<p class="caption"><a id="ch12lis5"/><em>Listing 12-5: Input test file</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_314"/>This file first defines an affine transformation as follows:</p>&#13;
<div class="equationc"><img src="../images/f0314-01.jpg" alt="Image"/></div>&#13;
<p class="indent">It also defines a circle, two rectangles, a polygon, and a segment. <a href="ch12.xhtml#ch12fig3">Figure 12-3</a> depicts the approximate layout of these geometric primitives before we apply the affine transformation.</p>&#13;
<div class="image"><img src="../images/12fig03.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch12fig3"><em>Figure 12-3: The geometric primitives in our test file</em></p>&#13;
<p class="indent">Now that <em>test.txt</em> has these definitions, let’s write the outline of the code we need to read and parse the input. Open <em>input.py</em> and enter the code in <a href="ch12.xhtml#ch12lis6">Listing 12-6</a>.</p>&#13;
<pre>def read_input():&#13;
    transform = __read_transform()&#13;
    primitives = __read_primitives()&#13;
    return transform, primitives&#13;
&#13;
&#13;
def __read_transform():&#13;
    return None&#13;
&#13;
&#13;
def __read_primitives():&#13;
    return None</pre>&#13;
<p class="caption"><a id="ch12lis6"/><em>Listing 12-6: Parsing the input file starting point</em></p>&#13;
<p class="indent">We first define a function, <span class="literal">read_input</span>, which will read both the affine transformation and the geometric primitives and return a tuple containing both. To do its work, it delegates each of the two tasks to private functions: <span class="literal">__read_transform</span> and <span class="literal">__read_primitives</span>. These functions return <span class="literal">None</span> for now. We’ll implement them in the next two sections.</p>&#13;
<h4 class="h4" id="ch00lev2sec138"><span epub:type="pagebreak" id="page_315"/><strong><em>Parsing the Affine Transformation</em></strong></h4>&#13;
<p class="noindent">The affine transformation in the input file will always span six lines, one line per term. We can simplify the parsing by requiring that the terms always appear in the same, predefined order. We’ll double-check that each of the terms has the appropriate name tag, just to make sure the user wrote the terms in the right order, but we won’t include that bit in our regular expression, which should make things a bit simpler.</p>&#13;
<p class="indent">The first thing we need is a regular expression that can match the floating-point numbers in the components of the transformation. It’s important to design this regular expression so that it also matches integer numbers; the decimal part should be optional. We also want to accept negative numbers. A regular expression combining all these characteristics could look like this:</p>&#13;
<p class="pre2">    /-?\d+(\.\d+)?/</p>&#13;
<p class="noindent">The regular expression has three parts. The first, <span class="literal">-?</span>, matches zero or one instances of the minus symbol. The second, <span class="literal">\d+</span>, matches one or more digits before the decimal separator: the integer part. Lastly comes <span class="literal">(\.\d+)?</span>, which matches zero or one sequence made of a dot and one or more digits. Note that we’ve used <span class="literal">?</span> to handle our optional components.</p>&#13;
<p class="indent">Using the regular expression shown earlier, we can prepare another regular expression that matches all of the term values:</p>&#13;
<p class="pre2">    /(?P&lt;val&gt;-?\d+(\.\d+)?)/</p>&#13;
<p class="noindent">This defines a group named <span class="literal">val</span> that will capture the term’s value using the previous expression.</p>&#13;
<p class="indent">Let’s open <em>parse_transform.py</em> (empty at the moment) and implement the logic for reading and parsing the affine transformation terms. Enter the code in <a href="ch12.xhtml#ch12lis7">Listing 12-7</a>.</p>&#13;
<pre>import re&#13;
&#13;
__TRANSF_VAL_RE = r'(?P&lt;val&gt;-?\d+(\.\d+)?)'&#13;
&#13;
&#13;
def parse_transform_term(term, line):&#13;
    __ensure_term_name(term, line)&#13;
    return __parse_transform_term(line)&#13;
&#13;
&#13;
def __ensure_term_name(name, line):&#13;
    if name not in line:&#13;
        raise ValueError(f'Expected {name} term')&#13;
&#13;
&#13;
def __parse_transform_term(line):&#13;
    matches = re.search(__TRANSF_VAL_RE, line)&#13;
    if not matches:&#13;
        raise ValueError('Couldn\'t read transform term')&#13;
&#13;
    <span epub:type="pagebreak" id="page_316"/>return float(matches.group('val'))</pre>&#13;
<p class="caption"><a id="ch12lis7"/><em>Listing 12-7: Parsing the affine transformation terms</em></p>&#13;
<p class="indent">We first define the regular expression to parse the affine transformation term values: <span class="literal">__TRANSF_VAL_RE</span>. Then comes the main function: <span class="literal">parse_transform</span> <span class="literal">_term</span>, which takes two parameters: the name of the term to validate and the line to parse. Each of these operations is handled by two private functions.</p>&#13;
<p class="indent">The function <span class="literal">__ensure_term_name</span> checks whether the given <span class="literal">name</span> is present in <span class="literal">line</span>. If it’s not, the function raises a <span class="literal">ValueError</span> with a helpful message to let the user know which term couldn’t be properly interpreted. Then, <span class="literal">__parse_transform_term</span> applies the regular expression <span class="literal">__TRANSF_VAL_RE</span> to match the term’s value. If it succeeds, the matched group <span class="literal">val</span> is converted to a <span class="literal">float</span> value and returned. An error is raised in the case that the string doesn’t match the regular expression.</p>&#13;
<p class="indent">Let’s now use this <span class="literal">parse</span> function in the <em>Input</em> module (as depicted by <a href="ch12.xhtml#ch12fig1">Figure 12-1</a>). Open your <em>input.py</em> file and add the following imports at the top:</p>&#13;
<pre>from apps.aff_transf_motion.parse_transform import parse_transform_term&#13;
from geom2d import AffineTransform</pre>&#13;
<p class="noindent">Then, refactor the <span class="literal">__read_transform</span> function as in <a href="ch12.xhtml#ch12lis8">Listing 12-8</a>.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
def __read_transform():&#13;
    return AffineTransform(&#13;
        sx=parse_transform_term('sx', input()),&#13;
        sy=parse_transform_term('sy', input()),&#13;
        shx=parse_transform_term('shx', input()),&#13;
        shy=parse_transform_term('shy', input()),&#13;
        tx=parse_transform_term('tx', input()),&#13;
        ty=parse_transform_term('ty', input())&#13;
    )</pre>&#13;
<p class="caption"><a id="ch12lis8"/><em>Listing 12-8: Parsing the affine transformation</em></p>&#13;
<p class="indent">We can easily test that our code works by editing the contents of our <em>main.py</em> file to match <a href="ch12.xhtml#ch12lis9">Listing 12-9</a>.</p>&#13;
<pre>from apps.aff_transf_motion.input import read_input&#13;
&#13;
if __name__ == '__main__':&#13;
    (transform, primitives) = read_input()&#13;
    print(transform)</pre>&#13;
<p class="caption"><a id="ch12lis9"/><em>Listing 12-9: Main file: reading transformation test</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_317"/>If you run the application using the run configuration or the bash script we created before, the output in your shell should be the following:</p>&#13;
<pre>Input is being redirected from .../test.txt&#13;
(sx: 1.2, sy: 1.4, shx: 2.0, shy: 3.0, tx: 50.0, ty: 25.0)&#13;
&#13;
Process finished with exit code 0</pre>&#13;
<p class="noindent">You want to make sure all of the values in the affine transformation we defined in <em>test.txt</em> are properly parsed. If you recall, those were as follows:</p>&#13;
<p class="pre2">    sx 1.2<br/>    sy 1.4<br/>    shx 2.0<br/>    shy 3.0<br/>    tx 50.0<br/>    ty 25.0</p>&#13;
<p class="noindent">Double-check that the output you got from the program matches these values. If you got it all right, congratulations! If you got any unexpected value, debug your program until you find the culprit and fix the bug.</p>&#13;
<h4 class="h4" id="ch00lev2sec139"><strong><em>Parsing the Geometric Primitives</em></strong></h4>&#13;
<p class="noindent">The geometric primitives can come in any order, and there can be any number of them, so we’ll need a different parsing strategy. We need to tackle two separate problems: we need to read an unknown number of lines from the input and then figure out the the type of geometric primitive for each line. Let’s solve these problems separately, starting with the first one.</p>&#13;
<h5 class="h5" id="ch00lev3sec63"><strong>Reading an Unknown Number of Lines</strong></h5>&#13;
<p class="noindent">To read an unknown number of lines, we can keep reading from the standard input until an <span class="literal">EOFError</span> (end of file error) is raised, signaling that we’ve exhausted all the available lines. Open <em>input.py</em> and refactor <span class="literal">__read_primitives</span> by entering the code in <a href="ch12.xhtml#ch12lis10">Listing 12-10</a>.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
def __read_primitives():&#13;
    has_more_lines = True&#13;
&#13;
    while has_more_lines:&#13;
        try:&#13;
            line = input()&#13;
            print('got line --&gt;', line)&#13;
&#13;
        except EOFError:&#13;
            has_more_lines = False</pre>&#13;
<p class="caption"><a id="ch12lis10"/><em>Listing 12-10: Reading lines from standard input</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_318"/>We declare a variable <span class="literal">has_more_lines</span> and assign it a value of <span class="literal">True</span>. Then, in a <span class="literal">while</span> loop that keeps looping provided the variable remains <span class="literal">True</span>, we try to read another line from the standard input. If the operation succeeds, we print the line to the output; otherwise, we catch the <span class="literal">EOFError</span> and set <span class="literal">has_more</span> <span class="literal">_lines</span> to <span class="literal">False</span>.</p>&#13;
<p class="indent">Run the program again to make sure all the lines from the input file are processed by <span class="literal">__read_primitives</span> and appear in the shell output. The output of your program should include the following lines:</p>&#13;
<pre>got line --&gt;&#13;
got line --&gt; circ 150 40 20&#13;
got line --&gt; rect 70 60 40 100&#13;
got line --&gt; rect 100 90 40 100&#13;
got line --&gt; poly 30 10 80 10 30 90&#13;
got line --&gt; segm 10 20 200 240</pre>&#13;
<p class="indent">The first problem is solved: our <em>input.py</em> module knows how to read all the lines from the input file. Notice that empty lines are also processed by the <span class="literal">__read_primitives</span> function; we’ll handle that in the next section. Now that we know how to read in the lines, let’s turn our focus to our second problem: identifying the primitive type for each of the read-in lines.</p>&#13;
<h5 class="h5" id="ch00lev3sec64"><strong>Parsing the Right Primitive</strong></h5>&#13;
<p class="noindent">Let’s start with one thing we know for sure: we need to have regular expressions for each of the geometric primitives our program understands. Earlier in the chapter, we defined the input format we expect for each of the primitives. We just need to turn that into a regular expression. We’ll accept either an integer or floating-point number for the properties of each of the primitives. We saw how to do this before. Let’s call the regex that captures a property value <span class="literal">NUM_RE</span> and use the following definition:</p>&#13;
<p class="pre2">    /\d+(\.\d+)?/</p>&#13;
<p class="indent">Using this regex, we could have the regular expression for a circle as follows:</p>&#13;
<p class="pre2">    /circ (?P&lt;cx&gt;NUM_RE) (?P&lt;cy&gt;NUM_RE) (?P&lt;r&gt;NUM_RE)/</p>&#13;
<p class="noindent">Here we’ve included three capture groups: <span class="literal">cx</span>, <span class="literal">cy</span>, and <span class="literal">r</span>. These groups coincide with the properties we defined for the input representation of the previous circle. In a similar fashion, a rectangle can be matched by the regular expression:</p>&#13;
<p class="pre2">    /rect (?P&lt;ox&gt;NUM_RE) (?P&lt;oy&gt;NUM_RE) (?P&lt;w&gt;NUM_RE) (?P&lt;h&gt;NUM_RE)/</p>&#13;
<p class="noindent">A regular expression to match segments can be as follows:</p>&#13;
<p class="pre2">    /segm (?P&lt;sx&gt;NUM_RE) (?P&lt;sy&gt;NUM_RE) (?P&lt;ex&gt;NUM_RE) (?P&lt;ey&gt;NUM_RE)/</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_319"/>Lastly, for the polygon, we use a slightly different approach that simplifies its parsing process a bit, as we’ll see now. The following is the regular expression we’ll use:</p>&#13;
<p class="pre2">    /poly (?P&lt;coords&gt;[\d\s\.]+)/</p>&#13;
<p class="noindent">This regex matches strings starting with the word <em>poly</em> followed by a space and a sequence of digits, spaces, or dots (used as decimal separator). With it, we’ll match polygon definitions, as follows,</p>&#13;
<p class="pre2">    poly 30 10 80.5 10 30 90.5</p>&#13;
<p class="noindent">which we’ll parse as a polygon defined by the vertices (30, 10), (80.5, 10), and (30, 90.5).</p>&#13;
<p class="indent">Let’s include these definitions in our <em>parse_geom.py</em> file, along with some imports that we’ll need to create the geometric primitives. Enter the code in <a href="ch12.xhtml#ch12lis11">Listing 12-11</a>.</p>&#13;
<pre>import re&#13;
&#13;
from geom2d import Circle, Point, Rect, Size, Segment&#13;
from geom2d import make_polygon_from_coords&#13;
&#13;
__NUM_RE = r'\d+(\.\d+)?'&#13;
&#13;
__CIRC_RE = rf'circ (?P&lt;cx&gt;{__NUM_RE}) (?P&lt;cy&gt;{__NUM_RE}) ' \&#13;
    rf'(?P&lt;r&gt;{__NUM_RE})'&#13;
&#13;
__RECT_RE = rf'rect (?P&lt;ox&gt;{__NUM_RE}) (?P&lt;oy&gt;{__NUM_RE}) ' \&#13;
    rf'(?P&lt;w&gt;{__NUM_RE}) (?P&lt;h&gt;{__NUM_RE})'&#13;
&#13;
__POLY_RE = rf'poly (?P&lt;coords&gt;[\d\s\.]+)'&#13;
&#13;
__SEGM_RE = rf'segm (?P&lt;sx&gt;{__NUM_RE}) (?P&lt;sy&gt;{__NUM_RE}) ' \&#13;
    rf'(?P&lt;ex&gt;{__NUM_RE}) (?P&lt;ey&gt;{__NUM_RE})'</pre>&#13;
<p class="caption"><a id="ch12lis11"/><em>Listing 12-11: Geometric primitives, regex definitions</em></p>&#13;
<p class="indent">We have all the regular expressions we need, so our next goal is for the appropriate primitive for each line we read. To solve this problem, we’ll follow the “if can &lt;verb&gt; then &lt;verb&gt;” pattern, in our case “if can parse then parse.” Let’s see how this works. We have a sequence of parser functions, each of which expects a string formatted in a specific way. These functions would fail if they tried to parse a geometric primitive out of a string with a wrong format. So before putting them to work, we want to make sure they’ll understand the string we pass them in. We’ll accompany each of the <span class="literal">parse</span> functions with a <span class="literal">can_parse</span> function. This second function should determine whether all of the parts the <span class="literal">parse</span> function expects are in the string: the pattern’s “can parse” part.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_320"/>For each of our geometric primitives we need a pair of functions: one to determine whether the given line of text can be parsed to this primitive (the “can parse” part) and another to actually parse it (the “then parse” part). The code for this algorithm is as follows:</p>&#13;
<pre>if can_parse_circle(line):&#13;
    parse_circle(line)&#13;
&#13;
elif can_parse_rect(line):&#13;
    parse_rect(line)&#13;
&#13;
elif can_parse_polygon(line):&#13;
    parse_polygon(line)&#13;
&#13;
elif can_parse_segment(line):&#13;
    parse_segment(line)&#13;
&#13;
else:&#13;
    handle_unknown_line(line)</pre>&#13;
<p class="indent">We first check whether the given line can be parsed to a circle. If the test passes, we proceed to parse the circle; otherwise, we continue with the next comparison, repeating this pattern. It may happen that none of these comparisons passes, and we reach the last <span class="literal">else</span> statement; we handle this situation in the <span class="literal">handle_unknown_line</span> function. Think, for example, about those empty lines we read from the input file; those won’t match against any known primitive. There are a couple of ways we could handle these problem lines. We could, for example, print them to the shell with a warning message, thus letting the user know there were lines the program didn’t understand. To keep things simple, we’ll just ignore unknown lines.</p>&#13;
<p class="indent">Let’s now implement the “can parse” and “parse” functions for each of our primitives. In <em>parse_geom.py</em>, after the regular expressions we just defined, enter the code in <a href="ch12.xhtml#ch12lis12">Listing 12-12</a>. This code handles the circle case.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
def can_parse_circle(line):&#13;
    return re.match(__CIRC_RE, line)&#13;
&#13;
&#13;
def parse_circle(line):&#13;
    match = re.match(__CIRC_RE, line)&#13;
    return Circle(&#13;
        center=Point(&#13;
            float(match.group('cx')),&#13;
            float(match.group('cy'))&#13;
        ),&#13;
        radius=float(match.group('r'))&#13;
    <span epub:type="pagebreak" id="page_321"/>)</pre>&#13;
<p class="caption"><a id="ch12lis12"/><em>Listing 12-12: Parsing a circle</em></p>&#13;
<p class="indent">As you can see, the <span class="literal">can_parse_circle</span> function simply checks for a match between the passed-in line and the regular expression for a circle: <span class="literal">__CIRC_RE</span>. The <span class="literal">parse_circle</span> function goes one step further and, assuming the line matches the regular expression, extracts the <span class="literal">cx</span> and <span class="literal">cy</span> group values, the center of the circle. It does the same with the <span class="literal">r</span> group, the radius.</p>&#13;
<p class="indent">Don’t forget that the values we extract from the regular expression capture groups are always strings. Since we’re expecting floating-point numbers, we need to do the conversion using the <span class="literal">float</span> function.</p>&#13;
<p class="indent">Let’s now implement the same functions for the case of a rectangle. After the code you just wrote, enter the code in <a href="ch12.xhtml#ch12lis13">Listing 12-13</a>.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
def can_parse_rect(line):&#13;
    return re.match(__RECT_RE, line)&#13;
&#13;
&#13;
def parse_rect(line):&#13;
    match = re.match(__RECT_RE, line)&#13;
    return Rect(&#13;
        origin=Point(&#13;
            float(match.group('ox')),&#13;
            float(match.group('oy'))&#13;
        ),&#13;
        size=Size(&#13;
            float(match.group('w')),&#13;
            float(match.group('h'))&#13;
        )&#13;
    )</pre>&#13;
<p class="caption"><a id="ch12lis13"/><em>Listing 12-13: Parsing a rectangle</em></p>&#13;
<p class="indent">No surprises here. We applied the same procedure, this time extracting groups named <span class="literal">ox</span>, <span class="literal">oy</span>, <span class="literal">w</span>, and <span class="literal">h</span>, which define the origin point and the size of the rectangle. Let’s do the same for the case of a polygon. Enter the code in <a href="ch12.xhtml#ch12lis14">Listing 12-14</a>.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
def can_parse_polygon(line):&#13;
    return re.match(__POLY_RE, line)&#13;
&#13;
&#13;
def parse_polygon(line):&#13;
    match = re.match(__POLY_RE, line)&#13;
    coords = [float(n) for n in match.group('coords').split(' ')]&#13;
    <span epub:type="pagebreak" id="page_322"/>return make_polygon_from_coords(coords)</pre>&#13;
<p class="caption"><a id="ch12lis14"/><em>Listing 12-14: Parsing a polygon</em></p>&#13;
<p class="indent">In this case, the mechanics are a bit different. Remember we had a slightly different regular expression for the case of a polygon. Since polygons are defined by an unknown number of vertices, the regex to match these numbers by pairs had to be more complicated. We also had to use a list comprehension to properly parse the coordinates.</p>&#13;
<p class="indent">First, the string captured by the group named <span class="literal">coords</span> is split using a space as the separator. Thus, the string of numbers</p>&#13;
<p class="pre2">    '10 20 30 40 50 60'</p>&#13;
<p class="noindent">would be converted to an array of strings like so:</p>&#13;
<p class="pre2">    ['10', '20', '30', '40', '50', '60']</p>&#13;
<p class="noindent">Then each of the strings is converted into a floating-point number:</p>&#13;
<p class="pre2">    [10.0, 20.0, 30.0, 40.0, 50.0, 60.0]</p>&#13;
<p class="noindent">With this array of numbers we can easily create an instance of our <span class="literal">Polygon</span> class using the factory function <span class="literal">make_polygon_from_coords</span>. Don’t forget to add the import at the top of the file:</p>&#13;
<pre>from geom2d import make_polygon_from_coords</pre>&#13;
<p class="indent">The last pair of “can parse” and “parse” functions we need are for segments. Enter the code in <a href="ch12.xhtml#ch12lis15">Listing 12-15</a>.</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
def can_parse_segment(line):&#13;
    return re.match(__SEGM_RE, line)&#13;
&#13;
&#13;
def parse_segment(line):&#13;
    match = re.match(__SEGM_RE, line)&#13;
    return Segment(&#13;
        start=Point(&#13;
            float(match.group('sx')),&#13;
            float(match.group('sy'))&#13;
        ),&#13;
        end=Point(&#13;
            float(match.group('ex')),&#13;
            float(match.group('ey'))&#13;
        )&#13;
    )</pre>&#13;
<p class="caption"><a id="ch12lis15"/><em>Listing 12-15: Parsing a segment</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_323"/>Great! We now have the functions we need to apply our “if can parse then parse” strategy. Open <em>input.py</em> and import these functions:</p>&#13;
<pre>from apps.aff_transf_motion.parse_geom import *</pre>&#13;
<p class="indent">We use the asterisk import to bring all the defined functions in the <em>parse _geom</em> module without writing all of their names. Now let’s refactor the <span class="literal">__read</span> <span class="literal">_primitives</span> function (<a href="ch12.xhtml#ch12lis16">Listing 12-16</a>).</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
def __read_primitives():&#13;
    prims = {'circs': [], 'rects': [], 'polys': [], 'segs': []}&#13;
    has_more_lines = True&#13;
&#13;
    while has_more_lines:&#13;
        try:&#13;
            line = input()&#13;
&#13;
            if can_parse_circle(line):&#13;
                prims['circs'].append(parse_circle(line))&#13;
&#13;
            elif can_parse_rect(line):&#13;
                prims['rects'].append(parse_rect(line))&#13;
&#13;
            elif can_parse_polygon(line):&#13;
                prims['polys'].append(parse_polygon(line))&#13;
&#13;
            elif can_parse_segment(line):&#13;
                prims['segs'].append(parse_segment(line))&#13;
&#13;
        except EOFError:&#13;
            has_more_lines = False&#13;
&#13;
    return prims</pre>&#13;
<p class="caption"><a id="ch12lis16"/><em>Listing 12-16: Reading the primitives from the input</em></p>&#13;
<p class="indent">We start defining a dictionary named <span class="literal">prims</span> with an array for each type of geometric primitive. Each of the arrays in the dictionary is identified by a name: <span class="literal">circs</span>, <span class="literal">rects</span>, <span class="literal">polys</span>, and <span class="literal">segs</span>. Then comes the <span class="literal">while</span> loop, which iterates through all the read-in lines. Instead of printing them to the shell, we added our parsing functions, similar to what we did in pseudocode before. This time, whenever a primitive is parsed, the result is appended to the corresponding array of the <span class="literal">prims</span> dictionary. The function ends by returning <span class="literal">prims</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_324"/><a href="ch12.xhtml#ch12lis17">Listing 12-17</a> contains the final result for <em>input.py</em>. Make sure yours looks similar.</p>&#13;
<pre>from apps.aff_transf_motion.parse_geom import *&#13;
from apps.aff_transf_motion.parse_transform import parse_transform_term&#13;
from geom2d import AffineTransform&#13;
&#13;
&#13;
def read_input():&#13;
    transform = __read_transform()&#13;
    primitives = __read_primitives()&#13;
    return transform, primitives&#13;
&#13;
&#13;
def __read_transform():&#13;
    return AffineTransform(&#13;
        sx=parse_transform_term('sx', input()),&#13;
        sy=parse_transform_term('sy', input()),&#13;
        shx=parse_transform_term('shx', input()),&#13;
        shy=parse_transform_term('shy', input()),&#13;
        tx=parse_transform_term('tx', input()),&#13;
        ty=parse_transform_term('ty', input())&#13;
    )&#13;
&#13;
&#13;
def __read_primitives():&#13;
    prims = {'circs': [], 'rects': [], 'polys': [], 'segs': []}&#13;
    has_more_lines = True&#13;
&#13;
    while has_more_lines:&#13;
        try:&#13;
            line = input()&#13;
&#13;
            if can_parse_circle(line):&#13;
                prims['circs'].append(parse_circle(line))&#13;
&#13;
            elif can_parse_rect(line):&#13;
                prims['rects'].append(parse_rect(line))&#13;
&#13;
            elif can_parse_polygon(line):&#13;
                prims['polys'].append(parse_polygon(line))&#13;
&#13;
            elif can_parse_segment(line):&#13;
                prims['segs'].append(parse_segment(line))&#13;
&#13;
        except EOFError:&#13;
            has_more_lines = False&#13;
&#13;
    <span epub:type="pagebreak" id="page_325"/>return prims</pre>&#13;
<p class="caption"><a id="ch12lis17"/><em>Listing 12-17: Complete input-reading code</em></p>&#13;
<p class="indent">Now that we can fully parse the input, let’s move on and implement the simulation.</p>&#13;
<h3 class="h3" id="ch00lev1sec76"><strong>Running the Simulation</strong></h3>&#13;
<p class="noindent">Once the configuration and input are completely read and parsed, they’re both passed to a simulation function that we’ll write shortly. This function will also define the user interface: a canvas to draw the shapes and a button to start the animation. <a href="ch12.xhtml#ch12fig4">Figure 12-4</a> shows how these components will be laid out.</p>&#13;
<p class="indent">The simulation won’t start until the user clicks the play button. This way we prevent the simulation from starting too soon; otherwise, the user may miss the first part of it. Furthermore, thanks to the button, we’ll be able to rerun the simulation without needing to relaunch the application.</p>&#13;
<div class="image"><img src="../images/12fig04.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch12fig4"><em>Figure 12-4: The simulation’s user interface</em></p>&#13;
<h4 class="h4" id="ch00lev2sec140"><strong><em>Building the User Interface</em></strong></h4>&#13;
<p class="noindent">Open the empty <em>simulation.py</em> and enter the code in <a href="ch12.xhtml#ch12lis18">Listing 12-18</a>.</p>&#13;
<pre>from tkinter import Tk, Canvas, Button&#13;
&#13;
&#13;
def simulate(transform, primitives, config):&#13;
    # ---------- UI DEFINITION ---------- #&#13;
    tk = Tk()&#13;
    tk.title("Affine Transformations")&#13;
&#13;
    canvas = Canvas(tk, width=800, height=800)&#13;
    canvas.grid(row=0, column=0)&#13;
&#13;
    def start_simulation():&#13;
        <span epub:type="pagebreak" id="page_326"/>tk.update()&#13;
        print('Starting Simulation...')&#13;
&#13;
    Button(tk, text='Play', command=start_simulation) \&#13;
        .grid(row=1, column=0)&#13;
&#13;
    # ---------- UPDATE, DRAW &amp; CONTINUE ---------- #&#13;
    def update_system(time_delta_s, time_s, frame):&#13;
        pass&#13;
&#13;
    def redraw():&#13;
        pass&#13;
&#13;
    def should_continue(frame, time_s):&#13;
        pass&#13;
&#13;
    # ---------- MAIN LOOP ---------- #&#13;
    redraw()&#13;
    tk.mainloop()</pre>&#13;
<p class="caption"><a id="ch12lis18"/><em>Listing 12-18: Simulation function</em></p>&#13;
<p class="indent">We’ve defined a function <span class="literal">simulate</span>, which takes in the target transform, the geometric primitives, and the configuration for the application. Recall that the configuration JSON file contains the number of frames to use for the simulation and the sizes and colors of everything we’ll draw to the screen. Since the function will get a bit long, we’ve added three header comments to easily locate each of the sections: the user interface definition; the <span class="literal">update</span>, <span class="literal">draw</span>, and <span class="literal">should_continue</span> functions; and the main loop.</p>&#13;
<p class="indent">The first section of the function builds the user interface. We instantiate the <span class="literal">Tk</span> class and add a <span class="literal">Canvas</span> and a <span class="literal">Button</span> to it. Using the grid system, we place the canvas in the first row (<span class="literal">row=0</span>) and the button in the second one (<span class="literal">row=1</span>). We’ve also created a function, <span class="literal">start_simulation</span>, which is executed when the button is pressed. This function doesn’t do much for now; all it does is tell Tkinter to process all pending events (<span class="literal">tk.update()</span>) and print a message to the shell. We’ll add the simulation’s updating logic here shortly.</p>&#13;
<p class="indent">Then we define the templates for the key simulation functions: <span class="literal">update</span> <span class="literal">_system</span>, <span class="literal">redraw</span>, and <span class="literal">should_continue</span>. Don’t forget to declare the appropriate input parameters for each of them; otherwise, Python will complain once we hand them to our <span class="literal">main_loop</span> function. We’ll fill in these functions shortly.</p>&#13;
<p class="indent">Lastly, we call <span class="literal">redraw</span> to render the initial state of the geometric primitives to the screen and start Tkinter’s main loop. To test our progress, let’s edit <em>main.py</em> so that it shows the user interface. Open that file and modify it so that it looks like <a href="ch12.xhtml#ch12lis19">Listing 12-19</a>.</p>&#13;
<pre>from apps.aff_transf_motion.config import read_config&#13;
from apps.aff_transf_motion.input import read_input&#13;
from apps.aff_transf_motion.simulation import simulate&#13;
&#13;
<span epub:type="pagebreak" id="page_327"/>if __name__ == '__main__':&#13;
    (transform, primitives) = read_input()&#13;
    config = read_config()&#13;
    simulate(transform, primitives, config)</pre>&#13;
<p class="caption"><a id="ch12lis19"/><em>Listing 12-19: Execution entry point</em></p>&#13;
<p class="indent">Our <em>main.py</em> file is now ready. Let’s work on the simulation code.</p>&#13;
<h4 class="h4" id="ch00lev2sec141"><strong><em>Implementing the Simulation Logic</em></strong></h4>&#13;
<p class="noindent">Let’s move on to the simulation logic. If you recall from <a href="ch07.xhtml#ch07">Chapter 7</a>, to draw the different frames of the animation, we need to generate a sequence of interpolated affine transformations going from the identity transformation to the target transformation that we parsed from the input. If you need a refresher on the topic, refer to “Interpolating Transformations” on <a href="ch07.xhtml#ch00lev1sec45">page 192</a>. Thanks to the affine-transformation interpolation function we implemented in <a href="ch07.xhtml#ch07">Chapter 7</a>, <span class="literal">ease_in_out_interpolation</span>, this piece of logic is a breeze. In <em>simulation.py</em> make the changes shown in <a href="ch12.xhtml#ch12lis20">Listing 12-20</a>.</p>&#13;
<pre>from tkinter import Tk, Canvas, Button&#13;
&#13;
from geom2d import affine_transforms as tf&#13;
&#13;
&#13;
def simulate(transform, primitives, config):&#13;
    # ---------- UI DEFINITION ---------- #&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    # ---------- UPDATE, DRAW &amp; CONTINUE ---------- #&#13;
    frames = config['frames']&#13;
    transform_seq = __make_transform_sequence(transform, frames)&#13;
&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
&#13;
def __make_transform_sequence(end_transform, frames):&#13;
    start_transform = tf.AffineTransform(sx=1, sy=1, tx=20, ty=20)&#13;
    return tf.ease_in_out_interpolation(&#13;
        start_transform, end_transform, frames&#13;
    )</pre>&#13;
<p class="caption"><a id="ch12lis20"/><em>Listing 12-20: Computing the transformation sequence</em></p>&#13;
<p class="indent">The first thing that we need is the number of steps for the interpolation. This is just the number of frames, a value that we read from the configuration and stored in variable <span class="literal">frames</span>. To compute the interpolated sequence, we’ve defined a private function in the file: <span class="literal">__make_transform_sequence</span>. This function takes the target affine transformation and the number of frames <span epub:type="pagebreak" id="page_328"/>and computes the sequence using the following transformation as the starting point:</p>&#13;
<div class="equationc"><img src="../images/f0328-01.jpg" alt="Image"/></div>&#13;
<p class="noindent">Notice the translation of 20 pixels in both the horizontal and vertical axes. This small offset separates the axes from the canvas’s upper and left sides. The resulting sequence of transformations is stored in <span class="literal">transform_seq</span>.</p>&#13;
<p class="indent">Let’s now dive into the key functions for the simulation: <span class="literal">update_system</span>, <span class="literal">redraw</span>, and <span class="literal">should_continue</span>. Edit <em>simulation.py</em> to look like the code in <a href="ch12.xhtml#ch12lis21">Listing 12-21</a>.</p>&#13;
<pre>from tkinter import Tk, Canvas, Button&#13;
&#13;
from geom2d import affine_transforms as tf&#13;
from graphic.simulation import CanvasDrawing&#13;
&#13;
&#13;
def simulate(transform, primitives, config):&#13;
    # ---------- UI DEFINITION ---------- #&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    # ---------- UPDATE, DRAW &amp; CONTINUE ---------- #&#13;
    frames = config['frames']&#13;
    transform_seq = __make_transform_sequence(transform, frames)&#13;
  <span class="ent">➊</span> drawing = CanvasDrawing(canvas, transform_seq[0])&#13;
&#13;
    def update_system(time_delta_s, time_s, frame):&#13;
     <span class="ent">➋</span> drawing.transform = transform_seq[frame - 1]&#13;
        tk.update()&#13;
&#13;
  <span class="ent">➌</span> def redraw():&#13;
        drawing.clear_drawing()&#13;
&#13;
        drawing.outline_width = config['geometry']['stroke-width']&#13;
        drawing.outline_color = config['geometry']['stroke-color']&#13;
&#13;
        for circle in primitives['circs']:&#13;
            drawing.draw_circle(circle)&#13;
&#13;
        for rect in primitives['rects']:&#13;
            drawing.draw_rectangle(rect)&#13;
&#13;
        for polygon in primitives['polys']:&#13;
            drawing.draw_polygon(polygon)&#13;
&#13;
        for segment in primitives['segs']:&#13;
            <span epub:type="pagebreak" id="page_329"/>drawing.draw_segment(segment)&#13;
&#13;
    def should_continue(frame, time_s):&#13;
     <span class="ent">➍</span> return frame &lt;= frames&#13;
&#13;
    # ---------- MAIN LOOP ---------- #&#13;
    redraw()&#13;
    tk.mainloop()&#13;
&#13;
&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption"><a id="ch12lis21"/><em>Listing 12-21: Implementing drawing and updating</em></p>&#13;
<p class="indent">After the sequence of transformations we recently computed, we instantiate our <span class="literal">CanvasDrawing</span> class, passing in the Tkinter canvas and the first affine transformations <span class="ent">➊</span>. Note that we imported the class at the top of the file and that the first transformation on the sequence is the initial transformation for the geometric primitives.</p>&#13;
<p class="indent">Then, we implement the <span class="literal">update_system</span> function. This function updates the drawing’s transformation according to the current frame number <span class="ent">➋</span> and invokes <span class="literal">tk</span>’s <span class="literal">update</span> method. To compute the index used to obtain the corresponding transformation, we subtract 1 from the frame number. Recall that the frames are counted from 1, while a Python list’s first index is 0. It’s important to realize that, in this particular simulation, it’s not the system (made up of the geometric primitives) that gets updated every frame but rather the affine transformation, a property of the <span class="literal">CanvasDrawing</span> class, that gets a new value.</p>&#13;
<p class="indent">Next is the <span class="literal">redraw</span> function <span class="ent">➌</span>. It first clears the canvas and sets the size and color for the outlines of the shapes we’re drawing. These two values come from the configuration file. Then, it iterates through all the primitives in the dictionary, calling the corresponding draw command from the <span class="literal">CanvasDrawing</span> class. Thanks to our previous work on that class, drawing to the canvas is that simple.</p>&#13;
<p class="indent">Last is the implementation of <span class="literal">should_continue</span> that simply compares the current frame number to the total number of frames for the animation <span class="ent">➍</span>.</p>&#13;
<h4 class="h4" id="ch00lev2sec142"><strong><em>Drawing the Axes</em></strong></h4>&#13;
<p class="noindent">We’re almost there! Let’s add some code to draw the x- and y-axes as well as a call to the simulation’s main loop (not to be confused with Tkinter’s <span class="literal">mainloop</span> function). The axes will provide a good visual reference for how the space is transformed. Include the changes in <a href="ch12.xhtml#ch12lis22">Listing 12-22</a>.</p>&#13;
<pre>from tkinter import Tk, Canvas, Button&#13;
&#13;
from geom2d import affine_transforms as tf, Segment, Point&#13;
from graphic.simulation import CanvasDrawing, main_loop&#13;
&#13;
&#13;
<span epub:type="pagebreak" id="page_330"/>def simulate(transform, primitives, config):&#13;
    # ---------- UI DEFINITION ---------- #&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def start_simulation():&#13;
        tk.update()&#13;
     <span class="ent">➊</span> main_loop(update_system, redraw, should_continue)&#13;
&#13;
    Button(tk, text='Play', command=start_simulation) \&#13;
        .grid(row=1, column=0)&#13;
&#13;
    # ---------- UPDATE, DRAW &amp; CONTINUE ---------- #&#13;
    frames = config['frames']&#13;
    transform_seq = __make_transform_sequence(transform, frames)&#13;
    axis_length = config['axes']['length']&#13;
 <span class="ent">➋</span> x_axis = Segment(Point(0, 0), Point(axis_length, 0))&#13;
 <span class="ent">➌</span> y_axis = Segment(Point(0, 0), Point(0, axis_length))&#13;
    drawing = CanvasDrawing(canvas, transform_seq[0])&#13;
&#13;
    def update_system(time_delta_s, time_s, frame):&#13;
        drawing.transform = transform_seq[frame - 1]&#13;
        tk.update()&#13;
&#13;
    def redraw():&#13;
        drawing.clear_drawing()&#13;
&#13;
        drawing.outline_width = config['axes']['stroke-width']&#13;
        drawing.outline_color = config['axes']['x-color']&#13;
     <span class="ent">➍</span> drawing.draw_arrow(&#13;
            x_axis,&#13;
            config['axes']['arrow-length'],&#13;
            config['axes']['arrow-height']&#13;
        )&#13;
&#13;
        drawing.outline_color = config['axes']['y-color']&#13;
     <span class="ent">➎</span> drawing.draw_arrow(&#13;
            y_axis,&#13;
            config['axes']['arrow-length'],&#13;
            config['axes']['arrow-height']&#13;
        )&#13;
&#13;
        <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def should_continue(frame, time_s):&#13;
        return frame &lt;= frames&#13;
    <span epub:type="pagebreak" id="page_331"/># ---------- MAIN LOOP ---------- #&#13;
    redraw()&#13;
    tk.mainloop()&#13;
&#13;
&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption"><a id="ch12lis22"/><em>Listing 12-22: Drawing the axes and main loop</em></p>&#13;
<p class="indent">First comes the most important addition: the inclusion of a call to the <span class="literal">main_loop</span> function <span class="ent">➊</span>. We pass in the functions defined next to take care of the updating, redrawing, and continuation of the simulation. Make sure you import the <span class="literal">main_loop</span> function at the top of the file.</p>&#13;
<p class="indent">Next come the definitions of <span class="literal">x_axis</span> <span class="ent">➋</span> and <span class="literal">y_axis</span> <span class="ent">➌</span>, both defined as segments. Each length is a parameter we read from the configuration file and store in <span class="literal">axis_length</span>. To draw the axes, we need to take into account that they have a different stroke width and color than the other geometry. We’ve added the code for these properties in the <span class="literal">redraw</span> function, just below the call to <span class="literal">clear_drawing</span>.</p>&#13;
<p class="indent">After setting the corresponding outline width and color, we use our <span class="literal">CanvasDrawing</span> class’s <span class="literal">draw_arrow</span> method, passing it the segment that defines the <span class="literal">x_axis</span> geometry and the size of the arrow <span class="ent">➍</span>. The size of the arrow, once again, comes from the configuration. We have to add the same code to draw <span class="literal">y_axis</span> <span class="ent">➎</span>, but this time only the stroke color needs to be updated: the axes are drawn using the same stroke width.</p>&#13;
<p class="indent">Well, we’ve been incrementally writing a lot of code. Just for reference, <a href="ch12.xhtml#ch12lis23">Listing 12-23</a> shows the final <em>simulation.py</em> file. Take a look and make sure you got it all.</p>&#13;
<pre>from tkinter import Tk, Canvas, Button&#13;
&#13;
from geom2d import affine_transforms as tf, Segment, Point&#13;
from graphic.simulation import CanvasDrawing, main_loop&#13;
&#13;
&#13;
def simulate(transform, primitives, config):&#13;
    # ---------- UI DEFINITION ---------- #&#13;
    tk = Tk()&#13;
    tk.title("Affine Transformations")&#13;
&#13;
    canvas = Canvas(tk, width=800, height=800)&#13;
    canvas.grid(row=0, column=0)&#13;
&#13;
    def start_simulation():&#13;
        tk.update()&#13;
        main_loop(update_system, redraw, should_continue)&#13;
&#13;
    Button(tk, text='Play', command=start_simulation) \&#13;
        .grid(row=1, column=0)&#13;
&#13;
    <span epub:type="pagebreak" id="page_332"/># ---------- UPDATE, DRAW &amp; CONTINUE ---------- #&#13;
    frames = config['frames']&#13;
    transform_seq = __make_transform_sequence(transform, frames)&#13;
    axis_length = config['axes']['length']&#13;
    x_axis = Segment(Point(0, 0), Point(axis_length, 0))&#13;
    y_axis = Segment(Point(0, 0), Point(0, axis_length))&#13;
    drawing = CanvasDrawing(canvas, transform_seq[0])&#13;
&#13;
    def update_system(time_delta_s, time_s, frame):&#13;
        drawing.transform = transform_seq[frame - 1]&#13;
        tk.update()&#13;
&#13;
    def redraw():&#13;
        drawing.clear_drawing()&#13;
&#13;
        drawing.outline_width = config['axes']['stroke-width']&#13;
        drawing.outline_color = config['axes']['x-color']&#13;
        drawing.draw_arrow(&#13;
            x_axis,&#13;
            config['axes']['arrow-length'],&#13;
            config['axes']['arrow-height']&#13;
        )&#13;
&#13;
        drawing.outline_color = config['axes']['y-color']&#13;
        drawing.draw_arrow(&#13;
            y_axis,&#13;
            config['axes']['arrow-length'],&#13;
            config['axes']['arrow-height']&#13;
        )&#13;
&#13;
        drawing.outline_width = config['geometry']['stroke-width']&#13;
        drawing.outline_color = config['geometry']['stroke-color']&#13;
&#13;
        for circle in primitives['circs']:&#13;
            drawing.draw_circle(circle)&#13;
&#13;
        for rect in primitives['rects']:&#13;
            drawing.draw_rectangle(rect)&#13;
&#13;
        for polygon in primitives['polys']:&#13;
            drawing.draw_polygon(polygon)&#13;
&#13;
        for segment in primitives['segs']:&#13;
            drawing.draw_segment(segment)&#13;
&#13;
    def should_continue(frame, time_s):&#13;
        <span epub:type="pagebreak" id="page_333"/>return frame &lt;= frames&#13;
&#13;
    # ---------- MAIN LOOP ---------- #&#13;
    redraw()&#13;
    tk.mainloop()&#13;
&#13;
&#13;
def __make_transform_sequence(end_transform, frames):&#13;
    start_transform = tf.AffineTransform(sx=1, sy=1, tx=20, ty=20)&#13;
    return tf.ease_in_out_interpolation(&#13;
        start_transform, end_transform, frames&#13;
    )</pre>&#13;
<p class="caption"><a id="ch12lis23"/><em>Listing 12-23: Complete simulation code</em></p>&#13;
<p class="indent">At last! We’re now ready to see the result, so execute the application using the run configuration or the bash script. A window with the geometric primitives as they were defined in the input file should appear (see the left image in <a href="ch12.xhtml#ch12fig5">Figure 12-5</a>). Notice also the x- and y-axes, which we drew as arrows; can you spot the 20 pixels of separation we gave the origin?</p>&#13;
<p class="indent">Now click <strong>Play</strong> and watch the result. The simulation should start slow, then build some speed, and finally decelerate toward its end. We achieved this effect using ease-in-out interpolation, which makes the animation look smooth and realistic.</p>&#13;
<div class="image"><img src="../images/12fig05.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch12fig5"><em>Figure 12-5: Simulating an affine transformation</em></p>&#13;
<p class="indent">Now is a good time to go back to “Interpolating Transformations” on <a href="ch07.xhtml#ch00lev1sec45">page 192</a> and give it a second read. After seeing the ease-in-out effect in action, you can build a solid visual intuition for <a href="ch07.xhtml#ch07eqa11">Equation 7.11</a> (<a href="ch07.xhtml#ch07eqa11">page 194</a>), which defines the pace for the animation you just witnessed.</p>&#13;
<p class="indent">Take some time to play with your application. Change some parameters to see the effect on the resulting simulation. For example, try to change the offset of the initial affine transformation (the translation components <span class="literal">tx</span> and <span class="literal">ty</span>). Play with the stroke widths and colors in the configuration file, and <span epub:type="pagebreak" id="page_334"/>edit the number of frames. Another interesting exercise is editing the affine transformation and the geometric primitives defined in the input file <em>test.txt</em>.</p>&#13;
<h3 class="h3" id="ch00lev1sec77"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, we developed our second application, one that animates the effect of affine transformations. Like before, we used regular expressions to parse the input and used our geometry library for the heavy lifting. This time the output was an animation, which, thanks to the work we did in the previous chapters, was straightforward to implement.</p>&#13;
<p class="indent">This chapter concludes <a href="part03.xhtml#part03">Part III</a> of the book. In this part, we learned to create SVG vector graphics and animated simulations from our geometric primitives, key skills for building good engineering software. We used that knowledge to build two simple applications: one that determines a circle passing through three given points and one that animates geometric primitives under an affine transformation. Those were simple applications, but they illustrate how powerful geometric and visual primitives really are.</p>&#13;
<p class="indent">In the next part of the book, we’ll look at how to solve systems of equations, another key piece for any engineering application. That is the last tool our <em>Mechanics</em> package needs. After exploring that topic, the rest of the book will be focused on solving mechanics problems using only the powerful primitives we coded ourselves.</p>&#13;
</body></html>