- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do One Thing Well and Other Unix Principles
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the Unix philosophy: Write programs that do one thing and do it well.
    Write programs to work together. Write programs to handle text streams, because
    that is a universal interface.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Douglas McIlroy
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The prevailing philosophy of the Unix operating system is simple: do one thing
    well. This means, for example, that it’s generally better to create a function
    or module that can solve one problem, reliably and efficiently, than to try to
    tackle multiple problems at the same time. Later in this chapter, you’ll see some
    Python code examples of “do one thing well” in action and learn how the Unix philosophy
    applies to programming. I’ll then present the top principles employed by some
    of the world’s most accomplished computer engineers in creating today’s operating
    systems. If you’re a software engineer, you’ll find valuable advice on writing
    better code in your own projects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But first things first: What is Unix anyway, and why should you care?'
  prefs: []
  type: TYPE_NORMAL
- en: The Rise of Unix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unix is a design philosophy that inspired many of the most popular operating
    systems today, including Linux and macOS. The family of Unix operating systems
    emerged in the late 1970s when Bell Systems made the source code of its technology
    open to the public. Since then, a multitude of extensions and new versions have
    been developed by universities, individuals, and corporations.
  prefs: []
  type: TYPE_NORMAL
- en: Today, the trademarked Unix standard certifies that operating systems meet specific
    quality requirements. Unix and Unix-like operating systems have a major impact
    on computing. About 7 out of 10 web servers run on Linux systems that use Unix
    as their base. Most supercomputers today run Unix-based systems. Even the macOS
    is a registered Unix system.
  prefs: []
  type: TYPE_NORMAL
- en: Linus Torvalds, Ken Thompson, Brian Kernighan—the list of Unix developers and
    maintainers contains the names of some of the world’s most impactful coders across
    the globe. You would think there must be great organizational systems in place
    to allow programmers all over the world to collaborate to build the massive Unix
    ecosystem comprising millions of lines of code. And rightly so! The philosophy
    that enables this scale of collaboration is the acronym DOTADIW (seriously)—or
    *do one thing and do it well*. Whole books have been written about the Unix philosophy,
    so here we’ll just focus on the most relevant ideas and use Python code snippets
    to showcase some examples. To the best of my knowledge, no book has ever contextualized
    the Unix principles for the Python programming language before. So, let’s get
    started!
  prefs: []
  type: TYPE_NORMAL
- en: Philosophy Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic idea of the Unix philosophy is to build simple, clear, concise, modular
    code that is easy to extend and maintain. This can mean many different things—more
    on this later in the chapter—but the goal is to allow many humans to work together
    on a codebase by prioritizing readability over efficiency and favoring composability
    over monolithic design. Monolithic applications are designed without modularity,
    meaning large parts of the code logic cannot be reused, executed, or debugged
    without accessing the overall application.
  prefs: []
  type: TYPE_NORMAL
- en: Say you write a program that takes a uniform resource locator (URL) and prints
    the HTML from this URL on the command line. Let’s call this program `url_to_html()`.
    According to the Unix philosophy, this program should do one thing well, and that
    one thing is to take the HTML from the URL and print it to the shell (see [Listing
    7-1](#listing7-1)). That’s it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-1: A simple code function that reads the HTML from a given URL and
    returns the string'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s all you need. Don’t add more functionality, such as filtering out tags
    or fixing bugs. For instance, you might be tempted to add code to fix common mistakes
    a user might make, like forgetting closing tags, such as a `<span>` tag that is
    not closed by `</span>` as highlighted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: According to the Unix philosophy, even if you spot these types of mistakes,
    you don’t fix them within this specific function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another temptation for this simple HTML function is to automatically fix formatting.
    For example, the following HTML code doesn’t look pretty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You may prefer this code formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: However, your function’s name is `url_to_html()`, not `prettify_html()`. Adding
    a feature such as code prettifying would add a second functionality that may not
    be needed by some users of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Rather, you’d be encouraged to create another function called `prettify_html(url)`
    whose “one thing” is to fix stylistic issues of the HTML. This function may internally
    use the function `url_to_html()` to get the HTML before processing it further.
  prefs: []
  type: TYPE_NORMAL
- en: By focusing every function on one purpose only, you improve the maintainability
    and extensibility of your code. The output of one program is the input of another.
    You reduce complexity, avoid clutter in the output, and focus on implementing
    one thing well.
  prefs: []
  type: TYPE_NORMAL
- en: Although a single subprogram may look small, even trivial, you can combine those
    subprograms to create more complicated programs while keeping them easy to debug.
  prefs: []
  type: TYPE_NORMAL
- en: 15 Useful Unix Principles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll next dive deep into the 15 Unix principles most relevant for today and,
    where possible, implement them in Python examples. I’ve compiled these principles
    from Unix coding experts Eric Raymond and Mike Gancarz and adapted them to modern
    Python programming. You’ll notice that many of these principles comply or overlap
    with other principles in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Make Each Function Do One Thing Well
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The overarching principle of the Unix philosophy is to *do one thing well*.
    Let’s see what that would look like in code. In [Listing 7-2](#listing7-2), you
    implement a function `display_html()` that takes a URL as a string and displays
    the prettified HTML on that URL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-2: Make each function or program do one thing well.'
  prefs: []
  type: TYPE_NORMAL
- en: This code is depicted in [Figure 7-1](#figure7-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Boxes linking a few html functions to several URLs and lines of code, showing
    the modularity and efficiency of using functions with a single focus.](image_fi/502185c07/f07001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-1: Overview of multiple simple functions—each doing one thing well—working
    together to accomplish a bigger task'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code provides a sample implementation that performs the following steps
    in the function `display_html`:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the HTML from a given URL location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix some missing tags.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prettify the HTML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the result to the function caller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you run the code with a URL that points to the not-very-pretty HTML code
    `'< a href="https://finxter.com">Solve next Puzzle</a>'`, the function `display_html`
    would fix the poorly formatted (and incorrect) HTML by brokering the inputs and
    outputs of the small code functions, because each of those does its one thing
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'You would print the result of the main function with this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This code would print the HTML code to your shell with a new tag and the excess
    whitespace removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Think of this whole program as a browser in your terminal. Alice calls the
    function `display_html(url)`, which takes the URL and passes it to another function
    `url_to_html(url)`, which collects the HTML from a given URL location. No need
    to implement the same functionality twice. Fortunately, the coder of the function
    `url_to_html()` has kept that function minimal so you can use its returned HTML
    output directly as an input to the function `fix_missing_tags(html)`. In Unix
    lingo, this is called *piping*: the output of one program is passed as an input
    to another program. The return value of `fix_missing_tags()` is the fixed HTML
    code with a closing `</span>` tag that was missing in the original HTML. You then
    pipe the output into the function `prettify_html(html)` and wait for the result:
    the corrected HTML with indentation to make it user-friendly. Only then does the
    function `display_html(url)` return the prettified and fixed HTML code to Alice.
    You see that a series of small functions connected and piped together can accomplish
    quite big tasks!'
  prefs: []
  type: TYPE_NORMAL
- en: In your project, you could implement another function that doesn’t prettify
    the HTML but only adds the `<!DOCTYPE html>` tag. You could then implement a third
    function that prettifies the HTML but doesn’t add the new tag. By staying small,
    you can easily create new code based on the existing functionality, and there
    wouldn’t be a lot of redundancy. The modular design of the code enables reusability,
    maintainability, and extensibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare this version to a possible monolithic implementation where the function
    `display_html(url)` would have to do all those small tasks by itself. You couldn’t
    partially reuse functionality, such as retrieving the HTML code from a URL or
    fixing faulty HTML code. If you use a monolithic code function that does all things
    itself, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The function is now more complicated: it handles multiple tasks instead of
    focusing on one. Even worse, if you implement variants of the same function without
    removing the whitespace after an opening tag `''<''`, you’d have to copy and paste
    the remaining code lines. This would lead to code redundancy and reduced readability.
    The more functionality you add, the worse it will get!'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Simple Is Better Than Complex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Simple is better than complex* is the foremost principle of this whole book.
    You’ve already seen it in many shapes and forms—I stress this point because if
    you don’t take decisive action to simplify, you’ll breed complexity. In Python,
    the principle *simple is better than complex* even made it into the unofficial
    rule book. If you open a Python shell and enter `import this`, you obtain the
    famous *Zen of Python* (see [Listing 7-3](#listing7-3)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-3: The Zen of Python'
  prefs: []
  type: TYPE_NORMAL
- en: Since we’ve covered the concept of simplicity at length already, I won’t go
    over it again here. If you’re still wondering *why* simple is better than complex,
    go back to Chapter 1 about the negative productivity effects that originate in
    high complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Small Is Beautiful
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rather than writing big code blocks, write small functions and work as an architect
    brokering the interaction between those functions, as exemplified in [Figure 7-1](#figure7-1).
    There are three main reasons to keep your program small:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduce complexity.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code is harder to comprehend as it gets longer. This is a cognitive fact: your
    brain can keep track of only so many chunks of information simultaneously. Too
    many pieces of information make it hard to see the big picture. By going small
    and reducing the number of code lines in a function, you *improve readability*
    and reduce the likelihood of injecting costly bugs into your codebase.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Improve maintainability.**'
  prefs: []
  type: TYPE_NORMAL
- en: Structuring your code in many small pieces of functionality makes it easier
    to maintain. Adding more small functions is unlikely to incur side effects, whereas
    in a big, monolithic code block, any changes you make can easily have unintended
    global effects, especially if multiple programmers are working on the code at
    the same time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Improve testability.**'
  prefs: []
  type: TYPE_NORMAL
- en: Many modern software companies use *test-driven development*, which involves
    using unit tests to stress-test inputs to each function and unit and compare the
    outputs with the expected ones. This allows you to find and isolate bugs. Unit
    tests are much more effective and easier to implement in small code, where each
    function focuses on just one thing, so you know what the expected result should
    be.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Python itself, rather than an example of small code in Python, is the best example
    of this principle. Any master coder uses other people’s code to improve their
    coding productivity. Millions of developers have spent countless hours optimizing
    code that you can import into your code in a split second. Python, like most other
    programming languages, provides this functionality through libraries. Many of
    the less frequently used libraries don’t ship with the default implementation
    and need to be explicitly installed. By not providing all the libraries as built-in
    functionality, the Python installation on your computer remains relatively small
    but doesn’t sacrifice the potential power of external libraries. On top of this,
    the libraries themselves are relatively small—all of them focus on a restricted
    subset of functions. Rather than one monolithic library to rule all problems,
    we have many small libraries, each responsible for a small part of the picture.
    Small is beautiful.
  prefs: []
  type: TYPE_NORMAL
- en: Every few years, new architectural patterns appear with the promise of breaking
    up large, monolithic applications into beautiful, small applications to scale
    up the software development cycle. Recent examples have been the Common Object
    Request Broker Architecture (CORBA), service-oriented architecture (SOA), and
    microservices. The idea of these is to break up a large software block into a
    series of independently deployable components that can then be accessed by multiple
    programs rather than just one. The hope is to accelerate the overall progress
    in the software development space by sharing and building upon each other’s microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The underlying driver of these trends is the idea of writing modular and reusable
    code. By studying the ideas presented in this chapter, you’ve prepared yourself
    to quickly and fundamentally understand these and upcoming trends with the same
    direction toward modularity. It pays to stay ahead of the curve by applying sound
    principles from the start.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Build a Prototype as Soon as Possible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Unix team is a keen proponent of the principle we discussed in Chapter 3,
    *build an MVP*. This allows you to avoid getting stuck in the cycle of perfectionism,
    adding more and more features and exponentially increasing complexity without
    need. If you work on large software applications such as operating systems, you
    simply cannot afford to go down the route of complexity!
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-2](#figure7-2) shows an example of an early app launch that’s stuffed
    itself full of unnecessary features, in defiance of the MVP principle.'
  prefs: []
  type: TYPE_NORMAL
- en: '![screenshot of a version of finxter with too many features, making it difficult
    to determine the focus.](image_fi/502185c07/f07002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-2: Finxter.com app versus Finxter MVP'
  prefs: []
  type: TYPE_NORMAL
- en: The app has features like interactive solution checking, puzzle voting, user
    statistics, user management, premium functionality, and related videos along with
    simple features such as a logo. All of these are unnecessary for an initial launch
    of the product. In fact, the MVP of the Finxter application should just be an
    image of a simple code puzzle shared on social media. This is enough to validate
    the hypothesis of user demand without spending years building the application.
    *Fail early, fail often, fail forward.*
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Choose Portability Over Efficiency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Portability* is the ability of a system or a program to be moved from one
    environment to another and still function properly. One major advantage of software
    is its portability: you can write a program on your computer, and millions of
    users can run the same program on their computers without adapting it at all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, portability comes at the cost of efficiency. This *portability/efficiency
    trade-off* is well documented in technical literature: you can reach higher efficiency
    by tailoring software to just one type of environment, but this sacrifices portability.
    *Virtualization* is a great example of this trade-off: by placing an additional
    layer of software between a piece of software and the underlying infrastructure
    on which the software runs, your program can run on almost any *physical machine*.
    Additionally, a virtual machine can carry the current execution state from one
    physical machine to another. This improves the portability of the software. However,
    the added layer required for virtualization reduces the runtime and memory efficiency
    because of the additional overhead of intermediating between the programs and
    the physical machine.'
  prefs: []
  type: TYPE_NORMAL
- en: The Unix philosophy advocates choosing portability over efficiency; this makes
    sense since the operating system is used by so many.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the rule of thumb to prefer portability also applies to the broader audience
    of software developers. Reducing portability means that you reduce your application’s
    value. Today, it is common to improve portability radically—even at the cost of
    efficiency. Web-based applications are expected to run on every computer with
    a browser, whether macOS, Windows, or Linux. Web applications are also increasingly
    accessible, accommodating visual impairment for example, even though hosting a
    website that facilitates accessibility may be less efficient. Many resources are
    much more valuable than computing cycles: human lives, human time, and other second-order
    consequences of computers.'
  prefs: []
  type: TYPE_NORMAL
- en: But what does it mean to program for portability, apart from these general considerations?
    In [Listing 7-4](#listing7-4) we create a function that computes the average of
    the specified arguments—the way we’ve written it, it’s not optimized for portability.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-4: Average function, not maximally portable'
  prefs: []
  type: TYPE_NORMAL
- en: This code is not portable for two reasons. First, the function name `calculate_average_age()`
    is not general enough to be usable in any other context, despite the fact that
    it simply calculates an average. You might not think to use it, for example, to
    calculate the average number of website visitors. Second, it uses a library needlessly
    because you could easily calculate the average without any external library (see
    [Listing 7-5](#listing7-5)). It’s generally a great idea to use libraries, but
    only if they add value. In this case, adding a library reduces portability because
    the user may not have this library installed; plus, it adds little, if any, efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 7-5](#listing7-5) we recreate the function with superior portability.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-5: Average function, portable'
  prefs: []
  type: TYPE_NORMAL
- en: We rename the functions to be more general and do away with the unnecessary
    import. Now you don’t have to worry if the library becomes depreciated, and you
    can port the same code to your other projects.
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Store Data in Flat Text Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Unix philosophy encourages the use of *flat text files* for storing data.
    Flat text files are simple text or binary files without advanced mechanisms to
    access the file content—unlike many more efficient but also more complicated file
    formats used by, for example, the database community. These are simple, human-readable
    data files. The common comma-separated values (CSV) format is an example of a
    flat file format, where each line relates to one data entry (see [Listing 7-6](#listing7-6))
    and someone new to the data can glean some understanding just by looking at it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-6: Data on stolen guns, from [Data.gov](https://catalog.data.gov/dataset/stolen-gun),
    provided as a flat file format (CSV)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can share flat text files easily, open them in any text editor, and modify
    them manually. However, this convenience comes at the cost of efficiency: a data
    format specialized for a specific purpose could store and read the data much more
    efficiently. Databases, for example, use their own data files on disk, which use
    optimizations, like detailed indices and compression schemes to represent dates.
    If you opened them, you wouldn’t understand a thing. These optimizations allow
    programs to read from the data with less memory consumption and less overhead
    than general flat text files. In a flat file, a system would have to scan the
    whole file to read a specific line. Web applications also require a more efficient
    optimized data representation to allow users quick access with low latency, so
    they rarely use flat representations and databases.'
  prefs: []
  type: TYPE_NORMAL
- en: However, you should use optimized data representations only if you’re sure you
    need them—for example, if you create an application that is highly performance
    sensitive, such as the Google search engine that can find the web documents most
    relevant to a given user query in milliseconds! For many smaller applications,
    such as training a machine learning model from a real-world dataset with 10,000
    entries, the CSV format is the recommended way to store the data. Using a database
    with a specialized format would reduce portability and add unnecessary complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-7](#listing7-7) gives an example of one situation in which the flat
    format is preferable. It uses Python, one of the most popular languages for data
    science and machine learning applications. Here we want to perform a data analysis
    task on a dataset of images (faces), so we load data from a flat CSV file and
    process it, favoring the portable approach over the more efficient one of using
    a database.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-7: Load data from a flat file for a Python data analysis task'
  prefs: []
  type: TYPE_NORMAL
- en: In the function `fetch_olivetti_faces`, we load scikit-learn’s *Olivetti faces*
    dataset, which contains a set of face images. The loading functions simply read
    this data and load it into memory before starting with the real computation. No
    database or hierarchical data structures are needed. The program is self-contained
    without installing a database or setting up advanced database connections.
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Use Software Leverage to Your Advantage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using *leverage* means applying a small amount of energy to multiply the effects
    of your effort. In finance, for example, leverage means to use other people’s
    money to invest and grow. In a large corporation, it might mean using an extensive
    distributor network to place products in stores worldwide. As a programmer, you
    should leverage the collective wisdom of generations of coders before you: use
    libraries for complex functionality rather than coding it from scratch, use StackOverflow
    and the wisdom of the crowd to fix bugs in your code, or ask other programmers
    to review your code. These are forms of leverage that allow you to accomplish
    far more with far less effort.'
  prefs: []
  type: TYPE_NORMAL
- en: The second source of leverage comes from computing power. A computer can perform
    work much faster (and at much lower cost) than a human being. Create better software,
    share it with more people, employ more computing power, and use other people’s
    libraries and software more often. Good coders create good source code quickly,
    but great coders tap into the many sources of leverage available to them to elevate
    their code.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, [Listing 7-8](#listing7-8) shows a one-liner program from my
    book *Python One-Liners* (No Starch Press, 2020) that scrapes a given HTML document
    and finds all occurrences of a URL that contains the substring `'finxter'` and
    either `'test'` or `'puzzle'`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-8: One-liner solution to analyze web page links'
  prefs: []
  type: TYPE_NORMAL
- en: By importing the `re` library, we leverage the powerful technology of regular
    expressions, instantly putting thousands of lines of code to work and allowing
    us to write the entire program with a single line. Leverage is a powerful companion
    on your path to becoming a great coder. For instance, using libraries in your
    code rather than implementing everything yourself is like using an app to plan
    your journey rather than working out every detail with a paper map.
  prefs: []
  type: TYPE_NORMAL
- en: 8\. Avoid Captive User Interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Captive user interfaces* are those that require the user to interact with
    the program before proceeding with the main execution flow. Examples are mini-programs
    such as Secure Shell (SSH), `top`, `cat`, and `vim`, as well as programming language
    features such as Python’s `input()` function. Captive user interfaces limit the
    usability of the code because they’re designed to run only with human involvement.
    However, oftentimes the functionality provided by the code behind the captive
    user interface is also useful for automated programs that must be able to run
    without manual interaction with users. Roughly speaking, if you put good code
    behind a captive user interface, it’s not reachable without user interaction!'
  prefs: []
  type: TYPE_NORMAL
- en: Say you create a simple life expectancy calculator in Python that takes a user’s
    age as input and returns the expected number of years left based on a straightforward
    heuristic.
  prefs: []
  type: TYPE_NORMAL
- en: “If you’re under 85, your life expectancy is 72 minus 80 percent of your age.
    Otherwise, it’s 22 minus 20 percent of your age.”
  prefs: []
  type: TYPE_NORMAL
- en: Your initial Python code might look something like [Listing 7-9](#listing7-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-9: Life expectancy calculator—a simple heuristic—implemented as a
    captive user interface'
  prefs: []
  type: TYPE_NORMAL
- en: Here are some runs of the code in [Listing 7-9](#listing7-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you want to try it yourself, I’ve shared the program in a Jupyter notebook
    at [https://blog.finxter.com/clean-code/#Life_Expectancy_Calculator/](https://blog.finxter.com/clean-code/#Life_Expectancy_Calculator/).
    But, please, don’t take it too seriously!
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Listing 7-9](#listing7-9), we used Python’s `input()` function, which blocks
    program execution until the user input is received. Without user input, the code
    doesn’t do anything. This captive user interface limits the usability of the code.
    If you wanted to calculate the life expectancy for every age from 1 to 100 and
    plot it, you’d have to manually enter 100 different ages and store the results
    in a separate file. Then, you’d have to copy and paste the results into a new
    script to plot them. As it is now, the function really does two things: process
    the user input and calculate the life expectancy, which also violates the first
    Unix principle: make each function do one thing well.'
  prefs: []
  type: TYPE_NORMAL
- en: To make the code compliant with this principle, we’ll separate the user interface
    from the functionality, which is often a great idea to improve your code (see
    [Listing 7-10](#listing7-10)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-10: Life expectancy calculator—a simple heuristic—without captive
    user interface'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in [Listing 7-10](#listing7-10) is functionally identical to [Listing
    7-9](#listing7-9), with one significant advantage: we can use this new function
    in various situations, even those that are unexpected by the initial developer.
    In [Listing 7-11](#listing7-11) we use the function to calculate the life expectancy
    for input ages between 0 and 99 and plot the result; note the portability gained
    from removing the user input interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-11: Code to plot the life expectancy for years 0–99'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-3](#figure7-3) shows the resulting plot.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Resulting plot of Listing 7-11, showing a declining line starting at the
    top right; the x-axis shows “Age” and the y-axis shows “number of years left.”
    ](image_fi/502185c07/f07003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-3: How the heuristic works for input years 0–99'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, any heuristic is crude by design—but the focus here is on how avoiding
    a captive user interface has helped us put the code to work to produce this plot.
    If we hadn’t adhered to the principle, we couldn’t have reused the original code
    function `your_life_expectancy` because the captive user interface required a
    user input for each year 0 to 99\. By considering the principle, we’ve simplified
    the code and opened up all kinds of future programs to use and build upon the
    heuristic. Instead of optimizing for one specific use case, we’ve written the
    code in a general way that can be used by hundreds of different applications.
    Why not create a library out of it?
  prefs: []
  type: TYPE_NORMAL
- en: 9\. Make Every Program a Filter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s a good argument to be made that every program already is a filter. A
    filter transforms an input to an output using a specific filtering mechanism.
    This allows us to easily string together multiple programs by using the output
    of one as the input of another, thereby increasing the reusability of your code
    significantly. For example, it’s generally not a good practice to print the result
    of a computation in the function itself—instead, the philosophy suggests that
    the program should return a string that can then be printed, written into a file,
    or used as input for another program.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a program that sorts a list can be considered a filter that filters
    the unsorted elements into a sorted order, as in [Listing 7-12](#listing7-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-12: This insertion sort algorithm filters an unsorted list to a sorted
    list.'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm creates a new list and inserts each element at the position where
    all elements on the left are smaller than the inserted element. The function uses
    a complex filter to change the order of the elements, transforming the input list
    into a sorted output list.
  prefs: []
  type: TYPE_NORMAL
- en: If any program already is a filter, you should design it as such by using intuitive
    input/output mapping. Let me explain this next.
  prefs: []
  type: TYPE_NORMAL
- en: 'The gold standard for filters is a *homogeneous* input/output mapping where
    one type of input is mapped to the same type of output. For example, if someone
    talks to you in English, they expect you to respond in English—and not in another
    language. Similarly, if a function takes an input argument, the expected output
    is a function return value. If a program reads from a file, the expected output
    is a file. If a program reads the input from the standard input, it should write
    the program to the standard output. You get the point: the most intuitive way
    to design a filter is to keep the data in the same category.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-13](#listing7-13) shows a negative example with *heterogeneous*
    input/output mapping where we build an `average()` function that transforms the
    input arguments into their average—but instead of returning the average value,
    `average()` prints the result to the shell.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-13: Negative example of heterogeneous input/output mapping'
  prefs: []
  type: TYPE_NORMAL
- en: A better approach, shown in [Listing 7-14](#listing7-14), makes the function
    `average()` return the average value (homogeneous input/output mapping), which
    you can then print to the standard output in a separate function call using the
    `print()` function. This is better because it allows you, for example, to write
    the output into a file rather than print it—or even use it as an input for another
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-14: Positive example of homogeneous input/output mapping'
  prefs: []
  type: TYPE_NORMAL
- en: Sure, some programs filter from one category to another—for example, writing
    a file to the standard output or translating English to Spanish. But following
    the principle of creating programs that do one thing well (see Unix Principle
    1), these programs should do nothing else. This is the gold standard of writing
    intuitive and natural programs—design them as filters!
  prefs: []
  type: TYPE_NORMAL
- en: 10\. Worse Is Better
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This principle suggests that developing code with less functionality is often
    the better approach in practice. When resources are limited, it’s better to release
    a worse product and be first on the market than strive continually to make it
    better before you can release it. This principle, conceived by list processing
    (LISP) developer Richard Gabriel in the late eighties, is similar to the MVP principle
    from Chapter 3. Don’t take this counterintuitive principle too literally. Worse
    is not better from a qualitative perspective. If you had infinite time and resources,
    it would be best always to make the program perfect. However, in a world with
    limited resources, releasing something worse is often more efficient. For instance,
    a crude and straightforward solution to a problem gives you a first-mover advantage,
    attracts quick feedback from the early adopters, and gains momentum and attention
    early in the software development process. Many practitioners argue that a second-mover
    must invest far more energy and resources to create a far superior product that’s
    able to pull users away from the first-mover.
  prefs: []
  type: TYPE_NORMAL
- en: 11\. Clean Code Is Better Than Clever Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I slightly modified the original principle in the Unix philosophy, *clarity
    is better than cleverness*, first to focus the principle on programming code and,
    second, to align it with the principles you’ve already learned: how to *write
    clean code* (see Chapter 4).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This principle highlights the trade-off between clean and clever code: clever
    code shouldn’t come at the cost of simplicity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, have a look at the simple bubble sort algorithm in [Listing 7-15](#listing7-15).
    A bubble sort algorithm sorts a list by going through it iteratively and switching
    the position of any two adjacent elements that aren’t sorted: the smaller element
    goes to the left, and the larger element goes to the right. Each time that happens,
    the list becomes a bit more sorted.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-15: Bubble sort algorithm in Python'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm in [Listing 7-15](#listing7-15) is readable and clear, and it
    achieves the goal and doesn’t contain unnecessary code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, suppose your bright colleague argues that you could shorten the code using
    *conditional assignments* to express the `if` statement with one less line of
    code (see [Listing 7-16](#listing7-16)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-16: “Clever” bubble sort algorithm in Python'
  prefs: []
  type: TYPE_NORMAL
- en: The trick doesn’t improve the code but does reduce readability and clarity.
    Conditional assignment features may be clever, but using them comes at the cost
    of expressing your ideas with clean code. For more tips on how to write clean
    code, please refer to Chapter 4.
  prefs: []
  type: TYPE_NORMAL
- en: 12\. Design Programs to Connect With Other Programs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your programs do not live in isolation. A program is called to perform a task,
    either by a human being or by another program. You therefore need to design the
    API to work with the outside world—users or other programs. By adhering to Unix
    Principle 9, *make any program a filter*, which says to ensure the input/output
    mapping is intuitive, you’re already designing connected programs rather than
    making them live in isolation. The great programmer is as much an architect as
    a craftsperson. They create new programs as a unique combination of old and new
    functions and other people’s programs. As a result, interfaces are able to be
    front and center of the development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 13\. Make Your Code Robust
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A codebase is *robust* if it cannot be easily broken. There are two perspectives
    on code robustness: the programmer’s view and the user’s view.'
  prefs: []
  type: TYPE_NORMAL
- en: As the programmer, you could potentially break code by modifying it. A codebase
    is therefore *robust against change* if even a careless programmer can work on
    the codebase without being able to destroy its functionality easily. Say you have
    a big, monolithic code block and every programmer in your organization has *edit
    access* to that whole thing. Any small change could break the whole thing. Now,
    compare this to code developed by organizations like Netflix or Google, where
    every change has to go through multiple approval levels before being deployed
    in the real world; changes are thoroughly tested, so deployed code is protected
    against breaking changes. By adding layers of protection, Google and Netflix have
    made their code more robust than a fragile, monolithic codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to accomplish codebase robustness is to control access rights so that
    individual developers are not able to damage the application without verifying
    with at least one additional person that the change is more likely to add value
    than damage the code. The process may come at a price of less agility, but the
    price is worth paying if you’re not a one-person startup. We’ve already seen other
    ways to ensure code robustness throughout the book: small is beautiful, create
    functions that do one thing well, use test-driven development, keep things simple.
    A few other easily applied techniques are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use versioning systems such as Git so that you can recover previous versions
    of your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Back up your application data regularly to make it recoverable (data is not
    part of a versioning system).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use distributed systems to avoid a single point of failure: run your application
    on multiple machines to reduce the probability of a failing machine adversely
    affecting your application. Say one machine has a failure probability of 1 percent
    per day—it’ll fail about every 100 days. Creating a distributed system of five
    machines that fail independently can theoretically reduce your failure probability
    to 0.01⁵ × 100% = 0.00000001%.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a user, an application is robust if you cannot easily break it by providing
    faulty or even malicious inputs. Assume that your users will behave like a mob
    of gorillas smacking the keyboard and submitting random series of characters and
    that highly skilled hackers understand the application better than you and are
    ready to exploit even the smallest security issue. Your application must be robust
    against both types of users.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s relatively simple to shield against the former group. Unit testing is
    one powerful tool: test any function against any function input you can think
    of, especially border cases. For example, if your function takes an integer and
    calculates the square root, check that it can handle negative inputs and 0 because
    unhandled exceptions would break the chain of reliable, simple, chainable programs.
    However, unhandled exceptions lead to another more subtle problem that was brought
    to my attention by security expert and technical editor of this book, Noah Spahn:
    providing input to break a program can give attackers a foothold into the host
    operating system. So, check your program’s ability to process all kinds of inputs
    and, thereby, make your code more robust!'
  prefs: []
  type: TYPE_NORMAL
- en: 14\. Repair What You Can—But Fail Early and Noisily
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While you should repair problems in your code wherever possible, you shouldn’t
    hide the errors you cannot fix. A hidden error will quickly compound, becoming
    bigger and bigger the longer it remains hidden.
  prefs: []
  type: TYPE_NORMAL
- en: 'Errors can accumulate. For example, say the speech recognition system in your
    driving assistance app is fed faulty training data classifying two completely
    different phonetic waves as the same word (see [Figure 7-4](#figure7-4)). So your
    code raises an error trying to map two completely different phonetic waves to
    the same English word (for example, the error may occur as you try to store this
    contradictory information in an inverted index that maps English terms to phonetic
    waves). You can write your code in two ways: hide the error or propagate the error
    up to the application, user, or programmer. While many coders intuitively want
    to hide errors from the users to improve usability, this is not the most sensible
    approach. Error messages should carry useful information. If your code makes you
    aware of this problem early, you could figure out a solution in advance. You better
    become aware of errors early before their consequences cumulate and destroy millions
    of dollars or even human lives.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphic depicting the classifier algorithm mapping the terms “right” and
    “left” to the same term: “right.”](image_fi/502185c07/f07004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-4: Classifier in the training phase maps two different phonetic waves
    to the same English word.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s better to raise unfixable errors and hand them to the user than bury them,
    even if the user doesn’t appreciate the error message and the usability of your
    application decreases. The alternative is to bury the errors until they have grown
    too big to ever handle.
  prefs: []
  type: TYPE_NORMAL
- en: To continue with our faulty training data example, [Listing 7-17](#listing7-17)
    shows an example in which the Python `classify()` function takes one input argument—the
    wave to be classified—and returns the English word associated with this classification.
    Say you’ve implemented a `duplicate_check(wave, word)` function that checks whether
    a substantially different wave in your database results in the same classification
    using the `wave` and `word` pairs. In this case, the classification is ambiguous
    because two completely different waves map to the same English word, and you should
    share this with the user by raising a `ClassificationError` rather than returning
    a random guess of the classified word. Yes, the user will be annoyed, but at least
    they have a chance to handle the consequences of the error themselves. *Repair
    what you can—but fail early and noisily!*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-17: Code snippet with noisy failure instead of random guess if the
    wave cannot be classified unambiguously'
  prefs: []
  type: TYPE_NORMAL
- en: '15\. Avoid Hand-Hacking: Write Programs to Write Programs If You Can'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The principle suggests that code that can be generated automatically *should
    be*, because humans are notoriously prone to failures, especially in an activity
    that’s repetitive and boring. There are many ways to accomplish this—in fact,
    modern high-level programming languages such as Python are compiled down to machine
    code using such programs. By writing programs to write programs, the creators
    of those compilers helped high-level programmers to create all kinds of application
    software without needing to worry about low-level hardware programming languages.
    Without those programs writing programs for us, the computer industry would still
    be in its infancy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code generators and compilers already produce large amounts of source code
    today. Let’s examine an additional way to think of this principle. Today, the
    technologies of machine learning and artificial intelligence lift this concept
    of writing programs to write programs to yet another level. Intelligent machines
    (machine learning models) are assembled by humans and then go on to rewrite (and
    tune) themselves based on data. Technically, a machine learning model is a program
    that has rewritten itself many times over until its behavior has maximized a set
    fitness function (usually set by humans). As machine learning permeates (and prevails
    over) more areas of computer science, this principle will become more and more
    relevant in modern computing. Human programmers will still play a major role in
    using those powerful tools; after all, compilers have not replaced human labor
    but have instead opened up a new world of applications created by human programmers.
    I expect that the same will happen in programming: machine learning engineers
    and software architects will design advanced applications by connecting the different
    low-level programs, such as machine learning models. Well, that’s one view on
    the topic—yours may be more or less optimistic!'
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you’ve learned 15 principles designed by the Unix creators
    to write better code. It’s worth repeating them—as you read through the list,
    think about how each principle applies to your current code project.
  prefs: []
  type: TYPE_NORMAL
- en: Make each function do one thing well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple is better than complex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Small is beautiful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a prototype as soon as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose portability over efficiency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store data in flat text files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use software leverage to your advantage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid captive user interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make every program a filter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Worse is better.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean code is better than clever code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design programs to be connected with other programs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make your code robust.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repair what you can—but fail early and noisily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write programs to write programs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you’ll learn about the impact of minimalism on design and
    how it can help you design applications that delight your users by doing less.
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mike Gancarz, *The Unix Philosophy*, Boston: Digital Press, 1994.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Eric Raymond, *The Art of Unix*, Boston: Addison-Wesley, 2004, [http://www.catb.org/~esr/writings/taoup/html/](http://www.catb.org/~esr/writings/taoup/html/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
