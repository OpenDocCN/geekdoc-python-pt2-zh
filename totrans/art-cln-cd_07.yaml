- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Do One Thing Well and Other Unix Principles
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 专注做好一件事及其他Unix原则
- en: 'This is the Unix philosophy: Write programs that do one thing and do it well.
    Write programs to work together. Write programs to handle text streams, because
    that is a universal interface.'
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这就是Unix哲学：编写做一件事并做好它的程序。编写能够协作的程序。编写处理文本流的程序，因为文本流是一种通用接口。
- en: ''
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Douglas McIlroy
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —Douglas McIlroy
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'The prevailing philosophy of the Unix operating system is simple: do one thing
    well. This means, for example, that it’s generally better to create a function
    or module that can solve one problem, reliably and efficiently, than to try to
    tackle multiple problems at the same time. Later in this chapter, you’ll see some
    Python code examples of “do one thing well” in action and learn how the Unix philosophy
    applies to programming. I’ll then present the top principles employed by some
    of the world’s most accomplished computer engineers in creating today’s operating
    systems. If you’re a software engineer, you’ll find valuable advice on writing
    better code in your own projects.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Unix操作系统的主流哲学很简单：做好一件事。这意味着，举个例子，通常创建一个能够可靠且高效地解决一个问题的函数或模块，比尝试同时解决多个问题更好。在本章稍后，你将看到一些展示“专注做好一件事”的Python代码示例，并学习Unix哲学如何应用于编程。我还会介绍一些世界上最出色的计算机工程师在创建当今操作系统时所采用的顶级原则。如果你是软件工程师，你将发现一些关于如何在自己项目中编写更好代码的宝贵建议。
- en: 'But first things first: What is Unix anyway, and why should you care?'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先：Unix到底是什么？为什么你应该关心它？
- en: The Rise of Unix
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unix的崛起
- en: Unix is a design philosophy that inspired many of the most popular operating
    systems today, including Linux and macOS. The family of Unix operating systems
    emerged in the late 1970s when Bell Systems made the source code of its technology
    open to the public. Since then, a multitude of extensions and new versions have
    been developed by universities, individuals, and corporations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Unix是一种设计哲学，启发了今天许多最流行的操作系统，包括Linux和macOS。Unix操作系统家族出现在1970年代末期，当时Bell Systems将其技术的源代码公开。此后，许多扩展和新版本由大学、个人和公司开发。
- en: Today, the trademarked Unix standard certifies that operating systems meet specific
    quality requirements. Unix and Unix-like operating systems have a major impact
    on computing. About 7 out of 10 web servers run on Linux systems that use Unix
    as their base. Most supercomputers today run Unix-based systems. Even the macOS
    is a registered Unix system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，注册商标Unix标准认证了操作系统是否符合特定的质量要求。Unix及类Unix操作系统对计算机产生了重大影响。大约7成的网络服务器运行的是基于Unix的Linux系统。今天的大部分超级计算机也都运行Unix系统。甚至macOS也是一个注册的Unix系统。
- en: Linus Torvalds, Ken Thompson, Brian Kernighan—the list of Unix developers and
    maintainers contains the names of some of the world’s most impactful coders across
    the globe. You would think there must be great organizational systems in place
    to allow programmers all over the world to collaborate to build the massive Unix
    ecosystem comprising millions of lines of code. And rightly so! The philosophy
    that enables this scale of collaboration is the acronym DOTADIW (seriously)—or
    *do one thing and do it well*. Whole books have been written about the Unix philosophy,
    so here we’ll just focus on the most relevant ideas and use Python code snippets
    to showcase some examples. To the best of my knowledge, no book has ever contextualized
    the Unix principles for the Python programming language before. So, let’s get
    started!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Linus Torvalds、Ken Thompson、Brian Kernighan——Unix的开发者和维护者名单中包含了全球一些最具影响力的程序员。你可能会想，必须有一个很好的组织系统，才能让全球的程序员合作构建庞大的Unix生态系统，涵盖数百万行代码。确实如此！促成这种规模合作的哲学理念就是DOTADIW（没错，真的！）——或者说是*专注做好一件事*。关于Unix哲学已经有许多书籍被写出来，因此在这里我们将重点关注最相关的思想，并通过Python代码片段来展示一些示例。据我所知，迄今为止还没有一本书将Unix原则与Python编程语言结合在一起讲解。那么，我们开始吧！
- en: Philosophy Overview
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哲学概述
- en: The basic idea of the Unix philosophy is to build simple, clear, concise, modular
    code that is easy to extend and maintain. This can mean many different things—more
    on this later in the chapter—but the goal is to allow many humans to work together
    on a codebase by prioritizing readability over efficiency and favoring composability
    over monolithic design. Monolithic applications are designed without modularity,
    meaning large parts of the code logic cannot be reused, executed, or debugged
    without accessing the overall application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Unix哲学的基本理念是构建简单、清晰、简洁、模块化的代码，易于扩展和维护。这可能意味着很多不同的事情——稍后在本章会有更多内容——但目标是通过优先考虑可读性而非效率，偏向组合性而非单体设计，来让多人可以共同在同一个代码库上工作。单体应用程序设计时没有模块化，意味着代码的大片逻辑无法在不访问整个应用程序的情况下被重用、执行或调试。
- en: Say you write a program that takes a uniform resource locator (URL) and prints
    the HTML from this URL on the command line. Let’s call this program `url_to_html()`.
    According to the Unix philosophy, this program should do one thing well, and that
    one thing is to take the HTML from the URL and print it to the shell (see [Listing
    7-1](#listing7-1)). That’s it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你写了一个程序，它接受一个统一资源定位符（URL），并在命令行上打印该URL的HTML。我们把这个程序叫做`url_to_html()`。根据Unix哲学，这个程序应该做好一件事，而这件事就是从URL获取HTML并将其打印到shell中（见[清单
    7-1](#listing7-1)）。就这么简单。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 7-1: A simple code function that reads the HTML from a given URL and
    returns the string'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-1：一个简单的代码函数，它读取给定URL的HTML并返回字符串
- en: 'That’s all you need. Don’t add more functionality, such as filtering out tags
    or fixing bugs. For instance, you might be tempted to add code to fix common mistakes
    a user might make, like forgetting closing tags, such as a `<span>` tag that is
    not closed by `</span>` as highlighted here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你所需要的。不要添加更多功能，比如过滤掉标签或修复错误。例如，你可能会有冲动添加代码来修复用户可能犯的常见错误，比如忘记关闭标签，比如一个`<span>`标签没有用`</span>`关闭，如这里所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: According to the Unix philosophy, even if you spot these types of mistakes,
    you don’t fix them within this specific function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Unix哲学，即使你发现了这些类型的错误，你也不应该在这个特定的函数中修复它们。
- en: 'Another temptation for this simple HTML function is to automatically fix formatting.
    For example, the following HTML code doesn’t look pretty:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个诱惑是为这个简单的HTML函数自动修复格式。例如，下面的HTML代码看起来并不漂亮：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You may prefer this code formatting:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能更喜欢这种代码格式：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, your function’s name is `url_to_html()`, not `prettify_html()`. Adding
    a feature such as code prettifying would add a second functionality that may not
    be needed by some users of the function.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你的函数名称是`url_to_html()`，而不是`prettify_html()`。添加像代码美化这样的功能，会增加第二个功能，而这个功能可能并不是某些用户所需要的。
- en: Rather, you’d be encouraged to create another function called `prettify_html(url)`
    whose “one thing” is to fix stylistic issues of the HTML. This function may internally
    use the function `url_to_html()` to get the HTML before processing it further.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你会被鼓励创建另一个名为`prettify_html(url)`的函数，它的“唯一目标”是修复HTML的样式问题。这个函数可以内部使用`url_to_html()`函数来获取HTML，然后再进行进一步处理。
- en: By focusing every function on one purpose only, you improve the maintainability
    and extensibility of your code. The output of one program is the input of another.
    You reduce complexity, avoid clutter in the output, and focus on implementing
    one thing well.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过让每个函数只专注于一个目标，你可以提高代码的可维护性和可扩展性。一个程序的输出是另一个程序的输入。你减少了复杂性，避免了输出中的杂乱无章，并专注于将一件事做到最好。
- en: Although a single subprogram may look small, even trivial, you can combine those
    subprograms to create more complicated programs while keeping them easy to debug.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管单个子程序看起来可能很小，甚至微不足道，但你可以将这些子程序组合起来，创建更复杂的程序，同时保持它们易于调试。
- en: 15 Useful Unix Principles
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15个有用的Unix原则
- en: We’ll next dive deep into the 15 Unix principles most relevant for today and,
    where possible, implement them in Python examples. I’ve compiled these principles
    from Unix coding experts Eric Raymond and Mike Gancarz and adapted them to modern
    Python programming. You’ll notice that many of these principles comply or overlap
    with other principles in this book.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将深入探讨15个与今天最相关的Unix原则，并在可能的情况下用Python示例加以实现。我已经从Unix编码专家Eric Raymond和Mike
    Gancarz那里整理了这些原则，并将其调整为现代Python编程的要求。你会发现这些原则中的许多都与本书中的其他原则相符或有重叠。
- en: 1\. Make Each Function Do One Thing Well
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1. 让每个函数专注于做好一件事
- en: The overarching principle of the Unix philosophy is to *do one thing well*.
    Let’s see what that would look like in code. In [Listing 7-2](#listing7-2), you
    implement a function `display_html()` that takes a URL as a string and displays
    the prettified HTML on that URL.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 哲学的基本原则是*做一件事并做好它*。让我们看看这在代码中是如何表现的。在[清单 7-2](#listing7-2)中，你实现了一个函数`display_html()`，它接受一个
    URL 字符串并显示该 URL 上的美化 HTML。
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 7-2: Make each function or program do one thing well.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-2：让每个函数或程序做一件事，并做好它。
- en: This code is depicted in [Figure 7-1](#figure7-1).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在[图 7-1](#figure7-1)中有所展示。
- en: '![Boxes linking a few html functions to several URLs and lines of code, showing
    the modularity and efficiency of using functions with a single focus.](image_fi/502185c07/f07001.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![展示将几个 HTML 函数与多个 URL 和代码行链接的框，显示使用单一功能的函数的模块化和高效性。](image_fi/502185c07/f07001.png)'
- en: 'Figure 7-1: Overview of multiple simple functions—each doing one thing well—working
    together to accomplish a bigger task'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1：多个简单函数概览——每个函数都做一件事，但做得很好——共同协作完成更大的任务
- en: 'This code provides a sample implementation that performs the following steps
    in the function `display_html`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码提供了一个示例实现，执行以下步骤：
- en: Get the HTML from a given URL location.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从给定的 URL 位置获取 HTML。
- en: Fix some missing tags.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复一些缺失的标签。
- en: Prettify the HTML.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 美化 HTML。
- en: Return the result to the function caller.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回结果给函数调用者。
- en: If you run the code with a URL that points to the not-very-pretty HTML code
    `'< a href="https://finxter.com">Solve next Puzzle</a>'`, the function `display_html`
    would fix the poorly formatted (and incorrect) HTML by brokering the inputs and
    outputs of the small code functions, because each of those does its one thing
    well.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用一个指向不太美观的 HTML 代码`'< a href="https://finxter.com">Solve next Puzzle</a>'`的
    URL 运行代码，函数`display_html`会通过协调小型代码函数的输入输出，修复格式不正确（且错误的）HTML，因为每个小函数都只做它自己擅长的事。
- en: 'You would print the result of the main function with this line:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用这一行打印主函数的结果：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code would print the HTML code to your shell with a new tag and the excess
    whitespace removed:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会将 HTML 代码打印到你的 shell 中，同时新标签已添加，且多余的空格被移除：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Think of this whole program as a browser in your terminal. Alice calls the
    function `display_html(url)`, which takes the URL and passes it to another function
    `url_to_html(url)`, which collects the HTML from a given URL location. No need
    to implement the same functionality twice. Fortunately, the coder of the function
    `url_to_html()` has kept that function minimal so you can use its returned HTML
    output directly as an input to the function `fix_missing_tags(html)`. In Unix
    lingo, this is called *piping*: the output of one program is passed as an input
    to another program. The return value of `fix_missing_tags()` is the fixed HTML
    code with a closing `</span>` tag that was missing in the original HTML. You then
    pipe the output into the function `prettify_html(html)` and wait for the result:
    the corrected HTML with indentation to make it user-friendly. Only then does the
    function `display_html(url)` return the prettified and fixed HTML code to Alice.
    You see that a series of small functions connected and piped together can accomplish
    quite big tasks!'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 想象这个程序就像终端中的浏览器。Alice 调用函数`display_html(url)`，它接收 URL 并将其传递给另一个函数`url_to_html(url)`，该函数从给定的
    URL 位置获取 HTML。这样就不需要实现重复的功能。幸运的是，`url_to_html()`函数的编写者保持了该函数的简洁性，因此你可以直接使用它返回的
    HTML 输出作为`fix_missing_tags(html)`函数的输入。在 Unix 中，这叫做*管道*：一个程序的输出作为另一个程序的输入传递。`fix_missing_tags()`的返回值是修复后的
    HTML 代码，补充了原始 HTML 中缺失的`</span>`闭合标签。然后你把输出传递给`prettify_html(html)`函数，等待结果：经过缩进修正后的
    HTML 代码，让它更具用户友好性。只有在此之后，`display_html(url)`函数才会将美化和修复后的 HTML 代码返回给 Alice。你会发现，一系列的小函数通过连接和管道组合起来，能够完成相当大的任务！
- en: In your project, you could implement another function that doesn’t prettify
    the HTML but only adds the `<!DOCTYPE html>` tag. You could then implement a third
    function that prettifies the HTML but doesn’t add the new tag. By staying small,
    you can easily create new code based on the existing functionality, and there
    wouldn’t be a lot of redundancy. The modular design of the code enables reusability,
    maintainability, and extensibility.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中，你可以实现另一个函数，该函数不美化 HTML，而仅仅添加`<!DOCTYPE html>`标签。然后你可以实现第三个函数，它美化 HTML
    但不添加新标签。通过保持函数简洁，你可以基于现有功能轻松创建新的代码，而且不会有太多冗余。代码的模块化设计使得它具备了可重用性、可维护性和可扩展性。
- en: 'Compare this version to a possible monolithic implementation where the function
    `display_html(url)` would have to do all those small tasks by itself. You couldn’t
    partially reuse functionality, such as retrieving the HTML code from a URL or
    fixing faulty HTML code. If you use a monolithic code function that does all things
    itself, it would look like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将此版本与可能的单一实现进行比较，在后者中，`display_html(url)`函数必须自己完成所有那些小任务。你无法部分重用某些功能，比如从URL获取HTML代码或修复HTML代码。如果你使用一个单一的代码函数来做所有的事情，它会像这样：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The function is now more complicated: it handles multiple tasks instead of
    focusing on one. Even worse, if you implement variants of the same function without
    removing the whitespace after an opening tag `''<''`, you’d have to copy and paste
    the remaining code lines. This would lead to code redundancy and reduced readability.
    The more functionality you add, the worse it will get!'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数现在更复杂了：它处理多个任务，而不是专注于一个任务。更糟糕的是，如果你没有去掉打开标签 `'<'` 后的空格，且实现了同一函数的多个变种，你就必须复制并粘贴其余的代码行。这会导致代码冗余和可读性下降。你添加的功能越多，问题就会越严重！
- en: 2\. Simple Is Better Than Complex
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2\. 简单优于复杂
- en: '*Simple is better than complex* is the foremost principle of this whole book.
    You’ve already seen it in many shapes and forms—I stress this point because if
    you don’t take decisive action to simplify, you’ll breed complexity. In Python,
    the principle *simple is better than complex* even made it into the unofficial
    rule book. If you open a Python shell and enter `import this`, you obtain the
    famous *Zen of Python* (see [Listing 7-3](#listing7-3)).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*简单优于复杂* 是本书的核心原则。你已经在许多不同的地方见过它——我强调这一点是因为，如果你不果断地简化，你就会滋生复杂性。在Python中，*简单优于复杂*
    甚至进入了非官方的规则书。如果你打开Python的shell并输入 `import this`，你将获得著名的 *Python之禅*（见[Listing 7-3](#listing7-3)）。'
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 7-3: The Zen of Python'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-3: Python之禅'
- en: Since we’ve covered the concept of simplicity at length already, I won’t go
    over it again here. If you’re still wondering *why* simple is better than complex,
    go back to Chapter 1 about the negative productivity effects that originate in
    high complexity.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经详细讨论过简单的概念，我这里就不再赘述。如果你仍然想知道*为什么*简单优于复杂，请回到第1章，了解高复杂性带来的负面生产力效应。
- en: 3\. Small Is Beautiful
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3\. 小而美
- en: 'Rather than writing big code blocks, write small functions and work as an architect
    brokering the interaction between those functions, as exemplified in [Figure 7-1](#figure7-1).
    There are three main reasons to keep your program small:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 与其编写庞大的代码块，不如编写小函数并像一个架构师一样调度这些函数之间的交互，如[Figure 7-1](#figure7-1)所示。保持程序小型化有三个主要原因：
- en: '**Reduce complexity.**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**降低复杂性。**'
- en: 'Code is harder to comprehend as it gets longer. This is a cognitive fact: your
    brain can keep track of only so many chunks of information simultaneously. Too
    many pieces of information make it hard to see the big picture. By going small
    and reducing the number of code lines in a function, you *improve readability*
    and reduce the likelihood of injecting costly bugs into your codebase.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着代码行数的增加，代码变得更难理解。这是一个认知事实：大脑一次只能处理有限的信息块。信息块过多会让你难以看清全貌。通过将代码做得更小，减少函数中的代码行数，你可以*提高可读性*，并减少向代码库中引入错误的可能性。
- en: '**Improve maintainability.**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**提高可维护性。**'
- en: Structuring your code in many small pieces of functionality makes it easier
    to maintain. Adding more small functions is unlikely to incur side effects, whereas
    in a big, monolithic code block, any changes you make can easily have unintended
    global effects, especially if multiple programmers are working on the code at
    the same time.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码拆分成许多小的功能块使得代码更容易维护。增加更多小函数不太可能产生副作用，而在一个庞大的、单一的代码块中，你所做的任何改动都可能轻易产生意外的全局效应，尤其是在多个程序员同时工作时。
- en: '**Improve testability.**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**提高可测试性。**'
- en: Many modern software companies use *test-driven development*, which involves
    using unit tests to stress-test inputs to each function and unit and compare the
    outputs with the expected ones. This allows you to find and isolate bugs. Unit
    tests are much more effective and easier to implement in small code, where each
    function focuses on just one thing, so you know what the expected result should
    be.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 许多现代软件公司采用*测试驱动开发*，该方法通过使用单元测试来对每个函数和单元的输入进行压力测试，并将输出与预期结果进行比较。这使得你能够找到并隔离错误。单元测试在小规模代码中更为有效且更容易实现，因为每个函数只专注于一件事，所以你能清楚知道预期的结果是什么。
- en: Python itself, rather than an example of small code in Python, is the best example
    of this principle. Any master coder uses other people’s code to improve their
    coding productivity. Millions of developers have spent countless hours optimizing
    code that you can import into your code in a split second. Python, like most other
    programming languages, provides this functionality through libraries. Many of
    the less frequently used libraries don’t ship with the default implementation
    and need to be explicitly installed. By not providing all the libraries as built-in
    functionality, the Python installation on your computer remains relatively small
    but doesn’t sacrifice the potential power of external libraries. On top of this,
    the libraries themselves are relatively small—all of them focus on a restricted
    subset of functions. Rather than one monolithic library to rule all problems,
    we have many small libraries, each responsible for a small part of the picture.
    Small is beautiful.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Python 本身，而不是 Python 中的某个小型代码示例，正是这一原则的最佳例子。任何大师级程序员都会使用他人的代码来提升自己的编码生产力。数百万开发者花费了无数小时优化代码，而你可以在一瞬间将这些代码导入到自己的项目中。像大多数其他编程语言一样，Python
    通过库提供这种功能。许多不常用的库不会随默认实现一起提供，需要显式安装。通过不将所有库作为内建功能提供，Python 安装在你的电脑上依然保持相对小巧，但不牺牲外部库的潜力。此外，这些库本身也很小——每个库都专注于一个有限的功能子集。与其拥有一个解决所有问题的庞大库，我们更倾向于拥有多个小型库，每个库负责解决一小部分问题。小即是美。
- en: Every few years, new architectural patterns appear with the promise of breaking
    up large, monolithic applications into beautiful, small applications to scale
    up the software development cycle. Recent examples have been the Common Object
    Request Broker Architecture (CORBA), service-oriented architecture (SOA), and
    microservices. The idea of these is to break up a large software block into a
    series of independently deployable components that can then be accessed by multiple
    programs rather than just one. The hope is to accelerate the overall progress
    in the software development space by sharing and building upon each other’s microservices.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每隔几年，新的架构模式就会出现，承诺将大型单体应用拆分成优雅的小型应用，以便扩展软件开发周期。近期的例子有通用对象请求代理架构（CORBA）、面向服务的架构（SOA）和微服务。它们的思路是将一个大型的软件模块拆分为一系列独立可部署的组件，然后多个程序可以访问这些组件，而不仅仅是一个程序。希望通过相互共享和构建各自的微服务，来加速软件开发领域的整体进展。
- en: The underlying driver of these trends is the idea of writing modular and reusable
    code. By studying the ideas presented in this chapter, you’ve prepared yourself
    to quickly and fundamentally understand these and upcoming trends with the same
    direction toward modularity. It pays to stay ahead of the curve by applying sound
    principles from the start.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些趋势背后的根本驱动力是编写模块化和可重用代码的理念。通过学习本章中提出的思想，你已经为快速而深刻地理解这些趋势以及未来的趋势做好了准备，并且这些趋势也朝着模块化的方向发展。从一开始就应用正确的原则，能够让你始终走在前沿。
- en: 4\. Build a Prototype as Soon as Possible
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4\. 尽早构建原型
- en: The Unix team is a keen proponent of the principle we discussed in Chapter 3,
    *build an MVP*. This allows you to avoid getting stuck in the cycle of perfectionism,
    adding more and more features and exponentially increasing complexity without
    need. If you work on large software applications such as operating systems, you
    simply cannot afford to go down the route of complexity!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 团队是我们在第 3 章讨论的原则——*构建 MVP*——的热衷支持者。这能帮助你避免陷入完美主义的循环，不断添加功能，毫无必要地成倍增加复杂性。如果你从事的是像操作系统这样的庞大软件应用，你就无法承受复杂性的增加！
- en: '[Figure 7-2](#figure7-2) shows an example of an early app launch that’s stuffed
    itself full of unnecessary features, in defiance of the MVP principle.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-2](#figure7-2) 展示了一个早期应用启动的例子，充满了不必要的功能，完全违背了 MVP 原则。'
- en: '![screenshot of a version of finxter with too many features, making it difficult
    to determine the focus.](image_fi/502185c07/f07002.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![包含过多功能的 finxter 版本截图，导致难以确定其焦点。](image_fi/502185c07/f07002.png)'
- en: 'Figure 7-2: Finxter.com app versus Finxter MVP'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-2：Finxter.com 应用与 Finxter MVP 对比
- en: The app has features like interactive solution checking, puzzle voting, user
    statistics, user management, premium functionality, and related videos along with
    simple features such as a logo. All of these are unnecessary for an initial launch
    of the product. In fact, the MVP of the Finxter application should just be an
    image of a simple code puzzle shared on social media. This is enough to validate
    the hypothesis of user demand without spending years building the application.
    *Fail early, fail often, fail forward.*
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序具有如交互式解题检查、拼图投票、用户统计、用户管理、付费功能以及相关视频等特点，同时也有一些简单功能，如标志。这些在产品初次发布时都是不必要的。事实上，Finxter应用的MVP（最简可行产品）应该仅仅是一个简单的代码拼图图像，分享在社交媒体上。这足以验证用户需求的假设，而不需要花费多年时间来构建应用程序。*早失败，常失败，向前失败。*
- en: 5\. Choose Portability Over Efficiency
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5. 优先选择可移植性而非效率
- en: '*Portability* is the ability of a system or a program to be moved from one
    environment to another and still function properly. One major advantage of software
    is its portability: you can write a program on your computer, and millions of
    users can run the same program on their computers without adapting it at all.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*可移植性*是指一个系统或程序可以从一个环境迁移到另一个环境，并且仍然能够正常工作。软件的一个主要优势是它的可移植性：你可以在自己的电脑上编写程序，数百万用户也可以在他们的电脑上运行相同的程序，而无需进行任何适配。'
- en: 'However, portability comes at the cost of efficiency. This *portability/efficiency
    trade-off* is well documented in technical literature: you can reach higher efficiency
    by tailoring software to just one type of environment, but this sacrifices portability.
    *Virtualization* is a great example of this trade-off: by placing an additional
    layer of software between a piece of software and the underlying infrastructure
    on which the software runs, your program can run on almost any *physical machine*.
    Additionally, a virtual machine can carry the current execution state from one
    physical machine to another. This improves the portability of the software. However,
    the added layer required for virtualization reduces the runtime and memory efficiency
    because of the additional overhead of intermediating between the programs and
    the physical machine.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可移植性是以效率为代价的。这种*可移植性/效率权衡*在技术文献中有很多讨论：通过将软件量身定制为单一环境，可以实现更高的效率，但这会牺牲可移植性。*虚拟化*就是这种权衡的一个典型例子：通过在软件和运行该软件的底层基础设施之间添加一层额外的软件，程序几乎可以在任何*物理机器*上运行。此外，虚拟机还可以将当前执行状态从一台物理机器传输到另一台。这提高了软件的可移植性。然而，虚拟化所需的附加层会降低运行时和内存效率，因为它在程序和物理机器之间增加了中介开销。
- en: The Unix philosophy advocates choosing portability over efficiency; this makes
    sense since the operating system is used by so many.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Unix哲学提倡优先选择可移植性而非效率；这一点是合理的，因为操作系统被如此多的用户使用。
- en: 'But the rule of thumb to prefer portability also applies to the broader audience
    of software developers. Reducing portability means that you reduce your application’s
    value. Today, it is common to improve portability radically—even at the cost of
    efficiency. Web-based applications are expected to run on every computer with
    a browser, whether macOS, Windows, or Linux. Web applications are also increasingly
    accessible, accommodating visual impairment for example, even though hosting a
    website that facilitates accessibility may be less efficient. Many resources are
    much more valuable than computing cycles: human lives, human time, and other second-order
    consequences of computers.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，倾向于可移植性的经验法则同样适用于更广泛的软件开发者群体。降低可移植性意味着降低了你应用程序的价值。如今，极大提高可移植性已经变得很常见——即使是以牺牲效率为代价。基于网页的应用程序预期能够在任何有浏览器的计算机上运行，无论是macOS、Windows还是Linux。网页应用程序还越来越注重无障碍功能，例如为视力障碍者提供便利，尽管托管一个能够促进无障碍访问的网站可能效率较低。许多资源比计算周期更有价值：人类的生命、人类的时间以及计算机所带来的其他二级后果。
- en: But what does it mean to program for portability, apart from these general considerations?
    In [Listing 7-4](#listing7-4) we create a function that computes the average of
    the specified arguments—the way we’ve written it, it’s not optimized for portability.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，除了这些一般性考虑外，为可移植性编程意味着什么呢？在[列表7-4](#listing7-4)中，我们创建了一个计算指定参数平均值的函数——按照我们编写的方式，它并没有为可移植性进行优化。
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 7-4: Average function, not maximally portable'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-4：平均值函数，不是最大化可移植性
- en: This code is not portable for two reasons. First, the function name `calculate_average_age()`
    is not general enough to be usable in any other context, despite the fact that
    it simply calculates an average. You might not think to use it, for example, to
    calculate the average number of website visitors. Second, it uses a library needlessly
    because you could easily calculate the average without any external library (see
    [Listing 7-5](#listing7-5)). It’s generally a great idea to use libraries, but
    only if they add value. In this case, adding a library reduces portability because
    the user may not have this library installed; plus, it adds little, if any, efficiency.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码因两点原因而不可移植。首先，函数名`calculate_average_age()`不够通用，无法在任何其他上下文中使用，尽管它只是计算一个平均值。例如，你可能不会想到使用它来计算网站访问者的平均人数。其次，它不必要地使用了一个库，因为你完全可以在不依赖任何外部库的情况下轻松计算平均值（参见[Listing
    7-5](#listing7-5)）。通常使用库是个好主意，但前提是它们能带来实际价值。在这种情况下，添加一个库反而降低了可移植性，因为用户可能没有安装这个库；此外，效率的提升几乎为零。
- en: In [Listing 7-5](#listing7-5) we recreate the function with superior portability.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Listing 7-5](#listing7-5)中，我们重新创建了具有更高可移植性的函数。
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 7-5: Average function, portable'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 7-5：平均函数，可移植
- en: We rename the functions to be more general and do away with the unnecessary
    import. Now you don’t have to worry if the library becomes depreciated, and you
    can port the same code to your other projects.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将函数重命名为更通用的名称，并去除了不必要的导入。现在，你不必担心这个库会被弃用，并且可以将相同的代码移植到其他项目中。
- en: 6\. Store Data in Flat Text Files
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6\. 将数据存储在平面文本文件中
- en: The Unix philosophy encourages the use of *flat text files* for storing data.
    Flat text files are simple text or binary files without advanced mechanisms to
    access the file content—unlike many more efficient but also more complicated file
    formats used by, for example, the database community. These are simple, human-readable
    data files. The common comma-separated values (CSV) format is an example of a
    flat file format, where each line relates to one data entry (see [Listing 7-6](#listing7-6))
    and someone new to the data can glean some understanding just by looking at it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Unix哲学提倡使用*平面文本文件*来存储数据。平面文本文件是简单的文本或二进制文件，没有高级机制来访问文件内容——与例如数据库社区使用的许多更高效但更复杂的文件格式不同。这些是简单的、可供人类阅读的数据文件。常见的逗号分隔值（CSV）格式就是平面文件格式的一个例子，其中每一行都对应一个数据条目（参见[Listing
    7-6](#listing7-6)），而且任何不熟悉这些数据的人，通过查看这些文件也能获得一些基本理解。
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 7-6: Data on stolen guns, from [Data.gov](https://catalog.data.gov/dataset/stolen-gun),
    provided as a flat file format (CSV)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 7-6：来自[Data.gov](https://catalog.data.gov/dataset/stolen-gun)的被盗枪支数据，采用平面文件格式（CSV）提供
- en: 'You can share flat text files easily, open them in any text editor, and modify
    them manually. However, this convenience comes at the cost of efficiency: a data
    format specialized for a specific purpose could store and read the data much more
    efficiently. Databases, for example, use their own data files on disk, which use
    optimizations, like detailed indices and compression schemes to represent dates.
    If you opened them, you wouldn’t understand a thing. These optimizations allow
    programs to read from the data with less memory consumption and less overhead
    than general flat text files. In a flat file, a system would have to scan the
    whole file to read a specific line. Web applications also require a more efficient
    optimized data representation to allow users quick access with low latency, so
    they rarely use flat representations and databases.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松地共享平面文本文件，在任何文本编辑器中打开并手动修改它们。然而，这种便利性是以效率为代价的：为特定用途定制的数据格式可以更高效地存储和读取数据。例如，数据库使用自己在磁盘上的数据文件，并利用优化手段，如详细的索引和压缩方案来表示数据。如果你打开这些文件，你根本不会理解它们的内容。这些优化使得程序能够以比一般平面文本文件更少的内存消耗和更低的开销读取数据。在平面文件中，系统必须扫描整个文件才能读取特定的行。Web应用程序也需要一种更高效的优化数据表示方式，以便允许用户快速访问并减少延迟，因此它们很少使用平面表示法和数据库。
- en: However, you should use optimized data representations only if you’re sure you
    need them—for example, if you create an application that is highly performance
    sensitive, such as the Google search engine that can find the web documents most
    relevant to a given user query in milliseconds! For many smaller applications,
    such as training a machine learning model from a real-world dataset with 10,000
    entries, the CSV format is the recommended way to store the data. Using a database
    with a specialized format would reduce portability and add unnecessary complexity.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你应该仅在确认需要时才使用优化的数据表示——例如，如果你创建的是一个对性能要求极高的应用，如 Google 搜索引擎，它能够在毫秒级别找到与用户查询最相关的网页文档！对于许多较小的应用，例如从具有
    10,000 条记录的现实世界数据集训练机器学习模型，推荐使用 CSV 格式来存储数据。使用具有专用格式的数据库会减少移植性并增加不必要的复杂性。
- en: '[Listing 7-7](#listing7-7) gives an example of one situation in which the flat
    format is preferable. It uses Python, one of the most popular languages for data
    science and machine learning applications. Here we want to perform a data analysis
    task on a dataset of images (faces), so we load data from a flat CSV file and
    process it, favoring the portable approach over the more efficient one of using
    a database.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-7](#listing7-7) 给出了一个在平面格式更为优越的情况下的示例。它使用 Python，这是一种在数据科学和机器学习应用中最受欢迎的编程语言之一。在这里，我们希望对一个人脸图像数据集执行数据分析任务，因此我们从一个平面
    CSV 文件加载数据并进行处理，选择便于移植的方式，而非使用数据库的更高效方式。'
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 7-7: Load data from a flat file for a Python data analysis task'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-7：从平面文件加载数据进行 Python 数据分析任务
- en: In the function `fetch_olivetti_faces`, we load scikit-learn’s *Olivetti faces*
    dataset, which contains a set of face images. The loading functions simply read
    this data and load it into memory before starting with the real computation. No
    database or hierarchical data structures are needed. The program is self-contained
    without installing a database or setting up advanced database connections.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数`fetch_olivetti_faces`中，我们加载了 scikit-learn 的*Olivetti faces*数据集，该数据集包含一组人脸图像。加载函数仅仅是读取这些数据并将其加载到内存中，然后再开始实际的计算。无需数据库或层级数据结构。该程序是自包含的，无需安装数据库或设置复杂的数据库连接。
- en: 7\. Use Software Leverage to Your Advantage
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7\. 利用软件杠杆获得优势
- en: 'Using *leverage* means applying a small amount of energy to multiply the effects
    of your effort. In finance, for example, leverage means to use other people’s
    money to invest and grow. In a large corporation, it might mean using an extensive
    distributor network to place products in stores worldwide. As a programmer, you
    should leverage the collective wisdom of generations of coders before you: use
    libraries for complex functionality rather than coding it from scratch, use StackOverflow
    and the wisdom of the crowd to fix bugs in your code, or ask other programmers
    to review your code. These are forms of leverage that allow you to accomplish
    far more with far less effort.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*杠杆*意味着用少量的精力来放大你努力的效果。例如，在金融领域，杠杆意味着使用他人的资金进行投资和增长。在大型公司中，它可能意味着利用广泛的分销网络将产品放置到全球的商店中。作为程序员，你应该利用前人编程者的集体智慧：使用库来实现复杂功能，而不是从头编写代码；使用
    StackOverflow 和群体智慧来修复代码中的 bug；或者请其他程序员审查你的代码。这些都是杠杆的形式，可以让你用更少的努力完成更多的事情。
- en: The second source of leverage comes from computing power. A computer can perform
    work much faster (and at much lower cost) than a human being. Create better software,
    share it with more people, employ more computing power, and use other people’s
    libraries and software more often. Good coders create good source code quickly,
    but great coders tap into the many sources of leverage available to them to elevate
    their code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种杠杆来源是计算能力。计算机可以比人类更快地执行工作（且成本更低）。创造更好的软件，与更多的人分享，利用更多的计算能力，并更加频繁地使用他人的库和软件。优秀的程序员能够快速编写出优质的源代码，而伟大的程序员则能够利用众多可用的杠杆来源来提升他们的代码。
- en: As an example, [Listing 7-8](#listing7-8) shows a one-liner program from my
    book *Python One-Liners* (No Starch Press, 2020) that scrapes a given HTML document
    and finds all occurrences of a URL that contains the substring `'finxter'` and
    either `'test'` or `'puzzle'`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，[列表 7-8](#listing7-8)展示了我书中《*Python One-Liners*》（No Starch Press，2020）中的一个单行程序，它可以抓取给定的
    HTML 文档，找到所有包含子字符串 `'finxter'` 并且同时包含 `'test'` 或 `'puzzle'` 的 URL。
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 7-8: One-liner solution to analyze web page links'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-8：分析网页链接的单行代码解决方案
- en: By importing the `re` library, we leverage the powerful technology of regular
    expressions, instantly putting thousands of lines of code to work and allowing
    us to write the entire program with a single line. Leverage is a powerful companion
    on your path to becoming a great coder. For instance, using libraries in your
    code rather than implementing everything yourself is like using an app to plan
    your journey rather than working out every detail with a paper map.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导入`re`库，我们利用了正则表达式的强大技术，瞬间将成千上万行代码转化为可用代码，并让我们用一行代码编写整个程序。杠杆效应是你成为一名优秀程序员的重要伙伴。例如，使用代码库而不是自己从头实现一切，就像用应用程序来规划你的旅行，而不是通过纸质地图来逐步确定每一个细节。
- en: 8\. Avoid Captive User Interfaces
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8. 避免使用封闭式用户界面
- en: '*Captive user interfaces* are those that require the user to interact with
    the program before proceeding with the main execution flow. Examples are mini-programs
    such as Secure Shell (SSH), `top`, `cat`, and `vim`, as well as programming language
    features such as Python’s `input()` function. Captive user interfaces limit the
    usability of the code because they’re designed to run only with human involvement.
    However, oftentimes the functionality provided by the code behind the captive
    user interface is also useful for automated programs that must be able to run
    without manual interaction with users. Roughly speaking, if you put good code
    behind a captive user interface, it’s not reachable without user interaction!'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*封闭式用户界面*是指要求用户在继续执行程序主流程之前必须与程序交互的界面。典型的例子包括小程序如 Secure Shell (SSH)、`top`、`cat`
    和 `vim`，以及编程语言中的功能如 Python 的`input()`函数。封闭式用户界面限制了代码的可用性，因为它们只能在人类的参与下运行。然而，通常封闭式用户界面背后的代码功能对于需要无需人工交互就能运行的自动化程序也很有用。大致来说，如果你把优秀的代码放在封闭式用户界面后面，那么没有用户交互是无法访问的！'
- en: Say you create a simple life expectancy calculator in Python that takes a user’s
    age as input and returns the expected number of years left based on a straightforward
    heuristic.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 比如，你创建了一个简单的寿命预测计算器，它接收用户的年龄作为输入，并根据简单的启发式方法返回预期的剩余寿命。
- en: “If you’re under 85, your life expectancy is 72 minus 80 percent of your age.
    Otherwise, it’s 22 minus 20 percent of your age.”
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: “如果你不到 85 岁，寿命预测为 72 减去你年龄的 80%。否则，寿命预测为 22 减去你年龄的 20%。”
- en: Your initial Python code might look something like [Listing 7-9](#listing7-9).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你最初的 Python 代码可能类似于[清单 7-9](#listing7-9)。
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 7-9: Life expectancy calculator—a simple heuristic—implemented as a
    captive user interface'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-9：寿命预测计算器——一个简单的启发式方法——作为封闭式用户界面实现
- en: Here are some runs of the code in [Listing 7-9](#listing7-9).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是[清单 7-9](#listing7-9)中的一些代码执行示例。
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you want to try it yourself, I’ve shared the program in a Jupyter notebook
    at [https://blog.finxter.com/clean-code/#Life_Expectancy_Calculator/](https://blog.finxter.com/clean-code/#Life_Expectancy_Calculator/).
    But, please, don’t take it too seriously!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想自己试试，我已经在 Jupyter notebook 中分享了该程序，链接在这里：[https://blog.finxter.com/clean-code/#Life_Expectancy_Calculator/](https://blog.finxter.com/clean-code/#Life_Expectancy_Calculator/)。不过，请不要太认真对待它！
- en: 'In [Listing 7-9](#listing7-9), we used Python’s `input()` function, which blocks
    program execution until the user input is received. Without user input, the code
    doesn’t do anything. This captive user interface limits the usability of the code.
    If you wanted to calculate the life expectancy for every age from 1 to 100 and
    plot it, you’d have to manually enter 100 different ages and store the results
    in a separate file. Then, you’d have to copy and paste the results into a new
    script to plot them. As it is now, the function really does two things: process
    the user input and calculate the life expectancy, which also violates the first
    Unix principle: make each function do one thing well.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 7-9](#listing7-9)中，我们使用了 Python 的`input()`函数，它会阻塞程序的执行，直到接收到用户输入。在没有用户输入的情况下，代码什么也不做。这个封闭式用户界面限制了代码的可用性。如果你想计算从
    1 到 100 每个年龄的寿命预测并绘制图表，你必须手动输入 100 个不同的年龄，并将结果存储在单独的文件中。然后，你必须复制并粘贴结果到一个新的脚本中来绘制它们。现在的功能实际上做了两件事：处理用户输入并计算寿命预测，这也违反了
    Unix 的第一个原则：每个函数只做一件事并做得好。
- en: To make the code compliant with this principle, we’ll separate the user interface
    from the functionality, which is often a great idea to improve your code (see
    [Listing 7-10](#listing7-10)).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码符合这个原则，我们将用户界面与功能性分离，这通常是提升代码质量的好方法（见[清单 7-10](#listing7-10)）。
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 7-10: Life expectancy calculator—a simple heuristic—without captive
    user interface'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-10：寿命预测计算器——一个简单的启发式方法——没有封闭式用户界面
- en: 'The code in [Listing 7-10](#listing7-10) is functionally identical to [Listing
    7-9](#listing7-9), with one significant advantage: we can use this new function
    in various situations, even those that are unexpected by the initial developer.
    In [Listing 7-11](#listing7-11) we use the function to calculate the life expectancy
    for input ages between 0 and 99 and plot the result; note the portability gained
    from removing the user input interface.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-10](#listing7-10)中的代码在功能上与[列表 7-9](#listing7-9)完全相同，但有一个显著的优势：我们可以在各种场景下使用这个新函数，甚至是初始开发者未曾预料到的情况。在[列表
    7-11](#listing7-11)中，我们使用该函数计算0到99岁之间的预期寿命，并绘制结果；注意到去除用户输入界面带来的可移植性。'
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 7-11: Code to plot the life expectancy for years 0–99'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-11：计算0-99岁预期寿命并绘制图表的代码
- en: '[Figure 7-3](#figure7-3) shows the resulting plot.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-3](#figure7-3)展示了最终的图表。'
- en: '![Resulting plot of Listing 7-11, showing a declining line starting at the
    top right; the x-axis shows “Age” and the y-axis shows “number of years left.”
    ](image_fi/502185c07/f07003.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![列表 7-11 的结果图，显示一条从右上方开始下降的线；x 轴表示“年龄”，y 轴表示“剩余年数”。](image_fi/502185c07/f07003.png)'
- en: 'Figure 7-3: How the heuristic works for input years 0–99'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-3：启发式方法如何处理0-99岁输入
- en: Okay, any heuristic is crude by design—but the focus here is on how avoiding
    a captive user interface has helped us put the code to work to produce this plot.
    If we hadn’t adhered to the principle, we couldn’t have reused the original code
    function `your_life_expectancy` because the captive user interface required a
    user input for each year 0 to 99\. By considering the principle, we’ve simplified
    the code and opened up all kinds of future programs to use and build upon the
    heuristic. Instead of optimizing for one specific use case, we’ve written the
    code in a general way that can be used by hundreds of different applications.
    Why not create a library out of it?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，任何启发式方法本质上都是粗糙的——但这里的重点是，避免使用限制性的用户界面帮助我们将代码付诸实践，绘制出这个图表。如果我们没有遵循这个原则，我们就无法复用原始代码函数`your_life_expectancy`，因为限制性用户界面要求每年（0到99岁）都要有用户输入。通过遵循这一原则，我们简化了代码，并为未来的所有程序打开了使用和扩展这个启发式方法的可能性。我们没有针对某一个特定的用例进行优化，而是将代码编写得更加通用，能够被数百个不同的应用程序使用。为什么不把它做成一个库呢？
- en: 9\. Make Every Program a Filter
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9\. 使每个程序都成为一个过滤器
- en: There’s a good argument to be made that every program already is a filter. A
    filter transforms an input to an output using a specific filtering mechanism.
    This allows us to easily string together multiple programs by using the output
    of one as the input of another, thereby increasing the reusability of your code
    significantly. For example, it’s generally not a good practice to print the result
    of a computation in the function itself—instead, the philosophy suggests that
    the program should return a string that can then be printed, written into a file,
    or used as input for another program.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可以提出一个合理的观点，即每个程序本身已经是一个过滤器。过滤器使用特定的过滤机制将输入转化为输出。这使得我们可以通过将一个程序的输出作为另一个程序的输入，轻松地将多个程序串联起来，从而大大提高代码的可重用性。例如，通常来说，在函数内部打印计算结果并不是一个好的做法——而是建议程序返回一个字符串，之后可以打印出来、写入文件或用作另一个程序的输入。
- en: For example, a program that sorts a list can be considered a filter that filters
    the unsorted elements into a sorted order, as in [Listing 7-12](#listing7-12).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个排序列表的程序可以被视为一个过滤器，它将未排序的元素过滤成排序后的顺序，正如[列表 7-12](#listing7-12)所示。
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 7-12: This insertion sort algorithm filters an unsorted list to a sorted
    list.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-12：这个插入排序算法将一个未排序的列表过滤成一个已排序的列表。
- en: The algorithm creates a new list and inserts each element at the position where
    all elements on the left are smaller than the inserted element. The function uses
    a complex filter to change the order of the elements, transforming the input list
    into a sorted output list.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法创建一个新列表，并将每个元素插入到所有左侧元素都小于该插入元素的位置。此函数使用复杂的过滤机制来改变元素的顺序，将输入列表转换为排序后的输出列表。
- en: If any program already is a filter, you should design it as such by using intuitive
    input/output mapping. Let me explain this next.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何程序本身已经是一个过滤器，你应该通过直观的输入/输出映射将其设计为一个过滤器。接下来，我将为你解释这个概念。
- en: 'The gold standard for filters is a *homogeneous* input/output mapping where
    one type of input is mapped to the same type of output. For example, if someone
    talks to you in English, they expect you to respond in English—and not in another
    language. Similarly, if a function takes an input argument, the expected output
    is a function return value. If a program reads from a file, the expected output
    is a file. If a program reads the input from the standard input, it should write
    the program to the standard output. You get the point: the most intuitive way
    to design a filter is to keep the data in the same category.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器的黄金标准是*同质*的输入/输出映射，其中一种类型的输入映射到相同类型的输出。例如，如果有人用英语和你交谈，他们期望你用英语回应，而不是用另一种语言。类似地，如果一个函数接受一个输入参数，期望的输出是函数的返回值。如果一个程序从文件中读取，期望的输出是一个文件。如果一个程序从标准输入中读取，它应该把程序输出到标准输出。你明白了吧：设计一个过滤器的最直观方法就是保持数据在相同的类别中。
- en: '[Listing 7-13](#listing7-13) shows a negative example with *heterogeneous*
    input/output mapping where we build an `average()` function that transforms the
    input arguments into their average—but instead of returning the average value,
    `average()` prints the result to the shell.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 7-13](#listing7-13)展示了一个负面例子，使用*异质*输入/输出映射，在这个例子中，我们构建了一个`average()`函数，将输入参数转换为它们的平均值——但它没有返回平均值，而是将结果打印到终端。'
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 7-13: Negative example of heterogeneous input/output mapping'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-13：异质输入/输出映射的负面例子
- en: A better approach, shown in [Listing 7-14](#listing7-14), makes the function
    `average()` return the average value (homogeneous input/output mapping), which
    you can then print to the standard output in a separate function call using the
    `print()` function. This is better because it allows you, for example, to write
    the output into a file rather than print it—or even use it as an input for another
    function.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法，如[示例 7-14](#listing7-14)所示，是让函数`average()`返回平均值（同质输入/输出映射），然后你可以在另一个函数调用中使用`print()`函数将其打印到标准输出。这更好，因为它允许你将输出写入文件而不是打印，或者甚至将其作为另一个函数的输入。
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 7-14: Positive example of homogeneous input/output mapping'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-14：同质输入/输出映射的正面例子
- en: Sure, some programs filter from one category to another—for example, writing
    a file to the standard output or translating English to Spanish. But following
    the principle of creating programs that do one thing well (see Unix Principle
    1), these programs should do nothing else. This is the gold standard of writing
    intuitive and natural programs—design them as filters!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一些程序会从一种类别过滤到另一种类别——例如，将文件写入标准输出，或者将英语翻译成西班牙语。但遵循编写只做一件事且做得好的程序的原则（参见 Unix
    原则 1），这些程序不应做任何其他事情。这就是编写直观且自然的程序的黄金标准——将它们设计为过滤器！
- en: 10\. Worse Is Better
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10\. 更差的就是更好的
- en: This principle suggests that developing code with less functionality is often
    the better approach in practice. When resources are limited, it’s better to release
    a worse product and be first on the market than strive continually to make it
    better before you can release it. This principle, conceived by list processing
    (LISP) developer Richard Gabriel in the late eighties, is similar to the MVP principle
    from Chapter 3. Don’t take this counterintuitive principle too literally. Worse
    is not better from a qualitative perspective. If you had infinite time and resources,
    it would be best always to make the program perfect. However, in a world with
    limited resources, releasing something worse is often more efficient. For instance,
    a crude and straightforward solution to a problem gives you a first-mover advantage,
    attracts quick feedback from the early adopters, and gains momentum and attention
    early in the software development process. Many practitioners argue that a second-mover
    must invest far more energy and resources to create a far superior product that’s
    able to pull users away from the first-mover.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这一原则表明，在实际开发中，功能较少的代码往往是更好的方法。当资源有限时，发布一个较差的产品并率先进入市场，往往比在发布之前不断改进它要好。这一原则由列表处理（LISP）开发者理查德·加布里埃尔（Richard
    Gabriel）在八十年代末提出，类似于第3章中的MVP原则。不要过于字面地理解这一反直觉的原则。从质量角度来看，较差并不意味着更好。如果你拥有无限的时间和资源，最好总是使程序完美。然而，在有限资源的世界里，发布一个较差的版本通常更有效。例如，一个粗糙而直接的问题解决方案可以让你占据先发优势，吸引早期采用者的快速反馈，并在软件开发过程中早期获得动力和关注。许多从业者认为，后发者必须投入更多的精力和资源，才能创造出远超前者的产品，吸引用户。
- en: 11\. Clean Code Is Better Than Clever Code
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11\. 清晰的代码优于聪明的代码
- en: 'I slightly modified the original principle in the Unix philosophy, *clarity
    is better than cleverness*, first to focus the principle on programming code and,
    second, to align it with the principles you’ve already learned: how to *write
    clean code* (see Chapter 4).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我稍微修改了Unix哲学中的原始原则，*清晰胜于巧妙*，首先将这个原则专注于编程代码，其次将其与您已经学到的原则对齐：如何*编写简洁的代码*（参见第4章）。
- en: 'This principle highlights the trade-off between clean and clever code: clever
    code shouldn’t come at the cost of simplicity.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则强调了简洁和巧妙代码之间的权衡：巧妙的代码不应以简洁为代价。
- en: 'For example, have a look at the simple bubble sort algorithm in [Listing 7-15](#listing7-15).
    A bubble sort algorithm sorts a list by going through it iteratively and switching
    the position of any two adjacent elements that aren’t sorted: the smaller element
    goes to the left, and the larger element goes to the right. Each time that happens,
    the list becomes a bit more sorted.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看[清单7-15](#listing7-15)中的简单冒泡排序算法。冒泡排序算法通过迭代遍历列表并交换任何未排序的相邻元素的位置来对列表进行排序：较小的元素移到左边，较大的元素移到右边。每当发生这种交换时，列表就会变得更加有序。
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 7-15: Bubble sort algorithm in Python'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 清单7-15：Python中的冒泡排序算法
- en: The algorithm in [Listing 7-15](#listing7-15) is readable and clear, and it
    achieves the goal and doesn’t contain unnecessary code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单7-15](#listing7-15)中的算法可读性高，清晰明了，达到了目标，并且没有包含不必要的代码。'
- en: Now, suppose your bright colleague argues that you could shorten the code using
    *conditional assignments* to express the `if` statement with one less line of
    code (see [Listing 7-16](#listing7-16)).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你聪明的同事辩称，你可以通过使用*条件赋值*来缩短代码，用一行更少的代码来表达`if`语句（参见[清单7-16](#listing7-16)）。
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 7-16: “Clever” bubble sort algorithm in Python'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 清单7-16：“聪明的”Python冒泡排序算法
- en: The trick doesn’t improve the code but does reduce readability and clarity.
    Conditional assignment features may be clever, but using them comes at the cost
    of expressing your ideas with clean code. For more tips on how to write clean
    code, please refer to Chapter 4.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧并没有改善代码，反而降低了可读性和清晰度。条件赋值特性可能很聪明，但使用它们是以表达想法时不够简洁的代价为前提的。想了解更多如何编写简洁代码的技巧，请参考第4章。
- en: 12\. Design Programs to Connect With Other Programs
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12. 设计程序以与其他程序连接
- en: Your programs do not live in isolation. A program is called to perform a task,
    either by a human being or by another program. You therefore need to design the
    API to work with the outside world—users or other programs. By adhering to Unix
    Principle 9, *make any program a filter*, which says to ensure the input/output
    mapping is intuitive, you’re already designing connected programs rather than
    making them live in isolation. The great programmer is as much an architect as
    a craftsperson. They create new programs as a unique combination of old and new
    functions and other people’s programs. As a result, interfaces are able to be
    front and center of the development cycle.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序并非孤立存在。程序被调用来执行任务，无论是由人类还是由其他程序。因此，你需要设计API以便与外部世界——用户或其他程序——进行交互。通过遵循Unix原则9，*让任何程序都成为过滤器*，即确保输入/输出映射直观易懂，你已经在设计可以连接的程序，而不是让它们孤立存在。伟大的程序员既是架构师，也是工匠。他们创造的新程序是旧功能和新功能以及其他人程序的独特组合。因此，接口能够成为开发周期的核心。
- en: 13\. Make Your Code Robust
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13. 使你的代码健壮
- en: 'A codebase is *robust* if it cannot be easily broken. There are two perspectives
    on code robustness: the programmer’s view and the user’s view.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个代码库是*健壮*的，它就不容易被破坏。代码健壮性有两种视角：程序员的视角和用户的视角。
- en: As the programmer, you could potentially break code by modifying it. A codebase
    is therefore *robust against change* if even a careless programmer can work on
    the codebase without being able to destroy its functionality easily. Say you have
    a big, monolithic code block and every programmer in your organization has *edit
    access* to that whole thing. Any small change could break the whole thing. Now,
    compare this to code developed by organizations like Netflix or Google, where
    every change has to go through multiple approval levels before being deployed
    in the real world; changes are thoroughly tested, so deployed code is protected
    against breaking changes. By adding layers of protection, Google and Netflix have
    made their code more robust than a fragile, monolithic codebase.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，你可能会通过修改代码而破坏它。因此，代码库*对变更具有稳健性*，即使是一个粗心的程序员也可以在不轻易破坏功能的情况下对代码库进行工作。假设你有一个大的单体代码块，并且你组织中的每个程序员都对这个代码块具有*编辑权限*。任何小的修改都可能破坏整个系统。现在，拿这个和像Netflix或Google这样的公司开发的代码进行比较，在这些公司，每个更改都必须经过多个审批级别才能部署到实际环境中；更改会经过充分的测试，因此部署的代码能有效防止破坏性更改。通过增加保护层，Google和Netflix使他们的代码比脆弱的单体代码库更加稳健。
- en: 'One way to accomplish codebase robustness is to control access rights so that
    individual developers are not able to damage the application without verifying
    with at least one additional person that the change is more likely to add value
    than damage the code. The process may come at a price of less agility, but the
    price is worth paying if you’re not a one-person startup. We’ve already seen other
    ways to ensure code robustness throughout the book: small is beautiful, create
    functions that do one thing well, use test-driven development, keep things simple.
    A few other easily applied techniques are the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 确保代码库的稳健性的一种方法是控制访问权限，以便个别开发人员在未经至少一个额外人员验证的情况下，不能修改应用程序，确保修改更可能为代码增加价值而不是造成破坏。这个过程可能会以较低的敏捷性为代价，但如果你不是一个单人创业公司，这个代价是值得支付的。我们在本书中已经看到了确保代码稳健性的其他方法：简洁即美，创建做一件事做得很好的函数，使用测试驱动开发，保持简单。还有一些其他容易应用的技术如下：
- en: Use versioning systems such as Git so that you can recover previous versions
    of your code.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用像Git这样的版本控制系统，以便你可以恢复代码的先前版本。
- en: Back up your application data regularly to make it recoverable (data is not
    part of a versioning system).
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期备份你的应用程序数据，使其可恢复（数据不属于版本控制系统的范畴）。
- en: 'Use distributed systems to avoid a single point of failure: run your application
    on multiple machines to reduce the probability of a failing machine adversely
    affecting your application. Say one machine has a failure probability of 1 percent
    per day—it’ll fail about every 100 days. Creating a distributed system of five
    machines that fail independently can theoretically reduce your failure probability
    to 0.01⁵ × 100% = 0.00000001%.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分布式系统来避免单点故障：将你的应用程序运行在多台机器上，以降低单台机器故障对应用程序的负面影响。假设一台机器的故障概率是每天1%，它大约每100天就会故障。创建一个由五台独立故障的机器组成的分布式系统，可以理论上将故障概率降低到0.01⁵
    × 100% = 0.00000001%。
- en: For a user, an application is robust if you cannot easily break it by providing
    faulty or even malicious inputs. Assume that your users will behave like a mob
    of gorillas smacking the keyboard and submitting random series of characters and
    that highly skilled hackers understand the application better than you and are
    ready to exploit even the smallest security issue. Your application must be robust
    against both types of users.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户而言，如果你不能通过提供有缺陷甚至恶意的输入轻易破坏一个应用程序，那么这个应用程序是稳健的。假设你的用户像一群猩猩一样乱按键盘，提交随机的字符序列，并且那些技术高超的黑客比你更了解应用程序，准备利用任何即便是最小的安全问题。你的应用程序必须能够抵御这两类用户。
- en: 'It’s relatively simple to shield against the former group. Unit testing is
    one powerful tool: test any function against any function input you can think
    of, especially border cases. For example, if your function takes an integer and
    calculates the square root, check that it can handle negative inputs and 0 because
    unhandled exceptions would break the chain of reliable, simple, chainable programs.
    However, unhandled exceptions lead to another more subtle problem that was brought
    to my attention by security expert and technical editor of this book, Noah Spahn:
    providing input to break a program can give attackers a foothold into the host
    operating system. So, check your program’s ability to process all kinds of inputs
    and, thereby, make your code more robust!'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前一类错误，防范相对简单。单元测试是一个强有力的工具：测试任何函数，针对你能想到的任何函数输入，特别是边界情况。例如，如果你的函数接受一个整数并计算平方根，检查它是否能处理负数输入和0，因为未处理的异常会破坏可靠、简单、可链式的程序链条。然而，未处理的异常会引发另一个更微妙的问题，安全专家和本书技术编辑Noah
    Spahn提醒了我这一点：提供输入来破坏程序可能会为攻击者提供进入宿主操作系统的立足点。因此，检查你的程序处理各种输入的能力，从而使你的代码更健壮！
- en: 14\. Repair What You Can—But Fail Early and Noisily
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14\. 修复你能修复的错误——但要尽早且大声地失败
- en: While you should repair problems in your code wherever possible, you shouldn’t
    hide the errors you cannot fix. A hidden error will quickly compound, becoming
    bigger and bigger the longer it remains hidden.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你应该尽可能修复代码中的问题，但你不应隐藏无法修复的错误。隐藏的错误会迅速积累，长时间隐藏后会变得越来越严重。
- en: 'Errors can accumulate. For example, say the speech recognition system in your
    driving assistance app is fed faulty training data classifying two completely
    different phonetic waves as the same word (see [Figure 7-4](#figure7-4)). So your
    code raises an error trying to map two completely different phonetic waves to
    the same English word (for example, the error may occur as you try to store this
    contradictory information in an inverted index that maps English terms to phonetic
    waves). You can write your code in two ways: hide the error or propagate the error
    up to the application, user, or programmer. While many coders intuitively want
    to hide errors from the users to improve usability, this is not the most sensible
    approach. Error messages should carry useful information. If your code makes you
    aware of this problem early, you could figure out a solution in advance. You better
    become aware of errors early before their consequences cumulate and destroy millions
    of dollars or even human lives.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 错误可能会积累。例如，假设你在驾驶辅助应用中的语音识别系统接收了错误的训练数据，将两个完全不同的语音波形错误地分类为同一个单词（参见[图 7-4](#figure7-4)）。于是你的代码在试图将这两种完全不同的语音波形映射到同一个英文单词时抛出错误（例如，当你尝试将这种矛盾信息存储到一个将英语术语映射到语音波形的倒排索引中时，错误可能就会发生）。你可以通过两种方式编写代码：隐藏错误或将错误传播给应用程序、用户或程序员。虽然许多程序员直觉上希望通过隐藏错误来提高可用性，但这并不是最明智的方法。错误信息应该包含有用的信息。如果你的代码能让你及早意识到这个问题，你可以提前找到解决方案。你最好在错误的后果积累并摧毁数百万美元甚至人命之前，尽早意识到这些错误。
- en: '![Graphic depicting the classifier algorithm mapping the terms “right” and
    “left” to the same term: “right.”](image_fi/502185c07/f07004.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图示展示分类器算法将“right”和“left”这两个术语映射到同一个术语“right”上。](image_fi/502185c07/f07004.png)'
- en: 'Figure 7-4: Classifier in the training phase maps two different phonetic waves
    to the same English word.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-4：训练阶段的分类器将两种不同的语音波形映射到相同的英文单词上。
- en: It’s better to raise unfixable errors and hand them to the user than bury them,
    even if the user doesn’t appreciate the error message and the usability of your
    application decreases. The alternative is to bury the errors until they have grown
    too big to ever handle.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与其埋藏无法修复的错误，宁可抛出错误并交给用户处理，即便用户可能不会欣赏错误信息，且你的应用程序的可用性因此下降。另一种做法是将错误埋藏起来，直到它们变得无法处理。
- en: To continue with our faulty training data example, [Listing 7-17](#listing7-17)
    shows an example in which the Python `classify()` function takes one input argument—the
    wave to be classified—and returns the English word associated with this classification.
    Say you’ve implemented a `duplicate_check(wave, word)` function that checks whether
    a substantially different wave in your database results in the same classification
    using the `wave` and `word` pairs. In this case, the classification is ambiguous
    because two completely different waves map to the same English word, and you should
    share this with the user by raising a `ClassificationError` rather than returning
    a random guess of the classified word. Yes, the user will be annoyed, but at least
    they have a chance to handle the consequences of the error themselves. *Repair
    what you can—but fail early and noisily!*
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们错误训练数据的例子，[示例 7-17](#listing7-17)展示了一个例子，其中 Python 的 `classify()` 函数接受一个输入参数——需要分类的波形——并返回与该分类相关的英文单词。假设你已经实现了一个
    `duplicate_check(wave, word)` 函数，用来检查数据库中是否存在与某个波形相似的波形，且它们返回相同的分类结果（`wave` 和
    `word` 配对）。在这种情况下，分类是模糊的，因为两种完全不同的波形映射到相同的英文单词，你应该通过抛出一个 `ClassificationError`
    来与用户分享这个问题，而不是返回一个随机的分类结果。是的，用户会不高兴，但至少他们有机会自己处理错误带来的后果。*修复你能修复的——但要尽早且显著地失败！*
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 7-17: Code snippet with noisy failure instead of random guess if the
    wave cannot be classified unambiguously'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-17：如果波形无法明确分类，使用带有噪声失败的代码片段，而不是随机猜测
- en: '15\. Avoid Hand-Hacking: Write Programs to Write Programs If You Can'
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15\. 避免手动编写代码：如果可以，写程序来写程序
- en: The principle suggests that code that can be generated automatically *should
    be*, because humans are notoriously prone to failures, especially in an activity
    that’s repetitive and boring. There are many ways to accomplish this—in fact,
    modern high-level programming languages such as Python are compiled down to machine
    code using such programs. By writing programs to write programs, the creators
    of those compilers helped high-level programmers to create all kinds of application
    software without needing to worry about low-level hardware programming languages.
    Without those programs writing programs for us, the computer industry would still
    be in its infancy.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 该原则建议，应该自动生成的代码*应该*由机器完成，因为人类在这类重复且枯燥的活动中容易出错。有许多方式可以实现这一点——事实上，现代的高级编程语言，如
    Python，都是通过此类程序编译成机器码的。通过编写程序来编写程序，这些编译器的创造者帮助高级程序员创建各种应用软件，而无需担心低级硬件编程语言。如果没有这些为我们编写程序的程序，计算机行业仍然处于初期阶段。
- en: 'Code generators and compilers already produce large amounts of source code
    today. Let’s examine an additional way to think of this principle. Today, the
    technologies of machine learning and artificial intelligence lift this concept
    of writing programs to write programs to yet another level. Intelligent machines
    (machine learning models) are assembled by humans and then go on to rewrite (and
    tune) themselves based on data. Technically, a machine learning model is a program
    that has rewritten itself many times over until its behavior has maximized a set
    fitness function (usually set by humans). As machine learning permeates (and prevails
    over) more areas of computer science, this principle will become more and more
    relevant in modern computing. Human programmers will still play a major role in
    using those powerful tools; after all, compilers have not replaced human labor
    but have instead opened up a new world of applications created by human programmers.
    I expect that the same will happen in programming: machine learning engineers
    and software architects will design advanced applications by connecting the different
    low-level programs, such as machine learning models. Well, that’s one view on
    the topic—yours may be more or less optimistic!'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成器和编译器今天已经能够生成大量的源代码。让我们从另一个角度来思考这个原则。如今，机器学习和人工智能的技术将“写程序来写程序”这一概念提升到了另一个层次。智能机器（机器学习模型）由人类组装，然后根据数据进行自我重写（和调优）。从技术上讲，机器学习模型就是一个已经经过多次自我重写的程序，直到其行为最大化某个设定的适应函数（通常由人类设置）。随着机器学习在计算机科学领域的普及（并逐渐占据主导地位），这一原则在现代计算中将变得越来越相关。人类程序员仍将在人类使用这些强大工具的过程中发挥重要作用；毕竟，编译器并没有取代人类的劳动，而是为人类程序员打开了一个全新的应用世界。我预计在编程领域也会发生同样的事情：机器学习工程师和软件架构师将通过连接不同的低级程序（如机器学习模型）来设计高级应用程序。好吧，这只是我对这个话题的一种看法——你的看法可能更乐观或更悲观！
- en: Conclusion
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, you’ve learned 15 principles designed by the Unix creators
    to write better code. It’s worth repeating them—as you read through the list,
    think about how each principle applies to your current code project.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你已经学习了由Unix创始人设计的15条原则，用于编写更好的代码。值得一再强调它们——在阅读这些原则时，思考每一条是如何应用到你当前的代码项目中的。
- en: Make each function do one thing well.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让每个函数都做好一件事。
- en: Simple is better than complex.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单优于复杂。
- en: Small is beautiful.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小就是美。
- en: Build a prototype as soon as possible.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽早构建一个原型。
- en: Choose portability over efficiency.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在效率和可移植性之间，选择可移植性。
- en: Store data in flat text files.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据存储在纯文本文件中。
- en: Use software leverage to your advantage.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用软件杠杆发挥你的优势。
- en: Avoid captive user interfaces.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免封闭的用户界面。
- en: Make every program a filter.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让每个程序都成为一个过滤器。
- en: Worse is better.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更差的东西反而更好。
- en: Clean code is better than clever code.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 干净的代码优于巧妙的代码。
- en: Design programs to be connected with other programs.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计程序时要考虑到与其他程序的连接。
- en: Make your code robust.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使你的代码更加健壮。
- en: Repair what you can—but fail early and noisily.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复你能修复的东西——但要尽早失败，并发出明显的信号。
- en: Write programs to write programs.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写程序来编写程序。
- en: In the next chapter, you’ll learn about the impact of minimalism on design and
    how it can help you design applications that delight your users by doing less.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习极简主义对设计的影响，以及它如何帮助你设计出让用户满意的应用程序，尽管这些程序做的事情更少。
- en: Resources
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源
- en: 'Mike Gancarz, *The Unix Philosophy*, Boston: Digital Press, 1994.'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mike Gancarz，*《Unix哲学》*，波士顿：数字出版社，1994年。
- en: 'Eric Raymond, *The Art of Unix*, Boston: Addison-Wesley, 2004, [http://www.catb.org/~esr/writings/taoup/html/](http://www.catb.org/~esr/writings/taoup/html/).'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Eric Raymond，*《Unix的艺术》*，波士顿：Addison-Wesley，2004年，[http://www.catb.org/~esr/writings/taoup/html/](http://www.catb.org/~esr/writings/taoup/html/)。
