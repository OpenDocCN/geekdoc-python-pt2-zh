- en: '16'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '16'
- en: Completing the Mr. Stick Man Game
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 完善《小人先生》游戏
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common.jpg)'
- en: 'In the previous three chapters, we’ve been developing our game: *Mr. Stick
    Man Races for the Exit*. We created the graphics, and then wrote code to add the
    background image, platforms, and stick figure. In this chapter, we’ll fill in
    the missing pieces to animate the stick figure and add the door. You’ll find the
    full listing for the complete game at the end of this chapter. If you get lost
    or become confused when writing some of this code, compare your code with that
    listing to see where you might have gone wrong.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的三章中，我们一直在开发我们的游戏：《小人先生竞速逃生》。我们创建了图像，然后编写代码添加背景图像、平台和小人。在本章中，我们将填补缺失的部分，给小人添加动画并添加门。你可以在本章末尾找到完整游戏的代码清单。如果你在编写某些代码时迷失了方向或感到困惑，可以将你的代码与该清单进行比较，看看你可能出了什么问题。
- en: Animating the Stick Figure
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画化小人
- en: So far, we’ve created a basic class for our stick figure, loading the images
    we’ll be using and binding keys to some functions. But none of our code will do
    anything particularly interesting if you run the game at this point.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为小人创建了一个基本类，加载了我们将使用的图像，并将按键绑定到一些函数。但如果你此时运行游戏，我们的代码不会做出任何特别有趣的事情。
- en: 'Now we’ll add the remaining functions to the StickFigureSprite class we created
    in [Chapter 15](ch15.xhtml#ch15): animate, move, and coords. The animate function
    will draw the different stick figure images; move will determine where the character
    needs to move to; and coords will return the stick figure’s current position.
    (Unlike with the platform sprites, we need to recalculate the position of the
    stick figure as he moves around the screen.)'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将向我们在[第15章](ch15.xhtml#ch15)中创建的StickFigureSprite类添加剩余的函数：animate、move和coords。animate函数将绘制不同的小人图像；move函数将确定角色需要移动的位置；coords函数将返回小人当前位置。（与平台精灵不同，我们需要在小人移动时重新计算其在屏幕上的位置。）
- en: '![Image](Images/f0244-01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0244-01.jpg)'
- en: Creating the Animate Function
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建动画函数
- en: First, we’ll add the animate function, which will need to check for movement
    and change the image accordingly.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将添加动画函数，该函数需要检查是否有移动，并相应地更改图片。
- en: Checking for Movement
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查是否移动
- en: We don’t want to change the stick figure image too quickly in our animation,
    or its movement won’t look realistic. Think about a flip animation, drawn in the
    corner of a notepad—if you flip the pages too quickly, you may not get the full
    effect of what you’ve drawn.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望在动画中改变小人图像的速度太快，否则其运动看起来不真实。想象一下在记事本角落绘制的翻页动画——如果翻页速度太快，你可能无法完全呈现你所绘制的效果。
- en: 'The first half of the animate function checks to see if the stick figure is
    running to the left or right, and then uses the last_time variable to decide whether
    to change the current image. This variable will help us control the speed of our
    animation. The function will go after the jump function, which we added to our
    StickFigureSprite class in [Chapter 15](ch15.xhtml#ch15) ([page 238](ch15.xhtml#ch15lev1sec6)):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 动画函数的前半部分检查小人是向左还是向右跑，然后利用last_time变量来决定是否更换当前图片。这个变量将帮助我们控制动画的速度。这个函数会紧接着我们在[第15章](ch15.xhtml#ch15)（[第238页](ch15.xhtml#ch15lev1sec6)）中为StickFigureSprite类添加的跳跃函数之后。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the first if statement, we check to see if x is not 0 to determine whether
    the stick figure is moving (either left or right), and we check to see if y is
    0 to determine that the stick figure is not jumping. If this if statement is True,
    we need to animate our stick figure; if not, he’s standing still, so there’s no
    need to keep drawing. If the stick figure isn’t moving, we drop out of the function,
    and the rest of the code in this listing is ignored.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个if语句中，我们检查x是否不为0，以确定小人是否在移动（向左或向右），并检查y是否为0，以确认小人没有跳跃。如果此if语句为True，我们需要为小人添加动画；如果不为True，则说明小人静止不动，因此无需继续绘制。如果小人没有移动，我们就跳出函数，后面的代码将被忽略。
- en: We then calculate the amount of time since the animate function was last called,
    by subtracting the value of the last_time variable from the current time, using
    time.time(). This calculation is used to decide whether to draw the next image
    in the sequence. If the result is greater than a tenth of a second (0.1), we continue
    with the block of code. We set the last_time variable to the current time, basically
    resetting the stopwatch to start timing again for the next image change.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过用`time.time()`获取当前时间，并减去last_time变量的值，计算出自上次调用animate函数以来经过的时间。这个计算用于决定是否绘制序列中的下一张图像。如果结果大于0.1秒，我们继续执行代码块。我们将last_time变量设置为当前时间，基本上是重置计时器，为下一次图像更改开始计时。
- en: Next, we add the value of the object variable current_image_add to the variable
    current_image, which stores the index position of the currently displayed image.
    Remember that we created the current_image_add variable in the stick figure’s
    __init__ function in [Chapter 15](ch15.xhtml#ch15) (see [page 235](ch15.xhtml#ch15lev1sec3)),
    so when the animate function is first called, the value of the variable has already
    been set to 1.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对象变量current_image_add的值加到当前图像索引位置的变量current_image中。记住，我们在[第15章](ch15.xhtml#ch15)的火柴人`__init__`函数中创建了current_image_add变量（见[第235页](ch15.xhtml#ch15lev1sec3)），所以当animate函数第一次被调用时，变量的值已经设置为1。
- en: Then, we check to see if the value of the index position in current_image is
    greater than or equal to 2; if so, we change the value of current_image_add to
    –1\. The process is similar for the last two lines; once we reach 0, we need to
    start counting up again.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查current_image中的索引位置的值是否大于或等于2；如果是，我们将current_image_add的值改为-1。最后两行的过程类似；一旦达到0，我们需要重新开始计数。
- en: Note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you’re having trouble figuring out how to indent this code, here’s a hint:
    there are 8 spaces at the line beginning if self.x and 20 spaces at the last line.*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你在弄清楚如何缩进这段代码时遇到困难，给你一个提示：在“if self.x”这一行开头有8个空格，而在最后一行有20个空格。*'
- en: To help you understand what’s going on in the function so far, imagine that
    you have a sequence of colored blocks in a line on the floor. You move your finger
    from one block to the next, and each block that your finger points to has a number
    (1, 2, 3, 4, and so on)—this is the current_image variable. The number of the
    block your finger moves to (it points at one block at a time) is the number stored
    in the current_image_add variable. When your finger moves one way up the line
    of blocks, you’re adding 1 each time, and when it hits the end of the line and
    moves back down, you’re subtracting 1 (adding –1).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你理解到目前为止函数中发生的事情，想象一下你在地板上有一排彩色块。你把手指从一个块移动到下一个块，每个你手指指向的块都有一个数字（1，2，3，4，依此类推）——这就是current_image变量。你手指指向的块的编号（它一次指向一个块）是存储在current_image_add变量中的数字。当你的手指朝着块的方向向前移动时，每次你都在加1，而当它到达末端并向下移动时，你在减去1（即加-1）。
- en: The code we’ve added to our animate function performs this process, but instead
    of colored blocks, we have the three stick figure images for each direction stored
    in a list. The index positions of these images are 0, 1, and 2\. As we animate
    the stick figure, once we reach the last image, we start counting down, and once
    we reach the first image, we need to start counting up again. As a result, we
    create the effect of a running figure.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到animate函数中的代码执行了这个过程，但不同的是，我们在列表中存储了三个方向的火柴人图像，而不是彩色块。这些图像的索引位置分别是0、1和2。当我们动画展示火柴人时，一旦到达最后一张图像，我们开始倒计时；当我们到达第一张图像时，我们需要重新开始计数。因此，我们创造了一个奔跑人物的效果。
- en: '[Table 16-1](ch16.xhtml#ch16tab01) shows how we move through the list of images,
    using the index positions we calculate in the animate function.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[表16-1](ch16.xhtml#ch16tab01)展示了我们如何通过animate函数中计算的索引位置，遍历图像列表。'
- en: '**Table 16-1:** Image Positions in Animation'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**表16-1：** 动画中的图像位置'
- en: '| Position 0 | Position 1 | Position 2 | Position 1 | Position 0 | Position
    1 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 位置 0 | 位置 1 | 位置 2 | 位置 1 | 位置 0 | 位置 1 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| Counting up | Counting up | Counting up | Counting down | Counting down |
    Counting up |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 计数增加 | 计数增加 | 计数增加 | 计数减少 | 计数减少 | 计数增加 |'
- en: '| ![Image](Images/246fig01.jpg) | ![Image](Images/246fig02.jpg) | ![Image](Images/246fig03.jpg)
    | ![Image](Images/246fig04.jpg) | ![Image](Images/246fig05.jpg) | ![Image](Images/246fig06.jpg)
    |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| ![Image](Images/246fig01.jpg) | ![Image](Images/246fig02.jpg) | ![Image](Images/246fig03.jpg)
    | ![Image](Images/246fig04.jpg) | ![Image](Images/246fig05.jpg) | ![Image](Images/246fig06.jpg)
    |'
- en: Changing the Image
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更改图像
- en: 'In the next half of the animate function, we change the currently displayed
    image, using the calculated index position:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 animate 函数的下一部分，我们使用计算出的索引位置更改当前显示的图像：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Firstly, if x is less than 0, the stick figure is moving left, so Python moves
    into the block of code, which checks whether y is not equal to 0 (meaning the
    stick figure is jumping). If y is not equal to 0 (the stick figure is jumping),
    we use the canvas’s itemconfig function to change the displayed image to the last
    image in our list of left-facing images at images_left[2]. Because the stick figure
    is jumping, we’ll use the image showing him in full stride to make the animation
    look a bit more realistic, as you can see in [Figure 16-1](ch16.xhtml#ch16fig01).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果 x 小于 0，小人正在向左移动，那么 Python 会进入代码块，检查 y 是否不等于 0（意味着小人在跳跃）。如果 y 不等于 0（小人正在跳跃），我们会使用
    canvas 的 itemconfig 函数将显示的图像更改为我们的左向图像列表中的最后一张图像 images_left[2]。由于小人正在跳跃，我们将使用显示他全程奔跑的图像，让动画看起来更加逼真，正如你在
    [图 16-1](ch16.xhtml#ch16fig01) 中看到的那样。
- en: '![Image](Images/16fig01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/16fig01.jpg)'
- en: '*Figure 16-1: Jumping images*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 16-1：跳跃图像*'
- en: If the stick figure is not jumping (that is, y is equal to 0), the else block
    ➊ uses itemconfig to change the displayed image to whatever index position is
    in the variable current_image.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果小人没有跳跃（也就是说，y 等于 0），else 块 ➊ 会使用 itemconfig 将显示的图像更改为当前图像索引变量 current_image
    中的内容。
- en: At the elif statement, we see if the stick figure is running right (x is greater
    than 0), and Python moves into the code block. This code is very similar to the
    first block, again checking whether the stick figure is jumping and drawing the
    correct image if so, except that it uses the images_right list.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 elif 语句中，我们检查小人是否在向右跑（x 大于 0），然后 Python 进入该代码块。这个代码与第一个块非常相似，再次检查小人是否跳跃，并在跳跃时绘制正确的图像，只不过这次使用的是
    images_right 列表。
- en: Getting the Stick Figure’s Position
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取小人位置
- en: 'Because we’ll need to determine where the stick figure is on the screen (since
    he’s moving around), the coords function will differ from the other Sprite class
    functions. We’ll use the coords function of the canvas to determine where the
    stick figure is, and then use those values to set the x1, y1 and x2, y2 values
    of the coordinates variable we created in the __init__ function at the beginning
    of [Chapter 15](ch15.xhtml#ch15). Add the following code after the animate function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们需要确定小人当前在屏幕上的位置（因为他会移动），所以 coords 函数与其他 Sprite 类函数有所不同。我们将使用 canvas 的 coords
    函数来确定小人所在的位置，然后使用这些值来设置我们在 [第 15 章](ch15.xhtml#ch15) 开头的 __init__ 函数中创建的坐标变量的
    x1、y1 和 x2、y2 值。将以下代码添加到 animate 函数后面：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we created the Game class in [Chapter 14](ch14.xhtml#ch14), one of the
    object variables was the canvas. We use the coords function of this canvas variable
    (with self.game.canvas.coords), which takes the identifier of something drawn
    on the canvas, and returns the *x* and *y* positions as a list of two numbers.
    In this case, we use the identifier stored in the variable current_image and store
    the returned list in the variable xy. We then use the two values to set the coordinates
    for our stick figure. The value xy[0] (that’s the first number in the list) becomes
    our x1 coordinate, and the value xy[1] (the second number in the list) becomes
    our y1 coordinate. So that’s the top-left position of the figure.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 [第 14 章](ch14.xhtml#ch14) 中创建 Game 类时，其中一个对象变量是 canvas。我们使用这个 canvas 变量的
    coords 函数（通过 self.game.canvas.coords），它接受画布上某个绘制物体的标识符，并返回一个包含 *x* 和 *y* 位置的两个数字的列表。在这里，我们使用存储在变量
    current_image 中的标识符，并将返回的列表存储在变量 xy 中。然后我们使用这两个值来设置小人的坐标。xy[0] 的值（即列表中的第一个数字）成为我们的
    x1 坐标，xy[1] 的值（列表中的第二个数字）成为我们的 y1 坐标。所以那是小人图像的左上角位置。
- en: Because all of the stick figure images we created are 27 pixels wide by 30 pixels
    high, we can determine what the x2 and y2 variables should be (that’s the bottom-right
    position of the figure) by adding the width and the height to the xy[0] and xy[1]
    values, respectively.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们创建的所有小人图像都是 27 像素宽、30 像素高，所以我们可以通过将宽度和高度分别加到 xy[0] 和 xy[1] 值上来确定 x2 和 y2
    应该是什么（那是小人的右下角位置）。
- en: 'So, if self.game.canvas.coords(self.image) returns [270, 350] we will end up
    with the following values:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果 self.game.canvas.coords(self.image) 返回 [270, 350]，我们将得到以下值：
- en: self.coordinates.x1 will be 270
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: self.coordinates.x1 的值将为 270
- en: self.coordinates.y1 will be 350
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: self.coordinates.y1 的值将为 350
- en: self.coordinates.x2 will be 297
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: self.coordinates.x2 的值将为 297
- en: self.coordinates.y2 will be 380
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: self.coordinates.y2 的值将为 380
- en: Finally, on the last line of the function, we return the object variable coordinates
    that we just updated.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在函数的最后一行，我们返回刚刚更新的对象变量坐标。
- en: Making the Stick Figure Move
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让小人移动
- en: The final function of the StickFigureSprite class, move, is in charge of actually
    moving our game character around the screen. It also needs to be able to tell
    us when the character has bumped into something.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: StickFigureSprite类的最后一个函数move负责实际控制游戏角色在屏幕上的移动。它还需要能够告诉我们角色是否碰到什么物体。
- en: Starting the move Function
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 开始移动函数
- en: 'The following code is for the first part of the move function. This will go
    after coords:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是移动函数的第一部分。这将跟在coords之后：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first line (self.animate()) calls the function we created earlier in this
    chapter, which changes the currently displayed image if necessary. Then, we see
    whether the value of y is less than 0\. If it is, we know that the stick figure
    is jumping because a negative value will move him up the screen. (Remember that
    0 is at the top of the canvas, and the bottom of the canvas is pixel position
    500.)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行（self.animate()）调用我们在本章前面创建的函数，如果需要，它会更改当前显示的图像。然后，我们检查y的值是否小于0。如果小于0，我们知道小人正在跳跃，因为负值会将他往上移动。（记住，0是在画布的顶部，画布的底部是像素位置500。）
- en: Next, we add 1 to jump_count. We want our stick figure to jump up, but not to
    keep floating up the screen forever (it’s jumping, after all), so we use that
    variable to count the number of times we have executed the move function—if it
    reaches 20, we should change y to 4 to start the stick figure falling again.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们给jump_count加1。我们希望小人跳起来，但不能让他一直在屏幕上浮动（毕竟是在跳），所以我们使用这个变量来计算我们执行了多少次移动函数——如果计数达到20，我们应该把y值设为4，让小人再次开始下落。
- en: We then see if the value of y is greater than 0 (meaning the character must
    be falling); if it is, we subtract 1 from jump_count because once we’ve counted
    up to 20, we need to count back down again. (Move your hand slowly up in the air
    while counting to 20, and then move it back down again while counting down from
    20, and you’ll get a sense of how calculating the stick figure jumping up and
    down is supposed to work.)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查y的值是否大于0（这意味着角色必须在下落）；如果是，我们从jump_count中减去1，因为当计数到20时，我们需要重新向下计数。（把手慢慢向空中抬起，同时数到20，然后再从20开始倒数，把手放回去，你就能明白计算小人上下跳跃的原理了。）
- en: '![Image](Images/f0250-01.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0250-01.jpg)'
- en: 'In the next few lines of the move function, we call the coords function, which
    tells us where our character is on the screen, and then store its result in the
    co variable. We then create the variables left, right, top, bottom, and falling.
    We’ll use each in the remainder of this function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几行move函数中，我们调用coords函数，它告诉我们角色在屏幕上的位置，然后将结果存储在co变量中。接着我们创建变量left、right、top、bottom和falling。在这个函数的后续部分，我们将使用这些变量：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that each variable has been set to the Boolean value True. We’ll use
    these as indicators to check whether the character has hit something on the screen
    or is falling.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个变量都被设置为布尔值True。我们将使用这些作为标志，检查角色是否碰到屏幕上的物体或正在下落。
- en: Has the Stick Figure Hit the Bottom or Top of the Canvas?
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 小人是否碰到画布的底部或顶部？
- en: 'The next section of the move function checks whether our character has hit
    the bottom or top of the canvas. Add the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: move函数的下一个部分检查我们的角色是否碰到画布的底部或顶部。请添加以下代码：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the character is falling down the screen, y will be greater than 0, so we
    need to make sure it hasn’t yet hit the bottom of the canvas (or it will vanish
    off the bottom of the screen). To do so, we see if its *y2* position (the bottom
    of the stick figure) is greater than or equal to the canvas_height variable of
    the game object. If it is, we set the value of y to 0 to stop the stick figure
    from falling, and then set the bottom variable to False, which tells the remaining
    code that we no longer need to see if the stick figure has hit the bottom.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果角色正在屏幕上方下落，y将大于0，因此我们需要确保它还没有碰到底部（否则它会从屏幕底部消失）。为此，我们检查其*y2*位置（小人底部）是否大于或等于游戏对象的canvas_height变量。如果是，我们将y的值设为0，以停止小人下落，然后将bottom变量设为False，这样剩下的代码就知道我们不再需要检查小人是否触底了。
- en: The process of determining whether the stick figure has hit the top of the screen
    is very similar to the way we determine whether he has hit the bottom. To do so,
    we first see if the stick figure is jumping (y is less than 0), and then we see
    if his *y1* position is less than or equal to 0, meaning he has hit the top of
    the canvas. If both conditions are true, we set y equal to 0 to stop the movement.
    We also set the top variable to False to tell the remaining code that we no longer
    need to see if the stick figure has hit the top.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 确定棒人是否撞到屏幕顶部的过程与确定他是否撞到底部非常相似。为此，我们首先检查棒人是否在跳跃（y 小于 0），然后检查他的 *y1* 位置是否小于或等于
    0，这意味着他撞到了画布顶部。如果两个条件都为真，我们将 y 设置为 0 以停止移动。我们还将 top 变量设置为 False，告知其余代码我们不再需要检查棒人是否撞到顶部。
- en: Has the Stick Figure Hit the Side of the Canvas?
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 棒人是否撞到画布的边缘？
- en: 'We follow almost exactly the same process as in the preceding code to determine
    whether the stick figure has hit the right and left sides of the canvas, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎按照与前面代码完全相同的过程来判断棒人是否撞到画布的左右两侧，具体如下：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The if statement is based on the fact that we know the stick figure is running
    to the right if x is greater than 0\. We also know whether he has hit the right-hand
    side of the screen by seeing if the *x2* position (co.x2) is greater than or equal
    to the width of the canvas stored in canvas_width. If either statement is true,
    we set x equal to 0 (to stop the stick figure from running) and set the right
    or left variables to False.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 if 语句基于以下事实：如果 x 大于 0，我们知道棒人在向右跑。我们还可以通过查看 *x2* 位置（co.x2）是否大于或等于存储在 canvas_width
    中的画布宽度，来判断他是否撞到屏幕的右侧。如果任一条件为真，我们将 x 设置为 0（以停止棒人跑动），并将 right 或 left 变量设置为 False。
- en: Colliding with Other Sprites
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与其他精灵发生碰撞
- en: 'Once we’ve determined whether the figure has hit the sides of the screen, we
    need to see if he has hit anything else on the screen. We use the following code
    to loop through the list of sprite objects stored in the game object to see if
    the stick figure has hit any of them:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定棒人是否撞到屏幕的两侧，我们需要检查他是否撞到屏幕上的其他物体。我们使用以下代码循环遍历存储在游戏对象中的精灵列表，查看棒人是否撞到其中任何一个：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At the for statement, we loop through the list of sprites, assigning each one
    in turn to the variable sprite. Then we say that if the sprite is equal to self
    (that’s another way of saying, “if this particular sprite is actually me”), we
    don’t need to determine whether the stick figure has collided because he would
    have only hit himself. If the sprite variable is equal to self, we use continue
    to jump to the next sprite in the list (continue simply tells Python to ignore
    the rest of the code in the block and continue the loop).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 for 语句中，我们循环遍历精灵列表，依次将每个精灵赋值给变量 sprite。然后我们说，如果精灵等于 self（这是另一种说法，“如果这个精灵实际上是我”），我们就不需要确定棒人是否发生碰撞，因为他只会撞到自己。如果
    sprite 变量等于 self，我们使用 continue 跳到列表中的下一个精灵（continue 只是告诉 Python 忽略代码块中的其余代码，继续循环）。
- en: Next, we get the coordinates of the new sprite by calling its coords function
    and storing the results in the sprite_co variable.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过调用其 coords 函数并将结果存储在 sprite_co 变量中来获取新精灵的坐标。
- en: 'The final if statement checks for the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的 if 语句检查以下内容：
- en: The stick figure has not hit the top of the canvas (the top variable is still
    true).
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 棒人没有撞到画布顶部（top 变量仍为真）。
- en: The stick figure is jumping (the y value is less than 0).
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 棒人正在跳跃（y 值小于 0）。
- en: The top of the stick figure has collided with the sprite from the list (using
    the collided_top function we created on [page 224](ch14.xhtml#ch14lev2sec3)).
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 棒人的顶部与精灵列表中的精灵发生了碰撞（使用我们在 [第224页](ch14.xhtml#ch14lev2sec3) 创建的 collided_top
    函数）。
- en: '![Image](Images/f0253-01.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/f0253-01.jpg)'
- en: If all of these conditions are true, we want the sprite to start falling back
    down again, so we reverse the value of the y variable (self.y becomes -self.y).
    The top variable is set to False because once the stick figure has hit the top,
    we don’t need to keep checking for a collision.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些条件都为真，我们希望精灵重新开始下落，因此我们将 y 变量的值反转（self.y 变为 -self.y）。top 变量设置为 False，因为一旦棒人撞到顶部，我们就不需要继续检查碰撞。
- en: Colliding at the Bottom
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 底部碰撞
- en: 'The next part of the loop checks to see if the bottom of our character has
    hit something:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的下一部分检查我们的角色底部是否撞到什么东西：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We start with three similar checks: whether the bottom variable is still set,
    whether the character is falling (y is greater than 0), and whether the bottom
    of our character has hit the sprite. If all three checks are true, we subtract
    the bottom *y* value (y2) of the stick figure from the top *y* value of the sprite
    (y1). This might seem strange, so let’s discuss why we do this.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从三个相似的检查开始：底部变量是否仍然设置，角色是否在下落（y 大于 0），以及我们角色的底部是否碰到精灵。如果这三个检查都为真，我们将小人底部的
    *y* 值（y2）从精灵顶部的 *y* 值（y1）中减去。这个看起来可能有些奇怪，下面我们来讨论一下为什么要这样做。
- en: Imagine that our game character has fallen off a platform. He moves down the
    screen 4 pixels each time the mainloop function runs, until the foot of the stick
    figure is 3 pixels above another platform. Let’s say the stick figure’s bottom
    (y2) is at position 57, and the top of the platform (y1) is at position 60\. In
    this case, the collided_bottom function would return True, because its code will
    add the value of y (which is 4) to the stick figure’s y2 variable, resulting in
    61.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的游戏角色已经从平台上掉下来。每当 mainloop 函数运行时，他都会下移 4 像素，直到小人脚下距离下一个平台只有 3 像素。假设小人底部（y2）的位置是
    57，平台顶部（y1）的位置是 60。在这种情况下，collided_bottom 函数会返回 True，因为它的代码会将 y 的值（即 4）加到小人的 y2
    变量上，得到 61。
- en: However, we don’t want Mr. Stick Man to stop falling as soon as it looks like
    he’ll hit a platform or the bottom of the screen, because that would be like taking
    a huge jump off a step and stopping in midair, an inch above the ground. That
    may be a neat trick, but it won’t look right in our game. Instead, if we subtract
    the character’s y2 value (57) from the platform’s y1 value (60), we get 3, the
    amount the stick figure should drop in order to land properly on top of the platform.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们并不希望小人一看到他会碰到平台或屏幕底部就停止下落，因为那就像是从台阶上跳下来却在半空中停住，离地面只有一英寸。虽然那可能是一个有趣的特技，但在我们的游戏中看起来不太合适。相反，如果我们将角色的
    y2 值（57）从平台的 y1 值（60）中减去，我们得到 3，这就是小人应该下落的距离，以便能够正确地落在平台上。
- en: We continue by making sure the calculation doesn’t result in a negative number
    (if self.y < 0:); if it does, we set y equal to 0\. (If we let the number be negative,
    the stick figure would fly back up again, and we don’t want that to happen.)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续确保计算不会导致负数（if self.y < 0:）；如果是负数，我们将 y 设置为 0。（如果允许这个数值为负，小人就会飞回去，我们不希望那样发生。）
- en: Finally, we set the top and bottom flags to False, so we no longer need to check
    whether the stick figure has collided at the top or bottom with another sprite.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将顶部和底部标志设置为 False，这样我们就不再需要检查小人是否与其他精灵在顶部或底部发生碰撞。
- en: 'We’ll follow this code with one more “bottom” check to see whether the stick
    figure has run off the edge of a platform. Here’s the code for this if statement:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们再做一次“底部”检查，查看小人是否已经跑出了平台的边缘。以下是该 if 语句的代码：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For the falling variable to be set to False, we must check that the following
    five elements are all true:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要将下落变量设置为 False，我们必须确保以下五个元素都为真：
- en: The bottom flag is set to True.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底部标志被设置为 True。
- en: The stick figure should be falling (the falling flag is still set to True).
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小人应该正在下落（下落标志仍然为 True）。
- en: The stick figure isn’t already falling (y is 0).
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小人并未开始下落（y 为 0）。
- en: The bottom of the sprite hasn’t hit the bottom of the screen (it’s less than
    the canvas height).
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精灵的底部没有碰到底部屏幕（它小于画布的高度）。
- en: The stick figure has hit the top of a platform (collided_bottom returns True).
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小人已经碰到了平台的顶部（collided_bottom 返回 True）。
- en: Then we set the falling variable to False to stop the figure from dropping down
    the screen.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将下落变量设置为 False，停止角色继续向下掉落。
- en: Note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '*You can check whether the value of a Boolean variable is True in an if statement
    by simply referencing the variable. For example, if bottom == True and falling
    == True can be rewritten simply as if bottom and falling (as we did above).*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以通过简单地引用变量来检查布尔变量的值是否为 True。例如，如果 bottom == True 且 falling == True，可以简化为
    if bottom 和 falling（就像我们上面做的那样）。*'
- en: Checking Left and Right
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查左右
- en: 'We’ve checked whether the stick figure has hit a sprite at the bottom or the
    top. Now we need to check whether he has hit the left or right side, with this
    code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经检查了小人是否碰到了精灵的底部或顶部。现在我们需要检查他是否碰到了左右两侧，可以使用以下代码：
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First, we see if we should still be looking for collisions to the left (left
    is still set to True) and whether the stick figure is moving to the left (x is
    less than 0). We also check to see if the stick figure has collided with a sprite
    by using the collided_left function. If these three conditions are true, we set
    x equal to 0 (to make the stick figure stop running), and set left to False, so
    that we no longer check for collisions on the left.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查是否仍需要检查左侧的碰撞（left 仍然设置为 True）以及火柴人是否在向左移动（x 小于 0）。我们还检查火柴人是否与精灵发生碰撞，使用
    collided_left 函数。如果这三个条件都成立，我们将 x 设置为 0（使火柴人停止跑动），并将 left 设置为 False，这样我们就不再检查左侧的碰撞了。
- en: '![Image](Images/f0255-01.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0255-01.jpg)'
- en: The code is similar for collisions to the right. We set x equal to 0 again,
    and set right to False, to stop checking for right-hand collisions.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对右侧碰撞的代码类似。我们再次将 x 设置为 0，并将 right 设置为 False，以停止检查右侧的碰撞。
- en: 'Now, with checks for collisions in all four directions, our for loop should
    look like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，经过四个方向碰撞的检查，我们的 for 循环应该是这样的：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We need to add only a few more lines to the move function, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要向移动函数中再添加几行，如下所示：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We check whether both the falling and bottom variables are set to True. If so,
    we’ve looped through every platform sprite in the list without colliding at the
    bottom.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查掉落和底部变量是否都设置为 True。如果是这样，我们就已经遍历了列表中的每一个平台精灵，而没有在底部发生碰撞。
- en: The final check in this line determines whether the bottom of our character
    is less than the canvas height—that is, above the ground (the bottom of the canvas).
    If the stick figure hasn’t collided with anything and is above the ground, he
    is standing in midair, so he should start falling (in other words, he has run
    off the end of a platform). To make him run off the end of any platform, we set
    y equal to 4.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这行中的最终检查确定我们的角色底部是否小于画布的高度——也就是说，是否在地面上方（画布底部）。如果火柴人没有与任何物体碰撞并且在地面上方，他就站在空中，因此他应该开始掉落（换句话说，他已经跑出了平台的边缘）。为了让他跑出任何平台的边缘，我们将
    y 设置为 4。
- en: Lastly, we move the image across the screen, according to the values we set
    in the variables x and y. The fact that we’ve looped through the sprites checking
    for collisions may mean that we’ve set both variables to 0, because the stick
    figure has collided on the left and with the bottom. In that case, the call to
    the move function of the canvas will actually do nothing.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们根据在 x 和 y 变量中设置的值将图像在屏幕上移动。我们遍历精灵并检查碰撞，可能意味着我们已经将两个变量都设置为 0，因为火柴人已经在左边和底部发生碰撞。在这种情况下，调用画布的移动函数实际上什么也不做。
- en: It may also be the case that Mr. Stick Man has walked off the edge of a platform.
    If that happens, y will be set to 4 and Mr. Stick Man will fall downward.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 也有可能是火柴人走出了平台的边缘。如果发生这种情况，y 将被设置为 4，火柴人将向下掉落。
- en: Phew, that was a long function!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 呼，那个函数真长！
- en: Testing Our Stick Figure Sprite
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试我们的火柴人精灵
- en: 'Having created the StickFigureSprite class, let’s try it out by adding the
    following two lines just before the call to the mainloop function:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了 StickFigureSprite 类之后，让我们通过在调用 mainloop 函数之前添加以下两行来进行测试：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We create a StickFigureSprite object and label it with the sf variable. As we
    did with the platforms, we add this new variable to the list of sprites stored
    in the game object.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个 StickFigureSprite 对象，并用 sf 变量标记它。像对待平台一样，我们将这个新变量添加到存储在游戏对象中的精灵列表中。
- en: Now run the program. You should find that Mr. Stick Man can run, jump from platform
    to platform, and fall!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行程序。你应该发现火柴人能够跑动、从平台跳到平台并掉落！
- en: The Exit!
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 退出！
- en: The only thing missing from our game is the exit. We’ll finish up by creating
    a sprite for the door, adding code to detect the door, and giving our program
    a door object.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们游戏中唯一缺少的就是出口。我们将通过创建一个门的精灵、添加检测门的代码以及给程序添加门对象来完成这个部分。
- en: Creating the DoorSprite Class
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 DoorSprite 类
- en: 'We need to create one more class: DoorSprite. The start of the code is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个新类：DoorSprite。代码的开头如下所示：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The __init__ function of the DoorSprite class has parameters for self, a game
    object, a photo_image object, the x and y coordinates, and the width and height
    of the image. We call Sprite.__init__ as with our other sprite classes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: DoorSprite 类的 __init__ 函数有自我、游戏对象、photo_image 对象、x 和 y 坐标以及图像的宽度和高度等参数。我们像其他精灵类一样调用
    Sprite.__init__。
- en: '![Image](Images/f0258-01.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0258-01.jpg)'
- en: We then save the parameter photo_image using an object variable with the same
    name, as we did with PlatformSprite. We create a display image using the canvas
    create_image function and save the identifying number returned by that function
    using the object variable image.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们像处理PlatformSprite一样，使用相同名称的对象变量保存参数photo_image。我们使用画布的create_image函数创建显示图像，并使用该函数返回的标识号将其保存到对象变量image中。
- en: Next, we set the coordinates of DoorSprite to the x and y parameters (which
    become the *x1* and *y1* positions of the door), and then calculate the *x2* and
    *y2* positions. We calculate the *x2* position by adding half of the width (the
    width variable divided by 2) to the x parameter. For example, if x is 10 (the
    x1 coordinate is also 10) and the width is 40, the x2 coordinate would be 30 (10
    plus half of 40).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将门精灵的坐标设置为x和y参数（它们变成门的*x1*和*y1*位置），然后计算*x2*和*y2*位置。我们通过将宽度的一半（宽度变量除以2）加到x参数来计算*x2*位置。例如，如果x是10（x1坐标也是10），而宽度是40，那么x2坐标就是30（10加上40的一半）。
- en: Why use this confusing little calculation? Because, unlike with the platforms,
    where we want Mr. Stick Man to stop running as soon as he collides with the side
    of the platform, we want him to stop in front of the door. You’ll see this in
    action when you play the game and make it to the door.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用这个让人困惑的小计算呢？因为与平台不同，在平台上我们希望小人碰到平台的边缘时立刻停止，但我们希望他停在门前。你会在玩游戏并到达门时看到这一点。
- en: Unlike the *x1* position, the *y1* position is simple to calculate. We just
    add the value of the height variable to the y parameter, and that’s it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与*x1*位置不同，*y1*位置的计算非常简单。我们只需将高度变量的值加到y参数上，其他的就没什么了。
- en: Finally, we set the endgame object variable to True. This says that when the
    stick figure reaches the door, the game ends.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将endgame对象变量设置为True。这表示当小人到达门时，游戏结束。
- en: Detecting the Door
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测门
- en: 'Now we need to change the code in the StickFigureSprite class of the move function
    that determines when the stick figure has collided with a sprite on the left or
    the right. Here’s the first change:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要修改StickFigureSprite类中move函数的代码，该函数决定小人何时与左侧或右侧的精灵发生碰撞。以下是第一次修改：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We check to see if the stick figure has collided with a sprite that has an endgame
    variable set to True. If it does, we set the running variable to False, and everything
    stops—we’ve reached the end of the game.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查小人是否与一个设置了endgame变量为True的精灵发生了碰撞。如果发生了碰撞，我们将running变量设置为False，一切停止——游戏结束。
- en: 'We’ll add these same lines to the code that checks for a collision on the right.
    Here’s the code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些相同的代码行添加到检查右侧碰撞的代码中。以下是代码：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Adding the Door Object
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加门对象
- en: 'Our final addition to the game code is an object for the door. We’ll add this
    before the main loop. Just before creating the stick figure object, we’ll create
    a door object and then add it to the list of sprites. Here’s the code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对游戏代码的最终补充是为门创建一个对象。我们将在主循环之前添加这个对象。在创建小人对象之前，我们将创建一个门对象，然后将其添加到精灵列表中。以下是代码：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We create a door object using the variable for our game object, g, followed
    by a PhotoImage (the door image we created in [Chapter 13](ch13.xhtml#ch13)).
    We set the x and y parameters to 45 and 30 to put the door on a platform near
    the top of the screen, and set the width and height to 40 and 35\. We add the
    door object to the list of sprites, as with all the other sprites in the game.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用游戏对象的变量g创建一个门对象，后面跟一个PhotoImage（我们在[第13章](ch13.xhtml#ch13)中创建的门图像）。我们将x和y参数设置为45和30，将门放在屏幕顶部附近的一个平台上，并设置宽度和高度为40和35。我们像处理游戏中其他精灵一样将门对象添加到精灵列表中。
- en: You can see the result when Mr. Stick Man reaches the door. He stops running
    in front of the door, rather than next to it, as shown in [Figure 16-2](ch16.xhtml#ch16fig02).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到当小人到达门时的效果。他停在门前，而不是门旁边，正如[图16-2](ch16.xhtml#ch16fig02)所示。
- en: '![Image](Images/16fig02.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/16fig02.jpg)'
- en: '*Figure 16-2: Reaching the door*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*图16-2：到达门*'
- en: The Final Game
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最终游戏
- en: 'The full listing of our game is now a bit more than 200 lines of code. The
    following is the complete code for the game. If you have trouble getting your
    game to work, compare each function (and each class) to this listing:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏完整代码现在已经有200多行了。以下是游戏的完整代码。如果你在运行游戏时遇到问题，可以将每个函数（以及每个类）与这段代码进行对比：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What You Learned
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你学到了什么
- en: In this chapter, we completed our game, *Mr. Stick Man Races for the Exit*.
    We created a class for our animated stick figure and wrote functions to move him
    around the screen and animate him as he moves (changing from one image to the
    next to give the illusion of running). We’ve used basic collision detection to
    tell when he has hit the left or right sides of the canvas, and when he has hit
    another sprite, such as a platform or a door. We’ve also added collision code
    to tell when he hits the top of the screen or the bottom, and to make sure that
    when he runs off the edge of a platform, he tumbles down accordingly. We added
    code to tell when Mr. Stick Man has reached the door, so the game comes to an
    end.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们完成了我们的游戏，*小棍人跑向出口*。我们为动画小棍人创建了一个类，并编写了函数来移动他在屏幕上的位置，并在他移动时进行动画处理（通过图像切换来营造奔跑的错觉）。我们使用了基本的碰撞检测来判断他是否撞到画布的左右边缘，或者是否撞到其他精灵，如平台或门。我们还添加了碰撞代码，以判断他是否撞到屏幕的顶部或底部，并确保当他跑出平台的边缘时，会相应地跌落下来。我们添加了代码来判断小棍人是否到达门口，这样游戏就结束了。
- en: '![Image](Images/f0267-01.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0267-01.jpg)'
- en: Programming Puzzles
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程难题
- en: There’s a lot more we can do to improve the game. We can add code to make it
    more professional looking and more interesting to play. Try adding the following
    features and then compare your code with the solutions at *[http://python-for-kids.com](http://python-for-kids.com)*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多事情可以做，以改善游戏。我们可以添加代码，使其看起来更专业，也更有趣。尝试添加以下功能，然后将你的代码与* [http://python-for-kids.com](http://python-for-kids.com)*上的解决方案进行比较。
- en: '#1: “You Win!”'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '#1：“你赢了！”'
- en: Like the “Game Over” text in the *Bounce!* game we completed in [Chapter 12](ch12.xhtml#ch12),
    add “You Win!” text when the stick figure reaches the door.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们在[第12章](ch12.xhtml#ch12)中完成的*Bounce!*游戏中的“游戏结束”文字，当小棍人到达门口时，添加“你赢了！”的文字。
- en: '#2: Animating the Door'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '#2：动画门的实现'
- en: 'In [Chapter 13](ch13.xhtml#ch13), we created two images for the door: one open
    and one closed. When Mr. Stick Man reaches the door, the door image should change
    to the open door, Mr. Stick Man should vanish, and the door image should revert
    to the closed door. This will give the illusion that Mr. Stick Man is exiting
    and closing the door as he leaves. You can do this by changing the DoorSprite
    class and the StickFigureSprite class.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](ch13.xhtml#ch13)中，我们为门创建了两个图像：一个是开着的，另一个是关着的。当小棍人到达门时，门的图像应该切换为开门状态，小棍人应该消失，而门的图像应该恢复为关门状态。这将产生小棍人退出并关闭门的错觉。你可以通过修改DoorSprite类和StickFigureSprite类来实现这一点。
- en: '![Image](Images/f0268-01.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0268-01.jpg)'
- en: '#3: Moving Platforms'
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '#3：移动平台'
- en: Try adding a new class called MovingPlatformSprite. This platform should move
    from side to side, making it more difficult for Mr. Stick Man to reach the door
    at the top. You can pick some platforms to be moving, and leave some platforms
    to be static, depending on how hard you want your game to be.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试添加一个新的类，名为MovingPlatformSprite。这个平台应该左右移动，使得小棍人更难到达顶部的门。你可以选择一些平台设置为移动的，其他平台保持静态，具体取决于你希望游戏的难度有多大。
- en: '#4: Lamp as a Sprite'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '#4：台灯作为精灵'
- en: Instead of the bookshelf and lamp we added as background images in [Chapter
    14](ch14.xhtml#ch14)’s third programming puzzle, try adding a lamp that the stick
    man has to jump over. Rather than being a part of the game’s background, it will
    be a sprite similar to the platforms or the door.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 不再使用我们在[第14章](ch14.xhtml#ch14)的第三个编程难题中添加的书架和台灯作为背景图片，而是尝试添加一个小棍人需要跳过的台灯。它将不再是游戏背景的一部分，而是一个与平台或门类似的精灵。
- en: '![Image](Images/f0269-01.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0269-01.jpg)'
