- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Databases
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: A *database* is an organized collection of data that can be easily accessed,
    managed, and updated. Even if there isn’t a database in the initial architecture
    of your project, data that flows through your application will likely touch one
    or more databases at some point.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing the previous chapter’s discussion on importing data into your Python
    applications, this chapter covers working with database data. The examples here
    will show you how to access and manipulate data stored in databases of different
    types, including those that position SQL as the primary tool to work with data
    and those that don’t. You’ll explore how to use Python to interface with a variety
    of popular databases, including MySQL, Regis, and MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Databases offer many advantages. For one, with the help of a database, you can
    persist data between invocations of a script and efficiently share data between
    different applications. Moreover, database languages can help you systematically
    organize and answer questions about your data. Additionally, many database systems
    allow you to implement programming code within the database itself, which can
    improve the performance, modularity, and reusability of an application. For example,
    you might store a *trigger* in a database; this is a piece of code that’s invoked
    automatically each time a certain event happens, such as every time you insert
    a new row into a particular table.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two categories of databases: relational databases and nonrelational
    (NoSQL) databases. Relational databases have a rigid structure implemented in
    the form of a schema for the data being stored. This approach helps ensure the
    integrity, consistency, and overall accuracy of the data. However, the major drawback
    of relational databases is that they don’t scale well as data volumes increase.
    In contrast, NoSQL databases don’t impose restrictions on the structure of the
    data being stored, thus allowing for more flexibility, adaptability, and scalability.
    This chapter will cover storing and retrieving data in both relational and nonrelational
    databases.'
  prefs: []
  type: TYPE_NORMAL
- en: Relational Databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Relational databases*, also known as *row-and-column databases*, are the most
    common type of database in use today. They provide a structured way of storing
    data. Just like a list of books on Amazon has a set structure for storing information,
    with fields for book titles, authors, descriptions, ratings, and so on, the data
    stored in a relational database must fit a predefined formal schema. Working with
    a relational database starts with designing that formal schema: you define a collection
    of tables, each made up of a set of fields or columns, and you specify what type
    of data each field will store. You also establish the relationships between the
    tables. Then you can store data to the database, retrieve data from the database,
    or update the data as needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases are designed to allow the efficient insertion, updating,
    and/or deleting of small to vast amounts of structured data. There are plenty
    of applications where this type of database can be put to great use. In particular,
    relational databases are well suited for *online transaction processing (OLTP)*
    applications, which process a high volume of transactions for a large number of
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Some common relational database systems are MySQL, MariaDB, and PostgreSQL.
    This section will focus on MySQL, arguably the world’s most popular open source
    database, to illustrate how to interact with a database. You’ll learn how to set
    up MySQL, create a new database, define its structure, and write Python scripts
    to store and retrieve data to and from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SQL Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*SQL*, or *Structured Query Language*, is the primary tool for interacting
    with a relational database. Although our focus here is on interfacing with databases
    using Python, the Python code must itself contain SQL statements to do this. A
    comprehensive look at SQL is beyond the scope of this book, but a brief introduction
    to this query language is nonetheless in order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL statements are text commands recognized and executed by a database engine
    like MySQL. For example, this SQL statement asks a database to retrieve all the
    rows from a table called `orders` whose `status` field is set to `Shipped`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'SQL statements typically have three major components: an *operation* to be
    performed, a *target* for that operation, and a *condition* that narrows the scope
    of the operation. In the preceding example, `SELECT` is the SQL operation, meaning
    we’re accessing rows from the database. The `orders` table is the target for the
    operation, as defined by the `FROM` clause, and the condition is specified in
    the `WHERE` clause of the statement. All SQL statements must have an operation
    and a target, but the condition is optional. This statement, for instance, lacks
    a condition, so it retrieves all the rows from the `orders` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also refine SQL statements to only affect certain columns of a table.
    Here’s how to retrieve only the `pono` and `date` columns of all the rows in the
    `orders` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: By convention, language-reserved words in SQL, such as `SELECT` and `FROM`,
    are written in all caps. However, SQL is a case-insensitive language, so this
    capitalization isn’t strictly necessary. Each SQL statement should end with a
    semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT` operations like those just shown are examples of *Data Manipulation
    Language (DML)* *statements*, a category of SQL statements that you use to access
    and manipulate database data. Other DML operations include `INSERT`, `UPDATE`,
    and `DELETE`, which add, change, and remove records from a database, respectively.
    *Data Definition Language (DDL)* *statements* are another common category of SQL
    statements. You use these to actually define the database structure. Typical DDL
    operations include `CREATE` to make, `ALTER` to modify, and `DROP` to delete data
    containers, whether that be columns, tables, or whole databases.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started with MySQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MySQL is available on a majority of modern operating systems, including Linux,
    Unix, Windows, and macOS. Both free and commercial editions are available. For
    the purposes of this chapter, you can use MySQL Community Edition ([https://www.mysql.com/products/community](https://www.mysql.com/products/community)),
    the freely downloadable version of MySQL, which is available under the GPL license.
    For detailed MySQL installation instructions for your operating system, refer
    to the reference manual for the latest version of MySQL, available at [https://dev.mysql.com/doc](https://dev.mysql.com/doc).
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the MySQL server after installation, you need to use the command that
    the installation guide specifies for your operating system. Then you can connect
    to the MySQL server from a system terminal using the *mysql* client program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll be asked to enter your password, which you set during the MySQL server
    installation process. After that, you’ll see the MySQL prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you like, you can choose a new password for the root user with the following
    SQL command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can create the database that you’ll need for your application. Enter
    this command at the `mysql>` prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a database called `sampledb`. Next, you must choose that database
    for use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now any subsequent commands will apply to your `sampledb` database.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Database Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A relational database gets its structure from the makeup of its constituent
    tables and from the connections between those tables. The fields that link different
    tables are called *keys*. There are two types: *primary keys* and *foreign keys*.
    A primary key uniquely identifies a record in a table. A foreign key is a field
    in another table that corresponds to the primary key in the first table. Typically,
    the primary key and its corresponding foreign key share the same name in both
    tables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve created your `sampledb` database, you’re ready to create some
    tables and define their structure. For demonstration purposes, the tables will
    have the same structure as some of the pandas DataFrames you worked with in Chapter
    3. Here are three tabular data structures to be implemented in your database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To review what relations can be established between these structures, refer
    back to Figures 3-4 and 3-6 from Chapter 3. As can be seen in Figure 3-4, the
    rows in the `emps` and `salary` tables are related with a one-to-one relationship.
    The relation is established via the `empno` field. The `emps` and `orders` tables
    are also related via the `empno` field. This is a one-to-many relationship, as
    depicted in Figure 3-6.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add these data structures to your relational database using SQL commands
    at the `mysql>` prompt. Start by creating the `emps` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You create the table with the `CREATE TABLE` command, specifying each column
    along with the type and, optionally, the size of data you can store in it. For
    example, the `empno` column is for integers (type `INT`), and the `NOT NULL` constraint
    applied to it guarantees that you won’t be able to insert a row with an empty
    `empno` field. Meanwhile, the `empname` column can hold strings (type `VARCHAR`)
    up to 50 characters long, while `job` can hold strings up to 30 characters long.
    You also specify that `empno` is the primary key column in the table, meaning
    it’s not supposed to have duplicates across the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'On successful execution of this command, you’ll see the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, here’s how to create the `salary` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you’ll add a foreign key constraint to the `empno` column of the `salary`
    table, referencing the `empno` column of the `emps` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This command creates the relationship between the `salary` and `empno` tables.
    It establishes that an employee number in the `salary` table must match an employee
    number in the `emps` table. This constraint guarantees that you won’t be able
    to insert a row into the `salary` table if the table doesn’t have a corresponding
    row in the `emps` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `salary` table has no rows so far, the `ALTER TABLE` operation affects
    no rows, as can be seen from the resulting message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create the `orders` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This time you add a foreign key constraint within the `CREATE TABLE` command,
    thus defining the foreign key immediately upon the creation of the table.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting Data into the Database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you’re ready to insert rows into your newly created tables. While you could
    do this using the `mysql>` prompt, this type of operation is usually performed
    from an application. You’ll interact with the database from your Python code through
    the MySQL Connector/Python driver. You can install it via `pip`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following script to populate your database tables with data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this script, you import the MySQL Connector/Python driver as `mysql.connector`.
    Then you open a `try/except` block, which provides a template for any database-related
    operations you need to perform within your script. You write the code for the
    operation in the `try` block, and if an error occurs when the operation is carried
    out, the execution is transferred to the `except` block.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `try` block, you start by establishing a connection to the database,
    specifying your username and password, the host IP address (in this case, your
    local host), and the database name ❶. Then you obtain a `cursor` object related
    to this connection ❷. The `cursor` object provides the means for statement execution
    as well as the interface for fetching the results.
  prefs: []
  type: TYPE_NORMAL
- en: You define rows for the `emps` table as a list of tuples ❸. Then, you define
    the SQL statement to be executed to insert these rows into the table ❹. In this
    `INSERT` statement, you specify the fields to be filled with data, along with
    `%s` placeholders that map these fields to the members of each tuple. In a loop,
    you execute the statement, inserting the rows one at a time with the `cursor.execute()`
    method ❺. Similarly, you then insert rows into the `salary` and `orders` tables.
    At the end of the `try` block, you make all the insertions into the database permanent
    with the connection’s `commit()` method ❻.
  prefs: []
  type: TYPE_NORMAL
- en: If any database-related operation fails, the rest of the `try` clause is skipped
    and the `except` clause executes ❼, printing out an error code generated by the
    MySQL server along with the corresponding error message.
  prefs: []
  type: TYPE_NORMAL
- en: The `finally` clause is executed in any case ❽. In this clause, you explicitly
    close the `cursor` and then close the connection.
  prefs: []
  type: TYPE_NORMAL
- en: Querying Database Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you’ve populated the tables with data, you can query that data for
    use in your Python code. Say you want to retrieve all the rows in the `emps` table
    where `empno` is greater than `9001`. To achieve this, use the script from the
    previous section as a model, changing only the `try` block as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the insertion operation, selecting rows doesn’t require you to perform
    multiple `cursor.execute()` operations in a loop, one for each row. Instead, you
    write a query specifying criteria for the rows you want to select, then get them
    all at once with a single `cursor.execute()` operation.
  prefs: []
  type: TYPE_NORMAL
- en: In the `SELECT` statement that forms your query, you specify the asterisk symbol
    (`*`), which means you want to see all the fields in the retrieved rows ❶. In
    the `WHERE` clause, you specify the condition that a row must meet in order to
    be selected. Here, you indicate that rows must have an `empno` greater than the
    value of the variable bound to the `%s` placeholder ❷. The variable `empno` is
    bound to the placeholder during execution ❸. When you execute the query with `cursor.execute()`,
    you pass in the binding variable within a tuple as the second parameter ❹. The
    `execute()` method requires that binding variables be passed within a tuple or
    a dictionary even if you only need to pass in a single variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You access the retrieved rows via the `cursor` object, iterating over it in
    a loop. Each row is accessible as a tuple whose items represent the values of
    the row’s fields ❺. Here, you simply print the fields’ values, outputting the
    results row by row, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can also write `SELECT` statements that join rows from different tables
    together. Joining relational database tables mirrors the process of joining pandas
    DataFrames, as discussed in Chapter 3. You typically join tables through the foreign
    key relationship you define when you set up the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you want to join the `emps` and `salary` tables while
    keeping the condition that `empno` be greater than `9001`. You do this through
    their shared `empno` columns, since you defined `empno` in the `salary` table
    as a foreign key referencing `empno` in the `emps` table. You can implement this
    join with another modification to the `try` block of your script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This time, `query` contains a `SELECT` statement joining the `emps` and `salary`
    tables. In the `SELECT` list, you specify the columns from both tables that you
    want to include in the join ❶. In the `FROM` clause, you specify the two tables,
    connecting them with the `JOIN` keyword, along with the aliases `e` and `s`, which
    are needed to differentiate columns with the same name in both tables ❷. In the
    `ON` clause, you define the join condition, stating that the values in both tables’
    `empno` columns should match ❸. In the `WHERE` clause, as in the previous example,
    you use the `%s` placeholder to set the minimum `empno` value ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script outputs the following rows, with each employee’s salary joined to
    their record from the `emps` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Using Database Analytics Tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When persisting data in MySQL, you can take advantage of the database’s built-in
    analytics tools, such as analytical SQL, to significantly reduce the volume of
    data sent between your application and the database. *Analytical SQL* is an extra
    set of SQL commands designed for actually analyzing data stored in a database
    rather than simply storing, retrieving, and updating data. As an example, say
    you only want to import stock market data related to those companies whose prices
    didn’t drop more than 1 percent below the previous day’s price over a certain
    period. You can perform this preliminary analysis with analytical SQL, saving
    you from having to load an entire dataset of stock prices from the database into
    your Python script.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, you’ll obtain stock data via the yfinance library introduced
    in Chapter 3 and store it to a database table. You’ll then query the table from
    a Python script, loading only the portion of the stock data that satisfies the
    specified condition. To start, you need to create a table in your `sampledb` database
    to store the stock data. The table should have three columns: `ticker`, `date`,
    and `price`. Enter the following command at the `mysql>` prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now use this script to obtain some stock data with yfinance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: First, you define an empty list called `data` that will be populated with stock
    data ❶. As you saw earlier in the chapter, the `cursor.execute()` method expects
    data in the form of a list object when it executes an `INSERT` statement. Next,
    you define a list of tickers for which you want to obtain data ❷. Then, in a loop,
    you pass in each ticker from the `tickers` list to yfinance’s `Ticker()` function
    ❸. The function returns a `Ticker` object, whose `history()` method provides you
    with data related to the corresponding ticker. In this example you obtain stock
    data for each ticker for the last five business days (`period='5d'`).
  prefs: []
  type: TYPE_NORMAL
- en: The `history()` method returns stock data as a pandas DataFrame with the `Date`
    column as the index. Ultimately, you want to convert that DataFrame into a list
    of tuples for insertion into the database. Since you need to include the `Date`
    column in your dataset, you remove it from the index with the DataFrame’s `reset_index()`
    method, thus turning `Date` into a regular column ❹. You then take only the `Date`
    and `Close` columns from the retrieved DataFrame, where `Close` contains stock
    prices at the end of the day, and convert them to a NumPy record array, an intermediate
    step in the process of converting the input data ❺. Next, you convert the data
    to a list of tuples ❻. After that, you still need to reformat each tuple so that
    it can be inserted into the `stocks` database table as a row. In particular, each
    `Date` field contains a lot of extraneous information (hours, minutes, seconds,
    and so on). By taking only the first 10 characters of field 0 in each tuple, you
    extract just the year, month, and day, which is all that you need for your analysis
    ❼. For example, `2022-01-06T00:00:00.000000000` would become simply `2022-01-06`.
    Finally, still within the loop, you append the tuples related to the ticker to
    the `data` list ❽.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, the content of the `data` list of tuples might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To insert this dataset into the `stocks` table as a set of rows, append the
    following code to the previous script and re-execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The code follows the same model you used earlier to insert data into the database.
    This time, however, you use the `cursor.executemany()` method, which allows you
    to efficiently execute the `INSERT` statement multiple times, for each tuple in
    the `data` list of tuples ❶.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have the data in the database, you can play with queries against
    it using analytical SQL, trying to answer questions. For example, to filter out
    stocks that have dropped more than 1 percent below the previous day’s price, as
    suggested at the beginning of this section, you’ll need a query that can analyze
    prices for the same ticker across multiple days. As a first step, the following
    query generates a dataset that includes both the current stock price and its price
    for the previous day within the same row. Try it out at the `mysql>` prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LAG()` function in the `SELECT` list is an analytical SQL function. It
    lets you access a previous row’s data from the current row. The `PARTITION BY`
    clause within the `OVER` clause divides the dataset into groups, one for each
    ticker. The `LAG()` function is applied separately within each group, ensuring
    data won’t bleed over from one ticker to the next. The result generated by the
    query will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The query generated a new column, `prev_price`, containing the previous day’s
    stock prices. As you can see, `LAG()` essentially gives you access to two rows’
    worth of data in the same row, meaning you can manipulate data from both rows
    within the same math expression as part of a query. For example, you can divide
    one price by the other to calculate the percent change from day to day. With this
    in mind, here’s a query to address the original requirement, selecting the rows
    of only those tickers whose prices didn’t drop more than 1 percent below the previous
    day’s price over the specified period:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL statement is a join between two different queries issued against the
    same table: `stocks`. The first query of the join retrieves all the rows from
    the `stocks` table ❶, while the second query retrieves only the names of those
    tickers whose prices dropped 1 percent or more below their previous day’s price
    at least once over the period of analysis ❷. This second query of the join has
    a complex structure: it selects data from a subquery rather than from the `stocks`
    table directly. The subquery, which starts at ❸, retrieves those rows from the
    table whose values in the `price` field are at least 1 percent lower than in the
    previous row. You determine this by dividing `price` by `LAG(price)` ❹ and checking
    if the result is less than `0.99` ❺. Then, in the `SELECT` list of the main query,
    you apply the `DISTINCT()` function to the `ticker` field to eliminate duplicate
    ticker names from the result set ❷.'
  prefs: []
  type: TYPE_NORMAL
- en: You join the queries on the `ticker` column ❻. In the `WHERE` clause, you instruct
    the join to retrieve only the rows where no correspondence is found between the
    `a.ticker` field (tickers whose price dropped more than 1 percent) and the `s.ticker`
    field (all the tickers) ❼. Since you have a left join, only the matching rows
    from the first query are retrieved. As a result, the join returns all the rows
    of the `stocks` table with a ticker not found among the tickers retrieved by the
    second query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the stock data shown previously, the result set generated by the query
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, not all the rows from the `stocks` table have been retrieved.
    In particular, you won’t find the rows related to the FB and TSLA tickers. The
    latter, for example, was excluded due to the following row found in the output
    generated by the previous query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This row shows a 3.54 percent drop, which exceeds the 1 percent threshold.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following script, you issue the same query from within Python code and
    fetch the results into a pandas DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The script looks mostly like the ones shown earlier in the chapter. The key
    difference is that you load the database data directly into a pandas DataFrame.
    For that, you use the pandas `read_sql()` method, which takes a SQL query as a
    string as the first parameter and a database connection object as the second ❶.
    Then, you set the `ticker` and `date` columns as the DataFrame index ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the stock data shown previously, the resulting `df_stocks` DataFrame
    will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have the data in a DataFrame, you can proceed with further analysis
    within Python. For example, you might want to calculate the average price of each
    ticker over a defined period. In the next chapter, you’ll see how you can solve
    such problems, applying an appropriate aggregate function at a group level in
    a DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL Databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*NoSQL databases*, or *nonrelational databases*, don’t require a predetermined
    organizational schema for the data being stored, and they don’t support standard
    relational database operations like joins. Instead, they provide ways to store
    data with more structural flexibility, making it easier to handle massive volumes
    of data. For example, key-value stores, one type of NoSQL database, let you store
    and retrieve data as key-value pairs, such as time-event pairs. Document-oriented
    databases, another type of NoSQL database, are designed to work with flexibly
    structured data containers such as JSON documents. This allows you to store all
    the information related to a given object as a single entry in the database rather
    than splitting information across multiple tables, as is common in relational
    databases.'
  prefs: []
  type: TYPE_NORMAL
- en: Although NoSQL databases haven’t been around as long as their relational counterparts,
    they’ve quickly become popular because they allow developers to store data in
    simple, straightforward formats and don’t require advanced expertise to access
    and manipulate the data. Their flexibility makes them particularly well suited
    to real-time and big data applications such as Google Gmail or LinkedIn.
  prefs: []
  type: TYPE_NORMAL
- en: Key-Value Stores
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *key-value store* is a database that holds key-value pairs, similar to a
    Python dictionary. A good example of a key-value store is Redis, which stands
    for Remote Dictionary Service. Redis supports commands such as `GET`, `SET`, and
    `DEL` to access and manipulate key-value pairs, as illustrated in this simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, you use the `SET` command to create the key `emp1` with the value `Maya
    Silver`, then you use `GET` to retrieve the value via its key.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Redis
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To explore Redis yourself, you’ll need to install it. You can find details
    on the Redis Quick Start page at [https://redis.io/topics/quickstart](https://redis.io/topics/quickstart).
    After installing the Redis server in your system, you’ll also need to install
    redis-py, the Python library that lets you interact with Redis from your Python
    code. You can do this with the `pip` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You then import redis-py into your script with the command `import redis`.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Redis with Python
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following is a simple example of accessing the Redis server from Python
    via the redis-py library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You use the `redis.Redis()` method to set a connection to the Redis server
    ❶. Since the method’s parameters are omitted, the default values will be taken,
    which assume the server is running on your local machine: `host=''localhost''`,
    `port=6379`, and `db=0`.'
  prefs: []
  type: TYPE_NORMAL
- en: After establishing a connection, you use the `mset()` method to set multiple
    key-value pairs ❷ (*m* is short for *multiple*). The server returns `True` when
    data has been stored successfully. You can then get the value of any of your stored
    keys with the `get()` method ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like any other database, Redis allows you to persist the data being inserted,
    so you’ll be able to get a value by its key in another Python session or script.
    Redis also allows you to set an *expire flag* on a key when you set a key-value
    pair, specifying how long it should be retained. This can be especially useful
    in real-time applications where input data becomes irrelevant after a certain
    period of time. For example, if your application was for a taxi service, you might
    want to store data about the availability of each individual cab. Since this data
    would be subject to change often, you’d want it to expire after a short time.
    Here’s how this might work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You use the `setex()` method to set a key-value pair that will be automatically
    removed from the database after a specified period of time. Here, you specify
    the expiration time as a `timedelta` object. Alternatively, you could specify
    it as a number in seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far we’ve only looked at simple key-value pairs, but you can also store
    multiple pieces of information about the same object using Redis, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You start by defining a Python dictionary that can contain an arbitrary number
    of key-value pairs. Then, you send the entire dictionary to the database, storing
    it under the key `cab48` using `hmset()` (*h* is short for *hash*). You then use
    the `hgetall()` function to retrieve all the key-value pairs stored under the
    `cab48` key.
  prefs: []
  type: TYPE_NORMAL
- en: Document-Oriented Databases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *document-oriented database* stores each record as a separate document. Rather
    than having to conform to a predefined schema, like the fields of a relational
    database table, each document in a document-oriented database can have its own
    structure. This flexibility makes document-oriented databases the most popular
    category of NoSQL databases, and among document-oriented databases, MongoDB is
    arguably the leader. MongoDB is designed to manage collections of JSON-like documents.
    We’ll explore how to work with MongoDB in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up MongoDB
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are several ways you can try out MongoDB. One is to install the MongoDB
    database on your system. For details, refer to the MongoDB documentation at [https://docs.mongodb.com/manual/installation](https://docs.mongodb.com/manual/installation).
    Another option that requires no installation overhead is to create a free hosted
    MongoDB database using MongoDB Atlas. You’ll need to register at [https://www.mongodb.com/cloud/atlas/register](https://www.mongodb.com/cloud/atlas/register).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can start interacting with a MongoDB database from Python, you’ll
    need to install PyMongo, the official Python driver for MongoDB. This can be done
    with the `pip` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Accessing MongoDB with Python
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first step to working with MongoDB using Python is to establish a connection
    to the database server via a PyMongo `MongoClient` object, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The connection string can be a MongoDB connection URI, such as *mongodb://localhost:27017*.
    This connection string assumes you have installed MongoDB on your local system.
    If you’re using MongoDB Atlas instead, you’ll need to use a connection string
    provided by Atlas. For further details, refer to the “Connect via Driver” page
    in the Atlas documentation at [https://docs.atlas.mongodb.com/driver-connection](https://docs.atlas.mongodb.com/driver-connection).
    You might also want to check out the “Connection String URI Format” page of the
    MongoDB documentation at [https://docs.mongodb.com/manual/reference/connection-string](https://docs.mongodb.com/manual/reference/connection-string).
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using a connection string, you might specify the host and port as
    separate parameters of the `MongoClient()` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'A single MongoDB instance can support multiple databases, so once a connection
    to the server is established, you need to specify the database you want to work
    with. MongoDB doesn’t provide a separate command to create a database, so you
    use the same syntax for creating a new database and accessing an existing one.
    For example, to create a database named `sampledb` (or access it if it already
    exists), you can use the following dictionary-like syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'or use the attribute-access syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike relational databases, MongoDB doesn’t store data in tables. Instead,
    documents are grouped into *collections*. Creating or accessing a collection is
    similar to creating or accessing a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will create the `emps` collection in the `sampledb` database,
    if it has not already been created. Then, you can use the `insert_one()` method
    to insert a document into the collection. In this example, you insert an `emp`
    document formatted as a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon insertion of the document, an `"_id"` field is automatically added to
    it. The value of this field is generated to be unique across the collection. You
    can access the ID via the `inserted_id` field of the object returned by `insert_one()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have some data in the database, how can you query it? The most
    common type of query can be performed with `find_one()`, which returns a single
    document that matches the search criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `find_one()` doesn’t require you to use the document’s ID, which
    was automatically added on insert. Instead, you can query on specific elements,
    assuming that the resulting document matches them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you saw examples of moving data to and from databases of different
    types, including relational and NoSQL databases. You worked with MySQL, one of
    the most popular relational databases. Then you looked at Redis, a NoSQL solution
    that allows you to efficiently store and retrieve key-value pairs. You also explored
    MongoDB, arguably the most popular NoSQL database today, which allows you to work
    with JSON-like documents in a Python-friendly manner.
  prefs: []
  type: TYPE_NORMAL
