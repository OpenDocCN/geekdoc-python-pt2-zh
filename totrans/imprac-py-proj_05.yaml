- en: '**5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5'
- en: ENCODING ENGLISH CIVIL WAR CIPHERS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**英国内战密码编码**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: In 1587, Mary, Queen of Scots, lost her head due to a scrap of paper. Fifty-five
    years later, Sir John Trevanion, a supporter of another beheaded monarch, Charles
    the First, had his head saved by a scrap of paper. What made the difference? Steganography.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 1587年，苏格兰的玛丽女王因一张纸条丧命。55年后，查理一世的支持者约翰·特雷瓦尼恩爵士因一张纸条保住了性命。是什么造成了这种差异？隐写术。
- en: '*Steganography* is the time-tested practice of concealing messages so well
    that their existence isn’t even suspected. The name is based on the Greek words
    for “covered writing,” and a very literal Grecian example was to take wax-covered
    wooden tablets used for writing, scrape off the wax, write on the wood, and then
    cover the board with a new coating of smooth wax. A modern-day example is to embed
    a message in an image by subtly altering its color components. Even a simple 8-bit
    JPEG image contains more colors than the human eye can detect, so without digital
    processing or filtering, the message is essentially invisible.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*隐写术*是一种经得起时间考验的做法，用来将信息隐藏得如此精妙，以至于其存在根本不会被怀疑。这个名字源自希腊语，意为“隐藏的文字”，而一个非常字面意义上的希腊示例是用带有蜡层的木板写字，然后刮掉蜡层，在木板上写字，再覆盖一层新的光滑蜡膜。一个现代的例子是通过微妙地改变图像的颜色成分将信息嵌入图像中。即便是一张简单的8位JPEG图像，也包含了人眼无法察觉的更多颜色，因此在没有数字处理或过滤的情况下，信息几乎是不可见的。'
- en: 'In this chapter, you’ll work with the *null cipher*, which isn’t a cipher at
    all but a steganographic technique for concealing plaintext within other strings
    of noncipher material. *Null* means “none,” so with a null cipher, you have chosen
    not to encrypt the message. The following is an example of a null cipher using
    the first letter in every word:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用*无效密码*，这其实根本不是一种密码，而是一种将明文隐藏在其他非密码材料中的隐写技术。*Null*意味着“没有”，所以在无效密码中，你选择不加密信息。以下是使用每个单词的第一个字母的无效密码示例：
- en: '**N**ice **u**ncles **l**ive **l**onger. **C**ruel, **i**nsensitive **p**eople
    **h**ave **e**ternal **r**egrets.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**N**ice **u**ncles **l**ive **l**onger. **C**ruel, **i**nsensitive **p**eople
    **h**ave **e**ternal **r**egrets.'
- en: First, you’ll write code that finds the hidden message that saved Sir John,
    and then you’ll accomplish the much more difficult task of writing a null cipher.
    Finally, you’ll get the opportunity to write a program that might have saved Mary’s
    head, had she used the output.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将编写代码来找到救了约翰爵士的隐蔽讯息，然后你将完成一个更为困难的任务——编写一个无效密码。最后，你将有机会编写一个程序，如果玛丽使用了该程序的输出，可能会保住她的头颅。
- en: '**Project #10: The Trevanion Cipher**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #10：特雷瓦尼恩密码**'
- en: Queen Mary relied on both steganography and encryption to protect her messages.
    The strategy was sound, but her application was flawed. Unknowingly, she relied
    on a double agent named Gilbert Gifford to smuggle her messages. Gifford first
    delivered them to Queen Elizabeth’s spymaster, who cracked the cipher and replaced
    it with a forged message that enticed Mary to incriminate herself. The rest, as
    they say, is history.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 玛丽女王依靠隐写术和加密技术来保护她的讯息。这个策略是有效的，但她的应用存在缺陷。她在不知情的情况下依赖一个名叫吉尔伯特·吉福德的双重间谍来走私她的讯息。吉福德首先将讯息交给伊丽莎白女王的间谍头目，后者破解了密码，并用伪造的讯息替换，诱使玛丽自陷囹圄。接下来，正如他们所说的，这就是历史。
- en: For John Trevanion, the outcome was rosier. Sir John, a distinguished cavalier
    who aided Charles I against Oliver Cromwell in the English Civil War, was captured
    and imprisoned in Colchester Castle. The day before his execution, he received
    a letter from one of his friends. The letter was not smuggled in but delivered
    straight into the hands of his jailors, who examined it but didn’t notice any
    deception. After reading it, Sir John asked for some time alone to pray in the
    chapel. When his jailors came back to fetch him, he had vanished.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于约翰·特雷瓦尼恩来说，结局更加美好。约翰爵士是一位杰出的骑士，他在英国内战中帮助查理一世抵抗奥利弗·克伦威尔，后来被捕并关押在科尔切斯特城堡。就在他被处决前一天，他收到了来自一位朋友的信。信件并非走私，而是直接交到看守手中，尽管他们检查过信件，但并没有发现任何欺骗。读完信后，约翰爵士请求独自到教堂祈祷。当他的看守回来找他时，他已经消失了。
- en: 'Here is the message Sir John received:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是约翰爵士收到的讯息：
- en: 'Worthie Sir John: Hope, that is the beste comfort of the afflicted, cannot
    much, I fear me, help you now. That I would saye to you, is this only: if ever
    I may be able to requite that I do owe you, stand not upon asking me. ''Tis not
    much I can do: but what I can do, bee you verie sure I wille. I knowe that, if
    deathe comes, if ordinary men fear it, it frights not you, accounting for it for
    a high honour, to have such a rewarde of your loyalty. Pray yet that you may be
    spared this soe bitter, cup. I fear not that you will grudge any sufferings; onlie
    if bie submission you can turn them away, ''tis the part of a wise man. Tell me,
    an if you can, to do for you anythinge that you wolde have done. The general goes
    back on Wednesday. Restinge your servant to command. R.T.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尊敬的约翰爵士：希望，这是受苦者最好的安慰，我恐怕现在无法为您提供太多帮助。我想对您说的仅有这一点：如果我能偿还我欠您的，我会毫不犹豫地为您效劳。虽然我能做的不多，但我能做的，您可以非常确信我一定会做。我知道，如果死亡来临，普通人会害怕，但它不会让您害怕，您把它视为对忠诚的至高荣誉的奖赏。祈祷您能避免这杯苦酒。我不担心您会抱怨任何苦难；只有在通过顺从您能避免它们时，那才是智者的行为。告诉我，如果您能的话，我可以为您做任何您希望我做的事情。将军将在星期三回去。恭敬的，您的仆人，R.T.
- en: 'As you have probably guessed, this seemingly innocent letter contains a hidden
    message, revealed below in bold:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能猜到的，这封看似无害的信中包含了一个隐藏的信息，以下是用粗体显示的部分：
- en: 'Worthie Sir John: Ho**p**e, th**a**t is the beste comfort of the afflicted,
    ca**n**not much, I f**e**ar me, he**l**p you now. Th**a**t I would saye to you,
    is **t**his only: if **e**ver I may be able to requite that I do owe you, st**a**nd
    not upon asking me. ''Ti**s** not much I can do: bu**t** what I can do, be**e**
    you verie sure I wille. I k**n**owe that, if **d**eathe comes, if **o**rdinary
    men fear it, it **f**rights not you, ac**c**ounting for it for a high honour,
    to **h**ave such a rewarde of your loyalty. Pr**a**y yet that you may be spared
    this soe bitter, cu**p**. I f**e**ar not that you will grudge any sufferings;
    on**l**ie if bie submission you can turn them away, ''ti**s** the part of a wise
    man. Te**l**l me, an **i**f you can, to **d**o for you anythinge that you wolde
    have done. Th**e** general goes back on Wednesday. Re**s**tinge your servant to
    command. R.T.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尊敬的约翰爵士：希望，这是受苦者最好的安慰，我恐怕现在无法为您提供太多帮助。我想对您说的仅有这一点：如果我能偿还我欠您的，我会毫不犹豫地为您效劳。虽然我能做的不多，但我能做的，您可以非常确信我一定会做。我知道，如果死亡来临，普通人会害怕，但它不会让您害怕，您把它视为对忠诚的至高荣誉的奖赏。祈祷您能避免这杯苦酒。我不担心您会抱怨任何苦难；只有在通过顺从您能避免它们时，那才是智者的行为。告诉我，如果您能的话，我可以为您做任何您希望我做的事情。将军将在星期三回去。恭敬的，您的仆人，R.T.
- en: This null cipher uses every third letter after a punctuation mark to let Sir
    John know that a “panel at east end of chapel slides.” It’s rumored that the remains
    of a narrow stairway were later discovered in a recess in a wall in the castle.
    The passage was blocked at the time of discovery, but it may have been Sir John’s
    escape route around 1642.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个空白密码利用标点符号后的每三个字母来让约翰爵士知道“教堂东端的面板滑动”。有传闻说，后来在城堡的一堵墙的壁龛中发现了一个狭窄楼梯的遗迹。这个通道在发现时被封锁，但它可能是约翰爵士在1642年左右的逃生通道。
- en: This last-minute escape would not have been possible with a traditional cipher.
    Only by expertly concealing the message with steganography was its author able
    to get it so quickly into Sir John’s hands. And the beauty of a null cipher is
    that, even if Sir John didn’t know the pattern but suspected a message was present,
    he could have found it fairly quickly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种临时逃生如果使用传统的密码是无法实现的。只有通过巧妙地隐藏消息，使用隐写术，作者才能如此迅速地将其交到约翰爵士手中。而空白密码的美妙之处在于，即使约翰爵士不知道模式，但怀疑消息存在，他也能相当迅速地找到它。
- en: If Sir John’s friend had been more careful, concealing encrypted ciphertext
    instead of plaintext, Sir John probably wouldn’t have deciphered the message in
    the short time he had remaining—unless he’d been informed beforehand of the cipher
    type and key.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果约翰爵士的朋友更小心一点，隐藏的是加密的密文而非明文，约翰爵士可能就无法在剩余的短时间内解密出消息——除非他事先得知了密码的类型和密钥。
- en: '**THE OBJECTIVE**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Write code that finds the letters hidden after punctuation marks in a null cipher
    and lets the user choose the number of letters after a punctuation mark to search
    for a solution.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码，找出空白密码中标点符号后隐藏的字母，并让用户选择在标点符号后查找的字母数量，以寻找解决方案。
- en: '***Strategy and Pseudocode***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略与伪代码***'
- en: Null ciphers rely on a repeating pattern known to both the sender and receiver.
    For example, every third word may be part of the real message or, better, the
    last letter of every third word. In the Trevanion cipher, it’s the third letter
    after a punctuation mark.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 空白密码依赖于发送者和接收者都知道的重复模式。例如，每三个单词可能是实际消息的一部分，或者更好的是，每三个单词的最后一个字母。在Trevanion密码中，它是标点符号后的第三个字母。
- en: To find the Trevanion cipher, assume punctuation marks are the signal to begin
    counting, and then write code that locates every *n*th letter after the mark and
    saves those letters to a string or list. Once you’ve worked out how to do this,
    you can easily edit the code to work with any starting point, such as every capitalized
    word, every second letter per word, or the starting letter of every third word.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到Trevanion密码，假设标点符号是开始计数的信号，然后编写代码找到每个标点符号后的*第n*个字母，并将这些字母保存到字符串或列表中。一旦你弄清楚如何做，你就可以轻松编辑代码，以便它适用于任何起始点，例如每个大写字母单词、每个单词的第二个字母，或者每三个单词的起始字母。
- en: The only real point of contention involves punctuation marks. For instance,
    did the null cipher’s writer *want* punctuation marks to be included in the plaintext?
    How do you handle a second punctuation mark within the desired count range? What
    happens if two punctuation marks occur in succession?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的争议点涉及标点符号。例如，空白密码的作者*是否希望*将标点符号包括在明文中？如何处理计数范围内出现的第二个标点符号？如果两个标点符号连续出现会怎样？
- en: If you take a close look at the Trevanion cipher, you should see that there
    are double punctuations caused by the repeated use of the word *’tis*. There is
    also a jumble of punctuation marks at the end of the message, where the writer
    provides his initials. To deal with this, Sir John and his friend may have established
    some rules before Sir John’s incarceration, or Sir John just used trial and error
    to work them out.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仔细观察Trevanion密码，你应该会看到由于重复使用词语*’tis*，导致了双重标点符号。消息结尾处还有一串标点符号，作者在此提供了自己的首字母。为了解决这个问题，约翰爵士和他的朋友可能在约翰爵士入狱之前就已经制定了一些规则，或者约翰爵士通过反复试验得出了这些规则。
- en: Based on the end of the message, punctuation marks aren’t included in the letter
    count. If Sir John’s friend had intended them to be, then the hidden message would
    end with a capital *T*, because the *T* is three *characters* after a punctuation
    mark, and crucially not three *letters* after. This means that, if the reader
    encounters a punctuation mark within the count limit, they have to restart their
    count.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据消息结尾，标点符号不包括在字母计数内。如果约翰爵士的朋友打算将它们包括在内，那么隐藏消息将以大写的*T*结尾，因为*T*在标点符号后面三*个字符*，而关键是这不是三个*字母*。这意味着，如果读者在计数范围内遇到标点符号，他们必须重新开始计数。
- en: 'So these are the rules:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这些是规则：
- en: Initiate a letter count with every punctuation mark.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每遇到一个标点符号，启动字母计数。
- en: Reset the count if a punctuation mark is encountered.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果遇到标点符号，则重置计数。
- en: Punctuation marks cannot be part of the plaintext message.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标点符号不能成为明文消息的一部分。
- en: 'Since you may not know what the letter count should be, write the code so that
    it checks all counts up through a limit the user provides. The pseudocode is fairly
    straightforward:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可能不知道字母计数应该是多少，因此编写代码以检查所有计数，直到用户提供的限制。伪代码相当简单：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the first-found variable ➊ will remain `False` until a punctuation
    mark is encountered, after which it will be set to `True` ➋. This prevents the
    program from counting until the first punctuation mark is found.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，第一次找到的变量➊将保持`False`，直到遇到标点符号为止，此时它将设置为`True` ➋。这防止程序在找到第一个标点符号之前进行计数。
- en: Now you’re ready to write the code!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你准备好编写代码了！
- en: '***The Trevanion Cipher Code***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Trevanion密码代码***'
- en: The code in this section will find a Trevanion-type null cipher encoded with
    a specific number of letters after each punctuation mark. You will also need the
    text file containing the Trevanion cipher. You can download both the script and
    the text file from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    as *null_cipher_finder.py* and *trevanion.txt*, respectively. Keep these files
    in the same folder.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的代码将找到使用特定字母数编码的Trevanion类型空白密码，该字母数位于每个标点符号后。你还需要包含Trevanion密码的文本文件。你可以从*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*下载脚本和文本文件，分别命名为*null_cipher_finder.py*和*trevanion.txt*。请将这些文件保存在同一文件夹中。
- en: '**Loading the Text**'
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**加载文本**'
- en: '[Listing 5-1](ch05.xhtml#ch05list1) imports some useful modules and loads the
    text file containing the null cipher.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 5-1](ch05.xhtml#ch05list1) 导入一些有用的模块并加载包含空密码的文本文件。'
- en: '*null_cipher_finder.py,* part 1'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*null_cipher_finder.py,* 第 1 部分'
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 5-1: Imports modules and loads the null cipher text*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-1: 导入模块并加载空密码文本*'
- en: First, import the now-familiar `sys` module so you can handle exceptions that
    may occur during user input ➊. Also import the `string` module to gain access
    to useful collections of constants, like letters and punctuation marks.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导入现在已经熟悉的 `sys` 模块，以便处理用户输入过程中可能发生的异常 ➊。还需要导入 `string` 模块，以便访问一些有用的常量集合，比如字母和标点符号。
- en: Next, define a function to load the text file containing the null cipher ➋.
    This function is similar to the one you used to load a dictionary file in [Chapter
    2](ch02.xhtml#ch02). It will be called by the `main()`function later to actually
    load the file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个函数来加载包含空密码的文本文件 ➋。这个函数类似于你在 [第 2 章](ch02.xhtml#ch02) 中用来加载字典文件的函数。稍后
    `main()` 函数会调用它来实际加载文件。
- en: Start the `load_text()` function by using `with` to open the file ➌. By using
    `with`, you know the file will be automatically closed after it is loaded. Use
    `read()` to load the contents and `strip()` to remove leading and trailing whitespace.
    Note that you can do this on the same line with the `return` statement ➍.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `with` 打开文件 ➌ 来启动 `load_text()` 函数。通过使用 `with`，你可以确保文件在加载后会自动关闭。使用 `read()`
    加载文件内容，并使用 `strip()` 去除前后的空白字符。注意，你可以在同一行中结合 `return` 语句来完成这一步 ➍。
- en: '**Finding the Hidden Message**'
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**寻找隐藏的信息**'
- en: '[Listing 5-2](ch05.xhtml#ch05list2) defines the function that finds the hidden
    message. It takes two arguments. The first is the message, which is the original
    text file as a string stripped of whitespace, and the second is the number of
    letters to check after a punctuation mark. This check value is obtained from the
    user as part of the `main()` function.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 5-2](ch05.xhtml#ch05list2) 定义了一个查找隐藏信息的函数。它接受两个参数，第一个是消息，即去除空白字符后的原始文本文件，第二个是标点符号后要检查的字母数。这个检查值是从用户那里获得的，作为
    `main()` 函数的一部分。'
- en: '*null_cipher_finder.py,* part 2'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*null_cipher_finder.py,* 第 2 部分'
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 5-2: Searches for hidden letters*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-2: 搜索隐藏的字母*'
- en: Treat the `lookahead` value as the endpoint of a range in a `for` loop so that
    you can check all the intervening letters in the message for the presence of a
    hidden message. Set the range as `(1, lookahead + 1)` ➊; that way, you start with
    the first letter after a punctuation mark and include the user’s choice in the
    evaluation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `lookahead` 值视为 `for` 循环中的范围终点，这样你就可以检查消息中所有介于其间的字母，查找是否存在隐藏的信息。将范围设置为 `(1,
    lookahead + 1)` ➊；这样，你就可以从标点符号后的第一个字母开始，并将用户选择的字母包含在评估中。
- en: Now, assign a few variables ➋. First, initialize an empty string to hold the
    translated plaintext. Then set a counter to `0`. Finally, set a `found_first`
    variable to `False`. Remember that the program uses this variable to defer counting
    until the first punctuation mark is encountered.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，分配几个变量 ➋。首先，初始化一个空字符串用于存储翻译后的明文。然后，将计数器设置为 `0`。最后，将 `found_first` 变量设置为 `False`。记住，程序使用这个变量来推迟计数，直到遇到第一个标点符号。
- en: Next, begin looping through the characters in the message ➌. If you encounter
    a punctuation mark, reset the counter to `0` and set `found_first` to `True` ➍.
    If you’ve found a punctuation mark already and the current character isn’t punctuation,
    advance the counter by 1 ➎. If you’ve found the letter you’re looking for—meaning
    the count has reached the current `lookahead` value (`i`)—add the letter to the
    plaintext string ➏.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，开始遍历消息中的字符 ➌。如果遇到标点符号，重置计数器为 `0`，并将 `found_first` 设置为 `True` ➍。如果已经找到了标点符号，而当前字符不是标点符号，则将计数器加
    1 ➎。如果找到了你要找的字母—即计数器已经达到当前的 `lookahead` 值（`i`）—则将字母添加到明文字符串中 ➏。
- en: When you’ve examined all the characters in the message for the current `lookahead`
    value, display the current key and the translation ➐.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查完消息中所有字符以匹配当前的 `lookahead` 值后，显示当前的密钥和翻译 ➐。
- en: '**Defining the main() Function**'
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义 main() 函数**'
- en: '[Listing 5-3](ch05.xhtml#ch05list3) defines the `main()` function. You may
    remember from [Chapter 3](ch03.xhtml#ch03) that the `main()` function is like
    your program’s project manager: it takes input, keeps track of progress, and tells
    the other functions when to work.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 5-3](ch05.xhtml#ch05list3) 定义了 `main()` 函数。你可能记得在 [第 3 章](ch03.xhtml#ch03)
    中提到过，`main()` 函数就像程序的项目经理：它接收输入，跟踪进度，并告诉其他函数何时工作。'
- en: '*null_cipher_finder.py,* part 3'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*null_cipher_finder.py,* 第 3 部分'
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 5-3: Defines the* main() *function*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-3：定义了* main() *函数*'
- en: Start by asking the user for the name of the file (name + extension) ➊, and
    then use `try` to call the `load_text()` function ➋. If the file can’t be found,
    print the error in red—for those using the IDLE window—and exit the program using
    `sys.exit(1)`, where the `1` indicates termination with an error.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先询问用户文件的名称（名称 + 扩展名） ➊，然后使用 `try` 调用 `load_text()` 函数 ➋。如果找不到文件，打印红色错误信息——对于使用
    IDLE 窗口的用户——并使用 `sys.exit(1)` 退出程序，其中 `1` 表示错误终止。
- en: Print the message followed by the list of punctuation marks in the `string`
    module ➌. Only the characters in this list will be recognized by the program as
    punctuation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 打印消息后，列出 `string` 模块中的标点符号 ➌。程序将只识别这个列表中的字符作为标点符号。
- en: Next, take the loaded message and remove all spaces ➍. You’re going to count
    only letters and punctuation marks, so spaces would just get in the way. Start
    a `while` loop that keeps asking the user for input in the event they enter a
    bad value ➎. Ask the user for the number of letters to check after a punctuation
    mark ➏. This will be treated as a range, starting with 1 and ending with the user’s
    choice plus 1\. If the input value is a digit ➐, turn it into an integer, since
    `input` returns a string. Then, use `break` to exit the loop.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，取出已加载的消息并移除所有空格 ➍。你只会计算字母和标点符号，因此空格会妨碍操作。启动一个 `while` 循环，在用户输入无效值时继续请求输入
    ➎。询问用户要检查标点符号后几个字母 ➏。这将作为一个范围，起始值为 1，结束值为用户选择的数字加 1。如果输入值是数字 ➐，将其转为整数，因为 `input`
    返回的是字符串。然后，使用 `break` 退出循环。
- en: If the user enters an invalid value, like “Bob,” use a `print` statement to
    request a number and, for shell users, make the font red using `sys.stderr` ➑.
    The `while` loop will then repeat the request for input.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入无效值，如“Bob”，则使用 `print` 语句请求一个数字，并且对于 shell 用户，使用 `sys.stderr` 使字体变为红色
    ➑。然后，`while` 循环会重复请求输入。
- en: Pass the `lookahead` variable, along with the `message`, to the `solve_null_cipher`
    function ➒. Now all that’s left is to call the `main()` function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `lookahead` 变量与 `message` 一起传递给 `solve_null_cipher` 函数 ➒。现在只剩下调用 `main()`
    函数。
- en: '**Running the main() Function**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**运行 main() 函数**'
- en: Back in the global space, complete the code by calling `main()`—but only if
    the program is run in stand-alone mode versus being imported into another program
    ([Listing 5-4](ch05.xhtml#ch05list4)).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局空间中，通过调用 `main()` 完成代码——但仅当程序以独立模式运行，而不是被导入到另一个程序中时（[列表 5-4](ch05.xhtml#ch05list4)）。
- en: '*null_cipher_finder.py,* part 4'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*null_cipher_finder.py,* 第 4 部分'
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 5-4: Calls the* main() *function*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-4：调用了* main() *函数*'
- en: 'The following is example output from the completed program, using the Trevanion
    cipher as input:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 Trevanion 密码作为输入的完成程序的示例输出：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this output, the program has checked up to the fourth letter after a punctuation
    mark, but as you can see, it finds the solution using three letters after a punctuation
    mark.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在此输出中，程序已检查到标点符号后的第四个字母，但正如您所看到的，它是使用标点符号后面的三个字母找到解决方案的。
- en: '**Project #11: Writing a Null Cipher**'
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #11：编写空密码**'
- en: 'Here is an unfinished example of a very weak null cipher based on the start
    of each word. Take a minute and try to complete the sentence:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基于每个单词开头的非常弱的空密码的未完成示例。花一点时间尝试完成这个句子：
- en: H__________ e__________ l__________ p__________ m__________ e__________.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: H__________ e__________ l__________ p__________ m__________ e__________.
- en: You probably found it difficult, because whether you use letters or even whole
    words, it takes hard work and time to produce a null cipher that doesn’t read
    awkwardly and arouse suspicion. The heart of the problem is context. If the cipher
    is encapsulated within correspondence, that correspondence has to be coherent
    to avoid suspicion. That means it has to address a relevant topic and stay true
    to that topic for a reasonable number of sentences. As you probably saw, drafting
    even one sentence on any topic is no easy task!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能觉得很困难，因为无论是使用字母还是完整单词，要产生一个不显得生硬且不引起怀疑的空密码都需要艰苦的工作和时间。问题的核心是上下文。如果密码包含在通信中，那么这些通信必须连贯，以避免引起怀疑。这意味着它必须涉及一个相关话题，并且在合理的句子数范围内保持与该话题的一致性。正如你可能看到的，草拟关于任何话题的一个句子都不是一件容易的事！
- en: The key is to credibly avoid context, and a good way to do this is with a list.
    No one expects a shopping list to be rigidly organized or make sense. Lists can
    also be tailored to the receiver. For example, correspondents might get into a
    discussion of books or movies and exchange lists of their favorites. A prisoner
    might start studying a foreign language and receive regular vocabulary lists from
    their tutor. A businessperson might get monthly inventories from one of their
    warehouses. With lists, context is honored even while words are shuffled so the
    correct letter is found in the correct place.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是要可靠地避免上下文，而一个很好的方法就是使用列表。没有人期望购物清单是严格有序的或者合乎逻辑的。列表还可以根据接收者量身定制。例如，通讯员可能会讨论书籍或电影，并交换他们最喜欢的书单或影单。囚犯可能会开始学习外语，并从导师那里定期接收词汇表。商人可能会从其中一个仓库收到每月的库存清单。通过使用列表，即使单词被打乱，仍然可以尊重上下文，以便正确的字母出现在正确的位置。
- en: '**THE OBJECTIVE**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Write code that hides a null cipher within a list of words.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码，将空白密码隐藏在一个单词列表中。
- en: '***The List Cipher Code***'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***列表密码代码***'
- en: The *list_cipher.py* code, in [Listing 5-5](ch05.xhtml#ch05list5), embeds a
    null cipher within a list of dictionary words under the deception of vocabulary
    training. You’ll also need the *load_dictionary.py* program you used in [Chapters
    2](ch02.xhtml#ch02) and [3](ch03.xhtml#ch03). You can download this file, along
    with the following script, from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    Finally, you’ll need one of the dictionary files you used in [Chapters 2](ch02.xhtml#ch02)
    and [3](ch03.xhtml#ch03). You can find a list of suitable online dictionaries
    in [Table 2-1](ch02.xhtml#ch02tab1) on [page 20](ch02.xhtml#page_20). All of the
    aforementioned files should be kept in the same folder.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*list_cipher.py* 代码，在 [清单 5-5](ch05.xhtml#ch05list5) 中，将一个空白密码嵌入在一个字典单词的列表中，伪装成词汇训练。你还需要在
    [第 2 章](ch02.xhtml#ch02) 和 [第 3 章](ch03.xhtml#ch03) 中使用过的 *load_dictionary.py*
    程序。你可以从 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载这个文件以及以下脚本。最后，你还需要在 [第 2 章](ch02.xhtml#ch02) 和 [第 3 章](ch03.xhtml#ch03) 中使用过的字典文件。你可以在
    [第 2-1 表](ch02.xhtml#ch02tab1) 中找到适合的在线字典，位置在 [第 20 页](ch02.xhtml#page_20)。所有上述文件应该保存在同一个文件夹中。'
- en: '*list_cipher.py*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*list_cipher.py*'
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 5-5: Hides null cipher in a list*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-5：在列表中隐藏空白密码*'
- en: Start by importing the `random` module’s `randint()` function ➊. This permits
    the (pseudo)random selection of an integer value. Then load the `string` module,
    for access to ASCII letters. Finish by importing your `load_dictionary` module.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导入 `random` 模块的 `randint()` 函数 ➊。这允许选择一个（伪）随机的整数值。然后加载 `string` 模块，以访问 ASCII
    字母。最后，导入你的 `load_dictionary` 模块。
- en: 'Next, write a short secret message. Note that the associated comment forbids
    punctuation marks or numbers. Trying to use these with a dictionary file’s contents
    would be problematic. So, filter out everything but letters by checking for membership
    in `string.ascii_letters`, which contains both uppercase and lowercase letters
    ➋:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编写一条简短的秘密消息。请注意，相关的注释禁止使用标点符号或数字。尝试在字典文件的内容中使用这些会引发问题。因此，通过检查 `string.ascii_letters`
    中的成员来筛选出除了字母以外的所有内容，`string.ascii_letters` 包含大写字母和小写字母 ➋：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Display the message and then remove the whitespace ➌. Load your dictionary file
    ➍ and start an empty list to hold the vocabulary words ➎.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 显示消息后，去除空白字符 ➌。加载字典文件 ➍，并开始一个空列表来保存词汇单词 ➎。
- en: Use a `for` loop to go through each letter in the message ➏. Name a `size` variable
    and assign it a random value between 6 and 10 using the `randint()` function.
    This variable will ensure the words are long enough to be credible as vocabulary
    words. You can set the maximum value higher if you wish.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `for` 循环遍历消息中的每个字母 ➏。命名一个 `size` 变量，并使用 `randint()` 函数为其分配一个介于 6 到 10 之间的随机值。这个变量将确保单词足够长，看起来像是一个可信的词汇。你可以根据需要将最大值设置得更高。
- en: Nest another `for` loop and use it to go through the dictionary words ➐, checking
    their length against the `size` variable and comparing the (lowercase) letter
    at index 2—the word’s third letter—to the current (lowercase) letter in the message
    loop. You can change the index value on the word, but make sure it doesn’t exceed
    the lowest possible `size` variable minus 1! A final comparison prevents the same
    word from being used twice. If the word passes the tests, append it to `vocab_list`
    and move on to the next letter in the message.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套另一个`for`循环，使用它来遍历字典中的单词 ➐，检查它们的长度是否与`size`变量相符，并将第2个索引位置（即单词的第三个字母）的小写字母与消息循环中的当前（小写）字母进行比较。你可以更改单词中的索引值，但要确保它不超过最低可能的`size`变量减去1！最后的比较防止同一个单词被使用两次。如果单词通过测试，则将其附加到`vocab_list`中，并继续处理消息中的下一个字母。
- en: A typical dictionary file should contain enough words to encrypt a short message.
    But, to be safe, use a conditional to check that the length of `vocab_list` is
    not shorter than the length of the message ➑. If it’s shorter, then you ran out
    of words before reaching the end of the message, and you need to print a warning
    for the user. Otherwise, print the list of words.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的字典文件应包含足够的单词来加密一个简短的消息。但是，为了安全起见，使用条件语句检查`vocab_list`的长度是否不小于消息的长度 ➑。如果较短，那么你在到达消息末尾之前就已经用完了单词，应该给用户打印警告。否则，打印单词列表。
- en: '***The List Cipher Output***'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***列表密码输出***'
- en: 'Here is the output from the code (I’ve highlighted every third letter for readability,
    though the message is pretty easy to spot without any aid):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码的输出（我已将每第三个字母突出显示，以便阅读，尽管没有任何辅助工具消息也很容易找到）：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using a font with a consistent character width and stacking the words really
    compromises the cipher. We’ll look at ways to deal with this in “[Saving Mary](ch05.xhtml#lev128)”
    on [page 102](ch05.xhtml#page_102).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符宽度一致的字体并堆叠单词会严重削弱密码的安全性。我们将在《[拯救玛丽](ch05.xhtml#lev128)》一章中，[第102页](ch05.xhtml#page_102)讨论如何解决这个问题。
- en: '**Summary**'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you wrote a program that reveals the hidden message in a Trevanion-type
    null cipher. Then, you wrote a second program that generates a null cipher and
    conceals it within a language learner’s vocabulary list. In the following practice
    projects, you can explore ways to make this list cipher more secure.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你编写了一个程序，揭示了特雷瓦尼翁型空密码中的隐藏信息。然后，你又编写了第二个程序，生成了一个空密码，并将其隐藏在语言学习者的词汇表中。在接下来的实践项目中，你可以探索如何使这个列表密码更加安全。
- en: '**Further Reading**'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: 'More details on Mary, Queen of Scots, and Sir John Trevanion can be found in
    *Mysterious Messages: A History of Codes and Ciphers* (The Penguin Group, 2009)
    by Gary Blackwood and *The Code Book: The Science of Secrecy from Ancient Egypt
    to Quantum Cryptography* (Anchor, 2000) by Simon Singh.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 关于玛丽·斯图亚特女王和约翰·特雷瓦尼翁爵士的更多详情可以在*《神秘信息：密码和暗号的历史》*（企鹅集团，2009年）和*《密码书：从古埃及到量子密码学的秘密科学》*（Anchor，2000年）中找到，前者作者为加里·布莱克伍德，后者为西蒙·辛格。
- en: '**Practice Projects**'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目**'
- en: Now that you’re an expert on the null cipher, see if you can change the fate
    of Mary, Queen of Scots, and then sneak a look at Sir John’s most secret correspondence.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经是一个空密码的专家，试试看能否改变玛丽·斯图亚特女王的命运，然后偷看一下约翰爵士最机密的信件。
- en: '***Saving Mary***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***拯救玛丽***'
- en: 'The best part of coding is thinking about problems and how to solve them. Let’s
    revisit the sad case of Mary, Queen of Scots. Here’s what we know:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 编码的最佳部分是思考问题及如何解决它们。让我们回顾一下玛丽·斯图亚特女王的悲剧案例。我们知道的情况如下：
- en: Mary was not allowed correspondence, so letters had to be smuggled in. This
    means that the traitorous Gilbert Gifford cannot be removed from the equation.
    Gifford was the only person Mary knew with the means to deliver her mail.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玛丽被禁止通信，因此信件必须通过走私方式送入。这意味着叛徒吉尔伯特·吉福德无法从中除去。吉福德是玛丽唯一认识的、能送信的人。
- en: Mary and her correspondents put too much faith in an insecure cipher and thus
    spoke too freely. With less confidence, they might have shown more forbearance.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玛丽和她的通信者对不安全的密码过于信任，因此言语过于轻率。如果他们少一点信心，也许会更加忍耐。
- en: Mary’s jailors, having an obvious cipher in their possession, assumed it contained
    incriminating material and kept working until they found it.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玛丽的狱卒们发现了一个明显的密码本，他们认为里面包含了有罪证据，便继续工作，直到找到了它。
- en: Gifford, the double agent, wasn’t privy to the details of the ciphers Mary used.
    Now, assume Mary used a null cipher. If the correspondence was somewhat seditious—though
    not treasonously so—the message might have been overlooked by her captors. In
    the event a cursory examination was made, the use of a variable pattern might
    have sufficed to stymie the cryptanalysts.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 伪双重间谍吉福德并未掌握玛丽所使用密码的细节。现在，假设玛丽使用了空白密码。如果信件的内容有些煽动性——但并非叛国——那么她的监禁者可能会忽视这条消息。如果进行过粗略检查，使用可变模式可能足以阻止密码分析师。
- en: As you have seen, it’s easier to hide a null cipher in a list than in a letter.
    A list of families supporting Mary could serve the purpose. These could be known
    supporters or, in a Machiavellian twist, a mix of friends *and* enemies! This
    message wouldn’t be openly seditious, but would be close enough so that a lack
    of encryption would suggest no form of encryption was being used at all.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，将空白密码隐藏在列表中比隐藏在信件中要容易得多。支持玛丽的家庭列表可以用作此目的。这些家庭可以是已知的支持者，或者在马基雅维利式的扭曲中，既有朋友*也*有敌人！这条消息不会公开煽动叛乱，但足够接近，以至于缺乏加密会暗示根本没有使用任何形式的加密。
- en: For this practice project, write a program that embeds the message “Give your
    word and we rise” in a list of surnames. To hide the letters in the message, start
    at the second letter in the second name, move to the third letter in the third
    name, and then keep alternating between second and third letters for the remaining
    words.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习项目，编写一个程序，将消息“Give your word and we rise”嵌入一个姓氏列表中。为了隐藏消息中的字母，从第二个名字的第二个字母开始，接着是第三个名字的第三个字母，然后在剩余的单词中交替使用第二个和第三个字母。
- en: 'In addition to the unused first name, include “Stuart” and “Jacob” as null
    words early in the list to help hide the presence of the cipher. Don’t embed letters
    from the cipher in these null names and completely ignore them when choosing the
    letter position for the cipher in the following word; if the second letter was
    used in the word *before* the null name, use the third letter in the word *after*
    the null name. The null cipher would occupy the following bolded letters (the
    location of the null words is up to you, but don’t let them affect the pattern):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除了未使用的名字外，在列表的前面包含“Stuart”和“Jacob”作为空白词，以帮助隐藏密码的存在。不要在这些空白名字中嵌入密码字母，并且在为下一个单词选择密码字母位置时，完全忽略它们；如果第二个字母在空白名字*之前*的单词中已使用，则在空白名字*之后*的单词中使用第三个字母。空白密码将占据以下加粗字母的位置（空白词的位置由你决定，但不要让它们影响模式）：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The program can print the list either vertically or horizontally. The name list
    should be credibly introduced with a short message, but that message shouldn’t
    be part of the cipher.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以垂直或水平打印列表。姓名列表应该用一条简短的消息进行可信的介绍，但这条消息不应该是密码的一部分。
- en: The list of names can be downloaded from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    as *supporters.txt* and loaded as a standard dictionary file. You can find a solution
    in the appendix and online as *save_Mary_practice.py*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 姓名列表可以从 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载，作为 *supporters.txt* 并加载为标准字典文件。你可以在附录和网上找到解决方案，文件名为 *save_Mary_practice.py*。
- en: '***The Colchester Catch***'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***科尔切斯特捕捉***'
- en: 'Instead of some ale-sotted dimwit, *you* are left in charge of the prisoner
    John Trevanion when the following letter arrives at Colchester Castle:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你不再是那个喝醉的傻瓜，*你*在接下来的信件到达科尔切斯特城堡时，负责看守囚犯约翰·特雷瓦尼昂：
- en: 'Sir John: Odd and too hard, your lot. Still, we will band together and, like
    you, persevere. Who else could love their enemies, stand firm when all others
    fail, hate and despair? While we all can, let us feel hope. -R.T.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰爵士：你们这些人真是奇怪又太难了。不过，我们会团结起来，像你一样坚持到底。还有谁能爱敌人，失败时坚持不懈，仇恨并绝望？在我们都能做的情况下，让我们感受希望。-
    R.T.
- en: It seems clumsily phrased, even for the 17th century, and you decide to examine
    it more closely before passing it to your inmate.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这句话看起来很笨拙，即使对于17世纪来说也是如此，你决定在将其交给你的囚犯之前，仔细检查一下。
- en: 'Write a Python program that takes an input, *n*, and checks for and displays
    a null cipher based on the *n*th letter after the start of every *n*th word. For
    example, an input of `2` would find the bolded letters in this message:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个 Python 程序，输入 *n*，并根据每个第 *n* 个单词的第 *n* 个字母后的字母检查并显示空白密码。例如，输入 `2` 将会在这条消息中找到加粗字母：
- en: So, t**h**e cold t**e**a didn’t p**l**ease the o**l**d finicky w**o**man.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，冷**茶**没能让**老**女人感到满意。
- en: You can download the text file of the message from *[https://nostarch.com/impracticalpython/](https://nostarch.com/impracticalpython/)*
    as *colchester_message.txt*. A solution can be found in the appendix and online
    as *colchester_practice.py*. Keep the text and Python files together in the same
    folder.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 *[https://nostarch.com/impracticalpython/](https://nostarch.com/impracticalpython/)*
    下载消息的文本文件，文件名为 *colchester_message.txt*。解决方案可以在附录和在线找到，文件名为 *colchester_practice.py*。请将文本和
    Python 文件保存在同一个文件夹中。
