- en: '**5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5'
- en: ENCODING ENGLISH CIVIL WAR CIPHERS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编码 英国内战密码**
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: In 1587, Mary, Queen of Scots, lost her head due to a scrap of paper. Fifty-five
    years later, Sir John Trevanion, a supporter of another beheaded monarch, Charles
    the First, had his head saved by a scrap of paper. What made the difference? Steganography.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 1587年，苏格兰女王玛丽因一张纸丧命。55年后，另一位被斩首的君主查理一世的支持者约翰·特雷瓦农爵士，因一张纸得以保住性命。这其中的关键是什么？隐写术。
- en: '*Steganography* is the time-tested practice of concealing messages so well
    that their existence isn’t even suspected. The name is based on the Greek words
    for “covered writing,” and a very literal Grecian example was to take wax-covered
    wooden tablets used for writing, scrape off the wax, write on the wood, and then
    cover the board with a new coating of smooth wax. A modern-day example is to embed
    a message in an image by subtly altering its color components. Even a simple 8-bit
    JPEG image contains more colors than the human eye can detect, so without digital
    processing or filtering, the message is essentially invisible.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*隐写术*是经过时间考验的技术，能够巧妙地隐藏信息，甚至让人完全没有怀疑其存在的可能。这个名字源自希腊词汇，意思是“隐藏的文字”，一个非常字面上的希腊例子是用蜡覆盖的木板来写字，写完后刮去蜡，再在木板上写字，然后用新的一层光滑蜡覆盖。这种技术的现代例子就是通过微妙地改变图像的色彩成分来嵌入信息。即便是一个简单的8位JPEG图像，也包含了人眼无法察觉的颜色，因此未经数字处理或滤波，信息基本上是不可见的。'
- en: 'In this chapter, you’ll work with the *null cipher*, which isn’t a cipher at
    all but a steganographic technique for concealing plaintext within other strings
    of noncipher material. *Null* means “none,” so with a null cipher, you have chosen
    not to encrypt the message. The following is an example of a null cipher using
    the first letter in every word:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习*空密码*，这其实并不是一种真正的密码，而是一种将明文隐藏在其他非密码材料中的隐写术技巧。*Null*意味着“没有”，所以空密码的意思是你选择不对信息进行加密。下面是一个使用每个单词首字母的空密码示例：
- en: '**N**ice **u**ncles **l**ive **l**onger. **C**ruel, **i**nsensitive **p**eople
    **h**ave **e**ternal **r**egrets.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**N**ice **u**ncles **l**ive **l**onger. **C**ruel, **i**nsensitive **p**eople
    **h**ave **e**ternal **r**egrets.'
- en: First, you’ll write code that finds the hidden message that saved Sir John,
    and then you’ll accomplish the much more difficult task of writing a null cipher.
    Finally, you’ll get the opportunity to write a program that might have saved Mary’s
    head, had she used the output.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将编写代码，找出那个救了约翰爵士的隐藏信息，然后你将完成一个更为困难的任务——编写一个空密码。最后，你将有机会编写一个程序，如果玛丽使用了它的输出，或许她的头就能得以保全。
- en: '**Project #10: The Trevanion Cipher**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #10：特雷瓦农密码**'
- en: Queen Mary relied on both steganography and encryption to protect her messages.
    The strategy was sound, but her application was flawed. Unknowingly, she relied
    on a double agent named Gilbert Gifford to smuggle her messages. Gifford first
    delivered them to Queen Elizabeth’s spymaster, who cracked the cipher and replaced
    it with a forged message that enticed Mary to incriminate herself. The rest, as
    they say, is history.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 玛丽女王依赖隐写术和加密技术来保护她的信件。这个策略本身是合理的，但她的应用存在缺陷。她不知情地依赖了一名双重间谍吉尔伯特·吉福德来走私她的信件。吉福德首先将信件交给了伊丽莎白女王的间谍首脑，他破解了密码并用一份伪造的信息取而代之，诱使玛丽自我陷害。后来的事情，正如他们所说，已经成为了历史。
- en: For John Trevanion, the outcome was rosier. Sir John, a distinguished cavalier
    who aided Charles I against Oliver Cromwell in the English Civil War, was captured
    and imprisoned in Colchester Castle. The day before his execution, he received
    a letter from one of his friends. The letter was not smuggled in but delivered
    straight into the hands of his jailors, who examined it but didn’t notice any
    deception. After reading it, Sir John asked for some time alone to pray in the
    chapel. When his jailors came back to fetch him, he had vanished.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于约翰·特雷瓦农来说，结果则更加美好。约翰爵士是一位杰出的骑士，他曾在英国内战中支持查理一世对抗奥利弗·克伦威尔，并被俘并囚禁在科尔切斯特城堡。执行死刑的前一天，他收到了一个朋友的信。这封信并不是走私进来的，而是直接交到守卫手中，守卫检查过后并未发现任何异常。在阅读完信件后，约翰爵士请求独自一人到教堂祈祷。当守卫回来寻找他时，他已经消失了。
- en: 'Here is the message Sir John received:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是约翰爵士收到的消息：
- en: 'Worthie Sir John: Hope, that is the beste comfort of the afflicted, cannot
    much, I fear me, help you now. That I would saye to you, is this only: if ever
    I may be able to requite that I do owe you, stand not upon asking me. ''Tis not
    much I can do: but what I can do, bee you verie sure I wille. I knowe that, if
    deathe comes, if ordinary men fear it, it frights not you, accounting for it for
    a high honour, to have such a rewarde of your loyalty. Pray yet that you may be
    spared this soe bitter, cup. I fear not that you will grudge any sufferings; onlie
    if bie submission you can turn them away, ''tis the part of a wise man. Tell me,
    an if you can, to do for you anythinge that you wolde have done. The general goes
    back on Wednesday. Restinge your servant to command. R.T.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尊敬的约翰爵士：希望，这是遭遇困境者的最佳安慰，恐怕不能**帮助**您。我要告诉您的是，仅此一件事：如果我有机会回报我欠您的，不要因为请求我而犹豫。“这并不是我能做的很多，但我能做的，您可以放心，我一定会做。我知道，如果死亡降临，普通人都会害怕，但它并不会让您害怕，因为您视此为一种崇高的荣誉，作为您忠诚的回报。祈祷您能避免这杯苦酒。我不担心您会抱怨任何痛苦；只有在您通过忍耐能化解它们时，那才是明智之举。告诉我，如果您能，是否有我能为您做的任何事情。将军星期三回去。恭敬的，您的仆人，R.T.
- en: 'As you have probably guessed, this seemingly innocent letter contains a hidden
    message, revealed below in bold:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所猜测的，这封看似无害的信件实际上包含了一个隐藏的信息，已在下面以**粗体**显示：
- en: 'Worthie Sir John: Ho**p**e, th**a**t is the beste comfort of the afflicted,
    ca**n**not much, I f**e**ar me, he**l**p you now. Th**a**t I would saye to you,
    is **t**his only: if **e**ver I may be able to requite that I do owe you, st**a**nd
    not upon asking me. ''Ti**s** not much I can do: bu**t** what I can do, be**e**
    you verie sure I wille. I k**n**owe that, if **d**eathe comes, if **o**rdinary
    men fear it, it **f**rights not you, ac**c**ounting for it for a high honour,
    to **h**ave such a rewarde of your loyalty. Pr**a**y yet that you may be spared
    this soe bitter, cu**p**. I f**e**ar not that you will grudge any sufferings;
    on**l**ie if bie submission you can turn them away, ''ti**s** the part of a wise
    man. Te**l**l me, an **i**f you can, to **d**o for you anythinge that you wolde
    have done. Th**e** general goes back on Wednesday. Re**s**tinge your servant to
    command. R.T.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尊敬的约翰爵士：**希望**，这是遭遇困境者的最佳安慰，**不能**做太多，我恐怕**不能**帮助您。我要告诉您的是，仅此一件事：如果我有机会回报我欠您的，我不会因为要求您而犹豫。“这并不是我能做的很多，但我能做的，您可以放心，我一定会做。我知道，如果死亡降临，普通人都会害怕，但它并不会让您害怕，因为您视此为一种崇高的荣誉，作为您忠诚的回报。祈祷您能避免这杯苦酒。我不担心您会抱怨任何痛苦；只有在您通过忍耐能化解它们时，那才是明智之举。告诉我，如果您能，是否有我能为您做的任何事情。将军星期三回去。恭敬的，您的仆人，R.T.
- en: This null cipher uses every third letter after a punctuation mark to let Sir
    John know that a “panel at east end of chapel slides.” It’s rumored that the remains
    of a narrow stairway were later discovered in a recess in a wall in the castle.
    The passage was blocked at the time of discovery, but it may have been Sir John’s
    escape route around 1642.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这种空白密码在标点符号后使用每三个字母来通知约翰爵士，“教堂东端的面板滑动。”有传闻称，后来在城堡的墙壁凹处发现了一个狭窄的楼梯遗址。这个通道在发现时被堵住，但它可能是约翰爵士在1642年左右的逃脱路线。
- en: This last-minute escape would not have been possible with a traditional cipher.
    Only by expertly concealing the message with steganography was its author able
    to get it so quickly into Sir John’s hands. And the beauty of a null cipher is
    that, even if Sir John didn’t know the pattern but suspected a message was present,
    he could have found it fairly quickly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种临时的逃脱在传统的密码系统下是无法实现的。只有通过巧妙地使用隐写术将信息隐藏，作者才能如此迅速地将其交到约翰爵士手中。而空白密码的优点在于，即使约翰爵士不知道密码的模式，但怀疑其中有信息，他也能相当快速地找到它。
- en: If Sir John’s friend had been more careful, concealing encrypted ciphertext
    instead of plaintext, Sir John probably wouldn’t have deciphered the message in
    the short time he had remaining—unless he’d been informed beforehand of the cipher
    type and key.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果约翰爵士的朋友更加小心，隐藏的是加密的密文而不是明文，那么约翰爵士可能在剩余的短短时间内无法破译该消息——除非他事先得知密码类型和密钥。
- en: '**THE OBJECTIVE**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Write code that finds the letters hidden after punctuation marks in a null cipher
    and lets the user choose the number of letters after a punctuation mark to search
    for a solution.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码，找出空白密码中标点符号后隐藏的字母，并让用户选择每个标点符号后查找的字母数量，以找到解决方案。
- en: '***Strategy and Pseudocode***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略与伪代码***'
- en: Null ciphers rely on a repeating pattern known to both the sender and receiver.
    For example, every third word may be part of the real message or, better, the
    last letter of every third word. In the Trevanion cipher, it’s the third letter
    after a punctuation mark.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 空白密码依赖于发送者和接收者都知道的重复模式。例如，每第三个单词可能是实际信息的一部分，或者更好的是，每第三个单词的最后一个字母。在特雷瓦尼恩密码中，它是标点符号后的第三个字母。
- en: To find the Trevanion cipher, assume punctuation marks are the signal to begin
    counting, and then write code that locates every *n*th letter after the mark and
    saves those letters to a string or list. Once you’ve worked out how to do this,
    you can easily edit the code to work with any starting point, such as every capitalized
    word, every second letter per word, or the starting letter of every third word.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到特雷瓦尼恩密码，假设标点符号是开始计数的信号，然后编写代码，定位标点符号后的每*n*个字母，并将这些字母保存到字符串或列表中。一旦你弄清楚如何做到这一点，你可以轻松编辑代码，以便它适应任何起始点，比如每个大写字母单词、每个单词的第二个字母或每第三个单词的第一个字母。
- en: The only real point of contention involves punctuation marks. For instance,
    did the null cipher’s writer *want* punctuation marks to be included in the plaintext?
    How do you handle a second punctuation mark within the desired count range? What
    happens if two punctuation marks occur in succession?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的争议点涉及标点符号。例如，空白密码的写作者*想要*标点符号包含在明文中吗？如果第二个标点符号出现在期望的计数范围内，应该如何处理？如果两个标点符号连续出现，会发生什么？
- en: If you take a close look at the Trevanion cipher, you should see that there
    are double punctuations caused by the repeated use of the word *’tis*. There is
    also a jumble of punctuation marks at the end of the message, where the writer
    provides his initials. To deal with this, Sir John and his friend may have established
    some rules before Sir John’s incarceration, or Sir John just used trial and error
    to work them out.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察特雷瓦尼恩密码，你会发现由于重复使用单词*’tis*，导致了双重标点符号。在消息的结尾，还有一堆标点符号，其中写作者提供了他的名字首字母。为了解决这个问题，约翰爵士和他的朋友可能在约翰爵士被囚禁之前就制定了一些规则，或者约翰爵士只是通过反复试探来找出这些规则。
- en: Based on the end of the message, punctuation marks aren’t included in the letter
    count. If Sir John’s friend had intended them to be, then the hidden message would
    end with a capital *T*, because the *T* is three *characters* after a punctuation
    mark, and crucially not three *letters* after. This means that, if the reader
    encounters a punctuation mark within the count limit, they have to restart their
    count.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据消息的结尾，标点符号不包括在字母计数中。如果约翰爵士的朋友本意是将它们包括在内，那么隐藏的消息会以一个大写的*T*结束，因为*T*在标点符号后的第三个*字符*，而不是第三个*字母*。这意味着，如果读者在计数限制内遇到标点符号，他们必须重新开始计数。
- en: 'So these are the rules:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这些是规则：
- en: Initiate a letter count with every punctuation mark.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当遇到标点符号时，启动一个字母计数。
- en: Reset the count if a punctuation mark is encountered.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果遇到标点符号，则重置计数。
- en: Punctuation marks cannot be part of the plaintext message.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标点符号不能是明文信息的一部分。
- en: 'Since you may not know what the letter count should be, write the code so that
    it checks all counts up through a limit the user provides. The pseudocode is fairly
    straightforward:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你可能不知道字母的计数应该是多少，所以编写代码以检查用户提供的上限值范围内的所有计数。伪代码相当简单明了：
- en: Load a text file and strip it of whitespace
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 加载文本文件并去除空白字符
- en: Get user input on how many letters after punctuation to look ahead and examine
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 获取用户输入，确定要查看的标点符号后要前瞻多少个字母
- en: Loop through number of letters from 1 to this lookahead value
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 循环遍历从 1 到此前瞻值的字母数量
- en: Start an empty string to hold the translation
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个空字符串来保存翻译
- en: Start a counter
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个计数器
- en: Start a ➊first-found marker and set to False
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个 ➊第一个找到标记，并设置为 False
- en: Loop through characters in the text
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 循环遍历文本中的字符
- en: If character is punctuation
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符是标点符号
- en: Counter = 0
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器 = 0
- en: First-found = True
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个找到 = True
- en: Otherwise, if ➋first-found is True
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，如果 ➋第一个找到为 True
- en: Counter + 1
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器 + 1
- en: If counter = lookahead value
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计数器 = 前瞻值
- en: Add character to translation string
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符添加到翻译字符串
- en: Display translation for this lookahead value
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 显示此前瞻值的翻译
- en: Note that the first-found variable ➊ will remain False until a punctuation mark
    is encountered, after which it will be set to True ➋. This prevents the program
    from counting until the first punctuation mark is found.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一个找到的变量 ➊ 会保持为 False，直到遇到标点符号，然后它会被设置为 True ➋。这可以防止程序在找到第一个标点符号之前进行计数。
- en: Now you’re ready to write the code!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你准备好编写代码了！
- en: '***The Trevanion Cipher Code***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***特雷瓦尼翁密码代码***'
- en: The code in this section will find a Trevanion-type null cipher encoded with
    a specific number of letters after each punctuation mark. You will also need the
    text file containing the Trevanion cipher. You can download both the script and
    the text file from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    as *null_cipher_finder.py* and *trevanion.txt*, respectively. Keep these files
    in the same folder.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的代码将找到特雷瓦尼翁类型的空密码，它在每个标点符号后的特定数量的字母中编码。你还需要包含特雷瓦尼翁密码的文本文件。你可以从 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载脚本和文本文件，分别命名为 *null_cipher_finder.py* 和 *trevanion.txt*。请将这些文件保存在同一个文件夹中。
- en: '**Loading the Text**'
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**加载文本**'
- en: '[Listing 5-1](ch05.xhtml#ch05list1) imports some useful modules and loads the
    text file containing the null cipher.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-1](ch05.xhtml#ch05list1) 导入了一些有用的模块，并加载了包含空密码的文本文件。'
- en: '*null_cipher_finder.py,* part 1'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*null_cipher_finder.py,* 第 1 部分'
- en: ➊ import sys
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ import sys
- en: import string
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: import string
- en: '➋ def load_text(file):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ def load_text(file):'
- en: '"""Load a text file as a string."""'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将文本文件加载为字符串。"""'
- en: '➌ with open(file) as f:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ 使用 open(file) 打开文件：
- en: ➍ return f.read().strip()
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ return f.read().strip()
- en: '*Listing 5-1: Imports modules and loads the null cipher text*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-1：导入模块并加载空密码文本*'
- en: First, import the now-familiar sys module so you can handle exceptions that
    may occur during user input ➊. Also import the string module to gain access to
    useful collections of constants, like letters and punctuation marks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导入现在熟悉的 sys 模块，以便在用户输入过程中处理可能出现的异常 ➊。还需要导入 string 模块，以便访问有用的常量集合，如字母和标点符号。
- en: Next, define a function to load the text file containing the null cipher ➋.
    This function is similar to the one you used to load a dictionary file in [Chapter
    2](ch02.xhtml#ch02). It will be called by the main()function later to actually
    load the file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个函数来加载包含空密码的文本文件 ➋。这个函数类似于你在[第 2 章](ch02.xhtml#ch02)中用来加载字典文件的那个函数。稍后，它将由
    `main()` 函数调用来实际加载文件。
- en: Start the load_text() function by using with to open the file ➌. By using with,
    you know the file will be automatically closed after it is loaded. Use read()
    to load the contents and strip() to remove leading and trailing whitespace. Note
    that you can do this on the same line with the return statement ➍.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 开始 `load_text()` 函数，使用 with 打开文件 ➌。通过使用 with，你可以确保文件在加载后会自动关闭。使用 `read()` 加载内容，并使用
    `strip()` 去除前后的空白字符。请注意，你可以在同一行中使用 return 语句 ➍。
- en: '**Finding the Hidden Message**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**查找隐藏的消息**'
- en: '[Listing 5-2](ch05.xhtml#ch05list2) defines the function that finds the hidden
    message. It takes two arguments. The first is the message, which is the original
    text file as a string stripped of whitespace, and the second is the number of
    letters to check after a punctuation mark. This check value is obtained from the
    user as part of the main() function.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-2](ch05.xhtml#ch05list2) 定义了一个函数，用于查找隐藏的消息。该函数接受两个参数。第一个是消息，即去除空白字符的原始文本文件作为字符串，第二个是标点符号后的字母检查数量。这个检查值是作为
    `main()` 函数的一部分从用户那里获取的。'
- en: '*null_cipher_finder.py,* part 2'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*null_cipher_finder.py,* 第 2 部分'
- en: 'def solve_null_cipher(message, lookahead):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 'def solve_null_cipher(message, lookahead):'
- en: '"""Solve a null cipher based on number of letters after punctuation mark.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '"""根据标点符号后的字母数量解决空密码问题。'
- en: message = null cipher text as string stripped of whitespace
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: message = 空密码文本作为去除空白的字符串
- en: lookahead = endpoint of range of letters after punctuation mark to examine
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: lookahead = 检查标点符号后字母范围的终点
- en: '"""'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: '➊ for i in range(1, lookahead + 1):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ for i in range(1, lookahead + 1):'
- en: ➋ plaintext = ''
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ plaintext = ''
- en: count = 0
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: count = 0
- en: found_first = False
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: found_first = False
- en: '➌ for char in message:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ for char in message:'
- en: '➍ if char in string.punctuation:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ if char in string.punctuation:'
- en: count = 0
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: count = 0
- en: found_first = True
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: found_first = True
- en: '➎ elif found_first is True:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ elif found_first is True:'
- en: count += 1
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: count += 1
- en: '➏ if count == i:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '➏ if count == i:'
- en: plaintext += char
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: plaintext += char
- en: ➐ print("Using offset of {} after punctuation = {}".
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ print("使用标点符号后的偏移量 {} = {}"。
- en: format(i, plaintext))
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: format(i, plaintext))
- en: print()
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: print()
- en: '*Listing 5-2: Searches for hidden letters*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-2：搜索隐藏字母*'
- en: Treat the lookahead value as the endpoint of a range in a for loop so that you
    can check all the intervening letters in the message for the presence of a hidden
    message. Set the range as (1, lookahead + 1) ➊; that way, you start with the first
    letter after a punctuation mark and include the user’s choice in the evaluation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 将 lookahead 值视为 for 循环中的一个范围的终点，这样你就可以检查消息中所有介于两者之间的字母，以确定是否存在隐藏的消息。将范围设置为 (1,
    lookahead + 1) ➊；这样，你就从标点符号后的第一个字母开始，并在评估时包含用户的选择。
- en: Now, assign a few variables ➋. First, initialize an empty string to hold the
    translated plaintext. Then set a counter to 0. Finally, set a found_first variable
    to False. Remember that the program uses this variable to defer counting until
    the first punctuation mark is encountered.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，给几个变量赋值 ➋。首先，初始化一个空字符串来保存翻译后的明文。然后将计数器设置为 0。最后，将 found_first 变量设置为 False。记住，程序使用这个变量推迟计数，直到遇到第一个标点符号为止。
- en: Next, begin looping through the characters in the message ➌. If you encounter
    a punctuation mark, reset the counter to 0 and set found_first to True ➍. If you’ve
    found a punctuation mark already and the current character isn’t punctuation,
    advance the counter by 1 ➎. If you’ve found the letter you’re looking for—meaning
    the count has reached the current lookahead value (i)—add the letter to the plaintext
    string ➏.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，开始遍历消息中的字符 ➌。如果遇到标点符号，将计数器重置为 0 并将 found_first 设置为 True ➍。如果已经找到了标点符号并且当前字符不是标点符号，则将计数器加
    1 ➎。 如果找到了你要找的字母——即计数器达到了当前的 lookahead 值（i）——则将该字母添加到明文字符串 ➏。
- en: When you’ve examined all the characters in the message for the current lookahead
    value, display the current key and the translation ➐.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当你检查完消息中所有字符并且当前的 lookahead 值已经处理完后，显示当前的密钥和翻译 ➐。
- en: '**Defining the main() Function**'
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义 main() 函数**'
- en: '[Listing 5-3](ch05.xhtml#ch05list3) defines the main() function. You may remember
    from [Chapter 3](ch03.xhtml#ch03) that the main() function is like your program’s
    project manager: it takes input, keeps track of progress, and tells the other
    functions when to work.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-3](ch05.xhtml#ch05list3) 定义了 main() 函数。你可能还记得在[第 3 章](ch03.xhtml#ch03)中，main()
    函数就像是你程序的项目经理：它接收输入，跟踪进度，并告诉其他函数何时开始工作。'
- en: '*null_cipher_finder.py,* part 3'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*null_cipher_finder.py,* 第 3 部分'
- en: 'def main():'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '"""Load text, solve null cipher."""'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '"""加载文本，解决空白密码问题。"""'
- en: '# load & process message:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '# 加载并处理消息：'
- en: '➊ filename = input("\nEnter full filename for message to translate: ")'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ filename = input("\n请输入要翻译的消息的完整文件名：")
- en: '➋ try:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ try:'
- en: loaded_message = load_text(filename)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: loaded_message = load_text(filename)
- en: 'except IOError as e:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 'except IOError as e:'
- en: print("{}. Terminating program.".format(e), file=sys.stderr)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: print("{}. 正在终止程序.".format(e), file=sys.stderr)
- en: sys.exit(1)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit(1)
- en: ➌ print("\nORIGINAL MESSAGE =")
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ print("\n原始消息 =")
- en: print("{}".format(loaded_message), "\n")
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: print("{}".format(loaded_message), "\n")
- en: print("\nList of punctuation marks to check = {}".
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: print("\n待检查的标点符号列表 = {}".
- en: format(string.punctuation), "\n")
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: format(string.punctuation), "\n")
- en: '# remove whitespace:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '# 移除空白字符：'
- en: ➍ message = ''.join(loaded_message.split())
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ message = ''.join(loaded_message.split())
- en: '# get range of possible cipher keys from user:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取用户输入的可能的密码密钥范围：'
- en: '➎ while True:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ while True:'
- en: ➏ lookahead = input("\nNumber of letters to check after " \
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ lookahead = input("\n检查 ' " \
- en: '"punctuation mark: ")'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '"标点符号：")'
- en: '➐ if lookahead.isdigit():'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ 如果 lookahead 是数字：
- en: lookahead = int(lookahead)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: lookahead = int(lookahead)
- en: break
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: 'else:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: ➑ print("Please input a number.", file=sys.stderr)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ print("请输入一个数字。", file=sys.stderr)
- en: print()
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: print()
- en: '# run function to decode cipher'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '# 运行函数解密密码'
- en: ➒ solve_null_cipher(message, lookahead)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ solve_null_cipher(message, lookahead)
- en: '*Listing 5-3: Defines the* main() *function*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-3：定义了* main() *函数*'
- en: Start by asking the user for the name of the file (name + extension) ➊, and
    then use try to call the load_text() function ➋. If the file can’t be found, print
    the error in red—for those using the IDLE window—and exit the program using sys.exit(1),
    where the 1 indicates termination with an error.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，询问用户文件的名称（名称 + 扩展名） ➊，然后尝试调用 load_text() 函数 ➋。如果找不到文件，则打印红色错误信息（对于使用 IDLE
    窗口的用户），并使用 sys.exit(1) 终止程序，其中 1 表示发生错误终止。
- en: Print the message followed by the list of punctuation marks in the string module
    ➌. Only the characters in this list will be recognized by the program as punctuation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 打印消息，并跟随字符串模块中的标点符号列表 ➌。只有这些字符会被程序识别为标点符号。
- en: Next, take the loaded message and remove all spaces ➍. You’re going to count
    only letters and punctuation marks, so spaces would just get in the way. Start
    a while loop that keeps asking the user for input in the event they enter a bad
    value ➎. Ask the user for the number of letters to check after a punctuation mark
    ➏. This will be treated as a range, starting with 1 and ending with the user’s
    choice plus 1\. If the input value is a digit ➐, turn it into an integer, since
    input returns a string. Then, use break to exit the loop.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，取出加载的消息并移除所有空格➍。你只需要计算字母和标点符号，所以空格会妨碍你。启动一个while循环，在用户输入无效值时持续请求输入➎。询问用户每个标点符号后的字母数量➏。这将被当作一个范围，起始为1，结束为用户选择的数字加1。如果输入值是数字➐，将其转换为整数，因为输入会返回字符串。然后，使用break退出循环。
- en: If the user enters an invalid value, like “Bob,” use a print statement to request
    a number and, for shell users, make the font red using sys.stderr ➑. The while
    loop will then repeat the request for input.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入了无效值，比如“Bob”，使用print语句请求输入一个数字，并且对于shell用户，使用sys.stderr将字体变为红色➑。然后，while循环会重复请求输入。
- en: Pass the lookahead variable, along with the message, to the solve_null_cipher
    function ➒. Now all that’s left is to call the main() function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将前瞻变量与消息一起传递给solve_null_cipher函数➒。现在剩下的就是调用main()函数了。
- en: '**Running the main() Function**'
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**运行main()函数**'
- en: Back in the global space, complete the code by calling main()—but only if the
    program is run in stand-alone mode versus being imported into another program
    ([Listing 5-4](ch05.xhtml#ch05list4)).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 回到全局空间，通过调用main()来完成代码——但只有在程序以独立模式运行，而不是被导入到另一个程序时（[清单5-4](ch05.xhtml#ch05list4)）。
- en: '*null_cipher_finder.py,* part 4'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*null_cipher_finder.py,* 第4部分'
- en: 'if __name__ == ''__main__'':'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 __name__ == ''__main__'':'
- en: main()
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: '*Listing 5-4: Calls the* main() *function*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单5-4：调用* main() *函数*'
- en: 'The following is example output from the completed program, using the Trevanion
    cipher as input:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Trevanion密码作为输入的完整程序的示例输出：
- en: 'Enter full filename for message to translate: trevanion.txt'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 输入要翻译的完整文件名：trevanion.txt
- en: ORIGINAL MESSAGE =
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 原始消息 =
- en: 'Worthie Sir John: Hope, that is the beste comfort of the afflicted, cannot'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尊敬的约翰先生：希望，这是患难中的最好安慰。
- en: 'much, I fear me, help you now. That I would saye to you, is this only: if ever'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我担心，我现在无法为你提供太多帮助。我要对你说的是，这只是：如果曾经
- en: I may be able to requite that I do owe you, stand not upon asking me. 'Tis not
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我也许能够回报我欠你的，不必再问我。‘’这不是
- en: 'much I can do: but what I can do, bee you verie sure I wille. I knowe that,'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我能做的有限：但我能做的事，你可以很确信我会做。我知道，
- en: if deathe comes, if ordinary men fear it, it frights not you, accounting for
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果死亡来临，如果普通人害怕它，它不会吓到你，原因是
- en: it for a high honour, to have such a rewarde of your loyalty. Pray yet that
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了一个崇高的荣誉，拥有你忠诚的回报。祈祷吧，
- en: you may be spared this soe bitter, cup. I fear not that you will grudge any
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会避免这杯苦酒。我不担心你会为此有所怨言
- en: sufferings; onlie if bie submission you can turn them away, 'tis the part of
    a
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 苦难；只有如果通过提交，你才能驱赶它们，这是
- en: wise man. Tell me, an if you can, to do for you anythinge that you wolde have
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 智者。告诉我，如果你能的话，做任何你想做的事。
- en: done. The general goes back on Wednesday. Restinge your servant to command.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将军将在星期三返回。休息，我的仆人，命令我行。
- en: R.T.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: R.T.
- en: List of punctuation marks to check = !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查的标点符号列表 = !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
- en: 'Number of letters to check after punctuation mark: 4'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查的标点符号后的字母数：4
- en: Using offset of 1 after punctuation = HtcIhTiisTbbIiiiatPcIotTatTRRT
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标点符号后偏移量为1 = HtcIhTiisTbbIiiiatPcIotTatTRRT
- en: Using offset of 2 after punctuation = ohafehsftiuekfftcorufnienohe
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标点符号后偏移量为2 = ohafehsftiuekfftcorufnienohe
- en: Using offset of 3 after punctuation = panelateastendofchapelslides
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标点符号后偏移量为3 = panelateastendofchapelslides
- en: Using offset of 4 after punctuation = etnapthvnnwyoerroayaitlfogt
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标点符号后偏移量为4 = etnapthvnnwyoerroayaitlfogt
- en: In this output, the program has checked up to the fourth letter after a punctuation
    mark, but as you can see, it finds the solution using three letters after a punctuation
    mark.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在此输出中，程序已检查了标点符号后的第四个字母，但正如你所见，它使用标点符号后的三个字母找到了答案。
- en: '**Project #11: Writing a Null Cipher**'
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目#11：编写一个空密码**'
- en: 'Here is an unfinished example of a very weak null cipher based on the start
    of each word. Take a minute and try to complete the sentence:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常弱的空密码的未完成示例，基于每个单词的开头。花一点时间试着完成这个句子：
- en: H__________ e__________ l__________ p__________ m__________ e__________.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: H__________ e__________ l__________ p__________ m__________ e__________。
- en: You probably found it difficult, because whether you use letters or even whole
    words, it takes hard work and time to produce a null cipher that doesn’t read
    awkwardly and arouse suspicion. The heart of the problem is context. If the cipher
    is encapsulated within correspondence, that correspondence has to be coherent
    to avoid suspicion. That means it has to address a relevant topic and stay true
    to that topic for a reasonable number of sentences. As you probably saw, drafting
    even one sentence on any topic is no easy task!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得很难，因为无论是使用字母还是整个单词，制作一个不显得尴尬并引起怀疑的空白密码需要付出艰苦的努力和时间。问题的核心是上下文。如果密码被封装在通信中，这些通信必须是连贯的，以避免怀疑。这意味着它必须涉及一个相关的话题，并在合理的句数内始终围绕这个话题展开。正如你可能看到的，起草任何话题的一个句子都不是一件容易的事！
- en: The key is to credibly avoid context, and a good way to do this is with a list.
    No one expects a shopping list to be rigidly organized or make sense. Lists can
    also be tailored to the receiver. For example, correspondents might get into a
    discussion of books or movies and exchange lists of their favorites. A prisoner
    might start studying a foreign language and receive regular vocabulary lists from
    their tutor. A businessperson might get monthly inventories from one of their
    warehouses. With lists, context is honored even while words are shuffled so the
    correct letter is found in the correct place.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是可信地避免上下文，做这件事的一个好方法是使用列表。没有人会期望购物清单是严谨组织的或有意义的。列表也可以根据接收者量身定制。例如，通信者可能会讨论书籍或电影，并交换自己最喜欢的列表。囚犯可能开始学习外语，并从导师那里定期收到词汇列表。商人可能每月收到一个仓库的库存清单。通过使用列表，即使单词被打乱，正确的字母也能出现在正确的位置，同时仍保持上下文的完整性。
- en: '**THE OBJECTIVE**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Write code that hides a null cipher within a list of words.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码，在单词列表中隐藏一个空白密码。
- en: '***The List Cipher Code***'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***列表密码代码***'
- en: The *list_cipher.py* code, in [Listing 5-5](ch05.xhtml#ch05list5), embeds a
    null cipher within a list of dictionary words under the deception of vocabulary
    training. You’ll also need the *load_dictionary.py* program you used in [Chapters
    2](ch02.xhtml#ch02) and [3](ch03.xhtml#ch03). You can download this file, along
    with the following script, from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    Finally, you’ll need one of the dictionary files you used in [Chapters 2](ch02.xhtml#ch02)
    and [3](ch03.xhtml#ch03). You can find a list of suitable online dictionaries
    in [Table 2-1](ch02.xhtml#ch02tab1) on [page 20](ch02.xhtml#page_20). All of the
    aforementioned files should be kept in the same folder.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*list_cipher.py* 代码（见[示例 5-5](ch05.xhtml#ch05list5)）将一个空白密码嵌入到一个字典单词列表中，借用词汇训练的伪装。你还需要在[第
    2 章](ch02.xhtml#ch02)和[第 3 章](ch03.xhtml#ch03)中使用的 *load_dictionary.py* 程序。你可以从
    *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载这个文件，以及以下脚本。最后，你需要一个在[第 2 章](ch02.xhtml#ch02)和[第 3 章](ch03.xhtml#ch03)中使用的字典文件。你可以在[表
    2-1](ch02.xhtml#ch02tab1)中找到适合的在线字典，位于[第 20 页](ch02.xhtml#page_20)。所有上述文件应该保存在同一个文件夹中。'
- en: '*list_cipher.py*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*list_cipher.py*'
- en: ➊ from random import randint
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ 从 random 导入 randint
- en: import string
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 string
- en: import load_dictionary
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 load_dictionary
- en: '# write a short message that doesn''t contain punctuation or numbers!'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '# 编写一条不包含标点符号或数字的简短信息！'
- en: input_message = "Panel at east end of chapel slides"
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: input_message = "教堂东端的面板滑动"
- en: message = ''
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: message = ''
- en: 'for char in input_message:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 input_message 中的每个字符：
- en: '➋ if char in string.ascii_letters:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ 如果 char 在 string.ascii_letters 中：
- en: message += char
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: message += char
- en: print(message, "\n")
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: print(message, "\n")
- en: ➌ message = "".join(message.split())
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ message = "".join(message.split())
- en: '➍ # open dictionary file'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ # 打开字典文件'
- en: word_list = load_dictionary.load('2of4brif.txt')
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: word_list = load_dictionary.load('2of4brif.txt')
- en: '# build vocabulary word list with hidden message'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '# 构建包含隐藏信息的词汇表'
- en: ➎ vocab_list = []
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ vocab_list = []
- en: '➏ for letter in message:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ 对于 message 中的每个字母：
- en: size = randint(6, 10)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: size = randint(6, 10)
- en: '➐ for word in word_list:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ 对于 word_list 中的每个单词：
- en: if len(word) == size and word[2].lower() == letter.lower()\
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 len(word) == size 且 word[2].lower() == letter.lower()\
- en: 'and word not in vocab_list:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 且 word 不在 vocab_list 中：
- en: vocab_list.append(word)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: vocab_list.append(word)
- en: break
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: break
- en: '➑ if len(vocab_list) < len(message):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '➑ 如果 len(vocab_list) < len(message):'
- en: print("Word List is too small. Try larger dictionary or shorter message!")
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: print("词汇表太小了。尝试使用更大的字典或更短的消息！")
- en: 'else:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: 'print("Vocabulary words for Unit 1: \n", *vocab_list, sep="\n")'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: print("单元 1 的词汇：\n", *vocab_list, sep="\n")
- en: '*Listing 5-5: Hides null cipher in a list*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 5-5：在列表中隐藏空白密码*'
- en: Start by importing the random module’s randint() function ➊. This permits the
    (pseudo)random selection of an integer value. Then load the string module, for
    access to ASCII letters. Finish by importing your load_dictionary module.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入random模块的randint()函数 ➊。这样可以进行（伪）随机整数选择。然后加载字符串模块，以便访问ASCII字母。最后导入你的load_dictionary模块。
- en: 'Next, write a short secret message. Note that the associated comment forbids
    punctuation marks or numbers. Trying to use these with a dictionary file’s contents
    would be problematic. So, filter out everything but letters by checking for membership
    in string.ascii_letters, which contains both uppercase and lowercase letters ➋:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，写一个简短的秘密消息。请注意，相关评论禁止使用标点符号或数字。尝试使用这些内容与词典文件的内容结合会很有问题。因此，检查是否属于string.ascii_letters中的字母，以过滤出除了字母以外的所有内容
    ➋：
- en: '''abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'''
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '''abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'''
- en: Display the message and then remove the whitespace ➌. Load your dictionary file
    ➍ and start an empty list to hold the vocabulary words ➎.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 显示消息后，去除空格 ➌。加载你的词典文件 ➍ 并开始一个空列表，用于存储词汇单词 ➎。
- en: Use a for loop to go through each letter in the message ➏. Name a size variable
    and assign it a random value between 6 and 10 using the randint() function. This
    variable will ensure the words are long enough to be credible as vocabulary words.
    You can set the maximum value higher if you wish.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for循环遍历消息中的每个字母 ➏。定义一个大小变量，并使用randint()函数为其分配一个介于6到10之间的随机值。这个变量将确保单词的长度足够长，以便作为词汇单词具有可信度。如果需要，你可以将最大值设置得更高。
- en: Nest another for loop and use it to go through the dictionary words ➐, checking
    their length against the size variable and comparing the (lowercase) letter at
    index 2—the word’s third letter—to the current (lowercase) letter in the message
    loop. You can change the index value on the word, but make sure it doesn’t exceed
    the lowest possible size variable minus 1! A final comparison prevents the same
    word from being used twice. If the word passes the tests, append it to vocab_list
    and move on to the next letter in the message.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套另一个for循环，使用它遍历字典中的单词 ➐，检查它们的长度是否与大小变量相符，并将单词的第三个字母（小写）与消息循环中的当前字母（小写）进行比较。你可以更改单词的索引值，但要确保它不超过最小的大小变量减去1！最后的比较避免了相同的单词被使用两次。如果单词通过测试，将其添加到vocab_list中，并继续处理消息中的下一个字母。
- en: A typical dictionary file should contain enough words to encrypt a short message.
    But, to be safe, use a conditional to check that the length of vocab_list is not
    shorter than the length of the message ➑. If it’s shorter, then you ran out of
    words before reaching the end of the message, and you need to print a warning
    for the user. Otherwise, print the list of words.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的词典文件应包含足够的单词以加密一条短消息。但是，为了安全起见，使用条件语句检查vocab_list的长度是否不小于消息的长度 ➑。 如果它更短，那么你在消息结束之前就用完了单词，必须打印警告给用户。否则，打印单词列表。
- en: '***The List Cipher Output***'
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***列表密码输出***'
- en: 'Here is the output from the code (I’ve highlighted every third letter for readability,
    though the message is pretty easy to spot without any aid):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码的输出（我已突出显示每第三个字母以便于阅读，尽管没有任何帮助，消息本身也很容易被发现）：
- en: Panelateastendofchapelslides
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Panelateastendofchapelslides
- en: 'Vocabulary words for Unit 1:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 第1单元的词汇：
- en: alphabets
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 字母表
- en: abandoning
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃
- en: annals
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 年鉴
- en: aberration
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 异常
- en: ablaze
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 着火的
- en: abandoned
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 被遗弃的
- en: acting
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 演出
- en: abetted
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 协助
- en: abasement
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 屈辱
- en: abseil
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 攀岩
- en: activated
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 激活的
- en: adequately
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 充分的
- en: abnormal
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 异常的
- en: abdomen
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 腹部
- en: abolish
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 废除
- en: affecting
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 影响
- en: acceding
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 赞同
- en: abhors
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 厌恶
- en: abalone
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃
- en: ampersands
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 和号
- en: acetylene
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 乙炔
- en: allegation
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 指控
- en: absconds
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 逃逸
- en: aileron
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 副翼
- en: acidifying
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 酸化
- en: abdicating
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃
- en: adepts
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 精通者
- en: absent
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 缺席
- en: Using a font with a consistent character width and stacking the words really
    compromises the cipher. We’ll look at ways to deal with this in “[Saving Mary](ch05.xhtml#lev128)”
    on [page 102](ch05.xhtml#page_102).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用具有一致字符宽度的字体并将单词堆叠在一起，确实会破坏密码的安全性。我们将在“[保存玛丽](ch05.xhtml#lev128)”中讨论如何处理这个问题，[第102页](ch05.xhtml#page_102)。
- en: '**Summary**'
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you wrote a program that reveals the hidden message in a Trevanion-type
    null cipher. Then, you wrote a second program that generates a null cipher and
    conceals it within a language learner’s vocabulary list. In the following practice
    projects, you can explore ways to make this list cipher more secure.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你编写了一个程序，揭示了Trevanion类型的空白密码中的隐藏信息。然后，你编写了第二个程序，生成一个空白密码并将其隐藏在语言学习者的词汇表中。在接下来的实践项目中，你可以探索如何使这个列表密码更加安全。
- en: '**Further Reading**'
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: 'More details on Mary, Queen of Scots, and Sir John Trevanion can be found in
    *Mysterious Messages: A History of Codes and Ciphers* (The Penguin Group, 2009)
    by Gary Blackwood and *The Code Book: The Science of Secrecy from Ancient Egypt
    to Quantum Cryptography* (Anchor, 2000) by Simon Singh.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于玛丽·斯图尔特女王和约翰·特雷瓦尼翁爵士的细节可以在*《神秘的信息：密码和密码学的历史》*（企鹅出版集团，2009年）由加里·布莱克伍德（Gary
    Blackwood）和*《密码书：从古埃及到量子密码学的秘密科学》*（Anchor，2000年）由西蒙·辛格（Simon Singh）中找到。
- en: '**Practice Projects**'
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目**'
- en: Now that you’re an expert on the null cipher, see if you can change the fate
    of Mary, Queen of Scots, and then sneak a look at Sir John’s most secret correspondence.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经是空密码的专家了，看看你能否改变玛丽·斯图尔特女王的命运，然后偷偷查看约翰爵士最机密的通信。
- en: '***Saving Mary***'
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***拯救玛丽***'
- en: 'The best part of coding is thinking about problems and how to solve them. Let’s
    revisit the sad case of Mary, Queen of Scots. Here’s what we know:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 编程最棒的部分是思考问题和如何解决它们。让我们重新审视玛丽·斯图尔特女王的悲剧。以下是我们所知道的：
- en: Mary was not allowed correspondence, so letters had to be smuggled in. This
    means that the traitorous Gilbert Gifford cannot be removed from the equation.
    Gifford was the only person Mary knew with the means to deliver her mail.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玛丽不允许书信往来，因此信件必须被走私进入。这意味着叛徒吉尔伯特·吉福德无法从这个方程中去除。吉福德是玛丽唯一认识的、有能力投递她信件的人。
- en: Mary and her correspondents put too much faith in an insecure cipher and thus
    spoke too freely. With less confidence, they might have shown more forbearance.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玛丽和她的通讯者过于信任一种不安全的密码，因此说得太过随便。如果他们少些自信，可能会更加忍耐。
- en: Mary’s jailors, having an obvious cipher in their possession, assumed it contained
    incriminating material and kept working until they found it.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玛丽的狱卒们手中有明显的密码，他们认为它包含了有罪的材料，并一直工作，直到他们找到了它。
- en: Gifford, the double agent, wasn’t privy to the details of the ciphers Mary used.
    Now, assume Mary used a null cipher. If the correspondence was somewhat seditious—though
    not treasonously so—the message might have been overlooked by her captors. In
    the event a cursory examination was made, the use of a variable pattern might
    have sufficed to stymie the cryptanalysts.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 双重间谍吉福德并未了解玛丽使用的密码的细节。现在，假设玛丽使用了空密码。如果通信内容有些许叛国情节——虽然不至于构成叛国罪——信息可能被她的捕获者忽略。如果进行过初步检查，使用变换模式可能足以让密码分析师无法破解。
- en: As you have seen, it’s easier to hide a null cipher in a list than in a letter.
    A list of families supporting Mary could serve the purpose. These could be known
    supporters or, in a Machiavellian twist, a mix of friends *and* enemies! This
    message wouldn’t be openly seditious, but would be close enough so that a lack
    of encryption would suggest no form of encryption was being used at all.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，将空密码隐藏在列表中比隐藏在信件中更容易。支持玛丽的家族列表可以作为这种用途。这些家族可能是已知的支持者，或者在马基雅维利式的扭曲中，可能是朋友*和*敌人的混合！这个信息不会公开反叛，但会足够接近，以至于没有加密会让人认为根本没有使用任何加密形式。
- en: For this practice project, write a program that embeds the message “Give your
    word and we rise” in a list of surnames. To hide the letters in the message, start
    at the second letter in the second name, move to the third letter in the third
    name, and then keep alternating between second and third letters for the remaining
    words.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个实践项目，编写一个程序，将“Give your word and we rise”这句话嵌入姓氏列表中。为了隐藏消息中的字母，从第二个姓氏的第二个字母开始，移动到第三个姓氏的第三个字母，然后在剩下的单词中交替使用第二个和第三个字母。
- en: 'In addition to the unused first name, include “Stuart” and “Jacob” as null
    words early in the list to help hide the presence of the cipher. Don’t embed letters
    from the cipher in these null names and completely ignore them when choosing the
    letter position for the cipher in the following word; if the second letter was
    used in the word *before* the null name, use the third letter in the word *after*
    the null name. The null cipher would occupy the following bolded letters (the
    location of the null words is up to you, but don’t let them affect the pattern):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 除了未使用的第一个名字外，还在列表早期包含“斯图尔特”和“雅各布”作为空字词，帮助隐藏密码的存在。不要在这些空名字中嵌入密码的字母，并在选择下一个单词的密码字母位置时完全忽略它们；如果在空名字*之前*的单词中使用了第二个字母，则应在空名字*之后*的单词中使用第三个字母。空密码将占据以下加粗字母（空字词的位置由你决定，但不要让它们影响模式）：
- en: First Second Third STUART Fourth Fifth JACOB Sixth Seventh Eighth
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 第一 第二 第三 斯图尔特 第四 第五 雅各布 第六 第七 第八
- en: The program can print the list either vertically or horizontally. The name list
    should be credibly introduced with a short message, but that message shouldn’t
    be part of the cipher.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 程序可以以垂直或水平的方式打印列表。名字列表应该以简短的消息可信地介绍，但该消息不应成为密码的一部分。
- en: The list of names can be downloaded from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    as *supporters.txt* and loaded as a standard dictionary file. You can find a solution
    in the appendix and online as *save_Mary_practice.py*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 名字列表可以从*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*下载，文件名为*supporters.txt*，并作为标准字典文件加载。你可以在附录和在线找到解决方案，文件名为*save_Mary_practice.py*。
- en: '***The Colchester Catch***'
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***科尔切斯特的捕捉***'
- en: 'Instead of some ale-sotted dimwit, *you* are left in charge of the prisoner
    John Trevanion when the following letter arrives at Colchester Castle:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 不是某个酒醉的傻瓜，*你*被留下来负责囚犯约翰·特雷瓦尼翁的事务，当以下信件到达科尔切斯特城堡时：
- en: 'Sir John: Odd and too hard, your lot. Still, we will band together and, like
    you, persevere. Who else could love their enemies, stand firm when all others
    fail, hate and despair? While we all can, let us feel hope. -R.T.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰爵士：你们这群人奇怪且过于坚硬。然而，我们会团结起来，像你一样坚持到底。还有谁能爱他们的敌人，当所有人都失败时站稳脚跟，仇恨与绝望？只要我们还能够，让我们感受到希望。
    -R.T.
- en: It seems clumsily phrased, even for the 17th century, and you decide to examine
    it more closely before passing it to your inmate.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 它似乎表述笨拙，即使对于17世纪来说也是如此，你决定在将它交给囚犯之前仔细检查一下。
- en: 'Write a Python program that takes an input, *n*, and checks for and displays
    a null cipher based on the *n*th letter after the start of every *n*th word. For
    example, an input of 2 would find the bolded letters in this message:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个Python程序，接受一个输入*n*，并根据每个第*n*个单词的第*n*个字母检查并显示一个空密码。例如，输入2会在此消息中找到加粗字母：
- en: So, t**h**e cold t**e**a didn’t p**l**ease the o**l**d finicky w**o**man.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，t**h**e cold t**e**a didn’t p**l**ease the o**l**d finicky w**o**man.
- en: You can download the text file of the message from *[https://nostarch.com/impracticalpython/](https://nostarch.com/impracticalpython/)*
    as *colchester_message.txt*. A solution can be found in the appendix and online
    as *colchester_practice.py*. Keep the text and Python files together in the same
    folder.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从*[https://nostarch.com/impracticalpython/](https://nostarch.com/impracticalpython/)*下载消息的文本文件，文件名为*colchester_message.txt*。解决方案可以在附录和在线找到，文件名为*colchester_practice.py*。请将文本和Python文件放在同一文件夹中。
