- en: '**5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ENCODING ENGLISH CIVIL WAR CIPHERS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: In 1587, Mary, Queen of Scots, lost her head due to a scrap of paper. Fifty-five
    years later, Sir John Trevanion, a supporter of another beheaded monarch, Charles
    the First, had his head saved by a scrap of paper. What made the difference? Steganography.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '*Steganography* is the time-tested practice of concealing messages so well
    that their existence isn’t even suspected. The name is based on the Greek words
    for “covered writing,” and a very literal Grecian example was to take wax-covered
    wooden tablets used for writing, scrape off the wax, write on the wood, and then
    cover the board with a new coating of smooth wax. A modern-day example is to embed
    a message in an image by subtly altering its color components. Even a simple 8-bit
    JPEG image contains more colors than the human eye can detect, so without digital
    processing or filtering, the message is essentially invisible.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll work with the *null cipher*, which isn’t a cipher at
    all but a steganographic technique for concealing plaintext within other strings
    of noncipher material. *Null* means “none,” so with a null cipher, you have chosen
    not to encrypt the message. The following is an example of a null cipher using
    the first letter in every word:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '**N**ice **u**ncles **l**ive **l**onger. **C**ruel, **i**nsensitive **p**eople
    **h**ave **e**ternal **r**egrets.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: First, you’ll write code that finds the hidden message that saved Sir John,
    and then you’ll accomplish the much more difficult task of writing a null cipher.
    Finally, you’ll get the opportunity to write a program that might have saved Mary’s
    head, had she used the output.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #10: The Trevanion Cipher**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Queen Mary relied on both steganography and encryption to protect her messages.
    The strategy was sound, but her application was flawed. Unknowingly, she relied
    on a double agent named Gilbert Gifford to smuggle her messages. Gifford first
    delivered them to Queen Elizabeth’s spymaster, who cracked the cipher and replaced
    it with a forged message that enticed Mary to incriminate herself. The rest, as
    they say, is history.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: For John Trevanion, the outcome was rosier. Sir John, a distinguished cavalier
    who aided Charles I against Oliver Cromwell in the English Civil War, was captured
    and imprisoned in Colchester Castle. The day before his execution, he received
    a letter from one of his friends. The letter was not smuggled in but delivered
    straight into the hands of his jailors, who examined it but didn’t notice any
    deception. After reading it, Sir John asked for some time alone to pray in the
    chapel. When his jailors came back to fetch him, he had vanished.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the message Sir John received:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Worthie Sir John: Hope, that is the beste comfort of the afflicted, cannot
    much, I fear me, help you now. That I would saye to you, is this only: if ever
    I may be able to requite that I do owe you, stand not upon asking me. ''Tis not
    much I can do: but what I can do, bee you verie sure I wille. I knowe that, if
    deathe comes, if ordinary men fear it, it frights not you, accounting for it for
    a high honour, to have such a rewarde of your loyalty. Pray yet that you may be
    spared this soe bitter, cup. I fear not that you will grudge any sufferings; onlie
    if bie submission you can turn them away, ''tis the part of a wise man. Tell me,
    an if you can, to do for you anythinge that you wolde have done. The general goes
    back on Wednesday. Restinge your servant to command. R.T.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'As you have probably guessed, this seemingly innocent letter contains a hidden
    message, revealed below in bold:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Worthie Sir John: Ho**p**e, th**a**t is the beste comfort of the afflicted,
    ca**n**not much, I f**e**ar me, he**l**p you now. Th**a**t I would saye to you,
    is **t**his only: if **e**ver I may be able to requite that I do owe you, st**a**nd
    not upon asking me. ''Ti**s** not much I can do: bu**t** what I can do, be**e**
    you verie sure I wille. I k**n**owe that, if **d**eathe comes, if **o**rdinary
    men fear it, it **f**rights not you, ac**c**ounting for it for a high honour,
    to **h**ave such a rewarde of your loyalty. Pr**a**y yet that you may be spared
    this soe bitter, cu**p**. I f**e**ar not that you will grudge any sufferings;
    on**l**ie if bie submission you can turn them away, ''ti**s** the part of a wise
    man. Te**l**l me, an **i**f you can, to **d**o for you anythinge that you wolde
    have done. Th**e** general goes back on Wednesday. Re**s**tinge your servant to
    command. R.T.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: This null cipher uses every third letter after a punctuation mark to let Sir
    John know that a “panel at east end of chapel slides.” It’s rumored that the remains
    of a narrow stairway were later discovered in a recess in a wall in the castle.
    The passage was blocked at the time of discovery, but it may have been Sir John’s
    escape route around 1642.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: This last-minute escape would not have been possible with a traditional cipher.
    Only by expertly concealing the message with steganography was its author able
    to get it so quickly into Sir John’s hands. And the beauty of a null cipher is
    that, even if Sir John didn’t know the pattern but suspected a message was present,
    he could have found it fairly quickly.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: If Sir John’s friend had been more careful, concealing encrypted ciphertext
    instead of plaintext, Sir John probably wouldn’t have deciphered the message in
    the short time he had remaining—unless he’d been informed beforehand of the cipher
    type and key.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '**THE OBJECTIVE**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Write code that finds the letters hidden after punctuation marks in a null cipher
    and lets the user choose the number of letters after a punctuation mark to search
    for a solution.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '***Strategy and Pseudocode***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Null ciphers rely on a repeating pattern known to both the sender and receiver.
    For example, every third word may be part of the real message or, better, the
    last letter of every third word. In the Trevanion cipher, it’s the third letter
    after a punctuation mark.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: To find the Trevanion cipher, assume punctuation marks are the signal to begin
    counting, and then write code that locates every *n*th letter after the mark and
    saves those letters to a string or list. Once you’ve worked out how to do this,
    you can easily edit the code to work with any starting point, such as every capitalized
    word, every second letter per word, or the starting letter of every third word.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The only real point of contention involves punctuation marks. For instance,
    did the null cipher’s writer *want* punctuation marks to be included in the plaintext?
    How do you handle a second punctuation mark within the desired count range? What
    happens if two punctuation marks occur in succession?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: If you take a close look at the Trevanion cipher, you should see that there
    are double punctuations caused by the repeated use of the word *’tis*. There is
    also a jumble of punctuation marks at the end of the message, where the writer
    provides his initials. To deal with this, Sir John and his friend may have established
    some rules before Sir John’s incarceration, or Sir John just used trial and error
    to work them out.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Based on the end of the message, punctuation marks aren’t included in the letter
    count. If Sir John’s friend had intended them to be, then the hidden message would
    end with a capital *T*, because the *T* is three *characters* after a punctuation
    mark, and crucially not three *letters* after. This means that, if the reader
    encounters a punctuation mark within the count limit, they have to restart their
    count.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'So these are the rules:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Initiate a letter count with every punctuation mark.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reset the count if a punctuation mark is encountered.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Punctuation marks cannot be part of the plaintext message.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since you may not know what the letter count should be, write the code so that
    it checks all counts up through a limit the user provides. The pseudocode is fairly
    straightforward:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Load a text file and strip it of whitespace
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Get user input on how many letters after punctuation to look ahead and examine
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Loop through number of letters from 1 to this lookahead value
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Start an empty string to hold the translation
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Start a counter
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Start a ➊first-found marker and set to False
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Loop through characters in the text
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: If character is punctuation
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Counter = 0
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: First-found = True
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, if ➋first-found is True
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Counter + 1
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: If counter = lookahead value
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Add character to translation string
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Display translation for this lookahead value
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Note that the first-found variable ➊ will remain False until a punctuation mark
    is encountered, after which it will be set to True ➋. This prevents the program
    from counting until the first punctuation mark is found.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re ready to write the code!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '***The Trevanion Cipher Code***'
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code in this section will find a Trevanion-type null cipher encoded with
    a specific number of letters after each punctuation mark. You will also need the
    text file containing the Trevanion cipher. You can download both the script and
    the text file from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    as *null_cipher_finder.py* and *trevanion.txt*, respectively. Keep these files
    in the same folder.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '**Loading the Text**'
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 5-1](ch05.xhtml#ch05list1) imports some useful modules and loads the
    text file containing the null cipher.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '*null_cipher_finder.py,* part 1'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: ➊ import sys
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: import string
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '➋ def load_text(file):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '"""Load a text file as a string."""'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '➌ with open(file) as f:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: ➍ return f.read().strip()
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-1: Imports modules and loads the null cipher text*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: First, import the now-familiar sys module so you can handle exceptions that
    may occur during user input ➊. Also import the string module to gain access to
    useful collections of constants, like letters and punctuation marks.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Next, define a function to load the text file containing the null cipher ➋.
    This function is similar to the one you used to load a dictionary file in [Chapter
    2](ch02.xhtml#ch02). It will be called by the main()function later to actually
    load the file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Start the load_text() function by using with to open the file ➌. By using with,
    you know the file will be automatically closed after it is loaded. Use read()
    to load the contents and strip() to remove leading and trailing whitespace. Note
    that you can do this on the same line with the return statement ➍.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding the Hidden Message**'
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 5-2](ch05.xhtml#ch05list2) defines the function that finds the hidden
    message. It takes two arguments. The first is the message, which is the original
    text file as a string stripped of whitespace, and the second is the number of
    letters to check after a punctuation mark. This check value is obtained from the
    user as part of the main() function.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '*null_cipher_finder.py,* part 2'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'def solve_null_cipher(message, lookahead):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '"""Solve a null cipher based on number of letters after punctuation mark.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: message = null cipher text as string stripped of whitespace
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: lookahead = endpoint of range of letters after punctuation mark to examine
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '➊ for i in range(1, lookahead + 1):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: ➋ plaintext = ''
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: count = 0
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: found_first = False
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '➌ for char in message:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '➍ if char in string.punctuation:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: count = 0
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: found_first = True
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '➎ elif found_first is True:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '➏ if count == i:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: plaintext += char
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: ➐ print("Using offset of {} after punctuation = {}".
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: format(i, plaintext))
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: print()
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-2: Searches for hidden letters*'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Treat the lookahead value as the endpoint of a range in a for loop so that you
    can check all the intervening letters in the message for the presence of a hidden
    message. Set the range as (1, lookahead + 1) ➊; that way, you start with the first
    letter after a punctuation mark and include the user’s choice in the evaluation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Now, assign a few variables ➋. First, initialize an empty string to hold the
    translated plaintext. Then set a counter to 0. Finally, set a found_first variable
    to False. Remember that the program uses this variable to defer counting until
    the first punctuation mark is encountered.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Next, begin looping through the characters in the message ➌. If you encounter
    a punctuation mark, reset the counter to 0 and set found_first to True ➍. If you’ve
    found a punctuation mark already and the current character isn’t punctuation,
    advance the counter by 1 ➎. If you’ve found the letter you’re looking for—meaning
    the count has reached the current lookahead value (i)—add the letter to the plaintext
    string ➏.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve examined all the characters in the message for the current lookahead
    value, display the current key and the translation ➐.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the main() Function**'
  id: totrans-91
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 5-3](ch05.xhtml#ch05list3) defines the main() function. You may remember
    from [Chapter 3](ch03.xhtml#ch03) that the main() function is like your program’s
    project manager: it takes input, keeps track of progress, and tells the other
    functions when to work.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '*null_cipher_finder.py,* part 3'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '"""Load text, solve null cipher."""'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '# load & process message:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '➊ filename = input("\nEnter full filename for message to translate: ")'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '➋ try:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: loaded_message = load_text(filename)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'except IOError as e:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: print("{}. Terminating program.".format(e), file=sys.stderr)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit(1)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: ➌ print("\nORIGINAL MESSAGE =")
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: print("{}".format(loaded_message), "\n")
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: print("\nList of punctuation marks to check = {}".
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: format(string.punctuation), "\n")
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '# remove whitespace:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: ➍ message = ''.join(loaded_message.split())
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '# get range of possible cipher keys from user:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '➎ while True:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: ➏ lookahead = input("\nNumber of letters to check after " \
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '"punctuation mark: ")'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '➐ if lookahead.isdigit():'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: lookahead = int(lookahead)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: break
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: ➑ print("Please input a number.", file=sys.stderr)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: print()
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '# run function to decode cipher'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: ➒ solve_null_cipher(message, lookahead)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-3: Defines the* main() *function*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Start by asking the user for the name of the file (name + extension) ➊, and
    then use try to call the load_text() function ➋. If the file can’t be found, print
    the error in red—for those using the IDLE window—and exit the program using sys.exit(1),
    where the 1 indicates termination with an error.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Print the message followed by the list of punctuation marks in the string module
    ➌. Only the characters in this list will be recognized by the program as punctuation.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Next, take the loaded message and remove all spaces ➍. You’re going to count
    only letters and punctuation marks, so spaces would just get in the way. Start
    a while loop that keeps asking the user for input in the event they enter a bad
    value ➎. Ask the user for the number of letters to check after a punctuation mark
    ➏. This will be treated as a range, starting with 1 and ending with the user’s
    choice plus 1\. If the input value is a digit ➐, turn it into an integer, since
    input returns a string. Then, use break to exit the loop.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，取出加载的消息并移除所有空格➍。你只需要计算字母和标点符号，所以空格会妨碍你。启动一个while循环，在用户输入无效值时持续请求输入➎。询问用户每个标点符号后的字母数量➏。这将被当作一个范围，起始为1，结束为用户选择的数字加1。如果输入值是数字➐，将其转换为整数，因为输入会返回字符串。然后，使用break退出循环。
- en: If the user enters an invalid value, like “Bob,” use a print statement to request
    a number and, for shell users, make the font red using sys.stderr ➑. The while
    loop will then repeat the request for input.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户输入了无效值，比如“Bob”，使用print语句请求输入一个数字，并且对于shell用户，使用sys.stderr将字体变为红色➑。然后，while循环会重复请求输入。
- en: Pass the lookahead variable, along with the message, to the solve_null_cipher
    function ➒. Now all that’s left is to call the main() function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将前瞻变量与消息一起传递给solve_null_cipher函数➒。现在剩下的就是调用main()函数了。
- en: '**Running the main() Function**'
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**运行main()函数**'
- en: Back in the global space, complete the code by calling main()—but only if the
    program is run in stand-alone mode versus being imported into another program
    ([Listing 5-4](ch05.xhtml#ch05list4)).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 回到全局空间，通过调用main()来完成代码——但只有在程序以独立模式运行，而不是被导入到另一个程序时（[清单5-4](ch05.xhtml#ch05list4)）。
- en: '*null_cipher_finder.py,* part 4'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*null_cipher_finder.py,* 第4部分'
- en: 'if __name__ == ''__main__'':'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 __name__ == ''__main__'':'
- en: main()
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: '*Listing 5-4: Calls the* main() *function*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单5-4：调用* main() *函数*'
- en: 'The following is example output from the completed program, using the Trevanion
    cipher as input:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Trevanion密码作为输入的完整程序的示例输出：
- en: 'Enter full filename for message to translate: trevanion.txt'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 输入要翻译的完整文件名：trevanion.txt
- en: ORIGINAL MESSAGE =
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 原始消息 =
- en: 'Worthie Sir John: Hope, that is the beste comfort of the afflicted, cannot'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 尊敬的约翰先生：希望，这是患难中的最好安慰。
- en: 'much, I fear me, help you now. That I would saye to you, is this only: if ever'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我担心，我现在无法为你提供太多帮助。我要对你说的是，这只是：如果曾经
- en: I may be able to requite that I do owe you, stand not upon asking me. 'Tis not
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我也许能够回报我欠你的，不必再问我。‘’这不是
- en: 'much I can do: but what I can do, bee you verie sure I wille. I knowe that,'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我能做的有限：但我能做的事，你可以很确信我会做。我知道，
- en: if deathe comes, if ordinary men fear it, it frights not you, accounting for
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果死亡来临，如果普通人害怕它，它不会吓到你，原因是
- en: it for a high honour, to have such a rewarde of your loyalty. Pray yet that
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了一个崇高的荣誉，拥有你忠诚的回报。祈祷吧，
- en: you may be spared this soe bitter, cup. I fear not that you will grudge any
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会避免这杯苦酒。我不担心你会为此有所怨言
- en: sufferings; onlie if bie submission you can turn them away, 'tis the part of
    a
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 苦难；只有如果通过提交，你才能驱赶它们，这是
- en: wise man. Tell me, an if you can, to do for you anythinge that you wolde have
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 智者。告诉我，如果你能的话，做任何你想做的事。
- en: done. The general goes back on Wednesday. Restinge your servant to command.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将军将在星期三返回。休息，我的仆人，命令我行。
- en: R.T.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: R.T.
- en: List of punctuation marks to check = !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查的标点符号列表 = !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
- en: 'Number of letters to check after punctuation mark: 4'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查的标点符号后的字母数：4
- en: Using offset of 1 after punctuation = HtcIhTiisTbbIiiiatPcIotTatTRRT
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标点符号后偏移量为1 = HtcIhTiisTbbIiiiatPcIotTatTRRT
- en: Using offset of 2 after punctuation = ohafehsftiuekfftcorufnienohe
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标点符号后偏移量为2 = ohafehsftiuekfftcorufnienohe
- en: Using offset of 3 after punctuation = panelateastendofchapelslides
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标点符号后偏移量为3 = panelateastendofchapelslides
- en: Using offset of 4 after punctuation = etnapthvnnwyoerroayaitlfogt
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标点符号后偏移量为4 = etnapthvnnwyoerroayaitlfogt
- en: In this output, the program has checked up to the fourth letter after a punctuation
    mark, but as you can see, it finds the solution using three letters after a punctuation
    mark.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在此输出中，程序已检查了标点符号后的第四个字母，但正如你所见，它使用标点符号后的三个字母找到了答案。
- en: '**Project #11: Writing a Null Cipher**'
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目#11：编写一个空密码**'
- en: 'Here is an unfinished example of a very weak null cipher based on the start
    of each word. Take a minute and try to complete the sentence:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常弱的空密码的未完成示例，基于每个单词的开头。花一点时间试着完成这个句子：
- en: H__________ e__________ l__________ p__________ m__________ e__________.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: H__________ e__________ l__________ p__________ m__________ e__________。
- en: You probably found it difficult, because whether you use letters or even whole
    words, it takes hard work and time to produce a null cipher that doesn’t read
    awkwardly and arouse suspicion. The heart of the problem is context. If the cipher
    is encapsulated within correspondence, that correspondence has to be coherent
    to avoid suspicion. That means it has to address a relevant topic and stay true
    to that topic for a reasonable number of sentences. As you probably saw, drafting
    even one sentence on any topic is no easy task!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The key is to credibly avoid context, and a good way to do this is with a list.
    No one expects a shopping list to be rigidly organized or make sense. Lists can
    also be tailored to the receiver. For example, correspondents might get into a
    discussion of books or movies and exchange lists of their favorites. A prisoner
    might start studying a foreign language and receive regular vocabulary lists from
    their tutor. A businessperson might get monthly inventories from one of their
    warehouses. With lists, context is honored even while words are shuffled so the
    correct letter is found in the correct place.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '**THE OBJECTIVE**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Write code that hides a null cipher within a list of words.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '***The List Cipher Code***'
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *list_cipher.py* code, in [Listing 5-5](ch05.xhtml#ch05list5), embeds a
    null cipher within a list of dictionary words under the deception of vocabulary
    training. You’ll also need the *load_dictionary.py* program you used in [Chapters
    2](ch02.xhtml#ch02) and [3](ch03.xhtml#ch03). You can download this file, along
    with the following script, from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    Finally, you’ll need one of the dictionary files you used in [Chapters 2](ch02.xhtml#ch02)
    and [3](ch03.xhtml#ch03). You can find a list of suitable online dictionaries
    in [Table 2-1](ch02.xhtml#ch02tab1) on [page 20](ch02.xhtml#page_20). All of the
    aforementioned files should be kept in the same folder.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '*list_cipher.py*'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: ➊ from random import randint
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: import string
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: import load_dictionary
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '# write a short message that doesn''t contain punctuation or numbers!'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: input_message = "Panel at east end of chapel slides"
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: message = ''
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'for char in input_message:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '➋ if char in string.ascii_letters:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: message += char
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: print(message, "\n")
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: ➌ message = "".join(message.split())
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '➍ # open dictionary file'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: word_list = load_dictionary.load('2of4brif.txt')
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '# build vocabulary word list with hidden message'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: ➎ vocab_list = []
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '➏ for letter in message:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: size = randint(6, 10)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '➐ for word in word_list:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: if len(word) == size and word[2].lower() == letter.lower()\
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'and word not in vocab_list:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: vocab_list.append(word)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: break
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '➑ if len(vocab_list) < len(message):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: print("Word List is too small. Try larger dictionary or shorter message!")
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Vocabulary words for Unit 1: \n", *vocab_list, sep="\n")'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-5: Hides null cipher in a list*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Start by importing the random module’s randint() function ➊. This permits the
    (pseudo)random selection of an integer value. Then load the string module, for
    access to ASCII letters. Finish by importing your load_dictionary module.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, write a short secret message. Note that the associated comment forbids
    punctuation marks or numbers. Trying to use these with a dictionary file’s contents
    would be problematic. So, filter out everything but letters by checking for membership
    in string.ascii_letters, which contains both uppercase and lowercase letters ➋:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '''abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'''
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Display the message and then remove the whitespace ➌. Load your dictionary file
    ➍ and start an empty list to hold the vocabulary words ➎.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Use a for loop to go through each letter in the message ➏. Name a size variable
    and assign it a random value between 6 and 10 using the randint() function. This
    variable will ensure the words are long enough to be credible as vocabulary words.
    You can set the maximum value higher if you wish.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Nest another for loop and use it to go through the dictionary words ➐, checking
    their length against the size variable and comparing the (lowercase) letter at
    index 2—the word’s third letter—to the current (lowercase) letter in the message
    loop. You can change the index value on the word, but make sure it doesn’t exceed
    the lowest possible size variable minus 1! A final comparison prevents the same
    word from being used twice. If the word passes the tests, append it to vocab_list
    and move on to the next letter in the message.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: A typical dictionary file should contain enough words to encrypt a short message.
    But, to be safe, use a conditional to check that the length of vocab_list is not
    shorter than the length of the message ➑. If it’s shorter, then you ran out of
    words before reaching the end of the message, and you need to print a warning
    for the user. Otherwise, print the list of words.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '***The List Cipher Output***'
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is the output from the code (I’ve highlighted every third letter for readability,
    though the message is pretty easy to spot without any aid):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Panelateastendofchapelslides
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Vocabulary words for Unit 1:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: alphabets
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: abandoning
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: annals
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: aberration
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: ablaze
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: abandoned
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: acting
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: abetted
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: abasement
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: abseil
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: activated
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: adequately
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: abnormal
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: abdomen
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: abolish
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: affecting
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: acceding
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: abhors
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: abalone
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: ampersands
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: acetylene
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: allegation
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: absconds
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: aileron
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: acidifying
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: abdicating
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: adepts
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: absent
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Using a font with a consistent character width and stacking the words really
    compromises the cipher. We’ll look at ways to deal with this in “[Saving Mary](ch05.xhtml#lev128)”
    on [page 102](ch05.xhtml#page_102).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you wrote a program that reveals the hidden message in a Trevanion-type
    null cipher. Then, you wrote a second program that generates a null cipher and
    conceals it within a language learner’s vocabulary list. In the following practice
    projects, you can explore ways to make this list cipher more secure.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More details on Mary, Queen of Scots, and Sir John Trevanion can be found in
    *Mysterious Messages: A History of Codes and Ciphers* (The Penguin Group, 2009)
    by Gary Blackwood and *The Code Book: The Science of Secrecy from Ancient Egypt
    to Quantum Cryptography* (Anchor, 2000) by Simon Singh.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Projects**'
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’re an expert on the null cipher, see if you can change the fate
    of Mary, Queen of Scots, and then sneak a look at Sir John’s most secret correspondence.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '***Saving Mary***'
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The best part of coding is thinking about problems and how to solve them. Let’s
    revisit the sad case of Mary, Queen of Scots. Here’s what we know:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Mary was not allowed correspondence, so letters had to be smuggled in. This
    means that the traitorous Gilbert Gifford cannot be removed from the equation.
    Gifford was the only person Mary knew with the means to deliver her mail.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mary and her correspondents put too much faith in an insecure cipher and thus
    spoke too freely. With less confidence, they might have shown more forbearance.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mary’s jailors, having an obvious cipher in their possession, assumed it contained
    incriminating material and kept working until they found it.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gifford, the double agent, wasn’t privy to the details of the ciphers Mary used.
    Now, assume Mary used a null cipher. If the correspondence was somewhat seditious—though
    not treasonously so—the message might have been overlooked by her captors. In
    the event a cursory examination was made, the use of a variable pattern might
    have sufficed to stymie the cryptanalysts.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: As you have seen, it’s easier to hide a null cipher in a list than in a letter.
    A list of families supporting Mary could serve the purpose. These could be known
    supporters or, in a Machiavellian twist, a mix of friends *and* enemies! This
    message wouldn’t be openly seditious, but would be close enough so that a lack
    of encryption would suggest no form of encryption was being used at all.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: For this practice project, write a program that embeds the message “Give your
    word and we rise” in a list of surnames. To hide the letters in the message, start
    at the second letter in the second name, move to the third letter in the third
    name, and then keep alternating between second and third letters for the remaining
    words.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the unused first name, include “Stuart” and “Jacob” as null
    words early in the list to help hide the presence of the cipher. Don’t embed letters
    from the cipher in these null names and completely ignore them when choosing the
    letter position for the cipher in the following word; if the second letter was
    used in the word *before* the null name, use the third letter in the word *after*
    the null name. The null cipher would occupy the following bolded letters (the
    location of the null words is up to you, but don’t let them affect the pattern):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: First Second Third STUART Fourth Fifth JACOB Sixth Seventh Eighth
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: The program can print the list either vertically or horizontally. The name list
    should be credibly introduced with a short message, but that message shouldn’t
    be part of the cipher.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: The list of names can be downloaded from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    as *supporters.txt* and loaded as a standard dictionary file. You can find a solution
    in the appendix and online as *save_Mary_practice.py*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '***The Colchester Catch***'
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Instead of some ale-sotted dimwit, *you* are left in charge of the prisoner
    John Trevanion when the following letter arrives at Colchester Castle:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Sir John: Odd and too hard, your lot. Still, we will band together and, like
    you, persevere. Who else could love their enemies, stand firm when all others
    fail, hate and despair? While we all can, let us feel hope. -R.T.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: It seems clumsily phrased, even for the 17th century, and you decide to examine
    it more closely before passing it to your inmate.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a Python program that takes an input, *n*, and checks for and displays
    a null cipher based on the *n*th letter after the start of every *n*th word. For
    example, an input of 2 would find the bolded letters in this message:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: So, t**h**e cold t**e**a didn’t p**l**ease the o**l**d finicky w**o**man.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: You can download the text file of the message from *[https://nostarch.com/impracticalpython/](https://nostarch.com/impracticalpython/)*
    as *colchester_message.txt*. A solution can be found in the appendix and online
    as *colchester_practice.py*. Keep the text and Python files together in the same
    folder.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
