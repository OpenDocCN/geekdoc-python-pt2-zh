- en: '**5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ENCODING ENGLISH CIVIL WAR CIPHERS**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In 1587, Mary, Queen of Scots, lost her head due to a scrap of paper. Fifty-five
    years later, Sir John Trevanion, a supporter of another beheaded monarch, Charles
    the First, had his head saved by a scrap of paper. What made the difference? Steganography.
  prefs: []
  type: TYPE_NORMAL
- en: '*Steganography* is the time-tested practice of concealing messages so well
    that their existence isn’t even suspected. The name is based on the Greek words
    for “covered writing,” and a very literal Grecian example was to take wax-covered
    wooden tablets used for writing, scrape off the wax, write on the wood, and then
    cover the board with a new coating of smooth wax. A modern-day example is to embed
    a message in an image by subtly altering its color components. Even a simple 8-bit
    JPEG image contains more colors than the human eye can detect, so without digital
    processing or filtering, the message is essentially invisible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll work with the *null cipher*, which isn’t a cipher at
    all but a steganographic technique for concealing plaintext within other strings
    of noncipher material. *Null* means “none,” so with a null cipher, you have chosen
    not to encrypt the message. The following is an example of a null cipher using
    the first letter in every word:'
  prefs: []
  type: TYPE_NORMAL
- en: '**N**ice **u**ncles **l**ive **l**onger. **C**ruel, **i**nsensitive **p**eople
    **h**ave **e**ternal **r**egrets.'
  prefs: []
  type: TYPE_NORMAL
- en: First, you’ll write code that finds the hidden message that saved Sir John,
    and then you’ll accomplish the much more difficult task of writing a null cipher.
    Finally, you’ll get the opportunity to write a program that might have saved Mary’s
    head, had she used the output.
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #10: The Trevanion Cipher**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Queen Mary relied on both steganography and encryption to protect her messages.
    The strategy was sound, but her application was flawed. Unknowingly, she relied
    on a double agent named Gilbert Gifford to smuggle her messages. Gifford first
    delivered them to Queen Elizabeth’s spymaster, who cracked the cipher and replaced
    it with a forged message that enticed Mary to incriminate herself. The rest, as
    they say, is history.
  prefs: []
  type: TYPE_NORMAL
- en: For John Trevanion, the outcome was rosier. Sir John, a distinguished cavalier
    who aided Charles I against Oliver Cromwell in the English Civil War, was captured
    and imprisoned in Colchester Castle. The day before his execution, he received
    a letter from one of his friends. The letter was not smuggled in but delivered
    straight into the hands of his jailors, who examined it but didn’t notice any
    deception. After reading it, Sir John asked for some time alone to pray in the
    chapel. When his jailors came back to fetch him, he had vanished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the message Sir John received:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Worthie Sir John: Hope, that is the beste comfort of the afflicted, cannot
    much, I fear me, help you now. That I would saye to you, is this only: if ever
    I may be able to requite that I do owe you, stand not upon asking me. ''Tis not
    much I can do: but what I can do, bee you verie sure I wille. I knowe that, if
    deathe comes, if ordinary men fear it, it frights not you, accounting for it for
    a high honour, to have such a rewarde of your loyalty. Pray yet that you may be
    spared this soe bitter, cup. I fear not that you will grudge any sufferings; onlie
    if bie submission you can turn them away, ''tis the part of a wise man. Tell me,
    an if you can, to do for you anythinge that you wolde have done. The general goes
    back on Wednesday. Restinge your servant to command. R.T.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you have probably guessed, this seemingly innocent letter contains a hidden
    message, revealed below in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Worthie Sir John: Ho**p**e, th**a**t is the beste comfort of the afflicted,
    ca**n**not much, I f**e**ar me, he**l**p you now. Th**a**t I would saye to you,
    is **t**his only: if **e**ver I may be able to requite that I do owe you, st**a**nd
    not upon asking me. ''Ti**s** not much I can do: bu**t** what I can do, be**e**
    you verie sure I wille. I k**n**owe that, if **d**eathe comes, if **o**rdinary
    men fear it, it **f**rights not you, ac**c**ounting for it for a high honour,
    to **h**ave such a rewarde of your loyalty. Pr**a**y yet that you may be spared
    this soe bitter, cu**p**. I f**e**ar not that you will grudge any sufferings;
    on**l**ie if bie submission you can turn them away, ''ti**s** the part of a wise
    man. Te**l**l me, an **i**f you can, to **d**o for you anythinge that you wolde
    have done. Th**e** general goes back on Wednesday. Re**s**tinge your servant to
    command. R.T.'
  prefs: []
  type: TYPE_NORMAL
- en: This null cipher uses every third letter after a punctuation mark to let Sir
    John know that a “panel at east end of chapel slides.” It’s rumored that the remains
    of a narrow stairway were later discovered in a recess in a wall in the castle.
    The passage was blocked at the time of discovery, but it may have been Sir John’s
    escape route around 1642.
  prefs: []
  type: TYPE_NORMAL
- en: This last-minute escape would not have been possible with a traditional cipher.
    Only by expertly concealing the message with steganography was its author able
    to get it so quickly into Sir John’s hands. And the beauty of a null cipher is
    that, even if Sir John didn’t know the pattern but suspected a message was present,
    he could have found it fairly quickly.
  prefs: []
  type: TYPE_NORMAL
- en: If Sir John’s friend had been more careful, concealing encrypted ciphertext
    instead of plaintext, Sir John probably wouldn’t have deciphered the message in
    the short time he had remaining—unless he’d been informed beforehand of the cipher
    type and key.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE OBJECTIVE**'
  prefs: []
  type: TYPE_NORMAL
- en: Write code that finds the letters hidden after punctuation marks in a null cipher
    and lets the user choose the number of letters after a punctuation mark to search
    for a solution.
  prefs: []
  type: TYPE_NORMAL
- en: '***Strategy and Pseudocode***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Null ciphers rely on a repeating pattern known to both the sender and receiver.
    For example, every third word may be part of the real message or, better, the
    last letter of every third word. In the Trevanion cipher, it’s the third letter
    after a punctuation mark.
  prefs: []
  type: TYPE_NORMAL
- en: To find the Trevanion cipher, assume punctuation marks are the signal to begin
    counting, and then write code that locates every *n*th letter after the mark and
    saves those letters to a string or list. Once you’ve worked out how to do this,
    you can easily edit the code to work with any starting point, such as every capitalized
    word, every second letter per word, or the starting letter of every third word.
  prefs: []
  type: TYPE_NORMAL
- en: The only real point of contention involves punctuation marks. For instance,
    did the null cipher’s writer *want* punctuation marks to be included in the plaintext?
    How do you handle a second punctuation mark within the desired count range? What
    happens if two punctuation marks occur in succession?
  prefs: []
  type: TYPE_NORMAL
- en: If you take a close look at the Trevanion cipher, you should see that there
    are double punctuations caused by the repeated use of the word *’tis*. There is
    also a jumble of punctuation marks at the end of the message, where the writer
    provides his initials. To deal with this, Sir John and his friend may have established
    some rules before Sir John’s incarceration, or Sir John just used trial and error
    to work them out.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the end of the message, punctuation marks aren’t included in the letter
    count. If Sir John’s friend had intended them to be, then the hidden message would
    end with a capital *T*, because the *T* is three *characters* after a punctuation
    mark, and crucially not three *letters* after. This means that, if the reader
    encounters a punctuation mark within the count limit, they have to restart their
    count.
  prefs: []
  type: TYPE_NORMAL
- en: 'So these are the rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Initiate a letter count with every punctuation mark.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reset the count if a punctuation mark is encountered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Punctuation marks cannot be part of the plaintext message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since you may not know what the letter count should be, write the code so that
    it checks all counts up through a limit the user provides. The pseudocode is fairly
    straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: Load a text file and strip it of whitespace
  prefs: []
  type: TYPE_NORMAL
- en: Get user input on how many letters after punctuation to look ahead and examine
  prefs: []
  type: TYPE_NORMAL
- en: Loop through number of letters from 1 to this lookahead value
  prefs: []
  type: TYPE_NORMAL
- en: Start an empty string to hold the translation
  prefs: []
  type: TYPE_NORMAL
- en: Start a counter
  prefs: []
  type: TYPE_NORMAL
- en: Start a ➊first-found marker and set to False
  prefs: []
  type: TYPE_NORMAL
- en: Loop through characters in the text
  prefs: []
  type: TYPE_NORMAL
- en: If character is punctuation
  prefs: []
  type: TYPE_NORMAL
- en: Counter = 0
  prefs: []
  type: TYPE_NORMAL
- en: First-found = True
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, if ➋first-found is True
  prefs: []
  type: TYPE_NORMAL
- en: Counter + 1
  prefs: []
  type: TYPE_NORMAL
- en: If counter = lookahead value
  prefs: []
  type: TYPE_NORMAL
- en: Add character to translation string
  prefs: []
  type: TYPE_NORMAL
- en: Display translation for this lookahead value
  prefs: []
  type: TYPE_NORMAL
- en: Note that the first-found variable ➊ will remain False until a punctuation mark
    is encountered, after which it will be set to True ➋. This prevents the program
    from counting until the first punctuation mark is found.
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re ready to write the code!
  prefs: []
  type: TYPE_NORMAL
- en: '***The Trevanion Cipher Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The code in this section will find a Trevanion-type null cipher encoded with
    a specific number of letters after each punctuation mark. You will also need the
    text file containing the Trevanion cipher. You can download both the script and
    the text file from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    as *null_cipher_finder.py* and *trevanion.txt*, respectively. Keep these files
    in the same folder.
  prefs: []
  type: TYPE_NORMAL
- en: '**Loading the Text**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 5-1](ch05.xhtml#ch05list1) imports some useful modules and loads the
    text file containing the null cipher.'
  prefs: []
  type: TYPE_NORMAL
- en: '*null_cipher_finder.py,* part 1'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ import sys
  prefs: []
  type: TYPE_NORMAL
- en: import string
  prefs: []
  type: TYPE_NORMAL
- en: '➋ def load_text(file):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Load a text file as a string."""'
  prefs: []
  type: TYPE_NORMAL
- en: '➌ with open(file) as f:'
  prefs: []
  type: TYPE_NORMAL
- en: ➍ return f.read().strip()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-1: Imports modules and loads the null cipher text*'
  prefs: []
  type: TYPE_NORMAL
- en: First, import the now-familiar sys module so you can handle exceptions that
    may occur during user input ➊. Also import the string module to gain access to
    useful collections of constants, like letters and punctuation marks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, define a function to load the text file containing the null cipher ➋.
    This function is similar to the one you used to load a dictionary file in [Chapter
    2](ch02.xhtml#ch02). It will be called by the main()function later to actually
    load the file.
  prefs: []
  type: TYPE_NORMAL
- en: Start the load_text() function by using with to open the file ➌. By using with,
    you know the file will be automatically closed after it is loaded. Use read()
    to load the contents and strip() to remove leading and trailing whitespace. Note
    that you can do this on the same line with the return statement ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding the Hidden Message**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 5-2](ch05.xhtml#ch05list2) defines the function that finds the hidden
    message. It takes two arguments. The first is the message, which is the original
    text file as a string stripped of whitespace, and the second is the number of
    letters to check after a punctuation mark. This check value is obtained from the
    user as part of the main() function.'
  prefs: []
  type: TYPE_NORMAL
- en: '*null_cipher_finder.py,* part 2'
  prefs: []
  type: TYPE_NORMAL
- en: 'def solve_null_cipher(message, lookahead):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Solve a null cipher based on number of letters after punctuation mark.'
  prefs: []
  type: TYPE_NORMAL
- en: message = null cipher text as string stripped of whitespace
  prefs: []
  type: TYPE_NORMAL
- en: lookahead = endpoint of range of letters after punctuation mark to examine
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: '➊ for i in range(1, lookahead + 1):'
  prefs: []
  type: TYPE_NORMAL
- en: ➋ plaintext = ''
  prefs: []
  type: TYPE_NORMAL
- en: count = 0
  prefs: []
  type: TYPE_NORMAL
- en: found_first = False
  prefs: []
  type: TYPE_NORMAL
- en: '➌ for char in message:'
  prefs: []
  type: TYPE_NORMAL
- en: '➍ if char in string.punctuation:'
  prefs: []
  type: TYPE_NORMAL
- en: count = 0
  prefs: []
  type: TYPE_NORMAL
- en: found_first = True
  prefs: []
  type: TYPE_NORMAL
- en: '➎ elif found_first is True:'
  prefs: []
  type: TYPE_NORMAL
- en: count += 1
  prefs: []
  type: TYPE_NORMAL
- en: '➏ if count == i:'
  prefs: []
  type: TYPE_NORMAL
- en: plaintext += char
  prefs: []
  type: TYPE_NORMAL
- en: ➐ print("Using offset of {} after punctuation = {}".
  prefs: []
  type: TYPE_NORMAL
- en: format(i, plaintext))
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-2: Searches for hidden letters*'
  prefs: []
  type: TYPE_NORMAL
- en: Treat the lookahead value as the endpoint of a range in a for loop so that you
    can check all the intervening letters in the message for the presence of a hidden
    message. Set the range as (1, lookahead + 1) ➊; that way, you start with the first
    letter after a punctuation mark and include the user’s choice in the evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Now, assign a few variables ➋. First, initialize an empty string to hold the
    translated plaintext. Then set a counter to 0. Finally, set a found_first variable
    to False. Remember that the program uses this variable to defer counting until
    the first punctuation mark is encountered.
  prefs: []
  type: TYPE_NORMAL
- en: Next, begin looping through the characters in the message ➌. If you encounter
    a punctuation mark, reset the counter to 0 and set found_first to True ➍. If you’ve
    found a punctuation mark already and the current character isn’t punctuation,
    advance the counter by 1 ➎. If you’ve found the letter you’re looking for—meaning
    the count has reached the current lookahead value (i)—add the letter to the plaintext
    string ➏.
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve examined all the characters in the message for the current lookahead
    value, display the current key and the translation ➐.
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the main() Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 5-3](ch05.xhtml#ch05list3) defines the main() function. You may remember
    from [Chapter 3](ch03.xhtml#ch03) that the main() function is like your program’s
    project manager: it takes input, keeps track of progress, and tells the other
    functions when to work.'
  prefs: []
  type: TYPE_NORMAL
- en: '*null_cipher_finder.py,* part 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: '"""Load text, solve null cipher."""'
  prefs: []
  type: TYPE_NORMAL
- en: '# load & process message:'
  prefs: []
  type: TYPE_NORMAL
- en: '➊ filename = input("\nEnter full filename for message to translate: ")'
  prefs: []
  type: TYPE_NORMAL
- en: '➋ try:'
  prefs: []
  type: TYPE_NORMAL
- en: loaded_message = load_text(filename)
  prefs: []
  type: TYPE_NORMAL
- en: 'except IOError as e:'
  prefs: []
  type: TYPE_NORMAL
- en: print("{}. Terminating program.".format(e), file=sys.stderr)
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit(1)
  prefs: []
  type: TYPE_NORMAL
- en: ➌ print("\nORIGINAL MESSAGE =")
  prefs: []
  type: TYPE_NORMAL
- en: print("{}".format(loaded_message), "\n")
  prefs: []
  type: TYPE_NORMAL
- en: print("\nList of punctuation marks to check = {}".
  prefs: []
  type: TYPE_NORMAL
- en: format(string.punctuation), "\n")
  prefs: []
  type: TYPE_NORMAL
- en: '# remove whitespace:'
  prefs: []
  type: TYPE_NORMAL
- en: ➍ message = ''.join(loaded_message.split())
  prefs: []
  type: TYPE_NORMAL
- en: '# get range of possible cipher keys from user:'
  prefs: []
  type: TYPE_NORMAL
- en: '➎ while True:'
  prefs: []
  type: TYPE_NORMAL
- en: ➏ lookahead = input("\nNumber of letters to check after " \
  prefs: []
  type: TYPE_NORMAL
- en: '"punctuation mark: ")'
  prefs: []
  type: TYPE_NORMAL
- en: '➐ if lookahead.isdigit():'
  prefs: []
  type: TYPE_NORMAL
- en: lookahead = int(lookahead)
  prefs: []
  type: TYPE_NORMAL
- en: break
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: ➑ print("Please input a number.", file=sys.stderr)
  prefs: []
  type: TYPE_NORMAL
- en: print()
  prefs: []
  type: TYPE_NORMAL
- en: '# run function to decode cipher'
  prefs: []
  type: TYPE_NORMAL
- en: ➒ solve_null_cipher(message, lookahead)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-3: Defines the* main() *function*'
  prefs: []
  type: TYPE_NORMAL
- en: Start by asking the user for the name of the file (name + extension) ➊, and
    then use try to call the load_text() function ➋. If the file can’t be found, print
    the error in red—for those using the IDLE window—and exit the program using sys.exit(1),
    where the 1 indicates termination with an error.
  prefs: []
  type: TYPE_NORMAL
- en: Print the message followed by the list of punctuation marks in the string module
    ➌. Only the characters in this list will be recognized by the program as punctuation.
  prefs: []
  type: TYPE_NORMAL
- en: Next, take the loaded message and remove all spaces ➍. You’re going to count
    only letters and punctuation marks, so spaces would just get in the way. Start
    a while loop that keeps asking the user for input in the event they enter a bad
    value ➎. Ask the user for the number of letters to check after a punctuation mark
    ➏. This will be treated as a range, starting with 1 and ending with the user’s
    choice plus 1\. If the input value is a digit ➐, turn it into an integer, since
    input returns a string. Then, use break to exit the loop.
  prefs: []
  type: TYPE_NORMAL
- en: If the user enters an invalid value, like “Bob,” use a print statement to request
    a number and, for shell users, make the font red using sys.stderr ➑. The while
    loop will then repeat the request for input.
  prefs: []
  type: TYPE_NORMAL
- en: Pass the lookahead variable, along with the message, to the solve_null_cipher
    function ➒. Now all that’s left is to call the main() function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Running the main() Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Back in the global space, complete the code by calling main()—but only if the
    program is run in stand-alone mode versus being imported into another program
    ([Listing 5-4](ch05.xhtml#ch05list4)).
  prefs: []
  type: TYPE_NORMAL
- en: '*null_cipher_finder.py,* part 4'
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: main()
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-4: Calls the* main() *function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is example output from the completed program, using the Trevanion
    cipher as input:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter full filename for message to translate: trevanion.txt'
  prefs: []
  type: TYPE_NORMAL
- en: ORIGINAL MESSAGE =
  prefs: []
  type: TYPE_NORMAL
- en: 'Worthie Sir John: Hope, that is the beste comfort of the afflicted, cannot'
  prefs: []
  type: TYPE_NORMAL
- en: 'much, I fear me, help you now. That I would saye to you, is this only: if ever'
  prefs: []
  type: TYPE_NORMAL
- en: I may be able to requite that I do owe you, stand not upon asking me. 'Tis not
  prefs: []
  type: TYPE_NORMAL
- en: 'much I can do: but what I can do, bee you verie sure I wille. I knowe that,'
  prefs: []
  type: TYPE_NORMAL
- en: if deathe comes, if ordinary men fear it, it frights not you, accounting for
  prefs: []
  type: TYPE_NORMAL
- en: it for a high honour, to have such a rewarde of your loyalty. Pray yet that
  prefs: []
  type: TYPE_NORMAL
- en: you may be spared this soe bitter, cup. I fear not that you will grudge any
  prefs: []
  type: TYPE_NORMAL
- en: sufferings; onlie if bie submission you can turn them away, 'tis the part of
    a
  prefs: []
  type: TYPE_NORMAL
- en: wise man. Tell me, an if you can, to do for you anythinge that you wolde have
  prefs: []
  type: TYPE_NORMAL
- en: done. The general goes back on Wednesday. Restinge your servant to command.
  prefs: []
  type: TYPE_NORMAL
- en: R.T.
  prefs: []
  type: TYPE_NORMAL
- en: List of punctuation marks to check = !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
  prefs: []
  type: TYPE_NORMAL
- en: 'Number of letters to check after punctuation mark: 4'
  prefs: []
  type: TYPE_NORMAL
- en: Using offset of 1 after punctuation = HtcIhTiisTbbIiiiatPcIotTatTRRT
  prefs: []
  type: TYPE_NORMAL
- en: Using offset of 2 after punctuation = ohafehsftiuekfftcorufnienohe
  prefs: []
  type: TYPE_NORMAL
- en: Using offset of 3 after punctuation = panelateastendofchapelslides
  prefs: []
  type: TYPE_NORMAL
- en: Using offset of 4 after punctuation = etnapthvnnwyoerroayaitlfogt
  prefs: []
  type: TYPE_NORMAL
- en: In this output, the program has checked up to the fourth letter after a punctuation
    mark, but as you can see, it finds the solution using three letters after a punctuation
    mark.
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #11: Writing a Null Cipher**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is an unfinished example of a very weak null cipher based on the start
    of each word. Take a minute and try to complete the sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: H__________ e__________ l__________ p__________ m__________ e__________.
  prefs: []
  type: TYPE_NORMAL
- en: You probably found it difficult, because whether you use letters or even whole
    words, it takes hard work and time to produce a null cipher that doesn’t read
    awkwardly and arouse suspicion. The heart of the problem is context. If the cipher
    is encapsulated within correspondence, that correspondence has to be coherent
    to avoid suspicion. That means it has to address a relevant topic and stay true
    to that topic for a reasonable number of sentences. As you probably saw, drafting
    even one sentence on any topic is no easy task!
  prefs: []
  type: TYPE_NORMAL
- en: The key is to credibly avoid context, and a good way to do this is with a list.
    No one expects a shopping list to be rigidly organized or make sense. Lists can
    also be tailored to the receiver. For example, correspondents might get into a
    discussion of books or movies and exchange lists of their favorites. A prisoner
    might start studying a foreign language and receive regular vocabulary lists from
    their tutor. A businessperson might get monthly inventories from one of their
    warehouses. With lists, context is honored even while words are shuffled so the
    correct letter is found in the correct place.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE OBJECTIVE**'
  prefs: []
  type: TYPE_NORMAL
- en: Write code that hides a null cipher within a list of words.
  prefs: []
  type: TYPE_NORMAL
- en: '***The List Cipher Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *list_cipher.py* code, in [Listing 5-5](ch05.xhtml#ch05list5), embeds a
    null cipher within a list of dictionary words under the deception of vocabulary
    training. You’ll also need the *load_dictionary.py* program you used in [Chapters
    2](ch02.xhtml#ch02) and [3](ch03.xhtml#ch03). You can download this file, along
    with the following script, from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
    Finally, you’ll need one of the dictionary files you used in [Chapters 2](ch02.xhtml#ch02)
    and [3](ch03.xhtml#ch03). You can find a list of suitable online dictionaries
    in [Table 2-1](ch02.xhtml#ch02tab1) on [page 20](ch02.xhtml#page_20). All of the
    aforementioned files should be kept in the same folder.
  prefs: []
  type: TYPE_NORMAL
- en: '*list_cipher.py*'
  prefs: []
  type: TYPE_NORMAL
- en: ➊ from random import randint
  prefs: []
  type: TYPE_NORMAL
- en: import string
  prefs: []
  type: TYPE_NORMAL
- en: import load_dictionary
  prefs: []
  type: TYPE_NORMAL
- en: '# write a short message that doesn''t contain punctuation or numbers!'
  prefs: []
  type: TYPE_NORMAL
- en: input_message = "Panel at east end of chapel slides"
  prefs: []
  type: TYPE_NORMAL
- en: message = ''
  prefs: []
  type: TYPE_NORMAL
- en: 'for char in input_message:'
  prefs: []
  type: TYPE_NORMAL
- en: '➋ if char in string.ascii_letters:'
  prefs: []
  type: TYPE_NORMAL
- en: message += char
  prefs: []
  type: TYPE_NORMAL
- en: print(message, "\n")
  prefs: []
  type: TYPE_NORMAL
- en: ➌ message = "".join(message.split())
  prefs: []
  type: TYPE_NORMAL
- en: '➍ # open dictionary file'
  prefs: []
  type: TYPE_NORMAL
- en: word_list = load_dictionary.load('2of4brif.txt')
  prefs: []
  type: TYPE_NORMAL
- en: '# build vocabulary word list with hidden message'
  prefs: []
  type: TYPE_NORMAL
- en: ➎ vocab_list = []
  prefs: []
  type: TYPE_NORMAL
- en: '➏ for letter in message:'
  prefs: []
  type: TYPE_NORMAL
- en: size = randint(6, 10)
  prefs: []
  type: TYPE_NORMAL
- en: '➐ for word in word_list:'
  prefs: []
  type: TYPE_NORMAL
- en: if len(word) == size and word[2].lower() == letter.lower()\
  prefs: []
  type: TYPE_NORMAL
- en: 'and word not in vocab_list:'
  prefs: []
  type: TYPE_NORMAL
- en: vocab_list.append(word)
  prefs: []
  type: TYPE_NORMAL
- en: break
  prefs: []
  type: TYPE_NORMAL
- en: '➑ if len(vocab_list) < len(message):'
  prefs: []
  type: TYPE_NORMAL
- en: print("Word List is too small. Try larger dictionary or shorter message!")
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: 'print("Vocabulary words for Unit 1: \n", *vocab_list, sep="\n")'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-5: Hides null cipher in a list*'
  prefs: []
  type: TYPE_NORMAL
- en: Start by importing the random module’s randint() function ➊. This permits the
    (pseudo)random selection of an integer value. Then load the string module, for
    access to ASCII letters. Finish by importing your load_dictionary module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, write a short secret message. Note that the associated comment forbids
    punctuation marks or numbers. Trying to use these with a dictionary file’s contents
    would be problematic. So, filter out everything but letters by checking for membership
    in string.ascii_letters, which contains both uppercase and lowercase letters ➋:'
  prefs: []
  type: TYPE_NORMAL
- en: '''abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'''
  prefs: []
  type: TYPE_NORMAL
- en: Display the message and then remove the whitespace ➌. Load your dictionary file
    ➍ and start an empty list to hold the vocabulary words ➎.
  prefs: []
  type: TYPE_NORMAL
- en: Use a for loop to go through each letter in the message ➏. Name a size variable
    and assign it a random value between 6 and 10 using the randint() function. This
    variable will ensure the words are long enough to be credible as vocabulary words.
    You can set the maximum value higher if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Nest another for loop and use it to go through the dictionary words ➐, checking
    their length against the size variable and comparing the (lowercase) letter at
    index 2—the word’s third letter—to the current (lowercase) letter in the message
    loop. You can change the index value on the word, but make sure it doesn’t exceed
    the lowest possible size variable minus 1! A final comparison prevents the same
    word from being used twice. If the word passes the tests, append it to vocab_list
    and move on to the next letter in the message.
  prefs: []
  type: TYPE_NORMAL
- en: A typical dictionary file should contain enough words to encrypt a short message.
    But, to be safe, use a conditional to check that the length of vocab_list is not
    shorter than the length of the message ➑. If it’s shorter, then you ran out of
    words before reaching the end of the message, and you need to print a warning
    for the user. Otherwise, print the list of words.
  prefs: []
  type: TYPE_NORMAL
- en: '***The List Cipher Output***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is the output from the code (I’ve highlighted every third letter for readability,
    though the message is pretty easy to spot without any aid):'
  prefs: []
  type: TYPE_NORMAL
- en: Panelateastendofchapelslides
  prefs: []
  type: TYPE_NORMAL
- en: 'Vocabulary words for Unit 1:'
  prefs: []
  type: TYPE_NORMAL
- en: alphabets
  prefs: []
  type: TYPE_NORMAL
- en: abandoning
  prefs: []
  type: TYPE_NORMAL
- en: annals
  prefs: []
  type: TYPE_NORMAL
- en: aberration
  prefs: []
  type: TYPE_NORMAL
- en: ablaze
  prefs: []
  type: TYPE_NORMAL
- en: abandoned
  prefs: []
  type: TYPE_NORMAL
- en: acting
  prefs: []
  type: TYPE_NORMAL
- en: abetted
  prefs: []
  type: TYPE_NORMAL
- en: abasement
  prefs: []
  type: TYPE_NORMAL
- en: abseil
  prefs: []
  type: TYPE_NORMAL
- en: activated
  prefs: []
  type: TYPE_NORMAL
- en: adequately
  prefs: []
  type: TYPE_NORMAL
- en: abnormal
  prefs: []
  type: TYPE_NORMAL
- en: abdomen
  prefs: []
  type: TYPE_NORMAL
- en: abolish
  prefs: []
  type: TYPE_NORMAL
- en: affecting
  prefs: []
  type: TYPE_NORMAL
- en: acceding
  prefs: []
  type: TYPE_NORMAL
- en: abhors
  prefs: []
  type: TYPE_NORMAL
- en: abalone
  prefs: []
  type: TYPE_NORMAL
- en: ampersands
  prefs: []
  type: TYPE_NORMAL
- en: acetylene
  prefs: []
  type: TYPE_NORMAL
- en: allegation
  prefs: []
  type: TYPE_NORMAL
- en: absconds
  prefs: []
  type: TYPE_NORMAL
- en: aileron
  prefs: []
  type: TYPE_NORMAL
- en: acidifying
  prefs: []
  type: TYPE_NORMAL
- en: abdicating
  prefs: []
  type: TYPE_NORMAL
- en: adepts
  prefs: []
  type: TYPE_NORMAL
- en: absent
  prefs: []
  type: TYPE_NORMAL
- en: Using a font with a consistent character width and stacking the words really
    compromises the cipher. We’ll look at ways to deal with this in “[Saving Mary](ch05.xhtml#lev128)”
    on [page 102](ch05.xhtml#page_102).
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you wrote a program that reveals the hidden message in a Trevanion-type
    null cipher. Then, you wrote a second program that generates a null cipher and
    conceals it within a language learner’s vocabulary list. In the following practice
    projects, you can explore ways to make this list cipher more secure.
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More details on Mary, Queen of Scots, and Sir John Trevanion can be found in
    *Mysterious Messages: A History of Codes and Ciphers* (The Penguin Group, 2009)
    by Gary Blackwood and *The Code Book: The Science of Secrecy from Ancient Egypt
    to Quantum Cryptography* (Anchor, 2000) by Simon Singh.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Projects**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’re an expert on the null cipher, see if you can change the fate
    of Mary, Queen of Scots, and then sneak a look at Sir John’s most secret correspondence.
  prefs: []
  type: TYPE_NORMAL
- en: '***Saving Mary***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The best part of coding is thinking about problems and how to solve them. Let’s
    revisit the sad case of Mary, Queen of Scots. Here’s what we know:'
  prefs: []
  type: TYPE_NORMAL
- en: Mary was not allowed correspondence, so letters had to be smuggled in. This
    means that the traitorous Gilbert Gifford cannot be removed from the equation.
    Gifford was the only person Mary knew with the means to deliver her mail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mary and her correspondents put too much faith in an insecure cipher and thus
    spoke too freely. With less confidence, they might have shown more forbearance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mary’s jailors, having an obvious cipher in their possession, assumed it contained
    incriminating material and kept working until they found it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gifford, the double agent, wasn’t privy to the details of the ciphers Mary used.
    Now, assume Mary used a null cipher. If the correspondence was somewhat seditious—though
    not treasonously so—the message might have been overlooked by her captors. In
    the event a cursory examination was made, the use of a variable pattern might
    have sufficed to stymie the cryptanalysts.
  prefs: []
  type: TYPE_NORMAL
- en: As you have seen, it’s easier to hide a null cipher in a list than in a letter.
    A list of families supporting Mary could serve the purpose. These could be known
    supporters or, in a Machiavellian twist, a mix of friends *and* enemies! This
    message wouldn’t be openly seditious, but would be close enough so that a lack
    of encryption would suggest no form of encryption was being used at all.
  prefs: []
  type: TYPE_NORMAL
- en: For this practice project, write a program that embeds the message “Give your
    word and we rise” in a list of surnames. To hide the letters in the message, start
    at the second letter in the second name, move to the third letter in the third
    name, and then keep alternating between second and third letters for the remaining
    words.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the unused first name, include “Stuart” and “Jacob” as null
    words early in the list to help hide the presence of the cipher. Don’t embed letters
    from the cipher in these null names and completely ignore them when choosing the
    letter position for the cipher in the following word; if the second letter was
    used in the word *before* the null name, use the third letter in the word *after*
    the null name. The null cipher would occupy the following bolded letters (the
    location of the null words is up to you, but don’t let them affect the pattern):'
  prefs: []
  type: TYPE_NORMAL
- en: First Second Third STUART Fourth Fifth JACOB Sixth Seventh Eighth
  prefs: []
  type: TYPE_NORMAL
- en: The program can print the list either vertically or horizontally. The name list
    should be credibly introduced with a short message, but that message shouldn’t
    be part of the cipher.
  prefs: []
  type: TYPE_NORMAL
- en: The list of names can be downloaded from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    as *supporters.txt* and loaded as a standard dictionary file. You can find a solution
    in the appendix and online as *save_Mary_practice.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Colchester Catch***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Instead of some ale-sotted dimwit, *you* are left in charge of the prisoner
    John Trevanion when the following letter arrives at Colchester Castle:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sir John: Odd and too hard, your lot. Still, we will band together and, like
    you, persevere. Who else could love their enemies, stand firm when all others
    fail, hate and despair? While we all can, let us feel hope. -R.T.'
  prefs: []
  type: TYPE_NORMAL
- en: It seems clumsily phrased, even for the 17th century, and you decide to examine
    it more closely before passing it to your inmate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a Python program that takes an input, *n*, and checks for and displays
    a null cipher based on the *n*th letter after the start of every *n*th word. For
    example, an input of 2 would find the bolded letters in this message:'
  prefs: []
  type: TYPE_NORMAL
- en: So, t**h**e cold t**e**a didn’t p**l**ease the o**l**d finicky w**o**man.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the text file of the message from *[https://nostarch.com/impracticalpython/](https://nostarch.com/impracticalpython/)*
    as *colchester_message.txt*. A solution can be found in the appendix and online
    as *colchester_practice.py*. Keep the text and Python files together in the same
    folder.
  prefs: []
  type: TYPE_NORMAL
