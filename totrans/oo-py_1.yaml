- en: method call raises an AbortTransaction exception, control will be transferred
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: to the except statement 4\.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions are objects. In the except clause, we handle the AbortTransaction
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: exception that was raised at any lower level. We assign the value of the
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '**82** Chapter 4'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: exception to the variable error. When we print that variable, the user will
    see the associated error message. Since the exception was handled in the
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: except clause, the program continues running, and the user is asked what
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: they wish to do.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '**Calling the Same Method on a List of Objects**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Unlike in our bank example, in cases where individual objects do not need
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: to be uniquely identified, using a list of objects works extremely well. Let’s
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: say you’re coding a game and you need to have some number of bad guys,
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: spaceships, bullets, zombies, or whatever else. Each such object will typically
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: have some data it remembers and some actions it can perform. As long as
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: each object does not require a unique identifier, the standard way to handle
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: this is to create many instances of the object from the class and put all the
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'objects into a list:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'objectList = [] # start off with an empty list'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(nObjects):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'oNewObject = MyClass() # create a new instance'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'objectList.append(oNewObject) # store the object in the list'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: In our game, we represent a world as a large grid, like a spreadsheet.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: We want monsters placed at random locations in the grid. Listing 4-12
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: shows the start of a Monster class with its __init__() method and a move()
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: method. When a Monster is instantiated, it is told the number of rows and
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: columns in the grid and the maximum speed, and it chooses a random
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: starting location and speed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '**File: MonsterExample.py**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: import random
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: class Monster()
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, nRows, nCols, maxSpeed):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'self.nRows = nRows # save away'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'self.nCols = nCols # save away'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'self.myRow = random.randrange(self.nRows) # chooses a random row'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'self.myCol = random.randrange(self.nCols) # chooses a random col'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'self.mySpeedX = random.randrange(-maxSpeed, maxSpeed + 1) # chooses an X speed'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'self.mySpeedY = random.randrange(-maxSpeed, maxSpeed + 1) # chooses a Y speed'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Set other instance variables like health, power, etc.
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def move(self):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: self.myRow = (self.myRow + self.mySpeedY) % self.nRows
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: self.myCol = (self.myCol + self.mySpeedX) % self.nCols
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-12: A Monster class that can be used to instantiate many Monsters*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Managing Multiple Objects **83**
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'With this Monster class, we can create a list of Monster objects like this:
    N_MONSTERS = 20'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'N_ROWS = 100 # could be any size'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'N_COLS = 200 # could be any size'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: MAX_SPEED = 4
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'monsterList = [] # start with an empty list'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(N_MONSTERS):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'oMonster = Monster(N_ROWS, N_COLS, MAX_SPEED) # create a Monster'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'monsterList.append(oMonster) # add the Monster to our list'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: This loop will instantiate 20 Monsters, and each will know its own start-
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: ing location in the grid and its individual speed. Once you have a list of
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: objects, later in the program when you want each object to do the same
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对象，当你希望每个对象执行相同的
- en: action, you can write a simple loop where you call the same method of each
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 操作，你可以写一个简单的循环，调用每个对象的相同方法
- en: 'object in the list:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个对象：
- en: 'for objectVariable in objectVariablesList:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 objectVariable 在 objectVariablesList 中：
- en: objectVariable.someMethod()
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: objectVariable.someMethod()
- en: For example, if we want each of our Monster objects to move, we could
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们希望每个 Monster 对象都移动，我们可以
- en: 'use a loop like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似这样的循环：
- en: 'for oMonster in monsterList:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 oMonster 在 monsterList 中：
- en: oMonster.move()
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: oMonster.move()
- en: Since each Monster object remembers its location and speed, in the
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个 Monster 对象记住了它的位置和速度，在
- en: move() method, each Monster can move to and remember its new location.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: move() 方法，每个 Monster 都可以移动到并记住它的新位置。
- en: This technique of building a list of objects and calling the same
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这种构建对象列表并调用相同方法的技术
- en: method of all objects in the list is extremely useful, and it’s a standard
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中所有对象的方法非常有用，它是处理集合的标准
- en: approach to dealing with a collection of similar objects. We will use this
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 处理一组相似对象的标准方法。我们将使用这种
- en: approach quite often when we get to building games using pygame later.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们稍后使用 pygame 构建游戏时，经常采用这种方法。
- en: '**Interface vs. Implementation**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口 vs. 实现**'
- en: Our earlier Account class seems to have methods and instance variables that
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的 Account 类似乎有方法和实例变量
- en: work well. When you’re confident your code is working well, you no longer
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 工作得如何。当你确信你的代码工作正常时，你就不再
- en: have to be concerned with the details within the class. When a class does
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要关心类内部的细节。当一个类做
- en: what you want it to do, all you need to remember is what methods are avail-
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要它做什么，只需记住哪些方法是可用的，
- en: 'able in the class. There are two different ways to look at a class: by focusing'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类中可用的两种不同方式：关注
- en: on what it is capable of doing (the *interface*) and how it works internally
    (the *implementation*).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 根据对象的 *接口* 以及它的 *实现* 如何运作，来判断它能做什么。
- en: '**interface**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口**'
- en: The col ection of methods a class provides (and the parameters that each method
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 类提供的方法集合（以及每个方法的参数）
- en: expects) . The interface shows *what* an object created from the class can do
    .
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 期望的方式）。接口展示了对象从类创建后能做 *什么*。
- en: '**implementation** The actual code of the class, which shows *how* an object
    does what it does .'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现** 类的实际代码，展示对象是 *如何* 完成它的任务的。'
- en: '**84** Chapter 4'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**第 84 章**'
- en: If you are the creator or maintainer of a class, you need to fully understand
    the implementation—the code of all of the methods and how they
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是类的创建者或维护者，你需要完全理解实现——所有方法的代码以及它们
- en: work together to affect the instance variables. If you are purely writing code
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一起影响实例变量。如果你只是写代码
- en: to *use* a class, you only need to concern yourself with the interface—the
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要 *使用* 一个类，你只需要关注接口——
- en: different methods that are available in the class, the values that need to be
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类中可用的不同方法，所需的值必须
- en: passed into each, and any value(s) that are returned from the methods. If
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给每个方法的值，以及从方法返回的任何值。如果
- en: you are coding on your own (as a “one-person team”), then you will be both
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是在独立编程（作为“单人团队”），那么你将同时
- en: the implementer of a class and the user of its interface.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 类的实现者和接口的用户之间的关系。
- en: As long as the interface of a class does not change, the class’s imple-
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 只要类的接口不变，类的实现
- en: mentation can change at any time. That is, if you find that a method can be
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实现可以随时更改。也就是说，如果你发现一个方法可以
- en: implemented in a faster or more efficient way, changing the relevant code
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以更快或更高效的方式实现，改变相关的代码
- en: inside the class will not have any bad side effects on any other part of the
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 类内部的更改不会对程序的其他部分产生不良副作用。
- en: program.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 程序。
- en: '**Summary**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: An object manager object is an object that manages other objects. It does
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对象管理器对象是一个管理其他对象的对象。它不做
- en: this by having one or more instance variables that are lists or dictionaries
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过具有一个或多个实例变量，它们是列表或字典，来实现这一点
- en: made up of other objects. The object manager can call methods of any spe-
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由其他对象组成。对象管理器可以调用任何特定对象的
- en: cific object or of all managed objects. This technique gives full control of
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 特定对象或所有管理对象的。此技术提供了对类的完全控制，
- en: all managed objects to the object manager alone.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有管理对象都归对象管理器管理。
- en: When you encounter an error in a method or function, you can raise an
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在方法或函数中遇到错误时，你可以抛出一个
- en: exception. The raise statement returns control to the caller. The caller can
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 异常。raise 语句将控制权返回给调用者。调用者可以
- en: detect a potential error by placing the call in a try block, and it can react
    to
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将调用放入 try 块中，可以检测潜在错误，并对其做出反应
- en: any such error using an except block.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 except 块处理任何此类错误。
- en: The interface of a class is the documentation of all the methods and
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 类的接口是所有方法和
- en: related parameters in the class. The implementation is the actual code
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的相关参数。实现是实际的代码
- en: of the class. What you need to know depends on your role. The writer/
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 类的实现。你需要了解的内容取决于你的角色。编写者/
- en: maintainer of a class needs to understand the details of the code, whereas
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 类的维护者需要理解代码的细节，而
- en: anyone who uses the class only needs to understand the interface that the
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类的任何人只需理解类的接口
- en: class provides.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 类提供的功能。
- en: Managing Multiple Objects **85**
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 管理多个对象 **85**
- en: '**PART II**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二部分**'
- en: '**G R A P H I C A L U S E R**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形用户界面**'
- en: '**I N T E R F A C E S W I T H P Y G A M E**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**与 Pygame 的接口**'
- en: These chapters introduce you to *pygame,* an external
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些章节将向你介绍*pygame*，一个外部
- en: package that adds functionality common to GUI pro-
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 包，它为 GUI 程序添加了常见的功能
- en: grams. Pygame allows you to write Python programs
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 克拉姆。Pygame 允许你编写 Python 程序
- en: that have windows, respond to the mouse and key-
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那些有窗口、响应鼠标和键盘输入的
- en: board, play sounds, and more.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 主板、播放声音等等。
- en: '[Chapter 5 g](#p118)ives you a basic understanding of how pygame works and
    provides a standard template for building pygame-based programs. We’ll'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章 g](#p118)为你提供了对 pygame 如何工作的基本理解，并提供了构建基于 pygame 的程序的标准模板。我们将'
- en: build a few simple programs first, create a program that controls an image
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 先构建几个简单程序，创建一个控制图像的程序
- en: with the keyboard, then we’ll build a ball-bouncing program.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用键盘输入，然后我们将构建一个球体反弹程序。
- en: '[Chapter 6 e](#p150)xplains how pygame can best be used as an object-oriented
    framework. You’ll see how to rewrite the ball-bouncing program using'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[第6章 e](#p150)解释了如何将 pygame 最好地作为面向对象框架使用。你将看到如何使用'
- en: object-oriented techniques, and develop simple buttons and text input
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象技术，并开发简单的按钮和文本输入
- en: fields.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 领域。
- en: '[Chapter 7 d](index_split_003.html#p172)escribes the pygwidgets module, which
    contains full implementations of many standard user interface widgets like buttons,
    input'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章 d](index_split_003.html#p172)描述了 pygwidgets 模块，它包含了许多标准用户界面控件的完整实现，比如按钮、输入框'
- en: and output fields, radio buttons, checkboxes, and more, all using object-
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 和输出字段、单选按钮、复选框等，所有这些都使用面向对象技术
- en: oriented programming. All the code is available for you so that you can use
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的文档。所有代码都可以供你使用
- en: it to build your own applications. I’ll provide several examples.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 用它来构建你自己的应用程序。我会提供几个示例。
- en: '**5**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**5**'
- en: '**I N T R O D U C T I O N T O P Y G A M E**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**P Y G A M E 简介**'
- en: The Python language was designed to han-
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Python 语言的设计旨在处理
- en: dle text input and text output. It provides
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文本输入和文本输出。它提供
- en: the ability to get text from and send text to
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 获取文本并发送文本到
- en: the user, a file, and the internet. The core lan-
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 用户、文件和互联网的核心语言
- en: guage, however, has no way of dealing with more mod-
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 语言本身没有处理更现代的方式
- en: ern concepts such as windows, mouse clicks, sounds,
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现代概念，如窗口、鼠标点击、声音等，
- en: and so on. So, what if you want to use Python to create
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。那么，如果你想使用 Python 创建
- en: something more state-of-the-art than a text-based program? In this chapter
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 想做些比基于文本的程序更先进的东西吗？在这一章中
- en: I’ll introduce *pygame*, a free open source external package that was designed
    to extend Python to allow programmers to build game programs. You can
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我将介绍 *pygame*，一个免费的开源外部包，旨在扩展 Python 以允许程序员构建游戏程序。你可以
- en: also use pygame to build other kinds of interactive programs with a graphi-
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用 pygame 构建其他类型的图形交互程序——
- en: cal user interface (GUI). It adds the ability to create windows, show images,
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图形用户界面（GUI）。它增加了创建窗口、显示图像的功能，
- en: recognize mouse move ments and clicks, play sounds, and more. In short, it
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 识别鼠标移动和点击、播放声音等等。简而言之，它
- en: allows Python programmers to build the types of games and applications
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 允许 Python 程序员构建游戏和应用程序
- en: that current computer users have become familiar with.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当前计算机用户已经熟悉的。
- en: It is not my intent to turn you all into game programmers—even though
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不打算让你们都成为游戏程序员——尽管
- en: that might be a fun outcome. Rather, I’ll use the pygame environment to
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个有趣的结果。而是，我将使用 pygame 环境来
- en: make certain object-oriented programming techniques clearer and more visual.
    By working with pygame to make objects visible in a window and
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使某些面向对象编程技巧更清晰、更具视觉效果。通过使用 pygame 在窗口中显示对象并
- en: dealing with a user interacting with those objects, you should gain a deeper
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 处理用户与这些对象交互时，你应该更深入地
- en: understanding of how to effectively use OOP techniques.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 理解如何有效使用面向对象编程（OOP）技术。
- en: This chapter provides a general introduction to pygame, so most of the
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了pygame的一般介绍，因此大多数
- en: information and examples in this chapter will use procedural coding. Starting
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的信息和示例将使用过程化编程。开始
- en: with the next chapter, I will explain how to use OOP effectively with pygame.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节中，我将解释如何使用pygame有效地运用OOP。
- en: '**Installing Pygame**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装Pygame**'
- en: Pygame is a free downloadable package. We’ll use the package manager
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame是一个免费的可下载包。我们将使用包管理器
- en: '*pip* (short for *pip installs packages*) to install Python packages. As mentioned
    in the Introduction, I am assuming that you have installed the official version
    of Python from *python.org*. The pip program is included as part of that download,
    so you should already have it installed.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*pip*（即*pip安装包*）用于安装Python包。如引言中所述，我假设你已经从*python.org*安装了官方版本的Python。pip程序作为该下载的一部分包含在内，因此你应该已经安装了它。'
- en: Unlike a standard application, you must run pip from the command
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准应用程序不同，你必须从命令行运行pip
- en: line. On a Mac, start the Terminal application (located in the *Utilities*
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一行。在Mac上，启动终端应用程序（位于*实用工具*文件夹内）。
- en: subfolder inside the *Applications* folder). On a Windows system, click the
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 子文件夹位于*应用程序*文件夹内）。在Windows系统中，点击
- en: Windows icon, type **cmd**, and press ENTER.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Windows图标，输入**cmd**，然后按回车。
- en: '**N O T E**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**注**'
- en: '*This book was not tested with Linux systems. However, most, if not all, of
    the content* *should work with minimal tweaking. To install pygame on a Linux
    distribution,*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*本书没有在Linux系统上进行测试。然而，大部分内容* *应该可以在最小调整的情况下运行。在Linux发行版上安装pygame，*'
- en: '*open a terminal in whatever way you’re used to.*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*以你惯用的方式打开终端。*'
- en: 'Enter the following commands at the command line:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行输入以下命令：
- en: python3 -m pip install -U pip --user
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m pip install -U pip --user
- en: python3 -m pip install -U pygame --user
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m pip install -U pygame --user
- en: The first command ensures that you have the latest version of the pip
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令确保你拥有最新版本的pip。
- en: program. The second line installs the most recent version of pygame.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 程序。第二行安装pygame的最新版本。
- en: If you have any problems installing pygame, consult the pygame docu-
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在安装pygame时遇到任何问题，请查阅pygame文档
- en: mentation at [*https://www.pygame.org/wiki/GettingStarted*](https://www.pygame.org/wiki/GettingStarted).
    To test that pygame has been installed correctly, open IDLE (the development environment
    that
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 文档可以在[*https://www.pygame.org/wiki/GettingStarted*](https://www.pygame.org/wiki/GettingStarted)查阅。要测试pygame是否正确安装，打开IDLE（Python的开发环境，
- en: is bundled with the default implementation of Python), and in the shell win-
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 随Python的默认实现一起捆绑在一起），并且在shell中win-
- en: 'dow enter:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按回车：
- en: import pygame
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: If you see a message saying something like “Hello from the pygame
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到类似“Hello from the pygame
- en: community” or if you get no message at all, then pygame has been installed
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 社区”或者如果你根本没有收到任何消息，那么pygame已经安装
- en: correctly. The lack of an error message indicates that Python has been able
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正确无误。没有错误消息表示Python已经能够
- en: to find and load the pygame package and it’s ready to use. If you would like
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 查找并加载pygame包并准备就绪。如果你想
- en: to see a sample game using pygame, enter the following command (which
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 查看使用pygame的示例游戏，输入以下命令（这
- en: 'starts a version of *Space Invaders*):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个版本的*太空侵略者*）：
- en: python3 -m pygame.examples.aliens
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m pygame.examples.aliens
- en: '**90** Chapter 5'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**90** 第五章'
- en: Before we get into using pygame, I need to explain two important concepts. First,
    I’ll explain how individual pixels are addressed in programs
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用pygame之前，我需要解释两个重要的概念。首先，我将解释程序中如何处理单个像素。
- en: that use a GUI. Then, I’ll discuss event-driven programs and how they dif-
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GUI的程序。然后，我将讨论事件驱动的程序以及它们如何不同于
- en: fer from typical text-based programs. After that, we’ll code a few programs
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与典型的基于文本的程序有所不同。之后，我们将编写一些程序
- en: that demonstrate key pygame features.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 演示关键pygame功能的程序。
- en: '**Window Details**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**窗口详情**'
- en: A computer screen is made up of a large number of rows and columns of
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机屏幕由大量的行列组成
- en: small dots called *pixels* (from the words *picture element*). A user interacts
    with a GUI program through one or more windows; each window is a rectangular portion
    of the screen. Programs can control the color of any individual
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由称为*像素*的小点组成（源自*图像元素*）。用户通过一个或多个窗口与GUI程序进行交互；每个窗口都是屏幕上的矩形区域。程序可以控制任何单个
- en: pixel in their window(s). If you’re running multiple GUI programs, each
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: program is typically displayed in its own window. In this section, I’ll discuss
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: how you address and alter individual pixels in a window. These concepts are
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: independent of Python; they are common to all computers and are used in
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: all programming languages.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '***The Window Coordinate System***'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: You are probably familiar with Cartesian coordinates in a grid like Figure 5-1\.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: y–axis
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: x–axis
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: –6 –5 –4 –3 –2 –1
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: –1
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: –2
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: –3
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: –4
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: –5
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: –6
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5-1: The standard Cartesian coordinate system*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pygame **91**
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Any point in a Cartesian grid can be located by specifying its x- and y-coordinates
    (in that order). The origin is the point specified as (0, 0) and
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: is found in the center of the grid.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Computer window coordinates work in a similar way (Figure 5-2).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Max x
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Max y
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5-2: A computer window’s coordinate system*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are a few key differences:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The origin (0, 0) point is in the upper-left corner of the window.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 2\. The y-axis is reversed so that y values start at zero at the top of the
    win-
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: dow and increase as you go down.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 3\. The x and y values are always integers. Each (x, y) pair specifies a single
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: pixel in the window. These values are always specified as relative to the
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: upper-left corner of the window, not the screen. That way, the user can
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: move the window anywhere on the screen without affecting the coordi-
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: nates of the elements of the program displayed in the window.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The full computer screen has its own set of (x, y) coordinates for every
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: pixel and uses the same type of coordinate system, but programs rarely, if
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: ever, need to deal with screen coordinates.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: When we write a pygame application, we need to specify the width and
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: height of the window we want to create. Within the window, we can address
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: any pixel using its x- and y-coordinates, as shown in Figure 5-3\.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-3 shows a black pixel at position (3, 5). That is an x-value of 3
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: (note that this is actually the fourth column, since coordinates start at 0)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: and a y value of 5 (actually the sixth row). Each pixel in a window is com-
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: monly referred to as a *point*. To reference a point in a window, you would
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: typically use a Python tuple. For example, you might have an assignment
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'statement like this, with the x value first:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: pixelLocation = (3, 5)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '**92** Chapter 5'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 10 11 12 13 …
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: …
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5-3: A single point (a single pixel) in a computer window*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: To show an image in a window, we need to specify the coordinates of its
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: starting point—always the upper-left corner of the image—as an (x, y) pair,
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: as in Figure 5-4, where we draw the image at location (3, 5).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: When working with an image, you’ll often need to deal with the
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '*bounding rectangle*, which is the smallest rectangle that can be made that'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: completely surrounds all pixels of the image. A rectangle is represented
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'in pygame by a set of four values: x, y, width, height. The rectangle for'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: the image in Figure 5-4 has values of 3, 5, 11, 7\. I’ll show you how to use
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: a rectangle like this in an upcoming example program. Even if your
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: image is not rectangular (for example, if it’s a circle or an ellipse), you
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: still have to consider its bounding rectangle for positioning and collision
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: detection.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pygame **93**
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 10 11 12 13 …
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: …
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5-4: An image in a window*'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '***Pixel Colors***'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore how colors are represented on the computer screen. If you
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: have experience with a graphics program like Photoshop, you probably
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: already know how this works, but you may want a quick refresher anyway.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Each pixel on the screen is made up of a combination of three colors:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: red, green, and blue, often referred to as *RGB*. The color displayed in
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: any pixel is composed of some amount of red, green, and blue, where the
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: amount of each is specified as a value from 0, meaning none, to 255, mean-
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: ing full intensity. Therefore, there are 256 × 256 × 256 possible combina-
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: tions, or 16,777,216 (often referred to as just “16 million”) possible colors,
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: for each pixel.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Colors in pygame are given as RGB values, and we write them as Python
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'tuples of three numbers. Here is how we create constants for the main colors:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'RED = (255, 0, 0) # full red, no green, no blue'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'GREEN = (0, 255, 0) # no red, full green, no blue'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'BLUE = (0, 0, 255) # no red, no green, full blue'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '**94** Chapter 5'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the definitions of a few more colors. You can create a color using
    any combination of three numbers between 0 and 255:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'BLACK = (0, 0, 0) # no red, no green, no blue'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'WHITE = (255, 255, 255) # full red, full green, full blue'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: DARK_GRAY = (75, 75, 75)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: MEDIUM_GRAY = (128, 128, 128)
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: LIGHT_GRAY = (175, 175, 175)
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'TEAL = (0, 128, 128) # no red, half-strength green, half-strength blue'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: YELLOW = (255, 255, 0)
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: PURPLE = (128, 0, 128)
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: In pygame, you’ll need to specify colors when you want to fill the back-
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: ground of a window, draw a shape in a color, draw text in a color, and so on.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Defining colors up front as tuple constants makes them very easy to spot
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: later in code.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '**Event-Driven Programs**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: In most of the programs in the book so far, the main code has lived in a
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: while loop. The program stops at a call to the built-in input() function and
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: waits for some user input to work on. Program output is typically handled
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: using calls to print().
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: In interactive GUI programs, this model no longer works. GUIs intro-
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: duce a new model of computing known as the *event-driven* model. Event-
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: driven programs don’t rely on input() and print(); instead, the user interacts
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: with elements in a window at will using a keyboard and/or mouse or other
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: pointing device. They may be able to click various buttons or icons, make
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: selections from menus, provide input in text fields, or give commands via
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: clicks or key presses to control some avatar in the window.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '*Calls to print() can still be highly useful for debugging, when used to write
    out intermediate results.*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用 print() 仍然在调试时非常有用，可以用来输出中间结果。*'
- en: Central to event-driven programming is the concept of an *event*. Events
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动编程的核心概念是 *事件*。事件
- en: are difficult to define and are best described with examples, such as a mouse
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 很难定义这些事件，最好通过示例来描述，比如鼠标
- en: 'click and a key press (each of which is actually made up of two events: mouse'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 点击和按键事件（每个事件实际上由两个事件组成：鼠标
- en: down and mouse up and key down and key up, respectively). Here is my
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 向下、鼠标抬起、按键按下和按键抬起事件，分别对应）。这是我的
- en: working definition.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 工作定义。
- en: '**event**'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件**'
- en: Something that happens while your program is running that your program wants
    to
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序运行时发生的事件，程序希望对其作出反应
- en: or needs to respond to . Most events are generated by user actions .
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 或者需要响应的事件。大多数事件都是由用户的操作生成的。
- en: An event-driven GUI program runs constantly in an infinite loop. Each
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 一个事件驱动的 GUI 程序会不断在无限循环中运行。每个
- en: time through the loop, the program checks for any new events it needs to
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环时，程序都会检查是否有新的事件需要
- en: react to and executes appropriate code to handle those events. Also, each
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 响应并执行适当的代码来处理这些事件。此外，每个
- en: time through the loop, the program needs to redraw all the elements in the
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环时，程序需要重新绘制所有元素，
- en: window to update what the user sees.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口更新用户看到的内容。
- en: Introduction to Pygame **95**
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame简介 **95**
- en: '![Image 18](index-125_1.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![图片 18](index-125_1.png)'
- en: For example, say we have a simple GUI program that displays two but-
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个简单的 GUI 程序，显示两个按钮
- en: 'tons: Bark and Meow. When clicked, the Bark button plays a sound of a dog'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 吠声和喵声按钮。点击时，吠叫按钮播放狗叫声
- en: barking and the Meow button plays a sound of a cat meowing (Figure 5-5).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 吠叫和喵喵按钮播放猫咪叫声（图 5-5）。
- en: '*Figure 5-5: A simple program*'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5：一个简单的程序*'
- en: '*with two but ons*'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '*带有两个按钮*'
- en: The user can click these buttons in any order and at any time. To han-
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以随时以任何顺序点击这些按钮。为了处理
- en: dle the user’s actions, the program runs in a loop and constantly checks to
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 处理用户的操作时，程序会在循环中运行并不断检查
- en: see if either button has been clicked. When it receives a mouse down event
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 查看哪个按钮被点击。当程序接收到鼠标按下事件时，
- en: on a button, the program remembers that the button has been clicked and
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击按钮时，程序会记住该按钮已被点击，并
- en: draws the depressed image of that button. When it receives a mouse up
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制按下状态的按钮图像。当它接收到鼠标抬起
- en: event on the button, it remembers the new state and redraws the button
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在按钮上发生的事件，程序记住新的状态并重新绘制按钮
- en: with its original appearance, and it plays the appropriate sound. Because
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 保持原来的外观，并播放适当的声音。因为
- en: the main loop runs so quickly, the user perceives that the sound plays
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环运行得非常快，用户感觉声音是即时播放的。
- en: immediately after they click the button. Each time through the loop, the
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 每次点击按钮后立即执行。每次通过循环时，
- en: program redraws both buttons with an image matching each button’s cur-
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会重新绘制两个按钮，并用与每个按钮当前
- en: rent state.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 租赁状态。
- en: '**Using Pygame**'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 Pygame**'
- en: At first, pygame may seem like an overwhelmingly large package with many
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，pygame 可能看起来是一个庞大的软件包，包含很多
- en: different calls available. Although it is large, there’s actually not a lot
    that
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多不同的调用可用。虽然它很大，但实际上没有很多
- en: you need to understand to get a small program up and running. To intro-
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要理解的内容，才能让一个小程序顺利运行。为了介绍
- en: duce pygame, I’ll first give you a template that you can use for all pygame
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 pygame 时，我将首先提供一个模板，您可以将其用于所有 pygame
- en: programs you create. Then I’ll build on that template, adding key pieces of
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 你所创建的程序。然后我会在此基础上构建，添加关键部分
- en: functionality little by little.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 一点一点地完善功能。
- en: 'In the following sections, I’ll show you how to:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我将向您展示如何：
- en: • Bring up a blank window.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: • 打开空白窗口。
- en: • Show an image.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: • 显示图像。
- en: • Detect a mouse click.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: • 检测鼠标点击。
- en: • Detect both single and continuous key presses.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: • 检测单次和连续的键盘按键。
- en: • Create a simple animation.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: • 创建简单的动画。
- en: • Play sound effects and background sounds.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: • 播放音效和背景音效。
- en: • Draw shapes.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: • 绘制形状。
- en: In the next chapter, we’ll continue the discussion of pygame and you’ll
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续讨论 pygame，您将
- en: 'see how to:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何：
- en: • Animate many objects.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: • 动画多个对象。
- en: • Build and react to a button.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: • 构建并响应按钮。
- en: • Create a text display field.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: • 创建文本显示区域。
- en: '**96** Chapter 5'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**96** 第五章'
- en: '***Bringing Up a Blank Window***'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '***打开空白窗口***'
- en: As I said earlier, pygame programs run constantly in a loop, checking for
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说，pygame 程序会不断地在循环中运行，检查
- en: events. It might help to think of your program as an animation, where
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 事件。你可以把程序当作动画来看，其中
- en: each pass through the main loop is one frame. The user may click on
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 每次通过主循环就是一帧。用户可能会点击
- en: something during any frame, and your program must not only respond
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧中做点什么，并且你的程序不仅要响应
- en: to that input but also keep track of everything it needs to draw in the
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 对该输入进行处理，同时跟踪所有需要绘制的内容
- en: window. For instance, in one example program later in this chapter, we’ll
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口。比如，在本章后面的一个示例程序中，我们会
- en: move a ball across the window so in each frame the ball is drawn in a
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 移动一个球穿越窗口，所以在每一帧中，球会被绘制在一个
- en: slightly different position.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 略微不同的位置。
- en: Listing 5-1 is a generic template that you can use as a starting point for
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-1 是一个通用模板，你可以将其作为
- en: all your pygame programs. This program opens a window and paints the
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你所有 pygame 程序的基础。这个程序打开一个窗口，并绘制
- en: entire contents black. The only thing the user can do is click the close but-
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 整个内容被涂成黑色。用户唯一能做的就是点击关闭按钮
- en: ton to quit the program.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 让程序无法退出。
- en: '**File: PygameDemo0_WindowOnly/PygameWindowOnly.py**'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PygameDemo0_WindowOnly/PygameWindowOnly.py**'
- en: pygame demo 0 - window only
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pygame 演示 0 - 仅窗口
- en: 1 - Import packages
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 - 导入包
- en: import pygame
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from pygame.locals import *
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: from pygame.locals import *
- en: import sys
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: 2 - Define constants
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 - 定义常量
- en: BLACK = (0, 0, 0)
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: BLACK = (0, 0, 0)
- en: WINDOW_WIDTH = 640
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_WIDTH = 640
- en: WINDOW_HEIGHT = 480
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_HEIGHT = 480
- en: FRAMES_PER_SECOND = 30
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: FRAMES_PER_SECOND = 30
- en: 3 - Initialize the world
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 - 初始化世界
- en: pygame.init()
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.init()
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
- en: clock = pygame.time.Clock()
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: clock = pygame.time.Clock()
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 - 加载资源：图像、声音等。
- en: 5 - Initialize variables
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 - 初始化变量
- en: 6 - Loop forever
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 - 永久循环
- en: 'while True:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 7 - Check for and handle events
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 - 检查并处理事件
- en: 'for event in pygame.event.get():'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: Clicked the close button? Quit pygame and end the program
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击了关闭按钮？退出 pygame 并结束程序
- en: 'if event.type == pygame.QUIT:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件类型是 pygame.QUIT：
- en: pygame.quit()
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: 8 - Do any "per frame" actions
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 - 执行任何“每帧”操作
- en: 9 - Clear the window
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 - 清除窗口
- en: Introduction to Pygame **97**
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame 简介 **97**
- en: window.fill(BLACK)
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: window.fill(BLACK)
- en: 10 - Draw all window elements
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 - 绘制所有窗口元素
- en: 11 - Update the window
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 - 更新窗口
- en: pygame.display.update()
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.update()
- en: 12 - Slow things down a bit
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 - 稍微放慢速度
- en: clock.tick(FRAMES_PER_SECOND)
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: clock.tick(FRAMES_PER_SECOND)
- en: '*Listing 5-1: A template for creating pygame programs*'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-1：创建 pygame 程序的模板*'
- en: 'Let’s walk through the different parts of this template:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解这个模板的不同部分：
- en: 1\. Import packages.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 导入包。
- en: The template starts with the import statements. We first import the pyg-
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 模板从导入语句开始。我们首先导入 pygame
- en: ame package itself, then some constants defined inside pygame that
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏包本身，然后是 pygame 中定义的一些常量
- en: we’ll use later. The last import is the sys package, which we’ll use to quit
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们会用到的。最后一个导入是 sys 包，我们将用它来退出
- en: our program.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序。
- en: 2\. Define constants.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 定义常量。
- en: We next define any constants for our program. First we define the
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们为程序定义常量。首先我们定义
- en: RGB value for BLACK, which we will use to paint the background of
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: RGB 值为 BLACK，我们将用它来绘制窗口的背景。
- en: our window. Then we define constants for the width and height of our
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的窗口。然后我们为窗口的宽度和高度定义常量，
- en: window in pixels and a constant for the refresh rate for our program.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 以像素为单位的窗口宽度和高度，并为程序定义一个刷新率常量。
- en: This number defines the maximum number of times the program will
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字定义了程序每秒钟将执行的最大循环次数
- en: loop (and therefore redraw the window) per second. Our value of 30
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒钟的循环次数（因此会重新绘制窗口）。我们的值为 30
- en: is fairly typical. If the amount of work done in our main loop is exces-
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式是相当典型的。如果主循环中执行的工作量过多，
- en: sive, the program might run slower than this value, but it will never
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 由于程序可能会运行得比这个值慢，但永远不会
- en: run faster. A refresh rate that’s too high might cause the program to
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 运行得更快。刷新率过高可能导致程序运行
- en: run too fast. In our ball example, this means the ball might bounce
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 运行过快。在我们的球的示例中，这意味着球可能会反弹
- en: around the window faster than intended.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 使得窗口的周围区域运行速度比预期更快。
- en: 3\. Initialize the pygame environment.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 初始化 pygame 环境。
- en: In this section, we call a function that tells pygame to initialize itself.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们调用一个函数来告诉 pygame 初始化自身。
- en: We then ask pygame to create a window for our program with the
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们让 pygame 为我们的程序创建一个窗口，使用
- en: pygame.display.set_mode() function and pass in the desired width and
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.set_mode() 函数并传入所需的宽度和
- en: height of the window. Finally, we call another pygame function to cre-
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: ate a clock object, which will be used at the bottom of our main loop to
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: maintain our maximum frame rate.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Load assets: image(s), sound(s), and so on.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: This is a placeholder section, into which we will eventually add code to
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: load external images, sounds, and so on from the disk for use in our
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: program. In this basic program we’re not using any external assets, so
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: this section is empty for now.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Initialize variables.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: Here we will eventually initialize any variables that our program will
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: use. Currently we have none, so we have no code here.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '**98** Chapter 5'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Loop forever.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Here we start our main loop. This is a simple while True infinite loop.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: Again, you can think of each iteration through the main loop as one
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: frame in an animation.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Check for and handle events; commonly referred to as the *event loop*.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we call pygame.event.get() to get a list of the events that
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: happened since the last time we checked (the last time the main loop
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: ran), then iterate through the list of events. Each event reported to the
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: program is an object, and every event object has a type. If no event has
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: happened, this section is skipped over.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: In this minimal program, where the only action a user can take is
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: to close the window, the only event type we check for is the constant
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: pygame.QUIT, generated by pygame when the user clicks the close but-
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: ton. If we find this event, we tell pygame to quit, which frees up any
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: resources it was using. Then we quit our program.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: 8\. Do any “per frame” actions.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: In this section we’ll eventually put any code that needs to run in every
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: frame. This might involve moving things in the window or checking for
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: collisions between elements. In this minimal program, we have nothing
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: to do here.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: 9\. Clear the window.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: On each iteration through the main loop, our program must redraw
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: everything in the window, which means we need to clear it first. The
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: simplest approach is to just fill the window with a color, which we do here
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: with a call to window.fill(), specifying a black background. We could also
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: draw a background picture, but we’ll hold off on that for now.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: 10\. Draw all window elements.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: Here we’ll place code to draw everything we want to show in our win-
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: dow. In this sample program there is nothing to draw.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: In real programs, things are drawn in the order they appear in the
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: code, in layers from backmost to frontmost. For example, assume we
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: want to draw two partially overlapping circles, A and B. If we draw A
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: first, A will appear behind B, and portions of A will be obscured by B.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: If we draw B first and then A, the opposite happens, and we see A in
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: front of B. This is a natural mapping equivalent to the layers in graph-
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: ics programs such as Photoshop.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: 11\. Update the window.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: This line tells pygame to take all the drawing we’ve included and show
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: it in the window. Pygame actually does all the drawing in steps 8, 9, and
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: 10 in an off-screen buffer. When you tell pygame to update, it takes the
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: contents of this off-screen buffer and puts them in the real window.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pygame **99**
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 19](index-129_1.png)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
- en: 12\. Slow things down a bit.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: Computers are very fast, and if the loop continued to the next iteration
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: right away without pausing, the program might run faster than the des-
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: ignated frame rate. The line in this section tells pygame to wait until a
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: given amount of time has elapsed in order to make the frames of our
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: program run at the frame rate that we specified. This is important to
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: ensure the program runs at a consistent rate, independent of the speed
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: of the computer on which it’s running.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: When you run this program, the program just puts up a blank window
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: filled with black. To end the program, click on the close button in the
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: title bar.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '***Drawing an Image***'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: Let’s draw something in the window. There are two parts to showing a
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: 'graphic image: first we load the image into the computer’s memory, then we'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: display the image in the application window.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: With pygame, all images (and sounds) need to be kept in files external
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: to your code. Pygame supports many standard graphic file formats, includ-
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: ing *.png*, *.jpg*, and *.gif*. In this program we’ll load a picture of a ball
    from the file *ball.png*. As a reminder, the code and assets associated with all
    the major listings in this book are available for download at [*https://www.nostarch.com/*](https://www.nostarch.com/objectorientedpython/)
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '[*objectorientedpython/* a](https://www.nostarch.com/objectorientedpython/)nd
    [*https://github.com/IrvKalb/O*](https://github.com/IrvKalb/Object-Oriented-Python-Code/)
    *bject-Oriented-Python-Code/*.'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: While we only need one graphic file in this program, it’s a good idea
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: to use a consistent approach to handling graphic and sound files, so I’ll lay
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: one out for you here. First, create a project folder. Place your main program
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: in that folder, along with any related files containing Python classes and
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: functions. Then, inside the project folder, create an *images* folder into which
    you’ll place any image files you want to use in your program. Also create
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: a *sounds* folder and place any sound files you want to use there. Figure 5-6
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: shows the suggested structure. All of the example programs in this book
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: will use this project folder layout.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5-6: Suggested project folder hierarchy*'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: A *path* (also called a *pathname*) is a string that uniquely identifies the
    location of a file or folder on a computer. To load a graphic or sound file
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: into your program, you must specify the path to the file. There are two
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: 'types of paths: relative and absolute.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: A *relative path* is a relative to the current folder, often called the *current*
    *working directory*. When you run a program using an IDE such as IDLE or
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '**100** Chapter 5'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm, it sets the current folder to the one containing your main Python program
    so you can use relative paths with ease. In this book, I will assume
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: you’re using an IDE and will represent all paths as relative paths.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: The relative path for a graphic file (for example, *ball.png*) in the same
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: folder as your main Python file would be just the filename as a string (for
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: example, 'ball.png'). Using the suggested project structure, the relative
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: path would be 'images/ball.png'.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: This says that inside the project folder will be another folder named
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '*images*, and inside that folder is a file named *ball.png*. In path strings,
    folder names are separated by the slash character.'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: However, if you expect to run your program from the command line,
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: then you need to construct absolute paths for all files. An *absolute path*
    is one that starts from the root of the filesystem and includes the full hierarchy
    of folders to your file. To build an absolute path to any file, you can use
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: 'code like this, which builds an absolute path string to the *ball.png* file
    in the *images* folder inside the project folder:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: from pathlib import Path
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: 'Place this in section #2, defining a constant'
  id: totrans-580
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BASE_PATH = Path(__file__).resolve().parent
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: Build a path to the file in the images folder
  id: totrans-582
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pathToBall = BASE_PATH + 'images/ball.png'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll create the code of the ball program, starting with the ear-
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: lier 12-step template and adding just two new lines of code, as shown in
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5-2\.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo1_OneImage/PygameOneImage.py**'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: pygame demo 1 – draw one image
  id: totrans-588
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  id: totrans-590
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: clock = pygame.time.Clock()
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-594
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 ballImage = pygame.image.load('images/ball.png')
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  id: totrans-596
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw all window elements
  id: totrans-598
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: draw ball at position 100 across (x) and 200 down (y)
  id: totrans-599
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2 window.blit(ballImage, (100, 200))
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  id: totrans-601
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Pygame **101**
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: pygame.display.update()
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  id: totrans-604
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-2: Load one image and draw it in every frame.*'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: First, we tell pygame to find the file containing the image of the ball
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: and load that image into memory 1\. The variable ballImage now refers to
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: the image of the ball. Notice that this assignment statement is only exe-
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: cuted once, before the main loop starts.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '*In the official documentation of pygame, every image, including the application
    window, is known as a* surface *. I’ll use more specific terms: I will refer to
    the application* *window simply as a* window *and to any picture loaded from an
    external file as an* image *. I reserve the term* surface *for any picture drawn
    on the fly.*'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: We then tell the program to draw the ball 2 every time we go through
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: the main loop. We specify the location representing the position to place
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: the upper-left corner of the image’s bounding rectangle, typically as a tuple
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: of x- and y-coordinates.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: The function name blit() is a very old reference to the words *bit block*
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: '*transfer*, but in this context it really just means “draw.” Since the program
    loaded the ball image earlier, pygame knows how big the image is, so we'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: just need to tell it where to draw the ball. In Listing 5-2, we give an x value
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: of 100 and a y value of 200\.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: When you run the program, on each iteration through the loop (30
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: times per second) every pixel in the window is set to black, then the ball
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: is drawn over the background. From the user’s point of view, it looks like
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: nothing is happening—the ball just stays in one spot with the upper-left
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: corner of its bounding rectangle at location (100, 200).
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: '***Detecting a Mouse Click***'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll allow our program to detect and react to a mouse click. The user
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: will be able to click on the ball to make it appear somewhere else in the
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: window. When the program detects a mouse click on the ball, it randomly
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: picks new coordinates and draws the ball at that new location. Instead of
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: using hardcoded coordinates of (100, 200), we’ll create two variables, ballX
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: and ballY, and refer to the coordinates of the ball in the window as the
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: tuple (ballX, ballY). Listing 5-3 provides the code.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo2_ImageClickAndMove/PygameImageClickAndMove.py**'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: pygame demo 2 - one image, click and move
  id: totrans-635
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 - Import packages
  id: totrans-636
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: '**102** Chapter 5'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: 1 import random
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: 2 - Define constants
  id: totrans-642
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BLACK = (0, 0, 0)
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_WIDTH = 640
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_HEIGHT = 480
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: 2 BALL_WIDTH_HEIGHT = 100
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: MAX_WIDTH = WINDOW_WIDTH - BALL_WIDTH_HEIGHT
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: MAX_HEIGHT = WINDOW_HEIGHT - BALL_WIDTH_HEIGHT
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  id: totrans-650
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: clock = pygame.time.Clock()
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-654
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ballImage = pygame.image.load('images/ball.png')
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  id: totrans-656
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 ballX = random.randrange(MAX_WIDTH)
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: ballY = random.randrange(MAX_HEIGHT)
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: 4 ballRect = pygame.Rect(ballX, ballY, BALL_WIDTH_HEIGHT, BALL_WIDTH_HEIGHT)
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  id: totrans-660
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  id: totrans-662
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: Clicked the close button? Quit pygame and end the program
  id: totrans-664
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: See if user clicked
  id: totrans-668
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '5 if event.type == pygame.MOUSEBUTTONUP:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: 'mouseX, mouseY = event.pos # Could do this if we needed it'
  id: totrans-670
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check if the click was in the rect of the ball
  id: totrans-671
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If so, choose a random new location
  id: totrans-672
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6 if ballRect.collidepoint(event.pos):'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: ballX = random.randrange(MAX_WIDTH)
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: ballY = random.randrange(MAX_HEIGHT)
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: ballRect = pygame.Rect(ballX, ballY, BALL_WIDTH_HEIGHT,
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: BALL_WIDTH_HEIGHT)
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: 8 Do any "per frame" actions
  id: totrans-678
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 9 - Clear the window
  id: totrans-679
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(BLACK)
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw all window elements
  id: totrans-681
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Draw the ball at the randomized location
  id: totrans-682
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 7 window.blit(ballImage, (ballX, ballY))
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pygame **103**
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  id: totrans-685
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  id: totrans-687
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-3: Detecting a mouse click and acting on it*'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: Since we need to generate random numbers for the ball coordinates,
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: we import the random package 1\.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: We then add a new constant to define the height and width of our
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: image as 100 pixels 2\. We also create two more constants to limit the maxi-
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: mum width and height coordinates. By using these constants rather than
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: the size of the window, we ensure that our ball image will always appear
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: fully within the window (remember that when we refer to the location of an
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: image, we are specifying the position of its upper-left corner). We use those
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: constants to choose random values for the starting x- and y-coordinates for
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: our ball 3\.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call pygame.Rect() to create a rectangle 4\. Defining a rectangle
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: requires four parameters—an x-coordinate, a y-coordinate, a width, and a
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: 'height, in that order:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: '*<rectObject>* = pygame.Rect( *<x>* , *<y>* , *<width>* , *<height>* ) This
    returns a pygame rectangle object, or rect. We’ll use the rectangle'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: of the ball in the processing of events.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: We also add code to check if the user clicked the mouse. As mentioned,
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: 'a mouse click is actually made up of two different events: a mouse down'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: event and a mouse up event. Since the mouse up event is typically used to
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: signal activation, we’ll only look for that event here. This event is signaled
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: by a new event.type value of pygame.MOUSEBUTTONUP 5\. When we find that a
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: mouse up event has occurred, we’ll then check to see if the location where
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: the user clicked was inside the current rectangle of the ball.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: When pygame detects that an event has happened, it builds an event
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: object containing a lot of data. In this case, we only care about the x- and
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: y-coordinates where the event happened. We retrieve the (x, y) position of
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: the click using event.pos, which provides a tuple of two values.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '*If we need to separate the x- and y-coordinates of the click, we can unpack
    the tuple* *and store the values into two variables like this:*'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: mouseX, mouseY = event.pos
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: Now we check to see if the event happened inside the rectangle of the
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: 'ball using collidepoint() 6, whose syntax is:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: '*<booleanVariable>* = *<someRectangle>* .collidepoint( *<someXYLocation>* )
    **104** Chapter 5'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: The method returns a Boolean True if the given point is inside the rectangle.
    If the user has clicked the ball, we randomly select new values for
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: ballX and ballY. We use those values to create a new rectangle for the ball
    at
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: the new random location.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: The only change here is that we always draw the ball at the location
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: given by the tuple (ballX, ballY) 7\. The effect is that whenever the user
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: clicks inside the rectangle of the ball, the ball appears to move to some new
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: random spot in the window.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: '***Handling the Keyboard***'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to allow the user to control some aspect of the program
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: through the keyboard. There are two different ways to handle user key-
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: 'board interactions: as individual key presses, and when a user holds down a'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: key to indicate that an action should happen for as long as that key is down
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: (known as *continuous mode*).
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: '**Recognizing Individual Key Presses**'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the mouse clicks, each key press generates two events: key down and key'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: 'up. The two events have different event types: pygame.KEYDOWN and pygame.KEYUP.'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5-4 shows a small sample program that allows the user to move
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: the ball image in the window using the keyboard. The program also shows
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: a target rectangle in the window. The user’s goal is to move the ball image
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: so that it overlaps with the target image.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo3_MoveByKeyboard/PygameMoveByKeyboardOncePerKey.py**'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: pygame demo 3(a) - one image, move by keyboard
  id: totrans-743
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 - Import packages
  id: totrans-744
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: import random
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: 2 - Define constants
  id: totrans-749
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BLACK = (0, 0, 0)
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_WIDTH = 640
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_HEIGHT = 480
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: BALL_WIDTH_HEIGHT = 100
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: MAX_WIDTH = WINDOW_WIDTH - BALL_WIDTH_HEIGHT
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: MAX_HEIGHT = WINDOW_HEIGHT - BALL_WIDTH_HEIGHT
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: 1 TARGET_X = 400
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: TARGET_Y = 320
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: TARGET_WIDTH_HEIGHT = 120
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: N_PIXELS_TO_MOVE = 3
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  id: totrans-761
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pygame **105**
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: clock = pygame.time.Clock()
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-766
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ballImage = pygame.image.load('images/ball.png')
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: 2 targetImage = pygame.image.load('images/target.jpg')
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  id: totrans-769
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ballX = random.randrange(MAX_WIDTH)
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: ballY = random.randrange(MAX_HEIGHT)
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: targetRect = pygame.Rect(TARGET_X, TARGET_Y, TARGET_WIDTH_HEIGHT, TARGET_
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: WIDTH_HEIGHT)
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  id: totrans-774
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  id: totrans-776
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: Clicked the close button? Quit pygame and end the program
  id: totrans-778
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: See if the user pressed a key
  id: totrans-782
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3 elif event.type == pygame.KEYDOWN:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.key == pygame.K_LEFT:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: ballX = ballX - N_PIXELS_TO_MOVE
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: 'elif event.key == pygame.K_RIGHT:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: ballX = ballX + N_PIXELS_TO_MOVE
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: 'elif event.key == pygame.K_UP:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: ballY = ballY - N_PIXELS_TO_MOVE
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: 'elif event.key == pygame.K_DOWN:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: ballY = ballY + N_PIXELS_TO_MOVE
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: 8 Do any "per frame" actions
  id: totrans-792
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check if the ball is colliding with the target
  id: totrans-793
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4 ballRect = pygame.Rect(ballX, ballY,
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: BALL_WIDTH_HEIGHT, BALL_WIDTH_HEIGHT)
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: '5 if ballRect.colliderect(targetRect):'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: print('Ball is touching the target')
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: 9 - Clear the window
  id: totrans-798
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(BLACK)
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw all window elements
  id: totrans-800
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6 window.blit(targetImage, (TARGET_X, TARGET_Y)) # draw the target'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: 'window.blit(ballImage, (ballX, ballY)) # draw the ball'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  id: totrans-803
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  id: totrans-805
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-4: Detecting and acting on single key presses*'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: '**106** Chapter 5'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: First we add a few new constants 1 to define the x- and y-coordinates of the
    upper-left corner of the target rectangle and the width and height of
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: the target. We then load the image of the target rectangle 2\.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: In the loop where we look for for events, we add a test for a key press
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: by checking for an event of type pygame.KEYDOWN 3\. If a key down event is
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: detected, we look into the event to find out what key was pressed. Each
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: key has an associated constant in pygame, so here we check if the user has
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: pressed the left, up, down, or right arrow. For each of these keys, we modify
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: the value of the ball’s x- or y-coordinate appropriately by a small number
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: of pixels.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: Next we create a pygame rect object for the ball based on its x- and
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: y-coordinates and its height and width 4\. We can check to see if two rect-
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: 'angles overlap with the following call:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: '*<booleanVariable>* = *<rect1>* .colliderect( *<rect2>* ) This call compares
    two rectangles and returns True if they overlap at all'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: or False if they don’t. We compare the ball rectangle with the target rectan-
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: gle 5, and if they overlap, the program prints “Ball is touching the target”
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: to the shell window.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: The last change is where we draw both the target and the ball. The
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: target is drawn first so that when the two overlap, the ball appears over
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: the target 6\.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: When the program is run, if the rectangle of the ball overlaps the rect-
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: angle of the target, the message is written to the shell window. If you move
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: the ball away from the target, the message stops being written out.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: '**Dealing with Repeating Keys in Continuous Mode**'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: The second way to handle keyboard interactions in pygame is to *poll* the
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: keyboard. This involves asking pygame for a list representing which keys
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: 'are currently down in every frame using the following call:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: '*<aTuple>* = pygame.key.get_pressed()'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: 'This call returns a tuple of 0s and 1s representing the state of each key:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: 0 if the key is up, 1 if the key is down. You can then use constants defined
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: within pygame as an index into the returned tuple to see if a *particular* key
    is down. For example, the following lines can be used to determine the
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: 'state of the A key:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: keyPressedTuple = pygame.key.get_pressed()
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: Now use a constant to get the appropriate element of the tuple
  id: totrans-841
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: aIsDown = keyPressedTuple[pygame.K_a]
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: The full listing of constants representing all keys defined in pygame
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: can be found a[t *https://www.pygame.org/docs/ref/key.html*.](https://www.pygame.org/docs/ref/key.html)
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pygame **107**
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: The code in Listing 5-5 shows how we can use this technique to move an image
    continuously rather than once per key press. In this version, we
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: 'move the keyboard handling from section #7 to section #8\. The rest of the'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: code is identical to the previous version in Listing 5-4\.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo3_MoveByKeyboard/PygameMoveByKeyboardContinuous.py**'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: pygame demo 3(b) - one image, continuous mode, move as long as a key is down
  id: totrans-850
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  id: totrans-852
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: Clicked the close button? Quit pygame and end the program
  id: totrans-854
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  id: totrans-858
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check for user pressing keys
  id: totrans-859
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 keyPressedTuple = pygame.key.get_pressed()
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: 'if keyPressedTuple[pygame.K_LEFT]: # moving left'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: ballX = ballX - N_PIXELS_TO_MOVE
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: 'if keyPressedTuple[pygame.K_RIGHT]: # moving right'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: ballX = ballX + N_PIXELS_TO_MOVE
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: 'if keyPressedTuple[pygame.K_UP]: # moving up'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: ballY = ballY - N_PIXELS_TO_MOVE
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: 'if keyPressedTuple[pygame.K_DOWN]: # moving down'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: ballY = ballY + N_PIXELS_TO_MOVE
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: Check if the ball is colliding with the target
  id: totrans-869
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ballRect = pygame.Rect(ballX, ballY,
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: BALL_WIDTH_HEIGHT, BALL_WIDTH_HEIGHT)
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: 'if ballRect.colliderect(targetRect):'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: print('Ball is touching the target')
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-5: Handling keys being held down*'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: The keyboard-handling code in Listing 5-5 does not rely on events,
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: so we place the new code outside of the for loop that iterates through all
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: events returned by pygame 1\.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: Because we are doing this check in every frame, the movement of the
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: ball will appear to be continuous as long as the user holds down a key. For
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: example, if the user presses and holds the right arrow key, this code will
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: add 3 to the value of the ballX coordinate in every frame, and the user will
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: see the ball moving smoothly to the right. When they stop pressing the key,
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: the movement stops.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: '**108** Chapter 5'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: The other change is that this approach allows you to check for multiple keys
    being down at the same time. For example, if the user presses and holds
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: the left and down arrow keys, the ball will move diagonally down and to the
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: left. You can check for as many keys being held down as you wish. However,
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: the number of *simultaneous* key presses that can be detected is limited by
    the operating system, the keyboard hardware, and many other factors. The
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: typical limit is around four keys, but your mileage may vary.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a Location-Based Animation***'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll build a location-based animation. This code will allow us to
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: move an image diagonally and then have it appear to bounce off the edges
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: of the window. This was a favorite technique of screensavers on old CRT-
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: based monitors, to avoid burning in a static image.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: We’ll change the location of our image slightly in every frame. We’ll
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: also check if the result of that movement would place any part of the image
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: outside one of the window boundaries and, if so, reverse the movement in
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: that direction. For example, if the image was moving down and would cross
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: the bottom of the window, we would reverse the direction and make the
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: image start moving up.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: We’ll again use the same starting template. Listing 5-6 gives the full
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: source code.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo4_OneBal Bounce/PygameOneBal BounceXY.py**'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: pygame demo 4(a) - one image, bounce around the window using (x, y) coords
  id: totrans-905
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 - Import packages
  id: totrans-906
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: import random
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: 2 - Define constants
  id: totrans-911
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BLACK = (0, 0, 0)
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_WIDTH = 640
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_HEIGHT = 480
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: BALL_WIDTH_HEIGHT = 100
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: N_PIXELS_PER_FRAME = 3
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  id: totrans-918
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: clock = pygame.time.Clock()
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-922
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ballImage = pygame.image.load('images/ball.png')
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  id: totrans-924
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Pygame **109**
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: MAX_WIDTH = WINDOW_WIDTH - BALL_WIDTH_HEIGHT
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: MAX_HEIGHT = WINDOW_HEIGHT - BALL_WIDTH_HEIGHT
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: 1 ballX = random.randrange(MAX_WIDTH)
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: ballY = random.randrange(MAX_HEIGHT)
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: xSpeed = N_PIXELS_PER_FRAME
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: ySpeed = N_PIXELS_PER_FRAME
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  id: totrans-932
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  id: totrans-934
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: Clicked the close button? Quit pygame and end the program
  id: totrans-936
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  id: totrans-940
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2 if (ballX < 0) or (ballX >= MAX_WIDTH):'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: 'xSpeed = -xSpeed # reverse X direction'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: 'if (ballY < 0) or (ballY >= MAX_HEIGHT):'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: 'ySpeed = -ySpeed # reverse Y direction'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: Update the ball's location, using the speed in two directions
  id: totrans-945
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 ballX = ballX + xSpeed
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: ballY = ballY + ySpeed
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: 9 - Clear the window before drawing it again
  id: totrans-948
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(BLACK)
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw the window elements
  id: totrans-950
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.blit(ballImage, (ballX, ballY))
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  id: totrans-952
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  id: totrans-954
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: clock.tick(FRAMES_PER_SECOND)
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-6: A location-based animation, bouncing a ball around the window*'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating and initializing the two variables xSpeed and ySpeed 1,
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: which determine how far and in what direction the image should move in
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: each frame. We initialize both variables to the number of pixels to move per
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: frame (3), so the image will start by moving three pixels to the right (the
    posi-
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: tive x direction) and three pixels down (the positive y direction).
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: In the key part of the program, we handle the x- and y-coordinates
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: separately 2\. First, we check to see if the x-coordinate of the ball is less
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: than zero, meaning that part of the image is off the left edge, or past the
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: MAX_WIDTH pixel and so effectively off the right edge. If either of these is
    the
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: case, we reverse the sign of the speed in the x direction, meaning it will go
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: in the opposite direction. For example, if the ball was moving to the right
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: '**110** Chapter 5'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: and went off the right edge, we would change the value of xSpeed from 3 to
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: –3 to cause the ball to start moving to the left, and vice versa.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: Then we do a similar check for the y-coordinate to make the ball
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: bounce off the top or bottom edge, as needed.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we update the position of the ball by adding the xSpeed to the
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: ballX coordinate and adding the ySpeed to the ballY coordinate 3\. This posi-
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: tions the ball at a new location on both axes.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the main loop, we draw the ball. Since we’re updat-
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: ing the values of ballX and ballY in every frame, the ball appears to ani-
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: mate smoothly. Try it out. Whenever the ball reaches any edge, it seems to
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: bounce off.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Pygame rects***'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: Next I’ll present a different way to achieve the same result. Rather than
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: keeping track of the current x- and y-coordinates of the ball in separate
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: variables, we’ll use the rect of the ball, update the rect every frame, and
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: check if performing the update would cause any part of the rect to move
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: outside an edge of the window. This results in fewer variables, and because
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: we’ll start by making a call to get the rect of an image, it will work with
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: images of any size.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: When you create a rect object, in addition to remembering the left, top,
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: width, and height as attributes of the rectangle, that object also calculates
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: and maintains a number of other attributes for you. You can access any of
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: these attributes directly by name using *dot syntax*, as shown in Table 5-1\.
    (I’ll provide more detail on this i[n Chapter 8.)](index_split_003.html#p192)
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-1:** Direct Access to Attributes of a rect'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: '**Attribute**'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: '**Description**'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .x'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: The x-coordinate of the left edge of the rect
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .y'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: The y-coordinate of the top edge of the rect
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .left'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: The x-coordinate of the left edge of the rect (same as
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .x)'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .top'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: The y-coordinate of the top edge of the rect (same as
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .y)'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .right'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
- en: The x-coordinate of the right edge of the rect
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .bottom'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: The y-coordinate of the bottom edge of the rect
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .topleft'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
- en: 'A two-integer tuple: the coordinates of the upper-left corner of'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
- en: the rect
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .bottomleft'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
- en: 'A two-integer tuple: the coordinates of the lower-left corner of'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: the rect
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .topright'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: 'A two-integer tuple: the coordinates of the upper-right corner of'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: the rect
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .bottomright'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: 'A two-integer tuple: the coordinates of the lower-right corner of'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
- en: the rect
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: '*(continued)*'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pygame **111**
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-1:** Direct Access to Attributes of a rect *(continued)* **Attribute**'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
- en: '**Description**'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .midtop'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: 'A two-integer tuple: the coordinates of the midpoint of the top'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
- en: edge of the rect
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .midleft'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: 'A two-integer tuple: the coordinates of the midpoint of the left'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: edge of the rect
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .midbottom'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: 'A two-integer tuple: the coordinates of the midpoint of the bot-'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: tom edge of the rect
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .midright'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: 'A two-integer tuple: the coordinates of the midpoint of the right'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
- en: edge of the rect
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .center'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: 'A two-integer tuple: the coordinates at the center of the rect'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .centerx'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: The x-coordinate of the center of the width of the rect
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .centery'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: The y-coordinate of the center of the height of the rect
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .size'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: 'A two-integer tuple: the (width, height) of the rect'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .width'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: The width of the rect
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .height'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: The height of the rect
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .w'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: The width of the rect (same as *<rect>* .width)
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .h'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
- en: The height of the rect (same as *<rect>* .height)
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: A pygame rect also can be thought of, and accessed as, a list of four ele-
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: ments. Specifically, you can use an index to get or set any individual part
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: of a rect. For instance, using the ballRect, the individual elements can be
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
- en: 'accessed as:'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: • ballRect[0] is the x value (but you could also use ballRect.left)
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: • ballRect[1] is the y value (but you could also use ballRect.top)
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: • ballRect[2] is the width (but you could also use ballRect.width)
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: • ballRect[3] is the height (but you could also use ballRect.height)
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5-7 is an alternative version of our bouncing ball program that
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: maintains all the information about the ball in a rectangle object.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo4_OneBal Bounce/PygameOneBal BounceRects.py**'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: pygame demo 4(b) - one image, bounce around the window using rects
  id: totrans-1064
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 - Import packages
  id: totrans-1065
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: import random
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
- en: 2 - Define constants
  id: totrans-1070
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BLACK = (0, 0, 0)
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_WIDTH = 640
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_HEIGHT = 480
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
- en: '**112** Chapter 5'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
- en: N_PIXELS_PER_FRAME = 3
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  id: totrans-1077
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
- en: clock = pygame.time.Clock()
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-1081
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ballImage = pygame.image.load('images/ball.png')
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  id: totrans-1083
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 ballRect = ballImage.get_rect()
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
- en: MAX_WIDTH = WINDOW_WIDTH - ballRect.width
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: MAX_HEIGHT = WINDOW_HEIGHT - ballRect.height
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: ballRect.left = random.randrange(MAX_WIDTH)
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
- en: ballRect.top = random.randrange(MAX_HEIGHT)
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: xSpeed = N_PIXELS_PER_FRAME
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: ySpeed = N_PIXELS_PER_FRAME
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  id: totrans-1091
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  id: totrans-1093
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: Clicked the close button? Quit pygame and end the program
  id: totrans-1095
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  id: totrans-1099
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2 if (ballRect.left < 0) or (ballRect.right >= WINDOW_WIDTH):'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: 'xSpeed = -xSpeed # reverse X direction'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
- en: 'if (ballRect.top < 0) or (ballRect.bottom >= WINDOW_HEIGHT):'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
- en: 'ySpeed = -ySpeed # reverse Y direction'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: Update the ball's rectangle using the speed in two directions
  id: totrans-1104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ballRect.left = ballRect.left + xSpeed
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: ballRect.top = ballRect.top + ySpeed
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: 9 - Clear the window before drawing it again
  id: totrans-1107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(BLACK)
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw the window elements
  id: totrans-1109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 window.blit(ballImage, ballRect)
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  id: totrans-1111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  id: totrans-1113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: clock.tick(FRAMES_PER_SECOND)
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-7: A location-based animation, bouncing a ball around the window,
    using rects* Introduction to Pygame **113**'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
- en: This approach of using a rect object is neither better nor worse than using
    separate variables. The resulting program works exactly the same as
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
- en: the original. The important lesson here is how you can use and manipulate
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: attributes of a rect object.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
- en: After loading the image of the ball, we call the get_rect() method 1
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: to get the bounding rectangle of the image. That call returns a rect object,
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: which we store into a variable called ballRect. We use ballRect.width and
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
- en: ballRect.height to get direct access to the width and height of the ball image.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
- en: (In the previous version, we used a constant of 100 for the width and the
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: height.) Getting these values from the image that was loaded makes our code
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
- en: much more adaptable because it means we can use a graphic of any size.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
- en: The code also uses the attributes of the rectangle rather than using
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
- en: separate variables for checking if any part of the ball’s rectangle goes over
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
- en: an edge. We can use ballRect.left and ballRect.right to see if the ballRect
    is
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
- en: off the left or right edges 2\. We do a similar test with ballRect.top and ball-
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: Rect.bottom. Rather than updating individual x- and y-coordinate variables,
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: we update the left and top of the ballRect.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: The other subtle but important change is in the call to draw the ball 3\.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: The second argument in the call to blit() can be either an (x, y) tuple or a
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: rect. The code inside blit() uses the left and top position in the rect as the
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: x- and y-coordinates.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: '**Playing Sounds**'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of sounds that you might want to play in your pro-
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: 'grams: short sound effects and background music.'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: '***Playing Sound Effects***'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: All sound effects must live in external files and must be in either *.wav* or
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: '*.ogg* format. Playing a relatively short sound effect consists of two steps:
    load the sound from an external sound file once; then at the appropriate time(s)'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: play your sound.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: 'To load a sound effect into memory, you use a line like this:'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: '*<soundVariable>* = pygame.mixer.Sound( *<path to sound file>* ) To play the
    sound effect, you only need to call its play() method:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: '*<soundVariable>* .play()'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: We’ll modify Listing 5-7 to add a “boing” sound effect whenever the
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: ball bounces off a side of the window. There is a *sounds* folder in the project
    folder at the same level as the main program. Right after loading the ball
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: 'image, we load the sound file by adding this code:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-1149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ballImage = pygame.image.load('images/ball.png')
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: bounceSound = pygame.mixer.Sound('sounds/boing.wav')
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: '**114** Chapter 5'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
- en: 'To play the “boing” sound effect whenever we change either the horizontal or
    vertical direction of the ball, we modify section #8 to look like this:'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  id: totrans-1154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if (ballRect.left < 0) or (ballRect.right >= WINDOW_WIDTH):'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: 'xSpeed = -xSpeed # reverse X direction'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: bounceSound.play()
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: 'if (ballRect.top < 0) or (ballRect.bottom >= WINDOW_HEIGHT):'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: 'ySpeed = -ySpeed # reverse Y direction'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: bounceSound.play()
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: When you find a condition that should play a sound effect, you add a
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: call to the play() method of the sound. There are many more options for
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: controlling sound effects; you can find details in the official documentation
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: at [*https://www.pygame.org/docs/ref/mixer.html*](https://www.pygame.org/docs/ref/mixer.html).
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: '***Playing Background Music***'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: Playing background music involves two lines of code using calls to the
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: pygame.mixer.music module. First, you need this to load the sound file into
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: 'memory:'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: pygame.mixer.music.load( *<path to sound file>* )
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: 'The *<path to sound file>* is a path string where the sound file can be found.
    You can use *.mp3* files, which seem to work best, as well as *.wav* or *.ogg*
    files. When you want to start the music playing, you need to make this call:'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: pygame.mixer.music.play( *<number of loops>* , *<starting position>* ) To play
    some background music repeatedly, you can pass in a -1 for
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: '*<number of loops>* to run the music forever. The *<starting position>* is
    typically set to 0 to indicate that you want to play the sound from the beginning.'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: There is a downloadable, modified version of the bouncing ball pro-
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
- en: gram that properly loads the sound effect and background music files and
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: 'starts the background sound playing. The only changes are in section #4, as'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: shown here.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo4_OneBal Bounce/PyGameOneBal BounceWithSound.py**'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-1178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ballImage = pygame.image.load('images/ball.png')
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: bounceSound = pygame.mixer.Sound('sounds/boing.wav')
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: pygame.mixer.music.load('sounds/background.mp3')
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: pygame.mixer.music.play(-1, 0.0)
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
- en: Pygame allows for much more intricate handling of background
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: sounds. You can find the full documentation a[t *https://www.pygame.org/docs/*](https://www.pygame.org/docs/ref/music.html#module-pygame.mixer.music)
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
- en: '[*ref/music.html#module-pygame.mixer.music*](https://www.pygame.org/docs/ref/music.html#module-pygame.mixer.music).'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pygame **115**
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: '*In order to make future examples more clearly focused on OOP, I’ll leave out
    calls to* *play sound effects and background music. But adding sounds greatly
    enhances the* *user experience of a game, and I strongly encourage including them.*'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
- en: '**Drawing Shapes**'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: Pygame offers a number of built-in functions that allow you to draw certain
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
- en: shapes known as *primitives*, which include lines, circles, ellipses, arcs,
    polygons, and rectangles. Table 5-2 provides a list of these functions. Note that
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
- en: there are two calls that draw *anti-aliased* lines. These are lines that include
    blended colors at the edges to make the lines look smooth and less jagged.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two key advantages to using these drawing functions: they exe-'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
- en: cute extremely quickly, and they allow you to draw simple shapes without
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
- en: having to create or load images from external files.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-2:** Functions for Drawing Shapes'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: '**Function**'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
- en: '**Description**'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.aaline()
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
- en: Draws an anti-aliased line
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.aalines()
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: Draws a series of anti-aliased lines
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.arc()
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: Draws an arc
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.circle()
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: Draws a circle
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.ellipse()
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: Draws an ellipse
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.line()
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: Draws a line
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.lines()
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
- en: Draws a series of lines
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.polygon()
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: Draws a polygon
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.rect()
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: Draws a rectangle
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-7 shows the output of a sample program that demonstrates
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: calls to these primitive drawing functions.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5-8 is the code of the sample program, using the same 12-step
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: template that produced the output in Figure 5-7\.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo5_DrawingShapes.py**'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
- en: pygame demo 5 - drawing
  id: totrans-1222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  id: totrans-1225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: Clicked the close button? Quit pygame and end the program
  id: totrans-1227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: '**116** Chapter 5'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  id: totrans-1232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 9 - Clear the window
  id: totrans-1233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(GRAY)
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: '1 # 10 - Draw all window elements'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
- en: Draw a box
  id: totrans-1236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'pygame.draw.line(window, BLUE, (20, 20), (60, 20), 4) # top'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: 'pygame.draw.line(window, BLUE, (20, 20), (20, 60), 4) # left'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: 'pygame.draw.line(window, BLUE, (20, 60), (60, 60), 4) # right'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: 'pygame.draw.line(window, BLUE, (60, 20), (60, 60), 4) # bottom'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: Draw an X in the box
  id: totrans-1241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.draw.line(window, BLUE, (20, 20), (60, 60), 1)
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.line(window, BLUE, (20, 60), (60, 20), 1)
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
- en: Draw a filled circle and an empty circle
  id: totrans-1244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'pygame.draw.circle(window, GREEN, (250, 50), 30, 0) # filled'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: 'pygame.draw.circle(window, GREEN, (400, 50), 30, 2) # 2 pixel edge'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: Draw a filled rectangle and an empty rectangle
  id: totrans-1247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'pygame.draw.rect(window, RED, (250, 150, 100, 50), 0) # filled'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
- en: 'pygame.draw.rect(window, RED, (400, 150, 100, 50), 1) # 1 pixel edge'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: Draw a filled ellipse and an empty ellipse
  id: totrans-1250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'pygame.draw.ellipse(window, YELLOW, (250, 250, 80, 40), 0) # filled'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: 'pygame.draw.ellipse(window, YELLOW, (400, 250, 80, 40), 2) # 2 pixel edge'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
- en: Draw a six-sided polygon
  id: totrans-1253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.draw.polygon(window, TEAL, ((240, 350), (350, 350),
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
- en: (410, 410), (350, 470),
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
- en: (240, 470), (170, 410)))
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
- en: Draw an arc
  id: totrans-1257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.draw.arc(window, BLUE, (20, 400, 100, 100), 0, 2, 5)
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
- en: 'Draw anti-aliased lines: a single line, then a list of points'
  id: totrans-1259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.draw.aaline(window, RED, (500, 400), (540, 470), 1)
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.aalines(window, BLUE, True,
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: ((580, 400), (587, 450),
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
- en: (595, 460), (600, 444)), 1)
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  id: totrans-1264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  id: totrans-1266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-8: A program to demonstrate cal s to primitive drawing functions
    in pygame* The drawing of all the primitives occurs in section #10 1\. We make'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: calls to pygame’s drawing functions to draw a box with two diagonals, filled
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
- en: and empty circles, filled and empty rectangles, filled and empty ovals, a six-
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: sided polygon, an arc, and two anti-aliased lines.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pygame **117**
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 20](index-147_1.png)'
  id: totrans-1273
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-7: A sample program that demonstrates using cal s to draw primitive
    shapes*'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
- en: '***Reference for Primitive Shapes***'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: For your reference, here is the documentation for the pygame methods to
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: draw these primitives. In all of the following, the color argument expects
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
- en: 'you to pass in a tuple of RGB values:'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
- en: '**Anti-aliased line**'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.aaline(window, color, startpos, endpos, blend=True)
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
- en: Draws an anti-aliased line in the window. If blend is True, the shades will
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
- en: be blended with existing pixel shades instead of overwriting pixels.
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
- en: '**Anti-aliased lines**'
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.aalines(window, color, closed, points, blend=True)
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
- en: Draws a sequence of anti-aliased lines in the window. The closed argu-
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
- en: ment is a simple Boolean; if it’s True, a line will be drawn between the
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: first and last points to complete the shape. The points argument is a list
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
- en: or tuple of (x, y) coordinates to be connected by line segments (there
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
- en: must be at least two). The Boolean blend argument, if set to True, will
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
- en: blend the shades with existing pixel shades instead of overwriting them.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
- en: '**118** Chapter 5'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
- en: '**Arc**'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.arc(window, color, rect, angle_start, angle_stop, width=0)
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
- en: Draws an arc in the window. The arc will fit inside the given rect. The
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
- en: two angle arguments are the initial and final angles (in radians, with
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
- en: zero on the right). The width argument is the thickness to draw the
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
- en: outer edge.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
- en: '**Circle**'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.circle(window, color, pos, radius, width=0)
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: Draws a circle in the window. The pos is the center of the circle, and
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
- en: radius is the radius. The width argument is the thickness to draw the
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
- en: outer edge. If width is 0, then the circle will be filled.
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: '**Ellipse**'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.ellipse(window, color, rect, width=0)
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: Draws an ellipse in the window. The given rect is the area that the
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
- en: ellipse will fill. The width argument is the thickness to draw the outer
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: edge. If width is 0, then the ellipse will be filled.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
- en: '**Line**'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.line(window, color, startpos, endpos, width=1)
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
- en: Draws a line in a window. The width argument is the thickness of the line.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines**'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.lines(window, color, closed, points, width=1)
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
- en: Draws a sequence of lines in the window. The closed argument is a simple
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
- en: Boolean; if it’s True, a line will be drawn between the first and last points
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
- en: to complete the shape. The points argument is a list or tuple of (x, y)
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
- en: coordinates to be connected by line segments (there must be at least
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
- en: two). The width argument is the thickness of the line. Note that specify-
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
- en: ing a line width wider than 1 does not fill in the gaps between the lines.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, wide lines and sharp corners won’t be joined seamlessly.
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
- en: '**Polygon**'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.polygon(window, color, pointslist, width=0)
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
- en: Draws a polygon in the window. The pointslist specifies the vertices
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
- en: of the polygon. The width argument is the thickness to draw the outer
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
- en: edge. If width is 0, then the polygon will be filled.
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pygame **119**
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
- en: '**Rectangle**'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.rect(window, color, rect, width=0)
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
- en: Draws a rectangle in the window. The rect is the area of the rectangle.
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
- en: The width argument is the thickness to draw the outer edge. If width is 0,
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
- en: then the rectangle will be filled.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
- en: '*For additional information, see* [http://www.pygame.org/docs/ref/draw.html
    *.*](http://www.pygame.org/docs/ref/draw.html)'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
- en: The set of primitive calls allows you the flexibility to draw any shapes
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
- en: you wish. Again, the order in which you make calls is important. Think of
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
- en: the order of your calls as layers; elements that are drawn early can be over-
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
- en: laid by later calls to any other drawing primitive function.
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter I introduced the basics of pygame. You installed pygame on
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
- en: your computer, then learned about the model of event-driven programming
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
- en: and the use of events, which is very different from coding text-based pro-
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
- en: grams. I explained the coordinate system of pixels in a window and the way
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
- en: that colors are represented in code.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
- en: To start right at the beginning with pygame, I introduced a 12-section
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
- en: template that does nothing but bring up a window and can be used to build
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
- en: any pygame-based program. Using that framework, we then built sample
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
- en: programs that showed how to draw an image in the window (using blit()),
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
- en: how to detect mouse events, and how to handle keyboard input. The next
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
- en: demonstration explained how to build a location-based animation.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
- en: Rectangles are highly important in pygame, so I covered how the attri-
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
- en: butes of a rect object can be used. I also provided some example code to
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
- en: show how to play sound effects and background music to enhance the user’s
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
- en: enjoyment of your programs. Finally, I introduced how to use pygame meth-
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
- en: ods to draw primitive shapes in a window.
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
- en: While I have introduced many concepts within pygame, almost every-
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
- en: thing I showed in this chapter has essentially been procedural. The rect
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
- en: object is an example of object-oriented code built directly into pygame. In
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
- en: the next chapter, I’ll show how to use OOP in code to use pygame more
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
- en: effectively.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
- en: '**120** Chapter 5'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
- en: '**6**'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
- en: '**O B J E C T- O R I E N T E D P Y G A M E**'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter I’ll demonstrate how you
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
- en: can use OOP techniques effectively within
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
- en: the pygame framework. We’ll start off with
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
- en: an example of procedural code, then split that
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
- en: code into a single class and some main code that calls
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
- en: the methods of that class. After that, we’ll build two
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
- en: classes, SimpleButton and SimpleText, that implement
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
- en: 'basic user interface widgets: a button and a field for'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
- en: displaying text. I’ll also introduce the concept of a
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
- en: callback.
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
- en: '**Building the Screensaver Ball with OOP Pygame**'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
- en: I[n Chapter 5, w](#p118)e created an old-school screensaver where a ball bounced
    around inside a window (Listing 5-6, if you need to refresh your memory).
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
- en: That code works, but the data for the ball and the code to manipu-
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
- en: late the ball are intertwined, meaning there’s a lot of initialization code,
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
- en: and the code to update and draw the ball are embedded in the 12-step
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
- en: framework.
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
- en: A more modular approach is to split the code into a Ball class and a
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
- en: main program that instantiates a Ball object and makes calls to its methods.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
- en: In this section we’ll make this split, and I’ll show you how to create multiple
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
- en: balls from the Ball class.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a Ball Class***'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by extracting all code relating to the ball from the main pro-
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
- en: gram and moving it into a separate Ball class. Looking at the original code,
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
- en: 'we can see that the sections that deal with the ball are:'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
- en: '• Section #4, which loads the image of the ball'
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
- en: '• Section #5, which creates and initializes all the variables that have'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
- en: something to do with the ball
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
- en: '• Section #8, which includes code for moving the ball, detecting an edge'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
- en: bounce, and changing speed and direction
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
- en: '• Section #10, which draws the ball'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
- en: From this we can conclude that our Ball class will require the following
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
- en: 'methods:'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
- en: '**create()** Loads an image, sets a location, and initializes all instance'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
- en: variables
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
- en: '**update()** Changes the location of the ball in every frame, based on the'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
- en: x speed and y speed of the ball
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
- en: '**draw()** Draws the ball in the window'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to create a project folder, in which you need a *Ball.py*
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
- en: for the new Ball class, the main code file *Main_BallBounce.py*, and an *images*
    folder containing the *ball.png* image file.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6-1 shows the code of the new Ball class.
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo6_Bal BounceObjectOriented/Bal .py**'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
- en: import pygame
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
- en: import random
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
- en: Ball class
  id: totrans-1406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class Ball():'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
- en: '1 def __init__(self, window, windowWidth, windowHeight):'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
- en: 'self.window = window # remember the window, so we can draw later'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
- en: self.windowWidth = windowWidth
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: self.windowHeight = windowHeight
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
- en: '**122** Chapter 6'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
- en: 2 self.image = pygame.image.load('images/ball.png')
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
- en: A rect is made up of [x, y, width, height]
  id: totrans-1414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ballRect = self.image.get_rect()
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
- en: self.width = ballRect.width
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
- en: self.height = ballRect.height
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
- en: self.maxWidth = windowWidth - self.width
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: self.maxHeight = windowHeight - self.height
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
- en: Pick a random starting position
  id: totrans-1420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 self.x = random.randrange(0, self.maxWidth)
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
- en: self.y = random.randrange(0, self.maxHeight)
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
- en: Choose a random speed between -4 and 4, but not zero,
  id: totrans-1423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: in both the x and y directions
  id: totrans-1424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4 speedsList = [-4, -3, -2, -1, 1, 2, 3, 4]
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
- en: self.xSpeed = random.choice(speedsList)
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
- en: self.ySpeed = random.choice(speedsList)
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
- en: '5 def update(self):'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
- en: Check for hitting a wall. If so, change that direction.
  id: totrans-1429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if (self.x < 0) or (self.x >= self.maxWidth):'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
- en: self.xSpeed = -self.xSpeed
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
- en: 'if (self.y < 0) or (self.y >= self.maxHeight):'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
- en: self.ySpeed = -self.ySpeed
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
- en: Update the Ball's x and y, using the speed in two directions
  id: totrans-1434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.x = self.x + self.xSpeed
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
- en: self.y = self.y + self.ySpeed
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
- en: '6 def draw(self):'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
- en: self.window.blit(self.image, (self.x, self.y))
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-1: The new Ball class*'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
- en: When we instantiate a Ball object, the __init__() method receives three
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
- en: 'pieces of data: the window to draw into, the width of the window, and the'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
- en: height of the window 1\. We save the window variable into the instance vari-
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
- en: able self.window so that we can use it later in the draw() method, and we do
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
- en: the same with the self.windowHeight and self.windowWidth instance variables.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
- en: We then load the image of the ball using the path to the file and get the
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
- en: rect of that ball image 2\. We need the rect to calculate the maximum val-
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
- en: ues for x and y so that the ball will always fully appear in the window. Next,
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
- en: we pick a randomized starting location for the ball 3\. Finally, we set the
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
- en: speed in the x and y directions to a random value between –4 and 4 (but
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
- en: not 0), representing the number of pixels to move per frame 4\. Because
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
- en: of these numbers, the ball may move differently each time we run the pro-
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
- en: gram. All these values are saved in instance variables to be used by other
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
- en: methods.
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
- en: In the main program, we’ll call the update() method in each frame of
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
- en: the main loop, so this is where we place the code that checks for the ball
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Pygame **123**
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
- en: hitting any border of the window 5\. If it does hit an edge, we reverse the
    speed in that direction and modify the x- and y-coordinates (self.x and
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
- en: self.y) by the current speed in the x and y directions.
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also call the draw() method, which simply calls blit() to draw the
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
- en: ball at its current x- and y-coordinates 6, in every frame of the main loop.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
- en: '***Using the Ball Class***'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
- en: Now all functionality associated with a ball has been placed in the Ball
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
- en: class code. All the main program needs to do is create the ball, then call
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
- en: its update() and draw() methods in every frame. Listing 6-2 shows the greatly
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
- en: simplified code of the main program.
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo6_Bal BounceObjectOriented/Main_Bal Bounce.py**'
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
- en: pygame demo 6(a) - using the Ball class, bounce one ball
  id: totrans-1467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 - Import packages
  id: totrans-1468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
- en: import random
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
- en: '1 from Ball import * # bring in the Ball class code'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
- en: 2 - Define constants
  id: totrans-1474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BLACK = (0, 0, 0)
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_WIDTH = 640
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_HEIGHT = 480
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  id: totrans-1479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
- en: clock = pygame.time.Clock()
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-1483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  id: totrans-1484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2 oBall = Ball(window, WINDOW_WIDTH, WINDOW_HEIGHT)
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  id: totrans-1486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  id: totrans-1488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  id: totrans-1493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3 oBall.update() # tell the Ball to update itself'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
- en: '**124** Chapter 6'
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
- en: 9 - Clear the window before drawing it again
  id: totrans-1496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(BLACK)
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw the window elements
  id: totrans-1498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '4 oBall.draw() # tell the Ball to draw itself'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  id: totrans-1500
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  id: totrans-1502
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: clock.tick(FRAMES_PER_SECOND)
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-2: The new main program that instantiates a Ball and makes cal s
    to its methods* If you compare this new main program with the original code in'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5-6, you’ll see that it’s much simpler and clearer. We use an import
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
- en: statement to bring in the Ball class code 1\. We create a Ball object, passing
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
- en: in the window that we created and the width and height of that window 2,
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
- en: and we save the resulting Ball object in a variable named oBall.
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
- en: The responsibility of moving the ball is now in the Ball class code, so
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
- en: here we only need to call the update() method of the oBall object 3\. Since
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
- en: the Ball object knows how big the window is, how big the image of the ball
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
- en: is, and the location and the speed of the ball, it can do all the calculations
    it
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
- en: needs to do to move the ball and bounce it off the walls.
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
- en: The main code calls the draw() method of the oBall object 4, but the
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
- en: actual drawing is done in the oBall object.
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Many Ball Objects***'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s make a slight but important modification to the main program to
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
- en: create multiple Ball objects. This is one of the real powers of object orien-
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
- en: 'tation: to create three balls, we only have to instantiate three Ball objects'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
- en: from the Ball class. Here we’ll use a basic approach and build a list of Ball
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
- en: objects. In each frame, we’ll iterate through the list of Ball objects, tell
    each
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
- en: one to update its location, then iterate again to tell each one to draw itself.
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6-3 shows a modified main program that creates and updates three
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
- en: Ball objects.
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo6_BallBounceObjectOriented/Main_BallBounceManyBalls.py**'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
- en: pygame demo 6(b) - using the Ball class, bounce many balls
  id: totrans-1526
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
- en: N_BALLS = 3
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  id: totrans-1530
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 ballList = []
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
- en: 'for oBall in range(0, N_BALLS):'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
- en: Each time through the loop, create a Ball object
  id: totrans-1533
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oBall = Ball(window, WINDOW_WIDTH, WINDOW_HEIGHT)
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Pygame **125**
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
- en: 'ballList.append(oBall) # append the new Ball to the list of Balls'
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  id: totrans-1537
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  id: totrans-1540
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2 for oBall in ballList:'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
- en: 'oBall.update() # tell each Ball to update itself'
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
- en: 9 - Clear the window before drawing it again
  id: totrans-1543
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(BLACK)
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw the window elements
  id: totrans-1545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3 for oBall in ballList:'
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
- en: 'oBall.draw() # tell each Ball to draw itself'
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  id: totrans-1548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  id: totrans-1550
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: clock.tick(FRAMES_PER_SECOND)
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-3: Creating, moving, and displaying three bal s*'
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
- en: We start with an empty list of Ball objects 1\. Then we have a loop
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
- en: that creates three Ball objects, each of which we append to our list of Ball
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
- en: objects, ballList. Each Ball object chooses and remembers a randomized
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
- en: starting location and a randomized speed in both the x and y directions.
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
- en: Inside the main loop, we iterate through all the Ball objects and tell
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
- en: each one to update itself 2, changing the x- and y-coordinates of each Ball
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
- en: object to a new location. We then iterate through the list again, calling the
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
- en: draw() method of each Ball object 3\.
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
- en: When we run the program, we see three balls, each starting at a ran-
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
- en: domized location and each moving with a randomized x and y speed. Each
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
- en: ball bounces correctly off the boundaries of the window.
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
- en: Using this object-oriented approach, we made no changes to the Ball
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
- en: class, but just changed our main program to now manage a list of Ball
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
- en: objects instead of a single Ball object. This is a common, and very positive,
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
- en: 'side effect of OOP code: well-written classes can often be reused without'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
- en: change.
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Many, Many Ball Objects***'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
- en: We can change the value of the constant N_BALLS from 3 to some much
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
- en: larger value, like 300, to quickly create that many balls (Figure 6-1). By
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
- en: changing just a single constant, we make a major change to the behavior
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
- en: of the program. Each ball maintains its own speed and location and draws
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
- en: itself.
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
- en: '**126** Chapter 6'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 21](index-156_1.png)'
  id: totrans-1576
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-1: Creating, updating, and drawing 300 Ball objects*'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
- en: The fact that we can instantiate any number of objects from a single
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
- en: script will be vital not only in defining game objects like spaceships, zom-
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
- en: bies, bullets, treasures, and so on, but also in building GUI controls such
    as
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
- en: buttons, checkboxes, text input fields, and text outputs.
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
- en: '**Building a Reusable Object-Oriented Button**'
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
- en: The simple button is one of the most recognizable elements of a graphical
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
- en: user interface. The standard behavior of a button consists of the user using
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
- en: their mouse to click down on the button image and then releasing it.
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
- en: 'Buttons typically consist of at least two images: one to represent the *up*'
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
- en: or normal state of the button and another to represent the *down* or pressed
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: state of the button. The sequence of a click can be broken down into the
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
- en: 'following steps:'
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
- en: 1\. User moves the mouse pointer over the button
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: 2\. User presses the mouse button down
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Program reacts by changing the image to the down state
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
- en: 4\. User releases the mouse button
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Program reacts by showing the up image of the button
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Program performs some action based on the button click
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
- en: Good GUIs also allow the user to click down on a button, temporarily
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
- en: roll off the button, changing the button to the up state, and then, with the
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Pygame **127**
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: mouse button still down, roll back over the image so the button changes back
    to the down image. If the user clicks down on a button but then rolls
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
- en: the mouse off and lifts up on the mouse button, that is not considered a
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
- en: click. This means the program takes action only when the user presses
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
- en: down and releases while the mouse is positioned over the image of a button.
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
- en: '***Building a Button Class***'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
- en: The button behavior should be common and consistent for all buttons used
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
- en: in a GUI, so we’ll build a class that takes care of the behavior details. Once
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
- en: we’ve built a simple button class, we can instantiate any number of buttons
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
- en: and they’ll all work exactly the same way.
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider what behaviors our button class must support. We’ll need
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
- en: 'methods to:'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
- en: • Load the images of the up and down states, then initialize any instance
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
- en: variables needed to track the button’s state.
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
- en: • Tell the button about all events that the main program has detected
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
- en: and check whether there are any that the button needs to react to.
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
- en: • Draw the current image representing the button.
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6-4 presents the code of a SimpleButton class. (We’ll build a
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
- en: more complicated button class i[n Chapter 7.) T](index_split_003.html#p172)his
    class has three methods, __init__(), handleEvent(), and draw(), that implement
    the behaviors mentioned. The code of the handleEvent() method does get a little
    tricky, but
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
- en: once you have it working, it’s incredibly easy to use. Feel free to work your
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
- en: way through it, but know that the implementation of the code is not that
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: relevant. The important thing here is to understand the purpose and usage
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
- en: of the different methods.
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo7_SimpleButton/SimpleButton.py**'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
- en: SimpleButton class
  id: totrans-1622
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#'
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
- en: Uses a "state machine" approach
  id: totrans-1624
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#'
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
- en: import pygame
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
- en: 'class SimpleButton():'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
- en: Used to track the state of the button
  id: totrans-1629
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'STATE_IDLE = ''idle'' # button is up, mouse not over button'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
- en: 'STATE_ARMED = ''armed'' # button is down, mouse over button'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
- en: 'STATE_DISARMED = ''disarmed'' # clicked down on button, rolled off'
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window, loc, up, down): 1'
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
- en: self.loc = loc
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
- en: self.surfaceUp = pygame.image.load(up)
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
- en: '**128** Chapter 6'
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
- en: self.surfaceDown = pygame.image.load(down)
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
- en: Get the rect of the button (used to see if the mouse is over the button)
  id: totrans-1639
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.rect = self.surfaceUp.get_rect()
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
- en: self.rect[0] = loc[0]
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
- en: self.rect[1] = loc[1]
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
- en: self.state = SimpleButton.STATE_IDLE
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
- en: 'def handleEvent(self, eventObj): 2'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
- en: This method will return True if user clicks the button.
  id: totrans-1645
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally returns False.
  id: totrans-1646
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if eventObj.type not in (MOUSEMOTION, MOUSEBUTTONUP, MOUSEBUTTONDOWN): 3'
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
- en: The button only cares about mouse-related events
  id: totrans-1648
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: return False
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
- en: eventPointInButtonRect = self.rect.collidepoint(eventObj.pos)
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.state == SimpleButton.STATE_IDLE:'
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
- en: 'if (eventObj.type == MOUSEBUTTONDOWN) and eventPointInButtonRect:'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
- en: self.state = SimpleButton.STATE_ARMED
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
- en: 'elif self.state == SimpleButton.STATE_ARMED:'
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
- en: 'if (eventObj.type == MOUSEBUTTONUP) and eventPointInButtonRect:'
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
- en: self.state = SimpleButton.STATE_IDLE
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
- en: 'return True # clicked!'
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
- en: 'if (eventObj.type == MOUSEMOTION) and (not eventPointInButtonRect):'
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
- en: self.state = SimpleButton.STATE_DISARMED
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
- en: 'elif self.state == SimpleButton.STATE_DISARMED:'
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
- en: 'if eventPointInButtonRect:'
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
- en: self.state = SimpleButton.STATE_ARMED
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
- en: 'elif eventObj.type == MOUSEBUTTONUP:'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: self.state = SimpleButton.STATE_IDLE
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
- en: return False
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw(self): 4'
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
- en: Draw the button's current appearance to the window
  id: totrans-1667
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if self.state == SimpleButton.STATE_ARMED:'
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
- en: self.window.blit(self.surfaceDown, self.loc)
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: 'else: # IDLE or DISARMED'
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
- en: self.window.blit(self.surfaceUp, self.loc)
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-4: The SimpleButton class*'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() method begins by saving all values passed in into
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: instance variables 1 to use in other methods. It then initializes a few
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: more instance variables.
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the main program detects any event, it calls the handleEvent()
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: method 2\. This method first checks that the event is one of MOUSEMOTION,
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Pygame **129**
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 22](index-159_1.png)'
  id: totrans-1679
  prefs: []
  type: TYPE_IMG
- en: MOUSEBUTTONUP, or MOUSEBUTTONDOWN 3\. The rest of the method is implemented
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
- en: as a *state machine*, a technique that I will go into more detail about in
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 15\.](index_split_006.html#p340) The code is a little complicated,
    and you should feel free to study how it works, but for now note that it uses
    the instance variable'
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
- en: self.state (over the course of multiple calls) to detect if the user has
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
- en: clicked on the button. The handleEvent() method returns True when the
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
- en: user completes a mouse click by pressing down on the button, then later
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
- en: releasing on the same button. In all other cases, handleEvent() returns
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
- en: False.
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the draw() method uses the state of the object’s instance variable
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
- en: self.state to decide which image (up or down) to draw 4\.
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
- en: '***Main Code Using a SimpleButton***'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
- en: To use a SimpleButton in the main code, we first instantiate one from the
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
- en: 'SimpleButton class before the main loop starts with a line like this:'
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
- en: oButton = SimpleButton(window, (150, 30),
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonUp.png'','
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonDown.png'')'
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
- en: This line creates a SimpleButton object, specifying a location to draw
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
- en: it (as usual, the coordinates are for the top-left corner of the bounding
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: rectangle) and providing the paths to both the up and down images of the
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
- en: button. In the main loop, any time any event happens we need to call the
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
- en: handleEvent() method to see if the user has clicked the button. If the user
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
- en: clicks the button, the program should perform some action. Also in the
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
- en: main loop, we need to call the draw() method to make the button show in
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
- en: the window.
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
- en: We’ll build a small test program, which will generate a user interface
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
- en: like Figure 6-2, to incorporate one instance of a SimpleButton.
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6-2: The user interface of a program with a single instance of a SimpleButton*
    Whenever the user completes a click on the button, the program'
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
- en: outputs a line of text in the shell saying that the button has been clicked.
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6-5 contains the main program code.
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo7_SimpleButton/Main_SimpleButton.py**'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
- en: Pygame demo 7 - SimpleButton test
  id: totrans-1710
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  id: totrans-1712
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create an instance of a SimpleButton
  id: totrans-1713
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**130** Chapter 6'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
- en: 1 oButton = SimpleButton(window, (150, 30),
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonUp.png'','
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonDown.png'')'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  id: totrans-1718
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  id: totrans-1720
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
- en: Pass the event to the button, see if it has been clicked on
  id: totrans-1725
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2 if oButton.handleEvent(event):'
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
- en: 3 print('User has clicked the button')
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  id: totrans-1728
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 9 - Clear the window
  id: totrans-1729
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(GRAY)
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw all window elements
  id: totrans-1731
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '4 oButton.draw() # draw the button'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  id: totrans-1733
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  id: totrans-1735
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: clock.tick(FRAMES_PER_SECOND)
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-5: The main program that creates and reacts to a SimpleButton*'
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
- en: Again, we start with the standard pygame template from [Chapter 5\.](#p118)
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
- en: Before the main loop, we create an instance of our SimpleButton 1, specify-
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
- en: ing a window to draw into, a location, a path to the up image, and a path to
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
- en: the down image.
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
- en: Every time through the main loop, we need to react to events detected
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
- en: in the main program. To implement this, we call the SimpleButton class’s
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
- en: handleEvent() method 2 and pass in the event from the main program.
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
- en: The handleEvent() method tracks all of the user’s actions on the button
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
- en: (pressing down, releasing, rolling off, rolling back on). When handleEvent()
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
- en: returns True, indicating that a click has occurred, we perform the action
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
- en: associated with clicking that button. Here, we just print a message 3\.
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
- en: Finally we call the button’s draw() method 4 to draw an image to repre-
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
- en: sent the appropriate state of the button (up or down).
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a Program with Multiple Buttons***'
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
- en: With our SimpleButton class, we can instantiate as many buttons as we wish.
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can modify our main program to incorporate three
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
- en: SimpleButton instances, as shown in Figure 6-3\.
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Pygame **131**
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 23](index-161_1.png)'
  id: totrans-1756
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-3: The main program with three SimpleButton objects*'
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to make any changes to the SimpleButton class file to
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
- en: do this. We simply modify our main code to instantiate three SimpleButton
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
- en: objects instead of one.
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo7_SimpleButton/Main_SimpleButton3Buttons.py**'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
- en: oButtonA = SimpleButton(window, (25, 30),
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonAUp.png'','
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonADown.png'')'
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
- en: oButtonB = SimpleButton(window, (150, 30),
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonBUp.png'','
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonBDown.png'')'
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
- en: oButtonC = SimpleButton(window, (275, 30),
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonCUp.png'','
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonCDown.png'')'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to call the handleEvent() method of all three buttons:'
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
- en: Pass the event to each button, see if one has been clicked
  id: totrans-1772
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if oButtonA.handleEvent(event):'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
- en: print('User clicked button A.')
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
- en: 'elif oButtonB.handleEvent(event):'
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
- en: print('User clicked button B.')
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
- en: 'elif oButtonC.handleEvent(event):'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
- en: print('User clicked button C.')
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we tell each button to draw itself:'
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
- en: oButtonA.draw()
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
- en: oButtonB.draw()
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
- en: oButtonC.draw()
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
- en: When you run the program, you’ll see a window with three buttons.
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
- en: Clicking any of the buttons prints a message showing the name of the but-
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
- en: ton that was clicked.
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
- en: The key idea here is that since we are using three instances of the
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
- en: same SimpleButton class, the behavior of each button will be identical. An
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
- en: important benefit of this approach is that any change to the code in the
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
- en: SimpleButton class will affect all buttons instantiated from the class. The
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
- en: main program does not need to worry about any details of the inner work-
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
- en: ings of the button code, needing only to call the handleEvent() method of
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
- en: each button in the main loop. Each button will return True or False to say
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
- en: that it has or has not been clicked.
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
- en: '**132** Chapter 6'
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
- en: '**Building a Reusable Object-Oriented Text Display**'
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different types of text in a pygame program: display text and'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
- en: input text. Display text is output from your program, equivalent to a call to
    the
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
- en: print() function, except it’s displayed in a pygame window. Input text is string
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
- en: input from the user, equivalent to a call to input(). In this section, I’ll
    discuss display text. We’ll look at how to deal with input text in the next chapter.
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
- en: '***Steps to Display Text***'
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
- en: Displaying text in a window is a fairly complicated process in pygame
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
- en: because it’s not simply displayed as a string in the shell, but requires you
    to
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
- en: choose a location, fonts and sizes, and other attributes. For example, you
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
- en: 'might use code like the following:'
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
- en: pygame.font.init()
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
- en: myFont = pygame.font.SysFont('Comic Sans MS', 30)
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
- en: textSurface = myfont.render('Some text', True, (0, 0, 0))
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
- en: window.blit(textSurface, (10, 10))
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
- en: We start by initializing the font system within pygame; we do this before
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
- en: the main loop starts. Then we tell pygame to load a particular font from the
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
- en: system by name. Here, we request Comic Sans with a font size of 30\.
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is the key one: we use that font to *render* our text, which'
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
- en: creates a graphical image of the text, called a *surface* in pygame. We supply
    the text we want to output, a Boolean that says whether we want our text to
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
- en: be anti-aliased, and a color in RGB format. Here, (0, 0, 0) indicates that
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
- en: we want our text to be black. Finally, using blit(), we draw the image of the
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
- en: text into the window at some (x, y) location.
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
- en: This code works well to show the provided text in the window at the
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
- en: given location. However, if the text doesn’t change, there will be a lot of
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
- en: wasted work done re-creating the textSurface on each iteration through the
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
- en: main loop. There are also a lot of details to remember, and you must get
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
- en: them all correct to draw the text properly. We can hide most of this com-
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
- en: plexity by building a class.
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a SimpleText Class***'
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to build a set of methods that take care of font loading and text
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
- en: rendering in pygame, meaning we no longer have to remember the details
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
- en: of the implementation. Listing 6-6 contains a new class called SimpleText
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
- en: that does this work.
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo8_SimpleTextDisplay/SimpleText.py**'
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
- en: SimpleText class
  id: totrans-1829
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Pygame **133**
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
- en: 'class SimpleText():'
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
- en: '1 def __init__(self, window, loc, value, textColor):'
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
- en: 2 pygame.font.init()
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
- en: self.loc = loc
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
- en: 3 self.font = pygame.font.SysFont(None, 30)
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
- en: self.textColor = textColor
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
- en: 'self.text = None # so that the call to setText below will'
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
- en: force the creation of the text image
  id: totrans-1841
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'self.setValue(value) # set the initial text for drawing'
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
- en: '4 def setValue(self, newText):'
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.text == newText:'
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
- en: 'return # nothing to change'
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
- en: 'self.text = newText # save the new text'
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
- en: self.textSurface = self.font.render(self.text, True, self.textColor)
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
- en: '5 def draw(self):'
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
- en: self.window.blit(self.textSurface, self.loc)
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-6: The SimpleText class for displaying text*'
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
- en: You can think of a SimpleText object as a field in the window where you
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
- en: want text to be displayed. You can use one to display unchanging label text
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
- en: or to display text that changes throughout a program.
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
- en: The SimpleText class has only three methods. The __init__() method 1
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
- en: expects the window to draw into, the location at which to draw the text in
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
- en: the window, any initial text you want to see displayed in the field, and a text
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
- en: color. Calling pygame.font.init() 2 starts up pygame’s font system. The call
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
- en: in the first instantiated SimpleText object actually does the initialization;
    any
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
- en: additional SimpleText objects will also make this call, but since fonts have
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
- en: already been initialized, the call returns immediately. We create a new Font
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
- en: object with pygame.font.SysFont() 3\. Rather than providing a specific font
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
- en: name, None indicates that we will use whatever the standard system font is.
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
- en: The setValue() method renders an image of the text to display and saves
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
- en: that image in the self.textSurface instance variable 4\. As the program runs,
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
- en: any time you want to change the text that’s displayed, you call the setValue()
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
