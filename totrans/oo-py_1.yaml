- en: method call raises an AbortTransaction exception, control will be transferred
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法调用引发 AbortTransaction 异常，控制将转移到
- en: to the except statement 4\.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 跳转到 except 语句 4\。
- en: Exceptions are objects. In the except clause, we handle the AbortTransaction
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是对象。在 except 子句中，我们处理 AbortTransaction 异常
- en: exception that was raised at any lower level. We assign the value of the
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 异常在任何较低级别引发时，我们将异常的值分配给
- en: '**82** Chapter 4'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**82** 第4章'
- en: exception to the variable error. When we print that variable, the user will
    see the associated error message. Since the exception was handled in the
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 异常并存储在错误变量中。当我们打印该变量时，用户将看到相关的错误信息。因为异常已经在
- en: except clause, the program continues running, and the user is asked what
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: except 子句中，程序继续运行，并询问用户想做什么
- en: they wish to do.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 他们希望做的事情。
- en: '**Calling the Same Method on a List of Objects**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**对一组对象调用相同的方法**'
- en: Unlike in our bank example, in cases where individual objects do not need
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的银行示例不同，在个别对象不需要
- en: to be uniquely identified, using a list of objects works extremely well. Let’s
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了唯一标识每个对象，使用对象列表效果非常好。让我们
- en: say you’re coding a game and you need to have some number of bad guys,
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个游戏，需要一些坏人角色，
- en: spaceships, bullets, zombies, or whatever else. Each such object will typically
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 飞船、子弹、僵尸，或者其他什么。每个这样的对象通常
- en: have some data it remembers and some actions it can perform. As long as
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一些它记住的数据和一些它可以执行的动作。只要
- en: each object does not require a unique identifier, the standard way to handle
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象不需要唯一标识符时，处理方式通常是
- en: this is to create many instances of the object from the class and put all the
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从类中创建多个对象实例，并将它们放在一起
- en: 'objects into a list:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象放入列表：
- en: 'objectList = [] # start off with an empty list'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 'objectList = [] # 从空列表开始'
- en: 'for i in range(nObjects):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(nObjects):'
- en: 'oNewObject = MyClass() # create a new instance'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 'oNewObject = MyClass() # 创建一个新的实例'
- en: 'objectList.append(oNewObject) # store the object in the list'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 'objectList.append(oNewObject) # 将对象存储在列表中'
- en: In our game, we represent a world as a large grid, like a spreadsheet.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们将世界表示为一个大的网格，类似于电子表格。
- en: We want monsters placed at random locations in the grid. Listing 4-12
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望怪物出现在网格中的随机位置。示例 4-12
- en: shows the start of a Monster class with its __init__() method and a move()
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 显示一个怪物类的开头，其中包含 __init__() 方法和 move()
- en: method. When a Monster is instantiated, it is told the number of rows and
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 方法。当实例化一个怪物时，它会被告知行数和
- en: columns in the grid and the maximum speed, and it chooses a random
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 网格中的列和最大速度，然后选择一个随机的
- en: starting location and speed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 初始位置和速度。
- en: '**File: MonsterExample.py**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：MonsterExample.py**'
- en: import random
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: class Monster()
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: class Monster()
- en: 'def __init__(self, nRows, nCols, maxSpeed):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, nRows, nCols, maxSpeed):'
- en: 'self.nRows = nRows # save away'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.nRows = nRows # 保存行数'
- en: 'self.nCols = nCols # save away'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.nCols = nCols # 保存列数'
- en: 'self.myRow = random.randrange(self.nRows) # chooses a random row'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.myRow = random.randrange(self.nRows) # 选择一个随机的行'
- en: 'self.myCol = random.randrange(self.nCols) # chooses a random col'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.myCol = random.randrange(self.nCols) # 选择一个随机的列'
- en: 'self.mySpeedX = random.randrange(-maxSpeed, maxSpeed + 1) # chooses an X speed'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.mySpeedX = random.randrange(-maxSpeed, maxSpeed + 1) # 选择一个 X 速度'
- en: 'self.mySpeedY = random.randrange(-maxSpeed, maxSpeed + 1) # chooses a Y speed'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.mySpeedY = random.randrange(-maxSpeed, maxSpeed + 1) # 选择一个 Y 速度'
- en: Set other instance variables like health, power, etc.
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置其他实例变量，如健康、力量等
- en: 'def move(self):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 'def move(self):'
- en: self.myRow = (self.myRow + self.mySpeedY) % self.nRows
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: self.myRow = (self.myRow + self.mySpeedY) % self.nRows
- en: self.myCol = (self.myCol + self.mySpeedX) % self.nCols
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: self.myCol = (self.myCol + self.mySpeedX) % self.nCols
- en: '*Listing 4-12: A Monster class that can be used to instantiate many Monsters*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 4-12：一个可以用来实例化多个怪物的 Monster 类*'
- en: Managing Multiple Objects **83**
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 管理多个对象 **83**
- en: 'With this Monster class, we can create a list of Monster objects like this:
    N_MONSTERS = 20'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个 Monster 类，我们可以像这样创建一个怪物对象列表： N_MONSTERS = 20
- en: 'N_ROWS = 100 # could be any size'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 'N_ROWS = 100 # 可以是任何大小'
- en: 'N_COLS = 200 # could be any size'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 'N_COLS = 200 # 可以是任何大小'
- en: MAX_SPEED = 4
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: MAX_SPEED = 4
- en: 'monsterList = [] # start with an empty list'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 'monsterList = [] # 从空列表开始'
- en: 'for i in range(N_MONSTERS):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(N_MONSTERS):'
- en: 'oMonster = Monster(N_ROWS, N_COLS, MAX_SPEED) # create a Monster'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 'oMonster = Monster(N_ROWS, N_COLS, MAX_SPEED) # 创建一个怪物'
- en: 'monsterList.append(oMonster) # add the Monster to our list'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 'monsterList.append(oMonster) # 将怪物添加到我们的列表中'
- en: This loop will instantiate 20 Monsters, and each will know its own start-
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环将实例化 20 个怪物，每个怪物都会知道自己的起始位置
- en: ing location in the grid and its individual speed. Once you have a list of
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 网格中的起始位置和各自的速度。一旦你有一个对象列表，
- en: objects, later in the program when you want each object to do the same
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对象，当你希望每个对象执行相同的
- en: action, you can write a simple loop where you call the same method of each
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 操作，你可以写一个简单的循环，调用每个对象的相同方法
- en: 'object in the list:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个对象：
- en: 'for objectVariable in objectVariablesList:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 objectVariable 在 objectVariablesList 中：
- en: objectVariable.someMethod()
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: objectVariable.someMethod()
- en: For example, if we want each of our Monster objects to move, we could
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们希望每个 Monster 对象都移动，我们可以
- en: 'use a loop like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似这样的循环：
- en: 'for oMonster in monsterList:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 oMonster 在 monsterList 中：
- en: oMonster.move()
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: oMonster.move()
- en: Since each Monster object remembers its location and speed, in the
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个 Monster 对象记住了它的位置和速度，在
- en: move() method, each Monster can move to and remember its new location.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: move() 方法，每个 Monster 都可以移动到并记住它的新位置。
- en: This technique of building a list of objects and calling the same
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这种构建对象列表并调用相同方法的技术
- en: method of all objects in the list is extremely useful, and it’s a standard
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中所有对象的方法非常有用，它是处理集合的标准
- en: approach to dealing with a collection of similar objects. We will use this
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 处理一组相似对象的标准方法。我们将使用这种
- en: approach quite often when we get to building games using pygame later.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们稍后使用 pygame 构建游戏时，经常采用这种方法。
- en: '**Interface vs. Implementation**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口 vs. 实现**'
- en: Our earlier Account class seems to have methods and instance variables that
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的 Account 类似乎有方法和实例变量
- en: work well. When you’re confident your code is working well, you no longer
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 工作得如何。当你确信你的代码工作正常时，你就不再
- en: have to be concerned with the details within the class. When a class does
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要关心类内部的细节。当一个类做
- en: what you want it to do, all you need to remember is what methods are avail-
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要它做什么，只需记住哪些方法是可用的，
- en: 'able in the class. There are two different ways to look at a class: by focusing'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类中可用的两种不同方式：关注
- en: on what it is capable of doing (the *interface*) and how it works internally
    (the *implementation*).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 根据对象的 *接口* 以及它的 *实现* 如何运作，来判断它能做什么。
- en: '**interface**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口**'
- en: The col ection of methods a class provides (and the parameters that each method
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 类提供的方法集合（以及每个方法的参数）
- en: expects) . The interface shows *what* an object created from the class can do
    .
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 期望的方式）。接口展示了对象从类创建后能做 *什么*。
- en: '**implementation** The actual code of the class, which shows *how* an object
    does what it does .'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**实现** 类的实际代码，展示对象是 *如何* 完成它的任务的。'
- en: '**84** Chapter 4'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**第 84 章**'
- en: If you are the creator or maintainer of a class, you need to fully understand
    the implementation—the code of all of the methods and how they
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是类的创建者或维护者，你需要完全理解实现——所有方法的代码以及它们
- en: work together to affect the instance variables. If you are purely writing code
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一起影响实例变量。如果你只是写代码
- en: to *use* a class, you only need to concern yourself with the interface—the
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要 *使用* 一个类，你只需要关注接口——
- en: different methods that are available in the class, the values that need to be
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类中可用的不同方法，所需的值必须
- en: passed into each, and any value(s) that are returned from the methods. If
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给每个方法的值，以及从方法返回的任何值。如果
- en: you are coding on your own (as a “one-person team”), then you will be both
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是在独立编程（作为“单人团队”），那么你将同时
- en: the implementer of a class and the user of its interface.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 类的实现者和接口的用户之间的关系。
- en: As long as the interface of a class does not change, the class’s imple-
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 只要类的接口不变，类的实现
- en: mentation can change at any time. That is, if you find that a method can be
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实现可以随时更改。也就是说，如果你发现一个方法可以
- en: implemented in a faster or more efficient way, changing the relevant code
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以更快或更高效的方式实现，改变相关的代码
- en: inside the class will not have any bad side effects on any other part of the
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 类内部的更改不会对程序的其他部分产生不良副作用。
- en: program.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 程序。
- en: '**Summary**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: An object manager object is an object that manages other objects. It does
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对象管理器对象是一个管理其他对象的对象。它不做
- en: this by having one or more instance variables that are lists or dictionaries
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过具有一个或多个实例变量，它们是列表或字典，来实现这一点
- en: made up of other objects. The object manager can call methods of any spe-
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由其他对象组成。对象管理器可以调用任何特定对象的
- en: cific object or of all managed objects. This technique gives full control of
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 特定对象或所有管理对象的。此技术提供了对类的完全控制，
- en: all managed objects to the object manager alone.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 所有管理对象都归对象管理器管理。
- en: When you encounter an error in a method or function, you can raise an
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在方法或函数中遇到错误时，你可以抛出一个
- en: exception. The raise statement returns control to the caller. The caller can
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 异常。raise 语句将控制权返回给调用者。调用者可以
- en: detect a potential error by placing the call in a try block, and it can react
    to
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将调用放入 try 块中，可以检测潜在错误，并对其做出反应
- en: any such error using an except block.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 except 块处理任何此类错误。
- en: The interface of a class is the documentation of all the methods and
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 类的接口是所有方法和
- en: related parameters in the class. The implementation is the actual code
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的相关参数。实现是实际的代码
- en: of the class. What you need to know depends on your role. The writer/
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 类的实现。你需要了解的内容取决于你的角色。编写者/
- en: maintainer of a class needs to understand the details of the code, whereas
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 类的维护者需要理解代码的细节，而
- en: anyone who uses the class only needs to understand the interface that the
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类的任何人只需理解类的接口
- en: class provides.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 类提供的功能。
- en: Managing Multiple Objects **85**
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 管理多个对象 **85**
- en: '**PART II**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二部分**'
- en: '**G R A P H I C A L U S E R**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**图形用户界面**'
- en: '**I N T E R F A C E S W I T H P Y G A M E**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**与 Pygame 的接口**'
- en: These chapters introduce you to *pygame,* an external
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些章节将向你介绍*pygame*，一个外部
- en: package that adds functionality common to GUI pro-
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 包，它为 GUI 程序添加了常见的功能
- en: grams. Pygame allows you to write Python programs
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 克拉姆。Pygame 允许你编写 Python 程序
- en: that have windows, respond to the mouse and key-
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 那些有窗口、响应鼠标和键盘输入的
- en: board, play sounds, and more.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 主板、播放声音等等。
- en: '[Chapter 5 g](#p118)ives you a basic understanding of how pygame works and
    provides a standard template for building pygame-based programs. We’ll'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[第5章 g](#p118)为你提供了对 pygame 如何工作的基本理解，并提供了构建基于 pygame 的程序的标准模板。我们将'
- en: build a few simple programs first, create a program that controls an image
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 先构建几个简单程序，创建一个控制图像的程序
- en: with the keyboard, then we’ll build a ball-bouncing program.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用键盘输入，然后我们将构建一个球体反弹程序。
- en: '[Chapter 6 e](#p150)xplains how pygame can best be used as an object-oriented
    framework. You’ll see how to rewrite the ball-bouncing program using'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[第6章 e](#p150)解释了如何将 pygame 最好地作为面向对象框架使用。你将看到如何使用'
- en: object-oriented techniques, and develop simple buttons and text input
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象技术，并开发简单的按钮和文本输入
- en: fields.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 领域。
- en: '[Chapter 7 d](index_split_003.html#p172)escribes the pygwidgets module, which
    contains full implementations of many standard user interface widgets like buttons,
    input'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7章 d](index_split_003.html#p172)描述了 pygwidgets 模块，它包含了许多标准用户界面控件的完整实现，比如按钮、输入框'
- en: and output fields, radio buttons, checkboxes, and more, all using object-
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 和输出字段、单选按钮、复选框等，所有这些都使用面向对象技术
- en: oriented programming. All the code is available for you so that you can use
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的文档。所有代码都可以供你使用
- en: it to build your own applications. I’ll provide several examples.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 用它来构建你自己的应用程序。我会提供几个示例。
- en: '**5**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**5**'
- en: '**I N T R O D U C T I O N T O P Y G A M E**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**P Y G A M E 简介**'
- en: The Python language was designed to han-
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Python 语言的设计旨在处理
- en: dle text input and text output. It provides
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文本输入和文本输出。它提供
- en: the ability to get text from and send text to
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 获取文本并发送文本到
- en: the user, a file, and the internet. The core lan-
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 用户、文件和互联网的核心语言
- en: guage, however, has no way of dealing with more mod-
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 语言本身没有处理更现代的方式
- en: ern concepts such as windows, mouse clicks, sounds,
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现代概念，如窗口、鼠标点击、声音等，
- en: and so on. So, what if you want to use Python to create
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。那么，如果你想使用 Python 创建
- en: something more state-of-the-art than a text-based program? In this chapter
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 想做些比基于文本的程序更先进的东西吗？在这一章中
- en: I’ll introduce *pygame*, a free open source external package that was designed
    to extend Python to allow programmers to build game programs. You can
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我将介绍 *pygame*，一个免费的开源外部包，旨在扩展 Python 以允许程序员构建游戏程序。你可以
- en: also use pygame to build other kinds of interactive programs with a graphi-
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用 pygame 构建其他类型的图形交互程序——
- en: cal user interface (GUI). It adds the ability to create windows, show images,
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图形用户界面（GUI）。它增加了创建窗口、显示图像的功能，
- en: recognize mouse move ments and clicks, play sounds, and more. In short, it
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 识别鼠标移动和点击、播放声音等等。简而言之，它
- en: allows Python programmers to build the types of games and applications
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 允许 Python 程序员构建游戏和应用程序
- en: that current computer users have become familiar with.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当前计算机用户已经熟悉的。
- en: It is not my intent to turn you all into game programmers—even though
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不打算让你们都成为游戏程序员——尽管
- en: that might be a fun outcome. Rather, I’ll use the pygame environment to
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个有趣的结果。而是，我将使用 pygame 环境来
- en: make certain object-oriented programming techniques clearer and more visual.
    By working with pygame to make objects visible in a window and
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使某些面向对象编程技巧更清晰、更具视觉效果。通过使用 pygame 在窗口中显示对象并
- en: dealing with a user interacting with those objects, you should gain a deeper
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 处理用户与这些对象交互时，你应该更深入地
- en: understanding of how to effectively use OOP techniques.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 理解如何有效使用面向对象编程（OOP）技术。
- en: This chapter provides a general introduction to pygame, so most of the
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了pygame的一般介绍，因此大多数
- en: information and examples in this chapter will use procedural coding. Starting
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的信息和示例将使用过程化编程。开始
- en: with the next chapter, I will explain how to use OOP effectively with pygame.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节中，我将解释如何使用pygame有效地运用OOP。
- en: '**Installing Pygame**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装Pygame**'
- en: Pygame is a free downloadable package. We’ll use the package manager
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame是一个免费的可下载包。我们将使用包管理器
- en: '*pip* (short for *pip installs packages*) to install Python packages. As mentioned
    in the Introduction, I am assuming that you have installed the official version
    of Python from *python.org*. The pip program is included as part of that download,
    so you should already have it installed.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*pip*（即*pip安装包*）用于安装Python包。如引言中所述，我假设你已经从*python.org*安装了官方版本的Python。pip程序作为该下载的一部分包含在内，因此你应该已经安装了它。'
- en: Unlike a standard application, you must run pip from the command
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准应用程序不同，你必须从命令行运行pip
- en: line. On a Mac, start the Terminal application (located in the *Utilities*
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一行。在Mac上，启动终端应用程序（位于*实用工具*文件夹内）。
- en: subfolder inside the *Applications* folder). On a Windows system, click the
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 子文件夹位于*应用程序*文件夹内）。在Windows系统中，点击
- en: Windows icon, type **cmd**, and press ENTER.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Windows图标，输入**cmd**，然后按回车。
- en: '**N O T E**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**注**'
- en: '*This book was not tested with Linux systems. However, most, if not all, of
    the content* *should work with minimal tweaking. To install pygame on a Linux
    distribution,*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*本书没有在Linux系统上进行测试。然而，大部分内容* *应该可以在最小调整的情况下运行。在Linux发行版上安装pygame，*'
- en: '*open a terminal in whatever way you’re used to.*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*以你惯用的方式打开终端。*'
- en: 'Enter the following commands at the command line:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行输入以下命令：
- en: python3 -m pip install -U pip --user
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m pip install -U pip --user
- en: python3 -m pip install -U pygame --user
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m pip install -U pygame --user
- en: The first command ensures that you have the latest version of the pip
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令确保你拥有最新版本的pip。
- en: program. The second line installs the most recent version of pygame.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 程序。第二行安装pygame的最新版本。
- en: If you have any problems installing pygame, consult the pygame docu-
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在安装pygame时遇到任何问题，请查阅pygame文档
- en: mentation at [*https://www.pygame.org/wiki/GettingStarted*](https://www.pygame.org/wiki/GettingStarted).
    To test that pygame has been installed correctly, open IDLE (the development environment
    that
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 文档可以在[*https://www.pygame.org/wiki/GettingStarted*](https://www.pygame.org/wiki/GettingStarted)查阅。要测试pygame是否正确安装，打开IDLE（Python的开发环境，
- en: is bundled with the default implementation of Python), and in the shell win-
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 随Python的默认实现一起捆绑在一起），并且在shell中win-
- en: 'dow enter:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后按回车：
- en: import pygame
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: If you see a message saying something like “Hello from the pygame
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到类似“Hello from the pygame
- en: community” or if you get no message at all, then pygame has been installed
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 社区”或者如果你根本没有收到任何消息，那么pygame已经安装
- en: correctly. The lack of an error message indicates that Python has been able
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正确无误。没有错误消息表示Python已经能够
- en: to find and load the pygame package and it’s ready to use. If you would like
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 查找并加载pygame包并准备就绪。如果你想
- en: to see a sample game using pygame, enter the following command (which
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 查看使用pygame的示例游戏，输入以下命令（这
- en: 'starts a version of *Space Invaders*):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个版本的*太空侵略者*）：
- en: python3 -m pygame.examples.aliens
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: python3 -m pygame.examples.aliens
- en: '**90** Chapter 5'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**90** 第五章'
- en: Before we get into using pygame, I need to explain two important concepts. First,
    I’ll explain how individual pixels are addressed in programs
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用pygame之前，我需要解释两个重要的概念。首先，我将解释程序中如何处理单个像素。
- en: that use a GUI. Then, I’ll discuss event-driven programs and how they dif-
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GUI的程序。然后，我将讨论事件驱动的程序以及它们如何不同于
- en: fer from typical text-based programs. After that, we’ll code a few programs
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与典型的基于文本的程序有所不同。之后，我们将编写一些程序
- en: that demonstrate key pygame features.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 演示关键pygame功能的程序。
- en: '**Window Details**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**窗口详情**'
- en: A computer screen is made up of a large number of rows and columns of
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机屏幕由大量的行列组成
- en: small dots called *pixels* (from the words *picture element*). A user interacts
    with a GUI program through one or more windows; each window is a rectangular portion
    of the screen. Programs can control the color of any individual
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由称为*像素*的小点组成（源自*图像元素*）。用户通过一个或多个窗口与GUI程序进行交互；每个窗口都是屏幕上的矩形区域。程序可以控制任何单个
- en: pixel in their window(s). If you’re running multiple GUI programs, each
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口中的像素。如果你运行多个 GUI 程序，每个
- en: program is typically displayed in its own window. In this section, I’ll discuss
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 程序通常在自己的窗口中显示。在这一节中，我将讨论
- en: how you address and alter individual pixels in a window. These concepts are
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在窗口中定位和改变单个像素。这些概念是
- en: independent of Python; they are common to all computers and are used in
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 独立于 Python；它们是所有计算机通用的，并用于
- en: all programming languages.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 所有编程语言。
- en: '***The Window Coordinate System***'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '***窗口坐标系统***'
- en: You are probably familiar with Cartesian coordinates in a grid like Figure 5-1\.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉图 5-1 中那样的笛卡尔坐标。
- en: y–axis
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: y 轴
- en: '6'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '5'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '4'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '3'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '2'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '1'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: x–axis
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: x 轴
- en: –6 –5 –4 –3 –2 –1
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: –6 –5 –4 –3 –2 –1
- en: '1'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '5'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '6'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: –1
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: –1
- en: –2
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: –2
- en: –3
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: –3
- en: –4
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: –4
- en: –5
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: –5
- en: –6
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: –6
- en: '*Figure 5-1: The standard Cartesian coordinate system*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：标准的笛卡尔坐标系统*'
- en: Introduction to Pygame **91**
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame 简介 **91**
- en: Any point in a Cartesian grid can be located by specifying its x- and y-coordinates
    (in that order). The origin is the point specified as (0, 0) and
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 笛卡尔网格中的任何点都可以通过指定其 x 和 y 坐标（按此顺序）来定位。原点是指定为 (0, 0) 的点，并
- en: is found in the center of the grid.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 位于网格的中心。
- en: Computer window coordinates work in a similar way (Figure 5-2).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机窗口坐标的工作方式类似（图 5-2）。
- en: '0'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: Max x
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最大 x
- en: '0'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: Max y
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最大 y
- en: '*Figure 5-2: A computer window’s coordinate system*'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：计算机窗口的坐标系统*'
- en: 'However, there are a few key differences:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些关键的区别：
- en: 1\. The origin (0, 0) point is in the upper-left corner of the window.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 原点 (0, 0) 位于窗口的左上角。
- en: 2\. The y-axis is reversed so that y values start at zero at the top of the
    win-
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. y 轴被反转，因此 y 值从窗口顶部的零开始。
- en: dow and increase as you go down.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 向下时，行和列增加。
- en: 3\. The x and y values are always integers. Each (x, y) pair specifies a single
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. x 和 y 值总是整数。每个 (x, y) 对指定一个
- en: pixel in the window. These values are always specified as relative to the
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口中的像素。这些值总是相对于
- en: upper-left corner of the window, not the screen. That way, the user can
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的左上角，而不是屏幕的位置。这样，用户可以
- en: move the window anywhere on the screen without affecting the coordi-
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 将窗口移动到屏幕的任何位置，而不会影响坐标-
- en: nates of the elements of the program displayed in the window.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中元素的坐标在窗口中显示。
- en: The full computer screen has its own set of (x, y) coordinates for every
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 整个计算机屏幕有一套独立的 (x, y) 坐标，
- en: pixel and uses the same type of coordinate system, but programs rarely, if
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 像素并使用相同类型的坐标系统，但程序很少，除非
- en: ever, need to deal with screen coordinates.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要处理屏幕坐标的情况很少。
- en: When we write a pygame application, we need to specify the width and
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写一个 pygame 应用程序时，我们需要指定窗口的宽度和
- en: height of the window we want to create. Within the window, we can address
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的高度我们想要创建。在窗口中，我们可以定位
- en: any pixel using its x- and y-coordinates, as shown in Figure 5-3\.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 x 和 y 坐标来引用任意像素，如图 5-3 所示\。
- en: Figure 5-3 shows a black pixel at position (3, 5). That is an x-value of 3
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-3 显示了在位置 (3, 5) 处的黑色像素。那是 x 值为 3
- en: (note that this is actually the fourth column, since coordinates start at 0)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，这实际上是第四列，因为坐标从 0 开始）
- en: and a y value of 5 (actually the sixth row). Each pixel in a window is com-
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 y 值为 5（实际上是第六行）。窗口中的每个像素都是计算
- en: monly referred to as a *point*. To reference a point in a window, you would
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 通常被称为 *点*。要引用窗口中的点，可以
- en: typically use a Python tuple. For example, you might have an assignment
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用 Python 元组。例如，你可能有一个赋值
- en: 'statement like this, with the x value first:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 语句像这样，先写 x 值：
- en: pixelLocation = (3, 5)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: pixelLocation = (3, 5)
- en: '**92** Chapter 5'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**92** 第 5 章'
- en: '0'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '5'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '6'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '7'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '8'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '9'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: 10 11 12 13 …
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 10 11 12 13 …
- en: '0'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '5'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '6'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '7'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '8'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '9'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: '10'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: '11'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: '12'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: '13'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: …
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: '*Figure 5-3: A single point (a single pixel) in a computer window*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-3：计算机窗口中的单个点（单个像素）*'
- en: To show an image in a window, we need to specify the coordinates of its
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要在窗口中显示图像，我们需要指定其
- en: starting point—always the upper-left corner of the image—as an (x, y) pair,
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 起始点——始终是图像的左上角——作为 (x, y) 对，
- en: as in Figure 5-4, where we draw the image at location (3, 5).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如图 5-4 所示，我们在位置 (3, 5) 绘制图像。
- en: When working with an image, you’ll often need to deal with the
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理图像时，你经常需要处理
- en: '*bounding rectangle*, which is the smallest rectangle that can be made that'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '*边界矩形*，即可以形成的最小矩形'
- en: completely surrounds all pixels of the image. A rectangle is represented
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 完全围绕图像的所有像素。矩形表示
- en: 'in pygame by a set of four values: x, y, width, height. The rectangle for'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pygame 中由一组四个值表示：x, y, 宽度, 高度。矩形的
- en: the image in Figure 5-4 has values of 3, 5, 11, 7\. I’ll show you how to use
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-4中的图像具有3、5、11、7的值。我将展示如何使用
- en: a rectangle like this in an upcoming example program. Even if your
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是下一个示例程序中这样的矩形，也会用到。即使你的
- en: image is not rectangular (for example, if it’s a circle or an ellipse), you
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图像不是矩形的（例如，如果它是圆形或椭圆形），你
- en: still have to consider its bounding rectangle for positioning and collision
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然必须考虑其边界矩形以进行定位和碰撞检测
- en: detection.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 检测。
- en: Introduction to Pygame **93**
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 《Pygame简介**93**
- en: '0'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '5'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '6'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '7'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '8'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '9'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: 10 11 12 13 …
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 10 11 12 13 …
- en: '0'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '0'
- en: '1'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '2'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '3'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '4'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '5'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '6'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '6'
- en: '7'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '7'
- en: '8'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '8'
- en: '9'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '9'
- en: '10'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '10'
- en: '11'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '11'
- en: '12'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '12'
- en: '13'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '13'
- en: …
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: '*Figure 5-4: An image in a window*'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-4：窗口中的图像*'
- en: '***Pixel Colors***'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '***像素颜色***'
- en: Let’s explore how colors are represented on the computer screen. If you
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一下颜色在计算机屏幕上的表示方式。如果你
- en: have experience with a graphics program like Photoshop, you probably
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有使用过像Photoshop这样的图形程序，你可能
- en: already know how this works, but you may want a quick refresher anyway.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经知道这是如何工作的，但你可能还是想要快速复习一下。
- en: 'Each pixel on the screen is made up of a combination of three colors:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上的每个像素都是由三种颜色的组合构成：
- en: red, green, and blue, often referred to as *RGB*. The color displayed in
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 红色、绿色和蓝色，通常称为*RGB*。屏幕上显示的颜色
- en: any pixel is composed of some amount of red, green, and blue, where the
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 每个像素由一定量的红色、绿色和蓝色组成，其中
- en: amount of each is specified as a value from 0, meaning none, to 255, mean-
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 每种颜色的量通过一个0到255之间的值来指定，0表示没有，255表示最大强度-
- en: ing full intensity. Therefore, there are 256 × 256 × 256 possible combina-
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以全强度显示。因此，存在256 × 256 × 256种可能的组合-
- en: tions, or 16,777,216 (often referred to as just “16 million”) possible colors,
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 组合的可能性或16,777,216种（通常简称“1600万”）种颜色，
- en: for each pixel.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个像素。
- en: Colors in pygame are given as RGB values, and we write them as Python
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: pygame中的颜色是通过RGB值给出的，我们将它们写成Python
- en: 'tuples of three numbers. Here is how we create constants for the main colors:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三个数字的元组。以下是我们为主要颜色创建常量的方式：
- en: 'RED = (255, 0, 0) # full red, no green, no blue'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 'RED = (255, 0, 0) # 完全红色，无绿色，无蓝色'
- en: 'GREEN = (0, 255, 0) # no red, full green, no blue'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 'GREEN = (0, 255, 0) # 无红色，完全绿色，无蓝色'
- en: 'BLUE = (0, 0, 255) # no red, no green, full blue'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 'BLUE = (0, 0, 255) # 无红色，无绿色，完全蓝色'
- en: '**94** Chapter 5'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**94** 第五章'
- en: 'Here are the definitions of a few more colors. You can create a color using
    any combination of three numbers between 0 and 255:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是几种颜色的定义。你可以使用任意组合的三种数字（0到255之间）来创建颜色：
- en: 'BLACK = (0, 0, 0) # no red, no green, no blue'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 'BLACK = (0, 0, 0) # 无红色，无绿色，无蓝色'
- en: 'WHITE = (255, 255, 255) # full red, full green, full blue'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 'WHITE = (255, 255, 255) # 完全红色，完全绿色，完全蓝色'
- en: DARK_GRAY = (75, 75, 75)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: DARK_GRAY = (75, 75, 75)
- en: MEDIUM_GRAY = (128, 128, 128)
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: MEDIUM_GRAY = (128, 128, 128)
- en: LIGHT_GRAY = (175, 175, 175)
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: LIGHT_GRAY = (175, 175, 175)
- en: 'TEAL = (0, 128, 128) # no red, half-strength green, half-strength blue'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 'TEAL = (0, 128, 128) # 无红色，半强度绿色，半强度蓝色'
- en: YELLOW = (255, 255, 0)
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: YELLOW = (255, 255, 0)
- en: PURPLE = (128, 0, 128)
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: PURPLE = (128, 0, 128)
- en: In pygame, you’ll need to specify colors when you want to fill the back-
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在pygame中，当你想要填充窗口背景时，你需要指定颜色-
- en: ground of a window, draw a shape in a color, draw text in a color, and so on.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口的背景上绘制一个形状，绘制文本等。
- en: Defining colors up front as tuple constants makes them very easy to spot
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 提前定义颜色作为元组常量可以使它们非常容易辨识
- en: later in code.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后在代码中。
- en: '**Event-Driven Programs**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件驱动程序**'
- en: In most of the programs in the book so far, the main code has lived in a
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在到目前为止书中的大多数程序中，主要代码通常位于
- en: while loop. The program stops at a call to the built-in input() function and
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用内建的input()函数时，程序会停止并
- en: waits for some user input to work on. Program output is typically handled
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 等待用户输入以便工作。程序的输出通常由
- en: using calls to print().
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 使用print()函数输出。
- en: In interactive GUI programs, this model no longer works. GUIs intro-
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在交互式图形用户界面（GUI）程序中，这种模型不再适用。GUI介绍-
- en: duce a new model of computing known as the *event-driven* model. Event-
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 引入了一种新的计算模型，称为*事件驱动*模型。事件-
- en: driven programs don’t rely on input() and print(); instead, the user interacts
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序不再依赖input()和print()；相反，用户通过
- en: with elements in a window at will using a keyboard and/or mouse or other
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过键盘和/或鼠标或其他指点设备在窗口中随意操作元素
- en: pointing device. They may be able to click various buttons or icons, make
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 指点设备。用户可能能够点击各种按钮或图标，进行
- en: selections from menus, provide input in text fields, or give commands via
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 从菜单中选择，提供文本框输入，或通过
- en: clicks or key presses to control some avatar in the window.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 点击或按键来控制窗口中的某个化身。
- en: '**N O T E**'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**注释**'
- en: '*Calls to print() can still be highly useful for debugging, when used to write
    out intermediate results.*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '*调用 print() 仍然在调试时非常有用，可以用来输出中间结果。*'
- en: Central to event-driven programming is the concept of an *event*. Events
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动编程的核心概念是 *事件*。事件
- en: are difficult to define and are best described with examples, such as a mouse
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 很难定义这些事件，最好通过示例来描述，比如鼠标
- en: 'click and a key press (each of which is actually made up of two events: mouse'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 点击和按键事件（每个事件实际上由两个事件组成：鼠标
- en: down and mouse up and key down and key up, respectively). Here is my
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 向下、鼠标抬起、按键按下和按键抬起事件，分别对应）。这是我的
- en: working definition.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 工作定义。
- en: '**event**'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件**'
- en: Something that happens while your program is running that your program wants
    to
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序运行时发生的事件，程序希望对其作出反应
- en: or needs to respond to . Most events are generated by user actions .
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 或者需要响应的事件。大多数事件都是由用户的操作生成的。
- en: An event-driven GUI program runs constantly in an infinite loop. Each
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 一个事件驱动的 GUI 程序会不断在无限循环中运行。每个
- en: time through the loop, the program checks for any new events it needs to
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环时，程序都会检查是否有新的事件需要
- en: react to and executes appropriate code to handle those events. Also, each
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 响应并执行适当的代码来处理这些事件。此外，每个
- en: time through the loop, the program needs to redraw all the elements in the
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 每次循环时，程序需要重新绘制所有元素，
- en: window to update what the user sees.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口更新用户看到的内容。
- en: Introduction to Pygame **95**
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame简介 **95**
- en: '![Image 18](index-125_1.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![图片 18](index-125_1.png)'
- en: For example, say we have a simple GUI program that displays two but-
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个简单的 GUI 程序，显示两个按钮
- en: 'tons: Bark and Meow. When clicked, the Bark button plays a sound of a dog'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 吠声和喵声按钮。点击时，吠叫按钮播放狗叫声
- en: barking and the Meow button plays a sound of a cat meowing (Figure 5-5).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 吠叫和喵喵按钮播放猫咪叫声（图 5-5）。
- en: '*Figure 5-5: A simple program*'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5：一个简单的程序*'
- en: '*with two but ons*'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '*带有两个按钮*'
- en: The user can click these buttons in any order and at any time. To han-
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以随时以任何顺序点击这些按钮。为了处理
- en: dle the user’s actions, the program runs in a loop and constantly checks to
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 处理用户的操作时，程序会在循环中运行并不断检查
- en: see if either button has been clicked. When it receives a mouse down event
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 查看哪个按钮被点击。当程序接收到鼠标按下事件时，
- en: on a button, the program remembers that the button has been clicked and
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击按钮时，程序会记住该按钮已被点击，并
- en: draws the depressed image of that button. When it receives a mouse up
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制按下状态的按钮图像。当它接收到鼠标抬起
- en: event on the button, it remembers the new state and redraws the button
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在按钮上发生的事件，程序记住新的状态并重新绘制按钮
- en: with its original appearance, and it plays the appropriate sound. Because
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 保持原来的外观，并播放适当的声音。因为
- en: the main loop runs so quickly, the user perceives that the sound plays
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环运行得非常快，用户感觉声音是即时播放的。
- en: immediately after they click the button. Each time through the loop, the
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 每次点击按钮后立即执行。每次通过循环时，
- en: program redraws both buttons with an image matching each button’s cur-
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 程序会重新绘制两个按钮，并用与每个按钮当前
- en: rent state.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 租赁状态。
- en: '**Using Pygame**'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 Pygame**'
- en: At first, pygame may seem like an overwhelmingly large package with many
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，pygame 可能看起来是一个庞大的软件包，包含很多
- en: different calls available. Although it is large, there’s actually not a lot
    that
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多不同的调用可用。虽然它很大，但实际上没有很多
- en: you need to understand to get a small program up and running. To intro-
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要理解的内容，才能让一个小程序顺利运行。为了介绍
- en: duce pygame, I’ll first give you a template that you can use for all pygame
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 引入 pygame 时，我将首先提供一个模板，您可以将其用于所有 pygame
- en: programs you create. Then I’ll build on that template, adding key pieces of
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 你所创建的程序。然后我会在此基础上构建，添加关键部分
- en: functionality little by little.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 一点一点地完善功能。
- en: 'In the following sections, I’ll show you how to:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我将向您展示如何：
- en: • Bring up a blank window.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: • 打开空白窗口。
- en: • Show an image.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: • 显示图像。
- en: • Detect a mouse click.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: • 检测鼠标点击。
- en: • Detect both single and continuous key presses.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: • 检测单次和连续的键盘按键。
- en: • Create a simple animation.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: • 创建简单的动画。
- en: • Play sound effects and background sounds.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: • 播放音效和背景音效。
- en: • Draw shapes.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: • 绘制形状。
- en: In the next chapter, we’ll continue the discussion of pygame and you’ll
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续讨论 pygame，您将
- en: 'see how to:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何：
- en: • Animate many objects.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: • 动画多个对象。
- en: • Build and react to a button.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: • 构建并响应按钮。
- en: • Create a text display field.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: • 创建文本显示区域。
- en: '**96** Chapter 5'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**96** 第五章'
- en: '***Bringing Up a Blank Window***'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '***打开空白窗口***'
- en: As I said earlier, pygame programs run constantly in a loop, checking for
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前所说，pygame 程序会不断地在循环中运行，检查
- en: events. It might help to think of your program as an animation, where
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 事件。你可以把程序当作动画来看，其中
- en: each pass through the main loop is one frame. The user may click on
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 每次通过主循环就是一帧。用户可能会点击
- en: something during any frame, and your program must not only respond
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧中做点什么，并且你的程序不仅要响应
- en: to that input but also keep track of everything it needs to draw in the
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 对该输入进行处理，同时跟踪所有需要绘制的内容
- en: window. For instance, in one example program later in this chapter, we’ll
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口。比如，在本章后面的一个示例程序中，我们会
- en: move a ball across the window so in each frame the ball is drawn in a
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 移动一个球穿越窗口，所以在每一帧中，球会被绘制在一个
- en: slightly different position.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 略微不同的位置。
- en: Listing 5-1 is a generic template that you can use as a starting point for
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-1 是一个通用模板，你可以将其作为
- en: all your pygame programs. This program opens a window and paints the
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你所有 pygame 程序的基础。这个程序打开一个窗口，并绘制
- en: entire contents black. The only thing the user can do is click the close but-
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 整个内容被涂成黑色。用户唯一能做的就是点击关闭按钮
- en: ton to quit the program.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 让程序无法退出。
- en: '**File: PygameDemo0_WindowOnly/PygameWindowOnly.py**'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PygameDemo0_WindowOnly/PygameWindowOnly.py**'
- en: pygame demo 0 - window only
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pygame 演示 0 - 仅窗口
- en: 1 - Import packages
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 - 导入包
- en: import pygame
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from pygame.locals import *
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: from pygame.locals import *
- en: import sys
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: 2 - Define constants
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 - 定义常量
- en: BLACK = (0, 0, 0)
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: BLACK = (0, 0, 0)
- en: WINDOW_WIDTH = 640
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_WIDTH = 640
- en: WINDOW_HEIGHT = 480
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_HEIGHT = 480
- en: FRAMES_PER_SECOND = 30
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: FRAMES_PER_SECOND = 30
- en: 3 - Initialize the world
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 - 初始化世界
- en: pygame.init()
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.init()
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
- en: clock = pygame.time.Clock()
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: clock = pygame.time.Clock()
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 - 加载资源：图像、声音等。
- en: 5 - Initialize variables
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 - 初始化变量
- en: 6 - Loop forever
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 - 永久循环
- en: 'while True:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 7 - Check for and handle events
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 - 检查并处理事件
- en: 'for event in pygame.event.get():'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: Clicked the close button? Quit pygame and end the program
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击了关闭按钮？退出 pygame 并结束程序
- en: 'if event.type == pygame.QUIT:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件类型是 pygame.QUIT：
- en: pygame.quit()
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: 8 - Do any "per frame" actions
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 - 执行任何“每帧”操作
- en: 9 - Clear the window
  id: totrans-449
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 - 清除窗口
- en: Introduction to Pygame **97**
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame 简介 **97**
- en: window.fill(BLACK)
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: window.fill(BLACK)
- en: 10 - Draw all window elements
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 - 绘制所有窗口元素
- en: 11 - Update the window
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 - 更新窗口
- en: pygame.display.update()
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.update()
- en: 12 - Slow things down a bit
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 - 稍微放慢速度
- en: clock.tick(FRAMES_PER_SECOND)
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: clock.tick(FRAMES_PER_SECOND)
- en: '*Listing 5-1: A template for creating pygame programs*'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-1：创建 pygame 程序的模板*'
- en: 'Let’s walk through the different parts of this template:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解这个模板的不同部分：
- en: 1\. Import packages.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 导入包。
- en: The template starts with the import statements. We first import the pyg-
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 模板从导入语句开始。我们首先导入 pygame
- en: ame package itself, then some constants defined inside pygame that
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏包本身，然后是 pygame 中定义的一些常量
- en: we’ll use later. The last import is the sys package, which we’ll use to quit
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们会用到的。最后一个导入是 sys 包，我们将用它来退出
- en: our program.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序。
- en: 2\. Define constants.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 定义常量。
- en: We next define any constants for our program. First we define the
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们为程序定义常量。首先我们定义
- en: RGB value for BLACK, which we will use to paint the background of
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: RGB 值为 BLACK，我们将用它来绘制窗口的背景。
- en: our window. Then we define constants for the width and height of our
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的窗口。然后我们为窗口的宽度和高度定义常量，
- en: window in pixels and a constant for the refresh rate for our program.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 以像素为单位的窗口宽度和高度，并为程序定义一个刷新率常量。
- en: This number defines the maximum number of times the program will
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字定义了程序每秒钟将执行的最大循环次数
- en: loop (and therefore redraw the window) per second. Our value of 30
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒钟的循环次数（因此会重新绘制窗口）。我们的值为 30
- en: is fairly typical. If the amount of work done in our main loop is exces-
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式是相当典型的。如果主循环中执行的工作量过多，
- en: sive, the program might run slower than this value, but it will never
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 由于程序可能会运行得比这个值慢，但永远不会
- en: run faster. A refresh rate that’s too high might cause the program to
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 运行得更快。刷新率过高可能导致程序运行
- en: run too fast. In our ball example, this means the ball might bounce
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 运行过快。在我们的球的示例中，这意味着球可能会反弹
- en: around the window faster than intended.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 使得窗口的周围区域运行速度比预期更快。
- en: 3\. Initialize the pygame environment.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 初始化 pygame 环境。
- en: In this section, we call a function that tells pygame to initialize itself.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们调用一个函数来告诉 pygame 初始化自身。
- en: We then ask pygame to create a window for our program with the
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们让 pygame 为我们的程序创建一个窗口，使用
- en: pygame.display.set_mode() function and pass in the desired width and
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.set_mode() 函数并传入所需的宽度和
- en: height of the window. Finally, we call another pygame function to cre-
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的高度。最后，我们调用另一个pygame函数来创建
- en: ate a clock object, which will be used at the bottom of our main loop to
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个时钟对象，这将在我们的主循环底部用于
- en: maintain our maximum frame rate.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 维持我们的最大帧率。
- en: '4\. Load assets: image(s), sound(s), and so on.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 加载资源：图像、声音等。
- en: This is a placeholder section, into which we will eventually add code to
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个占位部分，我们最终会在其中添加代码来
- en: load external images, sounds, and so on from the disk for use in our
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 从磁盘加载外部图像、声音等资源供我们的程序使用。
- en: program. In this basic program we’re not using any external assets, so
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基本程序中，我们没有使用任何外部资源，所以
- en: this section is empty for now.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部分现在是空的。
- en: 5\. Initialize variables.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 初始化变量。
- en: Here we will eventually initialize any variables that our program will
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们最终会初始化程序中需要的任何变量。
- en: use. Currently we have none, so we have no code here.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 使用。目前我们没有外部资源，所以这里没有代码。
- en: '**98** Chapter 5'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '**98** 第五章'
- en: 6\. Loop forever.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. 无限循环。
- en: Here we start our main loop. This is a simple while True infinite loop.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们开始我们的主循环。这是一个简单的while True无限循环。
- en: Again, you can think of each iteration through the main loop as one
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以把主循环中的每次迭代当作一个
- en: frame in an animation.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 动画中的每一帧。
- en: 7\. Check for and handle events; commonly referred to as the *event loop*.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 7\. 检查并处理事件；通常称为*事件循环*。
- en: In this section, we call pygame.event.get() to get a list of the events that
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们调用pygame.event.get()来获取事件列表，
- en: happened since the last time we checked (the last time the main loop
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 自上次检查以来发生了什么（上次主循环执行时）
- en: ran), then iterate through the list of events. Each event reported to the
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时），然后遍历事件列表。每个事件都被报告给
- en: program is an object, and every event object has a type. If no event has
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 程序是一个对象，每个事件对象都有一个类型。如果没有事件
- en: happened, this section is skipped over.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情，这部分会被跳过。
- en: In this minimal program, where the only action a user can take is
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个最小的程序中，用户唯一能做的操作是
- en: to close the window, the only event type we check for is the constant
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭窗口时，我们检查的唯一事件类型是常量
- en: pygame.QUIT, generated by pygame when the user clicks the close but-
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.QUIT，由pygame在用户点击关闭按钮时生成。
- en: ton. If we find this event, we tell pygame to quit, which frees up any
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发现这个事件，我们告诉pygame退出，这样可以释放出任何
- en: resources it was using. Then we quit our program.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它的资源。然后，我们退出程序。
- en: 8\. Do any “per frame” actions.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 8\. 执行任何“每帧”操作。
- en: In this section we’ll eventually put any code that needs to run in every
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们最终会放入每一帧需要运行的代码。
- en: frame. This might involve moving things in the window or checking for
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 帧。它可能涉及到移动窗口中的物体或检查
- en: collisions between elements. In this minimal program, we have nothing
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 元素之间的碰撞。在这个最小程序中，我们没有任何
- en: to do here.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有代码要做。
- en: 9\. Clear the window.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 9\. 清空窗口。
- en: On each iteration through the main loop, our program must redraw
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环的每次迭代中，我们的程序必须重新绘制
- en: everything in the window, which means we need to clear it first. The
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 清空窗口中的所有内容，这意味着我们需要先清空它。这个
- en: simplest approach is to just fill the window with a color, which we do here
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是直接用颜色填充窗口，我们在这里就做了这个
- en: with a call to window.fill(), specifying a black background. We could also
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 使用window.fill()调用，指定一个黑色背景。我们也可以
- en: draw a background picture, but we’ll hold off on that for now.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 画一个背景图，但我们现在先不做。
- en: 10\. Draw all window elements.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 10\. 绘制所有窗口元素。
- en: Here we’ll place code to draw everything we want to show in our win-
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们会放入代码来绘制我们希望在窗口中显示的所有内容。
- en: dow. In this sample program there is nothing to draw.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口。在这个示例程序中没有东西需要绘制。
- en: In real programs, things are drawn in the order they appear in the
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际程序中，事物是按照它们在代码中的顺序绘制的。
- en: code, in layers from backmost to frontmost. For example, assume we
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 代码按层次从最远到最近进行绘制。例如，假设我们
- en: want to draw two partially overlapping circles, A and B. If we draw A
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要绘制两个部分重叠的圆，A和B。如果我们先画A
- en: first, A will appear behind B, and portions of A will be obscured by B.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们先画A，它将出现在B后面，A的一部分会被B遮挡。
- en: If we draw B first and then A, the opposite happens, and we see A in
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们先画B然后是A，情况就相反，我们看到A在
- en: front of B. This is a natural mapping equivalent to the layers in graph-
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在B前面。这是一个自然的映射，等同于图形中的层次结构。
- en: ics programs such as Photoshop.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 例如Photoshop这样的图形程序。
- en: 11\. Update the window.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 11\. 更新窗口。
- en: This line tells pygame to take all the drawing we’ve included and show
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行告诉pygame将我们包含的所有绘图内容展示出来。
- en: it in the window. Pygame actually does all the drawing in steps 8, 9, and
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 它在窗口中。Pygame实际上在步骤8、9和
- en: 10 in an off-screen buffer. When you tell pygame to update, it takes the
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 10 在一个离屏缓冲区中。当你告诉pygame更新时，它会将
- en: contents of this off-screen buffer and puts them in the real window.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 将离屏缓冲区的内容放入实际窗口。
- en: Introduction to Pygame **99**
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame简介 **99**
- en: '![Image 19](index-129_1.png)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
  zh: '![Image 19](index-129_1.png)'
- en: 12\. Slow things down a bit.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 12\. 稍微放慢节奏。
- en: Computers are very fast, and if the loop continued to the next iteration
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机运行速度非常快，如果循环继续到下一个迭代
- en: right away without pausing, the program might run faster than the des-
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序没有暂停，程序可能会比设计的帧速率运行得更快，
- en: ignated frame rate. The line in this section tells pygame to wait until a
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 直到经过指定的帧速率时间后，pygame才会继续执行。该段代码告诉pygame等到
- en: given amount of time has elapsed in order to make the frames of our
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 经过指定时间后，为了使我们的帧显示一致，
- en: program run at the frame rate that we specified. This is important to
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 程序按照我们指定的帧速率运行。这一点非常重要
- en: ensure the program runs at a consistent rate, independent of the speed
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 确保程序以一致的速率运行，不受计算机速度的影响
- en: of the computer on which it’s running.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的运行速度。
- en: When you run this program, the program just puts up a blank window
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，程序会直接显示一个空白窗口
- en: filled with black. To end the program, click on the close button in the
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 填充为黑色。要结束程序，请点击
- en: title bar.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 标题栏。
- en: '***Drawing an Image***'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '***绘制图像***'
- en: Let’s draw something in the window. There are two parts to showing a
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在窗口中绘制一些东西。显示一个图像有两个部分
- en: 'graphic image: first we load the image into the computer’s memory, then we'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 图像文件：首先我们将图像加载到计算机内存中，然后我们
- en: display the image in the application window.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序窗口中显示图像。
- en: With pygame, all images (and sounds) need to be kept in files external
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 在pygame中，所有图像（和声音）都需要保存在外部文件中
- en: to your code. Pygame supports many standard graphic file formats, includ-
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 路径类型：相对路径和绝对路径。
- en: ing *.png*, *.jpg*, and *.gif*. In this program we’ll load a picture of a ball
    from the file *ball.png*. As a reminder, the code and assets associated with all
    the major listings in this book are available for download at [*https://www.nostarch.com/*](https://www.nostarch.com/objectorientedpython/)
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: pygame支持许多标准的图像文件格式，包括*.png*、*.jpg*和*.gif*。在这个程序中，我们将从文件*ball.png*中加载一个球的图片。提醒一下，本书中所有主要示例的代码和相关资源都可以在[*https://www.nostarch.com/*](https://www.nostarch.com/objectorientedpython/)
    下载。
- en: '[*objectorientedpython/* a](https://www.nostarch.com/objectorientedpython/)nd
    [*https://github.com/IrvKalb/O*](https://github.com/IrvKalb/Object-Oriented-Python-Code/)
    *bject-Oriented-Python-Code/*.'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '[*objectorientedpython/* a](https://www.nostarch.com/objectorientedpython/)和[*https://github.com/IrvKalb/O*](https://github.com/IrvKalb/Object-Oriented-Python-Code/)
    *面向对象Python代码/*。'
- en: While we only need one graphic file in this program, it’s a good idea
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个程序中我们只需要一个图像文件，但最好
- en: to use a consistent approach to handling graphic and sound files, so I’ll lay
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一致的方式处理图像和声音文件，因此我会这样组织
- en: one out for you here. First, create a project folder. Place your main program
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 这里给你提供了一个例子。首先，创建一个项目文件夹。将你的主程序
- en: in that folder, along with any related files containing Python classes and
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在该文件夹中，以及包含Python类和相关文件的任何文件
- en: functions. Then, inside the project folder, create an *images* folder into which
    you’ll place any image files you want to use in your program. Also create
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 功能。然后，在项目文件夹中创建一个*images*文件夹，在其中放入你要在程序中使用的任何图像文件。还要创建
- en: a *sounds* folder and place any sound files you want to use there. Figure 5-6
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*声音*文件夹，并将你要使用的任何声音文件放在那里。图5-6
- en: shows the suggested structure. All of the example programs in this book
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 显示了建议的结构。本书中的所有示例程序
- en: will use this project folder layout.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用这个项目文件夹结构。
- en: '*Figure 5-6: Suggested project folder hierarchy*'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-6：建议的项目文件夹层次结构*'
- en: A *path* (also called a *pathname*) is a string that uniquely identifies the
    location of a file or folder on a computer. To load a graphic or sound file
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '*路径*（也称为*路径名*）是唯一标识文件或文件夹在计算机上位置的字符串。要加载图像或声音文件'
- en: into your program, you must specify the path to the file. There are two
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件加载到你的程序中时，必须指定文件的路径。有两种
- en: 'types of paths: relative and absolute.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 路径有两种类型：相对路径和绝对路径。
- en: A *relative path* is a relative to the current folder, often called the *current*
    *working directory*. When you run a program using an IDE such as IDLE or
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '*相对路径*是相对于当前文件夹的路径，通常称为*当前* *工作目录*。当你使用IDLE或'
- en: '**100** Chapter 5'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '**100** 第5章'
- en: PyCharm, it sets the current folder to the one containing your main Python program
    so you can use relative paths with ease. In this book, I will assume
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用PyCharm，它会将当前文件夹设置为包含你主Python程序的文件夹，因此你可以轻松使用相对路径。在本书中，我假设
- en: you’re using an IDE and will represent all paths as relative paths.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 IDE，并且会将所有路径表示为相对路径。
- en: The relative path for a graphic file (for example, *ball.png*) in the same
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 图形文件的相对路径（例如，*ball.png*）在同一
- en: folder as your main Python file would be just the filename as a string (for
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹作为你的主 Python 文件时，路径将只是文件名字符串（例如
- en: example, 'ball.png'). Using the suggested project structure, the relative
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，'ball.png'）。使用建议的项目结构，相对路径
- en: path would be 'images/ball.png'.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 路径将是 'images/ball.png'。
- en: This says that inside the project folder will be another folder named
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示在项目文件夹内将有一个名为
- en: '*images*, and inside that folder is a file named *ball.png*. In path strings,
    folder names are separated by the slash character.'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '*图像*，并且该文件夹内有一个名为 *ball.png* 的文件。在路径字符串中，文件夹名称之间用斜杠字符分隔。'
- en: However, if you expect to run your program from the command line,
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你打算从命令行运行程序，
- en: then you need to construct absolute paths for all files. An *absolute path*
    is one that starts from the root of the filesystem and includes the full hierarchy
    of folders to your file. To build an absolute path to any file, you can use
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要为所有文件构建绝对路径。*绝对路径*是指从文件系统的根目录开始，并包含到文件的完整文件夹层次结构。要构建到任何文件的绝对路径，可以使用
- en: 'code like this, which builds an absolute path string to the *ball.png* file
    in the *images* folder inside the project folder:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 代码类似于这样，它构建了一个绝对路径字符串指向项目文件夹内 *images* 文件夹中的 *ball.png* 文件：
- en: from pathlib import Path
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 pathlib 的 Path
- en: 'Place this in section #2, defining a constant'
  id: totrans-580
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将此放入第2节，定义一个常量
- en: BASE_PATH = Path(__file__).resolve().parent
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: BASE_PATH = Path(__file__).resolve().parent
- en: Build a path to the file in the images folder
  id: totrans-582
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建到图像文件夹中文件的路径
- en: pathToBall = BASE_PATH + 'images/ball.png'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: pathToBall = BASE_PATH + 'images/ball.png'
- en: Now we’ll create the code of the ball program, starting with the ear-
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建球的程序代码，从最初的部分开始—
- en: lier 12-step template and adding just two new lines of code, as shown in
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: liar 12 步模板并只添加两行新代码，如下所示
- en: Listing 5-2\.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-2。
- en: '**File: PygameDemo1_OneImage/PygameOneImage.py**'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PygameDemo1_OneImage/PygameOneImage.py**'
- en: pygame demo 1 – draw one image
  id: totrans-588
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pygame 示例 1 – 绘制一张图像
- en: '--- snip ---'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 截取 ---'
- en: 3 - Initialize the world
  id: totrans-590
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 - 初始化世界
- en: pygame.init()
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.init()
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
- en: clock = pygame.time.Clock()
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: clock = pygame.time.Clock()
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-594
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 - 加载资源：图像、声音等。
- en: 1 ballImage = pygame.image.load('images/ball.png')
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 1 ballImage = pygame.image.load('images/ball.png')
- en: 5 - Initialize variables
  id: totrans-596
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 - 初始化变量
- en: '--- snip ---'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 截取 ---'
- en: 10 - Draw all window elements
  id: totrans-598
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 - 绘制所有窗口元素
- en: draw ball at position 100 across (x) and 200 down (y)
  id: totrans-599
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在位置 100 处绘制球（x 轴）和 200 处（y 轴）
- en: 2 window.blit(ballImage, (100, 200))
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 2 window.blit(ballImage, (100, 200))
- en: 11 - Update the window
  id: totrans-601
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 - 更新窗口
- en: Introduction to Pygame **101**
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame 介绍 **101**
- en: pygame.display.update()
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.update()
- en: 12 - Slow things down a bit
  id: totrans-604
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 - 稍微放慢一点
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 'clock.tick(FRAMES_PER_SECOND) # 让 pygame 等待'
- en: '*Listing 5-2: Load one image and draw it in every frame.*'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-2：加载一张图像并在每一帧中绘制它。*'
- en: First, we tell pygame to find the file containing the image of the ball
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们告诉 pygame 找到包含球图像的文件
- en: and load that image into memory 1\. The variable ballImage now refers to
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 并将该图像加载到内存中 1。变量 ballImage 现在指向
- en: the image of the ball. Notice that this assignment statement is only exe-
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 球的图像。请注意，这个赋值语句只有在
- en: cuted once, before the main loop starts.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环开始之前，已经执行一次。
- en: '**N O T E**'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '**注**'
- en: '*In the official documentation of pygame, every image, including the application
    window, is known as a* surface *. I’ll use more specific terms: I will refer to
    the application* *window simply as a* window *and to any picture loaded from an
    external file as an* image *. I reserve the term* surface *for any picture drawn
    on the fly.*'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 pygame 的官方文档中，所有图像，包括应用程序窗口，都被称为* surface *。我将使用更具体的术语：我将把应用程序*窗口*简单地称为*窗口*，而将从外部文件加载的任何图片称为*图像*。我保留*surface*一词，用于指代任何动态绘制的图片。*'
- en: We then tell the program to draw the ball 2 every time we go through
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们告诉程序每次循环时绘制球 2
- en: the main loop. We specify the location representing the position to place
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环。我们指定代表位置的坐标来放置
- en: the upper-left corner of the image’s bounding rectangle, typically as a tuple
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 图像边界矩形的左上角，通常表示为一个元组
- en: of x- and y-coordinates.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: x 和 y 坐标。
- en: The function name blit() is a very old reference to the words *bit block*
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名 blit() 是对 *bit block* 词组的一个非常旧的引用
- en: '*transfer*, but in this context it really just means “draw.” Since the program
    loaded the ball image earlier, pygame knows how big the image is, so we'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '*转移*，但在这个上下文中，它实际上只是意味着“绘制”。由于程序之前已经加载了球的图像，pygame 知道图像的大小，所以我们'
- en: just need to tell it where to draw the ball. In Listing 5-2, we give an x value
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要告诉它在哪里绘制球。在列出 5-2 中，我们给了一个 x 值
- en: of 100 and a y value of 200\.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 100 和 y 值为 200\。
- en: When you run the program, on each iteration through the loop (30
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，在每次循环迭代中（每秒 30 次）
- en: times per second) every pixel in the window is set to black, then the ball
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒 30 次) 每次循环时，窗口中的每个像素都会被设置为黑色，然后绘制球
- en: is drawn over the background. From the user’s point of view, it looks like
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 是绘制在背景上的。从用户的角度来看，它看起来像是
- en: nothing is happening—the ball just stays in one spot with the upper-left
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么发生——球只是停留在一个位置，左上角
- en: corner of its bounding rectangle at location (100, 200).
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 它的边界矩形的左上角位置在 (100, 200)。
- en: '***Detecting a Mouse Click***'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '***检测鼠标点击***'
- en: Next, we’ll allow our program to detect and react to a mouse click. The user
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将允许程序检测并响应鼠标点击。用户
- en: will be able to click on the ball to make it appear somewhere else in the
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够点击球，使它出现在窗口中的另一个位置
- en: window. When the program detects a mouse click on the ball, it randomly
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口。当程序检测到在球上点击鼠标时，它会随机
- en: picks new coordinates and draws the ball at that new location. Instead of
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 会选择新的坐标，并在该新位置绘制球。与其
- en: using hardcoded coordinates of (100, 200), we’ll create two variables, ballX
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 使用硬编码的坐标 (100, 200)，我们将创建两个变量，ballX
- en: and ballY, and refer to the coordinates of the ball in the window as the
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 和 ballY，指的是窗口中球的位置坐标
- en: tuple (ballX, ballY). Listing 5-3 provides the code.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 元组 (ballX, ballY)。列出 5-3 提供了代码。
- en: '**File: PygameDemo2_ImageClickAndMove/PygameImageClickAndMove.py**'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PygameDemo2_ImageClickAndMove/PygameImageClickAndMove.py**'
- en: pygame demo 2 - one image, click and move
  id: totrans-635
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pygame 演示 2 - 一个图像，点击并移动
- en: 1 - Import packages
  id: totrans-636
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 - 导入包
- en: import pygame
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from pygame.locals import *
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 从 pygame.locals 导入 *
- en: import sys
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: '**102** Chapter 5'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '**102** 第五章'
- en: 1 import random
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 1 import random
- en: 2 - Define constants
  id: totrans-642
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 - 定义常量
- en: BLACK = (0, 0, 0)
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 黑色 = (0, 0, 0)
- en: WINDOW_WIDTH = 640
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口宽度 = 640
- en: WINDOW_HEIGHT = 480
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口高度 = 480
- en: FRAMES_PER_SECOND = 30
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 每秒帧数 = 30
- en: 2 BALL_WIDTH_HEIGHT = 100
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 2 BALL_WIDTH_HEIGHT = 100
- en: MAX_WIDTH = WINDOW_WIDTH - BALL_WIDTH_HEIGHT
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: MAX_WIDTH = 窗口宽度 - BALL_WIDTH_HEIGHT
- en: MAX_HEIGHT = WINDOW_HEIGHT - BALL_WIDTH_HEIGHT
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: MAX_HEIGHT = 窗口高度 - BALL_WIDTH_HEIGHT
- en: 3 - Initialize the world
  id: totrans-650
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 - 初始化世界
- en: pygame.init()
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.init()
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: window = pygame.display.set_mode((窗口宽度, 窗口高度))
- en: clock = pygame.time.Clock()
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: clock = pygame.time.Clock()
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-654
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 - 加载资源：图像、声音等
- en: ballImage = pygame.image.load('images/ball.png')
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: ballImage = pygame.image.load('images/ball.png')
- en: 5 - Initialize variables
  id: totrans-656
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 - 初始化变量
- en: 3 ballX = random.randrange(MAX_WIDTH)
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 3 ballX = random.randrange(MAX_WIDTH)
- en: ballY = random.randrange(MAX_HEIGHT)
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: ballY = random.randrange(MAX_HEIGHT)
- en: 4 ballRect = pygame.Rect(ballX, ballY, BALL_WIDTH_HEIGHT, BALL_WIDTH_HEIGHT)
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 4 ballRect = pygame.Rect(ballX, ballY, BALL_WIDTH_HEIGHT, BALL_WIDTH_HEIGHT)
- en: 6 - Loop forever
  id: totrans-660
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 - 永久循环
- en: 'while True:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 7 - Check for and handle events
  id: totrans-662
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 - 检查并处理事件
- en: 'for event in pygame.event.get():'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: Clicked the close button? Quit pygame and end the program
  id: totrans-664
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击了关闭按钮？退出 pygame 并结束程序
- en: 'if event.type == pygame.QUIT:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 event.type == pygame.QUIT:'
- en: pygame.quit()
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: See if user clicked
  id: totrans-668
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看用户是否点击
- en: '5 if event.type == pygame.MOUSEBUTTONUP:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '5 如果 event.type == pygame.MOUSEBUTTONUP:'
- en: 'mouseX, mouseY = event.pos # Could do this if we needed it'
  id: totrans-670
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'mouseX, mouseY = event.pos  # 如果我们需要，可以使用这个'
- en: Check if the click was in the rect of the ball
  id: totrans-671
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查点击是否发生在球的矩形区域内
- en: If so, choose a random new location
  id: totrans-672
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果是，选择一个随机的新位置
- en: '6 if ballRect.collidepoint(event.pos):'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '6 如果 ballRect.collidepoint(event.pos):'
- en: ballX = random.randrange(MAX_WIDTH)
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: ballX = random.randrange(MAX_WIDTH)
- en: ballY = random.randrange(MAX_HEIGHT)
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: ballY = random.randrange(MAX_HEIGHT)
- en: ballRect = pygame.Rect(ballX, ballY, BALL_WIDTH_HEIGHT,
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: ballRect = pygame.Rect(ballX, ballY, BALL_WIDTH_HEIGHT,
- en: BALL_WIDTH_HEIGHT)
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: BALL_WIDTH_HEIGHT)
- en: 8 Do any "per frame" actions
  id: totrans-678
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 执行每帧的操作
- en: 9 - Clear the window
  id: totrans-679
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 - 清除窗口
- en: window.fill(BLACK)
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: window.fill(黑色)
- en: 10 - Draw all window elements
  id: totrans-681
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 - 绘制所有窗口元素
- en: Draw the ball at the randomized location
  id: totrans-682
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在随机位置绘制球
- en: 7 window.blit(ballImage, (ballX, ballY))
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 7 window.blit(ballImage, (ballX, ballY))
- en: Introduction to Pygame **103**
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame 入门 **103**
- en: 11 - Update the window
  id: totrans-685
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 - 更新窗口
- en: pygame.display.update()
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.update()
- en: 12 - Slow things down a bit
  id: totrans-687
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 - 稍微减慢一下
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 'clock.tick(每秒帧数)  # 使 pygame 等待'
- en: '*Listing 5-3: Detecting a mouse click and acting on it*'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 5-3：检测鼠标点击并做出反应*'
- en: Since we need to generate random numbers for the ball coordinates,
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要生成随机数来确定球的位置，
- en: we import the random package 1\.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入 random 包 1\.
- en: We then add a new constant to define the height and width of our
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加一个新的常量来定义我们球的高度和宽度
- en: image as 100 pixels 2\. We also create two more constants to limit the maxi-
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 图像大小为 100 像素 2\. 我们还创建了两个常量来限制最大
- en: mum width and height coordinates. By using these constants rather than
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 最大宽度和高度坐标。通过使用这些常量而不是
- en: the size of the window, we ensure that our ball image will always appear
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的大小时，我们确保我们的球形图像始终会出现
- en: fully within the window (remember that when we refer to the location of an
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口内完全显示（记住，当我们提到一个物体的位置时，它是指
- en: image, we are specifying the position of its upper-left corner). We use those
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 图像，我们指定的是它的左上角位置。我们使用这些
- en: constants to choose random values for the starting x- and y-coordinates for
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 常量，用于为球的初始 x 和 y 坐标选择随机值
- en: our ball 3\.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的球 3\.
- en: Next, we call pygame.Rect() to create a rectangle 4\. Defining a rectangle
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用 pygame.Rect() 来创建一个矩形 4\. 定义一个矩形
- en: requires four parameters—an x-coordinate, a y-coordinate, a width, and a
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 需要四个参数——一个 x 坐标、一个 y 坐标、一个宽度和一个
- en: 'height, in that order:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 高度，按此顺序：
- en: '*<rectObject>* = pygame.Rect( *<x>* , *<y>* , *<width>* , *<height>* ) This
    returns a pygame rectangle object, or rect. We’ll use the rectangle'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rectObject>* = pygame.Rect( *<x>* , *<y>* , *<width>* , *<height>* ) 这将返回一个
    pygame 矩形对象，或者叫 rect。我们将使用该矩形'
- en: of the ball in the processing of events.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件处理过程中，球形图像的位置。
- en: We also add code to check if the user clicked the mouse. As mentioned,
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了代码来检查用户是否点击了鼠标。如前所述，
- en: 'a mouse click is actually made up of two different events: a mouse down'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标点击实际上由两个不同的事件组成：一个是鼠标按下
- en: event and a mouse up event. Since the mouse up event is typically used to
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 事件和鼠标释放事件。由于鼠标释放事件通常用于
- en: signal activation, we’ll only look for that event here. This event is signaled
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 信号激活时，我们仅在此处查找该事件。此事件通过键盘触发。
- en: by a new event.type value of pygame.MOUSEBUTTONUP 5\. When we find that a
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个新的 event.type 值 pygame.MOUSEBUTTONUP 5。当我们发现
- en: mouse up event has occurred, we’ll then check to see if the location where
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标释放事件发生后，我们将检查事件发生的位置是否
- en: the user clicked was inside the current rectangle of the ball.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 用户点击的位置是否在当前球形矩形内。
- en: When pygame detects that an event has happened, it builds an event
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 当 pygame 检测到事件发生时，它会构建一个事件
- en: object containing a lot of data. In this case, we only care about the x- and
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 对象包含大量数据。在这种情况下，我们只关心事件发生时的 x 和
- en: y-coordinates where the event happened. We retrieve the (x, y) position of
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: y 坐标，获取事件发生时的 (x, y) 位置。
- en: the click using event.pos, which provides a tuple of two values.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 event.pos 来获取点击位置，它提供一个包含两个值的元组。
- en: '**N O T E**'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '**注**'
- en: '*If we need to separate the x- and y-coordinates of the click, we can unpack
    the tuple* *and store the values into two variables like this:*'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果我们需要分离点击的 x 和 y 坐标，我们可以解包元组* *并将值存储到两个变量中，如下所示：*'
- en: mouseX, mouseY = event.pos
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: mouseX, mouseY = event.pos
- en: Now we check to see if the event happened inside the rectangle of the
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们检查事件是否发生在矩形区域内
- en: 'ball using collidepoint() 6, whose syntax is:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 collidepoint() 来检测球形图像 6，语法如下：
- en: '*<booleanVariable>* = *<someRectangle>* .collidepoint( *<someXYLocation>* )
    **104** Chapter 5'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: '*<booleanVariable>* = *<someRectangle>* .collidepoint( *<someXYLocation>* )
    **104** 第五章'
- en: The method returns a Boolean True if the given point is inside the rectangle.
    If the user has clicked the ball, we randomly select new values for
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回一个布尔值 True，如果给定的点在矩形内。如果用户点击了球，我们将为球随机选择新的位置
- en: ballX and ballY. We use those values to create a new rectangle for the ball
    at
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: ballX 和 ballY。我们使用这些值来为球创建一个新的矩形
- en: the new random location.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 新的随机位置。
- en: The only change here is that we always draw the ball at the location
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的变化是我们始终在该位置绘制球形图像
- en: given by the tuple (ballX, ballY) 7\. The effect is that whenever the user
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 由元组（ballX, ballY）给出 7\. 其效果是，每当用户
- en: clicks inside the rectangle of the ball, the ball appears to move to some new
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 点击球形矩形内，球会移动到一个新的随机位置
- en: random spot in the window.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口中的随机位置。
- en: '***Handling the Keyboard***'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '***处理键盘事件***'
- en: The next step is to allow the user to control some aspect of the program
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是允许用户控制程序的某些方面
- en: through the keyboard. There are two different ways to handle user key-
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 处理用户按键有两种不同的方法——
- en: 'board interactions: as individual key presses, and when a user holds down a'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 面板交互：作为单个按键事件，或者当用户长按某个键时
- en: key to indicate that an action should happen for as long as that key is down
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 按下某个键表示应在该键保持按下时执行某个操作
- en: (known as *continuous mode*).
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: （称为 *连续模式*）。
- en: '**Recognizing Individual Key Presses**'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '**识别单个按键按下**'
- en: 'Like the mouse clicks, each key press generates two events: key down and key'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 像鼠标点击一样，每次按下一个键都会生成两个事件：按键按下和按键抬起
- en: 'up. The two events have different event types: pygame.KEYDOWN and pygame.KEYUP.'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 向上。两个事件有不同的事件类型：pygame.KEYDOWN 和 pygame.KEYUP。
- en: Listing 5-4 shows a small sample program that allows the user to move
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-4 展示了一个小示例程序，允许用户移动
- en: the ball image in the window using the keyboard. The program also shows
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 使用键盘在窗口中显示小球的图像。程序还显示了
- en: a target rectangle in the window. The user’s goal is to move the ball image
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口中的目标矩形。用户的目标是移动小球图像
- en: so that it overlaps with the target image.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 使其与目标图像重叠。
- en: '**File: PygameDemo3_MoveByKeyboard/PygameMoveByKeyboardOncePerKey.py**'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PygameDemo3_MoveByKeyboard/PygameMoveByKeyboardOncePerKey.py**'
- en: pygame demo 3(a) - one image, move by keyboard
  id: totrans-743
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pygame 演示 3(a) - 一张图像，通过键盘移动
- en: 1 - Import packages
  id: totrans-744
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 - 导入包
- en: import pygame
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from pygame.locals import *
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: from pygame.locals import *
- en: import sys
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: import random
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: 2 - Define constants
  id: totrans-749
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 - 定义常量
- en: BLACK = (0, 0, 0)
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: BLACK = (0, 0, 0)
- en: WINDOW_WIDTH = 640
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_WIDTH = 640
- en: WINDOW_HEIGHT = 480
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_HEIGHT = 480
- en: FRAMES_PER_SECOND = 30
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: FRAMES_PER_SECOND = 30
- en: BALL_WIDTH_HEIGHT = 100
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: BALL_WIDTH_HEIGHT = 100
- en: MAX_WIDTH = WINDOW_WIDTH - BALL_WIDTH_HEIGHT
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: MAX_WIDTH = WINDOW_WIDTH - BALL_WIDTH_HEIGHT
- en: MAX_HEIGHT = WINDOW_HEIGHT - BALL_WIDTH_HEIGHT
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: MAX_HEIGHT = WINDOW_HEIGHT - BALL_WIDTH_HEIGHT
- en: 1 TARGET_X = 400
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 1 TARGET_X = 400
- en: TARGET_Y = 320
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: TARGET_Y = 320
- en: TARGET_WIDTH_HEIGHT = 120
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: TARGET_WIDTH_HEIGHT = 120
- en: N_PIXELS_TO_MOVE = 3
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: N_PIXELS_TO_MOVE = 3
- en: 3 - Initialize the world
  id: totrans-761
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 - 初始化世界
- en: pygame.init()
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.init()
- en: Introduction to Pygame **105**
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame 简介 **105**
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
- en: clock = pygame.time.Clock()
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: clock = pygame.time.Clock()
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-766
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 - 加载资源：图像、声音等
- en: ballImage = pygame.image.load('images/ball.png')
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: ballImage = pygame.image.load('images/ball.png')
- en: 2 targetImage = pygame.image.load('images/target.jpg')
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 2 targetImage = pygame.image.load('images/target.jpg')
- en: 5 - Initialize variables
  id: totrans-769
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 - 初始化变量
- en: ballX = random.randrange(MAX_WIDTH)
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: ballX = random.randrange(MAX_WIDTH)
- en: ballY = random.randrange(MAX_HEIGHT)
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: ballY = random.randrange(MAX_HEIGHT)
- en: targetRect = pygame.Rect(TARGET_X, TARGET_Y, TARGET_WIDTH_HEIGHT, TARGET_
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: targetRect = pygame.Rect(TARGET_X, TARGET_Y, TARGET_WIDTH_HEIGHT, TARGET_
- en: WIDTH_HEIGHT)
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: WIDTH_HEIGHT)
- en: 6 - Loop forever
  id: totrans-774
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 - 永久循环
- en: 'while True:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 7 - Check for and handle events
  id: totrans-776
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 - 检查并处理事件
- en: 'for event in pygame.event.get():'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: Clicked the close button? Quit pygame and end the program
  id: totrans-778
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击了关闭按钮？退出 pygame 并结束程序
- en: 'if event.type == pygame.QUIT:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 'if event.type == pygame.QUIT:'
- en: pygame.quit()
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: See if the user pressed a key
  id: totrans-782
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查用户是否按下了一个键
- en: '3 elif event.type == pygame.KEYDOWN:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '3 elif event.type == pygame.KEYDOWN:'
- en: 'if event.key == pygame.K_LEFT:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 'if event.key == pygame.K_LEFT:'
- en: ballX = ballX - N_PIXELS_TO_MOVE
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: ballX = ballX - N_PIXELS_TO_MOVE
- en: 'elif event.key == pygame.K_RIGHT:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif event.key == pygame.K_RIGHT:'
- en: ballX = ballX + N_PIXELS_TO_MOVE
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: ballX = ballX + N_PIXELS_TO_MOVE
- en: 'elif event.key == pygame.K_UP:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif event.key == pygame.K_UP:'
- en: ballY = ballY - N_PIXELS_TO_MOVE
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: ballY = ballY - N_PIXELS_TO_MOVE
- en: 'elif event.key == pygame.K_DOWN:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif event.key == pygame.K_DOWN:'
- en: ballY = ballY + N_PIXELS_TO_MOVE
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: ballY = ballY + N_PIXELS_TO_MOVE
- en: 8 Do any "per frame" actions
  id: totrans-792
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 执行任何“每帧”操作
- en: Check if the ball is colliding with the target
  id: totrans-793
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查小球是否与目标发生碰撞
- en: 4 ballRect = pygame.Rect(ballX, ballY,
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 4 ballRect = pygame.Rect(ballX, ballY,
- en: BALL_WIDTH_HEIGHT, BALL_WIDTH_HEIGHT)
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: BALL_WIDTH_HEIGHT, BALL_WIDTH_HEIGHT)
- en: '5 if ballRect.colliderect(targetRect):'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: '5 如果 ballRect.colliderect(targetRect):'
- en: print('Ball is touching the target')
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: print('小球正在接触目标')
- en: 9 - Clear the window
  id: totrans-798
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 - 清空窗口
- en: window.fill(BLACK)
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: window.fill(BLACK)
- en: 10 - Draw all window elements
  id: totrans-800
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 - 绘制所有窗口元素
- en: '6 window.blit(targetImage, (TARGET_X, TARGET_Y)) # draw the target'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '6 window.blit(targetImage, (TARGET_X, TARGET_Y)) # 绘制目标'
- en: 'window.blit(ballImage, (ballX, ballY)) # draw the ball'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 'window.blit(ballImage, (ballX, ballY)) # 绘制小球'
- en: 11 - Update the window
  id: totrans-803
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 - 更新窗口
- en: pygame.display.update()
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.update()
- en: 12 - Slow things down a bit
  id: totrans-805
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 - 稍微放慢速度
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 'clock.tick(FRAMES_PER_SECOND) # 让 pygame 等待'
- en: '*Listing 5-4: Detecting and acting on single key presses*'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-4：检测并响应单个按键按下*'
- en: '**106** Chapter 5'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '**106** 第五章'
- en: First we add a few new constants 1 to define the x- and y-coordinates of the
    upper-left corner of the target rectangle and the width and height of
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们添加几个新的常量 1 来定义目标矩形左上角的 x 和 y 坐标，以及目标矩形的宽度和高度
- en: the target. We then load the image of the target rectangle 2\.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 目标。我们接着加载目标矩形的图像 2\。
- en: In the loop where we look for for events, we add a test for a key press
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们寻找事件的循环中，我们添加了一个按键按下的测试
- en: by checking for an event of type pygame.KEYDOWN 3\. If a key down event is
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查事件类型是否为 pygame.KEYDOWN 来检测按键事件 3\。如果是按键按下事件
- en: detected, we look into the event to find out what key was pressed. Each
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检测到按键，我们会查看事件来找出按下了哪个键。每个
- en: key has an associated constant in pygame, so here we check if the user has
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 每个按键在pygame中都有一个关联常量，因此我们检查用户是否
- en: pressed the left, up, down, or right arrow. For each of these keys, we modify
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 按下了左、上、下或右方向键。对于这些键，我们进行修改
- en: the value of the ball’s x- or y-coordinate appropriately by a small number
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 适当调整球的x或y坐标的值，数值较小
- en: of pixels.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 像素的数量。
- en: Next we create a pygame rect object for the ball based on its x- and
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们基于球的x和y坐标创建一个pygame矩形对象
- en: y-coordinates and its height and width 4\. We can check to see if two rect-
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: y坐标及其高度和宽度4。我们可以检查两个矩形是否相交
- en: 'angles overlap with the following call:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 角度重叠的处理调用：
- en: '*<booleanVariable>* = *<rect1>* .colliderect( *<rect2>* ) This call compares
    two rectangles and returns True if they overlap at all'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '*<booleanVariable>* = *<rect1>* .colliderect( *<rect2>* ) 这个调用比较两个矩形，如果它们有任何重叠，则返回True'
- en: or False if they don’t. We compare the ball rectangle with the target rectan-
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 或者如果它们没有重叠，则返回False。我们将球的矩形与目标矩形进行比较
- en: gle 5, and if they overlap, the program prints “Ball is touching the target”
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 角度为5，如果它们重叠，程序会打印“Ball is touching the target”（球与目标接触）
- en: to the shell window.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 输出到命令行窗口。
- en: The last change is where we draw both the target and the ball. The
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '最后的变化是我们绘制目标和球的位置。 '
- en: target is drawn first so that when the two overlap, the ball appears over
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 目标先绘制，这样当两个矩形重叠时，球会出现在目标上方
- en: the target 6\.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 目标6\。
- en: When the program is run, if the rectangle of the ball overlaps the rect-
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，如果球的矩形与目标的矩形重叠
- en: angle of the target, the message is written to the shell window. If you move
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 目标的角度，消息会写入到命令行窗口。如果你移动
- en: the ball away from the target, the message stops being written out.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 如果球与目标的矩形不再重叠，消息停止输出。
- en: '**Dealing with Repeating Keys in Continuous Mode**'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '**处理连续模式中的重复键**'
- en: The second way to handle keyboard interactions in pygame is to *poll* the
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 处理键盘交互的第二种方式是*轮询*键盘
- en: keyboard. This involves asking pygame for a list representing which keys
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘。这涉及到询问pygame获取一个表示哪些键被按下的列表
- en: 'are currently down in every frame using the following call:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 当前每帧按下的键使用以下调用：
- en: '*<aTuple>* = pygame.key.get_pressed()'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '*<aTuple>* = pygame.key.get_pressed()'
- en: 'This call returns a tuple of 0s and 1s representing the state of each key:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用返回一个由0和1组成的元组，表示每个键的状态：
- en: 0 if the key is up, 1 if the key is down. You can then use constants defined
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按键处于松开状态则为0，按下状态为1。然后可以使用已定义的常量
- en: within pygame as an index into the returned tuple to see if a *particular* key
    is down. For example, the following lines can be used to determine the
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 在pygame中作为返回元组的索引，查看特定的按键是否被按下。例如，以下几行可以用来判断
- en: 'state of the A key:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: A键的状态：
- en: keyPressedTuple = pygame.key.get_pressed()
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: keyPressedTuple = pygame.key.get_pressed()
- en: Now use a constant to get the appropriate element of the tuple
  id: totrans-841
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在使用常量来获取元组中适当的元素
- en: aIsDown = keyPressedTuple[pygame.K_a]
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: aIsDown = keyPressedTuple[pygame.K_a]
- en: The full listing of constants representing all keys defined in pygame
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: pygame中定义的所有按键常量的完整列表
- en: can be found a[t *https://www.pygame.org/docs/ref/key.html*.](https://www.pygame.org/docs/ref/key.html)
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[a](https://www.pygame.org/docs/ref/key.html)找到。
- en: Introduction to Pygame **107**
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame介绍 **107**
- en: The code in Listing 5-5 shows how we can use this technique to move an image
    continuously rather than once per key press. In this version, we
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5-5中的代码展示了如何使用这种技巧来连续移动图像，而不是每次按下键时只移动一次。在这个版本中，我们
- en: 'move the keyboard handling from section #7 to section #8\. The rest of the'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 将键盘处理从第7节移到第8节。其余部分的
- en: code is identical to the previous version in Listing 5-4\.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与列表5-4中的前一个版本完全相同。
- en: '**File: PygameDemo3_MoveByKeyboard/PygameMoveByKeyboardContinuous.py**'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PygameDemo3_MoveByKeyboard/PygameMoveByKeyboardContinuous.py**'
- en: pygame demo 3(b) - one image, continuous mode, move as long as a key is down
  id: totrans-850
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pygame演示3(b) - 一张图像，连续模式下，键按住时持续移动
- en: '--- snip ---'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 截断 ---'
- en: 7 - Check for and handle events
  id: totrans-852
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 - 检查并处理事件
- en: 'for event in pygame.event.get():'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: Clicked the close button? Quit pygame and end the program
  id: totrans-854
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击了关闭按钮？退出pygame并结束程序
- en: 'if event.type == pygame.QUIT:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 event.type == pygame.QUIT:'
- en: pygame.quit()
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: 8 - Do any "per frame" actions
  id: totrans-858
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 - 执行每帧动作
- en: Check for user pressing keys
  id: totrans-859
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查用户是否按下了键
- en: 1 keyPressedTuple = pygame.key.get_pressed()
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 1 keyPressedTuple = pygame.key.get_pressed()
- en: 'if keyPressedTuple[pygame.K_LEFT]: # moving left'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 keyPressedTuple[pygame.K_LEFT]: # 向左移动'
- en: ballX = ballX - N_PIXELS_TO_MOVE
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: ballX = ballX - N_PIXELS_TO_MOVE
- en: 'if keyPressedTuple[pygame.K_RIGHT]: # moving right'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 keyPressedTuple[pygame.K_RIGHT]: # 向右移动'
- en: ballX = ballX + N_PIXELS_TO_MOVE
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: ballX = ballX + N_PIXELS_TO_MOVE
- en: 'if keyPressedTuple[pygame.K_UP]: # moving up'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 keyPressedTuple[pygame.K_UP]: # 向上移动'
- en: ballY = ballY - N_PIXELS_TO_MOVE
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: ballY = ballY - N_PIXELS_TO_MOVE
- en: 'if keyPressedTuple[pygame.K_DOWN]: # moving down'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 keyPressedTuple[pygame.K_DOWN]: # 向下移动'
- en: ballY = ballY + N_PIXELS_TO_MOVE
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: ballY = ballY + N_PIXELS_TO_MOVE
- en: Check if the ball is colliding with the target
  id: totrans-869
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查球是否与目标发生碰撞
- en: ballRect = pygame.Rect(ballX, ballY,
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: ballRect = pygame.Rect(ballX, ballY,
- en: BALL_WIDTH_HEIGHT, BALL_WIDTH_HEIGHT)
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: BALL_WIDTH_HEIGHT, BALL_WIDTH_HEIGHT)
- en: 'if ballRect.colliderect(targetRect):'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 ballRect.colliderect(targetRect):'
- en: print('Ball is touching the target')
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: print('球正在触碰目标')
- en: '--- snip ---'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 省略 ---'
- en: '*Listing 5-5: Handling keys being held down*'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-5：处理按住的按键*'
- en: The keyboard-handling code in Listing 5-5 does not rely on events,
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-5 中的键盘处理代码不依赖于事件，
- en: so we place the new code outside of the for loop that iterates through all
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们将新代码放在循环外面，循环会遍历所有
- en: events returned by pygame 1\.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 由 pygame 返回的事件 1\。
- en: Because we are doing this check in every frame, the movement of the
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在每一帧都在做这个检查，所以
- en: ball will appear to be continuous as long as the user holds down a key. For
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 只要用户按住一个键，球就会持续出现。对于
- en: example, if the user presses and holds the right arrow key, this code will
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果用户按下并保持右箭头键，该代码将
- en: add 3 to the value of the ballX coordinate in every frame, and the user will
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧中将 3 加到 ballX 坐标的值，用户将看到
- en: see the ball moving smoothly to the right. When they stop pressing the key,
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 看到球平滑地向右移动。当他们停止按下键时，
- en: the movement stops.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 当运动停止时。
- en: '**108** Chapter 5'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '**108** 第五章'
- en: The other change is that this approach allows you to check for multiple keys
    being down at the same time. For example, if the user presses and holds
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个变化是这种方法允许你同时检测多个按键被按下。例如，如果用户按下并保持
- en: the left and down arrow keys, the ball will move diagonally down and to the
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 左箭头和下箭头键被按下时，球会沿对角线向下左移。
- en: left. You can check for as many keys being held down as you wish. However,
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 向左。你可以检查任意数量的键是否被按下。然而，
- en: the number of *simultaneous* key presses that can be detected is limited by
    the operating system, the keyboard hardware, and many other factors. The
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统、键盘硬件以及许多其他因素限制了可以同时检测到的键盘按键数。
- en: typical limit is around four keys, but your mileage may vary.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 一般限制大约是四个按键，但实际情况可能有所不同。
- en: '***Creating a Location-Based Animation***'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '***创建基于位置的动画***'
- en: Next, we’ll build a location-based animation. This code will allow us to
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建一个基于位置的动画。此代码将允许我们
- en: move an image diagonally and then have it appear to bounce off the edges
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像对角线移动，然后让它看起来从边缘弹回
- en: of the window. This was a favorite technique of screensavers on old CRT-
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的左边缘。这是老式 CRT 屏幕保护程序中的常见技巧之一。
- en: based monitors, to avoid burning in a static image.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 基于显示器，以避免图像烧录成静态图像。
- en: We’ll change the location of our image slightly in every frame. We’ll
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在每一帧中稍微改变图像的位置。我们将
- en: also check if the result of that movement would place any part of the image
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 还要检查该运动的结果是否会将图像的某部分放置到
- en: outside one of the window boundaries and, if so, reverse the movement in
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 检查球是否已超出窗口边界，如果是，反转运动方向
- en: that direction. For example, if the image was moving down and would cross
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 那个方向。例如，如果图像正在向下移动并会越过
- en: the bottom of the window, we would reverse the direction and make the
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 如果球碰到窗口底部，我们将反转方向并让球
- en: image start moving up.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 图像开始向上移动。
- en: We’ll again use the same starting template. Listing 5-6 gives the full
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用相同的起始模板。列表 5-6 给出了完整的代码。
- en: source code.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码
- en: '**File: PygameDemo4_OneBal Bounce/PygameOneBal BounceXY.py**'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PygameDemo4_OneBal Bounce/PygameOneBal BounceXY.py**'
- en: pygame demo 4(a) - one image, bounce around the window using (x, y) coords
  id: totrans-905
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pygame 演示 4(a) - 一张图像，使用 (x, y) 坐标在窗口内弹跳
- en: 1 - Import packages
  id: totrans-906
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 - 导入包
- en: import pygame
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 pygame
- en: from pygame.locals import *
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 从 pygame.locals 导入 *
- en: import sys
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 sys
- en: import random
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 random
- en: 2 - Define constants
  id: totrans-911
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 - 定义常量
- en: BLACK = (0, 0, 0)
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: BLACK = (0, 0, 0)
- en: WINDOW_WIDTH = 640
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_WIDTH = 640
- en: WINDOW_HEIGHT = 480
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_HEIGHT = 480
- en: FRAMES_PER_SECOND = 30
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: FRAMES_PER_SECOND = 30
- en: BALL_WIDTH_HEIGHT = 100
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: BALL_WIDTH_HEIGHT = 100
- en: N_PIXELS_PER_FRAME = 3
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: N_PIXELS_PER_FRAME = 3
- en: 3 - Initialize the world
  id: totrans-918
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 - 初始化世界
- en: pygame.init()
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.init()
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
- en: clock = pygame.time.Clock()
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: clock = pygame.time.Clock()
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-922
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 - 加载资源：图像、声音等
- en: ballImage = pygame.image.load('images/ball.png')
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: ballImage = pygame.image.load('images/ball.png')
- en: 5 - Initialize variables
  id: totrans-924
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 - 初始化变量
- en: Introduction to Pygame **109**
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame 介绍 **109**
- en: MAX_WIDTH = WINDOW_WIDTH - BALL_WIDTH_HEIGHT
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: MAX_WIDTH = WINDOW_WIDTH - BALL_WIDTH_HEIGHT
- en: MAX_HEIGHT = WINDOW_HEIGHT - BALL_WIDTH_HEIGHT
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: MAX_HEIGHT = WINDOW_HEIGHT - BALL_WIDTH_HEIGHT
- en: 1 ballX = random.randrange(MAX_WIDTH)
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 1 ballX = random.randrange(MAX_WIDTH)
- en: ballY = random.randrange(MAX_HEIGHT)
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: ballY = random.randrange(MAX_HEIGHT)
- en: xSpeed = N_PIXELS_PER_FRAME
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: xSpeed = N_PIXELS_PER_FRAME
- en: ySpeed = N_PIXELS_PER_FRAME
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: ySpeed = N_PIXELS_PER_FRAME
- en: 6 - Loop forever
  id: totrans-932
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 - 无限循环
- en: 'while True:'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 7 - Check for and handle events
  id: totrans-934
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 - 检查并处理事件
- en: 'for event in pygame.event.get():'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 对 pygame.event.get() 中的每个事件进行循环：
- en: Clicked the close button? Quit pygame and end the program
  id: totrans-936
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击了关闭按钮？退出 pygame 并结束程序
- en: 'if event.type == pygame.QUIT:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 event.type == pygame.QUIT:'
- en: pygame.quit()
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: 8 - Do any "per frame" actions
  id: totrans-940
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 - 执行任何“每帧”操作
- en: '2 if (ballX < 0) or (ballX >= MAX_WIDTH):'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: '2 如果 (ballX < 0) 或 (ballX >= MAX_WIDTH):'
- en: 'xSpeed = -xSpeed # reverse X direction'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 'xSpeed = -xSpeed # 反转X方向'
- en: 'if (ballY < 0) or (ballY >= MAX_HEIGHT):'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 (ballY < 0) 或 (ballY >= MAX_HEIGHT):'
- en: 'ySpeed = -ySpeed # reverse Y direction'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 'ySpeed = -ySpeed # 反转 Y 方向'
- en: Update the ball's location, using the speed in two directions
  id: totrans-945
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新球的位置，使用两个方向的速度
- en: 3 ballX = ballX + xSpeed
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 3 ballX = ballX + xSpeed
- en: ballY = ballY + ySpeed
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: ballY = ballY + ySpeed
- en: 9 - Clear the window before drawing it again
  id: totrans-948
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 - 在重新绘制之前清空窗口
- en: window.fill(BLACK)
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: window.fill(BLACK)
- en: 10 - Draw the window elements
  id: totrans-950
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 - 绘制窗口元素
- en: window.blit(ballImage, (ballX, ballY))
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: window.blit(ballImage, (ballX, ballY))
- en: 11 - Update the window
  id: totrans-952
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 - 更新窗口
- en: pygame.display.update()
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.update()
- en: 12 - Slow things down a bit
  id: totrans-954
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 - 稍微减缓速度
- en: clock.tick(FRAMES_PER_SECOND)
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: clock.tick(FRAMES_PER_SECOND)
- en: '*Listing 5-6: A location-based animation, bouncing a ball around the window*'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出 5-6：基于位置的动画，球在窗口中反弹*'
- en: We start by creating and initializing the two variables xSpeed and ySpeed 1,
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从创建并初始化两个变量 xSpeed 和 ySpeed 开始 1，
- en: which determine how far and in what direction the image should move in
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 这些决定了图像应该在两个方向上移动多远和朝哪个方向
- en: each frame. We initialize both variables to the number of pixels to move per
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 每一帧。我们将两个变量初始化为每帧移动的像素数
- en: frame (3), so the image will start by moving three pixels to the right (the
    posi-
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 每帧（3），所以图像将首先向右移动三像素（正的 x 方向）
- en: tive x direction) and three pixels down (the positive y direction).
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 在 X 方向上移动三像素（正的 x 方向）并且向下三像素（正的 y 方向）。
- en: In the key part of the program, we handle the x- and y-coordinates
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的关键部分，我们处理 x 和 y 坐标
- en: separately 2\. First, we check to see if the x-coordinate of the ball is less
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 分开处理 2。首先，我们检查球的 x 坐标是否小于
- en: than zero, meaning that part of the image is off the left edge, or past the
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 小于零，意味着图像的某部分已越过左边缘，或者超出了
- en: MAX_WIDTH pixel and so effectively off the right edge. If either of these is
    the
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: MAX_WIDTH 像素，实际上是从右边缘离开。如果其中任何一个条件成立，
- en: case, we reverse the sign of the speed in the x direction, meaning it will go
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这种情况，我们将反转 x 方向速度的符号，意味着它将朝
- en: in the opposite direction. For example, if the ball was moving to the right
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 向相反的方向移动。例如，如果球向右移动
- en: '**110** Chapter 5'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '**110** 第五章'
- en: and went off the right edge, we would change the value of xSpeed from 3 to
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 并且越过右边缘，我们会将 xSpeed 的值从 3 改为
- en: –3 to cause the ball to start moving to the left, and vice versa.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: -3 使球开始向左移动，反之亦然。
- en: Then we do a similar check for the y-coordinate to make the ball
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们对 y 坐标进行类似的检查，使球
- en: bounce off the top or bottom edge, as needed.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要从顶部或底部边缘反弹。
- en: Finally, we update the position of the ball by adding the xSpeed to the
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过将 xSpeed 添加到
- en: ballX coordinate and adding the ySpeed to the ballY coordinate 3\. This posi-
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: ballX 坐标并将 ySpeed 添加到 ballY 坐标 3。此位置
- en: tions the ball at a new location on both axes.
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 将球的位置在两个轴上重新定位。
- en: At the bottom of the main loop, we draw the ball. Since we’re updat-
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环的底部，我们绘制球。由于我们在更新
- en: ing the values of ballX and ballY in every frame, the ball appears to ani-
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更新 ballX 和 ballY 的值，每一帧，球似乎在动。
- en: mate smoothly. Try it out. Whenever the ball reaches any edge, it seems to
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 平滑地配合。试试看。每当球碰到任何一个边缘时，它似乎
- en: bounce off.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 反弹。
- en: '***Using Pygame rects***'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '***使用 Pygame rects***'
- en: Next I’ll present a different way to achieve the same result. Rather than
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我将展示一种不同的方法来实现相同的结果。与其
- en: keeping track of the current x- and y-coordinates of the ball in separate
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 分别跟踪球的当前 x 和 y 坐标
- en: variables, we’ll use the rect of the ball, update the rect every frame, and
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用球的 rect 来跟踪变量，每一帧更新 rect，
- en: check if performing the update would cause any part of the rect to move
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 检查执行更新是否会导致矩形的任何部分移动
- en: outside an edge of the window. This results in fewer variables, and because
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 超出窗口边缘。这会减少变量的数量，并且因为
- en: we’ll start by making a call to get the rect of an image, it will work with
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将首先调用获取图像的 rect，它将直接与这些属性一起使用  '
- en: images of any size.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: '任意大小的图像。  '
- en: When you create a rect object, in addition to remembering the left, top,
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '当你创建一个 rect 对象时，除了记住左边、顶部，  '
- en: width, and height as attributes of the rectangle, that object also calculates
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '它的宽度和高度作为矩形的属性，这个对象还会计算  '
- en: and maintains a number of other attributes for you. You can access any of
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: '并为你维护许多其他属性。你可以通过：  '
- en: these attributes directly by name using *dot syntax*, as shown in Table 5-1\.
    (I’ll provide more detail on this i[n Chapter 8.)](index_split_003.html#p192)
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '这些属性可以通过 *点语法* 直接按名称访问，如表 5-1 所示。（我将在第 8 章提供更多细节）  '
- en: '**Table 5-1:** Direct Access to Attributes of a rect'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-1：** 直接访问 rect 属性  '
- en: '**Attribute**'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: '**属性**  '
- en: '**Description**'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: '**描述**  '
- en: '*<rect>* .x'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .x  '
- en: The x-coordinate of the left edge of the rect
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 'rect 左边缘的 x 坐标  '
- en: '*<rect>* .y'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .y  '
- en: The y-coordinate of the top edge of the rect
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 'rect 顶边的 y 坐标  '
- en: '*<rect>* .left'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .left  '
- en: The x-coordinate of the left edge of the rect (same as
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 'rect 左边缘的 x 坐标（与  '
- en: '*<rect>* .x)'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .x)  '
- en: '*<rect>* .top'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .top  '
- en: The y-coordinate of the top edge of the rect (same as
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 'rect 顶边的 y 坐标（与  '
- en: '*<rect>* .y)'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .y)  '
- en: '*<rect>* .right'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .right  '
- en: The x-coordinate of the right edge of the rect
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 'rect 右边缘的 x 坐标  '
- en: '*<rect>* .bottom'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .bottom  '
- en: The y-coordinate of the bottom edge of the rect
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 'rect 底边的 y 坐标  '
- en: '*<rect>* .topleft'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .topleft  '
- en: 'A two-integer tuple: the coordinates of the upper-left corner of'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: '一个包含两个整数的元组：左上角的坐标  '
- en: the rect
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 'rect  '
- en: '*<rect>* .bottomleft'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .bottomleft 相同）  '
- en: 'A two-integer tuple: the coordinates of the lower-left corner of'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: '一个包含两个整数的元组：左下角的坐标  '
- en: the rect
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 'rect  '
- en: '*<rect>* .topright'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .topright  '
- en: 'A two-integer tuple: the coordinates of the upper-right corner of'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: '一个包含两个整数的元组：右上角的坐标  '
- en: the rect
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 'rect  '
- en: '*<rect>* .bottomright'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .bottomright  '
- en: 'A two-integer tuple: the coordinates of the lower-right corner of'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: '一个包含两个整数的元组：右下角的坐标  '
- en: the rect
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 'rect  '
- en: '*(continued)*'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '*(继续)*  '
- en: Introduction to Pygame **111**
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 'Pygame 介绍 **111**  '
- en: '**Table 5-1:** Direct Access to Attributes of a rect *(continued)* **Attribute**'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-1：** 直接访问 rect 属性 *(继续)* **属性**  '
- en: '**Description**'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: '**描述**  '
- en: '*<rect>* .midtop'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .midtop  '
- en: 'A two-integer tuple: the coordinates of the midpoint of the top'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: '一个包含两个整数的元组：顶部中点的坐标  '
- en: edge of the rect
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 'rect 边缘的坐标  '
- en: '*<rect>* .midleft'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .midleft  '
- en: 'A two-integer tuple: the coordinates of the midpoint of the left'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: '一个包含两个整数的元组：左侧中点的坐标  '
- en: edge of the rect
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 'rect 边缘的坐标  '
- en: '*<rect>* .midbottom'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .midbottom  '
- en: 'A two-integer tuple: the coordinates of the midpoint of the bot-'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: '一个包含两个整数的元组：底部中点的坐标  '
- en: tom edge of the rect
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: rect 底边的坐标
- en: '*<rect>* .midright'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .midright  '
- en: 'A two-integer tuple: the coordinates of the midpoint of the right'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: '一个包含两个整数的元组：右下角中点的坐标  '
- en: edge of the rect
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 'rect 边缘的 x 坐标相同）  '
- en: '*<rect>* .center'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .center  '
- en: 'A two-integer tuple: the coordinates at the center of the rect'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: '一个包含两个整数的元组：rect 中心的坐标  '
- en: '*<rect>* .centerx'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .centerx  '
- en: The x-coordinate of the center of the width of the rect
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 'rect 宽度中心的 x 坐标  '
- en: '*<rect>* .centery'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .centery  '
- en: The y-coordinate of the center of the height of the rect
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 'rect 高度中心的 y 坐标  '
- en: '*<rect>* .size'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .size  '
- en: 'A two-integer tuple: the (width, height) of the rect'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: '一个包含两个整数的元组：（宽度，高度）  '
- en: '*<rect>* .width'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .width  '
- en: The width of the rect
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 'rect 的宽度  '
- en: '*<rect>* .height'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .height  '
- en: The height of the rect
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 'rect 的高度  '
- en: '*<rect>* .w'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .w  '
- en: The width of the rect (same as *<rect>* .width)
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 'rect 的宽度（与 *<rect>* .width 相同）  '
- en: '*<rect>* .h'
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: '*<rect>* .h  '
- en: The height of the rect (same as *<rect>* .height)
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 'rect 的高度（与 *<rect>* .height 相同）  '
- en: A pygame rect also can be thought of, and accessed as, a list of four ele-
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 'pygame 的 rect 也可以看作并访问为一个包含四个元素的列表  '
- en: ments. Specifically, you can use an index to get or set any individual part
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: '元素。具体来说，你可以使用索引来获取或设置 rect 的任何部分  '
- en: of a rect. For instance, using the ballRect, the individual elements can be
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，使用 ballRect，可以访问单独的元素  '
- en: 'accessed as:'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: '访问这些属性  '
- en: • ballRect[0] is the x value (but you could also use ballRect.left)
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: '• ballRect[0] 是 x 值（但你也可以使用 ballRect.left）  '
- en: • ballRect[1] is the y value (but you could also use ballRect.top)
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: '• ballRect[1] 是 y 值（但你也可以使用 ballRect.top）  '
- en: • ballRect[2] is the width (but you could also use ballRect.width)
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: '• ballRect[2] 是宽度（但你也可以使用 ballRect.width）  '
- en: • ballRect[3] is the height (but you could also use ballRect.height)
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '• ballRect[3] 是高度（但你也可以使用 ballRect.height）  '
- en: Listing 5-7 is an alternative version of our bouncing ball program that
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 5-7 是我们的反弹球程序的另一个版本  '
- en: maintains all the information about the ball in a rectangle object.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 将关于球的信息保存在矩形对象中。
- en: '**File: PygameDemo4_OneBal Bounce/PygameOneBal BounceRects.py**'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件: PygameDemo4_OneBal Bounce/PygameOneBal BounceRects.py**'
- en: pygame demo 4(b) - one image, bounce around the window using rects
  id: totrans-1064
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pygame演示4(b) - 一个图像，使用矩形在窗口中反弹
- en: 1 - Import packages
  id: totrans-1065
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 - 导入包
- en: import pygame
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from pygame.locals import *
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: from pygame.locals import *
- en: import sys
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: import random
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: 2 - Define constants
  id: totrans-1070
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 - 定义常量
- en: BLACK = (0, 0, 0)
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: BLACK = (0, 0, 0)
- en: WINDOW_WIDTH = 640
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_WIDTH = 640
- en: WINDOW_HEIGHT = 480
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_HEIGHT = 480
- en: '**112** Chapter 5'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: '**112** 第五章'
- en: FRAMES_PER_SECOND = 30
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: FRAMES_PER_SECOND = 30
- en: N_PIXELS_PER_FRAME = 3
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: N_PIXELS_PER_FRAME = 3
- en: 3 - Initialize the world
  id: totrans-1077
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 - 初始化世界
- en: pygame.init()
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.init()
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
- en: clock = pygame.time.Clock()
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: clock = pygame.time.Clock()
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-1081
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 - 加载资源：图像、声音等
- en: ballImage = pygame.image.load('images/ball.png')
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: ballImage = pygame.image.load('images/ball.png')
- en: 5 - Initialize variables
  id: totrans-1083
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 - 初始化变量
- en: 1 ballRect = ballImage.get_rect()
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 1 ballRect = ballImage.get_rect()
- en: MAX_WIDTH = WINDOW_WIDTH - ballRect.width
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: MAX_WIDTH = WINDOW_WIDTH - ballRect.width
- en: MAX_HEIGHT = WINDOW_HEIGHT - ballRect.height
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: MAX_HEIGHT = WINDOW_HEIGHT - ballRect.height
- en: ballRect.left = random.randrange(MAX_WIDTH)
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: ballRect.left = random.randrange(MAX_WIDTH)
- en: ballRect.top = random.randrange(MAX_HEIGHT)
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: ballRect.top = random.randrange(MAX_HEIGHT)
- en: xSpeed = N_PIXELS_PER_FRAME
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: xSpeed = N_PIXELS_PER_FRAME
- en: ySpeed = N_PIXELS_PER_FRAME
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: ySpeed = N_PIXELS_PER_FRAME
- en: 6 - Loop forever
  id: totrans-1091
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 - 无限循环
- en: 'while True:'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 7 - Check for and handle events
  id: totrans-1093
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 - 检查并处理事件
- en: 'for event in pygame.event.get():'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: Clicked the close button? Quit pygame and end the program
  id: totrans-1095
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击关闭按钮？退出pygame并结束程序
- en: 'if event.type == pygame.QUIT:'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 'if event.type == pygame.QUIT:'
- en: pygame.quit()
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: 8 - Do any "per frame" actions
  id: totrans-1099
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 - 执行每帧的操作
- en: '2 if (ballRect.left < 0) or (ballRect.right >= WINDOW_WIDTH):'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: '2 if (ballRect.left < 0) or (ballRect.right >= WINDOW_WIDTH):'
- en: 'xSpeed = -xSpeed # reverse X direction'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 'xSpeed = -xSpeed # 反转X方向'
- en: 'if (ballRect.top < 0) or (ballRect.bottom >= WINDOW_HEIGHT):'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 'if (ballRect.top < 0) or (ballRect.bottom >= WINDOW_HEIGHT):'
- en: 'ySpeed = -ySpeed # reverse Y direction'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 'ySpeed = -ySpeed # 反转Y方向'
- en: Update the ball's rectangle using the speed in two directions
  id: totrans-1104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新球的矩形，使用两个方向的速度
- en: ballRect.left = ballRect.left + xSpeed
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: ballRect.left = ballRect.left + xSpeed
- en: ballRect.top = ballRect.top + ySpeed
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: ballRect.top = ballRect.top + ySpeed
- en: 9 - Clear the window before drawing it again
  id: totrans-1107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 - 在重新绘制之前清除窗口
- en: window.fill(BLACK)
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: window.fill(BLACK)
- en: 10 - Draw the window elements
  id: totrans-1109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 - 绘制窗口元素
- en: 3 window.blit(ballImage, ballRect)
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 3 window.blit(ballImage, ballRect)
- en: 11 - Update the window
  id: totrans-1111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 - 更新窗口
- en: pygame.display.update()
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.update()
- en: 12 - Slow things down a bit
  id: totrans-1113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 - 稍微减慢速度
- en: clock.tick(FRAMES_PER_SECOND)
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: clock.tick(FRAMES_PER_SECOND)
- en: '*Listing 5-7: A location-based animation, bouncing a ball around the window,
    using rects* Introduction to Pygame **113**'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-7: 基于位置的动画，使用矩形让球在窗口中反弹* Pygame简介 **113**'
- en: This approach of using a rect object is neither better nor worse than using
    separate variables. The resulting program works exactly the same as
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用矩形对象的方法既不比使用独立变量更好，也不更差。结果程序的工作方式完全相同
- en: the original. The important lesson here is how you can use and manipulate
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 原始代码。这里的重要教训是你如何使用和操作
- en: attributes of a rect object.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形对象的属性。
- en: After loading the image of the ball, we call the get_rect() method 1
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 加载完球的图像后，我们调用get_rect()方法 1
- en: to get the bounding rectangle of the image. That call returns a rect object,
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 获取图像的边界矩形。这个调用返回一个矩形对象，
- en: which we store into a variable called ballRect. We use ballRect.width and
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其存储到名为ballRect的变量中。我们使用ballRect.width和
- en: ballRect.height to get direct access to the width and height of the ball image.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: ballRect.height 直接访问球图像的宽度和高度。
- en: (In the previous version, we used a constant of 100 for the width and the
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: （在之前的版本中，我们使用了一个常量100作为宽度和
- en: height.) Getting these values from the image that was loaded makes our code
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: height.) 从加载的图像中获取这些值使我们的代码更加简洁
- en: much more adaptable because it means we can use a graphic of any size.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做更加灵活，因为意味着我们可以使用任何大小的图像。
- en: The code also uses the attributes of the rectangle rather than using
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码还使用矩形的属性，而不是使用
- en: separate variables for checking if any part of the ball’s rectangle goes over
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 用于检查球的矩形是否超出任何部分的独立变量
- en: an edge. We can use ballRect.left and ballRect.right to see if the ballRect
    is
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果球矩形超出了边界，我们可以使用ballRect.left和ballRect.right来判断
- en: off the left or right edges 2\. We do a similar test with ballRect.top and ball-
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 从左侧或右侧边缘掉出 2。我们使用ballRect.top和ballRect-
- en: Rect.bottom. Rather than updating individual x- and y-coordinate variables,
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: we update the left and top of the ballRect.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
- en: The other subtle but important change is in the call to draw the ball 3\.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
- en: The second argument in the call to blit() can be either an (x, y) tuple or a
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: rect. The code inside blit() uses the left and top position in the rect as the
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
- en: x- and y-coordinates.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
- en: '**Playing Sounds**'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of sounds that you might want to play in your pro-
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
- en: 'grams: short sound effects and background music.'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: '***Playing Sound Effects***'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: All sound effects must live in external files and must be in either *.wav* or
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
- en: '*.ogg* format. Playing a relatively short sound effect consists of two steps:
    load the sound from an external sound file once; then at the appropriate time(s)'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: play your sound.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: 'To load a sound effect into memory, you use a line like this:'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
- en: '*<soundVariable>* = pygame.mixer.Sound( *<path to sound file>* ) To play the
    sound effect, you only need to call its play() method:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: '*<soundVariable>* .play()'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
- en: We’ll modify Listing 5-7 to add a “boing” sound effect whenever the
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: ball bounces off a side of the window. There is a *sounds* folder in the project
    folder at the same level as the main program. Right after loading the ball
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: 'image, we load the sound file by adding this code:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-1149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ballImage = pygame.image.load('images/ball.png')
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: bounceSound = pygame.mixer.Sound('sounds/boing.wav')
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: '**114** Chapter 5'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
- en: 'To play the “boing” sound effect whenever we change either the horizontal or
    vertical direction of the ball, we modify section #8 to look like this:'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  id: totrans-1154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if (ballRect.left < 0) or (ballRect.right >= WINDOW_WIDTH):'
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: 'xSpeed = -xSpeed # reverse X direction'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
- en: bounceSound.play()
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: 'if (ballRect.top < 0) or (ballRect.bottom >= WINDOW_HEIGHT):'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
- en: 'ySpeed = -ySpeed # reverse Y direction'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
- en: bounceSound.play()
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: When you find a condition that should play a sound effect, you add a
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
- en: call to the play() method of the sound. There are many more options for
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: controlling sound effects; you can find details in the official documentation
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: at [*https://www.pygame.org/docs/ref/mixer.html*](https://www.pygame.org/docs/ref/mixer.html).
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
- en: '***Playing Background Music***'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: Playing background music involves two lines of code using calls to the
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: pygame.mixer.music module. First, you need this to load the sound file into
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
- en: 'memory:'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: pygame.mixer.music.load( *<path to sound file>* )
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
- en: 'The *<path to sound file>* is a path string where the sound file can be found.
    You can use *.mp3* files, which seem to work best, as well as *.wav* or *.ogg*
    files. When you want to start the music playing, you need to make this call:'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: pygame.mixer.music.play( *<number of loops>* , *<starting position>* ) To play
    some background music repeatedly, you can pass in a -1 for
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: '*<number of loops>* to run the music forever. The *<starting position>* is
    typically set to 0 to indicate that you want to play the sound from the beginning.'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
- en: There is a downloadable, modified version of the bouncing ball pro-
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个可下载的修改版弹跳球程序
- en: gram that properly loads the sound effect and background music files and
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 程序正确加载音效和背景音乐文件并
- en: 'starts the background sound playing. The only changes are in section #4, as'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 启动背景音效播放。唯一的更改是在第4节，
- en: shown here.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 如此处所示。
- en: '**File: PygameDemo4_OneBal Bounce/PyGameOneBal BounceWithSound.py**'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PygameDemo4_OneBal Bounce/PyGameOneBal BounceWithSound.py**'
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-1178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 - 加载资源：图像、声音等
- en: ballImage = pygame.image.load('images/ball.png')
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: ballImage = pygame.image.load('images/ball.png')
- en: bounceSound = pygame.mixer.Sound('sounds/boing.wav')
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: bounceSound = pygame.mixer.Sound('sounds/boing.wav')
- en: pygame.mixer.music.load('sounds/background.mp3')
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.mixer.music.load('sounds/background.mp3')
- en: pygame.mixer.music.play(-1, 0.0)
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.mixer.music.play(-1, 0.0)
- en: Pygame allows for much more intricate handling of background
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame允许更加精细的背景处理
- en: sounds. You can find the full documentation a[t *https://www.pygame.org/docs/*](https://www.pygame.org/docs/ref/music.html#module-pygame.mixer.music)
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 声音。你可以在[a*tps://www.pygame.org/docs/*](https://www.pygame.org/docs/ref/music.html#module-pygame.mixer.music)找到完整的文档
- en: '[*ref/music.html#module-pygame.mixer.music*](https://www.pygame.org/docs/ref/music.html#module-pygame.mixer.music).'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: '[*ref/music.html#module-pygame.mixer.music*](https://www.pygame.org/docs/ref/music.html#module-pygame.mixer.music).'
- en: Introduction to Pygame **115**
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame简介 **115**
- en: '**N O T E**'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: '**注释**'
- en: '*In order to make future examples more clearly focused on OOP, I’ll leave out
    calls to* *play sound effects and background music. But adding sounds greatly
    enhances the* *user experience of a game, and I strongly encourage including them.*'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了使未来的示例更加专注于面向对象编程，我将省略播放音效和背景音乐的调用。* *但是添加声音会大大增强游戏的* *用户体验，我强烈建议加入它们。*'
- en: '**Drawing Shapes**'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: '**绘制形状**'
- en: Pygame offers a number of built-in functions that allow you to draw certain
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame 提供了多个内建函数，可以用来绘制某些
- en: shapes known as *primitives*, which include lines, circles, ellipses, arcs,
    polygons, and rectangles. Table 5-2 provides a list of these functions. Note that
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 形状被称为*原始形状*，包括线条、圆形、椭圆、弧形、多边形和矩形。表 5-2 列出了这些函数。请注意
- en: there are two calls that draw *anti-aliased* lines. These are lines that include
    blended colors at the edges to make the lines look smooth and less jagged.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个调用用于绘制*抗锯齿*线条。这些线条的边缘包含了混合颜色，使得线条看起来平滑，减少了锯齿感。
- en: 'There are two key advantages to using these drawing functions: they exe-'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些绘图函数有两个关键优点：它们执行
- en: cute extremely quickly, and they allow you to draw simple shapes without
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 可爱得极快，而且它们允许你无需
- en: having to create or load images from external files.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 无需从外部文件创建或加载图像。
- en: '**Table 5-2:** Functions for Drawing Shapes'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-2：** 绘制形状的函数'
- en: '**Function**'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能**'
- en: '**Description**'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: '**描述**'
- en: pygame.draw.aaline()
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.aaline()
- en: Draws an anti-aliased line
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 画一条抗锯齿线
- en: pygame.draw.aalines()
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.aalines()
- en: Draws a series of anti-aliased lines
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 画一系列抗锯齿线
- en: pygame.draw.arc()
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.arc()
- en: Draws an arc
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 画一个弧
- en: pygame.draw.circle()
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.circle()
- en: Draws a circle
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 画一个圆
- en: pygame.draw.ellipse()
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.ellipse()
- en: Draws an ellipse
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 画一个椭圆
- en: pygame.draw.line()
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.line()
- en: Draws a line
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 画一条线
- en: pygame.draw.lines()
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.lines()
- en: Draws a series of lines
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 画一系列线条
- en: pygame.draw.polygon()
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.polygon()
- en: Draws a polygon
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 画一个多边形
- en: pygame.draw.rect()
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.rect()
- en: Draws a rectangle
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 画一个矩形
- en: Figure 5-7 shows the output of a sample program that demonstrates
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-7 显示了演示示例程序的输出
- en: calls to these primitive drawing functions.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这些基础绘图函数。
- en: Listing 5-8 is the code of the sample program, using the same 12-step
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-8 是示例程序的代码，使用了相同的 12 步
- en: template that produced the output in Figure 5-7\.
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 模板生成了图 5-7 中的输出。
- en: '**File: PygameDemo5_DrawingShapes.py**'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PygameDemo5_DrawingShapes.py**'
- en: pygame demo 5 - drawing
  id: totrans-1222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pygame 示例 5 - 绘图
- en: '--- snip ---'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 截断 ---'
- en: 'while True:'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 7 - Check for and handle events
  id: totrans-1225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 - 检查并处理事件
- en: 'for event in pygame.event.get():'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: Clicked the close button? Quit pygame and end the program
  id: totrans-1227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击了关闭按钮？退出 pygame 并结束程序
- en: 'if event.type == pygame.QUIT:'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 'if event.type == pygame.QUIT:'
- en: pygame.quit()
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: '**116** Chapter 5'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: '**116** 第五章'
- en: 8 - Do any "per frame" actions
  id: totrans-1232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 - 执行任何"每帧"动作
- en: 9 - Clear the window
  id: totrans-1233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 - 清除窗口
- en: window.fill(GRAY)
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: window.fill(GRAY)
- en: '1 # 10 - Draw all window elements'
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: '1 # 10 - 绘制所有窗口元素'
- en: Draw a box
  id: totrans-1236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 画一个框
- en: 'pygame.draw.line(window, BLUE, (20, 20), (60, 20), 4) # top'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 'pygame.draw.line(window, BLUE, (20, 20), (60, 20), 4) # 上'
- en: 'pygame.draw.line(window, BLUE, (20, 20), (20, 60), 4) # left'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 'pygame.draw.line(window, BLUE, (20, 20), (20, 60), 4) # 左'
- en: 'pygame.draw.line(window, BLUE, (20, 60), (60, 60), 4) # right'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 'pygame.draw.line(window, BLUE, (20, 60), (60, 60), 4) # 右'
- en: 'pygame.draw.line(window, BLUE, (60, 20), (60, 60), 4) # bottom'
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 'pygame.draw.line(window, BLUE, (60, 20), (60, 60), 4) # 底部'
- en: Draw an X in the box
  id: totrans-1241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在框内画一个 X
- en: pygame.draw.line(window, BLUE, (20, 20), (60, 60), 1)
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.line(window, BLUE, (20, 20), (60, 60), 1)
- en: pygame.draw.line(window, BLUE, (20, 60), (60, 20), 1)
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.line(window, BLUE, (20, 60), (60, 20), 1)
- en: Draw a filled circle and an empty circle
  id: totrans-1244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制一个填充圆和一个空心圆
- en: 'pygame.draw.circle(window, GREEN, (250, 50), 30, 0) # filled'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 'pygame.draw.circle(window, GREEN, (250, 50), 30, 0) # 填充'
- en: 'pygame.draw.circle(window, GREEN, (400, 50), 30, 2) # 2 pixel edge'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 'pygame.draw.circle(window, GREEN, (400, 50), 30, 2) # 2像素边缘'
- en: Draw a filled rectangle and an empty rectangle
  id: totrans-1247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制一个填充矩形和一个空心矩形
- en: 'pygame.draw.rect(window, RED, (250, 150, 100, 50), 0) # filled'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 'pygame.draw.rect(window, RED, (250, 150, 100, 50), 0) # 填充'
- en: 'pygame.draw.rect(window, RED, (400, 150, 100, 50), 1) # 1 pixel edge'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 'pygame.draw.rect(window, RED, (400, 150, 100, 50), 1) # 1像素边缘'
- en: Draw a filled ellipse and an empty ellipse
  id: totrans-1250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制一个填充椭圆和一个空心椭圆
- en: 'pygame.draw.ellipse(window, YELLOW, (250, 250, 80, 40), 0) # filled'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 'pygame.draw.ellipse(window, YELLOW, (250, 250, 80, 40), 0) # 填充'
- en: 'pygame.draw.ellipse(window, YELLOW, (400, 250, 80, 40), 2) # 2 pixel edge'
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 'pygame.draw.ellipse(window, YELLOW, (400, 250, 80, 40), 2) # 2像素边缘'
- en: Draw a six-sided polygon
  id: totrans-1253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制一个六边形
- en: pygame.draw.polygon(window, TEAL, ((240, 350), (350, 350),
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.polygon(window, TEAL, ((240, 350), (350, 350),
- en: (410, 410), (350, 470),
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: (410, 410), (350, 470),
- en: (240, 470), (170, 410)))
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: (240, 470), (170, 410)))
- en: Draw an arc
  id: totrans-1257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制一个弧形
- en: pygame.draw.arc(window, BLUE, (20, 400, 100, 100), 0, 2, 5)
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.arc(window, BLUE, (20, 400, 100, 100), 0, 2, 5)
- en: 'Draw anti-aliased lines: a single line, then a list of points'
  id: totrans-1259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制抗锯齿线：一条线，然后是一组点
- en: pygame.draw.aaline(window, RED, (500, 400), (540, 470), 1)
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.aaline(window, RED, (500, 400), (540, 470), 1)
- en: pygame.draw.aalines(window, BLUE, True,
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.aalines(window, BLUE, True,
- en: ((580, 400), (587, 450),
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: ((580, 400), (587, 450),
- en: (595, 460), (600, 444)), 1)
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: (595, 460), (600, 444)), 1)
- en: 11 - Update the window
  id: totrans-1264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 - 更新窗口
- en: pygame.display.update()
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.update()
- en: 12 - Slow things down a bit
  id: totrans-1266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 - 稍微放慢一些
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 'clock.tick(FRAMES_PER_SECOND) # 让 pygame 等待'
- en: '*Listing 5-8: A program to demonstrate cal s to primitive drawing functions
    in pygame* The drawing of all the primitives occurs in section #10 1\. We make'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-8：一个程序，展示如何在 pygame 中使用 cal s 绘制基本图形函数* 所有基础图形的绘制发生在第10章。我们进行'
- en: calls to pygame’s drawing functions to draw a box with two diagonals, filled
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 pygame 的绘图函数，绘制一个带有两条对角线的矩形，填充
- en: and empty circles, filled and empty rectangles, filled and empty ovals, a six-
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 填充和空心圆，填充和空心矩形，填充和空心椭圆，一个六边形—
- en: sided polygon, an arc, and two anti-aliased lines.
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形、多边形弧线和两条抗锯齿线。
- en: Introduction to Pygame **117**
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame简介 **117**
- en: '![Image 20](index-147_1.png)'
  id: totrans-1273
  prefs: []
  type: TYPE_IMG
  zh: '![图像 20](index-147_1.png)'
- en: '*Figure 5-7: A sample program that demonstrates using cal s to draw primitive
    shapes*'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-7：一个示例程序，展示如何使用 cal s 绘制基本形状*'
- en: '***Reference for Primitive Shapes***'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: '***基础形状参考***'
- en: For your reference, here is the documentation for the pygame methods to
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 供你参考，以下是 pygame 方法的文档
- en: draw these primitives. In all of the following, the color argument expects
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制这些基本形状。在以下所有内容中，color 参数期待
- en: 'you to pass in a tuple of RGB values:'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 允许你传入一个RGB值的元组：
- en: '**Anti-aliased line**'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: '**抗锯齿线**'
- en: pygame.draw.aaline(window, color, startpos, endpos, blend=True)
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.aaline(window, color, startpos, endpos, blend=True)
- en: Draws an anti-aliased line in the window. If blend is True, the shades will
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口中绘制一条抗锯齿线。如果 blend 为 True，颜色将
- en: be blended with existing pixel shades instead of overwriting pixels.
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 将与现有的像素颜色混合，而不是覆盖像素。
- en: '**Anti-aliased lines**'
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: '**抗锯齿线**'
- en: pygame.draw.aalines(window, color, closed, points, blend=True)
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.aalines(window, color, closed, points, blend=True)
- en: Draws a sequence of anti-aliased lines in the window. The closed argu-
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口中绘制一系列抗锯齿线。封闭参数—
- en: ment is a simple Boolean; if it’s True, a line will be drawn between the
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: '`ment` 是一个简单的布尔值；如果它为 True，一条线将在'
- en: first and last points to complete the shape. The points argument is a list
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
  zh: 通过连接第一个和最后一个点来完成形状。points 参数是一个点的列表
- en: or tuple of (x, y) coordinates to be connected by line segments (there
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 或 (x, y) 坐标的元组，通过线段连接这些点（至少需要两个点）。
- en: must be at least two). The Boolean blend argument, if set to True, will
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: 必须至少有两个点）。布尔值 blend 参数，如果设置为 True，将会
- en: blend the shades with existing pixel shades instead of overwriting them.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 与现有的像素颜色混合，而不是覆盖它们。
- en: '**118** Chapter 5'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: '**118** 第5章'
- en: '**Arc**'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: '**弧形**'
- en: pygame.draw.arc(window, color, rect, angle_start, angle_stop, width=0)
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.arc(window, color, rect, angle_start, angle_stop, width=0)
- en: Draws an arc in the window. The arc will fit inside the given rect. The
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口中绘制一个弧形。弧形将适应给定的矩形。
- en: two angle arguments are the initial and final angles (in radians, with
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 两个角度参数是初始角度和结束角度（以弧度表示，范围从
- en: zero on the right). The width argument is the thickness to draw the
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧为零）。width参数是绘制
- en: outer edge.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 外边缘。
- en: '**Circle**'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: '**圆形**'
- en: pygame.draw.circle(window, color, pos, radius, width=0)
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.circle(window, color, pos, radius, width=0)
- en: Draws a circle in the window. The pos is the center of the circle, and
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口中绘制一个圆形。pos是圆心，
- en: radius is the radius. The width argument is the thickness to draw the
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: radius是半径。width参数是绘制
- en: outer edge. If width is 0, then the circle will be filled.
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 外边缘。如果width为0，则圆形将被填充。
- en: '**Ellipse**'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: '**椭圆**'
- en: pygame.draw.ellipse(window, color, rect, width=0)
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.ellipse(window, color, rect, width=0)
- en: Draws an ellipse in the window. The given rect is the area that the
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口中绘制一个椭圆。给定的rect是椭圆的区域
- en: ellipse will fill. The width argument is the thickness to draw the outer
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆将被填充。width参数是绘制外边缘的粗细。
- en: edge. If width is 0, then the ellipse will be filled.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘。如果width为0，则椭圆将被填充。
- en: '**Line**'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: '**线条**'
- en: pygame.draw.line(window, color, startpos, endpos, width=1)
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.line(window, color, startpos, endpos, width=1)
- en: Draws a line in a window. The width argument is the thickness of the line.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口中绘制一条线。width参数是线条的粗细。
- en: '**Lines**'
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: '**线条**'
- en: pygame.draw.lines(window, color, closed, points, width=1)
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.lines(window, color, closed, points, width=1)
- en: Draws a sequence of lines in the window. The closed argument is a simple
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口中绘制一系列线条。closed参数是一个简单的
- en: Boolean; if it’s True, a line will be drawn between the first and last points
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值；如果为True，则会在第一个和最后一个点之间绘制一条线。
- en: to complete the shape. The points argument is a list or tuple of (x, y)
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 完成形状的坐标。points参数是一个包含（x，y）坐标的列表或元组。
- en: coordinates to be connected by line segments (there must be at least
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标由线段连接（必须至少有
- en: two). The width argument is the thickness of the line. Note that specify-
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 两个）。width参数是线条的粗细。注意，指定比1更宽的线条不会填补线条之间的空隙。
- en: ing a line width wider than 1 does not fill in the gaps between the lines.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: 设定线条宽度大于1不会填充线条之间的间隙。
- en: Therefore, wide lines and sharp corners won’t be joined seamlessly.
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，宽线条和锐角不会无缝连接。
- en: '**Polygon**'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: '**多边形**'
- en: pygame.draw.polygon(window, color, pointslist, width=0)
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.polygon(window, color, pointslist, width=0)
- en: Draws a polygon in the window. The pointslist specifies the vertices
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口中绘制一个多边形。pointslist指定了多边形的顶点
- en: of the polygon. The width argument is the thickness to draw the outer
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 多边形的顶点。width参数是绘制外边缘的粗细。
- en: edge. If width is 0, then the polygon will be filled.
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘。如果width为0，则多边形将被填充。
- en: Introduction to Pygame **119**
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: Pygame简介 **119**
- en: '**Rectangle**'
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: '**矩形**'
- en: pygame.draw.rect(window, color, rect, width=0)
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.draw.rect(window, color, rect, width=0)
- en: Draws a rectangle in the window. The rect is the area of the rectangle.
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口中绘制一个矩形。rect是矩形的区域。
- en: The width argument is the thickness to draw the outer edge. If width is 0,
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: width参数是绘制外边缘的粗细。如果width为0，
- en: then the rectangle will be filled.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 那么矩形将被填充。
- en: '**N O T E**'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: '**注释**'
- en: '*For additional information, see* [http://www.pygame.org/docs/ref/draw.html
    *.*](http://www.pygame.org/docs/ref/draw.html)'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关更多信息，请参见* [http://www.pygame.org/docs/ref/draw.html *.*](http://www.pygame.org/docs/ref/draw.html)'
- en: The set of primitive calls allows you the flexibility to draw any shapes
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 一组原始调用允许你灵活地绘制任何形状。
- en: you wish. Again, the order in which you make calls is important. Think of
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望的顺序。再次提醒，调用的顺序非常重要。想象
- en: the order of your calls as layers; elements that are drawn early can be over-
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 你调用的顺序作为层次；早期绘制的元素可能会被覆盖。
- en: laid by later calls to any other drawing primitive function.
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 由后续的任何其他绘图原语函数调用构成。
- en: '**Summary**'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter I introduced the basics of pygame. You installed pygame on
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我介绍了pygame的基础知识。你已经安装了pygame
- en: your computer, then learned about the model of event-driven programming
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 你的计算机，接着了解了事件驱动编程的模型
- en: and the use of events, which is very different from coding text-based pro-
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 以及事件的使用，这与编写基于文本的程序有很大不同。
- en: grams. I explained the coordinate system of pixels in a window and the way
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 程序。我解释了窗口中像素的坐标系统以及如何
- en: that colors are represented in code.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色在代码中的表示方式。
- en: To start right at the beginning with pygame, I introduced a 12-section
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从一开始就学习pygame，我介绍了一个12节的
- en: template that does nothing but bring up a window and can be used to build
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不做任何事情的模板，只是打开一个窗口，可以用来构建
- en: any pygame-based program. Using that framework, we then built sample
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 任何基于pygame的程序。使用这个框架，我们接着构建了示例
- en: programs that showed how to draw an image in the window (using blit()),
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 程序展示了如何在窗口中绘制图像（使用blit()）,
- en: how to detect mouse events, and how to handle keyboard input. The next
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 如何检测鼠标事件，以及如何处理键盘输入。接下来
- en: demonstration explained how to build a location-based animation.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 演示都解释了如何构建基于位置的动画。
- en: Rectangles are highly important in pygame, so I covered how the attri-
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形在pygame中非常重要，所以我介绍了如何使用其属性
- en: butes of a rect object can be used. I also provided some example code to
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: rect对象的属性可以被使用。我还提供了一些示例代码
- en: show how to play sound effects and background music to enhance the user’s
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何播放音效和背景音乐，以增强用户的
- en: enjoyment of your programs. Finally, I introduced how to use pygame meth-
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 增强你程序的乐趣。最后，我介绍了如何使用pygame方法
- en: ods to draw primitive shapes in a window.
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法在窗口中绘制原始形状。
- en: While I have introduced many concepts within pygame, almost every-
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我在pygame中介绍了许多概念，但几乎每个
- en: thing I showed in this chapter has essentially been procedural. The rect
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中展示的所有内容本质上都是过程化的。rect
- en: object is an example of object-oriented code built directly into pygame. In
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是直接构建在pygame中的面向对象代码的一个例子。在
- en: the next chapter, I’ll show how to use OOP in code to use pygame more
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将展示如何在代码中使用OOP，使得pygame的使用更加
- en: effectively.
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: 有效地。
- en: '**120** Chapter 5'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: '**120** 第5章'
- en: '**6**'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: '**6**'
- en: '**O B J E C T- O R I E N T E D P Y G A M E**'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象的pygame游戏**'
- en: In this chapter I’ll demonstrate how you
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将展示如何
- en: can use OOP techniques effectively within
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在代码中有效地使用OOP技术，
- en: the pygame framework. We’ll start off with
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: pygame框架。我们将从
- en: an example of procedural code, then split that
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 一个过程化代码的例子，然后将其拆分
- en: code into a single class and some main code that calls
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码拆分成一个类和一些主代码来调用
- en: the methods of that class. After that, we’ll build two
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的方法。之后，我们将构建两个
- en: classes, SimpleButton and SimpleText, that implement
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 类SimpleButton和SimpleText实现了
- en: 'basic user interface widgets: a button and a field for'
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 基本用户界面小部件：一个按钮和一个字段，用于
- en: displaying text. I’ll also introduce the concept of a
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 显示文本。我还将介绍一个
- en: callback.
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数。
- en: '**Building the Screensaver Ball with OOP Pygame**'
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: '**用OOP和Pygame构建屏幕保护程序球**'
- en: I[n Chapter 5, w](#p118)e created an old-school screensaver where a ball bounced
    around inside a window (Listing 5-6, if you need to refresh your memory).
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章中，我们创建了一个老式的屏幕保护程序，其中一个球在窗口内弹跳（如果你需要回忆，查看清单5-6）。
- en: That code works, but the data for the ball and the code to manipu-
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码可以正常工作，但球体的数据和操控代码交织在一起，这意味着有大量的初始化代码，
- en: late the ball are intertwined, meaning there’s a lot of initialization code,
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: 使得球体的数据和代码相互交织，这意味着有大量的初始化代码，
- en: and the code to update and draw the ball are embedded in the 12-step
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 更新和绘制球体的代码被嵌入在12步的程序中
- en: framework.
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 框架。
- en: A more modular approach is to split the code into a Ball class and a
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 更具模块化的方法是将代码拆分成一个Ball类和一些
- en: main program that instantiates a Ball object and makes calls to its methods.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序实例化一个Ball对象并调用其方法。
- en: In this section we’ll make this split, and I’ll show you how to create multiple
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将进行这次拆分，我将展示如何创建多个
- en: balls from the Ball class.
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 从Ball类中创建球体。
- en: '***Creating a Ball Class***'
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: '***创建一个Ball类***'
- en: We’ll start by extracting all code relating to the ball from the main pro-
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先从主程序中提取所有与球体相关的代码，
- en: gram and moving it into a separate Ball class. Looking at the original code,
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 程序并将其移动到一个独立的Ball类中。查看原始代码，
- en: 'we can see that the sections that deal with the ball are:'
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，处理球体的各个部分包括：
- en: '• Section #4, which loads the image of the ball'
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: • 第4节，加载球体图像的代码
- en: '• Section #5, which creates and initializes all the variables that have'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: • 第5节，创建并初始化所有具有
- en: something to do with the ball
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 与球体有关的东西
- en: '• Section #8, which includes code for moving the ball, detecting an edge'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: • 第8节，其中包括移动球体、检测边缘的代码
- en: bounce, and changing speed and direction
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 弹跳，改变速度和方向
- en: '• Section #10, which draws the ball'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: • 第10节，绘制球体的代码
- en: From this we can conclude that our Ball class will require the following
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以得出结论，我们的Ball类将需要以下内容
- en: 'methods:'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 方法：
- en: '**create()** Loads an image, sets a location, and initializes all instance'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: '**create()** 加载一个图像，设置位置，并初始化所有实例'
- en: variables
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 变量
- en: '**update()** Changes the location of the ball in every frame, based on the'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: '**update()** 在每一帧中根据'
- en: x speed and y speed of the ball
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 球体的x速度和y速度
- en: '**draw()** Draws the ball in the window'
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: '**draw()** 在窗口中绘制球体'
- en: The first step is to create a project folder, in which you need a *Ball.py*
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个项目文件夹，其中需要一个*Ball.py*
- en: for the new Ball class, the main code file *Main_BallBounce.py*, and an *images*
    folder containing the *ball.png* image file.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 新的Ball类代码文件、主代码文件*Main_BallBounce.py*，以及包含*ball.png*图像文件的*images*文件夹。
- en: Listing 6-1 shows the code of the new Ball class.
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-1 显示了新 Ball 类的代码。
- en: '**File: PygameDemo6_Bal BounceObjectOriented/Bal .py**'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件: PygameDemo6_Ball BounceObjectOriented/Bal .py**'
- en: import pygame
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from pygame.locals import *
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: from pygame.locals import *
- en: import random
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: Ball class
  id: totrans-1406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ball 类
- en: 'class Ball():'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Ball():'
- en: '1 def __init__(self, window, windowWidth, windowHeight):'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: '1 def __init__(self, window, windowWidth, windowHeight):'
- en: 'self.window = window # remember the window, so we can draw later'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.window = window  # 记住窗口，以便以后绘制'
- en: self.windowWidth = windowWidth
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: self.windowWidth = windowWidth
- en: self.windowHeight = windowHeight
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: self.windowHeight = windowHeight
- en: '**122** Chapter 6'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: '**122** 第6章'
- en: 2 self.image = pygame.image.load('images/ball.png')
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 2 self.image = pygame.image.load('images/ball.png')
- en: A rect is made up of [x, y, width, height]
  id: totrans-1414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个矩形由 [x, y, 宽度, 高度] 组成
- en: ballRect = self.image.get_rect()
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: ballRect = self.image.get_rect()
- en: self.width = ballRect.width
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: self.width = ballRect.width
- en: self.height = ballRect.height
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: self.height = ballRect.height
- en: self.maxWidth = windowWidth - self.width
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: self.maxWidth = windowWidth - self.width
- en: self.maxHeight = windowHeight - self.height
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: self.maxHeight = windowHeight - self.height
- en: Pick a random starting position
  id: totrans-1420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择一个随机的起始位置
- en: 3 self.x = random.randrange(0, self.maxWidth)
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 3 self.x = random.randrange(0, self.maxWidth)
- en: self.y = random.randrange(0, self.maxHeight)
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: self.y = random.randrange(0, self.maxHeight)
- en: Choose a random speed between -4 and 4, but not zero,
  id: totrans-1423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择一个在 -4 到 4 之间的随机速度，但不能为零，
- en: in both the x and y directions
  id: totrans-1424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 x 和 y 两个方向上
- en: 4 speedsList = [-4, -3, -2, -1, 1, 2, 3, 4]
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 4 speedsList = [-4, -3, -2, -1, 1, 2, 3, 4]
- en: self.xSpeed = random.choice(speedsList)
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: self.xSpeed = random.choice(speedsList)
- en: self.ySpeed = random.choice(speedsList)
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: self.ySpeed = random.choice(speedsList)
- en: '5 def update(self):'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: '5 def update(self):'
- en: Check for hitting a wall. If so, change that direction.
  id: totrans-1429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查是否撞墙。如果是，改变方向。
- en: 'if (self.x < 0) or (self.x >= self.maxWidth):'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: '如果(self.x < 0) 或者 (self.x >= self.maxWidth):'
- en: self.xSpeed = -self.xSpeed
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: self.xSpeed = -self.xSpeed
- en: 'if (self.y < 0) or (self.y >= self.maxHeight):'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: '如果(self.y < 0) 或者 (self.y >= self.maxHeight):'
- en: self.ySpeed = -self.ySpeed
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: self.ySpeed = -self.ySpeed
- en: Update the Ball's x and y, using the speed in two directions
  id: totrans-1434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新球的 x 和 y 坐标，使用两个方向的速度
- en: self.x = self.x + self.xSpeed
  id: totrans-1435
  prefs: []
  type: TYPE_NORMAL
  zh: self.x = self.x + self.xSpeed
- en: self.y = self.y + self.ySpeed
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: self.y = self.y + self.ySpeed
- en: '6 def draw(self):'
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: '6 def draw(self):'
- en: self.window.blit(self.image, (self.x, self.y))
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: self.window.blit(self.image, (self.x, self.y))
- en: '*Listing 6-1: The new Ball class*'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-1: 新的 Ball 类*'
- en: When we instantiate a Ball object, the __init__() method receives three
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实例化一个 Ball 对象时，__init__() 方法接收三个
- en: 'pieces of data: the window to draw into, the width of the window, and the'
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据：绘制窗口、窗口宽度和
- en: height of the window 1\. We save the window variable into the instance vari-
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口的高度 1\. 我们将窗口变量保存到实例变量中-
- en: able self.window so that we can use it later in the draw() method, and we do
  id: totrans-1443
  prefs: []
  type: TYPE_NORMAL
  zh: 将 self.window 赋值给窗口，以便以后在 draw() 方法中使用，我们这样做
- en: the same with the self.windowHeight and self.windowWidth instance variables.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 同样操作 self.windowHeight 和 self.windowWidth 实例变量。
- en: We then load the image of the ball using the path to the file and get the
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用文件路径加载球的图像并获取
- en: rect of that ball image 2\. We need the rect to calculate the maximum val-
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 该球的图像矩形 2\. 我们需要这个矩形来计算最大值-
- en: ues for x and y so that the ball will always fully appear in the window. Next,
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 调整 x 和 y 方向上的速度值，使得球总是完全出现在窗口中。接下来，
- en: we pick a randomized starting location for the ball 3\. Finally, we set the
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为球选择一个随机的起始位置 3\. 最后，我们设置
- en: speed in the x and y directions to a random value between –4 and 4 (but
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: x 和 y 方向上的速度随机设置为 -4 到 4 之间的值（但
- en: not 0), representing the number of pixels to move per frame 4\. Because
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 不是 0)，表示每帧移动的像素数 4\. 因为
- en: of these numbers, the ball may move differently each time we run the pro-
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字的不同组合，球的运动可能每次运行程序时都不同-
- en: gram. All these values are saved in instance variables to be used by other
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 程序。所有这些值都保存在实例变量中，以供其他
- en: methods.
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 方法。
- en: In the main program, we’ll call the update() method in each frame of
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: 在主程序中，我们将在每一帧调用 update() 方法
- en: the main loop, so this is where we place the code that checks for the ball
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环中，因此这是我们放置检查球
- en: Object-Oriented Pygame **123**
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的 Pygame **123**
- en: hitting any border of the window 5\. If it does hit an edge, we reverse the
    speed in that direction and modify the x- and y-coordinates (self.x and
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 如果撞到窗口的任何边界 5\. 如果碰到边缘，我们反转该方向的速度并修改 x 和 y 坐标（self.x 和
- en: self.y) by the current speed in the x and y directions.
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: self.y) 由当前的 x 和 y 方向速度决定。
- en: We’ll also call the draw() method, which simply calls blit() to draw the
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将调用 draw() 方法，该方法只是调用 blit() 来绘制
- en: ball at its current x- and y-coordinates 6, in every frame of the main loop.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 每帧在主循环中，我们将绘制球的位置，它位于当前的 x 和 y 坐标 6。
- en: '***Using the Ball Class***'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: '***使用 Ball 类***'
- en: Now all functionality associated with a ball has been placed in the Ball
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有与球相关的功能都已经被放入 Ball 类中
- en: class code. All the main program needs to do is create the ball, then call
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 类代码。主程序需要做的就是创建球对象，然后调用
- en: its update() and draw() methods in every frame. Listing 6-2 shows the greatly
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 它的 update() 和 draw() 方法在每一帧中都被调用。示例 6-2 显示了大大简化的
- en: simplified code of the main program.
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序的简化代码。
- en: '**File: PygameDemo6_Bal BounceObjectOriented/Main_Bal Bounce.py**'
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PygameDemo6_BallBounceObjectOriented/Main_BallBounce.py**'
- en: pygame demo 6(a) - using the Ball class, bounce one ball
  id: totrans-1467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pygame 示例 6(a) - 使用 Ball 类，反弹一个球
- en: 1 - Import packages
  id: totrans-1468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 - 导入包
- en: import pygame
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from pygame.locals import *
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: from pygame.locals import *
- en: import sys
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: import sys
- en: import random
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: import random
- en: '1 from Ball import * # bring in the Ball class code'
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: '1 from Ball import * # 引入 Ball 类代码'
- en: 2 - Define constants
  id: totrans-1474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 - 定义常量
- en: BLACK = (0, 0, 0)
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: BLACK = (0, 0, 0)
- en: WINDOW_WIDTH = 640
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_WIDTH = 640
- en: WINDOW_HEIGHT = 480
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: WINDOW_HEIGHT = 480
- en: FRAMES_PER_SECOND = 30
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: FRAMES_PER_SECOND = 30
- en: 3 - Initialize the world
  id: totrans-1479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 - 初始化世界
- en: pygame.init()
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.init()
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
- en: clock = pygame.time.Clock()
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: clock = pygame.time.Clock()
- en: '4 - Load assets: image(s), sound(s), etc.'
  id: totrans-1483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 - 加载资源：图像、声音等
- en: 5 - Initialize variables
  id: totrans-1484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 - 初始化变量
- en: 2 oBall = Ball(window, WINDOW_WIDTH, WINDOW_HEIGHT)
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: 2 oBall = Ball(window, WINDOW_WIDTH, WINDOW_HEIGHT)
- en: 6 - Loop forever
  id: totrans-1486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 - 无限循环
- en: 'while True:'
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 7 - Check for and handle events
  id: totrans-1488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 - 检查并处理事件
- en: 'for event in pygame.event.get():'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 'for event in pygame.event.get():'
- en: 'if event.type == pygame.QUIT:'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: 'if event.type == pygame.QUIT:'
- en: pygame.quit()
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: 8 - Do any "per frame" actions
  id: totrans-1493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 - 执行任何“每帧”操作
- en: '3 oBall.update() # tell the Ball to update itself'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: '3 oBall.update() # 告诉 Ball 更新自己'
- en: '**124** Chapter 6'
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: '**124** 第 6 章'
- en: 9 - Clear the window before drawing it again
  id: totrans-1496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 - 在绘制之前清空窗口
- en: window.fill(BLACK)
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: window.fill(BLACK)
- en: 10 - Draw the window elements
  id: totrans-1498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 - 绘制窗口元素
- en: '4 oBall.draw() # tell the Ball to draw itself'
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: '4 oBall.draw() # 告诉 Ball 绘制自己'
- en: 11 - Update the window
  id: totrans-1500
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 - 更新窗口
- en: pygame.display.update()
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.update()
- en: 12 - Slow things down a bit
  id: totrans-1502
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 - 稍微减慢速度
- en: clock.tick(FRAMES_PER_SECOND)
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: clock.tick(FRAMES_PER_SECOND)
- en: '*Listing 6-2: The new main program that instantiates a Ball and makes cal s
    to its methods* If you compare this new main program with the original code in'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 6-2：新的主程序，实例化一个 Ball 并调用其方法* 如果你将这个新的主程序与原始代码进行比较，'
- en: Listing 5-6, you’ll see that it’s much simpler and clearer. We use an import
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例 5-6 中，你会发现这变得更加简单和清晰。我们使用了一个 import
- en: statement to bring in the Ball class code 1\. We create a Ball object, passing
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 语句来引入 Ball 类代码 1。我们创建一个 Ball 对象，传递
- en: in the window that we created and the width and height of that window 2,
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建的窗口中，以及该窗口的宽度和高度 2，
- en: and we save the resulting Ball object in a variable named oBall.
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将得到的 Ball 对象保存在一个名为 oBall 的变量中。
- en: The responsibility of moving the ball is now in the Ball class code, so
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 移动球的责任现在在 Ball 类的代码中，所以
- en: here we only need to call the update() method of the oBall object 3\. Since
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们只需要调用 oBall 对象的 update() 方法 3。由于
- en: the Ball object knows how big the window is, how big the image of the ball
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: Ball 对象知道窗口的大小，球的图像大小，
- en: is, and the location and the speed of the ball, it can do all the calculations
    it
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 它的大小、位置和速度，Ball 对象可以做所有需要的计算，
- en: needs to do to move the ball and bounce it off the walls.
  id: totrans-1513
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要做的就是移动球并使其反弹。
- en: The main code calls the draw() method of the oBall object 4, but the
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 主代码调用了 oBall 对象的 draw() 方法 4，但是
- en: actual drawing is done in the oBall object.
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的绘制操作是在 oBall 对象中完成的。
- en: '***Creating Many Ball Objects***'
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: '***创建多个 Ball 对象***'
- en: Now let’s make a slight but important modification to the main program to
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们对主程序做一个稍微但重要的修改，以
- en: create multiple Ball objects. This is one of the real powers of object orien-
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 创建多个 Ball 对象。这是面向对象编程的真正力量之一，
- en: 'tation: to create three balls, we only have to instantiate three Ball objects'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 说明：为了创建三个球，我们只需要实例化三个 Ball 对象
- en: from the Ball class. Here we’ll use a basic approach and build a list of Ball
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Ball 类中引入。这里我们将使用一种基本方法，构建一个 Ball 对象的列表
- en: objects. In each frame, we’ll iterate through the list of Ball objects, tell
    each
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 对象。每一帧中，我们将遍历 Ball 对象的列表，告诉每个
- en: one to update its location, then iterate again to tell each one to draw itself.
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 更新位置后，再次迭代，让每个对象自行绘制。
- en: Listing 6-3 shows a modified main program that creates and updates three
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-3 显示了一个修改过的主程序，它创建并更新三个
- en: Ball objects.
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: Ball 对象。
- en: '**File: PygameDemo6_BallBounceObjectOriented/Main_BallBounceManyBalls.py**'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PygameDemo6_BallBounceObjectOriented/Main_BallBounceManyBalls.py**'
- en: pygame demo 6(b) - using the Ball class, bounce many balls
  id: totrans-1526
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pygame演示6(b) - 使用Ball类，反弹多个小球
- en: '--- snip ---'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 略 ---'
- en: N_BALLS = 3
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: N_BALLS = 3
- en: '--- snip ---'
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 略 ---'
- en: 5 - Initialize variables
  id: totrans-1530
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 - 初始化变量
- en: 1 ballList = []
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 1 ballList = []
- en: 'for oBall in range(0, N_BALLS):'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个oBall在范围0到N_BALLS中：
- en: Each time through the loop, create a Ball object
  id: totrans-1533
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每次循环时，创建一个Ball对象
- en: oBall = Ball(window, WINDOW_WIDTH, WINDOW_HEIGHT)
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: oBall = Ball(window, WINDOW_WIDTH, WINDOW_HEIGHT)
- en: Object-Oriented Pygame **125**
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的Pygame **125**
- en: 'ballList.append(oBall) # append the new Ball to the list of Balls'
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: 'ballList.append(oBall) # 将新的Ball对象添加到Ball列表中'
- en: 6 - Loop forever
  id: totrans-1537
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 - 永久循环
- en: 'while True:'
  id: totrans-1538
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: '--- snip ---'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 略 ---'
- en: 8 - Do any "per frame" actions
  id: totrans-1540
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 - 执行“每帧”动作
- en: '2 for oBall in ballList:'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 2 对每个oBall在ballList中：
- en: 'oBall.update() # tell each Ball to update itself'
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: 'oBall.update() # 告诉每个Ball更新自己'
- en: 9 - Clear the window before drawing it again
  id: totrans-1543
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 - 在重新绘制窗口之前清除它
- en: window.fill(BLACK)
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: window.fill(BLACK)
- en: 10 - Draw the window elements
  id: totrans-1545
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 - 绘制窗口元素
- en: '3 for oBall in ballList:'
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 3 对每个oBall在ballList中：
- en: 'oBall.draw() # tell each Ball to draw itself'
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 'oBall.draw() # 告诉每个Ball绘制自己'
- en: 11 - Update the window
  id: totrans-1548
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 - 更新窗口
- en: pygame.display.update()
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.update()
- en: 12 - Slow things down a bit
  id: totrans-1550
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 - 稍微减慢速度
- en: clock.tick(FRAMES_PER_SECOND)
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: clock.tick(FRAMES_PER_SECOND)
- en: '*Listing 6-3: Creating, moving, and displaying three bal s*'
  id: totrans-1552
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-3：创建、移动和显示三个小球*'
- en: We start with an empty list of Ball objects 1\. Then we have a loop
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个空的Ball对象列表开始1。然后我们有一个循环
- en: that creates three Ball objects, each of which we append to our list of Ball
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了三个Ball对象，我们将每个Ball对象添加到Ball列表中
- en: objects, ballList. Each Ball object chooses and remembers a randomized
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: 对象，ballList。每个Ball对象选择并记住一个随机化的
- en: starting location and a randomized speed in both the x and y directions.
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: 起始位置和随机的x和y方向速度。
- en: Inside the main loop, we iterate through all the Ball objects and tell
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环中，我们遍历所有Ball对象并告诉
- en: each one to update itself 2, changing the x- and y-coordinates of each Ball
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象更新自己2，改变每个Ball的x和y坐标
- en: object to a new location. We then iterate through the list again, calling the
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象移动到一个新位置。然后，我们再次遍历列表，调用
- en: draw() method of each Ball object 3\.
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Ball对象的draw()方法3。
- en: When we run the program, we see three balls, each starting at a ran-
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行程序时，我们看到三个小球，每个小球都从一个随机
- en: domized location and each moving with a randomized x and y speed. Each
  id: totrans-1562
  prefs: []
  type: TYPE_NORMAL
  zh: 随机位置，并且每个球以随机的x和y速度移动。每个
- en: ball bounces correctly off the boundaries of the window.
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 小球正确地从窗口边界反弹。
- en: Using this object-oriented approach, we made no changes to the Ball
  id: totrans-1564
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种面向对象的方法，我们没有对Ball类做任何更改
- en: class, but just changed our main program to now manage a list of Ball
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 类别，但我们刚刚修改了主程序，现在管理一个Ball对象的列表
- en: objects instead of a single Ball object. This is a common, and very positive,
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 对象而不是单一的Ball对象。这是一个常见且非常积极的
- en: 'side effect of OOP code: well-written classes can often be reused without'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: OOP代码的副作用：编写良好的类通常可以在不做任何修改的情况下重用
- en: change.
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: 改变。
- en: '***Creating Many, Many Ball Objects***'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: '***创建许多、许多Ball对象***'
- en: We can change the value of the constant N_BALLS from 3 to some much
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将常量N_BALLS的值从3改为更大的值
- en: larger value, like 300, to quickly create that many balls (Figure 6-1). By
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: 更大的值，例如300，快速创建那样多的球（图6-1）。通过
- en: changing just a single constant, we make a major change to the behavior
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仅更改一个常量，我们使行为发生了重大变化
- en: of the program. Each ball maintains its own speed and location and draws
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的部分。每个球保持自己的速度和位置，并绘制
- en: itself.
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: 本身。
- en: '**126** Chapter 6'
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: '**126** 第六章'
- en: '![Image 21](index-156_1.png)'
  id: totrans-1576
  prefs: []
  type: TYPE_IMG
  zh: '![图像 21](index-156_1.png)'
- en: '*Figure 6-1: Creating, updating, and drawing 300 Ball objects*'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：创建、更新和绘制300个Ball对象*'
- en: The fact that we can instantiate any number of objects from a single
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从一个类实例化任意数量的对象
- en: script will be vital not only in defining game objects like spaceships, zom-
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本在定义游戏对象（如飞船、僵尸等）时至关重要，
- en: bies, bullets, treasures, and so on, but also in building GUI controls such
    as
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 干尸、子弹、宝物等等，也可用于构建GUI控件，如
- en: buttons, checkboxes, text input fields, and text outputs.
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮、复选框、文本输入框和文本输出框。
- en: '**Building a Reusable Object-Oriented Button**'
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建一个可重用的面向对象按钮**'
- en: The simple button is one of the most recognizable elements of a graphical
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 简单按钮是图形界面中最具辨识度的元素之一
- en: user interface. The standard behavior of a button consists of the user using
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面。按钮的标准行为是用户用鼠标点击按钮图像并释放它。
- en: their mouse to click down on the button image and then releasing it.
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 用户使用鼠标点击按钮图像并释放它。
- en: 'Buttons typically consist of at least two images: one to represent the *up*'
  id: totrans-1586
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮通常由至少两个图像组成：一个表示*按下*状态
- en: or normal state of the button and another to represent the *down* or pressed
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
- en: state of the button. The sequence of a click can be broken down into the
  id: totrans-1588
  prefs: []
  type: TYPE_NORMAL
- en: 'following steps:'
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
- en: 1\. User moves the mouse pointer over the button
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
- en: 2\. User presses the mouse button down
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Program reacts by changing the image to the down state
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
- en: 4\. User releases the mouse button
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Program reacts by showing the up image of the button
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Program performs some action based on the button click
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
- en: Good GUIs also allow the user to click down on a button, temporarily
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
- en: roll off the button, changing the button to the up state, and then, with the
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Pygame **127**
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
- en: mouse button still down, roll back over the image so the button changes back
    to the down image. If the user clicks down on a button but then rolls
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
- en: the mouse off and lifts up on the mouse button, that is not considered a
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
- en: click. This means the program takes action only when the user presses
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
- en: down and releases while the mouse is positioned over the image of a button.
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
- en: '***Building a Button Class***'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
- en: The button behavior should be common and consistent for all buttons used
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
- en: in a GUI, so we’ll build a class that takes care of the behavior details. Once
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
- en: we’ve built a simple button class, we can instantiate any number of buttons
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
- en: and they’ll all work exactly the same way.
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider what behaviors our button class must support. We’ll need
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
- en: 'methods to:'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
- en: • Load the images of the up and down states, then initialize any instance
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
- en: variables needed to track the button’s state.
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
- en: • Tell the button about all events that the main program has detected
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
- en: and check whether there are any that the button needs to react to.
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
- en: • Draw the current image representing the button.
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6-4 presents the code of a SimpleButton class. (We’ll build a
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
- en: more complicated button class i[n Chapter 7.) T](index_split_003.html#p172)his
    class has three methods, __init__(), handleEvent(), and draw(), that implement
    the behaviors mentioned. The code of the handleEvent() method does get a little
    tricky, but
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
- en: once you have it working, it’s incredibly easy to use. Feel free to work your
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
- en: way through it, but know that the implementation of the code is not that
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
- en: relevant. The important thing here is to understand the purpose and usage
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
- en: of the different methods.
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo7_SimpleButton/SimpleButton.py**'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
- en: SimpleButton class
  id: totrans-1622
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#'
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
- en: Uses a "state machine" approach
  id: totrans-1624
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#'
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
- en: import pygame
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
- en: 'class SimpleButton():'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
- en: Used to track the state of the button
  id: totrans-1629
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'STATE_IDLE = ''idle'' # button is up, mouse not over button'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
- en: 'STATE_ARMED = ''armed'' # button is down, mouse over button'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
- en: 'STATE_DISARMED = ''disarmed'' # clicked down on button, rolled off'
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window, loc, up, down): 1'
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  id: totrans-1634
  prefs: []
  type: TYPE_NORMAL
- en: self.loc = loc
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
- en: self.surfaceUp = pygame.image.load(up)
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
- en: '**128** Chapter 6'
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
- en: self.surfaceDown = pygame.image.load(down)
  id: totrans-1638
  prefs: []
  type: TYPE_NORMAL
- en: Get the rect of the button (used to see if the mouse is over the button)
  id: totrans-1639
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.rect = self.surfaceUp.get_rect()
  id: totrans-1640
  prefs: []
  type: TYPE_NORMAL
- en: self.rect[0] = loc[0]
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
- en: self.rect[1] = loc[1]
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
- en: self.state = SimpleButton.STATE_IDLE
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
- en: 'def handleEvent(self, eventObj): 2'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
- en: This method will return True if user clicks the button.
  id: totrans-1645
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally returns False.
  id: totrans-1646
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if eventObj.type not in (MOUSEMOTION, MOUSEBUTTONUP, MOUSEBUTTONDOWN): 3'
  id: totrans-1647
  prefs: []
  type: TYPE_NORMAL
- en: The button only cares about mouse-related events
  id: totrans-1648
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: return False
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
- en: eventPointInButtonRect = self.rect.collidepoint(eventObj.pos)
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.state == SimpleButton.STATE_IDLE:'
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
- en: 'if (eventObj.type == MOUSEBUTTONDOWN) and eventPointInButtonRect:'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
- en: self.state = SimpleButton.STATE_ARMED
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
- en: 'elif self.state == SimpleButton.STATE_ARMED:'
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
- en: 'if (eventObj.type == MOUSEBUTTONUP) and eventPointInButtonRect:'
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
- en: self.state = SimpleButton.STATE_IDLE
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
- en: 'return True # clicked!'
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
- en: 'if (eventObj.type == MOUSEMOTION) and (not eventPointInButtonRect):'
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
- en: self.state = SimpleButton.STATE_DISARMED
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
- en: 'elif self.state == SimpleButton.STATE_DISARMED:'
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
- en: 'if eventPointInButtonRect:'
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
- en: self.state = SimpleButton.STATE_ARMED
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
- en: 'elif eventObj.type == MOUSEBUTTONUP:'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
- en: self.state = SimpleButton.STATE_IDLE
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
- en: return False
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw(self): 4'
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
- en: Draw the button's current appearance to the window
  id: totrans-1667
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if self.state == SimpleButton.STATE_ARMED:'
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
- en: self.window.blit(self.surfaceDown, self.loc)
  id: totrans-1669
  prefs: []
  type: TYPE_NORMAL
- en: 'else: # IDLE or DISARMED'
  id: totrans-1670
  prefs: []
  type: TYPE_NORMAL
- en: self.window.blit(self.surfaceUp, self.loc)
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-4: The SimpleButton class*'
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() method begins by saving all values passed in into
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
- en: instance variables 1 to use in other methods. It then initializes a few
  id: totrans-1674
  prefs: []
  type: TYPE_NORMAL
- en: more instance variables.
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the main program detects any event, it calls the handleEvent()
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
- en: method 2\. This method first checks that the event is one of MOUSEMOTION,
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Pygame **129**
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 22](index-159_1.png)'
  id: totrans-1679
  prefs: []
  type: TYPE_IMG
- en: MOUSEBUTTONUP, or MOUSEBUTTONDOWN 3\. The rest of the method is implemented
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
- en: as a *state machine*, a technique that I will go into more detail about in
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 15\.](index_split_006.html#p340) The code is a little complicated,
    and you should feel free to study how it works, but for now note that it uses
    the instance variable'
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
- en: self.state (over the course of multiple calls) to detect if the user has
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
- en: clicked on the button. The handleEvent() method returns True when the
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
- en: user completes a mouse click by pressing down on the button, then later
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
- en: releasing on the same button. In all other cases, handleEvent() returns
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
- en: False.
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the draw() method uses the state of the object’s instance variable
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
- en: self.state to decide which image (up or down) to draw 4\.
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
- en: '***Main Code Using a SimpleButton***'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
- en: To use a SimpleButton in the main code, we first instantiate one from the
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
- en: 'SimpleButton class before the main loop starts with a line like this:'
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
- en: oButton = SimpleButton(window, (150, 30),
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonUp.png'','
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonDown.png'')'
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
- en: This line creates a SimpleButton object, specifying a location to draw
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
- en: it (as usual, the coordinates are for the top-left corner of the bounding
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
- en: rectangle) and providing the paths to both the up and down images of the
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
- en: button. In the main loop, any time any event happens we need to call the
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
- en: handleEvent() method to see if the user has clicked the button. If the user
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
- en: clicks the button, the program should perform some action. Also in the
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 用户点击按钮时，程序应执行某些操作。也在
- en: main loop, we need to call the draw() method to make the button show in
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环中，我们需要调用draw()方法来显示按钮。
- en: the window.
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口中。
- en: We’ll build a small test program, which will generate a user interface
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个小型测试程序，它将生成一个用户界面。
- en: like Figure 6-2, to incorporate one instance of a SimpleButton.
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: 如图6-2所示，加入一个SimpleButton实例。
- en: '*Figure 6-2: The user interface of a program with a single instance of a SimpleButton*
    Whenever the user completes a click on the button, the program'
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：一个包含单个SimpleButton实例的程序用户界面* 每当用户完成对按钮的点击时，程序'
- en: outputs a line of text in the shell saying that the button has been clicked.
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell中输出一行文本，表明按钮已被点击。
- en: Listing 6-5 contains the main program code.
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-5包含主程序代码。
- en: '**File: PygameDemo7_SimpleButton/Main_SimpleButton.py**'
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PygameDemo7_SimpleButton/Main_SimpleButton.py**'
- en: Pygame demo 7 - SimpleButton test
  id: totrans-1710
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pygame演示7 - SimpleButton测试
- en: '--- snip ---'
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: '--- 省略 ---'
- en: 5 - Initialize variables
  id: totrans-1712
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 - 初始化变量
- en: Create an instance of a SimpleButton
  id: totrans-1713
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建SimpleButton实例
- en: '**130** Chapter 6'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: '**130** 第六章'
- en: 1 oButton = SimpleButton(window, (150, 30),
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: 1 oButton = SimpleButton(window, (150, 30)，
- en: '''images/buttonUp.png'','
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/buttonUp.png''，'
- en: '''images/buttonDown.png'')'
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/buttonDown.png'')'
- en: 6 - Loop forever
  id: totrans-1718
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 - 永久循环
- en: 'while True:'
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 7 - Check for and handle events
  id: totrans-1720
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 - 检查并处理事件
- en: 'for event in pygame.event.get():'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: for event in pygame.event.get()：
- en: 'if event.type == pygame.QUIT:'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: 'if event.type == pygame.QUIT:'
- en: pygame.quit()
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.quit()
- en: sys.exit()
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: sys.exit()
- en: Pass the event to the button, see if it has been clicked on
  id: totrans-1725
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将事件传递给按钮，查看是否被点击
- en: '2 if oButton.handleEvent(event):'
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: '2 如果oButton.handleEvent(event):'
- en: 3 print('User has clicked the button')
  id: totrans-1727
  prefs: []
  type: TYPE_NORMAL
  zh: 3 print('用户已点击按钮')
- en: 8 - Do any "per frame" actions
  id: totrans-1728
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 - 执行任何“每帧”操作
- en: 9 - Clear the window
  id: totrans-1729
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9 - 清空窗口
- en: window.fill(GRAY)
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: window.fill(GRAY)
- en: 10 - Draw all window elements
  id: totrans-1731
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 - 绘制所有窗口元素
- en: '4 oButton.draw() # draw the button'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: '4 oButton.draw()  # 绘制按钮'
- en: 11 - Update the window
  id: totrans-1733
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11 - 更新窗口
- en: pygame.display.update()
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: pygame.display.update()
- en: 12 - Slow things down a bit
  id: totrans-1735
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 - 稍微减慢速度
- en: clock.tick(FRAMES_PER_SECOND)
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: clock.tick(FRAMES_PER_SECOND)
- en: '*Listing 6-5: The main program that creates and reacts to a SimpleButton*'
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表6-5：创建并响应SimpleButton的主程序*'
- en: Again, we start with the standard pygame template from [Chapter 5\.](#p118)
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们从[第5章](#p118)的标准pygame模板开始。
- en: Before the main loop, we create an instance of our SimpleButton 1, specify-
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环之前，我们创建一个SimpleButton 1的实例，并指定—
- en: ing a window to draw into, a location, a path to the up image, and a path to
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个窗口用于绘制，指定位置、上图像路径和
- en: the down image.
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: 按下图像。
- en: Every time through the main loop, we need to react to events detected
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: 每次进入主循环时，我们需要对检测到的事件做出反应。
- en: in the main program. To implement this, we call the SimpleButton class’s
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: 在主程序中。为了实现这一点，我们调用SimpleButton类的
- en: handleEvent() method 2 and pass in the event from the main program.
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: handleEvent()方法2并传入来自主程序的事件。
- en: The handleEvent() method tracks all of the user’s actions on the button
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: handleEvent()方法跟踪用户在按钮上的所有操作
- en: (pressing down, releasing, rolling off, rolling back on). When handleEvent()
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: （按下、释放、滚出、滚回）。当handleEvent()
- en: returns True, indicating that a click has occurred, we perform the action
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 返回True，表示已发生点击事件，我们执行相应的操作。
- en: associated with clicking that button. Here, we just print a message 3\.
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: 与点击该按钮相关的操作，这里我们只是在3中打印一条信息。
- en: Finally we call the button’s draw() method 4 to draw an image to repre-
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用按钮的draw()方法4，绘制一个表示
- en: sent the appropriate state of the button (up or down).
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: 发送按钮的相应状态（按下或释放）。
- en: '***Creating a Program with Multiple Buttons***'
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: '***创建一个包含多个按钮的程序***'
- en: With our SimpleButton class, we can instantiate as many buttons as we wish.
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的SimpleButton类，我们可以实例化任意数量的按钮。
- en: For example, we can modify our main program to incorporate three
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以修改我们的主程序，加入三个按钮。
- en: SimpleButton instances, as shown in Figure 6-3\.
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleButton实例，如图6-3所示。
- en: Object-Oriented Pygame **131**
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的Pygame **131**
- en: '![Image 23](index-161_1.png)'
  id: totrans-1756
  prefs: []
  type: TYPE_IMG
  zh: '![图23](index-161_1.png)'
- en: '*Figure 6-3: The main program with three SimpleButton objects*'
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：包含三个SimpleButton对象的主程序*'
- en: We don’t need to make any changes to the SimpleButton class file to
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要对SimpleButton类文件做任何修改来
- en: do this. We simply modify our main code to instantiate three SimpleButton
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做，只需要修改主程序代码以实例化三个SimpleButton
- en: objects instead of one.
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: 对象而不是一个。
- en: '**File: PygameDemo7_SimpleButton/Main_SimpleButton3Buttons.py**'
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PygameDemo7_SimpleButton/Main_SimpleButton3Buttons.py**'
- en: oButtonA = SimpleButton(window, (25, 30),
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: oButtonA = SimpleButton(window, (25, 30)，
- en: '''images/buttonAUp.png'','
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/buttonAUp.png''，'
- en: '''images/buttonADown.png'')'
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: '''images/buttonADown.png'')'
- en: oButtonB = SimpleButton(window, (150, 30),
  id: totrans-1765
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonBUp.png'','
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonBDown.png'')'
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
- en: oButtonC = SimpleButton(window, (275, 30),
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonCUp.png'','
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonCDown.png'')'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to call the handleEvent() method of all three buttons:'
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
- en: Pass the event to each button, see if one has been clicked
  id: totrans-1772
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if oButtonA.handleEvent(event):'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
- en: print('User clicked button A.')
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
- en: 'elif oButtonB.handleEvent(event):'
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
- en: print('User clicked button B.')
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
- en: 'elif oButtonC.handleEvent(event):'
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
- en: print('User clicked button C.')
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we tell each button to draw itself:'
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
- en: oButtonA.draw()
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
- en: oButtonB.draw()
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
- en: oButtonC.draw()
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
- en: When you run the program, you’ll see a window with three buttons.
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
- en: Clicking any of the buttons prints a message showing the name of the but-
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
- en: ton that was clicked.
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
- en: The key idea here is that since we are using three instances of the
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
- en: same SimpleButton class, the behavior of each button will be identical. An
  id: totrans-1787
  prefs: []
  type: TYPE_NORMAL
- en: important benefit of this approach is that any change to the code in the
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
- en: SimpleButton class will affect all buttons instantiated from the class. The
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
- en: main program does not need to worry about any details of the inner work-
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
- en: ings of the button code, needing only to call the handleEvent() method of
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
- en: each button in the main loop. Each button will return True or False to say
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
- en: that it has or has not been clicked.
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
- en: '**132** Chapter 6'
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
- en: '**Building a Reusable Object-Oriented Text Display**'
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different types of text in a pygame program: display text and'
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
- en: input text. Display text is output from your program, equivalent to a call to
    the
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
- en: print() function, except it’s displayed in a pygame window. Input text is string
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
- en: input from the user, equivalent to a call to input(). In this section, I’ll
    discuss display text. We’ll look at how to deal with input text in the next chapter.
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
- en: '***Steps to Display Text***'
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
- en: Displaying text in a window is a fairly complicated process in pygame
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
- en: because it’s not simply displayed as a string in the shell, but requires you
    to
  id: totrans-1802
  prefs: []
  type: TYPE_NORMAL
- en: choose a location, fonts and sizes, and other attributes. For example, you
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
- en: 'might use code like the following:'
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
- en: pygame.font.init()
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
- en: myFont = pygame.font.SysFont('Comic Sans MS', 30)
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
- en: textSurface = myfont.render('Some text', True, (0, 0, 0))
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
- en: window.blit(textSurface, (10, 10))
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
- en: We start by initializing the font system within pygame; we do this before
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
- en: the main loop starts. Then we tell pygame to load a particular font from the
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
- en: system by name. Here, we request Comic Sans with a font size of 30\.
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is the key one: we use that font to *render* our text, which'
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
- en: creates a graphical image of the text, called a *surface* in pygame. We supply
    the text we want to output, a Boolean that says whether we want our text to
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
- en: be anti-aliased, and a color in RGB format. Here, (0, 0, 0) indicates that
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
- en: we want our text to be black. Finally, using blit(), we draw the image of the
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
- en: text into the window at some (x, y) location.
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
- en: This code works well to show the provided text in the window at the
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
- en: given location. However, if the text doesn’t change, there will be a lot of
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
  zh: 给定位置的文本。然而，如果文本没有改变，每次迭代时都会有很多
- en: wasted work done re-creating the textSurface on each iteration through the
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代时重新创建 textSurface 是浪费工作，
- en: main loop. There are also a lot of details to remember, and you must get
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
  zh: 主循环。这里有很多细节需要记住，而且你必须确保
- en: them all correct to draw the text properly. We can hide most of this com-
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都正确地绘制文本。我们可以隐藏大部分实现的细节。
- en: plexity by building a class.
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建一个类来减少复杂度。
- en: '***Creating a SimpleText Class***'
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: '***创建一个 SimpleText 类***'
- en: The idea is to build a set of methods that take care of font loading and text
  id: totrans-1824
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是构建一组方法，处理字体加载和文本
- en: rendering in pygame, meaning we no longer have to remember the details
  id: totrans-1825
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pygame 中进行渲染，这意味着我们不再需要记住实现的细节
- en: of the implementation. Listing 6-6 contains a new class called SimpleText
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的细节。列表 6-6 包含一个新类，叫做 SimpleText
- en: that does this work.
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此工作的功能。
- en: '**File: PygameDemo8_SimpleTextDisplay/SimpleText.py**'
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件：PygameDemo8_SimpleTextDisplay/SimpleText.py**'
- en: SimpleText class
  id: totrans-1829
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SimpleText 类
- en: import pygame
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: import pygame
- en: from pygame.locals import *
  id: totrans-1831
  prefs: []
  type: TYPE_NORMAL
  zh: from pygame.locals import *
- en: Object-Oriented Pygame **133**
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的 Pygame **133**
- en: 'class SimpleText():'
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
  zh: 'class SimpleText():'
- en: '1 def __init__(self, window, loc, value, textColor):'
  id: totrans-1834
  prefs: []
  type: TYPE_NORMAL
  zh: '1 def __init__(self, window, loc, value, textColor):'
- en: 2 pygame.font.init()
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: 2 pygame.font.init()
- en: self.window = window
  id: totrans-1836
  prefs: []
  type: TYPE_NORMAL
  zh: self.window = window
- en: self.loc = loc
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
  zh: self.loc = loc
- en: 3 self.font = pygame.font.SysFont(None, 30)
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: 3 self.font = pygame.font.SysFont(None, 30)
- en: self.textColor = textColor
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: self.textColor = textColor
- en: 'self.text = None # so that the call to setText below will'
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.text = None # 这样下面调用 setText 时将'
- en: force the creation of the text image
  id: totrans-1841
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制创建文本图像
- en: 'self.setValue(value) # set the initial text for drawing'
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.setValue(value) # 设置绘制的初始文本'
- en: '4 def setValue(self, newText):'
  id: totrans-1843
  prefs: []
  type: TYPE_NORMAL
  zh: '4 def setValue(self, newText):'
- en: 'if self.text == newText:'
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 self.text == newText:'
- en: 'return # nothing to change'
  id: totrans-1845
  prefs: []
  type: TYPE_NORMAL
  zh: 'return # 无需更改'
- en: 'self.text = newText # save the new text'
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: 'self.text = newText # 保存新文本'
- en: self.textSurface = self.font.render(self.text, True, self.textColor)
  id: totrans-1847
  prefs: []
  type: TYPE_NORMAL
  zh: self.textSurface = self.font.render(self.text, True, self.textColor)
- en: '5 def draw(self):'
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
  zh: '5 def draw(self):'
- en: self.window.blit(self.textSurface, self.loc)
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: self.window.blit(self.textSurface, self.loc)
- en: '*Listing 6-6: The SimpleText class for displaying text*'
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 6-6：用于显示文本的 SimpleText 类*'
- en: You can think of a SimpleText object as a field in the window where you
  id: totrans-1851
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把 SimpleText 对象看作是窗口中的一个字段，在那里你
- en: want text to be displayed. You can use one to display unchanging label text
  id: totrans-1852
  prefs: []
  type: TYPE_NORMAL
  zh: 希望显示文本。你可以用它来显示不变的标签文本
- en: or to display text that changes throughout a program.
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
  zh: 或显示在程序中不断变化的文本。
- en: The SimpleText class has only three methods. The __init__() method 1
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
  zh: SimpleText 类只有三个方法。__init__() 方法 1
- en: expects the window to draw into, the location at which to draw the text in
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
  zh: 预期窗口会绘制的内容、绘制文本的位置
- en: the window, any initial text you want to see displayed in the field, and a text
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
  zh: 窗口、任何你想在字段中显示的初始文本以及文本
- en: color. Calling pygame.font.init() 2 starts up pygame’s font system. The call
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色。调用 pygame.font.init() 2 启动 pygame 的字体系统。此调用
- en: in the first instantiated SimpleText object actually does the initialization;
    any
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个实例化的 SimpleText 对象中实际上执行了初始化；任何
- en: additional SimpleText objects will also make this call, but since fonts have
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的 SimpleText 对象也会进行此调用，但由于字体已
- en: already been initialized, the call returns immediately. We create a new Font
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经初始化，此调用会立即返回。我们创建一个新的 Font
- en: object with pygame.font.SysFont() 3\. Rather than providing a specific font
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pygame.font.SysFont() 3 创建对象。与其提供特定的字体
- en: name, None indicates that we will use whatever the standard system font is.
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: name, None 表示我们将使用系统默认字体。
- en: The setValue() method renders an image of the text to display and saves
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
  zh: setValue() 方法渲染文本的图像以供显示，并保存
- en: that image in the self.textSurface instance variable 4\. As the program runs,
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
  zh: 该图像保存在 self.textSurface 实例变量中 4。随着程序的运行，
- en: any time you want to change the text that’s displayed, you call the setValue()
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你想更改显示的文本时，调用 setValue()
