- en: method call raises an AbortTransaction exception, control will be transferred
  prefs: []
  type: TYPE_NORMAL
- en: to the except statement 4\.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions are objects. In the except clause, we handle the AbortTransaction
  prefs: []
  type: TYPE_NORMAL
- en: exception that was raised at any lower level. We assign the value of the
  prefs: []
  type: TYPE_NORMAL
- en: '**82** Chapter 4'
  prefs: []
  type: TYPE_NORMAL
- en: exception to the variable error. When we print that variable, the user will
    see the associated error message. Since the exception was handled in the
  prefs: []
  type: TYPE_NORMAL
- en: except clause, the program continues running, and the user is asked what
  prefs: []
  type: TYPE_NORMAL
- en: they wish to do.
  prefs: []
  type: TYPE_NORMAL
- en: '**Calling the Same Method on a List of Objects**'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike in our bank example, in cases where individual objects do not need
  prefs: []
  type: TYPE_NORMAL
- en: to be uniquely identified, using a list of objects works extremely well. Let’s
  prefs: []
  type: TYPE_NORMAL
- en: say you’re coding a game and you need to have some number of bad guys,
  prefs: []
  type: TYPE_NORMAL
- en: spaceships, bullets, zombies, or whatever else. Each such object will typically
  prefs: []
  type: TYPE_NORMAL
- en: have some data it remembers and some actions it can perform. As long as
  prefs: []
  type: TYPE_NORMAL
- en: each object does not require a unique identifier, the standard way to handle
  prefs: []
  type: TYPE_NORMAL
- en: this is to create many instances of the object from the class and put all the
  prefs: []
  type: TYPE_NORMAL
- en: 'objects into a list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'objectList = [] # start off with an empty list'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(nObjects):'
  prefs: []
  type: TYPE_NORMAL
- en: 'oNewObject = MyClass() # create a new instance'
  prefs: []
  type: TYPE_NORMAL
- en: 'objectList.append(oNewObject) # store the object in the list'
  prefs: []
  type: TYPE_NORMAL
- en: In our game, we represent a world as a large grid, like a spreadsheet.
  prefs: []
  type: TYPE_NORMAL
- en: We want monsters placed at random locations in the grid. Listing 4-12
  prefs: []
  type: TYPE_NORMAL
- en: shows the start of a Monster class with its __init__() method and a move()
  prefs: []
  type: TYPE_NORMAL
- en: method. When a Monster is instantiated, it is told the number of rows and
  prefs: []
  type: TYPE_NORMAL
- en: columns in the grid and the maximum speed, and it chooses a random
  prefs: []
  type: TYPE_NORMAL
- en: starting location and speed.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: MonsterExample.py**'
  prefs: []
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: class Monster()
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, nRows, nCols, maxSpeed):'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.nRows = nRows # save away'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.nCols = nCols # save away'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.myRow = random.randrange(self.nRows) # chooses a random row'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.myCol = random.randrange(self.nCols) # chooses a random col'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.mySpeedX = random.randrange(-maxSpeed, maxSpeed + 1) # chooses an X speed'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.mySpeedY = random.randrange(-maxSpeed, maxSpeed + 1) # chooses a Y speed'
  prefs: []
  type: TYPE_NORMAL
- en: Set other instance variables like health, power, etc.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def move(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.myRow = (self.myRow + self.mySpeedY) % self.nRows
  prefs: []
  type: TYPE_NORMAL
- en: self.myCol = (self.myCol + self.mySpeedX) % self.nCols
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 4-12: A Monster class that can be used to instantiate many Monsters*'
  prefs: []
  type: TYPE_NORMAL
- en: Managing Multiple Objects **83**
  prefs: []
  type: TYPE_NORMAL
- en: 'With this Monster class, we can create a list of Monster objects like this:
    N_MONSTERS = 20'
  prefs: []
  type: TYPE_NORMAL
- en: 'N_ROWS = 100 # could be any size'
  prefs: []
  type: TYPE_NORMAL
- en: 'N_COLS = 200 # could be any size'
  prefs: []
  type: TYPE_NORMAL
- en: MAX_SPEED = 4
  prefs: []
  type: TYPE_NORMAL
- en: 'monsterList = [] # start with an empty list'
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(N_MONSTERS):'
  prefs: []
  type: TYPE_NORMAL
- en: 'oMonster = Monster(N_ROWS, N_COLS, MAX_SPEED) # create a Monster'
  prefs: []
  type: TYPE_NORMAL
- en: 'monsterList.append(oMonster) # add the Monster to our list'
  prefs: []
  type: TYPE_NORMAL
- en: This loop will instantiate 20 Monsters, and each will know its own start-
  prefs: []
  type: TYPE_NORMAL
- en: ing location in the grid and its individual speed. Once you have a list of
  prefs: []
  type: TYPE_NORMAL
- en: objects, later in the program when you want each object to do the same
  prefs: []
  type: TYPE_NORMAL
- en: action, you can write a simple loop where you call the same method of each
  prefs: []
  type: TYPE_NORMAL
- en: 'object in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for objectVariable in objectVariablesList:'
  prefs: []
  type: TYPE_NORMAL
- en: objectVariable.someMethod()
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we want each of our Monster objects to move, we could
  prefs: []
  type: TYPE_NORMAL
- en: 'use a loop like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'for oMonster in monsterList:'
  prefs: []
  type: TYPE_NORMAL
- en: oMonster.move()
  prefs: []
  type: TYPE_NORMAL
- en: Since each Monster object remembers its location and speed, in the
  prefs: []
  type: TYPE_NORMAL
- en: move() method, each Monster can move to and remember its new location.
  prefs: []
  type: TYPE_NORMAL
- en: This technique of building a list of objects and calling the same
  prefs: []
  type: TYPE_NORMAL
- en: method of all objects in the list is extremely useful, and it’s a standard
  prefs: []
  type: TYPE_NORMAL
- en: approach to dealing with a collection of similar objects. We will use this
  prefs: []
  type: TYPE_NORMAL
- en: approach quite often when we get to building games using pygame later.
  prefs: []
  type: TYPE_NORMAL
- en: '**Interface vs. Implementation**'
  prefs: []
  type: TYPE_NORMAL
- en: Our earlier Account class seems to have methods and instance variables that
  prefs: []
  type: TYPE_NORMAL
- en: work well. When you’re confident your code is working well, you no longer
  prefs: []
  type: TYPE_NORMAL
- en: have to be concerned with the details within the class. When a class does
  prefs: []
  type: TYPE_NORMAL
- en: what you want it to do, all you need to remember is what methods are avail-
  prefs: []
  type: TYPE_NORMAL
- en: 'able in the class. There are two different ways to look at a class: by focusing'
  prefs: []
  type: TYPE_NORMAL
- en: on what it is capable of doing (the *interface*) and how it works internally
    (the *implementation*).
  prefs: []
  type: TYPE_NORMAL
- en: '**interface**'
  prefs: []
  type: TYPE_NORMAL
- en: The col ection of methods a class provides (and the parameters that each method
  prefs: []
  type: TYPE_NORMAL
- en: expects) . The interface shows *what* an object created from the class can do
    .
  prefs: []
  type: TYPE_NORMAL
- en: '**implementation** The actual code of the class, which shows *how* an object
    does what it does .'
  prefs: []
  type: TYPE_NORMAL
- en: '**84** Chapter 4'
  prefs: []
  type: TYPE_NORMAL
- en: If you are the creator or maintainer of a class, you need to fully understand
    the implementation—the code of all of the methods and how they
  prefs: []
  type: TYPE_NORMAL
- en: work together to affect the instance variables. If you are purely writing code
  prefs: []
  type: TYPE_NORMAL
- en: to *use* a class, you only need to concern yourself with the interface—the
  prefs: []
  type: TYPE_NORMAL
- en: different methods that are available in the class, the values that need to be
  prefs: []
  type: TYPE_NORMAL
- en: passed into each, and any value(s) that are returned from the methods. If
  prefs: []
  type: TYPE_NORMAL
- en: you are coding on your own (as a “one-person team”), then you will be both
  prefs: []
  type: TYPE_NORMAL
- en: the implementer of a class and the user of its interface.
  prefs: []
  type: TYPE_NORMAL
- en: As long as the interface of a class does not change, the class’s imple-
  prefs: []
  type: TYPE_NORMAL
- en: mentation can change at any time. That is, if you find that a method can be
  prefs: []
  type: TYPE_NORMAL
- en: implemented in a faster or more efficient way, changing the relevant code
  prefs: []
  type: TYPE_NORMAL
- en: inside the class will not have any bad side effects on any other part of the
  prefs: []
  type: TYPE_NORMAL
- en: program.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: An object manager object is an object that manages other objects. It does
  prefs: []
  type: TYPE_NORMAL
- en: this by having one or more instance variables that are lists or dictionaries
  prefs: []
  type: TYPE_NORMAL
- en: made up of other objects. The object manager can call methods of any spe-
  prefs: []
  type: TYPE_NORMAL
- en: cific object or of all managed objects. This technique gives full control of
  prefs: []
  type: TYPE_NORMAL
- en: all managed objects to the object manager alone.
  prefs: []
  type: TYPE_NORMAL
- en: When you encounter an error in a method or function, you can raise an
  prefs: []
  type: TYPE_NORMAL
- en: exception. The raise statement returns control to the caller. The caller can
  prefs: []
  type: TYPE_NORMAL
- en: detect a potential error by placing the call in a try block, and it can react
    to
  prefs: []
  type: TYPE_NORMAL
- en: any such error using an except block.
  prefs: []
  type: TYPE_NORMAL
- en: The interface of a class is the documentation of all the methods and
  prefs: []
  type: TYPE_NORMAL
- en: related parameters in the class. The implementation is the actual code
  prefs: []
  type: TYPE_NORMAL
- en: of the class. What you need to know depends on your role. The writer/
  prefs: []
  type: TYPE_NORMAL
- en: maintainer of a class needs to understand the details of the code, whereas
  prefs: []
  type: TYPE_NORMAL
- en: anyone who uses the class only needs to understand the interface that the
  prefs: []
  type: TYPE_NORMAL
- en: class provides.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Multiple Objects **85**
  prefs: []
  type: TYPE_NORMAL
- en: '**PART II**'
  prefs: []
  type: TYPE_NORMAL
- en: '**G R A P H I C A L U S E R**'
  prefs: []
  type: TYPE_NORMAL
- en: '**I N T E R F A C E S W I T H P Y G A M E**'
  prefs: []
  type: TYPE_NORMAL
- en: These chapters introduce you to *pygame,* an external
  prefs: []
  type: TYPE_NORMAL
- en: package that adds functionality common to GUI pro-
  prefs: []
  type: TYPE_NORMAL
- en: grams. Pygame allows you to write Python programs
  prefs: []
  type: TYPE_NORMAL
- en: that have windows, respond to the mouse and key-
  prefs: []
  type: TYPE_NORMAL
- en: board, play sounds, and more.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5 g](#p118)ives you a basic understanding of how pygame works and
    provides a standard template for building pygame-based programs. We’ll'
  prefs: []
  type: TYPE_NORMAL
- en: build a few simple programs first, create a program that controls an image
  prefs: []
  type: TYPE_NORMAL
- en: with the keyboard, then we’ll build a ball-bouncing program.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6 e](#p150)xplains how pygame can best be used as an object-oriented
    framework. You’ll see how to rewrite the ball-bouncing program using'
  prefs: []
  type: TYPE_NORMAL
- en: object-oriented techniques, and develop simple buttons and text input
  prefs: []
  type: TYPE_NORMAL
- en: fields.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7 d](index_split_003.html#p172)escribes the pygwidgets module, which
    contains full implementations of many standard user interface widgets like buttons,
    input'
  prefs: []
  type: TYPE_NORMAL
- en: and output fields, radio buttons, checkboxes, and more, all using object-
  prefs: []
  type: TYPE_NORMAL
- en: oriented programming. All the code is available for you so that you can use
  prefs: []
  type: TYPE_NORMAL
- en: it to build your own applications. I’ll provide several examples.
  prefs: []
  type: TYPE_NORMAL
- en: '**5**'
  prefs: []
  type: TYPE_NORMAL
- en: '**I N T R O D U C T I O N T O P Y G A M E**'
  prefs: []
  type: TYPE_NORMAL
- en: The Python language was designed to han-
  prefs: []
  type: TYPE_NORMAL
- en: dle text input and text output. It provides
  prefs: []
  type: TYPE_NORMAL
- en: the ability to get text from and send text to
  prefs: []
  type: TYPE_NORMAL
- en: the user, a file, and the internet. The core lan-
  prefs: []
  type: TYPE_NORMAL
- en: guage, however, has no way of dealing with more mod-
  prefs: []
  type: TYPE_NORMAL
- en: ern concepts such as windows, mouse clicks, sounds,
  prefs: []
  type: TYPE_NORMAL
- en: and so on. So, what if you want to use Python to create
  prefs: []
  type: TYPE_NORMAL
- en: something more state-of-the-art than a text-based program? In this chapter
  prefs: []
  type: TYPE_NORMAL
- en: I’ll introduce *pygame*, a free open source external package that was designed
    to extend Python to allow programmers to build game programs. You can
  prefs: []
  type: TYPE_NORMAL
- en: also use pygame to build other kinds of interactive programs with a graphi-
  prefs: []
  type: TYPE_NORMAL
- en: cal user interface (GUI). It adds the ability to create windows, show images,
  prefs: []
  type: TYPE_NORMAL
- en: recognize mouse move ments and clicks, play sounds, and more. In short, it
  prefs: []
  type: TYPE_NORMAL
- en: allows Python programmers to build the types of games and applications
  prefs: []
  type: TYPE_NORMAL
- en: that current computer users have become familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: It is not my intent to turn you all into game programmers—even though
  prefs: []
  type: TYPE_NORMAL
- en: that might be a fun outcome. Rather, I’ll use the pygame environment to
  prefs: []
  type: TYPE_NORMAL
- en: make certain object-oriented programming techniques clearer and more visual.
    By working with pygame to make objects visible in a window and
  prefs: []
  type: TYPE_NORMAL
- en: dealing with a user interacting with those objects, you should gain a deeper
  prefs: []
  type: TYPE_NORMAL
- en: understanding of how to effectively use OOP techniques.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides a general introduction to pygame, so most of the
  prefs: []
  type: TYPE_NORMAL
- en: information and examples in this chapter will use procedural coding. Starting
  prefs: []
  type: TYPE_NORMAL
- en: with the next chapter, I will explain how to use OOP effectively with pygame.
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing Pygame**'
  prefs: []
  type: TYPE_NORMAL
- en: Pygame is a free downloadable package. We’ll use the package manager
  prefs: []
  type: TYPE_NORMAL
- en: '*pip* (short for *pip installs packages*) to install Python packages. As mentioned
    in the Introduction, I am assuming that you have installed the official version
    of Python from *python.org*. The pip program is included as part of that download,
    so you should already have it installed.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike a standard application, you must run pip from the command
  prefs: []
  type: TYPE_NORMAL
- en: line. On a Mac, start the Terminal application (located in the *Utilities*
  prefs: []
  type: TYPE_NORMAL
- en: subfolder inside the *Applications* folder). On a Windows system, click the
  prefs: []
  type: TYPE_NORMAL
- en: Windows icon, type **cmd**, and press ENTER.
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  prefs: []
  type: TYPE_NORMAL
- en: '*This book was not tested with Linux systems. However, most, if not all, of
    the content* *should work with minimal tweaking. To install pygame on a Linux
    distribution,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*open a terminal in whatever way you’re used to.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following commands at the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: python3 -m pip install -U pip --user
  prefs: []
  type: TYPE_NORMAL
- en: python3 -m pip install -U pygame --user
  prefs: []
  type: TYPE_NORMAL
- en: The first command ensures that you have the latest version of the pip
  prefs: []
  type: TYPE_NORMAL
- en: program. The second line installs the most recent version of pygame.
  prefs: []
  type: TYPE_NORMAL
- en: If you have any problems installing pygame, consult the pygame docu-
  prefs: []
  type: TYPE_NORMAL
- en: mentation at [*https://www.pygame.org/wiki/GettingStarted*](https://www.pygame.org/wiki/GettingStarted).
    To test that pygame has been installed correctly, open IDLE (the development environment
    that
  prefs: []
  type: TYPE_NORMAL
- en: is bundled with the default implementation of Python), and in the shell win-
  prefs: []
  type: TYPE_NORMAL
- en: 'dow enter:'
  prefs: []
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: If you see a message saying something like “Hello from the pygame
  prefs: []
  type: TYPE_NORMAL
- en: community” or if you get no message at all, then pygame has been installed
  prefs: []
  type: TYPE_NORMAL
- en: correctly. The lack of an error message indicates that Python has been able
  prefs: []
  type: TYPE_NORMAL
- en: to find and load the pygame package and it’s ready to use. If you would like
  prefs: []
  type: TYPE_NORMAL
- en: to see a sample game using pygame, enter the following command (which
  prefs: []
  type: TYPE_NORMAL
- en: 'starts a version of *Space Invaders*):'
  prefs: []
  type: TYPE_NORMAL
- en: python3 -m pygame.examples.aliens
  prefs: []
  type: TYPE_NORMAL
- en: '**90** Chapter 5'
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into using pygame, I need to explain two important concepts. First,
    I’ll explain how individual pixels are addressed in programs
  prefs: []
  type: TYPE_NORMAL
- en: that use a GUI. Then, I’ll discuss event-driven programs and how they dif-
  prefs: []
  type: TYPE_NORMAL
- en: fer from typical text-based programs. After that, we’ll code a few programs
  prefs: []
  type: TYPE_NORMAL
- en: that demonstrate key pygame features.
  prefs: []
  type: TYPE_NORMAL
- en: '**Window Details**'
  prefs: []
  type: TYPE_NORMAL
- en: A computer screen is made up of a large number of rows and columns of
  prefs: []
  type: TYPE_NORMAL
- en: small dots called *pixels* (from the words *picture element*). A user interacts
    with a GUI program through one or more windows; each window is a rectangular portion
    of the screen. Programs can control the color of any individual
  prefs: []
  type: TYPE_NORMAL
- en: pixel in their window(s). If you’re running multiple GUI programs, each
  prefs: []
  type: TYPE_NORMAL
- en: program is typically displayed in its own window. In this section, I’ll discuss
  prefs: []
  type: TYPE_NORMAL
- en: how you address and alter individual pixels in a window. These concepts are
  prefs: []
  type: TYPE_NORMAL
- en: independent of Python; they are common to all computers and are used in
  prefs: []
  type: TYPE_NORMAL
- en: all programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Window Coordinate System***'
  prefs: []
  type: TYPE_NORMAL
- en: You are probably familiar with Cartesian coordinates in a grid like Figure 5-1\.
  prefs: []
  type: TYPE_NORMAL
- en: y–axis
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: x–axis
  prefs: []
  type: TYPE_NORMAL
- en: –6 –5 –4 –3 –2 –1
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: –1
  prefs: []
  type: TYPE_NORMAL
- en: –2
  prefs: []
  type: TYPE_NORMAL
- en: –3
  prefs: []
  type: TYPE_NORMAL
- en: –4
  prefs: []
  type: TYPE_NORMAL
- en: –5
  prefs: []
  type: TYPE_NORMAL
- en: –6
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5-1: The standard Cartesian coordinate system*'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pygame **91**
  prefs: []
  type: TYPE_NORMAL
- en: Any point in a Cartesian grid can be located by specifying its x- and y-coordinates
    (in that order). The origin is the point specified as (0, 0) and
  prefs: []
  type: TYPE_NORMAL
- en: is found in the center of the grid.
  prefs: []
  type: TYPE_NORMAL
- en: Computer window coordinates work in a similar way (Figure 5-2).
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: Max x
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: Max y
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5-2: A computer window’s coordinate system*'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are a few key differences:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. The origin (0, 0) point is in the upper-left corner of the window.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. The y-axis is reversed so that y values start at zero at the top of the
    win-
  prefs: []
  type: TYPE_NORMAL
- en: dow and increase as you go down.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. The x and y values are always integers. Each (x, y) pair specifies a single
  prefs: []
  type: TYPE_NORMAL
- en: pixel in the window. These values are always specified as relative to the
  prefs: []
  type: TYPE_NORMAL
- en: upper-left corner of the window, not the screen. That way, the user can
  prefs: []
  type: TYPE_NORMAL
- en: move the window anywhere on the screen without affecting the coordi-
  prefs: []
  type: TYPE_NORMAL
- en: nates of the elements of the program displayed in the window.
  prefs: []
  type: TYPE_NORMAL
- en: The full computer screen has its own set of (x, y) coordinates for every
  prefs: []
  type: TYPE_NORMAL
- en: pixel and uses the same type of coordinate system, but programs rarely, if
  prefs: []
  type: TYPE_NORMAL
- en: ever, need to deal with screen coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: When we write a pygame application, we need to specify the width and
  prefs: []
  type: TYPE_NORMAL
- en: height of the window we want to create. Within the window, we can address
  prefs: []
  type: TYPE_NORMAL
- en: any pixel using its x- and y-coordinates, as shown in Figure 5-3\.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-3 shows a black pixel at position (3, 5). That is an x-value of 3
  prefs: []
  type: TYPE_NORMAL
- en: (note that this is actually the fourth column, since coordinates start at 0)
  prefs: []
  type: TYPE_NORMAL
- en: and a y value of 5 (actually the sixth row). Each pixel in a window is com-
  prefs: []
  type: TYPE_NORMAL
- en: monly referred to as a *point*. To reference a point in a window, you would
  prefs: []
  type: TYPE_NORMAL
- en: typically use a Python tuple. For example, you might have an assignment
  prefs: []
  type: TYPE_NORMAL
- en: 'statement like this, with the x value first:'
  prefs: []
  type: TYPE_NORMAL
- en: pixelLocation = (3, 5)
  prefs: []
  type: TYPE_NORMAL
- en: '**92** Chapter 5'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: 10 11 12 13 …
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5-3: A single point (a single pixel) in a computer window*'
  prefs: []
  type: TYPE_NORMAL
- en: To show an image in a window, we need to specify the coordinates of its
  prefs: []
  type: TYPE_NORMAL
- en: starting point—always the upper-left corner of the image—as an (x, y) pair,
  prefs: []
  type: TYPE_NORMAL
- en: as in Figure 5-4, where we draw the image at location (3, 5).
  prefs: []
  type: TYPE_NORMAL
- en: When working with an image, you’ll often need to deal with the
  prefs: []
  type: TYPE_NORMAL
- en: '*bounding rectangle*, which is the smallest rectangle that can be made that'
  prefs: []
  type: TYPE_NORMAL
- en: completely surrounds all pixels of the image. A rectangle is represented
  prefs: []
  type: TYPE_NORMAL
- en: 'in pygame by a set of four values: x, y, width, height. The rectangle for'
  prefs: []
  type: TYPE_NORMAL
- en: the image in Figure 5-4 has values of 3, 5, 11, 7\. I’ll show you how to use
  prefs: []
  type: TYPE_NORMAL
- en: a rectangle like this in an upcoming example program. Even if your
  prefs: []
  type: TYPE_NORMAL
- en: image is not rectangular (for example, if it’s a circle or an ellipse), you
  prefs: []
  type: TYPE_NORMAL
- en: still have to consider its bounding rectangle for positioning and collision
  prefs: []
  type: TYPE_NORMAL
- en: detection.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pygame **93**
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: 10 11 12 13 …
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: '3'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '6'
  prefs: []
  type: TYPE_NORMAL
- en: '7'
  prefs: []
  type: TYPE_NORMAL
- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: '9'
  prefs: []
  type: TYPE_NORMAL
- en: '10'
  prefs: []
  type: TYPE_NORMAL
- en: '11'
  prefs: []
  type: TYPE_NORMAL
- en: '12'
  prefs: []
  type: TYPE_NORMAL
- en: '13'
  prefs: []
  type: TYPE_NORMAL
- en: …
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5-4: An image in a window*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Pixel Colors***'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore how colors are represented on the computer screen. If you
  prefs: []
  type: TYPE_NORMAL
- en: have experience with a graphics program like Photoshop, you probably
  prefs: []
  type: TYPE_NORMAL
- en: already know how this works, but you may want a quick refresher anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each pixel on the screen is made up of a combination of three colors:'
  prefs: []
  type: TYPE_NORMAL
- en: red, green, and blue, often referred to as *RGB*. The color displayed in
  prefs: []
  type: TYPE_NORMAL
- en: any pixel is composed of some amount of red, green, and blue, where the
  prefs: []
  type: TYPE_NORMAL
- en: amount of each is specified as a value from 0, meaning none, to 255, mean-
  prefs: []
  type: TYPE_NORMAL
- en: ing full intensity. Therefore, there are 256 × 256 × 256 possible combina-
  prefs: []
  type: TYPE_NORMAL
- en: tions, or 16,777,216 (often referred to as just “16 million”) possible colors,
  prefs: []
  type: TYPE_NORMAL
- en: for each pixel.
  prefs: []
  type: TYPE_NORMAL
- en: Colors in pygame are given as RGB values, and we write them as Python
  prefs: []
  type: TYPE_NORMAL
- en: 'tuples of three numbers. Here is how we create constants for the main colors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'RED = (255, 0, 0) # full red, no green, no blue'
  prefs: []
  type: TYPE_NORMAL
- en: 'GREEN = (0, 255, 0) # no red, full green, no blue'
  prefs: []
  type: TYPE_NORMAL
- en: 'BLUE = (0, 0, 255) # no red, no green, full blue'
  prefs: []
  type: TYPE_NORMAL
- en: '**94** Chapter 5'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the definitions of a few more colors. You can create a color using
    any combination of three numbers between 0 and 255:'
  prefs: []
  type: TYPE_NORMAL
- en: 'BLACK = (0, 0, 0) # no red, no green, no blue'
  prefs: []
  type: TYPE_NORMAL
- en: 'WHITE = (255, 255, 255) # full red, full green, full blue'
  prefs: []
  type: TYPE_NORMAL
- en: DARK_GRAY = (75, 75, 75)
  prefs: []
  type: TYPE_NORMAL
- en: MEDIUM_GRAY = (128, 128, 128)
  prefs: []
  type: TYPE_NORMAL
- en: LIGHT_GRAY = (175, 175, 175)
  prefs: []
  type: TYPE_NORMAL
- en: 'TEAL = (0, 128, 128) # no red, half-strength green, half-strength blue'
  prefs: []
  type: TYPE_NORMAL
- en: YELLOW = (255, 255, 0)
  prefs: []
  type: TYPE_NORMAL
- en: PURPLE = (128, 0, 128)
  prefs: []
  type: TYPE_NORMAL
- en: In pygame, you’ll need to specify colors when you want to fill the back-
  prefs: []
  type: TYPE_NORMAL
- en: ground of a window, draw a shape in a color, draw text in a color, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Defining colors up front as tuple constants makes them very easy to spot
  prefs: []
  type: TYPE_NORMAL
- en: later in code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Event-Driven Programs**'
  prefs: []
  type: TYPE_NORMAL
- en: In most of the programs in the book so far, the main code has lived in a
  prefs: []
  type: TYPE_NORMAL
- en: while loop. The program stops at a call to the built-in input() function and
  prefs: []
  type: TYPE_NORMAL
- en: waits for some user input to work on. Program output is typically handled
  prefs: []
  type: TYPE_NORMAL
- en: using calls to print().
  prefs: []
  type: TYPE_NORMAL
- en: In interactive GUI programs, this model no longer works. GUIs intro-
  prefs: []
  type: TYPE_NORMAL
- en: duce a new model of computing known as the *event-driven* model. Event-
  prefs: []
  type: TYPE_NORMAL
- en: driven programs don’t rely on input() and print(); instead, the user interacts
  prefs: []
  type: TYPE_NORMAL
- en: with elements in a window at will using a keyboard and/or mouse or other
  prefs: []
  type: TYPE_NORMAL
- en: pointing device. They may be able to click various buttons or icons, make
  prefs: []
  type: TYPE_NORMAL
- en: selections from menus, provide input in text fields, or give commands via
  prefs: []
  type: TYPE_NORMAL
- en: clicks or key presses to control some avatar in the window.
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Calls to print() can still be highly useful for debugging, when used to write
    out intermediate results.*'
  prefs: []
  type: TYPE_NORMAL
- en: Central to event-driven programming is the concept of an *event*. Events
  prefs: []
  type: TYPE_NORMAL
- en: are difficult to define and are best described with examples, such as a mouse
  prefs: []
  type: TYPE_NORMAL
- en: 'click and a key press (each of which is actually made up of two events: mouse'
  prefs: []
  type: TYPE_NORMAL
- en: down and mouse up and key down and key up, respectively). Here is my
  prefs: []
  type: TYPE_NORMAL
- en: working definition.
  prefs: []
  type: TYPE_NORMAL
- en: '**event**'
  prefs: []
  type: TYPE_NORMAL
- en: Something that happens while your program is running that your program wants
    to
  prefs: []
  type: TYPE_NORMAL
- en: or needs to respond to . Most events are generated by user actions .
  prefs: []
  type: TYPE_NORMAL
- en: An event-driven GUI program runs constantly in an infinite loop. Each
  prefs: []
  type: TYPE_NORMAL
- en: time through the loop, the program checks for any new events it needs to
  prefs: []
  type: TYPE_NORMAL
- en: react to and executes appropriate code to handle those events. Also, each
  prefs: []
  type: TYPE_NORMAL
- en: time through the loop, the program needs to redraw all the elements in the
  prefs: []
  type: TYPE_NORMAL
- en: window to update what the user sees.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pygame **95**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 18](index-125_1.png)'
  prefs: []
  type: TYPE_IMG
- en: For example, say we have a simple GUI program that displays two but-
  prefs: []
  type: TYPE_NORMAL
- en: 'tons: Bark and Meow. When clicked, the Bark button plays a sound of a dog'
  prefs: []
  type: TYPE_NORMAL
- en: barking and the Meow button plays a sound of a cat meowing (Figure 5-5).
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5-5: A simple program*'
  prefs: []
  type: TYPE_NORMAL
- en: '*with two but ons*'
  prefs: []
  type: TYPE_NORMAL
- en: The user can click these buttons in any order and at any time. To han-
  prefs: []
  type: TYPE_NORMAL
- en: dle the user’s actions, the program runs in a loop and constantly checks to
  prefs: []
  type: TYPE_NORMAL
- en: see if either button has been clicked. When it receives a mouse down event
  prefs: []
  type: TYPE_NORMAL
- en: on a button, the program remembers that the button has been clicked and
  prefs: []
  type: TYPE_NORMAL
- en: draws the depressed image of that button. When it receives a mouse up
  prefs: []
  type: TYPE_NORMAL
- en: event on the button, it remembers the new state and redraws the button
  prefs: []
  type: TYPE_NORMAL
- en: with its original appearance, and it plays the appropriate sound. Because
  prefs: []
  type: TYPE_NORMAL
- en: the main loop runs so quickly, the user perceives that the sound plays
  prefs: []
  type: TYPE_NORMAL
- en: immediately after they click the button. Each time through the loop, the
  prefs: []
  type: TYPE_NORMAL
- en: program redraws both buttons with an image matching each button’s cur-
  prefs: []
  type: TYPE_NORMAL
- en: rent state.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Pygame**'
  prefs: []
  type: TYPE_NORMAL
- en: At first, pygame may seem like an overwhelmingly large package with many
  prefs: []
  type: TYPE_NORMAL
- en: different calls available. Although it is large, there’s actually not a lot
    that
  prefs: []
  type: TYPE_NORMAL
- en: you need to understand to get a small program up and running. To intro-
  prefs: []
  type: TYPE_NORMAL
- en: duce pygame, I’ll first give you a template that you can use for all pygame
  prefs: []
  type: TYPE_NORMAL
- en: programs you create. Then I’ll build on that template, adding key pieces of
  prefs: []
  type: TYPE_NORMAL
- en: functionality little by little.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following sections, I’ll show you how to:'
  prefs: []
  type: TYPE_NORMAL
- en: • Bring up a blank window.
  prefs: []
  type: TYPE_NORMAL
- en: • Show an image.
  prefs: []
  type: TYPE_NORMAL
- en: • Detect a mouse click.
  prefs: []
  type: TYPE_NORMAL
- en: • Detect both single and continuous key presses.
  prefs: []
  type: TYPE_NORMAL
- en: • Create a simple animation.
  prefs: []
  type: TYPE_NORMAL
- en: • Play sound effects and background sounds.
  prefs: []
  type: TYPE_NORMAL
- en: • Draw shapes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll continue the discussion of pygame and you’ll
  prefs: []
  type: TYPE_NORMAL
- en: 'see how to:'
  prefs: []
  type: TYPE_NORMAL
- en: • Animate many objects.
  prefs: []
  type: TYPE_NORMAL
- en: • Build and react to a button.
  prefs: []
  type: TYPE_NORMAL
- en: • Create a text display field.
  prefs: []
  type: TYPE_NORMAL
- en: '**96** Chapter 5'
  prefs: []
  type: TYPE_NORMAL
- en: '***Bringing Up a Blank Window***'
  prefs: []
  type: TYPE_NORMAL
- en: As I said earlier, pygame programs run constantly in a loop, checking for
  prefs: []
  type: TYPE_NORMAL
- en: events. It might help to think of your program as an animation, where
  prefs: []
  type: TYPE_NORMAL
- en: each pass through the main loop is one frame. The user may click on
  prefs: []
  type: TYPE_NORMAL
- en: something during any frame, and your program must not only respond
  prefs: []
  type: TYPE_NORMAL
- en: to that input but also keep track of everything it needs to draw in the
  prefs: []
  type: TYPE_NORMAL
- en: window. For instance, in one example program later in this chapter, we’ll
  prefs: []
  type: TYPE_NORMAL
- en: move a ball across the window so in each frame the ball is drawn in a
  prefs: []
  type: TYPE_NORMAL
- en: slightly different position.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5-1 is a generic template that you can use as a starting point for
  prefs: []
  type: TYPE_NORMAL
- en: all your pygame programs. This program opens a window and paints the
  prefs: []
  type: TYPE_NORMAL
- en: entire contents black. The only thing the user can do is click the close but-
  prefs: []
  type: TYPE_NORMAL
- en: ton to quit the program.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo0_WindowOnly/PygameWindowOnly.py**'
  prefs: []
  type: TYPE_NORMAL
- en: pygame demo 0 - window only
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 - Import packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: 2 - Define constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BLACK = (0, 0, 0)
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_WIDTH = 640
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_HEIGHT = 480
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  prefs: []
  type: TYPE_NORMAL
- en: clock = pygame.time.Clock()
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 6 - Loop forever
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  prefs: []
  type: TYPE_NORMAL
- en: Clicked the close button? Quit pygame and end the program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 9 - Clear the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Pygame **97**
  prefs: []
  type: TYPE_NORMAL
- en: window.fill(BLACK)
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw all window elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 11 - Update the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: clock.tick(FRAMES_PER_SECOND)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-1: A template for creating pygame programs*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s walk through the different parts of this template:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Import packages.
  prefs: []
  type: TYPE_NORMAL
- en: The template starts with the import statements. We first import the pyg-
  prefs: []
  type: TYPE_NORMAL
- en: ame package itself, then some constants defined inside pygame that
  prefs: []
  type: TYPE_NORMAL
- en: we’ll use later. The last import is the sys package, which we’ll use to quit
  prefs: []
  type: TYPE_NORMAL
- en: our program.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Define constants.
  prefs: []
  type: TYPE_NORMAL
- en: We next define any constants for our program. First we define the
  prefs: []
  type: TYPE_NORMAL
- en: RGB value for BLACK, which we will use to paint the background of
  prefs: []
  type: TYPE_NORMAL
- en: our window. Then we define constants for the width and height of our
  prefs: []
  type: TYPE_NORMAL
- en: window in pixels and a constant for the refresh rate for our program.
  prefs: []
  type: TYPE_NORMAL
- en: This number defines the maximum number of times the program will
  prefs: []
  type: TYPE_NORMAL
- en: loop (and therefore redraw the window) per second. Our value of 30
  prefs: []
  type: TYPE_NORMAL
- en: is fairly typical. If the amount of work done in our main loop is exces-
  prefs: []
  type: TYPE_NORMAL
- en: sive, the program might run slower than this value, but it will never
  prefs: []
  type: TYPE_NORMAL
- en: run faster. A refresh rate that’s too high might cause the program to
  prefs: []
  type: TYPE_NORMAL
- en: run too fast. In our ball example, this means the ball might bounce
  prefs: []
  type: TYPE_NORMAL
- en: around the window faster than intended.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Initialize the pygame environment.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we call a function that tells pygame to initialize itself.
  prefs: []
  type: TYPE_NORMAL
- en: We then ask pygame to create a window for our program with the
  prefs: []
  type: TYPE_NORMAL
- en: pygame.display.set_mode() function and pass in the desired width and
  prefs: []
  type: TYPE_NORMAL
- en: height of the window. Finally, we call another pygame function to cre-
  prefs: []
  type: TYPE_NORMAL
- en: ate a clock object, which will be used at the bottom of our main loop to
  prefs: []
  type: TYPE_NORMAL
- en: maintain our maximum frame rate.
  prefs: []
  type: TYPE_NORMAL
- en: '4\. Load assets: image(s), sound(s), and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a placeholder section, into which we will eventually add code to
  prefs: []
  type: TYPE_NORMAL
- en: load external images, sounds, and so on from the disk for use in our
  prefs: []
  type: TYPE_NORMAL
- en: program. In this basic program we’re not using any external assets, so
  prefs: []
  type: TYPE_NORMAL
- en: this section is empty for now.
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Initialize variables.
  prefs: []
  type: TYPE_NORMAL
- en: Here we will eventually initialize any variables that our program will
  prefs: []
  type: TYPE_NORMAL
- en: use. Currently we have none, so we have no code here.
  prefs: []
  type: TYPE_NORMAL
- en: '**98** Chapter 5'
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Loop forever.
  prefs: []
  type: TYPE_NORMAL
- en: Here we start our main loop. This is a simple while True infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: Again, you can think of each iteration through the main loop as one
  prefs: []
  type: TYPE_NORMAL
- en: frame in an animation.
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Check for and handle events; commonly referred to as the *event loop*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we call pygame.event.get() to get a list of the events that
  prefs: []
  type: TYPE_NORMAL
- en: happened since the last time we checked (the last time the main loop
  prefs: []
  type: TYPE_NORMAL
- en: ran), then iterate through the list of events. Each event reported to the
  prefs: []
  type: TYPE_NORMAL
- en: program is an object, and every event object has a type. If no event has
  prefs: []
  type: TYPE_NORMAL
- en: happened, this section is skipped over.
  prefs: []
  type: TYPE_NORMAL
- en: In this minimal program, where the only action a user can take is
  prefs: []
  type: TYPE_NORMAL
- en: to close the window, the only event type we check for is the constant
  prefs: []
  type: TYPE_NORMAL
- en: pygame.QUIT, generated by pygame when the user clicks the close but-
  prefs: []
  type: TYPE_NORMAL
- en: ton. If we find this event, we tell pygame to quit, which frees up any
  prefs: []
  type: TYPE_NORMAL
- en: resources it was using. Then we quit our program.
  prefs: []
  type: TYPE_NORMAL
- en: 8\. Do any “per frame” actions.
  prefs: []
  type: TYPE_NORMAL
- en: In this section we’ll eventually put any code that needs to run in every
  prefs: []
  type: TYPE_NORMAL
- en: frame. This might involve moving things in the window or checking for
  prefs: []
  type: TYPE_NORMAL
- en: collisions between elements. In this minimal program, we have nothing
  prefs: []
  type: TYPE_NORMAL
- en: to do here.
  prefs: []
  type: TYPE_NORMAL
- en: 9\. Clear the window.
  prefs: []
  type: TYPE_NORMAL
- en: On each iteration through the main loop, our program must redraw
  prefs: []
  type: TYPE_NORMAL
- en: everything in the window, which means we need to clear it first. The
  prefs: []
  type: TYPE_NORMAL
- en: simplest approach is to just fill the window with a color, which we do here
  prefs: []
  type: TYPE_NORMAL
- en: with a call to window.fill(), specifying a black background. We could also
  prefs: []
  type: TYPE_NORMAL
- en: draw a background picture, but we’ll hold off on that for now.
  prefs: []
  type: TYPE_NORMAL
- en: 10\. Draw all window elements.
  prefs: []
  type: TYPE_NORMAL
- en: Here we’ll place code to draw everything we want to show in our win-
  prefs: []
  type: TYPE_NORMAL
- en: dow. In this sample program there is nothing to draw.
  prefs: []
  type: TYPE_NORMAL
- en: In real programs, things are drawn in the order they appear in the
  prefs: []
  type: TYPE_NORMAL
- en: code, in layers from backmost to frontmost. For example, assume we
  prefs: []
  type: TYPE_NORMAL
- en: want to draw two partially overlapping circles, A and B. If we draw A
  prefs: []
  type: TYPE_NORMAL
- en: first, A will appear behind B, and portions of A will be obscured by B.
  prefs: []
  type: TYPE_NORMAL
- en: If we draw B first and then A, the opposite happens, and we see A in
  prefs: []
  type: TYPE_NORMAL
- en: front of B. This is a natural mapping equivalent to the layers in graph-
  prefs: []
  type: TYPE_NORMAL
- en: ics programs such as Photoshop.
  prefs: []
  type: TYPE_NORMAL
- en: 11\. Update the window.
  prefs: []
  type: TYPE_NORMAL
- en: This line tells pygame to take all the drawing we’ve included and show
  prefs: []
  type: TYPE_NORMAL
- en: it in the window. Pygame actually does all the drawing in steps 8, 9, and
  prefs: []
  type: TYPE_NORMAL
- en: 10 in an off-screen buffer. When you tell pygame to update, it takes the
  prefs: []
  type: TYPE_NORMAL
- en: contents of this off-screen buffer and puts them in the real window.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pygame **99**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 19](index-129_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 12\. Slow things down a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Computers are very fast, and if the loop continued to the next iteration
  prefs: []
  type: TYPE_NORMAL
- en: right away without pausing, the program might run faster than the des-
  prefs: []
  type: TYPE_NORMAL
- en: ignated frame rate. The line in this section tells pygame to wait until a
  prefs: []
  type: TYPE_NORMAL
- en: given amount of time has elapsed in order to make the frames of our
  prefs: []
  type: TYPE_NORMAL
- en: program run at the frame rate that we specified. This is important to
  prefs: []
  type: TYPE_NORMAL
- en: ensure the program runs at a consistent rate, independent of the speed
  prefs: []
  type: TYPE_NORMAL
- en: of the computer on which it’s running.
  prefs: []
  type: TYPE_NORMAL
- en: When you run this program, the program just puts up a blank window
  prefs: []
  type: TYPE_NORMAL
- en: filled with black. To end the program, click on the close button in the
  prefs: []
  type: TYPE_NORMAL
- en: title bar.
  prefs: []
  type: TYPE_NORMAL
- en: '***Drawing an Image***'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s draw something in the window. There are two parts to showing a
  prefs: []
  type: TYPE_NORMAL
- en: 'graphic image: first we load the image into the computer’s memory, then we'
  prefs: []
  type: TYPE_NORMAL
- en: display the image in the application window.
  prefs: []
  type: TYPE_NORMAL
- en: With pygame, all images (and sounds) need to be kept in files external
  prefs: []
  type: TYPE_NORMAL
- en: to your code. Pygame supports many standard graphic file formats, includ-
  prefs: []
  type: TYPE_NORMAL
- en: ing *.png*, *.jpg*, and *.gif*. In this program we’ll load a picture of a ball
    from the file *ball.png*. As a reminder, the code and assets associated with all
    the major listings in this book are available for download at [*https://www.nostarch.com/*](https://www.nostarch.com/objectorientedpython/)
  prefs: []
  type: TYPE_NORMAL
- en: '[*objectorientedpython/* a](https://www.nostarch.com/objectorientedpython/)nd
    [*https://github.com/IrvKalb/O*](https://github.com/IrvKalb/Object-Oriented-Python-Code/)
    *bject-Oriented-Python-Code/*.'
  prefs: []
  type: TYPE_NORMAL
- en: While we only need one graphic file in this program, it’s a good idea
  prefs: []
  type: TYPE_NORMAL
- en: to use a consistent approach to handling graphic and sound files, so I’ll lay
  prefs: []
  type: TYPE_NORMAL
- en: one out for you here. First, create a project folder. Place your main program
  prefs: []
  type: TYPE_NORMAL
- en: in that folder, along with any related files containing Python classes and
  prefs: []
  type: TYPE_NORMAL
- en: functions. Then, inside the project folder, create an *images* folder into which
    you’ll place any image files you want to use in your program. Also create
  prefs: []
  type: TYPE_NORMAL
- en: a *sounds* folder and place any sound files you want to use there. Figure 5-6
  prefs: []
  type: TYPE_NORMAL
- en: shows the suggested structure. All of the example programs in this book
  prefs: []
  type: TYPE_NORMAL
- en: will use this project folder layout.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5-6: Suggested project folder hierarchy*'
  prefs: []
  type: TYPE_NORMAL
- en: A *path* (also called a *pathname*) is a string that uniquely identifies the
    location of a file or folder on a computer. To load a graphic or sound file
  prefs: []
  type: TYPE_NORMAL
- en: into your program, you must specify the path to the file. There are two
  prefs: []
  type: TYPE_NORMAL
- en: 'types of paths: relative and absolute.'
  prefs: []
  type: TYPE_NORMAL
- en: A *relative path* is a relative to the current folder, often called the *current*
    *working directory*. When you run a program using an IDE such as IDLE or
  prefs: []
  type: TYPE_NORMAL
- en: '**100** Chapter 5'
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm, it sets the current folder to the one containing your main Python program
    so you can use relative paths with ease. In this book, I will assume
  prefs: []
  type: TYPE_NORMAL
- en: you’re using an IDE and will represent all paths as relative paths.
  prefs: []
  type: TYPE_NORMAL
- en: The relative path for a graphic file (for example, *ball.png*) in the same
  prefs: []
  type: TYPE_NORMAL
- en: folder as your main Python file would be just the filename as a string (for
  prefs: []
  type: TYPE_NORMAL
- en: example, 'ball.png'). Using the suggested project structure, the relative
  prefs: []
  type: TYPE_NORMAL
- en: path would be 'images/ball.png'.
  prefs: []
  type: TYPE_NORMAL
- en: This says that inside the project folder will be another folder named
  prefs: []
  type: TYPE_NORMAL
- en: '*images*, and inside that folder is a file named *ball.png*. In path strings,
    folder names are separated by the slash character.'
  prefs: []
  type: TYPE_NORMAL
- en: However, if you expect to run your program from the command line,
  prefs: []
  type: TYPE_NORMAL
- en: then you need to construct absolute paths for all files. An *absolute path*
    is one that starts from the root of the filesystem and includes the full hierarchy
    of folders to your file. To build an absolute path to any file, you can use
  prefs: []
  type: TYPE_NORMAL
- en: 'code like this, which builds an absolute path string to the *ball.png* file
    in the *images* folder inside the project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: from pathlib import Path
  prefs: []
  type: TYPE_NORMAL
- en: 'Place this in section #2, defining a constant'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BASE_PATH = Path(__file__).resolve().parent
  prefs: []
  type: TYPE_NORMAL
- en: Build a path to the file in the images folder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pathToBall = BASE_PATH + 'images/ball.png'
  prefs: []
  type: TYPE_NORMAL
- en: Now we’ll create the code of the ball program, starting with the ear-
  prefs: []
  type: TYPE_NORMAL
- en: lier 12-step template and adding just two new lines of code, as shown in
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5-2\.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo1_OneImage/PygameOneImage.py**'
  prefs: []
  type: TYPE_NORMAL
- en: pygame demo 1 – draw one image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  prefs: []
  type: TYPE_NORMAL
- en: clock = pygame.time.Clock()
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 ballImage = pygame.image.load('images/ball.png')
  prefs: []
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw all window elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: draw ball at position 100 across (x) and 200 down (y)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2 window.blit(ballImage, (100, 200))
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Pygame **101**
  prefs: []
  type: TYPE_NORMAL
- en: pygame.display.update()
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-2: Load one image and draw it in every frame.*'
  prefs: []
  type: TYPE_NORMAL
- en: First, we tell pygame to find the file containing the image of the ball
  prefs: []
  type: TYPE_NORMAL
- en: and load that image into memory 1\. The variable ballImage now refers to
  prefs: []
  type: TYPE_NORMAL
- en: the image of the ball. Notice that this assignment statement is only exe-
  prefs: []
  type: TYPE_NORMAL
- en: cuted once, before the main loop starts.
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the official documentation of pygame, every image, including the application
    window, is known as a* surface *. I’ll use more specific terms: I will refer to
    the application* *window simply as a* window *and to any picture loaded from an
    external file as an* image *. I reserve the term* surface *for any picture drawn
    on the fly.*'
  prefs: []
  type: TYPE_NORMAL
- en: We then tell the program to draw the ball 2 every time we go through
  prefs: []
  type: TYPE_NORMAL
- en: the main loop. We specify the location representing the position to place
  prefs: []
  type: TYPE_NORMAL
- en: the upper-left corner of the image’s bounding rectangle, typically as a tuple
  prefs: []
  type: TYPE_NORMAL
- en: of x- and y-coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: The function name blit() is a very old reference to the words *bit block*
  prefs: []
  type: TYPE_NORMAL
- en: '*transfer*, but in this context it really just means “draw.” Since the program
    loaded the ball image earlier, pygame knows how big the image is, so we'
  prefs: []
  type: TYPE_NORMAL
- en: just need to tell it where to draw the ball. In Listing 5-2, we give an x value
  prefs: []
  type: TYPE_NORMAL
- en: of 100 and a y value of 200\.
  prefs: []
  type: TYPE_NORMAL
- en: When you run the program, on each iteration through the loop (30
  prefs: []
  type: TYPE_NORMAL
- en: times per second) every pixel in the window is set to black, then the ball
  prefs: []
  type: TYPE_NORMAL
- en: is drawn over the background. From the user’s point of view, it looks like
  prefs: []
  type: TYPE_NORMAL
- en: nothing is happening—the ball just stays in one spot with the upper-left
  prefs: []
  type: TYPE_NORMAL
- en: corner of its bounding rectangle at location (100, 200).
  prefs: []
  type: TYPE_NORMAL
- en: '***Detecting a Mouse Click***'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll allow our program to detect and react to a mouse click. The user
  prefs: []
  type: TYPE_NORMAL
- en: will be able to click on the ball to make it appear somewhere else in the
  prefs: []
  type: TYPE_NORMAL
- en: window. When the program detects a mouse click on the ball, it randomly
  prefs: []
  type: TYPE_NORMAL
- en: picks new coordinates and draws the ball at that new location. Instead of
  prefs: []
  type: TYPE_NORMAL
- en: using hardcoded coordinates of (100, 200), we’ll create two variables, ballX
  prefs: []
  type: TYPE_NORMAL
- en: and ballY, and refer to the coordinates of the ball in the window as the
  prefs: []
  type: TYPE_NORMAL
- en: tuple (ballX, ballY). Listing 5-3 provides the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo2_ImageClickAndMove/PygameImageClickAndMove.py**'
  prefs: []
  type: TYPE_NORMAL
- en: pygame demo 2 - one image, click and move
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 - Import packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: '**102** Chapter 5'
  prefs: []
  type: TYPE_NORMAL
- en: 1 import random
  prefs: []
  type: TYPE_NORMAL
- en: 2 - Define constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BLACK = (0, 0, 0)
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_WIDTH = 640
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_HEIGHT = 480
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  prefs: []
  type: TYPE_NORMAL
- en: 2 BALL_WIDTH_HEIGHT = 100
  prefs: []
  type: TYPE_NORMAL
- en: MAX_WIDTH = WINDOW_WIDTH - BALL_WIDTH_HEIGHT
  prefs: []
  type: TYPE_NORMAL
- en: MAX_HEIGHT = WINDOW_HEIGHT - BALL_WIDTH_HEIGHT
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  prefs: []
  type: TYPE_NORMAL
- en: clock = pygame.time.Clock()
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ballImage = pygame.image.load('images/ball.png')
  prefs: []
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 ballX = random.randrange(MAX_WIDTH)
  prefs: []
  type: TYPE_NORMAL
- en: ballY = random.randrange(MAX_HEIGHT)
  prefs: []
  type: TYPE_NORMAL
- en: 4 ballRect = pygame.Rect(ballX, ballY, BALL_WIDTH_HEIGHT, BALL_WIDTH_HEIGHT)
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  prefs: []
  type: TYPE_NORMAL
- en: Clicked the close button? Quit pygame and end the program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: See if user clicked
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '5 if event.type == pygame.MOUSEBUTTONUP:'
  prefs: []
  type: TYPE_NORMAL
- en: 'mouseX, mouseY = event.pos # Could do this if we needed it'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check if the click was in the rect of the ball
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If so, choose a random new location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6 if ballRect.collidepoint(event.pos):'
  prefs: []
  type: TYPE_NORMAL
- en: ballX = random.randrange(MAX_WIDTH)
  prefs: []
  type: TYPE_NORMAL
- en: ballY = random.randrange(MAX_HEIGHT)
  prefs: []
  type: TYPE_NORMAL
- en: ballRect = pygame.Rect(ballX, ballY, BALL_WIDTH_HEIGHT,
  prefs: []
  type: TYPE_NORMAL
- en: BALL_WIDTH_HEIGHT)
  prefs: []
  type: TYPE_NORMAL
- en: 8 Do any "per frame" actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 9 - Clear the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(BLACK)
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw all window elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Draw the ball at the randomized location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 7 window.blit(ballImage, (ballX, ballY))
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pygame **103**
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-3: Detecting a mouse click and acting on it*'
  prefs: []
  type: TYPE_NORMAL
- en: Since we need to generate random numbers for the ball coordinates,
  prefs: []
  type: TYPE_NORMAL
- en: we import the random package 1\.
  prefs: []
  type: TYPE_NORMAL
- en: We then add a new constant to define the height and width of our
  prefs: []
  type: TYPE_NORMAL
- en: image as 100 pixels 2\. We also create two more constants to limit the maxi-
  prefs: []
  type: TYPE_NORMAL
- en: mum width and height coordinates. By using these constants rather than
  prefs: []
  type: TYPE_NORMAL
- en: the size of the window, we ensure that our ball image will always appear
  prefs: []
  type: TYPE_NORMAL
- en: fully within the window (remember that when we refer to the location of an
  prefs: []
  type: TYPE_NORMAL
- en: image, we are specifying the position of its upper-left corner). We use those
  prefs: []
  type: TYPE_NORMAL
- en: constants to choose random values for the starting x- and y-coordinates for
  prefs: []
  type: TYPE_NORMAL
- en: our ball 3\.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call pygame.Rect() to create a rectangle 4\. Defining a rectangle
  prefs: []
  type: TYPE_NORMAL
- en: requires four parameters—an x-coordinate, a y-coordinate, a width, and a
  prefs: []
  type: TYPE_NORMAL
- en: 'height, in that order:'
  prefs: []
  type: TYPE_NORMAL
- en: '*<rectObject>* = pygame.Rect( *<x>* , *<y>* , *<width>* , *<height>* ) This
    returns a pygame rectangle object, or rect. We’ll use the rectangle'
  prefs: []
  type: TYPE_NORMAL
- en: of the ball in the processing of events.
  prefs: []
  type: TYPE_NORMAL
- en: We also add code to check if the user clicked the mouse. As mentioned,
  prefs: []
  type: TYPE_NORMAL
- en: 'a mouse click is actually made up of two different events: a mouse down'
  prefs: []
  type: TYPE_NORMAL
- en: event and a mouse up event. Since the mouse up event is typically used to
  prefs: []
  type: TYPE_NORMAL
- en: signal activation, we’ll only look for that event here. This event is signaled
  prefs: []
  type: TYPE_NORMAL
- en: by a new event.type value of pygame.MOUSEBUTTONUP 5\. When we find that a
  prefs: []
  type: TYPE_NORMAL
- en: mouse up event has occurred, we’ll then check to see if the location where
  prefs: []
  type: TYPE_NORMAL
- en: the user clicked was inside the current rectangle of the ball.
  prefs: []
  type: TYPE_NORMAL
- en: When pygame detects that an event has happened, it builds an event
  prefs: []
  type: TYPE_NORMAL
- en: object containing a lot of data. In this case, we only care about the x- and
  prefs: []
  type: TYPE_NORMAL
- en: y-coordinates where the event happened. We retrieve the (x, y) position of
  prefs: []
  type: TYPE_NORMAL
- en: the click using event.pos, which provides a tuple of two values.
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If we need to separate the x- and y-coordinates of the click, we can unpack
    the tuple* *and store the values into two variables like this:*'
  prefs: []
  type: TYPE_NORMAL
- en: mouseX, mouseY = event.pos
  prefs: []
  type: TYPE_NORMAL
- en: Now we check to see if the event happened inside the rectangle of the
  prefs: []
  type: TYPE_NORMAL
- en: 'ball using collidepoint() 6, whose syntax is:'
  prefs: []
  type: TYPE_NORMAL
- en: '*<booleanVariable>* = *<someRectangle>* .collidepoint( *<someXYLocation>* )
    **104** Chapter 5'
  prefs: []
  type: TYPE_NORMAL
- en: The method returns a Boolean True if the given point is inside the rectangle.
    If the user has clicked the ball, we randomly select new values for
  prefs: []
  type: TYPE_NORMAL
- en: ballX and ballY. We use those values to create a new rectangle for the ball
    at
  prefs: []
  type: TYPE_NORMAL
- en: the new random location.
  prefs: []
  type: TYPE_NORMAL
- en: The only change here is that we always draw the ball at the location
  prefs: []
  type: TYPE_NORMAL
- en: given by the tuple (ballX, ballY) 7\. The effect is that whenever the user
  prefs: []
  type: TYPE_NORMAL
- en: clicks inside the rectangle of the ball, the ball appears to move to some new
  prefs: []
  type: TYPE_NORMAL
- en: random spot in the window.
  prefs: []
  type: TYPE_NORMAL
- en: '***Handling the Keyboard***'
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to allow the user to control some aspect of the program
  prefs: []
  type: TYPE_NORMAL
- en: through the keyboard. There are two different ways to handle user key-
  prefs: []
  type: TYPE_NORMAL
- en: 'board interactions: as individual key presses, and when a user holds down a'
  prefs: []
  type: TYPE_NORMAL
- en: key to indicate that an action should happen for as long as that key is down
  prefs: []
  type: TYPE_NORMAL
- en: (known as *continuous mode*).
  prefs: []
  type: TYPE_NORMAL
- en: '**Recognizing Individual Key Presses**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the mouse clicks, each key press generates two events: key down and key'
  prefs: []
  type: TYPE_NORMAL
- en: 'up. The two events have different event types: pygame.KEYDOWN and pygame.KEYUP.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5-4 shows a small sample program that allows the user to move
  prefs: []
  type: TYPE_NORMAL
- en: the ball image in the window using the keyboard. The program also shows
  prefs: []
  type: TYPE_NORMAL
- en: a target rectangle in the window. The user’s goal is to move the ball image
  prefs: []
  type: TYPE_NORMAL
- en: so that it overlaps with the target image.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo3_MoveByKeyboard/PygameMoveByKeyboardOncePerKey.py**'
  prefs: []
  type: TYPE_NORMAL
- en: pygame demo 3(a) - one image, move by keyboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 - Import packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: 2 - Define constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BLACK = (0, 0, 0)
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_WIDTH = 640
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_HEIGHT = 480
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  prefs: []
  type: TYPE_NORMAL
- en: BALL_WIDTH_HEIGHT = 100
  prefs: []
  type: TYPE_NORMAL
- en: MAX_WIDTH = WINDOW_WIDTH - BALL_WIDTH_HEIGHT
  prefs: []
  type: TYPE_NORMAL
- en: MAX_HEIGHT = WINDOW_HEIGHT - BALL_WIDTH_HEIGHT
  prefs: []
  type: TYPE_NORMAL
- en: 1 TARGET_X = 400
  prefs: []
  type: TYPE_NORMAL
- en: TARGET_Y = 320
  prefs: []
  type: TYPE_NORMAL
- en: TARGET_WIDTH_HEIGHT = 120
  prefs: []
  type: TYPE_NORMAL
- en: N_PIXELS_TO_MOVE = 3
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pygame **105**
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  prefs: []
  type: TYPE_NORMAL
- en: clock = pygame.time.Clock()
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ballImage = pygame.image.load('images/ball.png')
  prefs: []
  type: TYPE_NORMAL
- en: 2 targetImage = pygame.image.load('images/target.jpg')
  prefs: []
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ballX = random.randrange(MAX_WIDTH)
  prefs: []
  type: TYPE_NORMAL
- en: ballY = random.randrange(MAX_HEIGHT)
  prefs: []
  type: TYPE_NORMAL
- en: targetRect = pygame.Rect(TARGET_X, TARGET_Y, TARGET_WIDTH_HEIGHT, TARGET_
  prefs: []
  type: TYPE_NORMAL
- en: WIDTH_HEIGHT)
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  prefs: []
  type: TYPE_NORMAL
- en: Clicked the close button? Quit pygame and end the program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: See if the user pressed a key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3 elif event.type == pygame.KEYDOWN:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.key == pygame.K_LEFT:'
  prefs: []
  type: TYPE_NORMAL
- en: ballX = ballX - N_PIXELS_TO_MOVE
  prefs: []
  type: TYPE_NORMAL
- en: 'elif event.key == pygame.K_RIGHT:'
  prefs: []
  type: TYPE_NORMAL
- en: ballX = ballX + N_PIXELS_TO_MOVE
  prefs: []
  type: TYPE_NORMAL
- en: 'elif event.key == pygame.K_UP:'
  prefs: []
  type: TYPE_NORMAL
- en: ballY = ballY - N_PIXELS_TO_MOVE
  prefs: []
  type: TYPE_NORMAL
- en: 'elif event.key == pygame.K_DOWN:'
  prefs: []
  type: TYPE_NORMAL
- en: ballY = ballY + N_PIXELS_TO_MOVE
  prefs: []
  type: TYPE_NORMAL
- en: 8 Do any "per frame" actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check if the ball is colliding with the target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4 ballRect = pygame.Rect(ballX, ballY,
  prefs: []
  type: TYPE_NORMAL
- en: BALL_WIDTH_HEIGHT, BALL_WIDTH_HEIGHT)
  prefs: []
  type: TYPE_NORMAL
- en: '5 if ballRect.colliderect(targetRect):'
  prefs: []
  type: TYPE_NORMAL
- en: print('Ball is touching the target')
  prefs: []
  type: TYPE_NORMAL
- en: 9 - Clear the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(BLACK)
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw all window elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '6 window.blit(targetImage, (TARGET_X, TARGET_Y)) # draw the target'
  prefs: []
  type: TYPE_NORMAL
- en: 'window.blit(ballImage, (ballX, ballY)) # draw the ball'
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-4: Detecting and acting on single key presses*'
  prefs: []
  type: TYPE_NORMAL
- en: '**106** Chapter 5'
  prefs: []
  type: TYPE_NORMAL
- en: First we add a few new constants 1 to define the x- and y-coordinates of the
    upper-left corner of the target rectangle and the width and height of
  prefs: []
  type: TYPE_NORMAL
- en: the target. We then load the image of the target rectangle 2\.
  prefs: []
  type: TYPE_NORMAL
- en: In the loop where we look for for events, we add a test for a key press
  prefs: []
  type: TYPE_NORMAL
- en: by checking for an event of type pygame.KEYDOWN 3\. If a key down event is
  prefs: []
  type: TYPE_NORMAL
- en: detected, we look into the event to find out what key was pressed. Each
  prefs: []
  type: TYPE_NORMAL
- en: key has an associated constant in pygame, so here we check if the user has
  prefs: []
  type: TYPE_NORMAL
- en: pressed the left, up, down, or right arrow. For each of these keys, we modify
  prefs: []
  type: TYPE_NORMAL
- en: the value of the ball’s x- or y-coordinate appropriately by a small number
  prefs: []
  type: TYPE_NORMAL
- en: of pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Next we create a pygame rect object for the ball based on its x- and
  prefs: []
  type: TYPE_NORMAL
- en: y-coordinates and its height and width 4\. We can check to see if two rect-
  prefs: []
  type: TYPE_NORMAL
- en: 'angles overlap with the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '*<booleanVariable>* = *<rect1>* .colliderect( *<rect2>* ) This call compares
    two rectangles and returns True if they overlap at all'
  prefs: []
  type: TYPE_NORMAL
- en: or False if they don’t. We compare the ball rectangle with the target rectan-
  prefs: []
  type: TYPE_NORMAL
- en: gle 5, and if they overlap, the program prints “Ball is touching the target”
  prefs: []
  type: TYPE_NORMAL
- en: to the shell window.
  prefs: []
  type: TYPE_NORMAL
- en: The last change is where we draw both the target and the ball. The
  prefs: []
  type: TYPE_NORMAL
- en: target is drawn first so that when the two overlap, the ball appears over
  prefs: []
  type: TYPE_NORMAL
- en: the target 6\.
  prefs: []
  type: TYPE_NORMAL
- en: When the program is run, if the rectangle of the ball overlaps the rect-
  prefs: []
  type: TYPE_NORMAL
- en: angle of the target, the message is written to the shell window. If you move
  prefs: []
  type: TYPE_NORMAL
- en: the ball away from the target, the message stops being written out.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dealing with Repeating Keys in Continuous Mode**'
  prefs: []
  type: TYPE_NORMAL
- en: The second way to handle keyboard interactions in pygame is to *poll* the
  prefs: []
  type: TYPE_NORMAL
- en: keyboard. This involves asking pygame for a list representing which keys
  prefs: []
  type: TYPE_NORMAL
- en: 'are currently down in every frame using the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '*<aTuple>* = pygame.key.get_pressed()'
  prefs: []
  type: TYPE_NORMAL
- en: 'This call returns a tuple of 0s and 1s representing the state of each key:'
  prefs: []
  type: TYPE_NORMAL
- en: 0 if the key is up, 1 if the key is down. You can then use constants defined
  prefs: []
  type: TYPE_NORMAL
- en: within pygame as an index into the returned tuple to see if a *particular* key
    is down. For example, the following lines can be used to determine the
  prefs: []
  type: TYPE_NORMAL
- en: 'state of the A key:'
  prefs: []
  type: TYPE_NORMAL
- en: keyPressedTuple = pygame.key.get_pressed()
  prefs: []
  type: TYPE_NORMAL
- en: Now use a constant to get the appropriate element of the tuple
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: aIsDown = keyPressedTuple[pygame.K_a]
  prefs: []
  type: TYPE_NORMAL
- en: The full listing of constants representing all keys defined in pygame
  prefs: []
  type: TYPE_NORMAL
- en: can be found a[t *https://www.pygame.org/docs/ref/key.html*.](https://www.pygame.org/docs/ref/key.html)
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pygame **107**
  prefs: []
  type: TYPE_NORMAL
- en: The code in Listing 5-5 shows how we can use this technique to move an image
    continuously rather than once per key press. In this version, we
  prefs: []
  type: TYPE_NORMAL
- en: 'move the keyboard handling from section #7 to section #8\. The rest of the'
  prefs: []
  type: TYPE_NORMAL
- en: code is identical to the previous version in Listing 5-4\.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo3_MoveByKeyboard/PygameMoveByKeyboardContinuous.py**'
  prefs: []
  type: TYPE_NORMAL
- en: pygame demo 3(b) - one image, continuous mode, move as long as a key is down
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  prefs: []
  type: TYPE_NORMAL
- en: Clicked the close button? Quit pygame and end the program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check for user pressing keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 keyPressedTuple = pygame.key.get_pressed()
  prefs: []
  type: TYPE_NORMAL
- en: 'if keyPressedTuple[pygame.K_LEFT]: # moving left'
  prefs: []
  type: TYPE_NORMAL
- en: ballX = ballX - N_PIXELS_TO_MOVE
  prefs: []
  type: TYPE_NORMAL
- en: 'if keyPressedTuple[pygame.K_RIGHT]: # moving right'
  prefs: []
  type: TYPE_NORMAL
- en: ballX = ballX + N_PIXELS_TO_MOVE
  prefs: []
  type: TYPE_NORMAL
- en: 'if keyPressedTuple[pygame.K_UP]: # moving up'
  prefs: []
  type: TYPE_NORMAL
- en: ballY = ballY - N_PIXELS_TO_MOVE
  prefs: []
  type: TYPE_NORMAL
- en: 'if keyPressedTuple[pygame.K_DOWN]: # moving down'
  prefs: []
  type: TYPE_NORMAL
- en: ballY = ballY + N_PIXELS_TO_MOVE
  prefs: []
  type: TYPE_NORMAL
- en: Check if the ball is colliding with the target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ballRect = pygame.Rect(ballX, ballY,
  prefs: []
  type: TYPE_NORMAL
- en: BALL_WIDTH_HEIGHT, BALL_WIDTH_HEIGHT)
  prefs: []
  type: TYPE_NORMAL
- en: 'if ballRect.colliderect(targetRect):'
  prefs: []
  type: TYPE_NORMAL
- en: print('Ball is touching the target')
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-5: Handling keys being held down*'
  prefs: []
  type: TYPE_NORMAL
- en: The keyboard-handling code in Listing 5-5 does not rely on events,
  prefs: []
  type: TYPE_NORMAL
- en: so we place the new code outside of the for loop that iterates through all
  prefs: []
  type: TYPE_NORMAL
- en: events returned by pygame 1\.
  prefs: []
  type: TYPE_NORMAL
- en: Because we are doing this check in every frame, the movement of the
  prefs: []
  type: TYPE_NORMAL
- en: ball will appear to be continuous as long as the user holds down a key. For
  prefs: []
  type: TYPE_NORMAL
- en: example, if the user presses and holds the right arrow key, this code will
  prefs: []
  type: TYPE_NORMAL
- en: add 3 to the value of the ballX coordinate in every frame, and the user will
  prefs: []
  type: TYPE_NORMAL
- en: see the ball moving smoothly to the right. When they stop pressing the key,
  prefs: []
  type: TYPE_NORMAL
- en: the movement stops.
  prefs: []
  type: TYPE_NORMAL
- en: '**108** Chapter 5'
  prefs: []
  type: TYPE_NORMAL
- en: The other change is that this approach allows you to check for multiple keys
    being down at the same time. For example, if the user presses and holds
  prefs: []
  type: TYPE_NORMAL
- en: the left and down arrow keys, the ball will move diagonally down and to the
  prefs: []
  type: TYPE_NORMAL
- en: left. You can check for as many keys being held down as you wish. However,
  prefs: []
  type: TYPE_NORMAL
- en: the number of *simultaneous* key presses that can be detected is limited by
    the operating system, the keyboard hardware, and many other factors. The
  prefs: []
  type: TYPE_NORMAL
- en: typical limit is around four keys, but your mileage may vary.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a Location-Based Animation***'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll build a location-based animation. This code will allow us to
  prefs: []
  type: TYPE_NORMAL
- en: move an image diagonally and then have it appear to bounce off the edges
  prefs: []
  type: TYPE_NORMAL
- en: of the window. This was a favorite technique of screensavers on old CRT-
  prefs: []
  type: TYPE_NORMAL
- en: based monitors, to avoid burning in a static image.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll change the location of our image slightly in every frame. We’ll
  prefs: []
  type: TYPE_NORMAL
- en: also check if the result of that movement would place any part of the image
  prefs: []
  type: TYPE_NORMAL
- en: outside one of the window boundaries and, if so, reverse the movement in
  prefs: []
  type: TYPE_NORMAL
- en: that direction. For example, if the image was moving down and would cross
  prefs: []
  type: TYPE_NORMAL
- en: the bottom of the window, we would reverse the direction and make the
  prefs: []
  type: TYPE_NORMAL
- en: image start moving up.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll again use the same starting template. Listing 5-6 gives the full
  prefs: []
  type: TYPE_NORMAL
- en: source code.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo4_OneBal Bounce/PygameOneBal BounceXY.py**'
  prefs: []
  type: TYPE_NORMAL
- en: pygame demo 4(a) - one image, bounce around the window using (x, y) coords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 - Import packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: 2 - Define constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BLACK = (0, 0, 0)
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_WIDTH = 640
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_HEIGHT = 480
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  prefs: []
  type: TYPE_NORMAL
- en: BALL_WIDTH_HEIGHT = 100
  prefs: []
  type: TYPE_NORMAL
- en: N_PIXELS_PER_FRAME = 3
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  prefs: []
  type: TYPE_NORMAL
- en: clock = pygame.time.Clock()
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ballImage = pygame.image.load('images/ball.png')
  prefs: []
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Pygame **109**
  prefs: []
  type: TYPE_NORMAL
- en: MAX_WIDTH = WINDOW_WIDTH - BALL_WIDTH_HEIGHT
  prefs: []
  type: TYPE_NORMAL
- en: MAX_HEIGHT = WINDOW_HEIGHT - BALL_WIDTH_HEIGHT
  prefs: []
  type: TYPE_NORMAL
- en: 1 ballX = random.randrange(MAX_WIDTH)
  prefs: []
  type: TYPE_NORMAL
- en: ballY = random.randrange(MAX_HEIGHT)
  prefs: []
  type: TYPE_NORMAL
- en: xSpeed = N_PIXELS_PER_FRAME
  prefs: []
  type: TYPE_NORMAL
- en: ySpeed = N_PIXELS_PER_FRAME
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  prefs: []
  type: TYPE_NORMAL
- en: Clicked the close button? Quit pygame and end the program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2 if (ballX < 0) or (ballX >= MAX_WIDTH):'
  prefs: []
  type: TYPE_NORMAL
- en: 'xSpeed = -xSpeed # reverse X direction'
  prefs: []
  type: TYPE_NORMAL
- en: 'if (ballY < 0) or (ballY >= MAX_HEIGHT):'
  prefs: []
  type: TYPE_NORMAL
- en: 'ySpeed = -ySpeed # reverse Y direction'
  prefs: []
  type: TYPE_NORMAL
- en: Update the ball's location, using the speed in two directions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 ballX = ballX + xSpeed
  prefs: []
  type: TYPE_NORMAL
- en: ballY = ballY + ySpeed
  prefs: []
  type: TYPE_NORMAL
- en: 9 - Clear the window before drawing it again
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(BLACK)
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw the window elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.blit(ballImage, (ballX, ballY))
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: clock.tick(FRAMES_PER_SECOND)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-6: A location-based animation, bouncing a ball around the window*'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating and initializing the two variables xSpeed and ySpeed 1,
  prefs: []
  type: TYPE_NORMAL
- en: which determine how far and in what direction the image should move in
  prefs: []
  type: TYPE_NORMAL
- en: each frame. We initialize both variables to the number of pixels to move per
  prefs: []
  type: TYPE_NORMAL
- en: frame (3), so the image will start by moving three pixels to the right (the
    posi-
  prefs: []
  type: TYPE_NORMAL
- en: tive x direction) and three pixels down (the positive y direction).
  prefs: []
  type: TYPE_NORMAL
- en: In the key part of the program, we handle the x- and y-coordinates
  prefs: []
  type: TYPE_NORMAL
- en: separately 2\. First, we check to see if the x-coordinate of the ball is less
  prefs: []
  type: TYPE_NORMAL
- en: than zero, meaning that part of the image is off the left edge, or past the
  prefs: []
  type: TYPE_NORMAL
- en: MAX_WIDTH pixel and so effectively off the right edge. If either of these is
    the
  prefs: []
  type: TYPE_NORMAL
- en: case, we reverse the sign of the speed in the x direction, meaning it will go
  prefs: []
  type: TYPE_NORMAL
- en: in the opposite direction. For example, if the ball was moving to the right
  prefs: []
  type: TYPE_NORMAL
- en: '**110** Chapter 5'
  prefs: []
  type: TYPE_NORMAL
- en: and went off the right edge, we would change the value of xSpeed from 3 to
  prefs: []
  type: TYPE_NORMAL
- en: –3 to cause the ball to start moving to the left, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Then we do a similar check for the y-coordinate to make the ball
  prefs: []
  type: TYPE_NORMAL
- en: bounce off the top or bottom edge, as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we update the position of the ball by adding the xSpeed to the
  prefs: []
  type: TYPE_NORMAL
- en: ballX coordinate and adding the ySpeed to the ballY coordinate 3\. This posi-
  prefs: []
  type: TYPE_NORMAL
- en: tions the ball at a new location on both axes.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the main loop, we draw the ball. Since we’re updat-
  prefs: []
  type: TYPE_NORMAL
- en: ing the values of ballX and ballY in every frame, the ball appears to ani-
  prefs: []
  type: TYPE_NORMAL
- en: mate smoothly. Try it out. Whenever the ball reaches any edge, it seems to
  prefs: []
  type: TYPE_NORMAL
- en: bounce off.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Pygame rects***'
  prefs: []
  type: TYPE_NORMAL
- en: Next I’ll present a different way to achieve the same result. Rather than
  prefs: []
  type: TYPE_NORMAL
- en: keeping track of the current x- and y-coordinates of the ball in separate
  prefs: []
  type: TYPE_NORMAL
- en: variables, we’ll use the rect of the ball, update the rect every frame, and
  prefs: []
  type: TYPE_NORMAL
- en: check if performing the update would cause any part of the rect to move
  prefs: []
  type: TYPE_NORMAL
- en: outside an edge of the window. This results in fewer variables, and because
  prefs: []
  type: TYPE_NORMAL
- en: we’ll start by making a call to get the rect of an image, it will work with
  prefs: []
  type: TYPE_NORMAL
- en: images of any size.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a rect object, in addition to remembering the left, top,
  prefs: []
  type: TYPE_NORMAL
- en: width, and height as attributes of the rectangle, that object also calculates
  prefs: []
  type: TYPE_NORMAL
- en: and maintains a number of other attributes for you. You can access any of
  prefs: []
  type: TYPE_NORMAL
- en: these attributes directly by name using *dot syntax*, as shown in Table 5-1\.
    (I’ll provide more detail on this i[n Chapter 8.)](index_split_003.html#p192)
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-1:** Direct Access to Attributes of a rect'
  prefs: []
  type: TYPE_NORMAL
- en: '**Attribute**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Description**'
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .x'
  prefs: []
  type: TYPE_NORMAL
- en: The x-coordinate of the left edge of the rect
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .y'
  prefs: []
  type: TYPE_NORMAL
- en: The y-coordinate of the top edge of the rect
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .left'
  prefs: []
  type: TYPE_NORMAL
- en: The x-coordinate of the left edge of the rect (same as
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .x)'
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .top'
  prefs: []
  type: TYPE_NORMAL
- en: The y-coordinate of the top edge of the rect (same as
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .y)'
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .right'
  prefs: []
  type: TYPE_NORMAL
- en: The x-coordinate of the right edge of the rect
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .bottom'
  prefs: []
  type: TYPE_NORMAL
- en: The y-coordinate of the bottom edge of the rect
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .topleft'
  prefs: []
  type: TYPE_NORMAL
- en: 'A two-integer tuple: the coordinates of the upper-left corner of'
  prefs: []
  type: TYPE_NORMAL
- en: the rect
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .bottomleft'
  prefs: []
  type: TYPE_NORMAL
- en: 'A two-integer tuple: the coordinates of the lower-left corner of'
  prefs: []
  type: TYPE_NORMAL
- en: the rect
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .topright'
  prefs: []
  type: TYPE_NORMAL
- en: 'A two-integer tuple: the coordinates of the upper-right corner of'
  prefs: []
  type: TYPE_NORMAL
- en: the rect
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .bottomright'
  prefs: []
  type: TYPE_NORMAL
- en: 'A two-integer tuple: the coordinates of the lower-right corner of'
  prefs: []
  type: TYPE_NORMAL
- en: the rect
  prefs: []
  type: TYPE_NORMAL
- en: '*(continued)*'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pygame **111**
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-1:** Direct Access to Attributes of a rect *(continued)* **Attribute**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Description**'
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .midtop'
  prefs: []
  type: TYPE_NORMAL
- en: 'A two-integer tuple: the coordinates of the midpoint of the top'
  prefs: []
  type: TYPE_NORMAL
- en: edge of the rect
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .midleft'
  prefs: []
  type: TYPE_NORMAL
- en: 'A two-integer tuple: the coordinates of the midpoint of the left'
  prefs: []
  type: TYPE_NORMAL
- en: edge of the rect
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .midbottom'
  prefs: []
  type: TYPE_NORMAL
- en: 'A two-integer tuple: the coordinates of the midpoint of the bot-'
  prefs: []
  type: TYPE_NORMAL
- en: tom edge of the rect
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .midright'
  prefs: []
  type: TYPE_NORMAL
- en: 'A two-integer tuple: the coordinates of the midpoint of the right'
  prefs: []
  type: TYPE_NORMAL
- en: edge of the rect
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .center'
  prefs: []
  type: TYPE_NORMAL
- en: 'A two-integer tuple: the coordinates at the center of the rect'
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .centerx'
  prefs: []
  type: TYPE_NORMAL
- en: The x-coordinate of the center of the width of the rect
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .centery'
  prefs: []
  type: TYPE_NORMAL
- en: The y-coordinate of the center of the height of the rect
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .size'
  prefs: []
  type: TYPE_NORMAL
- en: 'A two-integer tuple: the (width, height) of the rect'
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .width'
  prefs: []
  type: TYPE_NORMAL
- en: The width of the rect
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .height'
  prefs: []
  type: TYPE_NORMAL
- en: The height of the rect
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .w'
  prefs: []
  type: TYPE_NORMAL
- en: The width of the rect (same as *<rect>* .width)
  prefs: []
  type: TYPE_NORMAL
- en: '*<rect>* .h'
  prefs: []
  type: TYPE_NORMAL
- en: The height of the rect (same as *<rect>* .height)
  prefs: []
  type: TYPE_NORMAL
- en: A pygame rect also can be thought of, and accessed as, a list of four ele-
  prefs: []
  type: TYPE_NORMAL
- en: ments. Specifically, you can use an index to get or set any individual part
  prefs: []
  type: TYPE_NORMAL
- en: of a rect. For instance, using the ballRect, the individual elements can be
  prefs: []
  type: TYPE_NORMAL
- en: 'accessed as:'
  prefs: []
  type: TYPE_NORMAL
- en: • ballRect[0] is the x value (but you could also use ballRect.left)
  prefs: []
  type: TYPE_NORMAL
- en: • ballRect[1] is the y value (but you could also use ballRect.top)
  prefs: []
  type: TYPE_NORMAL
- en: • ballRect[2] is the width (but you could also use ballRect.width)
  prefs: []
  type: TYPE_NORMAL
- en: • ballRect[3] is the height (but you could also use ballRect.height)
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5-7 is an alternative version of our bouncing ball program that
  prefs: []
  type: TYPE_NORMAL
- en: maintains all the information about the ball in a rectangle object.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo4_OneBal Bounce/PygameOneBal BounceRects.py**'
  prefs: []
  type: TYPE_NORMAL
- en: pygame demo 4(b) - one image, bounce around the window using rects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 - Import packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: 2 - Define constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BLACK = (0, 0, 0)
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_WIDTH = 640
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_HEIGHT = 480
  prefs: []
  type: TYPE_NORMAL
- en: '**112** Chapter 5'
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  prefs: []
  type: TYPE_NORMAL
- en: N_PIXELS_PER_FRAME = 3
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  prefs: []
  type: TYPE_NORMAL
- en: clock = pygame.time.Clock()
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ballImage = pygame.image.load('images/ball.png')
  prefs: []
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 ballRect = ballImage.get_rect()
  prefs: []
  type: TYPE_NORMAL
- en: MAX_WIDTH = WINDOW_WIDTH - ballRect.width
  prefs: []
  type: TYPE_NORMAL
- en: MAX_HEIGHT = WINDOW_HEIGHT - ballRect.height
  prefs: []
  type: TYPE_NORMAL
- en: ballRect.left = random.randrange(MAX_WIDTH)
  prefs: []
  type: TYPE_NORMAL
- en: ballRect.top = random.randrange(MAX_HEIGHT)
  prefs: []
  type: TYPE_NORMAL
- en: xSpeed = N_PIXELS_PER_FRAME
  prefs: []
  type: TYPE_NORMAL
- en: ySpeed = N_PIXELS_PER_FRAME
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  prefs: []
  type: TYPE_NORMAL
- en: Clicked the close button? Quit pygame and end the program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2 if (ballRect.left < 0) or (ballRect.right >= WINDOW_WIDTH):'
  prefs: []
  type: TYPE_NORMAL
- en: 'xSpeed = -xSpeed # reverse X direction'
  prefs: []
  type: TYPE_NORMAL
- en: 'if (ballRect.top < 0) or (ballRect.bottom >= WINDOW_HEIGHT):'
  prefs: []
  type: TYPE_NORMAL
- en: 'ySpeed = -ySpeed # reverse Y direction'
  prefs: []
  type: TYPE_NORMAL
- en: Update the ball's rectangle using the speed in two directions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ballRect.left = ballRect.left + xSpeed
  prefs: []
  type: TYPE_NORMAL
- en: ballRect.top = ballRect.top + ySpeed
  prefs: []
  type: TYPE_NORMAL
- en: 9 - Clear the window before drawing it again
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(BLACK)
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw the window elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 window.blit(ballImage, ballRect)
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: clock.tick(FRAMES_PER_SECOND)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-7: A location-based animation, bouncing a ball around the window,
    using rects* Introduction to Pygame **113**'
  prefs: []
  type: TYPE_NORMAL
- en: This approach of using a rect object is neither better nor worse than using
    separate variables. The resulting program works exactly the same as
  prefs: []
  type: TYPE_NORMAL
- en: the original. The important lesson here is how you can use and manipulate
  prefs: []
  type: TYPE_NORMAL
- en: attributes of a rect object.
  prefs: []
  type: TYPE_NORMAL
- en: After loading the image of the ball, we call the get_rect() method 1
  prefs: []
  type: TYPE_NORMAL
- en: to get the bounding rectangle of the image. That call returns a rect object,
  prefs: []
  type: TYPE_NORMAL
- en: which we store into a variable called ballRect. We use ballRect.width and
  prefs: []
  type: TYPE_NORMAL
- en: ballRect.height to get direct access to the width and height of the ball image.
  prefs: []
  type: TYPE_NORMAL
- en: (In the previous version, we used a constant of 100 for the width and the
  prefs: []
  type: TYPE_NORMAL
- en: height.) Getting these values from the image that was loaded makes our code
  prefs: []
  type: TYPE_NORMAL
- en: much more adaptable because it means we can use a graphic of any size.
  prefs: []
  type: TYPE_NORMAL
- en: The code also uses the attributes of the rectangle rather than using
  prefs: []
  type: TYPE_NORMAL
- en: separate variables for checking if any part of the ball’s rectangle goes over
  prefs: []
  type: TYPE_NORMAL
- en: an edge. We can use ballRect.left and ballRect.right to see if the ballRect
    is
  prefs: []
  type: TYPE_NORMAL
- en: off the left or right edges 2\. We do a similar test with ballRect.top and ball-
  prefs: []
  type: TYPE_NORMAL
- en: Rect.bottom. Rather than updating individual x- and y-coordinate variables,
  prefs: []
  type: TYPE_NORMAL
- en: we update the left and top of the ballRect.
  prefs: []
  type: TYPE_NORMAL
- en: The other subtle but important change is in the call to draw the ball 3\.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument in the call to blit() can be either an (x, y) tuple or a
  prefs: []
  type: TYPE_NORMAL
- en: rect. The code inside blit() uses the left and top position in the rect as the
  prefs: []
  type: TYPE_NORMAL
- en: x- and y-coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: '**Playing Sounds**'
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of sounds that you might want to play in your pro-
  prefs: []
  type: TYPE_NORMAL
- en: 'grams: short sound effects and background music.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Playing Sound Effects***'
  prefs: []
  type: TYPE_NORMAL
- en: All sound effects must live in external files and must be in either *.wav* or
  prefs: []
  type: TYPE_NORMAL
- en: '*.ogg* format. Playing a relatively short sound effect consists of two steps:
    load the sound from an external sound file once; then at the appropriate time(s)'
  prefs: []
  type: TYPE_NORMAL
- en: play your sound.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load a sound effect into memory, you use a line like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*<soundVariable>* = pygame.mixer.Sound( *<path to sound file>* ) To play the
    sound effect, you only need to call its play() method:'
  prefs: []
  type: TYPE_NORMAL
- en: '*<soundVariable>* .play()'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll modify Listing 5-7 to add a “boing” sound effect whenever the
  prefs: []
  type: TYPE_NORMAL
- en: ball bounces off a side of the window. There is a *sounds* folder in the project
    folder at the same level as the main program. Right after loading the ball
  prefs: []
  type: TYPE_NORMAL
- en: 'image, we load the sound file by adding this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ballImage = pygame.image.load('images/ball.png')
  prefs: []
  type: TYPE_NORMAL
- en: bounceSound = pygame.mixer.Sound('sounds/boing.wav')
  prefs: []
  type: TYPE_NORMAL
- en: '**114** Chapter 5'
  prefs: []
  type: TYPE_NORMAL
- en: 'To play the “boing” sound effect whenever we change either the horizontal or
    vertical direction of the ball, we modify section #8 to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if (ballRect.left < 0) or (ballRect.right >= WINDOW_WIDTH):'
  prefs: []
  type: TYPE_NORMAL
- en: 'xSpeed = -xSpeed # reverse X direction'
  prefs: []
  type: TYPE_NORMAL
- en: bounceSound.play()
  prefs: []
  type: TYPE_NORMAL
- en: 'if (ballRect.top < 0) or (ballRect.bottom >= WINDOW_HEIGHT):'
  prefs: []
  type: TYPE_NORMAL
- en: 'ySpeed = -ySpeed # reverse Y direction'
  prefs: []
  type: TYPE_NORMAL
- en: bounceSound.play()
  prefs: []
  type: TYPE_NORMAL
- en: When you find a condition that should play a sound effect, you add a
  prefs: []
  type: TYPE_NORMAL
- en: call to the play() method of the sound. There are many more options for
  prefs: []
  type: TYPE_NORMAL
- en: controlling sound effects; you can find details in the official documentation
  prefs: []
  type: TYPE_NORMAL
- en: at [*https://www.pygame.org/docs/ref/mixer.html*](https://www.pygame.org/docs/ref/mixer.html).
  prefs: []
  type: TYPE_NORMAL
- en: '***Playing Background Music***'
  prefs: []
  type: TYPE_NORMAL
- en: Playing background music involves two lines of code using calls to the
  prefs: []
  type: TYPE_NORMAL
- en: pygame.mixer.music module. First, you need this to load the sound file into
  prefs: []
  type: TYPE_NORMAL
- en: 'memory:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.mixer.music.load( *<path to sound file>* )
  prefs: []
  type: TYPE_NORMAL
- en: 'The *<path to sound file>* is a path string where the sound file can be found.
    You can use *.mp3* files, which seem to work best, as well as *.wav* or *.ogg*
    files. When you want to start the music playing, you need to make this call:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.mixer.music.play( *<number of loops>* , *<starting position>* ) To play
    some background music repeatedly, you can pass in a -1 for
  prefs: []
  type: TYPE_NORMAL
- en: '*<number of loops>* to run the music forever. The *<starting position>* is
    typically set to 0 to indicate that you want to play the sound from the beginning.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a downloadable, modified version of the bouncing ball pro-
  prefs: []
  type: TYPE_NORMAL
- en: gram that properly loads the sound effect and background music files and
  prefs: []
  type: TYPE_NORMAL
- en: 'starts the background sound playing. The only changes are in section #4, as'
  prefs: []
  type: TYPE_NORMAL
- en: shown here.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo4_OneBal Bounce/PyGameOneBal BounceWithSound.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ballImage = pygame.image.load('images/ball.png')
  prefs: []
  type: TYPE_NORMAL
- en: bounceSound = pygame.mixer.Sound('sounds/boing.wav')
  prefs: []
  type: TYPE_NORMAL
- en: pygame.mixer.music.load('sounds/background.mp3')
  prefs: []
  type: TYPE_NORMAL
- en: pygame.mixer.music.play(-1, 0.0)
  prefs: []
  type: TYPE_NORMAL
- en: Pygame allows for much more intricate handling of background
  prefs: []
  type: TYPE_NORMAL
- en: sounds. You can find the full documentation a[t *https://www.pygame.org/docs/*](https://www.pygame.org/docs/ref/music.html#module-pygame.mixer.music)
  prefs: []
  type: TYPE_NORMAL
- en: '[*ref/music.html#module-pygame.mixer.music*](https://www.pygame.org/docs/ref/music.html#module-pygame.mixer.music).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pygame **115**
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In order to make future examples more clearly focused on OOP, I’ll leave out
    calls to* *play sound effects and background music. But adding sounds greatly
    enhances the* *user experience of a game, and I strongly encourage including them.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Drawing Shapes**'
  prefs: []
  type: TYPE_NORMAL
- en: Pygame offers a number of built-in functions that allow you to draw certain
  prefs: []
  type: TYPE_NORMAL
- en: shapes known as *primitives*, which include lines, circles, ellipses, arcs,
    polygons, and rectangles. Table 5-2 provides a list of these functions. Note that
  prefs: []
  type: TYPE_NORMAL
- en: there are two calls that draw *anti-aliased* lines. These are lines that include
    blended colors at the edges to make the lines look smooth and less jagged.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two key advantages to using these drawing functions: they exe-'
  prefs: []
  type: TYPE_NORMAL
- en: cute extremely quickly, and they allow you to draw simple shapes without
  prefs: []
  type: TYPE_NORMAL
- en: having to create or load images from external files.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-2:** Functions for Drawing Shapes'
  prefs: []
  type: TYPE_NORMAL
- en: '**Function**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Description**'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.aaline()
  prefs: []
  type: TYPE_NORMAL
- en: Draws an anti-aliased line
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.aalines()
  prefs: []
  type: TYPE_NORMAL
- en: Draws a series of anti-aliased lines
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.arc()
  prefs: []
  type: TYPE_NORMAL
- en: Draws an arc
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.circle()
  prefs: []
  type: TYPE_NORMAL
- en: Draws a circle
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.ellipse()
  prefs: []
  type: TYPE_NORMAL
- en: Draws an ellipse
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.line()
  prefs: []
  type: TYPE_NORMAL
- en: Draws a line
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.lines()
  prefs: []
  type: TYPE_NORMAL
- en: Draws a series of lines
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.polygon()
  prefs: []
  type: TYPE_NORMAL
- en: Draws a polygon
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.rect()
  prefs: []
  type: TYPE_NORMAL
- en: Draws a rectangle
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5-7 shows the output of a sample program that demonstrates
  prefs: []
  type: TYPE_NORMAL
- en: calls to these primitive drawing functions.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5-8 is the code of the sample program, using the same 12-step
  prefs: []
  type: TYPE_NORMAL
- en: template that produced the output in Figure 5-7\.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo5_DrawingShapes.py**'
  prefs: []
  type: TYPE_NORMAL
- en: pygame demo 5 - drawing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  prefs: []
  type: TYPE_NORMAL
- en: Clicked the close button? Quit pygame and end the program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: '**116** Chapter 5'
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 9 - Clear the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(GRAY)
  prefs: []
  type: TYPE_NORMAL
- en: '1 # 10 - Draw all window elements'
  prefs: []
  type: TYPE_NORMAL
- en: Draw a box
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'pygame.draw.line(window, BLUE, (20, 20), (60, 20), 4) # top'
  prefs: []
  type: TYPE_NORMAL
- en: 'pygame.draw.line(window, BLUE, (20, 20), (20, 60), 4) # left'
  prefs: []
  type: TYPE_NORMAL
- en: 'pygame.draw.line(window, BLUE, (20, 60), (60, 60), 4) # right'
  prefs: []
  type: TYPE_NORMAL
- en: 'pygame.draw.line(window, BLUE, (60, 20), (60, 60), 4) # bottom'
  prefs: []
  type: TYPE_NORMAL
- en: Draw an X in the box
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.draw.line(window, BLUE, (20, 20), (60, 60), 1)
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.line(window, BLUE, (20, 60), (60, 20), 1)
  prefs: []
  type: TYPE_NORMAL
- en: Draw a filled circle and an empty circle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'pygame.draw.circle(window, GREEN, (250, 50), 30, 0) # filled'
  prefs: []
  type: TYPE_NORMAL
- en: 'pygame.draw.circle(window, GREEN, (400, 50), 30, 2) # 2 pixel edge'
  prefs: []
  type: TYPE_NORMAL
- en: Draw a filled rectangle and an empty rectangle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'pygame.draw.rect(window, RED, (250, 150, 100, 50), 0) # filled'
  prefs: []
  type: TYPE_NORMAL
- en: 'pygame.draw.rect(window, RED, (400, 150, 100, 50), 1) # 1 pixel edge'
  prefs: []
  type: TYPE_NORMAL
- en: Draw a filled ellipse and an empty ellipse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'pygame.draw.ellipse(window, YELLOW, (250, 250, 80, 40), 0) # filled'
  prefs: []
  type: TYPE_NORMAL
- en: 'pygame.draw.ellipse(window, YELLOW, (400, 250, 80, 40), 2) # 2 pixel edge'
  prefs: []
  type: TYPE_NORMAL
- en: Draw a six-sided polygon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.draw.polygon(window, TEAL, ((240, 350), (350, 350),
  prefs: []
  type: TYPE_NORMAL
- en: (410, 410), (350, 470),
  prefs: []
  type: TYPE_NORMAL
- en: (240, 470), (170, 410)))
  prefs: []
  type: TYPE_NORMAL
- en: Draw an arc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.draw.arc(window, BLUE, (20, 400, 100, 100), 0, 2, 5)
  prefs: []
  type: TYPE_NORMAL
- en: 'Draw anti-aliased lines: a single line, then a list of points'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.draw.aaline(window, RED, (500, 400), (540, 470), 1)
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.aalines(window, BLUE, True,
  prefs: []
  type: TYPE_NORMAL
- en: ((580, 400), (587, 450),
  prefs: []
  type: TYPE_NORMAL
- en: (595, 460), (600, 444)), 1)
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'clock.tick(FRAMES_PER_SECOND) # make pygame wait'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-8: A program to demonstrate cal s to primitive drawing functions
    in pygame* The drawing of all the primitives occurs in section #10 1\. We make'
  prefs: []
  type: TYPE_NORMAL
- en: calls to pygame’s drawing functions to draw a box with two diagonals, filled
  prefs: []
  type: TYPE_NORMAL
- en: and empty circles, filled and empty rectangles, filled and empty ovals, a six-
  prefs: []
  type: TYPE_NORMAL
- en: sided polygon, an arc, and two anti-aliased lines.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pygame **117**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 20](index-147_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-7: A sample program that demonstrates using cal s to draw primitive
    shapes*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Reference for Primitive Shapes***'
  prefs: []
  type: TYPE_NORMAL
- en: For your reference, here is the documentation for the pygame methods to
  prefs: []
  type: TYPE_NORMAL
- en: draw these primitives. In all of the following, the color argument expects
  prefs: []
  type: TYPE_NORMAL
- en: 'you to pass in a tuple of RGB values:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Anti-aliased line**'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.aaline(window, color, startpos, endpos, blend=True)
  prefs: []
  type: TYPE_NORMAL
- en: Draws an anti-aliased line in the window. If blend is True, the shades will
  prefs: []
  type: TYPE_NORMAL
- en: be blended with existing pixel shades instead of overwriting pixels.
  prefs: []
  type: TYPE_NORMAL
- en: '**Anti-aliased lines**'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.aalines(window, color, closed, points, blend=True)
  prefs: []
  type: TYPE_NORMAL
- en: Draws a sequence of anti-aliased lines in the window. The closed argu-
  prefs: []
  type: TYPE_NORMAL
- en: ment is a simple Boolean; if it’s True, a line will be drawn between the
  prefs: []
  type: TYPE_NORMAL
- en: first and last points to complete the shape. The points argument is a list
  prefs: []
  type: TYPE_NORMAL
- en: or tuple of (x, y) coordinates to be connected by line segments (there
  prefs: []
  type: TYPE_NORMAL
- en: must be at least two). The Boolean blend argument, if set to True, will
  prefs: []
  type: TYPE_NORMAL
- en: blend the shades with existing pixel shades instead of overwriting them.
  prefs: []
  type: TYPE_NORMAL
- en: '**118** Chapter 5'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arc**'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.arc(window, color, rect, angle_start, angle_stop, width=0)
  prefs: []
  type: TYPE_NORMAL
- en: Draws an arc in the window. The arc will fit inside the given rect. The
  prefs: []
  type: TYPE_NORMAL
- en: two angle arguments are the initial and final angles (in radians, with
  prefs: []
  type: TYPE_NORMAL
- en: zero on the right). The width argument is the thickness to draw the
  prefs: []
  type: TYPE_NORMAL
- en: outer edge.
  prefs: []
  type: TYPE_NORMAL
- en: '**Circle**'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.circle(window, color, pos, radius, width=0)
  prefs: []
  type: TYPE_NORMAL
- en: Draws a circle in the window. The pos is the center of the circle, and
  prefs: []
  type: TYPE_NORMAL
- en: radius is the radius. The width argument is the thickness to draw the
  prefs: []
  type: TYPE_NORMAL
- en: outer edge. If width is 0, then the circle will be filled.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ellipse**'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.ellipse(window, color, rect, width=0)
  prefs: []
  type: TYPE_NORMAL
- en: Draws an ellipse in the window. The given rect is the area that the
  prefs: []
  type: TYPE_NORMAL
- en: ellipse will fill. The width argument is the thickness to draw the outer
  prefs: []
  type: TYPE_NORMAL
- en: edge. If width is 0, then the ellipse will be filled.
  prefs: []
  type: TYPE_NORMAL
- en: '**Line**'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.line(window, color, startpos, endpos, width=1)
  prefs: []
  type: TYPE_NORMAL
- en: Draws a line in a window. The width argument is the thickness of the line.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines**'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.lines(window, color, closed, points, width=1)
  prefs: []
  type: TYPE_NORMAL
- en: Draws a sequence of lines in the window. The closed argument is a simple
  prefs: []
  type: TYPE_NORMAL
- en: Boolean; if it’s True, a line will be drawn between the first and last points
  prefs: []
  type: TYPE_NORMAL
- en: to complete the shape. The points argument is a list or tuple of (x, y)
  prefs: []
  type: TYPE_NORMAL
- en: coordinates to be connected by line segments (there must be at least
  prefs: []
  type: TYPE_NORMAL
- en: two). The width argument is the thickness of the line. Note that specify-
  prefs: []
  type: TYPE_NORMAL
- en: ing a line width wider than 1 does not fill in the gaps between the lines.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, wide lines and sharp corners won’t be joined seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Polygon**'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.polygon(window, color, pointslist, width=0)
  prefs: []
  type: TYPE_NORMAL
- en: Draws a polygon in the window. The pointslist specifies the vertices
  prefs: []
  type: TYPE_NORMAL
- en: of the polygon. The width argument is the thickness to draw the outer
  prefs: []
  type: TYPE_NORMAL
- en: edge. If width is 0, then the polygon will be filled.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Pygame **119**
  prefs: []
  type: TYPE_NORMAL
- en: '**Rectangle**'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.draw.rect(window, color, rect, width=0)
  prefs: []
  type: TYPE_NORMAL
- en: Draws a rectangle in the window. The rect is the area of the rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: The width argument is the thickness to draw the outer edge. If width is 0,
  prefs: []
  type: TYPE_NORMAL
- en: then the rectangle will be filled.
  prefs: []
  type: TYPE_NORMAL
- en: '**N O T E**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For additional information, see* [http://www.pygame.org/docs/ref/draw.html
    *.*](http://www.pygame.org/docs/ref/draw.html)'
  prefs: []
  type: TYPE_NORMAL
- en: The set of primitive calls allows you the flexibility to draw any shapes
  prefs: []
  type: TYPE_NORMAL
- en: you wish. Again, the order in which you make calls is important. Think of
  prefs: []
  type: TYPE_NORMAL
- en: the order of your calls as layers; elements that are drawn early can be over-
  prefs: []
  type: TYPE_NORMAL
- en: laid by later calls to any other drawing primitive function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter I introduced the basics of pygame. You installed pygame on
  prefs: []
  type: TYPE_NORMAL
- en: your computer, then learned about the model of event-driven programming
  prefs: []
  type: TYPE_NORMAL
- en: and the use of events, which is very different from coding text-based pro-
  prefs: []
  type: TYPE_NORMAL
- en: grams. I explained the coordinate system of pixels in a window and the way
  prefs: []
  type: TYPE_NORMAL
- en: that colors are represented in code.
  prefs: []
  type: TYPE_NORMAL
- en: To start right at the beginning with pygame, I introduced a 12-section
  prefs: []
  type: TYPE_NORMAL
- en: template that does nothing but bring up a window and can be used to build
  prefs: []
  type: TYPE_NORMAL
- en: any pygame-based program. Using that framework, we then built sample
  prefs: []
  type: TYPE_NORMAL
- en: programs that showed how to draw an image in the window (using blit()),
  prefs: []
  type: TYPE_NORMAL
- en: how to detect mouse events, and how to handle keyboard input. The next
  prefs: []
  type: TYPE_NORMAL
- en: demonstration explained how to build a location-based animation.
  prefs: []
  type: TYPE_NORMAL
- en: Rectangles are highly important in pygame, so I covered how the attri-
  prefs: []
  type: TYPE_NORMAL
- en: butes of a rect object can be used. I also provided some example code to
  prefs: []
  type: TYPE_NORMAL
- en: show how to play sound effects and background music to enhance the user’s
  prefs: []
  type: TYPE_NORMAL
- en: enjoyment of your programs. Finally, I introduced how to use pygame meth-
  prefs: []
  type: TYPE_NORMAL
- en: ods to draw primitive shapes in a window.
  prefs: []
  type: TYPE_NORMAL
- en: While I have introduced many concepts within pygame, almost every-
  prefs: []
  type: TYPE_NORMAL
- en: thing I showed in this chapter has essentially been procedural. The rect
  prefs: []
  type: TYPE_NORMAL
- en: object is an example of object-oriented code built directly into pygame. In
  prefs: []
  type: TYPE_NORMAL
- en: the next chapter, I’ll show how to use OOP in code to use pygame more
  prefs: []
  type: TYPE_NORMAL
- en: effectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**120** Chapter 5'
  prefs: []
  type: TYPE_NORMAL
- en: '**6**'
  prefs: []
  type: TYPE_NORMAL
- en: '**O B J E C T- O R I E N T E D P Y G A M E**'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter I’ll demonstrate how you
  prefs: []
  type: TYPE_NORMAL
- en: can use OOP techniques effectively within
  prefs: []
  type: TYPE_NORMAL
- en: the pygame framework. We’ll start off with
  prefs: []
  type: TYPE_NORMAL
- en: an example of procedural code, then split that
  prefs: []
  type: TYPE_NORMAL
- en: code into a single class and some main code that calls
  prefs: []
  type: TYPE_NORMAL
- en: the methods of that class. After that, we’ll build two
  prefs: []
  type: TYPE_NORMAL
- en: classes, SimpleButton and SimpleText, that implement
  prefs: []
  type: TYPE_NORMAL
- en: 'basic user interface widgets: a button and a field for'
  prefs: []
  type: TYPE_NORMAL
- en: displaying text. I’ll also introduce the concept of a
  prefs: []
  type: TYPE_NORMAL
- en: callback.
  prefs: []
  type: TYPE_NORMAL
- en: '**Building the Screensaver Ball with OOP Pygame**'
  prefs: []
  type: TYPE_NORMAL
- en: I[n Chapter 5, w](#p118)e created an old-school screensaver where a ball bounced
    around inside a window (Listing 5-6, if you need to refresh your memory).
  prefs: []
  type: TYPE_NORMAL
- en: That code works, but the data for the ball and the code to manipu-
  prefs: []
  type: TYPE_NORMAL
- en: late the ball are intertwined, meaning there’s a lot of initialization code,
  prefs: []
  type: TYPE_NORMAL
- en: and the code to update and draw the ball are embedded in the 12-step
  prefs: []
  type: TYPE_NORMAL
- en: framework.
  prefs: []
  type: TYPE_NORMAL
- en: A more modular approach is to split the code into a Ball class and a
  prefs: []
  type: TYPE_NORMAL
- en: main program that instantiates a Ball object and makes calls to its methods.
  prefs: []
  type: TYPE_NORMAL
- en: In this section we’ll make this split, and I’ll show you how to create multiple
  prefs: []
  type: TYPE_NORMAL
- en: balls from the Ball class.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a Ball Class***'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by extracting all code relating to the ball from the main pro-
  prefs: []
  type: TYPE_NORMAL
- en: gram and moving it into a separate Ball class. Looking at the original code,
  prefs: []
  type: TYPE_NORMAL
- en: 'we can see that the sections that deal with the ball are:'
  prefs: []
  type: TYPE_NORMAL
- en: '• Section #4, which loads the image of the ball'
  prefs: []
  type: TYPE_NORMAL
- en: '• Section #5, which creates and initializes all the variables that have'
  prefs: []
  type: TYPE_NORMAL
- en: something to do with the ball
  prefs: []
  type: TYPE_NORMAL
- en: '• Section #8, which includes code for moving the ball, detecting an edge'
  prefs: []
  type: TYPE_NORMAL
- en: bounce, and changing speed and direction
  prefs: []
  type: TYPE_NORMAL
- en: '• Section #10, which draws the ball'
  prefs: []
  type: TYPE_NORMAL
- en: From this we can conclude that our Ball class will require the following
  prefs: []
  type: TYPE_NORMAL
- en: 'methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**create()** Loads an image, sets a location, and initializes all instance'
  prefs: []
  type: TYPE_NORMAL
- en: variables
  prefs: []
  type: TYPE_NORMAL
- en: '**update()** Changes the location of the ball in every frame, based on the'
  prefs: []
  type: TYPE_NORMAL
- en: x speed and y speed of the ball
  prefs: []
  type: TYPE_NORMAL
- en: '**draw()** Draws the ball in the window'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to create a project folder, in which you need a *Ball.py*
  prefs: []
  type: TYPE_NORMAL
- en: for the new Ball class, the main code file *Main_BallBounce.py*, and an *images*
    folder containing the *ball.png* image file.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6-1 shows the code of the new Ball class.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo6_Bal BounceObjectOriented/Bal .py**'
  prefs: []
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  prefs: []
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: Ball class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class Ball():'
  prefs: []
  type: TYPE_NORMAL
- en: '1 def __init__(self, window, windowWidth, windowHeight):'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.window = window # remember the window, so we can draw later'
  prefs: []
  type: TYPE_NORMAL
- en: self.windowWidth = windowWidth
  prefs: []
  type: TYPE_NORMAL
- en: self.windowHeight = windowHeight
  prefs: []
  type: TYPE_NORMAL
- en: '**122** Chapter 6'
  prefs: []
  type: TYPE_NORMAL
- en: 2 self.image = pygame.image.load('images/ball.png')
  prefs: []
  type: TYPE_NORMAL
- en: A rect is made up of [x, y, width, height]
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ballRect = self.image.get_rect()
  prefs: []
  type: TYPE_NORMAL
- en: self.width = ballRect.width
  prefs: []
  type: TYPE_NORMAL
- en: self.height = ballRect.height
  prefs: []
  type: TYPE_NORMAL
- en: self.maxWidth = windowWidth - self.width
  prefs: []
  type: TYPE_NORMAL
- en: self.maxHeight = windowHeight - self.height
  prefs: []
  type: TYPE_NORMAL
- en: Pick a random starting position
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3 self.x = random.randrange(0, self.maxWidth)
  prefs: []
  type: TYPE_NORMAL
- en: self.y = random.randrange(0, self.maxHeight)
  prefs: []
  type: TYPE_NORMAL
- en: Choose a random speed between -4 and 4, but not zero,
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: in both the x and y directions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4 speedsList = [-4, -3, -2, -1, 1, 2, 3, 4]
  prefs: []
  type: TYPE_NORMAL
- en: self.xSpeed = random.choice(speedsList)
  prefs: []
  type: TYPE_NORMAL
- en: self.ySpeed = random.choice(speedsList)
  prefs: []
  type: TYPE_NORMAL
- en: '5 def update(self):'
  prefs: []
  type: TYPE_NORMAL
- en: Check for hitting a wall. If so, change that direction.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if (self.x < 0) or (self.x >= self.maxWidth):'
  prefs: []
  type: TYPE_NORMAL
- en: self.xSpeed = -self.xSpeed
  prefs: []
  type: TYPE_NORMAL
- en: 'if (self.y < 0) or (self.y >= self.maxHeight):'
  prefs: []
  type: TYPE_NORMAL
- en: self.ySpeed = -self.ySpeed
  prefs: []
  type: TYPE_NORMAL
- en: Update the Ball's x and y, using the speed in two directions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.x = self.x + self.xSpeed
  prefs: []
  type: TYPE_NORMAL
- en: self.y = self.y + self.ySpeed
  prefs: []
  type: TYPE_NORMAL
- en: '6 def draw(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.window.blit(self.image, (self.x, self.y))
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-1: The new Ball class*'
  prefs: []
  type: TYPE_NORMAL
- en: When we instantiate a Ball object, the __init__() method receives three
  prefs: []
  type: TYPE_NORMAL
- en: 'pieces of data: the window to draw into, the width of the window, and the'
  prefs: []
  type: TYPE_NORMAL
- en: height of the window 1\. We save the window variable into the instance vari-
  prefs: []
  type: TYPE_NORMAL
- en: able self.window so that we can use it later in the draw() method, and we do
  prefs: []
  type: TYPE_NORMAL
- en: the same with the self.windowHeight and self.windowWidth instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: We then load the image of the ball using the path to the file and get the
  prefs: []
  type: TYPE_NORMAL
- en: rect of that ball image 2\. We need the rect to calculate the maximum val-
  prefs: []
  type: TYPE_NORMAL
- en: ues for x and y so that the ball will always fully appear in the window. Next,
  prefs: []
  type: TYPE_NORMAL
- en: we pick a randomized starting location for the ball 3\. Finally, we set the
  prefs: []
  type: TYPE_NORMAL
- en: speed in the x and y directions to a random value between –4 and 4 (but
  prefs: []
  type: TYPE_NORMAL
- en: not 0), representing the number of pixels to move per frame 4\. Because
  prefs: []
  type: TYPE_NORMAL
- en: of these numbers, the ball may move differently each time we run the pro-
  prefs: []
  type: TYPE_NORMAL
- en: gram. All these values are saved in instance variables to be used by other
  prefs: []
  type: TYPE_NORMAL
- en: methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the main program, we’ll call the update() method in each frame of
  prefs: []
  type: TYPE_NORMAL
- en: the main loop, so this is where we place the code that checks for the ball
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Pygame **123**
  prefs: []
  type: TYPE_NORMAL
- en: hitting any border of the window 5\. If it does hit an edge, we reverse the
    speed in that direction and modify the x- and y-coordinates (self.x and
  prefs: []
  type: TYPE_NORMAL
- en: self.y) by the current speed in the x and y directions.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll also call the draw() method, which simply calls blit() to draw the
  prefs: []
  type: TYPE_NORMAL
- en: ball at its current x- and y-coordinates 6, in every frame of the main loop.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using the Ball Class***'
  prefs: []
  type: TYPE_NORMAL
- en: Now all functionality associated with a ball has been placed in the Ball
  prefs: []
  type: TYPE_NORMAL
- en: class code. All the main program needs to do is create the ball, then call
  prefs: []
  type: TYPE_NORMAL
- en: its update() and draw() methods in every frame. Listing 6-2 shows the greatly
  prefs: []
  type: TYPE_NORMAL
- en: simplified code of the main program.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo6_Bal BounceObjectOriented/Main_Bal Bounce.py**'
  prefs: []
  type: TYPE_NORMAL
- en: pygame demo 6(a) - using the Ball class, bounce one ball
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 - Import packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  prefs: []
  type: TYPE_NORMAL
- en: import random
  prefs: []
  type: TYPE_NORMAL
- en: '1 from Ball import * # bring in the Ball class code'
  prefs: []
  type: TYPE_NORMAL
- en: 2 - Define constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BLACK = (0, 0, 0)
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_WIDTH = 640
  prefs: []
  type: TYPE_NORMAL
- en: WINDOW_HEIGHT = 480
  prefs: []
  type: TYPE_NORMAL
- en: FRAMES_PER_SECOND = 30
  prefs: []
  type: TYPE_NORMAL
- en: 3 - Initialize the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.init()
  prefs: []
  type: TYPE_NORMAL
- en: window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
  prefs: []
  type: TYPE_NORMAL
- en: clock = pygame.time.Clock()
  prefs: []
  type: TYPE_NORMAL
- en: '4 - Load assets: image(s), sound(s), etc.'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2 oBall = Ball(window, WINDOW_WIDTH, WINDOW_HEIGHT)
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3 oBall.update() # tell the Ball to update itself'
  prefs: []
  type: TYPE_NORMAL
- en: '**124** Chapter 6'
  prefs: []
  type: TYPE_NORMAL
- en: 9 - Clear the window before drawing it again
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(BLACK)
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw the window elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '4 oBall.draw() # tell the Ball to draw itself'
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: clock.tick(FRAMES_PER_SECOND)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-2: The new main program that instantiates a Ball and makes cal s
    to its methods* If you compare this new main program with the original code in'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 5-6, you’ll see that it’s much simpler and clearer. We use an import
  prefs: []
  type: TYPE_NORMAL
- en: statement to bring in the Ball class code 1\. We create a Ball object, passing
  prefs: []
  type: TYPE_NORMAL
- en: in the window that we created and the width and height of that window 2,
  prefs: []
  type: TYPE_NORMAL
- en: and we save the resulting Ball object in a variable named oBall.
  prefs: []
  type: TYPE_NORMAL
- en: The responsibility of moving the ball is now in the Ball class code, so
  prefs: []
  type: TYPE_NORMAL
- en: here we only need to call the update() method of the oBall object 3\. Since
  prefs: []
  type: TYPE_NORMAL
- en: the Ball object knows how big the window is, how big the image of the ball
  prefs: []
  type: TYPE_NORMAL
- en: is, and the location and the speed of the ball, it can do all the calculations
    it
  prefs: []
  type: TYPE_NORMAL
- en: needs to do to move the ball and bounce it off the walls.
  prefs: []
  type: TYPE_NORMAL
- en: The main code calls the draw() method of the oBall object 4, but the
  prefs: []
  type: TYPE_NORMAL
- en: actual drawing is done in the oBall object.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Many Ball Objects***'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s make a slight but important modification to the main program to
  prefs: []
  type: TYPE_NORMAL
- en: create multiple Ball objects. This is one of the real powers of object orien-
  prefs: []
  type: TYPE_NORMAL
- en: 'tation: to create three balls, we only have to instantiate three Ball objects'
  prefs: []
  type: TYPE_NORMAL
- en: from the Ball class. Here we’ll use a basic approach and build a list of Ball
  prefs: []
  type: TYPE_NORMAL
- en: objects. In each frame, we’ll iterate through the list of Ball objects, tell
    each
  prefs: []
  type: TYPE_NORMAL
- en: one to update its location, then iterate again to tell each one to draw itself.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6-3 shows a modified main program that creates and updates three
  prefs: []
  type: TYPE_NORMAL
- en: Ball objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo6_BallBounceObjectOriented/Main_BallBounceManyBalls.py**'
  prefs: []
  type: TYPE_NORMAL
- en: pygame demo 6(b) - using the Ball class, bounce many balls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  prefs: []
  type: TYPE_NORMAL
- en: N_BALLS = 3
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  prefs: []
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 ballList = []
  prefs: []
  type: TYPE_NORMAL
- en: 'for oBall in range(0, N_BALLS):'
  prefs: []
  type: TYPE_NORMAL
- en: Each time through the loop, create a Ball object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: oBall = Ball(window, WINDOW_WIDTH, WINDOW_HEIGHT)
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Pygame **125**
  prefs: []
  type: TYPE_NORMAL
- en: 'ballList.append(oBall) # append the new Ball to the list of Balls'
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: '--- snip ---'
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2 for oBall in ballList:'
  prefs: []
  type: TYPE_NORMAL
- en: 'oBall.update() # tell each Ball to update itself'
  prefs: []
  type: TYPE_NORMAL
- en: 9 - Clear the window before drawing it again
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(BLACK)
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw the window elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '3 for oBall in ballList:'
  prefs: []
  type: TYPE_NORMAL
- en: 'oBall.draw() # tell each Ball to draw itself'
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: clock.tick(FRAMES_PER_SECOND)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-3: Creating, moving, and displaying three bal s*'
  prefs: []
  type: TYPE_NORMAL
- en: We start with an empty list of Ball objects 1\. Then we have a loop
  prefs: []
  type: TYPE_NORMAL
- en: that creates three Ball objects, each of which we append to our list of Ball
  prefs: []
  type: TYPE_NORMAL
- en: objects, ballList. Each Ball object chooses and remembers a randomized
  prefs: []
  type: TYPE_NORMAL
- en: starting location and a randomized speed in both the x and y directions.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the main loop, we iterate through all the Ball objects and tell
  prefs: []
  type: TYPE_NORMAL
- en: each one to update itself 2, changing the x- and y-coordinates of each Ball
  prefs: []
  type: TYPE_NORMAL
- en: object to a new location. We then iterate through the list again, calling the
  prefs: []
  type: TYPE_NORMAL
- en: draw() method of each Ball object 3\.
  prefs: []
  type: TYPE_NORMAL
- en: When we run the program, we see three balls, each starting at a ran-
  prefs: []
  type: TYPE_NORMAL
- en: domized location and each moving with a randomized x and y speed. Each
  prefs: []
  type: TYPE_NORMAL
- en: ball bounces correctly off the boundaries of the window.
  prefs: []
  type: TYPE_NORMAL
- en: Using this object-oriented approach, we made no changes to the Ball
  prefs: []
  type: TYPE_NORMAL
- en: class, but just changed our main program to now manage a list of Ball
  prefs: []
  type: TYPE_NORMAL
- en: objects instead of a single Ball object. This is a common, and very positive,
  prefs: []
  type: TYPE_NORMAL
- en: 'side effect of OOP code: well-written classes can often be reused without'
  prefs: []
  type: TYPE_NORMAL
- en: change.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Many, Many Ball Objects***'
  prefs: []
  type: TYPE_NORMAL
- en: We can change the value of the constant N_BALLS from 3 to some much
  prefs: []
  type: TYPE_NORMAL
- en: larger value, like 300, to quickly create that many balls (Figure 6-1). By
  prefs: []
  type: TYPE_NORMAL
- en: changing just a single constant, we make a major change to the behavior
  prefs: []
  type: TYPE_NORMAL
- en: of the program. Each ball maintains its own speed and location and draws
  prefs: []
  type: TYPE_NORMAL
- en: itself.
  prefs: []
  type: TYPE_NORMAL
- en: '**126** Chapter 6'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 21](index-156_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-1: Creating, updating, and drawing 300 Ball objects*'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that we can instantiate any number of objects from a single
  prefs: []
  type: TYPE_NORMAL
- en: script will be vital not only in defining game objects like spaceships, zom-
  prefs: []
  type: TYPE_NORMAL
- en: bies, bullets, treasures, and so on, but also in building GUI controls such
    as
  prefs: []
  type: TYPE_NORMAL
- en: buttons, checkboxes, text input fields, and text outputs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Building a Reusable Object-Oriented Button**'
  prefs: []
  type: TYPE_NORMAL
- en: The simple button is one of the most recognizable elements of a graphical
  prefs: []
  type: TYPE_NORMAL
- en: user interface. The standard behavior of a button consists of the user using
  prefs: []
  type: TYPE_NORMAL
- en: their mouse to click down on the button image and then releasing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Buttons typically consist of at least two images: one to represent the *up*'
  prefs: []
  type: TYPE_NORMAL
- en: or normal state of the button and another to represent the *down* or pressed
  prefs: []
  type: TYPE_NORMAL
- en: state of the button. The sequence of a click can be broken down into the
  prefs: []
  type: TYPE_NORMAL
- en: 'following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. User moves the mouse pointer over the button
  prefs: []
  type: TYPE_NORMAL
- en: 2\. User presses the mouse button down
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Program reacts by changing the image to the down state
  prefs: []
  type: TYPE_NORMAL
- en: 4\. User releases the mouse button
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Program reacts by showing the up image of the button
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Program performs some action based on the button click
  prefs: []
  type: TYPE_NORMAL
- en: Good GUIs also allow the user to click down on a button, temporarily
  prefs: []
  type: TYPE_NORMAL
- en: roll off the button, changing the button to the up state, and then, with the
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Pygame **127**
  prefs: []
  type: TYPE_NORMAL
- en: mouse button still down, roll back over the image so the button changes back
    to the down image. If the user clicks down on a button but then rolls
  prefs: []
  type: TYPE_NORMAL
- en: the mouse off and lifts up on the mouse button, that is not considered a
  prefs: []
  type: TYPE_NORMAL
- en: click. This means the program takes action only when the user presses
  prefs: []
  type: TYPE_NORMAL
- en: down and releases while the mouse is positioned over the image of a button.
  prefs: []
  type: TYPE_NORMAL
- en: '***Building a Button Class***'
  prefs: []
  type: TYPE_NORMAL
- en: The button behavior should be common and consistent for all buttons used
  prefs: []
  type: TYPE_NORMAL
- en: in a GUI, so we’ll build a class that takes care of the behavior details. Once
  prefs: []
  type: TYPE_NORMAL
- en: we’ve built a simple button class, we can instantiate any number of buttons
  prefs: []
  type: TYPE_NORMAL
- en: and they’ll all work exactly the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider what behaviors our button class must support. We’ll need
  prefs: []
  type: TYPE_NORMAL
- en: 'methods to:'
  prefs: []
  type: TYPE_NORMAL
- en: • Load the images of the up and down states, then initialize any instance
  prefs: []
  type: TYPE_NORMAL
- en: variables needed to track the button’s state.
  prefs: []
  type: TYPE_NORMAL
- en: • Tell the button about all events that the main program has detected
  prefs: []
  type: TYPE_NORMAL
- en: and check whether there are any that the button needs to react to.
  prefs: []
  type: TYPE_NORMAL
- en: • Draw the current image representing the button.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6-4 presents the code of a SimpleButton class. (We’ll build a
  prefs: []
  type: TYPE_NORMAL
- en: more complicated button class i[n Chapter 7.) T](index_split_003.html#p172)his
    class has three methods, __init__(), handleEvent(), and draw(), that implement
    the behaviors mentioned. The code of the handleEvent() method does get a little
    tricky, but
  prefs: []
  type: TYPE_NORMAL
- en: once you have it working, it’s incredibly easy to use. Feel free to work your
  prefs: []
  type: TYPE_NORMAL
- en: way through it, but know that the implementation of the code is not that
  prefs: []
  type: TYPE_NORMAL
- en: relevant. The important thing here is to understand the purpose and usage
  prefs: []
  type: TYPE_NORMAL
- en: of the different methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo7_SimpleButton/SimpleButton.py**'
  prefs: []
  type: TYPE_NORMAL
- en: SimpleButton class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: Uses a "state machine" approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  prefs: []
  type: TYPE_NORMAL
- en: 'class SimpleButton():'
  prefs: []
  type: TYPE_NORMAL
- en: Used to track the state of the button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'STATE_IDLE = ''idle'' # button is up, mouse not over button'
  prefs: []
  type: TYPE_NORMAL
- en: 'STATE_ARMED = ''armed'' # button is down, mouse over button'
  prefs: []
  type: TYPE_NORMAL
- en: 'STATE_DISARMED = ''disarmed'' # clicked down on button, rolled off'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, window, loc, up, down): 1'
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  prefs: []
  type: TYPE_NORMAL
- en: self.loc = loc
  prefs: []
  type: TYPE_NORMAL
- en: self.surfaceUp = pygame.image.load(up)
  prefs: []
  type: TYPE_NORMAL
- en: '**128** Chapter 6'
  prefs: []
  type: TYPE_NORMAL
- en: self.surfaceDown = pygame.image.load(down)
  prefs: []
  type: TYPE_NORMAL
- en: Get the rect of the button (used to see if the mouse is over the button)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: self.rect = self.surfaceUp.get_rect()
  prefs: []
  type: TYPE_NORMAL
- en: self.rect[0] = loc[0]
  prefs: []
  type: TYPE_NORMAL
- en: self.rect[1] = loc[1]
  prefs: []
  type: TYPE_NORMAL
- en: self.state = SimpleButton.STATE_IDLE
  prefs: []
  type: TYPE_NORMAL
- en: 'def handleEvent(self, eventObj): 2'
  prefs: []
  type: TYPE_NORMAL
- en: This method will return True if user clicks the button.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally returns False.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if eventObj.type not in (MOUSEMOTION, MOUSEBUTTONUP, MOUSEBUTTONDOWN): 3'
  prefs: []
  type: TYPE_NORMAL
- en: The button only cares about mouse-related events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: return False
  prefs: []
  type: TYPE_NORMAL
- en: eventPointInButtonRect = self.rect.collidepoint(eventObj.pos)
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.state == SimpleButton.STATE_IDLE:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if (eventObj.type == MOUSEBUTTONDOWN) and eventPointInButtonRect:'
  prefs: []
  type: TYPE_NORMAL
- en: self.state = SimpleButton.STATE_ARMED
  prefs: []
  type: TYPE_NORMAL
- en: 'elif self.state == SimpleButton.STATE_ARMED:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if (eventObj.type == MOUSEBUTTONUP) and eventPointInButtonRect:'
  prefs: []
  type: TYPE_NORMAL
- en: self.state = SimpleButton.STATE_IDLE
  prefs: []
  type: TYPE_NORMAL
- en: 'return True # clicked!'
  prefs: []
  type: TYPE_NORMAL
- en: 'if (eventObj.type == MOUSEMOTION) and (not eventPointInButtonRect):'
  prefs: []
  type: TYPE_NORMAL
- en: self.state = SimpleButton.STATE_DISARMED
  prefs: []
  type: TYPE_NORMAL
- en: 'elif self.state == SimpleButton.STATE_DISARMED:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if eventPointInButtonRect:'
  prefs: []
  type: TYPE_NORMAL
- en: self.state = SimpleButton.STATE_ARMED
  prefs: []
  type: TYPE_NORMAL
- en: 'elif eventObj.type == MOUSEBUTTONUP:'
  prefs: []
  type: TYPE_NORMAL
- en: self.state = SimpleButton.STATE_IDLE
  prefs: []
  type: TYPE_NORMAL
- en: return False
  prefs: []
  type: TYPE_NORMAL
- en: 'def draw(self): 4'
  prefs: []
  type: TYPE_NORMAL
- en: Draw the button's current appearance to the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if self.state == SimpleButton.STATE_ARMED:'
  prefs: []
  type: TYPE_NORMAL
- en: self.window.blit(self.surfaceDown, self.loc)
  prefs: []
  type: TYPE_NORMAL
- en: 'else: # IDLE or DISARMED'
  prefs: []
  type: TYPE_NORMAL
- en: self.window.blit(self.surfaceUp, self.loc)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-4: The SimpleButton class*'
  prefs: []
  type: TYPE_NORMAL
- en: The __init__() method begins by saving all values passed in into
  prefs: []
  type: TYPE_NORMAL
- en: instance variables 1 to use in other methods. It then initializes a few
  prefs: []
  type: TYPE_NORMAL
- en: more instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever the main program detects any event, it calls the handleEvent()
  prefs: []
  type: TYPE_NORMAL
- en: method 2\. This method first checks that the event is one of MOUSEMOTION,
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Pygame **129**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 22](index-159_1.png)'
  prefs: []
  type: TYPE_IMG
- en: MOUSEBUTTONUP, or MOUSEBUTTONDOWN 3\. The rest of the method is implemented
  prefs: []
  type: TYPE_NORMAL
- en: as a *state machine*, a technique that I will go into more detail about in
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 15\.](index_split_006.html#p340) The code is a little complicated,
    and you should feel free to study how it works, but for now note that it uses
    the instance variable'
  prefs: []
  type: TYPE_NORMAL
- en: self.state (over the course of multiple calls) to detect if the user has
  prefs: []
  type: TYPE_NORMAL
- en: clicked on the button. The handleEvent() method returns True when the
  prefs: []
  type: TYPE_NORMAL
- en: user completes a mouse click by pressing down on the button, then later
  prefs: []
  type: TYPE_NORMAL
- en: releasing on the same button. In all other cases, handleEvent() returns
  prefs: []
  type: TYPE_NORMAL
- en: False.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the draw() method uses the state of the object’s instance variable
  prefs: []
  type: TYPE_NORMAL
- en: self.state to decide which image (up or down) to draw 4\.
  prefs: []
  type: TYPE_NORMAL
- en: '***Main Code Using a SimpleButton***'
  prefs: []
  type: TYPE_NORMAL
- en: To use a SimpleButton in the main code, we first instantiate one from the
  prefs: []
  type: TYPE_NORMAL
- en: 'SimpleButton class before the main loop starts with a line like this:'
  prefs: []
  type: TYPE_NORMAL
- en: oButton = SimpleButton(window, (150, 30),
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonUp.png'','
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonDown.png'')'
  prefs: []
  type: TYPE_NORMAL
- en: This line creates a SimpleButton object, specifying a location to draw
  prefs: []
  type: TYPE_NORMAL
- en: it (as usual, the coordinates are for the top-left corner of the bounding
  prefs: []
  type: TYPE_NORMAL
- en: rectangle) and providing the paths to both the up and down images of the
  prefs: []
  type: TYPE_NORMAL
- en: button. In the main loop, any time any event happens we need to call the
  prefs: []
  type: TYPE_NORMAL
- en: handleEvent() method to see if the user has clicked the button. If the user
  prefs: []
  type: TYPE_NORMAL
- en: clicks the button, the program should perform some action. Also in the
  prefs: []
  type: TYPE_NORMAL
- en: main loop, we need to call the draw() method to make the button show in
  prefs: []
  type: TYPE_NORMAL
- en: the window.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll build a small test program, which will generate a user interface
  prefs: []
  type: TYPE_NORMAL
- en: like Figure 6-2, to incorporate one instance of a SimpleButton.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6-2: The user interface of a program with a single instance of a SimpleButton*
    Whenever the user completes a click on the button, the program'
  prefs: []
  type: TYPE_NORMAL
- en: outputs a line of text in the shell saying that the button has been clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 6-5 contains the main program code.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo7_SimpleButton/Main_SimpleButton.py**'
  prefs: []
  type: TYPE_NORMAL
- en: Pygame demo 7 - SimpleButton test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '--- snip ---'
  prefs: []
  type: TYPE_NORMAL
- en: 5 - Initialize variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create an instance of a SimpleButton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**130** Chapter 6'
  prefs: []
  type: TYPE_NORMAL
- en: 1 oButton = SimpleButton(window, (150, 30),
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonUp.png'','
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonDown.png'')'
  prefs: []
  type: TYPE_NORMAL
- en: 6 - Loop forever
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'while True:'
  prefs: []
  type: TYPE_NORMAL
- en: 7 - Check for and handle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'for event in pygame.event.get():'
  prefs: []
  type: TYPE_NORMAL
- en: 'if event.type == pygame.QUIT:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.quit()
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit()
  prefs: []
  type: TYPE_NORMAL
- en: Pass the event to the button, see if it has been clicked on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '2 if oButton.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: 3 print('User has clicked the button')
  prefs: []
  type: TYPE_NORMAL
- en: 8 - Do any "per frame" actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 9 - Clear the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: window.fill(GRAY)
  prefs: []
  type: TYPE_NORMAL
- en: 10 - Draw all window elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '4 oButton.draw() # draw the button'
  prefs: []
  type: TYPE_NORMAL
- en: 11 - Update the window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pygame.display.update()
  prefs: []
  type: TYPE_NORMAL
- en: 12 - Slow things down a bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: clock.tick(FRAMES_PER_SECOND)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-5: The main program that creates and reacts to a SimpleButton*'
  prefs: []
  type: TYPE_NORMAL
- en: Again, we start with the standard pygame template from [Chapter 5\.](#p118)
  prefs: []
  type: TYPE_NORMAL
- en: Before the main loop, we create an instance of our SimpleButton 1, specify-
  prefs: []
  type: TYPE_NORMAL
- en: ing a window to draw into, a location, a path to the up image, and a path to
  prefs: []
  type: TYPE_NORMAL
- en: the down image.
  prefs: []
  type: TYPE_NORMAL
- en: Every time through the main loop, we need to react to events detected
  prefs: []
  type: TYPE_NORMAL
- en: in the main program. To implement this, we call the SimpleButton class’s
  prefs: []
  type: TYPE_NORMAL
- en: handleEvent() method 2 and pass in the event from the main program.
  prefs: []
  type: TYPE_NORMAL
- en: The handleEvent() method tracks all of the user’s actions on the button
  prefs: []
  type: TYPE_NORMAL
- en: (pressing down, releasing, rolling off, rolling back on). When handleEvent()
  prefs: []
  type: TYPE_NORMAL
- en: returns True, indicating that a click has occurred, we perform the action
  prefs: []
  type: TYPE_NORMAL
- en: associated with clicking that button. Here, we just print a message 3\.
  prefs: []
  type: TYPE_NORMAL
- en: Finally we call the button’s draw() method 4 to draw an image to repre-
  prefs: []
  type: TYPE_NORMAL
- en: sent the appropriate state of the button (up or down).
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a Program with Multiple Buttons***'
  prefs: []
  type: TYPE_NORMAL
- en: With our SimpleButton class, we can instantiate as many buttons as we wish.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can modify our main program to incorporate three
  prefs: []
  type: TYPE_NORMAL
- en: SimpleButton instances, as shown in Figure 6-3\.
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Pygame **131**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image 23](index-161_1.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-3: The main program with three SimpleButton objects*'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to make any changes to the SimpleButton class file to
  prefs: []
  type: TYPE_NORMAL
- en: do this. We simply modify our main code to instantiate three SimpleButton
  prefs: []
  type: TYPE_NORMAL
- en: objects instead of one.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo7_SimpleButton/Main_SimpleButton3Buttons.py**'
  prefs: []
  type: TYPE_NORMAL
- en: oButtonA = SimpleButton(window, (25, 30),
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonAUp.png'','
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonADown.png'')'
  prefs: []
  type: TYPE_NORMAL
- en: oButtonB = SimpleButton(window, (150, 30),
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonBUp.png'','
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonBDown.png'')'
  prefs: []
  type: TYPE_NORMAL
- en: oButtonC = SimpleButton(window, (275, 30),
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonCUp.png'','
  prefs: []
  type: TYPE_NORMAL
- en: '''images/buttonCDown.png'')'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to call the handleEvent() method of all three buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: Pass the event to each button, see if one has been clicked
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if oButtonA.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: print('User clicked button A.')
  prefs: []
  type: TYPE_NORMAL
- en: 'elif oButtonB.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: print('User clicked button B.')
  prefs: []
  type: TYPE_NORMAL
- en: 'elif oButtonC.handleEvent(event):'
  prefs: []
  type: TYPE_NORMAL
- en: print('User clicked button C.')
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we tell each button to draw itself:'
  prefs: []
  type: TYPE_NORMAL
- en: oButtonA.draw()
  prefs: []
  type: TYPE_NORMAL
- en: oButtonB.draw()
  prefs: []
  type: TYPE_NORMAL
- en: oButtonC.draw()
  prefs: []
  type: TYPE_NORMAL
- en: When you run the program, you’ll see a window with three buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking any of the buttons prints a message showing the name of the but-
  prefs: []
  type: TYPE_NORMAL
- en: ton that was clicked.
  prefs: []
  type: TYPE_NORMAL
- en: The key idea here is that since we are using three instances of the
  prefs: []
  type: TYPE_NORMAL
- en: same SimpleButton class, the behavior of each button will be identical. An
  prefs: []
  type: TYPE_NORMAL
- en: important benefit of this approach is that any change to the code in the
  prefs: []
  type: TYPE_NORMAL
- en: SimpleButton class will affect all buttons instantiated from the class. The
  prefs: []
  type: TYPE_NORMAL
- en: main program does not need to worry about any details of the inner work-
  prefs: []
  type: TYPE_NORMAL
- en: ings of the button code, needing only to call the handleEvent() method of
  prefs: []
  type: TYPE_NORMAL
- en: each button in the main loop. Each button will return True or False to say
  prefs: []
  type: TYPE_NORMAL
- en: that it has or has not been clicked.
  prefs: []
  type: TYPE_NORMAL
- en: '**132** Chapter 6'
  prefs: []
  type: TYPE_NORMAL
- en: '**Building a Reusable Object-Oriented Text Display**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different types of text in a pygame program: display text and'
  prefs: []
  type: TYPE_NORMAL
- en: input text. Display text is output from your program, equivalent to a call to
    the
  prefs: []
  type: TYPE_NORMAL
- en: print() function, except it’s displayed in a pygame window. Input text is string
  prefs: []
  type: TYPE_NORMAL
- en: input from the user, equivalent to a call to input(). In this section, I’ll
    discuss display text. We’ll look at how to deal with input text in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '***Steps to Display Text***'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying text in a window is a fairly complicated process in pygame
  prefs: []
  type: TYPE_NORMAL
- en: because it’s not simply displayed as a string in the shell, but requires you
    to
  prefs: []
  type: TYPE_NORMAL
- en: choose a location, fonts and sizes, and other attributes. For example, you
  prefs: []
  type: TYPE_NORMAL
- en: 'might use code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: pygame.font.init()
  prefs: []
  type: TYPE_NORMAL
- en: myFont = pygame.font.SysFont('Comic Sans MS', 30)
  prefs: []
  type: TYPE_NORMAL
- en: textSurface = myfont.render('Some text', True, (0, 0, 0))
  prefs: []
  type: TYPE_NORMAL
- en: window.blit(textSurface, (10, 10))
  prefs: []
  type: TYPE_NORMAL
- en: We start by initializing the font system within pygame; we do this before
  prefs: []
  type: TYPE_NORMAL
- en: the main loop starts. Then we tell pygame to load a particular font from the
  prefs: []
  type: TYPE_NORMAL
- en: system by name. Here, we request Comic Sans with a font size of 30\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is the key one: we use that font to *render* our text, which'
  prefs: []
  type: TYPE_NORMAL
- en: creates a graphical image of the text, called a *surface* in pygame. We supply
    the text we want to output, a Boolean that says whether we want our text to
  prefs: []
  type: TYPE_NORMAL
- en: be anti-aliased, and a color in RGB format. Here, (0, 0, 0) indicates that
  prefs: []
  type: TYPE_NORMAL
- en: we want our text to be black. Finally, using blit(), we draw the image of the
  prefs: []
  type: TYPE_NORMAL
- en: text into the window at some (x, y) location.
  prefs: []
  type: TYPE_NORMAL
- en: This code works well to show the provided text in the window at the
  prefs: []
  type: TYPE_NORMAL
- en: given location. However, if the text doesn’t change, there will be a lot of
  prefs: []
  type: TYPE_NORMAL
- en: wasted work done re-creating the textSurface on each iteration through the
  prefs: []
  type: TYPE_NORMAL
- en: main loop. There are also a lot of details to remember, and you must get
  prefs: []
  type: TYPE_NORMAL
- en: them all correct to draw the text properly. We can hide most of this com-
  prefs: []
  type: TYPE_NORMAL
- en: plexity by building a class.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a SimpleText Class***'
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to build a set of methods that take care of font loading and text
  prefs: []
  type: TYPE_NORMAL
- en: rendering in pygame, meaning we no longer have to remember the details
  prefs: []
  type: TYPE_NORMAL
- en: of the implementation. Listing 6-6 contains a new class called SimpleText
  prefs: []
  type: TYPE_NORMAL
- en: that does this work.
  prefs: []
  type: TYPE_NORMAL
- en: '**File: PygameDemo8_SimpleTextDisplay/SimpleText.py**'
  prefs: []
  type: TYPE_NORMAL
- en: SimpleText class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: import pygame
  prefs: []
  type: TYPE_NORMAL
- en: from pygame.locals import *
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Pygame **133**
  prefs: []
  type: TYPE_NORMAL
- en: 'class SimpleText():'
  prefs: []
  type: TYPE_NORMAL
- en: '1 def __init__(self, window, loc, value, textColor):'
  prefs: []
  type: TYPE_NORMAL
- en: 2 pygame.font.init()
  prefs: []
  type: TYPE_NORMAL
- en: self.window = window
  prefs: []
  type: TYPE_NORMAL
- en: self.loc = loc
  prefs: []
  type: TYPE_NORMAL
- en: 3 self.font = pygame.font.SysFont(None, 30)
  prefs: []
  type: TYPE_NORMAL
- en: self.textColor = textColor
  prefs: []
  type: TYPE_NORMAL
- en: 'self.text = None # so that the call to setText below will'
  prefs: []
  type: TYPE_NORMAL
- en: force the creation of the text image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'self.setValue(value) # set the initial text for drawing'
  prefs: []
  type: TYPE_NORMAL
- en: '4 def setValue(self, newText):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.text == newText:'
  prefs: []
  type: TYPE_NORMAL
- en: 'return # nothing to change'
  prefs: []
  type: TYPE_NORMAL
- en: 'self.text = newText # save the new text'
  prefs: []
  type: TYPE_NORMAL
- en: self.textSurface = self.font.render(self.text, True, self.textColor)
  prefs: []
  type: TYPE_NORMAL
- en: '5 def draw(self):'
  prefs: []
  type: TYPE_NORMAL
- en: self.window.blit(self.textSurface, self.loc)
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 6-6: The SimpleText class for displaying text*'
  prefs: []
  type: TYPE_NORMAL
- en: You can think of a SimpleText object as a field in the window where you
  prefs: []
  type: TYPE_NORMAL
- en: want text to be displayed. You can use one to display unchanging label text
  prefs: []
  type: TYPE_NORMAL
- en: or to display text that changes throughout a program.
  prefs: []
  type: TYPE_NORMAL
- en: The SimpleText class has only three methods. The __init__() method 1
  prefs: []
  type: TYPE_NORMAL
- en: expects the window to draw into, the location at which to draw the text in
  prefs: []
  type: TYPE_NORMAL
- en: the window, any initial text you want to see displayed in the field, and a text
  prefs: []
  type: TYPE_NORMAL
- en: color. Calling pygame.font.init() 2 starts up pygame’s font system. The call
  prefs: []
  type: TYPE_NORMAL
- en: in the first instantiated SimpleText object actually does the initialization;
    any
  prefs: []
  type: TYPE_NORMAL
- en: additional SimpleText objects will also make this call, but since fonts have
  prefs: []
  type: TYPE_NORMAL
- en: already been initialized, the call returns immediately. We create a new Font
  prefs: []
  type: TYPE_NORMAL
- en: object with pygame.font.SysFont() 3\. Rather than providing a specific font
  prefs: []
  type: TYPE_NORMAL
- en: name, None indicates that we will use whatever the standard system font is.
  prefs: []
  type: TYPE_NORMAL
- en: The setValue() method renders an image of the text to display and saves
  prefs: []
  type: TYPE_NORMAL
- en: that image in the self.textSurface instance variable 4\. As the program runs,
  prefs: []
  type: TYPE_NORMAL
- en: any time you want to change the text that’s displayed, you call the setValue()
  prefs: []
  type: TYPE_NORMAL
