- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Build a Minimum Viable Product
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter covers a well-known but still undervalued idea popularized in Eric
    Ries’s book *The Lean Startup* (Crown Business, 2011). The idea is to build a
    *minimum viable product* *(MVP)*, which is a version of your product stripped
    of all except the most necessary features, in order to test and validate your
    hypotheses quickly without losing a lot of time in implementing features your
    users may not end up using. In particular, you’ll learn how to radically reduce
    complexity in the software development cycle by focusing on features you know
    your users want, because they’ve confirmed as much from your MVP.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll introduce MVPs by looking at the pitfalls of developing
    software without using MVPs. We’ll then elaborate on the concept in more detail
    and provide you with a number of practical tips on how to use MVPs in your own
    projects to accelerate progress.
  prefs: []
  type: TYPE_NORMAL
- en: A Problem Scenario
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The idea behind building an MVP is to combat problems that arise when you program
    in stealth mode (see [Figure 3-1](#figure3-1)). *Stealth mode* is when you work
    on a project to completion without seeking any feedback from potential users.
    Say you come up with a wonderful idea for a program that will change the world:
    a machine learning–enhanced search engine specifically for searching for code.
    You start coding enthusiastically on your idea a few nights in a row.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram depicting someone having an idea and sinking into the “secret world”
    of stealth programming, emerging only at the point of a one million dollar launch.
    ](image_fi/502185c03/f03001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-1: The stealth mode of programming consists of keeping the app secret
    until the final polished version can be released in the hope of immediate success.
    In most cases, this is a fallacy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in practice, coding an app in one go leads to immediate success very,
    very, very rarely. Here’s a more likely outcome of following the stealth mode
    of programming:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You quickly develop the prototype, but when you try your search engine, you
    find that many search terms in the recommended results are not relevant. When
    you search for `Quicksort`, you obtain a `MergeSort` code snippet with a comment
    `# This is not Quicksort`. That doesn’t seem right. So, you keep tweaking the
    models, but each time you improve the results for one keyword, you create new
    problems for other search results. You’re never quite happy with the result, and
    you don’t feel like you can present your crappy code search engine to the world
    for three reasons: nobody will find it useful; the first users will create negative
    publicity around your website because it won’t feel professional and polished;
    and you worry that if competitors see your poorly implemented concept, they’ll
    steal it and implement it in a better way. These depressing thoughts cause you
    to lose faith and motivation, and your progress on the app drops to zero.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-2](#figure3-2) depicts what can and will go wrong in the stealth
    mode of programming.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The same as Figure 3-1 but now with labels at various points positing things
    that can go wrong. These include: lost motivation, distractions, taking longer
    than anticipated, and then at the point of launch the costs have increased to
    97 million and we find that there’s no product or market fit.](image_fi/502185c03/f03002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-2: Common pitfalls in the stealth mode of programming'
  prefs: []
  type: TYPE_NORMAL
- en: Here I’ll discuss the six most common pitfalls of working in stealth mode.
  prefs: []
  type: TYPE_NORMAL
- en: Loss of Motivation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In stealth mode, you’re alone with your idea, and doubts will pop up regularly.
    You resist the doubts initially, while your initial enthusiasm for the project
    is big enough, but the longer you work on your project, the bigger your doubts
    grow. Maybe you come across a similar tool already in existence, or you start
    to believe that it cannot be done. Loss of motivation can kill your project entirely.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you release an early version of the tool, encouraging
    words from an early adopter could keep you motivated enough to persevere, and
    feedback from users might inspire you to improve the tool or overcome problems.
    You have external motivation.
  prefs: []
  type: TYPE_NORMAL
- en: Distraction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you work alone in stealth mode, daily distractions are difficult to ignore.
    You work in your day job, you spend time with family and friends, other ideas
    pop into your mind. These days, your attention is a rare good sought by many devices
    and services. The longer you are in stealth mode, the higher the likelihood of
    getting distracted before ever finishing your polished app.
  prefs: []
  type: TYPE_NORMAL
- en: An MVP can combat this by reducing the time from idea to market response, creating
    an environment of more immediate feedback that helps refocus your attention. And
    who knows—maybe you’ll find some eager early users of your MVP that can help propel
    the application development.
  prefs: []
  type: TYPE_NORMAL
- en: Running Over Time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another powerful enemy of project completion is faulty planning. Say you estimate
    that your product will take 60 hours to complete, so you initially plan to work
    on it for 2 hours every day for a month. However, loss of motivation and distractions
    cause you to average only 1 hour every day. Further delays are caused by research
    you have to commit to, external distractions, and unexpected events and bugs that
    you must work around. An infinite number of factors will increase your anticipated
    project duration, and few will reduce it. By the end of the first month, you’re
    nowhere near where you thought you’d be, feeding back into the loss-of-motivation
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: An MVP is stripped of all unnecessary features. Thus, your planning mistakes
    will be fewer, and your progress will be more predictable. Having fewer features
    means fewer things will go wrong. Furthermore, the more predictable your project,
    the more you or the people invested in your project will believe in its success.
    Investors and stakeholders love predictability!
  prefs: []
  type: TYPE_NORMAL
- en: Lack of Response
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Say you overcome your low motivation and complete the product. You finally launch
    it, and nothing happens. Only a handful of users even check it out, and they’re
    not enthusiastic about it. The most likely outcome of any software project is
    silence—an absence of positive or negative feedback. A common reason is that your
    product doesn’t deliver the specific value the users demand. It’s almost impossible
    to find the so-called *product-market fit* in your first shot. If you don’t get
    any feedback from the real world during development, you start to drift away from
    reality, working on features nobody will use.
  prefs: []
  type: TYPE_NORMAL
- en: Your MVP will help you find product-market fit much quicker because, as you’ll
    see later in this chapter, an MVP-based approach develops the project to directly
    address the most pressing customer needs, increasing your chances of customer
    engagement and therefore response to early product versions.
  prefs: []
  type: TYPE_NORMAL
- en: Wrong Assumptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main cause of failure in stealth mode is your own assumptions. You start
    a project with a bunch of assumptions, such as who the users will be, what they
    do for a living, what problems they face, or how often they will use your product.
    These assumptions are often wrong, and without external testing, you carry on
    blindly creating products your actual audience does not want. Once you get no
    feedback or negative feedback, it corrodes any motivation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When I was creating my Finxter.com app for learning Python by solving rated
    code puzzles, I assumed that most users would be computer science students because
    I was one (reality: most users are not computer scientists). I assumed that users
    would come when I released the app (reality: nobody came initially). I assumed
    that many users would share their successes on Finxter via their social media
    accounts (reality: only a tiny minority of users shared their coding ranks). I
    assumed that users would submit their own code puzzles (reality: from hundreds
    of thousands of users, only a handful submitted code puzzles). I assumed that
    users wanted a fancy design with colors and images (reality: a simple geeky design
    led to improved usage behavior—see Chapter 8 on simple designs). All those assumptions
    led to concrete implementation decisions that cost me tens, if not hundreds, of
    hours implementing many features my audience did not want. If I’d known better,
    I would have tested these assumptions in an MVP, responded to user feedback, saved
    myself time and energy, and reduced the likelihood of jeopardizing the project’s
    success.'
  prefs: []
  type: TYPE_NORMAL
- en: Unnecessary Complexity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There’s another problem with the stealth mode of programming: *unnecessary
    complexity*. Say you implement a software product that includes four features
    (see [Figure 3-3](#figure3-3)). You’ve been lucky—the market accepted it. You’ve
    spent considerable time implementing those four features, and you take the positive
    feedback as a reinforcement for all four features. All future releases of the
    software product will contain those four features—in addition to the features
    you’ll add in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Depiction of a product in stealth mode building up four Features. Upon release,
    the market responds with a resounding “yes!” but we cannot tell which of the four
    features was a hit. ](image_fi/502185c03/f03003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-3: A valuable software product consisting of four features'
  prefs: []
  type: TYPE_NORMAL
- en: However, by releasing the package of four features at once rather than one or
    two features at a time, you don’t know whether the market would’ve accepted, or
    even preferred, any subset of features (see [Figure 3-4](#figure3-4)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Depiction of the same four features from Figure 3-3, this time released in
    small groups and tested in order to see which combination of features received
    a “yes!” and which a “no!”](image_fi/502185c03/f03004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-4: Which subsets of features would have been accepted by the market?'
  prefs: []
  type: TYPE_NORMAL
- en: Feature 1 may be completely irrelevant, even though it took you the most time
    to implement. At the same time, Feature 4 may be a highly valuable feature that
    the market demands. There are 2*n* different combinations of software product
    packages out of *n* features. If you release them as feature bundles, how can
    you possibly know which is valuable and which is a waste of time?
  prefs: []
  type: TYPE_NORMAL
- en: 'The costs of implementing the wrong features are already high, and releasing
    bundles of wrong features incurs the cumulative costs of maintaining unnecessary
    features:'
  prefs: []
  type: TYPE_NORMAL
- en: Longer, feature-heavy projects require more time to “load” the whole project
    in your mind.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each feature risks introducing new bugs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each line of code adds time cost to opening, loading, and compiling the project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing feature *n* requires you to check all previous features 1, 2, .
    . ., *n* – 1 to ensure that feature *n* doesn’t interfere with their functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every new feature requires new unit tests that must compile and run before you
    can release the next version of the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every added feature makes the codebase more complicated for a coder to understand,
    increasing learning time for new coders joining the project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is not an exhaustive list, but you get the point. If each feature increases
    your future implementation costs by *x* percent, maintaining unnecessary features
    can result in orders of magnitude difference in coding productivity. You cannot
    afford to systematically keep unnecessary features in your code projects!
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you may ask: If the stealth mode of programming is unlikely to succeed,
    what’s the solution?'
  prefs: []
  type: TYPE_NORMAL
- en: Building a Minimum Viable Product
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The solution is simple: build a series of MVPs. Formulate an explicit hypothesis—such
    as *users enjoy solving Python puzzles*—and create a product that validates only
    this hypothesis. Remove all features that don’t help you validate this hypothesis.
    Build an MVP based on that feature. By implementing just a single feature per
    release, you more thoroughly understand what features the marketplace accepts
    and which hypotheses are true. But at all costs, avoid complexity. After all,
    if users don’t enjoy solving Python puzzles, why even proceed with implementing
    the Finxter.com website? Once you’ve tested your MVP on the real-world market
    and analyzed whether it works, you can build a second MVP that adds the next most
    important feature. The term to describe this strategy of searching for the right
    product via a series of MVPs is called *rapid prototyping*. Each prototype builds
    on what you learn from the previous launches, and each is designed to bring you
    maximal learning in minimal time and with minimum effort. You *release early and
    often* in order to find *product-market fit*, which entails nailing the product
    needs and desires of your target market (even if this target market is very small
    in the beginning).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example using the code search engine. You first formulate
    a hypothesis to test: coders need a way to search for code. Think about what form
    the first MVP might take for your code search engine app. A shell-based API? A
    backend server that performs a database lookup on all open source GitHub projects
    for exact word matches? The first MVP must validate the main hypotheses. Thus,
    you decide the simplest way to validate this hypothesis and gain some insight
    into possible queries is to build a user interface without any sophisticated backend
    functionality that automatically retrieves results for the query. You set up a
    website with an input field and drive some traffic to it by sharing your idea
    in coding groups and on social media and by spending a small amount on ads. The
    app interface is simple: users enter the code they want to search for and hit
    a search button. You don’t bother optimizing the search results too much; this
    is not the point of your first MVP. Instead, you decide to simply relay Google’s
    search results after a quick postprocessing. The point is to collect the first,
    say, 100 search queries to find some common user behavior patterns before you
    even start developing the search engine!'
  prefs: []
  type: TYPE_NORMAL
- en: 'You analyze the data and find that 90 percent of the search queries are related
    to error messages; coders are simply copying and pasting their coding errors into
    the search field. Furthermore, you find that 60 out of the 90 queries concern
    JavaScript. You conclude that the initial hypothesis is validated: coders do indeed
    search for code. However, you learn the valuable information that most coders
    search for errors than for, say, functions. Based on your analysis, you decide
    to narrow your second MVP from a general-purpose code search engine to an *error*
    search engine. This way, you can tailor your product to the actual user needs
    and get more engaged feedback from a subsection of coders in order to learn quickly
    and integrate your learning in a useful product. You can always scale to other
    languages and query types over time as you gain more and more traction and market
    insights. Without your first MVP, you may have spent months working on features
    almost nobody uses, like regular expression functionality to find arbitrary patterns
    in the code, at the cost of features everybody uses like error message searches.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-5](#figure3-5) sketches this gold standard of software development
    and product creation. First, you find product-market fit through iteratively launching
    MVPs until users love your product. The chained launches of MVPs build interest
    over time and allow you to incorporate user feedback to gradually improve the
    core idea of your software. As soon as you’ve reached product-market fit, you
    add new features—one at a time. Only if a feature can prove that it improves key
    user metrics does it remain in the product.'
  prefs: []
  type: TYPE_NORMAL
- en: '![On the right: an implementation of three iterations of an MVP, each tested
    with user feedback to find the product-market fit. On the left: the MVP with positive
    feedback is scaled up and split-tested. ](image_fi/502185c03/f03005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-5: Two phases of software development involve the following: (1) Find
    product-market fit through iterative MVP creation and build interest over time.
    (2) Scale up by adding and validating new features through carefully designed
    split tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Finxter.com as an example, if I had followed the MVP rule from the start,
    I would probably have created a simple Instagram account that shared code puzzles
    and checked if users enjoyed solving them. Instead of spending a year writing
    the Finxter app without validation, I could’ve spent a few weeks or even months
    sharing puzzles on a social network. Then, I could’ve taken lessons learned from
    interacting with the community to build a second MVP with slightly more functionality,
    such as a dedicated website that hosts the coding puzzles and their correct solutions.
    This method would have allowed me to build the Finxter app in a fraction of the
    time and with a fraction of the unnecessary features. The lesson of building an
    MVP stripped from all unnecessary features is one I’ve learned the hard way.
  prefs: []
  type: TYPE_NORMAL
- en: In *The Lean Startup*, Eric Ries discusses how the billion-dollar company Dropbox
    famously adopted the MVP approach. Instead of spending time and effort on an untested
    idea to implement the complicated Dropbox functionality of synchronizing folder
    structures into the cloud—which requires a tight integration in different operating
    systems and a thorough implementation of burdensome distributed systems concepts
    such as replica synchronization—the founders validated the idea with a simple
    product video, even though the product featured in the video didn’t exist yet.
    Countless iterations followed the validated Dropbox MVP to add more helpful features
    to the core project that simplify the lives of their users. Since then, the concept
    has been tested by thousands of successful companies in the software industry
    (and beyond).
  prefs: []
  type: TYPE_NORMAL
- en: If the market signals that users love and value your product idea, you’ve achieved
    product-market fit with just a simple, well-crafted MVP. From there, you can iteratively
    build and refine your MVPs.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use an MVP-based approach for software development, adding one feature
    at a time, it’s important to be able to identify which feature to keep and which
    to reject. The final step of the MVP software creation process is *split testing*:
    rather than release the iterations with new features to your entire user base,
    you launch the new product to a fraction of your users and observe the implicit
    and explicit response. Only if you like what you see—for example, the average
    time spent on your website increases—do you keep the feature. Otherwise, you reject
    it and stay with the previous iteration without the feature. This means you must
    sacrifice the time and energy you spent developing the feature, but it does allow
    you to keep your product as simple as possible, allowing you to remain agile,
    flexible, and efficient. By using split tests, you engage in data-driven software
    development.'
  prefs: []
  type: TYPE_NORMAL
- en: Four Pillars of Building a Minimum Viable Product
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When building your first software based on MVP thinking, consider these four
    pillars:'
  prefs: []
  type: TYPE_NORMAL
- en: Functionality The product provides a clearly formulated function to the user,
    and it does it well. The function doesn’t have to be provided with great economic
    efficiency. Your MVP for a chat bot might actually just be you chatting with the
    user yourself; this clearly could not scale, but you’re demonstrating the functionality
    of high-quality chatting—even if you haven’t figured out how to provide this functionality
    in an economically feasible way yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Design The product is well designed and focused, and its design supports the
    value that your product offers to your target niche. One common mistake in MVP
    generation is that you create an interface that doesn’t accurately reflect your
    single-function MVP website. The design can be straightforward, but it must support
    the value proposition. Think Google Search—they certainly didn’t spend lots of
    effort on design when releasing their first version of the search engine, but
    the design was well suited for the product they offered: distraction-free search.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Reliability Just because your product is minimal doesn’t mean it can be unreliable.
    Make sure to write test cases and test all functions in your code rigorously.
    Otherwise, your learnings from the MVP will be corrupted by the negative user
    feedback based on its unreliability, and not feedback on the features directly.
    Remember: you want to maximize learning with minimal effort.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Usability The MVP must be easy to use. The functionality is clearly articulated,
    and the design supports it. Users don’t need to spend a lot of time figuring out
    what to do or which buttons to click. The MVP is responsive and fast enough to
    allow fluent interactions. This is often simpler to achieve with a focused, minimalistic
    product: it is obvious how you should use a page with one button and one input
    field. Again, the Google search engine’s initial prototype is a prime example,
    and it was so usable that it lasted for more than two decades.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Many people misunderstand this characteristic of MVPs: they wrongly assume
    that, because it’s an extremely minimalist version of a product, an MVP must provide
    little value, bad usability, and a lazy design. However, the minimalist knows
    that the concision of an MPV actually comes from a rigorous focus on one core
    functionality rather than from lazy product creation. For Dropbox, creating an
    effective video showcasing intention was easier than implementing the service
    itself. The MVP was a high-quality product with great functionality, design, reliability,
    and usability.'
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of the Minimum Viable Product
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The advantages of MVP-driven software design are manifold.
  prefs: []
  type: TYPE_NORMAL
- en: You can test your hypotheses as cheaply as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can often avoid actually writing the code until you know it’s necessary,
    and then when you do write code, you minimize the amount of work before gathering
    real-world feedback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You spend much less time writing code and finding bugs—and you’ll know the time
    you do spend is highly valuable for your users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any new feature you ship to users provides instant feedback, and the continuous
    progress keeps you and your team motivated to crank out feature after feature.
    This dramatically minimizes the risks you’re exposed to in the stealth mode of
    programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You reduce the maintenance costs in the future because the MVP approach reduces
    the complexity of your codebase by a long shot—and all future features will be
    easier and less error prone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll make faster progress, and implementation will be easier throughout the
    life of your software—which keeps you in a motivated state and on the road to
    success.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll ship products faster, earn money from your software faster, and build
    your brand more predictably and reliably.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stealth vs. Minimum Viable Product Approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common counterargument against rapid prototyping and *for* the stealth mode
    of programming is that stealth programming protects your ideas. People assume
    their idea is special and unique enough that if they release it in the raw form,
    as an MVP, it will get stolen by larger and more powerful companies that can implement
    it more quickly. Frankly, this is a fallacy. Ideas are cheap; execution is king.
    Any given idea is unlikely to be unique, and there’s a strong chance your idea
    has already been thought of by some other person. Rather than reducing competition,
    the stealth mode of programming may even encourage others to work on the same
    idea, because like you, they assume that nobody else has already thought of it.
    For an idea to succeed, it takes a person to push it into reality. If you fast-forward
    a few years, the person that succeeded will be the one who took quick and decisive
    action, released early and often, incorporated feedback from real users, and gradually
    improved their software by building on the momentum of previous releases. Keeping
    the idea secret would simply restrict its growth potential.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Envision your end product and think about the needs of your users before you
    write any code. Work on your MVP and make it valuable, well designed, responsive,
    and usable. Remove all features but those that are absolutely necessary to achieve
    the goal. Focus on one thing at a time. Then, release MVPs quickly and often—improve
    them over time by gradually testing and adding more features. Less is more! Spend
    more time thinking about the next feature to implement than you spend actually
    implementing each feature. Every feature incurs not only direct but also indirect
    implementation costs for all features to come in the future. Use split testing
    to test the response to two product variants at a time and quickly discard features
    that don’t lead to an improvement in your key user metrics, such as retention,
    time on page, or activity. This leads to a more holistic approach to your business—acknowledging
    that software development is only one step in the whole product creation and value
    delivery process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, you’ll learn why and how to write clean and simple code,
    but remember: not writing unnecessary code is the surest path to clean and simple
    code!'
  prefs: []
  type: TYPE_NORMAL
