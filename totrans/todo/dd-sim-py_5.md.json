["```py\npip install --upgrade pip setuptools wheel\n```", "```py\n[metadata]\nname = timecard-app\n```", "```py\nversion = 2.1.0\n```", "```py\ndescription = Track time beautifully.\nlong_description = file: *README.md*\nlong_description_content_type = text/markdown; charset=UTF-8\n```", "```py\nlicense_file = LICENSE\n```", "```py\nauthor = Jason C. McDonald\nauthor_email = codemouse92@outlook.com\nurl = https://github.com/codemouse92/timecard\nproject_urls =\n    Bug Reports = https://github.com/codemouse92/timecard/issues\n    Funding = https://github.com/sponsors/CodeMouse92\n    Source = https://github.com/codemouse92/timecard\n```", "```py\nkeywords = time tracking office clock tool utility\n```", "```py\nclassifiers =\n    Development Status :: 5 - Production/Stable\n    Environment :: X11 Applications :: Qt\n    Natural Language :: English\n    Operating System :: OS Independent\n    Intended Audience :: End Users/Desktop\n    Topic :: Office/Business\n    License :: OSI Approved :: BSD License\n    Programming Language :: Python\n    Programming Language :: Python :: 3\n    Programming Language :: Python :: 3.6\n    Programming Language :: Python :: 3.7\n Programming Language :: Python :: 3.8\n    Programming Language :: Python :: 3 :: Only\n    Programming Language :: Python :: Implementation :: CPython\n```", "```py\n[options]\n\npackage_dir =\n    = src\npackages = ❶ find:\n```", "```py\n[options.packages.find]\nwhere = src\n```", "```py\n[options]\npackage_dir =\n    = src\npackages = find:\n**include_package_data = True**\n```", "```py\n[options]\npackage_dir =\n    = src\npackages = find:\ninclude_package_data = True\n**python_requires = >=3.6, <4**\n```", "```py\n[options]\npackage_dir =\n    = src\npackages = find:\ninclude_package_data = True\npython_requires = >=3.6, <4\n**install_requires =**\n **PySide2>=5.15.0**\n **appdirs>=1.4.4**\n```", "```py\ninstall_requires =\n    PySide2>=5.15.0**; python_requires <= \"3.7\"**\n    appdirs>=1.4.4\n```", "```py\n[options.extras_require]\ntest =\n    pytest\n```", "```py\n[options.entry_points]\ngui_scripts =\n    Timecard-App = timecard.__main__:main\n```", "```py\nfrom setuptools import setup\nsetup()\n```", "```py\ninclude LICENSE *.md\n```", "```py\ngraft src/timecard/resources\ngraft distribution_resources\n```", "```py\nrecursive-include stuff *.ini\ngraft data\nprune data/temp\nrecursive-exclude data/important *.scary\n```", "```py\nPySide2 >= 5.11.0\npytest\n```", "```py\npip install -r requirements.txt\n```", "```py\npip install -r requirements.txt -r dev-requirements.txt\n```", "```py\nvenv/bin/pip freeze > requirements.txt\n```", "```py\n[build-system]\nrequires = [\"setuptools>=40.8.0\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n```", "```py\nvenv/bin/pip install .\n```", "```py\nvenv/bin/Timecard-App\n```", "```py\nvenv/bin/pip install -e .\n```", "```py\npython3 -m pip install --upgrade setuptools wheel build\npython3 -m build\n```", "```py\npython3 -m pip install --upgrade twine\n```", "```py\ntwine upload --repository testpypi dist/*\n```", "```py\nEnter your username: `__token__`\nEnter your password: `(your API token here)`\n```", "```py\nvenv/bin/pip install -r requirements.txt\n```", "```py\nvenv/bin/pip install \\\n    --index-url https://test.pypi.org/simple/ \\\n    --no-deps/ \\\n    Timecard-App\n```", "```py\nvenv/bin/Timecard-App\n```", "```py\ntwine upload dist/*\n```", "```py\nvenv/bin/sphinx-quickstart\n```", "```py\nimport warnings\n\nthumbs = \"pricking\"\n\nif thumbs == \"pricking\":\n    warnings.warn(\"Something wicked this way comes.\")\n\nwith open('locks.txt', 'w') as file:\n    file.write(\"Whoever knocks\")\n```", "```py\nbasic_warning.py:6: UserWarning: Something wicked this way comes.\n  warnings.warn(\"Something wicked this way comes.\")\n```", "```py\nWhoever knocks\n```", "```py\nimport warnings\n\nthumbs = \"pricking\"\n\nif thumbs == \"pricking\":\n    warnings.warn(\"Something wicked this way comes.\", **FutureWarning**)\n\nwith open('locks.txt', 'w') as file:\n    file.write(\"Whoever knocks\")\n```", "```py\nbasic_warning.py:6: **FutureWarning**: Something wicked this way comes.\n  warnings.warn(\"Something wicked this way comes.\", **FutureWarning**)\n```", "```py\n`action`:`message`:`category`:`module`:`lineno`\n```", "```py\n`action`::`category`\n```", "```py\npython3 -Wmodule basic_warning.py\n```", "```py\npython3 -Wignore::DeprecationWarning basic_warning.py\n```", "```py\npython3 -Werror basic_warning.py\n```", "```py\npython3 -Werror**:::__main__** basic_warning.py\n```", "```py\npython3 -Werror:::timecard[.*] basic_warning.py\n```", "```py\nimport logging\nlogger = logging.getLogger(__name__)\n```", "```py\nimport pathlib\nimport argparse\nimport logging\n\nfrom letter_counter.common import scrub_string\nfrom letter_counter.letters import most_common_consonant, most_common_vowel\n\nlogger = ❶ logging.getLogger('letter_counter')\n```", "```py\nimport logging\nfrom collections import defaultdict\n\nlogger = logging.getLogger(__name__)\n```", "```py\nimport logging\n\nlogger = logging.getLogger(__name__)\n```", "```py\nstream_handler = logging.StreamHandler()\nlogger.addHandler(stream_handler)\n```", "```py\nlogger.propagate = False\n```", "```py\ndef scrub_string(string):\n    string = string.lower()\n    string = ''.join(filter(str.isalpha, string))\n    logger.debug(f\"{len(string)} letters detected.\")\n    return string\n```", "```py\nconsonants = 'bcdfghjklmnpqrstvwxyz'\nvowels = 'aeiou'\n\ndef count_letters(string, letter_set):\n counts = defaultdict(lambda: 0)\n    for ch in string:\n        if ch in letter_set:\n            counts[ch] += 1\n    return counts\n\ndef most_common_consonant(string):\n    if not len(string):\n      ❶ logger.info(\"No consonants in empty string.\")\n        return \"\"\n    counts = count_letters(string, consonants)\n    return max(counts, key=counts.get).upper()\n\ndef most_common_vowel(string):\n    if not len(string):\n      ❷ logger.info(\"No vowels in empty string.\")\n        return \"\"\n    counts = count_letters(string, vowels)\n    return max(counts, key=counts.get).upper()\n```", "```py\nparser = argparse.ArgumentParser(description=\"Find which letters appear most.\")\nparser.add_argument(\"-v\", help=\"Show all messages.\", action=\"store_true\") ❶\nparser.add_argument(\"raw_path\", metavar=\"P\", type=str, help=\"The file to read.\") ❷\n\ndef main():\n    args = parser.parse_args()\n\n    if args.v:\n      ❸ logger.setLevel(logging.INFO)\n    else:\n        logger.setLevel(logging.WARNING)\n```", "```py\n path = pathlib.Path(args.raw_path).resolve()\n  ❶ logger.info(f\"Opening {path}\")\n\n    if not path.exists():\n      ❷ logger.warning(\"File does not exist.\")\n        return\n\n    with path.open('r') as file:\n        string = scrub_string(file.read())\n        print(f\"Most common vowel: {most_common_vowel(string)}\")\n        print(f\"Most common consonant: {most_common_consonant(string)}\")\n\nif __name__ == \"__main__\":\n    main()\n```", "```py\npython3 -m letter_counter zen.txt\n```", "```py\nMost common vowel: E\nMost common consonant: T\n```", "```py\npython3 -m letter_counter **-v** zen.txt\n```", "```py\nOpening /home/jason/Documents/DeadSimplePython/Code/ch19/zen.txt\nMost common vowel: E\nMost common consonant: T\n```", "```py\npython3 -m letter_counter -v **empty.txt**\n```", "```py\nOpening /home/jason/Documents/DeadSimplePython/Code/ch19/empty.txt\nNo vowels in empty string.\nMost common vowel: \nNo consonants in empty string.\nMost common consonant: \n```", "```py\npython3 -m letter_counter **invalid.txt**\n```", "```py\nFile does not exist.\n```", "```py`` It is also possible to configure a logger using a specialized configuration file.    For additional information on logging, I recommend reading the official *Logging HOWTO* tutorial by Vinay Sajip at [https://docs.python.org/3/howto/logging.html](https://docs.python.org/3/howto/logging.html), followed by the official documentation at [https://docs.python.org/3/library/logging.html](https://docs.python.org/3/library/logging.html).    Alternatively, you could use a third-party logging library like *eliot* ([https://eliot.readthedocs.io/](https://eliot.readthedocs.io/)) or *loguru* ([https://github.com/Delgan/loguru](https://github.com/Delgan/loguru)). These libraries have their own patterns and techniques, so you’ll want to see their documentation to learn more.    ## Assert Statements    While coding, you may sometimes become aware of conditions that would render your logic nonsensical. You can check for these conditions using an `assert` statement, which will raise an `AssertionError` exception if an expression fails.    However, while these checks are useful during development or debugging, they’re often extraneous during normal operation by the end user. If you pass the `-O` flag (for *optimize*) to the Python interpreter when invoking your package or module, all `assert` statements are removed from the code by the Python interpreter.    For this reason, only use `assert` statements to check for mistakes *you* made! Never use them for data validation, nor in response to user mistakes, as users should never be able to disable data and input validation. Use exceptions and warnings for those scenarios.    Instead, use assertions to aid you in debugging particularly *brittle* areas of your code: places where a minor or seemingly unrelated change to the code could have unintended side effects. The following simple example will demonstrate where `assert` is and is not useful.    ### Proper Use of assert    In this example program, I want to calculate how many vinyl records I can store on any given bookshelf. There’s one key constant in the program: the thickness of a single vinyl record in its jacket:    ```", "```py    Listing 19-12: *vinyl_collector.py:1a*    Using a constant for this value is helpful for making the code maintainable. If I need to update this thickness later—perhaps because I do some complicated statistics to find a more precise average—I need to make sure the value I’m using is still valid. I know in advance that I’ll need to use this constant as the divisor in some later math, which means the constant absolutely cannot be zero. It should also be a positive number, as vinyl records can’t have a negative thickness. Thus, the comment is somewhat helpful here . . . but then again, it won’t do anything to stop me from assigning a nonsense value to the constant!    Since a wrong value will cause major problems in the code itself, and since the value is not externally sourced data or user input, I can make an assertion. Under the hood, an `assert` statement looks like this:    ```", "```py    Listing 19-13: *vinyl_collector.py:1b*    The `__debug__` constant is defined by the interpreter and set to `True` by default. If the `-O` flag is passed to the interpreter, it is set to `False`. It is not possible to assign a value to `__debug__` directly, so as long as `-O` was not passed to the interpreter, the assertion condition is evaluated. In this case, if `THICKNESS` is not greater than `0`, I raise an `AssertionError`.    The `assert` statement wraps all this logic into one line:    ```", "```py    Listing 19-14: *vinyl_collector.py:1c*    Note the lack of parentheses involved here, as `assert` is a keyword, not a function. The condition `THICKNESS > 0` is checked, and if it fails, an `AssertionError` is raised, with the string after the comma used as the error’s message.    The reason for placing the `assert` here becomes clearer given the next part of the code, which performs some operations using `THICKNESS`:    ```", "```py    Listing 19-15: *vinyl_collector.py:2*    If `THICKNESS` were ever `0`, the division in this function would raise a `ZeroDivisionError`. That error could point me in the right direction while debugging, but there are three issues. First, the actual problem is where I define `THICKNESS`, which could (theoretically) be some distance away from this function. Second, the error would only surface once this function is called, meaning that if I don’t happen to invoke this function during my testing, I could miss the bug entirely. Third, a negative value in `THICKNESS` would produce nonsense output, but the math would still be valid, so the bug might slip past.    The purpose of placing the assertion right next to the definition of the constant is to alert me to a bug at its source, as early in the execution flow as possible.    ### Wrong Use of assert    As I mentioned earlier, `assert` should not be used for data or input validation. Regular exceptions and conditions should be used for those instead.    For example, this function prompts the user to input a value and then attempts to convert it to an integer. This first version improperly uses `assert` to ensure that the number is positive:    ```", "```py    Listing 19-16: *vinyl_collector.py:3**a*    You may be able to see where this is going, but I’ll finish up with the rest of the program so we can see the problem in action:    ```", "```py    Listing 19-17: *vinyl_collector.py:4*    If I run the program normally, this seems to work pretty well. However, if I pass the `-O` flag to the interpreter, I find that my input validation has vanished:    ```", "```py    Input validation isn’t very useful if it can be turned off. This is why `assert` should never be used for validating external data or user input. Instead, I use other techniques and leave `assert` out of it:    ```", "```py    Listing 19-18: *vinyl_collector.py:3**b*    Now, even if I run the program with the `-O` flag, data validation will work as expected.    ### Seeing assert in Action    The final program only uses `assert` to catch a nonsense value being assigned to the `THICKNESS` constant in code, and nothing else. For the sake of example, I’ll change `THICKNESS` to a negative value, to get on the bad side of the assert statement:    ```", "```py    Listing 19-19: *vinyl_collector.py:1d*    I invoke the program in the ordinary way:    ```", "```py    That outputs the expected `AssertionError`, since the value of `THICKNESS` is negative:    ```", "```py    I can jump right to line 2, which is immediately next to the source of the problem. I can fix the problem, although I won’t do that yet, for the sake of example.    If I instead pass `-O` to the interpreter, that will turn on optimizations and thereby suppress the assertion:    ```", "```py    Even though the value of `THICKNESS` is wrong, the program will try to work with it anyway, as if the `assert` statement weren’t even there:    ```", "```py    Nonsense output, sure, but I was expecting problems since I ran the program with `-O`, without fixing the assertion errors. In reality, you’ll only want to invoke with `-O` once you’re reasonably certain there are no assertion errors in your program; it’s a flag you’ll only ever use in *production*, not in development.    ## The inspect Module    One more useful tool in your debugging toolbox is the `inspect` module, which provides a number of functions to return data about objects and modules in Python, as well as code and traceback information. This data can be used to log more insightful debug messages.    As a fun little aside, outside of debugging, one of my favorite tricks I’ve ever done with `inspect` is to send the source of a Python function over a network to a remote machine. This allowed me to perform automated testing on those machines, without first having to install anything special.    The documentation is sufficient to introduce the functionality of this module: [https://docs.python.org/3/library/inspect.html](https://docs.python.org/3/library/inspect.html).    ## Using pdb    Warnings, logging, and `assert` statements make it possible to perform quite a bit of manual debugging, without the use of external tools. While this is useful for many scenarios, there are a number of other tools that can help you quickly home in on a problem in your code. These are primarily helpful when there’s a possibility that the source of the error is some distance from its manifestation or when there are multiple components involved in the problem.    The *Python Debugger* (`pdb`) is a full-featured debugger for Python. Its workflow is similar to other command-line debuggers like `gdb` (for C++) and `jdb (for Java). You use it by setting *breakpoints*, places in the program where control is turned over to the debugger, allowing you to step through the code line by line to observe what’s going on.`   ```", "```py from datetime import time   def get_timetable(train):     # Pretend this gets data from a server.     return [         {\"station\": \"target_field\", \"arrives\": time(hour=16, minute=27)},         {\"station\": \"fridley\", \"arrives\": time(hour=16, minute=41)},         {\"station\": \"coon_rapids_fridley\", \"arrives\": time(hour=16, minute=50)},         {\"station\": \"anoka\", \"arrives\": time(hour=16, minute=54)},         {\"station\": \"ramsey\", \"arrives\": time(hour=16, minute=59)},         {\"station\": \"elk_river\", \"arrives\": time(hour=17, minute=4)},         {\"station\": \"big_lake\", \"arrives\": time(hour=17, minute=17)},     ]   def next_station(now, timetable):     \"\"\"Return the name of the next station.\"\"\"     station = None     for stop in timetable:         if stop['arrives'] > now:             station = stop             break     station['station'] = station['station'].replace('_', ' ').title()     return station   def arrives_at(station, timetable):     for stop in timetable:         if station == stop['station']:             return stop   timetable = get_timetable('nstar_northbound')  station = next_station(time(hour=16, minute=43), timetable) print(f\"Next station is {station['station']}.\")  stop = arrives_at('coon_rapids_fridley', timetable) print(f\"Arrives at {stop['arrives']}.\") ```", "```py Traceback (most recent call last):   File \"./train_timetable.py\", line 40, in <module>     stop = arrives_at('coon_rapids_fridley', timetable) TypeError: 'NoneType' object is not subscriptable ```", "```py python3 -m pdb train_timetable.py ```", "```py python3 -m pdb -m timecard ```", "```py > ./train_timetable.py(1)<module>() -> from datetime import time (Pdb)  ```", "```py breakpoint() ```", "```py import pdb; pdb.set_trace() ```", "```py python3 the_module_being_debugged.py ```", "```py python3 -m pdb train_timetable.py ```", "```py > ./train_timetable.py(1)<module>() -> from datetime import time (Pdb) **next** > ./train_timetable.py(4)<module>() -> def get_timetable(train): (Pdb) **n** > ./train_timetable.py(17)<module>() -> def next_station(now, timetable): (Pdb) **n** > ./train_timetable.py(28)<module>() -> def arrives_at(station, timetable): (Pdb) **n** > ./train_timetable.py(34)<module>() ❶ -> timetable = get_timetable('nstar_northbound') (Pdb) **list**  29      for stop in timetable:  30          if station == stop['station']:  31              return stop  32  33  34  ->timetable = get_timetable('nstar_northbound')  35  36  station = next_station(time(hour=16, minute=43), timetable)  37  print(f\"Next station is {station['station']}.\")  38  39  stop = arrives_at('coon_rapids_fridley', timetable) ```", "```py (Pdb) **break 39** Breakpoint 1 at ./train_timetable.py:39 (Pdb) **continue** Next station is Coon Rapids Fridley. > ./train_timetable.py(39)<module>() -> stop = arrives_at('coon_rapids_fridley', timetable) ```", "```py (Pdb) **step** --Call-- > ./train_timetable.py(28)arrives_at() -> def arrives_at(station, timetable): (Pdb) **s** > ./train_timetable.py(29)arrives_at() -> for stop in timetable: (Pdb) **args** ❶ station = 'coon_rapids_fridley' timetable = (     {'station': 'target_field', 'arrives': datetime.time(16, 27)},     {'station': 'fridley', 'arrives': datetime.time(16, 41)}, ❷     {'station': 'Coon Rapids Fridley', 'arrives': datetime.time(16, 50)},     {'station': 'anoka', 'arrives': datetime.time(16, 54)},     {'station': 'ramsey', 'arrives': datetime.time(16, 59)},     {'station': 'elk_river', 'arrives': datetime.time(17, 4)},     {'station': 'big_lake', 'arrives': datetime.time(17, 17)} ) ```", "```py (Pdb) **where**   /usr/local/lib/python3.9/bdb.py(580)run() -> exec(cmd, globals, locals)   <string>(1)<module>()   ./train_timetable.py(39)<module>() -> stop = arrives_at('coon_rapids_fridley', timetable) ❶ > ./train_timetable.py(29)arrives_at() -> for stop in timetable: (Pdb) **up** > ./train_timetable.py(39)<module>() -> stop = arrives_at('coon_rapids_fridley', timetable) ```", "```py stop = arrives_at('coon_rapids_fridley', timetable) ```", "```py (Pdb) **l**  34  timetable = get_timetable('nstar_northbound')  35  36  station = next_station(time(hour=16, minute=43), timetable)  37  print(f\"Next station is {station['station']}.\")  38  39 B->stop = arrives_at('coon_rapids_fridley', timetable)  40  print(f\"Arrives at {stop['arrives']}.\") [EOF] (Pdb) **b 36** Breakpoint 2 at ./train_timetable.py:36 ```", "```py (Pdb) **next** > ./train_timetable.py(40)<module>() -> print(f\"Arrives at {stop['arrives']}.\") ```", "```py (Pdb) **jump 34** > ./train_timetable.py(36)<module>() -> timetable = get_timetable('nstar_northbound') (Pdb) **n** > ./train_timetable.py(36)<module>() -> station = next_station(time(hour=16, minute=43), timetable) (Pdb) **pp timetable** ({'arrives': datetime.time(16, 27), 'station': 'target_field'},  {'arrives': datetime.time(16, 41), 'station': 'fridley'},  {'arrives': datetime.time(16, 50), 'station': 'coon_rapids_fridley'},  {'arrives': datetime.time(16, 54), 'station': 'anoka'},  {'arrives': datetime.time(16, 59), 'station': 'ramsey'},  {'arrives': datetime.time(17, 4), 'station': 'elk_river'},  {'arrives': datetime.time(17, 17), 'station': 'big_lake'}) ```", "```py (Pdb) **source next_station**  17  def next_station(now, timetable):  18      \"\"\"Return the name of the next station.\"\"\"  19      station = None  20      for stop in timetable:  21          if stop['arrives'] > now:  22              station = stop  23              break  24      station['station'] = station['station'].replace('_', ' ').title()  25      return station (Pdb) **b 24** Breakpoint 2 at ./train_timetable.py:24 (Pdb) **c** > ./train_timetable.py(22)next_station() -> station = stop ```", "```py (Pdb) **p station** {'station': 'coon_rapids_fridley', 'arrives': datetime.time(16, 50)} (Pdb) **n** > ./ch19/train_timetable.py(25)next_station() -> return station (Pdb) **p station** {'station': 'Coon Rapids Fridley', 'arrives': datetime.time(16, 50)} (Pdb) **pp timetable** ({'arrives': datetime.time(16, 27), 'station': 'target_field'},  {'arrives': datetime.time(16, 41), 'station': 'fridley'},  {'arrives': datetime.time(16, 50), 'station': 'Coon Rapids Fridley'},  {'arrives': datetime.time(16, 54), 'station': 'anoka'},  {'arrives': datetime.time(16, 59), 'station': 'ramsey'},  {'arrives': datetime.time(17, 4), 'station': 'elk_river'},  {'arrives': datetime.time(17, 17), 'station': 'big_lake'}) ```", "```py (Pdb) **!station['station'] = 'coon_rapids_fridley'** (Pdb) **pp timetable** ({'arrives': datetime.time(16, 27), 'station': 'target_field'},  {'arrives': datetime.time(16, 41), 'station': 'fridley'},  {'arrives': datetime.time(16, 50), 'station': 'coon_rapids_fridley'},  {'arrives': datetime.time(16, 54), 'station': 'anoka'},  {'arrives': datetime.time(16, 59), 'station': 'ramsey'},  {'arrives': datetime.time(17, 4), 'station': 'elk_river'},  {'arrives': datetime.time(17, 17), 'station': 'big_lake'}) (Pdb) **n** --Return-- > ./train_timetable.py(25)next_station()->{'arrives': datetime.time(16, 50), 'station': 'coon_rapids_fridley'} -> return station ```", "```py (Pdb) **b** Num Type         Disp Enb   Where 1   breakpoint   keep yes   at ./train_timetable.py:39         breakpoint already hit 1 time 2   breakpoint   keep yes   at ./train_timetable.py:36         breakpoint already hit 1 time 3   breakpoint   keep yes   at ./train_timetable.py:24         breakpoint already hit 1 time (Pdb) **clear 1 2** Deleted breakpoint 1 at ./train_timetable.py:39 Deleted breakpoint 2 at ./train_timetable.py:36 ```", "```py (Pdb) **continue** Next station is coon_rapids_fridley. Arrives at 16:50:00. The program finished and will be restarted > ./train_timetable.py(1)<module>() -> from datetime import time (Pdb) **q** ```", "```py $ **python3 -i train_timetable.py** Next station is Coon Rapids Fridley. Traceback (most recent call last):   File \"/home/jason/IBP Nextcloud/Documents/NoStarchPress/DeadSimplePython/Code/ch19/train_timetable.py\", line 40, in <module>     print(f\"Arrives at {stop['arrives']}.\") TypeError: 'NoneType' object is not subscriptable > **import pdb; pdb.pm()** > /home/jason/IBP Nextcloud/Documents/NoStarchPress/DeadSimplePython/Code/ch19/train_timetable.py(40)<module>() -> print(f\"Arrives at {stop['arrives']}.\") (Pdb)  ```", "```py (Pdb) **pp timetable** ({'arrives': datetime.time(16, 27), 'station': 'target_field'},  {'arrives': datetime.time(16, 41), 'station': 'fridley'},  {'arrives': datetime.time(16, 50), 'station': 'Coon Rapids Fridley'},  {'arrives': datetime.time(16, 54), 'station': 'anoka'},  {'arrives': datetime.time(16, 59), 'station': 'ramsey'},  {'arrives': datetime.time(17, 4), 'station': 'elk_river'},  {'arrives': datetime.time(17, 17), 'station': 'big_lake'}) (Pdb) **p station** {'station': 'Coon Rapids Fridley', 'arrives': datetime.time(16, 50)} ```", "```py import ctypes  ctypes.memset(0, 254, 1) ```", "```py Segmentation fault (core dumped) ```", "```py python3 -X faulthandler segfault.py ```", "```py import ctypes  **import faulthandler; faulthandler.enable()**  ctypes.memset(0, 254, 1) ```", "```py Fatal Python error: Segmentation fault  Current thread 0x00007f7af346a280 (most recent call first):   File \"/home/jason/DeadSimplePython/segfault.py\", line 5 in <module> Segmentation fault (core dumped) ```", "```py equation = input(\"Enter an equation: \") result = eval(equation) print(f\"{equation} = {result}\") ```", "```py python3 -m bandit magic_calculator.py ```", "```py [main]  INFO    profile include tests: None [main]  INFO    profile exclude tests: None [main]  INFO    cli include tests: None [main]  INFO    cli exclude tests: None [main]  INFO    running on Python 3.9.0 [node_visitor]  INFO    Unable to find qualified name for module: super_calculator.py Run started:2022-05-29 22:25:37.497963 Test results: Issue: [B322:blacklist] The input method in Python 2 will read from standard input, evaluate, and run the resulting string as python source code. This is similar to, though in many ways worse than, using eval. On Python 2, use raw_input instead. Input is safe in Python 3\\. 1    Severity: High   Confidence: High    Location: super_calculator.py:1    More Info: https://bandit.readthedocs.io/en/latest/blacklists/blacklist_calls.html#b322-input 1       equation = input(\"Enter an equation: \") 2       result = eval(equation) 3       print(f\"{equation} = {result}\")  -------------------------------------------------- Issue: [B307:blacklist] Use of possibly insecure function - consider using safer ast.literal_eval. 2    Severity: Medium   Confidence: High    Location: super_calculator.py:2    More Info: https://bandit.readthedocs.io/en/latest/blacklists/blacklist_calls.html#b307-eval 1       equation = input(\"Enter an equation: \") 2       result = eval(equation) 3       print(f\"{equation} = {result}\")  --------------------------------------------------  Code scanned:         Total lines of code: 3         Total lines skipped (#nosec): 0  Run metrics:         Total issues (by severity):                 Undefined: 0.0                 Low: 0.0                 Medium: 1.0                 High: 1.0         Total issues (by confidence):                 Undefined: 0.0                 Low: 0.0                 Medium: 0.0                 High: 2.0 Files skipped (0):  ```", "```py #!/usr/bin/env python3  equation = input(\"Enter an equation: \") result = eval(equation) print(f\"{equation} = {result}\") ```", "```py #!/bin/env/python3 **import ast**  equation = input(\"Enter an equation: \") result = **ast.literal_eval(**equation**)** print(f\"{equation} = {result}\") ```", "```py` ```", "```py`` ```", "```py textproof/ ├── LICENSE ├── MANIFEST.in ├── pyproject.toml ├── README.md ├── requirements.txt ├── setup.cfg ├── setup.py ├── src/ │   └── textproof/ │   │   ├── __init__.py │   │   └── __main__.py ├── tests/ │   ├── conftest.py │   └── __init__.py └── venv/ ```", "```py [options] package_dir =     = src packages = find: include_package_data = True install_requires =     requests     click python_version = >=3.6, <4  [options.packages.find] where = src exclude = tests  [options.extras_require] test =     pytest  [options.entry_points] console_scripts =     textproof = textproof.__main__:main  [flake8] max-line-length = 120 ```", "```py include LICENSE *.md ```", "```py [build-system] requires = [\"setuptools>40.8.0\", \"wheel\"] build-backend = \"setuptools.build_meta\" ```", "```py import pathlib   class FileIO:      def __init__(self, in_file, out_file=None):         self.in_file = pathlib.Path(in_file)          if out_file is None:             out_file = in_file         self.out_file = pathlib.Path(out_file)         self.out_file_tmp = pathlib.Path(out_file + '.tmp')          self.data = None      def load(self):         if not self.data:             with self.in_file.open('r') as file:                 self.data = file.read()          return self.data      def save(self):         if not self.data:             raise RuntimeError(\"Nothing to save.\")          with self.out_file_tmp.open('w') as file:             file.write(self.data)         self.out_file_tmp.rename(self.out_file) ```", "```py import pathlib import pytest from textproof.fileio import FileIO  class TestFileIO:      def test_in_path(self):         file = FileIO('tests/to_be.txt')         assert file.in_file == pathlib.Path('tests/to_be.txt')      def test_out_path(self):         file = FileIO('tests/to_be.txt', 'tests/out.txt')         assert file.out_file == pathlib.Path('tests/out.txt')      def test_no_out_path(self):         file = FileIO('tests/to_be.txt')         assert file.in_file == file.out_file ```", "```py venv/bin/pip install -e '.[test]' ```", "```py venv/bin/pytest ```", "```py ====================== test session starts ======================= platform linux --  rootdir: /home/jason/Code/Repositories/textproof collected 3 items  tests/test_fileio.py ...                                   [100%]  ======================= 3 passed in 0.02s ======================== ```", "```py  def test_invalid_in_path(self):         with pytest.raises(FileNotFoundError):             FileIO('tests/idonotexist.txt') ```", "```py ====================== test session starts ======================= platform linux --  rootdir: /home/jason/Code/Repositories/textproof collected 4 items  tests/test_fileio.py ...❶  F                                  [100%]  ============================ FAILURES ============================ ________________ TestFileIO.test_invalid_in_path _________________  self = <tests.test_fileio.TestFileIO object at 0x7f9945d29580>      def test_invalid_in_path(self):         with pytest.raises(FileNotFoundError): >           FileIO('tests/idonotexist.txt') E       ❷  Failed: DID NOT RAISE <class 'FileNotFoundError'>  tests/test_fileio.py:21: Failed ==================== short test summary info ===================== FAILED tests/test_fileio.py::TestFileIO::test_invalid_in_path ================== 1 failed, 3 passed in 0.03s =================== ```", "```py import pathlib   class FileIO:      def __init__(self, in_file, out_file=None):         self.in_file = pathlib.Path(in_file)         **if not self.in_file.exists():**  **raise FileNotFoundError(f\"Invalid input file: {self.in_file}\")**          if out_file is None:             out_file = in_file         `# --snip--` ```", "```py import pytest import pathlib from textproof.fileio import FileIO   class TestFileIO:      **demo_data = \"To be, or not to be, that is the question!\"**   **@pytest.fixture**  **def demo_in_file(self, tmp_path):**  **test_in_file = pathlib.Path(tmp_path) / 'to_be.txt'**  **with test_in_file.open('w') as file:**  **file.write(self.demo_data)**  **return str(test_in_file)**   **@pytest.fixture**  **def demo_out_file(self, tmp_path):**  **test_out_file = pathlib.Path(tmp_path) / 'out.txt'**  **return str(test_out_file)**      `#` `--snip--` ```", "```py  # `--snip--`     def test_in_path(self, **demo_in_file**):         file = FileIO(**demo_in_file**)         assert file.in_file == pathlib.Path(**demo_in_file**)      def test_out_path(self, **demo_in_file, demo_out_file**):         file = FileIO(**demo_in_file, demo_out_file**)         assert file.out_file == pathlib.Path(**demo_out_file**)      def test_no_out_path(self, **demo_in_file**):         file = FileIO(**demo_in_file**)         assert file.in_file == file.out_file ```", "```py  def test_load(self, demo_in_file):         file = FileIO(demo_in_file)         file.load()         assert file.data == self.demo_data      def test_save(self, demo_in_file, demo_out_file):         file = FileIO(demo_in_file, demo_out_file)         file.data = self.demo_data         file.save()         with pathlib.Path(demo_out_file).open('r') as check_file:             assert check_file.read() == self.demo_data      def test_save__no_load(self, demo_in_file, demo_out_file):         file = FileIO(demo_in_file, demo_out_file)         with pytest.raises(RuntimeError):             file.save() ```", "```py import requests   def api_query(text):     lang = \"en-US\"     response = requests.post(         \"https://languagetool.org/api/v2/check\",         headers={\"Content-Type\": \"application/json\"},         data={\"text\": text, \"language\": lang},     )  if response.status_code != 200:         raise RuntimeError(f\"API error: [{response}] {response.text}\")      software = response.json()[\"software\"]     print(f\"{software['name']} v{software['version']}\")     print(response.json()['language']['name'])     return response.json()[\"matches\"] ```", "```py import pytest  example_text = \"He and me went too the stor.\"  example_output = \"He and I went to the store.\"  example_api_response = [     {         'context': {             'length': 2,             'offset': 7,  'text': 'He and me went too the stor.'         },         'length': 2,         'message': 'Did you mean \"I\"?',         'offset': 7,         'replacements': [{'value': 'I'}],     },     {         'context': {                 'length': 7,                 'offset': 15,                 'text': 'He and me went too the stor.'         },         'length': 7,         'message': 'Did you mean \"to the\"?',         'offset': 15,         'replacements': [{'value': 'to the'}],     },     {         'context': {             'length': 4,             'offset': 23,             'text': 'He and me went too the stor.'         },         'length': 4,         'message': 'Possible spelling mistake found.',         'offset': 23,         'replacements': [{'value': 'story'},                         {'value': 'stop'},                         {'value': 'store'},                         {'value': 'storm'}]     } ]   def pytest_configure(config):     pytest.example_text = example_text     pytest.example_output = example_output     pytest.example_api_response = example_api_response ```", "```py import pytest import requests   def test_api_layout():     response = requests.post(         \"https://languagetool.org/api/v2/check\",         headers={\"Content-Type\": \"application/json\"},         data={\"text\": pytest.example_text, \"language\": \"en-US\"},     )     if response.status_code != 200:         pytest.skip(\"Server unavailable\")      matches = response.json()[\"matches\"]     for from_api, expected in zip(matches, pytest.example_api_response):         from_api = set(from_api.keys())         expected = set(expected.keys())         assert expected.issubset(from_api) ```", "```py class Typo:     def __init__(self, typo):         context = typo[\"context\"]         self.text = context[\"text\"]         self.hint_offset = int(context[\"offset\"])         self.offset = int(typo[\"offset\"])         self.length = int(typo[\"length\"])         self.message = typo[\"message\"]         self.suggestions = typo[\"replacements\"]      def __str__(self):         underline = \"\".join((\" \" * self.hint_offset, \"^\" * self.length))         return \"\\n\".join((self.text, underline, self.message)) ```", "```py He and me went too the stor.        ^^ Did you mean \"I\"? ```", "```py  def get_choice(self):         while True:             raw = input(\"Select an option: \")             try:                 choice = int(raw)             except ValueError:                 print(\"Please enter a valid integer.\")                 continue              if choice < 0 or choice > len(self.suggestions):                 print(\"Invalid choice.\")                 continue              return choice ```", "```py  def select_fix(self):         print('')         print(self)          for num, suggestion in enumerate(self.suggestions, 1):             if \"shortDescription\" in suggestion:                 print(                     f\"{num}: {suggestion['value']} \"                     f\"({suggestion['shortDescription']})\"                 )             else:                 print(f\"{num}: {suggestion['value']}\")         print(\"0: (Skip)\")          choice = self.get_choice()         if choice > 0:             suggestion = self.suggestions[choice - 1][\"value\"]             length_change = len(suggestion) - self.length             return (suggestion, self.offset, self.length, length_change)         else:             return (None, 0, 0, 0) ```", "```py import pytest from textproof.typo import Typo   class TestTypo:      @pytest.mark.parametrize(\"index\", range(3))     def test_create_typo(self, index):         example_response = pytest.example_api_response[index]         example_typo = Typo(example_response)         assert example_typo.offset == example_response['offset']         assert example_typo.length == example_response['length']         assert example_typo.message == example_response['message']         assert example_typo.suggestions == example_response['replacements'] ```", "```py ====================== test session starts ======================= platform linux -- Python 3.8.10, pytest-7.1.2, pluggy-1.0.0 rootdir: /home/jason/Code/Repositories/textproof collected 11 items  tests/test_api.py .                                        [  9%] tests/test_fileio.py .......                               [ 72%] tests/test_typo.py ...                                     [100%]  ======================= 11 passed in 0.58s ======================= ```", "```py FAILED tests/test_typo.py::TestTypo::test_create_typo[1] - ... ```", "```py @pytest.fixture def example_response(request):     return example_api_response[request.param] ```", "```py @pytest.fixture def example_typo(request):     from textproof.typo import Typo     return Typo(example_api_response[request.param]) ```", "```py import pytest from textproof.typo import Typo   class TestTypo:      @pytest.mark.parametrize(         **(\"example_typo\", \"example_response\"),**  **[(0, 0), (1, 1), (2, 2)],**  **indirect=(\"example_typo\", \"example_response\")**     )     def test_create_typo(self, **example_typo, example_response**):         assert example_typo.offset == example_response['offset']         assert example_typo.length == example_response['length']         assert example_typo.message == example_response['message']         assert example_typo.suggestions == example_response['replacements'] ```", "```py @pytest.fixture def fake_inputs(request, monkeypatch):     def fake():         value = iter(request.param)          def input(_):             return next(value)          return input      monkeypatch.setattr('builtins.input', fake()) ```", "```py  @pytest.mark.parametrize(         \"fake_inputs\",         [('-1', '20', '3'), ('3',), ('fish', '1.1', '3')],         indirect=True     )     def test_choice(self, fake_inputs):         example_response = pytest.example_api_response[2]         example_typo = Typo(example_response)         assert example_typo.get_choice() == 3 ```", "```py @pytest.fixture def example_response(request):     **marker = request.node.get_closest_marker(\"typo_id\")**     **if marker:**  **index = marker.args[0]**  **else:**         **index = request.param**     return example_api_response[**index**] ```", "```py @pytest.fixture def example_typo(request):     **marker = request.node.get_closest_marker(\"typo_id\")**  **if marker:**  **index = marker.args[0]**  **else:**  **index = request.param**      from textproof.typo import Typo     return Typo(example_api_response[**index**]) ```", "```py  **@pytest.mark.typo_id(2)**     @pytest.mark.parametrize(         \"fake_inputs\",  [('-1', '20', '3'), '3', ('fish', '1.1', '3')],         indirect=True     )     def test_choice(self, **example_typo,** fake_inputs):         assert example_typo.get_choice() == 3 ```", "```py ===================== test session starts ====================== platform linux --  rootdir: /home/jason/Code/Repositories/textproof collected 14 items                                               tests/test_api.py .                                      [  7%] tests/test_fileio.py .......                             [ 57%] tests/test_typo.py ......                                [100%]  ======================= warnings summary ======================= tests/test_typo.py:38   /home/jason/Code/Repositories/textproof/tests/test_typo.py:38: PytestUnknownMarkWarning: Unknown pytest.mark.typo_id - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/mark.html     @pytest.mark.typo_id(2)  -- Docs: https://docs.pytest.org/en/stable/warnings.html ================ 14 passed, 1 warning in 0.89s ================= ```", "```py [build-system] requires = [\"setuptools>40.8.0\", \"wheel\"] build-backend = \"setuptools.build_meta\"  **[tool.pytest.ini_options]** **markers = [**  **\"typo_id: the example scenario number\"** **]** ```", "```py def pytest_configure(config):     pytest.example_text = example_text     pytest.example_output = example_output     pytest.example_api_response = example_api_response      **config.addinivalue_line(**  **\"markers\", \"typo_id: the example scenario number\"**  **)** ```", "```py # `--snip--`  **example_prompts = [** **\"\"\"** **He and me went too the stor.**  **^^** **Did you mean \"I\"?** **1: I** **0: (Skip)** **\"\"\",** **\"\"\"** **He and me went too the stor.**  **^^^^^^^** **Did you mean \"to the\"?** **1: to the** **0: (Skip)** **\"\"\",** **\"\"\"** **He and me went too the stor.**  **^^^^** **Possible spelling mistake found.** **1: story** **2: stop** **3: store** **4: storm** **0: (Skip)** **\"\"\"** **]**   def pytest_configure(config):     pytest.example_text = example_text     pytest.example_output = example_output     pytest.example_api_response = example_api_response     **pytest.example_prompts = example_prompts** ```", "```py @pytest.fixture def example_prompt(request):     marker = request.node.get_closest_marker(\"typo_id\")     if marker:         index = marker.args[0]     else:         index = request.param      return example_prompts[index] ```", "```py  @pytest.mark.parametrize(         (\"example_typo, example_prompt\"),         [(n, n) for n in range(3)],         indirect=[\"example_typo\", \"example_prompt\"]     )     def test_prompt(self, example_typo, example_prompt, capsys, monkeypatch):         monkeypatch.setattr('builtins.input', lambda _: '0')         example_typo.select_fix()         captured = capsys.readouterr()         assert captured.out == example_prompt ```", "```py from textproof.typo import Typo from textproof.api import api_query   class CheckedText:     def __init__(self, text):         self.text = text         self.revised = text         self.length_change = 0         self.typos = [Typo(typo) for typo in api_query(text)]      def __str__(self):         return self.revised      def fix_typos(self):         for typo in self.typos:             suggestion, offset, length, change = typo.select_fix()             if not suggestion:                 continue             offset += self.length_change             self.revised = \"\".join(                 (                     self.revised[:offset],                     suggestion,  self.revised[offset + length:]                 )             )             self.length_change += change ```", "```py @pytest.fixture(autouse=True) def fake_api_query(monkeypatch):     def mock_api_query(_):         print(\"FAKING IT\")         return example_api_response      monkeypatch.setattr('textproof.api.api_query', mock_api_query) ```", "```py from textproof.api import api_query ```", "```py @pytest.fixture(autouse=True) def fake_api_query(monkeypatch):     def mock_api_query(_):         print(\"FAKING IT\")         return example_api_response      monkeypatch.setattr('textproof.api.api_query', mock_api_query)     **monkeypatch.setattr('textproof.checked_text.api_query', mock_api_query)** ```", "```py import pytest from textproof.checked_text import CheckedText   class TestCheckedText:      @pytest.fixture     def example_checked(self, monkeypatch):         return CheckedText(pytest.example_text)      def test_checked_text__init(self, example_checked):         assert example_checked.text == pytest.example_text         assert len(example_checked.typos) == 3 ```", "```py  @pytest.mark.parametrize(         (\"fake_inputs\", \"expected\"),         [             ((0, 0, 0), pytest.example_text),             ((1, 1, 3), pytest.example_output)         ],         indirect=[\"fake_inputs\"]     )     def test_fix_typo(self, example_checked, fake_inputs, expected):         example_checked.fix_typos()         assert example_checked.revised == expected ```", "```py #!/usr/bin/env python3  import click from textproof.fileio import FileIO from textproof.checked_text import CheckedText  @click.command() @click.argument('path') @click.option('--output', default=None, help=\"the path to write to\") def main(path, output):     file = FileIO(path, output)     try:         file.load()     except FileNotFoundError:         print(f\"Could not open file {path}\")         return      check = CheckedText(file.data)     check.fix_typos()     file.data = str(check)      file.save()   if __name__ == \"__main__\":     main() ```", "```py He and me went too the stor. We gott three bags of chips for the prty. the cola was too much so we gott lemon lime insted. ```", "```py venv/bin/textproof fixme.txt --output fixmeout.txt ```", "```py `# --snip--` [options.extras_require] test =     pytest     **coverage** `# --snip--` ```", "```py venv/bin/pip install -e '.[test]' ```", "```py [tool.coverage.run] source = [     \"textproof\", ]  [tool.coverage.paths] source = [     \"src/textproof\",     \"**/site-packages/textproof\" ] ```", "```py venv/bin/coverage run -m pytest venv/bin/coverage combine venv/bin/coverage report ```", "```py Name                                                     Stmts   Miss  Cover ---------------------------------------------------------------------------- venv/lib/python3.10/site-packages/textproof/__init__.py       0      0   100% venv/lib/python3.10/site-packages/textproof/__main__.py      19     19     0% venv/lib/python3.10/site-packages/textproof/api.py           10      8    20% venv/lib/python3.10/site-packages/textproof/checked_text.py  17      1    94% venv/lib/python3.10/site-packages/textproof/fileio.py        22      0   100% venv/lib/python3.10/site-packages/textproof/typo.py          37      1    97% ---------------------------------------------------------------------------- TOTAL                                                      105     29    72% ```", "```py `# --snip--` [options.extras_require] test =     pytest     coverage     **tox** `# --snip--` ```", "```py [tool.tox] legacy_tox_ini = \"\"\" [tox] isolated_build = True envlist = py38, py39, py310  [testenv] deps = pytest commands = pytest \"\"\" ```", "```py venv/bin/pip install '.[test]' ```", "```py venv/bin/tox ```", "```py __________________________ summary ___________________________   py38: commands succeeded   py39: commands succeeded   py310: commands succeeded   congratulations :) ```", "```py from timeit import timeit  count = 10_000_000  def multiple_assign():     x, y, z = 'foo', 'bar', 'baz'  time_multiple_assign = timeit(multiple_assign)  def single_assign():     x = 'foo'     y = 'bar'     z = 'baz'  time_single_assign = timeit(single_assign)  print(\"Multiple assignment:\", time_multiple_assign, sep='\\t') print(\"Individual assignment:\", time_single_assign, sep='\\t') ```", "```py Multiple assignment:    0.21586943799957226 Individual assignment:  0.18725779700071143 ```", "```py $ **python3 -m timeit -n 10000000 'x, y, z = \"foo\", \"bar\", \"baz\"'** 10000000 loops, best of 5: 20.8 nsec per loop $ **python3 -m timeit -n 10000000 'x = \"foo\"; y = \"bar\"; z = \"baz\"'** 10000000 loops, best of 5: 19.1 nsec per loop ```", "```py `# --snip--`  if __name__ == \"__main__\":     # main()     **import cProfile**     **cProfile.run('main()')** ```", "```py venv/bin/pip install -e . venv/bin/python3 -m textproof fixme.txt --output fixmeout.txt ```", "```py if __name__ == \"__main__\":     # main()     import cProfile**, pstats**     **pr = cProfile.Profile()**  **pr.enable()**  **main()**  **pr.disable()**  **stats = pstats.Stats(pr)**  **stats.strip_dirs()**  **stats.sort_stats(pstats.SortKey.CUMULATIVE)**  **stats.print_stats(10)** ```", "```py if __name__ == \"__main__\":     # main()     import cProfile, pstats     **with cProfile.Profile() as pr:**         main()     stats = pstats.Stats(pr)     stats.strip_dirs()     stats.sort_stats(pstats.SortKey.CUMULATIVE)     stats.print_stats(10) ```", "```py #!/usr/bin/env python3  import click from textproof.fileio import FileIO from textproof.checked_text import CheckedText  @click.command() @click.argument('path') @click.option('--output', default=None, help=\"the path to write to\") def main(path, output):     **import cProfile, pstats**     **with cProfile.Profile() as pr:**         file = FileIO(path, output)         `# --snip--`          file.save() ****stats = pstats.Stats(pr)**  **stats.strip_dirs()**  **stats.sort_stats(pstats.SortKey.CUMULATIVE)**  **stats.print_stats(10)**   if __name__ == \"__main__\":  **main()**** ```", "```py  7146 function calls (7110 primitive calls) in 3.521 seconds   Ordered by: cumulative time  List reduced from 652 to 10 due to restriction <10>   ncalls  tottime  percall  cumtime  percall filename:lineno(function)       1    0.000    0.000    2.693    2.693 checked_text.py:15(fix_typos)       9    0.000    0.000    2.693    0.299 typo.py:30(select_fix)       9    0.000    0.000    2.692    0.299 typo.py:15(get_choice)       9    2.691    0.299    2.691    0.299 {built-in method builtins.input}       1    0.000    0.000    0.827    0.827 checked_text.py:6(__init__)       1    0.000    0.000    0.827    0.827 api.py:4(api_query)       1    0.000    0.000    0.825    0.825 api.py:107(post)       1    0.000    0.000    0.825    0.825 api.py:16(request)       1    0.000    0.000    0.824    0.824 sessions.py:463(request)       1    0.000    0.000    0.820    0.820 sessions.py:614(send) ```", "```py venv/bin/python3 -m cProfile ❶ -o profile_out venv/bin/textproof fixme.txt --output fixmeout.txt venv/bin/snakeviz profile_out ```", "```py` ```"]