- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generators and Comprehensions
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In the previous chapter, we escaped all the headaches of traditional index-based
    loops. However, we haven’t yet completely escaped the nested loop.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to employ *generator expressions*, which allow you to rewrite
    the entire logic of a loop in a single statement. You can even create lists in
    this manner, with the much-loved *list comprehensions*. Before I get there, I’ll
    introduce *generators*, which provide a more compact alternative to custom iterable
    classes in many situations. You’ll also encounter the oft-overshadowed cousin
    of the generator, the humble *simple coroutine*, which provides an iterative solution
    for inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy Evaluation and Eager Iterables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The features I cover in this chapter all build on the principles of iterators,
    and many utilize the concept of *lazy evaluation,* which describes a process in
    which an iterator does not provide the next value until it is requested. This
    behavior, paired with the fact that iterators do not care how many items are possible
    in their iterable, provides the power behind generator objects.
  prefs: []
  type: TYPE_NORMAL
- en: While *iterators* are lazy, the definition of an iterable is not! Understanding
    this distinction is important when you’re writing code that works with large amounts
    of data. Incorrectly defining an iterable can lock your program in an infinite
    loop. In some cases, you can even chew through all available system memory and
    raise a `MemoryError` or even crash your machine. (I crashed my system twice while
    writing this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, collection literals are incredibly *eager*, in that they evaluate
    all of their items upon creation. Programmer Kyle Keen demonstrates this phenomenon
    with the following example, which I’ve restructured slightly for clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-1: *sleepy.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: Python eagerly evaluates each of the expressions in the list literal before
    assigning it to `sleepy`, which means it calls the two `time.sleep()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior can mean that collections have the potential to become a performance
    bottleneck when working with a lot of data or particularly complex expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, you must choose your approaches carefully! One of the best ways to handle
    large amounts of data is to use either generators or *generator expressions*,
    which I’ll cover shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Infinite Iterators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lazy evaluation makes it possible to have *infinite iterators*, which provide
    values on demand without ever being exhausted. This behavior is very important
    to some features I cover in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `itertools` module offers three infinite iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`count()` counts from the given numeric value, `start`, adding the optional
    `step` value each time. So, `count(5, 2)` would produce the values `5`, `7`, `9`,
    `11`, and so on, forever.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cycle()` cycles through each item in the given iterable, infinitely. Therefore,
    `cycle([1,2,3])` would produce `1`, `2`, `3`, `1`, `2`, `3`, on and on, forever.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repeat()` repeats the given value, either endlessly or up to an optionally
    specified number of times. Therefore, `repeat(42)` would produce the value `42`
    forever, while `repeat(42, 10)` would produce the value `42` up to `10` times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, as I mentioned earlier, the very behavior that makes infinite iterators
    useful also makes them dangerous: they have no brakes! When passed to a `for`
    loop that has no `break` statement, the loop becomes infinite. When unpacked with
    a starred expression or used to create a collection, the Python interpreter locks
    up or even crashes the system. Use infinite iterators with caution!'
  prefs: []
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A powerful alternative to the iterator class is the *generator function*, which
    looks like an ordinary function, except for its use of a special `yield` keyword.
    When a generator function is called directly, it returns a *generator iterator*
    (also known as a *generator object*) that encapsulates the logic from the suite
    of the generator function.
  prefs: []
  type: TYPE_NORMAL
- en: On each iteration, the generator iterator will run up to (and including) a `yield`
    statement, and then it will wait for another call to the special method `__next__()`,
    which Python implicitly creates behind the scenes. You will recall from Chapter
    9 that `__next__()` is the special method responsible for providing the next value
    in an iterator; it is called anytime an iterator object is passed to the `next()`
    function or used in a `for` loop. Once a generator iterator receives the call
    to `__next__()`, it will continue running until it hits another `yield`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, I can use a generator to generate license plate numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-2: *license_generator.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: I declare the `gen_license_plates()` generator function like any other function.
  prefs: []
  type: TYPE_NORMAL
- en: To generate all the possible combinations of letters, I use the `itertool.product`
    iterable. The predefined string `string.ascii_uppercase`, which I’m locally renaming
    to `alphabet`, will provide the values for each letter within an iterable collection
    (a string).
  prefs: []
  type: TYPE_NORMAL
- en: I iterate over all the possible combinations of three letters by initializing
    a `product` iterator ❶ that iterates over the `alphabet` string three times, concatenated.
    I join the three letters into a single string ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Before I iterate over the numbers, I ensure that `letters` is not equal to the
    string `'GOV'`. If it is, the generator will skip that iteration of letter combinations,
    as I imagine in this scenario that `'GOV'` is reserved for government vehicles
    only.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I iterate over all possible numbers, `000 to 999` ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The line that makes this function a generator is the `yield` statement. Every
    time this line is reached in the program execution, the value is returned, and
    then the generator waits for another call to `__next__()`. When `__next__()` is
    called again, the generator resumes exactly where it left off, thereby producing
    and yielding the next value.
  prefs: []
  type: TYPE_NORMAL
- en: 'I must call my generator function to create the generator iterator I want to
    use, which I’ll bind to a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-3: *license_generator.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: The name `license_plates` is now bound to the generator iterator created by
    `gen_license_plates()`. This is the object with the `__next__()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can treat `license_plates` the same as any iterator. For example, I’ll loop
    through all possible license plates, although this will take a long time to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-4: *license_generator.py:3a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'That outputs the following (redacted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Most real-world scenarios wouldn’t want all the possible numbers at once. Here’s
    a more practical usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-5: *license_generator.py:3b*'
  prefs: []
  type: TYPE_NORMAL
- en: I define a function, `new_registration()`, which handles all of the logic for
    a new license plate registration. If the name is not already in the system, it
    retrieves the next plate from the iterator `license_plates` ❶ and stores it in
    the `registrations` dictionary, with the given `owner` as the key. Then, it returns
    the plate number for convenience. If the name is already in the system, it will
    return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the example a little more interesting, I’m manually fast-forwarding
    through a few thousand license plates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-6: *license_generator.py:4*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I’ll put the `new_registration()` function to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-7: *license_plates.py:5*'
  prefs: []
  type: TYPE_NORMAL
- en: I use the `new_registration()` function to register myself at this fictional
    DMV, and then I store the returned license plate number in `my_plate`, which I
    print out. I also directly check the `registrations` dictionary, to see what license
    plate was registered to me.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Generators vs. Iterator Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall that a `__next__()` method in an iterator class will raise the `StopIteration`
    exception to announce that there are no more items to iterate over. Generators
    don’t require that exception to be explicitly raised; what’s more, since Python
    3.5, they don’t even allow it. When the generator function terminates, either
    by reaching its end or explicitly with a `return` statement, `StopIteration` is
    raised automatically, behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: As an Iterator Class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To demonstrate this, I’ll write an iterator class that randomly generates traffic
    on a freeway. Once it’s working, I’ll rewrite it as a generator function.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll start by defining a couple of lists of possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-8: *traffic_generator_class.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, I create a `Traffic` class for my iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-9: *traffic_generator_class.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: I don’t need an initializer, since I have no instance attributes. I make this
    class an iterable by defining the `__iter__()` special method, which returns `self`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I also need to define `__next__()` for this class to be an iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-10: *traffic_generator_class.py:4*'
  prefs: []
  type: TYPE_NORMAL
- en: In the `__next__()` special method, I randomly select a vehicle from the global
    `vehicles` list, using `random.choice()`. If I select the item `None` from that
    list, I raise the `StopIteration` exception to indicate an end (gap) in the stream
    of traffic. Otherwise, I select a random color from the global `colors` list,
    and then I return a formatted string containing the vehicle and color.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can use my `Traffic` iterator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-11: *traffic_generator_class.py:5*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I iterate over each vehicle, print out its description, and keep count of how
    many vehicles have passed. Once `StopIteration` is raised by `Traffic()`, the
    loop ends and the final `print()` statement is run. One example output of this
    code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That works fine, but the iterator class has a lot of extra boilerplate. Instead,
    I can write the iterator as a generator function, which I’ll do next.
  prefs: []
  type: TYPE_NORMAL
- en: As a Generator Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As before, I’ll reuse the lists from the previous example to define a couple
    of lists containing possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-12: *traffic_generator.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I’ll define the `traffic()` generator function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-13: *traffic_generator.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: I declare this generator function like any other function, although I must structure
    it to run continuously, the same as if I were going to `print()` each item. I
    accomplish this with an infinite loop. As soon as the function returns, either
    implicitly by reaching its end (which is not possible in this case) or via a `return`
    statement, the iterator will raise `StopIteration` behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Since I don’t know how much traffic is going to be randomly generated, I want
    this generator function to run indefinitely, until it selects a `None` value from
    `vehicles`. Then, instead of raising `StopIteration`, I exit the function with
    `return` to indicate that iteration is finished. Since Python 3.5, raising `StopIteration`
    within a generator function will raise a `RuntimeError` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage is the same as before, except that I’m now iterating over the generator,
    not the iterator class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-14: *traffic_generator.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is effectively the same as before (although remember, it’s random):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Closing Generators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generators, like any iterators, can be infinite. However, when you’re done with
    an iterator, you should close it, since leaving it sitting idle in memory for
    the rest of your program would be a waste of resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, here’s my traffic generator, rewritten to be infinite.
    I start by using the lists I wrote for the earlier example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-15: *traffic_infinite_generator.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my rewritten traffic generator function, which is the same as [Listing
    10-13](#listing10-13), except that I’ve dropped the `return` logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-16: *traffic_infinite_generator.py:2a*'
  prefs: []
  type: TYPE_NORMAL
- en: Since the function can never reach its end and has no `return` statement, the
    generator is an infinite iterator.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can use this generator in whatever way I want. For example, I could write
    a function for a car wash that uses the generator but limits how many vehicles
    can be washed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-17: *traffic_infinite_generator.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: I would pass a `traffic` iterator to the `car_wash()` function, along with an
    integer value bound to `limit` representing how many vehicles can be washed. The
    function iterates over traffic, washing each car, and keeping count.
  prefs: []
  type: TYPE_NORMAL
- en: Once the limit has been reached (or surpassed), I don’t want to keep the `traffic`
    iterable around anymore, especially as it may have been instantiated right in
    the argument list, so I close it. This causes `GeneratorExit` to be raised within
    the generator, which in turn causes `StopIteration` to be raised—ending the loop,
    and thus, the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that I’ve written the generator and the function using it, here’s how I
    put the two together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-18: *traffic_infinite_generator.py:4a*'
  prefs: []
  type: TYPE_NORMAL
- en: A new iterator is created from the `traffic()` generator function and passed
    right to the `car_wash()` function. When the function is finished, it also closes
    the iterator. It can now be cleaned up by the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: A new iterator can still be created from the `traffic()` generator function,
    but the old iterator is exhausted.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can create a generator iterator instead and use it in `car_wash()`, which
    ultimately closes it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-19: *traffic_infinite_generator.py:4b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `car_wash()` function closes the iterator `queue`, I can no longer
    pass it to `next()` to get a result, as you can see if I add this erroneous line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Leaving out the error, running that code produces something like the following
    redacted output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Behavior on Close
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rather than exiting quietly, I can have the generator do something else when
    it is closed explicitly. I accomplish this by catching the `GeneratorExit` exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-20: *traffic_infinite_generator.py:2b*'
  prefs: []
  type: TYPE_NORMAL
- en: I wrap my `yield` statement in a `try` clause. When `traffic.close()` is called,
    `GeneratorExit` is raised at the `yield` statement the generator is waiting at.
    I can catch this exception and do whatever I like, such as print out a message.
    Most important is that I must re-raise the `GeneratorExit` exception, or else
    the generator will never actually close!
  prefs: []
  type: TYPE_NORMAL
- en: 'Without making any changes to the usage of this generator (Listings 10-17 and
    10-19), running the code shows this new behavior at work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Throwing Exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One seldom-used feature of generators is the `throw()` method, which can be
    used to put the generator into some sort of exceptional state, especially when
    that requires some special behavior beyond the run-of-the-mill `close()`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you’re using a generator to retrieve values from a thermometer
    device over a network connection, and if the connection is lost, a default value
    (say, `0`) is returned from the query instead. You don’t want to log that default
    value, since it’s wrong! Instead, you’ll want the generator to return the constant
    `NaN` for that iteration.
  prefs: []
  type: TYPE_NORMAL
- en: You could write a different function that detects that the network connection
    is lost, which would retrieve from trying to query the disconnected device. Then,
    you can cause the generator to raise an exception at the `yield` statement it’s
    idling at by using the `throw()` method. Your generator can catch that exception
    and yield `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to how `close()` will raise `GeneratorExit`; in fact, `close()`
    is functionally identical to `throw(GeneratorExit)`.
  prefs: []
  type: TYPE_NORMAL
- en: As amazingly useful as that sounds, there aren’t as many real-world use cases
    for `throw()`. The thermometer example is one of the few valid such scenarios,
    but even that would likely be solved better by having the generator call the function
    for checking the network connection.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve had to write a fairly contrived example using my `traffic()` generator
    to demonstrate this behavior. I’m catching `ValueError` to allow skipping a vehicle;
    that is the exception that I will raise at the `yield` statement with the `throw()`
    method in the usage later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-21: *traffic_generator_throw.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: When the `ValueError` exception is raised at the `yield` statement, it will
    be caught ❶ and the generator will announce that the current vehicle is being
    skipped ❷, before moving to the next iteration of its infinite loop ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'This would really only be conceivably useful if I abstracted out the logic
    of washing a car into its own function. That function can raise exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-22: *traffic_generator_throw.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: The `wash_vehicle()` function checks that it’s not being asked to wash a semi.
    If it is, a `ValueError` is raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll write a function, `car_wash()`, which will handle passing each vehicle
    from `traffic()` to `wash_vehicle()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-23: *traffic_generator_throw.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: In the context of the `car_wash()` function, I catch all exceptions thrown from
    my call to `wash_vehicle()`. This catch-all is completely acceptable because I’m
    re-raising the caught exception within the generator, using `traffic.throw()`
    ❶. That way, the logic of which exceptions can be raised and how they are handled
    is handled solely by the `wash_vehicle()` function and the `traffic` generator.
    If any exception is passed to `traffic.throw()` that is not explicitly handled
    by the generator, that exception will be raised and left uncaught at the `yield`
    statement, so there is no implicit error silencing.
  prefs: []
  type: TYPE_NORMAL
- en: If there’s no exception from calling `car_wash()`, I increment my count of vehicles
    washed. If an exception was caught, I don’t want to increment, since I don’t want
    to count the skipped semis in the number of vehicles washed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I create a `traffic()` generator and pass it to the `car_wash()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-24: *traffic_generator_throw.py:4*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running that code produces something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can see that 10 vehicles are washed and all the semis are skipped. It works
    exactly as designed.
  prefs: []
  type: TYPE_NORMAL
- en: As I said, this was a contrived example. There’s probably little reason to have
    the *generator* handle the `ValueError` exception, when I could have handled it
    in the `car_wash()` function instead. While I cannot guarantee that there is never
    a use for `throw()`, if you think you need it, you’re often overlooking a simpler
    way of handling the problem.
  prefs: []
  type: TYPE_NORMAL
- en: yield from
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using a generator, you are not limited to yielding data from the current
    generator iterator. You can temporarily hand off control to other iterables, generators,
    or coroutines, by using `yield from`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my traffic generator, I want to add a small chance of a biker gang being
    generated. I start by writing a generator specifically for a biker gang. As with
    prior examples, I’m reusing those same lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-25: *traffic_bikers_generator.py:1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s my new `biker_gang()` generator function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-26: *traffic_bikers_generator.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: The `biker_gang()` generator will use the `random.randint()` function to select
    a random number between 2 and 10 and generate a biker gang of that size. For each
    bike in the gang, a random color is selected ❶ and a motorcycle of the selected
    color is yielded ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, I add three lines to my original infinite `traffic()` generator
    from [Listing 10-16](#listing10-16):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-27: *traffic_bikers_generator.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: I use `random.randint()` to determine whether to generate a biker gang, at a
    1-in-50 probability. To generate the biker gang, I use `yield from` to hand off
    execution flow to the `biker_gang()` generator ❶. The `traffic()` generator will
    stay paused at this position until the `biker_gang()` generator is finished, at
    which point, control is passed back to this generator and it resumes.
  prefs: []
  type: TYPE_NORMAL
- en: Once `biker_gang()` is done, I skip to the next iteration of the infinite loop
    with `continue` to generate another vehicle ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage of the `traffic()` generator is pretty much the same as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-28: *traffic_bikers_generator.py:4*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this code will (probably) show the new biker gang–generation logic
    at work. Here’s an example output (redacted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You are not limited to passing off control to other generators. You can use
    `yield from` to iterate over any iterable object, whether it be a collection,
    an iterator class, or a generator object. Once the iterable is exhausted, control
    reverts back to the calling generator.
  prefs: []
  type: TYPE_NORMAL
- en: Generator Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *generator expression* is an iterator that wraps the entire logic of a generator
    into a single expression. Generator expressions are lazy, so you can use them
    to work with large amounts of data without locking up your program.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how to create and use generator expressions, I’ll rebuild my
    earlier license plate generator. I’ll write a generator function containing a
    single `for` loop. Later, I’ll transform this into a generator expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'This loop generates all the possible license plate numbers consisting of the
    letters *ABC* and three following digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-29: *license_plates.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: The iterable `range(1000)` produces all the integers from `0` to `999`. The
    loop iterates through those values, assigning the current value of each iteration
    to `num`. Within the loop, I create the license plate number with f-strings, using
    string formatting to pad `num` with leading `0`s as necessary, to ensure there
    are always three digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'I want to print the values to test. Since this is also an iterator object,
    it is best to print the values it produces from its usage, instead of from within
    the iterator itself. I print from the generator like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-30: *license_plates.py:2a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this code prints the following (redacted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Because this generator function is so simple, containing only one loop, it
    is an ideal case for a generator expression. I’ll rewrite as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-31: *license_plates.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: The generator expression is enclosed in the outer parentheses and is bound to
    the name `license_plates`. The generator expression itself is essentially an inversion
    of the loop syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Within the generator expression, the logic from the suite of the loop earlier
    ([Listing 10-30](#listing10-30)) is declared first, where I define an expression
    that will be evaluated on each iteration. I create a string composed of the letters
    *ABC* and the number from the current iteration, left-padded with zeroes to three
    digits. Similar to a `return` in a lambda, the `yield` in the generator expression
    is implied.
  prefs: []
  type: TYPE_NORMAL
- en: Next, I declare the loop itself. As before, I iterate over a `range()` iterable,
    using the name `number` for the value on each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The revised usage here prints out all the possible license plates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-32: *license_plates.py:2b*'
  prefs: []
  type: TYPE_NORMAL
- en: Generator Objects Are Lazy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, all generator objects are lazy, whether they were produced by generator
    functions or generator expressions. This means generator objects produce values
    on demand, and not a moment sooner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall the modified version of Kyle Keen’s eager-evaluation demonstration from
    [Listing 10-1](#listing10-1). I can replicate that same essential logic in a generator
    expression, and you can see this lazy evaluation at work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-33: *sleepy.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the list—whose very *definition* caused the program to sleep for three
    seconds before continuing, because every item was being evaluated at definition—this
    code runs instantly, because it defers evaluation of its values until they’re
    needed. Defining the generator expression itself does not execute `time.sleep()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even when I manually iterate over the first value in `sleepy`, there is no
    delay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-34: *sleepy.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: Because `time.sleep(0)` is called on the first iteration of the generator expression,
    `next(sleepy)` returns instantly. Subsequent calls to `next(sleepy)` would cause
    the program to sleep, but that won’t happen until I request it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one critical exception to the lazy evaluation of generator expressions:
    the expression in the leftmost `for` statement is evaluated immediately. For example,
    consider what would happen if you were to write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-35: *sleepy.py:1c*'
  prefs: []
  type: TYPE_NORMAL
- en: That version of the generator expression has none of the desired lazy evaluation
    behavior, as the list `[1, 2, 3, 4, 5]` in the `for` loop is evaluated immediately
    when the generator expression is first encountered. This is by design, so any
    errors in the loop’s expression will be raised with a traceback to the generator
    expression’s declaration, rather than the first *usage* of the generator expression.
    However, because the list here evaluates instantly, we don’t actually see a delay.
  prefs: []
  type: TYPE_NORMAL
- en: Generator Expressions with Multiple Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generator expressions can support more than one loop at a time, replicating
    the logic of a nested loop. You list the loops in order, from outermost to innermost.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll rewrite my license plate generator expression to generate all possible
    combinations of letters and numbers, starting with `AAA 000` and ending with `ZZZ
    999`. There are 17,576,000 possible results for this, so this is fast only because
    generator expressions are lazy; the values are not created until they’re requested.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-36: *license_plates.py:1c*'
  prefs: []
  type: TYPE_NORMAL
- en: The generator expression, which is wrapped in parentheses and bound to `license_plates`,
    spans three lines here for readability. I could have written it as a single line,
    but once a generator expression starts involving multiple loops, it’s usually
    best to split it over multiple lines.
  prefs: []
  type: TYPE_NORMAL
- en: In my generator expression, I’m employing two loops. For the first (and outermost)
    loop, I iterate over all the possible combinations of three letters via `itertools.product`
    ❷, as I did in [Listing 10-2](#listing10-2). The product `iterator` produces a
    tuple of values on each iteration, which I must concatenate together into a string
    using `"".join()` ❶ when creating the formatted string.
  prefs: []
  type: TYPE_NORMAL
- en: For the second (or inner) loop, I iterate over all possible numbers between
    `000` and `999`, as before ❸.
  prefs: []
  type: TYPE_NORMAL
- en: On each iteration, I use an f-string to generate the license plate.
  prefs: []
  type: TYPE_NORMAL
- en: The result is an iterator bound to `license_plates` that can lazily generate
    all the possible license plate numbers. The next license plate is not created
    until it’s requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can use the `license_plates` generator expression the same as I would a generator
    object. Its usage is no different from what you saw in [Listing 10-5](#listing10-5)
    through [Listing 10-7](#listing10-7):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-37: *license_plates.py:2c*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Conditionals in Generator Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you may notice, this produced license plates starting with the letters *GOV*.
    I need to integrate that conditional from [Listing 10-2](#listing10-2) to check
    for that reserved combination of letters, which I’ll do next.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can add a conditional to my generator expression from [Listing 10-36](#listing10-36),
    to incorporate this limitation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-38: *license_plates.py:1d*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve added the conditional: if the value of the tuple `letters` is *not* `(''G'',
    ''O'', ''V'')`, the value will be used. Otherwise, the iteration will be skipped
    (an implicit `continue`).'
  prefs: []
  type: TYPE_NORMAL
- en: Order matters here! The loops and conditionals are evaluated from top to bottom,
    as if they were nested. If I’d checked for `('G', 'O', 'V')` further down, `continue`
    would be implicitly called on a thousand separate iterations, but since it *precedes*
    the second loop, the numbers are never iterated over on `('G', 'O', 'V')` at all;
    the generator expression continues on the first loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'This syntax can be a bit pesky to keep straight at first. I like to think of
    it as a nested loop, where the `yield` line at the end has been yanked out and
    stuck on the front. The equivalent generator function, written with a single nested
    loop, would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The last line moves to the front, and you drop the `yield` keyword, since that’s
    implied in generator expressions. You also drop the colons from the end of each
    of the other lines. This way of writing generator expressions is helpful for making
    sure your logic is sound.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the code again produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the conditional is working. Instead of `GOV 888`, the result
    is now `GOW 888`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use `if-else` in the context of a generator expression, but there
    is one catch: the placement is different from with just an `if`! This subtlety
    catches a lot of Python developers unawares, even the experienced ones.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me show you what I mean. Here’s a generator expression with an `if`, which
    produces all the integers less than 100 that are divisible by 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-39: *divis_by_three.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'That works, but now, I want to print out `"redacted"` for every number that
    *isn’t* divisible by 3\. You might logically try the following (as I did while
    writing this chapter, and it failed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-40: *divis_by_three.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running that produces this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Eep! The reason for this error becomes clear if you convert the generator expression
    to a generator function, using the technique I described earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'That syntax is outright nonsense. The generator expression itself does not
    support the `else` clause—in fact, every compound statement may only have one
    clause in a generator expression. However, the generator expression does support
    a *ternary expression*, which is a compact conditional expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Ternary expressions follow the form `a` `if` `expression` `else` `b`. The ternary
    expression evaluates to value `a` if `expression` evaluates to `True`—or to `b`,
    otherwise. These sorts of expressions can show up anywhere, from assignment to
    return statements. However, their use is discouraged in most situations, as they
    are hard to read. Ternary expressions are mainly only used in lambdas and generator
    expressions, where full-size conditional statements are out of the question.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can convert that generator function logic back into a generator expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-41: *divis_by_three.py:1c*'
  prefs: []
  type: TYPE_NORMAL
- en: 'That version evaluates correctly. Hooray! However, if I were to revert to using
    an `if` and dropping the `else` statement, I’d be back to having problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-42: *divis_by_three.py:1d*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running that gives me this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If I convert that back to generator function logic, the problem becomes evident
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Without an `else`, that’s not a ternary expression, so I have to go back to
    the normal `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'That can be converted back to a generator expression that works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-43: *divis_by_three.py:1e (same as 1a)*'
  prefs: []
  type: TYPE_NORMAL
- en: This can be a bit infuriating to remember offhand. I recommend you write your
    logic as a generator function first and then convert it to a generator expression.
  prefs: []
  type: TYPE_NORMAL
- en: Nested Generator Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One inefficiency in my use of the current version of the license plate generator
    expression is that I’m joining the string together on every iteration. My generator
    expression in [Listing 10-38](#listing10-38) joined each combination of letters
    once, instead of once for every combination of letters *and* numbers. What’s more,
    in my conditional, the code would look cleaner and be more maintainable if I had
    a nice, clean string to work with, instead of the tuple being produced by `product()`.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike generator functions, generator expressions are limited to nested single-clause
    compound statements, and thus, a single top-level loop. I can overcome this by
    *nesting* one generator expression inside the other. This is effectively the same
    as writing two separate generator expressions and having one use the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how I’d use this technique in my license plate generator code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-44: *license_plates.py:1e*'
  prefs: []
  type: TYPE_NORMAL
- en: The inner nested generator expression handles iterating over the results of
    `product()`, joining the three letters into a single string. In the outer generator
    expression, I iterate over the inner expression to get the string containing the
    next combination of letters. Then, before I iterate over the numbers, I ensure
    that `letters` is not equal to the string `'GOV'`. If it is, the generator expression
    will skip that iteration of letter combinations.
  prefs: []
  type: TYPE_NORMAL
- en: This approach improves the readability of my code. Instead of having to add
    cruft to the f-string by calling `join()` inside of it, I can directly include
    `{letters}` ❶.
  prefs: []
  type: TYPE_NORMAL
- en: While this is the cleanest approach to license plate generation I’ve used *so
    far*, I wouldn’t use the above code in production, because I’ve arguably reached
    the practical limit of readability for generator expressions. When things get
    this complicated, you should just reach for ordinary generator functions. The
    generator function in [Listing 10-2](#listing10-2) is much more readable and maintainable
    than the equivalent generator expression in [Listing 10-44](#listing10-44).
  prefs: []
  type: TYPE_NORMAL
- en: List Comprehensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you wrap a generator expression in square brackets (`[ ])` instead of parentheses,
    you create a *list comprehension*, which uses the enclosed generator expression
    to populate the list. This is the most common and perhaps the most popular usage
    of generator expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, since I’m declaring an *iterable*, I’m losing the lazy evaluation
    inherent in the generator expression. List comprehensions are eager because list
    definitions are eager. For that reason, I’d likely never write the license plate
    generator expression as a list comprehension; it would take several seconds to
    finish, and that doesn’t make for a pleasant user experience. Make sure you only
    use a list comprehension when you actually need a list object: that is, when you
    need to store the values in a collection for later processing or use. Otherwise,
    use a generator expression.'
  prefs: []
  type: TYPE_NORMAL
- en: 'List comprehensions are preferable to `filter()` for purposes of readability,
    as they’re easier to write and debug, and they look cleaner. I can rewrite the
    coffee `filter()` example from Chapter 9 (Listing 9-96) as a list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-45: *orders_comprehension.py*'
  prefs: []
  type: TYPE_NORMAL
- en: Remember, a list comprehension is just a type of generator expression. I iterate
    over every item `order` in the iterable `orders` ❷. If the string `'drip'` can
    be found in the current `order`, then I’ll add that item to `drip_orders` ❸. I
    don’t need to do anything with `order` besides adding it to the list, so I lead
    the generator expression with a bare `order` ❶.
  prefs: []
  type: TYPE_NORMAL
- en: Functionally, this code is the same as before, but this version with the list
    comprehension is *much* cleaner! `filter()` has its uses, but most of the time,
    you’ll find that generator expressions or list comprehensions will serve your
    purposes better.
  prefs: []
  type: TYPE_NORMAL
- en: Set Comprehensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as you can create a list comprehension by enclosing a generator expression
    in square brackets, so also can you create a *set comprehension* by enclosing
    in curly braces (`{ }`). This will use the generator expression to populate a
    *set*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There aren’t any surprises here, so I’ll keep the example very basic. This
    set comprehension will find all the possible remainders from dividing 100 by an
    odd number less than 100\. Sets will exclude any duplicates, making the results
    easier to comprehend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-46: *odd_remainders.py*'
  prefs: []
  type: TYPE_NORMAL
- en: For every other integer `divisor` between `1` and `99` inclusive, I find the
    remainder of dividing `100` by the `divisor`, using the modulo operator. The result
    is added to the set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running that code gives me this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Set comprehensions really do work the same as list comprehensions, except for
    which collection is created. Sets are unordered and contain no duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary Comprehensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A dictionary comprehension follows almost the same structure as a set comprehension,
    but it requires colons. Both a set comprehension and a dictionary comprehension
    are enclosed in curly braces (`{ }`), like their respective collection literals.
    A dictionary comprehension additionally uses a colon (`:`) to separate key-value
    pairs, and this is what distinguishes it from a set comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if I wanted a dictionary comprehension that uses an integer between
    1 and 100 as the key and the square of that number as the value, I would write
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-47: *squares_dictionary_comprehension.py*'
  prefs: []
  type: TYPE_NORMAL
- en: The key expression, on the left side of the colon, is evaluated before the value
    expression, on the right. I use the same loop for creating both key and value.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware, like with list and set comprehensions, dictionary comprehensions are
    eager. The program will evaluate the dictionary comprehension until the `range()`
    iterable I’m using is exhausted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: That’s all there is to it! Again, besides the colon, everything is the same
    as in any other generator expression.
  prefs: []
  type: TYPE_NORMAL
- en: Hazards of Generator Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generator expressions, along with the different types of comprehension, can
    be addictive, partly because one feels really smart when crafting them. There’s
    something about powerful one-liners that gets programmers very excited. We really
    like being clever with our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, I must caution against going too crazy with generator expressions.
    As The Zen of Python reminds us:'
  prefs: []
  type: TYPE_NORMAL
- en: Beautiful is better than ugly.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Simple is better than complex.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Complex is better than complicated.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: …
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sparse is better than dense.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Readability counts.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Generator expressions can be beautiful—but they can also become dense, unreadable
    messes when used unwisely. List comprehensions are especially vulnerable to abuse.
    I’ll lay out some examples of where list comprehensions and generator expressions
    aren’t suitable.
  prefs: []
  type: TYPE_NORMAL
- en: They Quickly Become Unreadable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following example appeared in a survey by Open edX. In the original, each
    list comprehension was on a single line. For the sake of reproducing it legibly,
    without giving my typesetter fits, I’ve taken the liberty of splitting each of
    the three list comprehensions across multiple lines. Unfortunately, it really
    doesn’t do much to improve things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Can you tell what’s going on? You probably could if you read it for a while,
    but why would you want to? The code is as clear as mud, and sure enough, it was
    rated as the most unreadable example in the survey.
  prefs: []
  type: TYPE_NORMAL
- en: List comprehensions and generator expressions are powerful, but it doesn’t take
    much for them to become unreadable like this. Since generator expressions essentially
    “flip” the order of statements, so the loop comes after the statement that relates
    to it, it is harder to comprehend the logic in this format. The above would be
    better written in the context of a traditional loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'My colleague “grym” from Libera.Chat IRC shared an even more abhorrent example
    of how easily abused list comprehensions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Don’t ask me what it does. None of us wanted to figure it out. My soul burns
    just reading it.
  prefs: []
  type: TYPE_NORMAL
- en: They Don’t Replace Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since generator expressions and comprehensions are so neat and compact, it might
    be tempting to write clever one-liners in place of garden variety `for` loops.
    Resist this temptation! Generator expressions are suited for creating lazy iterators,
    while list comprehensions should only be employed when you actually need to create
    a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this is best understood by studying an example. Imagine you
    were reading through someone else’s code and you encountered this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The first thing that stands out is that, although a list comprehension is meant
    to create a list value, that value is not being stored anywhere. Anytime a value
    is implicitly discarded like this, it should be a warning that the pattern is
    being abused.
  prefs: []
  type: TYPE_NORMAL
- en: Second, you can’t tell at a glance whether the data in `some_list` is being
    mutated directly. This is a case of a list comprehension being used inappropriately,
    in place of a loop. It’s somewhat unreadable, as it obfuscates the behavior of
    the code, and it also makes debugging difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one case where the author should have stuck with loops, which would
    have looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: In this form, it’s not so unexpected that the values in `some_list` are being
    mutated, although it’s still bad practice for a function to have side effects
    like this. Most importantly, debugging is easier.
  prefs: []
  type: TYPE_NORMAL
- en: They Can Be Hard to Debug
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The nature of a generator expression or comprehension is that you’re packing
    everything into one gigantic statement. The benefit of this is that you eliminate
    a bunch of intermediate steps. The drawback is . . . you eliminate a bunch of
    intermediate steps.
  prefs: []
  type: TYPE_NORMAL
- en: Think about debugging in a typical loop. You can step through it, one iteration
    at a time, using your debugger to observe the state of each variable as you go.
    You can also use error handling to deal with unusual edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: None of that can help you in a generator expression, where either everything
    works or nothing works. You can try to parse through the errors and output to
    figure out what you did wrong, but I assure you, it’s a confusing experience.
  prefs: []
  type: TYPE_NORMAL
- en: You can avoid some of this madness by avoiding generator expressions or list
    comprehensions on your first version of the code. Write the logic the obvious
    way, using traditional loops, iterator tools, or normal generators (coming up).
    Once you know it’s working, *then and only then* should you collapse the logic
    into a generator expression, and *only* if you can do so without eschewing all
    your error handling (`try` statements).
  prefs: []
  type: TYPE_NORMAL
- en: This may sound like a lot of extra work, but I follow this exact pattern in
    competitive code golfing, especially when I’m up against the clock. My understanding
    of generator expressions is usually my main advantage against less-experienced
    competitors, but I *always* write the standard loop or generator first; I cannot
    afford to waste time debugging bad logic in a generator expression.
  prefs: []
  type: TYPE_NORMAL
- en: When to Use Generator Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s difficult to set a hard-and-fast rule on when generator expressions should
    be used. As always, the important factor is readability. Most of my preceding
    examples split the generator expression across multiple lines, but they’re primarily
    intended to be written on one line. If doing so results in code that is difficult
    to visually parse, think twice about using generator expressions at all.
  prefs: []
  type: TYPE_NORMAL
- en: In a way, a generator expression is to an iterator as a lambda is to a function,
    in that it’s particularly useful for defining a one-off iterator right where you’ll
    use it. You can even omit the extra parentheses around a generator expression
    when it’s the sole argument. A generator expression, like a lambda, is best suited
    for simple, one-off logic that would benefit from being declared right where it’s
    used.
  prefs: []
  type: TYPE_NORMAL
- en: When the purpose of this one-off iterator is to populate a list, a list comprehension
    would be used. The same is true of set comprehensions and dictionary comprehensions
    for their respective collections.
  prefs: []
  type: TYPE_NORMAL
- en: Generators are preferred over generator expressions whenever you’re working
    with more complicated logic. Because a generator expression follows the same syntactic
    structure as an ordinary function, it isn’t prone to becoming unreadable in the
    same way generator expressions are.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Coroutines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *coroutine* is a type of generator that *consumes* data on demand, instead
    of producing data, and it waits patiently until it receives it. For example, you
    could write a coroutine to maintain a running average temperature; you can periodically
    send a new temperature to the coroutine, and it will immediately recalculate the
    average with each new value.
  prefs: []
  type: TYPE_NORMAL
- en: There are two kinds of coroutines. What I’m covering here is the *simple coroutine*.
    Later, when I cover concurrency, I’ll introduce the *native coroutine* (also known
    as the *asynchronous coroutine*), which employs and further builds on these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of this chapter, when I refer to *coroutines*, assume I’m talking
    about simple coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Because coroutines are generators, you can use `close()` and `throw()` with
    them. Control can be handed off to another coroutine, using `yield from`. Only
    `next()` will not work here, since you are sending values, rather than retrieving
    them; instead, you use `send()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, I want to count the number of vehicles (from the earlier `traffic()`
    generator) of a particular color in an iterative fashion. Here’s a coroutine that
    does that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-48: *traffic_colors_coroutine.py:1a*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `color_counter()` coroutine function accepts a single argument: a string
    for the color of the vehicle being counted. This argument will be passed when
    the generator iterator is created.'
  prefs: []
  type: TYPE_NORMAL
- en: I want this coroutine to receive data until I explicitly close it, so I use
    an infinite loop. The key difference between a generator and a coroutine is the
    location where the yield statement appears. Here, the `yield` expression is being
    *assigned* to something—specifically, to the name `vehicle` ❶. The data sent to
    the coroutine is assigned to `vehicle`, which I can then process by checking whether
    the color matches and incrementing the count of vehicles that match. Finally,
    I print out the current count.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I mentioned, I’ll reuse the infinite traffic generator from earlier to create
    the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-49: *traffic_colors_coroutine.py:2*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage of my `color_counter()` coroutine is not too different from that
    of a generator, but there are a few key differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-50: *traffic_colors_coroutine.py:3*'
  prefs: []
  type: TYPE_NORMAL
- en: Before I can use the coroutine, I have to create a coroutine object (actually,
    a generator iterator) from the coroutine function. I bind this object to `counter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I send data to a coroutine by using its `send()` method. However, before a
    coroutine can receive data, it must be *primed* by passing `None` to `send()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-51: *traffic_colors_coroutine.py:4a*'
  prefs: []
  type: TYPE_NORMAL
- en: Priming causes the coroutine to run up to its first `yield` statement. Without
    priming, whatever value is first sent is lost, as it’s the `yield` statement that
    receives the value sent in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, I could prime like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-52: *traffic_colors_coroutine.py:4b*'
  prefs: []
  type: TYPE_NORMAL
- en: It doesn’t matter which you use. I prefer the technique in [Listing 10-51](#listing10-51),
    because it makes it clear I’m priming a coroutine, rather than working with any
    old generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'After priming, I can use the coroutine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-53: *traffic_colors_coroutine.py:5a*'
  prefs: []
  type: TYPE_NORMAL
- en: I iterate over the `traffic()` generator, sending each value to the coroutine
    `counter` by using the `send()` method. The coroutine processes the data and prints
    out the current count of red vehicles.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of my loop, once I’ve iterated through a hundred vehicles, I
    manually close the coroutine and break out of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this code produces the following redacted output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Returning Values from a Coroutine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In real projects, one very rarely wants to print the results and be done. For
    most coroutines to be useful, you need some way to retrieve the data being produced.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this with my color counter, I’ll change one line in my coroutine and
    drop the `print()` statement I no longer want, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-54: *traffic_colors_coroutine.py:1b*'
  prefs: []
  type: TYPE_NORMAL
- en: I place the name `matches` after the `yield` keyword to indicate that I want
    to yield the value bound to that variable. Because a coroutine instance is really
    a special kind of generator iterator, it can both accept and return values with
    the `yield` statement. In this case, on each iteration, a new value is accepted
    and assigned to `vehicle`, and then the current value of `matches` is yielded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usage is very similar; it requires just a simple change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-55: *traffic_colors_coroutine.py:5b*'
  prefs: []
  type: TYPE_NORMAL
- en: Every time a value is sent via `counter.send()`, a value is also returned and
    assigned to `matches`. I print out this value after the loop is done, instead
    of seeing a running count.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new output is now one line, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Sequence of Behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The order in which things happen in coroutines can be a little difficult to
    anticipate. To understand this, here is an oversimplified coroutine that only
    outputs its input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 10-56: *coroutine_sequence.py*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the sequence of behavior when using a generator as both a generator
    and a coroutine like this:'
  prefs: []
  type: TYPE_NORMAL
- en: The coroutine is primed with `co.send(None)` ❺, advancing it to the first `yield`
    statement ❷ and yielding the initial value of `ret` (`None`). This value is printed
    out external to the coroutine ❻.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first input to the coroutine (`0`) is accepted from `co.send()` ❽ and stored
    in `recv` ❶.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The value of `recv` (`0`) is printed out ❸ and then stored in `ret` ❹.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The coroutine advances to the next `yield` ❷.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The current value of `ret` (`0`) is yielded ❷, stored in `current` ❼, and printed
    in the `for` loop ❾. The `for` loop advances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next input (`1`) is accepted from `co.send()` ❽ and stored in `recv` ❶.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new value of `recv` (`1`) is printed out ❷ and then stored in `ret`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The coroutine advances to the next `yield`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The current value of `ret` (`1`) is yielded ❷, stored in `current` ❼, and printed
    in the `for` loop ❾. The `for` loop advances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And so on and so forth.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In simpler terms, the coroutine will always `yield` a value before it accepts
    a new value from `send()`. This is because the right side of the assignment expression
    is evaluated before the left side. The behavior is consistent with the rest of
    Python, even though it may feel a bit surprising in this context before you’re
    used to it.
  prefs: []
  type: TYPE_NORMAL
- en: What About Async?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some Python developers insist that simple coroutines have no place in modern
    Python code, that they’ve been entirely replaced by *native coroutines*—also known
    as *async coroutines*. This may be the case, but the difference in usage is nontrivial.
    Native coroutines have a number of advantages, but they have to be called differently.
    (I’ll cover `asyncio` and native coroutines in Chapter 16.)
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, I’ve covered the various forms of generator objects—generator
    expressions, comprehensions, and simple coroutines—and introduced infinite iterators.
  prefs: []
  type: TYPE_NORMAL
- en: Generators and coroutines make it possible to utilize lazy evaluation in your
    iterative code, wherein values are only evaluated on demand. When these features
    are utilized correctly, your code can process large amounts of data without hanging
    or crashing.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll build on many of these features in Chapter 16, when I introduce asynchrony.
  prefs: []
  type: TYPE_NORMAL
