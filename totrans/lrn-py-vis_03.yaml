- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Introduction to Strings and Working with Text
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串简介与文本操作
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In Chapter 1, you created a ‘Hello, World!’ string and printed it to the console,
    but Python can do far more than just print string data. In this chapter, you’ll
    use operators, functions, and methods to manipulate strings. Strings are fundamental
    data types common to most programming languages, and you’ll use them in almost
    all the programs you write. If you need to communicate information to your user,
    capture input from text fields, retrieve data from the web, or perform just about
    any task that involves text, you’ll be using strings.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，你创建了一个‘Hello, World!’字符串并将其打印到控制台，但 Python 能做的远不止打印字符串数据。在这一章，你将使用运算符、函数和方法来操作字符串。字符串是大多数编程语言中的基本数据类型，你将在几乎所有编写的程序中使用它们。如果你需要向用户传达信息、捕获文本框的输入、从网页获取数据或执行涉及文本的任何任务，你都会使用字符串。
- en: In this chapter, you’ll also learn how to use Processing’s text functions to
    render any string as text in the display window. Processing can draw text in various
    colors and styles, using different fonts, at different sizes and positions. You
    might use these features to paint with letters, label a graph, display a table
    of high scores, or construct an interactive interface.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章，你还将学习如何使用 Processing 的文本函数在显示窗口中渲染任何字符串为文本。Processing 可以使用不同的字体，以不同的大小和位置，绘制各种颜色和样式的文本。你可能会用这些功能来用字母作画、标注图表、显示高分表，或构建一个交互式界面。
- en: Strings
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: Before exploring Processing’s text-rendering functions, you’ll need a proper
    introduction to strings. By definition, a *string* contains a sequence of one
    or many characters. For example, ‘hello’ is a string that’s five characters long;
    it begins with an *h* and ends with an *o*. You already briefly encountered the
    string data type in Chapter 1, where you used it to define hexadecimal color values
    and print text messages to yourself in the console.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索 Processing 的文本渲染函数之前，你需要先了解字符串的基本知识。根据定义，*字符串*包含一个或多个字符的序列。例如，‘hello’ 是一个包含五个字符的字符串；它以
    *h* 开头，以 *o* 结尾。你已经在第一章中简要接触过字符串数据类型，在那里你用它来定义十六进制颜色值并在控制台打印文本信息。
- en: 'To create a new ‘hello’ string and assign it to a variable named `greeting`,
    use the following code:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的 'hello' 字符串并将其赋值给名为 `greeting` 的变量，可以使用以下代码：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Python recognizes `hello` as a string because it’s wrapped in quotes. You can
    use single or double quotes, but always make sure you close them using the same
    type with which you opened them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Python 识别 `hello` 为字符串，因为它被引号括起来。你可以使用单引号或双引号，但一定要确保使用与打开时相同类型的引号将其关闭。
- en: In Python, you can manipulate strings in various ways. To convert `hello` to
    `Hello!`,you would make the first character uppercase and insert an exclamation
    mark at the end of the string. Python has many built-in features for performing
    those types of operations, and I cover some of the most useful features in this
    section.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你可以用多种方式操作字符串。要将 `hello` 转换为 `Hello!`，你需要将第一个字符大写并在字符串末尾插入一个感叹号。Python
    提供了许多内置功能来执行这些操作，我将在这一节中介绍一些最有用的功能。
- en: You’ll look at how to combine strings, and how to find, count, and extract specific
    sequences of characters. Most of those features work exclusively with the string
    data type. For instance, you cannot convert an integer or a floating-point value
    to uppercase, because those things are numbers. And if you tack an ! character
    to the end of a number, it’s not a number anymore; it’s a string with digit characters
    and an exclamation mark. On the other hand, you can’t divide a string by a number.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何组合字符串，以及如何查找、计数和提取特定的字符序列。这些功能大多数仅适用于字符串数据类型。例如，你不能将整数或浮动值转换为大写字母，因为它们是数字。如果你在数字的末尾加上一个
    `!` 字符，它就不再是一个数字；它变成了一个包含数字字符和感叹号的字符串。另一方面，你不能用数字去除一个字符串。
- en: 'The following example uses the division operator to divide the integer `6`
    by `3`, which prints a `2` in the console. But attempting to divide `''hello''`
    by `3` results in an error:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用除法运算符将整数 `6` 除以 `3`，在控制台打印出 `2`。但尝试将 `'hello'` 除以 `3` 会导致错误：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Python cannot divide a string by an integer, so you get a `TypeError` message.
    However, certain mathematical operators do work on strings. For instance, `'hello'
    * 3` gives you `hellohellohello`. Later in this chapter, you’ll learn how to use
    the `+` operator to join strings.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Python 不能将字符串与整数相除，因此你会得到一个 `TypeError` 错误信息。然而，某些数学运算符可以作用于字符串。例如，`'hello'
    * 3` 会返回 `hellohellohello`。在本章稍后，你将学习如何使用 `+` 运算符连接字符串。
- en: Creating Strings in Python
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Python 中创建字符串
- en: Let’s begin by creating a few new string variables, looking at the way Python
    deals with different kinds of quotation marks, and working around some issues
    you might encounter when creating strings.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建一些新的字符串变量，了解 Python 如何处理不同类型的引号，并解决创建字符串时可能遇到的一些问题。
- en: 'Start a new sketch and save it as *strings*. Add the following code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个新的草图并将其保存为 *strings*。添加以下代码：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you run the sketch, the `print()` function writes `Hello, World!` to the
    console.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行草图时，`print()` 函数会将 `Hello, World!` 输出到控制台。
- en: 'Recall that Python expects a string to begin and end with quotation marks,
    so what happens when the string itself contains a quote character? Add another
    string variable to see what happens when you have unpaired quotes:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，Python 期望字符串以引号开始和结束，那么当字符串本身包含引号字符时会发生什么呢？添加另一个字符串变量，看看当你有未配对的引号时会发生什么：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Python interprets this string as `What`, ignoring everything after the apostrophe.
    Some dangling characters and an unpaired quote (`s up?'`) are left over. Run the
    sketch and observe the error message ([Figure 3-1](#figure3-1)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Python 会将这个字符串解释为 `What`，忽略撇号后面的所有内容。会留下些许悬空字符和一个未配对的引号（`s up?'`）。运行草图并观察错误信息（[图
    3-1](#figure3-1)）。
- en: '![f03001](image_fi/500969c03/f03001.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![f03001](image_fi/500969c03/f03001.png)'
- en: 'Figure 3-1: An error caused by an apostrophe'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-1：由撇号引起的错误
- en: 'To fix this, use double quotes:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个问题，请使用双引号：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or, you can *escape* the apostrophe character by using a backslash:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过使用反斜杠来 *转义* 撇号字符：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The backslash indicates that Python should treat the apostrophe as an ordinary
    character, not part of the language syntax. If you print the `whatsup` variable
    now, it displays this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠表示 Python 应该将撇号视为普通字符，而不是语言语法的一部分。如果你现在打印 `whatsup` 变量，它会显示以下内容：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that no backslash displays in the console output.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，控制台输出中不会显示反斜杠。
- en: The backslash is an escape character, so if you need to include a backslash
    in your string, you must prepend it with another backslash. For example, `print('\\')`
    displays a single backslash in the console.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠是转义字符，因此如果你需要在字符串中包含反斜杠，必须在前面加上另一个反斜杠。例如，`print('\\')` 会在控制台中显示一个单独的反斜杠。
- en: 'You’ve seen how to nest a single quote within a string delimited in double
    quotes. This works both ways, though. For example, add a new `question` variable
    that uses double quotes nested within single quotes:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到如何在用双引号限定的字符串中嵌套单引号。事实上，这种方法同样适用于反向操作。例如，添加一个新的 `question` 变量，使用单引号内嵌双引号：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Run the sketch to confirm that it has no errors. The console should display
    the contents of the three `print` statements.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图确认没有错误。控制台应显示三个 `print` 语句的内容。
- en: Using Concatenation and String Formatting
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用连接和字符串格式化
- en: 'The `+` operator performs arithmetic addition on integers and floats, but you
    also can use the `+` operator to concatenate multiple strings into a series or
    chain. *Concatenation* is programming terminology for *joining together*, and
    it’s useful for many tasks, such as chaining together words into sentences and
    paragraphs. Try this example in your sketch:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`+` 运算符执行整数和浮点数的算术加法，但你也可以使用 `+` 运算符将多个字符串连接成一个序列或链。*连接* 是编程术语，表示 *将多个元素结合在一起*，它对于许多任务非常有用，例如将单词连接成句子和段落。在你的草图中尝试这个示例：'
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This should display the following line in the console:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在控制台中显示以下行：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that concatenation joins strings together precisely as they are defined,
    with no additional spaces, so you need to insert the required space characters
    explicitly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，连接操作会精确地将字符串按其定义连接在一起，不会自动添加空格，因此你需要显式地插入所需的空格字符。
- en: 'To fix the preceding output, edit the `all` variable line:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复前面的输出，请编辑 `all` 变量所在的行：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The console should display the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应显示以下内容：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The line now includes the spaces specified in the code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这行代码包括了在代码中指定的空格。
- en: An alternative to concatenation is *string formatting*, and Python provides
    the `format()` method for this (I explain more about methods in “String Methods”
    on page 60). What you need to understand here is that `format()` works by substituting
    placeholder symbols with values, as opposed to chaining them together in a sequence.
    You’ll find that the concatenation operator is okay for simpler tasks, but it
    can be clumsy when you’re constructing lengthier and more intricate strings.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 连接的另一种替代方法是*字符串格式化*，而Python为此提供了`format()`方法（我将在第60页的“字符串方法”部分进一步解释方法）。你需要理解的是，`format()`通过替换占位符符号为值来工作，而不是将它们按顺序连接起来。你会发现，连接操作符适用于简单任务，但在构建较长且更复杂的字符串时，它可能会显得笨拙。
- en: 'Here’s the same line constructed using `format()`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`format()`构建的相同一行：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this approach, Python substitutes each pair of curly brackets (`{}`) with
    its corresponding variable—that is, `greeting` for the first pair of curly brackets,
    `whatsup` for the second, and `question` for the third. This saves you from needing
    to insert each space character by using `+ ' ' +`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，Python会将每一对大括号（`{}`）替换为对应的变量——也就是说，第一个大括号替换为`greeting`，第二个替换为`whatsup`，第三个替换为`question`。这样你就不需要通过`+
    ' ' +`来手动插入每个空格字符了。
- en: 'If the `format()` alternative doesn’t seem much simpler, consider this example
    that uses concatenation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`format()`的替代方法似乎并不简洁，可以考虑使用连接的这个示例：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you print `hi`, you get `Hi! I'm World. My atmosphere is 21% oxygen`. With
    concatenation, you have to place your space characters carefully, and it’s tricky
    to read what the `hi` line is doing. Moreover, you have to wrap the `o2` variable
    in the `str()` function to convert the value from a number to a string; if you
    don’t, Python will attempt (and fail) to add an integer and a string arithmetically.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打印`hi`，你会得到`Hi! I'm World. My atmosphere is 21% oxygen`。使用连接时，你必须仔细放置空格字符，而且很难看出`hi`这一行在做什么。此外，你还必须将`o2`变量包装在`str()`函数中，以将其从数字转换为字符串；如果不这样做，Python会尝试（并失败）将整数和字符串进行算术加法。
- en: 'Compare this to using the `format()` approach for the same line:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与使用`format()`方法构建的相同一行进行比较：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This provides a better idea of the result you’re going to get. The `format()`
    method also manages the conversion of numbers to strings. Use whichever approach
    works best for the task at hand.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这能更好地展示你将获得的结果。`format()`方法还可以处理数字到字符串的转换。你可以根据当前任务选择最适合的方法。
- en: Working with String Length
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理字符串长度
- en: The `len()` function returns the total number of characters in a string. You
    might use it to check whether a string contains more than 1 character or to verify
    that it fits into a tweet (280 characters). You can also use the `len()` function
    to find the total number of items in a list (Chapter 7) or dictionary (Chapter
    8).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`len()`函数返回字符串中的字符总数。你可以用它来检查字符串是否包含超过1个字符，或者验证字符串是否适合发布到推特（最多280个字符）。你还可以使用`len()`函数来查找列表（第7章）或字典（第8章）中的项目总数。'
- en: 'The `len()` function accepts a single argument; try this using your `greeting`
    variable:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`len()`函数接受一个参数；你可以使用`greeting`变量来试试看：'
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This should display 13, the total number of characters in the `greeting` string.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该显示13，即`greeting`字符串中的字符总数。
- en: So far, you’ve learned how to define new strings and construct strings from
    smaller strings, but you can do far more in Python. In the next section, you’ll
    learn how to manipulate strings by using slice notation and string methods.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学会了如何定义新字符串并通过小的字符串构建字符串，但在Python中你还能做更多的事情。在接下来的章节中，你将学习如何通过使用切片符号和字符串方法来操作字符串。
- en: String Manipulation
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串操作
- en: Let’s add code to your working sketch so you can try some string manipulation
    methods. You’ll extract partial strings by using slice notation, convert between
    uppercase and lowercase characters, and find and count the occurrences of specific
    character sequences. You can use these techniques to automate the processes involved
    in handling string data—for example, to scan data for keywords, dissect strings,
    or shorten them. Feel free to experiment with values and arguments on your own
    to see how things respond.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在你的工作草图中添加一些代码，这样你就可以尝试一些字符串操作方法。你将通过使用切片符号来提取部分字符串，转换大小写字符，并查找和计数特定字符序列的出现次数。你可以使用这些技术来自动化处理字符串数据的过程——例如，扫描数据中的关键词，分析字符串或缩短它们。你可以随意尝试不同的值和参数，看看它们的反应。
- en: Slice Notation
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切片符号
- en: Python *slice notation* provides a simple yet powerful means of extracting characters
    from strings. You can use slice notation to retrieve a single character or substring.
    A *substring* is any contiguous sequence of characters that form part of a longer
    string. For example, a string that’s a URL might begin with the substring `http://`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'To experiment with slice notation on a new string variable named `url`, add
    this variable to your *strings* sketch:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You’ll specify the position (*index*) of the character(s) you want to retrieve
    by using a pair of square brackets (`[]`). To keep things simple, let’s extract
    the first character in the `url` string. Note, however, that this indexing system
    is zero-based, meaning that the character indices start at 0, not 1\. See [Figure
    3-2](#figure3-2) as a reference for the character indices.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![f03002](image_fi/500969c03/f03002.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-2: The string indexing system begins at 0.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `0` (zero) to retrieve the first character:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The console should display an `h`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'The index for the second character is `1`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The console should display a `t`, the first `t` in `http`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a colon (`:`) to specify a range of characters. Use this to extract the
    *scheme* (`http`) along with the colon-slash-slash (`://`) in the URL string,
    which spans from index `0` up to index `7`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `:7` to the right of the `0` retrieves the characters up to, but not including,
    the first `w`. But because your range begins at index `0`, you can omit the `0`
    in front of the colon to produce the same result:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The colon precedes the index value (`7`), which means that Python must retrieve
    everything from the left/start of the string up to the seventh character.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'If you place the colon after the index, Python returns everything from the
    specified index to the end of the string. You can use this to retrieve everything
    to the right of the colon-slash-slash, which is the part of the URL you usually
    type into the browser address bar:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You now should see `www.nostarch.com` in your console. This is a combination
    of the URL’s *subdomain* (`www`), *domain* (`nostarch`), and *top-level* domain
    (`com`), separated by dot characters ([Figure 3-3](#figure3-3)).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![f03003](image_fi/500969c03/f03003.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-3: The parts of a URL'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'You can isolate each part of the URL with string-slicing operations. Assuming
    that the top-level domain (`com`) is always three characters, you can retrieve
    it by using an index of `-3` followed by a colon:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A negative value counts index positions starting from the end (right side) of
    a string, so `url[-3]` will retrieve just `c`. You can include a colon to retrieve
    the `c` and every character that follows it. No matter how long the URL, this
    code will always display the last three characters. Conversely, using `[:-3]`,
    with the colon to the left of `-3`, retrieves everything up to the third-to-last
    character (`http://www.nostarch.`).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract the domain (`nostarch`), retrieve the substring between index `11`
    and `-4`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will adapt to any domain. For instance, if you change the `url` value to
    `http://www.nostarchpress.com`, Python prints `nostarchpress`. But this works
    only if the scheme is *http* and the subdomain is *www*. You can use string methods
    that will adapt to schemes, subdomains, and top-level domains of any length.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将适应任何域名。例如，如果你将 `url` 值更改为 `http://www.nostarchpress.com`，Python 会打印出 `nostarchpress`。但这只有在方案是
    *http* 且子域是 *www* 的情况下有效。你可以使用字符串方法，这些方法将适应任何长度的方案、子域和顶级域名。
- en: This notation slices strings in a few other ways, but these should be sufficient
    for now. You can also use slice notation to extract items from lists and dictionaries,
    so you’ll encounter it again in the chapters that deal with those data types.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种符号切片字符串的方式有几种其他方法，但这些方法现在应该足够了。你还可以使用切片符号从列表和字典中提取项，因此你将在涉及这些数据类型的章节中再次遇到它。
- en: String Methods
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串方法
- en: '*String methods* perform various operations on strings, such as converting
    characters between uppercase and lowercase, and searching for and counting characters
    and substrings. You’ll use string methods in your sketch to verify that your URL
    contains a scheme, subdomain, domain, and top-level domain. This is not an exhaustive
    review of string methods, but it will familiarize you with how some of them operate.
    Any decent Python reference will cover the rest.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串方法*对字符串执行各种操作，如将字符在大写和小写之间转换，以及搜索和计数字符和子字符串。你将在草图中使用字符串方法来验证你的 URL 是否包含方案、子域、域名和顶级域名。这不是字符串方法的全面回顾，但它将让你熟悉它们的某些操作。任何一本合格的
    Python 参考书都会涵盖其余部分。'
- en: Methods vs. Functions
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法与函数
- en: A Python *method* looks and behaves much like a function. You call a function
    by its name—like `print()`—and it performs a predefined task for you. Methods
    work similarly, but they’re associated with specific objects, such as strings
    for string methods. A function may or may not accept arguments, depending on the
    function you’re using; the same is true for methods.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中的*方法*看起来和行为上都很像函数。你通过其名称调用函数——像 `print()`——它为你执行预定义的任务。方法也类似，但它们与特定的对象相关联，例如字符串方法是与字符串对象关联的。函数可能接受或不接受参数，具体取决于你使用的函数；方法也是如此。
- en: As an example, let’s contrast the `len()` *function* with a *method*. There’s
    no `len()` method, but we’ll pretend there is to focus on the syntactical differences
    between how you write a method versus a function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，让我们将 `len()` *函数*与*方法*进行对比。没有 `len()` 方法，但我们假设有一个，以便专注于方法和函数之间语法上的差异。
- en: 'Recall that the `len()` function returns the total number of characters in
    any string:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，`len()` 函数返回任何字符串中的字符总数：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `len()` function takes the `url` argument and returns the length of the
    string it holds. The total length of the `url` string is 23 characters, so the
    variable `urllength` is equal to the integer `23`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`len()` 函数接受 `url` 参数，并返回其包含的字符串的长度。`url` 字符串的总长度是 23 个字符，因此变量 `urllength`
    的值等于整数 `23`。'
- en: 'Methods begin with a dot (`.`) and are appended to data you want to affect.
    If the `len()` function were a method, you would write it like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 方法以点号（`.`）开头，并附加到你想要影响的数据上。如果 `len()` 函数是一个方法，你应该这样写：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Next, you’ll use the `upper()` method to convert string characters to uppercase.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使用 `upper()` 方法将字符串字符转换为大写。
- en: upper() and lower() Methods
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: upper() 和 lower() 方法
- en: 'The `upper()` method returns a version of the string with all the lowercase
    characters converted to uppercase. It takes no arguments. Here’s an example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`upper()` 方法返回一个字符串版本，其中所有小写字母都被转换为大写。它不接受任何参数。以下是一个例子：'
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `upper()` method is a string method, so you must append it to a string.
    The syntax might look similar to `format()`, which is the method you used to replace
    curly brackets with text values in strings earlier. In this instance, the variable
    `urlupper` is equal to `HTTP://WWW.NOSTARCH.COM`. This method might be useful
    to emphasize certain key phrases when you’re unable to use bold or italics. The
    `lower()` method is the inverse of `upper()`, and it converts all uppercase characters
    to lowercase.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`upper()` 方法是一个字符串方法，因此你必须将其附加到字符串上。语法可能与 `format()` 类似，后者是你之前用来将花括号替换为字符串中文本值的方法。在这个例子中，变量
    `urlupper` 的值是 `HTTP://WWW.NOSTARCH.COM`。当你无法使用粗体或斜体时，这个方法可能有助于突出某些关键短语。`lower()`
    方法是 `upper()` 的反向操作，它将所有大写字母转换为小写。'
- en: count() Method
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: count() 方法
- en: 'Now, let’s verify that the `url` string contains a *www* subdomain. The `count()`
    method returns the total number of times that a character, or character sequence,
    appears in a string, and it needs an argument to indicate which character(s) you
    want to count. For instance, you can use the `count()` method to verify that the
    URL contains three instances of the letter *w*:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们验证 `url` 字符串是否包含 *www* 子域名。`count()` 方法返回一个字符或字符序列在字符串中出现的总次数，并且它需要一个参数来指示你要计数的字符。例如，你可以使用
    `count()` 方法验证 URL 中是否包含三个 *w* 字符：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Your console should confirm that there are three *w* characters. But it doesn’t
    indicate whether they are contiguous; that letter might be scattered throughout
    the string. To be more explicit, use an argument of `''www''`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你的控制台应该确认有三个 *w* 字符。但它并没有指示这些字符是否是连续的；这些字母可能分散在字符串中。为了更明确，使用参数 `'www'`：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The substring `www` appears only once in this string. Still, you can’t be sure
    that this is the subdomain. What if the domain part of the URL has a *www* in
    it? You could be more specific and count the instances of `http://www`, but HTTP
    isn’t the only scheme for web addresses. For example, *HTTPS*, a secure extension
    of HTTP, is used to encrypt communication over computer networks. To make matters
    more complicated, a subdomain can be something other than *www*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 子字符串 `www` 在这个字符串中只出现一次。但你不能确定这就是子域名。如果 URL 的域名部分包含 *www* 呢？你可以更具体一些，统计 `http://www`
    出现的次数，但 HTTP 并不是唯一的 Web 地址方案。例如，*HTTPS*，HTTP 的安全扩展，用于加密计算机网络中的通信。更复杂的是，子域名可能不是
    *www*。
- en: find() Method
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`find()` 方法'
- en: 'Let’s try another approach. The `find()` method returns the index of any character
    or substring. Note how the colon-slash-slash (`://`) splits the scheme and subdomain.
    Use the `find()` method to retrieve the index of the colon-slash-slash. Add code
    to find the index, store it in a variable named `css`, and then use this to extract
    the scheme:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试另一种方法。`find()` 方法返回任何字符或子字符串的索引。注意冒号斜杠斜杠 (`://`) 如何分割方案和子域名。使用 `find()`
    方法来检索冒号斜杠斜杠的索引。添加代码来找到该索引，存储在一个名为 `css` 的变量中，然后用它来提取方案：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `find()` method retrieves the index for the first occurrence of any `://`
    in the `url` string. More specifically, it’s the index of the first character
    in the substring, the colon. If the substring cannot be found, the result is a
    `-1`. In this instance, it’s an index of `4`. Note that this argument is case-sensitive.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`find()` 方法检索 `url` 字符串中第一个出现的 `://` 的索引。更具体地说，这是子字符串中第一个字符，即冒号的索引。如果找不到该子字符串，结果将是
    `-1`。在这个实例中，索引为 `4`。请注意，这个参数区分大小写。'
- en: 'The subdomain sits between the colon-slash-slash and the first dot. Use the
    `find()` method to locate the index of the first dot, and use slice notation to
    extract and assign the subdomain to a variable named `subdomain`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 子域名位于冒号斜杠斜杠和第一个点之间。使用 `find()` 方法找到第一个点的索引，并使用切片符号提取并将子域名赋值给一个名为 `subdomain`
    的变量：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `css+3` is equal to `7`, the index of the first *w* in *www*. I’ve added
    the `3` to offset the starting index by the length of the colon-slash-slash. This
    will work for *www* or any other subdomain (although you will encounter issues
    if there’s no subdomain).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`css+3` 等于 `7`，即 *www* 中第一个 *w* 的索引。我加上了 `3` 来将起始索引偏移到冒号斜杠斜杠的长度。这对于 *www* 或任何其他子域名都有效（尽管如果没有子域名，你会遇到一些问题）。'
- en: 'The top-level domain (*com*) spans from the second dot to the end of the string.
    If a character or substring appears multiple times—like the dot—you can provide
    a second `find()` argument indicating the index where the search should begin.
    You can use the `dot1` variable for this offset, but you need to add `1` to start
    from the character immediately after it. Assign the top-level domain to a variable
    named `tld`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级域名 (*com*) 从第二个点开始一直到字符串的末尾。如果某个字符或子字符串出现多次—例如点—你可以提供第二个 `find()` 参数来指示搜索应该从哪个索引位置开始。你可以使用
    `dot1` 变量来表示这个偏移量，但你需要加上 `1` 来从它之后的字符开始。将顶级域名赋值给一个名为 `tld` 的变量：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `dot2` variable is equal to `19`, the index of the second dot in your URL.
    In the `tld` line, I’ve added `1` to the start index argument (of 19), because
    I don’t want the dot in *.com*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`dot2` 变量等于 `19`，即 URL 中第二个点的索引。在 `tld` 这一行中，我将 `19` 作为起始索引参数加上了 `1`，因为我不想包含
    *.com* 中的点。'
- en: The `find()` method can accept an additional third argument to indicate where
    along the string the search should terminate.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`find()` 方法可以接受一个额外的第三个参数，用于指示搜索应该在字符串的哪个位置终止。'
- en: 'Finally, assign the domain (*nostarch*) to a variable named `domain`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将域名（*nostarch*）赋值给一个名为`domain`的变量：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The domain substring sits between the first and second dot, but add `1` to `dot1`
    to avoid retrieving the first dot character.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 域名子串位于第一个和第二个点之间，但要加上`1`到`dot1`，以避免获取第一个点字符。
- en: You’ve now separated a URL into parts by using slice notation. Combining slice
    notation with string methods provides a more robust way of doing this, so your
    program can handle schemes, subdomains, and top-level domains of varying lengths.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经使用切片符号将URL分割成了各个部分。将切片符号与字符串方法结合使用，可以提供一种更强大的方式来完成此操作，这样你的程序就能处理不同长度的协议、子域和顶级域。
- en: In the next section, you’ll learn how to use Processing text functions to display
    strings as text in the display window, so you’re no longer constrained to printing
    strings in the console. You can use text decoratively, to label elements in your
    visual output, or provide feedback to users.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分中，你将学习如何使用Processing文本函数将字符串作为文本显示在显示窗口中，这样你就不再局限于在控制台中打印字符串。你可以使用文本作为装饰，标注视觉输出中的元素，或为用户提供反馈。
- en: Typography
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排版
- en: '*Typography* refers to the arranging and styling of text (or *type*) to make
    it more readable and aesthetically appealing. Typographical treatment can truly
    make or break a design. For instance, headings work best if they stand out from
    the rest of your text; letter spacing should be tighter than word spacing, and
    you probably agree that cursive fonts are not ideal for road signs. Although I
    wouldn’t recommend that you lay out a book in Processing, it does offer useful
    functions for controlling the appearance of text.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*排版*指的是文本（或*字体*）的排列和样式，以使其更易读且更具美感。排版处理可以真正决定设计的成败。例如，标题最好能与其他文本区分开；字母间距应比单词间距更紧凑，而且你可能同意，草书字体不适合用于路标。虽然我不建议你用Processing排版一本书，但它确实提供了有用的功能来控制文本的外观。'
- en: Fonts
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字体
- en: Fonts comprise many glyphs; a *glyph* is any individual character, such as *A*,
    *a*, or *?*. If you don’t specify which font Processing should use to draw text,
    it relies on a predefined default. Your computer includes a bundle of preinstalled
    fonts, but the selection varies among operating systems. You can also install
    additional fonts on your system to expand your selection. However, you might run
    into problems if you’re moving or sharing sketches between computers (with different
    collections of fonts). If a sketch requires a specific font, and it’s not installed,
    Processing cannot load it. To avoid these issues, I’ll explain how to bundle font
    files with your sketches.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 字体由许多字形组成；*字形*是任何单个字符，比如*A*、*a*或*?*。如果你没有指定Processing应该使用哪个字体来绘制文本，它会依赖预定义的默认字体。你的计算机包括一系列预安装的字体，但不同操作系统之间的选择可能不同。你还可以在系统中安装额外的字体来扩展选择。不过，如果你在不同计算机之间移动或共享草图（它们的字体库不同），你可能会遇到问题。如果一个草图需要特定字体，而该字体未安装，Processing就无法加载它。为避免这些问题，我将解释如何将字体文件与草图一起打包。
- en: Because early computer fonts were pixel-based, they required a separate set
    of glyphs for each font size. For example, if a font had three sizes and an italic
    variant, it included six complete sets of character graphics. However, modern
    fonts are vector-based, which is why you can scale text to any size you like without
    encountering pixelation. You no longer require a file for every font size, but
    bold and italic variants are still separate font files.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于早期的计算机字体是基于像素的，它们需要为每个字体大小提供一组独立的字形。例如，如果一种字体有三种大小和一种斜体变体，它包含六个完整的字符图形集。然而，现代字体是基于矢量的，这就是为什么你可以将文本缩放到任何大小而不会出现像素化的原因。你不再需要为每个字体大小准备一个文件，但粗体和斜体变体仍然是独立的字体文件。
- en: By default, Processing will render text in the display window by using a standard
    *sans serif* font. In font terminology, *serifs* are the small lines attached
    to the tips of characters (circled in [Figure 3-4](#figure3-4)). The term *sans*
    means *without*; hence, a sans serif font has no serifs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Processing会使用标准的*无衬线*字体在显示窗口中渲染文本。在字体术语中，*衬线*是附着在字符顶端的小线条（见[图3-4](#figure3-4)中的圆圈）。*无*的意思是“没有”；因此，无衬线字体没有衬线。
- en: '![f03004](image_fi/500969c03/f03004.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![f03004](image_fi/500969c03/f03004.png)'
- en: 'Figure 3-4: Classifying fonts'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-4：字体分类
- en: '*Monospace* fonts may also be serifed, but what distinguishes them is that
    each character occupies the same amount of horizontal space. *Proportionately
    spaced* fonts (like the serif and sans serif examples in [Figure 3-4](#figure3-4))
    make type more legible by using built-in metrics that specify how far a given
    character should sit from its neighbors. For example, having an *i* and *m* character
    occupy the same size “container” results in awkward spacing issues, which many
    monospaced fonts attempt to resolve by adding oversize serifs to the *i* and cramping
    the *m* ([Figure 3-5](#figure3-5)). This also means that monospace characters
    vertically align across multiple lines of text.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*等宽*字体也可以是衬线字体，但其特点是每个字符占用相同的水平空间。*比例间距*字体（如[图3-4](#figure3-4)中的衬线和无衬线示例）通过使用内建的度量标准来指定每个字符与其相邻字符之间的间距，从而使文本更易读。例如，当*i*和*m*字符占用相同大小的“容器”时，会出现不自然的间距问题，这也是许多等宽字体尝试通过给*i*加大衬线并压缩*m*来解决的问题（见[图3-5](#figure3-5)）。这也意味着等宽字符在多行文本中会垂直对齐。'
- en: '![f03005](image_fi/500969c03/f03005.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![f03005](image_fi/500969c03/f03005.png)'
- en: 'Figure 3-5: Monospace characters have a fixed width'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-5：等宽字符具有固定的宽度
- en: 'That said, monospace fonts are more legible in certain situations. For instance,
    a monospace font is useful when you need to have characters line up in columns:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，等宽字体在某些情况下更易读。例如，当你需要让字符在列中对齐时，等宽字体会很有用：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This characteristic makes monospace fonts preferable for writing code, which
    is why the default font for the Processing editor (and every other code editor)
    is monospaced.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特性使得等宽字体更适合编写代码，这也是为什么Processing编辑器（以及其他所有代码编辑器）的默认字体是等宽字体。
- en: Text Functions
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本函数
- en: Let’s create a new sketch to experiment with Processing text functions. You’ll
    use these functions to draw text in the display window and to set your font, font
    size, line spacing, and text alignment.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新草图来实验Processing的文本函数。你将使用这些函数在显示窗口中绘制文本，并设置你的字体、字体大小、行间距和文本对齐方式。
- en: 'Start a new sketch and save it as *typography*. Add the following code to get
    started:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个新草图，并将其保存为*typography*。添加以下代码开始：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This code sets the background to blue and the fill color to white. As you’ll
    soon see, the `fill()` color will affect the text you draw. Any strokes are pale
    blue and 3 pixels wide.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将背景设置为蓝色，填充颜色设置为白色。正如你很快会看到的，`fill()`颜色将影响你绘制的文本。任何描边都是淡蓝色的，宽度为3像素。
- en: 'A *pangram* is a sentence that uses every letter in a given alphabet at least
    once. Create a variable called `pangram` that holds a perfect English pangram:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*全字母句*是一个包含给定字母表中每个字母至少一次的句子。创建一个名为`pangram`的变量，存储一个完美的英语全字母句：'
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: From here on, you’ll render different versions of the string stored in `pangram`,
    as shown in [Figure 3-6](#figure3-6).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，你将渲染存储在`pangram`中的不同版本的字符串，如[图3-6](#figure3-6)所示。
- en: 'To recreate [Figure 3-6](#figure3-6), begin with the `text()` function, which
    draws text to the display window, the font color of which is determined by the
    active fill:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要重现[图3-6](#figure3-6)，从`text()`函数开始，`text()`函数将文本绘制到显示窗口中，其字体颜色由当前的填充颜色决定：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![f03006](image_fi/500969c03/f03006.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![f03006](image_fi/500969c03/f03006.png)'
- en: 'Figure 3-6: You will render these versions of the same pangram.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-6：你将渲染这些版本的相同全字母句。
- en: Run the sketch. You should see the first (top) version of the pangram rendered
    in the display window. The arguments `(pangram, 0, 50)` represent the string value,
    x-coordinate, and y-coordinate, respectively. You can add additional third and
    fourth arguments to specify a width and height for the text area, which you’ll
    use shortly.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图。你应该能在显示窗口中看到全字母句的第一个（顶部）版本。参数`(pangram, 0, 50)`分别代表字符串值、x坐标和y坐标。你可以添加额外的第三个和第四个参数来指定文本区域的宽度和高度，这些将在稍后使用。
- en: 'The `textSize()` function sets the font size (in pixels) for all subsequent
    `text()` functions. Add the following code to display the second version of the
    pangram:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`textSize()`函数设置所有后续`text()`函数的字体大小（以像素为单位）。添加以下代码以显示全字母句的第二个版本：'
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Run the sketch to confirm that you have a smaller and larger version of the
    pangram.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图以确认你有较小和较大的两种版本的全字母句。
- en: 'Observe that the vertical, pale blue line ([Figure 3-6](#figure3-6)) precisely
    marks the end of the longest/larger line of text. The purpose of adding this line
    is to explore the `textWidth()` function, which you use to calculate the width
    of any text you might display. In this instance, you want to measure the width
    of the second pangram and draw a vertical line at the end of it. Use `textWidth()`
    functions as arguments for a line function:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The width of the pangram now serves as the starting as well as ending x-coordinate
    for the line; the starting and ending y-coordinates are the top and bottom edges
    of the display window, respectively. This will draw a pale blue vertical rule,
    the height of the display window, that marks the end of the second pangram.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll render the third pangram in a serif font. To switch to a different font,
    you need to know the font name to reference. To list the fonts installed on your
    computer, use `PFont.list()`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Scroll through the console output to see if you can spot `Cambria` or `Georgia`.
    Both are serif fonts. If neither Cambria nor Georgia is installed on your system,
    you won’t find them in the list. In that case, any other serif font will work,
    such as Times New Roman.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Processing uses its own font format, so you need to convert your font before
    you can use it, using the `createFont()` function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `createFont()` line that includes a string argument with the name of
    the serif font you will use:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `createFont()` function takes two arguments: a font name (as it appears
    in the console listing) and point size. The preceding line assigns the converted
    font to a variable named `seriffont`, which you’ll use in the next step.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate the new font, use `textFont()`. Then, draw the pangram once more
    (the third version) to confirm that it’s working:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `textFont()` function accepts a single argument, a Processing-readied font.
    All subsequent `text()` functions will use the `seriffont` until Processing encounters
    another `textFont()` function.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: The `textLeading()` function controls the leading of your text. *Leading* (which
    rhymes with *wedding*) is the typographic term to describe the spacing between
    each line of text.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The `textAlign()` function controls text alignment; you can use an argument
    of `LEFT`, `CENTER`, or `RIGHT` to set the horizontal alignment of your text.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll use the `textLeading()` and `textAlign()` functions to render the bottom
    two (fourth and fifth) versions of the pangram in [Figure 3-6](#figure3-6). Add
    a left- and right-aligned pangram:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first pangram is left-aligned because that’s the Processing default. I’ve
    added width and height arguments to the `text()` functions to invoke word wrapping.
    Each pangram is constrained to its own rectangular area that’s 250 pixels wide
    by 100 pixels high. If a line of text exceeds the width of 250 pixels, Processing
    automatically pushes the words that don’t fit onto a new line. If any lines even
    partially exceed the height of the text area (100 pixels), you do not see them,
    although this doesn’t happen here. The leading is reduced to 10 pixels 1, causing
    the lines to overlap. Ordinarily, the leading value is proportionate to the font
    size.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个全字句是左对齐的，因为这是Processing的默认设置。我为`text()`函数添加了宽度和高度参数，以启用自动换行。每个全字句都被限制在自己的矩形区域内，宽度为250像素，高度为100像素。如果一行文字超出了250像素的宽度，Processing会自动将无法适应的单词推到新的一行。如果有任何行部分超过了文本区域的高度（100像素），它们是不可见的，尽管在这里没有发生这种情况。行间距（leading）被减小到10像素1，导致行与行之间重叠。通常情况下，行间距的值与字体大小成比例。
- en: Just like fill, stroke, and many other Processing attributes, the text parameters
    you set remain in effect until you specify otherwise. But if you adjust the text
    size—using another `textSize()` function—the leading will reset to a proportional
    value.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`fill`、`stroke`和许多其他Processing属性一样，你设置的文本参数会一直有效，直到你明确指定其它值。但如果你调整文本大小——通过另一个`textSize()`函数——行间距将重置为一个成比例的值。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This brief introduction explored manipulating strings by using Python’s slice
    notation and string methods, and drawing text in the display window with Processing’s
    `text()` function. Processing’s typography functions allow you to control font
    size, horizontal alignment, line spacing/leading, and font selection. You’ll be
    using string methods and text functions in many of the tasks to come.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这段简短的介绍探讨了通过使用Python的切片符号和字符串方法来操作字符串，并使用Processing的`text()`函数在显示窗口中绘制文本。Processing的排版功能让你能够控制字体大小、水平对齐、行间距/行距以及字体选择。在接下来的许多任务中，你将使用字符串方法和文本函数。
- en: In Chapter 4, you’ll explore topics including control flow and conditional statements—techniques
    that allow you to write programs that can skip, jump to, and repeat lines of code.
    These tools are helpful because they let you change the order of your code’s execution,
    and whether it executes at all, based on specific rules and values.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四章中，你将探索包括控制流和条件语句在内的主题——这些技术允许你编写可以跳过、跳转或重复执行代码行的程序。这些工具很有用，因为它们让你能够根据特定的规则和值改变代码执行的顺序，甚至决定是否执行代码。
