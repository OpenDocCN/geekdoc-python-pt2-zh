- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Strings and Working with Text
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In Chapter 1, you created a ‘Hello, World!’ string and printed it to the console,
    but Python can do far more than just print string data. In this chapter, you’ll
    use operators, functions, and methods to manipulate strings. Strings are fundamental
    data types common to most programming languages, and you’ll use them in almost
    all the programs you write. If you need to communicate information to your user,
    capture input from text fields, retrieve data from the web, or perform just about
    any task that involves text, you’ll be using strings.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll also learn how to use Processing’s text functions to
    render any string as text in the display window. Processing can draw text in various
    colors and styles, using different fonts, at different sizes and positions. You
    might use these features to paint with letters, label a graph, display a table
    of high scores, or construct an interactive interface.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before exploring Processing’s text-rendering functions, you’ll need a proper
    introduction to strings. By definition, a *string* contains a sequence of one
    or many characters. For example, ‘hello’ is a string that’s five characters long;
    it begins with an *h* and ends with an *o*. You already briefly encountered the
    string data type in Chapter 1, where you used it to define hexadecimal color values
    and print text messages to yourself in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new ‘hello’ string and assign it to a variable named `greeting`,
    use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Python recognizes `hello` as a string because it’s wrapped in quotes. You can
    use single or double quotes, but always make sure you close them using the same
    type with which you opened them.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, you can manipulate strings in various ways. To convert `hello` to
    `Hello!`,you would make the first character uppercase and insert an exclamation
    mark at the end of the string. Python has many built-in features for performing
    those types of operations, and I cover some of the most useful features in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll look at how to combine strings, and how to find, count, and extract specific
    sequences of characters. Most of those features work exclusively with the string
    data type. For instance, you cannot convert an integer or a floating-point value
    to uppercase, because those things are numbers. And if you tack an ! character
    to the end of a number, it’s not a number anymore; it’s a string with digit characters
    and an exclamation mark. On the other hand, you can’t divide a string by a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses the division operator to divide the integer `6`
    by `3`, which prints a `2` in the console. But attempting to divide `''hello''`
    by `3` results in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Python cannot divide a string by an integer, so you get a `TypeError` message.
    However, certain mathematical operators do work on strings. For instance, `'hello'
    * 3` gives you `hellohellohello`. Later in this chapter, you’ll learn how to use
    the `+` operator to join strings.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Strings in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s begin by creating a few new string variables, looking at the way Python
    deals with different kinds of quotation marks, and working around some issues
    you might encounter when creating strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new sketch and save it as *strings*. Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When you run the sketch, the `print()` function writes `Hello, World!` to the
    console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that Python expects a string to begin and end with quotation marks,
    so what happens when the string itself contains a quote character? Add another
    string variable to see what happens when you have unpaired quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Python interprets this string as `What`, ignoring everything after the apostrophe.
    Some dangling characters and an unpaired quote (`s up?'`) are left over. Run the
    sketch and observe the error message ([Figure 3-1](#figure3-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03001](image_fi/500969c03/f03001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-1: An error caused by an apostrophe'
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, use double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can *escape* the apostrophe character by using a backslash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The backslash indicates that Python should treat the apostrophe as an ordinary
    character, not part of the language syntax. If you print the `whatsup` variable
    now, it displays this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that no backslash displays in the console output.
  prefs: []
  type: TYPE_NORMAL
- en: The backslash is an escape character, so if you need to include a backslash
    in your string, you must prepend it with another backslash. For example, `print('\\')`
    displays a single backslash in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve seen how to nest a single quote within a string delimited in double
    quotes. This works both ways, though. For example, add a new `question` variable
    that uses double quotes nested within single quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Run the sketch to confirm that it has no errors. The console should display
    the contents of the three `print` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Using Concatenation and String Formatting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `+` operator performs arithmetic addition on integers and floats, but you
    also can use the `+` operator to concatenate multiple strings into a series or
    chain. *Concatenation* is programming terminology for *joining together*, and
    it’s useful for many tasks, such as chaining together words into sentences and
    paragraphs. Try this example in your sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This should display the following line in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that concatenation joins strings together precisely as they are defined,
    with no additional spaces, so you need to insert the required space characters
    explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix the preceding output, edit the `all` variable line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The console should display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The line now includes the spaces specified in the code.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to concatenation is *string formatting*, and Python provides
    the `format()` method for this (I explain more about methods in “String Methods”
    on page 60). What you need to understand here is that `format()` works by substituting
    placeholder symbols with values, as opposed to chaining them together in a sequence.
    You’ll find that the concatenation operator is okay for simpler tasks, but it
    can be clumsy when you’re constructing lengthier and more intricate strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the same line constructed using `format()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this approach, Python substitutes each pair of curly brackets (`{}`) with
    its corresponding variable—that is, `greeting` for the first pair of curly brackets,
    `whatsup` for the second, and `question` for the third. This saves you from needing
    to insert each space character by using `+ ' ' +`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `format()` alternative doesn’t seem much simpler, consider this example
    that uses concatenation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you print `hi`, you get `Hi! I'm World. My atmosphere is 21% oxygen`. With
    concatenation, you have to place your space characters carefully, and it’s tricky
    to read what the `hi` line is doing. Moreover, you have to wrap the `o2` variable
    in the `str()` function to convert the value from a number to a string; if you
    don’t, Python will attempt (and fail) to add an integer and a string arithmetically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare this to using the `format()` approach for the same line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This provides a better idea of the result you’re going to get. The `format()`
    method also manages the conversion of numbers to strings. Use whichever approach
    works best for the task at hand.
  prefs: []
  type: TYPE_NORMAL
- en: Working with String Length
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `len()` function returns the total number of characters in a string. You
    might use it to check whether a string contains more than 1 character or to verify
    that it fits into a tweet (280 characters). You can also use the `len()` function
    to find the total number of items in a list (Chapter 7) or dictionary (Chapter
    8).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `len()` function accepts a single argument; try this using your `greeting`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This should display 13, the total number of characters in the `greeting` string.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you’ve learned how to define new strings and construct strings from
    smaller strings, but you can do far more in Python. In the next section, you’ll
    learn how to manipulate strings by using slice notation and string methods.
  prefs: []
  type: TYPE_NORMAL
- en: String Manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s add code to your working sketch so you can try some string manipulation
    methods. You’ll extract partial strings by using slice notation, convert between
    uppercase and lowercase characters, and find and count the occurrences of specific
    character sequences. You can use these techniques to automate the processes involved
    in handling string data—for example, to scan data for keywords, dissect strings,
    or shorten them. Feel free to experiment with values and arguments on your own
    to see how things respond.
  prefs: []
  type: TYPE_NORMAL
- en: Slice Notation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python *slice notation* provides a simple yet powerful means of extracting characters
    from strings. You can use slice notation to retrieve a single character or substring.
    A *substring* is any contiguous sequence of characters that form part of a longer
    string. For example, a string that’s a URL might begin with the substring `http://`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To experiment with slice notation on a new string variable named `url`, add
    this variable to your *strings* sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You’ll specify the position (*index*) of the character(s) you want to retrieve
    by using a pair of square brackets (`[]`). To keep things simple, let’s extract
    the first character in the `url` string. Note, however, that this indexing system
    is zero-based, meaning that the character indices start at 0, not 1\. See [Figure
    3-2](#figure3-2) as a reference for the character indices.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03002](image_fi/500969c03/f03002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-2: The string indexing system begins at 0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `0` (zero) to retrieve the first character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The console should display an `h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The index for the second character is `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The console should display a `t`, the first `t` in `http`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use a colon (`:`) to specify a range of characters. Use this to extract the
    *scheme* (`http`) along with the colon-slash-slash (`://`) in the URL string,
    which spans from index `0` up to index `7`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `:7` to the right of the `0` retrieves the characters up to, but not including,
    the first `w`. But because your range begins at index `0`, you can omit the `0`
    in front of the colon to produce the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The colon precedes the index value (`7`), which means that Python must retrieve
    everything from the left/start of the string up to the seventh character.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you place the colon after the index, Python returns everything from the
    specified index to the end of the string. You can use this to retrieve everything
    to the right of the colon-slash-slash, which is the part of the URL you usually
    type into the browser address bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You now should see `www.nostarch.com` in your console. This is a combination
    of the URL’s *subdomain* (`www`), *domain* (`nostarch`), and *top-level* domain
    (`com`), separated by dot characters ([Figure 3-3](#figure3-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f03003](image_fi/500969c03/f03003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-3: The parts of a URL'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can isolate each part of the URL with string-slicing operations. Assuming
    that the top-level domain (`com`) is always three characters, you can retrieve
    it by using an index of `-3` followed by a colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: A negative value counts index positions starting from the end (right side) of
    a string, so `url[-3]` will retrieve just `c`. You can include a colon to retrieve
    the `c` and every character that follows it. No matter how long the URL, this
    code will always display the last three characters. Conversely, using `[:-3]`,
    with the colon to the left of `-3`, retrieves everything up to the third-to-last
    character (`http://www.nostarch.`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract the domain (`nostarch`), retrieve the substring between index `11`
    and `-4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This will adapt to any domain. For instance, if you change the `url` value to
    `http://www.nostarchpress.com`, Python prints `nostarchpress`. But this works
    only if the scheme is *http* and the subdomain is *www*. You can use string methods
    that will adapt to schemes, subdomains, and top-level domains of any length.
  prefs: []
  type: TYPE_NORMAL
- en: This notation slices strings in a few other ways, but these should be sufficient
    for now. You can also use slice notation to extract items from lists and dictionaries,
    so you’ll encounter it again in the chapters that deal with those data types.
  prefs: []
  type: TYPE_NORMAL
- en: String Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*String methods* perform various operations on strings, such as converting
    characters between uppercase and lowercase, and searching for and counting characters
    and substrings. You’ll use string methods in your sketch to verify that your URL
    contains a scheme, subdomain, domain, and top-level domain. This is not an exhaustive
    review of string methods, but it will familiarize you with how some of them operate.
    Any decent Python reference will cover the rest.'
  prefs: []
  type: TYPE_NORMAL
- en: Methods vs. Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A Python *method* looks and behaves much like a function. You call a function
    by its name—like `print()`—and it performs a predefined task for you. Methods
    work similarly, but they’re associated with specific objects, such as strings
    for string methods. A function may or may not accept arguments, depending on the
    function you’re using; the same is true for methods.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let’s contrast the `len()` *function* with a *method*. There’s
    no `len()` method, but we’ll pretend there is to focus on the syntactical differences
    between how you write a method versus a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that the `len()` function returns the total number of characters in
    any string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `len()` function takes the `url` argument and returns the length of the
    string it holds. The total length of the `url` string is 23 characters, so the
    variable `urllength` is equal to the integer `23`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods begin with a dot (`.`) and are appended to data you want to affect.
    If the `len()` function were a method, you would write it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Next, you’ll use the `upper()` method to convert string characters to uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: upper() and lower() Methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `upper()` method returns a version of the string with all the lowercase
    characters converted to uppercase. It takes no arguments. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `upper()` method is a string method, so you must append it to a string.
    The syntax might look similar to `format()`, which is the method you used to replace
    curly brackets with text values in strings earlier. In this instance, the variable
    `urlupper` is equal to `HTTP://WWW.NOSTARCH.COM`. This method might be useful
    to emphasize certain key phrases when you’re unable to use bold or italics. The
    `lower()` method is the inverse of `upper()`, and it converts all uppercase characters
    to lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: count() Method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, let’s verify that the `url` string contains a *www* subdomain. The `count()`
    method returns the total number of times that a character, or character sequence,
    appears in a string, and it needs an argument to indicate which character(s) you
    want to count. For instance, you can use the `count()` method to verify that the
    URL contains three instances of the letter *w*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Your console should confirm that there are three *w* characters. But it doesn’t
    indicate whether they are contiguous; that letter might be scattered throughout
    the string. To be more explicit, use an argument of `''www''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The substring `www` appears only once in this string. Still, you can’t be sure
    that this is the subdomain. What if the domain part of the URL has a *www* in
    it? You could be more specific and count the instances of `http://www`, but HTTP
    isn’t the only scheme for web addresses. For example, *HTTPS*, a secure extension
    of HTTP, is used to encrypt communication over computer networks. To make matters
    more complicated, a subdomain can be something other than *www*.
  prefs: []
  type: TYPE_NORMAL
- en: find() Method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s try another approach. The `find()` method returns the index of any character
    or substring. Note how the colon-slash-slash (`://`) splits the scheme and subdomain.
    Use the `find()` method to retrieve the index of the colon-slash-slash. Add code
    to find the index, store it in a variable named `css`, and then use this to extract
    the scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `find()` method retrieves the index for the first occurrence of any `://`
    in the `url` string. More specifically, it’s the index of the first character
    in the substring, the colon. If the substring cannot be found, the result is a
    `-1`. In this instance, it’s an index of `4`. Note that this argument is case-sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The subdomain sits between the colon-slash-slash and the first dot. Use the
    `find()` method to locate the index of the first dot, and use slice notation to
    extract and assign the subdomain to a variable named `subdomain`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `css+3` is equal to `7`, the index of the first *w* in *www*. I’ve added
    the `3` to offset the starting index by the length of the colon-slash-slash. This
    will work for *www* or any other subdomain (although you will encounter issues
    if there’s no subdomain).
  prefs: []
  type: TYPE_NORMAL
- en: 'The top-level domain (*com*) spans from the second dot to the end of the string.
    If a character or substring appears multiple times—like the dot—you can provide
    a second `find()` argument indicating the index where the search should begin.
    You can use the `dot1` variable for this offset, but you need to add `1` to start
    from the character immediately after it. Assign the top-level domain to a variable
    named `tld`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `dot2` variable is equal to `19`, the index of the second dot in your URL.
    In the `tld` line, I’ve added `1` to the start index argument (of 19), because
    I don’t want the dot in *.com*.
  prefs: []
  type: TYPE_NORMAL
- en: The `find()` method can accept an additional third argument to indicate where
    along the string the search should terminate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, assign the domain (*nostarch*) to a variable named `domain`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The domain substring sits between the first and second dot, but add `1` to `dot1`
    to avoid retrieving the first dot character.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now separated a URL into parts by using slice notation. Combining slice
    notation with string methods provides a more robust way of doing this, so your
    program can handle schemes, subdomains, and top-level domains of varying lengths.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you’ll learn how to use Processing text functions to display
    strings as text in the display window, so you’re no longer constrained to printing
    strings in the console. You can use text decoratively, to label elements in your
    visual output, or provide feedback to users.
  prefs: []
  type: TYPE_NORMAL
- en: Typography
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Typography* refers to the arranging and styling of text (or *type*) to make
    it more readable and aesthetically appealing. Typographical treatment can truly
    make or break a design. For instance, headings work best if they stand out from
    the rest of your text; letter spacing should be tighter than word spacing, and
    you probably agree that cursive fonts are not ideal for road signs. Although I
    wouldn’t recommend that you lay out a book in Processing, it does offer useful
    functions for controlling the appearance of text.'
  prefs: []
  type: TYPE_NORMAL
- en: Fonts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fonts comprise many glyphs; a *glyph* is any individual character, such as *A*,
    *a*, or *?*. If you don’t specify which font Processing should use to draw text,
    it relies on a predefined default. Your computer includes a bundle of preinstalled
    fonts, but the selection varies among operating systems. You can also install
    additional fonts on your system to expand your selection. However, you might run
    into problems if you’re moving or sharing sketches between computers (with different
    collections of fonts). If a sketch requires a specific font, and it’s not installed,
    Processing cannot load it. To avoid these issues, I’ll explain how to bundle font
    files with your sketches.
  prefs: []
  type: TYPE_NORMAL
- en: Because early computer fonts were pixel-based, they required a separate set
    of glyphs for each font size. For example, if a font had three sizes and an italic
    variant, it included six complete sets of character graphics. However, modern
    fonts are vector-based, which is why you can scale text to any size you like without
    encountering pixelation. You no longer require a file for every font size, but
    bold and italic variants are still separate font files.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Processing will render text in the display window by using a standard
    *sans serif* font. In font terminology, *serifs* are the small lines attached
    to the tips of characters (circled in [Figure 3-4](#figure3-4)). The term *sans*
    means *without*; hence, a sans serif font has no serifs.
  prefs: []
  type: TYPE_NORMAL
- en: '![f03004](image_fi/500969c03/f03004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-4: Classifying fonts'
  prefs: []
  type: TYPE_NORMAL
- en: '*Monospace* fonts may also be serifed, but what distinguishes them is that
    each character occupies the same amount of horizontal space. *Proportionately
    spaced* fonts (like the serif and sans serif examples in [Figure 3-4](#figure3-4))
    make type more legible by using built-in metrics that specify how far a given
    character should sit from its neighbors. For example, having an *i* and *m* character
    occupy the same size “container” results in awkward spacing issues, which many
    monospaced fonts attempt to resolve by adding oversize serifs to the *i* and cramping
    the *m* ([Figure 3-5](#figure3-5)). This also means that monospace characters
    vertically align across multiple lines of text.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f03005](image_fi/500969c03/f03005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-5: Monospace characters have a fixed width'
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, monospace fonts are more legible in certain situations. For instance,
    a monospace font is useful when you need to have characters line up in columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This characteristic makes monospace fonts preferable for writing code, which
    is why the default font for the Processing editor (and every other code editor)
    is monospaced.
  prefs: []
  type: TYPE_NORMAL
- en: Text Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s create a new sketch to experiment with Processing text functions. You’ll
    use these functions to draw text in the display window and to set your font, font
    size, line spacing, and text alignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new sketch and save it as *typography*. Add the following code to get
    started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This code sets the background to blue and the fill color to white. As you’ll
    soon see, the `fill()` color will affect the text you draw. Any strokes are pale
    blue and 3 pixels wide.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *pangram* is a sentence that uses every letter in a given alphabet at least
    once. Create a variable called `pangram` that holds a perfect English pangram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: From here on, you’ll render different versions of the string stored in `pangram`,
    as shown in [Figure 3-6](#figure3-6).
  prefs: []
  type: TYPE_NORMAL
- en: 'To recreate [Figure 3-6](#figure3-6), begin with the `text()` function, which
    draws text to the display window, the font color of which is determined by the
    active fill:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '![f03006](image_fi/500969c03/f03006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-6: You will render these versions of the same pangram.'
  prefs: []
  type: TYPE_NORMAL
- en: Run the sketch. You should see the first (top) version of the pangram rendered
    in the display window. The arguments `(pangram, 0, 50)` represent the string value,
    x-coordinate, and y-coordinate, respectively. You can add additional third and
    fourth arguments to specify a width and height for the text area, which you’ll
    use shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `textSize()` function sets the font size (in pixels) for all subsequent
    `text()` functions. Add the following code to display the second version of the
    pangram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Run the sketch to confirm that you have a smaller and larger version of the
    pangram.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe that the vertical, pale blue line ([Figure 3-6](#figure3-6)) precisely
    marks the end of the longest/larger line of text. The purpose of adding this line
    is to explore the `textWidth()` function, which you use to calculate the width
    of any text you might display. In this instance, you want to measure the width
    of the second pangram and draw a vertical line at the end of it. Use `textWidth()`
    functions as arguments for a line function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The width of the pangram now serves as the starting as well as ending x-coordinate
    for the line; the starting and ending y-coordinates are the top and bottom edges
    of the display window, respectively. This will draw a pale blue vertical rule,
    the height of the display window, that marks the end of the second pangram.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll render the third pangram in a serif font. To switch to a different font,
    you need to know the font name to reference. To list the fonts installed on your
    computer, use `PFont.list()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Scroll through the console output to see if you can spot `Cambria` or `Georgia`.
    Both are serif fonts. If neither Cambria nor Georgia is installed on your system,
    you won’t find them in the list. In that case, any other serif font will work,
    such as Times New Roman.
  prefs: []
  type: TYPE_NORMAL
- en: Processing uses its own font format, so you need to convert your font before
    you can use it, using the `createFont()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `createFont()` line that includes a string argument with the name of
    the serif font you will use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `createFont()` function takes two arguments: a font name (as it appears
    in the console listing) and point size. The preceding line assigns the converted
    font to a variable named `seriffont`, which you’ll use in the next step.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate the new font, use `textFont()`. Then, draw the pangram once more
    (the third version) to confirm that it’s working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `textFont()` function accepts a single argument, a Processing-readied font.
    All subsequent `text()` functions will use the `seriffont` until Processing encounters
    another `textFont()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `textLeading()` function controls the leading of your text. *Leading* (which
    rhymes with *wedding*) is the typographic term to describe the spacing between
    each line of text.
  prefs: []
  type: TYPE_NORMAL
- en: The `textAlign()` function controls text alignment; you can use an argument
    of `LEFT`, `CENTER`, or `RIGHT` to set the horizontal alignment of your text.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll use the `textLeading()` and `textAlign()` functions to render the bottom
    two (fourth and fifth) versions of the pangram in [Figure 3-6](#figure3-6). Add
    a left- and right-aligned pangram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The first pangram is left-aligned because that’s the Processing default. I’ve
    added width and height arguments to the `text()` functions to invoke word wrapping.
    Each pangram is constrained to its own rectangular area that’s 250 pixels wide
    by 100 pixels high. If a line of text exceeds the width of 250 pixels, Processing
    automatically pushes the words that don’t fit onto a new line. If any lines even
    partially exceed the height of the text area (100 pixels), you do not see them,
    although this doesn’t happen here. The leading is reduced to 10 pixels 1, causing
    the lines to overlap. Ordinarily, the leading value is proportionate to the font
    size.
  prefs: []
  type: TYPE_NORMAL
- en: Just like fill, stroke, and many other Processing attributes, the text parameters
    you set remain in effect until you specify otherwise. But if you adjust the text
    size—using another `textSize()` function—the leading will reset to a proportional
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This brief introduction explored manipulating strings by using Python’s slice
    notation and string methods, and drawing text in the display window with Processing’s
    `text()` function. Processing’s typography functions allow you to control font
    size, horizontal alignment, line spacing/leading, and font selection. You’ll be
    using string methods and text functions in many of the tasks to come.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 4, you’ll explore topics including control flow and conditional statements—techniques
    that allow you to write programs that can skip, jump to, and repeat lines of code.
    These tools are helpful because they let you change the order of your code’s execution,
    and whether it executes at all, based on specific rules and values.
  prefs: []
  type: TYPE_NORMAL
