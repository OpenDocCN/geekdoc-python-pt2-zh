# 5

二叉搜索树

![](img/chapterart.png)

*二叉搜索树*利用支撑二叉搜索算法的概念来创建一个动态数据结构。这里的关键字是*动态*。与排序数组不同，二叉搜索树不仅支持高效的搜索，还支持元素的添加和删除，这使它们成为二叉搜索算法效率和动态数据结构适应性的完美结合。它们还可以成为任何房间的漂亮装饰摆件。

本章除了介绍二叉搜索树，还讨论了用于搜索值、添加新值和删除值的算法。它展示了如何使用指针创建比前几章基于列表的结构更强大的分支结构。你将学习到，通过仔细构建值之间的关系，我们可以将二叉搜索法的思路编码到数据的结构本身中。

## 二叉搜索树结构

树是由节点的分支链组成的层次结构数据结构。它们是链表的自然扩展，每个树节点允许有两个指向不同链表中后续节点的`next`指针。图 5-1 展示了一个示例的二叉搜索树。

![一个二叉搜索树，图中有一个圆圈表示一个节点（一个值），指向另外两个节点。每个节点又指向其他节点（其他值）。](img/f05001.png)

图 5-1：一个示例的二叉搜索树

一个节点包含一个值（某种类型）和最多两个指向树中下级节点的指针，如图 5-2 所示。我们将至少有一个子节点的节点称为*内部节点*，没有任何子节点的节点称为*叶节点*。

![二叉搜索树节点的组件：一个表示值的圆圈，一个指向左子节点的指针，一个指向右子节点的指针](img/f05002.png)

图 5-2：二叉搜索树节点的必需组件

树节点可能包含其他信息，这取决于它们的用途。例如，我们通常会存储一个指向节点父节点的指针。这个额外的单一信息使我们能够从底部向上遍历树，也可以从顶部向下遍历，这在考虑删除节点时非常有用。

从形式上讲，我们将*二叉搜索树节点*定义为具有以下最小信息的数据结构：一个值（或键）、指向两个子节点的指针（如果没有对应的子节点，可以将其设置为`null`），以及一个指向父节点的可选指针。

```py
TreeNode {
    Type: value
    TreeNode: left
    TreeNode: right
    TreeNode: parent
}
```

我们也可能需要存储辅助数据。存储和查找单个值是有用的，但将这些值作为查找更详细信息的键，极大地扩展了数据结构的能力。例如，我们可以使用我们最喜欢的咖啡名称作为节点的值，从而高效地查找任何咖啡的记录。在这种情况下，我们的辅助数据将是关于该咖啡的所有详细记录。或者，我们的值可以是时间戳，节点可以包含我们在那个时间煮的咖啡的信息，从而使我们能够高效地搜索我们过去的咖啡消费记录。树节点数据结构可以直接存储这些辅助数据，或者包含指向位于内存其他地方的复合数据结构的指针。

二叉搜索树从树顶的一个*根*节点开始，随着树的下降，分支成多个路径，如图 5-3 所示。这种结构允许程序通过一个指针访问二叉搜索树——即其根节点的位置。

![图 5-1 中的二叉搜索树，其中最顶端的节点标记为“根节点”。](img/f05003.png)

图 5-3：根节点表示二叉搜索树的顶部，是操作的起始位置。

植物学纯粹主义者可能会将树的根节点画在树的底部，节点向上分支，而不是像图 5-3 中那样从顶部开始。然而，这两种表示是等效的。事实上，无论是自上而下还是自下而上的插图，都隐藏了二叉搜索树的实际复杂性。像链表一样，搜索树的单个节点可以分散在计算机的内存中。每个节点仅通过指针的力量和灵活性与其子节点和父节点相连。

二叉搜索树的强大之处在于其值在树中的组织方式。*二叉搜索树属性*表明：

> 对于任何节点*N*，*N*左子树中任何节点的值都小于*N*的值，而*N*右子树中任何节点的值都大于*N*的值。

换句话说，树是按照每个节点的值进行组织的，如图 5-4 所示。左侧节点及其下方所有节点的数据值都小于当前节点的值。同样，右侧节点及其下方所有节点的数据值都大于当前节点的值。因此，值在这里起到了两个作用。首先，最明显的，它表示存储在该节点上的值。其次，它通过将子树划分为两个子集，定义了该节点下方树的结构。

上面的定义隐含地限制了二分查找树必须包含唯一的值。通过相应地修改二分查找树的属性，确实可以定义允许重复值的二分查找树。其他参考资料可能会在是否允许重复值以及如何处理二分查找树属性中的相等性上有所不同。本章重点讨论非重复值的情况，以保持与本书中将要探讨的其他索引数据结构（如跳表和哈希表）的一致性，尽管所展示的算法可以调整以处理重复值。

![一棵二分查找树，其中根节点的值为 52。其左指针指向值为 32 的节点，32 小于 52。右指针指向值为 70 的节点，70 大于 52。所有子树也都根据二分查找树的属性进行组织。](img/f05004.png)

图 5-4：二分查找树中节点的值按二分查找树的属性排序。

我们可以将二分查找树的结构与一个按幽默程度组织的公共关系部门进行比较。每个员工通过一个数值来衡量自己的幽默程度，这个数值是他们在 30 分钟演讲中插入的幽默插图数量。得分为 0 表示严肃的演讲者，只包含技术图表。得分为 100 或更高表示有志成为喜剧演员的人，他们会在每一张幻灯片中加入多个笑话。整个部门围绕这一指标来构建。内部节点代表管理者，每位管理者都有一到两个直接下属。每个管理者考虑自己的幽默水平，并根据此来划分自己的子组织。那些插入更多笑话（幽默程度*较高*）的团队成员进入右侧子团队。那些插入较少笑话（幽默程度*较低*）的团队成员进入左侧子团队。因此，每个管理者既提供了划分功能，也在两个子团队之间提供了一个中间点。

尽管这种节点排序看起来可能不像有很多结构，但请记住，我们在使用二分查找时通过类似的属性获得了相当大的性能提升。二分查找树的属性实际上是保持树中的数据根据其在树中的位置进行排序。正如我们将看到的，这不仅允许我们高效地查找树中的值，还能高效地添加和删除节点。

## 搜索二分查找树

我们通过从根节点开始遍历来搜索二叉搜索树。在每一步中，我们通过比较当前节点的值和目标值来决定是探索左子树还是右子树。如果目标值小于当前值，搜索就会向左进行。如果目标值大于当前值，搜索就会向右进行。因此，节点的值起到了类似于酒店中的标志牌的作用，告诉我们房间 500 到 519 在左边，房间 520 到 590 在右边。通过一次快速检查，我们可以做出正确的转向，并忽略另一个方向的房间。搜索在找到目标值或到达一个没有正确方向子节点的节点时结束。在后一种情况下，我们可以明确地说目标值不在树中。

### 迭代和递归搜索

我们可以使用迭代或递归的方法来实现这种搜索。以下代码使用递归方法，其中搜索函数调用自身，传递树中的下一个节点，最初从树的根节点开始调用。该代码返回指向包含目标值的节点的指针，从而使我们能够从节点中提取任何附加信息。

```py
FindValue(TreeNode: current, Type: target):
  ❶ IF current == null:
        return null
  ❷ IF current.value == target:
        return current
  ❸ IF target < current.value AND current.left != null:
        return FindValue(current.left, target)
  ❹ IF target > current.value AND current.right != null:
        return FindValue(current.right, target)
  ❺ return null
```

该算法在每个节点上仅执行少量测试；如果任何一个测试通过，我们就通过返回一个值来结束函数。首先，代码检查`current`节点是否为`null`，这可能发生在搜索空树时。如果是`null`，说明树是空的，根据定义，它不包含目标值❶。其次，如果当前节点的值等于目标值，代码找到了目标值，并返回该节点❷。第三，代码检查是否应该探索左子树，如果是，则返回从该探索中找到的任何内容❸。第四，代码检查是否应该探索右子树，如果是，则返回从该探索中找到的任何内容❹。注意，在左子树和右子树的情况下，代码还会检查相应的子节点是否存在。如果没有任何测试触发，代码已到达一个不匹配目标值且在正确方向上没有子节点的节点。它已经走到了死胡同，不得不通过返回失败值（如`null`）来承认失败❺。当在正确方向上没有子节点时，就会发生死胡同，因此即使一个内部节点只有一个子节点，它仍然可能是搜索的死胡同。

假设我们使用这种策略搜索图 5-5 中的值 63。我们从根节点开始，将其值（50）与目标值进行比较。由于 50 小于 63，我们知道目标值不在左分支中，因为该分支中的每个节点值都小于 50。这个简单的事实让我们能够*剪枝*掉整个左子树。通过一次比较，我们可以避免检查树中 22 个节点中的 11 个。这一测试实际上与我们在第二章二叉搜索算法中的剪枝操作相同：我们将一个元素与目标值进行比较，并用它来剪掉搜索空间中的大部分区域。

![一棵根节点值为 50 的二叉搜索树。根节点被阴影标记，表示搜索从此开始。左侧第一个节点值为 23，右侧第一个节点值为 67。](img/f05005.png)

图 5-5：二叉搜索树搜索的第一步。搜索从根节点开始。

我们的搜索继续沿着右子树向下，直到值为 67 的节点，如图 5-6 所示。我们再次运用二叉搜索树的特性排除掉一半的搜索空间。在这个例子中，63 小于 67，因此我们选择左子树。67 右子树中的任何节点都必须大于 67，因此它不可能包含 63。我们又剪枝了 5 个节点。

![图 5-5 中的二叉搜索树。这次，根节点（值 50）下方直接右侧的节点（值 67）被高亮显示。](img/f05006.png)

图 5-6：二叉搜索树搜索的第二步

在这一点，我们可以对当前节点下方剩余的搜索空间做出明确的判断。由于我们在 50 处向右分支，在 67 处向左分支，因此我们知道新子树中的所有节点值都大于 50 且小于 67。事实上，每次我们选择右分支时，都会缩小剩余搜索空间的下界。而每当我们选择左分支时，我们则在缩小上界。

搜索继续沿树向下，遍历每个阴影节点，如图 5-7 所示。搜索经过了 22 个节点中的 4 个，才找到了目标值。

![图 5-5 中的二叉搜索树。这次，节点 50、67、60 和 63 都被高亮显示，表明我们已经找到了目标值 63。](img/f05007.png)

图 5-7：搜索二叉搜索树中值为 63 的完整路径

设想在幽默度衡量标准下，公关部门进行这项搜索。假设部门负责人需要为一个行业会议的非正式演讲找到一位讲者。经过一番考虑，他们确定每 30 分钟 63 个笑话的幽默水平最适合该听众。部门负责人（根节点）首先考虑自己的幽默水平，意识到自己太严肃，因此让自己的右手下属在下属的组织内找到合适的人选。右子树中的每个人都比部门负责人更幽默。那位经理重复相同的步骤，将自己的幽默水平（67）与目标值进行比较，并将任务委托给其适当的下属。

当然，搜索不需要一直向下进展到叶节点。如图 5-8 所示，相关节点可能位于树的中间。如果我们搜索同一棵树的值为 14，我们会走两次左分支，最终到达适当的内部节点。这个中间级别的管理者完全符合我们的幽默标准，并且可以进行演讲。因此，当我们沿着树下降时，我们需要检查当前节点是否等于我们的目标值，如果找到匹配项，则提前终止搜索。

![图 5-5 中的二叉搜索树。这次，节点 50、23 和 14 都被高亮显示，表示我们已经找到了目标值 14。节点 14 是一个内部节点，有两个子节点。](img/f05008.png)

图 5-8：二叉搜索树的搜索可以在一个内部节点处结束，那里值与我们的目标值匹配。

迭代方法通过用`WHILE`循环替代递归来搜索二叉搜索树，该循环沿着树向下迭代。搜索再次从树的根节点开始。

```py
FindValueItr(TreeNode: root, Type: target):
  ❶ TreeNode: current = root
  ❷ WHILE current != null AND current.value != target:
      ❸ IF target < current.value:
            current = current.left
        ELSE:
            current = current.right
  ❹ return current
```

代码首先通过创建一个局部变量`current`来指向搜索中的当前节点❶。最初，这将是根节点，在空树中可能是`null`。然后，一个`WHILE`循环不断迭代树，直到遇到死胡同（`current == null`）或找到正确的值（`current.value == target`）❷。在循环内部，代码检查下一个子节点应该在左边还是右边❸，并重新分配`current`指向相应的子节点。函数最终返回`current`，它可能是找到的节点，或者如果树为空或未找到该值，则为`null`❹。

递归搜索和迭代搜索的计算成本都与目标值在树中的深度成正比。我们从树的顶部开始，沿着一条路径向下搜索。树越深，我们需要执行的比较次数越多。因此，优化树的结构以最小化其深度可以提高搜索效率。

### 搜索树与搜索已排序数组的对比

怀疑的读者可能会反驳：“第二章已经教过我们如何在排序数据上进行高效的查找。二分查找的时间复杂度是对数级别的，随数据规模增大而增加。你已经有了图示，为什么还要将数据放入树中而不是排序数组？我们是不是在增加不必要的复杂性和开销？”

这些担忧是有道理的。然而，考虑数据结构和查找如何在更广泛的背景下使用是很重要的。如果我们的数据已经在一个排序数组中，并且我们只需要查找一次，构建一棵树而不是直接进行二分查找并没有帮助。事实上，构建树本身比进行一次线性扫描还要昂贵。同样，如果数据没有变化，那么一次性排序并使用排序数组可能更为优选。我们避免了树结构本身的内存开销。随着数据变得更加动态，权衡取舍也会发生变化。

想象一下员工加入或离开公关部门的情况。除了正常的文书工作，部门还需要更新其幽默水平的数据结构。每一位新员工的加入都会代表幽默水平列表的增加，每一次离开则代表删除。与其使用汇报层级，部门可以利用办公室分配将员工按幽默水平排序。幽默程度最低的人在 1 号办公室，幽默程度最高的人在 100 号办公室。经理仍然可以高效地查找正确的演讲者。然而，他们现在需要在每次新增或离职时修正办公室分配。对于大型部门或大量变动的情况，这种开销会增加。在高度动态的环境中，比如待处理的餐厅订单列表，开销可能变得相当可观。

二叉搜索树的强大功能，以及动态数据结构的一般优势，体现在数据*变化*的场景中。正如我们接下来的章节中将看到的，二叉搜索树允许我们高效地添加和删除数据点。在排序数组中，我们需要在添加和删除数据时不断更新数组，这可能会非常昂贵。相比之下，二叉搜索树能够在数据本身变化时保持数据在一个易于查找的结构中。如果我们在一个动态数据集上进行大量的查找，这种效率的结合变得至关重要。

## 修改二叉搜索树

在使用或修改二叉搜索树时，根节点总是需要特别关注。当在树中查找一个节点时，我们总是从根节点开始。当插入第一个节点时，比如说加入我们公关部门的第一位员工，我们将这个节点设为新的根节点。正如我们在本章后面会看到的，当从二叉树中删除节点时，我们必须将根节点作为一个特殊情况来处理。

我们可以通过将整个树封装在一个包含根节点的简单数据结构中来简化使用二叉搜索树的逻辑：

```py
BinarySearchTree {
    TreeNode: root
}
```

虽然这看起来像是浪费（增加了复杂性和额外的数据结构），但它为树提供了一个易于使用的接口，并大大简化了我们对根节点的处理。当使用包装数据结构（或类）来表示我们的二叉搜索树时，我们还需要提供顶层函数来添加或查找节点。这些函数是相对简单的包装器，处理没有任何节点的树时有一个特殊的案例。

为了搜索树，代码再次通过检查树是否为空（`tree.root == null`）开始：

```py
FindTreeNode(BinarySearchTree: tree, Type: target):
    IF tree.root == null:
        return null
    return FindValue(tree.root, target)
```

如果树为空，它会立即返回`null`，表示搜索未找到匹配项。否则，代码会递归地使用`FindValue`搜索树。在这里进行`null`检查甚至可以代替`FindValue`开始时的检查，这样我们就只需在整个树上执行一次检查，而不是在每个节点上进行检查。

### 添加节点

我们使用与搜索树相同的基本算法来向二叉搜索树添加值。我们从根节点开始，沿着树向下走，就像是在寻找新值一样，直到遇到死胡同：即一个叶子节点或一个具有单个子节点且方向错误的内部节点。我们搜索和插入算法的主要区别出现在我们遇到死胡同后，插入算法会将新节点作为当前节点的子节点创建：如果新值小于当前节点的值，则作为左子节点插入，否则作为右子节点插入。

在这里，我们可以清楚地看到允许重复值和不允许重复值的树在行为上的明显区别。如果我们的树允许重复值，我们会继续操作，直到遇到死胡同，然后将该值的新副本插入树中。如果树不允许重复值，我们可能会替换或增加存储在匹配节点中的数据。例如，我们可以跟踪的一个简单辅助数据是计数器——该值已被添加到树中的次数。下面我们重点讨论覆盖数据的情况，以保持与本书中将要探索的其他索引数据结构的一致性。

和我们的搜索函数一样，我们首先使用一个包装函数来处理树为空的情况：

```py
InsertTreeNode(BinarySearchTree: tree, Type: new_value):
    IF tree.root == null:
        tree.root = TreeNode(new_value)
    ELSE:
        InsertNode(tree.root, new_value)
```

首先，代码检查树是否为空（`tree.root == null`）。如果为空，它会创建一个包含该值的新根节点。否则，它会在根节点上调用`InsertNode`，从下方开始递归处理。因此，我们可以确保`InsertNode`是通过一个有效的（非空）节点进行调用的。

这是`InsertNode`的代码：

```py
InsertNode(TreeNode: current, Type: new_value):
  ❶ IF new_value == current.value:
        Update node as needed
        return
  ❷ IF new_value < current.value:
      ❸ IF current.left != null:
            InsertNode(current.left, new_value)
        ELSE:
            current.left = TreeNode(new_value)
            current.left.parent = current 
    ELSE:
      ❹ IF current.right != null:
            InsertNode(current.right, new_value)
        ELSE:
            current.right = TreeNode(new_value)
            current.right.parent = current
```

`InsertNode` 代码首先检查是否到达了具有匹配值的节点，如果是，则根据需要更新节点的数据 ❶。否则，代码会根据新值与当前节点值的比较，沿着左侧或右侧路径搜索正确的位置 ❷。无论哪种情况，代码都会检查沿着该路径的下一个节点是否存在 ❸ ❹。如果下一个节点存在，代码会继续沿着该路径深入树中。否则，代码找到了一个死胡同，表明这是插入新节点的正确位置。算法通过创建新节点、链接父节点的相应子节点指针（`left` 或 `right`），并设置 `parent` 链接来插入节点。

例如，如果我们想要将数字 77 添加到图 5-9 中的二叉搜索树，我们沿着节点 50、67、81 和 78 依次向下，直到在值为 78 的节点处碰到死胡同。此时，我们发现在正确方向上没有有效的子节点。我们的搜索已经走到死胡同。我们创建一个值为 77 的新节点，并将其设置为节点 78 的左子节点。

![图 5-5 中的二叉搜索树。我们想要插入值 77。一系列的左右分叉导致 78 下方的死胡同。我们将新节点插入为 78 的左子节点。](img/f05009.png)

图 5-9：将值 77 插入到我们的二叉搜索树中

向树中插入新节点的成本再次与我们插入新节点的分支的深度成正比。我们对路径上的每个节点进行一次比较，直到碰到死胡同，并且与搜索操作一样，我们忽略其他分支上的所有节点。因此，插入操作的最坏情况成本将与树的深度成线性关系。

### 删除节点

从二叉搜索树中删除节点比添加节点更复杂。删除节点有三种情况需要考虑：删除叶子节点（没有子节点）、删除只有一个子节点的内部节点，以及删除有两个子节点的内部节点。正如你所预料的，随着子节点数量的增加，操作变得更加复杂。

删除叶子节点时，我们只需删除该节点，并更新其父节点的子节点指针，以反映该节点不再存在。这可能会将父节点变成叶子节点。例如，要删除图 5-10 中的节点 58，我们只需删除节点 58，并将其父节点的左子节点指针设置为`null`。

![图 5-5 中的二叉搜索树。被删除的叶子节点 55 被划掉，来自其父节点的指针也被划掉。](img/f05010.png)

图 5-10：通过删除叶子节点并更新其父节点的指针，删除二叉搜索树中的叶子节点。

删除叶子节点展示了存储指向父节点的指针的价值：它允许我们查找要删除的节点，沿着父指针回到该节点的父节点，并将相应的子指针设置为`null`。存储这一个额外的数据使得删除操作变得更加简单。

在我们的公关部门示例中，一个被删除的叶子节点对应的是一名没有直接下属的员工离开公司。告别派对和蛋糕之后，组织中的其他人继续工作。层级结构中唯一的变化是前员工的上司团队少了一个人。事实上，现在他们可能没有任何下属了。

如果目标节点有一个子节点，我们通过将那个子节点提升为被删除节点的父节点的子节点来删除它。这就像是在我们的报告层级中移除一个经理，而不需要重新安排其他人。当经理离开时，他们的上司将接管前员工唯一的直接下属。例如，如果我们想从示例树中移除节点 17，我们可以简单地将节点 21 上移，取代其位置，如图 5-11 所示。节点 14 现在直接链接到节点 21。

![图 5-5 中的两个二叉搜索树示意图。左图中，节点 17 被划掉，节点 14 直接指向节点 21。右图中，节点 21 被上移至原节点 17 的位置。](img/f05011b.png)

图 5-11：通过更改指针（左）并将单个子节点上移（右）来删除一个具有单个子节点的内部节点。

这种删除单子节点的方法，即使我们要上移的节点有自己的子树，也有效。由于被上移的节点已经在父节点的子树中，它的所有后代将继续保持二叉搜索树的特性。

当我们尝试删除一个有两个子节点的内部节点时，复杂性大大增加。仅仅删除该节点或将单个子节点上移已经不再足够。在我们的公关部门中，节点的两个子节点代表了两个具有不同幽默感的员工。我们不能只是选择一个提升，而让另一个意外地从层级结构中消失，再也没有通过脆弱的指针链与根节点连接。我们必须保持树的完整性，确保它继续遵循二叉搜索树的特性。

要删除一个有两个子节点的节点，我们将该节点与树中另一个节点交换，以保持二叉搜索树的属性。我们通过找到要删除节点的*后继*来实现这一点——如果我们按排序顺序遍历节点，我们将遇到的下一个节点就是后继节点。我们将后继节点交换到被删除节点的位置。这个交换过的节点可能也有一个子节点，当它从原位置删除时需要处理。为了从二叉树中删除后继节点而不破坏任何指针，我们重新使用删除程序来删除要交换的节点。我们找到后继节点，保存该节点的指针，然后将其从树中删除。

例如，如果我们想要删除图 5-12 中的值 81，我们需要首先交换一个值为 91 的节点。我们通过保存要删除的节点和后继节点的指针来实现这一点（图 5-12(1)）。然后，我们将后继节点设置为被删除节点父节点的子节点（图 5-12(2)）。最后，我们将后继节点的子节点更新为最近删除节点的子节点，从而有效地将它交换到正确的位置（图 5-12(3)）。

为了执行删除操作，我们需要能够高效地找到一个节点的后继。虽然这看起来可能是一个令人头疼的任务，但我们有一个关键的优势。由于我们只考虑节点有两个子节点的情况，因此我们总能在节点的右子树中找到后继节点。具体而言，后继节点将是右子树中的最小节点（或者是最左边的节点）。作为额外的好处，后继节点最多只有一个（右子）子节点。如果候选后继节点有一个左子节点，那么这个子节点（或它自己左子树中的节点）才是真正的后继节点。

![图 5-5 中的三幅二叉搜索树图，展示了删除值为 81 的节点的过程，该节点是一个有两个子节点的内部节点。节点 81 的父节点是 67，指向子节点 78 和 92。67 的指针被更改为指向 91。然后，91 获得指向子节点 78 和 92 的指针。](img/f05012.png)

图 5-12：为了删除一个有两个子节点的内部节点，我们首先将节点的后继交换到该位置。

列表 5-1 提供了（虽然冗长）伪代码，用以演示如何从二叉搜索树中删除我们刚刚讨论的三种类型的节点。虽然也可以有更简短的实现，但显式地分解这些情况有助于展示所涉及的复杂性。还需要注意的是，我们通过指针而不是值来删除节点。因此，为了删除一个具有特定值的节点，我们首先会使用`FindTreeNode`查找该节点的指针，然后使用该指针调用删除操作。

```py
RemoveTreeNode(BinarySearchTree: tree, TreeNode: node):
  ❶ IF tree.root == null OR node == null:
        return

    # Case A: Deleting a leaf node.
  ❷ IF node.left == null AND node.right == null:
        IF node.parent == null:
            tree.root = null
        ELSE IF node.parent.left == node:
            node.parent.left = null
        ELSE:
            node.parent.right = null
        return

    # Case B: Deleting a node with one child.
  ❸ IF node.left == null OR node.right == null:
      ❹ TreeNode: child = node.left
        IF node.left == null:
            child = node.right

      ❺ child.parent = node.parent
        IF node.parent == null:
            tree.root = child
        ELSE IF node.parent.left == node:
            node.parent.left = child
        ELSE:
            node.parent.right = child
        return

    # Case C: Deleting a node with two children.
    # Find the successor and splice it out of the tree.
  ❻ TreeNode: successor = node.right
    WHILE successor.left != null:
        successor = successor.left
    RemoveTreeNode(tree, successor)

    # Insert the successor in the deleted node's place.
  ❼ IF node.parent == null:
        tree.root = successor
    ELSE IF node.parent.left == node:
        node.parent.left = successor
    ELSE:
        node.parent.right = successor
  ❽ successor.parent = node.parent

  ❾ successor.left = node.left
    node.left.parent = successor

    successor.right = node.right
    IF node.right != null:
        node.right.parent = successor
```

列表 5-1：从二叉搜索树中删除一个节点

与插入和搜索的包装函数一样，代码首先检查树是否为空 ❶，如果为空，则返回 `null`。它还检查是否有有效的节点可以删除（`node != null`），这在我们希望将搜索和删除合并为一行时非常有用：

```py
RemoveTreeNode(tree, FindTreeNode(tree, target))
```

由于 `FindTreeNode` 如果未找到节点会返回 `null`，因此我们需要显式处理这种情况。

然后，代码依次考虑这三种情况。在情况 A 中，移除叶子节点 ❷，代码只需要更改已删除节点父节点的正确子指针。首先，代码检查要删除的节点是否有父节点。如果没有，说明正在移除根节点，代码将根节点指针修改为 `null`，有效地移除根节点。如果被移除节点是父节点的左子节点，代码将该指针设置为 `null`。同样，如果被移除节点是父节点的右子节点，代码将该指针设置为 `null`。然后，代码可以返回，成功地将目标叶子节点从树中移除。

在情况 B 中，移除一个只有一个子节点的节点 ❸，代码首先通过检查两个子指针中哪个不是 `null` ❹ 来确定哪个指针指向子节点。代码将该子节点的指针存储起来以备后用。接下来，代码修复新提升的节点与其新父节点之间的指针 ❺。代码将子节点的父指针设置为其原先的祖父节点，从树中向上剪除被移除的节点。最后，代码修复被移除节点父节点中的正确子指针，并处理根节点的特殊情况。代码获取之前指向被移除节点的指针，并将其重定向到指向该节点的唯一子节点。如果被移除节点没有父节点，说明正在处理根节点，代码需要相应地修改该指针。一旦代码成功剪除正确的节点，它就返回。

在情况 C 中，移除的节点有两个子节点，代码首先通过识别后继节点并将其从树中移除 ❻。注意，如上所述，递归调用 `RemoveTreeNode` 本身无法触发情况 C，因为后继节点最多只有一个（右侧）子节点。代码在移除后继节点后，仍然保持对该后继节点的指针，因为它将用该节点来替换已删除的节点。接下来，代码通过以下步骤将已删除的节点替换为后继节点：

1.  修改已删除节点的父节点，以将正确的子指针指向后继节点 ❼。

1.  修改后继节点的父指针，使其指向新父节点 ❽。

1.  设置后继节点的左右子节点的链接❾。在处理右子节点时，代码特别小心，因为它有可能已经通过`RemoveTreeNode`操作删除了那个子节点（如果后继节点是`node`的直接右子节点）。因此，在尝试分配右子节点的父节点指针之前，需要检查右子节点是否为`null`。

根据编程语言和代码的使用方式，我们可能还希望将`node`的输出指针设置为`null`，作为删除操作的一部分。这将清理删除节点与树中其他节点之间的引用。我们可以通过在每个三种情况的末尾（在案例 A 和 B 中的`return`语句之前，以及案例 C 中的函数末尾）添加以下几行代码来实现：

```py
node.parent = null
node.right = null
node.left = null
```

与查找和插入操作类似，删除操作最多只涉及沿着一条路径从树的顶部到底部的遍历。在案例 A 和 B 中，这一过程发生在`RemoveTreeNode`函数之前（作为之前调用`FindTreeNode`来获取节点指针的一部分）。案例 C 添加了从要删除的内部节点到其后继节点的额外遍历。因此，删除操作的最坏情况运行时间仍然与树的深度成正比。

## 不平衡树的危险

在*完美平衡*的二叉查找树上执行搜索、添加和删除操作的时间，在最坏的情况下与树的深度成正比，因此在树不太深的情况下，这些操作的效率非常高。一个完美平衡的树是指，在每个节点处，右子树包含与左子树相同数量的节点。在这种情况下，每当我们将树中的节点数量加倍时，树的深度就会增加 1。因此，在平衡的树中，所有三种操作的最坏情况性能按对数函数 log2 进行增长，其中 *N* 是元素数量。

二叉查找树仍然高效，只要树大部分时间保持平衡，尽管不一定是完美平衡的。但如果树变得高度不平衡，它的深度可能会随着元素数量的增加线性增长。事实上，在极端情况下，我们辉煌的二叉查找树就变成了一个排序链表——所有的节点都只有一个子节点，并且都指向相同方向，如图 5-13 所示。

![一个不平衡的二叉查找树，每个节点只有指向单一右子节点的单个指针](img/f05013.png)

图 5-13：一个不平衡的二叉查找树示例

在许多现实世界的应用中，很容易出现高度不平衡的树。假设我们将咖啡日志存储在一个按时间戳索引的二叉搜索树中。每次我们喝一杯咖啡时，就将相关信息插入到树中。问题很快就出现了。由于时间戳单调递增，我们将每个条目按排序顺序插入，结果我们只用右子节点指针创建了一个链表。

对不平衡树的操作可能非常低效。考虑一个有*N*个节点的树。如果我们的树是平衡的，那么操作的时间复杂度是*N*的对数级别。相反，如果我们的树是一个链表，操作的时间复杂度可能与*N*成线性关系。

我们可以使用各种增强技术，如红黑树、2-3 树和 B 树，来保持树的平衡，同时进行动态插入和删除。这些方法的权衡是树操作的复杂性增加。我们将在第十二章详细讨论 B 树，并展示它们的结构如何保持平衡。

下一节介绍了一种简单的方法，用初始值集构建平衡的二叉搜索树。*批量构建*允许算法选择哪些节点来分割数据，从而平衡每一侧的节点数量。当我们事先知道很多值，但需要小心处理未来的插入时，这是一个不错的方法，因为插入可能导致树的不平衡。

## 二叉搜索树的批量构建

我们可以通过迭代地添加节点来轻松构建二叉搜索树：我们创建一个新的节点并将其标记为根节点，然后对于每个剩余的值，创建一个新节点并将该节点添加到树中。这种方法的优点是简单，并且重用了我们之前定义的算法。不幸的是，它可能导致树的不平衡。正如我们上面所看到的，如果我们按排序顺序添加值，就会得到一个排序好的链表。当从初始值集创建树时，我们可以做得更好。

我们从已排序数组（如图 5-14 所示）中创建平衡的二叉搜索树，方法是递归地将元素划分为更小的子集。在每一层，我们选择中间值作为该层的节点。如果元素数量是偶数，我们可以选择两个中间元素中的任何一个。

![一个包含从 1 到 12 的已排序数组](img/f05014.png)

图 5-14：用于批量构建二叉搜索树的已排序数组

我们创建一个新节点，其值等于数组中间的元素，并将其余元素分配到两个子节点，如图 5-15 所示。我们递归地为每个子节点创建子树，使用相同的过程。小于中间元素的值放在左边，而较大的值放在右边。

![图 5-14 中的排序数组被分成了两个部分。一个值为 7 的根节点指向一个包含值 1 到 6 的数组，并指向一个包含值 8 到 12 的数组。](img/f05015.png)

图 5-15：第一次分割后，我们得到了一个单独的节点和两个独立的数组。

我们不需要在每次分割时创建输入数组的新副本。相反，我们可以借鉴二叉搜索算法的做法，仅跟踪当前考虑的数组范围，如图 5-16 所示。每次分割都会将数组划分成一致的两半，因此我们只需要关注两个边界：当前分支中最高和最低值的索引。

![图 5-15 中的数组，框 7 到 12 被灰色标出。框 1 标记为 Low，框 6 标记为 High，表示左侧数组的边界。](img/f05016.png)

图 5-16：高低索引可以用来跟踪当前考虑的数组子集。

一旦我们创建了新的节点，就使用相同的方法独立构建左右子树。具体来说，我们选择中间值，从该值创建一个新节点，划分剩余的范围，并利用这些范围来创建子树。当范围中只剩下一个值时，过程结束。在这种情况下，我们创建一个包含该值且没有子节点的新叶节点。

## 为什么这很重要

二叉搜索树展示了我们如何将动态数据结构调整为特定问题。树形结构通过分支结构捕捉并维持数据值的排序信息。这使得它们能够实现高效搜索。此外，二叉搜索树基于指针的结构使得它们在新增数据时能够持续适应。这种数据、问题和计算的相互作用为我们提供了解决日益复杂的计算挑战的基础。

在后续的章节中，我们将继续在动态数据结构的概念基础上展开，调整数据的结构以适应问题本身，并使用分支数据结构来实现高效的剪枝。这些技术在多种不同的数据结构中都有应用。理解这些基本原理，例如这些技术如何在动态二叉搜索树中实现高效搜索，对于理解如何使用更复杂的数据结构和算法至关重要。下一章将介绍字典树（trie），展示如何将二叉搜索树中的基于树的概念扩展到多叉分支，以提高某些类型搜索的效率。
