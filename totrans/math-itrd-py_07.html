<html><head></head><body>
<h2 class="h2" id="ch05"><span epub:type="pagebreak" id="page_77"/><span class="big">5</span><br/>TRANSFORMING SHAPES WITH GEOMETRY</h2>&#13;
<p class="epigraph"><em>In the teahouse one day Nasrudin announced he was selling his house. When the other patrons asked him to describe it, he brought out a brick. “It’s just a collection of these.”—Idries Shah</em></p>&#13;
<div class="image1"><img alt="image" src="../images/fintro-01.jpg"/></div>&#13;
<p class="intro">In geometry class, everything you learn about involves dimensions in space using shapes. You typically start by examining one-dimensional lines and two-dimensional circles, squares, or triangles, then move on to three-dimensional objects like spheres and cubes. These days, creating geometric shapes is easy with technology and free software, though manipulating and changing the shapes you create can be more of a challenge.</p>&#13;
<p class="indent">In this chapter, you’ll learn how to manipulate and transform geometric shapes using the Processing graphics package. You’ll start with basic shapes like circles and triangles, which will allow you to work with complicated shapes like fractals and cellular automata in later chapters. You will also learn how to break down some complicated-looking designs into simple components.</p>&#13;
<h3 class="h3" id="ch05_1"><span epub:type="pagebreak" id="page_78"/>DRAWING A CIRCLE</h3>&#13;
<p class="noindent">Let’s start with a simple one-dimensional circle. Open a new sketch in Processing and save it as <em>geometry.pyde</em>. Then enter the code in <a href="ch05.xhtml#ch05list1">Listing 5-1</a> to create a circle on the screen.</p>&#13;
<pre><span class="pd_g1"><em>geometry.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    size(600,600)<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_blue1">ellipse</span>(200,100,20,20)</pre>&#13;
<p class="listing" id="ch05list1"><em>Listing 5-1: Drawing a circle</em></p>&#13;
<p class="indent">Before we draw the shape, we first define the size of our sketchbook, known as the <em>coordinate plane</em>. In this example, we use the <code>size()</code> function to say that our grid will be 600 pixels wide and 600 pixels tall.</p>&#13;
<p class="indent">With our coordinate plane set up, we then use the drawing function <code>ellipse()</code> to create our circle on this plane. The first two parameters, <code>200</code> and <code>100</code>, show where the center of the circle is located. Here, <code>200</code> is the x-coordinate and the second number, <code>100</code>, is the y-coordinate of this circle’s center, which places it at <code>(200,100)</code> on the plane.</p>&#13;
<p class="indent">The last two parameters determine the width and height of the shape in pixels. In the example, the shape is 20 pixels wide and 20 pixels tall. Because the two parameters are the same, it means that the points on the circumference are equidistant from the center, forming a perfectly round circle.</p>&#13;
<p class="indent">Click the <strong>Run</strong> button (it looks like a play symbol), and a new window with a small circle should open, like in <a href="ch05.xhtml#ch05fig1">Figure 5-1</a>.</p>&#13;
<div class="image"><a id="ch05fig1"/><img alt="image" src="../images/f078-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-1: The output of <a href="ch05.xhtml#ch05list1">Listing 5-1</a> showing a small circle</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_79"/>Processing has a number of functions you can use to draw shapes. Check out the full list at <a href="https://processing.org/reference/"><em>https://processing.org/reference/</em></a> to explore other shape functions.</p>&#13;
<p class="indent">Now that you know how to draw a circle in Processing, you’re almost ready to use these simple shapes to create dynamic, interactive graphics. In order to do that, you’ll first need to learn about location and transformations. Let’s start with location.</p>&#13;
<h3 class="h3" id="ch05_2">SPECIFYING LOCATION USING COORDINATES</h3>&#13;
<p class="noindent">In <a href="ch05.xhtml#ch05list1">Listing 5-1</a>, we used the first two parameters of the <code>ellipse()</code> function to specify our circle’s location on the grid. Likewise, each shape we create using Processing needs a location that we specify with the coordinate system, where each point on the graph is represented by two numbers: (x,y). In traditional math graphs, the origin (where x=0 and y=0) is at the center of the graph, as shown in <a href="ch05.xhtml#ch05fig2">Figure 5-2</a>.</p>&#13;
<div class="image"><a id="ch05fig2"/><img alt="image" src="../images/f079-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-2: A traditional coordinate system with the origin in the center</em></p>&#13;
<p class="indent">In computer graphics, however, the coordinate system is a little different. Its origin is in the top-left corner of the screen so that x and y increase as you move right and down, respectively, as you can see in <a href="ch05.xhtml#ch05fig3">Figure 5-3</a>.</p>&#13;
<div class="image"><a id="ch05fig3"/><img alt="image" src="../images/f079-02.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-3: The coordinate system for computer graphics, with the origin in the top-left corner</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_80"/>Each coordinate on this plane represents a pixel on the screen. As you can see, this means you don’t have to deal with negative coordinates. We’ll use functions to transform and translate increasingly complex shapes around this coordinate system.</p>&#13;
<p class="indent">Drawing a single circle was fairly easy, but drawing multiple shapes can get complicated pretty quickly. For example, imagine drawing a design like the one shown in <a href="ch05.xhtml#ch05fig4">Figure 5-4</a>.</p>&#13;
<div class="image"><a id="ch05fig4"/><img alt="image" src="../images/f080-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-4: A circle made of circles</em></p>&#13;
<p class="indent">Specifying the size and location of each individual circle and spacing them out perfectly evenly would involve entering many lines of similar code. Fortunately, you don’t really need to know the absolute x- and y-coordinates of each circle to do this. With Processing, you can easily place objects wherever you want on the grid.</p>&#13;
<p class="indent">Let’s see how you can do this using a simple example to start.</p>&#13;
<h3 class="h3" id="ch05_3">TRANSFORMATION FUNCTIONS</h3>&#13;
<p class="noindent">You might remember doing transformations with pencil and paper in geometry class, which you performed on a collection of points to laboriously move a shape around. It’s much more fun when you let a computer do the transforming. In fact, there wouldn’t be any computer graphics worth looking at without transformations! Geometric transformations like translation and rotation let you change where and how your objects appear without altering the objects themselves. For example, you can use transformations to move a triangle to a different location or spin it around without changing its shape. Processing has a number of built-in transformation functions that make it easy to translate and rotate objects.</p>&#13;
<h4 class="h4" id="ch05_1_1">TRANSLATING OBJECTS WITH TRANSLATE()</h4>&#13;
<p class="noindent">To <em>translate</em> means to move a shape on a grid so that all points of the shape move in the same direction and the same distance. In other words, translations let you move a shape on a grid without changing the shape itself and without tilting it in the slightest.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_81"/>Translating an object in math class involves manually changing the coordinates of all the points in the object. But in Processing, you translate an object by moving the <em>grid</em> itself, while the object’s coordinates stay the same! For an example of this, let’s put a rectangle on the screen. Revise your existing code in <em>geometry.pyde</em> with the code in <a href="ch05.xhtml#ch05list2">Listing 5-2</a>.</p>&#13;
<pre><span class="pd_g1"><em>geometry.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    size(600,600)<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_blue1">rect</span>(20,40,50,30)</pre>&#13;
<p class="listing" id="ch05list2"><em>Listing 5-2: Drawing a rectangle to translate</em></p>&#13;
<p class="indent">Here, we use the <code>rect()</code> function to draw the rectangle. The first two parameters are the x- and y-coordinates telling Processing where the top-left corner of the rectangle should be. The third and fourth parameters indicate its width and its height, respectively.</p>&#13;
<p class="indent">Run this code, and you should see the rectangle shown in <a href="ch05.xhtml#ch05fig5">Figure 5-5</a>.</p>&#13;
<div class="image"><a id="ch05fig5"/><img alt="image" src="../images/f081-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-5: The default coordinate setup with the origin at the top left</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep">In these examples, I’m showing the grid for reference, but you won’t see it on your screen.</p>&#13;
</div>&#13;
<p class="indent">Now let’s tell Processing to translate the rectangle using the code in <a href="ch05.xhtml#ch05list3">Listing 5-3</a>. Notice that we don’t change the coordinates of the rectangle.</p>&#13;
<pre><span class="pd_g1"><em>geometry.pyde</em></span><br/><span class="pd_gray">def setup():</span><br/><span class="pd_gray">    size(600,600)</span><br/><br/><span class="pd_gray">def draw():</span><br/>    <span class="pd_blue1">translate</span>(50,80);<br/>    <span class="pd_blue1">rect</span>(50,100,100,60)</pre>&#13;
<p class="listing" id="ch05list3"><em>Listing 5-3: Translating the rectangle</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_82"/>Here, we use <code>translate()</code> to move the rectangle. We provide two parameters: the first tells Processing how far to move the grid in the horizontal (x) direction, and the second parameter is for how far to move the grid vertically, in the y-direction. So <code>translate(50,80)</code> should move the entire grid 50 pixels to the right and 80 pixels down, as shown in <a href="ch05.xhtml#ch05fig6">Figure 5-6</a>.</p>&#13;
<div class="image"><a id="ch05fig6"/><img alt="image" src="../images/f082-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-6: Translating a rectangle by moving the grid 50 pixels to the right and 80 pixels down</em></p>&#13;
<p class="indent">Very often it’s useful (and easier!) to have the origin (0,0) in the center of the canvas. You can use <code>translate()</code> to easily move the origin to the center of your grid. You can also use it to change the width and height of your canvas if you want it bigger or smaller. Let’s explore Processing’s built-in <code>width</code> and <code>height</code> variables, which let you update the size of your canvas without having to change the numbers manually. To see this in action, update the existing code in <a href="ch05.xhtml#ch05list3">Listing 5-3</a> so it looks like <a href="ch05.xhtml#ch05list4">Listing 5-4</a>.</p>&#13;
<pre><span class="pd_g1"><em>geometry.pyde</em></span><br/><span class="pd_gray">def setup():</span><br/><span class="pd_gray">    size(600,600)</span><br/><br/><span class="pd_gray">def draw():</span><br/><span class="pd_gray">    </span><span class="pd_blue1">translate</span>(<span class="pd_raspberry">width</span>/2, <span class="pd_raspberry">height</span>/2)<br/><span class="pd_gray">    </span><span class="pd_blue1">rect</span>(50,100,100,60)</pre>&#13;
<p class="listing" id="ch05list4"><em>Listing 5-4: Using the <code>width</code> and <code>height</code> variables to translate the rectangle</em></p>&#13;
<p class="indent">Whatever numbers you put in the <code>size</code> declaration in the <code>setup()</code> function will become the “width” and “height” of the canvas. In this case, because I used <code>size(600,600)</code>, they’re both 600 pixels. When we change the <code>translate()</code> line to <code>translate(width/2, height/2)</code> using variables instead <span epub:type="pagebreak" id="page_83"/>of specific numbers, we tell Processing to move the location (0,0) to the center of the display window, no matter what the size is. This means that if you change the size of the window, Processing will automatically update <code>width</code> and <code>height</code>, and you won’t have to go through all your code and change the numbers manually.</p>&#13;
<p class="indent">Run the updated code, and you should see something like <a href="ch05.xhtml#ch05fig7">Figure 5-7</a>.</p>&#13;
<div class="image"><a id="ch05fig7"/><img alt="image" src="../images/f083-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-7: The grid is translated to the center of the screen</em>.</p>&#13;
<p class="indent">Notice that the origin is still labeled as (0,0), which shows that we haven’t actually moved the origin point but rather the entire coordinate plane itself so that the origin point falls in the middle of our canvas.</p>&#13;
<h4 class="h4" id="ch05_1_2">ROTATING OBJECTS WITH ROTATE()</h4>&#13;
<p class="noindent">In geometry, <em>rotation</em> is a kind of transformation that turns an object around a center point, as if it’s turning on an axis. The <code>rotate()</code> function in Processing rotates the grid around the origin (0,0). It takes a single number as its argument to specify the angle at which you want to rotate the grid around the point (0,0). The units for the rotation angle are radians, which you learn about in precalculus class. Instead of using 360 degrees to do a full rotation, we can use 2π (around 6.28) radians. If you think in degrees, like I do, you can use the <code>radians()</code> function to easily convert your degrees to radians so you don’t have to do the math yourself.</p>&#13;
<p class="indent">To see how the <code>rotate()</code> function works, enter the code shown in <a href="ch05.xhtml#ch05fig8">Figure 5-8</a> into your existing sketch by replacing the <code>translate()</code> code inside the <code>draw()</code> function with each of these examples, and then run them. <a href="ch05.xhtml#ch05fig8">Figure 5-8</a> shows the results.</p>&#13;
<span epub:type="pagebreak" id="page_84"/>&#13;
<div class="image"><a id="ch05fig8"/><img alt="image" src="../images/f084-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-8: The grid always rotates around (0,0)</em></p>&#13;
<p class="indent">On the left side of <a href="ch05.xhtml#ch05fig8">Figure 5-8</a>, the grid is rotated 20 degrees around (0,0), which is at the top-left corner of the screen. In the example on the right, the origin is first translated 200 units to the right and 200 units down and <em>then</em> the grid is rotated.</p>&#13;
<p class="indent">The <code>rotate()</code> function makes it easy to draw a circle of objects like the one in <a href="ch05.xhtml#ch05fig4">Figure 5-4</a> using the following steps:</p>&#13;
<ol>&#13;
<li class="noindent">Translate to where you want the center of the circle to be.</li>&#13;
<li class="noindent">Rotate the grid and put the objects along the circumference of the circle.</li>&#13;
</ol>&#13;
<p class="indent">Now that you know how to use transformation functions to manipulate the location of different objects on your canvas, let’s actually re-create <a href="ch05.xhtml#ch05fig4">Figure 5-4</a> in Processing.</p>&#13;
<h4 class="h4" id="ch05_1_3">DRAWING A CIRCLE OF CIRCLES</h4>&#13;
<p class="noindent">To create the circles arranged in a circle in <a href="ch05.xhtml#ch05fig4">Figure 5-4</a>, we’ll use a <code>for i in range()</code> loop to repeat the circles and make sure the circles are evenly spaced. First, let’s think about how many degrees should be between the circles to make a full circle, remembering that a circle is 360 degrees.</p>&#13;
<p class="indent">Enter the code shown in <a href="ch05.xhtml#ch05list5">Listing 5-5</a> to create this design.</p>&#13;
<pre><span class="pd_g1"><em>geometry.pyde</em></span><br/><span class="pd_gray">def setup():</span><br/><span class="pd_gray">    size(600,600)</span><br/><br/><span class="pd_gray">def draw():</span><br/><span class="pd_gray">    translate(width/2,height/2)</span><br/>    <span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(12):<br/>        <span class="pd_blue1">ellipse</span>(200,0,50,50)<br/><span epub:type="pagebreak" id="page_85"/>&#13;
        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(360/12))</pre>&#13;
<p class="listing" id="ch05list5"><em>Listing 5-5: Drawing a circular design</em></p>&#13;
<p class="indent">Note that the <code>translate(width/2,height/2)</code> function inside the <code>draw()</code> function translates the grid to the center of the screen. Then, we start a <code>for</code> loop to create an ellipse at a point on the grid, starting at (200,0), as you can see from the first two parameters of the function. Then we set the size of each small circle by setting both the <code>width</code> and <code>height</code> of the ellipse to <code>50</code>. Finally, we rotate the grid by 360/12, or 30 degrees, before creating the next ellipse. Note that we use <code>radians()</code> to convert 30 degrees into radians inside the <code>rotate()</code> function. This means that each circle will be 30 degrees away from the next one.</p>&#13;
<p class="indent">When you run this, you should see what’s shown in <a href="ch05.xhtml#ch05fig9">Figure 5-9</a>.</p>&#13;
<div class="image"><a id="ch05fig9"/><img alt="image" src="../images/f085-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-9: Using transformation to create a circular design</em></p>&#13;
<p class="indent">We have successfully arranged a bunch of circles into a circular shape!</p>&#13;
<h4 class="h4" id="ch05_1_4">DRAWING A CIRCLE OF SQUARES</h4>&#13;
<p class="noindent">Modify the program you wrote in <a href="ch05.xhtml#ch05list5">Listing 5-5</a> and change the circles into squares. To do this, just change <code>ellipse</code> in the existing code to <code>rect</code> to make the circles into squares, as shown here:</p>&#13;
<pre><span class="pd_g1"><em>geometry.pyde</em></span><br/><span class="pd_gray">def setup():</span><br/><span class="pd_gray">    size(600,600)</span><br/><br/><span class="pd_gray">def draw():</span><br/><span class="pd_gray">    translate(width/2,height/2)</span><br/><span class="pd_gray">    for i in range(12):</span><br/><span class="pd_gray">        </span><span class="pd_blue1">rect</span>(200,0,50,50)<br/><span class="pd_gray">        rotate(radians(360/12))</span></pre>&#13;
<span epub:type="pagebreak" id="page_86"/>&#13;
<p class="indent">That was easy!</p>&#13;
<h3 class="h3" id="ch05_4">ANIMATING OBJECTS</h3>&#13;
<p class="noindent">Processing is great for animating your objects to create dynamic graphics. For your first animation, you’ll use the <code>rotate()</code> function. Normally, <code>rotate</code> happens instantly, so you don’t get to see the action take place—only the result of the rotation. But this time, we’ll use a time variable <code>t</code>, which allows us to see the rotation unfold in real time!</p>&#13;
<h4 class="h4" id="ch05_1_5">CREATING THE T VARIABLE</h4>&#13;
<p class="noindent">Let’s use our circle of squares to write an animated program. To start, create the <code>t</code> variable and initialize it to 0 by adding <span class="codestrong1">t = 0</span> before the <code>setup()</code> function. Then insert the code in <a href="ch05.xhtml#ch05list6">Listing 5-6</a> before the <code>for</code> loop.</p>&#13;
<pre><span class="pd_g1"><em>geometry.pyde</em></span><br/>t = 0<br/><br/><span class="pd_gray">def setup():</span><br/><span class="pd_gray">    size(600,600)</span><br/><br/><span class="pd_gray">def draw():</span><br/><span class="pd_gray">    translate(width/2,height/2)</span><br/><span class="pd_gray">    </span><span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(t))<br/>    <span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(12):<br/><span class="pd_gray">        rect(200,0,50,50)</span><br/><span class="pd_gray">        rotate(radians(360/12))</span></pre>&#13;
<p class="listing" id="ch05list6"><em>Listing 5-6: Adding the <code>t</code> variable</em></p>&#13;
<p class="indent">However, if you try to run this code, you’ll get the following error message:</p>&#13;
<pre>UnboundLocalError: local variable 't' referenced before assignment</pre>&#13;
<p class="indent">This is because Python doesn’t know whether we’re creating a new local variable named <code>t</code> <em>inside</em> the function that doesn’t have anything to do with the global variable <code>t</code> <em>outside</em> the function, or just calling the global variable. Because we want to use the global variable, add <span class="codestrong1">global t</span> at the beginning of the <code>draw()</code> function so the program knows which one we’re referring to.</p>&#13;
<p class="indent">Enter the complete code shown here:</p>&#13;
<pre><span class="pd_g1"><em>geometry.pyde</em></span><br/>t = 0<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_blue1">size</span>(600,600)<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_green1">global</span> t<br/>    <span class="pd_gray">#set background white</span><br/>    <span class="pd_blue1">background</span>(255)<br/><span epub:type="pagebreak" id="page_87"/>&#13;
    <span class="pd_blue1">translate</span>(<span class="pd_raspberry">width</span>/2,<span class="pd_raspberry">height</span>/2)<br/>    <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(t))<br/>    <span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(12):<br/>        <span class="pd_blue1">rect</span>(200,0,50,50)<br/>        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(360/12))<br/>    t += 1</pre>&#13;
<p class="indent">This code starts <code>t</code> at 0, rotates the grid that number of degrees, increments <code>t</code> by 1, and then repeats. Run it, and you should see the squares start to rotate in a circular pattern, as in <a href="ch05.xhtml#ch05fig10">Figure 5-10</a>.</p>&#13;
<div class="image"><a id="ch05fig10"/><img alt="image" src="../images/f087-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-10: Making squares rotate in a circle</em></p>&#13;
<p class="indent">Pretty cool! Now let’s try rotating each individual square.</p>&#13;
<h4 class="h4" id="ch05_1_6">ROTATING THE INDIVIDUAL SQUARES</h4>&#13;
<p class="noindent">Because rotating is done around (0,0) in Processing, inside the loop we first have to translate to where each square needs to be, then rotate, and finally draw the square. Change the loop in your code to look like <a href="ch05.xhtml#ch05list7">Listing 5-7</a>.</p>&#13;
<pre><span class="pd_g1"><em>geometry.pyde</em></span><br/><span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(12):<br/>    <span class="pd_blue1">translate</span>(200,0)<br/>    <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(t))<br/>    <span class="pd_blue1">rect</span>(0,0,50,50)<br/>    <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(360/12))</pre>&#13;
<p class="listing" id="ch05list7"><em>Listing 5-7: Rotating each square</em></p>&#13;
<p class="indent">This translates the grid to where we want to place the square, rotates the grid so the square rotates, and then draws the square using the <code>rect()</code> function.</p>&#13;
<h4 class="h4" id="ch05_1_7"><span epub:type="pagebreak" id="page_88"/>SAVING ORIENTATION WITH PUSHMATRIX() AND POPMATRIX()</h4>&#13;
<p class="noindent">When you run <a href="ch05.xhtml#ch05list7">Listing 5-7</a>, you should see that it creates some strange behavior. The squares don’t rotate around the center, but keep moving around the screen instead, as shown in <a href="ch05.xhtml#ch05fig11">Figure 5-11</a>.</p>&#13;
<div class="image"><a id="ch05fig11"/><img alt="image" src="../images/f088-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-11: The squares are flying all over!</em></p>&#13;
<p class="indent">This is due to changing the center and changing the orientation of the grid so much. After translating to the location of the square, we need to rotate back to the center of the circle before translating to the next square. We could use another <code>translate()</code> function to undo the first one, but we might have to undo more transformations, and that could get confusing. Fortunately, there’s an easier way.</p>&#13;
<p class="indent">Processing has two built-in functions that save the orientation of the grid at a certain point and then return to that orientation: <code>pushMatrix()</code> and <code>popMatrix()</code>. In this case, we want to save the orientation when we’re in the center of the screen. To do this, revise the loop to look like <a href="ch05.xhtml#ch05list8">Listing 5-8</a>.</p>&#13;
<pre><span class="pd_g1"><em>geometry.pyde</em></span><br/><span class="pd_gray">for i in range(12):</span><br/><span class="pd_gray">    </span><span class="pd_blue1">pushMatrix</span>() <span class="pd_gray">#save this orientation</span><br/><span class="pd_gray">    translate(200,0)</span><br/><span class="pd_gray">    rotate(radians(t))</span><br/><span class="pd_gray">    rect(0,0,50,50)</span><br/><span class="pd_gray">    </span><span class="pd_blue1">popMatrix</span>() <span class="pd_gray">#return to the saved orientation</span><br/><span class="pd_gray">    rotate(radians(360/12))</span></pre>&#13;
<p class="listing" id="ch05list8"><em>Listing 5-8: Using <code>pushMatrix()</code> and <code>popMatrix()</code></em></p>&#13;
<p class="indent">The <code>pushMatrix()</code> function saves the position of the coordinate system at the center of the circle of squares. Then we translate to the location of the <span epub:type="pagebreak" id="page_89"/>square, rotate the grid so the square will spin, and then draw the square. Then we use <code>popMatrix()</code> to return instantly to the center of the circle of squares and repeat for all 12 squares.</p>&#13;
<h4 class="h4" id="ch05_1_8">ROTATING AROUND THE CENTER</h4>&#13;
<p class="noindent">The preceding code should work perfectly, but the rotation may look strange; that’s because Processing by default locates a rectangle at its top-left corner and rotates it about its top-left corner. This makes the squares look like they’re veering off the path of the larger circle. If you want your squares to rotate around their centers, add this line to your <code>setup()</code> function:</p>&#13;
<pre>    <span class="pd_blue1">rectMode</span>(<span class="pd_olive">CENTER</span>)</pre>&#13;
<p class="indent">Note that the all-uppercase <code>CENTER</code> in <code>rectMode()</code> matters. (You can also experiment with other types of <code>rectMode()</code>, like <code>CORNER</code>, <code>CORNERS</code>, and <code>RADIUS</code>.) Adding <code>rectMode(CENTER)</code> should make each square rotate around its center. If you want the squares to spin more quickly, change the <code>rotate()</code> line to increase the time in <code>t</code>, like so:</p>&#13;
<pre>    <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(5*t))</pre>&#13;
<p class="indent">Here, <code>5</code> is the frequency of the rotation. This means the program multiplies the value of <code>t</code> by 5 and rotates by the product. Therefore, the square will rotate five times as far as before. Change it to see what happens! Comment out the <code>rotate()</code> line outside the loop (by adding a hashtag at the beginning) to make the squares rotate in place, as shown in <a href="ch05.xhtml#ch05list9">Listing 5-9</a>.</p>&#13;
<pre><span class="pd_gray">    translate(width/2,height/2)</span><br/><span class="pd_gray">    </span>#rotate(radians(t))<br/><span class="pd_gray">    for i in range(12):</span><br/><span class="pd_gray">        rect(200,0,50,50)</span></pre>&#13;
<p class="listing" id="ch05list9"><em>Listing 5-9: Commenting out a line instead of deleting it</em></p>&#13;
<p class="indent">Being able to use transformations like <code>translate()</code> and <code>rotate()</code> to create dynamic graphics is a very powerful technique, but it can produce unexpected results if you do things in the wrong order!</p>&#13;
<h3 class="h3" id="ch05_5">CREATING AN INTERACTIVE RAINBOW GRID</h3>&#13;
<p class="noindent">Now that you’ve learned how to create designs using loops and to rotate them in different ways, we’ll create something pretty awesome: a grid of squares whose rainbow colors follow your mouse cursor! The first step is to make a grid.</p>&#13;
<h4 class="h4" id="ch05_1_9"><span epub:type="pagebreak" id="page_90"/>DRAWING A GRID OF OBJECTS</h4>&#13;
<p class="noindent">Many tasks involved in math and in creating games like Minesweeper require a grid. Grids are necessary for some of the models and all the cellular automata we’ll create in later chapters, so it’s worth learning how to write code for making a grid that we can reuse. To begin with, we’ll make a 12 × 12 grid of squares, evenly sized and spaced. Making a grid this size may seem like a time-consuming task, but in fact it’s easy to do using a loop.</p>&#13;
<p class="indent">Open a new Processing sketch and save as <em>colorGrid.pyde</em>. Too bad we used the name “grid” previously. We’ll make a 20 × 20 grid of squares on a white background. The squares need to be <code>rect</code>, and we need to use a <code>for</code> loop within a <code>for</code> loop to make sure they are all the same size and spaced equally. Also, we need our 25 × 25 pixel squares to be drawn every 30 pixels, using this line:</p>&#13;
<pre><span class="pd_blue1">rect</span>(30*x,30*y,25,25)</pre>&#13;
<p class="indent">As the <code>x</code> and <code>y</code> variables go up by 1, squares are drawn at 50-pixel intervals in two dimensions. We’ll start off, as usual, by writing our <code>setup()</code> and <code>draw()</code> functions, as in the previous sketch (see <a href="ch05.xhtml#ch05list10">Listing 5-10</a>).</p>&#13;
<pre><span class="pd_g1"><em>colorGrid.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/><span class="pd_gray">    </span><span class="pd_blue1">size</span>(600,600)<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/><span class="pd_gray">    #set background white</span><br/><span class="pd_gray">    </span><span class="pd_blue1">background</span>(255)</pre>&#13;
<p class="listing" id="ch05list10"><em>Listing 5-10: The standard structure for a Processing sketch: <code>setup()</code> and <code>draw()</code></em></p>&#13;
<p class="indent">This sets the size of the window at 600 by 600 pixels, and sets the background color to white. Next we’ll create a nested loop, where two variables will both go from 0 to 19, for a total of 20 numbers, since we want 20 rows of 20 squares. <a href="ch05.xhtml#ch05list11">Listing 5-11</a> shows the code that creates the grid.</p>&#13;
<pre><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/><span class="pd_gray">    </span><span class="pd_blue1">size</span>(600,600)<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/><span class="pd_gray">    #set background white</span><br/><span class="pd_gray">    </span><span class="pd_blue1">background</span>(255)<br/><span class="pd_gray">    </span><span class="pd_lime">for</span> x <span class="pd_green1">in</span> <span class="pd_lime">range</span>(20):<br/><span class="pd_gray">        </span><span class="pd_lime">for</span> y <span class="pd_green1">in</span> <span class="pd_lime">range</span>(20):<br/><span class="pd_gray">        </span><span class="pd_gray">    </span><span class="pd_blue1">rect</span>(30*x,30*y,25,25)</pre>&#13;
<p class="listing" id="ch05list11"><em>Listing 5-11: The code for a grid</em></p>&#13;
<p class="indent">This should create a 20 × 20 grid of squares, as you can see in <a href="ch05.xhtml#ch05fig12">Figure 5-12</a>. Time to add some colors to our grid.</p>&#13;
<span epub:type="pagebreak" id="page_91"/>&#13;
<div class="image"><a id="ch05fig12"/><img alt="image" src="../images/f091-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-12: A 20 × 20 grid!</em></p>&#13;
<h4 class="h4" id="ch05_1_10">ADDING THE RAINBOW COLOR TO OBJECTS</h4>&#13;
<p class="noindent">Processing’s <code>colorMode()</code> function helps us add some cool color to our sketches! It’s used to switch between the RGB and HSB modes. Recall that RGB uses three numbers indicating amounts of red, green, and blue. In HSB, the three numbers represent levels of hue, saturation, and brightness. The only one we need to change here is the first number, which represents the hue. The other two numbers can be the maximum value, 255. <a href="ch05.xhtml#ch05fig13">Figure 5-13</a> shows how to make rainbow colors by changing only the first value, the hue. Here, the 10 squares have the hue values shown in the figure, with 255 for saturation and 255 for brightness.</p>&#13;
<div class="image"><a id="ch05fig13"/><img alt="image" src="../images/f091-02.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-13: The colors of the rainbow using HSB mode and changing the hue value</em></p>&#13;
<p class="indent">Since we’re locating the rectangles at <code>(30*x,30*y)</code> in <a href="ch05.xhtml#ch05list11">Listing 5-11</a>, we’ll create a variable that measures the distance of the mouse from that location:</p>&#13;
<pre>         d = <span class="pd_blue1">dist</span>(30*x,30*y,<span class="pd_raspberry">mouseX</span>,<span class="pd_raspberry">mouseY</span>)</pre>&#13;
<p class="indent">Processing has a <code>dist()</code> function that finds the distance between two points, and in this case it’s the distance between the square and the mouse. It saves the distance to a variable called <code>d</code>, and we’ll link the hue to that variable. <a href="ch05.xhtml#ch05list12">Listing 5-12</a> shows the changes to the code.</p>&#13;
<span epub:type="pagebreak" id="page_92"/>&#13;
<pre><span class="pd_g1"><em>colorGrid.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/><span class="pd_gray">    size(600,600)</span><br/><span class="pd_gray">    rectMode(CENTER)</span><br/>  <span class="ent">➊</span> <span class="pd_blue1">colorMode</span>(<span class="pd_olive">HSB</span>)<br/><br/><span class="pd_gray">def draw():</span><br/><span class="pd_gray">    #set background black</span><br/><span class="pd_gray">  </span><span class="ent">➋</span><span class="pd_gray"/> <span class="pd_blue1">background</span>(0)<br/><span class="pd_gray">    translate(20,20)</span><br/><span class="pd_gray">    for x in range(30):</span><br/><span class="pd_gray">        for y in range(30):</span><br/>          <span class="ent">➌</span> d = <span class="pd_blue1">dist</span>(30*x,30*y,<span class="pd_raspberry">mouseX</span>,<span class="pd_raspberry">mouseY</span>)<br/>            <span class="pd_blue1">fill</span>(0.5*d,255,255)<br/>            <span class="pd_blue1">rect</span>(30*x,30*y,25,25)</pre>&#13;
<p class="listing" id="ch05list12"><em>Listing 5-12: Using the <code>dist()</code> function</em></p>&#13;
<p class="indent">We insert the <code>colorMode()</code> function and pass <code>HSB</code> to it <span class="ent">➊</span>. In the <code>draw()</code> function, we set the background to black first <span class="ent">➋</span>. Then we calculate the distance from the mouse to the square, which is at <code>(30*x,30*y)</code> <span class="ent">➌</span>. In the next line, we set the fill color using HSB numbers. The hue value is half the distance, while the saturation and brightness numbers are both 255, the maximum.</p>&#13;
<p class="indent">The hue is the only thing we change: we update the hue according to the distance the rectangle is from the mouse. We do this with the <code>dist()</code> function, which takes four arguments: the x- and y-coordinates of two points. It returns the distance between the points.</p>&#13;
<p class="indent">Run this code and you should see a very colorful design that changes colors according to the mouse’s location, as shown in <a href="ch05.xhtml#ch05fig14">Figure 5-14</a>.</p>&#13;
<p class="indent">Now that you’ve learned how to add colors to your objects, let’s explore how we can create more complicated shapes.</p>&#13;
<div class="image"><a id="ch05fig14"/><img alt="image" src="../images/f092-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-14: Adding colors to your grid</em></p>&#13;
<h3 class="h3" id="ch05_6"><span epub:type="pagebreak" id="page_93"/>DRAWING COMPLEX PATTERNS USING TRIANGLES</h3>&#13;
<div class="image"><a id="ch05fig15"/><img alt="image" src="../images/f093-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-15: Sketch of 90 rotating equilateral triangles by Roger Antonsen. See it in motion at</em> <a href="https://rantonse.no/en/art/2016-11-30">https://rantonse.no/en/art/2016-11-30</a>.</p>&#13;
<p class="noindent">In this section, we create more complicated, Spirograph-style patterns using triangles. For example, take a look at the sketch made up of rotating triangles in <a href="ch05.xhtml#ch05fig15">Figure 5-15</a>, created by the University of Oslo’s Roger Antonsen.</p>&#13;
<p class="indent">The original design moves, but in this book you’ll have to imagine all the triangles rotating. This sketch blew me away! Although this design looks very complicated, it’s not that difficult to make. Remember Nasrudin’s joke about the brick from the beginning of the chapter? Like Nasrudin’s house, this complicated design is just a collection of identical shapes. But what shape? Antonsen gave us a helpful clue to creating this design when he named the sketch “90 Rotating Equilateral Triangles.” It tells us that all we have to do is figure out how to draw an equilateral triangle, rotate it, and then repeat that for a total of 90 triangles. Let’s first discuss how to draw an equilateral triangle using the <code>triangle()</code> function. To start, open a new Processing sketch and name it <em>triangles.pyde</em>. The code in <a href="ch05.xhtml#ch05list13">Listing 5-13</a> shows one way to create a rotating triangle but not an equilateral one.</p>&#13;
<pre><span class="pd_g1"><em>triangles.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_blue1">size</span>(600,600)<br/>    <span class="pd_blue1">rectMode</span>(<span class="pd_olive">CENTER</span>)<br/><br/>t = 0<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_green1">global</span> t<br/>    <span class="pd_blue1">translate</span>(<span class="pd_raspberry">width</span>/2,<span class="pd_raspberry">height</span>/2)<br/>    <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(t))<br/>    <span class="pd_blue1">triangle</span>(0,0,100,100,200,-200)<br/>    t += 0.5</pre>&#13;
<p class="listing" id="ch05list13"><em>Listing 5-13: Drawing a rotating triangle, but not the right kind</em></p>&#13;
<p class="indent">Listing 5-13 uses the lessons you learned previously: it creates a <code>t</code> variable (for time), translates to where we want the triangle to be, rotates the grid, and then draws the triangle. Finally, it increments <code>t</code>. When you run this code, you should see something like <a href="ch05.xhtml#ch05fig16">Figure 5-16</a>.</p>&#13;
<span epub:type="pagebreak" id="page_94"/>&#13;
<div class="image"><a id="ch05fig16"/><img alt="image" src="../images/f094-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-16: Rotating a triangle around one of its vertices</em></p>&#13;
<p class="indent">As you can see in <a href="ch05.xhtml#ch05fig16">Figure 5-16</a>, the triangle rotates around one of its <em>vertices</em>, or points, and thus creates a circle with the outer point. You’ll also notice that this is a right triangle (a triangle containing a 90-degree angle), not an equilateral one.</p>&#13;
<p class="indent">To re-create Antonsen’s sketch, we need to draw an equilateral triangle, which is a triangle with equal sides. We also need to find the center of the equilateral triangle to be able to rotate it about its center. To do this, we need to find the location of the three vertices of the triangle. Let’s discuss how to draw an equilateral triangle by locating it at its center and specifying the location of its vertices.</p>&#13;
<h4 class="h4" id="ch05_1_11">A 30-60-90 TRIANGLE</h4>&#13;
<div class="image"><a id="ch05fig17"/><img alt="image" src="../images/f094-02.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-17: An equilateral triangle divided into three equal parts</em></p>&#13;
<p class="noindent">To find the location of the three vertices of our equilateral triangle, we’ll review a particular type of triangle you’ve likely seen in geometry class: the <em>30-60-90 triangle</em>, which is a special <em>right triangle</em>. First, we need an equilateral triangle, as shown in <a href="ch05.xhtml#ch05fig17">Figure 5-17</a>.</p>&#13;
<p class="indent">This equilateral triangle is made up of three equal parts. The point in the middle is the center of the triangle, with the three dissecting lines meeting at 120 degree angles. To draw a triangle in Processing, we give the <code>triangle()</code> function six numbers: the x- and y-coordinates of all three vertices. To find the coordinates of the vertices of the equilateral triangle shown in <a href="ch05.xhtml#ch05fig17">Figure 5-17</a>, let’s cut the bottom triangle in half, as shown in <a href="ch05.xhtml#ch05fig18">Figure 5-18</a>.</p>&#13;
<span epub:type="pagebreak" id="page_95"/>&#13;
<div class="image"><a id="ch05fig18"/><img alt="image" src="../images/f095-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-18: Dividing up the equilateral triangle into special triangles</em></p>&#13;
<p class="indent">Dividing the bottom triangle in half creates two right triangles, which are classic 30-60-90 triangles. As you might recall, the ratio between the sides of a 30-60-90 triangle can be expressed as shown in <a href="ch05.xhtml#ch05fig19">Figure 5-19</a>.</p>&#13;
<div class="image"><a id="ch05fig19"/><img alt="image" src="../images/f095-02.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-19: The ratios of the sides in a 30-60-90 triangle, from the legend on an SAT test</em></p>&#13;
<p class="indent">If we call the length of the smaller leg <em>x</em>, the hypotenuse is twice that length, or 2<em>x</em>, and the longer leg is <em>x</em> times the square root of 3, or approximately 1.732<em>x</em>. We’re going to be creating our function using the length from the center of the big equilateral triangle in <a href="ch05.xhtml#ch05fig18">Figure 5-18</a> to one of its vertices, which happens to be the hypotenuse of the 30-60-90 triangle. That means we can measure everything in terms of that length. For example, if we call the hypotenuse <code>length</code>, then the smaller leg will be half that length, or <code>length/2</code>. Finally, the longer leg will be <code>length</code> divided by 2 times the square root of 3. <a href="ch05.xhtml#ch05fig20">Figure 5-20</a> zooms in on the 30-60-90 triangle.</p>&#13;
<div class="image"><a id="ch05fig20"/><img alt="image" src="../images/f095-03.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-20: The 30-60-90 triangle up close and personal</em></p>&#13;
<p class="indent">As you can see, a 30-60-90 triangle has internal angles of 30, 60, and 90 degrees, and the lengths of the sides are in known proportions. You may <span epub:type="pagebreak" id="page_96"/>be familiar with this from the Pythagorean Theorem, which will come up again shortly.</p>&#13;
<p class="indent">We’ll call the distance from the center of the larger equilateral triangle to its vertex the “length,” which is also the <em>hypotenuse</em> of the 30-60-90 triangle. You’ll need to know the ratios between the lengths of the sides of this special triangle in order to find the three vertices of the equilateral triangle with respect to the center—you can draw it (the big equilateral triangle we’re trying to draw) by specifying where each point of the triangle should be.</p>&#13;
<p class="indent">The shorter leg of the right triangle opposite the 30 degree angle is always half the hypotenuse, and the longer leg is the measure of the shorter leg times the square root of 3. So if we use the center point for drawing the big equilateral triangle, the coordinates of the three vertices would be as shown in <a href="ch05.xhtml#ch05fig21">Figure 5-21</a>.</p>&#13;
<div class="image"><a id="ch05fig21"/><img alt="image" src="../images/f096-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-21: The vertices of the equilateral triangle</em></p>&#13;
<p class="indent">As you can see, because this triangle is made up of 30-60-90 triangles on all sides, we can use the special relation between them to figure out how far each vertex of the equilateral triangle should be from the origin.</p>&#13;
<h4 class="h4" id="ch05_1_12">DRAWING AN EQUILATERAL TRIANGLE</h4>&#13;
<p class="noindent">Now we can use the vertices we derived from the 30-60-90 triangle to create an equilateral triangle, using the code in <a href="ch05.xhtml#ch05list14">Listing 5-14</a>.</p>&#13;
<pre><span class="pd_g1"><em>triangles.pyde</em></span><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_blue1">size</span>(600,600)<br/>    <span class="pd_blue1">rectMode</span>(<span class="pd_olive">CENTER</span>)<br/><br/>t = 0<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_green1">global</span> t<br/>    <span class="pd_blue1">translate</span>(<span class="pd_raspberry">width</span>/2,<span class="pd_raspberry">height</span>/2)<br/>    <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(t))<br/>    tri(200) <span class="pd_gray">#draw the equilateral triangle</span><br/>    t += 0.5<br/><br/><span class="ent">➊</span> <span class="pd_green1">def</span> tri(<span class="pd_green1">length</span>):<br/><span epub:type="pagebreak" id="page_97"/>&#13;
    <span class="pd_purple">'''Draws an equilateral triangle</span><br/>    <span class="pd_purple">around center of triangle'''</span><br/>    <span class="ent">➋</span> <span class="pd_blue1">triangle</span>(0,<span class="pd_green1">-length</span>,<br/>             <span class="pd_green1">-length</span>*<span class="pd_blue1">sqrt</span>(3)/2, <span class="pd_green1">length</span>/2,<br/>             <span class="pd_green1">length</span>*<span class="pd_blue1">sqrt</span>(3)/2, <span class="pd_green1">length</span>/2)</pre>&#13;
<p class="listing" id="ch05list14"><em>Listing 5-14: The complete code for making a rotating equilateral triangle</em></p>&#13;
<p class="indent">First, we write the <code>tri()</code> function to take the variable <code>length</code> <span class="ent">➊</span>, which is the hypotenuse of the special 30-60-90 triangles we cut the equilateral triangle into. We then make a triangle using the three vertices we found. Inside the call to the <code>triangle()</code> function <span class="ent">➋</span>, we specify the location of each of the three vertices of the triangle: <code>(0,-length)</code>, <code>(-length*sqrt(3)/2, length/2)</code>, and <code>(length*sqrt(3)/2, length/2)</code>.</p>&#13;
<p class="indent">When you run the code, you should see something like <a href="ch05.xhtml#ch05fig22">Figure 5-22</a>.</p>&#13;
<div class="image"><a id="ch05fig22"/><img alt="image" src="../images/f097-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-22: A rotating equilateral triangle!</em></p>&#13;
<p class="indent">Now we can cover up all the triangles created during rotation by adding this line to the beginning of the <code>draw()</code> function:</p>&#13;
<pre>    background(255) <span class="pd_gray">#white</span></pre>&#13;
<p class="indent">This should erase all the rotating triangles except for one, so we just have a single equilateral triangle on the screen. All we have to do is put 90 of them in a circle, just like we did earlier in this chapter, using the <code>rotate()</code> function.</p>&#13;
<div class="sidebar">&#13;
<p class="title">EXERCISE 5-1: SPIN CYCLE</p>&#13;
<p class="noindent">Create a circle of equilateral triangles in a Processing sketch and rotate them using the <code>rotate()</code> function.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch05_1_13"><span epub:type="pagebreak" id="page_98"/>DRAWING MULTIPLE ROTATING TRIANGLES</h4>&#13;
<p class="noindent">Now that you’ve learned how to rotate a single equilateral triangle, we need to figure out how to arrange multiple equilateral triangles into a circle. This is similar to what you created while rotating squares, but this time we’ll use our <code>tri()</code> function. Enter the code in <a href="ch05.xhtml#ch05list15">Listing 5-15</a> in place of the <code>def draw()</code> section in Processing and then run it.</p>&#13;
<pre><span class="pd_g1"><em>triangles.pyde</em></span><br/><span class="pd_gray">def setup():</span><br/><span class="pd_gray">    size(600,600)</span><br/><span class="pd_gray">    rectMode(CENTER)</span><br/><br/><span class="pd_gray">t = 0</span><br/><br/><span class="pd_gray">def draw():</span><br/><span class="pd_gray">    global t</span><br/><span class="pd_gray">    background(255)#white</span><br/><span class="pd_gray">    translate(width/2,height/2)</span><br/>  <span class="ent">➊</span> <span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(90):<br/><span class="pd_gray">        #space the triangles evenly</span><br/><span class="pd_gray">        </span><span class="pd_gray">#around the circle</span><br/>        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(360/90))<br/>      <span class="ent">➋</span> <span class="pd_blue1">pushMatrix</span>() <span class="pd_gray">#save this orientation</span><br/><span class="pd_gray">        #go to circumference of circle</span><br/>        <span class="pd_blue1">translate</span>(200,0)<br/><span class="pd_gray">        #spin each triangle</span><br/>        <span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(t))<br/><span class="pd_gray">        #draw the triangle</span><br/>        tri(100)<br/><span class="pd_gray">        #return to saved orientation</span><br/>    <span class="ent">➌</span> <span class="pd_blue1">popMatrix</span>()<br/>    t += 0.5<br/><br/><span class="pd_green1">def</span> tri(<span class="pd_green1">length</span>):<br/>  <span class="ent">➍</span> <span class="pd_blue1">noFill</span>() <span class="pd_gray">#makes the triangle transparent</span><br/><br/>    <span class="pd_blue1">triangle</span>(0,<span class="pd_green1">-length</span>,<br/>             <span class="pd_green1">-length</span>*<span class="pd_blue1">sqrt</span>(3)/2, <span class="pd_green1">length</span>/2,<br/>             <span class="pd_green1">length</span>*<span class="pd_blue1">sqrt</span>(3)/2, <span class="pd_green1">length</span>/2)</pre>&#13;
<p class="listing" id="ch05list15"><em>Listing 5-15: Creating 90 rotating triangles</em></p>&#13;
<p class="indent">At <span class="ent">➊</span>, we use the <code>for</code> loop to arrange 90 triangles around the circle, making sure they’re evenly spaced by dividing 360 by 90. Then at <span class="ent">➋</span> we use <code>pushMatrix()</code> to save this position before moving the grid around. At the end of the loop at <span class="ent">➌</span> we use <code>popMatrix()</code> to return to the saved position. In the <code>tri()</code> function at <span class="ent">➍</span>, we add the <code>noFill()</code> line to make the triangles transparent.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_99"/>Now we have 90 rotating transparent triangles, but they’re all rotating in exactly the same way. It’s kind of cool, but not as cool as Antonsen’s sketch yet. Next, you’ll learn how to make each triangle rotate a little differently from the adjacent ones to make the pattern more interesting.</p>&#13;
<h4 class="h4" id="ch05_1_14">PHASE-SHIFTING THE ROTATION</h4>&#13;
<p class="noindent">We can change the pattern in which the triangles rotate with a <em>phase shift</em>, which makes each triangle lag a little bit behind its neighbor, giving the sketch a “wave” or “cascade” effect. Each triangle has been assigned a number in the loop, represented by <code>i</code>. We need to add <code>i</code> to <code>t</code> in the <code>rotate(radians(t))</code> function, like this:</p>&#13;
<pre><span class="pd_gray">        </span><span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(t+i))</pre>&#13;
<p class="indent">When you run this, you should see something like <a href="ch05.xhtml#ch05fig23">Figure 5-23</a>.</p>&#13;
<div class="image"><a id="ch05fig23"/><img alt="image" src="../images/f099-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-23: Rotating triangles with phase shift</em></p>&#13;
<p class="indent">Notice there’s a break in the pattern on the right side of the screen. This break in the pattern is caused by the phase shifts not matching up from the beginning triangle to the last triangle. We want a nice, seamless pattern, so we have to make the phase shifts add up to a multiple of 360 degrees to complete the circle. Because there are 90 triangles in the design, we’ll divide 360 by 90 and multiply that by <code>i</code>:</p>&#13;
<pre><span class="pd_gray">        </span><span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(t+i*360/90))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_100"/>It’s easy enough to calculate 360/90, which is 4, and then use that number to plug into the code, but I’m leaving the expression in because we’ll need it in case we want to change the number of triangles later. For now, this should create a nice seamless pattern, as shown in <a href="ch05.xhtml#ch05fig24">Figure 5-24</a>.</p>&#13;
<div class="image"><a id="ch05fig24"/><img alt="image" src="../images/f100-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-24: Seamlessly rotating triangles with phase shift</em></p>&#13;
<p class="indent">By making our phase shifts add up to a multiple of 360, we were able to remove the break in the pattern.</p>&#13;
<h4 class="h4" id="ch05_1_15">FINALIZING THE DESIGN</h4>&#13;
<p class="noindent">To make the design look more like the one in <a href="ch05.xhtml#ch05fig15">Figure 5-15</a>, we need to change the phase shift a little. Play around with it yourself to see how you can change the look of the sketch!</p>&#13;
<p class="indent">Here, we’re going to change the phase shift by multiplying <code>i</code> by 2, which will increase the shift between each triangle and its neighbor. Change the <code>rotate()</code> line in your code to the following:</p>&#13;
<pre><span class="pd_gray">        </span><span class="pd_blue1">rotate</span>(<span class="pd_blue1">radians</span>(t+2*i*360/90))</pre>&#13;
<p class="indent">After making this change, run the code. As you can see in <a href="ch05.xhtml#ch05fig25">Figure 5-25</a>, our design now looks very close to the design we were trying to re-create.</p>&#13;
<span epub:type="pagebreak" id="page_101"/>&#13;
<div class="image"><a id="ch05fig25"/><img alt="image" src="../images/f101-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 5-25: Re-creation of Antonsen’s “90 Rotating Equilateral Triangles” from <a href="ch05.xhtml#ch05fig15">Figure 5-15</a></em></p>&#13;
<p class="indent">Now that you’ve learned how to re-create a complicated design like this, try the next exercise to test your transformation skills!</p>&#13;
<div class="sidebar">&#13;
<p class="title">EXERCISE 5-2: RAINBOW TRIANGLES</p>&#13;
<p class="noindent">Color each triangle of the rotating triangle sketch using <code>stroke()</code>. It should look like this.</p>&#13;
<div class="image"><img alt="image" src="../images/f101-02.jpg"/></div>&#13;
</div>&#13;
<h3 class="h3" id="ch05_7"><span epub:type="pagebreak" id="page_102"/>SUMMARY</h3>&#13;
<p class="noindent">In this chapter, you learned how to draw shapes like circles, squares, and triangles and arrange them into different patterns using Processing’s built-in transformation functions. You also learned how to make your shapes dynamic by animating your graphics and adding color. Just like how Nasrudin’s house was just a collection of bricks, the complicated code examples in this chapter are just a collection of simpler shapes or functions.</p>&#13;
<p class="indent">In the next chapter, you’ll build on what you learned in this chapter and expand your skills to using trigonometric functions like sine and cosine. You’ll draw even cooler designs and write new functions to create even more complicated behaviors, like leaving a trail and creating any shape from a bunch of vertices.</p>&#13;
</body></html>