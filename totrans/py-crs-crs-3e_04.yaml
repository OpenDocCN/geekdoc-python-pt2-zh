- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Ship That Fires Bullets
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s build a game called *Alien Invasion*! We’ll use Pygame, a collection of
    fun, powerful Python modules that manage graphics, animation, and even sound,
    making it easier for you to build sophisticated games. With Pygame handling tasks
    like drawing images to the screen, you can focus on the higher-level logic of
    game dynamics.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll set up Pygame and then create a rocket ship that moves
    right and left and fires bullets in response to player input. In the next two
    chapters, you’ll create a fleet of aliens to destroy, and then continue to refine
    the game by setting limits on the number of ships you can use and adding a scoreboard.
  prefs: []
  type: TYPE_NORMAL
- en: While building this game, you’ll also learn how to manage large projects that
    span multiple files. We’ll refactor a lot of code and manage file contents to
    organize the project and make the code efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Making games is an ideal way to have fun while learning a language. It’s deeply
    satisfying to play a game you wrote, and writing a simple game will teach you
    a lot about how professionals develop games. As you work through this chapter,
    enter and run the code to identify how each code block contributes to overall
    gameplay. Experiment with different values and settings to better understand how
    to refine interactions in your games.
  prefs: []
  type: TYPE_NORMAL
- en: Planning Your Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you’re building a large project, it’s important to prepare a plan before
    you begin to write code. Your plan will keep you focused and make it more likely
    that you’ll complete the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write a description of the general gameplay. Although the following description
    doesn’t cover every detail of *Alien Invasion*, it provides a clear idea of how
    to start building the game:'
  prefs: []
  type: TYPE_NORMAL
- en: In *Alien Invasion*, the player controls a rocket ship that appears at the bottom
    center of the screen. The player can move the ship right and left using the arrow
    keys and shoot bullets using the spacebar. When the game begins, a fleet of aliens
    fills the sky and moves across and down the screen. The player shoots and destroys
    the aliens. If the player destroys all the aliens, a new fleet appears that moves
    faster than the previous fleet. If any alien hits the player’s ship or reaches
    the bottom of the screen, the player loses a ship. If the player loses three ships,
    the game ends.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For the first development phase, we’ll make a ship that can move right and left
    when the player presses the arrow keys and fire bullets when the player presses
    the spacebar. After setting up this behavior, we can create the aliens and refine
    the gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Pygame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you begin coding, install Pygame. We’ll do this the same way we installed
    pytest in Chapter 11: with pip. If you skipped Chapter 11 or need a refresher
    on pip, see “Installing pytest with pip” on page 210.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Pygame, enter the following command at a terminal prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you use a command other than `python` to run programs or start a terminal
    session, such as `python3`, make sure you use that command instead.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the Game Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll begin building the game by creating an empty Pygame window. Later, we’ll
    draw the game elements, such as the ship and the aliens, on this window. We’ll
    also make our game respond to user input, set the background color, and load a
    ship image.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Pygame Window and Responding to User Input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll make an empty Pygame window by creating a class to represent the game.
    In your text editor, create a new file and save it as *alien_invasion.py*; then
    enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: First, we import the `sys` and `pygame` modules. The `pygame` module contains
    the functionality we need to make a game. We’ll use tools in the `sys` module
    to exit the game when the player quits.
  prefs: []
  type: TYPE_NORMAL
- en: '*Alien Invasion* starts as a class called `AlienInvasion`. In the `__init__()`
    method, the `pygame.init()` function initializes the background settings that
    Pygame needs to work properly ❶. Then we call `pygame.display.set_mode()` to create
    a display window ❷, on which we’ll draw all the game’s graphical elements. The
    argument `(1200, 800)` is a tuple that defines the dimensions of the game window,
    which will be 1,200 pixels wide by 800 pixels high. (You can adjust these values
    depending on your display size.) We assign this display window to the attribute
    `self.screen`, so it will be available in all methods in the class.'
  prefs: []
  type: TYPE_NORMAL
- en: The object we assigned to `self.screen` is called a surface. A *surface* in
    Pygame is a part of the screen where a game element can be displayed. Each element
    in the game, like an alien or a ship, is its own surface. The surface returned
    by `display.set_mode()` represents the entire game window. When we activate the
    game’s animation loop, this surface will be redrawn on every pass through the
    loop, so it can be updated with any changes triggered by user input.
  prefs: []
  type: TYPE_NORMAL
- en: The game is controlled by the `run_game()` method. This method contains a `while`
    loop ❸ that runs continually. The `while` loop contains an event loop and code
    that manages screen updates. An *event* is an action that the user performs while
    playing the game, such as pressing a key or moving the mouse. To make our program
    respond to events, we write an *event loop* to *listen* for events and perform
    appropriate tasks depending on the kinds of events that occur. The `for` loop
    ❹ nested inside the `while` loop is an event loop.
  prefs: []
  type: TYPE_NORMAL
- en: To access the events that Pygame detects, we’ll use the `pygame.event.get()`
    function. This function returns a list of events that have taken place since the
    last time this function was called. Any keyboard or mouse event will cause this
    `for` loop to run. Inside the loop, we’ll write a series of `if` statements to
    detect and respond to specific events. For example, when the player clicks the
    game window’s close button, a `pygame.QUIT` event is detected and we call `sys.exit()`
    to exit the game ❺.
  prefs: []
  type: TYPE_NORMAL
- en: The call to `pygame.display.flip()` ❻ tells Pygame to make the most recently
    drawn screen visible. In this case, it simply draws an empty screen on each pass
    through the `while` loop, erasing the old screen so only the new screen is visible.
    When we move the game elements around, `pygame.display.flip()` continually updates
    the display to show the new positions of game elements and hide the old ones,
    creating the illusion of smooth movement.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the file, we create an instance of the game and then call `run_game()`.
    We place `run_game()` in an `if` block that only runs if the file is called directly.
    When you run this *alien_invasion.py* file, you should see an empty Pygame window.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the Frame Rate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ideally, games should run at the same speed, or *frame rate*, on all systems.
    Controlling the frame rate of a game that can run on multiple systems is a complex
    issue, but Pygame offers a relatively simple way to accomplish this goal. We’ll
    make a clock, and ensure the clock ticks once on each pass through the main loop.
    Anytime the loop processes faster than the rate we define, Pygame will calculate
    the correct amount of time to pause so that the game runs at a consistent rate.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll define the clock in the `__init__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After initializing `pygame`, we create an instance of the class `Clock`, from
    the `pygame.time` module. Then we’ll make the clock tick at the end of the `while`
    loop in `run_game()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tick()` method takes one argument: the frame rate for the game. Here I’m
    using a value of 60, so Pygame will do its best to make the loop run exactly 60
    times per second.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting the Background Color
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pygame creates a black screen by default, but that’s boring. Let’s set a different
    background color. We’ll do this at the end of the `__init__()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Colors in Pygame are specified as RGB colors: a mix of red, green, and blue.
    Each color value can range from 0 to 255\. The color value `(255, 0, 0)` is red,
    `(0, 255, 0)` is green, and `(0, 0, 255)` is blue. You can mix different RGB values
    to create up to 16 million colors. The color value `(230, 230, 230)` mixes equal
    amounts of red, blue, and green, which produces a light gray background color.
    We assign this color to `self.bg_color` ❶.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We fill the screen with the background color using the `fill()` method ❷, which
    acts on a surface and takes only one argument: a color.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Settings Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each time we introduce new functionality into the game, we’ll typically create
    some new settings as well. Instead of adding settings throughout the code, let’s
    write a module called `settings` that contains a class called `Settings` to store
    all these values in one place. This approach allows us to work with just one `settings`
    object anytime we need to access an individual setting. This also makes it easier
    to modify the game’s appearance and behavior as our project grows. To modify the
    game, we’ll change the relevant values in *settings.py*, which we’ll create next,
    instead of searching for different settings throughout the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named *settings.py* inside your *alien_invasion* folder,
    and add this initial `Settings` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**settings.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To make an instance of `Settings` in the project and use it to access our settings,
    we need to modify *alien_invasion.py* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We import `Settings` into the main program file. Then we create an instance
    of `Settings` and assign it to `self.settings` ❶, after making the call to `pygame.init()`.
    When we create a screen ❷, we use the `screen_width` and `screen_height` attributes
    of `self.settings`, and then we use `self.settings` to access the background color
    when filling the screen ❸ as well.
  prefs: []
  type: TYPE_NORMAL
- en: When you run *alien_invasion.py* now you won’t yet see any changes, because
    all we’ve done is move the settings we were already using elsewhere. Now we’re
    ready to start adding new elements to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Ship Image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s add the ship to our game. To draw the player’s ship on the screen, we’ll
    load an image and then use the Pygame `blit()` method to draw the image.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re choosing artwork for your games, be sure to pay attention to licensing.
    The safest and cheapest way to start is to use freely licensed graphics that you
    can use and modify, from a website like [https://opengameart.org](https://opengameart.org).
  prefs: []
  type: TYPE_NORMAL
- en: You can use almost any type of image file in your game, but it’s easiest when
    you use a bitmap (*.bmp*) file because Pygame loads bitmaps by default. Although
    you can configure Pygame to use other file types, some file types depend on certain
    image libraries that must be installed on your computer. Most images you’ll find
    are in *.jpg* or *.png* formats, but you can convert them to bitmaps using tools
    like Photoshop, GIMP, and Paint.
  prefs: []
  type: TYPE_NORMAL
- en: Pay particular attention to the background color in your chosen image. Try to
    find a file with a transparent or solid background that you can replace with any
    background color, using an image editor. Your games will look best if the image’s
    background color matches your game’s background color. Alternatively, you can
    match your game’s background to the image’s background.
  prefs: []
  type: TYPE_NORMAL
- en: For *Alien Invasion*, you can use the file *ship.bmp* ([Figure 12-1](#figure12-1)),
    which is available in this book’s resources at [https://ehmatthes.github.io/pcc_3e](https://ehmatthes.github.io/pcc_3e).
    The file’s background color matches the settings we’re using in this project.
    Make a folder called *images* inside your main *alien_invasion* project folder.
    Save the file *ship.bmp* in the *images* folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c12/f12001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-1: The ship for *Alien Invasion*'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Ship Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After choosing an image for the ship, we need to display it on the screen.
    To use our ship, we’ll create a new `ship` module that will contain the class
    `Ship`. This class will manage most of the behavior of the player’s ship:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ship.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Pygame is efficient because it lets you treat all game elements like rectangles
    (*rects*), even if they’re not exactly shaped like rectangles. Treating an element
    as a rectangle is efficient because rectangles are simple geometric shapes. When
    Pygame needs to figure out whether two game elements have collided, for example,
    it can do this more quickly if it treats each object as a rectangle. This approach
    usually works well enough that no one playing the game will notice that we’re
    not working with the exact shape of each game element. We’ll treat the ship and
    the screen as rectangles in this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We import the `pygame` module before defining the class. The `__init__()` method
    of `Ship` takes two parameters: the `self` reference and a reference to the current
    instance of the `AlienInvasion` class. This will give `Ship` access to all the
    game resources defined in `AlienInvasion`. We then assign the screen to an attribute
    of `Ship` ❶, so we can access it easily in all the methods in this class. We access
    the screen’s `rect` attribute using the `get_rect()` method and assign it to `self.screen_rect`
    ❷. Doing so allows us to place the ship in the correct location on the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: To load the image, we call `pygame.image.load()` ❸ and give it the location
    of our ship image. This function returns a surface representing the ship, which
    we assign to `self.image`. When the image is loaded, we call `get_rect()` to access
    the ship surface’s `rect` attribute so we can later use it to place the ship.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re working with a `rect` object, you can use the *x*- and *y*-coordinates
    of the top, bottom, left, and right edges of the rectangle, as well as the center,
    to place the object. You can set any of these values to establish the current
    position of the `rect`. When you’re centering a game element, work with the `center`,
    `centerx`, or `centery` attributes of a `rect`. When you’re working at an edge
    of the screen, work with the `top`, `bottom`, `left`, or `right` attributes. There
    are also attributes that combine these properties, such as `midbottom`, `midtop`,
    `midleft`, and `midright`. When you’re adjusting the horizontal or vertical placement
    of the `rect`, you can just use the `x` and `y` attributes, which are the *x*-
    and *y*-coordinates of its top-left corner. These attributes spare you from having
    to do calculations that game developers formerly had to do manually, and you’ll
    use them often.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll position the ship at the bottom center of the screen. To do so, make the
    value of `self.rect.midbottom` match the `midbottom` attribute of the screen’s
    `rect` ❹. Pygame uses these `rect` attributes to position the ship image so it’s
    centered horizontally and aligned with the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we define the `blitme()` method ❺, which draws the image to the screen
    at the position specified by `self.rect`.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the Ship to the Screen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s update *alien_invasion.py* so it creates a ship and calls the ship’s
    `blitme()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We import `Ship` and then make an instance of `Ship` after the screen has been
    created ❶. The call to `Ship()` requires one argument: an instance of `AlienInvasion`.
    The `self` argument here refers to the current instance of `AlienInvasion`. This
    is the parameter that gives `Ship` access to the game’s resources, such as the
    `screen` object. We assign this `Ship` instance to `self.ship`.'
  prefs: []
  type: TYPE_NORMAL
- en: After filling the background, we draw the ship on the screen by calling `ship.blitme()`,
    so the ship appears on top of the background ❷.
  prefs: []
  type: TYPE_NORMAL
- en: When you run *alien_invasion.py* now, you should see an empty game screen with
    the rocket ship sitting at the bottom center, as shown in [Figure 12-2](#figure12-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c12/f12002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-2: *Alien Invasion* with the ship at the bottom center of the screen'
  prefs: []
  type: TYPE_NORMAL
- en: 'Refactoring: The _check_events() and _update_screen() Methods'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In large projects, you’ll often refactor code you’ve written before adding more
    code. Refactoring simplifies the structure of the code you’ve already written,
    making it easier to build on. In this section, we’ll break the `run_game()` method,
    which is getting lengthy, into two helper methods. A *helper method* does work
    inside a class but isn’t meant to be used by code outside the class. In Python,
    a single leading underscore indicates a helper method.
  prefs: []
  type: TYPE_NORMAL
- en: The _check_events() Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll move the code that manages events to a separate method called `_check_events()`.
    This will simplify `run_game()` and isolate the event management loop. Isolating
    the event loop allows you to manage events separately from other aspects of the
    game, such as updating the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the `AlienInvasion` class with the new `_check_events()` method, which
    only affects the code in `run_game()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We make a new `_check_events()` method ❷ and move the lines that check whether
    the player has clicked to close the window into this new method.
  prefs: []
  type: TYPE_NORMAL
- en: To call a method from within a class, use dot notation with the variable `self`
    and the name of the method ❶. We call the method from inside the `while` loop
    in `run_game()`.
  prefs: []
  type: TYPE_NORMAL
- en: The _update_screen() Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To further simplify `run_game()`, we’ll move the code for updating the screen
    to a separate method called `_update_screen()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We moved the code that draws the background and the ship and flips the screen
    to `_update_screen()`. Now the body of the main loop in `run_game()` is much simpler.
    It’s easy to see that we’re looking for new events, updating the screen, and ticking
    the clock on each pass through the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve already built a number of games, you’ll probably start out by breaking
    your code into methods like these. But if you’ve never tackled a project like
    this, you probably won’t know exactly how to structure your code at first. This
    approach gives you an idea of a realistic development process: you start out writing
    your code as simply as possible, and then refactor it as your project becomes
    more complex.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve restructured the code to make it easier to add to, we can work
    on the dynamic aspects of the game!
  prefs: []
  type: TYPE_NORMAL
- en: Piloting the Ship
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we’ll give the player the ability to move the ship right and left. We’ll
    write code that responds when the player presses the right or left arrow key.
    We’ll focus first on movement to the right, and then we’ll apply the same principles
    to control movement to the left. As we add this code, you’ll learn how to control
    the movement of images on the screen and respond to user input.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to a Keypress
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever the player presses a key, that keypress is registered in Pygame as
    an event. Each event is picked up by the `pygame.event.get()` method. We need
    to specify in our `_check_events()` method what kinds of events we want the game
    to check for. Each keypress is registered as a `KEYDOWN` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'When Pygame detects a `KEYDOWN` event, we need to check whether the key that
    was pressed is one that triggers a certain action. For example, if the player
    presses the right arrow key, we want to increase the ship’s `rect.x` value to
    move the ship to the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Inside `_check_events()` we add an `elif` block to the event loop, to respond
    when Pygame detects a `KEYDOWN` event ❶. We check whether the key pressed, `event.key`,
    is the right arrow key ❷. The right arrow key is represented by `pygame.K_RIGHT`.
    If the right arrow key was pressed, we move the ship to the right by increasing
    the value of `self.ship.rect.x` by 1 ❸.
  prefs: []
  type: TYPE_NORMAL
- en: When you run *alien_invasion.py* now, the ship should move to the right one
    pixel every time you press the right arrow key. That’s a start, but it’s not an
    efficient way to control the ship. Let’s improve this control by allowing continuous
    movement.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing Continuous Movement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the player holds down the right arrow key, we want the ship to continue
    moving right until the player releases the key. We’ll have the game detect a `pygame.KEYUP`
    event so we’ll know when the right arrow key is released; then we’ll use the `KEYDOWN`
    and `KEYUP` events together with a flag called `moving_right` to implement continuous
    motion.
  prefs: []
  type: TYPE_NORMAL
- en: When the `moving_right` flag is `False`, the ship will be motionless. When the
    player presses the right arrow key, we’ll set the flag to `True`, and when the
    player releases the key, we’ll set the flag to `False` again.
  prefs: []
  type: TYPE_NORMAL
- en: The `Ship` class controls all attributes of the ship, so we’ll give it an attribute
    called `moving_right` and an `update()` method to check the status of the `moving_right`
    flag. The `update()` method will change the position of the ship if the flag is
    set to `True`. We’ll call this method once on each pass through the `while` loop
    to update the position of the ship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the changes to `Ship`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ship.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We add a `self.moving_right` attribute in the `__init__()` method and set it
    to `False` initially ❶. Then we add `update()`, which moves the ship right if
    the flag is `True` ❷. The `update()` method will be called from outside the class,
    so it’s not considered a helper method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to modify `_check_events()` so that `moving_right` is set to `True`
    when the right arrow key is pressed and `False` when the key is released:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we modify how the game responds when the player presses the right arrow
    key: instead of changing the ship’s position directly, we merely set `moving_right`
    to `True` ❶. Then we add a new `elif` block, which responds to `KEYUP` events
    ❷. When the player releases the right arrow key (`K_RIGHT`), we set `moving_right`
    to `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we modify the `while` loop in `run_game()` so it calls the ship’s `update()`
    method on each pass through the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The ship’s position will be updated after we’ve checked for keyboard events
    and before we update the screen. This allows the ship’s position to be updated
    in response to player input and ensures the updated position will be used when
    drawing the ship to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: When you run *alien_invasion.py* and hold down the right arrow key, the ship
    should move continuously to the right until you release the key.
  prefs: []
  type: TYPE_NORMAL
- en: Moving Both Left and Right
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that the ship can move continuously to the right, adding movement to the
    left is straightforward. Again, we’ll modify the `Ship` class and the `_check_events()`
    method. Here are the relevant changes to `__init__()` and `update()` in `Ship`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ship.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In `__init__()`, we add a `self.moving_left` flag. In `update()`, we use two
    separate `if` blocks, rather than an `elif`, to allow the ship’s `rect.x` value
    to be increased and then decreased when both arrow keys are held down. This results
    in the ship standing still. If we used `elif` for motion to the left, the right
    arrow key would always have priority. Using two `if` blocks makes the movements
    more accurate when the player might momentarily hold down both keys when changing
    directions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to make two additions to `_check_events()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If a `KEYDOWN` event occurs for the `K_LEFT` key, we set `moving_left` to `True`.
    If a `KEYUP` event occurs for the `K_LEFT` key, we set `moving_left` to `False`.
    We can use `elif` blocks here because each event is connected to only one key.
    If the player presses both keys at once, two separate events will be detected.
  prefs: []
  type: TYPE_NORMAL
- en: When you run *alien_invasion.py* now, you should be able to move the ship continuously
    to the right and left. If you hold down both keys, the ship should stop moving.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll further refine the ship’s movement. Let’s adjust the ship’s speed
    and limit how far the ship can move so it can’t disappear off the sides of the
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the Ship’s Speed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Currently, the ship moves one pixel per cycle through the `while` loop, but
    we can take finer control of the ship’s speed by adding a `ship_speed` attribute
    to the `Settings` class. We’ll use this attribute to determine how far to move
    the ship on each pass through the loop. Here’s the new attribute in *settings.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**settings.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We set the initial value of `ship_speed` to `1.5`. When the ship moves now,
    its position is adjusted by 1.5 pixels (rather than 1 pixel) on each pass through
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re using a float for the speed setting to give us finer control of the ship’s
    speed when we increase the tempo of the game later on. However, `rect` attributes
    such as `x` store only integer values, so we need to make some modifications to
    `Ship`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ship.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We create a `settings` attribute for `Ship`, so we can use it in `update()`
    ❶. Because we’re adjusting the position of the ship by fractions of a pixel, we
    need to assign the position to a variable that can have a float assigned to it.
    You can use a float to set an attribute of a `rect`, but the `rect` will only
    keep the integer portion of that value. To keep track of the ship’s position accurately,
    we define a new `self.x` ❷. We use the `float()` function to convert the value
    of `self.rect.x` to a float and assign this value to `self.x`.
  prefs: []
  type: TYPE_NORMAL
- en: Now when we change the ship’s position in `update()`, the value of `self.x`
    is adjusted by the amount stored in `settings.ship_speed` ❸. After `self.x` has
    been updated, we use the new value to update `self.rect.x`, which controls the
    position of the ship ❹. Only the integer portion of `self.x` will be assigned
    to `self.rect.x`, but that’s fine for displaying the ship.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can change the value of `ship_speed`, and any value greater than 1 will
    make the ship move faster. This will help make the ship respond quickly enough
    to shoot down aliens, and it will let us change the tempo of the game as the player
    progresses in gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the Ship’s Range
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At this point, the ship will disappear off either edge of the screen if you
    hold down an arrow key long enough. Let’s correct this so the ship stops moving
    when it reaches the screen’s edge. We do this by modifying the `update()` method
    in `Ship`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ship.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This code checks the position of the ship before changing the value of `self.x`.
    The code `self.rect.right` returns the *x*-coordinate of the right edge of the
    ship’s `rect`. If this value is less than the value returned by `self.screen_rect.right`,
    the ship hasn’t reached the right edge of the screen ❶. The same goes for the
    left edge: if the value of the left side of the `rect` is greater than 0, the
    ship hasn’t reached the left edge of the screen ❷. This ensures the ship is within
    these bounds before adjusting the value of `self.x`.'
  prefs: []
  type: TYPE_NORMAL
- en: When you run *alien_invasion.py* now, the ship should stop moving at either
    edge of the screen. This is pretty cool; all we’ve done is add a conditional test
    in an `if` statement, but it feels like the ship hits a wall or force field at
    either edge of the screen!
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring _check_events()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `_check_events()` method will increase in length as we continue to develop
    the game, so let’s break `_check_events()` into two separate methods: one that
    handles `KEYDOWN` events and another that handles `KEYUP` events:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We make two new helper methods: `_check_keydown_events()` and `_check_keyup_events()`.
    Each needs a `self` parameter and an `event` parameter. The bodies of these two
    methods are copied from `_check_events()`, and we’ve replaced the old code with
    calls to the new methods. The `_check_events()` method is simpler now with this
    cleaner code structure, which will make it easier to develop further responses
    to player input.'
  prefs: []
  type: TYPE_NORMAL
- en: Pressing Q to Quit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we’re responding to keypresses efficiently, we can add another way
    to quit the game. It gets tedious to click the X at the top of the game window
    to end the game every time you test a new feature, so we’ll add a keyboard shortcut
    to end the game when the player presses Q:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In `_check_keydown_events()`, we add a new block that ends the game when the
    player presses Q. Now, when testing, you can press Q to close the game instead
    of using your cursor to close the window.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Game in Fullscreen Mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pygame has a fullscreen mode that you might like better than running the game
    in a regular window. Some games look better in fullscreen mode, and on some systems,
    the game may perform better overall in fullscreen mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the game in fullscreen mode, make the following changes in `__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alien_invasion.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When creating the screen surface, we pass a size of `(0, 0)` and the parameter
    `pygame.FULLSCREEN` ❶. This tells Pygame to figure out a window size that will
    fill the screen. Because we don’t know the width and height of the screen ahead
    of time, we update these settings after the screen is created ❷. We use the `width`
    and `height` attributes of the screen’s `rect` to update the `settings` object.
  prefs: []
  type: TYPE_NORMAL
- en: If you like how the game looks or behaves in fullscreen mode, keep these settings.
    If you liked the game better in its own window, you can revert back to the original
    approach where we set a specific screen size for the game.
  prefs: []
  type: TYPE_NORMAL
- en: A Quick Recap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the next section, we’ll add the ability to shoot bullets, which involves
    adding a new file called *bullet.py* and making some modifications to some of
    the files we’re already using. Right now, we have three files containing a number
    of classes and methods. To be clear about how the project is organized, let’s
    review each of these files before adding more functionality.
  prefs: []
  type: TYPE_NORMAL
- en: alien_invasion.py
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main file, *alien_invasion.py*, contains the `AlienInvasion` class. This
    class creates a number of important attributes used throughout the game: the settings
    are assigned to `settings`, the main display surface is assigned to `screen`,
    and a `ship` instance is created in this file as well. The main loop of the game,
    a `while` loop, is also stored in this module. The `while` loop calls `_check_events()`,
    `ship.update()`, and `_update_screen()`. It also ticks the clock on each pass
    through the loop.'
  prefs: []
  type: TYPE_NORMAL
- en: The `_check_events()` method detects relevant events, such as keypresses and
    releases, and processes each of these types of events through the methods `_check_keydown_events()`
    and `_check_keyup_events()`. For now, these methods manage the ship’s movement.
    The `AlienInvasion` class also contains `_update_screen()`, which redraws the
    screen on each pass through the main loop.
  prefs: []
  type: TYPE_NORMAL
- en: The *alien_invasion.py* file is the only file you need to run when you want
    to play *Alien Invasion*. The other files, *settings.py* and *ship.py*, contain
    code that is imported into this file.
  prefs: []
  type: TYPE_NORMAL
- en: settings.py
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *settings.py* file contains the `Settings` class. This class only has an
    `__init__()` method, which initializes attributes controlling the game’s appearance
    and the ship’s speed.
  prefs: []
  type: TYPE_NORMAL
- en: ship.py
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *ship.py* file contains the `Ship` class. The `Ship` class has an `__init__()`
    method, an `update()` method to manage the ship’s position, and a `blitme()` method
    to draw the ship to the screen. The image of the ship is stored in *ship.bmp*,
    which is in the *images* folder.
  prefs: []
  type: TYPE_NORMAL
- en: Shooting Bullets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s add the ability to shoot bullets. We’ll write code that fires a bullet,
    which is represented by a small rectangle, when the player presses the spacebar.
    Bullets will then travel straight up the screen until they disappear off the top
    of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Bullet Settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the end of the `__init__()` method, we’ll update *settings.py* to include
    the values we’ll need for a new `Bullet` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**settings.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: These settings create dark gray bullets with a width of `3` pixels and a height
    of `15` pixels. The bullets will travel slightly faster than the ship.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Bullet Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now create a *bullet.py* file to store our `Bullet` class. Here’s the first
    part of *bullet.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**bullet.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `Bullet` class inherits from `Sprite`, which we import from the `pygame.sprite`
    module. When you use sprites, you can group related elements in your game and
    act on all the grouped elements at once. To create a bullet instance, `__init__()`
    needs the current instance of `AlienInvasion`, and we call ``super() to inherit
    properly from `Sprite`. We also set attributes for the screen and settings objects,
    and for the bullet’s color.``
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25] def update(self):     """Move the bullet up the screen."""     # Update
    the exact position of the bullet. ❶     self.y -= self.settings.bullet_speed     #
    Update the rect position. ❷     self.rect.y = self.y  def draw_bullet(self):     """Draw
    the bullet to the screen.""" ❸     pygame.draw.rect(self.screen, self.color, self.rect)
    [PRE26] *--snip--* from ship import Ship from bullet import Bullet [PRE27]  def
    __init__(self):   *--snip--*  self.ship = Ship(self)   self.bullets = pygame.sprite.Group()
    [PRE28]  def run_game(self):  """Start the main loop for the game."""  while True:  self._check_events()  self.ship.update()   self.bullets.update()  self._update_screen()  self.clock.tick(60)
    [PRE29]  def _check_keydown_events(self, event):   *--snip--*  elif event.key
    == pygame.K_q:  sys.exit() ❶         elif event.key == pygame.K_SPACE:             self._fire_bullet()   def
    _check_keyup_events(self, event):   *--snip--*      def _fire_bullet(self):         """Create
    a new bullet and add it to the bullets group.""" ❷         new_bullet = Bullet(self)
    ❸         self.bullets.add(new_bullet)   def _update_screen(self):  """Update
    images on the screen, and flip to the new screen."""  self.screen.fill(self.settings.bg_color)
    ❹       for bullet in self.bullets.sprites():             bullet.draw_bullet()  self.ship.blitme()   pygame.display.flip()
    *--snip--* [PRE30]  def run_game(self):  """Start the main loop for the game."""  while
    True:  self._check_events()  self.ship.update()  self.bullets.update()              #
    Get rid of bullets that have disappeared. ❶             for bullet in self.bullets.copy():
    ❷                 if bullet.rect.bottom <= 0: ❸                     self.bullets.remove(bullet)
    ❹             print(len(self.bullets))   self._update_screen()  self.clock.tick(60)
    [PRE31]  # Bullet settings   *--snip--*  self.bullet_color = (60, 60, 60)   self.bullets_allowed
    = 3 [PRE32]  def _fire_bullet(self):  """Create a new bullet and add it to the
    bullets group."""   if len(self.bullets) < self.settings.bullets_allowed:  new_bullet
    = Bullet(self)  self.bullets.add(new_bullet) [PRE33]  def _update_bullets(self):         """Update
    position of bullets and get rid of old bullets."""         # Update bullet positions.  self.bullets.update()   #
    Get rid of bullets that have disappeared.  for bullet in self.bullets.copy():  if
    bullet.rect.bottom <= 0:  self.bullets.remove(bullet) [PRE34]  while True:  self._check_events()  self.ship.update()   self._update_bullets()  self._update_screen()  self.clock.tick(60)
    [PRE35]`'
  prefs: []
  type: TYPE_NORMAL
