["```py\nclass Collection:\n\n    def __init__(self, title, page_start, length=1):\n        self.title = title\n        self.page_start = page_start\n self.page_end = page_start + length – 1\n        self.items = []\n\n    def __str__(self):\n        return self.title\n\n    def expand(self, by):\n        self.page_end += by\n\n    def add_item(self, bullet, note, signifier=None):\n        \"\"\"Adds an item to the monthly log.\"\"\"\n```", "```py\nclass MonthlyLog(Collection):\n\n    def __init__(self, month, year, page_start, length=2):\n        ❶ super().__init__( ❷ f\"{month} {year}\", page_start, length)\n        self.events = []\n\n    def __str__(self):\n        return f\"{ ❸ self.title} (Monthly Log)\"\n\n    def add_event(self, event, date=None):\n        \"\"\"Logs an event for the given date (today by default).\"\"\"\n```", "```py\nclass FutureLog(Collection):\n\n    def __init__(self, start_month, page_start):\n        super().__init__(\"Future Log\", page_start, 4)\n        self.start = start_month\n        self.months = [start_month]  # TODO: Add other five months.\n\n    def add_item(self, bullet, note, signifier=None, month=None):\n        \"\"\"Adds an item to the future log for the given month.\"\"\"\n```", "```py\nprint(issubclass(FutureLog, Collection))  # prints True\n```", "```py\nlog = FutureLog('May 2023', 5)\nlog.add_item('June 2023', '.', 'Clean mechanical keyboard')\nprint(log)      # prints \"Future Log\"\n\nmonthly = MonthlyLog('April', '2023', 9)\nmonthly.add_event('Finally learned Python inheritance!')\nmonthly.add_item('.', 'Email Ben re: coffee meeting')\nprint(monthly)  # prints \"April 2023 (Monthly Log)\"\n\nto_read = Collection(\"Books to Read\", 17)\nto_read.add_item('.', 'Anne of Avonlea')\nprint(to_read)  # prints \"Books to Read\"\n```", "```py\nclass Food:\n    def __str__(self):\n        return \"Yum, what is it?\"\n\nclass Pizza(Food):\n    def __str__(self):\n        return \"Piiiizzaaaaaa\"\n\nclass Sandwich(Food):\n    def __str__(self):\n        return \"Mmm, sammich.\"\n\nclass Calzone(Pizza, Sandwich):\n    pass\n```", "```py\ncalzone = Calzone()\nprint(calzone)  # What gets printed??\n```", "```py\nL[Food] = Food, object\n```", "```py\nL[Pizza] = merge(Pizza, {Food, object})\n```", "```py\nL[Pizza] = merge(`Pizza`, {Food, object})\n```", "```py\nL[Pizza] = **Pizza** + merge({`Food`, object})\n```", "```py\nL[Pizza] = Pizza + **Food** + merge({`object`})\n```", "```py\nL[Pizza] = Pizza + Food + **object**\n```", "```py\nL[Sandwich]: Sandwich + Food + object\n```", "```py\nL[Calzone] = merge(\n    Calzone,\n    {Pizza, Food, object},\n    {Sandwich, Food, object}\n)\n```", "```py\nL[Calzone] = merge(\n    `Calzone`,\n    {Pizza, Food, object},\n    {Sandwich, Food, object}\n)\n```", "```py\nL[Calzone] = **Calzone** + merge(\n    {`Pizza`, Food, object},\n    {Sandwich, Food, object}\n)\n```", "```py\nL[Calzone] = Calzone + **Pizza** + merge(\n    {*Food*, object},\n    {Sandwich, `Food`, object}\n)\n```", "```py\nL[Calzone] = Calzone + Pizza + merge(\n    {Food, object},\n    {`Sandwich`, Food, object}\n)\n```", "```py\nL[Calzone] = Calzone + Pizza + **Sandwich** + merge(\n    {`Food`, object},\n    {`Food`, object}\n)\n```", "```py\nL[Calzone] = Calzone + Pizza + Sandwich + **Food** + merge(\n    {`object`},\n    {`object`}\n)\n```", "```py\nL[Calzone] = Calzone + Pizza + Sandwich + Food + **object**\n```", "```py\ncalzone = Calzone()\nprint(calzone)  # What gets printed??\n```", "```py\nPiiiizzaaaaaa\n```", "```py\nclass PizzaSandwich(Sandwich, Pizza):\n    pass\n\nclass CalzonePizzaSandwich(Calzone, PizzaSandwich):\n    pass\n```", "```py\nL[PizzaSandwich] = PizzaSandwich + Sandwich + Pizza + Food + object\n```", "```py\nL[CalzonePizzaSandwich] = merge(\n    `CalzonePizzaSandwich`,\n    {Calzone, Pizza, Sandwich, Food, object},\n    {PizzaSandwich, Sandwich, Pizza, Food, object}\n)\n```", "```py\nL[CalzonePizzaSandwich] = **CalzonePizzaSandwich** + merge(\n    {`Calzone`, Pizza, Sandwich, Food, object},\n    {PizzaSandwich, Sandwich, Pizza, Food, object}\n)\n```", "```py\nL[CalzonePizzaSandwich] = CalzonePizzaSandwich + **Calzone** + merge(\n    {`Pizza`, Sandwich, Food, object},\n    {PizzaSandwich, Sandwich, `Pizza`, Food, object}\n)\n```", "```py\nL[CalzonePizzaSandwich] = CalzonePizzaSandwich + Calzone + merge(\n    {Pizza, Sandwich, Food, object},\n    {`PizzaSandwich`, Sandwich, Pizza, Food, object}\n)\n```", "```py\nL[CalzonePizzaSandwich] = CalzonePizzaSandwich + Calzone + **PizzaSandwich** + merge(\n    {`Pizza`, Sandwich, Food, object},\n    {Sandwich, `Pizza`, Food, object}\n)\n```", "```py\nL[CalzonePizzaSandwich] = CalzonePizzaSandwich + Calzone + PizzaSandwich + merge(\n    {Pizza, `Sandwich`, Food, object},\n    {`Sandwich`, Pizza, Food, object}\n)\n```", "```py\nTypeError: Cannot create a consistent method resolution\n```", "```py\nclass PizzaSandwich(**Pizza**, **Sandwich**):\n    pass\n\nclass CalzonePizzaSandwich(Calzone, PizzaSandwich):\n    pass\n```", "```py\nL[CalzonePizzaSandwich] = merge(\n    *CalzonePizzaSandwich*,\n    {Calzone, Pizza, Sandwich, Food, object},\n    {PizzaSandwich, Pizza, Sandwich, Food, object}\n)\n\nL[CalzonePizzaSandwich] = **CalzonePizzaSandwich** + merge(\n    {`Calzone`, Pizza, Sandwich, Food, object},\n    {PizzaSandwich, Pizza, Sandwich, Food, object}\n)\n\nL[CalzonePizzaSandwich] = CalzonePizzaSandwich + **Calzone** + merge(\n    {`Pizza`, Sandwich, Food, object},\n    {PizzaSandwich, `Pizza`, Sandwich, Food, object}\n)\n\nL[CalzonePizzaSandwich] = CalzonePizzaSandwich + Calzone + merge(\n    {Pizza, Sandwich, Food, object},\n    {`PizzaSandwich`, Pizza, Sandwich, Food, object}\n)\n\nL[CalzonePizzaSandwich] = CalzonePizzaSandwich + Calzone + **PizzaSandwich** + merge(\n    {`Pizza`, Sandwich, Food, object},\n    {`Pizza`, Sandwich, Food, object}\n)\n\nL[CalzonePizzaSandwich] = CalzonePizzaSandwich + Calzone + PizzaSandwich + **Pizza** + merge(\n    {`Sandwich`, Food, object},\n    {`Sandwich`, Food, object}\n)\n\nL[CalzonePizzaSandwich] = CalzonePizzaSandwich + Calzone + PizzaSandwich + Pizza + **Sandwich** + merge(\n    {`Food`, object},\n    {`Food`, object}\n)\n\nL[CalzonePizzaSandwich] = CalzonePizzaSandwich + Calzone + PizzaSandwich + Pizza + Sandwich + **Food** + merge(\n    {`object`},\n    {`object`}\n)\n\nL[CalzonePizzaSandwich] = CalzonePizzaSandwich + Calzone + PizzaSandwich + Pizza + Sandwich + Food + **object**\n```", "```py\nclass PizzaSandwich(Pizza, Sandwich):\n    pass\n\nclass CalzonePizzaSandwich(Calzone, PizzaSandwich):\n    **def __str__(self):**\n **return Calzone.__str__(self)**\n```", "```py\nclass Food:\n    def __init__(self, ❶ name):\n        self.name = name\n\nclass Pizza(Food):\n    def __init__(self, toppings):\n        super().__init__(\"Pizza\")\n        self.toppings = toppings\n\nclass Sandwich(Food):\n    def __init__(self, bread, fillings):\n        super().__init__(\"Sandwich\")\n        self.bread = bread\n        self.fillings = fillings\n```", "```py\nclass Calzone(Pizza, Sandwich):\n    def __init__(self, toppings):\n        super().__init__(toppings)\n        # what about Sandwich.__init__??\n\n# The usage...\npizza = Pizza(toppings=\"pepperoni\")\nsandwich = Sandwich(bread=\"rye\", fillings=\"swiss\")\ncalzone = Calzone(\"sausage\")  # TypeError: __init__() missing 1 required positional argument: 'fillings'\n```", "```py\nclass Calzone(Pizza, Sandwich):\n    def __init__(self, toppings):\n        **Pizza.__init__(self, toppings)**\n        **Sandwich.__init__(self, 'pizza crust', toppings)**\n\n# The usage...\npizza = Pizza(toppings=\"pepperoni\")\nsandwich = Sandwich(bread=\"rye\", fillings=\"swiss\")\ncalzone = Calzone(\"sausage\")\n```", "```py\nclass Food:\n    def __init__(self, name):\n        self.name = name\n\nclass Pizza(Food):\n    **def __init__(self, toppings, name=\"Pizza\", **kwargs):**\n **super().__init__(name=name, **kwargs)**\n        self.toppings = toppings\n\nclass Sandwich(Food):\n    **def __init__(self, bread, fillings, name=\"Sandwich\", **kwargs):**\n        **super().__init__(name=name, **kwargs)**\n        self.bread = bread\n        self.fillings = fillings\n```", "```py\nclass Calzone(Pizza, Sandwich):\n    def __init__(self, toppings):\n        **super().__init__(**\n **toppings=toppings,**\n **bread='pizza crust',**\n **fillings=toppings,**\n **name='Calzone'**\n **)**\n **# The usage...\npizza = Pizza(toppings=\"pepperoni\")\nsandwich = Sandwich(bread=\"rye\", fillings=\"swiss\")\ncalzone = Calzone(\"sausage\")**\n```", "```py\n[MAGIC]\nUserName = Jason\nMagicNumber = 42\n```", "```py\nimport configparser\nfrom pathlib import Path\n\nclass SettingsFileMixin:\n\n    settings_path = Path('livesettings.ini')\n    config = configparser.ConfigParser()\n\n    def read_setting(self, key):\n        self.config.read(self.settings_path)\n        try:\n            return self.config[self.settings_section][key]\n        except KeyError:\n            raise KeyError(\"Invalid section in settings file.\")\n```", "```py\nclass Greeter(SettingsFileMixin):\n\n    def __init__(self, greeting):\n        self.settings_section = 'MAGIC'\n        self.greeting = greeting\n\n    def __str__(self):\n        try:\n            name = self.read_setting('UserName')\n        except KeyError:\n            name = \"user\"\n        return f\"{self.greeting} {name}!\"\n```", "```py\nclass MagicNumberPrinter(SettingsFileMixin):\n\n    def __init__(self, greeting):\n        self.settings_section = 'MAGIC'\n\n    def __str__(self):\n        try:\n            magic_number = self.read_setting('MagicNumber')\n        except KeyError:\n            magic_number = \"unknown\"\n        return f\"The magic number is {magic_number}!\"\n```", "```py\ngreeter = Greeter(\"Salutations,\")\nfor i in range(100000):\n    print(greeter)\n```", "```py\n`# --snip--`\nSalutations, Jason!\nSalutations, Jason!\nSalutations, Jason!\nSalutations, Bob!\nSalutations, Bob!\nSalutations, Bob!\n`# --snip--`\n```", "```py\nprint(type(\"Hello\"))    # prints \"<class 'str'>\"\nprint(type(123))        # prints \"<class 'int'>\"\n\nclass Thing: pass\nprint(type(Thing))      # prints \"<class 'type'>\"\n\nsomething = Thing()\nprint(type(something))  # prints \"<class '__main__.Thing'>\"\n\nprint(type(type))       # prints \"<class 'type'>\"\n```", "```py\nFood = type('Food', (), {})\n```", "```py\nclass Food: pass\n```", "```py\ndef __init__(obj, toppings):\n    obj.toppings = toppings\n\nPizza = type( ❶ 'Pizza', ❷ (Food,), ❸ {'name':'pizza', '__init__':__init__})\n```", "```py\nclass Pizza(Food):\n    name = pizza\n\n    def __init__(self):\n        self.toppings = toppings\n```", "```py\nprint(Pizza.name)                     # 'name' is a class attribute\npizza = Pizza(['sausage', 'garlic'])  # instantiate like normal\nprint(pizza.toppings)                 # prints \"['sausage', 'garlic']\"\n```", "```py\nclass Gadget(type):\n\n    def __new__(self, name, bases, namespace):\n        print(f\"Creating a {name} gadget!\")\n        return super().__new__(self, name, bases, namespace)\n```", "```py\n @classmethod\n    def __prepare__(cls, name, bases):\n        return {'color': 'white'}\n```", "```py\nclass Thingamajig(metaclass=Gadget):\n    def __init__(self, widget):\n        self.widget = widget\n\n    def frob(self):\n        print(f\"Frobbing {self.widget}.\")\n```", "```py\nthing = Thingamajig(\"button\")  # also prints \"Creating Thingamajig gadget!\"\nthing.frob()                   # prints \"Frobbing button.\"\n\nprint(Thingamajig.color)       # prints \"white\"\nprint(thing.__class__)         # prints \"<class '__main__.Thingamajig'>\"\n```", "```py\ndef product_of_thirds(sequence):\n    if not ❶ hasattr(sequence, '__iter__'):\n        raise ValueError(\"Argument must be iterable.\")\n\n r = sequence[0]\n    for i in sequence[1::3]:\n        r *= i\n    return r\n\nprint(product_of_thirds(range(1, 50)))  # prints '262134882788466688000'\nprint(product_of_thirds(False))         # raises TypeError\n```", "```py\nclass Nonsense:\n    def __init__(self):\n        self.__iter__ = self\n```", "```py\ndef product_of_thirds(sequence):\n    if **(**\n        not hasattr(sequence, '__iter__')\n        **or not hasattr(sequence, '__getitem__'**\n    **)**:\n        raise TypeError(\"Argument must be iterable.\")\n **elif not hasattr(sequence[0], '__mul__'):**\n **raise TypeError(\"Sequence elements must support multiplication.\")**\n\n    r = sequence[0]\n    for i in sequence[1::3]:\n        r *= i\n    return r\n\n# `--snip--`\n\nprint(product_of_thirds(range(1, 50)))  # prints '262134882788466688000'\n**print(product_of_thirds(\"Foobarbaz\"))   # raises WRONG TypeError**\n```", "```py\nTypeError: can't multiply sequence by non-int of type 'str'\n```", "```py\nif not hasattr(some_obj, '__ge__'):\n    raise TypeError\n```", "```py\n**from collections.abc import Sequence**\n**from numbers import Complex**\n\ndef product_of_thirds(sequence):\n    **if not isinstance(sequence, Sequence):**\n        raise TypeError(\"Argument must be a sequence.\")\n    **if not isinstance(sequence[0], Complex):**\n        raise TypeError(\"Sequence elements must support multiplication.\")\n\n    r = sequence[0]\n    for i in sequence[1::3]:\n        r *= i\n    return r\n\nprint(product_of_thirds(range(1, 50)))  # prints '262134882788466688000'\nprint(product_of_thirds(\"Foobarbaz\"))   # raises TypeError\n```", "```py\nfrom collections.abc import Container, Sized, Iterable, Iterator\n```", "```py\nclass CafeQueue(**Container, Sized, Iterable**):\n\n    def __init__(self):\n        self._queue = []\n        self._orders = {}\n        self._togo = {}\n\n    def __iter__(self):\n        return CafeQueueIterator(self)\n\n    def __len__(self):\n        return len(self._queue)\n\n    def __contains__(self, customer):\n        return (customer in self._queue)\n\n    def add_customer(self, customer, *orders, to_go=True):\n        self._queue.append(customer)\n        self._orders[customer] = tuple(orders)\n        self._togo[customer] = to_go\n```", "```py`Because ABCs use metaclasses under the hood, they have the same problems with multiple inheritance that metaclasses do. I don’t have issues here because `type(Container)`, `type(Sized)`, and `type(Iterable)` are all instances of the `abc.ABCMeta` metaclass, but I wouldn’t be able to simultaneously inherit from an ABC or class that uses an altogether different metaclass.    I can achieve the same effect in a cleaner and simpler way by using the `Collection` ABC, which itself inherits from `Container`, `Sized`, and `Iterable`. This shortens the import line:    ```", "```py    Listing 14-14: *cafe_queue_abc.py:1b*    More importantly, it cleans up the inheritance list on the `CafeQueue` class:    ```", "```py    Listing 14-15: *cafe_queue_abc.py:2b*    This version is effectively identical to the previous one in [Listing 14-13](#listing14-13).    Next, I adjust my `CafeQueueIterator` class from Chapter 9 to use the `Iterator` ABC:    ```", "```py    Listing 14-16: *cafe_queue_**abc**.py:3*    Once again, I haven’t changed the implementation from the version in Chapter 9, except to inherit from `Iterator`. That ABC requires the `__next__()` method and inherits from `Iterable`, thereby also requiring `__iter__()`.    Here’s a revised usage of my `CafeQueue` class, to demonstrate ABCs at work:    ```", "```py    Listing 14-17: *cafe_queue_**abc**.py:4a*    In the `serve_customers()` function, I check that the `queue` argument is an instance of a class inheriting from the `Collection` ABC before proceeding ❶, as the function logic is relying on both `len()` and iteration.    Running this code produces what you’d expect:    ```", "```py    Although there are no functional changes to the example, ABCs contribute two advantages. First, anyone using my classes can check their functionality through the standard library ABCs. Second, and perhaps more important, it’s an insurance policy against one of these special methods the code relies on being accidentally removed from a class.    ### Implementing Custom ABCs    There often isn’t a preexisting abstract base class for everything you need, so you’ll need to write your own. You can make a class an ABC by having it inherit from `abc.ABC` or another ABC *and* giving it at least one method marked with the `@abstractmethod` decorator.    For my `CafeQueue` example, I’ll create a custom ABC to define a queue of customers. The rest of my code will expect a queue of customers to have certain methods and behaviors, so I’ll use the ABC to codify those expectations up front:    ```", "```py    Listing 14-18: *cafe_queue_abc.py:1c*    I make the `CustomerQueue` class inherit from `Collection` so its own derived classes must implement `__iter__()`, `__len__()`, and `__contains__()`, and so `CustomerQueue` indirectly inherits from `ABC` via `Collection`. Then, I add two additional abstract methods—`add_customer()` and the property `first()`—each marked with the `@abstractmethod` decorator, which I imported from `abc`. Any class that inherits from `CustomerQueue` must implement that property and those methods.    Before Python 3.3, if you wanted to require some types of methods in an abstract class, you had to use special decorators like `@abstractproperty`, `@abstractclassmethod`, and `@abstractstaticmethod`. You’ll still see code like that, but thankfully, that’s no longer necessary; instead, as long as `@abstractmethod` is the innermost decorator, you can use the usual method decorators, like `@property`.    While I can add abstract methods to require derived classes to have particular instance methods, class methods, static methods, and even properties, I *cannot* require derived classes to have particular instance attributes. ABCs are intended to specify *interfaces*, not data.    None of my abstract methods need implementations here, although I could write default implementations to be explicitly called via `super()`.    I can now update my `CafeQueue` class to inherit from this new `CustomerQueue` ABC:    ```", "```py    Listing 14-19: *cafe_queue_abc.py:2c*    I need to add the required property, `first()`, which, in my case, I use to peek at the name of the first person in line. If I don’t add this property, running the code would produce an error like this:    ```", "```py    Since I have implemented `first()`, I don’t need to worry about that error occurring.    I’ll also update the `serve_customers()` function to require a `CustomerQueue`, rather than a `Collection`. I can do this here because `CustomerQueue` inherits from `Collection`, so any class that inherits from `CustomerQueue` will also satisfy the interface of `Collection`.    ```", "```py    Listing 14-20: *cafe_queue_**abc**.py:4b*    In addition to testing whether `queue` is an instance of a class that inherits from `CustomerQueue`, I use the `queue.first` property toward the end, to test it out.    Running that code still produces the expected output:    ```", "```py    Aside from being able to check who is first in line, the functionality here hasn’t changed from prior versions of this example. As before, using ABCs here ensures that `CafeQueue` implements all the functionality the rest of my code depends on. If part of the expected interface is missing, the code will fail right away, instead of mid-execution.    ## Virtual Subclasses    As you start relying on custom abstract classes, you may reach a conundrum: you might require an argument to be an instance of a class derived from your custom ABC, and yet, you may want to somehow allow instances of certain preexisting classes to be used as well. For example, you cannot modify the built-in `list` class just to report that it satisfies some interface you specified in a custom ABC.    *Virtual subclassing* allows you to cause an ABC to report certain classes as being derived, even if they aren’t. This allows you to indicate particular built-in and third-party classes as fulfilling the interface outlined by one of your custom ABCs.    This works because calling `isinstance(Derived, Base)` or `issubclass(Derived, Base)` first checks for and calls the method `Base.__instancecheck__(Derived)` or `Base._subclasscheck__(Derived)`, respectively. Otherwise, `Derived.__isinstance__(Base)` or `Derived.__issubclass__(Base)` is called.    A critical limitation of virtual subclassing is that you’re bypassing the interface enforcement and instead reporting that *you* have verified that a particular class satisfies the interface. You can make any class a virtual subclass of ABC, but it’s entirely your own responsibility to ensure it has the expected interface.    ### Setting Up the Example    I’ll first create an example of a custom ABC that doesn’t use virtual subclassing, but where virtual subclassing can be helpful. Say that I’m creating a library of super-useful functions all related to palindromes, and I want to ensure I’m working with objects that implement certain methods: specifically, `__reversed__()`, `__iter__()`, and `__str__()`. I don’t want to require any further methods, since I’ll write a custom class for working with a sentence palindrome, which is more complex than a word palindrome. Unfortunately, there isn’t a built-in ABC that supports all those methods and *only* those.    There are different forms of palindromes, and I want to be able to interact with them all in the same way. This is why I create the custom `Palindromable` ABC:    ```", "```py    Listing 14-21: *palindrome_check.py:1*    The `Palindromable` ABC class doesn’t expand on any other ABC, so I only inherit from `abc.ABC`. With this ABC, I require the three methods I mentioned.    I now build a special `LetterPalindrome` class that interprets a string as a letter-based palindrome or sentence palindrome. This class inherits from the ABC `Palindromable`:    ```", "```py    Listing 14-22: *palindrome_check.py:2*    The initializer of `LetterPalindrome` accepts a string, strips out any non-letters, and converts it to all lowercase, thereby allowing it to check whether it’s a palindrome by reversing it and comparing it to the original.    Although I’m omitting it for reasons of space, I could also create a `WordPalindrome` class, which similarly accepts a string but reverses it word by word, instead of letter by letter.    I also implement all three required methods. Remember that, because the ABC mandates a `__str__()` method, I *must* implement it here. It doesn’t matter that one of the base classes—namely, `object`—has implemented `__str__()`; the `ABC` overwrote it as an abstract method, forcing me to reimplement it.    Below is my function for checking whether something is a palindrome. This function doesn’t care about the form of the palindrome; it just returns `True` as long as comparing the iterable to its reverse matches, item for item:    ```", "```py    Listing 14-23: *palindrome_check.py:3*    Before doing anything, I check that `sequence` is an instance of a class derived from `Palindromable`. If it is, I iteratively compare the items on sequence and its reversed form, indirectly relying on `sequence.__iter__()` and `sequence.__reversed__()`. In addition, I print a result onto the screen, indirectly using `sequence.__str__()`.    If I passed this function an instance of any class that lacked those three methods, this code wouldn’t make sense, and I would fail-fast with an exception. The particular strength of abstract base classes is that they aid in safely and effectively utilizing a form of duck typing. As long as a class can be used in a certain manner, it satisfies the ABC and nothing else matters.    I’ll try out my palindrome checker so far by instantiating a couple of `LetterPalindrome` instances and passing them to `check_palindrome()`:    ```", "```py    Listing 14-24: *palindrome_check.py:4*    Running that code outputs what I expect:    ```", "```py    ### Using Virtual Subclassing    Because my `check_palindrome()` function expects a class that inherits from my `Palindromable` ABC, that function would fail to work with some built-in classes, like lists, which could be palindromic in their own right. Instead, trying to pass a list to `check_palindrome()` fails with a `TypeError`:    ```", "```py    Listing 14-25: *palindrome_check.py:5a*    The code fails because `list` isn’t derived from `Palindromable`. I can’t reasonably go back and edit Python’s `list` class (nor should I try). Instead, I can make `list` a virtual subclass of `Palindromable`.    There are two ways of accomplishing this. The easiest is to register any class with an ABC by using the `register()` method, like this:    ```", "```py    Listing 14-26: *palindrome_check.py:5b*    That revised version works now because `list` is a virtual subclass of `Palindromable`. Instead of changing the `list` class to actually inherit from the `Palindromable` ABC, I have the ABC claim that `list` is among its derived classes.    However, this only applies to `list` so far. If I tried to pass a tuple to `check_palindrome()`, which should also work, it similarly fails. Sure, I could register `tuple` the same as I did with `list`, but it would be a pain to have to register every imaginable compatible class as a virtual subclass of `Palindromable`.    Anything could be considered a valid virtual subclass of `Palindromable`, as long as it implements the required methods and was *ordered* (so that the elements can be reversed reliably) and *finite*. Thinking it through, any class that is ordered would probably also be subscriptable via `__getitem__()`, and if it were finite, it would have a `__len__()` method as well. The built-in ABC `collections.abc.Sequence` mandates both of these methods, in addition to `__iter__()` and `__reversed__()`.    I can make `Sequence` a virtual subclass of `Palindromable`, thereby making any class that inherits from `Sequence` also a virtual subclass of `Palindromable`. I do that like this:    ```", "```py    Listing 14-27: *palindrome_check.py:5c*    Now I can use list, tuple, and any other class that inherits from `collections.abc.Sequence` with `check_palindrome()`.    If my rules for what qualifies as a `Palindromable` get any more complicated, as they often will in real life, I’ll need to either add more calls to `Palindromable.register()` or find another technique altogether. To deal with these potential complications, I can implement a special class method on the ABC called `__subclasshook__()`, which is called by `__subclasscheck__()` and augments the subclass checking behavior.    ```", "```py    Listing 14-28: *palindrome_check.py:1d*    The logic for the `__subclasshook__()` class method can be as simple or complex as I need it to be, and in this case, it’s extraordinarily simple. In any case, `__subclasshook__()` must return `True` if `C` should be considered a subclass of the `Palindromable` ABC, `False` if it definitely shouldn’t, and `NotImplemented` otherwise. This last part is important! When `__subclasshook__()` returns `NotImplemented`, it causes `__subclasscheck__()` to then check if `C` is an actual subclass, rather than a virtual one. If I returned `False` at the end of the method, it would cause my `LetterPalindrome` class to no longer be considered a subclass of `Palindromable`.    Unlike with most special methods, Python doesn’t require me to implement `__subclasscheck__()` directly, because that would mean I had to reimplement all the complicated subclass checking logic.    With this change made, I no longer need to register `list` and `Sequence` as virtual subclasses:    ```", "```py    Listing 14-29: *palindrome_check.py:5d*    As you can see, `check_palindrome()` now works with `list`, `tuple`, and `str`, in addition to `LetterPalindrome`.    Meanwhile, passing a `set` to `check_palindrome()` fails, which makes sense, because a set is unordered and cannot be reliably reversed.    Such is the beauty of duck typing with ABCs! I am able to write fail-fast code using a LBYL strategy, but I don’t have to specify every conceivable class that would work with that code. Instead, by creating a `Palindromable` abstract base class and adding `collections.abc.Sequence` as a virtual subclass, I’ve made my function work with practically any class that implements the needed interface.    ## Wrapping Up    Metaclasses are the mysterious “blueprints” from which classes are instantiated, in the same way classes are the blueprints for objects. Although seldom used by themselves, metaclasses allow you to override or extend how a class is created.    You can use abstract base classes, or ABCs, to mandate and then check for a specific interface on a class.    None of this means you shouldn’t use the type hints I mentioned back in Chapter 6. When it comes to enforcing a particular interface from a user perspective, annotations are going to be quite useful in clarifying how your code should be used. The purpose of ABCs and subclass checks is to make code that fails fast in situations where it cannot hope to succeed, especially when it may fail in subtle or unpredictable ways. Duck typing, inheritance, and type hints are complementary concepts. How they intersect in your code depends on you.```", "```py`` # 15 Introspection and Generics  ![](Images/chapterart.png)  *Introspection* is the ability of code to access information about itself at runtime and respond accordingly. As an interpreted language, Python excels at introspection. By understanding how Python inspects objects, you can uncover a number of patterns for improving and optimizing your code.    In this chapter, I’ll cover special attributes, which make this introspection possible. By making use of these special attributes, I’ll cover generic functions, descriptors, and slots, and I’ll even build an (effectively) immutable class. Then, while on the topic of code running itself, I’ll touch on the dangers of arbitrary execution.    ## Special Attributes    Python achieves introspection primarily by storing important information in *special attributes* on the different objects in use. These special attributes give Python runtime knowledge about names, project structure, relationships between objects, and more.    Like special methods, all special attributes start and end with a double underscore (`__`).    You’ve already seen several of these special attributes in preceding chapters, like the special attribute `__name__`, which contains the name of the module being executed, except on the entry point module, where it has the value `\"__main__\"`:    ```", "```py    There is also the special attribute `__file__`, which contains the absolute path to the current module and can be used to find files in a package:    ```", "```py    In both cases, Python is able to access information about the structure of the project at runtime. That’s introspection at work.    I’ll introduce the various special attributes as I need them in this chapter. As a handy reference, I’ve listed all the special attributes in Python in Appendix A.    ## Inside Object Attribute Access: The __dict__ Special Attribute    To write introspective code, you must understand how Python stores the names and values of attributes. Every class and every object has an instance of the special attribute `__dict__`, which is a dictionary that stores attributes and methods. Much of the behavior relating to object attribute access depends on which dictionary—the one on the class or the one on the instance—contains a particular attribute or method. This is actually more complicated than you might expect.    Consider the following simple class structure defining a `Llama` as a `Quadruped`:    ```", "```py    Listing 15-1: *llama.py:1*    The `Quadruped` and `Llama` classes here are designed specifically to demonstrate attribute access, so please overlook the violations of good object design here.    Let’s inspect the `__dict__` special attributes for the instance and two classes we created, to learn where Python stores everything:    ```", "```py    Listing 15-2: *llama.py:2a*    I’m using the `pprint` module and function to *pretty-print* the dictionaries, meaning I see each key-value pair in the dictionary on its own line. Pretty printing is useful for displaying complex collections in a more readable way. The output for this code shows the contents of the `__dict__` special attributes:    ```", "```py    You might be surprised at where some things are located. The instance attributes of `species` and `swimming` are found on the instance itself ❶, but all the instance methods are stored on the class (rather than the instance) ❷, along with the class attributes and custom class methods. `Quadruped.__dict__` stores the `Quadruped` class attribute `leg_count` ❸.    Another oddity is that the class `__dict__` attribute is actually of type `mappingproxy`, a special class defined in `types.MappingProxyType`. Technical details aside, it’s effectively a read-only view of a dictionary. The class’s `__dict__` attribute is this `MappingProxyType`, but the instance’s `__dict__` attribute is just an ordinary dictionary. Because of this, however, you cannot directly modify a class `__dict__` special attribute.    Lastly, although it’s impractical to depict here, all the special attributes and methods of the class itself are defined in the *metaclass’s* `__dict__` attribute. In most cases, including here, you can see that with `pprint(type.__dict__)`.    You can see there are some complex rules regarding where any given attribute or method is stored. Although I can directly access any class or instance attribute or method through the right `__dict__` special attribute, actually performing that lookup correctly is non-trivial. Python provides a better way.    ### Listing Attributes    There are two functions built for the purpose of inspecting the `__dict__` attribute of any class or instance: `vars()` and `dir()`.    The `vars()` function prints the `__dict__` attribute for the given object or class, like this:    ```", "```py    Listing 15-3: *llama.py:2b*    The output of this code should be identical to that for [Listing 15-2](#listing15-2).    Running `vars()` without any argument inside a class, object, or function prints out the `__dict__` for the current scope. Outside the scope of any objects, functions, and classes, it prints a dictionary representing the local symbol table. If you want the local or global symbol table as a dictionary, you can also run `locals()` or `globals()`, respectively. Be warned that you should never attempt to modify local or global values using the dictionaries returned from these functions.    The `dir()` built-in function returns a list of all names (but not values) in the current scope or the scope of the given object or class. By default, `dir()` compiles that list using the `__dict__` attributes, and it will also include names from the base classes. You can override this behavior by writing your own `__dir__()` method, which you might do if you’ve modified your class in other ways, to handle names that aren’t actually attributes.    In practice, these four functions—`vars()`, `locals()`, `globals()`, and `dir()`—are usually only useful when you’re working in the interactive prompt, or else during debugging.    ### Getting an Attribute    To access an attribute, say `leg_count` or `swimming`, I’d ordinarily use the dot operator (`.`), like this:    ```", "```py    Listing 15-4: *llama.py:3a*    The dot operator on a class or object is syntactic sugar for the built-in function `getattr()`. Here are the equivalent function calls:    ```", "```py    Listing 15-5: *llama.py:3b*    In both cases, I pass two arguments to `getattr()`: the object I’m searching on, followed by the name I’m searching for as a string.    Behind the scenes, the `getattr()` function employs two special methods: `__getattribute__()`, which handles the complex lookup logic, and `__getattr__()`, which the user can optionally implement to further extend the behavior of the `getattr()` function on a class.    Ultimately, either `object.__getattribute__()` or `type.__getattribute__()` is involved in searching on an instance or class, respectively. Even if this special method is reimplemented by a derived class or metaclass, that reimplementation will have to explicitly call `object.__getattribute__()` or `type.__getattribute__()` to avoid infinite recursion. This is just as well, as it would be no small matter to correctly reimplement all the behavior of `__getattribute__()`.    The `__getattribute__()` special method works by searching through the `__dict__` objects on the instances and classes, following the method resolution order. If it doesn’t find the attribute it’s searching for, it raises an `AttributeError`. From there, `getattr()` will check whether the special method `__getattr__()` has been defined—that’s the special user-defined method used as a fallback for attribute lookup when `__getattribute__()` fails. If `__getattr__()` has been defined, it is called by `getattr()` as a last step.    Here, I’ll use `__getattribute__()` directly:    ```", "```py    Listing 15-6: *llama.py:3c*    Objects and metaclasses both have a `__dict__` special attribute, which is used to store all other attributes by name. This is why you can add attributes to an object or class arbitrarily, even from outside the class definition. (There’s an alternative means of storing attributes, which I’ll return to later.)    Here is a rough reimplementation of the `getattr()` function, demonstrating how `__getattribute__()` and `__gettattr__()` are actually used in attribute lookups:    ```", "```py    Listing 15-7: *llama.py:3d*    While this is not identical to what’s really happening in `getattr()`, it’s close enough to understand what’s going on. In the first block, I’m accessing `llama.swimming`, and in the second, `Llama.leg_count`. In both cases, I start by calling the appropriate `__getattribute__()` special method in a `try` clause. If an `AttributeError` is raised, I next check if `__getattr__()` has been implemented; this, too, is done with `__getattribute__()`. If `__getattr__()` does exist, it’s called to perform a fallback attribute check, but if it doesn’t, the original `AttributeError` is raised again.    Whew! That’s a lot of work. Thankfully, Python hides all this complexity from us. To access an attribute or method, use the dot operator if you know the name of what you’re looking for in advance, or use `getattr()` to perform lookups at runtime, using a string for the name:    ```", "```py    Listing 15-8: *llama.py:3e*    As for overriding the normal behavior, `__getattr__()` is usually the only one of the two special methods involved that you should ever implement. One common use of `__getattr__()` is to provide a default value for attributes that don’t exist. As a rule, you should leave `__getattribute__()` alone.    ### Checking for an Attribute    To check for the existence of an attribute, use the `hasattr()` function, like this:    ```", "```py    Listing 15-9: *llama.py:4a*    Behind the scenes, `hasattr()` calls `getattr()` in a try statement, similar to if I had done this:    ```", "```py    Listing 15-10: *llama.py:4b*    ### Setting an Attribute    Setting an attribute isn’t quite as involved as accessing one. The `setattr()` function relies on the `__setattr__()` special method. By default, setting an attribute to a value should always work. Here, I set the instance attribute `larger_than_frogs` on `llama` to `True`:    ```", "```py    Listing 15-11: *llama.py:5a*    I pass three arguments to `setattr()`: the object or class to change the attribute on, the attribute name as a string, and the new value. The `setattr()` method completely ignores inheritance and the method resolution order; it is only concerned with modifying the `__dict__` on the specified object or class. If the attribute exists on that `__dict__`, the method alters it; otherwise, the method creates a new attribute on the `__dict__`.    Behind the scenes, `setattr()` relies on the special method `__setattr__()`, and the code in [Listing 15-11](#listing15-11) is effectively doing the following:    ```", "```py    Listing 15-12: *llama.py:5b*    That, in turn, modifies `llama.__dict__` and `Llama.__dict__`, respectively. There’s one funny detail here: while I could have modified `llama.__dict__` manually, `Llama.__dict__` is a `mappingproxy`, meaning it is read-only for everyone and everything *except* `type.__setattr__()`, which alone knows the secret to modifying the data represented in a `mappingproxy`. (Seriously, it’s not even documented.)    When setting an attribute, either via `setattr()` or the dot operator, pay careful attention to whether you are modifying an existing class attribute or merely shadowing it with an instance attribute. Accidental shadowing creates all sorts of bad surprises, as we’ve seen before. Here’s what I mean:    ```", "```py    Listing 15-13: *llama.py:6a*    In my call to `setattr()` here, I’m adding the key `'dangerous'` to the instance’s special attribute `llama.__dict__`, ignoring altogether the existence of the same key on the class’s special attribute, `Llama.__dict__`. The print statements demonstrate the resulting shadowing.    Unexpected shadowing is not a problem particular to `setattr()` but exists with any assignment to an attribute:    ```", "```py    Listing 15-14: *llama.py:6b*    To ensure I don’t shadow class attributes with instance attributes, I must be careful to only modify class attributes on the class, never on an instance thereof:    ```", "```py    Listing 15-15: *llama.py:6c*    To control how an object handles assignment to its attributes, you can reimplement the `__setattr__()` special method yourself. Use caution here, too. Your implementation of `__setattr__()` can actually *prevent* attributes from working altogether if it never modifies the `__dict__` special attribute and never calls `object.__setattr__()` (or `type.__setattr__()`, when working with class attributes).    ### Deleting an Attribute    The `delattr()` method deletes attributes. It relies on the `__delattr__()` special method and works in the same manner as `setattr()`, except that it returns an `AttributeError` if the requested attribute doesn’t exist.    Normally, you would use the `del` operator for this purpose, like this:    ```", "```py    Listing 15-16: *llama.py:7a*    This is the same as calling `delattr()` directly, like so:    ```", "```py    Listing 15-17: *llama.py:7b*    The `delattr()` function invokes `__delattr__()` the same way that `setattr()` invokes `__setattr__()`. If you want to control the deletion of attributes, you can reimplement `__delattr__()`, although you should use the same caution when altering this special method as with `__setattr__()`.    ## Function Attributes    If all objects can have attributes, and if functions are objects, then surely, functions can have attributes. This is indeed the case, but they don’t work in the way you might think.    In practice, you will rarely need to use function attributes directly. They’re mainly useful for enabling other patterns and techniques to work. These tasks border “deep magic” territory, whence we find metaclasses (Chapter 14).    Interestingly, function attributes were originally added to Python purely because they looked like they *should* exist. Libraries could already abuse `__docstring__` to hack in an approximation of function attribute behavior anyway. Meanwhile, other developers were trying to approximate function attributes by creating classes that consisted purely of class attributes and a `__call__()` method, a technique that has a fair bit of performance overhead compared to a normal function with attributes.    Thus, the Python developers reasoned, “Well, if they’re going to do it anyway, we might as well provide a formal and obvious mechanism for it.”    ### The Wrong Way to Use Function Attributes    To demonstrate function attributes and their pitfalls, consider the following example, in which I initially use function attributes incorrectly. This code defines a multiplier function that stores one of its operands in a function attribute. I’ll get to why this entire technique is a bad idea in a moment.    In this example, `multiplier()` multiplies the argument `n` by the value `factor` and prints the result:    ```", "```py    Listing 15-18: *function_attribute.py:1a*    In the usage, I incorrectly attempt to change the value of `factor` to `3` by assigning the value to a function attribute ❶. As you can see, the output of the function call is `0`, proving this did not work as expected ❷, as the local-scope variable is still `0`. Yet, if I inspect `multiplier.factor`, this function attribute’s value is indeed `3`. What happened?    The problem is that function attributes are not the same thing as local-scope variables, but rather exist inside the `multiplier` object’s `__dict__` attribute. If I print this `__dict__` attribute, you can see that it includes the `multiplier.factor` attribute:    ```", "```py    Listing 15-19: *function_attribute.py:1b*    What’s more, I cannot access function attributes within the function by name only, as I tried to do with the print call in the `multiplier()` function. The only way to access the function attributes is through `getattr()`, either directly or via the dot operator, like this:    ```", "```py    Listing 15-20: *function_attribute.py:1c*    As you can see, the multiplication operation now succeeds.    There’s still another technical problem with this code: if I fail to assign an initial value to `multiplier.factor`, the call to `multiplier()` in [Listing 15-20](#listing15-20) will fail. I can correct this problem by having the `multiplier()` function define a default value for that function attribute, if it is undefined.    Here’s the final working version:    ```", "```py    Listing 15-21: *function_attribute.py:1d*    At the top of `multiplier()`, I check whether the `factor` function attribute has been defined. If it hasn’t, I set it to a default value of `0`. Then, by changing the function attribute externally ❶, I can change the behavior of the function.    As I’ve said from the start, though, this is only a simple example to demonstrate how function attributes work. My usage is not even remotely Pythonic!    ### Mutability and Function Attributes    You’ll recall from Chapter 6 that functions should be *stateless*. Given what the function is designed to do, one may reasonably expect that ``multiplier(2) will return the same value every time. That premise has been violated because `multiplier()` stores state in its function attributes. Changing `multiplier.factor` will change the value returned by `multiplier(2)`.``   ```", "```py def skit():     print(skit.actor)  skit.actor = \"John Cleese\" skit()    # prints \"John Cleese\"  sketch = skit sketch()  # prints \"John Cleese\" sketch.actor = \"Eric Idle\" sketch()  # prints \"Eric Idle\"  skit()    # prints \"Eric Idle\"...yikes! ```", "```py import re   class Book:     pattern = re.compile(r'(.+)\\((\\d+)\\)\\. (.+)\\. (.+)\\..*')      def __set__(self, instance, value):         matches = self.pattern.match(value)         if not matches:             raise ValueError(\"Book data must be specified in APA 7 format.\")         self.author = matches.group(1)         self.year = matches.group(2)         self.title = matches.group(3)         self.publisher = matches.group(4) ```", "```py  def __get__(self, instance, owner=None):         try:             return f\"'{self.title}' by {self.author}\"         except AttributeError:             return \"nothing right now\" ```", "```py class BookClub:     reading = Book()      def __init__(self, name):         self.name = name         self.members = []      def new_member(self, member):         self.members.append(member)         print(             \"===== - - - - - - - - - =====\",             f\"Welcome to the {self.name} Book Club, {member}!\",             f\"We are reading {self.reading}\",             \"===== - - - - - - - - - =====\",             sep='\\n'         ) ```", "```py mystery_lovers = BookClub(\"Mystery Lovers\") lattes_and_lit = BookClub(\"Lattes and Lit\")  mystery_lovers.reading = (     \"McDonald, J. C. (2019). \"     \"Noah Clue, P.I. AJ Charleson Publishing.\" ) lattes_and_lit.reading = (     \"Christie, A. (1926). \"     \"The Murder of Roger Ackroyd. William Collins & Sons.\" )  print(mystery_lovers.reading)  # prints \"'The Murder of Roger Ackroyd...\" print(lattes_and_lit.reading)  # prints \"'The Murder of Roger Ackroyd...\" ```", "```py class Book:     pattern = re.compile(r'(.+)\\((\\d+)\\)\\. (.+)\\. (.+)\\..*')      def __set__(self, instance, value):         matches = self.pattern.match(value)         if not matches:             raise ValueError(\"Book data must be specified in APA 7 format.\")         **instance**.author = matches.group(1)         **instance**.year = matches.group(2)         **instance**.title = matches.group(3)         **instance**.publisher = matches.group(4) ```", "```py  def __get__(self, instance, owner=None):         try:             return f\"'{**instance**.title}' by {**instance**.author}\"         except AttributeError:  return \"nothing right now\"      **def __delete__(self, instance):**  **del instance.author**  **del instance.year**  **del instance.title**  **del instance.publisher** ```", "```py mystery_lovers = BookClub(\"Mystery Lovers\") lattes_and_lit = BookClub(\"Lattes and Lit\")  mystery_lovers.reading = (     \"McDonald, J. C. (2019). \"     \"Noah Clue, P.I. AJ Charleson Publishing.\" ) lattes_and_lit.reading = (     \"Christie, A. (1926). \"     \"The Murder of Roger Ackroyd. William Collins & Sons.\" )  print(mystery_lovers.reading)  # prints \"'Noah Clue, P.I....\" print(lattes_and_lit.reading)  # prints \"'The Murder of Roger Ackroyd...\" ```", "```py del lattes_and_lit.reading  lattes_and_lit.new_member(\"Jaime\")  lattes_and_lit.reading = (     \"Hillerman, T. (1973). \"     \"Dance Hall Of The Dead. Harper and Row.\" )  lattes_and_lit.new_member(\"Danny\") ```", "```py ===== - - - - - - - - - ===== Welcome to the Lattes and Lit Book Club, Jaime! We are reading nothing right now. ===== - - - - - - - - - ===== Welcome to the Lattes and Lit Book Club, Danny! We are reading 'Dance Hall Of The Dead' by Hillerman, T. ```", "```py class BookClub:     reading = Book()     **reading_next = Book()**      # `--snip--` ```", "```py mystery_lovers.reading = (     \"McDonald, J. C. (2019). \"     \"Noah Clue, P.I. AJ Charleson Publishing.\" )  mystery_lovers.reading_next = (     \"Chesterton, G.K. (1911). The Innocence of Father Brown. \"     \"Cassell and Company, Ltd.\" ) print(f\"Now: {mystery_lovers.reading}\") print(f\"Next: {mystery_lovers.reading_next}\") ```", "```py Now: 'The Innocence of Father Brown' by Chesterton, G.K.  Next: 'The Innocence of Father Brown' by Chesterton, G.K. ```", "```py import re  class Book:     pattern = re.compile(r'(.+)\\((\\d+)\\)\\. (.+)\\. (.+)\\..*')      **def __set_name__(self, owner, name):**  **self.name = name**      **def attr(self, attr):**  **return f\"{self.name}.{attr}\"**      def __set__(self, instance, value):         matches = self.pattern.match(value)         if not matches:             raise ValueError(\"Book data must be specified in APA 7 format.\")         **setattr(**instance**, self.attr('**author**'),** matches.group(1)**)**         **setattr(**instance**, self.attr('**year**'),** matches.group(2)**)**         **setattr(**instance**, self.attr('**title**'),** matches.group(3)**)**         **setattr(**instance**, self.attr('**publisher**'),** matches.group(4)**)** ```", "```py  def __get__(self, instance, owner=None):         try:             **title = getattr(instance, self.attr('title'))**             **author = getattr(instance, self.attr('author'))**         except AttributeError:             return \"nothing right now\"         **return f\"{title} by {author}\"**      def __delete__(self, instance):         **delattr(**instance**, self.attr('**author**'))**         **delattr(**instance**, self.attr('**year**'))**  **delattr(**instance**, self.attr('**title**'))**         **delattr(**instance**, self.attr('**publisher**'))** ```", "```py Now: 'Noah Clue, P.I.' by McDonald, J.C.  Next: 'The Innocence of Father Brown' by Chesterton, G.K. ```", "```py import pprint pprint.pprint(dir(mystery_lovers)) ```", "```py ['__class__', # `--snip--`  'reading',  'reading.author',  'reading.publisher',  'reading.title',  'reading.year',  'reading_next',  'reading_next.author',  'reading_next.publisher',  'reading_next.title',  'reading_next.year'] ```", "```py class Element:     __slots__ = (         'name',         'number',         'symbol',         'family',         'iupac_num',     ) ```", "```py  def __init__(self, symbol, number, name, family, numeration):         self.symbol = symbol.title()         self.number = number         self.name = name.lower()         self.family = family.lower()         self.iupac_num = numeration      def __str__(self):         return f\"{self.symbol} ({self.name}): {self.number}\" ```", "```py oxygen = Element('O', 8, 'oxygen', 'non-metals', 16) iron = Element('Fe', 26, 'iron', 'transition metal', 8)  print(oxygen)  # prints 'O (Oxygen): 8' print(iron)    # prints 'Fe (Iron): 26' ```", "```py iron.atomic_mass = 55.845  # raises AttributeError ```", "```py class Element:     __slots__ = (         'name',         'number',         'symbol',         'family',         'iupac_num',         **'__dict__',**         **'__weakref__',**     ) ```", "```py class Element:     __slots__ = (         'name',         'number',         'symbol',         '__weakref__',     )      def __init__(self, symbol, number, name):         self.symbol = symbol.title()         self.number = number         self.name = name.lower() ```", "```py  def __repr__(self):         return f\"{self.symbol} ({self.name}): {self.number}\"   def __str__(self):         return self.symbol      def __hash__(self):         return hash(self.symbol)      def __eq__(self, other):         return self.symbol == other.symbol      def __lt__(self, other):         return self.symbol < other.symbol      def __le__(self, other):         return self.symbol <= other.symbol ```", "```py  def __setattr__(self, name, value):         if hasattr(self, name):             raise AttributeError(                 f\"'{type(self)}' object attribute '{name}' is read-only\"             )         object.__setattr__(self, name, value) ```", "```py  def __delattr__(self, name):         raise AttributeError(             f\"'{type(self)}' object attribute ′{name}' is read-only\"         ) ```", "```py oxygen = Element('O', 8, 'oxygen') iron = Element('Fe', 26, 'iron')  print(oxygen)              # prints O print(f\"{iron!r}\")         # prints Fe (Iron): 26  iron.atomic_mass = 55.845  # raises AttributeError iron.symbol = \"Ir\"         # raises AttributeError del iron.symbol            # raises AttributeError ```", "```py `object.__setattr__(iron, 'symbol', 'Ir')` ```", "```py **from functools import singledispatchmethod** **from typing import overload**  class Element:   # `--snip--` ```", "```py  @singledispatchmethod     def __eq__(self, other):         return self.symbol == other.symbol ```", "```py  @__eq__.register     def _(self, other: str):         return self.symbol == other      @overload     def _(self, other: float):         ...     @__eq__.register     def _(self, other: int):         return self.number == other ```", "```py  @singledispatchmethod     def __lt__(self, other):         return self.symbol < other.symbol      @__lt__.register(str)     def _(self, other):  return self.symbol < other      @__lt__.register(int)     @__lt__.register(float)     def _(self, other):         return self.number < other ```", "```py  @singledispatchmethod     def __le__(self, other):         return self.symbol <= other.symbol      __le__.register(str, lambda self, other: self.symbol <= other)      __le__.register(int, lambda self, other: self.number <= other)     __le__.register(float, lambda self, other: self.number <= other) ```", "```py class Compound:      def __init__(self, name):  self.name = name.title()         self.components = {}      def add_element(self, element, count):         try:             self.components[element] += count         except KeyError:             self.components[element] = count      def __str__(self):         s = \"\"         formula = self.components.copy()         # Hill system         if 'C' in formula.keys():             s += f\"C{formula['C']}\"             del formula['C']             if 1 in formula.keys():                 s += f\"H{formula['H']}\"                 del formula['H']         for element, count in sorted(formula.items()):             s += f\"{element.symbol}{count if count > 1 else ''}\"         # substitute subscript digits for normal digits         s = s.translate(str.maketrans(\"0123456789\", \"[₀₁₂₃₄₅₆₇₈₉]\"))         return s      def __repr__(self):         return f\"{self.name}: {self}\" ```", "```py hydrogen = Element('H', 1, 'hydrogen') carbon = Element('C', 6, 'carbon') oxygen = Element('O', 8, 'oxygen') iron = Element('Fe', 26, 'iron')  rust = Compound(\"iron oxide\") rust.add_element(oxygen, count=3) rust.add_element(iron, count=2) print(f\"{rust!r}\")     # prints 'Iron Oxide: Fe₂O₃'  aspirin = Compound(\"acetylsalicylic acid\") aspirin.add_element(hydrogen, 8) aspirin.add_element(oxygen, 4) aspirin.add_element(carbon, 9) print(f\"{aspirin!r}\")  # prints 'Acetylsalicylic Acid: C₉H₈O₄'  water = Compound(\"water\") water.add_element(hydrogen, 2) water.add_element(oxygen, 1) print(f\"{water!r}\")    # prints 'Water: H₂O' ```", "```py with open('input.dat', 'r') as file:     nums = [value.strip() for value in file if value]  for num in nums:     expression = f\"{num} // 2 + 2\"     try:         answer = eval(expression)     except (NameError, ValueError, TypeError, SyntaxError) as e:         print(e)     finally:         code = \"print('The answer is', answer)\"         obj = compile(code, '<string>', mode='exec')         exec(obj) ```", "```py 40 (30 + 7) 9 * 3 0xAA & 0xBB 80 ```", "```py The answer is 22 The answer is 20 The answer is 15 The answer is 10 The answer is 42 ```", "```py 40 (30 + 7) 9 * 3 0xAA & 0xBB 80 exec('import os') or os.system('echo \\\"`whoami` is DOOMED\\\"') == 0 or 1 ```", "```py The answer is 22 The answer is 20 The answer is 15 The answer is 10 The answer is 42 jason is DOOMED The answer is True ```", "```py`  ```", "```py BOUND = 10**5 ```", "```py def collatz(n):     steps = 0     while n > 1:         if n % 2:             n = n * 3 + 1         else:             n = n / 2  steps += 1     return steps ```", "```py def length_counter(target):     count = 0     for i in range(2, BOUND):         if collatz(i) == target:             count += 1     return count ```", "```py def get_input(prompt):     while True:         n = input(prompt)         try:             n = int(n)         except ValueError:             print(\"Value must be an integer.\")             continue         if n <= 0:             print(\"Value must be positive.\")         else:             return n ```", "```py def main():     print(\"Collatz Sequence Counter\")      target = get_input(\"Collatz sequence length to search for: \")     print(f\"Searching in range 1-{BOUND}...\")   count = length_counter(target)     guess = get_input(\"How many times do you think it will appear? \")      if guess == count:         print(\"Exactly right! I'm amazed.\")     elif abs(guess - count) < 100:         print(f\"You're close! It was {count}.\")     else:         print(f\"Nope. It was {count}.\") ```", "```py if __name__ == \"__main__\":     main() ```", "```py Collatz Sequence Counter Collatz sequence length to search for: `42` Searching in range 1-100000... ```", "```py How many times do you think it will appear? `456` Nope. It was 782. ```", "```py import asyncio  BOUND = 10**5 ```", "```py async def some_function():     # ... ```", "```py await some_function() ```", "```py def collatz(start):     steps = 0     n = start     while n > 1:         if n % 2:             n = n * 3 + 1         else:             n = n / 2         steps += 1     return steps ```", "```py **async** def length_counter(target):     count = 0     for i in range(2, BOUND):         if collatz(i) == target:             count += 1         **await asyncio.sleep(0)**     return count ```", "```py **async** def get_input(prompt):     while True:         n = input(prompt)         try:             n = int(n)         except ValueError:             print(\"Value must be an integer.\")             continue         if n <= 0:             print(\"Value must be positive.\")         else:             return n ```", "```py f = length_counter(100) while True:     try:         f.send(None)     except StopIteration as e:         print(e)  # prints '255'         break ```", "```py **async** def main():     print(\"Collatz Sequence Counter\")      target = **await** get_input(\"Collatz sequence length to search for: \")     print(f\"Searching in range 1-{BOUND}\")      **length_counter_task = asyncio.create_task(length_counter(target))**  **guess_task = asyncio.create_task(**  **get_input(\"How many times do you think it will appear? \")**  **)**  ****count = await length_counter_task**  **guess = await guess_task**      if guess == count:         print(\"Exactly right! I'm amazed.\")     elif abs(guess-count) < 100:         print(f\"You're close! It was {count}.\")     else:         print(f\"Nope. It was {count}.\")** ```", "```py if __name__ == \"__main__\":     **loop =** ❶ **asyncio.get_event_loop()**   ❷ **loop.run_until_complete(main())** ```", "```py if __name__ == \"__main__\":     **asyncio.run(main())** ```", "```py  n = input(prompt) ```", "```py import asyncio **from aioconsole import ainput**  BOUND = 10**5 ```", "```py async def get_input(prompt):     while True:         n = **await ainput**(prompt)         try:             n = int(n)         except ValueError:             print(\"Value must be an integer.\")             continue  if n <= 0:             print(\"Value must be positive.\")         else:             return n ```", "```py asyncio.run(main()) ```", "```py  target = await get_input(\"Collatz sequence length to search for: \") ```", "```py  guess_task = asyncio.create_task(         get_input(\"How many times do you think it will appear? \")     ) ```", "```py  length_counter_task = asyncio.create_task(length_counter(target)) ```", "```py  count = await length_counter_task ```", "```py  n = await ainput(prompt) ```", "```py guess = await guess_task ```", "```py async def main():     print(\"Collatz Sequence Counter\")      target = await get_input(\"Collatz sequence length to search for: \")     print(f\"Searching in range 1-{BOUND}\")      **(guess, count) = await asyncio.gather(**         **get_input(\"How many times do you think it will appear? \"),**         **length_counter(target)**     **)**      if guess == count:         print(\"Exactly right! I'm amazed.\")     elif abs(guess-count) < 100:         print(f\"You're close! It was {count}.\")     else:         print(f\"Nope. It was {count}.\") ```", "```py import asyncio from aioconsole import ainput  BOUND = 10**5   class Collatz:      def __init__(self):         self.start = 2 ```", "```py  async def count_steps(self, start_value):         steps = 0         n = start_value         while n > 1:             if n % 2:                 n = n * 3 + 1             else:                 n = n // 2             steps += 1         return steps ```", "```py  def __aiter__(self):         return self      async def __anext__(self):         steps = await self.count_steps(self.start)         self.start += 1         if self.start == BOUND:             raise StopAsyncIteration         return steps ```", "```py async def length_counter(target):     count = 0     async for steps in ❶ Collatz():         if steps == target:             count += 1     return count ```", "```py async def length_counter(target):     count = 0     **iter = Collatz().__aiter__()**  **running = True**  **while running:**  **try:**  **steps = await iter.__anext__()**  **except StopAsyncIteration:**  **running = False**  **else:**  **if steps == target:**  **count += 1**     return count ```", "```py **import threading**  BOUND = 10**5   def collatz(n):     steps = 0     while n > 1:         if n % 2:             n = n * 3 + 1         else:             n = n // 2         steps += 1     return steps   def length_counter(target):     count = 0     for i in range(2, BOUND):         if collatz(i) == target:             count += 1     return count ```", "```py **guess = None**   def get_input(prompt):     **global guess**     while True:         n = input(prompt)         try:             n = int(n)         except ValueError:             print(\"Value must be an integer.\")             continue         if n <= 0:             print(\"Value must be positive.\")         else:             **guess = n**             return n ```", "```py def main():     print(\"Collatz Sequence Counter\")      target = get_input(\"Collatz sequence length to search for: \")     print(f\"Searching in range 1-{BOUND}...\")   **t_guess = threading.Thread(**  **target=get_input,**  **args=(\"How many times do you think it will appear? \",)**  **)**  **t_guess.start()**      count = length_counter(target)      **t_guess.join()**      if guess == count:         print(\"Exactly right! I'm amazed.\")     elif abs(guess - count) < 100:  print(f\"You're close! It was {count}.\")     else:         print(f\"Nope. It was {count}.\")   if __name__ == \"__main__\":     main() ```", "```py def main():     # `--snip--`      t_guess = threading.Thread(         target=get_input,         args=(\"How many times do you think it will appear? \",),         **daemon=True**     )     t_guess.start()      count = length_counter(target)      t_guess.join(**timeout=1.5**)     **if t_guess.is_alive():**  **print(\"\\nYou took too long to respond!\")**  **return**      # `--snip--`  if __name__ == \"__main__\":     main() ```", "```py **import concurrent.futures**  BOUND = 10**5  def collatz(n):     # `--snip--` ```", "```py def get_input(prompt):     while True:         n = input(prompt)         try:             n = int(n)         except ValueError:             print(\"Value must be an integer.\")             continue         if n <= 0:             print(\"Value must be positive.\")         else:             return n ```", "```py def main():     print(\"Collatz Sequence Counter\")      # `--snip--`      **executor = concurrent.futures.ThreadPoolExecutor()**     **future_guess = executor.submit(**  **get_input,**  **\"How many times do you think it will appear? \"**  **)**      **count = length_counter(target)**     **guess = future_guess.result()**     **executor.shutdown()**      # `--snip--`   if __name__ == \"__main__\":     main() ```", "```py def main():     print(\"Collatz Sequence Counter\")      # `--snip--`      **with concurrent.futures.ThreadPoolExecutor() as executor:**         future_guess = executor.submit(             get_input,             \"How many times do you think it will appear? \"         )          count = length_counter(target)      guess = future_guess.result()      # `--snip--`  if __name__ == \"__main__\":     main() ```", "```py  count = length_counter(target)     try:         guess = future_guess.result(timeout=1.5)     except concurrent.futures.TimeoutError:         print(\"\\nYou took too long to respond!\")       ❶ executor.shutdown(wait=False, cancel_futures=True)         return  # hangs forever!     else:         executor.shutdown() ```", "```py count = 0  def increment():     global count     count += 1 ```", "```py **import dis**  count = 0  def increment():     global count     count += 1  **dis.dis(increment)** ```", "```py  7           0 LOAD_GLOBAL              0 (count)               2 LOAD_CONST               1 (1)               4 INPLACE_ADD               6 STORE_GLOBAL             0 (count)               8 LOAD_CONST               0 (None)              10 RETURN_VALUE ```", "```py import concurrent.futures import functools import time  BOUND = 10**5  class Counter:     count = 0      @classmethod     def increment(cls):         new = cls.count + 1       ❶ time.sleep(0.1)  # forces the problem         cls.count = new      @classmethod     def get(cls):         return cls.count      @classmethod     def reset(cls):         cls.count = 0 ```", "```py def collatz(**target,** n):     steps = 0     while n > 1:         if n % 2:             n = n * 3 + 1         else:             n = n // 2         steps += 1   **if steps == target:**  **Counter.increment()** ```", "```py def length_counter(target):   ❶ Counter.reset()     with concurrent.futures.ThreadPoolExecutor( ❷ max_workers=5) as executor:         func = ❸ functools.partial(collatz, target)       ❹ executor.map(func, range(2, BOUND))     return Counter.get() ```", "```py Collatz Sequence Counter Collatz sequence length to search for: 123 Searching in range 1-100000... How many times do you think it will appear? 210 Nope. It was 43. ```", "```py import concurrent.futures **import threading** import functools import time  BOUND = 10**5   class Counter:     count = 0     **_lock =** ❶ **threading.Lock()**      @classmethod     def increment(cls):       ❷ **cls._lock.acquire()**         new = cls.count + 1         time.sleep(0.1)         cls.count = new       ❸ **cls._lock.release()**      # `--snip--` ```", "```py  # `--snip--`          @classmethod     def increment(cls):         **with cls._lock:**             new = cls.count + 1             time.sleep(0.1)             cls.count = new      # `--snip--` ```", "```py import concurrent.futures import functools **import queue**  BOUND = 10**5 ```", "```py def collatz(**results**, n):     steps = 0     while n > 1:         if n % 2:             n = n * 3 + 1         else:             n = n // 2         steps += 1     **results.put(steps)** ```", "```py def length_counter(target):     **results = queue.Queue()**     with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:         func = functools.partial(collatz, ❶ **results**)         executor.map(func, range(2, BOUND))     **results = list(results.queue)**     return **results.count(target)** ```", "```py import concurrent.futures  BOUND = 10**5 ```", "```py def collatz(n):     steps = 0     while n > 1:         if n % 2:             n = n * 3 + 1         else:             n = n // 2         steps += 1     **return steps** ```", "```py def length_counter(target):     **count = 0**     with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:         **for result in** executor.map(collatz, range(2, BOUND))**:**             **if result == target:**  **count += 1**     **return count** ```", "```py def length_counter(target):     count = 0     with concurrent.futures.**ProcessPoolExecutor()** as executor:         for result in executor.map(collatz, range(2, BOUND)):             if result == target:                 count += 1     return count ```", "```py def length_counter(target):     count = 0     with concurrent.futures.ProcessPoolExecutor() as executor:         for result in executor.map(             collatz,             range(2, BOUND)**,**             **chunksize=BOUND//4**         ):             if result == target:                 count += 1     return count ```", "```py import concurrent.futures import multiprocessing import queue import itertools import signal import time  BOUND = 10**5 ```", "```py in_queue = multiprocessing.Queue(100) exit_event = multiprocessing.Event() ```", "```py def exit_handler(signum, frame):   ❶ exit_event.set()   signal.signal(❷ signal.SIGINT, exit_handler) signal.signal(❸ signal.SIGTERM, exit_handler) ```", "```py def collatz(n):     steps = 0     while n > 1:         if n % 2:             n = n * 3 + 1         else:             n = n // 2         steps += 1     return steps   def collatz_consumer(target):     count = 0     while True:         if not in_queue.empty():             try:                 n = in_queue.get( ❶ timeout=1)             except queue.Empty:                 return count              if collatz(n) == target:                 count += 1          if exit_event.is_set():             return count ```", "```py def range_producer():     for n in range(2, BOUND):       ❶ if exit_event.is_set():             return         try:           ❷ in_queue.put(n, timeout=1)  except queue.Full:           ❸ exit_event.set()             return      while True:         time.sleep(0.05)         if in_queue.empty():             exit_event.set()             return ```", "```py def length_counter(target):     with concurrent.futures.ProcessPoolExecutor() as executor:         executor.submit( ❶ range_producer)         results = ❷ executor.map(             collatz_consumer,           ❸ itertools.repeat(target, 4)         )      return ❹ sum(results) ```", "```py Collatz Sequence Counter Collatz sequence length to search for: 128 Searching in range 1-100000... How many times do you think it will appear? 608 Exactly right! I'm amazed. ```", "```py` ```"]