<html><head></head><body>
<h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_65"/><span class="big">4</span><br/>POINTS AND VECTORS</h2>&#13;
<div class="image1"><img src="../images/common01.jpg" alt="Image"/></div>&#13;
<p class="noindent">Points and vectors are the basis of geometry. In this book, we’ll use them as our <em>primitives</em>, the building blocks for the rest of our geometry library. For our geometry library to be usable, it’s crucial that we implement points and vectors using bug-free code. A bug in our code will not only cause errors in the library’s functions but also could propagate to all the other libraries we build on top of it, giving us all sorts of false calculations.</p>&#13;
<p class="indent">In this chapter, we have two main tasks. First, we need to implement classes to represent both points and vectors. Then, we need to make sure our code is bug-free by unit testing, a process we’ll repeat throughout this book. Before we can do either, though, we need to implement a few useful methods.</p>&#13;
<h3 class="h3" id="ch00lev1sec29"><strong>Comparing Numbers</strong></h3>&#13;
<p class="noindent">When it comes to representing real numbers, computers don’t have infinite precision. Most computers use floating-point numbers to store these values, which cannot represent every rational number, let alone irrational numbers. <span epub:type="pagebreak" id="page_66"/>Thus, when comparing floating-point numbers, you have to specify a <em>tolerance</em>: a number <em>ϵ</em> as small as you need such that</p>&#13;
<p class="noindentc">|<em>a – b</em>| &lt; <em>ϵ</em></p>&#13;
<p class="noindent">where <em>a</em> and <em>b</em> are the two numbers you want to compare.</p>&#13;
<p class="indent">A tolerance’s order of magnitude needs to be consistent with the problem’s magnitudes and your desired precision. For example, it wouldn’t make much sense to use a tolerance of 1<em>E</em><sup>–20</sup> mm when working with a planet’s orbital lengths, which are on the order of millions of kilometers. Similarly, it would be pointless to use a tolerance of 1<em>E</em><sup>–2</sup> cm when working with atomic distances.</p>&#13;
<p class="indent">Before we start writing our primitives, we’ll need a way of knowing whether two floating-point numbers can be considered equal or not given a tolerance <em>ϵ</em>. But we can’t rely on the computer to compare floating-point numbers, as a different digit in the hundredth decimal is logically considered to be a completely different number. So, we’ll start this chapter by writing a function that compares two numbers using a given tolerance. For our geometrical calculations, we’ll use a default tolerance of 1<em>E</em><sup>–10</sup>, which is an acceptable level of precision for most of the calculations we’ll do throughout the book.</p>&#13;
<p class="indent">Open your project in the IDE, right-click the project’s root folder, and select <strong>New</strong> ▸ <strong>Python Package</strong>. Name it <em>geom2d</em> and click <strong>OK</strong>. This will be the package for all of our geometry code.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Because the package name establishes that everything inside is in 2D, we won’t repeat this piece of information when giving names to our files and classes. Inside the package, we’ll use names like</em> <span class="literal">point</span> <em>or</em> <span class="literal">segment</span> <em>instead of</em> <span class="literal">point2d</span> <em>or</em> <span class="literal">segment2d</span><em>. If we wanted to create a three-dimensional geometry package,</em> geom3d<em>, we’d still use</em> <span class="literal">point</span> <em>and</em> <span class="literal">segment</span><em>, only with different, three-dimensional implementations.</em></p>&#13;
</div>&#13;
<p class="indent">Create a new file by right-clicking the <em>geom2d</em> package folder and selecting <strong>New</strong> ▸ <strong>Python File</strong>. Name it <em>nums</em>, leave the Kind drop-down as is, and click <strong>OK</strong>.</p>&#13;
<p class="indent">With the file created, let’s implement our first comparison function. <a href="ch04.xhtml#ch4lis1">Listing 4-1</a> has the code for our function.</p>&#13;
<pre>import math&#13;
&#13;
&#13;
def are_close_enough(a, b, tolerance=1e-10):&#13;
    return math.fabs(a - b) &lt; tolerance</pre>&#13;
<p class="caption"><a id="ch4lis1"/><em>Listing 4-1: Comparing numbers</em></p>&#13;
<p class="indent">First, we import the <em>math</em> module, part of Python’s standard library that contains useful mathematical functions. Our function takes two numbers, <span class="literal">a</span> and <span class="literal">b</span>, and an optional <span class="literal">tolerance</span> parameter that will default to 1<em>E</em><sup>–10</sup> if no other value is provided. Last, we use the <span class="literal">math</span> library’s <span class="literal">fabs</span> function to check whether the absolute value of the difference between <span class="literal">a</span> and <span class="literal">b</span> is smaller than the tolerance, and we return the appropriate boolean.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_67"/>In practice, we’ll find there are two particular values we’re comparing against: zero and one. To save us from repeatedly writing something like</p>&#13;
<pre>are_close_enough(num, 1.0, 1e-5)</pre>&#13;
<p class="noindent">or</p>&#13;
<pre>are_close_enough(num, 0.0, 1e-5)</pre>&#13;
<p class="noindent">let’s implement them as functions. After the previous function, add the code in <a href="ch04.xhtml#ch4lis2">Listing 4-2</a>.</p>&#13;
 <pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
def is_close_to_zero(a, tolerance=1e-10):&#13;
    return are_close_enough(a, 0.0, tolerance)&#13;
&#13;
&#13;
def is_close_to_one(a, tolerance=1e-10):&#13;
    return are_close_enough(a, 1.0, tolerance)</pre>&#13;
<p class="caption"><a id="ch4lis2"/><em>Listing 4-2: Comparing number to zero or one</em></p>&#13;
<p class="noindent">Functions like the ones in <a href="ch04.xhtml#ch4lis2">Listing 4-2</a> aren’t strictly necessary, but they are convenient, and they make the code more readable.</p>&#13;
<h3 class="h3" id="ch00lev1sec30"><strong>The Point Class</strong></h3>&#13;
<p class="noindent">A point, according to Euclid’s first volume of the <em>Elements</em>, is “that of which there is no part.” In other words, a point is an entity with no width, length, or depth. It is just a position in space, something you can’t see with your naked eye. Points are the basis of all Euclidean geometry, and everything else in his writings is based on this simple concept. Accordingly, our geometry library will also be based on this powerful primitive.</p>&#13;
<p class="indent">A point consists of two numbers, <em>x</em> and <em>y</em>. These are its coordinates, sometimes also called <em>projections</em>. <a href="ch04.xhtml#ch4fig1">Figure 4-1</a> depicts a point <em>P</em> and its coordinates in the Euclidean plane.</p>&#13;
<div class="image"><img src="../images/04fig01.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch4fig1"><em>Figure 4-1: A point <span class="normal">P</span> in the plane</em></p>&#13;
<p class="indent">Let’s implement a class representing a two-dimensional point. As before, we’ll create a new file by right-clicking the <em>geom2d</em> package folder and <span epub:type="pagebreak" id="page_68"/>selecting <strong>New</strong> ▸ <strong>Python File</strong>. Name it <em>point</em> and click <strong>OK</strong>. Inside the file, enter the code in <a href="ch04.xhtml#ch4lis3">Listing 4-3</a>.</p>&#13;
<pre>class Point:&#13;
    def __init__(self, x, y):&#13;
        self.x = x&#13;
        self.y = y</pre>&#13;
<p class="caption"><a id="ch4lis3"/><em>Listing 4-3: Our <span class="codeitalic1">Point</span> class</em></p>&#13;
<p class="indent">The coordinates are passed to the initializer method (<span class="literal">__init__</span>) and stored as attributes of the class.</p>&#13;
<p class="indent">With our initializer written, let’s implement some functionality.</p>&#13;
<h4 class="h4" id="ch00lev2sec35"><strong><em>Calculating Distance Between Points</em></strong></h4>&#13;
<p class="noindent">To compute the distance <em>d</em>(<em>P, Q</em>) between the two points <em>P</em> and <em>Q</em>, we use <a href="ch04.xhtml#ch04eqa01">Equation 4.1</a>.</p>&#13;
<div class="equationc" id="ch04eqa01"><img src="../images/04eqa01.jpg" alt="Image"/></div>&#13;
<p class="noindent">Here, <em>P</em><sub><em>x</em></sub> and <em>P</em><sub><em>y</em></sub> are <em>P</em>’s coordinates, and <em>Q</em><sub><em>x</em></sub> and <em>Q</em><sub><em>y</em></sub> are <em>Q</em>’s coordinates. We can see this graphically in <a href="ch04.xhtml#ch4fig2">Figure 4-2</a>.</p>&#13;
<div class="image"><img src="../images/04fig02.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch4fig2"><em>Figure 4-2: Distance between the points <span class="normal">P</span> and <span class="normal">Q</span></em></p>&#13;
<p class="indent">We can implement our distance calculation in two ways. We could call the method on a point <span class="literal">p</span> to compute the distance to another point <span class="literal">q</span>, as in <span class="literal">p.distance_to(q)</span>. We could also implement the same calculation as a function where both points are given as arguments: <span class="literal">distance_between(p, q)</span>. The former is the object-oriented style; the latter is functional. Because we’re doing object-oriented programming here, we’ll go with the former.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch4lis4">Listing 4-4</a> has the code to implement <a href="ch04.xhtml#ch04eqa01">Equation 4.1</a> in our class.</p>&#13;
<pre>import math&#13;
&#13;
&#13;
class Point:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def distance_to(self, other):&#13;
        <span epub:type="pagebreak" id="page_69"/>delta_x = other.x - self.x&#13;
        delta_y = other.y - self.y&#13;
        return math.sqrt(delta_x ** 2 + delta_y ** 2)</pre>&#13;
<p class="caption"><a id="ch4lis4"/><em>Listing 4-4: Calculating the distance between two points</em></p>&#13;
<p class="indent">First, we need to import the <em>math</em> module, which loads a bunch of useful mathematical operations into our class. We define the <span class="literal">distance_to</span> method with <span class="literal">self</span> and <span class="literal">other</span> as arguments: <span class="literal">self</span> is the current point, and <span class="literal">other</span> is the point we want to calculate the distance to. We then calculate the distance (or <em>delta</em>) between the two coordinates and use the power (<span class="literal">**</span>) operator to square both deltas and return the square root of their sum.</p>&#13;
<p class="indent">Now let’s test this out. Open the Python console from the IDE and try the following:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from geom2d.point import Point</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">p = Point(1, 3)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">q = Point(2, 4)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">p.distance_to(q)</span>&#13;
1.4142135623730951</pre>&#13;
<p class="indent">Exciting! We’ve taken the first major step in building our geometry library—Euclid would be proud. You can try that same operation with your calculator and see whether our implementation yields the correct result. Later in the chapter, we’ll automate a test that checks that the distance method yields the right result.</p>&#13;
<p class="indent">While we have the console open and <span class="literal">p</span> and <span class="literal">q</span> loaded, try the following:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">p</span>&#13;
&lt;geom2d.point.Point object at 0x10f8a2588&gt;&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">p.__dict__</span>&#13;
{'x': 1, 'y': 3}</pre>&#13;
<p class="indent">Evaluating point <span class="literal">p</span> yields a string telling us <span class="literal">p</span> is an object of the <span class="literal">Point</span> class at memory position <span class="literal">0x10f8a2588</span>. Note that the memory address you obtain will likely be different than mine. Without knowing everything in the computer’s memory (and reading hexadecimal), this description isn’t much help. You can also inspect the <span class="literal">__dict__</span> attribute of any class to get a dictionary of all the attributes it holds. That gives you more interesting information about the instance. Later in the chapter, we’ll be implementing a special method that will help print a cleaner description of the object, something like <span class="literal">(2, 5)</span>.</p>&#13;
<p class="indent">Let’s now focus our attention on overloading the + and – operators for the <span class="literal">Point</span> class.</p>&#13;
<h4 class="h4" id="ch00lev2sec36"><strong><em>Addition and Subtraction Operators</em></strong></h4>&#13;
<p class="noindent">The next basic operations we’ll need are addition and subtraction, operations that we’ll also implement for vectors. We’ll use these basic methods quite often, both on their own and to build more complex methods. We could implement them as normal methods, calling them with something like <span class="literal">p.plus(q)</span> <span epub:type="pagebreak" id="page_70"/>and <span class="literal">p.minus(q)</span>, but we can do better. Python allows us to overload + and – operators (as we learned in “Magic Methods” on <a href="ch02.xhtml#ch00lev2sec25">page 43</a>) so that we can write <span class="literal">p + q</span> and <span class="literal">p - q</span> and have Python know to add and subtract the points correctly. Overloading operators makes code like this much easier to read and understand.</p>&#13;
<p class="indent"><em>Overloading</em> an operator in Python involves implementing a method using a specific name that corresponds to the operator. Then, when Python finds the operator, it will replace it with the method you’ve defined and call it. For the + operator, the name is <span class="literal">__add__</span>, and for –, it is <span class="literal">__sub__</span>. <a href="ch04.xhtml#ch4tab1">Table 4-1</a> contains common operators we can overload in our classes.</p>&#13;
<p class="tabcap" id="ch4tab1"><strong>Table 4-1:</strong> Python’s Overloadable Operators</p>&#13;
<table class="all">&#13;
<tbody><tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Operator</strong></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Method Name</strong></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">+</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">__add__(self, other)</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Addition</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">-</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">__sub__(self, other)</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Subtraction</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">*</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">__mul__(self, other)</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Multiplication</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">/</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">__truediv__(self, other)</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Division</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">%</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">__mod__(self, other)</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Modulo</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">==</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">__eq__(self, other)</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Equality</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">!=</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">__ne__(self, other)</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Inequality</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">&lt;</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">__lt__(self, other)</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Less than</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">&lt;=</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">__le__(self, other)</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Less than or equal to</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">&gt;</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba"><span class="literal">__gt__(self, other)</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;"><p class="taba">Greater than</p>&#13;
</td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-hs1"><p class="taba"><span class="literal">&gt;=</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-hs1"><p class="taba"><span class="literal">__ge__(self, other)</span></p>&#13;
</td>&#13;
<td style="vertical-align: top;" class="table-hs1"><p class="taba">Greater than or equal to</p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Let’s implement the addition and subtraction operations as methods. Inside the <span class="literal">Point</span> class and after the <span class="literal">distance_to</span> method, add the code in <a href="ch04.xhtml#ch4lis5">Listing 4-5</a>.</p>&#13;
<pre>class Point:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def __add__(self, other):&#13;
       return Point(&#13;
           self.x + other.x,&#13;
           self.y + other.y&#13;
       )&#13;
&#13;
   def __sub__(self, other):&#13;
       return Point(&#13;
           self.x - other.x,&#13;
           self.y - other.y&#13;
       )</pre>&#13;
<p class="caption"><a id="ch4lis5"/><em>Listing 4-5: Adding and subtracting points</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_71"/>The method <span class="literal">__add__</span> creates and returns a new <span class="literal">Point</span> where its projections are the sum of the two parameters’ projections. This operation doesn’t make a lot of sense algebraically speaking, but we may find it useful later. The method <span class="literal">__sub__</span> does the same where the resulting projections are the subtraction of the input points’ projections. Subtracting two points <em>P – Q</em> yields a vector going from <em>Q</em> to <em>P</em>, but we haven’t created a class for vectors yet. We will refactor this code in the next section so that it returns a vector instance.</p>&#13;
<p class="indent">Let’s implement our next major primitive: the vector.</p>&#13;
<h3 class="h3" id="ch00lev1sec31"><strong>The Vector Class</strong></h3>&#13;
<p class="noindent">Similar to points, <em>vectors</em> in the Euclidean plane are composed of two numbers, called the coordinates, that encode a magnitude and a direction. The vector ⟨3, 5⟩, for instance, can be understood as the displacement achieved by moving 3 units in the positive direction of the horizontal axis and 5 units in the positive direction of the vertical axis. <a href="ch04.xhtml#ch4fig3">Figure 4-3</a> depicts a vector <img class="inline" src="../images/pvictorit.jpg" alt="Image"/> in the Euclidean plane.</p>&#13;
<div class="image"><img src="../images/04fig03.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch4fig3"><em>Figure 4-3: A vector <img class="inline" src="../images/pvictor.jpg" alt="Image"/> in the plane</em></p>&#13;
<p class="indent">Many physical quantities are vectorial: they require both a magnitude and a direction to be completely defined. For example, velocities, accelerations, and forces are all vector quantities. Since vectors are so common, let’s create a class to represent them.</p>&#13;
<p class="indent">Right-click the <em>geom2d</em> package folder and select <strong>New</strong> ▸ <strong>Python File</strong>. Name it <em>vector</em> and click <strong>OK</strong>. Then enter the code in <a href="ch04.xhtml#ch4lis6">Listing 4-6</a>.</p>&#13;
<pre>class Vector:&#13;
    def __init__(self, u, v):&#13;
        self.u = u&#13;
        self.v = v</pre>&#13;
<p class="caption"><a id="ch4lis6"/><em>Listing 4-6: Vector class</em></p>&#13;
<p class="indent">The implementation of <span class="literal">Vector</span> is similar to that of the <span class="literal">Point</span> class. The coordinates are named <span class="literal">u</span> and <span class="literal">v</span> instead of <span class="literal">x</span> and <span class="literal">y</span>. This is just a convention to avoid mixing points and vectors unwittingly.</p>&#13;
<p class="indent">Before we move on, let’s refactor the <span class="literal">Point</span> class’s <span class="literal">__sub__</span> method so that it returns a <span class="literal">Vector</span>. Recall that subtracting two points <em>P – Q</em> yields a vector going from <em>Q</em> to <em>P</em>. Modify your <em>point.py</em> file so that it now matches the code in <a href="ch04.xhtml#ch4lis7">Listing 4-7</a>.<span epub:type="pagebreak" id="page_72"/></p>&#13;
<pre>import math&#13;
&#13;
from geom2d.vector import Vector&#13;
&#13;
&#13;
class Point:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def __sub__(self, other):&#13;
        return Vector(&#13;
            self.x - other.x,&#13;
            self.y - other.y&#13;
        )</pre>&#13;
<p class="caption"><a id="ch4lis7"/><em>Listing 4-7: Refactoring <span class="codeitalic1">Point __sub__</span> method</em></p>&#13;
<p class="indent">We’ll take a closer look at this operation in “Vector Factories” on <a href="ch04.xhtml#ch00lev2sec52">page 89</a>, where we’ll use this operation to create vectors.</p>&#13;
<p class="indent">Let’s now implement some useful methods for the <span class="literal">Vector</span> class.</p>&#13;
<h4 class="h4" id="ch00lev2sec37"><strong><em>Addition and Subtraction Operators</em></strong></h4>&#13;
<p class="noindent">Like with points, adding vectors and subtracting them are common operations. For example, we can get the sum of two forces (which are vector quantities) by summing the vectors representing them.</p>&#13;
<p class="indent">After the <span class="literal">__init__</span> method, enter the code in <a href="ch04.xhtml#ch4lis8">Listing 4-8</a>.</p>&#13;
<pre>class Vector:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def __add__(self, other):&#13;
        return Vector(&#13;
            self.u + other.u,&#13;
            self.v + other.v&#13;
        )&#13;
&#13;
    def __sub__(self, other):&#13;
        return Vector(&#13;
            self.u - other.u,&#13;
            self.v - other.v&#13;
        )</pre>&#13;
<p class="caption"><a id="ch4lis8"/><em>Listing 4-8: Vector addition and subtraction</em></p>&#13;
<p class="indent">In both the <span class="literal">__add__</span> and <span class="literal">__sub__</span> methods, we create a new instance of <span class="literal">Vector</span> to hold the addition or subtraction of projections.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch4fig4">Figure 4-4</a> depicts the addition and subtraction operations of two vectors, <img class="inline" src="../images/pvictorit.jpg" alt="Image"/> and <img class="inline" src="../images/qvictorit.jpg" alt="Image"/>. Notice how subtracting <img class="inline" src="../images/pvictorit.jpg" alt="Image"/> – <img class="inline" src="../images/qvictorit.jpg" alt="Image"/> can be interpreted as the sum of <img class="inline" src="../images/pvictorit.jpg" alt="Image"/> and –<img class="inline" src="../images/qvictorit.jpg" alt="Image"/>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_73"/><img src="../images/04fig04.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch4fig4"><em>Figure 4-4: A sum of two vectors: <img class="inline" src="../images/pvictor.jpg" alt="Image"/> + <img class="inline" src="../images/qvictor.jpg" alt="Image"/> and a subtraction of two vectors: <img class="inline" src="../images/pvictor.jpg" alt="Image"/> – <img class="inline" src="../images/qvictor.jpg" alt="Image"/></em></p>&#13;
<p class="indent">Now you might be wondering if we’ll do the same thing for the other operators. Addition and subtraction translate easily to the world of points and vectors, but for something like the <span class="literal">__mul__</span> operator (used to overload the multiplication operation), it’s not as simple. It’s unclear whether multiplication would be the dot product, the cross product, or a vector scaling operation. Instead of using a single operator, we’ll simply implement these operations as methods with descriptive names: <span class="literal">scaled_by</span>, <span class="literal">dot</span>, and <span class="literal">cross</span>.</p>&#13;
<p class="indent">We’ll begin with scaling.</p>&#13;
<h4 class="h4" id="ch00lev2sec38"><strong><em>Scaling Vectors</em></strong></h4>&#13;
<p class="noindent">To <em>scale</em> a vector <img class="inline" src="../images/uvictorit.jpg" alt="Image"/>, you multiply it by a magnitude <em>k</em> called a <em>scalar</em>, which will stretch or shrink the vector. Mathematically, the scalar multiplication looks like <a href="ch04.xhtml#ch04eqa02">Equation 4.2</a>:</p>&#13;
<div class="equationc" id="ch04eqa02"><img src="../images/04eqa02.jpg" alt="Image"/></div>&#13;
<p class="indent">Let’s create a scaling method in the <span class="literal">Vector</span> class. Enter the code in <a href="ch04.xhtml#ch4lis9">Listing 4-9</a> under the <span class="literal">__sub__</span> method.</p>&#13;
<pre>class Vector:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def scaled_by(self, factor):&#13;
       return Vector(factor * self.u, factor * self.v)</pre>&#13;
<p class="caption"><a id="ch4lis9"/><em>Listing 4-9: Scaling a vector</em></p>&#13;
<p class="indent">In the previous code, we simply return a new <span class="literal">Vector</span> whose <span class="literal">u</span> and <span class="literal">v</span> attributes are multiplied by <span class="literal">factor</span>, the passed-in scalar.</p>&#13;
<h4 class="h4" id="ch00lev2sec39"><strong><em>Displacing Points</em></strong></h4>&#13;
<p class="noindent">Using the <span class="literal">scaled</span> method, we can implement another operation: displacing a point <em>P</em> by a given vector <img class="inline" src="../images/uvictorit.jpg" alt="Image"/> <em>k</em> times. Mathematically, that looks like <a href="ch04.xhtml#ch04eqa03">Equation 4.3</a>.</p>&#13;
<div class="equationc" id="ch04eqa03"><img src="../images/04eqa03.jpg" alt="Image"/></div>&#13;
<p class="noindent">Graphically it looks like <a href="ch04.xhtml#ch4fig5">Figure 4-5</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_74"/><img src="../images/04fig05.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch4fig5"><em>Figure 4-5: Displacing a point <span class="normal">P</span> by a vector <img class="inline" src="../images/uvictor.jpg" alt="Image"/> a given number of times <span class="normal">k</span> (2 in this case)</em></p>&#13;
<p class="indent">Let’s implement it programmatically inside our <span class="literal">Point</span> class, as the displacement subject is the point (<a href="ch04.xhtml#ch4lis10">Listing 4-10</a>).</p>&#13;
<pre>class Point:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def displaced(self, vector: Vector, times=1):&#13;
       scaled_vec = vector.scaled_by(times)&#13;
       return Point(&#13;
           self.x + scaled_vec.u,&#13;
           self.y + scaled_vec.v&#13;
       )</pre>&#13;
<p class="caption"><a id="ch4lis10"/><em>Listing 4-10: Displacing a point <span class="normal">P</span> by a vector <img class="inline" src="../images/vvictorit.jpg" alt="Image"/> a given number of times <span class="normal">k</span></em></p>&#13;
<p class="indent">The method gets passed two arguments: a vector <span class="literal">vector</span> and a scalar <span class="literal">times</span>. The vector is scaled according to <span class="literal">times</span> to produce the net displacement. For instance, a vector ⟨3, 5⟩ scaled with <span class="literal">times = 2</span> would result in a displacement of ⟨6, 10⟩. Note the parameter <span class="literal">times</span> gets a default value of <span class="literal">1</span>, as often the passed <span class="literal">vector</span> already has the desired length. The returned point results from adding the coordinates of the source point and the displacement vector’s coordinates.</p>&#13;
<p class="indent">Let’s try to move a point in the Python shell. Restart the console so the previously imported <span class="literal">Point</span> and <span class="literal">Vector</span> classes don’t get in the way, and enter the following:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from geom2d.point import Point</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">from geom2d.vector import Vector</span>&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">p = Point(2, 3)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">v = Vector(10, 20)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">p_prime = p.displaced(v, 2)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">p_prime.__dict__</span>&#13;
{'x': 22, 'y': 43}</pre>&#13;
<p class="indent">You can use a calculator to confirm that the math works as expected.</p>&#13;
<h4 class="h4" id="ch00lev2sec40"><strong><em>Vector Norms</em></strong></h4>&#13;
<p class="noindent">A <em>norm</em> of a vector is its length. A <em>unitary norm</em> is a norm whose length is exactly one unit. Vectors with a unitary norm are useful for defining directions; <span epub:type="pagebreak" id="page_75"/>hence, we’ll frequently want to know whether a vector has a unitary norm (whether it’s <em>normal</em>). We’ll also frequently want to <em>normalize</em> a vector: keep its direction but scale it to have a length of 1. The norm of a two-dimensional vector is given by <a href="ch04.xhtml#ch04eqa04">Equation 4.4</a>.</p>&#13;
<div class="equationc" id="ch04eqa04"><img src="../images/04eqa04.jpg" alt="Image"/></div>&#13;
<p class="indent">Let’s implement a property that returns the norm of <span class="literal">Vector</span>, and let’s implement another property that checks whether the vector is normal. Both are included in <a href="ch04.xhtml#ch4lis11">Listing 4-11</a>.</p>&#13;
<pre>import math&#13;
&#13;
from geom2d import nums&#13;
&#13;
&#13;
class Vector:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    @property&#13;
    def norm(self):&#13;
        return math.sqrt(self.u ** 2 + self.v ** 2)&#13;
&#13;
    @property&#13;
    def is_normal(self):&#13;
        return nums.is_close_to_one(self.norm)</pre>&#13;
<p class="caption"><a id="ch4lis11"/><em>Listing 4-11: Norm of a vector</em></p>&#13;
<p class="indent">The value obtained from the <span class="literal">norm</span> property follows exactly the definition from <a href="ch04.xhtml#ch04eqa04">Equation 4.4</a>. To know whether a vector has a norm of 1, we use our numeric comparison <span class="literal">is_close_to_one</span> and pass in the vector’s norm.</p>&#13;
<p class="indent">We’ll implement two other important operations: a method that normalizes a vector <img class="inline" src="../images/uvictorit.jpg" alt="Image"/>, yielding a vector <em>û</em> with the same direction but unitary length, and a method that scales a vector to have a given length. A normalized version of a vector, which we’ll call a <em>unit vector</em> or <em>versor</em>, can be obtained using <a href="ch04.xhtml#ch04eqa05">Equation 4.5</a>.</p>&#13;
<div class="equationc" id="ch04eqa05"><img src="../images/04eqa05.jpg" alt="Image"/></div>&#13;
<p class="indent">A vector computed this way will have a length of 1. Multiplying that vector by a scalar <em>k</em> results in a vector <img class="inline" src="../images/uvictorit.jpg" alt="Image"/><em><sub>k</sub></em>, which has the same direction as the original but with a new length that’s exactly the value of the scalar, as shown in <a href="ch04.xhtml#ch04eqa06">Equation 4.6</a>.</p>&#13;
<div class="equationc" id="ch04eqa06"><img src="../images/04eqa06.jpg" alt="Image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_76"/>In <a href="ch04.xhtml#ch4lis12">Listing 4-12</a>, we’ll turn those equations into code.</p>&#13;
<pre>class Vector:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def normalized(self):&#13;
       return self.scaled_by(1.0 / self.norm)&#13;
&#13;
   def with_length(self, length):&#13;
       return self.normalized().scaled_by(length)</pre>&#13;
<p class="caption"><a id="ch4lis12"/><em>Listing 4-12: Vectors with unit or chosen length</em></p>&#13;
<p class="indent">To normalize a vector, we scale it by the inverse of its norm (which is equivalent to dividing the vector’s length by its norm). When we want a vector scaled to a given length, we simply normalize the vector and then scale it by the desired length.</p>&#13;
<h4 class="h4" id="ch00lev2sec41"><strong><em>Immutable Design</em></strong></h4>&#13;
<p class="noindent">You may have realized by now that we never mutate the attributes of any of our objects but rather create and return a new <span class="literal">Point</span> or <span class="literal">Vector</span> instance. To normalize a vector, for instance, we could have used the code in <a href="ch04.xhtml#ch4lis13">Listing 4-13</a>.</p>&#13;
<pre>def normalize(self):&#13;
   norm = self.norm&#13;
    self.x = self.x / norm&#13;
    self.y = self.y / norm</pre>&#13;
<p class="caption"><a id="ch4lis13"/><em>Listing 4-13: Normalization of a vector in place</em></p>&#13;
<p class="indent">Calling that method would result in a <em>normalization in place</em>, that is, a mutation of the current object’s attributes. Normalizing in place is faster and requires less memory but is also much more error-prone. It’s easier than it seems for your program to mistakenly mutate an object that is being used by other parts of the program not expecting the change. Finding these kinds of bugs is really tricky and requires extensive debugging. Furthermore, programs using immutable data are much easier to understand and reason about, as you don’t need to keep track of how objects change their state with respect to time.</p>&#13;
<p class="indent">Take a look at the following code. It implements the <span class="literal">normalize</span> method in a similar way to the previous one, but it contains a subtle error. In this case, the normalization would yield a wrong result. Can you spot why?</p>&#13;
<pre>def normalize(self):&#13;
    self.x = self.x / self.norm&#13;
    self.y = self.y / self.norm</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_77"/>This is a tricky one. By mutating the <span class="literal">self.x</span> attribute in the first line, the second call to get the <span class="literal">self.norm</span> property will use the updated value for <span class="literal">self.x</span>. The first and second calls to <span class="literal">self.norm</span> yield different results, which is why we had to store the value of <span class="literal">self.norm</span> in a variable.</p>&#13;
<p class="indent">When the amount of data the object has is small, you’re better off avoiding mutations altogether. Your program will behave correctly if executed concurrently, and your code will be simpler to understand. Reducing mutability to a minimum will make your code more robust; as you’ll see throughout the book, we’ll adhere to this principle as much as we can.</p>&#13;
<h4 class="h4" id="ch00lev2sec42"><strong><em>Naming Convention</em></strong></h4>&#13;
<p class="noindent">Notice the naming convention for methods. Methods mutating the state of the object upon calling are named as follows:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><span class="codestrong">normalize</span>    Normalizes the vector in place</p>&#13;
<p class="noindentin"><span class="codestrong">scale_by</span>    Scales the vector in place</p>&#13;
</div>&#13;
<p class="noindent">Methods creating a new object as their result are named as follows:</p>&#13;
<div class="bqparan">&#13;
<p class="noindentin"><span class="codestrong">normalized</span>    Returns a new normalized vector</p>&#13;
<p class="noindentin"><span class="codestrong">scaled_by</span>    Returns a new scaled vector</p>&#13;
</div>&#13;
<p class="indent">Next, we’ll implement the dot and cross products in our <span class="literal">Vector</span> class. These simple products will open the door to some useful operations such as computing the angle between two vectors or testing for perpendicularity.</p>&#13;
<h4 class="h4" id="ch00lev2sec43"><strong><em>Dot Product</em></strong></h4>&#13;
<p class="noindent">The <em>dot product</em> between two vectors <img class="inline" src="../images/uvictorit.jpg" alt="Image"/> and <img class="inline" src="../images/vvictorit.jpg" alt="Image"/> yields a scalar value, a measure of how different the directions of the two vectors are. In two dimensions, with <em>θ</em> being the angle between the vectors, this product is given by <a href="ch04.xhtml#ch04eqa07">Equation 4.7</a>.</p>&#13;
<div class="equationc" id="ch04eqa07"><img src="../images/04eqa07.jpg" alt="Image"/></div>&#13;
<p class="indent">To understand the different values the dot product can have depending on the relative directions of the two operand vectors, let’s take a look at <a href="ch04.xhtml#ch4fig6">Figure 4-6</a>. This figure depicts a reference vector <img class="inline" src="../images/vvictorit.jpg" alt="Image"/> and three other vectors: <img class="inline" src="../images/avictorit.jpg" alt="Image"/>, <img class="inline" src="../images/bvictorit.jpg" alt="Image"/>, and <img class="inline" src="../images/cvictorit.jpg" alt="Image"/>. A line perpendicular to <img class="inline" src="../images/vvictorit.jpg" alt="Image"/> divides the space in two half-planes. Vector <img class="inline" src="../images/bvictorit.jpg" alt="Image"/> lies on that line, so the angle <em>θ</em> between <img class="inline" src="../images/vvictorit.jpg" alt="Image"/> and <img class="inline" src="../images/bvictorit.jpg" alt="Image"/> is 90°, and since cos(90<sup>°</sup>) = 0, then <img class="inline" src="../images/vvictorit.jpg" alt="Image"/> · <img class="inline" src="../images/bvictorit.jpg" alt="Image"/> = 0. Perpendicular vectors yield a dot product of zero. Vector <img class="inline" src="../images/avictorit.jpg" alt="Image"/> happens to be on the same half-plane as <img class="inline" src="../images/vvictorit.jpg" alt="Image"/>; therefore, <img class="inline" src="../images/vvictorit.jpg" alt="Image"/> · <img class="inline" src="../images/avictorit.jpg" alt="Image"/> &gt; 0. Lastly, <img class="inline" src="../images/cvictorit.jpg" alt="Image"/> is on the opposite half-plane of <img class="inline" src="../images/vvictorit.jpg" alt="Image"/>; hence, <img class="inline" src="../images/vvictorit.jpg" alt="Image"/> · <img class="inline" src="../images/cvictorit.jpg" alt="Image"/> &lt; 0.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_78"/><img src="../images/04fig06.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch4fig6"><em>Figure 4-6: Vector directions with respect to <img class="inline" src="../images/normal_avictor.jpg" alt="Image"/> yield different dot products.</em></p>&#13;
<p class="indent">Implementing the dot product is straightforward from <a href="ch04.xhtml#ch04eqa07">Equation 4.7</a>. Inside the <span class="literal">Vector</span> class, enter the code in <a href="ch04.xhtml#ch4lis14">Listing 4-14</a>.</p>&#13;
<pre>class Vector:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def dot(self, other):&#13;
       return (self.u * other.u) + (self.v * other.v)</pre>&#13;
<p class="caption"><a id="ch4lis14"/><em>Listing 4-14: Dot product</em></p>&#13;
<p class="indent">Before we move on to the cross product, let’s stop for a minute and analyze one of its applications: obtaining the projection of a vector in a given direction.</p>&#13;
<h4 class="h4" id="ch00lev2sec44"><strong><em>Projecting Vectors</em></strong></h4>&#13;
<p class="noindent">When one of the vectors involved in a dot product is a unit vector, this operation’s result is the length of the projection of one vector over the other vector. To see why, let’s use <a href="ch04.xhtml#ch04eqa07">Equation 4.7</a>. Given a vector <img class="inline" src="../images/uvictorit.jpg" alt="Image"/> and a unit vector <img class="inline" src="../images/vcapit.jpg" alt="Image"/>, the dot product is:</p>&#13;
<div class="equationc"><img src="../images/f0078.jpg" alt="Image"/></div>&#13;
<p class="indent">where <img class="inline" src="../images/udouble_line.jpg" alt="Image"/> · cos<em>θ</em> is exactly the projection of <img class="inline" src="../images/uvictorit.jpg" alt="Image"/> over the direction of <img class="inline" src="../images/vcapit.jpg" alt="Image"/>. This will be handy for computing projections over a direction, which we could use to obtain the axial component of a force on a truss member, for example, as illustrated in <a href="ch04.xhtml#ch4fig7">Figure 4-7</a>. In this case, we’d simply have to do <img class="inline" src="../images/f0078-1.jpg" alt="Image"/> to compute the axial component <img class="inline" src="../images/fapvictor.jpg" alt="Image"/>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_79"/><img src="../images/04fig07.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch4fig7"><em>Figure 4-7: Projection of a force <img class="inline" src="../images/fvictor.jpg" alt="Image"/> in the axial direction <img class="inline" src="../images/ucap.jpg" alt="Image"/> of a truss member</em></p>&#13;
<p class="indent">Let’s implement this operation as a new method. Enter the code from <a href="ch04.xhtml#ch4lis15">Listing 4-15</a> into your class.</p>&#13;
<pre>class Vector:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def projection_over(self, direction):&#13;
       return self.dot(direction.normalized())</pre>&#13;
<p class="caption"><a id="ch4lis15"/><em>Listing 4-15: Projection of a vector over another vector</em></p>&#13;
<p class="indent">Note that the <span class="literal">direction</span> argument may not be a unit vector. To make sure our formula works, we normalize it.</p>&#13;
<h4 class="h4" id="ch00lev2sec45"><strong><em>Cross Product</em></strong></h4>&#13;
<p class="noindent">The <em>cross product</em> of two three-dimensional vectors yields a new vector that is perpendicular to the plane containing the other two. The order of operands matters and defines the direction of the resulting vector. You can figure out the direction of the cross product using the right-hand rule. Notice that this product is therefore noncommutative: <img class="inline" src="../images/f0079-3.jpg" alt="Image"/> <a href="ch04.xhtml#ch4fig8">Figure 4-8</a> illustrates this phenomenon.</p>&#13;
<div class="image"><img src="../images/04fig08.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch4fig8"><em>Figure 4-8: Cross products are noncommutative.</em></p>&#13;
<p class="indent">In 3D space, the cross product can be computed using <a href="ch04.xhtml#ch04eqa08">Equation 4.8</a>.</p>&#13;
<div class="equationc" id="ch04eqa08"><img src="../images/04eqa08.jpg" alt="Image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_80"/>When working in two dimensions, every vector is contained in the same plane; thus, every cross product yields a vector perpendicular to that plane. That is easy to observe from the previous expression by simply noting that <em>u</em><sub><em>z</em></sub> = <em>v</em><sub><em>z</em></sub> = 0:</p>&#13;
<div class="equationc"><img src="../images/f0080-01.jpg" alt="Image"/></div>&#13;
<p class="indent">In two-dimensional applications, the cross product is therefore considered to yield a scalar value, which is the z-coordinate of the previous expression’s resulting vector. You can think of this coordinate as being the length of the resulting vector. Since the x- and y-coordinates are zero, this magnitude given by the z-coordinate is all we need to keep. Given <em>θ</em> as the angle between vectors <img class="inline" src="../images/uvictorit.jpg" alt="Image"/> and <img class="inline" src="../images/vvictorit.jpg" alt="Image"/>, the cross product operation in two dimensions can be obtained by applying <a href="ch04.xhtml#ch04eqa09">Equation 4.9</a>.</p>&#13;
<div class="equationc" id="ch04eqa09"><img src="../images/04eqa09.jpg" alt="Image"/></div>&#13;
<p class="indent">Let’s implement the cross product. Enter the code in <a href="ch04.xhtml#ch4lis16">Listing 4-16</a>.</p>&#13;
<pre>class Vector:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def cross(self, other):&#13;
       return (self.u * other.v) - (self.v * other.u)</pre>&#13;
<p class="caption"><a id="ch4lis16"/><em>Listing 4-16: Cross product</em></p>&#13;
<p class="indent">One important application of the cross product in two dimensions is determining the rotational direction of angles. From <a href="ch04.xhtml#ch4fig8">Figure 4-8</a> you can see that <img class="inline" src="../images/uvictorit.jpg" alt="Image"/> × <img class="inline" src="../images/vvictorit.jpg" alt="Image"/> &gt; 0, since going from <img class="inline" src="../images/uvictorit.jpg" alt="Image"/> to <img class="inline" src="../images/vvictorit.jpg" alt="Image"/> describes a positive (counterclockwise) angle. Conversely, going from <img class="inline" src="../images/vvictorit.jpg" alt="Image"/> to <img class="inline" src="../images/uvictorit.jpg" alt="Image"/> describes a negative angle resulting in a negative cross product <img class="inline" src="../images/uvictorit.jpg" alt="Image"/> × <img class="inline" src="../images/vvictorit.jpg" alt="Image"/> &lt; 0. Lastly, note that parallel vectors have a cross product of zero, which is easy to see because sin 0 = 0. Let’s take a closer look at this fact and write methods in our class that determine whether two vectors are parallel or perpendicular.</p>&#13;
<h4 class="h4" id="ch00lev2sec46"><strong><em>Parallel and Perpendicular Vectors</em></strong></h4>&#13;
<p class="noindent">Using the dot and cross products, it’s easy to test whether two vectors are parallel or perpendicular to each other. <a href="ch04.xhtml#ch4lis17">Listing 4-17</a> contains the code for these operations.</p>&#13;
<pre>class Vector:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def is_parallel_to(self, other):&#13;
       return nums.is_close_to_zero(&#13;
           self.cross(other)&#13;
       )&#13;
&#13;
   <span epub:type="pagebreak" id="page_81"/>def is_perpendicular_to(self, other):&#13;
       return nums.is_close_to_zero(&#13;
           self.dot(other)&#13;
       )</pre>&#13;
<p class="caption"><a id="ch4lis17"/><em>Listing 4-17: Checking whether vectors are parallel or perpendicular</em></p>&#13;
<p class="indent">Checking whether two vectors are parallel to each other is as simple as checking that their cross product is zero. Likewise, checking whether two vectors are perpendicular is as simple as checking whether the dot product is zero. Notice that we use the function <span class="literal">is_close_to_zero</span> to account for floating-point number comparison difficulties in the calculations.</p>&#13;
<h4 class="h4" id="ch00lev2sec47"><strong><em>Angles Between Vectors</em></strong></h4>&#13;
<p class="noindent">Computing the angle between two vectors can be done with the help of the dot product expression:</p>&#13;
<div class="equationc"><img src="../images/f0081-01.jpg" alt="Image"/></div>&#13;
<p class="noindent">Dividing the dot product term on one side by the norm product on the other and taking the inverse of the cosine of that expression, we get <a href="ch04.xhtml#ch04eqa10">Equation 4.10</a>:</p>&#13;
<div class="equationc" id="ch04eqa10"><img src="../images/04eqa10.jpg" alt="Image"/></div>&#13;
<p class="indent">This expression computes only the magnitude of the angle; if we want to know the direction, we’ll need to make use of the cross product. The sign of the angle can be obtained using</p>&#13;
<div class="equationc"><img src="../images/f0081-02.jpg" alt="Image"/></div>&#13;
<p class="noindent">where sgn, the sign function, is defined as follows:</p>&#13;
<div class="equationc"><img src="../images/f0081-03.jpg" alt="Image"/></div>&#13;
<p class="indent">To understand why we only get the magnitude of the angle using <a href="ch04.xhtml#ch04eqa10">Equation 4.10</a>, we need to remember an important property of the cosine function. Recall from basic geometry that a unit vector’s angle cosine is exactly the value of its horizontal projection. As you can see by inspecting the unit circle from <a href="ch04.xhtml#ch4fig9">Figure 4-9</a>, two vectors with opposite angles (angles where the sum equals zero) get assigned the same cosine value. In other words, cos <em>α</em> = cos (–<em>α</em>), which means that once an angle goes through the cosine function, its sign is forever lost. That makes it impossible to determine what the angle’s sign is from a computed value of the dot product.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_82"/><img src="../images/04fig09.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch4fig9"><em>Figure 4-9: Cosines of opposite angles are equal.</em></p>&#13;
<p class="indent">For many of our applications, we’ll be needing both the magnitude and sign of angles; with the help of the cross product, we can bring this information back. Let’s create two new methods, one that yields the absolute value of the angle (for those cases where the magnitude is enough) and another one that includes the sign. Enter the code in <a href="ch04.xhtml#ch4lis18">Listing 4-18</a> in your <span class="literal">Vector</span> class.</p>&#13;
<pre>class Vector:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def angle_value_to(self, other):&#13;
       dot_product = self.dot(other)&#13;
       norm_product = self.norm * other.norm&#13;
       return math.acos(dot_product / norm_product)&#13;
&#13;
   def angle_to(self, other):&#13;
       value = self.angle_value_to(other)&#13;
       cross_product = self.cross(other)&#13;
       return math.copysign(value, cross_product)</pre>&#13;
<p class="caption"><a id="ch4lis18"/><em>Listing 4-18: Calculating the angle between two vectors</em></p>&#13;
<p class="indent">The first method, <span class="literal">angle_value_to</span>, computes the angle between <span class="literal">self</span> and <span class="literal">other</span> using <a href="ch04.xhtml#ch04eqa10">Equation 4.10</a>. We first obtain the dot product value and divide it by the product of norms. The angle is then the arc cosine of the result. The second method, <span class="literal">angle_to</span>, returns the value of the angle with the sign from the cross product. The <span class="literal">math.copysign(x, y)</span> function in Python returns the magnitude of <span class="literal">x</span> with the sign of <span class="literal">y</span>.</p>&#13;
<p class="indent">Let’s try these two methods in the console. Reload it and write the following:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from geom2d.vector import Vector</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">u = Vector(1, 0)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">v = Vector(1, 1)</span>&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">v.angle_value_to(u)</span>&#13;
0.7853981633974484 # result in radians&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">v.angle_to(u)</span>&#13;
-0.7853981633974484 # result in radians</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_83"/>Just for reference, the angle value of 0.78539... is <em>π</em>/4 rad (45<sup>°</sup>).</p>&#13;
<p class="indent">Now let’s suppose we have a vector and want to create a new one by rotating the original by a certain angle.</p>&#13;
<h4 class="h4" id="ch00lev2sec48"><strong><em>Rotating Vectors</em></strong></h4>&#13;
<p class="noindent">Imagine that in the case of the bar subject to an external force, as we saw in <a href="ch04.xhtml#ch4fig7">Figure 4-7</a>, we’re also interested in knowing the projection of force <img class="inline" src="../images/fvictorit.jpg" alt="Image"/> in the direction perpendicular to the bar. This is the force’s shear component. To find the projection of the force, we first need to figure out a vector perpendicular to the direction of the bar <em>û</em>, which is obtained by rotating this vector <em>π</em>/2 radians, as illustrated in <a href="ch04.xhtml#ch4fig10">Figure 4-10</a>.</p>&#13;
<div class="image"><img src="../images/04fig10.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch4fig10"><em>Figure 4-10: Rotating the bar’s direction vector <em>π</em>/2 radians</em></p>&#13;
<p class="indent">A rotation preserves the length of the original vector because a rotation is a transformation that respects lengths. Assuming <em>α</em> is the angle that we want the vector rotated by, we can use <a href="ch04.xhtml#ch04eqa11">Equation 4.11</a>:</p>&#13;
<div class="equationc" id="ch04eqa11"><img src="../images/04eqa11.jpg" alt="Image"/></div>&#13;
<p class="noindent">which in Python becomes the code in <a href="ch04.xhtml#ch4lis19">Listing 4-19</a>.</p>&#13;
<pre>class Vector:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def rotated_radians(self, radians):&#13;
       cos = math.cos(radians)&#13;
       sin = math.sin(radians)&#13;
       return Vector(&#13;
           self.u * cos - self.v * sin,&#13;
           self.u * sin + self.v * cos&#13;
       )</pre>&#13;
<p class="caption"><a id="ch4lis19"/><em>Listing 4-19: Rotating a vector</em></p>&#13;
<p class="indent">The <span class="literal">rotated_radians</span> function returns a new vector, the result of rotating the original one by the given number of radians. Following our immutability guidelines, we never mutate the source vector; instead, we return a new one with the rotation applied.</p>&#13;
<p class="indent">There’s one angle, <em>π</em>/2 rad (90<sup>°</sup>), which is quite useful for rotating a vector. Using <em>π</em>/2 rad, we get a new vector perpendicular to the original one. <span epub:type="pagebreak" id="page_84"/>To avoid writing <span class="literal">v.rotated_radians(math.pi / 2)</span> over and over again, we can define a new method in our <span class="literal">Vector</span> class. Knowing that cos (<em>π</em>/2) = 0 and sin (<em>π</em>/2) = 1, the angle in <a href="ch04.xhtml#ch04eqa11">Equation 4.11</a> simplifies to the following:</p>&#13;
<div class="equationc"><img src="../images/f0084-01.jpg" alt="Image"/></div>&#13;
<p class="indent">Let’s call the method <span class="literal">perpendicular</span>. In Python, it looks like <a href="ch04.xhtml#ch4lis20">Listing 4-20</a>.</p>&#13;
<pre>class Vector:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def perpendicular(self):&#13;
       return Vector(-self.v, self.u)</pre>&#13;
<p class="caption"><a id="ch4lis20"/><em>Listing 4-20: Obtaining a perpendicular vector</em></p>&#13;
<p class="indent">There’s another angle we’ll often use for rotations: <em>π</em> rad (180<sup>°</sup>). Rotating a vector <em>π</em> rad results in a vector that is colinear but in the opposite direction. This time, cos (<em>π</em>) = –1 and sin (<em>π</em>) = 0. The angle in <a href="ch04.xhtml#ch04eqa11">Equation 4.11</a> now looks like this:</p>&#13;
<div class="equationc"><img src="../images/f0084-02.jpg" alt="Image"/></div>&#13;
<p class="indent">Let’s call the method <span class="literal">opposite</span>. In Python, it looks like <a href="ch04.xhtml#ch4lis21">Listing 4-21</a>.</p>&#13;
<pre>class Vector:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def opposite(self):&#13;
       return Vector(-self.u, -self.v)</pre>&#13;
<p class="caption"><a id="ch4lis21"/><em>Listing 4-21: Obtaining the opposite vector</em></p>&#13;
<p class="indent">These two methods, <span class="literal">perpendicular</span> and <span class="literal">opposite</span>, don’t really add anything we didn’t have before; we could just use <span class="literal">rotated_radians</span>. Nevertheless, they’re convenient, and we’ll be using them often.</p>&#13;
<h4 class="h4" id="ch00lev2sec49"><strong><em>Sine and Cosine</em></strong></h4>&#13;
<p class="noindent">To project a vector quantity in the x- and y-axes, we use the sine or cosine values of the vector’s angle, as depicted in <a href="ch04.xhtml#ch4fig11">Figure 4-11</a>.</p>&#13;
<p class="indent">We’ll use these to compute the stiffness matrices in global coordinates of truss structure bars in <a href="part05.xhtml#part05">Part V</a> of the book. The stiffness matrix of a bar is computed relative to a reference frame whose x-axis is in the direction of the bar’s directrix, but we’ll need to project this matrix in the direction of the global x- and y-axes to build the structure’s global system of equations.</p>&#13;
<p class="indent">If the <span class="literal">Vector</span> class didn’t provide these two properties, clients of this class could get its angle value and then compute the sine or cosine of it. Even though this is perfectly acceptable, it requires a few operations to first compute the angle and then one extra sine or cosine operation. But as you know, we can compute the sine and cosine values much more efficiently by their mathematical definition.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_85"/><img src="../images/04fig11.jpg" alt="Image"/></div>&#13;
<p class="figcap" id="ch4fig11"><em>Figure 4-11: Vector projections</em></p>&#13;
<p class="indent">Say we have vector <img class="inline" src="../images/avictorit.jpg" alt="Image"/> with norm ∥<img class="inline" src="../images/avictorit.jpg" alt="Image"/>∥, whose projections are labeled <em>u</em> and <em>v</em>. The sine and cosine can be computed as follows:</p>&#13;
<div class="equationc"><img src="../images/f0085-01.jpg" alt="Image"/></div>&#13;
<p class="indent">Let’s implement these as attributes of the <span class="literal">Vector</span> class. Enter the code in <a href="ch04.xhtml#ch4lis22">Listing 4-22</a>.</p>&#13;
<pre>class Vector:&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    @property&#13;
    def sine(self):&#13;
        return self.v / self.norm&#13;
&#13;
    @property&#13;
    def cosine(self):&#13;
        return self.u / self.norm</pre>&#13;
<p class="caption"><a id="ch4lis22"/><em>Listing 4-22: Vector’s direction sine and cosine</em></p>&#13;
<p class="indent">The implementation is straightforward given the previous expressions. Let’s complete our <span class="literal">Point</span> and <span class="literal">Vector</span> classes by adding the last touches.</p>&#13;
<h3 class="h3" id="ch00lev1sec32"><strong>Completing Our Classes</strong></h3>&#13;
<p class="noindent">Our <span class="literal">Point</span> and <span class="literal">Vector</span> classes are looking good, but they’re missing some small details. If we compare two instances of any of them, Python may not be able to determine whether they are equivalent; we’ll fix that shortly. Also, if you remember, Python prints object instances to the console giving their class name accompanied with a memory address, which is not that helpful for us; we’ll also fix this here.</p>&#13;
<h4 class="h4" id="ch00lev2sec50"><strong><em>Checking Equality</em></strong></h4>&#13;
<p class="noindent">Try entering the following in the shell (don’t forget to reload it).<span epub:type="pagebreak" id="page_86"/></p>&#13;
<pre>  &gt;&gt;&gt; <span class="codestrong1">from geom2d.point import Point</span>&#13;
  &gt;&gt;&gt; <span class="codestrong1">p = Point(1, 0)</span>&#13;
  &gt;&gt;&gt; <span class="codestrong1">p == p</span>&#13;
<span class="ent">➊</span>  True&#13;
&#13;
  &gt;&gt;&gt; <span class="codestrong1">q = Point(1, 0)</span>&#13;
  &gt;&gt;&gt; <span class="codestrong1">p == q</span>&#13;
<span class="ent">➋</span>  False</pre>&#13;
<p class="indent">I bet <span class="ent">➊</span> didn’t surprise you: a <span class="literal">Point</span> is equal to itself. What about <span class="ent">➋</span>? Did you raise your eyebrows? We are comparing two points with the same coordinates, but Python states they are different. Shouldn’t (1, 0) be equal to (1, 0)? It should, but first we have to teach Python how to compare two given instances of our class. By default Python considers two instances of a class to be equal if they’re effectively the same instance, that is, if they live in the same memory region. To be more explicit, write this to the console:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">p</span>&#13;
&lt;geom2d.point.Point object at 0x10baa3f60&gt;&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">q</span>&#13;
&lt;geom2d.point.Point object at 0x10c63b438&gt;</pre>&#13;
<p class="indent">Python sees instance <span class="literal">p</span> as the one on the memory address <span class="literal">0x10baa3f60</span> and instance <span class="literal">q</span> on <span class="literal">0x10c63b438</span>. Don’t forget that the memory addresses of your instances will differ from these. We must instruct Python to compare our <span class="literal">Point</span> instances by checking whether the projections are close enough to be considered the same. If you recall from <a href="ch04.xhtml#ch4tab1">Table 4-1</a>, by implementing a method called <span class="literal">__eq__(self, other)</span>, you are effectively overloading the <span class="literal">==</span> operator. Let’s do this for both the <span class="literal">Point</span> and <span class="literal">Vector</span> classes.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch4lis23">Listing 4-23</a> contains the code for the <span class="literal">Point</span> class (don’t forget to import <span class="literal">nums</span>).</p>&#13;
<pre>import math&#13;
&#13;
from geom2d import nums&#13;
&#13;
&#13;
class Point:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def __eq__(self, other):&#13;
      if self is other:&#13;
           return True&#13;
&#13;
       if not isinstance(other, Point):&#13;
           return False&#13;
&#13;
       <span epub:type="pagebreak" id="page_87"/>return nums.are_close_enough(self.x, other.x) and \&#13;
              nums.are_close_enough(self.y, other.y)</pre>&#13;
<p class="caption"><a id="ch4lis23"/><em>Listing 4-23: Point equality implementation</em></p>&#13;
<p class="noindent"><a href="ch04.xhtml#ch4lis24">Listing 4-24</a> contains the code for the <span class="literal">Vector</span> class.</p>&#13;
<pre>import math&#13;
&#13;
from geom2d import nums&#13;
&#13;
&#13;
class Vector:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def __eq__(self, other):&#13;
      if self is other:&#13;
           return True&#13;
&#13;
       if not isinstance(other, Vector):&#13;
           return False&#13;
&#13;
       return nums.are_close_enough(self.u, other.u) and \&#13;
              nums.are_close_enough(self.v, other.v)</pre>&#13;
<p class="caption"><a id="ch4lis24"/><em>Listing 4-24: Implementing vector equality</em></p>&#13;
<p class="indent">As you can see, in both cases the idea is the same: comparing coordinates against another given instance. Prior to that, we do two important checks, though. The first one is to check for the case where we are comparing the same instance against itself, in which case we don’t require any further comparison, so we directly return <span class="literal">True</span>. The second check is for the case where <span class="literal">other</span> is not an instance of the class. Since Python allows us to compare any two objects, we may be comparing an instance of <span class="literal">Vector</span> against a string, for example. If we detect this case where we try to compare instances from different classes, we return <span class="literal">False</span>, and we’re done. You’ll see this comparison pattern throughout the book, as all of our classes implementing <span class="literal">__eq__</span> will use this same approach.</p>&#13;
<p class="indent">To make sure we got it right, let’s repeat the experiment. Don’t forget to reload the console to import the last version of the code, and enter the following code:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from geom2d.point import Point</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">p = Point(1, 0)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">p == p</span>&#13;
True&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">q = Point(1, 0)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">p == q</span>&#13;
True</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_88"/>There you go! Now our <span class="literal">Point</span> and <span class="literal">Vector</span> classes comparison actually works as it is supposed to work.</p>&#13;
<h4 class="h4" id="ch00lev2sec51"><strong><em>String Representation</em></strong></h4>&#13;
<p class="noindent">As you’ve seen in the console when evaluating an instance of a class, the output is not super helpful:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from geom2d.vector import Vector</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">v = Vector(2, 3)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">v</span>&#13;
&lt;geom2d.vector.Vector object at 0x10c63b438&gt;</pre>&#13;
<p class="noindent">If we try to convert the instance to its string representation using the <span class="literal">str</span> function, we get the same result:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">str(p)</span>&#13;
'&lt;geom2d.vector.Vector object at 0x10c63b438&gt;'</pre>&#13;
<p class="indent">When printing the string representation of <span class="literal">Vector</span> instances to the console, we’d find something like the following much more useful:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">str(p)</span>&#13;
'(2, 5) with norm 5.385164807134504'</pre>&#13;
<p class="indent">That message has the information of the coordinate values and the value of the norm. Function <span class="literal">str()</span> in Python converts an instance of a class to its string representation. This function first checks whether the passed argument implements method <span class="literal">__str__</span>. If it does, the function calls it and returns the result. If it doesn’t, the function simply returns the default string representation, which in our case is that unhelpful memory position mess.</p>&#13;
<p class="indent">Let’s implement <span class="literal">__str__</span> in our classes. Enter <a href="ch04.xhtml#ch4lis25">Listing 4-25</a> inside the <span class="literal">Point</span> class.</p>&#13;
<pre>class Point:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def __str__(self):&#13;
       return f'({self.x}, {self.y})'</pre>&#13;
<p class="caption"><a id="ch4lis25"/><em>Listing 4-25: Overriding string representation for <span class="codeitalic1">Point</span></em></p>&#13;
<p class="noindent">Then enter <a href="ch04.xhtml#ch4lis26">Listing 4-26</a> inside the <span class="literal">Vector</span> class.</p>&#13;
<pre>class Vector:&#13;
   <span class="codeitalic1">--snip--</span>&#13;
&#13;
   def __str__(self):&#13;
       return f'({self.u}, {self.v}) with norm {self.norm}'</pre>&#13;
<p class="caption"><a id="ch4lis26"/><em>Listing 4-26: Overriding string representation for <span class="codeitalic1">Vector</span></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_89"/>We include instance attributes in the string using <em>f-strings</em> (<span class="literal">f</span>’’). The attributes are inserted between curly brackets, and Python calls their <span class="literal">__str__</span> methods to get their string representation and concatenate the result. For example, you can think of the f-string,</p>&#13;
<pre>f'({self.x}, {self.y})'</pre>&#13;
<p class="noindent">as being translated by Python to something like this:</p>&#13;
<pre>"(" + str(self.x) + ", " + str(self.y) + ")"</pre>&#13;
<p class="indent">Now when using <span class="literal">str()</span> on instances of our classes, a much nicer description will be printed. Let’s reload the Python shell and give it a second try:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">from geom2d.vector import Vector</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">v = Vector(2, 3)</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">str(v)</span>&#13;
'(2, 3) with norm 3.605551275463989'</pre>&#13;
<p class="noindent">Much better, isn’t it?</p>&#13;
<h4 class="h4" id="ch00lev2sec52"><strong><em>Vector Factories</em></strong></h4>&#13;
<p class="noindent">A <em>factory function</em> is just a function that builds an object. Factory functions are a good option for initializing objects that require some calculation. An initializer should ideally only set its class attributes and avoid any computation; for that we will use factories.</p>&#13;
<p class="indent">A factory function is also helpful to improve the readability of the code. For instance, if you wanted to create a <span class="literal">Vector</span> from a point <em>P</em> to another point <em>Q</em>, the code</p>&#13;
<pre>    make_vector_between(p, q)</pre>&#13;
<p class="noindent">reads much better than this code:</p>&#13;
<pre>    Vector(q.x - p.x, q.y - p.y)</pre>&#13;
<p class="indent">Not only that, but the latter is likely to be written many times, which should tell you there is an algorithm that needs to be abstracted into its own concept. In this particular case, the algorithm is the formula to create a vector between two ordered points (see <a href="ch04.xhtml#ch04eqa12">Equation 4.12</a>).</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>A missing abstraction is a common problem. It happens when an algorithm representing a concrete concept is not properly encapsulated into its own function or class with a descriptive name. Its main hazards are that it takes longer for our brains to understand code when abstractions are not well encapsulated and that the same algorithm is copied and pasted in many places, making it difficult to maintain.</em></p>&#13;
</div>&#13;
<p class="indent">Create a new file inside <em>geom2d</em>, call it <em>vectors</em>, and enter the code from <a href="ch04.xhtml#ch4lis27">Listing 4-27</a>.<span epub:type="pagebreak" id="page_90"/></p>&#13;
<pre>from geom2d.point import Point&#13;
from geom2d.vector import Vector&#13;
&#13;
&#13;
def make_vector_between(p: Point, q: Point):&#13;
    return q - p&#13;
&#13;
&#13;
def make_versor(u: float, v: float):&#13;
    return Vector(u, v).normalized()&#13;
&#13;
&#13;
def make_versor_between(p: Point, q: Point):&#13;
    return make_vector_between(p, q).normalized()</pre>&#13;
<p class="caption"><a id="ch4lis27"/><em>Listing 4-27: Vector factory functions</em></p>&#13;
<p class="indent">This file defines several functions, all of which have the purpose of creating vectors. The first function we define, <span class="literal">make_vector_between</span>, creates a vector going from a point <span class="literal">p</span> to another point <span class="literal">q</span>. We’ve harnessed our <span class="literal">Point</span> class’s <span class="literal">__sub__</span> implementation to create the vector between the points. That is one handy way of creating vectors, expressed mathematically as shown in <a href="ch04.xhtml#ch04eqa12">Equation 4.12</a>.</p>&#13;
<div class="equationc" id="ch04eqa12"><img src="../images/04eqa12.jpg" alt="Image"/></div>&#13;
<p class="indent">Next, we have a function called <span class="literal">make_versor</span>, which creates versors, or vectors of unit length. <em>Versors</em> are frequently used to express direction or orientation, so we’ll want a convenient way of creating them. Note that versors are written with a hat over them, as in <em>û</em>, signifying their length is unitary.</p>&#13;
<p class="indent">Lastly, we have <span class="literal">make_versor_between</span> to create a versor between two points, which reuses the <span class="literal">make_vector_between</span> function to return the normalized result of it. The resulting versor could also be computed with <a href="ch04.xhtml#ch04eqa13">Equation 4.13</a>.</p>&#13;
<div class="equationc" id="ch04eqa13"><img src="../images/04eqa13.jpg" alt="Image"/></div>&#13;
<h3 class="h3" id="ch00lev1sec33"><strong>Unit Testing</strong></h3>&#13;
<p class="noindent">So far we’ve implemented a couple of methods on classes <span class="literal">Point</span> and <span class="literal">Vector</span>, and we’ve tested some of them in the console by hand, but now we face some big questions: How can we convince someone else that our code always works as expected? How can we be sure what we’ve written works all the time? How can we make sure we don’t break anything when we modify existing code or add new code?</p>&#13;
<p class="indent">Often enough, you’ll need to go back to some piece of code you wrote a long time ago to fix a bug. The problem comes when you want to change <span epub:type="pagebreak" id="page_91"/>that code but don’t know whether making that change will break what’s already working. In fact, you may not be aware of what all the code is supposed to be doing, so you end up changing something you shouldn’t have and break something else. This phenomenon happens so regularly it has its own name: <em>regression</em>.</p>&#13;
<p class="indent">Testing code by hand in the console is tiresome and boring, ensuring that you probably won’t test everything you need to test. Besides that, it’s not a repeatable process: you’ll forget about which tests you executed for each method, or if someone else needs to run them, they’ll have to figure out what to test and how. But still, we really need to make sure our changes won’t break anything. Code is entirely useless if it doesn’t do what it’s supposed to.</p>&#13;
<p class="indent">What would make our lives much easier is an automated test we could execute, which takes a few milliseconds to run and spits out output that clearly states whether anything went wrong, where, and why. This is the basic idea behind <em>unit testing</em>, a crucial activity for any serious developer. Your code cannot be considered finished until it’s accompanied with good unit tests that prove its quality. I consider this part of development so vital I want to cover it early in the book and make extensive use of it. Writing automated, unitary tests for our code is a simple process, and there’s really no excuse for not doing it.</p>&#13;
<p class="indent">Creating unit tests for your code is simple: create a new file, and inside it add a new class with methods that test small portions of the test subject. Each test case has an <em>assertion</em> function that ensures a specific result is obtained given a set of inputs. The test is considered to pass when the assertion succeeds and to fail otherwise. When the test class is executed (as we’ll see next), the methods are executed, and their assertions are checked.</p>&#13;
<p class="indent">Don’t worry if this still doesn’t make sense; we’re going to use unit testing so much in this book you’ll get to fully understand it.</p>&#13;
<h4 class="h4" id="ch00lev2sec53"><strong><em>Testing Distances</em></strong></h4>&#13;
<p class="noindent">The first method we wrote for <span class="literal">Point</span> was <span class="literal">distance_to</span>, so let’s start our unit test adventure there. In the <em>geom2d</em> package, create a new file named <em>point _test.py</em>. Your project’s structure should look like the following:</p>&#13;
<p class="pre2">    Mechanics<br/>      |- geom2d<br/>      |    |- __init__.py<br/>      |    |- nums.py<br/>      |    |- point.py<br/>      |    |- point_test.py<br/>      |    |- vector.py<br/>      |    |- vectors.py</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_92"/>In <em>point_test.py</em>, enter the code from <a href="ch04.xhtml#ch4lis28">Listing 4-28</a>.</p>&#13;
<pre>  import unittest&#13;
&#13;
  from geom2d.point import Point&#13;
&#13;
&#13;
<span class="ent">➊</span> class TestPoint(unittest.TestCase):&#13;
&#13;
   <span class="ent">➋</span> def test_distance_to(self):&#13;
          p = Point(1, 2)&#13;
          q = Point(4, 6)&#13;
          expected = 5&#13;
          actual = p.distance_to(q)&#13;
&#13;
       <span class="ent">➌</span> self.assertAlmostEqual(expected, actual)</pre>&#13;
<p class="caption"><a id="ch4lis28"/><em>Listing 4-28: Distance between points test</em></p>&#13;
<p class="indent">We start by importing the <em>unittest</em> module, shipped with Python. This module provides us with most of the infrastructure we need to write and execute unit tests. After importing our <span class="literal">Point</span> class, we define the class <span class="literal">TestPoint</span>, which inherits <span class="literal">unittest.TestCase</span> <span class="ent">➊</span>. The <span class="literal">TestCase</span> class defines a good collection of assertion methods that we gain access to inside our class when we inherit it.</p>&#13;
<p class="indent">Next we have the <span class="literal">test_distance_to</span> method <span class="ent">➋</span>. It’s important that the method name starts with the word <em>test_</em>, because this is how the class discovers which of its methods are tests to be executed. You can define other methods in the class, but as long as their names don’t start with <em>test</em>, they won’t be executed as tests. Inside the test we create two points that we know are 5 units apart from each other and assert that their distance <span class="literal">p.distance_to(q)</span> is close to that value.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The</em> unittest <em>module’s choice of words may be confusing. The name</em> <span class="literal">UnitTest</span> <em>is used for the class even though the tests themselves are actually the methods inside the class. Our class extending</em> <span class="literal">UnitTest</span> <em>is just a way of grouping related test cases.</em></p>&#13;
</div>&#13;
<p class="indent">The assertion method <span class="literal">assertAlmostEqual</span> <span class="ent">➌</span> (defined in the class we inherited from: <span class="literal">unittest.TestCase</span>) checks for floating-point number equality with a given tolerance, which is expressed as the number of decimal positions to compare. The default number of decimal positions to check is 7, and in this test, we’ll stick to the default (as we didn’t provide any other value). Remember that when dealing with floating-point number comparisons, a tolerance must be used or, in this case, a given number of decimal positions (see the “Comparing Numbers” on <a href="ch01.xhtml#page_4">page 4</a>).</p>&#13;
<p class="indent">There are several ways to run tests. Let’s explore how to do it from both PyCharm and the console.</p>&#13;
<h5 class="h5" id="ch00lev3sec20"><span epub:type="pagebreak" id="page_93"/><strong>Running the Test from PyCharm</strong></h5>&#13;
<p class="noindent">If you take a look at your test file in PyCharm, you’ll see a little green play button to the left of the class and method definitions. The class button executes all the tests inside of it (so far we have only one), whereas the button next to the method will run only that one test. Click the class one; from the menu, select <strong>Run ‘Unittest for point</strong>.’ The Run pane appears in the lower part of the IDE, and the result of executing your tests is displayed. If you did everything right, you should see the following:</p>&#13;
<pre><span class="codeitalic1">--snip--</span>&#13;
&#13;
Ran 1 test in 0.001s&#13;
&#13;
OK&#13;
&#13;
Process finished with exit code 0</pre>&#13;
<p class="indent">Let’s now learn how to run the same test from the console.</p>&#13;
<h5 class="h5" id="ch00lev3sec21"><strong>Running the Test from the Console</strong></h5>&#13;
<p class="noindent">IDEs other than PyCharm may have their own way to run tests. But regardless of the IDE you use, you can always run tests from the console. Open the console or shell and make sure you’re in the <em>Mechanics</em> project directory. Then run the following command:</p>&#13;
<pre>$ <span class="codestrong1">python3 -m unittest geom2d/point_test.py</span></pre>&#13;
<p class="indent">You should see the following result:</p>&#13;
<pre>Ran 1 tests in 0.000s&#13;
&#13;
OK</pre>&#13;
<p class="indent">We’ll run most of the tests throughout the book from the IDE, but feel free to run them from the console if you prefer.</p>&#13;
<h5 class="h5" id="ch00lev3sec22"><strong>Assertion Errors</strong></h5>&#13;
<p class="noindent">Let’s see what would’ve happened if the assertion detected a wrong result. Inside <em>point_test.py</em>, change the expected value for the distance:</p>&#13;
<pre>expected = 567</pre>&#13;
<p class="indent">This assertion is expecting points (1, 2) and (4, 6) to be 567 units apart, which is totally wrong. Now execute the test again by clicking the green play button beside the class. This is the result you should see:</p>&#13;
<pre>Ran 1 test in 0.006s&#13;
&#13;
FAILED (failures=1)&#13;
&#13;
<span epub:type="pagebreak" id="page_94"/>Failure&#13;
Traceback (most recent call last):&#13;
  <span class="codeitalic1">--snip--</span>&#13;
  File ".../geom2d/tests/point_test.py", line 14, in test_distance_to&#13;
    self.assertAlmostEqual(expected, actual)&#13;
  <span class="codeitalic1">--snip--</span>&#13;
&#13;
AssertionError: 567 != 5.0 within 7 places (562.0 difference)</pre>&#13;
<p class="indent">The message with the most valuable information is the last one. It’s telling us that there was an assertion error; that is, the assertion failed when it found 5.0 where 567 was expected. It used 7 decimal places in the comparison and still found a difference of 562.</p>&#13;
<p class="indent">Before this assertion error is the <em>traceback</em>, the execution path Python took until it got the error. As the message states, calls closer to the failure appear last in the list. As you can see, the test execution failed in file <em>point _test.py</em> (no surprise) on line 14 (yours may be different), in a test named <span class="literal">test_distance_to</span>. This information will prove invaluable when you modify existing code and run the tests only to find out whether a test fails, as it can tell you what exactly broke. These test failure messages will give you precise information.</p>&#13;
<p class="indent">Don’t forget to put our unit test back to how we initially wrote it and make sure it still runs successfully.</p>&#13;
<h4 class="h4" id="ch00lev2sec54"><strong><em>Testing Vector Plus and Minus Operations</em></strong></h4>&#13;
<p class="noindent">To ensure + and – operations work properly for vectors (doing the same for the <span class="literal">Point</span> class is left as an exercise for you), let’s use the following test cases:</p>&#13;
<div class="equationc"><img src="../images/f0094.jpg" alt="Image"/></div>&#13;
<p class="indent">and</p>&#13;
<div class="equationc"><img src="../images/f0094a.jpg" alt="Image"/></div>&#13;
<p class="indent">Create a new file inside package <em>geom2d</em> for testing the <span class="literal">Vector</span> class. Name it <em>vector_test</em> and enter the code from <a href="ch04.xhtml#ch4lis29">Listing 4-29</a>.</p>&#13;
<pre>import unittest&#13;
&#13;
from geom2d.vector import Vector&#13;
&#13;
&#13;
class TestVector(unittest.TestCase):&#13;
    u = Vector(1, 2)&#13;
    v = Vector(4, 6)&#13;
&#13;
    def test_plus(self):&#13;
        expected = Vector(5, 8)&#13;
        actual = self.u + self.v&#13;
        self.assertEqual(expected, actual)&#13;
&#13;
    <span epub:type="pagebreak" id="page_95"/>def test_minus(self):&#13;
        expected = Vector(-3, -4)&#13;
        actual = self.u - self.v&#13;
        self.assertEqual(expected, actual)</pre>&#13;
<p class="caption"><a id="ch4lis29"/><em>Listing 4-29: Tests for plus and minus operations</em></p>&#13;
<p class="indent">Run all tests using the green play button to the left of the class definition. If you got everything right, your two new tests should succeed. Yay! Our operations were properly implemented. The nice thing is, if there had been a bug in the implementation, these tests would have pointed out where and why.</p>&#13;
<p class="indent">It’s worth noting that this time we’re using assertion method <span class="literal">assertEqual</span>, which under the hood compares both arguments using the <span class="literal">==</span> operator. If we hadn’t overloaded this operator in the <span class="literal">Vector</span> class, the tests would fail even if the results were right. Try this: comment out the <span class="literal">__eq__(self, other)</span> method definition (by appending a <span class="literal">#</span> character at the beginning of the line) in the <span class="literal">Vector</span> class and rerun the tests.</p>&#13;
<p class="indent">You’ll find how the last two tests fail with a message like the following:</p>&#13;
<pre>&lt;geom2d.vector.Vector object at 0x10fd8d198&gt; !=&#13;
&lt;geom2d.vector.Vector object at 0x10fd8d240&gt;&#13;
&#13;
Expected :&lt;geom2d.vector.Vector object at 0x10fd8d240&gt;&#13;
Actual   :&lt;geom2d.vector.Vector object at 0x10fd8d198&gt;</pre>&#13;
<p class="indent">Familiar? That’s Python assuming two objects from the class can be equal only if they are the same actual object living in the same memory position. Our <span class="literal">__eq__</span> operator overload explains to Python the rules to determine when two objects should be considered the same. Don’t forget to uncomment the method.</p>&#13;
<h4 class="h4" id="ch00lev2sec55"><strong><em>Testing Vector Product Operations</em></strong></h4>&#13;
<p class="noindent">Let’s add two new test cases for dot and cross products using the same two vectors defined in the test class:</p>&#13;
<div class="equationc"><img src="../images/f0095-p1.jpg" alt="Image"/></div>&#13;
<p class="indent">and</p>&#13;
<div class="equationc"><img src="../images/f0095-p2.jpg" alt="Image"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_96"/>In code, this looks like <a href="ch04.xhtml#ch4lis30">Listing 4-30</a>.</p>&#13;
<pre>import unittest&#13;
&#13;
from geom2d.vector import Vector&#13;
&#13;
&#13;
class TestVector(unittest.TestCase):&#13;
&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def test_dot_product(self):&#13;
        expected = 16&#13;
        actual = self.u.dot(self.v)&#13;
        self.assertAlmostEqual(expected, actual)&#13;
&#13;
    def test_cross_product(self):&#13;
        expected = -2&#13;
        actual = self.u.cross(self.v)&#13;
        self.assertAlmostEqual(expected, actual)</pre>&#13;
<p class="caption"><a id="ch4lis30"/><em>Listing 4-30: Tests vector dot and cross products</em></p>&#13;
<p class="indent">Run all test cases to make sure the new ones also succeed. Note that, as we’re comparing numbers again, we use assertion method <span class="literal">assertAlmostEqual</span>.</p>&#13;
<h4 class="h4" id="ch00lev2sec56"><strong><em>Testing Vector Parallelism and Perpendicularity</em></strong></h4>&#13;
<p class="noindent">Next we’ll test the <span class="literal">is_parallel_to</span> and <span class="literal">is_perpendicular_to</span> methods. Since we’re checking a Boolean expression, we want to have two tests, one checking that the two vectors are parallel (a positive test) and one checking whether they’re not (a negative test). For the positive case, we’ll rely on the fact that a vector is always parallel to itself. Enter the <a href="ch04.xhtml#ch4lis31">Listing 4-31</a> code inside <span class="literal">TestVector</span>.</p>&#13;
<pre>import unittest&#13;
&#13;
from geom2d.vector import Vector&#13;
&#13;
class TestVector(unittest.TestCase):&#13;
&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def test_are_parallel(self):&#13;
        self.assertTrue(self.u.is_parallel_to(self.u))&#13;
&#13;
    def test_are_not_parallel(self):&#13;
        self.assertFalse(self.u.is_parallel_to(self.v))</pre>&#13;
<p class="caption"><a id="ch4lis31"/><em>Listing 4-31: Testing vector parallelism</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_97"/>There are two new assertion methods in this listing that are interesting ones: <span class="literal">assertTrue</span>, which checks whether a given expression evaluates to <span class="literal">True</span>; and <span class="literal">assertFalse</span>, which checks whether a given expression evaluates to <span class="literal">False</span>.</p>&#13;
<p class="indent">We’ll follow the same pattern for checking perpendicularity. After the last two tests, enter the two in <a href="ch04.xhtml#ch4lis32">Listing 4-32</a>.</p>&#13;
<pre>import unittest&#13;
&#13;
from geom2d.vector import Vector&#13;
&#13;
&#13;
class TestVector(unittest.TestCase):&#13;
&#13;
    <span class="codeitalic1">--snip--</span>&#13;
&#13;
    def test_are_perpendicular(self):&#13;
        perp = Vector(-2, 1)&#13;
        self.assertTrue(self.u.is_perpendicular_to(perp))&#13;
&#13;
    def test_are_not_perpendicular(self):&#13;
        self.assertFalse(self.u.is_perpendicular_to(self.v))</pre>&#13;
<p class="caption"><a id="ch4lis32"/><em>Listing 4-32: Testing vector perpendicularity</em></p>&#13;
<p class="indent">Run all tests inside the <span class="literal">TestVector</span> class to make sure they succeed. Congratulations! You’ve implemented your first unit tests. These tests will ensure the methods in our geometry classes work as expected. Additionally, if you find a better implementation for one of the methods we covered with tests, to make sure it still works as expected, just run its tests. Tests also serve to document the expected behavior of your code. If at some point you need a reminder about what the code you wrote is supposed to do in a particular case, unit tests should help.</p>&#13;
<p class="indent">Writing good tests is not a simple endeavor. One gets good at it by writing many, but there are some guidelines we can follow that will help us. Let’s take a look at three simple rules that will make our tests much more resilient.</p>&#13;
<h4 class="h4" id="ch00lev2sec57"><strong><em>Three Golden Rules for Unit Testing</em></strong></h4>&#13;
<p class="noindent">We’ve covered tests for a small fraction of the methods from the <span class="literal">Point</span> and <span class="literal">Vector</span> classes. Now that you have the required knowledge, try testing all the methods that we wrote in both the <span class="literal">Point</span> and <span class="literal">Vector</span> classes. I’ll leave this for you as an exercise, but you can take a look at the code provided with the book if you need help: it includes a lot of unit tests. Look for all the methods we didn’t test and write the tests you think are needed to make sure they work properly. I encourage you to try, but if you still feel like unit testing is foreign to you, don’t worry, we’ll be writing unit tests in other chapters of this book.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_98"/>As mentioned, I believe writing unit tests is an integral part of coding, and handling software not covered by unit tests should be considered a poor practice. Moreover, writing code for the open-source community requires good unit tests. You’ve got to give the community a reason to believe what you did actually works. Proving this with automated tests that anybody can easily run and see for themselves is always a good approach, as it’s unlikely anybody is going to take the time to think about how to test your code and then open the console and manually try it all.</p>&#13;
<p class="indent">You’ll get better at writing reliable unit tests as you practice. For now, I’d like to give you some basic rules to follow. Don’t expect to fully grasp their meanings now, but come back to this section from time to time as you move through the book.</p>&#13;
<h5 class="h5" id="ch00lev3sec23"><strong>Rule 1: One Reason to Fail</strong></h5>&#13;
<p class="noindent">Unit tests should have one and only one reason to fail. This sounds simple, but in many cases the <em>test subject</em> (what you are testing) is complex and made up of several components working together.</p>&#13;
<p class="indent">If tests fail for only one reason, it’s straightforward to find the bug in the code. Imagine the opposite: a test that could fail for, say, five different reasons. When that test fails, you’ll find yourself spending too much time reading error messages and debugging code, trying to understand what made it fail this particular time.</p>&#13;
<p class="indent">Some developers and test professionals (testing is a profession on its own, which I spent several years doing) state that each test should have one and only one assertion. Being pragmatic, sometimes having more than one assertion is not that harmful, but if it’s one, that’s much better.</p>&#13;
<p class="indent">Let’s analyze a particular case. Take the test we wrote for checking whether two vectors are perpendicular. If instead of</p>&#13;
<pre>def test_are_perpendicular(self):&#13;
    perp = Vector(-2, 1)&#13;
    self.assertTrue(self.u.is_perpendicular_to(perp))</pre>&#13;
<p class="noindent">we had written</p>&#13;
<pre>def test_are_perpendicular(self):&#13;
    perp = u.perpendicular()&#13;
    self.assertTrue(self.u.is_perpendicular_to(perp))</pre>&#13;
<p class="noindent">then the test could fail because of an error in the <span class="literal">is_perpendicular_to</span> method or because of an error in the implementation of <span class="literal">perpendicular</span>, which we use to compute a perpendicular vector to <img class="inline" src="../images/uvictorit.jpg" alt="Image"/>. See the difference?</p>&#13;
<h5 class="h5" id="ch00lev3sec24"><strong>Rule 2: Controlled Environment</strong></h5>&#13;
<p class="noindent">We use the word <em>fixture</em> to refer to the environment where a test runs. The environment includes all pieces of data surrounding our test and the state of the test subject itself, all of which may alter the results of the test. This rule states that you should have total control of the fixture where your test runs. <span epub:type="pagebreak" id="page_99"/>Inputs and expected outputs of the test should always be known beforehand. Everything happening inside your tests should be <em>deterministic</em>; that is, there should be no randomness or dependence on anything out of your control: dates or times, operating systems, machine environment variables not set by the test, and so on.</p>&#13;
<p class="indent">If your tests seem to fail at random, they are useless, and you should get rid of them. People get used to random failing tests fast and start ignoring them. The problem comes when they also ignore tests that are failing because of a bug in the code.</p>&#13;
<h5 class="h5" id="ch00lev3sec25"><strong>Rule 3: Test Independence</strong></h5>&#13;
<p class="noindent">Tests should never depend on other tests. Each test should run on its own and never depend on a fixture set by other tests.</p>&#13;
<p class="indent">There are at least three reasons for this. First, you’ll want to run or debug tests independently. Second, many test frameworks do not guarantee the execution order of tests. Finally, it’s much simpler to read and understand tests that don’t depend on other surrounding tests.</p>&#13;
<p class="indent">Let’s illustrate this with the <span class="literal">TestSwitch</span> class in <a href="ch04.xhtml#ch4lis33">Listing 4-33</a>.</p>&#13;
<pre>class TestSwitch(unittest.TestCase):&#13;
&#13;
   switch = Switch()&#13;
&#13;
   def test_switch_on(self):&#13;
    self.switch.on()&#13;
    self.assertTrue(self.switch.is_on())&#13;
&#13;
   def test_switch_off(self):&#13;
    # Last test should have switched on&#13;
    self.switch.toggle()&#13;
    self.assertTrue(self.switch.is_off())</pre>&#13;
<p class="caption"><a id="ch4lis33"/><em>Listing 4-33: Test depending on another test</em></p>&#13;
<p class="indent">See how <span class="literal">test_switch_off</span> depends on <span class="literal">test_switch_on</span>? By using a method called <span class="literal">toggle</span>, we could get the wrong result if the tests run in a different order and the switch has a state of <em>off</em> when this test runs.</p>&#13;
<p class="indent">Never rely on test execution order; that results in trouble. Tests should always run independently: they should work the same way no matter the order of execution.</p>&#13;
<h3 class="h3" id="ch00lev1sec34"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, we created two important classes: <span class="literal">Point</span> and <span class="literal">Vector</span>. The rest of our <em>geom2d</em> library will be built upon these simple but powerful abstractions. We taught Python how to determine whether two given instances of <span class="literal">Point</span> or <span class="literal">Vector</span> are logically equal by implementing the special method <span class="literal">__eq__</span>, and provided a better textual representation with <span class="literal">__str__</span>. <span epub:type="pagebreak" id="page_100"/>We covered some of the methods in these classes with unit tests, and I encouraged you to extend the coverage on your own. The best way to learn to write good unit tests is by practicing. In the next chapter, we’ll add two new geometrical abstractions to <em>geom2d</em>: lines and segments. These provide a new dimension that can be used to construct more complex shapes.</p>&#13;
</body></html>