- en: '9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9'
- en: BUILDING A CIRCLE FROM THREE POINTS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从三个点构建一个圆
- en: '![Image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common01.jpg)'
- en: 'In this chapter, we’ll build an entire command line program to solve a well-known
    problem: finding a circle passing through three given points. You may have solved
    this problem graphically in high school using a ruler and compass; you may have
    even solved it numerically. This time, we’ll be using the computer to solve it
    for us and produce an SVG image with the result. We already implemented the algorithm
    in [Chapter 6](ch06.xhtml#ch06); in this chapter, we’ll use the algorithm inside
    an application.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个完整的命令行程序来解决一个著名的问题：找出通过三个给定点的圆。你可能在高中时用尺子和圆规通过图形方式解决过这个问题；你甚至可能已经通过数值方法解决过。此次，我们将使用计算机来为我们解决这个问题，并生成一个包含结果的SVG图像。我们已经在[第六章](ch06.xhtml#ch06)实现了这个算法；在本章中，我们将把这个算法嵌入到一个应用程序中。
- en: It’s a simple problem, but it is good for understanding how to code a complete
    application. We’ll read the three input points from a file using regular expressions,
    which we’ll learn about later in the chapter. We’ll also read in a configuration
    file with the values for the colors and sizes for the program’s output.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的问题，但非常适合理解如何编写一个完整的应用程序。我们将使用正则表达式从文件中读取三个输入点，正则表达式的内容我们将在本章稍后学习。我们还将读取一个配置文件，其中包含程序输出的颜色和大小值。
- en: 'Then we’ll build the *model*: a group of objects that implement what we call
    the *domain logic* of our application, that is, the knowledge needed to solve
    the problem. In this case, the model consists of three points and the factory
    function that creates a circle passing through the three of them. Thanks to our
    previous work in [Chapter 6](ch06.xhtml#ch06), this shouldn’t be complicated.
    We’ll present the results graphically, with a vector image showing the input points
    and resulting circle.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将构建*模型*：一组实现我们称之为*领域逻辑*的对象，也就是解决问题所需的知识。在本例中，模型由三个点以及创建通过这三个点的圆的工厂函数组成。感谢我们在[第六章](ch06.xhtml#ch06)的前期工作，这应该不会太复杂。我们将通过图形方式展示结果，呈现一个包含输入点和结果圆的矢量图像。
- en: 'This is our first complete command line program, and it has all the ingredients
    of an engineering application: reading from an input file, solving a problem,
    and outputting a result diagram. After building this program, you should feel
    empowered to build your own. The possibilities are endless!'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一个完整的命令行程序，它包含了工程应用的所有要素：从输入文件读取、解决问题和输出结果图。构建完这个程序后，你应该有信心构建你自己的程序。可能性是无限的！
- en: '**Application Architecture**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**应用程序架构**'
- en: Most of the command line applications we’ll build together in this book, and
    probably many others you may build on your own, will use a similar architecture.
    The concept of *software architecture* refers to the organization and design of
    the components that make up a software application. *Architecture* deals with
    both the design of each individual piece of the program and the system of communication
    and interaction between each piece.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们一起构建的大多数命令行应用程序，可能还有你自己构建的许多其他程序，都将采用类似的架构。*软件架构*的概念指的是组成软件应用程序的各个组件的组织和设计。*架构*不仅涉及每个单独程序部分的设计，还包括各部分之间的通信和交互系统。
- en: 'To decide what components should make up the architecture of our application,
    let’s think about what our program has to do. Our application will generally consist
    of three big phases, each performed by a different set of components or architectural
    building blocks:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定我们的应用程序应该由哪些组件组成，让我们思考一下我们的程序需要做什么。我们的应用程序通常将由三个主要阶段组成，每个阶段由不同的组件或架构构建模块执行：
- en: '**Input parsing** We read the problem definition data from a file passed to
    our program. This phase may also include reading an external configuration file
    to tweak the program’s behavior or outputs.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入解析** 我们从传递给程序的文件中读取问题定义数据。这个阶段也可能包括读取外部配置文件，以调整程序的行为或输出。'
- en: '**Problem resolution** Using the model we parse from the input definition data,
    we find a solution to the problem.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题解决** 使用我们从输入定义数据中解析出的模型，我们找到问题的解决方案。'
- en: '**Output generation** We present the solution to the user. Depending on what
    kind of report we need, we may choose to produce diagrams, text files with data,
    simulations, or a combination of them. As important as solving the problem is,
    producing an output that is easy to understand and contains all the relevant pieces
    of information is crucial for our program to be of any use.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出生成** 我们将解决方案呈现给用户。根据需要的报告类型，我们可以选择生成图表、包含数据的文本文件、模拟结果，或它们的组合。解决问题本身固然重要，但生成易于理解且包含所有相关信息的输出，对于我们的程序能够发挥作用至关重要。'
- en: 'Since our problem for this chapter is fairly simple, we’ll divide the three
    phases into three files: *input.py*, *main.py*, and *output.py*. [Figure 9-1](ch09.xhtml#ch9fig1)
    shows the main architectural blocks of our application graphically.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章的问题相对简单，我们将把三个阶段分成三个文件：*input.py*、*main.py* 和 *output.py*。[图 9-1](ch09.xhtml#ch9fig1)
    以图形化方式展示了我们应用程序的主要架构块。
- en: '![Image](../images/09fig01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/09fig01.jpg)'
- en: '*Figure 9-1: The application architecture diagram*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-1：应用架构图*'
- en: The input file will contain the three points and should have the following format,
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文件将包含三个点，应该具有以下格式，
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'where x and y are the coordinates of a point, separated by a space and each
    on a different line. An example input file could look like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 x 和 y 是一个点的坐标，用空格分隔并且每个坐标在不同的行上。一个示例输入文件可能如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This file defines three points: *A*(300, 300), *B*(700, 400), and *C*(300,
    500). We’ll put a specification for the values of the coordinates and say they
    need to be positive integers. This simplifies the parsing logic a bit as there
    won’t be decimal separators or minus signs in the numbers, which is good to get
    us started with regular expressions, but don’t worry: we’ll learn to identify
    floating-point numbers and minus signs in [Chapter 12](ch12.xhtml#ch12).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件定义了三个点：*A*(300, 300)、*B*(700, 400) 和 *C*(300, 500)。我们会规定坐标的值需要是正整数。这使得解析逻辑稍微简单一些，因为数字中不会有小数点或负号，这有助于我们使用正则表达式入门，但别担心：我们将在[第
    12 章](ch12.xhtml#ch12)中学习如何识别浮动点数字和负号。
- en: 'Using plaintext files as the input to our programs has a big advantage: we
    can write them by hand. Also, we can easily inspect and edit them. The downside
    is that plaintext files usually take up more space than their binary counterparts,
    but that won’t be an issue for us. We’ll go with ease of creation and manipulation
    over file size. Just remember, whenever you’re working with plaintext files, always
    use a plaintext editor and never a rich-text editor. Rich-text editors (such as
    Word) have their own storage format that includes much more than you actually
    write to them, such as information about what goes in bold, what font face is
    used, or what size the font is. We need our input files to have in them only what
    we’ve written.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯文本文件作为我们程序的输入有一个很大的优势：我们可以手动编写它们。而且，我们可以轻松地检查和编辑它们。缺点是纯文本文件通常占用的空间比其二进制文件大，但这对我们来说不是问题。我们会选择创建和操作的便利性，而不是文件大小。只要记住，在处理纯文本文件时，务必使用纯文本编辑器，而不是富文本编辑器。富文本编辑器（如
    Word）有自己的存储格式，其中包括比你实际写入的内容更多的信息，例如关于粗体、使用的字体类型或字体大小的信息。我们需要我们的输入文件只包含我们写入的内容。
- en: '**Setup**'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**设置**'
- en: Since we’ll be creating other applications throughout the book, let’s create
    a new package at the top level of our Python project (the same level as the *geom2d*,
    *graphic*, and *utils* packages). Right-click the *Mechanics* folder, and from
    the menu choose **New** ▸ **Python Package**, name it *apps*, and click **OK**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在整本书中创建其他应用程序，让我们在 Python 项目的顶层创建一个新包（与 *geom2d*、*graphic* 和 *utils* 包处于同一级别）。右键点击
    *Mechanics* 文件夹，在菜单中选择 **新建** ▸ **Python 包**，命名为 *apps*，然后点击 **确定**。
- en: In *apps*, create a new package, this time named *circle_from_points*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *apps* 中创建一个新包，这次命名为 *circle_from_points*。
- en: 'Your project’s directory structure should look similar to the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你的项目目录结构应该类似于以下内容：
- en: Mechanics
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 机制
- en: '|- apps'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '|- apps'
- en: '|    |- circle_from_points'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- circle_from_points'
- en: '|- geom2d'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '|- geom2d'
- en: '|    |- tests'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- tests'
- en: '|- graphic'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '|- graphic'
- en: '|    |- svg'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '|    |- svg'
- en: Let’s create our main file. This is the file we’ll execute from the command
    line to run the application. Create a file named *main.py* in *circle_from _points*.
    Enter the code in [Listing 9-1](ch09.xhtml#ch9lis1).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建主文件。这是我们将在命令行中执行的文件来运行应用程序。在 *circle_from_points* 中创建一个名为 *main.py* 的文件。输入[清单
    9-1](ch09.xhtml#ch9lis1)中的代码。
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 9-1: Main file*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-1：主文件*'
- en: If you recall from [Chapter 1](ch01.xhtml#ch01) (in the “Running Files” section),
    we’re using the “if name is main” pattern to execute our main application script.
    We want to run this code only if we detect the file is being run by itself, and
    not when it’s imported by some other file. For now we’ll only print a message
    to the shell to make sure our setup works.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得 [第 1 章](ch01.xhtml#ch01)（在“运行文件”部分），我们使用的是“if name is main”模式来执行我们的主应用程序脚本。我们希望仅在检测到文件是单独运行时才执行这段代码，而不是在它被其他文件导入时执行。现在我们只会向终端输出一条消息，以确保我们的设置正常。
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This should print to the shell:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这应当会输出到终端：
- en: This is working
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这在正常工作
- en: '**NOTE**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This time, our main file doesn’t define any function that could be imported
    and used by other files. But thanks to the “if name is main” pattern, if this
    file was imported (presumably by mistake), nothing would be exported, and no code
    would be run either. All of our “runnable” scripts will use this pattern.*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*这次，我们的主文件没有定义任何可以被其他文件导入并使用的函数。但得益于“if name is main”模式，如果这个文件被导入（可能是误导入），那么不会导出任何内容，也不会执行任何代码。我们所有的“可运行”脚本都将使用这个模式。*'
- en: 'We’ll need a file containing the definition of three points to test our progress.
    Create a new file inside *circle_from_points* named *test.txt*. In it, enter the
    following coordinates:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个包含三个点坐标的文件来测试我们的进度。在 *circle_from_points* 文件夹中创建一个新文件，命名为 *test.txt*。在其中输入以下坐标：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, we’ll need to configure our IDE so we can test our application locally
    inside it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要配置我们的 IDE，以便可以在其中本地测试应用程序。
- en: '***Creating a Run Configuration***'
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建运行配置***'
- en: To test our application’s code using the data in the *test.txt* file we just
    wrote, we need to create what’s known as a *run configuration* inside PyCharm
    (refer to section “Creating Run Configurations” on page liv for a refresher).
    Run configurations are a convenience that will save us time when we are developing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用我们刚刚编写的 *test.txt* 文件中的数据来测试应用程序的代码，我们需要在 PyCharm 中创建一个称为 *运行配置* 的内容（请参阅第“创建运行配置”部分，第
    liv 页以复习）。运行配置是一个便捷功能，它能节省我们开发时的时间。
- en: '**NOTE**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You may want to refer to the documentation online to better understand run
    configurations:* [https://www.jetbrains.com/help/pycharm/run-debug-configuration.html](https://www.jetbrains.com/help/pycharm/run-debug-configuration.html)*.
    If you happen to be using an IDE other than PyCharm, refer to its documentation.
    Most IDEs include a similar concept to run configurations to configure test runs
    for your programs.*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能需要参考在线文档以更好地理解运行配置：* [https://www.jetbrains.com/help/pycharm/run-debug-configuration.html](https://www.jetbrains.com/help/pycharm/run-debug-configuration.html)*。如果你使用的是除
    PyCharm 之外的 IDE，请参考其文档。大多数 IDE 都有类似的运行配置概念，用于配置程序的测试运行。*'
- en: To create a run configuration, first make sure the navigation bar is visible
    by choosing **View** ▸ **Navigation Bar**. From the top menu, choose **Run** ▸
    **Edit Configurations**. The dialog shown in [Figure 9-2](ch09.xhtml#ch9fig2)
    will open.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建运行配置，首先确保通过选择 **查看** ▸ **导航栏** 来显示导航栏。从顶部菜单中选择 **运行** ▸ **编辑配置**。将打开 [图 9-2](ch09.xhtml#ch9fig2)
    中所示的对话框。
- en: '![Image](../images/09fig02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig02.jpg)'
- en: '*Figure 9-2: The run configuration dialog*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-2：运行配置对话框*'
- en: Click the **+** icon on the top left, which opens the Add New Configuration
    drop-down, and choose **Python** (see [Figure 9-3](ch09.xhtml#ch9fig3)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 点击左上角的 **+** 图标，这将打开“添加新配置”下拉菜单，并选择 **Python**（见 [图 9-3](ch09.xhtml#ch9fig3)）。
- en: '![Image](../images/09fig03.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/09fig03.jpg)'
- en: '*Figure 9-3: The new Python run configuration*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-3：新的 Python 运行配置*'
- en: 'The Run Configuration form should appear on the right side of the window. Enter
    the name *circle-three-points* in the Name field at the top. This will be the
    name you’ll use to refer to the configuration. On the Configuration tab, you should
    see the Script path field. This is the path to our *main.py* file: our program’s
    entry point. Click the folder icon inside the field and select *main.py*. Near
    the end of the Configuration tab, find the Execution section. Select the **Redirect
    input from** checkbox, and in the field click the folder icon and select our test
    file containing the definition of the points: *test.txt*. This way, the run configuration
    will always pass *test.txt* to the program’s standard input. Your configuration
    dialog should look like [Figure 9-4](ch09.xhtml#ch9fig4).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 运行配置表单应该出现在窗口的右侧。在顶部的名称字段中输入名称*circle-three-points*。这将是你用来引用该配置的名称。在“配置”选项卡中，你应该能看到脚本路径字段。这是我们*main.py*文件的路径：程序的入口点。点击字段中的文件夹图标并选择*main.py*。在配置选项卡的末尾，找到“执行”部分。选中**从输入重定向**复选框，然后在字段中点击文件夹图标，选择包含点定义的测试文件：*test.txt*。这样，运行配置将始终将*test.txt*传递给程序的标准输入。你的配置对话框应该类似于[图
    9-4](ch09.xhtml#ch9fig4)。
- en: '![Image](../images/09fig04.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/09fig04.jpg)'
- en: '*Figure 9-4: The run configuration data*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：运行配置数据*'
- en: We need to do one last thing. If we executed the run configuration as it is
    now, the output of the program would be printed to the shell (standard output).
    That is fine, but since we’ll be outputting SVG code, we want to redirect the
    standard output to a file with the *.svg* extension.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做最后一件事。如果我们按照现在的配置执行运行，程序的输出将打印到终端（标准输出）。这没有问题，但因为我们要输出 SVG 代码，所以我们希望将标准输出重定向到一个具有
    *.svg* 扩展名的文件。
- en: Go to the Logs tab to the right of Configuration. Check **Save console output
    to file**; then click the folder icon, and select any file in *circle_from _points*.
    Once the file is selected, just change its name to *result.svg*. Alternatively,
    you can copy and paste the path to the package *circle_from_points* and then append
    the name of the *result.svg* file. You could also create an empty *result.svg*
    file and then select it here. Whatever way you choose, the result should look
    something like [Figure 9-5](ch09.xhtml#ch9fig5).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 转到配置右侧的日志标签。勾选**将控制台输出保存到文件**；然后点击文件夹图标，选择*circle_from_points*中的任何文件。选择文件后，只需将其名称更改为*result.svg*。或者，你可以复制并粘贴*circle_from_points*包的路径，然后在路径末尾添加*result.svg*文件的名称。你也可以创建一个空的*result.svg*文件，然后在这里选择它。无论你选择哪种方式，结果应该类似于[图
    9-5](ch09.xhtml#ch9fig5)。
- en: '![Image](../images/09fig05.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/09fig05.jpg)'
- en: '*Figure 9-5: Redirecting output to a file*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-5：将输出重定向到文件*'
- en: We’re all set, so click **OK**. In your navigation bar you should see the newly
    created run configuration selected (see [Figure 9-6](ch09.xhtml#ch9fig6)). Click
    the green play button to its right. This executes the run configuration, which
    should result in the message “This is working” written in a file named *result.svg*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪，点击**确定**。在导航栏中，你应该看到新创建的运行配置被选中（参见[图 9-6](ch09.xhtml#ch9fig6)）。点击右侧的绿色播放按钮。这将执行运行配置，最终会在一个名为*result.svg*的文件中写入消息“这是有效的”。
- en: '![Image](../images/09fig06.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/09fig06.jpg)'
- en: '*Figure 9-6: The run configuration in the navigation bar*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-6：导航栏中的运行配置*'
- en: Let’s do a quick recap of what we’ve just done. We’ve created a configuration
    in PyCharm that instructs it on how to run our project. We told the configuration
    that *main.py* is the entry point to start executing our project. Then, we said
    we wanted the file *test.txt* containing our test data to be passed to the standard
    input of the program and the output of the program redirected to a file named
    *result.svg*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下我们刚刚做了什么。我们在 PyCharm 中创建了一个配置，告诉它如何运行我们的项目。我们告知配置，*main.py* 是开始执行我们项目的入口点。然后，我们指定将包含测试数据的*test.txt*文件传递给程序的标准输入，并将程序的输出重定向到名为*result.svg*的文件。
- en: '***Why Use a Run Configuration?***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***为什么使用运行配置？***'
- en: You may be asking yourself, why do we want to create a run configuration instead
    of just executing our script from the command line?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么我们要创建一个运行配置，而不是直接从命令行执行脚本？
- en: That’s a good question. There are two good reasons why we use run configurations.
    The first is that we’ll be much more productive during development. We won’t need
    to enter commands into the shell to run the program, redirecting its standard
    input and output as necessary. Besides, this configuration allows us to debug
    the program, something that would be considerably harder from the shell. If you
    set a breakpoint somewhere in the code, you can click the bug-like button next
    to the green play button and the program should stop once the breakpoint is reached.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的问题。我们使用运行配置有两个主要原因。第一个是，在开发过程中，我们会更加高效。我们无需在 shell 中输入命令来运行程序，也不必在必要时重定向标准输入和输出。此外，这个配置还允许我们调试程序，这在
    shell 中会变得相当困难。如果你在代码中的某个地方设置了断点，你可以点击绿色播放按钮旁边像虫子一样的按钮，程序将在断点处停止。
- en: The second reason is that, as we’ll see later in the chapter, if you try to
    run *main.py* from the shell, once we start importing our packages (such as *geom2d*)
    it simply won’t work. Yes, that’s kind of surprising, but we’ll learn why this
    happens and, more importantly, how to fix it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个原因是，正如我们在本章后面将看到的，如果你试图从 shell 运行 *main.py*，一旦开始导入我们的包（例如 *geom2d*），它就会根本无法工作。是的，这有点令人惊讶，但我们将学习为什么会发生这种情况，更重要的是，如何修复它。
- en: '**Reading the Input and Configuration Files**'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**读取输入和配置文件**'
- en: So far we have a *main.py* file and a run configuration that passes it *test.txt*
    using the standard input. Right now we’re doing nothing with that file’s contents,
    so a good next step would be reading the contents of the file and parsing each
    line as an instance of the Point class. How do we go about doing this? We need
    to use regular expressions, a powerful technology for reading and extracting information
    from a text.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有了一个 *main.py* 文件和一个运行配置，使用标准输入将 *test.txt* 传递给它。现在我们对该文件的内容什么也不做，所以接下来的好步骤是读取文件的内容，并将每一行解析为
    Point 类的实例。我们该如何做呢？我们需要使用正则表达式，一种强大的文本读取和信息提取技术。
- en: Before we explore regular expressions, let’s create a new file in our project
    to read both the input and configuration files. Let’s also take some time to learn
    to read files passed to the standard input of our program.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索正则表达式之前，让我们在项目中创建一个新文件，用于读取输入和配置文件。同时，花些时间学习如何读取传递给我们程序标准输入的文件。
- en: 'In *circle_from_points*, create a new file named *input.py*. Your *circle_from
    _points* directory should look like the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *circle_from_points* 中，创建一个名为 *input.py* 的新文件。你的 *circle_from_points* 目录应该如下所示：
- en: circle_from_points
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: circle_from_points
- en: '|- __init__.py'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '|- __init__.py'
- en: '|- input.py'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '|- input.py'
- en: '|- main.py'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '|- main.py'
- en: '|- test.txt'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '|- test.txt'
- en: Let’s start small and go one step at a time. Enter the code in [Listing 9-2](ch09.xhtml#ch9lis2)
    in the newly created file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从小处开始，一步步来。在新创建的文件中输入[清单 9-2](ch09.xhtml#ch9lis2)中的代码。
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 9-2: Reading lines from the input file*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-2：从输入文件读取行*'
- en: The parse_points function is not actually parsing points . . . yet. So far,
    it returns a tuple consisting of three strings, each of which corresponds to a
    line obtained from the standard input. Each line is read using Python’s input
    function, which reads in one line of input at a time. Let’s call parse_points
    from our main program to see how it reads the test file’s contents. Go back to
    *main.py* and modify the code to make it match [Listing 9-3](ch09.xhtml#ch9lis3).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse_points` 函数实际上还没有解析点……目前为止，它返回一个包含三个字符串的元组，每个字符串对应于从标准输入读取的一行。每一行都是通过
    Python 的 `input` 函数读取的，该函数一次读取一行输入。让我们从主程序中调用 `parse_points`，看看它是如何读取测试文件内容的。返回到
    *main.py* 并修改代码，使其与[清单 9-3](ch09.xhtml#ch9lis3)匹配。'
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 9-3: Printing the points to the shell*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-3：将点打印到 shell*'
- en: 'You may be tempted to use Python’s relative imports here like from .input import
    parse_points but that won’t work properly when the file doing the imports is run
    from the command line. To get an idea of why that is, take a look at this excerpt
    from PEP 238:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想使用 Python 的相对导入，例如 `from .input import parse_points`，但是当从命令行运行进行导入的文件时，这样做不会正常工作。为了理解为什么会这样，来看一下
    PEP 238 中的这段摘录：
- en: Relative imports use a module’s __name__ attribute to determine that module’s
    position in the package hierarchy. If the module’s name does not contain any package
    information (e.g. it is set to '__main__') then relative imports are resolved
    as if the module were a top level module, regardless of where the module is actually
    located on the file system.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 相对导入使用模块的__name__属性来确定该模块在包层次结构中的位置。如果模块的名称不包含任何包信息（例如，它被设置为'__main__'），则相对导入将被解析为模块是顶级模块，无论该模块在文件系统中的实际位置如何。
- en: The first thing we do in [Listing 9-3](ch09.xhtml#ch9lis3) is import parse_points
    from the *input.py* module. In the “if name is main” condition we call the parse_points
    function and assign its output to a tuple (a, b, c), which *destructures* its
    elements into the variables a, b, and c.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单9-3](ch09.xhtml#ch9lis3)中，我们首先从*input.py*模块导入parse_points。在“if name is main”条件中，我们调用parse_points函数并将其输出赋值给元组(a,
    b, c)，这将*解构*其元素为变量a、b和c。
- en: 'The following is the less elegant way of accomplishing the same result:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现相同结果的较不优雅的方法：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'But we’ll go with the former, which is a little cleaner. The last line prints
    the contents of a, b, and c to the shell, each in its own line. Run the application
    by clicking the green play button beside the run configuration we created earlier.
    You should get the following printed to the shell in the IDE:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们选择前者，它稍微干净一些。最后一行将a、b和c的内容打印到终端，每个打印在自己的行上。通过点击我们之前创建的运行配置旁边的绿色播放按钮来运行该应用程序。你应该会看到以下内容被打印到IDE的终端：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The two first lines are pretty interesting. They tell us that the configuration
    used to run the file is receiving input from file *test.txt* and writing the output
    to file *result.svg*. If you open *result.svg*, you should see the three points
    the same way they’re defined inside *test.txt*, and also the same way they were
    printed to the shell. We’re making good progress here! The next step is to convert
    those space-separated coordinates into instances of our Point class. For that,
    we need regular expressions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前两行非常有趣。它们告诉我们，用于运行文件的配置正在从文件*test.txt*接收输入，并将输出写入文件*result.svg*。如果你打开*result.svg*，你应该能看到与*test.txt*中定义的三点相同，并且也与它们在终端中打印的方式相同。我们在这里取得了很好的进展！下一步是将这些用空格分隔的坐标转换为我们的Point类实例。为此，我们需要使用正则表达式。
- en: '***Regular Expressions***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***正则表达式***'
- en: '*Regular expressions* (*regex* for short) are powerful constructs when it comes
    to interpreting text. Because the input to most, if not all, applications we’ll
    be creating in this book will be read from a plaintext file, we want to get acquainted
    with regular expressions.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*正则表达式*（简写为*regex*）在解释文本时是强大的构造。因为我们将在本书中创建的大多数应用程序的输入都将从纯文本文件中读取，所以我们希望了解正则表达式。'
- en: '**NOTE**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you want to learn more about regular expressions, take a look at this awesome
    interactive tutorial:* [*https://regexone.com*](https://regexone.com).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你想了解更多关于正则表达式的信息，请查看这个超棒的互动教程：* [*https://regexone.com*](https://regexone.com)。'
- en: 'Let’s quickly review the problem we’re trying to solve here: given a string
    of text containing two integer numbers separated by a space, extract them from
    the string, convert them to numbers, and use them as the coordinates of an instance
    of Point. How do regular expressions help us here?'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一下我们在这里要解决的问题：给定一个包含由空格分隔的两个整数的文本字符串，从字符串中提取它们，将它们转换为数字，并将它们作为Point类实例的坐标。正则表达式在这里如何帮助我们？
- en: A regular expression is a pattern defined as a string. It’s used to search for
    matches inside other strings and, optionally, extract parts of them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是定义为字符串的模式。它用于在其他字符串中查找匹配项，并可选地提取它们的部分内容。
- en: Let’s try an example. Note that regular expressions are denoted by writing them
    between two slash characters. Imagine we’re looking for this pattern,
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一个例子。请注意，正则表达式通过将它们写在两个斜杠字符之间来表示。假设我们正在寻找这个模式，
- en: /repeat 5 times/
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: /重复5次/
- en: 'and we’re interested in knowing whether that pattern appears in any of the
    following sentences:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 并且我们有兴趣知道这个模式是否出现在以下任何句子中：
- en: Repeat 5 times.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 重复5次。
- en: For each exercise, repeat 5 times.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个练习，重复5次。
- en: For that particular exercise, repeat 7 times.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那个特定的练习，重复7次。
- en: Let’s repeat 3301 times.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重复3301次。
- en: 'The /repeat 5 times/ regular expression compares itself against these strings
    searching for exactly the text repeat 5 times and thus yielding only the single
    bold match:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: /重复5次/ 正则表达式将自身与这些字符串进行比较，查找完全匹配文本repeat 5 times，因此只会得到单一的粗体匹配：
- en: Repeat 5 times.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重复 5 次。
- en: For each exercise, **repeat 5 times**.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个练习，**重复 5 次**。
- en: For that particular exercise, repeat 7 times.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于该特定练习，重复 7 次。
- en: Let’s repeat 3301 times.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重复 3301 次。
- en: 'That’s great, but not very flexible. The first sentence was not a match because
    the first letter, the *R*, is uppercase; our pattern is lowercased. We can tweak
    our pattern to accept both:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但灵活性不足。第一句话没有匹配，因为第一个字母 *R* 是大写的，而我们的模式是小写的。我们可以调整模式，使其接受两者：
- en: /[Rr]epeat 5 times/
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: /[Rr]epeat 5 次/
- en: 'This time the matches are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这次的匹配结果如下：
- en: '**Repeat 5 times**.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**重复 5 次**。'
- en: For each exercise, **repeat 5 times**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个练习，**重复 5 次**。
- en: For that particular exercise, repeat 7 times.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对于该特定练习，重复 7 次。
- en: Let’s repeat 3301 times.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重复 3301 次。
- en: 'To account for both kinds of *r*, we introduced a *character set*: a series
    of accepted characters in a given position of the text, any of which is considered
    valid. Character sets are defined between square brackets.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了同时处理两种 *r*，我们引入了一个 *字符集*：在文本的某个位置接受的一系列字符，任何一个字符都被视为有效。字符集通过方括号定义。
- en: There’s much more we can do with regular expressions. What about the number
    of repetitions specified in the sentence? Can we make it so any number of repetitions
    is considered a match? We sure can. If we modify our pattern to be
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正则表达式，我们可以做更多的事情。那句中的重复次数怎么办？我们能否使任何重复次数都被视为有效匹配？当然可以。如果我们修改模式为
- en: /[Rr]epeat \d times/
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: /[Rr]epeat \d times/
- en: 'we’ll get the following matches:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下匹配：
- en: '**Repeat 5 times**.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**重复 5 次**。'
- en: For each exercise, **repeat 5 times**.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个练习，**重复 5 次**。
- en: For that particular exercise, **repeat 7 times**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于该特定练习，**重复 7 次**。
- en: Let’s repeat 3301 times.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重复 3301 次。
- en: The pattern \d matches a single digit, any number between 0 and 9\. But what
    about that last sentence? If we wanted to match more than one digit, we’d need
    to add a *quantifier* to the \d pattern. In this case, the quantifier that makes
    the most sense is +, which is used to match one or more of the tokens it quantifies.
    The pattern
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 模式 \d 匹配一个数字，0 到 9 之间的任何数字。那最后一句话呢？如果我们想匹配多个数字，我们需要为 \d 模式添加一个 *量词*。在这种情况下，最合适的量词是
    +，它用于匹配一个或多个它量化的符号。模式
- en: /[Rr]epeat \d+ times/
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: /[Rr]epeat \d+ times/
- en: 'would then work with any number of repetitions and thus get us the full range
    of matches we’ve been after:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将适用于任何重复次数，从而获得我们一直追求的完整匹配范围：
- en: '**Repeat 5 times**.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**重复 5 次**。'
- en: For each exercise, **repeat 5 times**.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个练习，**重复 5 次**。
- en: For that particular exercise, **repeat 7 times**.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于该特定练习，**重复 7 次**。
- en: Let’s **repeat 3301 times**.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们 **重复 3301 次**。
- en: Now that you’re starting to see what regular expressions are about, let’s explore
    some of their basic concepts.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你开始理解正则表达式的基本概念了，让我们探索一些它们的基础概念。
- en: '**Character Sets**'
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符集**'
- en: As we’ve seen, we can include several different characters between square brackets
    to have our regular expression match any of them. For instance, we could use
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们可以在方括号之间包含几个不同的字符，以使我们的正则表达式匹配其中任何一个。例如，我们可以使用
- en: /[mbg]ore/
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: /[mbg]ore/
- en: 'to match **more**, **bore**, and **gore**. We can also include ranges like
    all lowercase letters from *a* to *z* like so:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配 **more**、**bore** 和 **gore**。我们还可以包含像这样所有小写字母 *a* 到 *z* 的范围：
- en: /[a-z]ore/
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: /[a-z]ore/
- en: This would produce a wide range of matches, for instance **more**, **core**,
    and exp**lore**. We can also include the range of uppercase letters,
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生广泛的匹配，例如 **more**、**core** 和 exp**lore**。我们还可以包括大写字母的范围，
- en: /[a-zA-Z]ore/
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: /[a-zA-Z]ore/
- en: to include matches like **More** or **Core**. One thing to keep an eye on is
    that consecutive ranges are not separated by a space. If you separated them using
    a space, the set would include the space as a valid character.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以包括像 **More** 或 **Core** 这样的匹配。需要注意的是，连续的字符范围之间没有空格。如果你用空格分隔它们，集合会把空格也视为有效字符。
- en: '**Character Classes**'
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**字符类**'
- en: There are some special characters we can use to match common things such as
    digits, whitespace, or single letters. The first one is a dot (**.**). We use
    it to match anything except line breaks. It matches letters (both uppercase and
    lowercase), numbers, punctuation marks, and whitespace. As you can see, this is
    quite a powerful *matcher*. For example, the pattern
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些特殊字符可以用来匹配常见的元素，如数字、空白符或单个字母。第一个是点号 (**.**)，我们用它来匹配除换行符之外的任何内容。它匹配字母（包括大写和小写）、数字、标点符号和空白符。正如你所看到的，这是一个相当强大的
    *匹配器*。例如，模式
- en: /the end./
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: /the end./
- en: would match **the end.**, **the end?**, **the end!**, and many more. To match
    a single dot, we need to escape the dot character using a backward slash,
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 它将匹配 **the end.**、**the end?**、**the end!** 和更多情况。要匹配一个单独的点，我们需要使用反斜杠来转义点字符，
- en: /the end\./
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: /the end\./
- en: 'which would produce only one match: **the end.**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只产生一个匹配项：**the end.**
- en: We already learned about the class \d, which matches a digit. If we want to
    match everything *but* digits, we can use \D (uppercase). Similarly, to match
    letters, we can use the class \w, and we can use \W for nonletters. Lastly, for
    whitespace there’s \s, and there’s \S to match whatever isn’t whitespace.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习过类 \d，它匹配一个数字。如果我们想匹配所有的*非*数字字符，可以使用 \D（大写字母）。类似地，若要匹配字母，可以使用类 \w，而 \W
    用于匹配非字母字符。最后，对于空白字符，我们使用 \s，而 \S 用于匹配任何非空白字符。
- en: 'Now let’s combine our knowledge on character classes into a regular expression:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将关于字符类的知识结合成一个正则表达式：
- en: /code\s\w-\d\d/
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: /code\s\w-\d\d/
- en: This regular expression matches strings like **code f-44**, **code M-81**, and
    **code p-29**.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式匹配像 **code f-44**、**code M-81** 和 **code p-29** 这样的字符串。
- en: '**Quantifiers**'
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**量词**'
- en: 'Quantifiers modify the number of matches expected for the token they quantify.
    There are five quantifiers:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 量词修改了它们量化的符号的匹配次数。共有五个量词：
- en: ?     Matches zero or one of the preceding tokens
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ?     匹配零个或一个前面的符号
- en: '*     Matches zero or more of the preceding tokens'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*     匹配零个或多个前面的符号'
- en: +     Matches one or more of the preceding tokens
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: +     匹配一个或多个前面的符号
- en: (n)     Matches exactly n of the preceding tokens
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: (n)     匹配前面符号的确切 n 个
- en: (n,m)     Matches from n to m of the preceding tokens
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: (n,m)     匹配前面符号的 n 到 m 个
- en: For example,
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，
- en: /o{2}m/
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: /o{2}m/
- en: would match b**oom**, z**oom**, or kab**oom**. But, if instead we use
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 它将匹配 b**oom**、z**oom** 或 kab**oom**。但是，如果我们使用
- en: /o+m/
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: /o+m/
- en: 'our matches could be any of the following: n**om**ad, b**oooo**m, or r**oom**.
    We’ll be using most of these quantifiers throughout the text, so there will be
    plenty more examples of them.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的匹配结果可以是以下任何一种：n**om**ad，b**oooo**m，或 r**oom**。我们将在文中使用大多数这些量词，所以会有很多示例。
- en: '**Capturing Groups**'
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**捕获分组**'
- en: So far we’ve seen how to match text using regular expressions. But sometimes
    we also want to extract the text we’ve matched. Here’s where groups come in. Groups
    are defined between parentheses. Let’s try the following regular expression,
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到如何使用正则表达式匹配文本。但有时我们还想提取我们匹配到的文本。这时，分组就派上用场了。分组是在圆括号之间定义的。让我们尝试以下正则表达式，
- en: /it takes (\d+) hours to go from (\w+) to (\w+)/
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: /it takes (\d+) hours to go from (\w+) to (\w+)/
- en: 'which applied to the sentence “it takes 4 hours to go from Barcelona to Pamplona”
    would match it entirely and capture the following groups:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将其应用于句子“从巴塞罗那到庞普洛纳需要 4 小时”时，它会完全匹配并捕获以下组：
- en: ('4', 'Barcelona', 'Pamplona')
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ('4', 'Barcelona', 'Pamplona')
- en: 'Let’s try it in Python’s shell. Python’s standard library includes a powerful
    regular expression package: re. Open your IDE’s shell and try entering the code
    in [Listing 9-4](ch09.xhtml#ch9lis4).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Python 的 shell 中试一下。Python 的标准库包括一个强大的正则表达式包：re。打开你的 IDE 的 shell，尝试输入 [示例
    9-4](ch09.xhtml#ch9lis4) 中的代码。
- en: '[PRE9]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 9-4: Capturing groups with regular expressions*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 9-4：使用正则表达式捕获分组*'
- en: We define the pattern using a *raw string literal*, which has the format r’’.
    These strings treat the backslash (\) as a valid character instead of interpreting
    it as an escape sequence. Regular expressions need the backslash to define their
    structure.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用*原始字符串字面量*来定义模式，格式为 r''。这些字符串将反斜杠（\）视为有效字符，而不是将其解释为转义序列。正则表达式需要反斜杠来定义其结构。
- en: 'In [Listing 9-4](ch09.xhtml#ch9lis4), the result is stored in a variable named
    matches, which we can call the groups method on to yield the three captured groups:
    4, Barcelona, and Pamplona.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 9-4](ch09.xhtml#ch9lis4) 中，结果存储在名为 matches 的变量中，我们可以调用 groups 方法来获取捕获的三个分组：4、Barcelona
    和 Pamplona。
- en: 'A neat thing about groups is that they can be assigned a name that we can later
    use to retrieve the matched value. For instance, consider the following pattern:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 分组的一个好处是，它们可以被赋予一个名称，稍后我们可以用这个名称来检索匹配的值。例如，考虑以下模式：
- en: /(?P<name>\w+), but they call me (?P<nick>\w+)/
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: /(?P<name>\w+), but they call me (?P<nick>\w+)/
- en: 'Applied to a sentence like “my name is Nelson, but they call me Big Head,”
    this would capture two groups, which we can retrieve by name:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于像“我的名字是 Nelson，但他们叫我 Big Head”这样的句子时，它会捕获两个分组，我们可以通过名称来检索它们：
- en: '[PRE10]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can guess, the syntax used to assign a name to a group is as follows,
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所猜测的，赋予分组名称的语法如下，
- en: '[PRE11]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: where name is the name assigned to the group and regex is the actual pattern
    to match the group.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 name 是分配给该组的名称，regex 是实际用于匹配该组的模式。
- en: '***Regular Expressions Cheat Sheet***'
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***正则表达式备忘单***'
- en: '[Table 9-1](ch09.xhtml#ch9tab1), [Table 9-2](ch09.xhtml#ch9tab2), [Table 9-3](ch09.xhtml#ch9tab3),
    and [Table 9-4](ch09.xhtml#ch9tab4) summarize the concepts we’ve explored and
    can be used as references throughout the rest of the book.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-1](ch09.xhtml#ch9tab1)、[表 9-2](ch09.xhtml#ch9tab2)、[表 9-3](ch09.xhtml#ch9tab3)
    和 [表 9-4](ch09.xhtml#ch9tab4) 总结了我们已经探索的概念，并可以作为本书其余部分的参考。'
- en: '**Table 9-1:** Regular Expressions Character Sets'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-1：** 正则表达式字符集'
- en: '| [abc] | Matches ’a’ or ’b’ or ’c’ |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| [abc] | 匹配 ’a’ 或 ’b’ 或 ’c’ |'
- en: '| [^ab] | Matches every character except ’a’ and ’b’ |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| [^ab] | 匹配除了 ’a’ 和 ’b’ 之外的所有字符 |'
- en: '| [a-z] | Matches every character between ’a’ and ’z’ |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| [a-z] | 匹配从 ’a’ 到 ’z’ 之间的所有字符 |'
- en: '**Table 9-2:** Regular Expressions Character Classes'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-2：** 正则表达式字符类'
- en: '| \s | Matches whitespace |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| \s | 匹配空白字符 |'
- en: '| \S | Matches every character but whitespace |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| \S | 匹配除空白字符之外的所有字符 |'
- en: '| \d | Matches digits |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| \d | 匹配数字 |'
- en: '| \D | Matches every character but digits |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| \D | 匹配除了数字之外的所有字符 |'
- en: '| \w | Matches letters |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| \w | 匹配字母 |'
- en: '| \W | Matches every character but letters |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| \W | 匹配除了字母之外的所有字符 |'
- en: '**Table 9-3:** Regular Expressions Quantifiers'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-3：** 正则表达式量词'
- en: '| ? | Zero or one |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| ? | 零个或一个 |'
- en: '| * | Zero or more |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| * | 零个或多个 |'
- en: '| + | One or more |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| + | 一个或多个 |'
- en: '| {n} | Exactly n |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| {n} | 精确匹配 n |'
- en: '| {n,m} | Between n and m (both included) |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| {n,m} | 匹配 n 到 m（包括 n 和 m）之间的字符 |'
- en: '**Table 9-4:** Regular Expressions Capture Groups'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-4：** 正则表达式捕获组'
- en: '| (...) | A capture group goes between parentheses |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| (...) | 捕获组位于圆括号之间 |'
- en: '| (?P<name>...) | A named capture group |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| (?P<name>...) | 一个命名的捕获组 |'
- en: '***Matching Points***'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***匹配点***'
- en: 'We already know everything we need to match the points defined as their space-separated
    coordinates and capture them by name. Because coordinates will be defined by integer
    numbers only, we can use the following regular expression:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道了匹配由空格分隔的坐标定义的点所需的一切，并且可以通过名称捕获它们。因为坐标仅由整数定义，我们可以使用以下正则表达式：
- en: /(?P<x>\d+)\s(?P<y>\d+)/
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: /(?P<x>\d+)\s(?P<y>\d+)/
- en: 'Let’s break that down. There are three parts to it:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其分解。它有三个部分：
- en: (?P<x>\d+)   Captures a group named x of one or more digits
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: (?P<x>\d+)   捕获一个名为 x 的组，该组由一个或多个数字组成
- en: \s   Matches a single space
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: \s   匹配一个空格
- en: (?P<y>\d+)   Captures a group named y of one or more digits
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: (?P<y>\d+)   捕获一个名为 y 的组，该组由一个或多个数字组成
- en: Let’s implement this matching pattern in our application’s *input.py* file.
    Edit the code we wrote so that it looks like [Listing 9-5](ch09.xhtml#ch9lis5).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在应用程序的 *input.py* 文件中实现这个匹配模式。编辑我们编写的代码，使其看起来像 [清单 9-5](ch09.xhtml#ch9lis5)。
- en: '[PRE12]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 9-5: Parsing points*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-5：解析点*'
- en: We start by importing re ➊. Then, we modify the parse_points function to map
    the line we read using input() on an instance of Point. This conversion is handled
    by the private __point_from_string function, which, using re.match, looks for
    matches of the pattern in the passed-in string ➋.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入 re ➊。然后，我们修改 parse_points 函数，将通过 input() 读取的行映射到 Point 实例。这一转换由私有的 __point_from_string
    函数处理，该函数通过 re.match，查找传入字符串中与模式匹配的部分 ➋。
- en: From matches we know there should be two groups named x and y, respectively.
    The function thus creates and returns an instance of Point whose x-coordinate
    is the result of parsing the string captured by the group with name x as an integer
    ➌. The y-coordinate is, in a similar fashion, the result of parsing the group
    named y ➍.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从匹配项中我们知道应该有两个组，分别命名为 x 和 y。因此，该函数创建并返回一个 Point 实例，其 x 坐标是通过解析名称为 x 的组所捕获的字符串，结果为一个整数
    ➌。y 坐标以类似的方式处理，通过解析名称为 y 的组 ➍ 获取结果。
- en: 'Run the application (using the *circle-three-points* configuration) by clicking
    the green play button. You should see something like this printed to the shell:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序（使用 *circle-three-points* 配置），点击绿色播放按钮。你应该看到类似下面的内容打印到 shell 中：
- en: '[PRE13]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Congratulations! You just parsed three points from a file containing three lines
    of plaintext. From here on out, all the command line applications we’ll create
    can expect the input data from a file, which you already know how to parse and
    interpret using the almighty regular expressions.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你刚刚从一个包含三行纯文本的文件中解析了三个点。从现在开始，我们将创建的所有命令行应用程序都可以期望从文件中获取输入数据，你已经知道如何使用强大的正则表达式解析和解释这些数据。
- en: '***The Configuration File***'
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置文件***'
- en: Our application will produce a beautiful vector image of both the input points
    and the resulting circle. To do this, we’ll use different colors and line thicknesses
    to help visually distinguish its parts. We could directly hard-code those colors
    and size values in our code, but that’s not a great idea; our app will be easier
    to maintain if we separate the configuration values from the actual logic. Instead,
    we’ll keep the configuration values in a separate JSON file. We’ll use the JSON
    format because it’s extremely easy to convert to a Python dictionary.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用将生成一个漂亮的矢量图，展示输入的点和结果圆形。为此，我们将使用不同的颜色和线条粗细，帮助直观区分它们的各个部分。我们可以直接将这些颜色和大小值硬编码到代码中，但这不是一个好主意；如果我们将配置值与实际逻辑分开，我们的应用将更容易维护。因此，我们将把配置值存储在一个单独的
    JSON 文件中。我们选择使用 JSON 格式，因为它非常容易转换为 Python 字典。
- en: '**NOTE**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*We say something is* hard-coded *into the code when there’s no way of changing
    it without altering the program’s source code. Configuration values, for instance,
    are often hard-coded into the main application’s logic, making them impossible
    to change without the need of reading through the code and potentially recompiling
    the application. Don’t do that. The fewer times you need to edit and recompile
    existing code, the better. Always move configuration values out of the program’s
    logic into a file of its own.*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*当我们说某个东西是*硬编码*到代码中时，意思是没有办法改变它，除非修改程序的源代码。例如，配置值通常硬编码到主应用的逻辑中，无法改变，除非逐行阅读代码并可能需要重新编译应用程序。不要这样做。你需要编辑和重新编译现有代码的次数越少越好。始终将配置值从程序的逻辑中移到一个独立的文件中。*'
- en: Inside *circle_from_points*, create a new file by right-clicking the package
    name and choosing **New** ▸ **File**. Enter the name *config.json*, and in it,
    write the contents in [Listing 9-6](ch09.xhtml#ch9lis6).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *circle_from_points* 中，右键点击包名并选择 **新建** ▸ **文件**，创建一个新文件。输入文件名 *config.json*，然后在其中编写
    [Listing 9-6](ch09.xhtml#ch9lis6) 的内容。
- en: '[PRE14]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 9-6: Application configuration inside a JSON file*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-6: 配置文件中的应用程序配置*'
- en: 'This file is in JSON, a widely used format. If you happen to be new to it,
    you can read more about it at [*www.json.org/*](http://www.json.org/). It looks
    similar to Python dictionaries as it stores data in a key-value fashion. Luckily
    for us, Python has an easy way of reading in JSON files: the standard library
    includes the *json* package to handle JSON data.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件是 JSON 格式的，这是一种广泛使用的格式。如果您对它不熟悉，可以在 [*www.json.org/*](http://www.json.org/)
    阅读更多内容。它的结构类似于 Python 字典，以键值对的方式存储数据。幸运的是，Python 提供了一种简单的方法来读取 JSON 文件：标准库中包括了处理
    JSON 数据的 *json* 包。
- en: In *input.py*, enter the function in [Listing 9-7](ch09.xhtml#ch9lis7) (don’t
    forget the imports).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *input.py* 中，输入 [Listing 9-7](ch09.xhtml#ch9lis7) 中的函数（不要忘记导入）。
- en: '[PRE15]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 9-7: Reading the configuration*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-7: 读取配置文件*'
- en: Using the pkg_resources module, this process becomes a breeze. The contents
    of file *config.json* are read into a binary string using res.resource_string(),
    which, when passed to json.loads, gets us the resulting Python dictionary with
    everything parsed and ready to be used. We’ll be using these values soon.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 pkg_resources 模块，这个过程变得轻而易举。使用 res.resource_string() 将 *config.json* 文件的内容读取为二进制字符串，并传递给
    json.loads，这样就能得到解析后的 Python 字典，准备好供使用。我们很快就会用到这些值。
- en: '**Problem Model and Resolution**'
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**问题模型与解决方案**'
- en: 'We’ve already parsed the problem’s model: the three instances of our Point
    class. Using these, our application should now compute the circle that passes
    through all of them. Our earlier work is about to pay off: we already have the
    code to do this (check out “Circle Factories” on [page 153](ch06.xhtml#ch00lev2sec74)
    for a refresher).'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解析了问题的模型：我们的 Point 类的三个实例。利用这些，我们的应用现在应该计算出一个通过所有这些点的圆。我们之前的工作即将得到回报：我们已经有了完成此任务的代码（请参考
    [第153页](ch06.xhtml#ch00lev2sec74)的“圆形工厂”部分，了解更多）。
- en: Open *main.py* and enter the code in [Listing 9-8](ch09.xhtml#ch9lis8).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 *main.py* 并输入 [Listing 9-8](ch09.xhtml#ch9lis8) 中的代码。
- en: '[PRE16]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 9-8: Computing the circle passing through the three points*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-8: 计算通过三个点的圆*'
- en: 'That was easy! We import make_circle_from_points from *geom2d* and simply pass
    it the three points: a, b, and c. To make sure the circle was correctly computed,
    we print the resulting circle. Run the application; you should expect the following
    string representation for the resulting circle:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单！我们从 *geom2d* 导入 make_circle_from_points，并将三个点：a、b 和 c 传递给它。为了确保圆形计算正确，我们打印出计算结果的圆形。运行应用程序，您应该期待结果圆形的以下字符串表示：
- en: '[PRE17]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you open *result.svg*, that should be its content. This file is where we’re
    redirecting our program’s output. There’s only one thing missing from our program:
    plotting the output using the SVG format!'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开*result.svg*，它应该是这个内容。这个文件是我们将程序的输出重定向到的地方。程序中只缺少一件事：使用SVG格式绘制输出！
- en: '**Generating Output**'
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**生成输出**'
- en: 'Now that the problem is solved, we need to draw an SVG with the resulting circle
    and input points. Start by creating a new file in *circle_from_points* named *output.py*.
    Your *circle_from_points* directory should look like the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在问题已经解决，我们需要绘制一个包含圆形和输入点的SVG。首先，在*circle_from_points*目录中创建一个新的文件，命名为*output.py*。你的*circle_from_points*目录应该像下面这样：
- en: circle_from_points
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: circle_from_points
- en: '|- __init__.py'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '|- __init__.py'
- en: '|- input.py'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '|- input.py'
- en: '|- main.py'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '|- main.py'
- en: '|- output.py'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '|- output.py'
- en: '|- test.txt'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '|- test.txt'
- en: In it, enter the code in [Listing 9-9](ch09.xhtml#ch9lis9).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，输入代码到[清单 9-9](ch09.xhtml#ch9lis9)。
- en: '[PRE18]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 9-9: First step to generating the output image*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-9：生成输出图像的第一步*'
- en: 'We defined a new function, draw_to_svg, which receives a sequence of points
    (the input points to the problem), the resulting circle, and a configuration dictionary.
    Note the type hint for a sequence of points: [Point]; it’s declared by the Point
    class between square brackets. A sequence type hint defined like this accepts
    both lists and tuples.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个新函数draw_to_svg，它接收一系列点（问题的输入点）、生成的圆形和配置字典。请注意，点序列的类型提示：[Point]；它由Point类在方括号中声明。这样定义的序列类型提示既可以接受列表也可以接受元组。
- en: For now, the function simply prints a message to the standard output, but we’ll
    be updating it one step at a time until it finally draws everything. With this,
    you can go ahead and give *main.py* its final look. Modify your code so that it
    looks like [Listing 9-10](ch09.xhtml#ch9lis10).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，函数只是将一条消息打印到标准输出，但我们会一步一步地更新它，直到它最终绘制出所有内容。这样，你就可以继续给*main.py*最终定型。修改你的代码，使其看起来像[清单
    9-10](ch09.xhtml#ch9lis10)。
- en: '[PRE19]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 9-10: Main file*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-10：主文件*'
- en: This code is concise. There are fundamentally three lines, which, respectively,
    read the input, solve the problem, and draw the output. With our main file all
    set up, let’s fill out draw_to_svg.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码简洁明了。基本上有三行，分别读取输入、解决问题并绘制输出。我们的主文件已经设置好，现在让我们填写draw_to_svg。
- en: '***Drawing the Output Circle***'
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制输出圆形***'
- en: We’ll start by drawing the circle. Open *output.py* and enter the code in [Listing
    9-11](ch09.xhtml#ch9lis11).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从绘制圆形开始。打开*output.py*并输入[清单 9-11](ch09.xhtml#ch9lis11)中的代码。
- en: '[PRE20]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 9-11: Drawing the resulting circle*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-11：绘制生成的圆形*'
- en: That seems like a lot of code, but don’t worry, we’ll break it down. First,
    we update the draw_to_svg function. Using the output_to_svg function we define
    later in the code, we create the SVG representation for the circle ➊. Note that
    we’re passing this function config[’output’], the *output* part of the configuration
    dictionary.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是很多代码，但别担心，我们会逐步分析。首先，我们更新draw_to_svg函数。使用我们稍后在代码中定义的output_to_svg函数，我们为圆形创建SVG表示
    ➊。请注意，我们传递给这个函数的是config[’output’]，即配置字典中的*output*部分。
- en: Then, using make_viewbox, a function we’ve yet to define, we compute the viewBox
    for the image ➋. Using this viewBox, its size, and svg_output, we generate the
    image ➌ and print it to the standard output.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用make_viewbox，这是一个我们还未定义的函数，我们计算图像的viewBox ➋。利用这个viewBox、它的大小和svg_output，我们生成图像
    ➌ 并将其打印到标准输出。
- en: 'Now let’s look at output_to_svg. This function stores the SVG attributes for
    the circle using another function we’ll define shortly (style_from_config) in
    a variable named style ➍. The same happens for the styling attributes we’ll use
    with the text, generated by label_style_from_config ➎. The function returns an
    array of three SVG primitives: the circle and two labels.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下output_to_svg。这个函数使用我们稍后将定义的另一个函数（style_from_config），将圆形的SVG属性存储在一个名为style的变量中
    ➍。对于我们将用于文本的样式属性，也是如此，它们由label_style_from_config生成 ➎。该函数返回一个包含三个SVG原语的数组：圆形和两个标签。
- en: The circle is straightforward; we use our prewritten circle function ➏. Then
    comes the label indicating where the center of the circle is ➐, located with its
    origin at the center point. Lastly, there’s the label with the information about
    the circle’s radius. This label is located in the center of the circle but displaced
    ⟨0, 20⟩ so that it appears below the former ➑.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形部分很简单；我们使用了我们预先编写的circle函数 ➏。接下来是标注，指示圆形的中心位置 ➐，该标注的原点位于圆心。最后是圆形半径信息的标签。这个标签位于圆形的中心，但稍微偏移⟨0,
    20⟩，使其出现在之前标签的下方 ➑。
- en: '**NOTE**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You may remember we said that when displacing the label by a vector* ⟨0, 20⟩*,
    it appears below the other. A positive number in the y-coordinate of the vector
    should produce an upward displacement and hence move the label on top of the other.
    But remember that in SVG the y-axis points downward. We could fix that by applying
    an affine transformation, but we won’t right now.*'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能还记得我们曾说过，当通过向量* ⟨0, 20⟩* 移动标签时，它会出现在另一个标签下方。在向量的 y 坐标中使用正数应当导致标签向上移动，因此会将标签移到另一个标签的上方。但请记住，在
    SVG 中，y 轴是向下的。我们本可以通过应用仿射变换来修正这一点，但我们现在不做这件事。*'
- en: To compute the viewBox, enter the code in [Listing 9-12](ch09.xhtml#ch9lis12)
    under output_to_svg.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算 viewBox，输入 [清单 9-12](ch09.xhtml#ch9lis12) 中的代码至 output_to_svg 函数下。
- en: '[PRE21]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 9-12: Computing the viewBox for the image*'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-12：计算图像的 viewBox*'
- en: This function computes the rectangle that defines the visible portion of the
    image. If you need a refresher, go back to section “The viewBox” on [page 207](ch08.xhtml#ch00lev2sec92).
    To construct the rectangle, we use the make_rect_centered factory function, which
    is pretty convenient now that we need a rectangle containing a circle. The height
    of the rectangle is 2.5 times the radius of the circle, that is, the diameter
    plus some margin. For the width, we use 4 times the radius (or 2 times the diameter),
    as we need some room for the labels we’ll draw. I came up with these values by
    pure trial and error, but feel free to adjust them based on your experiments.
    They’ll basically add more or less margin to your drawing; that’s all.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数计算定义图像可见部分的矩形。如果你需要复习一下，回到 [第 207 页](ch08.xhtml#ch00lev2sec92) 的“viewBox”章节。为了构建这个矩形，我们使用了
    make_rect_centered 工厂函数，这在现在需要一个包含圆形的矩形时非常方便。矩形的高度是圆形半径的 2.5 倍，也就是直径加上一些边距。宽度是半径的
    4 倍（或直径的 2 倍），因为我们需要为接下来绘制的标签留出空间。我是通过反复试验得出了这些值，但你可以根据自己的实验调整它们。它们基本上只是为你的绘图添加了更多或更少的边距，仅此而已。
- en: '[Figure 9-7](ch09.xhtml#ch9fig7) describes the layout of the SVG image we’re
    drawing for reference.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-7](ch09.xhtml#ch9fig7) 描述了我们正在绘制的 SVG 图像布局，供参考。'
- en: '![Image](../images/09fig07.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/09fig07.jpg)'
- en: '*Figure 9-7: The SVG output layout*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-7：SVG 输出布局*'
- en: Let’s implement the functions that generate the SVG styling attributes. Toward
    the end of your file *output.py*, enter the code in [Listing 9-13](ch09.xhtml#ch9lis13).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现生成 SVG 样式属性的函数。在你的文件 *output.py* 的末尾，输入 [清单 9-13](ch09.xhtml#ch9lis13)
    中的代码。
- en: '[PRE22]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 9-13: Creating styles from configuration*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-13：从配置中创建样式*'
- en: The style_from_config function creates a list of SVG attributes using the values
    from the configuration dictionary. Let’s do the same for the label’s style (see
    [Listing 9-14](ch09.xhtml#ch9lis14)).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: style_from_config 函数使用配置字典中的值创建一个 SVG 属性列表。让我们对标签的样式做同样的事情（参见 [清单 9-14](ch09.xhtml#ch9lis14)）。
- en: '[PRE23]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 9-14: Creating label styles from configuration*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-14：从配置中创建标签样式*'
- en: That’s it! We have all the code needed to draw the resulting circle in a cyanish
    color. If you run the application now, you should see how the shell spits out
    some SVG code, the same that is written in the file *result.svg*. Open this file
    using your favorite browser. The result should be something similar to [Figure
    9-8](ch09.xhtml#ch9fig8).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们已经拥有绘制结果圆形所需的所有代码，并且使用了青色。现在运行应用程序，你应该会看到 shell 输出一些 SVG 代码，这些代码与文件 *result.svg*
    中的内容相同。用你喜欢的浏览器打开这个文件，结果应该类似于 [图 9-8](ch09.xhtml#ch9fig8)。
- en: '![Image](../images/09fig08.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/09fig08.jpg)'
- en: '*Figure 9-8: The SVG output circle*'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-8：SVG 输出圆形*'
- en: There you go! We solved our first geometry problem and plotted the result into
    a vector image. Isn’t that super exciting? Go ahead and play with the configuration.
    Try changing the color for the output and rerunning the application.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们解决了第一个几何问题，并将结果绘制成了矢量图像。不是很激动人心吗？快去试试配置，改变输出颜色并重新运行应用程序。
- en: '***Drawing the Input Points***'
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***绘制输入点***'
- en: It’s nice that we drew the resulting circle with captions that indicate the
    position of the center and the radius, but the resulting image doesn’t include
    information about the input points that generated the circle. Let’s draw those
    so that one can get all the information from a single glance at the resulting
    image.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 很高兴我们绘制了带有指示圆心位置和半径的标签的圆形，但生成的图像并没有包括关于生成圆形的输入点的信息。让我们将这些点也绘制出来，这样就能一眼看出生成该圆形所需的所有信息。
- en: Let’s create a new function that is similar to output_to_svg but produces the
    SVG primitives that represent the input points. We’ll represent these points as
    circles as well. In *output.py* enter the code in [Listing 9-15](ch09.xhtml#ch9lis15).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的函数，它类似于 output_to_svg，但生成代表输入点的 SVG 基本元素。我们也将这些点表示为圆形。在 *output.py*
    中输入 [列表 9-15](ch09.xhtml#ch9lis15) 中的代码。
- en: '[PRE24]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 9-15: Drawing the input points*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-15：绘制输入点*'
- en: The input_to_svg function gets passed a list with the three input points, the
    radius to use for representing the points, and the input configuration dictionary.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: input_to_svg 函数接收一个列表，其中包含三个输入点、用于表示点的半径以及输入配置字典。
- en: As you’ll see, we’ll use a fraction of the size of the resulting circle as the
    radius for the input points. This is so that they look good no matter the size
    of the resulting image. Using a fixed number for their radius could result in
    tiny, almost invisible circles for certain inputs and monstrous circles bigger
    than the resulting one for others.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将使用生成的圆形大小的一部分作为输入点的半径。这样无论生成的图像大小如何，它们看起来都能很好。使用固定的半径值可能会导致某些输入点的圆形非常小，几乎不可见，而其他的则可能是比生成的圆形还大的巨大圆形。
- en: 'The styles for both the points and their labels are computed using the same
    functions we used before: style_from_config and label_style_from_config. The points
    in the sequence are destructured into variables a, b, and c so that we can conveniently
    use them ➊.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 点和标签的样式是使用我们之前使用的相同函数计算的：style_from_config 和 label_style_from_config。序列中的点被解构为变量
    a、b 和 c，以便我们可以方便地使用它们 ➊。
- en: Because we’ll need to move the labels a bit to the right so they don’t overlap
    with their circle, we construct a displacement vector, disp ➋. The function returns
    the array of circles with their labels ➌.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们需要将标签稍微向右移动，以避免与圆形重叠，我们构造了一个位移向量 disp ➋。该函数返回带有标签的圆形数组 ➌。
- en: Now update function draw_to_svg so that it also includes the three points in
    the resulting image (see [Listing 9-16](ch09.xhtml#ch9lis16)).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在更新函数 draw_to_svg，使其也包含生成图像中的三个点（参见 [列表 9-16](ch09.xhtml#ch9lis16)）。
- en: '[PRE25]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 9-16: Drawing to SVG*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-16：绘制到 SVG*'
- en: As mentioned, the radius for the input points needs to be a fraction of that
    from the resulting circle, so we chose one-twentieth of its radius ➊. If you think
    the resulting circles are too big or too small, you can change that value and
    experiment until you’re happy with the result. This value could be perfectly fine
    as part of the application’s configuration, but we’ll keep it as an implementation
    detail for the sake of simplicity.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，输入点的半径需要是生成的圆形半径的一部分，所以我们选择了其半径的五十分之一 ➊。如果你觉得生成的圆形太大或太小，可以更改这个值并进行实验，直到你对结果满意。这个值可以完全作为应用程序配置的一部分，但为了简单起见，我们将它保持为实现细节。
- en: After we compute pt_radius, we compute the SVG primitives for the output as
    before. Then we compute the SVG primitives for the input using the input_to_svg
    function and store the result in svg_input ➋.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算出 pt_radius 后，我们像之前一样计算输出的 SVG 基本元素。然后，我们使用 input_to_svg 函数计算输入的 SVG 基本元素，并将结果存储在
    svg_input ➋ 中。
- en: After creating a viewBox, we update the contents of the SVG image by appending
    svg_input to svg_output ➌. It’s important that svg_input goes after svg_output,
    as the image primitives are drawn in order. If you switched the order to this,
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 viewBox 后，我们通过将 svg_input 附加到 svg_output ➌ 来更新 SVG 图像的内容。重要的是，svg_input 要放在
    svg_output 后面，因为图像元素是按顺序绘制的。如果你交换顺序，变成这样，
- en: '[PRE26]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: you’d see the input point circles behind the big circle.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到输入点的圆形位于大圆形的后面。
- en: You’re now ready to run the application and then reload the *result.svg* file
    in the browser. The result should look like [Figure 9-9](ch09.xhtml#ch9fig9).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以运行应用程序，然后在浏览器中重新加载 *result.svg* 文件。结果应当如下所示：[图 9-9](ch09.xhtml#ch9fig9)。
- en: '![Image](../images/09fig09.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/09fig09.jpg)'
- en: '*Figure 9-9: An SVG with the complete result*'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-9：带有完整结果的 SVG*'
- en: '***Result***'
  id: totrans-301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***结果***'
- en: For your reference, [Listing 9-17](ch09.xhtml#ch9lis17) contains the finished
    version of *output.py*.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 供参考，[列表 9-17](ch09.xhtml#ch9lis17) 包含了 *output.py* 的完整版本。
- en: '[PRE27]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 9-17: Drawing to SVG result*'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 9-17：绘制 SVG 结果*'
- en: '***Flip the Y-Axis***'
  id: totrans-305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***翻转 Y 轴***'
- en: As you know by now, the SVG y-axis points downward. Point *C* at *y* = 500,
    for instance, is below *A* with *y* = 300\. This isn’t necessarily bad, but it
    may be the opposite of what you’re used to.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，SVG 的 y 轴是向下的。例如，点 *C* 在 *y* = 500 处，在 *y* = 300 的 *A* 之下。这不一定不好，但可能与你习惯的方式相反。
- en: 'Here’s a challenge for you: modify *output.py* so that the SVG produced uses
    an affine transformation such that the y-axis is flipped and therefore points
    upward. If you need a clue, go back to the section “Space Transformation” from
    [Chapter 8](ch08.xhtml#ch08).'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 给你一个挑战：修改*output.py*，使得生成的SVG图像使用仿射变换，使得y轴被翻转，从而指向上方。如果你需要提示，可以回顾一下[第8章](ch08.xhtml#ch08)中的“空间变换”部分。
- en: Note that if you choose to add an affine transformation that flips the y-axis
    of the entire SVG image, as follows,
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你选择添加一个仿射变换，使得整个SVG图像的y轴被翻转，如下所示，
- en: '[PRE28]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: all of the text labels will also flip vertically, which makes them impossible
    to read. Try to address this problem by also adding an affine transformation to
    all captions so that you basically flip them twice.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 所有文本标签也会垂直翻转，这使得它们无法读取。试着通过对所有标题添加仿射变换来解决这个问题，这样你就基本上翻转了它们两次。
- en: This is challenging, but a great exercise for you to try. Don’t worry, we’ll
    explore this in depth in [Part V](part05.xhtml#part05).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是个挑战，但对你来说是一个很好的练习。别担心，我们将在[第V部分](part05.xhtml#part05)深入探讨这个问题。
- en: '**Distributing Our Application**'
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**分发我们的应用程序**'
- en: 'The word has spread among your friends, and they’ve all heard about your achievement:
    you developed an application that computes the circle passing through three points
    and plots a beautiful vector image with the result. They know you’ve accomplished
    this all by yourself, without using any third-party library. They are amazed;
    “That is so hardcore,” you’ve even heard them say. They want to try it, and they’ve
    prepared a few input files to test your program. You share the code with them,
    and as they know Python, they open the shell and try to execute your *main.py*
    script, only to discover there’s a strange error that won’t let the program run.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这个消息已经在你的朋友之间传开了，他们都听说了你的成就：你开发了一个可以计算经过三点的圆并绘制出漂亮矢量图像的应用程序。他们知道这完全是你自己完成的，没有使用任何第三方库。他们都感到惊讶，“真是太厉害了，”你甚至听到他们这样说。他们也想试试，并且准备了一些输入文件来测试你的程序。你把代码分享给他们，他们因为懂Python，打开了命令行并尝试执行你的*main.py*脚本，却发现出现了一个奇怪的错误，导致程序无法运行。
- en: It’s unfortunate that to load all the modules that your application uses, there’s
    a trick that PyCharm does and we need to account for. But don’t worry, we’ll explore
    why the error happens and give a solution to it. You can use what you’ll learn
    here to distribute any application that we build in this book, or even those that
    you write yourself.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，为了加载你的应用程序所使用的所有模块，PyCharm做了一个小技巧，我们需要考虑到这一点。但别担心，我们会探讨为什么会出现这个错误并提供解决方案。你可以将这里学到的内容应用到本书中构建的任何应用程序，甚至是你自己编写的程序。
- en: '***Understanding the Problem***'
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***理解问题***'
- en: Let’s try to run our recently created program from the shell, without any change,
    to see whether we get the same result as from the IDE. In the bash shell (the
    one in your IDE or your system’s), navigate to the app’s directory,
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试从命令行运行我们最近创建的程序，不做任何更改，看看是否得到与IDE相同的结果。在bash命令行中（无论是在你的IDE中还是系统中），导航到应用程序的目录，
- en: '[PRE29]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'and run this:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行这个：
- en: '[PRE30]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Surprisingly, it doesn’t work:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 出乎意料的是，它没有起作用：
- en: '[PRE31]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is the error we get:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们得到的错误：
- en: '[PRE32]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is telling us that Python couldn’t find the apps module when it tried to
    import it. But if that’s the case, why was it running correctly from the IDE using
    the run configuration? Well, PyCharm’s run configurations do a trick under the
    hood, a trick we now need to do ourselves.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们Python在尝试导入apps模块时找不到它。但是如果是这样，为什么在使用IDE的运行配置时它能够正常运行呢？嗯，PyCharm的运行配置在幕后做了一个技巧，而我们现在需要自己做这个技巧。
- en: 'When a script imports modules, Python looks for them in specific directories.
    To know what those directories are exactly, you can query them at runtime: Python
    stores them at sys.path, which is a list that contains all the paths where Python
    looks for libraries in your machine. Python also appends the path to the script
    itself; this path is known as the *working directory*.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本导入模块时，Python会在特定的目录中查找它们。为了确切知道这些目录是什么，你可以在运行时查询它们：Python将它们存储在sys.path中，这是一个包含Python在你的计算机上查找库的所有路径的列表。Python还会将脚本本身的路径追加到这个列表中；这个路径被称为*工作目录*。
- en: 'The problem that we encountered is that sys.path doesn’t get the parent path
    of our project appended. That is unfortunate because this is where it should go
    to find our *geom2d*, *graphic*, and *apps* packages. PyCharm’s run configuration
    worked fine because it appends this path to sys.path. Let’s check this fact by
    printing the contents of sys.path to the shell inside the main script and then
    run it again using the run configuration. Open the *main.py* file and at the top
    of the file add the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到的问题是，sys.path 并没有将我们项目的父路径添加进来。这很不幸，因为它应该去这个地方查找我们的 *geom2d*、*graphic* 和
    *apps* 包。PyCharm 的运行配置之所以能正常工作，是因为它将这个路径添加到了 sys.path 中。让我们通过在主脚本中打印 sys.path
    的内容来验证这一点，然后再使用运行配置运行它。打开 *main.py* 文件，在文件顶部添加以下内容：
- en: '[PRE33]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Notice that the print statement goes right after importing sys and before the
    rest of the imports. You may get a PyCharm warning that doing this is conceptually
    wrong according to PEP-8 standards—ignore that warning. We want that print right
    before Python attempts to load anything else; otherwise, we’d get the same error
    as before when the script is run from the shell and never get to print sys.path.
    If you now rerun the project using the run configuration, the output you’ll get
    should be similar to the following:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，打印语句紧跟在导入 sys 后，位于其他导入之前。你可能会收到 PyCharm 的警告，认为按照 PEP-8 标准，这种做法在概念上是错误的——忽略这个警告。我们希望在
    Python 尝试加载其他内容之前先打印这行，否则当脚本从 shell 中运行时，我们会遇到和之前一样的错误，永远无法打印 sys.path。如果你现在使用运行配置重新运行项目，得到的输出应该类似于以下内容：
- en: '[PRE34]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Can you spot the second line (in bold) from the sys.path list? That line is
    the key to solving the problem of not finding the included modules inside our
    program. Let’s run the script now from the shell to see what that list of paths
    contains. In the IDE’s shell, navigate to the app’s directory and run this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你能从 sys.path 列表中找到第二行（加粗部分）吗？这一行是解决我们程序中找不到包含模块问题的关键。现在我们从 shell 中运行脚本，看看该路径列表包含了什么。在
    IDE 的 shell 中，导航到应用的目录并运行以下命令：
- en: '[PRE35]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This time the output is as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这次的输出如下：
- en: '[PRE36]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Can you see how the *Mechanics* directory isn’t listed here as a search path?
    If that directory isn’t included, Python won’t be able to find any module from
    that route when running our application.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看到 *Mechanics* 目录没有作为搜索路径列在这里吗？如果这个目录没有被包括在内，Python 就无法在运行应用程序时从这个路径找到任何模块。
- en: Delete the two lines you added to *main.py* so that the file looks like it did
    before, and let’s explore some possible solutions.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 删除你在 *main.py* 中添加的那两行，让文件恢复到之前的样子，然后让我们来探索一些可能的解决方案。
- en: '***Finding a Solution***'
  id: totrans-336
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***寻找解决方案***'
- en: 'The problem is clear: Python can’t load our libraries since it doesn’t have
    their parent directory listed as a search path. Let’s see how we can solve this.
    We’ll present two options, so we’ll try to understand their pros and cons before
    we decide which one works best for us.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 问题很明确：Python 无法加载我们的库，因为它没有将父目录列为搜索路径。我们来看看如何解决这个问题。我们将提供两个选项，在决定哪一个最适合我们之前，先了解它们的优缺点。
- en: '**Appending to sys.path**'
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**添加到 sys.path**'
- en: 'One possible solution is to do what PyCharm’s run configuration does: append
    the parent directory of our project to sys.path before Python attempts to import
    anything from it. We could modify *main.py* so that it looks like [Listing 9-18](ch09.xhtml#ch9lis18).'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是做 PyCharm 运行配置所做的事：在 Python 尝试导入任何内容之前，将我们项目的父目录添加到 sys.path。我们可以修改
    *main.py*，使其看起来像 [清单 9-18](ch09.xhtml#ch9lis18)。
- en: '[PRE37]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 9-18: Appending to sys.path*'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9-18：添加到 sys.path*'
- en: We first import both the os and sys modules. We then compute the project’s parent
    path by obtaining the current working directory (os.getcwd()) and navigating two
    steps back (’..’, ’..’) ➊.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入 os 和 sys 模块。然后通过获取当前工作目录 (os.getcwd()) 并向上回溯两步（'..', '..'）来计算项目的父路径 ➊。
- en: We’re using the os.path.normpath function to normalize the path so that it doesn’t
    contain the dots representing a backward movement in the directory tree. This
    function transforms a path like
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 os.path.normpath 函数来规范化路径，以确保路径中不包含表示目录树回溯的点。这个函数将像这样的路径：
- en: /Documents/MechBook/code/Mechanics/../..
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: /Documents/MechBook/code/Mechanics/../..
- en: 'into the following:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为以下内容：
- en: /Documents/MechBook
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: /Documents/MechBook
- en: That path is appended to sys.path before any other import attempts to load anything
    from our project ➋. If you run the app from the shell, it should run error free.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这个路径在 Python 尝试从我们的项目中加载任何内容之前被添加到 sys.path ➋。如果你从 shell 中运行应用，应该不会再报错。
- en: '[PRE38]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This solution works, but it still seems a bit awkward that we have to make
    users navigate into the *apps/circle_from_points* directory to run our script:
    it’d be more convenient if we could run the program from the parent directory
    of our project. Furthermore, the lines we added to *main.py* look a bit ugly and
    have nothing to do with solving the problem of finding the circle passing through
    three points. We don’t want to add those lines to every application that we implement;
    that’s unnecessary complexity we want to avoid.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案有效，但似乎有点尴尬，我们必须让用户进入*apps/circle_from_points*目录才能运行我们的脚本：如果我们能从项目的父目录运行程序会更方便。此外，我们添加到*main.py*中的那些行看起来有点难看，而且与解决通过三点画圆的问题无关。我们不希望将这些行添加到我们实现的每个应用中；那样会增加不必要的复杂性，我们希望避免。
- en: 'Let’s try a different approach that doesn’t involve changing the code in our
    main script: let’s create a bash script that appends the right working directory
    path to the Python script’s execution. Start by undoing what we did in [Listing
    9-18](ch09.xhtml#ch9lis18) so your *main.py* file looks the same as in [Listing
    9-10](ch09.xhtml#ch9lis10).'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一种不同的方法，不涉及修改主脚本中的代码：我们创建一个bash脚本，将正确的工作目录路径附加到Python脚本的执行中。首先撤销[Listing
    9-18](ch09.xhtml#ch9lis18)中所做的操作，使得你的*main.py*文件看起来和[Listing 9-10](ch09.xhtml#ch9lis10)中的一样。
- en: '**Wrapping the App with a Script**'
  id: totrans-351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**用脚本包装应用**'
- en: For what we just saw in the previous section, every package that our *main.py*
    script needs to run should be accessible either from the working directory or
    from any other path listed in sys.path.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中我们看到的，对于我们的*main.py*脚本运行所需的每个包，应该可以从工作目录或sys.path中列出的任何其他路径访问。
- en: '**NOTE**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Remember that the working directory is where the executing file (in this case*
    main.py*) is located.*'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '*记住，工作目录是执行文件（在本例中是*main.py*）所在的目录。*'
- en: 'Apart from appending paths to sys.path inside our Python code, we can also
    include paths in an *environment variable*: PYTHONPATH. When a Python script is
    run, it includes all paths defined in PYTHONPATH inside its sys.path.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在Python代码中将路径附加到sys.path之外，我们还可以在*环境变量*PYTHONPATH中包含路径。当运行Python脚本时，它会将PYTHONPATH中定义的所有路径包括在sys.path中。
- en: We can therefore create a bash script at the project’s top level, which sets
    the right paths in PYTHONPATH and then executes our app’s *main.py*. Remember
    that we use bash scripts to group a set of command line statements and run them
    together by executing a single file (revisit [Chapter 3](ch03.xhtml#ch03) for
    a refresher).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在项目的顶层创建一个bash脚本，设置PYTHONPATH中的正确路径，然后执行我们应用的*main.py*。记住，我们使用bash脚本来将一组命令行语句组合在一起，通过执行一个文件来运行它们（请回顾[第3章](ch03.xhtml#ch03)以刷新记忆）。
- en: At the top level of the project (at the same level as *geom2d* or *apps*), create
    a new file named *cifpts.sh* (an abbreviation of “circle from points”). In it,
    write the line in [Listing 9-19](ch09.xhtml#ch9lis19).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的顶层（与*geom2d*或*apps*同一级别），创建一个名为*cifpts.sh*的新文件（“circle from points”的缩写）。在其中，写入[Listing
    9-19](ch09.xhtml#ch9lis19)中的代码。
- en: '[PRE39]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*Listing 9-19: Wrapper script*'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 9-19：包装脚本*'
- en: 'The first thing we do in this line is define an environment variable PYTHONPATH
    with a value set to the current directory; the current directory is stored inside
    another Unix environment variable: PWD.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行的第一件事是定义一个环境变量PYTHONPATH，值设置为当前目录；当前目录存储在另一个Unix环境变量中：PWD。
- en: Then, in the same line, we run *main.py* in *apps/circle_from_points*. Having
    the definition of PYTHONPATH in the same line where the script is run scopes the
    environment variable to the execution of the script only. This means that once
    the script is done, the variable doesn’t exist anymore.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在同一行中，我们运行位于*apps/circle_from_points*中的*main.py*。将PYTHONPATH的定义与脚本运行放在同一行内，使环境变量仅限于脚本的执行。这意味着，一旦脚本执行完成，变量将不再存在。
- en: 'Let’s try running the script from the shell passing the file *test.txt*:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试从shell运行脚本，传递文件*test.txt*：
- en: '[PRE40]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'That should’ve printed the SVG output to the shell. We can even make the bash
    script appear as an executable by changing its user rights:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会将SVG输出打印到shell中。我们甚至可以通过更改用户权限，使bash脚本看起来像一个可执行文件：
- en: '[PRE41]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This allows us to further simplify the execution:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够进一步简化执行过程：
- en: '[PRE42]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Remember that the output needs to be redirected to a file if we want the result
    written to it instead of being printed to the shell:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果我们希望将结果写入文件而不是打印到shell中，输出需要重定向到文件：
- en: '[PRE43]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This looks more like something we want to share with our friends, all of whom
    have longed to have a script that computes the circle that passes through any
    three points.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来更像是我们希望与朋友们分享的东西，所有朋友都渴望拥有一个可以计算通过任意三点的圆的脚本。
- en: '***Running the App Without an Input File***'
  id: totrans-371
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***没有输入文件时运行应用程序***'
- en: It’s interesting to note that although we’ve been passing the script a file
    containing the definition of three points by their coordinates, our code just
    expects three lines from the standard input. This means we don’t have to create
    a file to pass our script. We can simply execute the script and write the expected
    input. If you try this in the shell,
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，尽管我们已经传递了一个包含三点坐标定义的文件，我们的代码只期待从标准输入中获取三行数据。这意味着我们不必创建一个文件来传递给脚本。我们只需要执行脚本并输入预期的数据。如果你在
    shell 中尝试这个，
- en: '[PRE44]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: you’ll get an image named *result.svg* with the result inside the current directory.
    As you see, you can directly give your program its input data from the shell.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会在当前目录下得到一个名为*result.svg*的图像，图像中包含结果。如你所见，你可以直接从 shell 中向程序提供输入数据。
- en: '**Summary**'
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'In this chapter, we’ve developed our first application: a command line tool
    that reads a file, parses it using regular expressions, and produces a beautiful
    SVG vector image. This application has integrated a lot of knowledge that we’ve
    been acquiring throughout the past chapters and has taught us about regular expressions.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了我们的第一个应用程序：一个命令行工具，它读取一个文件，使用正则表达式解析文件，并生成一个漂亮的 SVG 向量图像。这个应用程序整合了我们在过去几章中学到的很多知识，并教会了我们正则表达式的使用。
- en: We also analyzed the problem that caused our modules to not be found by Python
    when the application was run from the shell. We learned that this happened because
    our project’s root folder, *Mechanics*, wasn’t part of the list of directories
    Python uses to resolve imports. You can now easily distribute your *Mechanics*
    project to your friends so that they can play with the applications that we’ll
    be creating throughout the book, which will conveniently be wrapped into top-level
    bash scripts.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还分析了一个问题：当从 shell 运行应用程序时，Python 无法找到我们的模块。我们了解到，这个问题发生是因为我们项目的根文件夹*Mechanics*不在
    Python 用来解析导入的目录列表中。现在，你可以轻松地将你的*Mechanics*项目分发给你的朋友们，这样他们就可以使用我们将在本书中创建的应用程序，这些应用程序将方便地打包成顶级
    bash 脚本。
