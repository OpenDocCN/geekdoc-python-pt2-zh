# 13

布隆过滤器

![](img/chapterart.png)

正如我们在上一章中所看到的，我们通常需要关注我们的数据结构如何适应本地内存，以及如何限制从较慢内存中获取数据的操作。随着数据结构的增长，它能够存储更多的数据，但可能无法适应最快的内存。本章介绍了*布隆过滤器*，一种将哈希表背后的核心概念扩展到限制需要过滤大量键空间的内存量的数据结构。

布隆过滤器是由计算机科学家伯顿·布隆（Burton Bloom）于 1970 年发明的。布隆过滤器跟踪哪些键已经被插入，同时对内存使用和执行时间进行了严格的优化。它试图回答一个非常简单的“是/否”问题：我们是否曾经见过这个键？例如，我们可以使用布隆过滤器来检查一个密码是否在已知弱密码的列表中。或者，我们也可以在访问更大且更全面但较慢的数据结构之前，先使用布隆过滤器作为预筛选步骤。

为了追求极致的效率，布隆过滤器采用了一种可能导致假阳性的策略。这意味着布隆过滤器会有一定概率错误地显示某个键已经插入，而实际上它并没有插入。换句话说，布隆过滤器用于检测弱密码时，可能偶尔会拒绝一个有效的密码。

正如我们将看到的，低内存开销、快速执行时间和保证不会出现假阴性——即当某个键实际上已经存在时，系统却错误地认为它没有出现——的结合，使得布隆过滤器在进行预筛选任务和访问更昂贵的数据结构之前的早期检查中非常有用。这就导致了一种类似于第十一章缓存方法的两阶段查找。为了检查某条记录是否在我们的数据集中，我们首先检查它是否已经被插入到布隆过滤器中。由于布隆过滤器是一个紧凑的高速内存数据结构，我们可以快速地进行检查。如果布隆过滤器返回假，说明该记录不在我们的数据集中，我们可以跳过在更全面数据结构中的昂贵查找。如果布隆过滤器返回真，那么可能是出现了假阳性，或者该记录确实存在于我们更大的数据结构中，我们会进行完整的搜索。

想象一下，我们想在执行更为计算密集的搜索之前，确定某个给定记录是否存在于一个庞大的医疗记录数据库中。这个医疗数据库非常巨大，包含图片和视频，并且必须存储在多个大硬盘中。此外，鉴于有数百万条记录，甚至索引都太大，无法完全放入本地内存中。虽然布隆过滤器偶尔会返回假阳性，导致我们搜索一个不存在的记录，但它也能帮助我们避免许多无意义的搜索。每当布隆过滤器表示某个记录不在数据集中时，我们可以立即停止搜索！

## 介绍布隆过滤器

本质上，布隆过滤器是一个二进制值数组。每个桶跟踪我们是否曾经见过任何映射到该哈希值的内容。值为 1 表示该桶之前已被见过。值为 0 表示没有。

布隆过滤器在我们想在大量值中轻松搜索单一值时非常有用。想象一下，在寻找一个朋友的过程中，使用这种过滤方法来搜索一个庞大、拥挤的舞厅。我们可能会花几个小时在舞池里徘徊，注视着每个面孔，最后得出结论，朋友没有到场。首先向一个知识丰富的活动组织者询问会更简单。我们向组织者描述我们的朋友，他记忆力极好，可以确认是否有人符合这个描述。我们的描述和组织者的心理地图由一系列基本属性组成：我们的朋友很高，穿着运动鞋，戴着眼镜。

活动组织者的回答可能仍然不是百分之百准确——我们使用的是一般属性，并且多个不同的人会共享这些个人描述符。有时，组织者会给出假阳性，说：“我见过一个有这些特征的人”，而实际上我们的朋友并不在那里。但他们永远不会做出假阴性陈述，也不会告诉我们我们的朋友不在那儿，当他们实际上就在那儿。如果组织者没有见过我们列出的三个特征的人，那么我们可以保证我们的朋友不在活动中。回答不需要完全没有假阳性就能在平均上帮助我们。如果组织者能节省我们每 10 次搜索中 9 次的时间，那将是一个巨大的胜利。

让我们来探讨如何将第十章学到的哈希技术扩展到这个预筛选问题中。我们从一个简单的指示器数组开始，并检查它的不足之处。然后我们展示如何通过使用多个哈希函数来提供更强健的过滤方案。

### 指示器哈希表

考虑最简单的过滤器，一个由单个哈希函数映射的二进制指示器数组。当我们插入一个键时，我们计算哈希值并将相应的桶标记为 1。当我们查找一个键时，我们计算哈希值并检查对应的桶。这很简单，很优雅。可是，不幸的是，它会在最轻微的哈希冲突下失效。

想象一下，我们为我们那千页的咖啡日志实现了这个简单的单哈希函数过滤器。每当我们想在日志中查找某种咖啡时，我们首先问过滤器一个简单的问题：“我之前试过这种咖啡吗？”如果我们知道自己从未尝试过这款咖啡，这个过滤器常常能让我们避免在千页日志中进行二分查找。

第一个月它运行得非常完美。每次我们尝试新的咖啡时，我们都会将它添加到日志中，并将过滤器中相应的位从 0 翻转到 1，如图 13-1 所示。我们使用咖啡名称作为输入来计算哈希函数，使我们可以通过名称检查未来的咖啡。

![字符串“House Blend”被映射到第 6 个桶，该桶的值为 1。其他 11 个桶的值为 0。](img/f13001.png)

图 13-1：单一哈希函数可以将一个字符串映射到数组的索引。

对于前几个条目，单一哈希函数的布隆过滤器表现得类似于常规哈希表（没有冲突解决），它为每个条目存储二进制值。我们为每个遇到的键将 1 插入到相应的桶中，而 0 表示我们没有遇到任何映射到该值的条目。当我们询问是否尝试过 House Blend 品种时，当我们的查找返回 1 时，我们会得到一个简单的“是”。

然而，当我们向过滤器中添加越来越多的值时，问题就出现了。在一天的咖啡饮用后，我们的二进制数组开始填满。如图 13-2 所示，即使我们每天只消费几种咖啡，我们也开始将 1 填充到数组中。

![二进制数组中有四个桶的值为 1，其余的为 0。](img/f13002.png)

图 13-2：开始填满的二进制数组

由于布隆过滤器与哈希表不同，不使用链式处理或任何其他机制来解决冲突，所以两个不同的咖啡偶尔会映射到同一个条目。很快我们就无法确定是否真的尝试了烧焦豆深烘焙，还是对应的 1 是由于我们之前尝试过的生豆未煮苦辣爆豆，它恰好映射到了同一个条目。请记住，在第十章中提到，当我们从一个大的键空间（咖啡名称集合）映射到一个较小的键空间（数组中的条目）时，我们会遇到冲突。随着我们在日志中添加更多条目，这个问题变得越来越严重。

在一年之内，我们最初的过滤器实际上变得毫无用处。我们丰富的咖啡体验，虽然愉快，却把数组填满了 1。现在我们有了类似图 13-3 所示的数组。超过一半的查询结果都会发生哈希冲突，从而产生假阳性。过滤器不再是一个高效的预过滤器。相反，它几乎总是会在真正的搜索之前增加一次无用的检查。在我们的派对示例中，这相当于只用一个属性来描述我们的朋友。如果我们只提供朋友的发色，活动组织者几乎总是会遇到符合该描述的人。

![二进制数组中有 8 个桶的值为 1；只有 4 个为 0。](img/f13003.png)

图 13-3：已满的二进制数组，无法再作为有用的咖啡追踪器

解决我们不断增加的碰撞的最简单方法是增加哈希值的空间。我们可以将二进制数组变大。不再使用 100 个指示值，而是尝试 1,000。这样可以减少碰撞的可能性，但并不能完全消除它。一次碰撞仍然会导致误报，并且正如我们在第十章中所看到的那样，一些碰撞是无法避免的。不过，我们的哈希方法并不注定失败。通过采用一种策略，我们还可以进一步减少每次碰撞的*影响*。

### 布隆过滤器

布隆过滤器通过将哈希函数的思想推向极限，解决了碰撞问题。它不再为每个键使用单个哈希函数，而是采用* k *个独立的哈希函数，这些函数都将键映射到相同范围的哈希值。例如，如图 13-4 所示，我们可能为咖啡列表使用三个哈希函数。哈希函数*f1*将此键映射到索引 2；第二个函数*f2*将其映射到索引 6；第三个函数*f3*将其映射到索引 9。

![字符串“House Blend”通过第一个哈希函数映射到桶 2，通过第二个哈希函数映射到桶 6，通过第三个哈希函数映射到桶 9。](img/f13004.png)

图 13-4：使用三种哈希函数将字符串 HOUSE BLEND 插入布隆过滤器

从形式上讲，我们将布隆过滤器的操作定义如下：

1.  插入键 对于每个* k *哈希函数，将键映射到一个索引，并将该索引处的值设置为 1。

1.  查找键 对于每个* k *哈希函数，将键映射到一个索引并检查该索引处的值是否为 1。仅当所有* k *数组值为 1 时，才返回 true。

乍一看，我们所做的似乎只是让问题变得更糟。我们不再每个样本填充一个桶，而是填充三个桶。我们的数组几乎可以保证更快填满，并且更早看到碰撞。如果我们添加第二个条目，如图 13-5 所示，我们会向数组中添加更多的 1。

![字符串“Morning shock”通过第一个哈希函数映射到桶 5，通过第二个哈希函数映射到桶 2，通过第三个哈希函数映射到桶 8。](img/f13005.png)

图 13-5：使用三种哈希函数将字符串 MORNING SHOCK 插入布隆过滤器

相反，我们实际上是改进了系统。布隆过滤器的强大功能使我们能够高效地查找条目。我们要求*所有*目标字符串对应的桶中都包含 1，如图 13-6 所示，而不是屈服于单次碰撞，在看到单个 1 时就产生误报。

![字符串“Pure Caffeine”通过第一个哈希函数映射到桶 9，通过第二个哈希函数映射到桶 8，通过第三个哈希函数映射到桶 5。](img/f13006.png)

图 13-6：在具有三种哈希函数的布隆过滤器中查找字符串 PURE CAFFEINE

如果我们看到一个单独的 0，我们就知道这个条目没有被插入到数组中。在图 13-7 中，我们可以看到我们从未尝试过 Caffeine +10 烘焙咖啡。在舞厅中，活动组织者只需要知道我们的朋友戴着一顶圆顶礼帽，就可以明确回答他们没见过符合这种描述的人。他们见过身高合适和发色正确的人，但没有见过戴那顶帽子的人。我们可以安全地避免做全面搜索。

![字符串“Caffeine +10”通过第一个哈希函数映射到 9 号桶，第二个哈希函数映射到 8 号桶，第三个哈希函数映射到 4 号桶。前两个哈希函数映射到包含 1 的桶，但最后一个哈希函数映射到包含 0 的桶。](img/f13007.png)

图 13-7：在一个包含三个哈希函数的 Bloom filter 中查找字符串 CAFFEINE +10

为了注册一个假阳性，*每个*哈希值都必须与之前的条目发生碰撞。如果我们平衡数组的大小和哈希函数的数量，就可以降低假阳性的概率。

我们可以通过与一位知识渊博的咖啡师的对话来形象化 Bloom filter 处理碰撞的过程。假设在一次旅行中，朋友递给我们一杯令人惊叹的咖啡。品尝完浓郁的口感和强效的咖啡因后，我们询问朋友有关这次新发现的咖啡。令我们失望的是，朋友即将成为前朋友，他们耸耸肩，指向一个大致的方向，并声称是在“那边”的一家店里购买的。他们记不住咖啡师的名字、店铺名称，甚至连咖啡品牌都忘了。遗憾的是，我们没有时间去找到这家店并亲自询问店主。我们得赶上回家的航班。忍住失去这段知识的泪水，我们在纸上记下了几个特征，决定追踪这杯神秘的咖啡。

回到家后，我们去拜访了最有经验的咖啡师，并向他们展示我们的笔记。我们已经捕捉到了有关这杯咖啡的五个关键特征，比如“主要气味是巧克力”。显然，这些信息不足以唯一地识别这杯咖啡，但我们可以询问咖啡师是否知道有符合这些描述的咖啡。在翻阅自己 10,000 页的咖啡日志之前，咖啡师先独立地考虑这些特征，并排除了匹配的可能性。尽管我们强调这种味道的搭配出奇的好，但这位专家从未听说过有咖啡包含“额外甜美的泡泡糖味”。他们用一种奇怪的表情看着我们，并嘟囔着什么关于保持标准的事情。

在这种情况下，我们的五个属性实际上是哈希函数，将复杂的咖啡体验投影到一个较低维度的空间——一个描述词数组。咖啡师使用这些属性中的每一个单独地检查他们是否知道有任何咖啡可能匹配，使用他们自己咖啡日志的索引。索引中的条目意味着至少有一个匹配。每个属性的测试可能会出现假阳性，但这没关系。在最坏的情况下，我们浪费一些时间浏览旧的咖啡日志条目，最后确定没有完全匹配的咖啡。至少我们知道永远不会看到假阴性。如果至少有一个特征是独特的，咖啡师可以自信地说“不”，我们也可以自信地离开，知道我们咖啡师广泛的咖啡目录中没有我们想要的神秘咖啡。

我们可以仅使用布隆过滤器步骤来快速做出当下的决策，而不需要之后搜索更大的数据结构。想象一下，我们信任的咖啡师维护着一份秘密的咖啡避免列表，里面列出了全球 500 种恶心到让我们一个月都不想喝咖啡的咖啡。由于各种责任原因，他们没有公开这个列表。但如果我们问咖啡师关于列表中特定咖啡的情况，他们会礼貌地提醒我们，或许我们更适合选择无咖啡因咖啡。在品尝任何新咖啡之前，我们最好先检查它是否在他们的列表中。

当然，我们不会在每次有机会尝试新咖啡时都去找咖啡师，因此我们需要一个快速做出决定的方法。使用包括主要气味和粘度在内的五个信息属性，咖啡师为这些咖啡构建了一个布隆过滤器，列出列表中每种咖啡的五个属性，每个属性标记为 1。当我们有机会品尝新咖啡时，我们将这五个属性与列表进行对比。如果其中任何一个映射为 0，我们可以安全地喝这款新咖啡，保证它不在咖啡师的列表中。然而，如果所有属性都是 1，或许我们应该点别的。作为额外奖励，咖啡师永远不需要分发他们的秘密列表。

我们可以类似地将布隆过滤器应用于计算机科学中的应用。例如，考虑检查密码是否在已知弱密码列表中的问题。我们可以在每次有人提出新密码时，系统性地搜索整个列表。另一种选择是，我们可以创建一个布隆过滤器来快速检查是否应该拒绝该密码。偶尔我们可能会拒绝一个合理的密码，但可以保证我们永远不会让一个不好的密码通过。

### 布隆过滤器代码

在最简单的形式中，布隆过滤器可以仅作为一个二进制值数组来存储。为了让代码更清晰，我们将布隆过滤器封装在一个简单的复合数据结构中，包含一些参数，如大小和哈希函数的数量：

```py
BloomFilter {
    Integer: size
    Integer: k
    Array of bits: bins
    Array of hash functions: h
}
```

有了这个封装器，插入和查找功能的代码可以通过一个单独的`WHILE`循环来实现：

```py
BloomFilterInsertKey(BloomFilter: filter, Type: key):
    Integer: i = 0
 WHILE i < filter.k:
        Integer: index = filter.hi
        filter.bins[index] = 1
        i = i + 1

BloomFilterLookup(BloomFilter: filter, Type: key):
    Integer: i = 0
    WHILE i < filter.k:
        Integer: index = filter.hi
        IF filter.bins[index] == 0:
            return False
        i = i + 1
    return True
```

在这段代码中，`filter.hi` 表示应用于 `key` 的布隆过滤器的第 `i` 个哈希函数。两个函数都使用循环来迭代 *k* 个哈希函数，计算 `key` 的哈希值，并访问布隆过滤器数组中的相应桶。在插入时，代码将桶的值设置为 `1`；在查找时，代码检查桶是否包含 `0`，如果是，则返回 `False`。

在最坏的情况下，函数的成本随 *k* 线性增长，因为我们需要对每个操作迭代每个哈希函数。查找的结构提供了一个额外的潜在优势：一旦找到第一个 0，查找就可以立即终止，跳过后续的哈希函数。值得注意的是，插入和查找的运行时间与布隆过滤器的大小（桶的数量）和插入的项数无关。

## 调整布隆过滤器参数

影响布隆过滤器假阳性率的因素有多个，包括数组的大小和使用的哈希函数数量。通过根据实际问题调整这些参数，我们通常可以在最小化内存使用的同时，保持假阳性率非常低。我们可以通过真实数据的经验测试、模拟，或者通过一系列数学近似来评估假阳性率。

一种常见且简单的近似方法是：

*假阳性率* = (1 – (1 – 1/*m*)^(*nk*))^(*k*)

其中，*n* 是插入到布隆过滤器中的项数，*m* 是数组的大小，*k* 是使用的哈希函数数量。这个近似公式使用了简化的假设，但它很好地展示了各种参数是如何相互作用的：

+   增加数组的大小（*m*）总是会减少假阳性率，因为有更多的桶可以存储信息。

+   增加插入的项数（*n*）总是会增加假阳性率，因为更多的桶会被设置为 1。

+   增加哈希函数的数量（*k*）可以根据其他参数的不同，增加或减少假阳性率。如果使用过多的哈希函数，每次插入都会填满大量的数组。如果使用过少的哈希函数，少量的碰撞可能会产生假阳性。

表 13-1 通过展示不同布隆过滤器大小（*m*）和哈希函数数量（*k*）对假阳性率的影响，帮助我们理解对于固定项数（*n*= 100）时的假阳性率。

表 13-1：不同参数配置（*m*，*k*）下的假阳性率示例（*n*= 100）

| ***m*** | ***k* = 1** | ***k* = 3** | ***k* = 5** |
| --- | --- | --- | --- |
| 200 | 0.3942 | 0.4704 | 0.6535 |
| 400 | 0.2214 | 0.1473 | 0.1855 |
| 600 | 0.1536 | 0.0610 | 0.0579 |
| 800 | 0.1176 | 0.0306 | 0.0217 |
| 1000 | 0.0952 | 0.0174 | 0.0094 |

最终，最佳的参数设置将取决于具体的问题。我们需要在假阳性率、计算成本和内存成本之间选择一个权衡，以最适合我们的应用。

## 布隆过滤器与哈希表

此时，怀疑的读者可能再次举起双手抗议：“为什么不直接使用哈希表？每当一个键出现时，我们可以将它和一些无关的数据（例如布尔值 True）一起添加到哈希表中。然后我们可以在这个表中搜索精确匹配的键。当然，我们可能由于冲突需要做一些链式操作，但我们可以得到精确的答案。为什么你总是把事情搞得这么复杂？”

这是一个公平的观点。哈希表确实允许我们回答布隆过滤器所回答的相同问题，而且更为精确。但正如我们的怀疑读者所指出的那样，它们是以额外的空间和潜在的运行时成本为代价的。为了让哈希表完全解决冲突，我们需要存储足够的信息来确定我们以前是否见过这个确切的键，这意味着需要存储键本身。再加上链式哈希表中指针的开销，如图 13-8 所示，我们可能会使用更多的内存。

![哈希表桶的链表由包含键、值以及指向下一个节点的指针的数据节点组成。](img/f13008.png)

图 13-8：具有链式结构的哈希表需要为每个键分配内存，并至少需要一个指针。

相比之下，布隆过滤器不需要存储键或指向后续节点的指针。它仅保留每个桶的单一二进制值。我们可以使用恰好 *m* 位来存储 *m* 个桶。这种极端的空间效率具有多方面的价值。首先，它使我们能够在保持内存可管理的情况下大幅增加桶的数量（即过滤器的大小）。我们可以用一个 32 位整数的代价存储 32 个独立的桶。

第二点，更重要的是，对于计算密集型应用，它通常允许我们将布隆过滤器保留在内存中，甚至是在内存缓存中，以便快速访问。考虑我们在上一章中探讨的关于构建 B 树节点以减少从较慢内存中检索次数的权衡。布隆过滤器的作用是最大化数据结构中直接有助于过滤的部分，目标是将整个数据结构保留在非常快速的内存中。

## 这为什么很重要

布隆过滤器在我们需要在内存使用和准确性之间进行高度优化的权衡时，可以是强大的工具。它们结合了第十章中介绍的数学映射，以及第十二章中我们看到的将数据压缩成可以存储在本地内存中的形式的关注点。像缓存一样，它们提供了一种昂贵查找的中间步骤，有助于平均降低成本。

然而，更重要的是，布隆过滤器提供了一瞥一种新型数据结构——一种可能偶尔返回假阳性的结构。查找操作的准确性无法保证，而是依赖于数据的概率。如果我们运气好，可能会在看到任何假阳性之前插入大量元素。然而，如果运气不好，可能会很早就遇到冲突。这种数据结构提供了一种不同的思维方式来考虑我们如何组织数据及相关的权衡。如果我们愿意接受一些（希望是很小的）错误，我们能够推向多高的效率？

在下一章，我们将考虑一种依赖于不同类型随机性的数据显示结构。跳表（skip list）不是提供概率正确的答案，而是通过随机性避免最坏情况的表现，并在平均情况下提供高效的操作。
