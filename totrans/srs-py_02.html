<html><head></head><body>
<h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_15"/><strong><span class="big">2</span></strong><br/><strong>MODULES, LIBRARIES, AND FRAMEWORKS</strong></h2>&#13;
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>&#13;
<p class="noindent">Modules are an essential part of what makes Python extensible. Without them, Python would just be a language built around a monolithic interpreter; it wouldn’t flourish within a giant ecosystem that allows developers to build applications quickly and simply by combining extensions. In this chapter, I’ll introduce you to some of the features that make Python modules great, from the built-in modules you need to know to externally managed frameworks.</p>&#13;
<h3 class="h3" id="lev1sec8"><span epub:type="pagebreak" id="page_16"/><strong>The Import System</strong></h3>&#13;
<p class="noindent">To use modules and libraries in your programs, you have to import them using the <span class="literal">import</span> keyword. As an example, <a href="ch02.xhtml#ch2list1">Listing 2-1</a> imports the all-important Zen of Python guidelines.</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">import this</span><br/>The Zen of Python, by Tim Peters<br/><br/>Beautiful is better than ugly.<br/>Explicit is better than implicit.<br/>Simple is better than complex.<br/>Complex is better than complicated.<br/>Flat is better than nested.<br/>Sparse is better than dense.<br/>Readability counts.<br/>Special cases aren't special enough to break the rules.<br/>Although practicality beats purity.<br/>Errors should never pass silently.<br/>Unless explicitly silenced.<br/>In the face of ambiguity, refuse the temptation to guess.<br/>There should be one-- and preferably only one --obvious way to do it.<br/>Although that way may not be obvious at first unless you're Dutch.<br/>Now is better than never.<br/>Although never is often better than *right* now.<br/>If the implementation is hard to explain, it's a bad idea.<br/>If the implementation is easy to explain, it may be a good idea.<br/>Namespaces are one honking great idea -- let's do more of those!</p>&#13;
<p class="listing1"><a id="ch2list1"/><em>Listing 2-1: The Zen of Python</em></p>&#13;
<p class="indent">The import system is quite complex, and I’m assuming you already know the basics, so here I’ll show you some of the internals of this system, including how the <span class="literal">sys</span> module works, how to change or add import paths, and how to use custom importers.</p>&#13;
<p class="indent">First, you need to know that the <span class="literal">import</span> keyword is actually a wrapper around a function named <span class="literal">__import__</span>. Here is a familiar way of importing a module:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">import itertools</span><br/>&gt;&gt;&gt; <span class="codestrong1">itertools</span><br/>&lt;module 'itertools' from '/usr/.../&gt;</p>&#13;
<p class="indent">This is precisely equivalent to this method:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">itertools = __import__("itertools")</span><br/>&gt;&gt;&gt; <span class="codestrong1">itertools</span><br/>&lt;module 'itertools' from '/usr/.../&gt;</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_17"/>You can also imitate the <span class="literal">as</span> keyword of <span class="literal">import</span>, as these two equivalent ways of importing show:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">import itertools as it</span><br/>&gt;&gt;&gt; <span class="codestrong1">it</span><br/>&lt;module 'itertools' from '/usr/.../&gt;</p>&#13;
<p class="indent">And here’s the second example:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">it = __import__("itertools")</span><br/>&gt;&gt;&gt; <span class="codestrong1">it</span><br/>&lt;module 'itertools' from '/usr/.../&gt;</p>&#13;
<p class="indent">While <span class="literal">import</span> is a keyword in Python, internally it’s a simple function that’s accessible through the <span class="literal">__import__</span> name. The <span class="literal">__import__</span> function is extremely useful to know, as in some (corner) cases, you might want to import a module whose name is unknown beforehand, like so:</p>&#13;
<p class="programs">&gt;&gt;&gt; random = __import__("RANDOM".lower())<br/>&gt;&gt;&gt; random<br/>&lt;module 'random' from '/usr/.../&gt;</p>&#13;
<p class="indent">Don’t forget that modules, once imported, are essentially objects whose attributes (classes, functions, variables, and so on) are objects.</p>&#13;
<h4 class="h4" id="lev2sec5"><strong><em>The sys Module</em></strong></h4>&#13;
<p class="noindent">The <span class="literal">sys</span> module provides access to variables and functions related to Python itself and the operating system it is running on. This module also contains a lot of information about Python’s import system.</p>&#13;
<p class="indent">First of all, you can retrieve the list of modules currently imported using the <span class="literal">sys.modules</span> variable. The <span class="literal">sys.modules</span> variable is a dictionary whose key is the module name you want to inspect and whose returned value is the module object. For example, once the <span class="literal">os</span> module is imported, we can retrieve it by entering:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">import sys</span><br/>&gt;&gt;&gt; <span class="codestrong1">import os</span><br/>&gt;&gt;&gt; <span class="codestrong1">sys.modules['os']</span><br/>&lt;module 'os' from '/usr/lib/python2.7/os.pyc'&gt;</p>&#13;
<p class="indent">The <span class="literal">sys.modules</span> variable is a standard Python dictionary that contains all loaded modules. That means that calling <span class="literal">sys.modules.keys()</span>, for example, will return the complete list of the names of loaded modules.</p>&#13;
<p class="indent">You can also retrieve the list of modules that are built in by using the <span class="literal">sys.builtin_module_names</span> variable. The built-in modules compiled to your interpreter can vary depending on what compilation options were passed to the Python build system.</p>&#13;
<h4 class="h4" id="lev2sec6"><span epub:type="pagebreak" id="page_18"/><strong><em>Import Paths</em></strong></h4>&#13;
<p class="noindent">When importing modules, Python relies on a list of paths to know where to look for the module. This list is stored in the <span class="literal">sys.path</span> variable. To check which paths your interpreter will search for modules, just enter <span class="literal">sys.path</span>.</p>&#13;
<p class="indent">You can change this list, adding or removing paths as necessary, or even modify the <span class="literal">PYTHONPATH</span> environment variable to add paths without writing Python code at all. Adding paths to the <span class="literal">sys.path</span> variable can be useful if you want to install Python modules to nonstandard locations, such as a test environment. In normal operations, however, it should not be necessary to change the path variable. The following approaches are almost equivalent—<em>almost</em> because the path will not be placed at the same level in the list; this difference may not matter, depending on your use case:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">import sys</span><br/>&gt;&gt;&gt; <span class="codestrong1">sys.path.append('/foo/bar')</span></p>&#13;
<p class="indent">This would be (almost) the same as:</p>&#13;
<p class="programs">$ <span class="codestrong1">PYTHONPATH=/foo/bar python</span><br/>&gt;&gt;&gt; <span class="codestrong1">import sys</span><br/>&gt;&gt;&gt; <span class="codestrong1">'/foo/bar' in sys.path</span><br/>True</p>&#13;
<p class="indent">It’s important to note that the list will be iterated over to find the requested module, so the order of the paths in <span class="literal">sys.path</span> is important. It’s useful to put the path most likely to contain the modules you are importing early in the list to speed up search time. Doing so also ensures that if two modules with the same name are available, the first match will be picked.</p>&#13;
<p class="indent">This last property is especially important because one common mistake is to shadow Python built-in modules with your own. Your current directory is searched before the Python Standard Library directory. That means that if you decide to name one of your scripts <em>random.py</em> and then try using <span class="literal">import random</span>, the file from your current directory will be imported rather than the Python module.</p>&#13;
<h4 class="h4" id="lev2sec7"><strong><em>Custom Importers</em></strong></h4>&#13;
<p class="noindent">You can also extend the import mechanism using custom importers. This is the technique that the Lisp-Python dialect <span class="literal">Hy</span> uses to teach Python how to import files other than standard <em>.py</em> or <em>.pyc</em> files. (<span class="literal">Hy</span> is a Lisp implementation on top of Python, discussed later in the section “<a href="ch09.xhtml#lev1sec48">A Quick Introduction to Hy</a>” on <a href="ch09.xhtml#page_145">page 145</a>.)</p>&#13;
<p class="indent">The <em>import hook mechanism</em>, as this technique is called, is defined by PEP 302. It allows you to extend the standard import mechanism, which in turn allows you to modify how Python imports modules and build your own system of import. For example, you could write an extension that imports modules from a database over the network or that does some sanity checking before importing any module.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_19"/>Python offers two different but related ways to broaden the import system: the meta path finders for use with <span class="literal">sys.meta_path</span> and the path entry finders for use with <span class="literal">sys.path_hooks</span>.</p>&#13;
<h4 class="h4" id="lev2sec8"><strong><em>Meta Path Finders</em></strong></h4>&#13;
<p class="noindent">The <em>meta path finder</em> is an object that will allow you to load custom objects as well as standard <em>.py</em> files. A meta path finder object must expose a <span class="literal">find_module(fullname, path=None)</span> method that returns a loader object. The loader object must also have a <span class="literal">load_module(fullname)</span> method responsible for loading the module from a source file.</p>&#13;
<p class="indent">To illustrate, <a href="ch02.xhtml#ch2list2">Listing 2-2</a> shows how <span class="literal">Hy</span> uses a custom meta path finder to enable Python to import source files ending with <em>.hy</em> instead of <em>.py</em>.</p>&#13;
<p class="programs">class MetaImporter(object):<br/>    def find_on_path(self, fullname):<br/>        fls = ["%s/__init__.hy", "%s.hy"]<br/>        dirpath = "/".join(fullname.split("."))<br/><br/>        for pth in sys.path:<br/>            pth = os.path.abspath(pth)<br/>            for fp in fls:<br/>                composed_path = fp % ("%s/%s" % (pth, dirpath))<br/>                if os.path.exists(composed_path):<br/>                    return composed_path<br/><br/>    def find_module(self, fullname, path=None):<br/>        path = self.find_on_path(fullname)<br/>        if path:<br/>            return MetaLoader(path)<br/><br/>sys.meta_path.append(MetaImporter())</p>&#13;
<p class="listing1"><a id="ch2list2"/><em>Listing 2-2: A <span class="codeitalic">Hy</span> module importer</em></p>&#13;
<p class="indent">Once Python has determined that the path is valid and that it points to a module, a <span class="literal">MetaLoader</span> object is returned, as shown in <a href="ch02.xhtml#ch2list3">Listing 2-3</a>.</p>&#13;
<p class="programs">class MetaLoader(object):<br/>    def __init__(self, path):<br/>        self.path = path<br/><br/>    def is_package(self, fullname):<br/>        dirpath = "/".join(fullname.split("."))<br/>        for pth in sys.path:<br/>            pth = os.path.abspath(pth)<br/>            composed_path = "%s/%s/__init__.hy" % (pth, dirpath)<br/>            if os.path.exists(composed_path):<br/>                return True<br/>        return False<br/><br/>    def load_module(self, fullname):<br/>        if fullname in sys.modules:<span epub:type="pagebreak" id="page_20"/><br/>            return sys.modules[fullname]<br/><br/>        if not self.path:<br/>            return<br/><br/>        sys.modules[fullname] = None<br/>     <span class="ent">➊</span> mod = import_file_to_module(fullname, self.path)<br/><br/>        ispkg = self.is_package(fullname)<br/><br/>        mod.__file__ = self.path<br/>        mod.__loader__ = self<br/>        mod.__name__ = fullname<br/><br/>        if ispkg:<br/>            mod.__path__ = []<br/>            mod.__package__ = fullname<br/>        else:<br/>            mod.__package__ = fullname.rpartition('.')[0]<br/><br/>        sys.modules[fullname] = mod<br/>        return mod</p>&#13;
<p class="listing1"><a id="ch2list3"/><em>Listing 2-3: A <span class="codeitalic">Hy</span> module loader object</em></p>&#13;
<p class="indent">At <span class="ent">➊</span>, <span class="literal">import_file_to_module</span> reads a <em>.hy</em> source file, compiles it to Python code, and returns a Python module object.</p>&#13;
<p class="indent">This loader is pretty straightforward: once the <em>.hy</em> file is found, it’s passed to this loader, which compiles the file if necessary, registers it, sets some attributes, and then returns it to the Python interpreter.</p>&#13;
<p class="indent">The <span class="literal">uprefix</span> module is another good example of this feature in action. Python 3.0 through 3.2 didn’t support the <span class="literal">u</span> prefix for denoting Unicode strings that was featured in Python 2; the <span class="literal">uprefix</span> module ensures compatibility between Python versions 2 and 3 by removing the <span class="literal">u</span> prefix from strings before compilation.</p>&#13;
<h3 class="h3" id="lev1sec9"><strong>Useful Standard Libraries</strong></h3>&#13;
<p class="noindent">Python comes with a huge standard library packed with tools and features for almost any purpose you can think of. Newcomers to Python who are used to having to write their own functions for basic tasks are often shocked to find that the language itself ships with so much functionality built in and ready for use.</p>&#13;
<p class="indent">Whenever you’re tempted to write your own function to handle a simple task, first stop and look through the standard library. In fact, skim through the whole thing at least once before you begin working with Python so that next time you need a function, you have an idea of whether it already exists in the standard library.</p>&#13;
<p class="indent">We’ll talk about some of these modules, such as <span class="literal">functools</span> and <span class="literal">itertools</span>, in later chapters, but here are a few of the standard modules that you’ll definitely find useful:</p>&#13;
<ul>&#13;
<li><p class="noindent"><span epub:type="pagebreak" id="page_21"/><span class="literal">atexit</span> allows you to register functions for your program to call when it exits.</p></li>&#13;
<li><p class="noindent"><span class="literal">argparse</span> provides functions for parsing command line arguments.</p></li>&#13;
<li><p class="noindent"><span class="literal">bisect</span> provides bisection algorithms for sorting lists (see <a href="ch10.xhtml#ch10">Chapter 10</a>).</p></li>&#13;
<li><p class="noindent"><span class="literal">calendar</span> provides a number of date-related functions.</p></li>&#13;
<li><p class="noindent"><span class="literal">codecs</span> provides functions for encoding and decoding data.</p></li>&#13;
<li><p class="noindent"><span class="literal">collections</span> provides a variety of useful data structures.</p></li>&#13;
<li><p class="noindent"><span class="literal">copy</span> provides functions for copying data.</p></li>&#13;
<li><p class="noindent"><span class="literal">csv</span> provides functions for reading and writing CSV files.</p></li>&#13;
<li><p class="noindent"><span class="literal">datetime</span> provides classes for handling dates and times.</p></li>&#13;
<li><p class="noindent"><span class="literal">fnmatch</span> provides functions for matching Unix-style filename patterns.</p></li>&#13;
<li><p class="noindent"><span class="literal">concurrent</span> provides asynchronous computation (native in Python 3, available for Python 2 via PyPI).</p></li>&#13;
<li><p class="noindent"><span class="literal">glob</span> provides functions for matching Unix-style path patterns.</p></li>&#13;
<li><p class="noindent"><span class="literal">io</span> provides functions for handling I/O streams. In Python 3, it also contains StringIO (inside the module of the same name in Python 2), which allows you to treat strings as files.</p></li>&#13;
<li><p class="noindent"><span class="literal">json</span> provides functions for reading and writing data in JSON format.</p></li>&#13;
<li><p class="noindent"><span class="literal">logging</span> provides access to Python’s own built-in logging functionality.</p></li>&#13;
<li><p class="noindent"><span class="literal">multiprocessing</span> allows you to run multiple subprocesses from your application, while providing an API that makes them look like threads.</p></li>&#13;
<li><p class="noindent"><span class="literal">operator</span> provides functions implementing the basic Python operators, which you can use instead of having to write your own lambda expressions (see <a href="ch10.xhtml#ch10">Chapter 10</a>).</p></li>&#13;
<li><p class="noindent"><span class="literal">os</span> provides access to basic OS functions.</p></li>&#13;
<li><p class="noindent"><span class="literal">random</span> provides functions for generating pseudorandom numbers.</p></li>&#13;
<li><p class="noindent"><span class="literal">re</span> provides regular expression functionality.</p></li>&#13;
<li><p class="noindent"><span class="literal">sched</span> provides an event scheduler without using multithreading.</p></li>&#13;
<li><p class="noindent"><span class="literal">select</span> provides access to the <span class="literal">select()</span> and <span class="literal">poll()</span> functions for creating event loops.</p></li>&#13;
<li><p class="noindent"><span class="literal">shutil</span> provides access to high-level file functions.</p></li>&#13;
<li><p class="noindent"><span class="literal">signal</span> provides functions for handling POSIX signals.</p></li>&#13;
<li><p class="noindent"><span class="literal">tempfile</span> provides functions for creating temporary files and directories.</p></li>&#13;
<li><p class="noindent"><span class="literal">threading</span> provides access to high-level threading functionality.</p></li>&#13;
<li><p class="noindent"><span class="literal">urllib</span> (and <span class="literal">urllib2</span> and <span class="literal">urlparse</span> in Python 2.<em>x</em>) provides functions for handling and parsing URLs.</p></li>&#13;
<li><p class="noindent"><span class="literal">uuid</span> allows you to generate Universally Unique Identifiers (UUIDs).</p></li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_22"/>Use this list as a quick reference for what these useful libraries modules do. If you can memorize even part of this list, all the better. The less time you have to spend looking up library modules, the more time you can spend writing the code you actually need.</p>&#13;
<p class="indent">Most of the standard library is written in Python, so there’s nothing stopping you from looking at the source code of the modules and functions. When in doubt, crack open the code and see what it does for yourself. Even if the documentation has everything you need to know, there’s always a chance you could learn something useful.</p>&#13;
<h3 class="h3" id="lev1sec10"><strong>External Libraries</strong></h3>&#13;
<p class="noindent">Python’s “batteries included” philosophy is that, once you have Python installed, you should have everything you need to build whatever you want. This is to prevent the programming equivalent of unwrapping an awesome gift only to find out that whoever gave it to you forgot to buy batteries for it.</p>&#13;
<p class="indent">Unfortunately, there’s no way the people behind Python can predict <em>everything</em> you might want to make. And even if they could, most people wouldn’t want to deal with a multigigabyte download, especially if they just wanted to write a quick script for renaming files. So even with its extensive functionality, the Python Standard Library doesn’t cover everything. Luckily, members of the Python community have created external libraries.</p>&#13;
<p class="indent">The Python Standard Library is safe, well-charted territory: its modules are heavily documented, and enough people use it on a regular basis that you can feel assured it won’t break messily when you give it a try—and in the unlikely event that it <em>does</em> break, you can be confident someone will fix it in short order. External libraries, on the other hand, are the parts of the map labeled “here there be dragons”: documentation may be sparse, functionality may be buggy, and updates may be sporadic or even nonexistent. Any serious project will likely need functionality that only external libraries can provide, but you need to be mindful of the risks involved in using them.</p>&#13;
<p class="indent">Here’s a tale of external library dangers from the trenches. OpenStack uses SQLAlchemy, a database toolkit for Python. If you’re familiar with SQL, you know that database schemas can change over time, so OpenStack also made use of <span class="literal">sqlalchemy-migrate</span> to handle schema migration needs. And it worked . . . until it didn’t. Bugs started piling up, and nothing was getting done about them. At this time, OpenStack was also interested in supporting Python 3, but there was no sign that <span class="literal">sqlalchemy-migrate</span> was moving toward Python 3 support. It was clear by that point that <span class="literal">sqlalchemy-migrate</span> was effectively dead for our needs and we needed to switch to something else—our needs had outlived the capabilities of the external library. At the time of this writing, OpenStack projects are migrating toward using Alembic instead, a new SQL database migrations tool with Python 3 support. This is happening not without some effort, but fortunately without much pain.</p>&#13;
<h4 class="h4" id="lev2sec9"><span epub:type="pagebreak" id="page_23"/><strong><em>The External Libraries Safety Checklist</em></strong></h4>&#13;
<p class="noindentb">All of this builds up to one important question: how can you be sure you won’t fall into this external libraries trap? Unfortunately, you can’t: programmers are people, too, and there’s no way you can know for sure whether a library that’s zealously maintained today will still be in good shape in a few months. However, using such libraries may be worth the risk; it’s just important to carefully assess your situation. At OpenStack, we use the following checklist when choosing whether to use an external library, and I encourage you to do the same.</p>&#13;
<p class="noindent1"><strong>Python 3 compatibility</strong> Even if you’re not targeting Python 3 right now, odds are good that you will somewhere down the line, so it’s a good idea to check that your chosen library is already Python 3–compatible and committed to staying that way.</p>&#13;
<p class="noindent1"><strong>Active development</strong> GitHub and Ohloh usually provide enough information to determine whether a given library is being actively developed by its maintainers.</p>&#13;
<p class="noindent1"><strong>Active maintenance</strong> Even if a library is considered finished (that is, feature complete), the maintainers should be ensuring it remains bug-free. Check the project’s tracking system to see how quickly the maintainers respond to bugs.</p>&#13;
<p class="noindent1"><strong>Packaged with OS distributions</strong> If a library is packaged with major Linux distributions, that means other projects are depending on it—so if something goes wrong, you won’t be the only one complaining. It’s also a good idea to check this if you plan to release your software to the public: your code will be easier to distribute if its dependencies are already installed on the end user’s machine.</p>&#13;
<p class="noindent1"><strong>API compatibility commitment</strong> Nothing’s worse than having your software suddenly break because a library it depends on has changed its entire API. You might want to check whether your chosen library has had anything like this happen in the past.</p>&#13;
<p class="noindent1"><strong>License</strong> You need to make sure that the license is compatible with the software you’re planning to write and that it allows you to do whatever you intend to do with your code in terms of distribution, modification, and execution.</p>&#13;
<p class="indentt">Applying this checklist to dependencies is also a good idea, though that could turn out to be a huge undertaking. As a compromise, if you know your application is going to depend heavily on a particular library, you should apply this checklist to each of that library’s dependencies.</p>&#13;
<h4 class="h4" id="lev2sec10"><strong><em>Protecting Your Code with an API Wrapper</em></strong></h4>&#13;
<p class="noindent">No matter what libraries you end up using, you need to treat them as useful devices that could potentially do some serious damage. For safety, libraries should be treated like any physical tool: kept in your tool shed, away from your fragile valuables but available when you actually need them.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_24"/>No matter how useful an external library might be, be wary of letting it get its hooks into your actual source code. Otherwise, if something goes wrong and you need to switch libraries, you might have to rewrite huge swaths of your program. A better idea is to write your own API—a wrapper that encapsulates your external libraries and keeps them out of your source code. Your program never has to know what external libraries it’s using, only what functionality your API provides. Then, if you need to use a different library, all you have to change is your wrapper. As long as the new library provides the same functionality, you won’t have to touch the rest of your codebase at all. There might be exceptions, but probably not many; most libraries are designed to solve a tightly focused range of problems and can therefore be easily isolated.</p>&#13;
<p class="indent">Later in <a href="ch05.xhtml#ch05">Chapter 5</a>, we’ll also look at how you can use entry points to build driver systems that will allow you to treat parts of your projects as modules you can switch out at will.</p>&#13;
<h3 class="h3" id="lev1sec11"><strong>Package Installation: Getting More from pip</strong></h3>&#13;
<p class="noindent">The <span class="literal">pip</span> project offers a really simple way to handle package and external library installations. It is actively developed, well maintained, and included with Python starting at version 3.4. It can install or uninstall packages from the <em>Python Packaging Index (PyPI)</em>, a tarball, or a <span class="literal">Wheel</span> archive (we’ll discuss these in <a href="ch05.xhtml#ch05">Chapter 5</a>).</p>&#13;
<p class="indent">Its usage is simple:</p>&#13;
<p class="programs">$ <span class="codestrong1">pip install --user voluptuous</span><br/>Downloading/unpacking voluptuous<br/>  Downloading voluptuous-0.8.3.tar.gz<br/>  Storing download in cache at ./.cache/pip/https%3A%2F%2Fpypi.python.org%2Fpa<br/>ckages%2Fsource%2Fv%2Fvoluptuous%2Fvoluptuous-0.8.3.tar.gz<br/>  Running setup.py egg_info for package voluptuous<br/><br/>Requirement already satisfied (use --upgrade to upgrade): distribute in /usr/<br/>lib/python2.7/dist-packages (from voluptuous)<br/>Installing collected packages: voluptuous<br/>  Running setup.py install for voluptuous<br/><br/>Successfully installed voluptuous<br/>Cleaning up...</p>&#13;
<p class="indent">By looking it up on the PyPI distribution index, where anyone can upload a package for distribution and installation by others, <span class="literal">pip install</span> can install any package.</p>&#13;
<p class="indent">You can also provide a <span class="literal">--user</span> option that makes <span class="literal">pip</span> install the package in your home directory. This avoids polluting your operating system directories with packages installed system-wide.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_25"/>You can list the packages you already have installed using the <span class="literal">pip freeze</span> command, like so:</p>&#13;
<p class="programs">$ <span class="codestrong1">pip freeze</span><br/>Babel==1.3<br/>Jinja2==2.7.1<br/>commando=0.3.4<br/><span class="codeitalic1">--snip--</span></p>&#13;
<p class="indent">Uninstalling packages is also supported by <span class="literal">pip</span>, using the <span class="literal">uninstall</span> command:</p>&#13;
<p class="programs">$ <span class="codestrong1">pip uninstall pika-pool</span><br/>Uninstalling pika-pool-0.1.3:<br/>  /usr/local/lib/python2.7/site-packages/pika_pool-0.1.3.dist-info/<br/>DESCRIPTION.rst<br/>  /usr/local/lib/python2.7/site-packages/pika_pool-0.1.3.dist-info/INSTALLER<br/>  /usr/local/lib/python2.7/site-packages/pika_pool-0.1.3.dist-info/METADATA<br/><br/><span class="codeitalic1">--snip--</span><br/>Proceed (y/n)? y<br/>  Successfully uninstalled pika-pool-0.1.3</p>&#13;
<p class="indent">One very valuable feature of <span class="literal">pip</span> is its ability to install a package without copying the package’s file. The typical use case for this feature is when you’re actively working on a package and want to avoid the long and boring process of reinstalling it each time you need to test a change. This can be achieved by using the <span class="literal">-e <span class="codeitalic">&lt;directory&gt;</span></span> flag:</p>&#13;
<p class="programs">$ <span class="codestrong1">pip install -e .</span><br/>Obtaining file:///Users/jd/Source/daiquiri<br/>Installing collected packages: daiquiri<br/>  Running setup.py develop for daiquiri<br/>Successfully installed daiquiri</p>&#13;
<p class="indent">Here, <span class="literal">pip</span> does not copy the files from the local source directory but places a special file, called an <span class="literal">egg-link</span>, in your distribution path. For example:</p>&#13;
<p class="programs">$ <span class="codestrong1">cat /usr/local/lib/python2.7/site-packages/daiquiri.egg-link</span><br/>/Users/jd/Source/daiquiri</p>&#13;
<p class="indent">The <span class="literal">egg-link</span> file contains the path to add to <span class="literal">sys.path</span> to look for packages. The result can be easily checked by running the following command:</p>&#13;
<p class="programs">$ <span class="codestrong1">python -c "import sys; print('/Users/jd/Source/daiquiri' in sys.path)"</span><br/>True</p>&#13;
<p class="indent">Another useful <span class="literal">pip</span> tool is the <span class="literal">-e</span> option of <span class="literal">pip install</span>, helpful for deploying code from repositories of various version control systems: git, <span epub:type="pagebreak" id="page_26"/>Mercurial, Subversion, and even Bazaar are supported. For example, you can install any library directly from a git repository by passing its address as a URL after the <span class="literal">-e</span> option:</p>&#13;
<p class="programs">$ <span class="codestrong1">pip install -e git+https://github.com/jd/daiquiri.git\#egg=daiquiri</span><br/>Obtaining daiquiri from git+https://github.com/jd/daiquiri.git#egg=daiquiri<br/>  Cloning https://github.com/jd/daiquiri.git to ./src/daiquiri<br/>Installing collected packages: daiquiri<br/>  Running setup.py develop for daiquiri<br/>Successfully installed daiquiri</p>&#13;
<p class="indent">For the installation to work correctly, you need to provide the package egg name by adding <span class="literal">#egg=</span> at the end of the URL. Then, <span class="literal">pip</span> just uses <span class="literal">git clone</span> to clone the repository inside a <span class="literal">src/<span class="codeitalic">&lt;eggname&gt;</span></span> and creates an <span class="literal">egg-link</span> file pointing to that same cloned directory.</p>&#13;
<p class="indent">This mechanism is extremely handy when depending on unreleased versions of libraries or when working in a continuous testing system. However, since there is no versioning behind it, the <span class="literal">-e</span> option can also be very nasty. You cannot know in advance that the next commit in this remote repository is not going to break everything.</p>&#13;
<p class="indent">Finally, all other installation tools are being deprecated in favor of <span class="literal">pip</span>, so you can confidently treat it as your one-stop shop for all your package management needs.</p>&#13;
<h3 class="h3" id="lev1sec12"><strong>Using and Choosing Frameworks</strong></h3>&#13;
<p class="noindent">Python has a variety of frameworks available for various kinds of Python applications: if you’re writing a web application, you could use Django, Pylons, TurboGears, Tornado, Zope, or Plone; if you’re looking for an event-driven framework, you could use Twisted or Circuits; and so on.</p>&#13;
<p class="indent">The main difference between frameworks and external libraries is that applications use frameworks by building on top of them: your code will extend the framework rather than vice versa. Unlike a library, which is basically an add-on you can bring in to give your code some extra oomph, a framework forms the <em>chassis</em> of your code: everything you do builds on that chassis in some way. This can be a double-edged sword. There are plenty of upsides to using frameworks, such as rapid prototyping and development, but there are also some noteworthy downsides, such as lock-in. You need to take these considerations into account when you decide whether to use a framework.</p>&#13;
<p class="indent">The recommendations for what to check when choosing the right framework for your Python application are largely the same as those described in “<a href="ch02.xhtml#lev2sec9">The External Libraries Safety Checklist</a>” on <a href="ch02.xhtml#page_23">page 23</a>—which makes sense, as frameworks are distributed as bundles of Python libraries. Sometimes frameworks also include tools for creating, running, and deploying applications, but that doesn’t change the criteria you should apply. We’ve established <span epub:type="pagebreak" id="page_27"/>that replacing an external library after you’ve already written code that makes use of it is a pain, but replacing a framework is a thousand times worse, usually requiring a complete rewrite of your program from the ground up.</p>&#13;
<p class="indent">To give an example, the Twisted framework mentioned earlier still doesn’t have full Python 3 support: if you wrote a program using Twisted a few years back and wanted to update it to run on Python 3, you’d be out of luck. Either you’d have to rewrite your entire program to use a different framework, or you’d have to wait until someone finally gets around to upgrading Twisted with full Python 3 support.</p>&#13;
<p class="indent">Some frameworks are lighter than others. For example, Django has its own built-in ORM functionality; Flask, on the other hand, has nothing of the sort. The <em>less</em> a framework tries to do for you, the fewer problems you’ll have with it in the future. However, each feature a framework lacks is another problem for you to solve, either by writing your own code or going through the hassle of handpicking another library to handle it. It’s your choice which scenario you’d rather deal with, but choose wisely: migrating away from a framework when things go sour can be a Herculean task, and even with all its other features, there’s nothing in Python that can help you with that.</p>&#13;
<h3 class="h3" id="lev1sec13"><strong>Doug Hellmann, Python Core Developer, on Python Libraries</strong></h3>&#13;
<p class="noindent">Doug Hellmann is a senior developer at DreamHost and a fellow contributor to the OpenStack project. He launched the website Python Module of the Week (<em><a href="http://www.pymotw.com/">http://www.pymotw.com/</a></em>) and has written an excellent book called <em>The Python Standard Library by Example</em>. He is also a Python core developer. I’ve asked Doug a few questions about the Standard Library and designing libraries and applications around it.</p>&#13;
<p class="noindentt"><strong>When you start writing a Python application from scratch, what’s your first move?</strong></p>&#13;
<p class="noindent">The steps for writing an application from scratch are similar to hacking an existing application, in the abstract, but the details change.</p>&#13;
<p class="indent">When I change existing code, I start by figuring out how it works and where my changes would need to go. I may use some debugging techniques: adding logging or print statements, or using <span class="literal">pdb</span>, and running the app with test data to make sure I understand what it’s doing. I usually make the change and test it by hand, then add any automated tests before contributing a patch.</p>&#13;
<p class="indent">I take the same exploratory approach when I create a new application—create some code and run it by hand, and then once I have the basic functionality working, I write tests to make sure I’ve covered all of the edge cases. Creating the tests may also lead to some refactoring to make the code easier to work with.</p>&#13;
<p class="indent">That was definitely the case with smiley [a tool for spying on your Python programs and recording their activities]. I started by experimenting with Python’s trace API, using some throwaway scripts, before building the real application. Originally, I planned to have one piece to instrument and collect data from another running application, and <span epub:type="pagebreak" id="page_28"/>another to collect the data sent over the network and save it. While adding a couple of reporting features, I realized that the processing for replaying the collected data was almost identical to the processing for collecting it in the first place. I refactored a few classes and was able to create a base class for the data collection, database access, and report generator. Making those classes conform to the same API allowed me to easily create a version of the data collection app that wrote directly to the database instead of sending information over the network.</p>&#13;
<p class="indent">While designing an app, I think about how the user interface works, but for libraries, I focus on how a developer will use the API. It can also be easier to write the tests for programs that will use the new library first, then the library code. I usually create a series of example programs in the form of tests and then build the library to work that way.</p>&#13;
<p class="indent">I’ve also found that writing documentation for a library before writing any code helps me think through the features and workflows without committing to the implementation details, and it lets me record the choices I made in the design so the reader understands not just how to use the library but the expectations I had while creating it.</p>&#13;
<p class="noindentt"><strong>What’s the process for getting a module into the Python Standard Library?</strong></p>&#13;
<p class="noindent">The full process and guidelines for submitting a module into the standard library can be found in the Python Developer’s Guide at <em><a href="https://docs.python.org/devguide/stdlibchanges.html">https://docs.python.org/devguide/stdlibchanges.html</a></em>.</p>&#13;
<p class="indent">Before a module can be added, the submitter needs to prove that it’s stable and widely useful. The module should provide something that is either hard to implement correctly on your own or so useful that many developers have created their own variations. The API should be clear, and any module dependencies should be inside the Standard Library only.</p>&#13;
<p class="indent">The first step would be to run the idea of introducing the module into the standard library by the community via the <em>python-ideas</em> list to informally gauge the level of interest. Assuming the response is positive, the next step is to create a Python Enhancement Proposal (PEP), which should include the motivation for adding the module and implementation details of how the transition will happen.</p>&#13;
<p class="indent">Because package management and discovery tools have become so reliable, especially <span class="literal">pip</span> and the PyPI, it may be more practical to maintain a new library outside of the Python Standard Library. A separate release allows for more frequent updates with new features and bug fixes, which can be especially important for libraries addressing new technologies or APIs.</p>&#13;
<p class="noindentt"><strong>What are the top three modules from the Standard Library that you wish people knew more about?</strong></p>&#13;
<p class="noindent">One really useful tool from the Standard Library is the <span class="literal">abc</span> module. I use the <span class="literal">abc</span> module to define the APIs for dynamically loaded extensions as abstract base classes, to help extension authors understand which <span epub:type="pagebreak" id="page_29"/>methods of the API are required and which are optional. Abstract base classes are built into some other OOP [object-oriented programming] languages, but I’ve found a lot of Python programmers don’t know we have them as well.</p>&#13;
<p class="indent">The binary search algorithm in the <span class="literal">bisect</span> module is a good example of a useful feature that’s often implemented incorrectly, which makes it a great fit for the Standard Library. I especially like the fact that it can search sparse lists where the search value may not be included in the data.</p>&#13;
<p class="indent">There are some useful data structures in the <span class="literal">collections</span> module that aren’t used as often as they could be. I like to use <span class="literal">namedtuple</span> for creating small, class-like data structures that need to hold data without any associated logic. It’s very easy to convert from a <span class="literal">namedtuple</span> to a regular class if logic does need to be added later, since <span class="literal">namedtuple</span> supports accessing attributes by name. Another interesting data structure from the module is <span class="literal">ChainMap</span>, which makes a good stackable namespace. <span class="literal">ChainMap</span> can be used to create contexts for rendering templates or managing configuration settings from different sources with clearly defined precedence.</p>&#13;
<p class="noindentt"><strong>A lot of projects, including OpenStack and external libraries, roll their own abstractions on top of the Standard Library, like for date/time handling, for example. In your opinion, should programmers stick to the Standard Library, roll their own functions, switch to some external library, or start sending patches to Python?</strong></p>&#13;
<p class="noindent">All of the above! I prefer to avoid reinventing the wheel, so I advocate strongly for contributing fixes and enhancements upstream to projects that can be used as dependencies. On the other hand, sometimes it makes sense to create another abstraction and maintain that code separately, either within an application or as a new library.</p>&#13;
<p class="indent">The <span class="literal">timeutils</span> module, used in your example, is a fairly thin wrapper around Python’s <span class="literal">datetime</span> module. Most of the functions are short and simple, but creating a module with the most common operations ensures they’re handled consistently throughout all projects. Because a lot of the functions are application specific, in the sense that they enforce decisions about things like timestamp format strings or what “now” means, they are not good candidates for patches to Python’s library or to be released as a general purpose library and adopted by other projects.</p>&#13;
<p class="indent">In contrast, I have been working to move the API services in OpenStack away from the WSGI [Web Server Gateway Interface] framework created in the early days of the project and onto a third-party web development framework. There are a lot of options for creating WSGI applications in Python, and while we may need to enhance one to make it completely suitable for OpenStack’s API servers, contributing those reusable changes upstream is preferable to maintaining a “private” framework.</p>&#13;
<p class="noindentt"><span epub:type="pagebreak" id="page_30"/><strong>What would your advice be to developers hesitating between major Python versions?</strong></p>&#13;
<p class="noindent">The number of third-party libraries supporting Python 3 has reached critical mass. It’s easier than ever to build new libraries and applications for Python 3, and thanks to the compatibility features added to 3.3, maintaining support for Python 2.7 is also easier. The major Linux distributions are working on shipping releases with Python 3 installed by default. Anyone starting a new project in Python should look seriously at Python 3, unless they have a dependency that hasn’t been ported. At this point, though, libraries that don’t run on Python 3 could almost be classified as “unmaintained.”</p>&#13;
<p class="noindentt"><strong>What are the best ways to branch code out from an application into a library in terms of design, planning ahead, migration, etc.?</strong></p>&#13;
<p class="noindent">Applications are collections of “glue code” holding libraries together for a specific purpose. Designing your application with the features to achieve that purpose as a library first and then building the application ensures that code is properly organized into logical units, which in turn makes testing simpler. It also means the features of an application are accessible through the library and can be remixed to create other applications. If you don’t take this approach, you risk the features of the application being tightly bound to the user interface, which makes them harder to modify and reuse.</p>&#13;
<p class="noindentt"><strong>What advice would you give to people planning to design their own Python libraries?</strong></p>&#13;
<p class="noindent">I always recommend designing libraries and APIs from the top down, applying design criteria such as the Single Responsibility Principle (SRP) at each layer. Think about what the caller will want to do with the library and create an API that supports those features. Think about what values can be stored in an instance and used by the methods versus what needs to be passed to each method every time. Finally, think about the implementation and whether the underlying code should be organized differently than the code of the public API.</p>&#13;
<p class="indent">SQLAlchemy is an excellent example of applying those guidelines. The declarative ORM [object relational mapping], data mapping, and expression generation layers are all separate. A developer can decide the right level of abstraction for entering the API and using the library based on their needs rather than constraints imposed by the library’s design.</p>&#13;
<p class="noindentt"><strong>What are the most common programming errors you encounter while reading Python developers’ code?</strong></p>&#13;
<p class="noindent">One area where Python’s idioms are significantly different from other languages is in looping and iteration. For example, one of the most common anti-patterns I see is the use of a <span class="literal">for</span> loop to filter a list by first appending items to a new list and then processing the result in a second loop (possibly after passing the list as an argument to a function). I <span epub:type="pagebreak" id="page_31"/>almost always suggest converting filtering loops like these into generator expressions, which are more efficient and easier to understand. It’s also common to see lists being combined so their contents can be processed together in some way, rather than using <span class="literal">itertools.chain()</span>.</p>&#13;
<p class="indent">There are other, more subtle things I often suggest in code reviews, like using a <span class="literal">dict()</span> as a lookup table instead of a long <span class="literal">if:then:else</span> block, making sure functions always return the same type of object (for example, an empty list instead of <span class="literal">None</span>), reducing the number of arguments a function requires by combining related values into an object with either a tuple or a new class, and defining classes to use in public APIs instead of relying on dictionaries.</p>&#13;
<p class="noindentt"><strong>What’s your take on frameworks?</strong></p>&#13;
<p class="noindent">Frameworks are like any other kind of tool. They can help, but you need to take care when choosing one to make sure that it’s right for the job at hand.</p>&#13;
<p class="indent">Pulling out the common parts of your app into a framework helps you focus your development efforts on the unique aspects of an application. Frameworks also provide a lot of bootstrapping code, for doing things like running in development mode and writing a test suite, that helps you bring an application to a useful state more quickly. They also encourage consistency in the implementation of the application, which means you end up with code that is easier to understand and more reusable.</p>&#13;
<p class="indent">There are some potential pitfalls too, though. The decision to use a particular framework usually implies something about the design of the application itself. Selecting the wrong framework can make an application harder to implement if those design constraints do not align naturally with the application’s requirements. You may end up fighting with the framework if you try to use patterns or idioms that differ from what it recommends.</p>&#13;
</body></html>