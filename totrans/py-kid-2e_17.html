<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch14"><span epub:type="pagebreak" id="page_213"/><span class="big">14</span><br/>Developing the Mr. Stick Man Game</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="600" height="230"/></div>&#13;
<p class="indent">Now that we’ve created the images for <em>Mr. Stick Man Races for the Exit</em>, we can begin developing the code. The description of the game in the previous chapter gives us an idea what we’ll need: a stick figure that can run and jump and platforms he must jump to. We’ll write code to display the stick figure and move it across the screen, as well as to display the platforms. But before we write this code, we need to create the canvas to display our background image.</p>&#13;
<h3 class="h3" id="ch14lev1sec1"><span epub:type="pagebreak" id="page_214"/>Creating the Game Class</h3>&#13;
<p class="noindent">First, we’ll create a class called <span class="literal">Game</span> that will be our program’s main controller. The <span class="literal">Game</span> class will have an <span class="literal">__init__</span> function for initializing the game and a <span class="literal">mainloop</span> function for doing the animation.</p>&#13;
<h3 class="h3" id="ch14lev1sec2">Setting the Window Title and Creating the Canvas</h3>&#13;
<p class="noindent">In the first part of the <span class="literal">__init__</span> function, we’ll set the window title and create the canvas. As you’ll see, this part of the code is similar to the code we wrote for <em>Bounce!</em> in <a href="ch11.xhtml#ch11">Chapter 11</a>. Open a new file in IDLE and enter the following code, and then save your file as <em>stickmangame.py</em>. Make sure you save it in the <em>stickman</em> folder we created in <a href="ch13.xhtml#ch13">Chapter 13</a>:</p>&#13;
<pre class="pre1"><span class="orange">from</span> tkinter <span class="orange">import</span> *&#13;
<span class="orange">import</span> random&#13;
<span class="orange">import</span> time  &#13;
&#13;
<span class="orange">class</span> Game:&#13;
    <span class="orange">def</span> __init__(self):&#13;
        self.tk = Tk()&#13;
        self.tk.title(<span class="green">'Mr. Stick Man Races for the Exit'</span>)&#13;
        self.tk.resizable(0, 0)&#13;
        self.tk.wm_attributes(<span class="green">'-topmost'</span>, 1)&#13;
        self.canvas = Canvas(self.tk, width=500, height=500,&#13;
                             highlightthickness=0)&#13;
        self.canvas.pack()&#13;
        self.tk.update()&#13;
        self.canvas_height = self.canvas.winfo_height()&#13;
        self.canvas_width = self.canvas.winfo_width()&#13;
</pre>&#13;
<p class="indent">In the first half of this program (the lines from <span class="literal">tkinter import *</span> to <span class="literal">self.tk.wm_attributes</span>), we create the <span class="literal">tk</span> object and then set the window title with <span class="literal">self.tk.title</span> to (“Mr. Stick Man Races for the Exit”). We make the window <em>fixed</em> (so it can’t be resized) by calling the <span class="literal">resizable</span> function, and then we move the window in front of all other windows with the <span class="literal">wm_attributes</span> function.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_215"/>Next, we create the canvas with the <span class="literal">self.canvas = Canvas</span> line, and call the <span class="literal">pack</span> and <span class="literal">update</span> functions of the <span class="literal">tk</span> object. Finally, we create two variables for our <span class="literal">Game</span> class, <span class="literal">height</span> and <span class="literal">width</span>, to store the height and width (we use the <span class="literal">winfo_height</span> and <span class="literal">winfo_width</span> functions to get the size of the canvas).</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="notes">Note</span></p>&#13;
<p class="notep"><em>The backslash (\) in the line <span class="literal">self.canvas = Canvas</span> is used only to separate a long line of code. It’s not required in this case, but I’ve included it here for readability as the entire line won’t fit on the page.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch14lev1sec3">Finishing the __init__ Function</h3>&#13;
<p class="noindent">Now enter the rest of the <span class="literal">__init__</span> function into the <em>stickman game.py</em> file you just created. This code will load the background image and then display it on the canvas:</p>&#13;
<pre class="pre1">        <span class="gray">self.tk.update()&#13;
        self.canvas_height = self.canvas.winfo_height()&#13;
        self.canvas_width = self.canvas.winfo_width()</span>&#13;
        self.bg = PhotoImage(<span class="orange">file</span>=<span class="green">'background.gif'</span>)&#13;
        w = self.bg.width()&#13;
        h = self.bg.height()&#13;
     <span class="ent">➊</span> <span class="orange">for</span> x <span class="orange">in</span> <span class="violet">range</span>(0, 5):&#13;
         <span class="ent">➋</span> <span class="orange">for</span> y <span class="orange">in</span> <span class="violet">range</span>(0, 5):&#13;
                self.canvas.create_image(x * w, y * h, &#13;
                        image=self.bg, anchor=<span class="green">'nw'</span>)&#13;
        self.sprites = []&#13;
        self.running = <span class="violet">True</span>&#13;
</pre>&#13;
<p class="indent">At the line beginning <span class="literal">self.bg</span>, we create the variable <span class="literal">bg</span>, which contains a <span class="literal">PhotoImage</span> object—the background image file called <em>background.gif</em> that we created in <a href="ch13.xhtml#ch13">Chapter 13</a> on <a href="ch13.xhtml#ch13lev1sec8">page 210</a>. Next, we store the width and height of the image in the <span class="literal">w</span> and <span class="literal">h</span> variables. The <span class="literal">PhotoImage</span> class functions <span class="literal">width</span> and <span class="literal">height</span> return the size of the image once it’s been loaded.</p>&#13;
<p class="indent">Next come two loops inside this function. To understand what they do, imagine you have a small square rubber stamp, an ink pad, and a large piece of paper. How can you use the stamp to fill the paper with colored squares? Well, you could just randomly cover the page with stamps until it’s filled. The result would be a mess, and it would take a while to complete, <span epub:type="pagebreak" id="page_216"/>but it would fill the page. Or you could start stamping down in a column and then move back to the top and start stamping down the page in the next column, as shown in <a href="ch14.xhtml#ch14fig01">Figure 14-1</a>.</p>&#13;
<div class="image"><img id="ch14fig01" src="Images/14fig01.jpg" alt="Image" width="226" height="296"/></div>&#13;
<p class="figcap"><em>Figure 14-1: Stamping down the page</em></p>&#13;
&#13;
<p class="indent">The background image we created in the previous chapter is our stamp. We know that the canvas is 500 pixels across and 500 pixels down, and that we created a background image of 100 pixels square. This tells us that we need five columns across and five rows down to fill the screen with images. We use a <span class="literal">for</span> loop <span class="ent">➊</span> to calculate the columns across, and another <span class="literal">for</span> loop <span class="ent">➋</span> to calculate rows going down.</p>&#13;
<p class="indent">After this, we multiply the first loop variable <span class="literal">x</span> by the width of the image (<span class="literal">x *</span> <span class="literal">w</span>) to determine how far across we’re drawing, and then multiply the second loop variable <span class="literal">y</span> by the height of the image (<span class="literal">y * h</span>) to calculate how far down to draw. We use the <span class="literal">create_image</span> function of the canvas object (<span class="literal">self.canvas.create</span> <span class="literal">_image</span>) to draw the image on the screen using those coordinates.</p>&#13;
<p class="indent">Finally, we create the variables <span class="literal">sprites</span>, which holds an empty list, and <span class="literal">running</span>, which contains the <span class="literal">True</span> Boolean value. We’ll use these variables later in our game code.</p>&#13;
<h3 class="h3" id="ch14lev1sec4">Creating the mainloop Function</h3>&#13;
<p class="noindent">We’ll use the <span class="literal">mainloop</span> function in the <span class="literal">Game</span> class to animate our game. This function looks a lot like the main loop (or animation loop) we created for the <em>Bounce!</em> game in <a href="ch11.xhtml#ch11">Chapter 11</a>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_217"/>Our function is as follows:</p>&#13;
<pre class="pre1">        <span class="gray">for x in range(0, 5):&#13;
            for y in range(0, 5):&#13;
                self.canvas.create_image(x * w, y * h, &#13;
                        image=self.bg, anchor='nw')&#13;
        self.sprites = []&#13;
        self.running = True</span>&#13;
        &#13;
    <span class="orange">def</span> mainloop(self):&#13;
        <span class="orange">while</span> <span class="violet">True</span>:&#13;
           <span class="orange">if</span> self.running == <span class="violet">True</span>:&#13;
               <span class="orange">for</span> sprite <span class="orange">in</span> self.sprites:&#13;
                   sprite.move()&#13;
            self.tk.update_idletasks()&#13;
            self.tk.update()&#13;
            time.sleep(0.01)&#13;
</pre>&#13;
<p class="indent">We create a <span class="literal">while</span> loop that will run until the game window is closed (<span class="literal">while True</span> is an infinite loop, which we first saw back on <a href="ch11.xhtml#para95">page 175</a>). Next, we check to see if the <span class="literal">running</span> variable is equal to <span class="literal">True</span>. If it is, we loop through any sprites in the list of sprites (<span class="literal">self.sprites</span>), calling the <span class="literal">move</span> function for each one. (We have yet to create any sprites, so this code won’t do anything if we run the program now, but it will be useful later.)</p>&#13;
<p class="indent">The last three lines of the function force the <span class="literal">tk</span> object to redraw the screen and sleep for a fraction of a second, as we did with the <em>Bounce!</em> game.</p>&#13;
<p class="indent">So you can run this code, add the following two lines (note that there’s no indentation) and save the file:</p>&#13;
<div class="image1"><img src="Images/f0217-01.jpg" alt="Image" width="189" height="195"/></div>&#13;
<pre>g = Game()&#13;
g.mainloop()</pre>&#13;
<div class="note">&#13;
<p class="notet"><span class="notes">Note</span></p>&#13;
<p class="notep"><em>Be sure to add this code to the bottom of your game file. Also, make sure that your images and Python file are all in the</em> stickman <em>folder you created in <a href="ch13.xhtml#ch13">Chapter 13</a>.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_218"/>This code creates an object of the <span class="literal">Game</span> class and saves it as the <span class="literal">g</span> variable. We then call the <span class="literal">mainloop</span> function on the new object to draw the screen.</p>&#13;
<p class="indent">Once you’ve saved the program, run it in IDLE with <strong>Run</strong> ▸ <strong>Run Module</strong>. A window should appear with the background image filling the canvas, as in <a href="ch14.xhtml#ch14fig02">Figure 14-2</a>.</p>&#13;
<div class="image"><img id="ch14fig02" src="Images/14fig02.jpg" alt="Image" width="602" height="636"/></div>&#13;
<p class="figcap"><em>Figure 14-2: Game background</em></p>&#13;
&#13;
<p class="indent">With this, we’ve added a nice background for our game and created an animation loop that will draw sprites for us (once we’ve created them).</p>&#13;
<h3 class="h3" id="ch14lev1sec5">Creating the Coords Class</h3>&#13;
<p class="noindent">Now we’ll create the class that we’ll use to specify the position of sprites on our game screen. This class will store the top-left (<em>x1</em> and <em>y1</em>) and bottom-right (<em>x2</em> and <em>y2</em>) coordinates of any component of our game.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_219"/><a href="ch14.xhtml#ch14fig03">Figure 14-3</a> shows how you might record the position of the stick figure image using these coordinates.</p>&#13;
<div class="image"><img id="ch14fig03" src="Images/14fig03.jpg" alt="Image" width="224" height="241"/></div>&#13;
<p class="figcap"><em>Figure 14-3: Where the x and y coordinates can be found on the stick figure</em></p>&#13;
<p class="indent">Our new class, <span class="literal">Coords</span>, will contain only an <span class="literal">__init__</span> function, to which we pass the four parameters (<span class="literal">x1</span>, <span class="literal">y1</span>, <span class="literal">x2</span>, and <span class="literal">y2</span>). Put this code at the beginning of the <em>stickmangame.py</em> file:</p>&#13;
<pre class="pre1"><span class="orange">class</span> Coords:&#13;
    <span class="orange">def</span> __init__(self, x1=0, y1=0, x2=0, y2=0):&#13;
        self.x1 = x1&#13;
        self.y1 = y1&#13;
        self.x2 = x2&#13;
        self.y2 = y2&#13;
</pre>&#13;
&#13;
<p class="indent">Notice that each parameter is saved as an object variable of the same name (<span class="literal">x1</span>, <span class="literal">y1</span>, <span class="literal">x2</span>, and <span class="literal">y2</span>). We’ll be using objects of this class shortly.</p>&#13;
<h3 class="h3" id="ch14lev1sec6">Checking for Collisions</h3>&#13;
&#13;
<p class="noindent">Once we know how to store the position of our game sprites, we need a way to tell if one sprite has collided with another, like when Mr. Stick Man jumps around the screen and runs into one of the platforms. To make this problem easier to solve, we can break it into two smaller problems: checking if sprites are colliding vertically, and checking if sprites are colliding horizontally. We can then combine our solutions to see if two sprites are colliding in any direction!</p>&#13;
<h3 class="h3" id="ch14lev1sec7"><span epub:type="pagebreak" id="page_220"/>Sprites Colliding Horizontally</h3>&#13;
<p class="noindent">First, we’ll create the <span class="literal">within_x</span> function to determine if one set of <em>x</em> coordinates (<em>x1</em> and <em>x2</em>) has crossed over another set of <em>x</em> coordinates (again, <em>x1</em> and <em>x2</em>). Add the following directly below the <span class="literal">Coords</span> class:</p>&#13;
<pre class="pre1"><span class="gray">class Coords:&#13;
    def __init__(self, x1=0, y1=0, x2=0, y2=0):&#13;
        self.x1 = x1&#13;
        self.y1 = y1&#13;
        self.x2 = x2&#13;
        self.y2 = y2</span>&#13;
&#13;
<span class="orange">def</span> within_x(co1, co2):&#13;
 <span class="ent">➊</span> <span class="orange">if</span> co1.x1 &gt; co2.x1 <span class="orange">and</span> co1.x1 &lt; co2.x2:&#13;
        <span class="orange">return</span> <span class="violet">True</span>&#13;
 <span class="ent">➋</span> <span class="orange">elif</span> co1.x2 &gt; co2.x1 <span class="orange">and</span> co1.x2 &lt; co2.x2:&#13;
        <span class="orange">return</span> <span class="violet">True</span>&#13;
    <span class="orange">elif</span> co2.x1 &gt; co1.x1 <span class="orange">and</span> co2.x1 &lt; co1.x2:&#13;
        <span class="orange">return</span> <span class="violet">True</span>&#13;
    <span class="orange">elif</span> co2.x2 &gt; co1.x1 <span class="orange">and</span> co2.x2 &lt; co1.x2:&#13;
        <span class="orange">return</span> <span class="violet">True</span>&#13;
    <span class="orange">else</span>:&#13;
        <span class="orange">return</span> <span class="violet">False</span>&#13;
</pre>&#13;
<p class="indent">The <span class="literal">within_x</span> function takes the parameters <span class="literal">co1</span> and <span class="literal">co2</span>, both <span class="literal">Coords</span> objects. We first check to see if the leftmost position of the first coordinate object (<span class="literal">co1.x1</span>) is between the leftmost position (<span class="literal">co2.x1</span>) and the rightmost position (<span class="literal">co2.x2</span>) of the second coordinate object <span class="ent">➊</span>. We return <span class="literal">True</span> if it is.</p>&#13;
<div class="image1"><img src="Images/f0220-01.jpg" alt="Image" width="376" height="93"/></div>&#13;
<p class="indent">Let’s take a look at two lines with overlapping <em>x</em> coordinates to understand how this works. Each line in <a href="ch14.xhtml#ch14fig04">Figure 14-4</a> starts at <span class="literal">x1</span> and finishes at <span class="literal">x2</span>.</p>&#13;
<div class="image"><img id="ch14fig04" src="Images/14fig04.jpg" alt="Image" width="374" height="140"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_221"/><em>Figure 14-4: Overlapping horizontal (x) coordinates</em></p>&#13;
&#13;
<p class="indent">The first line in this diagram (<span class="literal">co1</span>) starts at pixel position 50 (<span class="literal">x1</span>) and finishes at 100 (<span class="literal">x2</span>). The second line (<span class="literal">co2</span>) starts at position 40 and finishes at 150. In this case, because the <span class="literal">x1</span> position of the first line is between the <span class="literal">x1</span> and <span class="literal">x2</span> positions of the second line, the <span class="literal">if</span> statement in the function would be true for these two sets of coordinates.</p>&#13;
<p class="indent">With the first <span class="literal">elif</span> statement <span class="ent">➋</span>, we see whether the rightmost position of the first line (<span class="literal">co1.x2</span>) is between the leftmost position (<span class="literal">co2.x1</span>) and rightmost position (<span class="literal">co2.x2</span>) of the second. If it is, we return <span class="literal">True</span>. The next two <span class="literal">elif</span> statements do almost the same thing: they check the leftmost and rightmost positions of the second line (<span class="literal">co2</span>) against the first (<span class="literal">co1</span>).</p>&#13;
<p class="indent">If none of the <span class="literal">if</span> statements match, we reach <span class="literal">else</span> and return <span class="literal">False</span>. This is effectively saying, “No, the two coordinate objects do not cross over each other horizontally.”</p>&#13;
<p class="indent">To see an example of the function working, look back at <a href="ch14.xhtml#ch14fig04">Figure 14-4</a>. The <span class="literal">x1</span> and <span class="literal">x2</span> positions of the first coordinate object are 50 and 100, and the <span class="literal">x1</span> and <span class="literal">x2</span> positions of the second coordinate object are 40 and 150. Here’s what happens when we call the <span class="literal">within_x</span> function we’ve created:</p>&#13;
<pre class="pre1"><span class="brown">&gt;&gt;&gt;</span> c1 = Coords(50, 50, 100, 100)&#13;
<span class="brown">&gt;&gt;&gt;</span> c2 = Coords(40, 40, 150, 150)&#13;
<span class="brown">&gt;&gt;&gt;</span> <span class="violet">print</span>(within_x(c1, c2))&#13;
<span class="blue">True</span>&#13;
</pre>&#13;
<p class="indent">The function returns <span class="literal">True</span>. This is the first step in determining whether one sprite has bumped into another. For example, when we create a class for Mr. Stick Man and for the platforms, we’ll be able to tell if their <em>x</em> coordinates have crossed one another.</p>&#13;
<p class="indent">It’s not best practice to have lots of <span class="literal">if</span> or <span class="literal">elif</span> statements that return the same value. To solve this problem, we can shorten the <span class="literal">within_x</span> function by surrounding each of its conditions with parentheses, separated by the <span class="literal">or</span> keyword. For a slightly neater function with fewer lines of code, you can change the <span epub:type="pagebreak" id="page_222"/>function so it looks like this:</p>&#13;
<pre class="pre1"><span class="orange">def</span> within_x(co1, co2):&#13;
    <span class="orange">if</span> (co1.x1 &gt; co2.x1 <span class="orange">and</span> co1.x1 &lt; co2.x2) \&#13;
            <span class="orange">or</span> (co1.x2 &gt; co2.x1 <span class="orange">and</span> co1.x2 &lt; co2.x2) \&#13;
            <span class="orange">or</span> (co2.x1 &gt; co1.x1 <span class="orange">and</span> co2.x1 &lt; co1.x2) \&#13;
            <span class="orange">or</span> (co2.x2 &gt; co1.x1 <span class="orange">and</span> co2.x2 &lt; co1.x2):&#13;
        <span class="orange">return</span> <span class="violet">True</span>&#13;
    <span class="orange">else</span>:&#13;
        <span class="orange">return</span> <span class="violet">False</span>&#13;
</pre>&#13;
<p class="indent">To extend the <span class="literal">if</span> statement across multiple lines so that we don’t end up with one really long line containing all the conditions, we use a backslash (\), as shown above.</p>&#13;
<h3 class="h3" id="ch14lev1sec8">Sprites Colliding Vertically</h3>&#13;
<p class="indent">We also need to know if sprites collide vertically. The <span class="literal">within_y</span> function is very similar to the <span class="literal">within_x</span> function. To create it, we check whether the <em>y1</em> position of the first coordinate has crossed over the <em>y1</em> and <em>y2</em> positions of the second, and then vice versa.</p>&#13;
<p class="indent">Add the following function below the <span class="literal">within_x</span> function. This time, we’ll use the shorter version of the code (rather than lots of <span class="literal">if</span> statements):</p>&#13;
<div class="image1"><img src="Images/f0222-01.jpg" alt="Image" width="241" height="290"/></div>&#13;
<pre class="pre1"><span class="orange">def</span> within_y(co1, co2):&#13;
    <span class="orange">if</span> (co1.y1 &gt; co2.y1 <span class="orange">and</span> co1.y1 &lt; co2.y2) \&#13;
            <span class="orange">or</span> (co1.y2 &gt; co2.y1 <span class="orange">and</span> co1.y2 &lt; co2.y2) \&#13;
            <span class="orange">or</span> (co2.y1 &gt; co1.y1 <span class="orange">and</span> co2.y1 &lt; co1.y2) \&#13;
            <span class="orange">or</span> (co2.y2 &gt; co1.y1 <span class="orange">and</span> co2.y2 &lt; co1.y2):&#13;
        <span class="orange">return</span> <span class="violet">True</span>&#13;
    <span class="orange">else</span>:&#13;
        <span class="orange">return</span> <span class="violet">False</span>&#13;
</pre>&#13;
<p class="indent">Our <span class="literal">within_x</span> and <span class="literal">within_y</span> functions look quite similar because, in the end, they are doing similar things.</p>&#13;
<h3 class="h3" id="ch14lev1sec9"><span epub:type="pagebreak" id="page_223"/>Putting It All Together: Our Final Collision-Detection Code</h3>&#13;
<p class="noindent">Once we’ve determined whether one set of <em>x</em> coordinates has crossed over another, and done the same for <em>y</em> coordinates, we can write functions to see whether a sprite has hit another sprite and on which side. We’ll do this with the <span class="literal">collided_left</span>, <span class="literal">collided_right</span>, <span class="literal">collided_top</span>, and <span class="literal">collided_bottom</span> functions.</p>&#13;
<h4 class="h4" id="ch14lev2sec1">The collided_left Function</h4>&#13;
<p class="noindent">Add the following code for the <span class="literal">collided_left</span> function below the two <span class="literal">within</span> functions we just created:</p>&#13;
<pre class="pre1"><span class="orange">def</span> collided_left(co1, co2):&#13;
    <span class="orange">if</span> within_y(co1, co2):&#13;
        <span class="orange">if</span> co1.x1 &gt;= co2.x1 <span class="orange">and</span> co1.x1 &lt;= co2.x2:&#13;
            <span class="orange">return</span> <span class="violet">True</span>&#13;
    <span class="orange">return</span> <span class="violet">False</span>&#13;
</pre>&#13;
<p class="indent">This function tells us whether the left-hand side (the <span class="literal">x1</span> value) of a first coordinate object has hit another coordinate object.</p>&#13;
<p class="indent">The function takes two parameters: <span class="literal">co1</span> (the first coordinate object) and <span class="literal">co2</span> (the second coordinate object). We check whether the two coordinate objects have crossed over vertically, using the <span class="literal">within_y</span> function. After all, there’s no point in checking whether Mr. Stick Man has hit a platform if he is floating way above it (like <a href="ch14.xhtml#ch14fig05">Figure 14-5</a>).</p>&#13;
<div class="image"><img id="ch14fig05" src="Images/14fig05.jpg" alt="Image" width="300" height="256"/></div>&#13;
<p class="figcap"><em>Figure 14-5: Mr. Stick Man above the platform</em></p>&#13;
&#13;
<p class="indent"><span epub:type="pagebreak" id="page_224"/>Then, we see if the value of the leftmost position of the first coordinate object (<span class="literal">co1.x1</span>) has hit the <span class="literal">x2</span> position of the second coordinate object (<span class="literal">co2.x2</span>). If so, it should be less than or equal to the <span class="literal">x2</span> position. We also check to make sure that it hasn’t gone past the <span class="literal">x1</span> position. If it has hit the side, we return <span class="literal">True</span>. If none of the <span class="literal">if</span> statements are true, we return <span class="literal">False</span>.</p>&#13;
<div class="image1"><img src="Images/f0224-01.jpg" alt="Image" width="237" height="222"/></div>&#13;
<h4 class="h4" id="ch14lev2sec2">The collided_right Function</h4>&#13;
<p class="noindent">The <span class="literal">collided_right</span> function looks a lot like <span class="literal">collided_left</span>:</p>&#13;
<pre class="pre1"><span class="orange">def</span> collided_right(co1, co2):&#13;
    <span class="orange">if</span> within_y(co1, co2):&#13;
        <span class="orange">if</span> co1.x2 &gt;= co2.x1 <span class="orange">and</span> co1.x2 &lt;= co2.x2:&#13;
            <span class="orange">return</span> <span class="violet">True</span>&#13;
    <span class="orange">return</span> <span class="violet">False</span>&#13;
</pre>&#13;
<p class="indent">As with <span class="literal">collided_left</span>, we check to see if the <em>y</em> coordinates have crossed over each other, using the <span class="literal">within_y</span> function. We then check to see if the <span class="literal">x2</span> value of the first coordinate object is between the <span class="literal">x1</span> and <span class="literal">x2</span> positions of the second coordinate object, and return <span class="literal">True</span> if it is. Otherwise, we return <span class="literal">False</span>.</p>&#13;
<h4 class="h4" id="ch14lev2sec3">The collided_top Function</h4>&#13;
<p class="noindent">The <span class="literal">collided_top</span> function is very similar to the two functions we just added:</p>&#13;
<pre class="pre1"><span class="orange">def</span> collided_top(co1, co2):&#13;
    <span class="orange">if</span> within_x(co1, co2):&#13;
        <span class="orange">if</span> co1.y1 &gt;= co2.y1 <span class="orange">and</span> co1.y1 &lt;= co2.y2:&#13;
            <span class="orange">return</span> <span class="violet">True</span>&#13;
    <span class="orange">return</span> <span class="violet">False</span>&#13;
</pre>&#13;
<p class="indent">This time, we check to see if the coordinates have crossed over horizontally, using the <span class="literal">within_x</span> function. Next, we see if the topmost position of the first coordinate (<span class="literal">co1.y1</span>) has crossed over the <span class="literal">y2</span> position of the second coordinate, but not its <span class="literal">y1</span> <span epub:type="pagebreak" id="page_225"/>position. If so, we return <span class="literal">True</span> (the top of the first coordinate has hit the second coordinate).</p>&#13;
<h4 class="h4" id="ch14lev2sec4">The collided_bottom Function</h4>&#13;
<p class="noindent">Our last function, <span class="literal">collided_bottom</span>, is just a bit different:</p>&#13;
<pre class="pre1"><span class="orange">def</span> collided_bottom(y, co1, co2):&#13;
    <span class="orange">if</span> within_x(co1, co2):&#13;
        y_calc = co1.y2 + y&#13;
     <span class="ent">➊</span> <span class="orange">if</span> y_calc &gt;= co2.y1 <span class="orange">and</span> y_calc &lt;= co2.y2:&#13;
            <span class="orange">return</span> <span class="violet">True</span>&#13;
     <span class="orange">return</span> <span class="violet">False</span>&#13;
</pre>&#13;
<p class="indent">This function takes an additional parameter, <span class="literal">y</span>, a value that we add to the <span class="literal">y</span> position of the first coordinate. Our <span class="literal">if</span> statement checks if the coordinates have crossed over horizontally (as we did with <span class="literal">collided_top</span>). Next, we add the value of the <span class="literal">y</span> parameter to the first coordinate’s <span class="literal">y2</span> position, and store the result in the <span class="literal">y_calc</span> variable. If the newly calculated value is between the <span class="literal">y1</span> and <span class="literal">y2</span> values of the second coordinate <span class="ent">➊</span>, we return <span class="literal">True</span> because the bottom of coordinate <span class="literal">co1</span> has hit the top of coordinate <span class="literal">co2</span>. However, if none of the <span class="literal">if</span> statements are true, we return <span class="literal">False</span>.</p>&#13;
<p class="indent">We need the additional <span class="literal">y</span> parameter because Mr. Stick Man could fall off a platform. Unlike the other <span class="literal">collided</span> functions, we need to be able to test if he <em>would</em> collide at the bottom, rather than whether he already has. If he walks off a platform and keeps floating in midair, our game won’t be very realistic; so as he walks, we check to see if he has collided with something on the left or right. When we check below him, we see if he would collide with the platform; if not, he needs to go crashing down!</p>&#13;
<h3 class="h3" id="ch14lev1sec10">Creating the Sprite Class</h3>&#13;
<p class="noindent">The parent class for our game items, <span class="literal">Sprite</span>, will provide two functions: <span class="literal">move</span> to move the sprite, and <span class="literal">coords</span> to return the sprite’s current position on the screen. We add the code for the <span class="literal">Sprite</span> class below the <span class="literal">collided_bottom</span> function, as follows:</p>&#13;
<pre class="pre1"><span class="orange">class</span> Sprite:&#13;
    <span class="orange">def</span> __init__(self, game):&#13;
<span epub:type="pagebreak" id="page_226"/>        self.game = game&#13;
        self.endgame = <span class="violet">False</span>&#13;
        self.coordinates = <span class="violet">None</span>&#13;
&#13;
    <span class="orange">def</span> move(self):&#13;
        <span class="orange">pass</span>&#13;
&#13;
    <span class="orange">def</span> coords(self):&#13;
        <span class="orange">return</span> self.coordinates&#13;
</pre>&#13;
<p class="indent">The Sprite class’s <span class="literal">__init__</span> function takes a single parameter, <span class="literal">game</span>, which will be the game object. We need it so that any sprite we create will be able to access the list of other sprites in the game. We store the game parameter as an object variable.</p>&#13;
<p class="indent">Then, we store the object variable <span class="literal">endgame</span>, which we’ll use to indicate the end of the game. (At the moment, it’s set to <span class="literal">False</span>.) The final object variable, <span class="literal">coordinates</span>, is set to nothing (<span class="literal">None</span>).</p>&#13;
<p class="indent">The <span class="literal">move</span> function does nothing in this parent class, so we use the <span class="literal">pass</span> keyword in the body of this function. The <span class="literal">coords</span> function simply returns the object variable <span class="literal">coordinates</span>.</p>&#13;
<p class="indent">So our <span class="literal">Sprite</span> class has a <span class="literal">move</span> function that does nothing and a <span class="literal">coords</span> function that returns no coordinates. That doesn’t sound very useful, does it? However, any classes that have <span class="literal">Sprite</span> as their parent will always have the <span class="literal">move</span> and <span class="literal">coords</span> functions. So, in the main loop of the game, when we loop through a list of sprites, calling the <span class="literal">move</span> function won’t cause any errors because each sprite has that function.</p>&#13;
<div class="image1"><img src="Images/f0226-01.jpg" alt="Image" width="241" height="277"/></div>&#13;
<div class="note">&#13;
<p class="notet"><span class="notes">Note</span></p>&#13;
<p class="notep"><em>Classes with functions that don’t do very much are quite common in programming. In a way, they’re an agreement that ensures all the children of a class provide the same sort of functionality, even if in some cases the functions in the child classes do nothing.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="ch14lev1sec11"><span epub:type="pagebreak" id="page_227"/>Adding the Platforms</h3>&#13;
<p class="noindent">Now we’ll add the platforms. Our class for platform objects, <span class="literal">PlatformSprite</span>, will be a child class of <span class="literal">Sprite</span>. The <span class="literal">__init__</span> function for this class will take a <span class="literal">game</span> parameter (as the <span class="literal">Sprite</span> parent class does), as well as an image, <span class="literal">x</span> and <span class="literal">y</span> positions, and the image <span class="literal">width</span> and <span class="literal">height</span>. Here’s the code for the <span class="literal">PlatformSprite</span> class, which goes directly below the <span class="literal">Sprite</span> class:</p>&#13;
<pre class="pre1"><span class="orange">class</span> PlatformSprite(Sprite):&#13;
    <span class="orange">def</span> __init__(self, game, photo_image, x, y, width, height):&#13;
        Sprite.__init__(self, game)&#13;
        self.photo_image = photo_image&#13;
        self.image = game.canvas.create_image(x, y, &#13;
                image=self.photo_image, anchor=<span class="green">'nw'</span>)&#13;
        self.coordinates = Coords(x, y, x + width, y + height)&#13;
</pre>&#13;
<p class="indent">When we define the <span class="literal">PlatformSprite</span> class, we give it a single parameter: the name of the parent class (<span class="literal">Sprite</span>). The <span class="literal">__init__</span> function has seven parameters: <span class="literal">self</span>, <span class="literal">game</span>, <span class="literal">photo_image</span>, <span class="literal">x</span>, <span class="literal">y</span>, <span class="literal">width</span>, and <span class="literal">height</span>.</p>&#13;
<p class="indent">We call the <span class="literal">__init__</span> function of the parent class, <span class="literal">Sprite</span>, using <span class="literal">self</span> and <span class="literal">game</span> as the parameter values, because other than the <span class="literal">self</span> parameter, the Sprite class’s <span class="literal">__init__</span> function takes only one parameter: <span class="literal">game</span>.</p>&#13;
<p class="indent">At this point, if we were to create a <span class="literal">PlatformSprite</span> object, it would have all the object variables from its parent class (<span class="literal">game</span>, <span class="literal">endgame</span>, and <span class="literal">coordinates</span>), simply because we’ve called the <span class="literal">__init__</span> function in <span class="literal">Sprite</span>.</p>&#13;
<div class="image1"><img src="Images/f0227-01.jpg" alt="Image" width="114" height="220"/></div>&#13;
<p class="indent">Next, we save the <span class="literal">photo_image</span> parameter as an object variable, and we use the <span class="literal">canvas</span> variable of the game object to draw the image onscreen with <span class="literal">create_image</span>.</p>&#13;
<p class="indent">Finally, we create a <span class="literal">Coords</span> object with the <span class="literal">x</span> and <span class="literal">y</span> parameters as the first two arguments. We then add the <span class="literal">width</span> and <span class="literal">height</span> parameters to these parameters for the second two arguments.</p>&#13;
<p class="indent">Even though the <span class="literal">coordinates</span> variable is set to <span class="literal">None</span> in the <span class="literal">Sprite</span> parent class, we’ve changed it in our <span class="literal">PlatformSprite</span> child class to an actual <span class="literal">Coords</span> object, containing the live location of the platform image on the screen.</p>&#13;
<h3 class="h3" id="ch14lev1sec12"><span epub:type="pagebreak" id="page_228"/>Adding a Platform Object</h3>&#13;
<p class="noindent">Let’s add a platform to the game to see how it looks. Change the last two lines of the game file (<em>stickmangame.py</em>):</p>&#13;
&#13;
<pre class="pre1">   g = Game()&#13;
<span class="ent">➊</span> platform1 = PlatformSprite(g, PhotoImage(<span class="orange">file</span>=<span class="green">'platform1.gif'</span>), &#13;
                              0, 480, 100, 10)&#13;
<span class="ent">➋</span> g.sprites.append(platform1)&#13;
   g.mainloop()&#13;
</pre>&#13;
<p class="indent">We create an object of the <span class="literal">PlatformSprite</span> class, passing it the variable for our game (<span class="literal">g</span>), along with a <span class="literal">PhotoImage</span> object (which uses the first of our platform images, <em>platform1.gif</em>) <span class="ent">➊</span>. We also pass it the position where we want to draw the platform (0 pixels across and 480 pixels down, near the bottom of the canvas), along with the height and width of our image (100 pixels across and 10 pixels high). We add this sprite to the list of sprites in our game object <span class="ent">➋</span>.</p>&#13;
<p class="indent">If you run the game now, you should see a platform at the bottom-left side of the screen, like <a href="ch14.xhtml#ch14fig06">Figure 14-6</a>.</p>&#13;
<div class="image"><img id="ch14fig06" src="Images/14fig06.jpg" alt="Image" width="377" height="399"/></div>&#13;
<p class="figcap"><em>Figure 14-6: Displaying a platform</em></p>&#13;
&#13;
<h3 class="h3" id="ch14lev1sec13"><span epub:type="pagebreak" id="page_229"/>Adding a Bunch of Platforms</h3>&#13;
<p class="noindent">Let’s add a whole bunch of platforms. Each platform will have different <em>x</em> and <em>y</em> positions, so they’ll be scattered around the screen. Use the following code:</p>&#13;
<pre class="pre1">g = Game()&#13;
platform1 = PlatformSprite(g, PhotoImage(<span class="orange">file</span>=<span class="green">'platform1.gif'</span>), &#13;
                           0, 480, 100, 10)&#13;
platform2 = PlatformSprite(g, PhotoImage(<span class="orange">file</span>=<span class="green">'platform1.gif'</span>), &#13;
                           150, 440, 100, 10)&#13;
platform3 = PlatformSprite(g, PhotoImage(<span class="orange">file</span>=<span class="green">'platform1.gif'</span>), &#13;
                           300, 400, 100, 10)&#13;
platform4 = PlatformSprite(g, PhotoImage(<span class="orange">file</span>=<span class="green">'platform1.gif'</span>), &#13;
                           300, 160, 100, 10)&#13;
platform5 = PlatformSprite(g, PhotoImage(<span class="orange">file</span>=<span class="green">'platform2.gif'</span>), &#13;
                           175, 350, 66, 10)&#13;
platform6 = PlatformSprite(g, PhotoImage(<span class="orange">file</span>=<span class="green">'platform2.gif'</span>), &#13;
                           50, 300, 66, 10)&#13;
platform7 = PlatformSprite(g, PhotoImage(<span class="orange">file</span>=<span class="green">'platform2.gif'</span>), &#13;
                           170, 120, 66, 10)&#13;
platform8 = PlatformSprite(g, PhotoImage(<span class="orange">file</span>=<span class="green">'platform2.gif'</span>), &#13;
                           45, 60, 66, 10)&#13;
platform9 = PlatformSprite(g, PhotoImage(<span class="orange">file</span>=<span class="green">'platform3.gif'</span>), &#13;
                           170, 250, 32, 10)&#13;
platform10 = PlatformSprite(g, PhotoImage(<span class="orange">file</span>=<span class="green">'platform3.gif'</span>), &#13;
                            230, 200, 32, 10)&#13;
g.sprites.append(platform1)&#13;
g.sprites.append(platform2)&#13;
g.sprites.append(platform3)&#13;
g.sprites.append(platform4)&#13;
g.sprites.append(platform5)&#13;
g.sprites.append(platform6)&#13;
g.sprites.append(platform7)&#13;
g.sprites.append(platform8)&#13;
g.sprites.append(platform9)&#13;
g.sprites.append(platform10)&#13;
g.mainloop()&#13;
</pre>&#13;
<p class="indent">We first create a ton of <span class="literal">PlatformSprite</span> objects, saving them as variables <span class="literal">platform1</span>, <span class="literal">platform2</span>, <span class="literal">platform3</span>, and so on, up to <span class="literal">platform10</span>. We then add each platform to the <span class="literal">sprites</span> variable, which we <span epub:type="pagebreak" id="page_230"/>created in our <span class="literal">Game</span> class. If you run the game now, it should look like <a href="ch14.xhtml#ch14fig07">Figure 14-7</a>.</p>&#13;
<div class="image"><img id="ch14fig07" src="Images/14fig07.jpg" alt="Image" width="376" height="399"/></div>&#13;
<p class="figcap"><em>Figure 14-7: Displaying all the platforms</em></p>&#13;
<p class="indent">We’ve created the basics of our game! Now we’re ready to add our main character, Mr. Stick Man.</p>&#13;
<h3 class="h3" id="ch14lev1sec14">What You Learned</h3>&#13;
<p class="noindent">In this chapter, you created the <span class="literal">Game</span> class and drew the background image onto the screen. You learned how to determine whether a horizontal or vertical position is within the bounds of two other horizontal or vertical positions by creating the <span class="literal">within_x</span> and <span class="literal">within_y</span> functions. You then used these functions to create new functions that determine whether one coordinate object had collided with another. We’ll use these functions in the next chapters when we animate Mr. Stick Man and need to detect whether he has collided with a platform as he moves around the canvas.</p>&#13;
<p class="indent">We also created a parent class <span class="literal">Sprite</span> and its first child class, <span class="literal">PlatformSprite</span>, which we used to draw the platforms onto the canvas.</p>&#13;
<h3 class="h3" id="ch14lev1sec15"><span epub:type="pagebreak" id="page_231"/>Programming Puzzles</h3>&#13;
<p class="noindent">The following coding puzzles are some ways to experiment with the game’s background image. Check your answers at <em><a href="http://python-for-kids.com">http://python-for-kids.com</a></em>.</p>&#13;
<h4 class="h4" id="ch14lev2sec5">#1: Checkerboard</h4>&#13;
<p class="noindent">Try changing the <span class="literal">Game</span> class so that the background image is drawn like a checkerboard, as in <a href="ch14.xhtml#ch14fig08">Figure 14-8</a>.</p>&#13;
<div class="image"><img id="ch14fig08" src="Images/14fig08.jpg" alt="Image" width="377" height="398"/></div>&#13;
<p class="figcap"><em>Figure 14-8: Background as a checkerboard</em></p>&#13;
<h4 class="h4" id="ch14lev2sec6">#2: Two-Image Checkerboard</h4>&#13;
<p class="noindent">Once you’ve figured out how to create a checkerboard effect, try using two alternating images. Come up with another wallpaper image (using your graphics program), and then change the <span class="literal">Game</span> class so it displays a checkerboard with two alternating images instead of one image and the blank background.</p>&#13;
<h4 class="h4" id="ch14lev2sec7">#3: Bookshelf and Lamp</h4>&#13;
<p class="noindent">You can create different wallpaper images to make the game’s background more interesting. Create a copy of the background image; then draw a simple bookshelf, a table with a lamp, or a window. Dot these images around the screen by changing the <span class="literal">Game</span> class so that it displays a few different wallpaper images.</p>&#13;
<h4 class="h4" id="ch14lev2sec8"><span epub:type="pagebreak" id="page_232"/>#4: Random Background</h4>&#13;
<p class="noindent">As an alternative to the two-image checkerboard, try creating five different background images. You can either draw them as a repeating pattern of background images (1, 2, 3, 4, 5, 1, 2, 3, 4, 5, and so on), or you can draw them randomly.</p>&#13;
<p class="indent">Hint: If you import the <span class="literal">random</span> module and put your images in a list, try using <span class="literal">random.choice()</span> to pick one randomly.</p>&#13;
</div></body></html>