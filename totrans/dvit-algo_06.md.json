["```py\npoint = [0.2,0.8]\n```", "```py\ntriangle = [[0.2,0.8],[0.5,0.2],[0.8,0.7]]\n```", "```py\ndef points_to_triangle(point1,point2,point3):\n    triangle = [list(point1),list(point2),list(point3)]\n    return(triangle)\n```", "```py\ndef genlines(listpoints,itinerary):\n    lines = []\n    for j in range(len(itinerary)-1):\n        lines.append([listpoints[itinerary[j]],listpoints[itinerary[j+1]]])\n    return(lines)\n```", "```py\nimport pylab as pl\nfrom matplotlib import collections as mc\ndef plot_triangle_simple(triangle,thename):\n    fig, ax = pl.subplots()\n\n    xs = [triangle[0][0],triangle[1][0],triangle[2][0]]\n    ys = [triangle[0][1],triangle[1][1],triangle[2][1]]\n\n    itin=[0,1,2,0]\n\n    thelines = genlines(triangle,itin)\n\n    lc = mc.LineCollection(genlines(triangle,itin), linewidths=2)\n\n    ax.add_collection(lc)\n\n    ax.margins(0.1)\n    pl.scatter(xs, ys)\n    pl.savefig(str(thename) + '.png')\n    pl.close()\n```", "```py\nplot_triangle_simple(points_to_triangle((0.2,0.8),(0.5,0.2),(0.8,0.7)),'tri')\n```", "```py\ndef get_distance(point1,point2):\n    distance = math.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)\n    return(distance)\n```", "```py\ndef triangle_to_circumcenter(triangle):\n    x,y,z = complex(triangle[0][0],triangle[0][1]), complex(triangle[1][0],triangle[1][1]), \\    complex(triangle[2][0],triangle[2][1])\n    w = z - x\n    w /= y - x\n    c = (x-y) * (w-abs(w)**2)/2j/w.imag - x\n    radius = abs(c + x)\n    return((0 - c.real,0 - c.imag),radius)\n```", "```py\ndef plot_triangle(triangles,centers,radii,thename):\n    fig, ax = pl.subplots()\n   ** ax.set_xlim([0,1])**\n **ax.set_ylim([0,1])**\n **for i in range(0,len(triangles)):**\n **triangle = triangles[i]**\n **center = centers[i]**\n **radius = radii[i]**\n        itin = [0,1,2,0]\n        thelines = genlines(triangle,itin)\n        xs = [triangle[0][0],triangle[1][0],triangle[2][0]]\n        ys = [triangle[0][1],triangle[1][1],triangle[2][1]]\n\n        lc = mc.LineCollection(genlines(triangle,itin), linewidths = 2)\n\n        ax.add_collection(lc)\n        ax.margins(0.1)\n        pl.scatter(xs, ys)\n        pl.scatter(center[0],center[1])\n\n       ** circle = pl.Circle(center, radius, color = 'b', fill = False)**\n\n **ax.add_artist(circle)**\n    pl.savefig(str(thename) + '.png')\n    pl.close()\n```", "```py\ntriangle1 = points_to_triangle((0.1,0.1),(0.3,0.6),(0.5,0.2))\ncenter1,radius1 = triangle_to_circumcenter(triangle1)\ntriangle2 = points_to_triangle((0.8,0.1),(0.7,0.5),(0.8,0.9))\ncenter2,radius2 = triangle_to_circumcenter(triangle2)\nplot_triangle([triangle1,triangle2],[center1,center2],[radius1,radius2],'two')\n```", "```py\ndelaunay = [points_to_triangle((0.2,0.8),(0.5,0.2),(0.8,0.7))]\n```", "```py\npoint_to_add = [0.5,0.5]\n```", "```py\nimport math\ninvalid_triangles = []\ndelaunay_index = 0\nwhile delaunay_index < len(delaunay):\n    circumcenter,radius = triangle_to_circumcenter(delaunay[delaunay_index])\n    new_distance = get_distance(circumcenter,point_to_add)\n    if(new_distance < radius):\n        invalid_triangles.append(delaunay[delaunay_index])\n    delaunay_index += 1\n```", "```py\npoints_in_invalid = []\n\nfor i in range(len(invalid_triangles)):\n    delaunay.remove(invalid_triangles[i])\n    for j in range(0,len(invalid_triangles[i])):\n        points_in_invalid.append(invalid_triangles[i][j])\n\n1 points_in_invalid = [list(x) for x in set(tuple(x) for x in points_in_invalid)]\n```", "```py\nfor i in range(len(points_in_invalid)):\n    for j in range(i + 1,len(points_in_invalid)):\n        #count the number of times both of these are in the bad triangles\n        count_occurrences = 0\n        for k in range(len(invalid_triangles)):\n            count_occurrences += 1 * (points_in_invalid[i] in invalid_triangles[k]) * \\            (points_in_invalid[j] in invalid_triangles[k])\n        if(count_occurrences == 1):\n            delaunay.append(points_to_triangle(points_in_invalid[i], points_in_invalid[j], \\point_to_add))\n```", "```py\ndef gen_delaunay(points):\n    delaunay = [points_to_triangle([-5,-5],[-5,10],[10,-5])]\n    number_of_points = 0\n\n    while number_of_points < len(points): 1\n        point_to_add = points[number_of_points]\n\n        delaunay_index = 0\n\n        invalid_triangles = [] 2\n        while delaunay_index < len(delaunay):\n            circumcenter,radius = triangle_to_circumcenter(delaunay[delaunay_index])\n            new_distance = get_distance(circumcenter,point_to_add)\n            if(new_distance < radius):\n                invalid_triangles.append(delaunay[delaunay_index])\n            delaunay_index += 1\n\n        points_in_invalid = [] 3\n        for i in range(0,len(invalid_triangles)):\n            delaunay.remove(invalid_triangles[i])\n            for j in range(0,len(invalid_triangles[i])):\n                points_in_invalid.append(invalid_triangles[i][j])\n        points_in_invalid = [list(x) for x in set(tuple(x) for x in points_in_invalid)]\n\n        for i in range(0,len(points_in_invalid)): 4\n            for j in range(i + 1,len(points_in_invalid)):\n                #count the number of times both of these are in the bad triangles\n                count_occurrences = 0\n                for k in range(0,len(invalid_triangles)):\n                    count_occurrences += 1 * (points_in_invalid[i] in invalid_triangles[k]) * \\                    (points_in_invalid[j] in invalid_triangles[k])\n                if(count_occurrences == 1):\n                    delaunay.append(points_to_triangle(points_in_invalid[i], \\points_in_invalid[j], point_to_add))\n\n**number_of_points += 1**\n\n    return(delaunay)\n```", "```py\nN=15\nimport numpy as np\nnp.random.seed(5201314)\nxs = np.random.rand(N)\nys = np.random.rand(N)\npoints = zip(xs,ys)\nlistpoints = list(points)\nthe_delaunay = gen_delaunay(listpoints)\n```", "```py\n--`snip`--\nfor j in range(len(triangles)):\n    commonpoints = 0\n    for k in range(len(triangles[i])):\n        for n in range(len(triangles[j])):\n            if triangles[i][k] == triangles[j][n]:\n               commonpoints += 1\n    if commonpoints == 2:\n        lines.append([list(centers[i][0]),list(centers[j][0])])\n```", "```py\ndef plot_triangle_circum(triangles,centers,plotcircles,plotpoints, \\plottriangles,plotvoronoi,plotvpoints,thename):\n    fig, ax = pl.subplots()\n    ax.set_xlim([-0.1,1.1])\n    ax.set_ylim([-0.1,1.1])\n\n    lines=[]\n    for i in range(0,len(triangles)):\n        triangle = triangles[i]\n        center = centers[i][0]\n        radius = centers[i][1]\n        itin = [0,1,2,0]\n        thelines = genlines(triangle,itin)\n        xs = [triangle[0][0],triangle[1][0],triangle[2][0]]\n        ys = [triangle[0][1],triangle[1][1],triangle[2][1]]\n\n        lc = mc.LineCollection(genlines(triangle,itin), linewidths=2)\n        **if(plottriangles):**\n            ax.add_collection(lc)\n        **if(plotpoints):**\n            pl.scatter(xs, ys)\n\n        ax.margins(0.1)\n 1 **if(plotvpoints):**\n **pl.scatter(center[0],center[1])**\n\n        circle = pl.Circle(center, radius, color = 'b', fill = False)\n        **if(plotcircles):**\n            ax.add_artist(circle)\n\n     2 **if(plotvoronoi):**\n **for j in range(0,len(triangles)):**\n **commonpoints = 0**\n **for k in range(0,len(triangles[i])):**\n **for n in range(0,len(triangles[j])):**\n **if triangles[i][k] == triangles[j][n]:**\n **commonpoints += 1**\n **if commonpoints == 2:**\n **lines.append([list(centers[i][0]),list(centers[j][0])])**\n\n        lc = mc.LineCollection(lines, linewidths = 1)\n\n        ax.add_collection(lc)\n\n    pl.savefig(str(thename) + '.png')\n    pl.close()\n```", "```py\ncircumcenters = []\nfor i in range(0,len(the_delaunay)):\n    circumcenters.append(triangle_to_circumcenter(the_delaunay[i]))\n```", "```py\nplot_triangle_circum(the_delaunay,circumcenters,False,True,False,True,False,'final')\n```", "```py\nplot_triangle_circum(the_delaunay,circumcenters,True,True,True,True,True,'everything')\n```"]