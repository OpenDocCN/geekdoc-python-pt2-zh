- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Spatial Trees
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 空间树
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: The previous chapter showed how nearest-neighbor search allows us to find nearby
    or close data points, broadening our ability to answer coffee-related questions,
    such as finding the closest physical location or finding items with similar attributes.
    In this chapter, we build on the concepts of tree-based data structures and spatial
    partitioning to further improve our nearest-neighbor searches.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章展示了如何通过最近邻搜索来找到附近或相近的数据点，扩展了我们回答与咖啡相关问题的能力，例如找到最近的物理位置或找到具有相似属性的项目。本章我们将在基于树的数据结构和空间划分的基础上，进一步提升我们的最近邻搜索能力。
- en: Chapter 8 discussed how we can adapt the algorithmic concepts for finding a
    specific value to the more general problem of finding nearest neighbors. We also
    saw how operations become more difficult as we transition from a single dimension
    to multiple dimensions. Maybe we want to find nearby coffee shops in two-dimensional
    space or similar friends (based on empathy, willingness to listen, and the ever-important
    coolness factor). Grids replace the simple arrays, and it’s no longer sufficient
    to sort along a single dimension.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 第 8 章讨论了如何将寻找特定值的算法概念适应到更一般的寻找最近邻问题中。我们还看到，随着从单一维度过渡到多维度，操作变得更加复杂。也许我们想在二维空间中寻找附近的咖啡馆，或寻找相似的朋友（基于共情、倾听意愿以及永恒重要的酷感因子）。网格取代了简单的数组，单一维度排序已经不再足够。
- en: 'This chapter introduces two new tree-based data structures: uniform quadtrees
    and k-d trees. The term *quadtree* is often used to describe an entire class of
    two-dimensional data structures, based on the original quadtree proposed by computer
    scientists Raphael Finkel and Jon Bentley, that partition each two-dimensional
    node into four subquadrants at each level. We focus on a uniform quadtree such
    as the structure proposed by researcher and inventor David P. Anderson. This structure
    has equal-sized subregions that mirror the grid structure, thus building upon
    our discussions in the previous chapter. In contrast, *k-d trees*, invented by
    Jon Bentley, use a more flexible binary partitioning scheme that can further adapt
    to the data and allow us to scale to higher dimensions. Through examining quadtrees
    and k-d trees, we learn to generalize and modify tree-based data structures—and
    examine these data structures by comparison with the projects of city planners.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了两种基于树的新数据结构：均匀四叉树和 k-d 树。术语*四叉树*通常用来描述一个二维数据结构的整个类，基于计算机科学家 Raphael Finkel
    和 Jon Bentley 提出的原始四叉树，该结构将每个二维节点在每个级别分割成四个子区域。我们关注的是均匀四叉树，如研究员和发明家 David P. Anderson
    提出的结构。该结构具有与网格结构相似的等大小子区域，从而延续了我们在上一章中的讨论。相比之下，*k-d 树*由 Jon Bentley 发明，使用一种更灵活的二进制分割方案，可以进一步适应数据并允许我们扩展到更高的维度。通过研究四叉树和
    k-d 树，我们学会了如何概括和修改基于树的数据结构，并通过与城市规划项目的比较来审视这些数据结构。
- en: Quadtrees
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 四叉树
- en: While grids provide a convenient data structure for storing two-dimensional
    data, they come with their own host of complexities. As we saw in the previous
    chapter, both the overhead and usefulness of grids depend heavily on how finely
    we partition the space. Using a large number of grid bins (by creating a finely
    grained grid) takes significant memory and may require us to search many bins.
    On the other hand, coarsely grained partitioning can result in a large number
    of points per bin, as in [Figure 9-1](#figure9-1), resembling a simple linear
    scan over a large number of individual points.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然网格提供了一种方便的二维数据存储结构，但它们也带来了许多复杂性。正如我们在上一章所看到的，网格的开销和实用性在很大程度上取决于我们如何细分空间。使用大量网格单元（通过创建细粒度的网格）需要大量内存，并可能要求我们搜索许多单元。另一方面，粗粒度的分割可能导致每个单元中有大量的点，如[图
    9-1](#figure9-1)所示，类似于对大量单独点的简单线性扫描。
- en: '![A two‐by‐two grid with 11 data points and a single target point.](image_fi/502604c09/f09001.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含 11 个数据点和一个目标点的二维网格](image_fi/502604c09/f09001.png)'
- en: 'Figure 9-1: A grid with a small number of bins'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-1：一个具有少量格子的网格
- en: We can think of the grids in terms of different approaches to home organization.
    If we throw all our kitchen equipment into a single massive drawer, it takes forever
    to find a given item. This is equivalent to having a single large grid bin. To
    improve matters, suppose we separate utensils into different drawers and cookware
    into various cupboards depending on their usage. We even put cereals on one shelf
    and spices on another. This is equivalent to using finer-grained bins. Suddenly
    things are looking up—we no longer need to search under the frying pans to find
    the cinnamon. A little additional structure makes our cooking routine significantly
    easier.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以把网格想象成不同的家居整理方法。如果我们把所有厨房用具丢进一个巨大的抽屉里，要找某个物品可得花费很长时间。这相当于使用一个大的网格箱。为了改善这一点，假设我们根据物品的用途将餐具分成不同的抽屉，把炊具分放到不同的橱柜里。甚至把麦片放在一层架子上，把香料放在另一层。这相当于使用更精细的网格箱。突然间情况变得好转——我们不再需要在煎锅下翻找肉桂粉了。多一点结构就让我们的烹饪变得更加轻松。
- en: However, we can take the idea too far. Perhaps we have too many utensils and
    it takes too long to search the packed drawer. We might improve efficiency by
    splitting the utensils into a drawer for scooping utensils and one for non-scooping
    utensils. But imagine the overhead of storing each utensil in its own drawer—or
    worse, allocating a drawer for each potential utensil we might buy. Soon we’re
    staring at a whole wall of drawers, wondering how many we’ll need to check to
    find something to beat our eggs. This is what happens when we use grids with overly
    fine bins.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们有时会过度应用这一思路。也许我们有太多的餐具，寻找一个已满的抽屉需要很长时间。我们可以通过将餐具分为专门放置勺子用具的抽屉和放置非勺子用具的抽屉来提高效率。但想象一下将每个餐具存放在自己的抽屉中的开销——更糟的是，为每个可能购买的餐具分配一个抽屉。很快，我们会看到一整面抽屉墙，心里想着，得检查多少个抽屉才能找到打蛋器。这就是当我们使用过于精细的网格划分时会发生的情况。
- en: The solution to this conundrum is to partition space dynamically relative to
    the data. We only bring in additional structure, and its corresponding overhead,
    when we need it. We start with a coarse-grained partition of the space. Maybe
    we wait to allocate a separate drawer for spatulas until we have at least five.
    Until then we can store them with the ladles and whisks. When we need more granularity,
    we subpartition our space further. To provide this dynamism, we can turn to *uniform
    quadtrees*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个难题的方法是相对于数据动态地划分空间。只有在需要时，我们才引入额外的结构及其相应的开销。我们从一个粗粒度的空间划分开始。也许我们等到有至少五个铲子时才分配一个单独的抽屉。否则我们可以把它们和勺子、打蛋器放在一起。当我们需要更细的粒度时，我们进一步对子空间进行划分。为了实现这种动态性，我们可以使用*均匀四叉树*。
- en: A uniform quadtree brings the branching structure of trees to grids. Each node
    in the tree represents a region of space. The root node represents the entire
    space covered by the tree and all points contained within this space. Each node
    is partitioned into four equal-sized quadrants, with a child node for each non-empty
    quadrant. The term *uniform* refers to the fact that nodes are partitioned into
    equal-sized spatial regions and thus partition the space within the node uniformly.
    [Figure 9-2](#figure9-2) illustrates a quadtree split.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 均匀四叉树将树的分支结构引入网格。树中的每个节点代表一个空间区域。根节点代表四叉树覆盖的整个空间以及该空间内的所有点。每个节点被划分为四个大小相等的象限，每个非空象限都有一个子节点。术语*均匀*指的是节点被划分为大小相等的空间区域，从而在节点内均匀地划分空间。[图
    9-2](#figure9-2)展示了四叉树的划分。
- en: '![The root node of the quadtree shown at the top encompasses the entire space
    and contains 11 points. Each of the four children contains a uniform region of
    the root node’s space and all points that fall within that region.](image_fi/502604c09/f09002.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![四叉树的根节点位于顶部，覆盖了整个空间并包含11个点。每个子节点包含根节点空间的均匀区域，以及所有落在该区域内的点。](image_fi/502604c09/f09002.png)'
- en: 'Figure 9-2: A quadtree node can have up to four children representing four
    equal-sized quadrants of that space.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-2：一个四叉树节点最多可以有四个子节点，分别代表该空间的四个大小相等的象限。
- en: When discussing the four subtrees, it’s common to label them NorthWest, NorthEast,
    SouthWest, and SouthEast to reflect their spatial positions in the original region.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论四个子树时，通常会标记它们为西北（NorthWest）、东北（NorthEast）、西南（SouthWest）和东南（SouthEast），以反映它们在原始区域中的空间位置。
- en: Internal quadtree nodes store pointers to up to four children, along with associated
    metadata such as the number of points in the branch or the region’s spatial bounds
    (the minimum and maximum values for the node along the x- and y-dimension). Leaf
    nodes store a list of points that fall within that region, along with any desired
    metadata. We can use a single data structure for both internal and leaf nodes
    by keeping both a 2×2 grid of pointers to child nodes (for internal nodes) and
    an array for points (for leaf nodes). We either set the child entries to `null`
    in a leaf node or use an empty array for internal nodes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 内部四叉树节点存储最多四个子节点的指针，以及与之关联的元数据，如分支中点的数量或该区域的空间边界（节点在 x 轴和 y 轴上的最小值和最大值）。叶子节点存储该区域内的点列表，以及任何所需的元数据。我们可以通过同时保持指向子节点的
    2×2 指针网格（对于内部节点）和点数组（对于叶子节点），使用一个统一的数据结构来表示内部节点和叶子节点。我们可以在叶子节点中将子节点条目设置为 `null`，或在内部节点中使用空数组。
- en: 'The following is an example of a composite data structure for the `QuadTreeNode`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 `QuadTreeNode` 的复合数据结构示例：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We use a simple composite data structure for the points:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为点使用了一个简单的复合数据结构：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As in the previous chapter, we could alternatively store the points in arrays
    or ordered tuples.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一章所述，我们也可以选择将点存储在数组或有序元组中。
- en: 'Technically, we don’t need to store the spatial bounds of the node explicitly.
    We can instead derive the bounds for each node from bounds of the root node and
    the sequence of splits, since each node partitions its points along the middle
    of each dimension, slicing the space into four predictably sized subregions. Given
    the root node’s original bounds and the series of branches, we can compute the
    bounds for any child node precisely. However, precomputing and storing the bounds
    has one distinct advantage: at any given node we can simply look up the bounds
    instead of deriving them, making implementing our search algorithms significantly
    easier. I’ve often found that the value of storing this type of additional spatial
    information outweighs the additional memory costs.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，我们不需要显式地存储节点的空间边界。我们可以通过从根节点的边界和分割序列中推导出每个节点的边界，因为每个节点都会沿每个维度的中线分割其点，将空间划分为四个可预测大小的子区域。给定根节点的原始边界和一系列分支，我们可以精确计算出任何子节点的边界。然而，预计算并存储边界有一个明显的优势：在任何给定的节点，我们可以直接查找边界，而不是推导它们，这使得我们实现搜索算法变得更加容易。我发现，存储这种额外的空间信息的价值往往超过了额外的内存开销。
- en: The power of quadtrees is that branching at each level (where there are enough
    points) effectively creates an adaptive, hierarchical grid. [Figure 9-3](#figure9-3)
    shows an example of one quadtree’s spatial partitioning.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 四叉树的强大之处在于每一级的分支（当有足够的点时）有效地创建了一个自适应的分层网格。[图 9-3](#figure9-3) 显示了一个四叉树空间分区的示例。
- en: '![A visualization of a four‐level quadtree. Lines indicate the splits at each
    level.](image_fi/502604c09/f09003.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![一个四层四叉树的可视化。线条表示每个级别的分割。](image_fi/502604c09/f09003.png)'
- en: 'Figure 9-3: The spatial partition created by a quadtree'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-3：四叉树创建的空间分区
- en: Imagine the successive partitions of a quadtree and how we search them as the
    interactive geographical search software in a sci-fi thriller. The protagonists
    crowd the command room and stare at a large screen representing the entire city.
    Tense music plays. As new information pours in, the operator selects a quadrant
    from the screen. Someone says, “Zoom in there and enhance,” and the operator does
    so. Regardless of the dialogue, this operation is the equivalent to descending
    a level in the quadtree. In an instant, the command room’s screen displays a subset
    of the city. The entire range under display is a single quadrant of the previous
    level. Everyone stares at the new geo-subset intently, before they select a further
    subquadrant and zoom in again. The search concludes when our heroes have found
    the transmitter closest to the target points.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下四叉树的连续分区，以及我们如何将其作为科幻惊悚片中的互动地理搜索软件进行搜索。主角们挤满了指挥室，凝视着代表整个城市的大屏幕。紧张的音乐播放着。随着新信息的不断涌入，操作员从屏幕中选择一个象限。有人说：“在那里放大并增强”，操作员照做了。无论对话如何，这一操作等同于在四叉树中下降一级。瞬间，指挥室的屏幕上显示了城市的一个子集。显示范围的整个区域是上一层级的一个象限。每个人都专注地盯着新的地理子集，随后他们选择进一步的子象限并再次放大。搜索在我们的英雄找到了最接近目标点的发射器时结束。
- en: 'As with other trees, we can add a wrapper data structure around the uniform
    quadtree to simplify bookkeeping:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他树一样，我们可以在统一的四叉树外部添加一个包装数据结构，以简化账务管理：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The root node is created as an empty node with the correct dimensions at the
    time the tree itself is created, so we do not need to worry about its being null.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 根节点在树创建时作为一个空节点与正确的尺寸一起创建，因此我们不需要担心它会是 null。
- en: Building Uniform Quadtrees
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建统一的四叉树
- en: 'We build these magical quadtrees by recursively dividing our allocated space
    into smaller and smaller subregions. Since data can contain arbitrarily close
    or even duplicate points, we need additional logic to determine when to stop subdividing
    and designate a node with multiple points as a leaf. At each level, we check whether
    we need to make the current node an internal node (with child nodes) or a leaf
    node (with a list of points). There are different mechanisms we can use for this
    test, but here are the most common:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过递归地将分配的空间划分为越来越小的子区域来构建这些神奇的四叉树。由于数据可能包含非常接近或甚至重复的点，我们需要额外的逻辑来确定何时停止细分，并将包含多个点的节点标记为叶节点。在每个层级，我们检查是否需要将当前节点设为内部节点（具有子节点）或叶节点（包含点的列表）。我们可以使用不同的机制来进行此测试，但以下是最常见的几种：
- en: Are there enough points to justify a split? If we have too few points, the cost
    of checking the distance to the child nodes is higher than exhaustively checking
    each of the points. It’s not worth the overhead.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否有足够的点来进行划分？如果点太少，检查到子节点的距离成本高于逐一检查每个点的成本。这样做不值得浪费开销。
- en: Are the spatial bounds large enough to justify a split? What if we have 10 points
    in exactly the same location? We could split and split and split without ever
    partitioning the points. It’s a waste of time and memory.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 空间边界是否足够大，以致于可以进行划分？如果我们有 10 个点正好位于同一个位置呢？我们可以一直划分，却永远无法分割这些点。这将浪费时间和内存。
- en: Have we hit a maximum depth? This provides an alternate check to prevent us
    from wasting time and memory on excessive subdivision by capping how deep our
    tree can be.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们是否达到了最大深度？这提供了一种替代检查，防止我们在过度细分时浪费时间和内存，通过限制树的深度来避免这种情况。
- en: We can visualize this process as an unconventional city planner’s attempt to
    divide up the land such that each parcel has a building. Unacquainted with modern
    geographical partitioning techniques, the planner always divides regions into
    four equal-sized quadrants. Each time they look at a plot of land, they ask, “Are
    there too many buildings on this land?” and “Is this plot big enough to divide
    up further? I can’t sell a 2-foot by 2-foot lot. People would laugh.” The third
    criterion (maximum depth) represents how much subdividing the planner is willing
    to do before they give up. After four levels, the planner might call it “good
    enough” and move on. If the criteria for stopping aren’t met, the planner sighs,
    mumbles “Really? Again?” and subdivides the plot.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个过程想象为一个非常规城市规划师的尝试，他们将土地划分为每个地块都有建筑物的方式。由于不熟悉现代地理分区技术，规划师总是将区域分为四个相等大小的象限。每当他们查看一块土地时，他们会问：“这块土地上的建筑物是不是太多了？”以及“这块土地足够大，能够进一步细分吗？我不能卖一个
    2 英尺乘 2 英尺的地块。人们会笑话我。”第三个标准（最大深度）表示规划师在放弃之前愿意进行多少次细分。经过四个层级，规划师可能会说“差不多了”然后继续。如果停止细分的标准没有达到，规划师会叹气，嘀咕一句“真的吗？又来？”然后继续细分这块地。
- en: When partitioning a level, we divide the current space into four equal quadrants,
    partition the points according to quadrant, and recursively examine each one.
    If we set the minimum of points to 1 and the maximum depth to 4 (including the
    root), we’d construct the tree in [Figure 9-4](#figure9-4). As shown by the illustration,
    we can save memory by only storing the non-empty children for each node. If a
    quadrant doesn’t have a child, we can set its pointer to `null`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在划分一个层级时，我们将当前空间划分为四个相等的象限，根据象限划分点，并递归地检查每个象限。如果我们将最小点数设置为 1，最大深度设置为 4（包括根节点），我们将构建图
    9-4 中的树。如图所示，我们可以通过只存储每个节点的非空子节点来节省内存。如果某个象限没有子节点，我们可以将其指针设置为`null`。
- en: '![The figure shows a quadtree with four levels. Each leaf node contains a single
    point.](image_fi/502604c09/f09004.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图示展示了一个具有四个层级的四叉树。每个叶节点包含一个单独的点。](image_fi/502604c09/f09004.png)'
- en: 'Figure 9-4: An example quadtree with four levels'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-4：一个具有四个层级的示例四叉树
- en: The code for bulk construction of quadtrees is very similar to the code presented
    in the next section for adding points. In fact, iteratively adding points to an
    empty quadtree is a good approach for constructing it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 用于批量构建四叉树的代码与下一节添加点的代码非常相似。事实上，逐步向一个空的四叉树中添加点是构建四叉树的好方法。
- en: Adding Points
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加点
- en: 'Since quadtrees are dynamic data structures, we can efficiently add points
    while maintaining the tree structure. We start with the wrapper function for the
    `QuadTree` data structure:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于四叉树是动态数据结构，我们可以在保持树结构的同时高效地添加点。我们从`QuadTree`数据结构的包装函数开始：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This wrapper guarantees we are always calling `QuadTreeNodeInsert` with a non-null
    node. The code also checks that the inserted point falls within the quadtree’s
    bounds. This is critical, as uniform quadtrees use equal-sized bins and cannot
    be dynamically resized. All points must fall within the root node’s spatial bounds.
    The code returns `False` if the point is out of range, but, depending on the implementation,
    you might want to use another mechanism such as returning an error or throwing
    an exception.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包装器保证我们始终调用`QuadTreeNodeInsert`时传入的是非空节点。代码还会检查插入的点是否落在四叉树的边界内。这是至关重要的，因为均匀四叉树使用的是相同大小的容器，且无法动态调整大小。所有点必须落在根节点的空间边界内。如果点超出范围，代码返回`False`，但是根据实现方式，你可能想使用其他机制，比如返回错误或抛出异常。
- en: 'As shown in the following code, adding points to a node consists of traversing
    the tree to find the new point’s location. This search can end in one of two ways:
    at a leaf node or at an internal dead end. If we terminate the search at a leaf
    node, we can add the new point there. Depending on our splitting criteria (spatial
    bounds, max depth, and number of points), we might need to split the node into
    subnodes. If we end at an internal dead end, then we have found a path that previously
    didn’t contain any points. We can create the appropriate node.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下代码所示，向节点添加点的过程是遍历树来找到新点的位置。这个搜索可以通过两种方式结束：在叶子节点或内部死胡同。如果我们在叶子节点结束搜索，就可以在该节点添加新点。根据我们的分割标准（空间边界、最大深度和点的数量），我们可能需要将节点分割成子节点。如果我们结束于内部死胡同，那就说明我们找到了一个先前没有包含任何点的路径。我们可以在此创建适当的节点。
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code starts by incrementing `num_points` to represent the new point ❶. The
    function then determines which of the four bins the new point falls into by computing
    the size of the bins and using that to map the x and y indices to either `0` or
    `1` ❷. If the node is not a leaf, the code needs to recursively add the point
    to the correct child ❸. It starts by checking whether the child exists. If not
    (if the child’s pointer is `null`), it creates the child ❹. We use the fact that
    both `xbin` and `ybin` are either `0` or `1` to simplify the logic. Instead of
    enumerating all four cases, we can compute the child’s bounds with arithmetic.
    Finally, at leaf nodes, the code inserts the points directly into the node ❺.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先通过增加`num_points`来表示新点❶。然后，函数通过计算容器的大小，并使用这些信息将x和y索引映射到`0`或`1`来确定新点属于四个容器中的哪一个❷。如果节点不是叶子节点，代码需要递归地将点添加到正确的子节点❸。它首先检查子节点是否存在。如果不存在（即子节点的指针为`null`），则创建子节点❹。我们利用`xbin`和`ybin`都只能是`0`或`1`这一事实来简化逻辑。我们不需要列举所有四种情况，而是可以通过算术运算计算子节点的边界。最后，在叶子节点中，代码直接将点插入到节点中❺。
- en: We aren’t done yet, though. The code needs to check whether the splitting conditions
    are met ❻; if so, it splits the current leaf node. Luckily, we can reuse the same
    insertion function for splitting as we did to add a point. The code marks the
    node as a non-leaf (`node.is_leaf = False`) and reinserts the points one at a
    time using a `FOR` loop ❼. Because the current node is no longer a leaf node,
    the reinserted points now fall through to the correct children, with new children
    created as needed. However, since we used the function twice for each point, we
    have to correct `num_points` to avoid double-counting the reinserted points ❽
    (due to the counter increment at ❶). The code also clears the list of points at
    the newly internal node.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我们还没完成。代码需要检查是否满足分割条件❻；如果满足，就会分割当前的叶子节点。幸运的是，我们可以重用插入函数来进行分割，就像我们插入一个点时一样。代码将节点标记为非叶子节点（`node.is_leaf
    = False`），并使用`FOR`循环逐一重新插入点❼。因为当前节点不再是叶子节点，重新插入的点现在会落到正确的子节点，并根据需要创建新的子节点。然而，由于我们为每个点调用了两次这个函数，我们需要修正`num_points`，以避免重复计数重新插入的点❽（由于❶处的计数器增加）。代码还会清空新内部节点的点列表。
- en: '[Figure 9-5](#figure9-5) shows what happens if we add two points to the tree.
    The inserted open-circle point causes one node to split before triggering the
    max-depth condition. The resulting leaf node holds two points. The inserted open-square
    point adds a single new child node corresponding to its parent NorthWest quadrant.
    The code does not split again because of the minimum number of points condition.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-5](#figure9-5)显示了如果我们向树中添加两个点会发生什么。插入的空心圆点在触发最大深度条件之前导致一个节点分裂。结果的叶节点包含两个点。插入的空心方形点为其父节点的西北象限添加了一个新的子节点。由于最小点数条件，代码没有再次分裂。'
- en: As noted in the previous section, we can use this approach to construct a uniform
    quadtree from a set of points. First, we create an empty root node with the necessary
    spatial bounds. Then we incrementally add each point from our set. Since splits
    are always based at the halfway point along each dimension, the tree structure
    does not change due to the order in which we insert the points.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一部分所述，我们可以使用这种方法从一组点构建一个统一的四叉树。首先，我们创建一个空的根节点，并设置必要的空间边界。然后我们逐步将每个点添加到树中。由于分裂始终基于每个维度的中间点，树的结构不会因我们插入点的顺序而改变。
- en: '![A figure showing the addition of two points to the uniform quadtree. The
    open circle is inserted in the root’s NorthWest Child and that node’s SouthWest
    child. The previous leaf now has two points and is split again. Both points are
    in the same resulting node, which is a leaf due to the depth constraint.](image_fi/502604c09/f09005.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![一幅图，显示将两个点添加到统一四叉树的过程。空心圆插入到根节点的西北子节点及该节点的西南子节点。之前的叶节点现在有两个点并再次分裂。两个点位于同一节点中，该节点由于深度限制而成为叶节点。](image_fi/502604c09/f09005.png)'
- en: 'Figure 9-5: An example of adding two points, indicated by a shaded circle and
    shaded square, to a quadtree'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-5：将两个点（表示为阴影圆圈和阴影方块）添加到四叉树的示例
- en: Removing Points
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除节点
- en: Removing points from a node follows a similar, but more complex, process as
    inserting points. We delete the point from the list in the leaf node. We can then
    proceed back up the tree, removing splits that are no longer warranted by our
    criteria. This can involve recursively extracting the points from each of the
    node’s children (which may themselves have children) and merging them into a single
    list at the next leaf node.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从节点中删除点的过程与插入点类似，但更为复杂。我们首先从叶节点中的点列表中删除该点。然后，我们可以沿着树返回，删除那些不再符合我们标准的分裂。这可能涉及递归地从每个节点的子节点中提取点（这些子节点可能本身也有子节点），并将它们合并到下一个叶节点的单一列表中。
- en: One additional difficulty is determining which point to delete. As with grids,
    the user might insert arbitrarily close or even duplicate points. In the code
    below, we delete the first matching point in the leaf node’s list. Due to floating-point
    errors (rounding due to a floating-point variable’s limited precision), we also
    cannot use a direct equality test. Therefore, we use a helper function to find
    a point that is close enough. We can reuse the `approx_equal` function from Listing
    8-3 for this test.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个困难是确定删除哪个点。与网格一样，用户可能会插入任意接近的点，甚至是重复的点。在下面的代码中，我们删除叶节点列表中的第一个匹配点。由于浮动点误差（由于浮动点变量的精度限制而导致的舍入误差），我们也不能使用直接的相等测试。因此，我们使用一个辅助函数来找到足够接近的点。我们可以复用在清单
    8-3 中的`approx_equal`函数来进行此测试。
- en: 'We also use a helper function to collapse nodes that no longer meet our splitting
    criteria. The code collapses a node with children and returns an array with all
    the subtree’s points:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用一个辅助函数来合并那些不再符合分裂标准的节点。代码会合并一个有子节点的节点，并返回包含整个子树所有点的数组：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code starts by checking whether the current node is already a leaf and,
    if so, directly returning the array of points ❶. Otherwise, the node is internal,
    and the code needs to aggregate the individual data points from each child. The
    code loops through each of the four children, checking whether they are `null`
    and, if not, recursively calling `QuadTreeNodeCollapse` to aggregate the points
    ❷. The function finishes by setting the current node to be a leaf ❸ and returning
    the points ❹.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先检查当前节点是否已经是叶节点，如果是，则直接返回点的数组 ❶。否则，该节点是内部节点，代码需要从每个子节点中汇总单独的数据点。代码循环遍历四个子节点，检查它们是否为`null`，如果不是，则递归调用`QuadTreeNodeCollapse`来汇总点
    ❷。函数最后通过将当前节点设置为叶节点 ❸，并返回点 ❹。
- en: With that helper function, we can move on to the deletion function. We start
    with the wrapper.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个辅助函数后，我们可以进入删除函数。我们从包装器开始。
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The wrapper function starts by checking that the point lies within the bounds
    of the tree and thus could be in the tree. If so, it calls the recursive deletion
    function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 包装函数首先检查点是否位于树的边界内，因此可能在树中。如果是，它会调用递归删除函数。
- en: The recursive deletion code proceeds down the tree as though searching for the
    point. When it reaches a leaf, it deletes the point if it exists. It then returns
    up the tree, collapsing nodes as needed. The function returns `True` if a point
    was deleted.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 递归删除代码沿树向下推进，仿佛在搜索目标点。当到达叶子节点时，如果该点存在，则删除该点。然后，代码向上返回树，必要时压缩节点。如果删除了一个点，函数返回
    `True`。
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The code starts by checking whether the recursion has reached a leaf node ❶.
    If so, it iterates through the array of points ❷, checking whether each one matches
    the target point ❸. If the code finds a matching point, it removes it from the
    array, decrements the count of points in this node, and returns `True` to indicate
    a successful deletion. Note that only a single matching point is ever deleted.
    If the code does not find a matching point at the leaf, it returns `False`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先检查递归是否到达叶子节点 ❶。如果是，它会遍历点数组 ❷，检查每个点是否与目标点匹配 ❸。如果找到匹配的点，它会将其从数组中移除，减少该节点中的点数，并返回
    `True`，表示删除成功。请注意，只有一个匹配点会被删除。如果代码在叶子节点没有找到匹配点，它会返回 `False`。
- en: The search then progresses down into the bin into which the target point would
    be assigned ❹. The code checks whether the correct child exists and, if not, returns
    `False` to indicate the point is not in the tree ❺. Otherwise, the code recursively
    calls `QuadTreeNodeDelete` on the child ❻.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索随后进入目标点应该被分配的桶 ❹。代码检查是否存在正确的子节点，如果不存在，则返回 `False`，表示该点不在树中 ❺。否则，代码递归调用 `QuadTreeNodeDelete`
    来处理子节点 ❻。
- en: If the recursive call to `QuadTreeNodeDelete` returns `True`, then the code
    has deleted a point from one of its children. It updates the count of points and
    checks whether the child is empty ❼. If so, it deletes the child node. Then the
    code checks whether the current node continues to meet the criteria for being
    an internal node ❽. If not, it collapses the node. The code returns `True` to
    indicate the deletion was successful. If the recursive call did not return `True`,
    then no point was deleted. The function finishes by returning `False` ❾.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对 `QuadTreeNodeDelete` 的递归调用返回 `True`，则说明代码已从其子节点中删除了一个点。它会更新点的计数，并检查该子节点是否为空
    ❼。如果为空，它会删除该子节点。然后，代码检查当前节点是否继续满足作为内部节点的标准 ❽。如果不满足，则会压缩该节点。代码返回 `True`，表示删除成功。如果递归调用未返回
    `True`，则说明没有删除任何点。该函数最终返回 `False` ❾。
- en: Searching Uniform QuadTrees
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索均匀四叉树
- en: We begin our search of the quadtree at the root node. At each node, we first
    ask whether the node could contain anything closer than our current candidate.
    If so, for an internal node we explore the children recursively, and for a leaf
    node we test the points directly. However, if we determine that the current node
    could *not* contain our nearest neighbor, we can prune the search by ignoring
    not only that node but its entire subtree.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从四叉树的根节点开始搜索。在每个节点中，我们首先询问该节点是否可能包含比当前候选点更接近的点。如果是这样，对于内部节点，我们递归地探索其子节点；对于叶子节点，我们直接测试这些点。然而，如果我们确定当前节点不可能包含我们最近的邻居，我们可以通过忽略该节点及其整个子树来剪枝搜索。
- en: 'We check the compatibility of points within a node using the same test we applied
    to grid cells in Chapter 8. We have similar information at our disposal: the location
    of the point and the bounding box of the region. As described in the previous
    chapter, the distance computation is:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用与第8章中对网格单元应用的相同测试来检查节点内点的兼容性。我们可以使用相似的信息：点的位置和区域的边界框。如前一章所述，距离计算为：
- en: '![g09001](image_fi/502604c09/g09001.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![g09001](image_fi/502604c09/g09001.png)'
- en: where
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: IF *x* < *x*[min] THEN *x*[dist] = *x*[min] – *x*
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *x* < *x*[min]，则 *x*[dist] = *x*[min] – *x*
- en: IF *x*[min] ≤ *x* ≤ *x*[max] THEN *x*[dist] = 0
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *x*[min] ≤ *x* ≤ *x*[max]，则 *x*[dist] = 0
- en: IF *x* > *x*[max] THEN *x*[dist] = *x* – *x*[max]
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *x* > *x*[max]，则 *x*[dist] = *x* – *x*[max]
- en: and
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: IF *y < y*[min]THEN *y*[dist] *= y*[min] *– y*
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *y < y*[min]，则 *y*[dist] *= y*[min] *– y*
- en: IF *y*[min] ≤ *y* ≤ *y*[max] THEN *y*[dist] = 0
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *y*[min] ≤ *y* ≤ *y*[max]，则 *y*[dist] = 0
- en: IF *y* > *y*[max] THEN *y*[dist] = *y* – *y*[max]
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *y* > *y*[max]，则 *y*[dist] = *y* – *y*[max]
- en: In short, we’re checking the distance from our search target to the closest
    possible point contained in the node’s spatial region. To revisit the example
    from the last chapter, we’re once again asking how far our lazy neighbor would
    need to throw a ball in order to just barely return it to our yard. This check
    only tests whether a point at this distance could exist within the node. We need
    to explore the node to see what points exist.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们正在检查从搜索目标到节点空间区域内最接近点的距离。回顾上一章的例子，我们再次在问：我们的懒惰邻居需要多远扔一个球才能勉强把球扔回我们的院子？这个检查只测试在此距离下是否有点可能存在于节点中。我们需要探索节点，以查看有哪些点存在。
- en: Consider searching for the nearest neighbor of the point marked with an X in
    [Figure 9-6](#figure9-6). This figure shows the same distribution of points as
    our original map of coffee shop locations in Figure 8-3, where the X is our current
    location and the other points are nearby cafés.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑搜索[图9-6](#figure9-6)中标记为X的点的最近邻。该图展示了与我们在[图8-3](#figure8-3)中咖啡店位置地图相同的点分布，其中X代表我们的当前位置，其他点则是附近的咖啡馆。
- en: We start at the root node with a dummy candidate point with infinite distance.
    We haven’t seen any candidate neighbors yet, so we need something with which to
    start our search. Using a dummy point with infinite distance allows the algorithm
    to accept the first point it finds as the new candidate without requiring any
    special logic. Any point we find is going to be closer than infinitely far away,
    and every region will contain closer points. In the case of searching for coffee
    shops, this corresponds to starting with an imaginary café that is infinitely
    far away. Any real café on our list is guaranteed to be closer than this imaginary
    point.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从根节点开始，设置一个无限远的虚拟候选点。我们还没有看到任何候选邻居，所以需要一个起始点来开始搜索。使用一个无限远的虚拟点可以让算法接受它找到的第一个点作为新的候选点，而无需特殊的逻辑。我们找到的任何点都会比无限远的点要近，而且每个区域都会包含更近的点。在搜索咖啡馆的情况下，这相当于从一个虚拟的、无限远的咖啡馆开始。我们列表中的任何一个真实咖啡馆都一定比这个虚拟点要近。
- en: '![A set of two‐dimensional points. There are 11 data points and 1 query point
    in the upper left‐hand area of the plot.](image_fi/502604c09/f09006.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![一组二维点。图的左上方有11个数据点和1个查询点。](image_fi/502604c09/f09006.png)'
- en: 'Figure 9-6: An example data set for nearest-neighbor search'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-6：最近邻搜索的示例数据集
- en: 'Since our (dummy) candidate point has infinite distance, our compatibility
    test for the root node passes. At least one of the points in the root node *could*
    be less than infinitely far away. Although this test is mathematically identical
    to the one we used for grid cells, it has one big practical difference: the size
    of the cells we are testing varies at each level of the tree. At higher levels,
    each node covers a large amount of space. As we descend lower, the spatial bounds
    tighten.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的（虚拟）候选点距离无限远，因此根节点的兼容性测试通过。根节点中的至少一个点*可能*会比无限远的距离更近。虽然这个测试在数学上与我们用于网格单元的测试相同，但它有一个很大的实际区别：我们在每一层树上测试的单元大小是不同的。在较高层次上，每个节点覆盖较大的空间；随着我们向下移动，空间边界会逐渐收紧。
- en: We prioritize which child node to search first based on the childrens’ proximity
    to the query point. After all, we ultimately want to find the closest point and
    prune as much as possible. So we consider the x and y splits and ask “Into which
    of the four quadrants would our target point fall?” In this case, our query point
    falls in the NorthWest quadrant, as shown in [Figure 9-7](#figure9-7), so we start
    there.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据子节点与查询点的接近程度来优先搜索哪个子节点。毕竟，我们最终是想找到最近的点并尽可能地修剪搜索。因此，我们考虑x和y的划分，并问：“我们的目标点会落入四个象限中的哪个？”在这种情况下，我们的查询点位于西北象限，如[图9-7](#figure9-7)所示，因此我们从这里开始。
- en: We proceed down the pointer to the NorthWest child and find ourselves focusing
    on a subset of both the space and the points as shown in [Figure 9-8](#figure9-8).
    The grayed-out nodes represent nodes that have not been explored, and the grayed-out
    points have not been checked.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们沿着指针进入到西北子节点，发现自己聚焦于一个子集，该子集包括空间和点，如[图9-8](#figure9-8)所示。灰色节点表示尚未探索的节点，灰色点表示尚未检查的点。
- en: '![The figure shows the root node with lines to indicate its partition into
    four quadrants. The query point is shown as an X in the NorthWest quadrant.](image_fi/502604c09/f09007.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![该图显示了根节点，并通过线条表示其划分为四个象限。查询点以X表示，位于西北象限。](image_fi/502604c09/f09007.png)'
- en: 'Figure 9-7: The query point falls within the NorthWest quadrant of the quadtree’s
    root node.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-7：查询点位于四叉树根节点的西北象限内。
- en: '![The diagram shows the first three levels of a quadtree. The child corresponding
    to the root node’s northwest quadrant is circled to indicate that the search is
    exploring that node.](image_fi/502604c09/f09008.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![该图显示了四叉树的前三个级别。表示根节点西北象限对应的子节点的圈，表明搜索正在探索该节点。](image_fi/502604c09/f09008.png)'
- en: 'Figure 9-8: The nearest-neighbor search for the example shown in [Figure 9-6](#figure9-6)
    starts by searching the subtree corresponding to the NorthWest quadrant of the
    root node.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-8：示例中最近邻搜索从根节点对应的西北象限子树开始，如[图9-6](#figure9-6)所示。
- en: Again, our test of spatial compatibility reveals that this node *could* contain
    our nearest neighbor. The minimum distance to the any point in the node is less
    than that of our current (dummy) candidate. We’re at another internal node, which
    means that the space is further partitioned into four subregions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们的空间兼容性测试表明这个节点*可能*包含我们最近的邻居。该节点中任何点的最小距离都小于我们当前的（虚拟）候选点的距离。我们在另一个内部节点，这意味着空间进一步被划分为四个子区域。
- en: Our search continues to the SouthWest child of the internal node in question,
    as illustrated in [Figure 9-9](#figure9-9). We choose this node because it is
    the closest to our query point. For the third time, the compatibility test passes.
    Since we’re at a leaf node, we explicitly check the distance to each point in
    that node. In this case, there is only a single point, and it is closer than our
    dummy candidate.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的搜索继续到相关内部节点的西南子节点，如[图9-9](#figure9-9)所示。我们选择这个节点，因为它离我们的查询点最近。第三次，兼容性测试通过。由于我们已经到达了叶节点，因此我们明确检查该节点中每个点的距离。在这种情况下，只有一个点，并且它比我们的虚拟候选点更近。
- en: '![The diagram shows the first three levels of a quadtree. Three nodes are solid:
    the root node, the root node’s NorthWest child, and that node’s SouthWest child.
    The current node in the search is circled.](image_fi/502604c09/f09009.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![该图显示了四叉树的前三个级别。三个节点是实心的：根节点、根节点的西北子节点以及该节点的西南子节点。当前正在搜索的节点被圈起来。](image_fi/502604c09/f09009.png)'
- en: 'Figure 9-9: At the second level of the quadtree, our search starts with the
    closest quadrant to the target point, SouthWest.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-9：在四叉树的第二级，我们的搜索从离目标点最近的象限——西南象限开始。
- en: We’ve found our first real candidate nearest neighbor! Its distance becomes
    our minimum distance so far. We can be pickier about all future points. In our
    running example of finding a nearby coffee shop, this first neighbor represents
    the closest coffee shop found so far. The distance to this point is the maximum
    distance that we’ll need to travel to get a cup of coffee. We might find closer
    coffee shops later in our search, but at least we don’t have to travel infinite
    miles. The relief is palpable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了第一个真正的候选最近邻！它的距离成为了我们迄今为止的最小距离。我们可以对所有未来的点要求更高的标准。在我们寻找附近咖啡店的示例中，第一个邻居代表了目前为止找到的最近咖啡店。到这个点的距离是我们获得一杯咖啡所需的最大距离。我们可能会在之后的搜索中找到更近的咖啡店，但至少我们不必走无穷远的路。这种解脱感是显而易见的。
- en: 'Once we’ve tested all the points in a leaf node, we return to the (internal)
    parent node and check the remainder of the children. Now that we have a real candidate
    and distance, our pruning tests have power. We check the compatibility of all
    remaining child quadrants: NorthWest, NorthEast, and SouthEast. Our distance test
    shows that we can skip the NorthWest quadrant: as shown in [Figure 9-10](#figure9-10),
    the closest possible point in its spatial bounds is further than the candidate
    we already have. It can’t possibly contain a better neighbor.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们测试了叶节点中的所有点，我们返回到（内部）父节点并检查剩余的子节点。现在我们有了一个真正的候选点和距离，我们的剪枝测试就有了意义。我们检查所有剩余子象限的兼容性：西北、东北和东南。我们的距离测试显示，我们可以跳过西北象限：如[图9-10](#figure9-10)所示，它的空间范围内最近的点比我们已有的候选点更远。它不可能包含更好的邻居。
- en: '![A diagram showing the four quadrants in the root’s NorthWest child. Lines
    from the query point to the best node so far indicate the threshold distance.
    The min distance to the current node’s NorthWest child is also indicated by a
    longer line.](image_fi/502604c09/f09010.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![该图显示了根节点西北子节点中的四个象限。图中从查询点到目前为止最佳节点的线表示阈值距离。当前节点西北子节点的最小距离也通过一条较长的线表示。](image_fi/502604c09/f09010.png)'
- en: 'Figure 9-10: An illustration of the relative distance between the best candidate
    seen so far and the current node’s NorthWest quadrant'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-10：显示到目前为止最佳候选点与当前节点的西北象限之间的相对距离
- en: We can also skip the empty NorthEast and SouthEast quadrants. Since they don’t
    have any points, they can’t have a better neighbor either. Our search can discard
    both quadrants without a distance test because their pointers will be `null` to
    indicate that no such child exists. We’ve managed to prune three of the four quadrants
    in this node as illustrated by the grayed-out quadrants in [Figure 9-11](#figure9-11).
    The two data points in the NorthWest quadrant also remain gray, because we never
    tested them.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以跳过空的东北和东南象限。由于它们没有任何点，它们也不能有更好的邻居。我们的搜索可以丢弃这两个象限，而无需进行距离测试，因为它们的指针将是`null`，表示不存在这样的子节点。如[图9-11](#figure9-11)所示，我们成功地修剪了该节点的四个象限中的三个。西北象限中的两个数据点也保持灰显，因为我们从未测试过它们。
- en: '![The search has returned to the root node’s NorthWest child. Three of the
    node’s quadrants are grayed out to indicate they were pruned from the search.](image_fi/502604c09/f09011.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![搜索已返回到根节点的西北子节点。该节点的三个象限已被灰显，表示它们已被从搜索中修剪掉。](image_fi/502604c09/f09011.png)'
- en: 'Figure 9-11: The nearest-neighbor search is able to skip three of the node’s
    four quadrants.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-11：最近邻搜索能够跳过该节点的四个象限中的三个。
- en: Once we’ve finished checking the quadrants within an internal node, we return
    to its parent and repeat the process. The next closest quadrant is SouthWest,
    which our pruning test confirms is close enough to possibly contain a better neighbor,
    as shown in [Figure 9-12](#figure9-12).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成检查内部节点的象限，我们返回到其父节点并重复此过程。下一个最接近的象限是西南象限，我们的修剪测试确认它足够接近，可能包含更好的邻居，如[图9-12](#figure9-12)所示。
- en: Any time we find a child that, according to our simple distance test, *could*
    contain a closer point, we proceed down that pathway to check if there are indeed
    closer neighbors. In this case, our search descends into the SouthWest quadrant.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们找到一个子节点，按照我们的简单距离测试，它*可能*包含一个更近的点时，我们就沿着该路径继续前进，检查是否确实存在更近的邻居。在这种情况下，我们的搜索向下遍历到了西南象限。
- en: '![An illustration of pruning at the root node. The query point is shown with
    an X, and a line shows the distance to the best neighbor so far. A second line
    shows the (smaller) distance to the root’s SouthWest child.](image_fi/502604c09/f09012.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![根节点修剪示意图。查询点以X表示，一条线表示到目前为止最佳邻居的距离。第二条线显示到根节点的西南子节点的（较小的）距离。](image_fi/502604c09/f09012.png)'
- en: 'Figure 9-12: A pruning test where the candidate quadrant could include a closer
    neighbor than the current best point'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-12：修剪测试，其中候选象限可能包含比当前最佳点更接近的邻居
- en: At the next level, four potential quadrants again vie for our attention. Armed
    with a real candidate point and its corresponding distance, we can aggressively
    prune our search, as shown in [Figure 9-13](#figure9-13). We check the NorthWest
    quadrant (and its single point) because it falls within our distance threshold.
    We can skip the other three quadrants; the NorthEast and SouthWest quadrants are
    both empty and thus have null child pointers, and we use a distance test to confirm
    that the SouthEast quadrant is too far away to contain a better neighbor.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一级，四个潜在象限再次争夺我们的注意力。我们有了一个真实的候选点及其对应的距离，可以积极地修剪搜索，如[图9-13](#figure9-13)所示。我们检查西北象限（以及它的唯一一个点），因为它在我们的距离阈值内。我们可以跳过其他三个象限；东北和西南象限都是空的，因此它们的子指针为null，我们使用距离测试确认东南象限距离太远，无法包含更好的邻居。
- en: This time when we return to the root node, we can prune out the two remaining
    children, as shown in [Figure 9-14](#figure9-14).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这次当我们返回根节点时，我们可以修剪掉剩余的两个子节点，如[图9-14](#figure9-14)所示。
- en: The remote expanses of both the NorthEast and SouthEast quadrants lie well outside
    our distance threshold.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 东北和东南象限的远端显著超出了我们的距离阈值。
- en: '![The search has progressed down the entire branch corresponding to the root
    node’s SouthWest child. That child has three of its four quadrants grayed out.
    ](image_fi/502604c09/f09013.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![搜索已遍历到与根节点的西南子节点对应的整个分支。该子节点的四个象限中有三个已被灰显。](image_fi/502604c09/f09013.png)'
- en: 'Figure 9-13: While checking the root node’s SouthWest quadrant, the nearest-neighbor
    search can again skip three of the four subquadrants.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-13：在检查根节点的西南象限时，最近邻搜索可以再次跳过四个子象限中的三个。
- en: '![The search has returned to the root node. Two of the root node’s quadrants
    are grayed out. Nine of the 11 data points remain gray.](image_fi/502604c09/f09014.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![搜索已返回到根节点。根节点的两个象限被灰色标出。11个数据点中的9个保持为灰色。](image_fi/502604c09/f09014.png)'
- en: 'Figure 9-14: Upon returning to the root node of the quadtree, the search can
    skip two of that node’s quadrants.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-14：返回四叉树的根节点后，搜索可以跳过该节点的两个象限。
- en: Nearest-Neighbor Search Code
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最近邻搜索代码
- en: 'To simplify our implementation of the nearest-neighbor search code, we start
    with a helper function to compute the distance from the target point (*x*, *y*)
    to a node. The code for checking the minimum distance to a node is similar to
    the minimum distance code presented for grids in the last chapter:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化最近邻搜索代码的实现，我们首先定义一个辅助函数来计算目标点（*x*，*y*）到某个节点的距离。检查最小距离的代码与上一章中介绍的网格最小距离代码类似：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: However, in this case, the code does not need to compute the minimum and maximum
    bounds for the node, since each node stores them explicitly.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，代码不需要计算节点的最小和最大边界，因为每个节点都明确地存储了这些边界。
- en: The main search algorithm uses the same recursive formulation described for
    other tree-based methods. Our implementation of this search algorithm includes
    a parameter `best_dist` that represents the distance so far. By passing `best_dist`
    to our search function, we can simplify the pruning logic. If the minimum distance
    to the current node is greater than the best distance so far, we can terminate
    that branch of the search. The function then returns a *closer* point if it finds
    one and `null` otherwise. It’s important to note that in this implementation,
    a return value of `null` means that there are no points in the current node closer
    than `best_dist`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的搜索算法使用与其他基于树的方法相同的递归公式。我们对该搜索算法的实现包括一个参数`best_dist`，表示目前为止的最短距离。通过将`best_dist`传递给我们的搜索函数，我们可以简化剪枝逻辑。如果当前节点的最小距离大于目前为止的最佳距离，我们可以终止该分支的搜索。然后，如果找到更近的点，函数会返回一个*更近*的点，否则返回`null`。需要注意的是，在这个实现中，返回`null`意味着当前节点内没有比`best_dist`更近的点。
- en: 'We use a thin wrapper that passes along the root node and an initial infinite
    distance:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个简单的包装器，传递根节点和初始的无限距离：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our wrapper function for nearest-neighbor search does not check that the target
    point falls within the quadtree bounds. This allows us to use the code to find
    neighbors within the tree for target points that fall outside the tree’s bounds,
    increasing the usefulness of the code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最近邻搜索包装函数没有检查目标点是否落在四叉树的边界内。这使我们能够使用代码找到树内邻居，即使目标点在树的边界之外，从而提高代码的实用性。
- en: 'Here’s the code for recursively searching the nodes:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是递归搜索节点的代码：
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The function starts with the pruning test, skipping the node and returning `null`
    if no point could be closer than `best_dist` ❶. The code then checks if it is
    at a leaf node ❷. If it has reached a leaf, it uses a `FOR` loop to check whether
    each point is closer than `best_dist`, updating `best_dist` and `best_candidate`
    if so. At the end of this loop, we return `best_candidate`, which has the value
    `null` if we haven’t found a new closer point.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 函数首先进行剪枝测试，如果没有任何点比`best_dist`更近，则跳过该节点并返回`null` ❶。然后，代码检查是否到达叶节点 ❷。如果已到达叶节点，它会使用`FOR`循环检查每个点是否比`best_dist`更近，如果是，则更新`best_dist`和`best_candidate`。在这个循环结束时，我们返回`best_candidate`，如果没有找到更近的点，它的值将是`null`。
- en: The next block of code handles the logic for an internal node. We have only
    made it this far if the node isn’t a leaf and thus doesn’t have any candidate
    points. Some basic numerical tests and integer manipulation control the order
    that the code searches the children, allowing the code to search the closest child
    first and then expand to the rest of the children. The code starts by computing
    into which x and y bin the candidate point should fall ❸, adjusting the value
    so that `xbin` and `ybin` both fall within [0, 1], and thus indicates the closest
    child node. This adjustment is necessary because, for many internal nodes, our
    target point will lie completely outside the 2×2 grid represented by the current
    node.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码块处理内部节点的逻辑。只有当节点不是叶节点时，我们才会到达这里，因此它没有任何候选点。一些基本的数值测试和整数操作控制着代码搜索子节点的顺序，允许代码先搜索最接近的子节点，然后再扩展到其他子节点。代码首先计算候选点应该落入哪个x和y的区域
    ❸，调整值，使得`xbin`和`ybin`都落在[0, 1]范围内，从而指示出最接近的子节点。这一调整是必要的，因为对于许多内部节点，我们的目标点可能完全位于当前节点表示的2×2网格之外。
- en: We then recursively explore the non-null children using a pair of nested `FOR`
    loops to iterate over the pairs ❹. Each time we check whether we find a closer
    point (represented by `quad_best != null)` and, if so, update both `best_candidate`
    and `best_dist` ❺. At the end of the function, we return `best_candidate`. As
    in the case of the leaf node, `best_candidate` may be `null` if we haven’t found
    a point closer than the original `best_dist`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用一对嵌套的`FOR`循环递归地探索非空的子节点，遍历这些对子 ❹。每次我们检查是否找到更接近的点（由`quad_best != null`表示），如果找到了，就更新`best_candidate`和`best_dist`
    ❺。函数结束时，我们返回`best_candidate`。与叶节点的情况一样，如果我们没有找到比原始`best_dist`更近的点，`best_candidate`可能会是`null`。
- en: k-d Trees
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: k-d 树
- en: We’ve solved the problem of dynamic splits for two dimensions, so now it’s time
    to turn our attention to searching for points or nearest neighbors in three or
    more dimensions using k-d trees. We’ve already seen the disappointment that can
    result when we don’t account for all the relevant attributes in our coffee. Higher-dimensional
    problems are common whenever we’re looking for similar points in data sets, such
    as searching for similar conditions (temperature, pressure, humidity) in a weather
    data set.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经解决了两维的动态划分问题，现在是时候将注意力转向使用k-d树在三维或更多维度中查找点或最近邻的任务了。我们已经看到，当我们没有考虑到咖啡中的所有相关属性时，可能会带来失望。在数据集中寻找相似点时，高维问题很常见，例如在天气数据集中寻找相似的条件（温度、压力、湿度）。
- en: In theory, we could scale quadtrees by simply splitting along more dimensions.
    *Octtrees*, for example, are three-dimensional versions that split into eight
    subnodes at each level. Eight-way splits may not seem too bad, but this approach
    clearly doesn’t scale gracefully with the number of dimensions. If we want to
    build a tree over *D*-dimensional data, we need to split along all *D* dimensions
    at once, giving us 2^(*D*) children for each internal node. If we were building
    a data structure over weather data containing temperature, pressure, humidity,
    precipitation, and wind speed, we would be using five-dimensional points and splitting
    32 subtrees at each level! This immense overhead is the same problem we found
    when scaling grids to higher dimensions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，我们可以通过简单地沿着更多的维度进行划分来扩展四叉树。例如，*八叉树*是三维版本，每一层都划分为八个子节点。八向划分看起来似乎还不算太糟，但这种方法显然无法随着维度数量的增加而优雅扩展。如果我们要构建一个覆盖*D*维数据的树结构，我们需要一次性沿所有*D*维度进行划分，这样每个内部节点就会有2^(*D*)个子节点。如果我们在处理包含温度、压力、湿度、降水量和风速的天气数据时，我们将使用五维点，每一层就需要划分32个子树！这种巨大的开销是我们在将网格扩展到更高维度时遇到的相同问题。
- en: To effectively scale to higher dimensions, we need to rein in the branching
    factor. There are a variety of powerful data structures designed to enable efficient
    proximity search in higher dimensions. One example is the k-d tree, which builds
    off similar concepts as the quadtree.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地扩展到更高的维度，我们需要控制分支因子。有多种强大的数据结构设计用于高维空间中的高效近邻搜索。一个例子是k-d树，它基于与四叉树类似的概念构建。
- en: k-d Tree Structure
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: k-d 树结构
- en: 'A *k-d tree* is a spatial data structure that combines the spatial partitioning
    of quadtrees with the binary branching factor of a binary search tree, giving
    us the best of both worlds. Instead of splitting along every dimension at every
    level, the k-d tree chooses a single dimension and splits the data along that
    dimension. Each internal node thus partitions the data into exactly two children:
    a left child whose points fall below (or equal to) the split value, and a right
    child whose points fall above the split value.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*k-d 树*是一种空间数据结构，它结合了四叉树的空间划分和二叉搜索树的二叉分支因子，兼具两者的优点。k-d 树不是在每一层沿每个维度进行分割，而是选择一个维度并沿该维度分割数据。因此，每个内部节点将数据分割成两个子节点：左子节点的点小于（或等于）分割值，右子节点的点大于分割值。'
- en: When working with k-d trees, we lose the regular grid-like structure of the
    uniform quadtree, but, in exchange, we return to the two-way branching factor
    we know and love from binary search trees. This ability to partition along a single
    dimension in turn allows the k-d tree to scale to higher-dimensional data sets.
    We no longer need to split into 2^(*D*) children at each level. [Figure 9-15](#figure9-15)
    shows an example k-d tree.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 k-d 树时，我们失去了均匀四叉树的规则网格结构，但作为交换，我们回到了我们熟悉并喜爱的二叉搜索树的二叉分支因子。这种沿单一维度分割的能力使得
    k-d 树能够扩展到更高维度的数据集。我们不再需要在每一层分割为 2^(*D*) 个子节点。[图 9-15](#figure9-15) 展示了一个 k-d
    树的示例。
- en: '![The root node of the k‐d tree is split along the y‐dimension. Each of the
    two resulting children is split along the x‐dimension.](image_fi/502604c09/f09015.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![k-d 树的根节点沿 y 维度进行分割。每个产生的子节点沿 x 维度进行分割。](image_fi/502604c09/f09015.png)'
- en: 'Figure 9-15: A k-d tree split along a single dimension at each level'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-15：k-d 树在每一层沿单一维度进行分割
- en: 'A k-d tree can adjust more flexibly to the structure of the data than quadtrees.
    We’re not constrained to split in the midpoint of every dimension at once. Instead
    of partitioning space into 2^(*D*) equally sized grid cells, we can choose a split
    dimension and value that are best suited to the data at each node. Each internal
    node thus stores both the dimension along which we’re partitioning (`split_dim`)
    and the value (`split_val`), with points assigned to the left child if their value
    in that one dimension is less than or equal to the node’s split value:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与四叉树相比，k-d 树可以更灵活地适应数据的结构。我们不再局限于在每个维度的中点进行分割。与将空间划分为 2^(*D*) 个大小相等的网格单元不同，我们可以选择一个分割维度和适合当前节点的数据的分割值。因此，每个内部节点都存储着我们正在进行分割的维度（`split_dim`）和分割值（`split_val`），如果点在该维度上的值小于或等于节点的分割值，则将其分配给左子节点：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Rather than split along alternating axes, producing partitioning similar to
    that of the quadtree in [Figure 9-15](#figure9-15), we can tailor our tree structure
    by choosing splits based on the composition of the data points within the current
    node, thus allowing us to make splits that will better aid our future searches.
    We might choose the split value based on the overall bounds of the node, such
    as splitting in the middle of the widest dimension. Or we could choose the split
    value based on the distribution of data points, such as splitting at the middle
    of the range or the median of the points’ values along the split dimension. The
    difference between these two options is illustrated in [Figure 9-16](#figure9-16).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再像在[图 9-15](#figure9-15)中那样沿交替的轴进行分割，这样的分割方式类似于四叉树。我们可以通过根据当前节点内数据点的组成来选择分割维度，从而定制我们的树结构，使分割更有利于未来的搜索。我们可能根据节点的整体边界来选择分割值，比如在最宽的维度的中间进行分割。或者我们可以根据数据点的分布来选择分割值，比如在分割维度上选择中位数或范围的中点。这两种选择之间的差异在[图
    9-16](#figure9-16)中有所展示。
- en: '![The left box shows points partitioned at the middle of the x‐dimension, splitting
    the space in half. The right box shows points partitioned at the median value
    along the x‐dimension, resulting in two boxes with an approximately equal number
    of points but different sizes.](image_fi/502604c09/f09016b.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![左边的框显示了沿 x 维度中点分割的点，空间被一分为二。右边的框显示了沿 x 维度的中位数值分割的点，产生了两个具有大致相等数量的点但大小不同的框。](image_fi/502604c09/f09016b.png)'
- en: 'Figure 9-16: A node split at the middle (left) and median (right)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-16：一个节点分别在中点（左）和中位数（右）进行分割
- en: 'The flexible structure of the k-d tree means we need to take additional care
    when dealing with nodes’ spatial bounds. Unlike the uniform quadtree’s square
    grid cells, the nodes of a k-d tree cover multidimensional rectangles of the overall
    search space. The width in each dimension can be completely different. Some nodes
    might be square-ish, while others might be long and thin. We represent a node’s
    area by explicitly tracking the multidimensional rectangle defining its spatial
    bounds—the minimum and maximum values in each dimension. Since we can have an
    arbitrary number of dimensions, we store the bounds in two arrays, `x_min` and
    `x_max`, where `x_min[d]` represents the lowest value along dimension `d` contained
    within the current node and `x_max[d]` represents the highest. All points within
    the node satisfy:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: k-d树的灵活结构意味着我们在处理节点的空间边界时需要额外小心。与统一的四叉树的方形网格单元不同，k-d树的节点覆盖了整体搜索空间的多维矩形。每个维度的宽度可能完全不同。一些节点可能是接近方形的，而其他的则可能是长而窄的。我们通过显式追踪定义其空间边界的多维矩形来表示一个节点的区域——每个维度的最小值和最大值。由于我们可以有任意数量的维度，因此我们将边界存储在两个数组中，`x_min`和`x_max`，其中`x_min[d]`表示当前节点内维度`d`的最小值，`x_max[d]`表示最大值。所有在该节点内的点都满足：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As a result of its complexity, each k-d tree node stores a significant amount
    of information. While this might initially seem like expensive overhead, as we’ll
    see in this section, the cost is offset by the power and flexibility of tree itself.
    As with every other data structure in this book, we are making an explicit tradeoff
    in terms of memory, data structure complexity, and later algorithmic efficiency.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其复杂性，每个k-d树节点都存储了大量信息。虽然这看起来可能是昂贵的开销，但正如我们在本节中将看到的，成本被树本身的强大功能和灵活性所抵消。与本书中的其他数据结构一样，我们在内存、数据结构复杂性和后续算法效率之间做出了显式的权衡。
- en: 'Here is an example composite data structure for the `KDTreeNode`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`KDTreeNode`的一个示例复合数据结构：
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, we use an array to represent each point, allowing it to have arbitrary
    dimensions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用数组表示每个点，从而使其具有任意维度。
- en: As with other trees in this book, we can wrap the nodes in an outer data structure
    such as a `KDTree`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 和本书中的其他树一样，我们可以将节点封装在外部数据结构中，如`KDTree`。
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is helpful to store the number of dimensions in this wrapper data structure
    to check for consistency during operations such as insertion, deletion, or search.
    The value of `num_dimensions` is set at time of the k-d tree’s creation and remains
    fixed for this tree.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个封装数据结构中存储维度的数量有助于在执行插入、删除或搜索等操作时检查一致性。`num_dimensions`的值在创建k-d树时设置，并且对于该树保持不变。
- en: 'This flexibility of choosing a strategy for splitting nodes illustrates the
    true power of the k-d tree: we’re augmenting the spatial partitioning of quadtrees
    to further adapt to the data. If our points are clustered, we choose splits that
    provide the most information by focusing on those regions. [Figure 9-17](#figure9-17)
    demonstrates this dynamic partitioning.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 选择分割节点策略的灵活性展示了k-d树的真正优势：我们在四叉树的空间划分基础上进行了增强，进一步适应数据。如果我们的点集是聚集的，我们会选择那些能够提供最多信息的分割方式，重点关注这些区域。[图
    9-17](#figure9-17)展示了这种动态划分。
- en: '![The figure of a k‐d tree with horizontal or vertical lines representing the
    different splits at each level. The subdivisions are all of different dimensions.](image_fi/502604c09/f09017.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![k-d树的图示，水平或垂直线表示每个层次上的不同分割，所有子区划分的维度不同。](image_fi/502604c09/f09017.png)'
- en: 'Figure 9-17: The spatial partition created by a k-d tree'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-17：k-d树创建的空间划分
- en: Consider our ongoing task of locating nearby coffee shops. If we are taking
    a road trip along Interstate 95 from Florida to Maine, we could preprocess the
    data to store only those coffee shops within 50 miles of the highway.[Figure 9-18](#figure9-18)
    shows an example distribution of this shape.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在进行定位附近咖啡店的任务。如果我们沿着95号州际公路从佛罗里达到缅因州进行自驾游，我们可以预处理数据，仅存储离高速公路50英里以内的咖啡店。[图
    9-18](#figure9-18)展示了这种形状的分布示例。
- en: 'This prefiltering helps limit the search space to only coffee shops near the
    highway, yet we can make our searches even more efficient by storing these locations
    in a spatial data structure. We want to narrow our search to the appropriate region
    along the highway as well. After all, there is no need to check coffee shops in
    Massachusetts while we are still in South Carolina. We quickly see that a uniform
    partitioning scheme is far from ideal: our trip covers over 1,500 miles of mostly
    northward driving. Since we have already filtered to only shops along the highway,
    we do not gain as much pruning from partitioning uniformly east and west as well.
    We can increase the amount of pruning, and thus decrease the search cost, by biasing
    our partitions along the north-south direction.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这种预过滤帮助将搜索空间限制为仅靠近高速公路的咖啡店，但我们可以通过将这些位置存储在空间数据结构中，使搜索更加高效。我们还希望将搜索范围缩小到高速公路上的适当区域。毕竟，当我们还在南卡罗来纳州时，没有必要检查马萨诸塞州的咖啡店。我们很快发现，均匀的分区方案远非理想：我们的旅程涵盖了超过1500英里的大部分北向行驶。由于我们已经过滤到仅沿高速公路的商店，因此从东西方向均匀分区所带来的剪枝效果不大。通过在南北方向上偏向分区，我们可以增加剪枝的数量，从而减少搜索成本。
- en: To give another analogy, if quadtrees are the daily routine of a city planner
    following rigid regulations to divide up a map, k-d trees represent a city planner
    with a wider range of tools at their disposal. They’re no longer constrained to
    divide each plot into perfect squares. Instead, they have the flexibility to partition
    the space according to the distribution of actual points. Our city planner chooses
    the widest dimension to split in order to minimize long, narrow zones. They also
    use the median point along this dimension to provide a balanced tree. The result
    might not always look as orderly as the quadtrees squares, but it can be much
    more effective.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 再举个例子，如果四叉树是一个城市规划者按照严格的规定划分地图的日常工作，那么k-d树就像一个拥有更多工具的城市规划者。他们不再局限于将每个地块划分为完美的正方形。相反，他们可以根据实际点的分布灵活地划分空间。我们的城市规划者选择最大的维度进行分割，以尽量减少狭长的区域。他们还使用该维度上的中位点来提供平衡的树结构。结果可能不像四叉树的正方形那样整齐，但它可能更有效。
- en: '![A scatterplot of points in the shape of Route 95.](image_fi/502604c09/f09018.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![形状类似于95号公路的点散点图。](image_fi/502604c09/f09018.png)'
- en: 'Figure 9-18: An example of how coffee shops might be distributed along a major
    highway'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-18：咖啡店在主要高速公路上的分布示例
- en: Tighter Spatial Bounds
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更紧密的空间边界
- en: We can often further improve a spatial tree’s pruning power by tracking the
    bounding box of all the points falling within a given node instead of the node’s
    total spatial bounds. This changes our pruning question from “Could a nearest-neighbor
    candidate exist in the space covered by the node?” to “Could a nearest-neighbor
    candidate exist in the bounding boxes of actual points within the node?” While
    this might seem like a small change, depending on what logic we use to split the
    nodes, we can see significant savings, as shown in [Figure 9-19](#figure9-19).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常可以通过跟踪落在给定节点内所有点的边界框，而不是节点的总空间边界，进一步提高空间树的剪枝能力。这将我们的剪枝问题从“在节点覆盖的空间中是否可能存在最近邻候选点？”转变为“在节点内实际点的边界框中是否可能存在最近邻候选点？”虽然这看起来是一个小变化，但根据我们用于分割节点的逻辑，可能会看到显著的节省，如[图9-19](#figure9-19)所示。
- en: '![The tight bounding box of a k‐d tree node is shown as a dashed box bounding
    the points within the node.](image_fi/502604c09/f09019.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![k-d树节点的紧密边界框显示为一个虚线框，框住节点内的点。](image_fi/502604c09/f09019.png)'
- en: 'Figure 9-19: The bounding box of points within a k-d tree node'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图9-19：k-d树节点中点的边界框
- en: If we use these tighter bounding boxes during node construction, we can better
    adapt to the data. We are no longer splitting based on the entire possible spatial
    region, but rather on the region occupied by actual points. The resulting k-d
    tree structure looks like the one in [Figure 9-20](#figure9-20). The black boxes
    indicate the tight bounding boxes at each node. The gray points and lines are
    shown to place the nodes’ bounds in the context of the rest of the data set.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在节点构建过程中使用这些更紧密的边界框，我们可以更好地适应数据。我们不再是基于整个可能的空间区域进行划分，而是基于实际点所占据的区域进行划分。结果的k-d树结构如[图9-20](#figure9-20)所示。黑色框表示每个节点的紧密边界框。灰色点和线则显示节点的边界框与数据集其余部分的关系。
- en: '![Each node in the k‐d tree is shown as a set of points, and a tight bounding
    box is laid over the grayed‐out full data set.](image_fi/502604c09/f09020.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图中的每个 k-d 树节点显示为一组点，紧密边界框覆盖了灰色区域的完整数据集。](image_fi/502604c09/f09020.png)'
- en: 'Figure 9-20: A three-level k-d tree and the bounding boxes for each node'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9-20：一个三层的 k-d 树及每个节点的边界框
- en: During a search, we use the black boxes (tight bounding boxes) for pruning.
    As you can see from the figure, the resulting regions can be significantly smaller,
    allowing us to prune much more aggressively. Since the tight bounding box is smaller,
    it will often have a greater minimum distance to our query point.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索过程中，我们使用黑盒（紧密边界框）来进行剪枝。正如图中所示，得到的区域可以显著缩小，从而使我们能够更积极地进行剪枝。由于紧密边界框较小，它通常与查询点的最小距离更大。
- en: 'We can use a simple helper function to compute the tight bounding boxes from
    a set of points represented as arrays ([Listing 9-1](#listing9-1)):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个简单的辅助函数来计算由数组表示的一组点的紧密边界框（[列表 9-1](#listing9-1)）：
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 9-1: A helper function to compute the tight bounding box of the points
    in a node'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 9-1：计算节点中点的紧密边界框的辅助函数
- en: The code extracts the number of points and number of dimensions from the input
    data ❶. It then creates new arrays `L` and `H` to hold the low and high bounds,
    respectively, ❷ and seeds them with the coordinates of the first point in our
    array ❸. The code then iterates through the remaining points in the array and
    checks whether any of them fall outside the bounds ❹. If so, it extends the bounds.
    The code ends by returning the two arrays ❺.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码从输入数据中提取点的数量和维度的数量 ❶。然后，它创建新的数组 `L` 和 `H` 来分别存储低值和高值边界 ❷，并用数组中第一个点的坐标初始化它们
    ❸。接着，代码遍历数组中剩余的点，并检查是否有点超出了边界 ❹。如果有，它会扩展边界。代码最后返回这两个数组 ❺。
- en: This helper function also illustrates the benefit of prechecking that all our
    points contain the correct number of dimensions in the `KDTree`’s wrapper function.
    This check ensures that we do not try to access our invalid array entries for
    our data points.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个辅助函数还展示了在 `KDTree` 的包装函数中预先检查所有点是否包含正确的维度数量的好处。这个检查确保我们不会尝试访问数据点中无效的数组条目。
- en: Of course, tracking these additional bounds adds significant complexity when
    we start dealing with dynamic changes. Adding points to a k-d tree can increase
    the bounds for a given node. Similarly, removing nodes may shrink the bounds.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当我们开始处理动态变化时，跟踪这些额外的边界会增加复杂性。向 k-d 树中添加点可能会增加给定节点的边界。同样，删除节点可能会缩小边界。
- en: Building k-d Trees
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建 k-d 树
- en: 'Construction of a k-d tree uses a recursive process similar to the one for
    binary search trees, but with a few major differences. We start with all the data
    points and divide them into two subsets by picking a splitting dimension and value.
    This process repeats at each level until we hit our termination criteria: a minimum
    number of points left at the node, a minimum width, or a max depth. Generally,
    we use two of these tests, minimum number of points and minimum width, but using
    at least one of the last two tests is essential to avoid infinite recursion when
    you have duplicate data points.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 k-d 树使用一个递归过程，类似于二叉搜索树的构建过程，但有一些主要的区别。我们从所有数据点开始，并通过选择一个分割维度和分割值将它们分成两个子集。这个过程在每一层重复，直到满足终止条件：节点中剩余的点数最小、宽度最小或深度最大。通常，我们使用两个测试：最小点数和最小宽度，但至少使用最后两个测试中的一个是必要的，以避免在有重复数据点时发生无限递归。
- en: 'We start with a wrapper function to check that our data is valid:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个包装函数开始，检查数据是否有效：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The code starts by checking that all points have the correct dimensionality.
    It then checks that there are points from which to build the tree. If so, it allocates
    a new root node (overwriting the previous tree) and recursively builds the k-d
    tree using the function below. Otherwise, it sets the root to `null` to indicate
    an empty tree.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先检查所有点是否具有正确的维度。然后，它检查是否有点可以用来构建树。如果有，代码会分配一个新的根节点（覆盖先前的树），并使用下面的函数递归地构建
    k-d 树。否则，它将根节点设置为 `null`，表示空树。
- en: The primary difference between k-d tree and quadtree construction is that k-d
    trees require us to choose a single split dimension at each level. If we are using
    tight bounding boxes, we also need to compute the bounding boxes over *D* dimensions.
    While these changes make the code a little longer (with extra loops over *D*),
    they don’t add any real complexity. The code for building a k-d tree recursively
    partitions our set of points among the child nodes until we reach the termination
    criteria.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: k-d 树与四叉树构建的主要区别在于，k-d 树要求我们在每一层选择一个单独的分割维度。如果我们使用紧密边界框，我们还需要计算 *D* 维度上的边界框。尽管这些变化使得代码略显冗长（增加了对
    *D* 的额外循环），但并没有增加任何实际的复杂性。构建 k-d 树的代码会递归地将我们的点集划分到子节点中，直到满足终止条件。
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code starts with bookkeeping to fill in the information needed at each
    node. We record the essential details, such as the number of points and number
    of dimensions of the current points ❶. Then the function loops over all the points,
    computing the tight bounding box for the node ❷ using the helper function in [Listing
    9-1](#listing9-1).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从记账开始，填充每个节点所需的信息。我们记录一些必要的细节，比如当前点的数量和维度数量 ❶。然后，函数遍历所有点，使用[清单 9-1](#listing9-1)中的辅助函数计算该节点的紧密边界框
    ❷。
- en: Once we have the bounds, the code loops over each of the dimensions to find
    the widest dimension ❸. We use this loop for one of the stopping conditions for
    the recursion (not splitting a node that is too small). If the node does not meet
    the conditions to keep splitting, the code stores all the points in a list at
    the leaf ❹. Otherwise, the code picks a split dimension and a split value for
    the node ❺. The code iterates over the current set of points, partitioning them
    into two arrays, `left_pts` and `right_pts`, according to the split dimension
    and value ❻. Those arrays are used to recursively build the two children nodes
    ❼.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获得边界，代码会遍历每个维度，找出最宽的维度 ❸。我们使用这个循环作为递归的一个停止条件（不再对过小的节点进行分割）。如果节点不符合继续分割的条件，代码会将所有的点存储在叶节点的一个列表中
    ❹。否则，代码会为该节点选择一个分割维度和分割值 ❺。代码会遍历当前点集，将其根据分割维度和分割值划分成两个数组，`left_pts` 和 `right_pts`
    ❻。这两个数组将用于递归地构建两个子节点 ❼。
- en: 'One approach for choosing `split_dim` and `split_val` is to split along the
    middle of the widest dimension. The code for this is relatively simple and most
    of it can be incorporated into the initial block that finds the widest dimension
    ❸:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 选择 `split_dim` 和 `split_val` 的一种方法是沿着最宽维度的中间进行分割。这段代码相对简单，而且大部分可以被并入到找到最宽维度
    ❸ 的初始代码块中。
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'and then later setting the split dimension and the value at ❺:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 ❺ 处设置分割维度和值：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Bulk construction of k-d trees has a significant advantage over dynamically
    inserting and removing points. By considering all the data points during construction,
    we can better adapt the structure of the tree to the data. We choose splits based
    on all the data points instead of the subset inserted so far.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 批量构建 k-d 树相较于动态插入和删除点有着显著的优势。通过在构建过程中考虑所有数据点，我们可以更好地调整树的结构以适应数据。我们选择的分割是基于所有数据点的，而不是目前为止插入的子集。
- en: k-d Tree Operations
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: k-d 树操作
- en: The basic operations of inserting points, deleting points, and searching the
    k-d tree follow the same approach as with quadtrees. We start all operations at
    the top of the tree (root node) and use the split values to navigate down the
    appropriate branches. The major difference is that, instead of picking which of
    four quadrants to explore, we use `split_dim` and test against `split_val` to
    choose one of two children. As the high-level concepts are similar to those presented
    for the quadtree, we will not go into the code in detail for each one. Instead,
    let’s look at some of the differences.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 插入点、删除点和搜索 k-d 树的基本操作与四叉树的操作方法相同。我们从树的顶部（根节点）开始所有操作，并使用分割值来沿着相应的分支导航。主要的区别是，选择分割的不是四个象限中的一个，而是使用`split_dim`并根据`split_val`来选择两个子节点之一。由于高层概念与四叉树中介绍的类似，我们不会对每一项操作的代码进行详细讲解。相反，让我们来看看一些区别。
- en: Insertion When inserting points into a k-d tree node, we use `split_dim` and
    `split_val` to determine which branch to take. We split leaf nodes if they meet
    our split condition using the same approach as we would use during bulk construction.
    Finally, if we are tracking the tight bounding box for each node, we need to update
    the bounds to account for the new point. Since we are adding points, this update
    will always increase the size of the bounding box.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入 当向k-d树节点插入点时，我们使用 `split_dim` 和 `split_val` 来决定应该选择哪一分支。如果叶节点满足分割条件，我们将其分割，方法与批量构建时使用的方式相同。最后，如果我们正在跟踪每个节点的紧密边界框，则需要更新边界以考虑新加入的点。由于我们在添加点，这个更新总会增加边界框的大小。
- en: '[PRE20]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This code iterates over each dimension of the new point, checks whether it falls
    outside the bounding box, and, if so, updates the bounds.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码遍历新点的每个维度，检查其是否超出了边界框，如果超出，则更新边界。
- en: Deletion When deleting points in a k-d tree, we use `split_dim` and `split_val`
    to determine which branch to take during our search for the point. After deleting
    a node, we return to the root of the tree. At each node along the way, we check
    whether the bounds can be tightened (using the points in a leaf or the two children’s
    bounding boxes for an internal node). We also check whether internal nodes can
    be collapsed.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 在删除k-d树中的点时，我们使用 `split_dim` 和 `split_val` 来决定在查找过程中应该选择哪一分支。删除节点后，我们回到树的根节点。在沿途的每个节点上，我们检查是否可以缩小边界（通过叶节点中的点或内部节点的两个子节点的边界框）。我们还会检查内部节点是否可以被合并。
- en: 'Search The key difference in the search operations between a quadtree and a
    k-d tree is in testing whether we can prune nodes. For example, we can compute
    the Euclidean distance between a point *x* and the closest possible point in a
    node’s (non-uniform, *D*-dimensional) bounding box using an extension of the formula
    ![i09001](image_fi/502604c09/i09001.png) that we used for quadtrees and grids.
    We start by competing the minimum distance from the point to the node’s spatial
    bounds along each individual dimension:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找 四叉树与k-d树在查找操作中的关键区别在于是否可以修剪节点。例如，我们可以通过扩展公式 ![i09001](image_fi/502604c09/i09001.png)
    来计算点 *x* 与节点（非均匀的，*D* 维度）边界框内最接近点的欧几里得距离，这个公式是我们在四叉树和网格中使用过的。我们首先计算点到节点空间边界在每个维度上的最小距离：
- en: IF *x*[*d*] < *x*[min][*d*] THEN *dist*[d] = *x*[min][*d*] − *x*[*d*]
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *x*[*d*] < *x*[min][*d*] 则 *dist*[d] = *x*[min][*d*] − *x*[*d*]
- en: IF *x*[min][*d*] ≤ *x* ≤ *x*[max][*d*] THEN *dist*[d] = 0
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *x*[min][*d*] ≤ *x* ≤ *x*[max][*d*] 则 *dist*[d] = 0
- en: IF *x*[*d*] > *x*[max][*d*] THEN *dist*[d] = *x*[*d*] − *x*[max][*d*]
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *x*[*d*] > *x*[max][*d*] 则 *dist*[d] = *x*[*d*] − *x*[max][*d*]
- en: 'where *x*[*d*] represents the query point’s *d*th dimension, and *x*[min][*d*]and
    *x*[max][*d*] represent the node’s low and high bounds in the *d*thdimension.
    Then we compute the sum of squared distances along each dimension and take the
    square root. We can implement this entire computation as a `WHILE` loop over the
    dimensions:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其中 *x*[*d*] 表示查询点的 *d* 维度，*x*[min][*d*] 和 *x*[max][*d*] 表示节点在 *d* 维度上的低和高边界。然后，我们计算每个维度上平方距离的总和并取平方根。我们可以将整个计算过程实现为一个在维度上进行的
    `WHILE` 循环：
- en: '[PRE21]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that k-d trees can be more sensitive to additions and deletions than quadtrees.
    While both trees can become unbalanced due to the splitting rules and the distribution
    of points, k-d trees’ splits are chosen based on the data at the time. If we significantly
    change the distribution of points, the original split values may no longer be
    good ones. During bulk construction, we can adapt the splits to the data at hand,
    considering such factors as the depth of the tree, whether it is balanced, and
    the tightness of the nodes’ spatial bounds. This illustrates another tradeoff
    we see with data structures—the performance of a structure may degrade as the
    data changes.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，k-d树对增加和删除的敏感度可能高于四叉树。虽然两者都可能由于分割规则和点的分布而变得不平衡，但k-d树的分割是基于当时数据选择的。如果我们显著改变点的分布，原来的分割值可能不再合适。在批量构建过程中，我们可以根据当前数据适应分割，考虑诸如树的深度、是否平衡以及节点空间边界的紧凑性等因素。这展示了数据结构中的另一种权衡——随着数据的变化，结构的性能可能会下降。
- en: Why This Matters
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么这很重要
- en: The quadtree and k-d trees are examples of how we can combine the power of dynamic
    data structures with the spatial structure in our search problem. By branching
    along multiple dimensions at once, quadtrees allow us to adapt the resolution
    of a grid to the density of data points in a local area. High-density areas result
    in deeper branches and thus a finer-grained grid. At the same time, retaining
    a regular grid structure introduces new costs for higher dimensions. Examining
    how quadtrees, octtrees, and their variants scale across different data sets provides
    an important lens for how we think about utilizing spatial structure.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 四叉树和k-d树是我们如何将动态数据结构的强大功能与空间结构结合应用于搜索问题的例子。通过在多个维度上同时分支，四叉树使我们能够根据局部区域内数据点的密度来调整网格的分辨率。高密度区域会导致更深的分支，从而生成更细粒度的网格。与此同时，保持规则网格结构会在更高维度上引入新的成本。考察四叉树、八叉树及其变体在不同数据集上的扩展性，为我们思考如何利用空间结构提供了一个重要的视角。
- en: A k-d tree represents a combination of the concepts we have built up over the
    past few chapters to solve the problem of nearest-neighbor search. It solves the
    problem of having a high branching factor by returning to the core concepts of
    binary search trees and choosing a single dimension along which to split at each
    node. In addition, it allows more flexibility to adapt to the structure of the
    data, increasing pruning power.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: k-d树代表了我们在过去几章中构建的概念的结合，旨在解决最近邻搜索问题。它通过回归到二叉搜索树的核心概念，选择一个单一维度在每个节点进行分割，从而解决了高分支因子的难题。此外，它还允许更多的灵活性来适应数据的结构，从而增强了剪枝能力。
- en: Quadtrees and k-d trees aren’t the only data structures for facilitating nearest-neighbor
    searches. There are a wealth of other tree-based and non-tree-based approaches.
    The topic of spatial data structures could fill multiple books. As with almost
    everything in computer science, each approach comes with its own tradeoffs in
    terms of program complexity, computational cost, and memory usage. For the purpose
    of this book, quadtrees and k-d trees serve as excellent examples of how we can
    combine the spatial pruning of nearest-neighbor search with tree-based structures
    to allow the spatial trees to adapt to the data at hand.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 四叉树和k-d树并不是唯一能够促进最近邻搜索的数据结构。还有许多其他基于树的和非树的方法。空间数据结构这一主题可以填满好几本书。和计算机科学中的几乎所有问题一样，每种方法都有其在程序复杂性、计算成本和内存使用方面的权衡。在本书中，四叉树和k-d树作为如何将最近邻搜索的空间剪枝与基于树的结构相结合的绝佳例子，从而使空间树能够根据手头的数据进行适应。
