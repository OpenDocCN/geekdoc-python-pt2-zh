["```py\n// rotational transform\nmat4 rot =  mat4(\n    vec4(1.0,  0.0,          0.0,         0.0),\n    vec4(0.0,  cos(uTheta),  sin(uTheta), 0.0),\n    vec4(0.0, -sin(uTheta),  cos(uTheta), 0.0),\n    vec4(0.0,  0.0,          0.0,         1.0)\n);\n\n```", "```py\n❶ # version 410 core\n❷ in vec3 aVert;\n❸ uniform mat4 uMVMatrix;\n❹ uniform mat4 uPMatrix;\n❺ out vec4 vCol;\nvoid main() {\n    // apply transformations\n  ❻ gl_Position = uPMatrix * uMVMatrix * vec4(aVert, 1.0);\n    // set color\n  ❼ vCol = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\n```", "```py\n❶ # version 410 core\n❷ in vec4 vCol;\n❸ out vec4 fragColor;\nvoid main() {\n    // use vertex color\n  ❹ fragColor = vCol;\n}\n\n```", "```py\nclass RenderWindow:\n    \"\"\"GLFW rendering window class\"\"\"\n    def __init__(self):\n        # save current working directory\n        cwd = os.getcwd()\n        # initialize glfw\n      ❶ glfw.glfwInit()\n        # restore cwd\n        os.chdir(cwd)\n        # version hints\n      ❷ glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MAJOR, 4)\n        glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MINOR, 1)\n        glfw.glfwWindowHint(glfw.GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE)\n        glfw.glfwWindowHint(glfw.GLFW_OPENGL_PROFILE,\n                            glfw.GLFW_OPENGL_CORE_PROFILE)\n        # make a window\n        self.width, self.height = 800, 600\n        self.aspect = self.width/float(self.height)\n      ❸ self.win = glfw.glfwCreateWindow(self.width, self.height,\n                                         b'simpleglfw')\n        # make the context current\n      ❹ glfw.glfwMakeContextCurrent(self.win)\n\n```", "```py\n        # initialize GL\n      ❶ glViewport(0, 0, self.width, self.height)\n      ❷ glEnable(GL_DEPTH_TEST)\n      ❸ glClearColor(0.5, 0.5, 0.5, 1.0)\n\n```", "```py\n        # set window callbacks\n        glfw.glfwSetKeyCallback(self.win, self.onKeyboard)\n\n```", "```py\ndef onKeyboard(self, win, key, scancode, action, mods):\n    # print 'keyboard: ', win, key, scancode, action, mods\n  ❶ if action == glfw.GLFW_PRESS:\n        # ESC to quit\n        if key == glfw.GLFW_KEY_ESCAPE:\n          ❷ self.exitNow = True\n        else:\n            # toggle cut\n          ❸ self.scene.showCircle = not self.scene.showCircle\n\n```", "```py\ndef run(self):\n    # initializer timer\n  ❶ glfw.glfwSetTime(0)\n    t = 0.0\n  ❷ while not glfw.glfwWindowShouldClose(self.win) and not self.exitNow:\n        # update every x seconds\n      ❸ currT = glfw.glfwGetTime()\n        if currT - t > 0.1:\n            # update time\n            t = currT\n            # clear\n          ❹ glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\n            # set viewport\n          ❺ self.width, self.height = glfw.glfwGetFramebufferSize(self.win)\n          ❻ self.aspect = self.width/float(self.height)\n          ❼ glViewport(0, 0, self.width, self.height)\n\n```", "```py\n            # build projection matrix\n          ❶ pMatrix = glutils.perspective(45.0, self.aspect, 0.1, 100.0)\n          ❷ mvMatrix = glutils.lookAt([0.0, 0.0, -2.0], [0.0, 0.0, 0.0],\n                                      [0.0, 1.0, 0.0])\n            # render\n          ❸ self.scene.render(pMatrix, mvMatrix)\n            # step\n          ❹ self.scene.step()\n          ❺ glfw.glfwSwapBuffers(self.win)\n            # poll for and process events\n          ❻ glfw.glfwPollEvents()\n    # end\n    glfw.glfwTerminate()\n\n```", "```py\nclass Scene:\n    \"\"\" OpenGL 3D scene class\"\"\"\n    # initialization\n    def __init__(self):\n        # create shader\n      ❶ self.program = glutils.loadShaders(strVS, strFS)\n      ❷ glUseProgram(self.program)\n\n```", "```py\n        # define triangle strip vertices\n      ❶ vertexData = numpy.array(\n            [-0.5, -0.5, 0.0,\n             0.5, -0.5, 0.0,\n             -0.5, 0.5, 0.0,\n             0.5, 0.5, 0.0], numpy.float32)\n        # set up vertex array object (VAO)\n      ❷ self.vao = glGenVertexArrays(1)\n        glBindVertexArray(self.vao)\n        # vertices\n      ❸ self.vertexBuffer = glGenBuffers(1)\n        glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)\n        # set buffer data\n      ❹ glBufferData(GL_ARRAY_BUFFER, 4*len(vertexData), vertexData,\n                     GL_STATIC_DRAW)\n        # enable vertex array\n      ❺ glEnableVertexAttribArray(0)\n        # set buffer data pointer\n      ❻ glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, None)\n        # unbind VAO\n      ❼ glBindVertexArray(0)\n\n```", "```py\n        # texture\n        self.texId = glutils.loadTexture('star.png')\n\n```", "```py\n# step\ndef step(self):\n    # increment angle\n  ❶ self.t = (self.t + 1) % 360\n\n```", "```py\ndef render(self, pMatrix, mvMatrix):\n    # use shader\n  ❶ glUseProgram(self.program)\n    # set projection matrix\n  ❷ glUniformMatrix4fv(self.pMatrixUniform, 1, GL_FALSE, pMatrix)\n    # set modelview matrix\n    glUniformMatrix4fv(self.mvMatrixUniform, 1, GL_FALSE, mvMatrix)\n    # set shader angle in radians\n  ❸ glUniform1f(glGetUniformLocation(self.program, 'uTheta'),\n                math.radians(self.t))\n    # show circle?\n  ❹ glUniform1i(glGetUniformLocation(self.program, b'showCircle'),\n                self.showCircle)\n    # enable texture\n  ❺ glActiveTexture(GL_TEXTURE0)\n  ❻ glBindTexture(GL_TEXTURE_2D, self.texId)\n  ❼ glUniform1i(self.tex2D, 0)\n    # bind VAO\n  ❽ glBindVertexArray(self.vao)\n    # draw\n  ❾ glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)\n    # unbind VAO\n  ❿ glBindVertexArray(0)\n\n```", "```py\n# version 410 core\n❶ layout(location = 0) in vec3 aVert;\n❷ uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform float uTheta;\n❸ out vec2 vTexCoord;\nvoid main() {\n    // rotational transform\n  ❹ mat4 rot = mat4(\n                vec4(1.0, 0.0, 0.0, 0.0),\n                vec4(0.0, cos(uTheta), -sin(uTheta), 0.0),\n                vec4(0.0, sin(uTheta),  cos(uTheta), 0.0),\n                vec4(0.0, 0.0,          0.0,         1.0)\n                );\n    // transform vertex\n  ❺ gl_Position = uPMatrix * uMVMatrix * rot * vec4(aVert, 1.0);\n    // set texture coordinate\n  ❻ vTexCoord = aVert.xy + vec2(0.5, 0.5);\n}\n\n```", "```py\n# version 410 core\n❶ in vec2 vTexCoord;\n❷ uniform sampler2D tex2D;\n❸ uniform bool showCircle;\n❹ out vec4 fragColor;\nvoid main() {\n    if (showCircle) {\n        // discard fragment outside circle\n      ❺ if (distance(vTexCoord, vec2(0.5, 0.5)) > 0.5) {\n            discard;\n        }\n        else {\n          ❻ fragColor = texture(tex2D, vTexCoord);\n        }\n    }\n        else {\n          ❼ fragColor = texture(tex2D, vTexCoord);\n        }\n}\n\n```", "```py\ndef loadTexture(filename):\n    \"\"\"load OpenGL 2D texture from given image file\"\"\"\n  ❶ img = Image.open(filename)\n  ❷ imgData = numpy.array(list(img.getdata()), np.int8)\n  ❸ texture = glGenTextures(1)\n  ❹ glBindTexture(GL_TEXTURE_2D, texture)\n  ❺ glPixelStorei(GL_UNPACK_ALIGNMENT, 1)\n  ❻ glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE)\n    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE)\n  ❼ glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)\n    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)\n  ❽ glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, img.size[0], img.size[1],\n                 0, GL_RGBA, GL_UNSIGNED_BYTE, imgData)\n    return texture\n\n```", "```py\n$ `python simpleglfw.py`\n\n```", "```py\n\"\"\"\nsimpleglfw.py\nA simple Python OpenGL program that uses PyOpenGL + GLFW to get an\nOpenGL 4.1 context.\nAuthor: Mahesh Venkitachalam\n\"\"\"\nimport OpenGL\nfrom OpenGL.GL import *\nimport numpy, math, sys, os\nimport glutils\nimport glfw\nstrVS = \"\"\"\n# version 410 core\nlayout(location = 0) in vec3 aVert;\nuniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform float uTheta;\nout vec2 vTexCoord;\nvoid main() {\n  // rotational transform\n  mat4 rot =  mat4(\n        vec4(1.0,  0.0,          0.0,         0.0),\n        vec4(0.0,  cos(uTheta),  sin(uTheta), 0.0),\n        vec4(0.0, -sin(uTheta),  cos(uTheta), 0.0),\n        vec4(0.0,  0.0,          0.0,         1.0)\n        );\n  // transform vertex\n  gl_Position = uPMatrix * uMVMatrix * rot * vec4(aVert, 1.0);\n  // set texture coord\n  vTexCoord = aVert.xy + vec2(0.5, 0.5);\n}\n\"\"\"\nstrFS = \"\"\"\n# version 410 core\nin vec2 vTexCoord;\nuniform sampler2D tex2D;\nuniform bool showCircle;\nout vec4 fragColor;\nvoid main() {\n  if (showCircle) {\n    // discard fragment outside circle\n    if (distance(vTexCoord, vec2(0.5, 0.5)) > 0.5) {\n      discard;\n    }\n    else {\n      fragColor = texture(tex2D, vTexCoord);\n    }\n  }\n  else {\n    fragColor = texture(tex2D, vTexCoord);\n  }\n}\n\"\"\"\nclass Scene:\n    \"\"\" OpenGL 3D scene class\"\"\"\n    # initialization\n    def __init__(self):\n        # create shader\n        self.program = glutils.loadShaders(strVS, strFS)\n        glUseProgram(self.program)\n        self.pMatrixUniform = glGetUniformLocation(self.program,\n                                                  b'uPMatrix')\n        self.mvMatrixUniform = glGetUniformLocation(self.program,\n                                                  b'uMVMatrix')\n        # texture\n        self.tex2D = glGetUniformLocation(self.program, b'tex2D')\n        # define triangle strip vertices\n        vertexData = numpy.array(\n            [-0.5, -0.5, 0.0,\n              0.5, -0.5, 0.0,\n              -0.5, 0.5, 0.0,\n              0.5, 0.5, 0.0], numpy.float32)\n        # set up vertex array object (VAO)\n        self.vao = glGenVertexArrays(1)\n        glBindVertexArray(self.vao)\n        # vertices\n        self.vertexBuffer = glGenBuffers(1)\n        glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)\n        # set buffer data\n        glBufferData(GL_ARRAY_BUFFER, 4*len(vertexData), vertexData,\n                     GL_STATIC_DRAW)\n        # enable vertex array\n        glEnableVertexAttribArray(0)\n        # set buffer data pointer\n        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, None)\n        # unbind VAO\n        glBindVertexArray(0)\n        # time\n        self.t = 0\n        # texture\n        self.texId = glutils.loadTexture('star.png')\n        # show circle?\n        self.showCircle = False\n    # step\n    def step(self):\n        # increment angle\n        self.t = (self.t + 1) % 360\n    # render\n    def render(self, pMatrix, mvMatrix):\n        # use shader\n        glUseProgram(self.program)\n        # set proj matrix\n        glUniformMatrix4fv(self.pMatrixUniform, 1, GL_FALSE, pMatrix)\n        # set modelview matrix\n        glUniformMatrix4fv(self.mvMatrixUniform, 1, GL_FALSE, mvMatrix)\n        # set shader angle in radians\n        glUniform1f(glGetUniformLocation(self.program, 'uTheta'),\n                    math.radians(self.t))\n        # show circle?\n        glUniform1i(glGetUniformLocation(self.program, b'showCircle'),\n                    self.showCircle)\n        # enable texture\n        glActiveTexture(GL_TEXTURE0)\n        glBindTexture(GL_TEXTURE_2D, self.texId)\n        glUniform1i(self.tex2D, 0)\n        # bind VAO\n        glBindVertexArray(self.vao)\n        # draw\n        glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)\n        # unbind VAO\n        glBindVertexArray(0)\nclass RenderWindow:\n    \"\"\"GLFW rendering window class\"\"\"\n    def __init__(self):\n        # save current working directory\n        cwd = os.getcwd()\n        # initialize glfw - this changes cwd\n        glfw.glfwInit()\n        # restore cwd\n        os.chdir(cwd)\n        # version hints\n        glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MAJOR, 4)\n        glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MINOR, 1)\n        glfw.glfwWindowHint(glfw.GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE)\n        glfw.glfwWindowHint(glfw.GLFW_OPENGL_PROFILE,\n                            glfw.GLFW_OPENGL_CORE_PROFILE)\n        # make a window\n        self.width, self.height = 800, 600\n        self.aspect = self.width/float(self.height)\n        self.win = glfw.glfwCreateWindow(self.width, self.height,\n                                         b'simpleglfw')\n        # make context current\n        glfw.glfwMakeContextCurrent(self.win)\n        # initialize GL\n        glViewport(0, 0, self.width, self.height)\n        glEnable(GL_DEPTH_TEST)\n        glClearColor(0.5, 0.5, 0.5, 1.0)\n        # set window callbacks\n        glfw.glfwSetKeyCallback(self.win, self.onKeyboard)\n        # create 3D\n        self.scene = Scene()\n        # exit flag\n        self.exitNow = False\n    def onKeyboard(self, win, key, scancode, action, mods):\n        # print 'keyboard: ', win, key, scancode, action, mods\n        if action == glfw.GLFW_PRESS:\n            # ESC to quit\n            if key == glfw.GLFW_KEY_ESCAPE:\n                self.exitNow = True\n            else:\n                # toggle cut\n                self.scene.showCircle = not self.scene.showCircle\n    def run(self):\n        # initializer timer\n        glfw.glfwSetTime(0)\n        t = 0.0\n        while not glfw.glfwWindowShouldClose(self.win) and not self.exitNow:\n            # update every x seconds\n            currT = glfw.glfwGetTime()\n            if currT - t > 0.1:\n                # update time\n                t = currT\n                # clear\n                glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)\n                # set viewport\n                self.width, self.height =\n                                    glfw.glfwGetFramebufferSize(self.win)\n                self.aspect = self.width/float(self.height)\n                glViewport(0, 0, self.width, self.height)\n                # build projection matrix\n                pMatrix = glutils.perspective(45.0, self.aspect, 0.1, 100.0)\n                mvMatrix = glutils.lookAt([0.0, 0.0, -2.0], [0.0, 0.0, 0.0],\n                                          [0.0, 1.0, 0.0])\n                # render\n                self.scene.render(pMatrix, mvMatrix)\n                # step\n                self.scene.step()\n                glfw.glfwSwapBuffers(self.win)\n                # poll for and process events\n                glfw.glfwPollEvents()\n        # end\n        glfw.glfwTerminate()\n    def step(self):\n        # step\n        self.scene.step()\n# main() function\ndef main():\n    print(\"Starting simpleglfw. \"\n          \"Press any key to toggle cut. Press ESC to quit.\")\n    rw = RenderWindow()\n    rw.run()\n# call main\nif __name__ == '__main__':\n    main()\n\n```"]