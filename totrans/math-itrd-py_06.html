<html><head></head><body>
<h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_53"/><span class="big">4</span><br/>TRANSFORMING AND STORING NUMBERS WITH ALGEBRA</h2>&#13;
<p class="epigraph"><em>“Mathematics may be defined as the subject in which we never know what we are talking about, nor whether what we are saying is true.”<br/>—Bertrand Russell</em></p>&#13;
<div class="image1"><img alt="image" src="../images/fintro-01.jpg"/></div>&#13;
<p class="intro">If you learned algebra in school, you’re probably familiar with the idea of replacing numbers with letters. For example, you can write 2<em>x</em> where <em>x</em> is a placeholder that can represent any number. So 2<em>x</em> represents the idea of multiplying two by some unknown number. In math</p>&#13;
<p class="noindent">class, variables become “mystery numbers” and you’re required to find what numbers the letters represent. <a href="ch04.xhtml#ch04fig1">Figure 4-1</a> shows a student’s cheeky response to the problem “Find <em>x</em>.”</p>&#13;
<div class="image"><a id="ch04fig1"/><img alt="image" src="../images/f053-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 4-1: Locating the</em> x <em>variable instead of solving for its value</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_54"/>As you can see, this student has located the variable <em>x</em> in the diagram instead of <em>solving</em> for its value. Algebra class is all about solving equations like this: solve 2<em>x</em> + 5 = 13. In this context, “to solve” means to figure out which number, when you replace <em>x</em> with that number, makes the equation true. You can solve algebra problems by balancing equations, which requires a lot of rules you have to memorize and follow.</p>&#13;
<p class="indent">Using letters as placeholders in this way is just like using variables in Python. In fact, you already learned how to use variables to store and calculate numerical values in previous chapters. The important skill math students should learn is not solving for variables but rather <em>using</em> variables. In fact, solving equations by hand is only of limited value. In this chapter you use variables to write programs that find unknown values quickly and automatically without having to balance equations! You also learn to use a programming environment called Processing to graph functions to help you explore algebra visually.</p>&#13;
<h3 class="h3" id="ch04_1">SOLVING FIRST-DEGREE EQUATIONS</h3>&#13;
<p class="noindent">One way to solve a simple equation like 2<em>x</em> + 5 = 13 with programming is by using <em>brute force</em> (that is, plugging in random numbers until we find the right one). For this particular equation we need to find a number, <em>x</em>, that when we multiply it by 2 and then add 5, returns 13. I’ll make an educated guess that <em>x</em> is a value between −100 and 100, since we’re working with mostly double-digit numbers or lower.</p>&#13;
<p class="indent">This means that we can write a program that plugs all the integers between −100 and 100 into the equation, checks the output, and prints the number that makes the equation true. Open a new file in IDLE, save it as <em>plug.py</em>, and enter the code in <a href="ch04.xhtml#ch04list1">Listing 4-1</a> to see such a program in action.</p>&#13;
<pre><span class="pd_orange">def</span> <span class="pd_blue">plug</span>():<br/>  <span class="ent">➊</span> x = -100 <span class="pd_red">#start at -100</span><br/>    <span class="pd_orange">while</span> x &lt; 100: <span class="pd_red">#go up to 100</span><br/>      <span class="ent">➋</span> <span class="pd_orange">if</span> 2*x + 5 == 13: <span class="pd_red">#if it makes the equation true</span><br/>            <span class="pd_purple">print</span>(<span class="pd_green">"x ="</span>,x) <span class="pd_red">#print it out</span><br/>      <span class="ent">➌</span> x += 1 <span class="pd_red">#make x go up by 1 to test the next number</span><br/><br/>plug() <span class="pd_red">#run the plug function</span></pre>&#13;
<p class="listing" id="ch04list1"><em>Listing 4-1: Brute-force program that plugs in numbers to see which one satisfies the equation</em></p>&#13;
<p class="indent">Here, we define the <code>plug()</code> function and initialize the <code>x</code> variable at <code>-100</code> <span class="ent">➊</span>. On the next line we start a <code>while</code> loop that repeats until <code>x</code> equals 100, which is the upper limit of the range we set. We then multiply <code>x</code> by 2 and add 5 <span class="ent">➋</span>. If the output equals 13, we tell the program to print the number, because that’s the solution. If the output does not equal 13, we tell the program to keep going through the code.</p>&#13;
<p class="indent">The loop then starts over, and the program tests the next number, which we get by incrementing <code>x</code> by 1 <span class="ent">➌</span>. We continue the loop until we hit <span epub:type="pagebreak" id="page_55"/>a match. Be sure to include the last line, which makes the program run the <code>plug()</code> function we just defined; if you don’t, your program won’t do anything! The output should be this:</p>&#13;
<pre><span class="pd_blue">x = 4</span></pre>&#13;
<p class="indent">Using the guess-and-check method is a perfectly valid way to solve this problem. Plugging in all the digits by hand can be laborious, but using Python makes it a cinch! If you suspect the solution isn’t an integer, you might have to increment by smaller numbers by changing the line at <span class="ent">➌</span> to <code>x += .25</code> or some other decimal value.</p>&#13;
<h4 class="h4" id="ch04_1_1">FINDING THE FORMULA FOR FIRST-DEGREE EQUATIONS</h4>&#13;
<p class="noindent">Another way to solve an equation like 2<em>x</em> + 5 = 13 is to find a general formula for this type of equation. We can then use this formula to write a program in Python. You might recall from math class that the equation 2<em>x</em> + 5 = 13 is an example of a <em>first-degree equation</em>, because the highest exponent a variable has in this equation is 1. And you probably know that a number raised to the first power equals the number itself.</p>&#13;
<p class="indent">In fact, all first-degree equations fit into this general formula: a<em>x</em> + b = c<em>x</em> + d, where a, b, c, and d represent different numbers. Here are some examples of other first-degree equations:</p>&#13;
<div class="image"><img alt="image" src="../images/e055-01.jpg"/></div>&#13;
<p class="indent">On each side of the equal sign, you can see an <em>x</em> term and a <em>constant</em>, which is a number with no <em>x</em> attached to it. The number that precedes the <em>x</em> variable is called a <em>coefficient</em>. For example, the coefficient of 3<em>x</em> is 3.</p>&#13;
<p class="indent">But sometimes there’s no <em>x</em> term at all on one side of the equation, which means that the coefficient of that <em>x</em> is zero. You can see this in the first example, 3<em>x</em> − 5 = 22, where 22 is the only term on the right side of the equal sign:</p>&#13;
<div class="image"><img alt="image" src="../images/e055-02.jpg"/></div>&#13;
<p class="indent">Using the general formula, you can see that a = 3, b = −5, and d = 22. The only thing that seems to be missing is the value of c. But it’s not actually missing. In fact, the fact that there’s nothing there means c<em>x</em> = 0, which means that c must equal zero.</p>&#13;
<p class="indent">Now let’s use a little algebra to solve the equation a<em>x</em> + b = c<em>x</em> + d for <em>x</em>. If we can find what <em>x</em> is in the formula, we can use it to solve virtually all equations of this form.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_56"/>To solve this equation, we first get all the <em>x</em>’s on one side of the equal sign by subtracting c<em>x</em> and b from both sides of the equation, like this:</p>&#13;
<p class="center">a<em>x</em> − c<em>x</em> = d − b</p>&#13;
<p class="indent">Then we can factor out the <em>x</em> from a<em>x</em> and c<em>x</em>:</p>&#13;
<p class="center"><em>x</em>(a − c) = d − b</p>&#13;
<p class="indent">Finally, divide both sides by a − c to isolate <em>x</em>, which gives us the value of <em>x</em> in terms of a, b, c, and d:</p>&#13;
<div class="image"><img alt="image" src="../images/e056-01.jpg"/></div>&#13;
<p class="indent">Now you can use this general equation to solve for any variable <em>x</em> when the equation is a first-degree equation and all coefficients (a, b, c, and d) are known. Let’s use this to write a Python program that can solve first-degree algebraic equations for us.</p>&#13;
<h4 class="h4" id="ch04_1_2">WRITING THE EQUATION() FUNCTION</h4>&#13;
<p class="noindent">To write a program that will take the four coefficients of the general equation and print out the solution for <em>x</em>, open a new Python file in IDLE. Save it as <em>algebra.py</em>. We’ll write a function that takes the four numbers a, b, c, and d as parameters and plug them into the formula (see <a href="ch04.xhtml#ch04list2">Listing 4-2</a>).</p>&#13;
<pre><span class="pd_orange">def</span> <span class="pd_blue">equation</span>(a,b,c,d):<br/>    <span class="pd_green">''''solves equations of the</span><br/><span class="pd_green">    form ax + b = cx + d''''</span><br/>    <span class="pd_orange">return</span> (d - b)/(a - c)</pre>&#13;
<p class="listing" id="ch04list2"><em>Listing 4-2: Using programming to solve for <code>x</code></em></p>&#13;
<p class="indent">Recall that the general formula of a first-degree equation is this:</p>&#13;
<div class="image"><img alt="image" src="../images/e056-02.jpg"/></div>&#13;
<p class="indent">This means that for any equation with the form a<em>x</em> + b = c<em>x</em> + d, if we take the coefficients and plug them into this formula, we can calculate the <em>x</em> value. First, we set the <code>equation()</code> function to take the four coefficients as its parameters. Then we use the expression <code>(d - b)/(a − c)</code> to represent the general equation.</p>&#13;
<p class="indent">Now let’s test our program with an equation you’ve already seen: 2<em>x</em> + 5 = 13. Open the Python shell, type the following code at the <code>&gt;&gt;&gt;</code> prompt, and press <small>ENTER</small>:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">equation(2,5,0,13)</span><br/><span class="literal1"><span class="pd_blue">4.0</span></span></pre>&#13;
<p class="indent">If you input the coefficients of this equation into the function, you get 4 as the solution. You can confirm that it’s correct by plugging in 4 in place of <em>x</em>. It works!</p>&#13;
<span epub:type="pagebreak" id="page_57"/>&#13;
<div class="sidebar">&#13;
<p class="title">EXERCISE 4-1: SOLVING MORE EQUATIONS FOR X</p>&#13;
<p class="noindent">Solve 12x + 18 = –34x + 67 using the program you wrote in <a href="ch04.xhtml#ch04list2">Listing 4-2</a>.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch04_1_3">USING PRINT() INSTEAD OF RETURN</h4>&#13;
<p class="noindent">In <a href="ch04.xhtml#ch04list2">Listing 4-2</a>, we used <code>return</code> instead of <code>print()</code> to display our results. This is because <code>return</code> gives us our result as a number that we can assign to a variable and then use again. <a href="ch04.xhtml#ch04list3">Listing 4-3</a> shows what would happen if we used <code>print()</code> instead of <code>return</code> to find <em>x</em>:</p>&#13;
<pre><span class="pd_gray">def equation(a,b,c,d):</span><br/><span class="pd_gray">    ''''solves equations of the</span><br/><span class="pd_gray">    form ax + b = cx + d''''</span><br/>    <span class="pd_purple">print</span>((d - b)/(a − c))</pre>&#13;
<p class="listing" id="ch04list3"><em>Listing 4-3: Using <code>print()</code> doesn’t let us save the output</em></p>&#13;
<p class="indent">When you run this, you get the same output:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">x = equation(2,5,0,13)</span><br/><span class="literal1"><span class="pd_blue">4.0</span></span><br/>&gt;&gt;&gt; <span class="literal1"><span class="pd_purple">print</span></span><span class="codestrong1">(x)</span><br/><span class="literal1"><span class="pd_blue">None</span></span></pre>&#13;
<p class="indent">But when you try to call the <code>x</code> value using <code>print()</code>, the program doesn’t recognize your command because it hasn’t saved the result. As you can see, <code>return</code> can be more useful in programming because it lets you save the output of a function so you can apply it elsewhere. This is why we used <code>return</code> in <a href="ch04.xhtml#ch04list2">Listing 4-2</a>.</p>&#13;
<p class="indent">To see how you can work with the returned output, use the equation 12<em>x</em> + 18 = −34<em>x</em> + 67 from Exercise 4-1 and assign the result to the <code>x</code> variable, as shown here:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">x = equation(12,18,-34,67)</span><br/>&gt;&gt;&gt; <span class="codestrong1">x</span><br/><span class="literal1"><span class="pd_blue">1.065217391304348</span></span></pre>&#13;
<p class="indent">First, we pass the coefficients and constants of our equation to the <code>equation()</code> function so that it solves the equation for us and assigns the solution to the variable <code>x</code>. Then we can simply enter <span class="codestrong1">x</span> to see its value. Now that the variable <code>x</code> stores the solution, we can plug it back into the equation to check that it’s the correct answer.</p>&#13;
<p class="indent">Enter the following to find out what 12<em>x</em> + 18, the left side of the equation, evaluates to:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">12*x + 18</span><br/><span class="literal1"><span class="pd_blue">30.782608695652176</span></span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_58"/>We get <code>30.782608695652176</code>. Now enter the following to do the same for −34<em>x</em> + 67, the right side of the equation:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">-34*x + 67</span><br/><span class="literal1"><span class="pd_blue">30.782608695652172</span></span></pre>&#13;
<p class="indent">Except for a slight rounding discrepancy at the 15th decimal place, you can see that both sides of the equation evaluate to around 30.782608. So we can be confident that 1.065217391304348 is indeed the correct solution for <em>x</em>! Good thing we returned the solution and saved the value instead of just printing it out once. After all, who wants to type in a number like 1.065217391304348 again and again?</p>&#13;
<div class="sidebar">&#13;
<p class="title">EXERCISE 4-2: FRACT IONS AS COEFFICIENTS</p>&#13;
<p class="noindent">Use the <code>equation()</code> function to solve the last, most sinister-looking equation you saw on <a href="ch04.xhtml#page_55">page 55</a>:</p>&#13;
<div class="image"><img alt="image" src="../images/e058-01.jpg"/></div>&#13;
</div>&#13;
<h3 class="h3" id="ch04_2">SOLVING HIGHER-DEGREE EQUATIONS</h3>&#13;
<p class="noindent">Now that you know how to write programs that solve for unknown values in first-degree equations, let’s try something harder. For example, things get a little more complicated when an equation has a term raised to the second degree, like <em>x</em><sup>2</sup> + 3<em>x</em> − 10 = 0. These are called <em>quadratic equations</em>, and their general form looks like a<em>x</em><sup>2</sup> + b<em>x</em> + c = 0, where a, b, and c can be any number: positive or negative, whole numbers, fractions, or decimals. The only exception is that a can’t be 0 because that would make this a first-degree equation. Unlike first-degree equations, which have one solution, quadratic equations have two possible solutions.</p>&#13;
<p class="indent">To solve an equation with a squared term, you can use the <em>quadratic formula</em>, which is what you get when you isolate <em>x</em> by balancing the equation a<em>x</em><sup>2</sup> + b<em>x</em> + c = 0:</p>&#13;
<div class="image"><img alt="image" src="../images/e058-02.jpg"/></div>&#13;
<p class="indent">The quadratic formula is a very powerful tool for solving equations, because no matter what a, b, and c are in a<em>x</em><sup>2</sup> + b<em>x</em> + c = 0, you can just plug them in to the formula and use basic arithmetic to find your solutions.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_59"/>We know that the coefficients of <em>x</em><sup>2</sup> + 3<em>x</em> − 10 = 0 are 1, 3, and −10. When we plug those in to the formula, we get</p>&#13;
<div class="image"><img alt="image" src="../images/e059-01.jpg"/></div>&#13;
<p class="indent">Isolate <em>x</em> and this simplifies to</p>&#13;
<div class="image"><img alt="image" src="../images/e059-02.jpg"/></div>&#13;
<p class="indent">There are two solutions:</p>&#13;
<div class="image"><img alt="image" src="../images/e059-03.jpg"/></div>&#13;
<p class="noindent">which is equal to 2, and</p>&#13;
<div class="image"><img alt="image" src="../images/e059-04.jpg"/></div>&#13;
<p class="noindent">which is equal to −5.</p>&#13;
<p class="indent">We can see that replacing <em>x</em> in the quadratic formula with either of these solutions makes the equation true:</p>&#13;
<p class="center">(<em>2</em>)<sup>2</sup> + 3(<em>2</em>) − 10 = 4 + 6 − 10 = 0</p>&#13;
<p class="center">(<em>−5</em>)<sup>2</sup> + 3(<em>−5</em>) − 10 = 25 − 15 − 10 = 0</p>&#13;
<p class="indent">Next, we’ll write a function that uses this formula to return two solutions for any quadratic equation.</p>&#13;
<h4 class="h4" id="ch04_1_4">USING QUAD() TO SOLVE QUADRATIC EQUATIONS</h4>&#13;
<p class="noindent">Let’s say we want to use Python to solve the following quadratic equation:</p>&#13;
<p class="center">2<em>x</em><sup>2</sup> + 7<em>x</em> − 15 = 0</p>&#13;
<p class="indent">To do this, we’ll write a function called <code>quad()</code> that takes the three coefficients (a, b, and c) and returns two solutions. But before we do anything, we need to import the <code>sqrt</code> method from the math module. The <code>sqrt</code> method allows us to find the square root of a number in Python, just like a square root button on a calculator. It works great for positive numbers, but if you try finding the square root of a negative number, you’ll see an error like this:</p>&#13;
<pre>&gt;&gt;&gt; <span class="pd_orange">from</span><span class="codestrong1">math</span> <span class="pd_orange">import</span><span class="codestrong1">sqrt</span><br/>&gt;&gt;&gt; <span class="codestrong1">sqrt(-4)</span><br/><span class="pd_red">Traceback (most recent call last):</span><br/><span class="pd_red">  File "&lt;pyshell#11&gt;", line 1, in &lt;module&gt;</span><br/><span class="pd_red">    sqrt(-4)</span><br/><span class="pd_red">ValueError: math domain error</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_60"/>Open a new Python file in IDLE and name it <em>polynomials.py</em>. Add the following line to the top of your file to import the <code>sqrt</code> function from the math module:</p>&#13;
<pre><span class="pd_orange">from</span> math <span class="pd_orange">import</span> sqrt</pre>&#13;
<p class="indent">Then enter the code in <a href="ch04.xhtml#ch04list4">Listing 4-4</a> to create the <code>quad()</code> function.</p>&#13;
<pre><span class="pd_orange">def</span> <span class="pd_blue">quad</span>(a,b,c):<br/>    <span class="pd_green">''''Returns the solutions of an equation</span><br/><span class="pd_green">    of the form a*x**2 + b*x + c = 0''''</span><br/>    x1 = (-b + sqrt(b**2 - 4*a*c))/(2*a)<br/>    x2 = (-b - sqrt(b**2 - 4*a*c))/(2*a)<br/>    <span class="pd_orange">return</span> x1,x2</pre>&#13;
<p class="listing" id="ch04list4"><em>Listing 4-4: Using the quadratic formula to solve an equation</em></p>&#13;
<p class="indent">The <code>quad()</code> function takes the numbers <code>a</code>, <code>b</code>, and <code>c</code> as parameters and plugs them in to the quadratic formula. We use <code>x1</code> to assign the result of (the first solution), and <code>x2</code> will store the value of (the second solution).</p>&#13;
<p class="indent">Now, let’s test this program to solve for <em>x</em> in 2<em>x</em><sup>2</sup> + 7<em>x</em> − 15 = 0. Plugging in the numbers 2, 7, and −15 for <code>a</code>, <code>b</code>, and <code>c</code> should return the following output:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">quad(2,7,-15)</span><br/><span class="literal1"><span class="pd_blue">(1.5, -5.0)</span></span></pre>&#13;
<p class="indent">As you can see, the two solutions for <em>x</em> are 1.5 and −5, which means both values should satisfy the equation 2<em>x</em><sup>2</sup> + 7<em>x</em> − 15 = 0. To test this, replace all the <em>x</em> variables in the original equation 2<em>x</em><sup>2</sup> + 7<em>x</em> − 15 = 0 with 1.5, the first solution, and then with −5, the second solution, as shown here:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">2*1.5**2 + 7*1.5 - 15</span><br/><span class="literal1"><span class="pd_blue">0.0</span></span><br/>&gt;&gt;&gt; <span class="codestrong1">2*(-5)**2 + 7*(-5) - 15</span><br/><span class="literal1"><span class="pd_blue">0</span></span></pre>&#13;
<p class="indent">Success! This confirms that both values work in the original equation. You can use the <code>equation()</code> and <code>quad()</code> functions any time in the future. Now that you’ve learned to write functions to solve first-degree and second-degree equations, let’s discuss how to solve even higher-degree equations!</p>&#13;
<h4 class="h4" id="ch04_1_5">USING PLUG() TO SOLVE A CUBIC EQUATION</h4>&#13;
<p class="noindent">In algebra class, students are often asked to solve a <em>cubic equation</em> like 6<em>x</em><sup>3</sup> + 31<em>x</em><sup>2</sup> + 3<em>x</em> − 10 = 0, which has a term raised to the third degree. We can tweak the <code>plug()</code> function we wrote in <a href="ch04.xhtml#ch04list1">Listing 4-1</a> to solve this cubic equation using the brute-force method. Enter the code shown in <a href="ch04.xhtml#ch04list5">Listing 4-5</a> into IDLE to see this in action.</p>&#13;
<span epub:type="pagebreak" id="page_61"/>&#13;
<pre><span class="pd_g1"><em>plug.py</em></span><br/><span class="pd_orange">def</span> <span class="pd_blue">g</span>(x):<br/>    <span class="pd_orange">return</span> 6*x**3 + 31*x**2 + 3*x − 10<br/><br/><span class="pd_orange">def</span> <span class="pd_blue">plug</span>():<br/>    x = -100<br/>    <span class="pd_orange">while</span> x &lt; 100:<br/>        <span class="pd_orange">if</span> g(x) == 0:<br/>            <span class="pd_purple">print</span>(<span class="pd_green">"x ="</span>,x)<br/>        x += 1<br/>    <span class="pd_purple">print</span>(<span class="pd_green">"done."</span>)</pre>&#13;
<p class="listing" id="ch04list5"><em>Listing 4-5: Using <code>plug()</code> to solve a cubic equation</em></p>&#13;
<p class="indent">First, we define <code>g(x)</code> to be a function that evaluates the expression <code>6*x**3 + 31*x**2 + 3*x − 10</code>, the left side of our cubic equation. Then we tell the program to plug all numbers between −100 and 100 into the <code>g(x)</code> function we just defined. If the program finds a number that makes <code>g(x)</code> equal zero, then it has found the solution and prints it for the user.</p>&#13;
<p class="indent">When you call <code>plug()</code>, you should see the following output:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">plug()</span><br/><span class="literal1"><span class="pd_blue">x = -5</span></span><br/><span class="literal1"><span class="pd_blue">done.</span></span></pre>&#13;
<p class="indent">This gives you −5 as the solution, but as you might suspect from working with quadratic equations previously, the <em>x</em><sup>3</sup> term means there could be as many as three solutions to this equation. As you can see, you can brute-force your way to a solution like this, but you won’t be able to determine whether other solutions exist or what they are. Fortunately, there’s a way to see all the possible inputs and corresponding outputs of a function; it’s called <em>graphing</em>.</p>&#13;
<h3 class="h3" id="ch04_3">SOLVING EQUATIONS GRAPHICALLY</h3>&#13;
<p class="noindent">In this section, we’ll use a nifty tool called Processing to graph higher-degree equations. This tool will help us find solutions to higher-degree equations in a fun and visual way! If you haven’t already installed Processing, follow the instructions in “Installing Processing” on <a href="ch00.xhtml#page_xxiii">page xxiii</a>.</p>&#13;
<h4 class="h4" id="ch04_1_6">GETTING STARTED WITH PROCESSING</h4>&#13;
<p class="noindent">Processing is a programming environment and a graphics library that makes it easy to visualize your code. You can see the cool, dynamic, interactive art you can make with Processing in the examples page at <em><a href="https://processing.org/examples/">https://processing.org/examples/</a></em>. You can think of Processing as a sketchbook for your programming ideas. In fact, each Processing program you create is called a <em>sketch</em>. <a href="ch04.xhtml#ch04fig2">Figure 4-2</a> shows what a short Processing sketch in Python mode looks like.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_62"/><a id="ch04fig2"/><img alt="image" src="../images/f062-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 4-2: Example of a Processing sketch</em></p>&#13;
<p class="indent">As you can see, there’s a programming environment where you enter code and a separate <em>display window</em> that shows the visualization of the code. This is a sketch of a simple program that creates a small circle. Every one of the Processing sketches we’ll create will contain two of Processing’s built-in functions: <code>setup()</code> and <code>draw()</code>. The code we put in the <code>setup()</code> function will be run once, when you click the play button, the arrow at the top left of the interface. Whatever we put in <code>draw()</code> will be repeated as an infinite loop until you click the stop button next to the play button.</p>&#13;
<p class="indent">In <a href="ch04.xhtml#ch04fig2">Figure 4-2</a> you can see in the <code>setup()</code> function we declared the size of the display screen to be 600 pixels by 600 pixels using the <code>size()</code> function. In the <code>draw()</code> function we told the program to draw a circle using the <code>ellipse()</code> function. Where? How big? We have to tell the <code>ellipse()</code> function four numbers: the x-coordinate of the ellipse, its y-coordinate, its width, and its height.</p>&#13;
<p class="indent">Notice the circle shows up in the middle of the screen, which in math class is the <em>origin</em> (0,0). But in Processing and in many other graphics libraries, (0,0) is in the top left corner of the screen. So to put a circle in the middle, I had to divide the length of the window (600) and the width of the window (600) in half. So its location is (300,300), and not (0,0).</p>&#13;
<p class="indent">Processing has a number of functions, like <code>ellipse()</code>, that make it easy to draw shapes. To see the full list, look at the reference pages at <em><a href="https://processing.org/reference/">https://processing.org/reference/</a></em> to find functions for drawing ellipses, triangles, rectangles, arcs, and much more. We’ll explore drawing shapes with Processing in more detail in the next chapter.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The code colors in Processing appear different from those used in IDLE. For example, you can see that <span class="codeitalic">def</span> appears green in Processing in <a href="ch04.xhtml#ch04fig2">Figure 4-2</a>, whereas it is orange in IDLE</em>.</p>&#13;
</div>&#13;
<span epub:type="pagebreak" id="page_63"/>&#13;
<h4 class="h4" id="ch04_1_7">CREATING YOUR OWN GRAPHING TOOL</h4>&#13;
<p class="noindent">Now that you’ve downloaded Processing, let’s use it to create a graphing tool that allows us to see how many solutions an equation has. First, we create a grid of blue lines that looks like graphing paper. Then, we create the x- and y-axes using black lines.</p>&#13;
<h5 class="h5">Setting Graph Dimensions</h5>&#13;
<p class="noindent">In order to make a grid for our graphing tool, we first need to set the dimensions of the display window. In Processing, you can use the <code>size()</code> function to indicate the width and height of the screen in pixels. The default screen size is 600 pixels by 600 pixels, but for our graphing tool we’ll create a graph that includes x- and y-values ranging from −10 to 10.</p>&#13;
<p class="indent">Open a new file in Processing and save it as <em>grid.pyde</em>. Make sure you’re in Python mode. Enter the code in <a href="ch04.xhtml#ch04list6">Listing 4-6</a> to declare the range of x- and y-values we’re interested in displaying for our graph.</p>&#13;
<pre><span class="pd_g1"><em>grid.pyde</em></span><br/><span class="pd_gray">#set the range of x-values</span><br/>xmin = -10<br/>xmax = 10<br/><br/><span class="pd_gray">#range of y-values</span><br/>ymin = -10<br/>ymax = 10<br/><br/><span class="pd_gray">#calculate the range</span><br/>rangex = xmax - xmin<br/>rangey = ymax - ymin<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/><span class="pd_blue1">    size</span>(600,600)</pre>&#13;
<p class="listing" id="ch04list6"><em>Listing 4-6: Setting the range of x- and y-values for the graph</em></p>&#13;
<p class="indent">In <a href="ch04.xhtml#ch04list6">Listing 4-6</a> we create two variables, <code>xmin</code> and <code>xmax</code>, for the minimum and maximum x-values in our grid, then we repeat the process for the y-values. Next we declare <code>rangex</code> for the x-range and <code>rangey</code> variable for the y-range. We calculate the value of <code>rangex</code> by subtracting <code>xmin</code> from <code>xmax</code> and do the same for the y-values.</p>&#13;
<p class="indent">Because we don’t need a graph that’s 600 units by 600 units, we need to scale the coordinates down by multiplying the x- and y-coordinates by scale factors. When graphing we have to remember to multiply all our x-coordinates and y-coordinates by these scale factors; otherwise, they won’t show up correctly on the screen. To do this, update the existing code in the <code>setup()</code> function with the lines of code in <a href="ch04.xhtml#ch04list7">Listing 4-7</a>.</p>&#13;
<pre><span class="pd_g1"><em>grid.pyde</em></span><br/><span class="pd_gray">def setup()</span><br/>    <span class="pd_green1">global</span> xscl, yscl<br/><span class="pd_gray">    size(600,600)</span><br/>    xscl = <span class="pd_raspberry">width</span> / rangex<br/><span epub:type="pagebreak" id="page_64"/>&#13;
    yscl = -<span class="pd_raspberry">height</span> / rangey</pre>&#13;
<p class="listing" id="ch04list7"><em>Listing 4-7: Scaling coordinates using scale factors</em></p>&#13;
<p class="indent">First, we declare the global variables <code>xscl</code> and <code>yscl</code>, which we’ll use to scale our screen. <code>xscl</code> and <code>yscl</code> stand for the x-scale factor and y-scale factor, respectively. For example, the x-scale factor would be 1 if we want our x-range to be 600 pixels, or the full width of the screen. But if we want our screen to be between −300 and 300, the x-scale factor would be 2, which we get by dividing the <code>width</code> (600) by the <code>rangex</code> (300).</p>&#13;
<p class="indent">In our case, we can calculate the scale factor by dividing 600 by the x-range, which is 20 (−10 to 10). So the scale factor has to be 30. From now on, we need to scale up all of our x- and y-coordinates by a factor of 30 so that they show on the screen. The good news is that the computer will do all the dividing and scaling for us. We just have to remember to use <code>xscl</code> and <code>yscl</code> when graphing!</p>&#13;
<h5 class="h5">Drawing a Grid</h5>&#13;
<p class="noindent">Now that we’ve set the proper dimensions for our graph, we can draw grid lines like the ones you see on graphing paper. Everything in the <code>setup()</code> function will be run once. Then we create an infinite loop with a function called <code>draw()</code>. <code>Setup()</code> and <code>draw()</code> are built-in Processing functions, and you can’t change their names if you want the sketch to run. Add the code in <a href="ch04.xhtml#ch04list8">Listing 4-8</a> to create the <code>draw()</code> function.</p>&#13;
<pre><span class="pd_g1"><em>grid.pyde</em></span><br/><span class="pd_gray">#set the range of x-values</span><br/><span class="pd_gray">xmin = -10</span><br/><span class="pd_gray">xmax = 10</span><br/><br/><span class="pd_gray">#range of y-values</span> <br/><span class="pd_gray">ymin = -10</span><br/><span class="pd_gray">ymax = 10</span><br/><br/><span class="pd_gray">#calculate the range</span><br/><span class="pd_gray">rangex = xmax - xmin</span><br/><span class="pd_gray">rangey = ymax - ymin</span><br/><br/><span class="pd_gray">def setup():</span><br/><span class="pd_gray">    global xscl, yscl</span> <br/><span class="pd_gray">    size(600,600)</span><br/><span class="pd_gray">    xscl = width / rangex</span><br/><span class="pd_gray">    yscl = height / rangey</span> <br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/><span class="pd_green1">    global</span> xscl, yscl<br/><span class="pd_blue1">    background</span>(255) <span class="pd_gray">#white</span><br/><span class="pd_blue1">    translate</span>(<span class="pd_raspberry">width</span>/2,<span class="pd_raspberry">height</span>/2)<br/>    <span class="pd_gray">#cyan lines</span><br/><span class="pd_blue1">    strokeWeight</span>(1)<br/><span epub:type="pagebreak" id="page_65"/>&#13;
<span class="pd_blue1">    stroke</span>(0,255,255)<br/><span class="pd_lime">    for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(xmin,xmax + 1):<br/><span class="pd_blue1">        line</span>(i*xscl,ymin*yscl,i*xscl,ymax*yscl)<br/><span class="pd_blue1">        line</span>(xmin*xscl,i*yscl,xmax*xscl,i*yscl)</pre>&#13;
<p class="listing" id="ch04list8"><em>Listing 4-8: Creating blue grid lines for the graph</em></p>&#13;
<p class="indent">First, we use <code>global xscl, yscl</code> to tell Python we’re not creating new variables but just using the global ones we already created. Then we set the background color to white using the value 255. We use Processing’s <code>translate()</code> function to move shapes up and down, or left and right. The code <code>translate(width/2,height/2)</code> will move the origin (where x and y are both 0) from the top left to the center of the screen. Then we set the thickness of the lines with <code>strokeWeight</code>, where <code>1</code> is the thinnest. You can make them thicker if you want by using higher numbers. You can also change the color of the lines using <code>stroke</code>. Here, we’re using cyan (“sky blue”), whose RGB value is (0,255,255), which means no red values, maximum green, and maximum blue.</p>&#13;
<p class="indent">After that, we use a <code>for</code> loop to avoid having to type 40 lines of code to draw 40 blue lines. We want the blue lines to go from <code>xmin</code> to <code>xmax</code>, including <code>xmax</code>, because that’s how wide our graph should be.</p>&#13;
<div class="sidebar">&#13;
<p class="title">RGB VALUES</p>&#13;
<p class="noindent">An RGB value is a mixture of red, green, and blue, in that order. The values range from 0 to 255. For example, (255,0,0) means “maximum red, no green, no blue.” Yellow is a mixture of red and green only, and cyan (“sky blue”) is a mixture of green and blue only.</p>&#13;
<div class="image"><img alt="image" src="../images/f065-01.jpg"/></div>&#13;
<p class="indent">Other colors are a mixture of different levels of red, green, and blue:</p>&#13;
<div class="image"><img alt="image" src="../images/f065-02.jpg"/></div>&#13;
<p class="indent">You can do a web search for “RGB Tables” to get RGB values for many more colors!</p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_66"/>In Processing, you can draw a line by declaring four numbers: the x- and y-coordinates of the beginning and endpoints of the line. The vertical lines would look something like this:</p>&#13;
<pre><span class="pd_blue1">line</span>(-10,-10, -10,10)<br/><span class="pd_blue1">line</span>(-9,-10, -9,10)<br/><span class="pd_blue1">line</span>(-8,-10, -8,10)</pre>&#13;
<p class="indent">But because <code>range(x)</code> doesn’t include <code>x</code> (as you learned previously), our <code>for</code> loop needs to go from <code>xmin</code> to <code>xmax + 1</code> to include <code>xmax</code>.</p>&#13;
<p class="indent">Similarly, the horizontal lines would go like this:</p>&#13;
<pre><span class="pd_blue1">line</span>(-10,-10, 10,-10)<br/><span class="pd_blue1">line</span>(-10,-9, 10,-9)<br/><span class="pd_blue1">line</span>(-10,-8, 10,-8)</pre>&#13;
<p class="indent">This time, you can see that the y-values are −10, −9, −8 and so on, whereas the x-values stay constant at −10 and 10, which are <code>xmin</code> and <code>xmax</code>. Let’s add another loop to go from <code>ymin</code> to <code>ymax</code>:</p>&#13;
<pre><span class="pd_gray">for i in range(xmin,xmax+1):</span><br/>    <span class="pd_gray">line(i,ymin,i,ymax)</span><br/><span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(ymin,ymax+1):<br/><span class="pd_blue1">    line</span>(xmin,i,xmax,i)</pre>&#13;
<p class="indent">If you graphed this right, you would now see a tiny splotch in the middle of the screen because the x- and y-coordinates go from −10 to 10, but the screen goes from 0 to 600 by default. This is because we haven’t multiplied all our x- and y-coordinates by their scale factor yet! To display the grid properly, update your code as follows:</p>&#13;
<pre><span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(xmin,xmax+1):<br/>    <span class="pd_blue1">line</span>(i*xscl,ymin*yscl,i*xscl,ymax*yscl)<br/><span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(ymin,ymax+1):<br/>    <span class="pd_blue1">line</span>(xmin*xscl,i*yscl,xmax*xscl,i*yscl)</pre>&#13;
<p class="indent">Now you’re ready to create the x- and y-axes.</p>&#13;
<h5 class="h5">Creating the X- and Y-Axes</h5>&#13;
<p class="noindent">To add the two black lines for the x- and y-axes, we first set the stroke color to black by calling the <code>stroke()</code> function (with 0 being black and 255 being white). Then we draw a vertical line from (0,−10) to (0,10) and a horizontal line from (−10,0) to (10,0). Don’t forget to multiply the values by their respective scale factors, unless they’re 0, in which case multiplying them wouldn’t change them anyway.</p>&#13;
<p class="indent">Listing 4-9 shows the complete code for creating the grid.</p>&#13;
<pre><span class="pd_g1"><em>grid.pyde</em></span><br/>    <span class="pd_gray">#cyan lines</span><br/>    <span class="pd_blue1">strokeWeight</span>(1)<br/>    <span class="pd_blue1">stroke</span>(0,255,255)<br/>    <span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(xmin,xmax+1):<br/>        <span class="pd_blue1">line</span>(i*xscl,ymin*yscl,i*xscl,ymax*yscl)<br/>    <span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(ymin,ymax+1):<br/>        <span class="pd_blue1">line</span>(xmin*xscl,i*yscl,xmax*xscl,i*yscl)<br/>    <span class="pd_blue1">stroke</span>(0) <span class="pd_gray">#black axes</span><br/>    <span class="pd_blue1">line</span>(0,ymin*yscl,0,ymax*yscl)<br/>    <span class="pd_blue1">line</span>(xmin*xscl,0,xmax*xscl,0)</pre>&#13;
<p class="listing" id="ch04list9"><em>Listing 4-9: Creating the grid lines</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_67"/>When you click <strong>Run</strong>, you should get a nice grid, like in <a href="ch04.xhtml#ch04fig3">Figure 4-3</a>.</p>&#13;
<div class="image"><a id="ch04fig3"/><img alt="image" src="../images/f067-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 4-3: You’ve created a grid for graphing—and you only have to do it once!</em></p>&#13;
<p class="indent">This looks done, but if we try to put a point (a tiny ellipse, actually) at (3,6), we see a problem. Add the following code to the end of the <code>draw()</code> function:</p>&#13;
<pre><span class="pd_g1"><em>grid.pyde</em></span><br/><span class="pd_gray">#test with a circle</span><br/><span class="pd_blue1">fill</span>(0)<br/><span class="pd_blue1">ellipse</span>(3*xscl,6*yscl,10,10)</pre>&#13;
<p class="indent">When you run this, you’ll see the output in <a href="ch04.xhtml#ch04fig4">Figure 4-4</a>.</p>&#13;
<div class="image"><a id="ch04fig4"/><img alt="image" src="../images/f067-02.jpg"/></div>&#13;
<p class="caption"><em>Figure 4-4: Checking our graphing program. Almost there!</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_68"/>As you can see, the point ends up on (3,−6) instead of at (3,6). Our graph is upside-down! To fix this, we can add a negative sign to the y-scale factor in the <code>setup()</code> function to flip it over:</p>&#13;
<pre>yscl = -height/rangey</pre>&#13;
<p class="indent">Now, you should see the point at the correct location, like in <a href="ch04.xhtml#ch04fig5">Figure 4-5</a>.</p>&#13;
<div class="image"><a id="ch04fig5"/><img alt="image" src="../images/f068-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 4-5: The grapher is working properly!</em></p>&#13;
<p class="indent">Now that we’ve written the graphing tool, let’s put it into a function so we can reuse it whenever we need to graph an equation.</p>&#13;
<h5 class="h5">Writing the grid() Function</h5>&#13;
<p class="noindent">To keep our code organized, we’ll separate all the code that makes the grid and place it in its own function, which we’ll call <code>grid()</code>. Then we’ll call the <code>grid()</code> function in the <code>draw()</code> function like in <a href="ch04.xhtml#ch04list10">Listing 4-10</a>.</p>&#13;
<pre><span class="pd_g1"><em>grid.pyde</em></span><br/><span class="pd_gray">def draw():</span><br/><span class="pd_gray">    global xscl, yscl</span><br/><span class="pd_gray">    background(255)</span><br/><span class="pd_gray">    translate(width/2,height/2)</span><br/>    grid(xscl,yscl) <span class="pd_gray">#draw the grid</span><br/><br/><span class="pd_green1">def</span> grid(xscl,yscl):<br/>    <span class="pd_gray">#Draws a grid for graphing</span><br/>    <span class="pd_gray">#cyan lines</span><br/>    <span class="pd_blue1">strokeWeight</span>(1)<br/>    <span class="pd_blue1">stroke</span>(0,255,255)<br/>    <span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(xmin,xmax+1):<br/>        <span class="pd_blue1">line</span>(i*xscl,ymin*yscl,i*xscl,ymax*yscl)<br/>    <span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(ymin,ymax+1):<br/>        <span class="pd_blue1">line</span>(xmin*xscl,i*yscl,xmax*xscl,i*yscl)<br/>    <span class="pd_blue1">stroke</span>(0) <span class="pd_gray">#black axes</span><br/><span epub:type="pagebreak" id="page_69"/>&#13;
    <span class="pd_blue1">line</span>(0,ymin*yscl,0,ymax*yscl)<br/>    <span class="pd_blue1">line</span>(xmin*xscl,0,xmax*xscl,0)</pre>&#13;
<p class="listing" id="ch04list10"><em>Listing 4-10: Moving all the grid code into a separate function</em></p>&#13;
<p class="indent">In programming we often organize our code into functions. Notice in <a href="ch04.xhtml#ch04list10">Listing 4-10</a> we can easily see what we’re executing in our <code>draw()</code> function. Now we’re ready to solve our cubic equation, 6<em>x</em><sup>3</sup> + 31<em>x</em><sup>2</sup> + 3<em>x</em> − 10 = 0.</p>&#13;
<h4 class="h4" id="ch04_1_8">GRAPHING AN EQUATION</h4>&#13;
<p class="noindent">Plotting graphs is a fun and visual way to find solutions of polynomials that have more than one potential solution for <em>x</em>. But before we try to graph a complicated equation like 6<em>x</em><sup>3</sup> + 31<em>x</em><sup>2</sup> + 3<em>x</em> − 10 = 0, let’s plot a simple parabola.</p>&#13;
<h5 class="h5">Plotting Points</h5>&#13;
<p class="noindent">Add this function after the <code>draw()</code> function from <a href="ch04.xhtml#ch04list10">Listing 4-10</a>:</p>&#13;
<pre><span class="pd_g1"><em>grid.pyde</em></span><br/><span class="pd_green1">def</span> f(x):<br/>    <span class="pd_lime">return</span> x**2</pre>&#13;
<p class="indent">This defines the function we’re calling <code>f(x)</code>. We’re telling Python what to do with the number <em>x</em> to produce the output of the function. In this case, we’re telling it to square the number <em>x</em> and return the output. Math classes have traditionally called functions <code>f(x), g(x), h(x)</code> and so on. Using a programming language, you can call functions whatever you like! We could have given this function a descriptive name like <code>parabola(x),</code> but since <code>f(x)</code> is commonly used, we’ll stick to that for now.</p>&#13;
<p class="indent">This is a simple parabola that we’ll graph before getting into more complicated functions. All the points on this curve are simply the values for <code>x</code> and its corresponding y-value. We could use a loop and draw small ellipses for points at all the whole-number values for <code>x</code>, but that would look like an unconnected group of points, as in <a href="ch04.xhtml#ch04fig6">Figure 4-6</a>.</p>&#13;
<div class="image"><a id="ch04fig6"/><img alt="image" src="../images/f069-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 4-6: A graph of disconnected dots</em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_70"/>Using a different kind of loop, we could draw dots closer together, as in <a href="ch04.xhtml#ch04fig7">Figure 4-7</a>.</p>&#13;
<div class="image"><a id="ch04fig7"/><img alt="image" src="../images/f070-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 4-7: The dots are closer together, but it’s still not a convincing curve</em>.</p>&#13;
<p class="indent">The best way to make a connected curve is to draw lines from point to point. If the points are close enough together, they’ll look curved. First, we’ll create a <code>graphFunction()</code> function after <code>f(x)</code>.</p>&#13;
<h5 class="h5">Connecting the Points</h5>&#13;
<p class="noindent">In the <code>graphFunction()</code> function, start <code>x</code> at <code>xmin</code>, like this:</p>&#13;
<pre><span class="pd_g1"><em>grid.pyde</em></span><br/><span class="pd_green1">def</span> graphFunction():<br/>    x = xmin</pre>&#13;
<p class="indent">To make the graph extend across the whole grid, we’ll keep increasing <code>x</code> until it’s equal to <code>xmax</code>. That means we’ll keep this loop going “while <code>x</code> is less than or equal to <code>xmax</code>,” as shown here:</p>&#13;
<pre><span class="pd_gray">def graphFunction():</span><br/><span class="pd_gray">    x = xmin</span><br/>    <span class="pd_lime">while</span> x &lt;= xmax:</pre>&#13;
<p class="indent">To draw the curve itself, we’ll draw lines from every point to every next point, going up a tenth of a unit at a time. Even if our function produces a curve, you probably won’t notice if we’re drawing a straight line between two points that are really close together. For example, the distance from (2, f(2)) to (2.1, f(2.1)) is tiny, so overall the output will look curved.</p>&#13;
<pre><span class="pd_green1">def</span> graphFunction():<br/>    x = xmin<br/>    <span class="pd_lime">while</span> x &lt;= xmax:<br/>        <span class="pd_blue1">fill</span>(0)<br/>        <span class="pd_blue1">line</span>(x*xscl,f(x)*yscl,(x+0.1)*xscl,f(x+0.1)*yscl)<br/>        x += 0.1</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_71"/>This code defines a function that draws a graph of <code>f(x)</code> by starting at <code>xmin</code> and going all the way up to <code>xmax</code>. While the x-value is less than or equal to <code>xmax</code>, we’ll draw a line from (x, f(x)) to ((x + 0.1), f(x + 0.1)). We can’t forget to increment <code>x</code> by 0.1 at the end of the loop.</p>&#13;
<p class="indent">Listing 4-11 shows the whole code for <em>grid.pyde</em>.</p>&#13;
<pre><span class="pd_g1"><em>grid.pyde</em></span><br/><span class="pd_gray">#set the range of x-values</span><br/>xmin = -10<br/>xmax = 10<br/><br/><span class="pd_gray">#range of y-values</span><br/>ymin = -10<br/>ymax = 10<br/><br/><span class="pd_gray">#calculate the range</span><br/>rangex = xmax - xmin<br/>rangey = ymax - ymin<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">setup</span>():<br/>    <span class="pd_green1">global</span> xscl, yscl<br/>    <span class="pd_blue1">size</span>(600,600)<br/>    xscl = <span class="pd_raspberry">width</span> / rangex<br/>    yscl = -<span class="pd_raspberry">height</span> / rangey<br/><br/><span class="pd_green1">def</span> <span class="pd_bluebold">draw</span>():<br/>    <span class="pd_green1">global</span> xscl, yscl<br/>    <span class="pd_blue1">background</span>(255) <span class="pd_gray">#white</span><br/>    <span class="pd_blue1">translate</span>(<span class="pd_raspberry">width</span>/2,<span class="pd_raspberry">height</span>/2)<br/>    grid(xscl,yscl)<br/>    graphFunction()<br/><br/><span class="pd_green1">def</span> f(x):<br/>    <span class="pd_lime">return</span> x**2<br/><br/><span class="pd_green1">def</span> graphFunction():<br/>    x = xmin<br/>    <span class="pd_lime">while</span> x &lt;= xmax:<br/>        <span class="pd_blue1">fill</span>(0)<br/>        <span class="pd_blue1">line</span>(x*xscl,f(x)*yscl,(x+0.1)*xscl,f(x+0.1)*yscl)<br/>        x += 0.1<br/><br/><span class="pd_green1">def</span> grid(xscl, yscl):<br/>    <span class="pd_purple">#Draws a grid for graphing</span><br/>    <span class="pd_gray">#cyan lines</span><br/>    <span class="pd_blue1">strokeWeight</span>(1)<br/>    <span class="pd_blue1">stroke</span>(0,255,255)<br/>    <span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(xmin,xmax+1):<br/>        <span class="pd_blue1">line</span>(i*xscl,ymin*yscl,i*xscl,ymax*yscl)<br/>    <span class="pd_lime">for</span> i <span class="pd_green1">in</span> <span class="pd_lime">range</span>(ymin,ymax+1):<br/>        <span class="pd_blue1">line</span>(xmin*xscl,i*yscl,xmax*xscl,i*yscl)<br/>    <span class="pd_blue1">stroke</span>(0) <span class="pd_gray">#black axes</span><br/><span epub:type="pagebreak" id="page_72"/>&#13;
    <span class="pd_blue1">line</span>(0,ymin*yscl,0,ymax*yscl)<br/>    <span class="pd_blue1">line</span>(xmin*xscl,0,xmax*xscl,0)</pre>&#13;
<p class="listing" id="ch04list11"><em>Listing 4-11: Complete code for graphing the parabola</em></p>&#13;
<p class="indent">This gets us the curve we’re looking for, as shown in <a href="ch04.xhtml#ch04fig8">Figure 4-8</a>.</p>&#13;
<div class="image"><a id="ch04fig8"/><img alt="image" src="../images/f072-01.jpg"/></div>&#13;
<p class="caption"><em>Figure 4-8: A nice continuous graph of a parabola!</em></p>&#13;
<p class="indent">Now we can change our function to something more complicated, and the grapher will easily draw it:</p>&#13;
<pre><span class="pd_g1"><em>grid.pyde</em></span><br/><span class="pd_green1">def</span> f(x):<br/>    <span class="pd_lime">return</span> 6*x**3 + 31*x**2 + 3*x − 10</pre>&#13;
<p class="indent">With this simple change, you’ll see the output in <a href="ch04.xhtml#ch04fig9">Figure 4-9</a>, but the function will be in black. If you prefer a red curve, change the <code>stroke(0)</code> line in <code>graphFunction()</code> to <code>stroke</code><code>(255,0,0)</code>, and you’ll get a red function.</p>&#13;
<div class="image"><a id="ch04fig9"/><img alt="image" src="../images/f072-02.jpg"/></div>&#13;
<p class="caption"><em>Figure 4-9: Graphing a polynomial function</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_73"/>It’s great to be able to simply change one line in the <code>f()</code> function and have the program automatically graph a different function! The solutions (called the <em>roots</em>) of the equation are where the graph crosses the x-axis. We can see three places: one where <em>x</em> = −5, another where <em>x</em> is between −1 and 0, and a third where <em>x</em> is between 0 and 1.</p>&#13;
<h4 class="h4" id="ch04_1_9">Using Guess and Check to Find the Roots</h4>&#13;
<p class="noindent">We already saw how effective our guess-and-check method was for guessing numbers in <a href="ch03.xhtml#ch03">Chapter 3</a>. Now we can use it to approximate the roots, or solutions, for the equation 6<em>x</em><sup>3</sup> + 31<em>x</em><sup>2</sup> + 3<em>x</em> − 10 = 0. Let’s start with the root between 0 and 1. Is it 0.5 or something else? To test this, we can easily plug 0.5 into the equation. Create a new file in IDLE, name it <em>guess.py</em>, and enter the following code:</p>&#13;
<pre><span class="pd_g1"><em>guess.py</em></span><br/><span class="pd_orange">def</span> <span class="codestrong1">f</span>(x):<br/>    <span class="pd_orange">return</span> 6*x**3 + 31*x**2 + 3*x − 10<br/><br/>&gt;&gt;&gt; <span class="codestrong1">f(0.5)</span><br/><span class="pd_blue">0.0</span></pre>&#13;
<p class="indent">As you can see, when <em>x</em> equals 0.5, it makes the function equal 0, so another solution of our equation is <em>x</em> = 0.5.</p>&#13;
<p class="indent">Next, let’s try to find the root between −1 and 0. We’ll try the average of −1 and 0 to start:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">f(-0.5)</span><br/><span class="literal1"><span class="pd_blue">-4.5</span></span></pre>&#13;
<p class="indent">At <em>x</em> = −0.5, the function is negative, not zero. Looking at the graph, we can tell we guessed too high, so the root must be somewhere between −1 and −0.5. We’ll average those endpoints and try again:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">f(-0.75)</span><br/><span class="literal1"><span class="pd_blue">2.65625</span></span></pre>&#13;
<p class="indent">We get a positive number, so we guessed too low. Therefore, the solution must be between −0.75 and −0.5:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">f(-0.625)</span><br/><span class="pd_blue">-1.23046875</span></pre>&#13;
<p class="indent">Still too high. This is getting a bit tedious. Let’s see how we might use Python to do these steps for us.</p>&#13;
<h4 class="h4" id="ch04_1_10">Writing the guess() Function</h4>&#13;
<p class="noindent">Let’s create a function that will find the roots of an equation by averaging the lower and upper values and adjusting its next guesses accordingly. This will work for our current task, where the function is passing through the <span epub:type="pagebreak" id="page_74"/>x-axis from positive to negative. For a function going up, from negative to positive, we’d have to change it around a little. <a href="ch04.xhtml#ch04list12">Listing 4-12</a> shows the complete code for this function.</p>&#13;
<pre><span class="pd_green">'''The guess method'''</span><br/><span class="pd_orange">def</span> <span class="pd_blue">f</span>(x):<br/>    <span class="pd_orange">return</span> 6*x**3 + 31*x**2 + 3*x - 10<br/><br/><span class="pd_orange">def</span> <span class="pd_blue">average</span>(a,b):<br/>    <span class="pd_orange">return</span> (a + b)/2.0<br/><br/><span class="pd_orange">def</span> <span class="pd_blue">guess</span>():<br/>    lower = -1<br/>    upper = 0<br/>  <span class="ent">➊</span> <span class="pd_orange">for</span> i <span class="pd_orange">in</span> <span class="pd_purple">range</span>(20):<br/>        midpt = average(lower,upper)<br/>        <span class="pd_orange">if</span> f(midpt) == 0:<br/>            <span class="pd_orange">return</span> midpt<br/>        <span class="pd_orange">elif</span> f(midpt) &lt; 0:<br/>            upper = midpt<br/>        <span class="pd_orange">else</span>:<br/>            lower = midpt<br/>    <span class="pd_orange">return</span> midpt<br/><br/>x = guess()<br/><br/><span class="pd_purple">print</span>(x,f(x))</pre>&#13;
<p class="listing" id="ch04list12"><em>Listing 4-12: The guess method for solving equations</em></p>&#13;
<p class="indent">First, we declare the function for the equation we’re trying to solve using <code>f(x)</code>. Then we create the <code>average()</code> function to find the average of two numbers, which we’ll be using at every step. Finally, we write a <code>guess()</code> function that starts with a lower limit of −1 and an upper limit of 0, since that’s where our graph crossed the x-axis.</p>&#13;
<p class="indent">We then use <code>for i in range(20):</code> <span class="ent">➊</span> to create a loop that cuts the range by half 20 times. Our guess will be the average, or midpoint, of the upper and lower limits. We put that midpoint into <code>f(x)</code> and if the output equals 0, we know that’s our root. If the output is negative, we know we guessed too high. Then the midpoint will replace our upper limit and we’ll take another guess. Otherwise, if we guessed too low, the midpoint will become our lower limit and we’ll guess again.</p>&#13;
<p class="indent">If we haven’t returned the solution in 20 guesses, we return the latest midpoint and the function of that midpoint.</p>&#13;
<p class="indent">When we run this, we should get two values as the output:</p>&#13;
<pre><span class="pd_blue">-0.6666669845581055 9.642708896251406e-06</span></pre>&#13;
<p class="indent">The first output is the x-value, which is very close to −2/3. The second output is what <code>f(x)</code> evaluates to when we plug in −2/3 as the x-value. The <code>e-06</code> at the end is scientific notation, which means you take 9.64 and move the decimal place to the left six places. So <code>f(x)</code> evaluates to 0.00000964, which is very <span epub:type="pagebreak" id="page_75"/>close to zero. To go through this guess-and-check program and get this solution, or rather an approximation accurate to within a millionth of the actual solution, to pop up in less than a second is still surprising and wonderful to me! Can you see the power in exploring math problems using free software like Python and Processing?</p>&#13;
<p class="indent">If we increase the number of iterations from 20 to 40, we get a number even closer to 0:</p>&#13;
<pre><span class="pd_blue">-0.6666666666669698 9.196199357575097e-12</span></pre>&#13;
<p class="indent">Let’s check <code>f(-0.6666666666669698)</code>, or <code>f(-2/3)</code>:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">f(-2/3)</span><br/><span class="literal1"><span class="pd_blue">0.0</span></span></pre>&#13;
<p class="indent">This checks out, so the three solutions to 6<em>x</em><sup>3</sup> + 31<em>x</em><sup>2</sup> + 3<em>x</em> − 10 = 0 are <em>x</em> = −5, −2/3, and 1/2.</p>&#13;
<div class="sidebar">&#13;
<p class="title">EXERCISE 4-3: FINDING MORE ROOTS</p>&#13;
<p class="noindent">Use the graphing tool you just created to find the roots of 2x<sup>2</sup> + 7x – 15 = 0. Remember, the roots are where the graph crosses the x-axis, or where the function equals 0. Check your answers using your <code>quad()</code> function.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch04_4">SUMMARY</h3>&#13;
<p class="noindent">Math class used to be all about taking years to learn how to solve equations of higher and higher degree. In this chapter you learned that this isn’t so hard to do programmatically using our guess-and-check method. You also wrote programs that solve equations in other ways, like using the quadratic formula and graphing. In fact, you learned that all we have to do to solve an equation, no matter how complicated, is to graph it and approximate where it crosses the x-axis. By iterating and halving the range of values that work, we can get as accurate as we want.</p>&#13;
<p class="indent">In programming, we use algebra to create variables to represent values that will change, like the size or coordinates of an object. The user can then change the value of a variable in one place, and the program will automatically change the value of that variable everywhere in the program. The user can also change these variables using a loop or declare the value in a function call. In future chapters we’ll model real-life situations where we need to use variables to represent parameters and constraints on the model, like energy content and force of gravity. Using variables lets us change values easily, to vary different aspects of the model.</p>&#13;
<p class="indent">In the next chapter you’ll use Processing to create interactive graphics, like rotating triangles and colorful grids!<span epub:type="pagebreak" id="page_76"/></p>&#13;
</body></html>