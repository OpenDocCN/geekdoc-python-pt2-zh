- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Visualizations
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Data can be viewed more clearly in a visual form than it can be as raw numbers.
    For example, you might want to create a line chart graphing the changes in a stock
    price over time. Or you could track the interest in the articles on your website
    using a histogram showing daily views of each. Visualizations such as these help
    you immediately recognize trends in your data.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides an overview of the most common types of data visualizations
    and covers how to create them using Matplotlib, a popular Python plotting library.
    You’ll also learn how to integrate Matplotlib with pandas and how to create maps
    with Matplotlib and the Cartopy library.
  prefs: []
  type: TYPE_NORMAL
- en: Common Visualizations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several chart types are available for visualizing data, including line graphs,
    bar graphs, pie charts, and histograms. In this section, we’ll discuss these common
    visualizations and explore typical use cases for each.
  prefs: []
  type: TYPE_NORMAL
- en: Line Graphs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Line graphs*, also known as *line charts*, are useful when you need to illustrate
    trends in data over a period of time. In a line graph, you place the timestamp
    column of a dataset along the x-axis and one or more numeric columns on the y-axis.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider a website where users can view different articles. You can create a
    chart for an article in which the x-axis plots a series of days and the y-axis
    displays how many times the article has been viewed each day. This is shown in
    [Figure 8-1](#figure8-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![A line graph with dates labeled along the x-axis and article views shown
    on the y-axis.](image_fi/502208c08/f08001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-1: A line graph showing article views over time'
  prefs: []
  type: TYPE_NORMAL
- en: You can overlay data from multiple parameters in one line chart to illustrate
    the correlation between them, plotting each parameter’s data with a line of a
    different color. For example, [Figure 8-2](#figure8-2) shows the website’s daily
    number of unique users on top of the number of article views.
  prefs: []
  type: TYPE_NORMAL
- en: '![The same line graph from Figure 8-1 with a second line added to show unique
    visitors each day. The two lines follow roughly the same shape.](image_fi/502208c08/f08002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-2: A line graph showing the relationship between various parameters'
  prefs: []
  type: TYPE_NORMAL
- en: The left-hand y-axis in this line graph shows article views, while the right-hand
    y-axis shows unique visitors. Overlaying the data for both parameters, it’s visually
    clear that there’s a general correlation between the numbers of article views
    and unique visitors.
  prefs: []
  type: TYPE_NORMAL
- en: Bar Graphs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Bar graphs*, also referred to as *bar charts* or *column charts*, show categorical
    data using rectangular bars with heights proportional to the values they represent,
    allowing for comparisons between categories. For example, consider the following
    figures, which represent a company’s annual sales aggregated on a regional basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 8-3](#figure8-3) illustrates what this sales data looks like when plotted
    on a bar graph.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A bar graph with vertical bars for three regions. The heights of the bars
    indicate the sales totals for each region.](image_fi/502208c08/f08003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-3: A bar graph showing comparative categorical data'
  prefs: []
  type: TYPE_NORMAL
- en: In this chart, the y-axis displays comparative sales figures for the regions
    shown on the x-axis.
  prefs: []
  type: TYPE_NORMAL
- en: Pie Charts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Pie charts* illustrate the proportion of each category in the full dataset,
    expressed as a percentage. [Figure 8-4](#figure8-4) illustrates the sales figures
    from the previous example when plotted on a pie chart.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A pie chart with three slices sized to show the sales totals for each of
    three regions.](image_fi/502208c08/f08004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-4: Pie charts represent the percentage of each category as a slice
    of a circle.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the size of each slice provides a visual representation of the proportion
    that each category contributes to the whole. You can easily see how the sales
    for each region compare to each other. This works well when each slice represents
    a substantial portion of the pie, but as you might guess, a pie chart isn’t the
    best choice when you have to represent very small portions. For example, a slice
    representing 0.01 percent of the whole may not even be visible in the chart.
  prefs: []
  type: TYPE_NORMAL
- en: Histograms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Histograms* show frequency distributions, or how many times a particular value
    or range of values appears in a dataset. Each value, or outcome, is represented
    by a vertical bar whose height corresponds to that value’s frequency. For example,
    the histogram in [Figure 8-5](#figure8-5) immediately makes apparent the frequency
    of different salary groups in a sales department.'
  prefs: []
  type: TYPE_NORMAL
- en: In this histogram, salaries are grouped into $50 ranges, with each vertical
    bar representing the number of people who have salaries within a certain range.
    The visualization lets you quickly see how many employees earn between $1,200
    and $1,250, for example, as compared to other ranges, like $1,250 to $1,300.
  prefs: []
  type: TYPE_NORMAL
- en: '![A histogram whose x-axis is divided into $50 increments from $1,100 to $1,850\.
    Vertical bars show how many people have a salary within each increment. Some increments
    are blank.](image_fi/502208c08/f08005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-5: A histogram showing a salary distribution'
  prefs: []
  type: TYPE_NORMAL
- en: Plotting with Matplotlib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve seen the most common types of charts, we’ll consider how to
    create them using Matplotlib, one of the most popular Python libraries for data
    visualization. You’ll learn how to make line graphs, pie charts, bar graphs, and
    histograms.
  prefs: []
  type: TYPE_NORMAL
- en: Each Matplotlib visualization, or *figure*, is built from a hierarchy of nested
    objects. You can work with those objects directly to create highly customizable
    visualizations, or you can manipulate the objects indirectly through the functions
    provided in the `matplotlib.pyplot` module. The latter approach is simpler and
    is often sufficient for creating basic charts and graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Matplotlib
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Check if Matplotlib is already installed by trying to import it in a Python
    interpreter session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get a `ModuleNotFoundError`, install Matplotlib with `pip` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using matplotlib.pyplot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `matplotlib.pyplot` module, typically referred to in code as `plt`, provides
    a collection of functions for building good-looking figures. The module lets you
    easily define various aspects of a figure, such as its title, its axis labels,
    and so on. For example, here’s how to construct a line graph plotting Tesla’s
    closing stock price over five consecutive days:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'First, you define your dataset as two lists: `days`, which contains the dates
    that will be plotted along the x-axis, and `prices`, which contains the prices
    that will be plotted along the y-axis. Then you create a *plot*, the part of the
    figure that actually shows the data, with the `plt.plot()` function, passing it
    the data for the x- and y-axes. In the next three lines of code, you customize
    the figure: you add a title with `plt.title()` and labels for the x- and y-axes
    with `plt.xlabel()` and `plt.ylabel()`. Finally, you display the figure with `plt.show()`.
    [Figure 8-6](#figure8-6) shows the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A line graph plotting the increase in Tesla stock prices over five days.](image_fi/502208c08/f08006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-6: A simple line graph generated with the `matplotlib.pyplot` module'
  prefs: []
  type: TYPE_NORMAL
- en: By default, `plt.plot()` yields a visualization rendered as a series of lines
    connecting the data points, which are plotted on the x- and y-axes. Matplotlib
    has automatically chosen a range of 720 to 880 for the y-axis, demarcated in intervals
    of 20, making it easy to see each day’s stock price.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building a basic pie chart is just as simple as making a line graph. For example,
    the following code generates the pie chart shown earlier in [Figure 8-4](#figure8-4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The script follows the same basic pattern you used to make the line graph:
    you define the data to be plotted, create a plot, customize some of its features,
    and display it. This time, the data consists of a list of regions, which will
    serve as labels for each slice of the pie chart, and a list of the sales totals
    for each region, which will define the size of each slice. To make the plot a
    pie chart rather than a line graph, you call the `plt.pie()` function, passing
    in `sales` as the data to be plotted and `regions` as the labels for the data.
    You also use the `autopct` parameter to display percent values in the pie slices,
    using Python string formatting to show the values to the nearest tenth of a percent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here you visualize the same input data as a bar graph, like the one in [Figure
    8-3](#figure8-3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You pass the `regions` list to the `plt.bar()` function as the x-axis labels
    for the bars. The second argument you pass to `plt.bar()` is the list with the
    sales figures corresponding to the items in `regions`. Both here and in the pie
    chart example, you’re able to use separate lists for labels and sales figures
    because the order of elements in a Python list is persistent.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Figure and Axes Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At heart, a Matplotlib visualization is built from two main types of objects:
    a `Figure` object and one or more `Axes` objects. In the previous examples, `matplotlib.pyplot`
    served as an interface for working indirectly with these objects, allowing you
    to customize some elements of a visualization. However, you can exert more control
    over your visualizations by working directly with the `Figure` and `Axes` objects
    themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Figure` object is the top-level, outermost container for a Matplotlib visualization.
    It can include one or more plots. You work with a `Figure` object when you need
    to do something with the overall visualization, such as resize it or save it to
    a file. Meanwhile, each `Axes` object represents one plot in the figure. You use
    an `Axes` object to customize a plot and define its layout. For example, you can
    set the coordinate system of the plot and mark positions on an axis.
  prefs: []
  type: TYPE_NORMAL
- en: You access the `Figure` and `Axes` objects through the `matplotlib.pyplot.subplots()`
    function. When invoked without arguments, this function returns a `Figure` instance
    and a single `Axes` instance associated with the `Figure`. By adding arguments
    to the `subplots()` function, you can create a `Figure` instance and multiple
    associated `Axes` instances. In other words, you’ll create a figure with multiple
    plots. For example, a call of `subplots(2,2)` creates a figure with four plots,
    arranged in two rows of two. Each plot is represented by one `Axes` object.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Histogram with subplots()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the following script, you use `subplots()` to create a `Figure` object and
    a single `Axes` object. You then manipulate the objects to produce the histogram
    shown earlier in [Figure 8-5](#figure8-5), displaying the salary distribution
    of a collection of employees. In addition to working with the `Figure` and `Axes`
    objects, you also work with a Matplotlib module called `matplotlib.ticker` to
    format the ticks along the x-axis of the plot as well as with NumPy to define
    a sequence of bins for the histogram in $50 increments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You start by defining a `salaries` list with the salary data you want to visualize
    ❶. You then invoke the `subplots()` function without parameters ❷, thus instructing
    it to create a figure containing a single plot. The function returns a tuple containing
    two objects, `fig` and `ax`, representing the figure and the plot, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have these `Figure` and `Axes` instances, you can begin to customize
    them. To start, you invoke the `set_size_inches()` method of the `Figure` object
    to resize the overall figure ❸. Then you invoke the `hist()` method of the `Axes`
    object to plot a histogram ❹. You pass the method the `salaries` list as the input
    data for the histogram, as well as a NumPy array defining the x-axis points for
    the histogram bins. You generate the array with NumPy’s `arange()` function, which
    produces an array of evenly spaced values within a given interval (in this case,
    increments of `50` between `1100` and `1900`). You use the `hist()` method’s `edgecolor`
    parameter to draw black line boundaries for the bins and the `linewidth` parameter
    to define the width of those boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you use the `FormatStrFormatter()` function from the `matplotlib.ticker`
    module to create a formatter that will prepend a dollar sign to each x-axis label
    ❺. You apply the formatter to the x-axis labels using the `set_major_formatter()`
    method of the `ax.xaxis` object ❻. Finally, you set the general aspects of the
    plot, such as its title and main axis labels, via the `matplotlib.pyplot` interface
    ❼ and display the plot.
  prefs: []
  type: TYPE_NORMAL
- en: Showing Frequency Distributions on a Pie Chart
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While histograms are well suited for visualizing frequency distributions, you
    can also use a pie chart to convey frequency distributions as percentages. As
    an example, this section shows how to transform the salary distribution histogram
    you just created into a pie chart displaying how the salaries are distributed
    as parts of a whole.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can create such a pie chart, you need to extract and organize some
    key information from the histogram. In particular, you need to learn the number
    of salaries in each $50 range. You can use NumPy’s `histogram()` function for
    this; it computes a histogram without displaying it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you call the `histogram()` function, passing it the same `salaries` list
    you created earlier and again using NumPy’s `arange()` function to generate evenly
    spaced bins. Calling `histogram()` returns two NumPy arrays: `count` and `labels`.
    The `count` array represents the number of employees with salaries in each interval
    and looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Meanwhile, the `labels` array contains the edges of the bin intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next you need to combine neighboring elements of the `labels` array, turning
    them into the labels for the slices of the pie chart. For example, neighboring
    elements `1100` and `1150` should become a single label formatted as `''$1100-1150''`.
    Use the following list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, the `labels` list will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Each element in `labels` corresponds to the element in the `count` array with
    the same index. Looking back at the `count` array, however, you may notice a problem:
    the count for some intervals is `0`, and you wouldn’t want to include these empty
    intervals to the pie chart. To exclude them, you need to generate a list of the
    indices corresponding to nonempty intervals in the `count` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can use `non_zero_pos` to filter `count` and `labels`, excluding those
    elements that represent empty intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all that remains is to create and display the pie chart using the `matplotlib.pyplot`
    interface and `plt.pie()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 8-7](#figure8-7) shows the result.'
  prefs: []
  type: TYPE_NORMAL
- en: The pie chart visualizes the same data as the histogram in [Figure 8-5](#figure8-5),
    but it shows each bin as a percentage of the whole instead of indicating exactly
    how many employees have salaries that fall within that bin.
  prefs: []
  type: TYPE_NORMAL
- en: '![A pie chart with slices showing the percentage of people with salaries in
    each $50 increment between $1,200 and $1,750\. A few slices are quite thin.](image_fi/502208c08/f08007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-7: A pie chart visualizing a frequency distribution'
  prefs: []
  type: TYPE_NORMAL
- en: Using Other Libraries with Matplotlib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Matplotlib can easily interface with other Python libraries to plot data from
    different sources or create other kinds of visualizations. For example, you can
    use Matplotlib in conjunction with pandas to plot the data from a DataFrame, or
    you can create maps by combining Matplotlib with Cartopy, a library that specializes
    in handling geospatial data.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting pandas Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The pandas library is closely integrated with Matplotlib. In fact, every pandas
    Series or DataFrame has a `plot()` method, which is actually a wrapper around
    the `matplotlib.pyplot.plot()` method. It allows you to directly convert a pandas
    data structure into a Matplotlib plot. To demonstrate, you’ll create a bar chart
    from a DataFrame with population data for US cities. You’ll use raw data from
    the *us-cities-top-1k.csv* file available at [https://github.com/plotly/datasets](https://github.com/plotly/datasets).
    The bar chart will show the number of megacities (those with a population of 1,000,000
    or greater) in each US state. Here’s how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You first load the dataset into a DataFrame using the pandas `read_csv()` method
    ❶. The dataset contains the population, latitude, and longitude of the 1,000 largest
    US cities. To filter the dataset to just megacities, you use the DataFrame’s `ge()`
    method, short for *greater than or equal to*, asking only for rows whose `Population`
    field is greater than or equal to `1000000` ❷. Then you group the data by the
    `State` column and apply the `count()` aggregate function to find the total number
    of megacities per state ❸. During the `groupby` operation, you set `as_index`
    to `False` to avoid converting the `State` column into the index of the resulting
    DataFrame. This is because you’ll need to refer to the `State` column later in
    the script. You rename the `City` column to `cities_count` to reflect that it
    now holds aggregate information and include only the `State` and `cities_count`
    columns in the resulting `top_cities_count` DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you draw a bar chart with the DataFrame’s `plot.bar()` method ❹. Remember,
    `plot()` is actually a wrapper for Matplotlib’s `pyplot.plot()` method. In this
    call, you specify the DataFrame column names that will be used as the x- and y-axes
    of the plot, and you rotate the x-axis tick labels to 0 degrees. Having created
    the figure, you’re then able to customize it with the `matplotlib.pyplot` interface,
    as you’ve done in earlier examples. You set the axis labels and the figure title
    ❺, and you use `plt.yticks()` to set number labels for the y-axis to reflect the
    top cities count ❻. Finally, you display the figure with `plt.show()`. [Figure
    8-8](#figure8-8) shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![A bar chart with vertical bars showing the number of megacities in the states
    of Arizona, California, Illinois, New York, Pennsylvania, and Texas.](image_fi/502208c08/f08008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-8: A bar chart generated from a pandas DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the figure has the same general appearance as the others you’ve
    created in this chapter, particularly the bar chart in [Figure 8-3](#figure8-3).
    This is not surprising, since it was generated by the same Matplotlib library,
    which pandas uses behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Plotting Geospatial Data with Cartopy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cartopy is a Python library for creating geospatial visualizations, or maps.
    It includes the `matplotlib.pyplot` programmatic interface, which makes drawing
    maps easy. Essentially, drawing a map with Cartopy becomes a matter of creating
    a Matplotlib figure with longitude coordinates plotted along the x-axis and latitude
    coordinates plotted along the y-axis. Cartopy handles the complexity of translating
    Earth’s spherical shape into the 2D plane of the plot. To demonstrate, you’ll
    use the *us-cities-top-1k.csv* dataset introduced in the previous section to draw
    outline maps of Southern California showing the locations of various cities. But
    first you need to set up Cartopy.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cartopy in Google Colab
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Installing Cartopy can be tricky, and the process varies depending on your system.
    Therefore, this section shows how to use Cartopy through the Google Colab web
    IDE, which allows you to write and execute Python code through your browser.
  prefs: []
  type: TYPE_NORMAL
- en: To load Colab, go to [https://colab.research.google.com](https://colab.research.google.com).
    Then click **New** **N****otebook** to start a new Colab notebook, where you can
    create, populate, and run an arbitrary number of code cells. In each code cell,
    you can group one or more lines of Python code together and execute them with
    a click of the run button in the top-left corner of the cell. Colab remembers
    the execution state built by any previously executed cells, similar to a Python
    interpreter session. You create new code cells with the +Code button in the upper-left
    corner of the Colab window.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first code cell, enter and run the following command to install Cartopy
    within your Colab notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Once Cartopy installs, you can proceed to the examples in the next section,
    running each separate listing as its own code cell.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Maps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this section, you’ll use Cartopy to create two maps of Southern California.
    First you’ll draw a map showing all the Southern California cities included in
    the *us-cities-top-1k.csv* dataset. You start by importing all the required modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll need pandas, the `matplotlib.pyplot` interface, and a few different
    Cartopy modules: `cartopy.crs` to generate maps and `LongitudeFormatter` and `LatitudeFormatter`
    to format the tick labels properly. The `%matplotlib inline` command is required
    to include Matplotlib figures in a Google Colab notebook, next to the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you load the required data and draw the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You load the *us-cities-top-1k.csv* dataset into a DataFrame ❶, as you did in
    the previous section. Remember, it contains geospatial data in the form of latitude
    and longitude coordinates, as well as population data. You then filter the data
    to include only California cities using the DataFrame’s `eq()` method ❷, short
    for *equal to*.
  prefs: []
  type: TYPE_NORMAL
- en: Since drawing a map requires more customization than the `matplotlib.pyplot`
    interface will allow, you need to work directly with the visualization’s underlying
    Matplotlib objects. You therefore call the `plt.subplots()` function to obtain
    a `Figure` object and a single `Axes` object, setting the figure size in the process
    ❸. You then call `plt.axes()` to overwrite the `Axes` object, turning it into
    a Cartopy map ❹. You do this by telling Matplotlib to use Cartopy’s Mercator projection
    when plotting coordinates on the flat surface of the figure. The Mercator projection
    is a standard mapmaking technique that converts Earth from a sphere to a cylinder,
    then unrolls that cylinder into a rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Next you call `ax.coastlines()` to show the outlines of landmasses on the map
    ❺. The coastal outlines are added to the current `Axes` object from the Natural
    Earth *coastline* shapefile collection. By specifying `10m`, you draw the coastlines
    at a scale of 1 to 10 million; that is, 1 centimeter on the map is equivalent
    to 100 kilometers in real life.
  prefs: []
  type: TYPE_NORMAL
- en: To define what the ticks along the y- and x-axes will be, you use the `set_yticks()`
    and `set_xticks()` methods, passing a list of latitudes and longitudes, respectively
    ❻. Specifically, you pass `32` through `36` as the y ticks and `-121` to `-115`
    as the x ticks (that is, 32°N to 36°N and 121°W to 115°W), since these latitudes
    and longitudes cover the area of Southern California. In both cases, you add `crs=ccrs.PlateCarree()`
    to specify how the latitude and longitude information should be projected onto
    a flat plane. Like the Mercator projection, Plate Carrée treats Earth as a cylinder
    that’s been flattened into a rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you create formatters using Cartopy’s `LongitudeFormatter()` and `LatitudeFormatter()`
    objects and apply them to the x- and y-axes ❼. Using these formatters ensures
    the longitude and latitude values will be shown with degree signs and a *W* or
    *N* for *west* or *north*, respectively. You also set the extent for the plot,
    specifying appropriate longitudes and latitudes to limit the map to showing only
    Southern California ❽. Then you extract two pandas Series objects from your DataFrame,
    `X` and `Y`, for the longitude and latitude values, respectively. Finally, you
    draw the map with Matplotlib’s `scatter()` method ❾, passing the data to plot
    on the x- and y-axes along with instructions to display the cities as red dots.
    [Figure 8-9](#figure8-9) shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![A map of Southern California with dots indicating cities. Latitude and longitude
    coordinates are labeled along the left and bottom sides of the map.](image_fi/502208c08/f08009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-9: An outline map of Southern California with cities'
  prefs: []
  type: TYPE_NORMAL
- en: 'The map provides a clear illustration of areas with a high population density.
    But what if you want to see only the largest cities marked with their names? Here’s
    how you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You filter the `calif_cities` DataFrame generated in the previous listing to
    only include those cities with populations of 400,000 or more ❶. Then you generate
    the plot by following the same process as before, with some extra steps for adding
    city labels. You store the city names in a pandas Series called `cities` ❷, then
    you iterate over the city names, assigning them as centered labels over the points
    on the map with Matplotlib’s `plt.text()` method ❸. You specify `transform=ccrs.Geodetic()`
    to make Matplotlib use Cartopy’s Geodetic coordinate system when adding the labels.
    This system treats Earth as a sphere and specifies coordinates as latitude and
    longitude values. [Figure 8-10](#figure8-10) shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![A map showing the same area as the previous figure. Three dots with text
    labels show the cities of Los Angeles, Long Beach, and San Diego.](image_fi/502208c08/f08010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-10: The largest cities in Southern California'
  prefs: []
  type: TYPE_NORMAL
- en: The map now shows the locations and names of the three cities in Southern California
    with populations over 400,000.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ve seen, data visualizations are a powerful tool for discovering trends
    and gaining insights from your data. For example, a line graph immediately reveals
    trends in a stock price, while a map can clearly illustrate areas of high population
    density. In this chapter, you learned how to create common visualizations like
    line graphs, bar graphs, pie charts, and histograms using the Matplotlib library.
    You saw how to build simple yet powerful visualizations with the `matplotlib.pyplot`
    interface and how to exert more control over the result by directly manipulating
    a visualization’s underlying `Figure` and `Axes` objects. You also learned how
    to use Matplotlib alongside pandas to visualize DataFrame data, and you practiced
    creating maps with Matplotlib and the Cartopy geospatial data processing library.
  prefs: []
  type: TYPE_NORMAL
