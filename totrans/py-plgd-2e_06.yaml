- en: '[4](nsp-venkitachalam503045-0008.xhtml#rch04)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[4](nsp-venkitachalam503045-0008.xhtml#rch04)'
- en: Musical Overtones with Karplus-Strong
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卡普鲁斯-斯特朗的音乐泛音
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: One of the main characteristics of any musical sound is its pitch, or *frequency*.
    This is the sound’s number of vibrations per second in hertz (Hz). For example,
    the fourth string of an acoustic guitar produces a D note with a frequency of
    146.83 Hz. You can approximate this sound by creating a sine wave with a frequency
    of 146.83 Hz on a computer, as shown in [Figure 4-1](nsp-venkitachalam503045-0016.xhtml#fig4-1).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 任何音乐声音的主要特征之一是其音高，或*频率*。这是声音每秒的振动次数，单位是赫兹（Hz）。例如，原声吉他的第四根弦会产生一个频率为146.83 Hz的D音符。你可以通过在计算机上创建一个频率为146.83
    Hz的正弦波来近似这个声音，如[图4-1](nsp-venkitachalam503045-0016.xhtml#fig4-1)所示。
- en: Unfortunately, if you play this sine wave on your computer, it won’t sound anything
    like a guitar. Nor will it sound like a piano, or any other real-world musical
    instrument for that matter. What makes a computer sound so different from a musical
    instrument when playing the same note?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果你在计算机上播放这个正弦波，它不会听起来像吉他。它也不会像钢琴或任何其他真实世界的乐器那样发声。为什么计算机播放相同音符时听起来与乐器的声音差异如此之大？
- en: '![](images/nsp-venkitachalam503045-f04001.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f04001.jpg)'
- en: 'Figure 4-1: A sine wave at 146.83 Hz'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-1：146.83 Hz的正弦波
- en: When you pluck a string on a guitar, the instrument produces a mix of frequencies
    with varying intensity. The sound is most intense when the note is first struck,
    and the intensity dies off over time. In the case of plucking a guitar’s D string,
    the dominant frequency you hear, called the *fundamental frequency*, is 146.83 Hz,
    but the sound also contains certain multiples of that frequency called *overtones*.
    In fact, the sound of any note on any instrument is composed of a fundamental
    frequency and overtones, and it’s the combination of these different frequencies
    at different intensities that makes a guitar sound like a guitar, a piano sound
    like a piano, and so on. By contrast, a pure sine wave generated by a computer
    contains only a fundamental frequency, and no overtones.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你弹奏吉他弦时，乐器会产生不同强度的频率混合。声音在第一次拨弦时最为强烈，之后强度逐渐减弱。在拨动吉他D弦的情况下，你听到的主频率被称为*基频*，为146.83
    Hz，但声音中也包含了一些该频率的倍频，称为*泛音*。实际上，任何乐器上发出的音符声音都由基频和泛音组成，正是这些不同频率在不同强度下的组合，使得吉他听起来像吉他，钢琴听起来像钢琴，等等。相比之下，由计算机生成的纯正弦波仅包含基频，没有泛音。
- en: You can see the evidence of overtones in *spectral plots*, like the one in [Figure
    4-2](nsp-venkitachalam503045-0016.xhtml#fig4-2) representing the D string of a
    guitar. A spectral plot shows all the frequencies present in a sound at a particular
    moment in time, as well as the intensity of those frequencies. Notice that there
    are many different peaks in the spectral plot shown in the figure, telling us
    that there are many frequencies present in the sound of the guitar’s D string
    being plucked. Near the far left of the plot, the highest peak represents the
    fundamental frequency. The other peaks, representing the overtones, are less intense,
    but they still contribute to the quality of the sound.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*频谱图*中看到泛音的证据，图[图4-2](nsp-venkitachalam503045-0016.xhtml#fig4-2)展示的是吉他D弦的频谱图。频谱图显示了在特定时间点上声音中所有存在的频率及其强度。请注意，图中频谱图有许多不同的峰值，告诉我们在拨动吉他D弦时，声音中有许多不同的频率。频谱图最左边的最高峰代表了基频。其他的峰代表泛音，虽然强度较小，但它们仍然对声音的质量起到了作用。
- en: '![](images/nsp-venkitachalam503045-f04002.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f04002.jpg)'
- en: 'Figure 4-2: A spectral plot of the note D3 played on a guitar'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-2：吉他弹奏D3音符的频谱图
- en: 'As you can see, to simulate the sound of a plucked string instrument on the
    computer, you need to be able to generate both the fundamental frequency and the
    overtones. The trick is to use the Karplus-Strong algorithm. In this project,
    you’ll generate five guitar-like notes of a musical scale (a series of related
    notes) using the Karplus-Strong algorithm. You’ll visualize the algorithm used
    to generate these notes and save the sounds as WAV files. You’ll also create a
    way to play them at random and learn how to do the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，要在计算机上模拟拨弦乐器的声音，你需要能够生成基频和泛音。诀窍就是使用卡普鲁斯-斯特朗算法。在这个项目中，你将使用卡普鲁斯-斯特朗算法生成五个类似吉他的音符（一个系列相关音符）。你将可视化生成这些音符的算法并将声音保存为WAV文件。你还将创建一种随机播放它们的方式，并学习如何做以下事情：
- en: • Implement a ring buffer using the Python `deque` class.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用Python的`deque`类实现环形缓冲区。
- en: • Use `numpy` arrays.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`numpy`数组。
- en: • Play WAV files using `pyaudio`.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`pyaudio`播放WAV文件。
- en: • Plot a graph using `matplotlib`.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`matplotlib`绘制图表。
- en: • Play the pentatonic musical scale.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 演奏五声音阶。
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah0601)'
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[它是如何工作的](nsp-venkitachalam503045-0008.xhtml#rah0601)'
- en: Imagine a string tied down at both ends, like a string on a guitar. When you
    pluck this string, it vibrates for a while, making a sound, and then settles back
    down to its resting position. At any given point in time while the string is vibrating,
    different parts of the string will be at different displacements from their resting
    position. These displacements can also be thought of as amplitudes of the sound
    wave produced by the vibrating string. The Karplus-Strong algorithm is a series
    of steps for generating and updating a series of these displacement or amplitude
    values to represent the motion of a wave along a plucked string. Play back those
    values as a WAV file and you get a pretty convincing simulation of a plucked string
    sound.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一根两端固定的弦，就像吉他上的弦。当你拨动这根弦时，它会震动一段时间，发出声音，然后恢复到静止位置。在弦震动的任何时刻，弦的不同部分将会与它的静止位置有不同的位移。这些位移也可以看作是弦震动所产生的声波的振幅。卡普鲁斯-斯特朗算法是一系列步骤，用于生成和更新这些位移或振幅值，以表示拨动弦上的波动。将这些值作为WAV文件播放，你就能得到一个非常逼真的拨弦声音模拟。
- en: The Karplus-Strong algorithm stores displacement values in a *ring buffer* (also
    known as a *circular buffer*), a fixed-length buffer (just an array of values)
    that wraps around itself. In other words, when you reach the end of the buffer,
    the next element you access will be the first element in the buffer. (See [“Implementing
    the Ring Buffer with deque”](nsp-venkitachalam503045-0016.xhtml#bh0604) on [page
    66](nsp-venkitachalam503045-0016.xhtml#p66) for more about ring buffers.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 卡普鲁斯-斯特朗算法将位移值存储在*环形缓冲区*（也叫*循环缓冲区*）中，这是一个固定长度的缓冲区（实际上是一个数值数组），它会绕回自身。换句话说，当你到达缓冲区的末尾时，接下来的元素会是缓冲区中的第一个元素。（关于环形缓冲区的更多内容，请参见[“使用deque实现环形缓冲区”](nsp-venkitachalam503045-0016.xhtml#bh0604)，详见[第66页](nsp-venkitachalam503045-0016.xhtml#p66)。）
- en: The length (*N*) of the ring buffer is related to the fundamental frequency
    of the note you want to simulate according to the equation *N* = *S*/*f*, where
    *S* is the sampling rate (more on this later) and *f* is the frequency. At the
    start of the simulation, the buffer is filled with random values in the range
    [−0.5, 0.5], which you might think of as representing the random displacement
    of a string when it’s first plucked. As the simulation progresses, the values
    are updated according to the steps of the Karplus-Strong algorithm, which we’ll
    outline next.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 环形缓冲区的长度(*N*)与所需模拟音符的基频有关，关系式为*N* = *S*/*f*，其中*S*是采样率（稍后会讲解），*f*是频率。在模拟开始时，缓冲区会被填充为[−0.5,
    0.5]范围内的随机值，你可以将这些值理解为表示弦在首次拨动时的随机位移。随着模拟的进行，数值会根据卡普鲁斯-斯特朗算法的步骤进行更新，接下来我们将概述这些步骤。
- en: In addition to the ring buffer, you’ll use a *samples buffer* to store the intensity
    of the sound at any particular time. This buffer represents the final sound data,
    and it’s built up based on the values in the ring buffer. The length of the samples
    buffer and the sampling rate determine the length of the sound clip.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了环形缓冲区，你还需要使用*采样缓冲区*来存储某一特定时间点的声音强度。这个缓冲区代表了最终的声音数据，并且是基于环形缓冲区中的数值构建的。采样缓冲区的长度和采样率决定了声音片段的长度。
- en: '[The Simulation](nsp-venkitachalam503045-0008.xhtml#rbh0601)'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[模拟](nsp-venkitachalam503045-0008.xhtml#rbh0601)'
- en: 'During each time step in the simulation, a value from the ring buffer is stored
    in the samples buffer, and then the values in the ring buffer are updated in a
    kind of feedback scheme, as shown in [Figure 4-3](nsp-venkitachalam503045-0016.xhtml#fig4-3).
    Once the samples buffer is full, you write its contents to a WAV file so the simulated
    note can be played back as audio. For each time step of the simulation, you follow
    these steps, which together make up the Karplus-Strong algorithm:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在仿真的每个时间步骤中，环形缓冲区中的一个值会被存储到样本缓冲区中，然后环形缓冲区中的值会以一种反馈机制进行更新，如[图 4-3](nsp-venkitachalam503045-0016.xhtml#fig4-3)所示。一旦样本缓冲区已满，就将其内容写入
    WAV 文件，以便模拟的音符可以作为音频播放。对于仿真的每个时间步骤，您将遵循以下步骤，这些步骤共同构成了卡普鲁斯-斯特朗算法：
- en: 1\. Store the first value from the ring buffer in the samples buffer.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 将环形缓冲区中的第一个值存储到样本缓冲区。
- en: 2\. Calculate the average of the first two elements in the ring buffer.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 计算环形缓冲区中前两个元素的平均值。
- en: 3\. Multiply this average value by an attenuation factor (in this case, 0.995).
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 将该平均值乘以一个衰减因子（在此例中为 0.995）。
- en: 4\. Append this value to the end of the ring buffer.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 将该值附加到环形缓冲区的末尾。
- en: 5\. Remove the first element of the ring buffer.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5\. 移除环形缓冲区中的第一个元素。
- en: '![](images/nsp-venkitachalam503045-f04003.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f04003.jpg)'
- en: 'Figure 4-3: A ring buffer and the Karplus-Strong algorithm'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-3：环形缓冲区与卡普鲁斯-斯特朗算法
- en: This feedback scheme is designed to simulate a wave traveling through a vibrating
    string. The numbers in the ring buffer represent the energy of the wave at each
    point on the string. According to physics, the fundamental frequency of a vibrating
    string is inversely proportional to its length. Since we’re interested in generating
    sounds of a certain frequency, we choose a ring buffer length inversely proportional
    to the desired frequency (this is the *N* = *S*/*f* formula mentioned earlier).
    The averaging that happens in step 2 of the algorithm acts as a *low-pass filter*
    that cuts off higher frequencies and allows lower frequencies through, thereby
    eliminating higher harmonics (that is, larger multiples of the fundamental frequency)
    because you’re mainly interested in the fundamental frequency. The attenuation
    factor in step 3 simulates the loss of energy as the wave travels back and forth
    along the string. This corresponds to the fading of the sound over time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 该反馈机制旨在模拟波在振动弦上的传播。环形缓冲区中的数字表示弦上每个点的波能量。根据物理学原理，振动弦的基频与其长度成反比。由于我们希望生成特定频率的声音，因此选择与期望频率成反比的环形缓冲区长度（这就是前面提到的
    *N* = *S*/*f* 公式）。算法第 2 步中的平均操作充当了一个*低通滤波器*，它会切除较高的频率，允许较低的频率通过，从而消除较高的谐波（即基频的较大倍数），因为我们主要关心的是基频。第
    3 步中的衰减因子模拟了波沿弦来回传播时能量的损失。这对应于声音随时间的衰减。
- en: The samples buffer that you add to in step 1 of the simulation represents the
    amplitude of the generated sound over time. Storing the attenuated values at the
    end of the ring buffer (step 4) and removing the first item from the ring buffer
    (step 5) ensures that a steady stream of gradually attenuating values will be
    passed to the samples buffer to build up the simulated sound.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在仿真步骤 1 中添加的样本缓冲区表示生成的声音随时间的振幅。通过在环形缓冲区的末尾存储衰减值（步骤 4）并从环形缓冲区中移除第一个项目（步骤 5），可以确保逐渐衰减的值不断传递到样本缓冲区，从而构建模拟的声音。
- en: Let’s look at a simple example of the Karplus-Strong algorithm in action. [Table
    4-1](nsp-venkitachalam503045-0016.xhtml#tab4-1) represents a ring buffer at two
    consecutive time steps. Each value in the ring buffer represents the amplitude
    of the sound, which is the same as the displacement of a point on a plucked string
    from its rest position. The buffer has five elements, and they are initially filled
    with some numbers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个卡普鲁斯-斯特朗算法实际应用的简单示例。[表 4-1](nsp-venkitachalam503045-0016.xhtml#tab4-1)表示两个连续时间步骤中的环形缓冲区。环形缓冲区中的每个值代表声音的振幅，这与拨动弦线时某个点相对于其静止位置的位移相同。缓冲区有五个元素，最初填充了一些数值。
- en: 'Table 4-1: A Ring Buffer at Two Time Steps in the Karplus-Strong Algorithm'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1：卡普鲁斯-斯特朗算法中两个时间步骤的环形缓冲区
- en: '| Time step 1 | 0.1 | −0.2 | 0.3 | 0.6 | −0.5 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 时间步骤 1 | 0.1 | −0.2 | 0.3 | 0.6 | −0.5 |'
- en: '| Time step 2 | −0.2 | 0.3 | 0.6 | −0.5 | −0.04975 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 时间步骤 2 | −0.2 | 0.3 | 0.6 | −0.5 | −0.04975 |'
- en: As you go from time step 1 to time step 2, you apply the Karplus-Strong algorithm
    as follows. The first value in the first row, 0.1, is removed, and all subsequent
    values from time step 1 are added in the same order to the second row, which represents
    time step 2\. The last value in time step 2 is the attenuated average of the first
    and second values of time step 1, which is calculated as 0.995 × ((0.1 + −0.2)
    ÷ 2) = −0.04975.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从时间步长 1 进入时间步长 2 时，你按如下方式应用 Karplus-Strong 算法。第一行中的第一个值 0.1 被移除，时间步长 1 中的所有后续值按相同顺序添加到第二行中，这代表时间步长
    2。时间步长 2 中的最后一个值是时间步长 1 中第一个和第二个值的衰减平均值，计算方式为 0.995 × ((0.1 + −0.2) ÷ 2) = −0.04975。
- en: '[The WAV File Format](nsp-venkitachalam503045-0008.xhtml#rbh0602)'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[WAV 文件格式](nsp-venkitachalam503045-0008.xhtml#rbh0602)'
- en: The *Waveform Audio File Format (WAV)* is used to store audio data. This format
    is convenient for small audio projects because it’s simple and doesn’t require
    you to worry about complicated compression techniques.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*波形音频文件格式 (WAV)* 用于存储音频数据。这个格式适用于小型音频项目，因为它简单且不需要你担心复杂的压缩技术。'
- en: In its simplest form, a WAV file consists of a series of values, where each
    value represents the amplitude of the stored sound at a given point in time. Each
    value is allotted a fixed number of bits, called the *resolution*. You’ll use
    16-bit resolution in this project. WAV files also have a set *sampling rate*,
    which is the number of times the audio is *sampled*, or read, every second. In
    this project, you use a sampling rate of 44,100 Hz, the rate used in audio CDs.
    In sum, when you generate a WAV file simulating the sound of a plucked string,
    it will contain 44,100 16-bit values for every second of audio.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式下，WAV 文件由一系列值组成，每个值表示在给定时间点存储声音的振幅。每个值都分配了固定数量的位，称为 *分辨率*。在这个项目中，你将使用
    16 位分辨率。WAV 文件还有一个固定的 *采样率*，即每秒钟对音频进行的 *采样* 次数，或者说读取的次数。在这个项目中，你使用的是 44,100 Hz
    的采样率，这是音频 CD 所使用的采样率。总之，当你生成一个模拟拨弦声音的 WAV 文件时，每秒钟的音频将包含 44,100 个 16 位的值。
- en: 'For this project, you’ll be using Python’s `wave` module, which includes methods
    for working with WAV files. To get a feel for how it works, let’s generate a five-second
    audio clip of a 220 Hz sine wave using Python. First you represent a sine wave
    using this formula:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你将使用 Python 的 `wave` 模块，它包含了处理 WAV 文件的方法。为了了解它的工作方式，让我们使用 Python 生成一个
    220 Hz 正弦波的五秒钟音频片段。首先，你可以使用这个公式表示一个正弦波：
- en: '*A* = sin(2π*ft*)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*A* = sin(2π*ft*)'
- en: 'Here, *A* is the amplitude of the wave, *f* is the frequency, and *t* is the
    current time index. Now you rewrite this equation as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*A* 是波的振幅，*f* 是频率，*t* 是当前的时间索引。现在你将这个方程重新写为如下形式：
- en: '*A* = sin(2π*fi*/*R*)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*A* = sin(2π*fi*/*R*)'
- en: In this equation, *i* is the index of the sample, and *R* is the sampling rate.
    Using these two equations, you can create a five-second WAV file for a 200 Hz
    sine wave as follows. (This code is available in *sine.py* in the chapter’s GitHub
    repository.)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方程中，*i* 是样本的索引，*R* 是采样率。使用这两个方程，你可以为 200 Hz 的正弦波创建一个五秒钟的 WAV 文件，如下所示。（此代码可以在章节的
    GitHub 仓库中的 *sine.py* 文件中找到。）
- en: import numpy as np
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: import wave, math
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: import wave, math
- en: sRate = 44100
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: sRate = 44100
- en: nSamples = sRate * 5
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: nSamples = sRate * 5
- en: ❶ x = np.arange(nSamples)/float(sRate)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ x = np.arange(nSamples)/float(sRate)
- en: ❷ vals = np.sin(2.0*math.pi*220.0*x)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ vals = np.sin(2.0*math.pi*220.0*x)
- en: ❸ data = np.array(vals*32767, 'int16').tostring()
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ data = np.array(vals*32767, 'int16').tostring()
- en: file = wave.open('sine220.wav', 'wb')
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: file = wave.open('sine220.wav', 'wb')
- en: ❹ file.setparams((1, 2, sRate, nSamples, 'NONE', 'uncompressed'))
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ file.setparams((1, 2, sRate, nSamples, 'NONE', 'uncompressed'))
- en: ❺ file.writeframes(data)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ file.writeframes(data)
- en: file.close()
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: file.close()
- en: You create a `numpy` array of numbers from `0` to `nSamples − 1` and divide
    those numbers by the sample rate to get the time value, in seconds, when each
    sample of the audio clip is taken ❶. This array represents the *i*/*R* portion
    of the sine wave equation discussed earlier. Next, you use the array to create
    a second `numpy` array, this one containing sine wave amplitude values, again
    following the sine wave equation ❷. The `numpy` array is a fast and convenient
    way to apply functions such as the `sin()` function to many values at once.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个从 `0` 到 `nSamples − 1` 的 `numpy` 数组，并将这些数字除以采样率，以得到每个音频片段样本的时间值，单位为秒 ❶。这个数组代表了先前讨论的正弦波方程中的
    *i*/*R* 部分。接下来，你使用这个数组创建了第二个 `numpy` 数组，包含了正弦波的振幅值，同样遵循正弦波方程 ❷。`numpy` 数组是一种快速且方便的方式，可以将像
    `sin()` 函数这样的函数应用于许多值。
- en: The computed sine wave values in the range [−1, 1] are scaled to 16-bit values
    and converted to a string so they can be written to a WAV file ❸. Then you set
    the parameters for the WAV file; in this case, it’s a single-channel (mono), 2-byte
    (16-bit), uncompressed format ❹. Finally, you write the data to the file ❺. [Figure
    4-4](nsp-venkitachalam503045-0016.xhtml#fig4-4) shows the generated *sine220.wav*
    file in Audacity, a free audio editor. As expected, you see a sine wave of frequency
    220 Hz, and when you play the file, you hear a 220 Hz tone for five seconds. (Note
    that you need to use the Zoom tool in Audacity to see the sine wave as shown in
    [Figure 4-4](nsp-venkitachalam503045-0016.xhtml#fig4-4).)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 计算得到的正弦波值在[-1, 1]范围内被缩放为16位值，并转换为字符串，以便写入WAV文件 ❸。然后你设置WAV文件的参数；在这种情况下，它是一个单通道（单声道）、2字节（16位）、未压缩的格式
    ❹。最后，你将数据写入文件 ❺。[图 4-4](nsp-venkitachalam503045-0016.xhtml#fig4-4)显示了在Audacity（一款免费的音频编辑软件）中生成的*sine220.wav*文件。如预期所示，你看到一个频率为220
    Hz的正弦波，当你播放该文件时，你会听到一个220 Hz的音调，持续五秒钟。（请注意，你需要在Audacity中使用缩放工具，才能看到如[图 4-4](nsp-venkitachalam503045-0016.xhtml#fig4-4)所示的正弦波。）
- en: '![](images/nsp-venkitachalam503045-f04004.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f04004.jpg)'
- en: 'Figure 4-4: A sine wave at 220 Hz, zoomed in'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-4：220 Hz的正弦波，已缩放
- en: In your project, once you’ve filled the samples buffer with audio data, you’ll
    write it to a WAV file using the same pattern illustrated in [Figure 4-4](nsp-venkitachalam503045-0016.xhtml#fig4-4).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中，一旦你用音频数据填充了样本缓冲区，你将按照[图 4-4](nsp-venkitachalam503045-0016.xhtml#fig4-4)中展示的相同模式将其写入WAV文件。
- en: '[The Minor Pentatonic Scale](nsp-venkitachalam503045-0008.xhtml#rbh0603)'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[小调五声音阶](nsp-venkitachalam503045-0008.xhtml#rbh0603)'
- en: A *musical scale* is a series of notes in increasing or decreasing pitch (frequency).
    Often, all notes in a piece of music are chosen from a particular scale. A *musical
    interval* is the difference between two pitches. A *semitone* is a basic building
    block of a scale and is the smallest musical interval in Western music. A *tone*
    is twice the length of a semitone. The *major scale*, one of the most common musical
    scales, is defined by the interval pattern *tone-tone-semitone-tone-tone-tone-semitone*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*音阶*是一个音符的系列，这些音符按升高或降低的音高（频率）排列。通常，一首音乐中的所有音符都是从某个特定的音阶中选出的。*音程*是两个音高之间的差异。*半音*是音阶的基本构建块，也是西方音乐中最小的音程。*全音*是半音的两倍长度。*大调音阶*是最常见的音阶之一，其间隔模式为*全音-全音-半音-全音-全音-全音-半音*。'
- en: We’ll briefly go into the pentatonic scale here, since you’ll be generating
    musical notes in that scale. This section will explain the source of the frequency
    numbers used in the final program to generate notes with the Karplus-Strong algorithm.
    The *pentatonic scale* is a five-note musical scale. A variant of this scale is
    the *minor pentatonic scale*, which is defined by the interval pattern *(tone+semitone)-tone-tone-(tone+semitone)-tone*.
    Thus, the C minor pentatonic scale consists of the notes C, E-flat, F, G, and
    B-flat. [Table 4-2](nsp-venkitachalam503045-0016.xhtml#tab4-2) lists the frequencies
    of the five notes of a C minor pentatonic scale that you’ll generate using the
    Karplus-Strong algorithm. (Here, C4 designates C in the fourth octave of a piano,
    or *middle C*, by convention.)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里简要介绍五声音阶，因为你将在该音阶中生成音符。本节将解释在最终程序中使用的频率数字的来源，这些频率数字将通过Karplus-Strong算法生成音符。*五声音阶*是一个由五个音符组成的音乐音阶。该音阶的变体是*小调五声音阶*，其间隔模式为*(全音+半音)-全音-全音-(全音+半音)-全音*。因此，C小调五声音阶由C、降E、F、G和降B五个音符组成。[表
    4-2](nsp-venkitachalam503045-0016.xhtml#tab4-2)列出了你将使用Karplus-Strong算法生成的C小调五声音阶的五个音符的频率。（在这里，C4表示钢琴第四八度的C音，或*中央C*，根据约定。）
- en: 'Table 4-2: Notes in a Minor Pentatonic Scale'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-2：小调五声音阶中的音符
- en: '| Note | Frequency (Hz) |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 音符 | 频率（Hz） |'
- en: '| --- | --- |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| C4 | 261.6 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| C4 | 261.6 |'
- en: '| E-flat | 311.1 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 降E | 311.1 |'
- en: '| F | 349.2 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| F | 349.2 |'
- en: '| G | 392.0 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| G | 392.0 |'
- en: '| B-flat | 466.2 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 降B | 466.2 |'
- en: One aspect of this project will be stringing together random sequences of notes
    to create melodies. One of the reasons we’re focusing on a minor pentatonic scale
    is that the notes of this scale sound pleasing no matter what order they’re played
    in. Thus, the scale is particularly conducive to generating random melodies in
    a way that other scales, such as a major scale, are not.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的一个方面将是将随机的音符序列串联在一起以创建旋律。我们之所以专注于小调五声音阶，是因为该音阶的音符无论以何种顺序演奏都听起来和谐。因此，这个音阶特别适合生成随机旋律，而不像其他音阶（例如大调音阶）那样受限。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah0602)'
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[需求](nsp-venkitachalam503045-0008.xhtml#rah0602)'
- en: In this project, you’ll use the Python `wave` module to create audio files in
    the WAV format. To implement the Karplus-Strong algorithm, you’ll use the `deque`
    class from the Python `collections` module as a ring buffer and a `numpy` array
    as a samples buffer. You’ll also use `matplotlib` to visualize the simulated guitar
    string, and you’ll play back the WAV files with the `pyaudio` module.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用Python的`wave`模块来创建WAV格式的音频文件。为了实现Karplus-Strong算法，你将使用Python `collections`模块中的`deque`类作为环形缓冲区，以及使用`numpy`数组作为样本缓冲区。你还将使用`matplotlib`来可视化模拟的吉他弦，并使用`pyaudio`模块来回放WAV文件。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah0603)'
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah0603)'
- en: Now let’s develop the various pieces of code required to implement the Karplus-Strong
    algorithm and then put them together for the complete program. To see the full
    project code, skip ahead to [“The Complete Code”](nsp-venkitachalam503045-0016.xhtml#ah0607)
    on [page 74](nsp-venkitachalam503045-0016.xhtml#p74). You can also download the
    code from the book’s GitHub repository at [https://github.com/mkvenkit/pp2e/tree/main/karplus](https://github.com/mkvenkit/pp2e/tree/main/karplus).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开发实现Karplus-Strong算法所需的各种代码块，并将它们组合成完整的程序。要查看完整的项目代码，请跳至[“完整代码”](nsp-venkitachalam503045-0016.xhtml#ah0607)，该部分位于[第74页](nsp-venkitachalam503045-0016.xhtml#p74)。你也可以从本书的GitHub仓库下载代码：[https://github.com/mkvenkit/pp2e/tree/main/karplus](https://github.com/mkvenkit/pp2e/tree/main/karplus)。
- en: '[Implementing the Ring Buffer with deque](nsp-venkitachalam503045-0008.xhtml#rbh0604)'
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[使用deque实现环形缓冲区](nsp-venkitachalam503045-0008.xhtml#rbh0604)'
- en: Recall from earlier that the Karplus-Strong algorithm uses a ring buffer to
    generate a musical note. You’ll implement the ring buffer using a `deque` container
    (pronounced “deck”), which is part of Python’s `collections` module of specialized
    container data types. You can insert and remove elements from the beginning (head)
    or end (tail) of a `deque` (see [Figure 4-5](nsp-venkitachalam503045-0016.xhtml#fig4-5)).
    This insertion and removal process is a `O(1)`, or a “constant time” operation,
    which means it takes the same amount of time regardless of how big the `deque`
    container gets.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，Karplus-Strong算法使用环形缓冲区来生成一个音符。你将使用`deque`容器（发音为“deck”）来实现环形缓冲区，它是Python
    `collections`模块中的一个专用容器数据类型。你可以从`deque`的开头（头部）或结尾（尾部）插入和移除元素（参见[图4-5](nsp-venkitachalam503045-0016.xhtml#fig4-5)）。这个插入和移除过程是一个`O(1)`，即“常数时间”操作，这意味着无论`deque`容器的大小如何，所花费的时间都是相同的。
- en: '![](images/nsp-venkitachalam503045-f04005.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f04005.jpg)'
- en: 'Figure 4-5: A ring buffer implemented using `deque`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-5：使用`deque`实现的环形缓冲区
- en: 'The following code shows an example of how you would use `deque` in Python:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何在Python中使用`deque`的示例：
- en: '>>> `from collections import deque`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `from collections import deque`'
- en: ❶ >>> `d = deque(range(10), maxlen=10)`
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ >>> `d = deque(range(10), maxlen=10)`
- en: '>>> `print(d)`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `print(d)`'
- en: deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)
- en: ❷ >>> `d.append(10)`
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ >>> `d.append(10)`
- en: '>>> `print(d)`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `print(d)`'
- en: deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], maxlen=10)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], maxlen=10)
- en: You create the `deque` container by passing in a list created with the `range()`
    function ❶. You also specify the maximum length `maxlen` of the `deque` as `10`.
    Next, you append the element `10` to the end of the `deque` container ❷. When
    you then print the `deque`, you can see that `10` has been appended to the end
    of the `deque`, while the first element, `0`, has automatically been removed to
    maintain the `deque` container’s maximum length of 10 elements. This scheme will
    allow you to simultaneously implement steps 4 and 5 of the Karplus-Strong algorithm—adding
    a new value at the end of the ring buffer while removing the first value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过传入一个使用`range()`函数创建的列表来创建`deque`容器❶。你还指定了`deque`的最大长度`maxlen`为`10`。接下来，你将元素`10`追加到`deque`容器的末尾❷。当你打印出`deque`时，你会发现`10`已经被添加到`deque`的末尾，同时第一个元素`0`已经被自动移除，以保持`deque`容器的最大长度为10个元素。这个方案将允许你同时实现Karplus-Strong算法的步骤4和步骤5——在环形缓冲区的末尾添加新值，同时移除第一个值。
- en: '[Implementing the Karplus-Strong Algorithm](nsp-venkitachalam503045-0008.xhtml#rbh0605)'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[实现Karplus-Strong算法](nsp-venkitachalam503045-0008.xhtml#rbh0605)'
- en: You’ll now implement the Karplus-Strong algorithm in the `generateNote()` function,
    using a `deque` container to implement the ring buffer and a `numpy` array to
    implement the samples buffer. In the same function, you’ll also visualize the
    algorithm using `matplotlib`. The plot will show how the amplitudes of the plucked
    string change over time, in effect showing how the string moves as it vibrates.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将在`generateNote()`函数中实现Karplus-Strong算法，使用`deque`容器实现环形缓冲区，使用`numpy`数组实现样本缓冲区。在同一个函数中，你还将使用`matplotlib`进行算法的可视化。绘图将展示拨弦时弦的振幅如何随时间变化，实质上展示了弦在振动过程中的运动。
- en: 'You begin with some setup:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先进行一些初始化设置：
- en: initialize plotting
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化绘图
- en: ❶ fig, ax = plt.subplots(1)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ fig, ax = plt.subplots(1)
- en: ❷ line, = ax.plot([], [])
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ line, = ax.plot([], [])
- en: 'def generateNote(freq):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 'def generateNote(freq):'
- en: '"""generate note using Karplus-Strong algorithm"""'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '"""使用Karplus-Strong算法生成音符"""'
- en: nSamples = 44100
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: nSamples = 44100
- en: sampleRate = 44100
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: sampleRate = 44100
- en: ❸ N = int(sampleRate/freq)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ N = int(sampleRate/freq)
- en: '❹ if gShowPlot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '❹ 如果 gShowPlot:'
- en: '# set axis'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置坐标轴'
- en: ax.set_xlim([0, N])
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_xlim([0, N])
- en: ax.set_ylim([-1.0, 1.0])
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_ylim([-1.0, 1.0])
- en: line.set_xdata(np.arange(0, N))
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: line.set_xdata(np.arange(0, N))
- en: '# initialize ring buffer'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化环形缓冲区'
- en: ❺ buf = deque([random.random() - 0.5 for i in range(N)], maxlen=N)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ buf = deque([random.random() - 0.5 for i in range(N)], maxlen=N)
- en: '# init samples buffer'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化样本缓冲区'
- en: ❻ samples = np.array([0]*nSamples, 'float32')
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ samples = np.array([0]*nSamples, 'float32')
- en: First you create a `matplotlib` figure ❶ and a line plot ❷, which you’ll fill
    with data. Then you begin the `generateNote()` function definition, which takes
    the frequency of the note to be generated as a parameter. You set the number of
    samples in the sound clip and the sample rate to both be 44,100, which means the
    resulting clip will be one second long. Then you divide the sample rate by the
    desired frequency to set the length `N` of the Karplus-Strong ring buffer ❸. If
    the `gShowPlot` flag is set ❹, you initialize the x and y range of the plot and
    initialize the x values to `[0, ... N-1]` using the `arange()` function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个`matplotlib`图形 ❶ 和一个折线图 ❷，然后用数据填充这些图形。接着你开始定义`generateNote()`函数，函数接受生成音符的频率作为参数。你将声音片段的样本数和采样率都设置为44,100，这意味着生成的片段将持续一秒钟。然后，你将采样率除以所需的频率，来设置Karplus-Strong环形缓冲区的长度`N`
    ❸。如果`gShowPlot`标志设置为`True` ❹，你将初始化图表的x和y范围，并使用`arange()`函数将x值初始化为`[0, ... N-1]`。
- en: You next initialize the ring buffer as a `deque` container with random numbers
    in the range [−0.5, 0.5], setting the maximum length of the `deque` to `N` ❺.
    You also initialize the samples buffer as a `numpy` array of floats ❻. You set
    the length of the array to be the number of samples the sound clip will contain.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你初始化环形缓冲区为`deque`容器，并用范围为[−0.5, 0.5]的随机数填充，设置`deque`的最大长度为`N` ❺。你还初始化样本缓冲区为`numpy`浮点数组
    ❻。你将数组的长度设置为声音片段将包含的样本数。
- en: 'Next comes the heart of the `generateNote()` function, where you implement
    the steps of the Karplus-Strong algorithm and create the visualization:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`generateNote()`函数的核心部分，在这里你实现Karplus-Strong算法的步骤并创建可视化效果：
- en: 'for i in range(nSamples):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(nSamples):'
- en: ❶ samples[i] = buf[0]
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ samples[i] = buf[0]
- en: ❷ avg = 0.995*0.5*(buf[0] + buf[1])
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ avg = 0.995*0.5*(buf[0] + buf[1])
- en: ❸ buf.append(avg)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ buf.append(avg)
- en: '# plot of flag set'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '# 标志设置的绘图'
- en: '❹ if gShowPlot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '❹ 如果 gShowPlot:'
- en: 'if i % 1000 == 0:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '如果i % 1000 == 0:'
- en: line.set_ydata(buf)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: line.set_ydata(buf)
- en: fig.canvas.draw()
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: fig.canvas.draw()
- en: fig.canvas.flush_events()
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: fig.canvas.flush_events()
- en: '# samples to 16-bit to string'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将样本转换为16位字符串'
- en: '# max value is 32767 for 16-bit'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '# 最大值为16位的32767'
- en: ❺ samples = np.array(samples * 32767, 'int16')
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ samples = np.array(samples * 32767, 'int16')
- en: ❻ return samples.tobytes()
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ return samples.tobytes()
- en: Here you iterate over each element in the samples buffer and carry out the steps
    of the Karplus-Strong algorithm. With each iteration, you copy the first element
    in the ring buffer to the samples buffer ❶. Then you perform the low-pass filtering
    and attenuation by averaging the first two elements in the ring buffer and multiplying
    the result by 0.995 ❷. This attenuated value is appended to the end of the ring
    buffer ❸. Since the `deque` representing the ring buffer has a maximum length,
    the `append()` operation also removes the first element from the buffer.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你遍历样本缓冲区中的每个元素，并执行Karplus-Strong算法的步骤。每次迭代时，你将环形缓冲区的第一个元素复制到样本缓冲区 ❶。然后，你通过平均环形缓冲区中的前两个元素并将结果乘以0.995来进行低通滤波和衰减
    ❷。这个衰减后的值会被添加到环形缓冲区的末尾 ❸。由于`deque`表示的环形缓冲区有最大长度，`append()`操作也会移除缓冲区中的第一个元素。
- en: The `samples` array is converted into a 16-bit format by multiplying each value
    by 32,767 ❺ (a 16-bit signed integer can take values only from −32,768 to 32,767,
    and 0.5 × 65,534 = 32,767). Then the array is converted to a byte representation
    for the `wave` module, which you’ll use to save this data to a file ❻.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`samples` 数组通过将每个值乘以 32,767 转换为 16 位格式 ❺（16 位有符号整数的取值范围仅为 −32,768 到 32,767，而
    0.5 × 65,534 = 32,767）。然后，数组将被转换为字节表示，用于 `wave` 模块，你将使用它将数据保存到文件中 ❻。'
- en: As the algorithm is running, you visualize how the ring buffer evolves ❹. For
    every thousand samples, you update the `matplotlib` graph with the values in the
    ring buffer, and this shows how the data changes with time.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当算法运行时，你将可视化环形缓冲区的演变 ❹。每当处理一千个采样时，你会更新 `matplotlib` 图形，以显示环形缓冲区中的数据值，这显示了数据随时间的变化。
- en: '[Writing a WAV File](nsp-venkitachalam503045-0008.xhtml#rbh0606)'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[写入 WAV 文件](nsp-venkitachalam503045-0008.xhtml#rbh0606)'
- en: 'Once you have the audio data, you can write it to a WAV file using the Python
    `wave` module. Define a `writeWAVE()` function to carry this out:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你拥有音频数据，可以使用 Python 的 `wave` 模块将其写入 WAV 文件。定义一个 `writeWAVE()` 函数来完成此操作：
- en: 'def writeWAVE(fname, data):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 'def writeWAVE(fname, data):'
- en: '# open file'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开文件'
- en: ❶ file = wave.open(fname, 'wb')
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ file = wave.open(fname, 'wb')
- en: '# WAV file parameters'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '# WAV 文件参数'
- en: nChannels = 1
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: nChannels = 1
- en: sampleWidth = 2
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: sampleWidth = 2
- en: frameRate = 44100
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: frameRate = 44100
- en: nFrames = 44100
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: nFrames = 44100
- en: '# set parameters'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置参数'
- en: ❷ file.setparams((nChannels, sampleWidth, frameRate, nFrames,
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ file.setparams((nChannels, sampleWidth, frameRate, nFrames,
- en: '''NONE'', ''noncompressed''))'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '''NONE'', ''noncompressed''))'
- en: ❸ file.writeframes(data)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ file.writeframes(data)
- en: file.close()
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: file.close()
- en: You create a WAV file ❶ and set its parameters using a single-channel, 16-bit,
    noncompressed format ❷. Then you write the data to the file ❸.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建一个 WAV 文件 ❶ 并使用单通道、16 位、无压缩格式设置其参数 ❷。然后，你将数据写入文件 ❸。
- en: '[Playing WAV Files with pyaudio](nsp-venkitachalam503045-0008.xhtml#rbh0607)'
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[使用 pyaudio 播放 WAV 文件](nsp-venkitachalam503045-0008.xhtml#rbh0607)'
- en: 'Now you’ll use the Python `pyaudio` module to play the WAV files generated
    by the algorithm. `pyaudio` is a high-performance, low-level library that gives
    you access to sound devices on a computer. For convenience, you encapsulate the
    code in a `NotePlayer` class, as shown here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将使用 Python 的 `pyaudio` 模块来播放由算法生成的 WAV 文件。`pyaudio` 是一个高性能、低级别的库，可以让你访问计算机上的声音设备。为了方便起见，你将代码封装在一个
    `NotePlayer` 类中，如下所示：
- en: 'class NotePlayer:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 'class NotePlayer:'
- en: '# constructor'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '# 构造函数'
- en: 'def __init__(self):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: '# init pyaudio'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化 pyaudio'
- en: ❶ self.pa = pyaudio.PyAudio()
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ self.pa = pyaudio.PyAudio()
- en: '# open stream'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开流'
- en: ❷ self.stream = self.pa.open(
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ self.stream = self.pa.open(
- en: format=pyaudio.paInt16,
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: format=pyaudio.paInt16,
- en: channels=1,
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: channels=1,
- en: rate=44100,
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: rate=44100,
- en: output=True)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: output=True)
- en: '# dictionary of notes'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '# 音符字典'
- en: ❸ self.notes = []
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ self.notes = []
- en: In the `NotePlayer` class’s constructor, you first create the `PyAudio` object
    that you’ll use to play the WAV file ❶. Then you open a 16-bit single-channel
    `PyAudio` output stream ❷. You also create an empty list that you’ll later fill
    with filenames of the five pentatonic note WAV files ❸.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `NotePlayer` 类的构造函数中，你首先创建了一个 `PyAudio` 对象，用来播放 WAV 文件 ❶。然后，你打开一个 16 位单通道的
    `PyAudio` 输出流 ❷。你还创建了一个空列表，稍后会用五个五声音阶音符 WAV 文件的文件名填充 ❸。
- en: 'In Python, when all references to an object have been deleted, the object is
    destroyed by a process called *garbage collection*. At that time, the object’s
    `__del__()` method, also known as a *destructor*, is called, if one is defined.
    Here’s the `NotePlayer` class’s destructor:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，当对象的所有引用都被删除时，系统会通过一个叫做 *垃圾回收* 的过程销毁该对象。此时，如果定义了 `__del__()` 方法，它会作为
    *析构函数* 被调用。以下是 `NotePlayer` 类的析构函数：
- en: 'def __del__(self):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __del__(self):'
- en: '# destructor'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '# 析构函数'
- en: self.stream.stop_stream()
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: self.stream.stop_stream()
- en: self.stream.close()
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: self.stream.close()
- en: self.pa.terminate()
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: self.pa.terminate()
- en: This method ensures that the `PyAudio` stream is cleaned up when the `NotePlayer`
    object is destroyed. Failing to provide a `__del__()` method for a class can cause
    problems when objects are repeatedly created and destroyed, since some system-wide
    resources (like `pyaudio` in this case) may not be cleaned up properly.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法确保当 `NotePlayer` 对象被销毁时，`PyAudio` 流会被清理。如果没有为类提供 `__del__()` 方法，在反复创建和销毁对象时可能会出现问题，因为某些系统级资源（如本例中的
    `pyaudio`）可能没有被正确清理。
- en: 'The remaining methods of the `NotePlayer` class are devoted to building up
    a list of possible notes and playing them. First, here’s the `add()` method, which
    is used to add a WAV filename to the class:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotePlayer` 类的其余方法用于构建一个可能音符的列表并播放它们。首先是 `add()` 方法，用于将一个 WAV 文件名添加到类中：'
- en: 'def add(self, fileName):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'def add(self, fileName):'
- en: self.notes.append(fileName)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: self.notes.append(fileName)
- en: The method takes a filename corresponding to one of the generated WAV files
    as a parameter and adds it to the `notes` list you initialized in the class’s
    constructor. The class will draw on this list when it wants to play a WAV file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接收一个与生成的 WAV 文件之一对应的文件名作为参数，并将其添加到你在类构造函数中初始化的 `notes` 列表中。类在需要播放 WAV 文件时会使用此列表。
- en: 'Next, let’s look at the `play()` method used to play a note:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一下 `play()` 方法，它用于播放音符：
- en: 'def play(self, fileName):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'def play(self, fileName):'
- en: 'try:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: print("playing " + fileName)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: print("正在播放 " + fileName)
- en: '# open WAV file'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开 WAV 文件'
- en: ❶ wf = wave.open(fileName, 'rb')
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ wf = wave.open(fileName, 'rb')
- en: '# read a chunk'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取一块数据'
- en: ❷ data = wf.readframes(CHUNK)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ data = wf.readframes(CHUNK)
- en: '# read rest'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取剩余数据'
- en: 'while data != b'''':'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 'while data != b'''':'
- en: ❸ self.stream.write(data)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ self.stream.write(data)
- en: ❹ data = wf.readframes(CHUNK)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ data = wf.readframes(CHUNK)
- en: '# clean up'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '# 清理'
- en: ❺ wf.close()
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ wf.close()
- en: 'except BaseException as err:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'except BaseException as err:'
- en: ❻ print(f"Exception! {err=}, {type(err)=}.\nExiting.")
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ print(f"异常！{err=}, {type(err)=}.\n退出程序。")
- en: exit(0)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: exit(0)
- en: Here you open the desired WAV file using Python’s `wave` module ❶. Then you
    read `CHUNK` frames (defined globally as 1,024 in this case) from the file into
    `data` ❷. Next, within a `while` loop, you write the contents of `data` to the
    `PyAudio` output stream ❸ and read the next chunk of data from the WAV file ❹.
    Writing to the output stream has the effect of playing the audio through the default
    audio device of your computer, which is typically a speaker. You read the data
    in chunks to maintain the sample rate at the output side. If the chunks are too
    large and you take too much time in between reading and writing, the audio won’t
    sound right.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用 Python 的`wave`模块打开所需的 WAV 文件 ❶。然后，你从文件中读取 `CHUNK` 帧（在此情况下全局定义为 1,024）到
    `data` 中 ❷。接下来，在一个 `while` 循环中，你将 `data` 的内容写入 `PyAudio` 输出流 ❸，并从 WAV 文件中读取下一块数据
    ❹。写入输出流的效果是通过计算机的默认音频设备（通常是扬声器）播放音频。你以块的方式读取数据，以保持输出端的采样率。如果块太大，并且在读取和写入之间的时间过长，音频将无法正确播放。
- en: The `while` loop continues for as long as there’s more data to read—that is,
    until `data` is empty. At that point, you close the WAV file object ❺. You handle
    any exceptions that may happen during the playback process (for example, the user
    pressing CTRL-C) by printing the error ❻ and exiting the program.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环会一直持续，直到读取完所有数据，即直到 `data` 为空为止。此时，你关闭 WAV 文件对象 ❺。你处理在播放过程中可能发生的任何异常（例如用户按下
    CTRL-C），通过打印错误 ❻ 并退出程序。'
- en: 'Finally, the `NotePlayer` class’s `playRandom()` method picks a random note
    from the five notes you’ve generated and plays it:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`NotePlayer` 类的 `playRandom()` 方法从你生成的五个音符中随机挑选一个并播放：
- en: 'def playRandom(self):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 'def playRandom(self):'
- en: '"""play a random note"""'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '"""播放一个随机音符"""'
- en: index = random.randint(0, len(self.notes)-1)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: index = random.randint(0, len(self.notes)-1)
- en: note = self.notes[index]
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: note = self.notes[index]
- en: self.play(note)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: self.play(note)
- en: The method selects a random WAV filename from the `notes` list and passes that
    filename to the `play()` method to be played.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法从 `notes` 列表中选择一个随机的 WAV 文件名，并将该文件名传递给 `play()` 方法进行播放。
- en: '[Creating Notes and Parsing Arguments](nsp-venkitachalam503045-0008.xhtml#rbh0608)'
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[创建音符并解析参数](nsp-venkitachalam503045-0008.xhtml#rbh0608)'
- en: 'Now let’s look at the program’s `main()` function, which creates the notes
    and handles various command line options to play the notes:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下程序的 `main()` 函数，它创建音符并处理各种命令行选项来播放音符：
- en: 'def main():'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: --`snip`--
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: --`snip`--
- en: parser = argparse.ArgumentParser(description="Generating sounds with
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: parser = argparse.ArgumentParser(description="生成声音并
- en: Karplus-Strong Algorithm")
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Karplus-Strong 算法")
- en: '# add arguments'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加参数'
- en: parser.add_argument('--display', action='store_true', required=False)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--display', action='store_true', required=False)
- en: parser.add_argument('--play', action='store_true', required=False)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--play', action='store_true', required=False)
- en: args = parser.parse_args()
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: args = parser.parse_args()
- en: '# show plot if flag set'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果标志设置为真，则显示图形'
- en: '❶ if args.display:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ if args.display:'
- en: gShowPlot = True
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: gShowPlot = True
- en: plt.show(block=False)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show(block=False)
- en: '# create note player'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建音符播放器'
- en: ❷ nplayer = NotePlayer()
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ nplayer = NotePlayer()
- en: print('creating notes...')
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: print('正在创建音符...')
- en: 'for name, freq in list(pmNotes.items()):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 'for name, freq in list(pmNotes.items()):'
- en: fileName = name + '.wav'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: fileName = name + '.wav'
- en: '❸ if not os.path.exists(fileName) or args.display:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ if not os.path.exists(fileName) or args.display:'
- en: data = generateNote(freq)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: data = generateNote(freq)
- en: print('creating ' + fileName + '...')
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: print('正在创建 ' + fileName + '...')
- en: writeWAVE(fileName, data)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: writeWAVE(fileName, data)
- en: 'else:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print('fileName already created. skipping...')
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: print('文件名已创建，跳过...')
- en: '# add note to player'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将音符添加到播放器'
- en: ❹ nplayer.add(name + '.wav')
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ nplayer.add(name + '.wav')
- en: '# play note if display flag set'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果设置了显示标志，则播放音符'
- en: 'if args.display:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.display:'
- en: ❺ nplayer.play(name + '.wav')
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ nplayer.play(name + '.wav')
- en: time.sleep(0.5)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: time.sleep(0.5)
- en: '# play a random tune'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '# 播放一段随机曲调'
- en: 'if args.play:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.play:'
- en: 'while True:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'try:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: ❻ nplayer.playRandom()
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ nplayer.playRandom()
- en: '# rest - 1 to 8 beats'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '# rest - 1 到 8 拍'
- en: ❼ rest = np.random.choice([1, 2, 4, 8], 1,
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ rest = np.random.choice([1, 2, 4, 8], 1,
- en: p=[0.15, 0.7, 0.1, 0.05])
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: p=[0.15, 0.7, 0.1, 0.05])
- en: time.sleep(0.25*rest[0])
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: time.sleep(0.25*rest[0])
- en: 'except KeyboardInterrupt:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 'except KeyboardInterrupt:'
- en: exit()
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: exit()
- en: First you set up some command line options for the program using `argparse`,
    as discussed in earlier projects. The `--display` option will play each of the
    five notes in turn, while visualizing each note’s waveform using `matplotlib`.
    The `--play` option generates a random melody using the five notes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你使用`argparse`为程序设置了一些命令行选项，如前面的项目中所讨论的。`--display`选项将依次播放五个音符，并使用`matplotlib`可视化每个音符的波形。`--play`选项使用这五个音符生成一个随机旋律。
- en: If the `--display` command line option was used ❶, you set up a `matplotlib`
    plot to show how the waveform evolves during the Karplus-Strong algorithm. The
    `plt.show(block=False)` call ensures that the `matplotlib` display method doesn’t
    block. This way, when you call this function, it will return immediately and go
    on to the next statement. This is the behavior you need, since you’re manually
    updating the plot every frame.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用了`--display`命令行选项❶，你设置了一个`matplotlib`绘图来显示卡普鲁斯-斯特朗算法过程中波形的变化。`plt.show(block=False)`调用确保`matplotlib`显示方法不会阻塞。这样，当你调用此函数时，它会立即返回并继续执行下一条语句。这是你所需要的行为，因为你正在手动更新每一帧的图表。
- en: 'You next create an instance of the `NotePlayer` class ❷. Then you generate
    WAV files of the five notes in the C minor pentatonic scale. The frequencies for
    the notes are defined in the global dictionary `pmNotes`, which looks like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你创建了`NotePlayer`类的一个实例❷。然后你生成了C小调五声音阶中五个音符的WAV文件。这些音符的频率在全局字典`pmNotes`中定义，如下所示：
- en: 'pmNotes = {''C4'': 262, ''Eb'': 311, ''F'': 349, ''G'': 391, ''Bb'': 466}'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 'pmNotes = {''C4'': 262, ''Eb'': 311, ''F'': 349, ''G'': 391, ''Bb'': 466}'
- en: To generate the notes, you iterate through the dictionary, first constructing
    a filename for the note using the dictionary key plus the *.wav* extension—for
    example, *C4.wav*. You use the `os.path.``exists()` method to see whether the
    WAV file for a particular note has been created ❸. If so, you skip the computation
    for that note. (This is a handy optimization if you’re running this program several
    times.) Otherwise, you generate the note using the `generateNote()` and `writeWAVE()`
    functions you defined earlier. Once the note is computed and the WAV file created,
    you add the note’s filename to the `NotePlayer` object’s list of notes ❹, and
    then you play the note if the `--display` command line option is used ❺.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成音符，你遍历字典，首先通过字典键加上*.wav*扩展名来构造音符的文件名——例如，*C4.wav*。你使用`os.path.exists()`方法来检查某个音符的WAV文件是否已经创建❸。如果是这样，你跳过该音符的计算。（如果你多次运行该程序，这是一个方便的优化。）否则，你使用之前定义的`generateNote()`和`writeWAVE()`函数来生成该音符。一旦音符被计算并且WAV文件被创建，你将该音符的文件名添加到`NotePlayer`对象的音符列表中❹，然后如果使用了`--display`命令行选项，你将播放该音符❺。
- en: If the `--play` option is used, the `playRandom()` method in `NotePlayer` repeatedly
    plays a note at random from the five notes ❻. For a note sequence to sound even
    remotely musical, you need to add rests between the notes played, so you use the
    `random.``choice()` method from `numpy` to choose a random rest interval ❼. This
    method also lets you choose the probability of the rest interval, which you set
    so that a two-beat rest is the most probable and an eight-beat rest the least
    probable. Try changing these values to create your own style of random music!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用了`--play`选项，`NotePlayer`中的`playRandom()`方法将反复从五个音符中随机播放一个音符❻。为了使音符序列听起来稍微像音乐，你需要在音符之间添加休止符，因此你使用`numpy`中的`random.choice()`方法来选择一个随机的休止时间❼。该方法还允许你选择休止符的概率，你可以设置一个二拍休止符为最可能的，八拍休止符为最不可能的。尝试更改这些值，创造你自己的随机音乐风格！
- en: '[Running the Plucked String Simulation](nsp-venkitachalam503045-0008.xhtml#rah0604)'
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行拨弦模拟](nsp-venkitachalam503045-0008.xhtml#rah0604)'
- en: 'To run the code for this project, enter this in a command shell:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此项目的代码，请在命令行中输入以下内容：
- en: $ `python ks.py --display`
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: $ `python ks.py --display`
- en: As you can see in [Figure 4-6](nsp-venkitachalam503045-0016.xhtml#fig4-6), the
    `matplotlib` plot shows how the Karplus-Strong algorithm converts the initial
    random displacements to create waves of the desired frequency.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图4-6](nsp-venkitachalam503045-0016.xhtml#fig4-6)所示，`matplotlib`图表显示了Karplus-Strong算法如何将初始随机位移转换为所需频率的波形。
- en: '![](images/nsp-venkitachalam503045-f04006.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f04006.jpg)'
- en: 'Figure 4-6: A sample run of the plucked string simulation'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-6：拨弦模拟的示例运行
- en: 'Now try playing a random sequence of notes using this command:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用以下命令播放一个随机音符序列：
- en: $ `python ks.py --play`
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: $ `python ks.py --play`
- en: This should play a random note sequence using the generated WAV files of the
    pentatonic musical scale.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该使用生成的五声音阶WAV文件播放一个随机音符序列。
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah0605)'
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[总结](nsp-venkitachalam503045-0008.xhtml#rah0605)'
- en: In this project, you used the Karplus-Strong algorithm to simulate the sound
    of plucked strings and played notes from generated WAV files. You learned how
    to implement the Karplus-Strong algorithm using a `deque` container as a ring
    buffer. You also learned about the WAV file format and how to play WAV files using
    `pyaudio`, as well as how to use `matplotlib` to visualize a vibrating string.
    You even learned about the pentatonic musical scale!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你使用Karplus-Strong算法模拟了拨弦声音并播放了从生成的WAV文件中得到的音符。你学会了如何使用`deque`容器作为环形缓冲区来实现Karplus-Strong算法。你还学习了WAV文件格式，以及如何使用`pyaudio`播放WAV文件，如何使用`matplotlib`可视化振动弦。你甚至还学会了五声音阶！
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah0606)'
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实验！](nsp-venkitachalam503045-0008.xhtml#rah0606)'
- en: 'Here are some ideas for experiments:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些实验的想法：
- en: 1\. I’ve stated that the Karplus-Strong algorithm creates realistic plucked
    string sounds by generating overtones as well as the fundamental frequency of
    the note. But how do you know it’s working? By creating spectral plots of your
    WAV files, like the one in [Figure 4-2](nsp-venkitachalam503045-0016.xhtml#fig4-2).
    You can use the free program Audacity to do this. Open one of the WAV files in
    Audacity, and select **Analyze‣Plot** **Spectrum**. You should see that the sound
    contains many frequencies.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 我已经提到，Karplus-Strong算法通过生成泛音和音符的基频来创造逼真的拨弦声音。但是你如何知道它在工作？通过创建你WAV文件的谱图，如[图4-2](nsp-venkitachalam503045-0016.xhtml#fig4-2)所示。你可以使用免费的程序Audacity来做到这一点。在Audacity中打开一个WAV文件，并选择**Analyze‣Plot**
    **Spectrum**。你应该能看到声音包含许多频率。
- en: 2\. Use the techniques you learned in this chapter to create a method that replicates
    the sound of two strings of different frequencies vibrating together. Remember,
    the Karplus-Strong algorithm produces a ring buffer full of sound amplitude values.
    You can combine two sounds by adding their amplitudes together.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 使用你在本章中学到的技术，创建一个方法，模拟两根不同频率的弦一起振动的声音。记住，Karplus-Strong算法生成一个充满声音幅度值的环形缓冲区。你可以通过将两个声音的幅度加在一起，来合成这两种声音。
- en: 3\. Replicate the sound of two strings vibrating together, as described in the
    previous experiment, but add a time delay between the first and second string
    plucks.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 如前面的实验所述，模拟两根弦一起振动的声音，但在第一根和第二根弦的拨动之间添加时间延迟。
- en: '4\. Write a method to read music from a text file and generate musical notes.
    Then play the music using these notes. You can use a format where the note names
    are followed by integer rest time intervals, like this: C4 1 F4 2 G4 1 . . .'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4. 编写一个方法，从文本文件读取音乐并生成音符。然后使用这些音符播放音乐。你可以使用一种格式，其中音符名称后跟整数的休止时间间隔，例如：C4 1 F4
    2 G4 1 . . .。
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah0607)'
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整代码](nsp-venkitachalam503045-0008.xhtml#rah0607)'
- en: 'Here’s the complete code for this project:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本项目的完整代码：
- en: '"""'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: ks.py
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ks.py
- en: Uses the Karplus-Strong algorithm to generate musical notes
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Karplus-Strong算法生成音乐音符
- en: in a pentatonic scale.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在五声音阶中。
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：Mahesh Venkitachalam
- en: '"""'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: import sys, os
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 导入sys和os模块：`import sys, os`
- en: import time, random
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 导入时间和随机模块：`import time, random`
- en: import wave, argparse
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 导入wave和argparse模块：`import wave, argparse`
- en: import numpy as np
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 导入numpy：`import numpy as np`
- en: from collections import deque
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 从collections模块导入deque：`from collections import deque`
- en: import matplotlib
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 导入matplotlib：`import matplotlib`
- en: to fix graph display issues on macOS
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复macOS上图形显示的问题
- en: matplotlib.use('TkAgg')
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: matplotlib.use('TkAgg')
- en: from matplotlib import pyplot as plt
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 来自matplotlib的pyplot模块：`import pyplot as plt`
- en: import pyaudio
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 导入pyaudio：`import pyaudio`
- en: show plot of algorithm in action?
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示算法运行时的图形？
- en: gShowPlot = False
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: gShowPlot = False
- en: notes of a pentatonic minor scale
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 五声音阶的音符
- en: piano C4-E(b)-F-G-B(b)-C5
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 钢琴音符C4-E(b)-F-G-B(b)-C5
- en: 'pmNotes = {''C4'': 262, ''Eb'': 311, ''F'': 349, ''G'':391, ''Bb'':466}'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 'pmNotes = {''C4'': 262, ''Eb'': 311, ''F'': 349, ''G'':391, ''Bb'':466}'
- en: CHUNK = 1024
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: CHUNK = 1024
- en: initialize plotting
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化绘图
- en: fig, ax = plt.subplots(1)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: fig, ax = plt.subplots(1)
- en: line, = ax.plot([], [])
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: line, = ax.plot([], [])
- en: write out WAV file
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写出WAV文件
- en: 'def writeWAVE(fname, data):'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 'def writeWAVE(fname, data):'
- en: '"""write data to WAV file"""'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '"""将数据写入WAV文件"""'
- en: '# open file'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开文件'
- en: file = wave.open(fname, 'wb')
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: file = wave.open(fname, 'wb')
- en: '# WAV file parameters'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '# WAV文件参数'
- en: nChannels = 1
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: nChannels = 1
- en: sampleWidth = 2
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: sampleWidth = 2
- en: frameRate = 44100
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: frameRate = 44100
- en: nFrames = 44100
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: nFrames = 44100
- en: '# set parameters'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置参数'
- en: file.setparams((nChannels, sampleWidth, frameRate, nFrames,
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: file.setparams((nChannels, sampleWidth, frameRate, nFrames,
- en: '''NONE'', ''noncompressed''))'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '''NONE'', ''noncompressed''))'
- en: file.writeframes(data)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: file.writeframes(data)
- en: file.close()
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: file.close()
- en: 'def generateNote(freq):'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 'def generateNote(freq):'
- en: '"""generate note using Karplus-Strong algorithm"""'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '"""使用Karplus-Strong算法生成音符"""'
- en: nSamples = 44100
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: nSamples = 44100
- en: sampleRate = 44100
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: sampleRate = 44100
- en: N = int(sampleRate/freq)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: N = int(sampleRate/freq)
- en: 'if gShowPlot:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 'if gShowPlot:'
- en: '# set axis'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置坐标轴'
- en: ax.set_xlim([0, N])
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_xlim([0, N])
- en: ax.set_ylim([-1.0, 1.0])
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_ylim([-1.0, 1.0])
- en: line.set_xdata(np.arange(0, N))
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: line.set_xdata(np.arange(0, N))
- en: '# initialize ring buffer'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化环形缓冲区'
- en: buf = deque([random.random() - 0.5 for i in range(N)], maxlen=N)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: buf = deque([random.random() - 0.5 for i in range(N)], maxlen=N)
- en: '# init sample buffer'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化采样缓冲区'
- en: samples = np.array([0]*nSamples, 'float32')
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: samples = np.array([0]*nSamples, 'float32')
- en: 'for i in range(nSamples):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(nSamples):'
- en: samples[i] = buf[0]
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: samples[i] = buf[0]
- en: avg = 0.995*0.5*(buf[0] + buf[1])
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: avg = 0.995*0.5*(buf[0] + buf[1])
- en: buf.append(avg)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: buf.append(avg)
- en: '# plot of flag set'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果设置了标志，则展示图形'
- en: 'if gShowPlot:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 'if gShowPlot:'
- en: 'if i % 1000 == 0:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 'if i % 1000 == 0:'
- en: line.set_ydata(buf)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: line.set_ydata(buf)
- en: fig.canvas.draw()
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: fig.canvas.draw()
- en: fig.canvas.flush_events()
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: fig.canvas.flush_events()
- en: '# samples to 16-bit to string'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将样本转为16位字符串'
- en: '# max value is 32767 for 16-bit'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '# 最大值为 32767，适用于16位'
- en: samples = np.array(samples * 32767, 'int16')
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: samples = np.array(samples * 32767, 'int16')
- en: return samples.tobytes()
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: return samples.tobytes()
- en: play a WAV file
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放WAV文件
- en: 'class NotePlayer:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 'class NotePlayer:'
- en: '# constructor'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '# 构造函数'
- en: 'def __init__(self):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: '# init pyaudio'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化pyaudio'
- en: self.pa = pyaudio.PyAudio()
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: self.pa = pyaudio.PyAudio()
- en: '# open stream'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开流'
- en: self.stream = self.pa.open(
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: self.stream = self.pa.open(
- en: format=pyaudio.paInt16,
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: format=pyaudio.paInt16,
- en: channels=1,
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: channels=1,
- en: rate=44100,
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: rate=44100,
- en: output=True)
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: output=True)
- en: '# dictionary of notes'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '# 音符字典'
- en: self.notes = []
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: self.notes = []
- en: 'def __del__(self):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __del__(self):'
- en: '# destructor'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '# 析构函数'
- en: self.stream.stop_stream()
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: self.stream.stop_stream()
- en: self.stream.close()
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: self.stream.close()
- en: self.pa.terminate()
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: self.pa.terminate()
- en: '# add a note'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加一个音符'
- en: 'def add(self, fileName):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 'def add(self, fileName):'
- en: self.notes.append(fileName)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: self.notes.append(fileName)
- en: '# play a note'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '# 播放音符'
- en: 'def play(self, fileName):'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 'def play(self, fileName):'
- en: 'try:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: print("playing " + fileName)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: print("正在播放 " + fileName)
- en: '# open WAV file'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开WAV文件'
- en: wf = wave.open(fileName, 'rb')
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: wf = wave.open(fileName, 'rb')
- en: '# read a chunk'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取一段'
- en: data = wf.readframes(CHUNK)
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: data = wf.readframes(CHUNK)
- en: '# read rest'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取剩余部分'
- en: 'while data != b'''':'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 'while data != b'''':'
- en: self.stream.write(data)
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: self.stream.write(data)
- en: data = wf.readframes(CHUNK)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: data = wf.readframes(CHUNK)
- en: '# clean up'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '# 清理'
- en: wf.close()
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: wf.close()
- en: 'except BaseException as err:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 'except BaseException as err:'
- en: print(f"Exception! {err=}, {type(err)=}.\nExiting.")
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: print(f"异常！{err=}, {type(err)=}。\n退出。")
- en: exit(0)
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: exit(0)
- en: 'def playRandom(self):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 'def playRandom(self):'
- en: '"""play a random note"""'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '"""播放一个随机音符"""'
- en: index = random.randint(0, len(self.notes)-1)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: index = random.randint(0, len(self.notes)-1)
- en: note = self.notes[index]
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: note = self.notes[index]
- en: self.play(note)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: self.play(note)
- en: main() function
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: main() function
- en: 'def main():'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '# declare global var'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '# 声明全局变量'
- en: global gShowPlot
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: global gShowPlot
- en: parser = argparse.ArgumentParser(description="Generating sounds with
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: parser = argparse.ArgumentParser(description="使用声音生成的
- en: Karplus-Strong Algorithm.")
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: Karplus-Strong 算法。")
- en: '# add arguments'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加参数'
- en: parser.add_argument('--display', action='store_true', required=False)
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--display', action='store_true', required=False)
- en: parser.add_argument('--play', action='store_true', required=False)
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--play', action='store_true', required=False)
- en: args = parser.parse_args()
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: args = parser.parse_args()
- en: '# show plot if flag set'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果设置了显示标志，展示图形'
- en: 'if args.display:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.display:'
- en: gShowPlot = True
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: gShowPlot = True
- en: '# plt.ion()'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '# plt.ion()'
- en: plt.show(block=False)
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show(block=False)
- en: '# create note player'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建音符播放器'
- en: nplayer = NotePlayer()
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: nplayer = NotePlayer()
- en: print('creating notes...')
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: print('正在创建笔记...')
- en: 'for name, freq in list(pmNotes.items()):'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 'for name, freq in list(pmNotes.items()):'
- en: fileName = name + '.wav'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: fileName = name + '.wav'
- en: 'if not os.path.exists(fileName) or args.display:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not os.path.exists(fileName) or args.display:'
- en: data = generateNote(freq)
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: data = generateNote(freq)
- en: print('creating ' + fileName + '...')
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: print('正在创建 ' + fileName + '...')
- en: writeWAVE(fileName, data)
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: writeWAVE(fileName, data)
- en: 'else:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print('fileName already created. skipping...')
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: print('fileName 已经创建，跳过...')
- en: '# add note to player'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加音符到播放器'
- en: nplayer.add(name + '.wav')
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: nplayer.add(name + '.wav')
- en: '# play note if display flag set'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果设置了显示标志，则播放音符'
- en: 'if args.display:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.display:'
- en: nplayer.play(name + '.wav')
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: nplayer.play(name + '.wav')
- en: time.sleep(0.5)
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: time.sleep(0.5)
- en: '# play a random tune'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '# 播放一首随机曲调'
- en: 'if args.play:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.play:'
- en: 'while True:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'try:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: nplayer.playRandom()
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: nplayer.playRandom()
- en: '# rest - 1 to 8 beats'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '# rest - 1到8拍'
- en: rest = np.random.choice([1, 2, 4, 8], 1,
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: rest = np.random.choice([1, 2, 4, 8], 1,
- en: p=[0.15, 0.7, 0.1, 0.05])
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: p=[0.15, 0.7, 0.1, 0.05])
- en: time.sleep(0.25*rest[0])
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: time.sleep(0.25*rest[0])
- en: 'except KeyboardInterrupt:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 'except KeyboardInterrupt:'
- en: exit()
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: exit()
- en: call main
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: call main
- en: 'if __name__ == ''__main__'':'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: main()
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: main()
