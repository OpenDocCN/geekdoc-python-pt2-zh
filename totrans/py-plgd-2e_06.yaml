- en: '[4](nsp-venkitachalam503045-0008.xhtml#rch04)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Musical Overtones with Karplus-Strong
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: One of the main characteristics of any musical sound is its pitch, or *frequency*.
    This is the sound’s number of vibrations per second in hertz (Hz). For example,
    the fourth string of an acoustic guitar produces a D note with a frequency of
    146.83 Hz. You can approximate this sound by creating a sine wave with a frequency
    of 146.83 Hz on a computer, as shown in [Figure 4-1](nsp-venkitachalam503045-0016.xhtml#fig4-1).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, if you play this sine wave on your computer, it won’t sound anything
    like a guitar. Nor will it sound like a piano, or any other real-world musical
    instrument for that matter. What makes a computer sound so different from a musical
    instrument when playing the same note?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f04001.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-1: A sine wave at 146.83 Hz'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: When you pluck a string on a guitar, the instrument produces a mix of frequencies
    with varying intensity. The sound is most intense when the note is first struck,
    and the intensity dies off over time. In the case of plucking a guitar’s D string,
    the dominant frequency you hear, called the *fundamental frequency*, is 146.83 Hz,
    but the sound also contains certain multiples of that frequency called *overtones*.
    In fact, the sound of any note on any instrument is composed of a fundamental
    frequency and overtones, and it’s the combination of these different frequencies
    at different intensities that makes a guitar sound like a guitar, a piano sound
    like a piano, and so on. By contrast, a pure sine wave generated by a computer
    contains only a fundamental frequency, and no overtones.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: You can see the evidence of overtones in *spectral plots*, like the one in [Figure
    4-2](nsp-venkitachalam503045-0016.xhtml#fig4-2) representing the D string of a
    guitar. A spectral plot shows all the frequencies present in a sound at a particular
    moment in time, as well as the intensity of those frequencies. Notice that there
    are many different peaks in the spectral plot shown in the figure, telling us
    that there are many frequencies present in the sound of the guitar’s D string
    being plucked. Near the far left of the plot, the highest peak represents the
    fundamental frequency. The other peaks, representing the overtones, are less intense,
    but they still contribute to the quality of the sound.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f04002.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-2: A spectral plot of the note D3 played on a guitar'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, to simulate the sound of a plucked string instrument on the
    computer, you need to be able to generate both the fundamental frequency and the
    overtones. The trick is to use the Karplus-Strong algorithm. In this project,
    you’ll generate five guitar-like notes of a musical scale (a series of related
    notes) using the Karplus-Strong algorithm. You’ll visualize the algorithm used
    to generate these notes and save the sounds as WAV files. You’ll also create a
    way to play them at random and learn how to do the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，要在计算机上模拟拨弦乐器的声音，你需要能够生成基频和泛音。诀窍就是使用卡普鲁斯-斯特朗算法。在这个项目中，你将使用卡普鲁斯-斯特朗算法生成五个类似吉他的音符（一个系列相关音符）。你将可视化生成这些音符的算法并将声音保存为WAV文件。你还将创建一种随机播放它们的方式，并学习如何做以下事情：
- en: • Implement a ring buffer using the Python `deque` class.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用Python的`deque`类实现环形缓冲区。
- en: • Use `numpy` arrays.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`numpy`数组。
- en: • Play WAV files using `pyaudio`.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`pyaudio`播放WAV文件。
- en: • Plot a graph using `matplotlib`.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用`matplotlib`绘制图表。
- en: • Play the pentatonic musical scale.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 演奏五声音阶。
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah0601)'
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[它是如何工作的](nsp-venkitachalam503045-0008.xhtml#rah0601)'
- en: Imagine a string tied down at both ends, like a string on a guitar. When you
    pluck this string, it vibrates for a while, making a sound, and then settles back
    down to its resting position. At any given point in time while the string is vibrating,
    different parts of the string will be at different displacements from their resting
    position. These displacements can also be thought of as amplitudes of the sound
    wave produced by the vibrating string. The Karplus-Strong algorithm is a series
    of steps for generating and updating a series of these displacement or amplitude
    values to represent the motion of a wave along a plucked string. Play back those
    values as a WAV file and you get a pretty convincing simulation of a plucked string
    sound.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一根两端固定的弦，就像吉他上的弦。当你拨动这根弦时，它会震动一段时间，发出声音，然后恢复到静止位置。在弦震动的任何时刻，弦的不同部分将会与它的静止位置有不同的位移。这些位移也可以看作是弦震动所产生的声波的振幅。卡普鲁斯-斯特朗算法是一系列步骤，用于生成和更新这些位移或振幅值，以表示拨动弦上的波动。将这些值作为WAV文件播放，你就能得到一个非常逼真的拨弦声音模拟。
- en: The Karplus-Strong algorithm stores displacement values in a *ring buffer* (also
    known as a *circular buffer*), a fixed-length buffer (just an array of values)
    that wraps around itself. In other words, when you reach the end of the buffer,
    the next element you access will be the first element in the buffer. (See [“Implementing
    the Ring Buffer with deque”](nsp-venkitachalam503045-0016.xhtml#bh0604) on [page
    66](nsp-venkitachalam503045-0016.xhtml#p66) for more about ring buffers.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 卡普鲁斯-斯特朗算法将位移值存储在*环形缓冲区*（也叫*循环缓冲区*）中，这是一个固定长度的缓冲区（实际上是一个数值数组），它会绕回自身。换句话说，当你到达缓冲区的末尾时，接下来的元素会是缓冲区中的第一个元素。（关于环形缓冲区的更多内容，请参见[“使用deque实现环形缓冲区”](nsp-venkitachalam503045-0016.xhtml#bh0604)，详见[第66页](nsp-venkitachalam503045-0016.xhtml#p66)。）
- en: The length (*N*) of the ring buffer is related to the fundamental frequency
    of the note you want to simulate according to the equation *N* = *S*/*f*, where
    *S* is the sampling rate (more on this later) and *f* is the frequency. At the
    start of the simulation, the buffer is filled with random values in the range
    [−0.5, 0.5], which you might think of as representing the random displacement
    of a string when it’s first plucked. As the simulation progresses, the values
    are updated according to the steps of the Karplus-Strong algorithm, which we’ll
    outline next.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 环形缓冲区的长度(*N*)与所需模拟音符的基频有关，关系式为*N* = *S*/*f*，其中*S*是采样率（稍后会讲解），*f*是频率。在模拟开始时，缓冲区会被填充为[−0.5,
    0.5]范围内的随机值，你可以将这些值理解为表示弦在首次拨动时的随机位移。随着模拟的进行，数值会根据卡普鲁斯-斯特朗算法的步骤进行更新，接下来我们将概述这些步骤。
- en: In addition to the ring buffer, you’ll use a *samples buffer* to store the intensity
    of the sound at any particular time. This buffer represents the final sound data,
    and it’s built up based on the values in the ring buffer. The length of the samples
    buffer and the sampling rate determine the length of the sound clip.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了环形缓冲区，你还需要使用*采样缓冲区*来存储某一特定时间点的声音强度。这个缓冲区代表了最终的声音数据，并且是基于环形缓冲区中的数值构建的。采样缓冲区的长度和采样率决定了声音片段的长度。
- en: '[The Simulation](nsp-venkitachalam503045-0008.xhtml#rbh0601)'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[模拟](nsp-venkitachalam503045-0008.xhtml#rbh0601)'
- en: 'During each time step in the simulation, a value from the ring buffer is stored
    in the samples buffer, and then the values in the ring buffer are updated in a
    kind of feedback scheme, as shown in [Figure 4-3](nsp-venkitachalam503045-0016.xhtml#fig4-3).
    Once the samples buffer is full, you write its contents to a WAV file so the simulated
    note can be played back as audio. For each time step of the simulation, you follow
    these steps, which together make up the Karplus-Strong algorithm:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Store the first value from the ring buffer in the samples buffer.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Calculate the average of the first two elements in the ring buffer.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. Multiply this average value by an attenuation factor (in this case, 0.995).
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4\. Append this value to the end of the ring buffer.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 5\. Remove the first element of the ring buffer.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f04003.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-3: A ring buffer and the Karplus-Strong algorithm'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: This feedback scheme is designed to simulate a wave traveling through a vibrating
    string. The numbers in the ring buffer represent the energy of the wave at each
    point on the string. According to physics, the fundamental frequency of a vibrating
    string is inversely proportional to its length. Since we’re interested in generating
    sounds of a certain frequency, we choose a ring buffer length inversely proportional
    to the desired frequency (this is the *N* = *S*/*f* formula mentioned earlier).
    The averaging that happens in step 2 of the algorithm acts as a *low-pass filter*
    that cuts off higher frequencies and allows lower frequencies through, thereby
    eliminating higher harmonics (that is, larger multiples of the fundamental frequency)
    because you’re mainly interested in the fundamental frequency. The attenuation
    factor in step 3 simulates the loss of energy as the wave travels back and forth
    along the string. This corresponds to the fading of the sound over time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The samples buffer that you add to in step 1 of the simulation represents the
    amplitude of the generated sound over time. Storing the attenuated values at the
    end of the ring buffer (step 4) and removing the first item from the ring buffer
    (step 5) ensures that a steady stream of gradually attenuating values will be
    passed to the samples buffer to build up the simulated sound.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a simple example of the Karplus-Strong algorithm in action. [Table
    4-1](nsp-venkitachalam503045-0016.xhtml#tab4-1) represents a ring buffer at two
    consecutive time steps. Each value in the ring buffer represents the amplitude
    of the sound, which is the same as the displacement of a point on a plucked string
    from its rest position. The buffer has five elements, and they are initially filled
    with some numbers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-1: A Ring Buffer at Two Time Steps in the Karplus-Strong Algorithm'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '| Time step 1 | 0.1 | −0.2 | 0.3 | 0.6 | −0.5 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| Time step 2 | −0.2 | 0.3 | 0.6 | −0.5 | −0.04975 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: As you go from time step 1 to time step 2, you apply the Karplus-Strong algorithm
    as follows. The first value in the first row, 0.1, is removed, and all subsequent
    values from time step 1 are added in the same order to the second row, which represents
    time step 2\. The last value in time step 2 is the attenuated average of the first
    and second values of time step 1, which is calculated as 0.995 × ((0.1 + −0.2)
    ÷ 2) = −0.04975.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[The WAV File Format](nsp-venkitachalam503045-0008.xhtml#rbh0602)'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Waveform Audio File Format (WAV)* is used to store audio data. This format
    is convenient for small audio projects because it’s simple and doesn’t require
    you to worry about complicated compression techniques.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: In its simplest form, a WAV file consists of a series of values, where each
    value represents the amplitude of the stored sound at a given point in time. Each
    value is allotted a fixed number of bits, called the *resolution*. You’ll use
    16-bit resolution in this project. WAV files also have a set *sampling rate*,
    which is the number of times the audio is *sampled*, or read, every second. In
    this project, you use a sampling rate of 44,100 Hz, the rate used in audio CDs.
    In sum, when you generate a WAV file simulating the sound of a plucked string,
    it will contain 44,100 16-bit values for every second of audio.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'For this project, you’ll be using Python’s `wave` module, which includes methods
    for working with WAV files. To get a feel for how it works, let’s generate a five-second
    audio clip of a 220 Hz sine wave using Python. First you represent a sine wave
    using this formula:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '*A* = sin(2π*ft*)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, *A* is the amplitude of the wave, *f* is the frequency, and *t* is the
    current time index. Now you rewrite this equation as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '*A* = sin(2π*fi*/*R*)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: In this equation, *i* is the index of the sample, and *R* is the sampling rate.
    Using these two equations, you can create a five-second WAV file for a 200 Hz
    sine wave as follows. (This code is available in *sine.py* in the chapter’s GitHub
    repository.)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: import wave, math
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: sRate = 44100
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: nSamples = sRate * 5
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: ❶ x = np.arange(nSamples)/float(sRate)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: ❷ vals = np.sin(2.0*math.pi*220.0*x)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: ❸ data = np.array(vals*32767, 'int16').tostring()
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: file = wave.open('sine220.wav', 'wb')
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: ❹ file.setparams((1, 2, sRate, nSamples, 'NONE', 'uncompressed'))
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: ❺ file.writeframes(data)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: file.close()
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: You create a `numpy` array of numbers from `0` to `nSamples − 1` and divide
    those numbers by the sample rate to get the time value, in seconds, when each
    sample of the audio clip is taken ❶. This array represents the *i*/*R* portion
    of the sine wave equation discussed earlier. Next, you use the array to create
    a second `numpy` array, this one containing sine wave amplitude values, again
    following the sine wave equation ❷. The `numpy` array is a fast and convenient
    way to apply functions such as the `sin()` function to many values at once.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The computed sine wave values in the range [−1, 1] are scaled to 16-bit values
    and converted to a string so they can be written to a WAV file ❸. Then you set
    the parameters for the WAV file; in this case, it’s a single-channel (mono), 2-byte
    (16-bit), uncompressed format ❹. Finally, you write the data to the file ❺. [Figure
    4-4](nsp-venkitachalam503045-0016.xhtml#fig4-4) shows the generated *sine220.wav*
    file in Audacity, a free audio editor. As expected, you see a sine wave of frequency
    220 Hz, and when you play the file, you hear a 220 Hz tone for five seconds. (Note
    that you need to use the Zoom tool in Audacity to see the sine wave as shown in
    [Figure 4-4](nsp-venkitachalam503045-0016.xhtml#fig4-4).)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f04004.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-4: A sine wave at 220 Hz, zoomed in'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: In your project, once you’ve filled the samples buffer with audio data, you’ll
    write it to a WAV file using the same pattern illustrated in [Figure 4-4](nsp-venkitachalam503045-0016.xhtml#fig4-4).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[The Minor Pentatonic Scale](nsp-venkitachalam503045-0008.xhtml#rbh0603)'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *musical scale* is a series of notes in increasing or decreasing pitch (frequency).
    Often, all notes in a piece of music are chosen from a particular scale. A *musical
    interval* is the difference between two pitches. A *semitone* is a basic building
    block of a scale and is the smallest musical interval in Western music. A *tone*
    is twice the length of a semitone. The *major scale*, one of the most common musical
    scales, is defined by the interval pattern *tone-tone-semitone-tone-tone-tone-semitone*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: We’ll briefly go into the pentatonic scale here, since you’ll be generating
    musical notes in that scale. This section will explain the source of the frequency
    numbers used in the final program to generate notes with the Karplus-Strong algorithm.
    The *pentatonic scale* is a five-note musical scale. A variant of this scale is
    the *minor pentatonic scale*, which is defined by the interval pattern *(tone+semitone)-tone-tone-(tone+semitone)-tone*.
    Thus, the C minor pentatonic scale consists of the notes C, E-flat, F, G, and
    B-flat. [Table 4-2](nsp-venkitachalam503045-0016.xhtml#tab4-2) lists the frequencies
    of the five notes of a C minor pentatonic scale that you’ll generate using the
    Karplus-Strong algorithm. (Here, C4 designates C in the fourth octave of a piano,
    or *middle C*, by convention.)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-2: Notes in a Minor Pentatonic Scale'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '| Note | Frequency (Hz) |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| C4 | 261.6 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| E-flat | 311.1 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| F | 349.2 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| G | 392.0 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| B-flat | 466.2 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: One aspect of this project will be stringing together random sequences of notes
    to create melodies. One of the reasons we’re focusing on a minor pentatonic scale
    is that the notes of this scale sound pleasing no matter what order they’re played
    in. Thus, the scale is particularly conducive to generating random melodies in
    a way that other scales, such as a major scale, are not.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah0602)'
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, you’ll use the Python `wave` module to create audio files in
    the WAV format. To implement the Karplus-Strong algorithm, you’ll use the `deque`
    class from the Python `collections` module as a ring buffer and a `numpy` array
    as a samples buffer. You’ll also use `matplotlib` to visualize the simulated guitar
    string, and you’ll play back the WAV files with the `pyaudio` module.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah0603)'
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s develop the various pieces of code required to implement the Karplus-Strong
    algorithm and then put them together for the complete program. To see the full
    project code, skip ahead to [“The Complete Code”](nsp-venkitachalam503045-0016.xhtml#ah0607)
    on [page 74](nsp-venkitachalam503045-0016.xhtml#p74). You can also download the
    code from the book’s GitHub repository at [https://github.com/mkvenkit/pp2e/tree/main/karplus](https://github.com/mkvenkit/pp2e/tree/main/karplus).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[Implementing the Ring Buffer with deque](nsp-venkitachalam503045-0008.xhtml#rbh0604)'
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall from earlier that the Karplus-Strong algorithm uses a ring buffer to
    generate a musical note. You’ll implement the ring buffer using a `deque` container
    (pronounced “deck”), which is part of Python’s `collections` module of specialized
    container data types. You can insert and remove elements from the beginning (head)
    or end (tail) of a `deque` (see [Figure 4-5](nsp-venkitachalam503045-0016.xhtml#fig4-5)).
    This insertion and removal process is a `O(1)`, or a “constant time” operation,
    which means it takes the same amount of time regardless of how big the `deque`
    container gets.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f04005.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-5: A ring buffer implemented using `deque`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows an example of how you would use `deque` in Python:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '>>> `from collections import deque`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: ❶ >>> `d = deque(range(10), maxlen=10)`
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '>>> `print(d)`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: ❷ >>> `d.append(10)`
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '>>> `print(d)`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], maxlen=10)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: You create the `deque` container by passing in a list created with the `range()`
    function ❶. You also specify the maximum length `maxlen` of the `deque` as `10`.
    Next, you append the element `10` to the end of the `deque` container ❷. When
    you then print the `deque`, you can see that `10` has been appended to the end
    of the `deque`, while the first element, `0`, has automatically been removed to
    maintain the `deque` container’s maximum length of 10 elements. This scheme will
    allow you to simultaneously implement steps 4 and 5 of the Karplus-Strong algorithm—adding
    a new value at the end of the ring buffer while removing the first value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[Implementing the Karplus-Strong Algorithm](nsp-venkitachalam503045-0008.xhtml#rbh0605)'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll now implement the Karplus-Strong algorithm in the `generateNote()` function,
    using a `deque` container to implement the ring buffer and a `numpy` array to
    implement the samples buffer. In the same function, you’ll also visualize the
    algorithm using `matplotlib`. The plot will show how the amplitudes of the plucked
    string change over time, in effect showing how the string moves as it vibrates.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'You begin with some setup:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: initialize plotting
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ❶ fig, ax = plt.subplots(1)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: ❷ line, = ax.plot([], [])
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'def generateNote(freq):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '"""generate note using Karplus-Strong algorithm"""'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: nSamples = 44100
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: sampleRate = 44100
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: ❸ N = int(sampleRate/freq)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '❹ if gShowPlot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '# set axis'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: ax.set_xlim([0, N])
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: ax.set_ylim([-1.0, 1.0])
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: line.set_xdata(np.arange(0, N))
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '# initialize ring buffer'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: ❺ buf = deque([random.random() - 0.5 for i in range(N)], maxlen=N)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '# init samples buffer'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: ❻ samples = np.array([0]*nSamples, 'float32')
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: First you create a `matplotlib` figure ❶ and a line plot ❷, which you’ll fill
    with data. Then you begin the `generateNote()` function definition, which takes
    the frequency of the note to be generated as a parameter. You set the number of
    samples in the sound clip and the sample rate to both be 44,100, which means the
    resulting clip will be one second long. Then you divide the sample rate by the
    desired frequency to set the length `N` of the Karplus-Strong ring buffer ❸. If
    the `gShowPlot` flag is set ❹, you initialize the x and y range of the plot and
    initialize the x values to `[0, ... N-1]` using the `arange()` function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: You next initialize the ring buffer as a `deque` container with random numbers
    in the range [−0.5, 0.5], setting the maximum length of the `deque` to `N` ❺.
    You also initialize the samples buffer as a `numpy` array of floats ❻. You set
    the length of the array to be the number of samples the sound clip will contain.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes the heart of the `generateNote()` function, where you implement
    the steps of the Karplus-Strong algorithm and create the visualization:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(nSamples):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: ❶ samples[i] = buf[0]
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: ❷ avg = 0.995*0.5*(buf[0] + buf[1])
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: ❸ buf.append(avg)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '# plot of flag set'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '❹ if gShowPlot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'if i % 1000 == 0:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: line.set_ydata(buf)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: fig.canvas.draw()
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: fig.canvas.flush_events()
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '# samples to 16-bit to string'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '# max value is 32767 for 16-bit'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: ❺ samples = np.array(samples * 32767, 'int16')
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: ❻ return samples.tobytes()
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Here you iterate over each element in the samples buffer and carry out the steps
    of the Karplus-Strong algorithm. With each iteration, you copy the first element
    in the ring buffer to the samples buffer ❶. Then you perform the low-pass filtering
    and attenuation by averaging the first two elements in the ring buffer and multiplying
    the result by 0.995 ❷. This attenuated value is appended to the end of the ring
    buffer ❸. Since the `deque` representing the ring buffer has a maximum length,
    the `append()` operation also removes the first element from the buffer.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The `samples` array is converted into a 16-bit format by multiplying each value
    by 32,767 ❺ (a 16-bit signed integer can take values only from −32,768 to 32,767,
    and 0.5 × 65,534 = 32,767). Then the array is converted to a byte representation
    for the `wave` module, which you’ll use to save this data to a file ❻.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: As the algorithm is running, you visualize how the ring buffer evolves ❹. For
    every thousand samples, you update the `matplotlib` graph with the values in the
    ring buffer, and this shows how the data changes with time.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[Writing a WAV File](nsp-venkitachalam503045-0008.xhtml#rbh0606)'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have the audio data, you can write it to a WAV file using the Python
    `wave` module. Define a `writeWAVE()` function to carry this out:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'def writeWAVE(fname, data):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '# open file'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: ❶ file = wave.open(fname, 'wb')
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '# WAV file parameters'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: nChannels = 1
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: sampleWidth = 2
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: frameRate = 44100
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: nFrames = 44100
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '# set parameters'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: ❷ file.setparams((nChannels, sampleWidth, frameRate, nFrames,
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '''NONE'', ''noncompressed''))'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: ❸ file.writeframes(data)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: file.close()
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: You create a WAV file ❶ and set its parameters using a single-channel, 16-bit,
    noncompressed format ❷. Then you write the data to the file ❸.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[Playing WAV Files with pyaudio](nsp-venkitachalam503045-0008.xhtml#rbh0607)'
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you’ll use the Python `pyaudio` module to play the WAV files generated
    by the algorithm. `pyaudio` is a high-performance, low-level library that gives
    you access to sound devices on a computer. For convenience, you encapsulate the
    code in a `NotePlayer` class, as shown here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'class NotePlayer:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '# constructor'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '# init pyaudio'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: ❶ self.pa = pyaudio.PyAudio()
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '# open stream'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: ❷ self.stream = self.pa.open(
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: format=pyaudio.paInt16,
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: channels=1,
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: rate=44100,
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: output=True)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '# dictionary of notes'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: ❸ self.notes = []
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: In the `NotePlayer` class’s constructor, you first create the `PyAudio` object
    that you’ll use to play the WAV file ❶. Then you open a 16-bit single-channel
    `PyAudio` output stream ❷. You also create an empty list that you’ll later fill
    with filenames of the five pentatonic note WAV files ❸.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, when all references to an object have been deleted, the object is
    destroyed by a process called *garbage collection*. At that time, the object’s
    `__del__()` method, also known as a *destructor*, is called, if one is defined.
    Here’s the `NotePlayer` class’s destructor:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'def __del__(self):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '# destructor'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: self.stream.stop_stream()
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: self.stream.close()
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: self.pa.terminate()
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: This method ensures that the `PyAudio` stream is cleaned up when the `NotePlayer`
    object is destroyed. Failing to provide a `__del__()` method for a class can cause
    problems when objects are repeatedly created and destroyed, since some system-wide
    resources (like `pyaudio` in this case) may not be cleaned up properly.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining methods of the `NotePlayer` class are devoted to building up
    a list of possible notes and playing them. First, here’s the `add()` method, which
    is used to add a WAV filename to the class:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'def add(self, fileName):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: self.notes.append(fileName)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: The method takes a filename corresponding to one of the generated WAV files
    as a parameter and adds it to the `notes` list you initialized in the class’s
    constructor. The class will draw on this list when it wants to play a WAV file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s look at the `play()` method used to play a note:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'def play(self, fileName):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: print("playing " + fileName)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '# open WAV file'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: ❶ wf = wave.open(fileName, 'rb')
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '# read a chunk'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: ❷ data = wf.readframes(CHUNK)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '# read rest'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'while data != b'''':'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: ❸ self.stream.write(data)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: ❹ data = wf.readframes(CHUNK)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '# clean up'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: ❺ wf.close()
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'except BaseException as err:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: ❻ print(f"Exception! {err=}, {type(err)=}.\nExiting.")
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: exit(0)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Here you open the desired WAV file using Python’s `wave` module ❶. Then you
    read `CHUNK` frames (defined globally as 1,024 in this case) from the file into
    `data` ❷. Next, within a `while` loop, you write the contents of `data` to the
    `PyAudio` output stream ❸ and read the next chunk of data from the WAV file ❹.
    Writing to the output stream has the effect of playing the audio through the default
    audio device of your computer, which is typically a speaker. You read the data
    in chunks to maintain the sample rate at the output side. If the chunks are too
    large and you take too much time in between reading and writing, the audio won’t
    sound right.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The `while` loop continues for as long as there’s more data to read—that is,
    until `data` is empty. At that point, you close the WAV file object ❺. You handle
    any exceptions that may happen during the playback process (for example, the user
    pressing CTRL-C) by printing the error ❻ and exiting the program.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `NotePlayer` class’s `playRandom()` method picks a random note
    from the five notes you’ve generated and plays it:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'def playRandom(self):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '"""play a random note"""'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: index = random.randint(0, len(self.notes)-1)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: note = self.notes[index]
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: self.play(note)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The method selects a random WAV filename from the `notes` list and passes that
    filename to the `play()` method to be played.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[Creating Notes and Parsing Arguments](nsp-venkitachalam503045-0008.xhtml#rbh0608)'
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s look at the program’s `main()` function, which creates the notes
    and handles various command line options to play the notes:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: --`snip`--
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: parser = argparse.ArgumentParser(description="Generating sounds with
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Karplus-Strong Algorithm")
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '# add arguments'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: parser.add_argument('--display', action='store_true', required=False)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: parser.add_argument('--play', action='store_true', required=False)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: args = parser.parse_args()
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '# show plot if flag set'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '❶ if args.display:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: gShowPlot = True
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: plt.show(block=False)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '# create note player'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: ❷ nplayer = NotePlayer()
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: print('creating notes...')
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'for name, freq in list(pmNotes.items()):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: fileName = name + '.wav'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '❸ if not os.path.exists(fileName) or args.display:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: data = generateNote(freq)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: print('creating ' + fileName + '...')
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: writeWAVE(fileName, data)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: print('fileName already created. skipping...')
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '# add note to player'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: ❹ nplayer.add(name + '.wav')
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '# play note if display flag set'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'if args.display:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: ❺ nplayer.play(name + '.wav')
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: time.sleep(0.5)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '# play a random tune'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'if args.play:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: ❻ nplayer.playRandom()
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '# rest - 1 to 8 beats'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: ❼ rest = np.random.choice([1, 2, 4, 8], 1,
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: p=[0.15, 0.7, 0.1, 0.05])
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: time.sleep(0.25*rest[0])
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'except KeyboardInterrupt:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: exit()
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: First you set up some command line options for the program using `argparse`,
    as discussed in earlier projects. The `--display` option will play each of the
    five notes in turn, while visualizing each note’s waveform using `matplotlib`.
    The `--play` option generates a random melody using the five notes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: If the `--display` command line option was used ❶, you set up a `matplotlib`
    plot to show how the waveform evolves during the Karplus-Strong algorithm. The
    `plt.show(block=False)` call ensures that the `matplotlib` display method doesn’t
    block. This way, when you call this function, it will return immediately and go
    on to the next statement. This is the behavior you need, since you’re manually
    updating the plot every frame.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'You next create an instance of the `NotePlayer` class ❷. Then you generate
    WAV files of the five notes in the C minor pentatonic scale. The frequencies for
    the notes are defined in the global dictionary `pmNotes`, which looks like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'pmNotes = {''C4'': 262, ''Eb'': 311, ''F'': 349, ''G'': 391, ''Bb'': 466}'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: To generate the notes, you iterate through the dictionary, first constructing
    a filename for the note using the dictionary key plus the *.wav* extension—for
    example, *C4.wav*. You use the `os.path.``exists()` method to see whether the
    WAV file for a particular note has been created ❸. If so, you skip the computation
    for that note. (This is a handy optimization if you’re running this program several
    times.) Otherwise, you generate the note using the `generateNote()` and `writeWAVE()`
    functions you defined earlier. Once the note is computed and the WAV file created,
    you add the note’s filename to the `NotePlayer` object’s list of notes ❹, and
    then you play the note if the `--display` command line option is used ❺.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: If the `--play` option is used, the `playRandom()` method in `NotePlayer` repeatedly
    plays a note at random from the five notes ❻. For a note sequence to sound even
    remotely musical, you need to add rests between the notes played, so you use the
    `random.``choice()` method from `numpy` to choose a random rest interval ❼. This
    method also lets you choose the probability of the rest interval, which you set
    so that a two-beat rest is the most probable and an eight-beat rest the least
    probable. Try changing these values to create your own style of random music!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[Running the Plucked String Simulation](nsp-venkitachalam503045-0008.xhtml#rah0604)'
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run the code for this project, enter this in a command shell:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: $ `python ks.py --display`
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 4-6](nsp-venkitachalam503045-0016.xhtml#fig4-6), the
    `matplotlib` plot shows how the Karplus-Strong algorithm converts the initial
    random displacements to create waves of the desired frequency.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f04006.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-6: A sample run of the plucked string simulation'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Now try playing a random sequence of notes using this command:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: $ `python ks.py --play`
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: This should play a random note sequence using the generated WAV files of the
    pentatonic musical scale.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah0605)'
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this project, you used the Karplus-Strong algorithm to simulate the sound
    of plucked strings and played notes from generated WAV files. You learned how
    to implement the Karplus-Strong algorithm using a `deque` container as a ring
    buffer. You also learned about the WAV file format and how to play WAV files using
    `pyaudio`, as well as how to use `matplotlib` to visualize a vibrating string.
    You even learned about the pentatonic musical scale!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah0606)'
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some ideas for experiments:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 1\. I’ve stated that the Karplus-Strong algorithm creates realistic plucked
    string sounds by generating overtones as well as the fundamental frequency of
    the note. But how do you know it’s working? By creating spectral plots of your
    WAV files, like the one in [Figure 4-2](nsp-venkitachalam503045-0016.xhtml#fig4-2).
    You can use the free program Audacity to do this. Open one of the WAV files in
    Audacity, and select **Analyze‣Plot** **Spectrum**. You should see that the sound
    contains many frequencies.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Use the techniques you learned in this chapter to create a method that replicates
    the sound of two strings of different frequencies vibrating together. Remember,
    the Karplus-Strong algorithm produces a ring buffer full of sound amplitude values.
    You can combine two sounds by adding their amplitudes together.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. Replicate the sound of two strings vibrating together, as described in the
    previous experiment, but add a time delay between the first and second string
    plucks.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '4\. Write a method to read music from a text file and generate musical notes.
    Then play the music using these notes. You can use a format where the note names
    are followed by integer rest time intervals, like this: C4 1 F4 2 G4 1 . . .'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah0607)'
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s the complete code for this project:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: ks.py
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Uses the Karplus-Strong algorithm to generate musical notes
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: in a pentatonic scale.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: import sys, os
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: import time, random
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: import wave, argparse
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: from collections import deque
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: import matplotlib
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: to fix graph display issues on macOS
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: matplotlib.use('TkAgg')
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: from matplotlib import pyplot as plt
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: import pyaudio
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: show plot of algorithm in action?
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: gShowPlot = False
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: notes of a pentatonic minor scale
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: piano C4-E(b)-F-G-B(b)-C5
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'pmNotes = {''C4'': 262, ''Eb'': 311, ''F'': 349, ''G'':391, ''Bb'':466}'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: CHUNK = 1024
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: initialize plotting
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: fig, ax = plt.subplots(1)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: line, = ax.plot([], [])
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: write out WAV file
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def writeWAVE(fname, data):'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '"""write data to WAV file"""'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '# open file'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: file = wave.open(fname, 'wb')
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '# WAV file parameters'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: nChannels = 1
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: sampleWidth = 2
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: frameRate = 44100
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: nFrames = 44100
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '# set parameters'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: file.setparams((nChannels, sampleWidth, frameRate, nFrames,
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '''NONE'', ''noncompressed''))'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: file.writeframes(data)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: file.close()
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'def generateNote(freq):'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '"""generate note using Karplus-Strong algorithm"""'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: nSamples = 44100
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: sampleRate = 44100
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: N = int(sampleRate/freq)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'if gShowPlot:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '# set axis'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: ax.set_xlim([0, N])
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: ax.set_ylim([-1.0, 1.0])
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: line.set_xdata(np.arange(0, N))
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '# initialize ring buffer'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: buf = deque([random.random() - 0.5 for i in range(N)], maxlen=N)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '# init sample buffer'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: samples = np.array([0]*nSamples, 'float32')
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(nSamples):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: samples[i] = buf[0]
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: avg = 0.995*0.5*(buf[0] + buf[1])
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: buf.append(avg)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '# plot of flag set'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'if gShowPlot:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'if i % 1000 == 0:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: line.set_ydata(buf)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: fig.canvas.draw()
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: fig.canvas.flush_events()
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '# samples to 16-bit to string'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '# max value is 32767 for 16-bit'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: samples = np.array(samples * 32767, 'int16')
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: return samples.tobytes()
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: play a WAV file
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'class NotePlayer:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '# constructor'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '# init pyaudio'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: self.pa = pyaudio.PyAudio()
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '# open stream'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: self.stream = self.pa.open(
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: format=pyaudio.paInt16,
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: channels=1,
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: rate=44100,
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: output=True)
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '# dictionary of notes'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: self.notes = []
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'def __del__(self):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '# destructor'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: self.stream.stop_stream()
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: self.stream.close()
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: self.pa.terminate()
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '# add a note'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'def add(self, fileName):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: self.notes.append(fileName)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '# play a note'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'def play(self, fileName):'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: print("playing " + fileName)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '# open WAV file'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: wf = wave.open(fileName, 'rb')
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '# read a chunk'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: data = wf.readframes(CHUNK)
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '# read rest'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'while data != b'''':'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: self.stream.write(data)
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: data = wf.readframes(CHUNK)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '# clean up'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: wf.close()
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'except BaseException as err:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: print(f"Exception! {err=}, {type(err)=}.\nExiting.")
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: exit(0)
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'def playRandom(self):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '"""play a random note"""'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: index = random.randint(0, len(self.notes)-1)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: note = self.notes[index]
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: self.play(note)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: main() function
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def main():'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '# declare global var'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: global gShowPlot
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: parser = argparse.ArgumentParser(description="Generating sounds with
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Karplus-Strong Algorithm.")
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '# add arguments'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: parser.add_argument('--display', action='store_true', required=False)
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: parser.add_argument('--play', action='store_true', required=False)
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: args = parser.parse_args()
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '# show plot if flag set'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'if args.display:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: gShowPlot = True
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '# plt.ion()'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: plt.show(block=False)
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '# create note player'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: nplayer = NotePlayer()
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: print('creating notes...')
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'for name, freq in list(pmNotes.items()):'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: fileName = name + '.wav'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'if not os.path.exists(fileName) or args.display:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: data = generateNote(freq)
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: print('creating ' + fileName + '...')
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: writeWAVE(fileName, data)
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: print('fileName already created. skipping...')
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '# add note to player'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: nplayer.add(name + '.wav')
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '# play note if display flag set'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'if args.display:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: nplayer.play(name + '.wav')
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: time.sleep(0.5)
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '# play a random tune'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'if args.play:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: nplayer.playRandom()
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '# rest - 1 to 8 beats'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: rest = np.random.choice([1, 2, 4, 8], 1,
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: p=[0.15, 0.7, 0.1, 0.05])
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: time.sleep(0.25*rest[0])
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'except KeyboardInterrupt:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: exit()
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: call main
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: main()
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
