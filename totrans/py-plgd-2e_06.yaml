- en: '[4](nsp-venkitachalam503045-0008.xhtml#rch04)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[4](nsp-venkitachalam503045-0008.xhtml#rch04)'
- en: Musical Overtones with Karplus-Strong
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Karplus-Strong 的音乐泛音
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: One of the main characteristics of any musical sound is its pitch, or *frequency*.
    This is the sound’s number of vibrations per second in hertz (Hz). For example,
    the fourth string of an acoustic guitar produces a D note with a frequency of
    146.83 Hz. You can approximate this sound by creating a sine wave with a frequency
    of 146.83 Hz on a computer, as shown in [Figure 4-1](nsp-venkitachalam503045-0016.xhtml#fig4-1).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 任何音乐声音的主要特征之一就是其音高，或称*频率*。这是声音每秒钟的振动次数，单位为赫兹（Hz）。例如，原声吉他的第四根弦发出 D 音符，其频率为 146.83
    Hz。你可以通过在计算机上生成频率为 146.83 Hz 的正弦波来大致模拟这种声音，如[图 4-1](nsp-venkitachalam503045-0016.xhtml#fig4-1)所示。
- en: Unfortunately, if you play this sine wave on your computer, it won’t sound anything
    like a guitar. Nor will it sound like a piano, or any other real-world musical
    instrument for that matter. What makes a computer sound so different from a musical
    instrument when playing the same note?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果你在计算机上播放这个正弦波，它听起来不会像吉他。它也不会像钢琴，或者任何其他现实中的乐器那样发声。那么，为什么计算机播放相同音符时，声音和乐器如此不同呢？
- en: '![](images/nsp-venkitachalam503045-f04001.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f04001.jpg)'
- en: 'Figure 4-1: A sine wave at 146.83 Hz'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-1：频率为 146.83 Hz 的正弦波
- en: When you pluck a string on a guitar, the instrument produces a mix of frequencies
    with varying intensity. The sound is most intense when the note is first struck,
    and the intensity dies off over time. In the case of plucking a guitar’s D string,
    the dominant frequency you hear, called the *fundamental frequency*, is 146.83 Hz,
    but the sound also contains certain multiples of that frequency called *overtones*.
    In fact, the sound of any note on any instrument is composed of a fundamental
    frequency and overtones, and it’s the combination of these different frequencies
    at different intensities that makes a guitar sound like a guitar, a piano sound
    like a piano, and so on. By contrast, a pure sine wave generated by a computer
    contains only a fundamental frequency, and no overtones.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拨动吉他的弦时，乐器会发出多种频率的声音，且其强度不同。音调在刚击打时最为强烈，随时间衰减。以拨动吉他的 D 弦为例，你听到的主要频率，称为*基频*，是
    146.83 Hz，但声音中还包含了该频率的某些倍频，称为*泛音*。事实上，任何乐器上的音符都由基频和泛音组成，正是这些不同频率的组合和不同强度的声音，使得吉他听起来像吉他，钢琴听起来像钢琴，等等。相比之下，由计算机生成的纯正弦波只包含基频，而没有泛音。
- en: You can see the evidence of overtones in *spectral plots*, like the one in [Figure
    4-2](nsp-venkitachalam503045-0016.xhtml#fig4-2) representing the D string of a
    guitar. A spectral plot shows all the frequencies present in a sound at a particular
    moment in time, as well as the intensity of those frequencies. Notice that there
    are many different peaks in the spectral plot shown in the figure, telling us
    that there are many frequencies present in the sound of the guitar’s D string
    being plucked. Near the far left of the plot, the highest peak represents the
    fundamental frequency. The other peaks, representing the overtones, are less intense,
    but they still contribute to the quality of the sound.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过*频谱图*看到泛音的证据，就像[图 4-2](nsp-venkitachalam503045-0016.xhtml#fig4-2)中表示吉他
    D 弦的频谱图一样。频谱图显示了某一时刻声音中所有频率的存在情况以及这些频率的强度。请注意，图中的频谱图有许多不同的峰值，这告诉我们吉他 D 弦拨动的声音中存在多种频率。在图的最左侧，最高的峰值代表基频。其他峰值代表泛音，它们的强度较低，但仍然对声音的品质有所贡献。
- en: '![](images/nsp-venkitachalam503045-f04002.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f04002.jpg)'
- en: 'Figure 4-2: A spectral plot of the note D3 played on a guitar'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-2：吉他上弹奏 D3 音符的频谱图
- en: 'As you can see, to simulate the sound of a plucked string instrument on the
    computer, you need to be able to generate both the fundamental frequency and the
    overtones. The trick is to use the Karplus-Strong algorithm. In this project,
    you’ll generate five guitar-like notes of a musical scale (a series of related
    notes) using the Karplus-Strong algorithm. You’ll visualize the algorithm used
    to generate these notes and save the sounds as WAV files. You’ll also create a
    way to play them at random and learn how to do the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，要在计算机上模拟拔弦乐器的声音，你需要能够生成基频和泛音。诀窍是使用 Karplus-Strong 算法。在这个项目中，你将使用 Karplus-Strong
    算法生成五个类似吉他的音符，构成一个音阶（一系列相关的音符）。你将可视化生成这些音符所使用的算法，并将声音保存为 WAV 文件。你还将创建一个随机播放它们的方法，并学习如何完成以下操作：
- en: • Implement a ring buffer using the Python `deque` class.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 Python 的 `deque` 类实现环形缓冲区。
- en: • Use `numpy` arrays.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 `numpy` 数组。
- en: • Play WAV files using `pyaudio`.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 `pyaudio` 播放 WAV 文件。
- en: • Plot a graph using `matplotlib`.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 `matplotlib` 绘制图表。
- en: • Play the pentatonic musical scale.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 播放五声音阶。
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah0601)'
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[它是如何工作的](nsp-venkitachalam503045-0008.xhtml#rah0601)'
- en: Imagine a string tied down at both ends, like a string on a guitar. When you
    pluck this string, it vibrates for a while, making a sound, and then settles back
    down to its resting position. At any given point in time while the string is vibrating,
    different parts of the string will be at different displacements from their resting
    position. These displacements can also be thought of as amplitudes of the sound
    wave produced by the vibrating string. The Karplus-Strong algorithm is a series
    of steps for generating and updating a series of these displacement or amplitude
    values to represent the motion of a wave along a plucked string. Play back those
    values as a WAV file and you get a pretty convincing simulation of a plucked string
    sound.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一根两端固定的弦，就像吉他上的弦。当你拨动这根弦时，它会震动一段时间，发出声音，然后回到静止位置。在弦震动的任何时刻，弦的不同部分将会处于与静止位置不同的位移状态。这些位移也可以看作是弦振动所产生的声波的振幅。Karplus-Strong
    算法是一系列步骤，用于生成和更新这些位移或振幅值，以表示拨动弦上波动的运动。将这些值作为 WAV 文件回放，你会得到一个相当逼真的拔弦声音模拟。
- en: The Karplus-Strong algorithm stores displacement values in a *ring buffer* (also
    known as a *circular buffer*), a fixed-length buffer (just an array of values)
    that wraps around itself. In other words, when you reach the end of the buffer,
    the next element you access will be the first element in the buffer. (See [“Implementing
    the Ring Buffer with deque”](nsp-venkitachalam503045-0016.xhtml#bh0604) on [page
    66](nsp-venkitachalam503045-0016.xhtml#p66) for more about ring buffers.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Karplus-Strong 算法将位移值存储在一个 *环形缓冲区*（也叫 *循环缓冲区*）中，这是一个固定长度的缓冲区（就是一个值的数组），它会自我环绕。换句话说，当你到达缓冲区的末尾时，下一个访问的元素将是缓冲区的第一个元素。（有关环形缓冲区的更多信息，请参见
    [“使用 deque 实现环形缓冲区”](nsp-venkitachalam503045-0016.xhtml#bh0604)，见 [第 66 页](nsp-venkitachalam503045-0016.xhtml#p66)）
- en: The length (*N*) of the ring buffer is related to the fundamental frequency
    of the note you want to simulate according to the equation *N* = *S*/*f*, where
    *S* is the sampling rate (more on this later) and *f* is the frequency. At the
    start of the simulation, the buffer is filled with random values in the range
    [−0.5, 0.5], which you might think of as representing the random displacement
    of a string when it’s first plucked. As the simulation progresses, the values
    are updated according to the steps of the Karplus-Strong algorithm, which we’ll
    outline next.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 环形缓冲区的长度（*N*）与您想要模拟的音符的基频有关，具体公式为 *N* = *S*/*f*，其中 *S* 是采样率（稍后会详细讲解），*f* 是频率。在模拟开始时，缓冲区被填充了范围为
    [−0.5, 0.5] 的随机值，你可以将这些值理解为弦在刚被拨动时的随机位移。随着模拟的进行，这些值会根据 Karplus-Strong 算法的步骤进行更新，接下来我们将概述这些步骤。
- en: In addition to the ring buffer, you’ll use a *samples buffer* to store the intensity
    of the sound at any particular time. This buffer represents the final sound data,
    and it’s built up based on the values in the ring buffer. The length of the samples
    buffer and the sampling rate determine the length of the sound clip.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了环形缓冲区，你还将使用一个 *样本缓冲区* 来存储某一时刻的声音强度。这个缓冲区代表最终的声音数据，它是根据环形缓冲区中的值构建的。样本缓冲区的长度和采样率决定了声音片段的长度。
- en: '[The Simulation](nsp-venkitachalam503045-0008.xhtml#rbh0601)'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[模拟过程](nsp-venkitachalam503045-0008.xhtml#rbh0601)'
- en: 'During each time step in the simulation, a value from the ring buffer is stored
    in the samples buffer, and then the values in the ring buffer are updated in a
    kind of feedback scheme, as shown in [Figure 4-3](nsp-venkitachalam503045-0016.xhtml#fig4-3).
    Once the samples buffer is full, you write its contents to a WAV file so the simulated
    note can be played back as audio. For each time step of the simulation, you follow
    these steps, which together make up the Karplus-Strong algorithm:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个时间步长的模拟过程中，环形缓冲区中的一个值被存储到样本缓冲区中，然后环形缓冲区中的值会在一种反馈机制下进行更新，如[图4-3](nsp-venkitachalam503045-0016.xhtml#fig4-3)所示。一旦样本缓冲区满了，你就可以将其内容写入WAV文件，以便模拟的音符可以作为音频回放。对于每一个时间步长的模拟，你按照这些步骤操作，这些步骤一起构成了Karplus-Strong算法：
- en: 1\. Store the first value from the ring buffer in the samples buffer.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 将环形缓冲区中的第一个值存储到样本缓冲区中。
- en: 2\. Calculate the average of the first two elements in the ring buffer.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 计算环形缓冲区前两个元素的平均值。
- en: 3\. Multiply this average value by an attenuation factor (in this case, 0.995).
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 将这个平均值乘以衰减因子（在这个例子中是0.995）。
- en: 4\. Append this value to the end of the ring buffer.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 将该值附加到环形缓冲区的末尾。
- en: 5\. Remove the first element of the ring buffer.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5\. 移除环形缓冲区的第一个元素。
- en: '![](images/nsp-venkitachalam503045-f04003.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f04003.jpg)'
- en: 'Figure 4-3: A ring buffer and the Karplus-Strong algorithm'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-3：环形缓冲区和Karplus-Strong算法
- en: This feedback scheme is designed to simulate a wave traveling through a vibrating
    string. The numbers in the ring buffer represent the energy of the wave at each
    point on the string. According to physics, the fundamental frequency of a vibrating
    string is inversely proportional to its length. Since we’re interested in generating
    sounds of a certain frequency, we choose a ring buffer length inversely proportional
    to the desired frequency (this is the *N* = *S*/*f* formula mentioned earlier).
    The averaging that happens in step 2 of the algorithm acts as a *low-pass filter*
    that cuts off higher frequencies and allows lower frequencies through, thereby
    eliminating higher harmonics (that is, larger multiples of the fundamental frequency)
    because you’re mainly interested in the fundamental frequency. The attenuation
    factor in step 3 simulates the loss of energy as the wave travels back and forth
    along the string. This corresponds to the fading of the sound over time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个反馈机制旨在模拟波动通过振动弦的传播。环形缓冲区中的数字表示波在弦上每个点的能量。根据物理学，振动弦的基频与其长度成反比。由于我们感兴趣的是生成特定频率的声音，我们选择一个与所需频率成反比的环形缓冲区长度（这就是前面提到的*N*
    = *S*/*f*公式）。算法第二步中的平均值计算充当了一个*低通滤波器*，它切断了较高的频率并允许较低的频率通过，从而消除较高的谐波（即基频的更高倍数），因为你主要关心的是基频。第三步中的衰减因子模拟了波在弦上来回传播时能量的损失。这对应于声音随时间的衰退。
- en: The samples buffer that you add to in step 1 of the simulation represents the
    amplitude of the generated sound over time. Storing the attenuated values at the
    end of the ring buffer (step 4) and removing the first item from the ring buffer
    (step 5) ensures that a steady stream of gradually attenuating values will be
    passed to the samples buffer to build up the simulated sound.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟的第一步中，你添加到的样本缓冲区代表了生成的声音随时间变化的幅度。将衰减后的值存储到环形缓冲区的末尾（第4步），并移除环形缓冲区的第一个元素（第5步），确保了逐渐衰减的值会持续传递到样本缓冲区，从而构建出模拟的声音。
- en: Let’s look at a simple example of the Karplus-Strong algorithm in action. [Table
    4-1](nsp-venkitachalam503045-0016.xhtml#tab4-1) represents a ring buffer at two
    consecutive time steps. Each value in the ring buffer represents the amplitude
    of the sound, which is the same as the displacement of a point on a plucked string
    from its rest position. The buffer has five elements, and they are initially filled
    with some numbers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个Karplus-Strong算法的简单例子。[表4-1](nsp-venkitachalam503045-0016.xhtml#tab4-1)表示两个连续时间步长下的环形缓冲区。环形缓冲区中的每个值代表声音的幅度，这与拨弦时弦上某一点从静止位置的位移相同。缓冲区有五个元素，初始时被填充了一些数字。
- en: 'Table 4-1: A Ring Buffer at Two Time Steps in the Karplus-Strong Algorithm'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-1：Karplus-Strong算法中两个时间步长的环形缓冲区
- en: '| Time step 1 | 0.1 | −0.2 | 0.3 | 0.6 | −0.5 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 时间步长 1 | 0.1 | −0.2 | 0.3 | 0.6 | −0.5 |'
- en: '| Time step 2 | −0.2 | 0.3 | 0.6 | −0.5 | −0.04975 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 时间步长 2 | −0.2 | 0.3 | 0.6 | −0.5 | −0.04975 |'
- en: As you go from time step 1 to time step 2, you apply the Karplus-Strong algorithm
    as follows. The first value in the first row, 0.1, is removed, and all subsequent
    values from time step 1 are added in the same order to the second row, which represents
    time step 2\. The last value in time step 2 is the attenuated average of the first
    and second values of time step 1, which is calculated as 0.995 × ((0.1 + −0.2)
    ÷ 2) = −0.04975.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从时间步长 1 走到时间步长 2 时，你应用 Karplus-Strong 算法如下：第一行中的第一个值 0.1 被移除，时间步长 1 中的所有后续值按顺序加入到第二行，第二行表示时间步长
    2。时间步长 2 中的最后一个值是时间步长 1 中第一个和第二个值的衰减平均值，计算方法是 0.995 × ((0.1 + −0.2) ÷ 2) = −0.04975。
- en: '[The WAV File Format](nsp-venkitachalam503045-0008.xhtml#rbh0602)'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[WAV 文件格式](nsp-venkitachalam503045-0008.xhtml#rbh0602)'
- en: The *Waveform Audio File Format (WAV)* is used to store audio data. This format
    is convenient for small audio projects because it’s simple and doesn’t require
    you to worry about complicated compression techniques.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*Waveform Audio File Format (WAV)* 用于存储音频数据。这个格式适用于小型音频项目，因为它简单且不需要担心复杂的压缩技术。'
- en: In its simplest form, a WAV file consists of a series of values, where each
    value represents the amplitude of the stored sound at a given point in time. Each
    value is allotted a fixed number of bits, called the *resolution*. You’ll use
    16-bit resolution in this project. WAV files also have a set *sampling rate*,
    which is the number of times the audio is *sampled*, or read, every second. In
    this project, you use a sampling rate of 44,100 Hz, the rate used in audio CDs.
    In sum, when you generate a WAV file simulating the sound of a plucked string,
    it will contain 44,100 16-bit values for every second of audio.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式中，WAV 文件由一系列值组成，每个值表示在给定时间点存储的声音的幅度。每个值分配了一定数量的比特，称为 *分辨率*。在这个项目中，你将使用
    16 位分辨率。WAV 文件还具有一个 *采样率*，即每秒钟音频被 *采样* 或读取的次数。在这个项目中，你将使用 44,100 Hz 的采样率，这也是音频
    CD 使用的采样率。总的来说，当你生成一个模拟拨弦声音的 WAV 文件时，它将包含每秒 44,100 个 16 位的值。
- en: 'For this project, you’ll be using Python’s `wave` module, which includes methods
    for working with WAV files. To get a feel for how it works, let’s generate a five-second
    audio clip of a 220 Hz sine wave using Python. First you represent a sine wave
    using this formula:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你将使用 Python 的 `wave` 模块，它包含了处理 WAV 文件的方法。为了熟悉如何操作，我们用 Python 生成一个持续五秒的
    220 Hz 正弦波音频片段。首先，你可以用以下公式表示一个正弦波：
- en: '*A* = sin(2π*ft*)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*A* = sin(2π*ft*)'
- en: 'Here, *A* is the amplitude of the wave, *f* is the frequency, and *t* is the
    current time index. Now you rewrite this equation as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*A* 是波的幅度，*f* 是频率，*t* 是当前的时间索引。现在你可以将这个方程式改写如下：
- en: '*A* = sin(2π*fi*/*R*)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*A* = sin(2π*fi*/*R*)'
- en: In this equation, *i* is the index of the sample, and *R* is the sampling rate.
    Using these two equations, you can create a five-second WAV file for a 200 Hz
    sine wave as follows. (This code is available in *sine.py* in the chapter’s GitHub
    repository.)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方程中，*i* 是采样的索引，*R* 是采样率。使用这两个方程，你可以创建一个持续五秒的 200 Hz 正弦波 WAV 文件，具体如下。（此代码可以在本章的
    GitHub 仓库中的 *sine.py* 文件中找到。）
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You create a `numpy` array of numbers from `0` to `nSamples − 1` and divide
    those numbers by the sample rate to get the time value, in seconds, when each
    sample of the audio clip is taken ❶. This array represents the *i*/*R* portion
    of the sine wave equation discussed earlier. Next, you use the array to create
    a second `numpy` array, this one containing sine wave amplitude values, again
    following the sine wave equation ❷. The `numpy` array is a fast and convenient
    way to apply functions such as the `sin()` function to many values at once.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建一个从 `0` 到 `nSamples − 1` 的 `numpy` 数字数组，并通过采样率将这些数字除以，以得到每个音频片段采样时的时间值，单位为秒
    ❶。这个数组代表了前面提到的正弦波方程中的 *i*/*R* 部分。接下来，你用这个数组创建第二个 `numpy` 数组，包含正弦波的幅度值，依旧遵循正弦波方程
    ❷。`numpy` 数组是一个快速且便捷的方式，可以将诸如 `sin()` 函数等操作应用到多个数值上。
- en: The computed sine wave values in the range [−1, 1] are scaled to 16-bit values
    and converted to a string so they can be written to a WAV file ❸. Then you set
    the parameters for the WAV file; in this case, it’s a single-channel (mono), 2-byte
    (16-bit), uncompressed format ❹. Finally, you write the data to the file ❺. [Figure
    4-4](nsp-venkitachalam503045-0016.xhtml#fig4-4) shows the generated *sine220.wav*
    file in Audacity, a free audio editor. As expected, you see a sine wave of frequency
    220 Hz, and when you play the file, you hear a 220 Hz tone for five seconds. (Note
    that you need to use the Zoom tool in Audacity to see the sine wave as shown in
    [Figure 4-4](nsp-venkitachalam503045-0016.xhtml#fig4-4).)
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 计算出的正弦波值在范围[−1, 1]内被缩放到16位值，并转换为字符串，以便写入 WAV 文件❸。然后，你设置 WAV 文件的参数；在这种情况下，它是单声道（mono）、2
    字节（16 位）、无压缩格式❹。最后，你将数据写入文件❺。[图 4-4](nsp-venkitachalam503045-0016.xhtml#fig4-4)显示了在
    Audacity（一款免费的音频编辑器）中生成的*sine220.wav* 文件。正如预期的那样，你会看到频率为220 Hz的正弦波，当你播放该文件时，会听到一个持续五秒钟的220
    Hz音调。（注意，你需要使用 Audacity 中的缩放工具才能看到[图 4-4](nsp-venkitachalam503045-0016.xhtml#fig4-4)中所示的正弦波。）
- en: '![](images/nsp-venkitachalam503045-f04004.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f04004.jpg)'
- en: 'Figure 4-4: A sine wave at 220 Hz, zoomed in'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-4：220 Hz 正弦波，放大显示
- en: In your project, once you’ve filled the samples buffer with audio data, you’ll
    write it to a WAV file using the same pattern illustrated in [Figure 4-4](nsp-venkitachalam503045-0016.xhtml#fig4-4).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中，一旦你用音频数据填充了样本缓冲区，你将使用与[图 4-4](nsp-venkitachalam503045-0016.xhtml#fig4-4)中所示的相同模式将其写入
    WAV 文件。
- en: '[The Minor Pentatonic Scale](nsp-venkitachalam503045-0008.xhtml#rbh0603)'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[小调五声音阶](nsp-venkitachalam503045-0008.xhtml#rbh0603)'
- en: A *musical scale* is a series of notes in increasing or decreasing pitch (frequency).
    Often, all notes in a piece of music are chosen from a particular scale. A *musical
    interval* is the difference between two pitches. A *semitone* is a basic building
    block of a scale and is the smallest musical interval in Western music. A *tone*
    is twice the length of a semitone. The *major scale*, one of the most common musical
    scales, is defined by the interval pattern *tone-tone-semitone-tone-tone-tone-semitone*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*音乐音阶*是一个音高（频率）升高或降低的音符序列。通常，一首音乐作品中的所有音符都是从某一特定音阶中选择的。*音乐音程*是两种音高之间的差距。*半音*是音阶的基本构成单位，是西方音乐中最小的音程。*全音*是半音的两倍长度。*大调音阶*是最常见的音乐音阶之一，其音程模式为*全音-全音-半音-全音-全音-全音-半音*。'
- en: We’ll briefly go into the pentatonic scale here, since you’ll be generating
    musical notes in that scale. This section will explain the source of the frequency
    numbers used in the final program to generate notes with the Karplus-Strong algorithm.
    The *pentatonic scale* is a five-note musical scale. A variant of this scale is
    the *minor pentatonic scale*, which is defined by the interval pattern *(tone+semitone)-tone-tone-(tone+semitone)-tone*.
    Thus, the C minor pentatonic scale consists of the notes C, E-flat, F, G, and
    B-flat. [Table 4-2](nsp-venkitachalam503045-0016.xhtml#tab4-2) lists the frequencies
    of the five notes of a C minor pentatonic scale that you’ll generate using the
    Karplus-Strong algorithm. (Here, C4 designates C in the fourth octave of a piano,
    or *middle C*, by convention.)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里简要介绍五声音阶，因为你将生成该音阶中的音符。本节将解释用于最终程序生成音符的频率数值来源，这些音符是通过 Karplus-Strong 算法生成的。*五声音阶*是一种五个音符的音乐音阶。这种音阶的变体是*小调五声音阶*，它的音程模式为*(全音+半音)-全音-全音-(全音+半音)-全音*。因此，C
    小调五声音阶包括音符 C、E-flat、F、G 和 B-flat。[表 4-2](nsp-venkitachalam503045-0016.xhtml#tab4-2)列出了你将使用
    Karplus-Strong 算法生成的 C 小调五声音阶中五个音符的频率。（这里，C4 指的是钢琴的第四个八度中的 C 音，或称为*中央 C*，这是约定俗成的表示方式。）
- en: 'Table 4-2: Notes in a Minor Pentatonic Scale'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-2：小调五声音阶中的音符
- en: '| Note | Frequency (Hz) |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 音符 | 频率（Hz） |'
- en: '| --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| C4 | 261.6 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| C4 | 261.6 |'
- en: '| E-flat | 311.1 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| E-flat | 311.1 |'
- en: '| F | 349.2 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| F | 349.2 |'
- en: '| G | 392.0 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| G | 392.0 |'
- en: '| B-flat | 466.2 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| B-flat | 466.2 |'
- en: One aspect of this project will be stringing together random sequences of notes
    to create melodies. One of the reasons we’re focusing on a minor pentatonic scale
    is that the notes of this scale sound pleasing no matter what order they’re played
    in. Thus, the scale is particularly conducive to generating random melodies in
    a way that other scales, such as a major scale, are not.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的一个方面是将随机音符序列串联起来，创作旋律。我们专注于小调五声音阶的原因之一是，无论这些音符以何种顺序播放，都听起来都很悦耳。因此，这种音阶特别适合生成随机旋律，而其他音阶（如大调音阶）则不具备这种特点。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah0602)'
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[要求](nsp-venkitachalam503045-0008.xhtml#rah0602)'
- en: In this project, you’ll use the Python `wave` module to create audio files in
    the WAV format. To implement the Karplus-Strong algorithm, you’ll use the `deque`
    class from the Python `collections` module as a ring buffer and a `numpy` array
    as a samples buffer. You’ll also use `matplotlib` to visualize the simulated guitar
    string, and you’ll play back the WAV files with the `pyaudio` module.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用 Python 的`wave`模块来创建 WAV 格式的音频文件。为了实现 Karplus-Strong 算法，你将使用 Python
    `collections`模块中的`deque`类作为环形缓冲区，并使用`numpy`数组作为样本缓冲区。你还将使用`matplotlib`来可视化模拟的吉他弦，并使用`pyaudio`模块播放
    WAV 文件。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah0603)'
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah0603)'
- en: Now let’s develop the various pieces of code required to implement the Karplus-Strong
    algorithm and then put them together for the complete program. To see the full
    project code, skip ahead to [“The Complete Code”](nsp-venkitachalam503045-0016.xhtml#ah0607)
    on [page 74](nsp-venkitachalam503045-0016.xhtml#p74). You can also download the
    code from the book’s GitHub repository at [https://github.com/mkvenkit/pp2e/tree/main/karplus](https://github.com/mkvenkit/pp2e/tree/main/karplus).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开发实现 Karplus-Strong 算法所需的各个代码片段，然后将它们组合成完整的程序。要查看完整的项目代码，请跳转到[《完整代码》](nsp-venkitachalam503045-0016.xhtml#ah0607)页面的[第74页](nsp-venkitachalam503045-0016.xhtml#p74)。你还可以从本书的
    GitHub 仓库下载代码，网址是[https://github.com/mkvenkit/pp2e/tree/main/karplus](https://github.com/mkvenkit/pp2e/tree/main/karplus)。
- en: '[Implementing the Ring Buffer with deque](nsp-venkitachalam503045-0008.xhtml#rbh0604)'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[使用 deque 实现环形缓冲区](nsp-venkitachalam503045-0008.xhtml#rbh0604)'
- en: Recall from earlier that the Karplus-Strong algorithm uses a ring buffer to
    generate a musical note. You’ll implement the ring buffer using a `deque` container
    (pronounced “deck”), which is part of Python’s `collections` module of specialized
    container data types. You can insert and remove elements from the beginning (head)
    or end (tail) of a `deque` (see [Figure 4-5](nsp-venkitachalam503045-0016.xhtml#fig4-5)).
    This insertion and removal process is a `O(1)`, or a “constant time” operation,
    which means it takes the same amount of time regardless of how big the `deque`
    container gets.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾之前，Karplus-Strong 算法使用环形缓冲区生成音符。你将使用`deque`容器（发音为“deck”）来实现环形缓冲区，它是 Python
    `collections`模块中专用容器数据类型的一部分。你可以从`deque`的开头（头部）或末尾（尾部）插入和移除元素（参见[图 4-5](nsp-venkitachalam503045-0016.xhtml#fig4-5)）。这个插入和移除过程是一个`O(1)`，即“常数时间”操作，这意味着无论`deque`容器多大，它所需的时间都是相同的。
- en: '![](images/nsp-venkitachalam503045-f04005.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f04005.jpg)'
- en: 'Figure 4-5: A ring buffer implemented using `deque`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-5：使用`deque`实现的环形缓冲区
- en: 'The following code shows an example of how you would use `deque` in Python:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何在 Python 中使用`deque`的一个示例：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You create the `deque` container by passing in a list created with the `range()`
    function ❶. You also specify the maximum length `maxlen` of the `deque` as `10`.
    Next, you append the element `10` to the end of the `deque` container ❷. When
    you then print the `deque`, you can see that `10` has been appended to the end
    of the `deque`, while the first element, `0`, has automatically been removed to
    maintain the `deque` container’s maximum length of 10 elements. This scheme will
    allow you to simultaneously implement steps 4 and 5 of the Karplus-Strong algorithm—adding
    a new value at the end of the ring buffer while removing the first value.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过传入使用`range()`函数创建的列表❶来创建`deque`容器。你还指定了`deque`的最大长度`maxlen`为`10`。接下来，你将元素`10`附加到`deque`容器的末尾❷。当你打印`deque`时，可以看到`10`已被附加到`deque`的末尾，而第一个元素`0`已被自动移除，以保持`deque`容器的最大长度为10个元素。这个方案将允许你同时实现
    Karplus-Strong 算法的第4步和第5步——在环形缓冲区的末尾添加新值，同时移除第一个值。
- en: '[Implementing the Karplus-Strong Algorithm](nsp-venkitachalam503045-0008.xhtml#rbh0605)'
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[实现 Karplus-Strong 算法](nsp-venkitachalam503045-0008.xhtml#rbh0605)'
- en: You’ll now implement the Karplus-Strong algorithm in the `generateNote()` function,
    using a `deque` container to implement the ring buffer and a `numpy` array to
    implement the samples buffer. In the same function, you’ll also visualize the
    algorithm using `matplotlib`. The plot will show how the amplitudes of the plucked
    string change over time, in effect showing how the string moves as it vibrates.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将在`generateNote()`函数中实现 Karplus-Strong 算法，使用`deque`容器实现环形缓冲区，并使用`numpy`数组实现样本缓冲区。在同一个函数中，你还将使用`matplotlib`可视化算法。图表将显示拨动弦的幅度如何随时间变化，从而展示弦在振动时的运动。
- en: 'You begin with some setup:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你从一些设置开始：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First you create a `matplotlib` figure ❶ and a line plot ❷, which you’ll fill
    with data. Then you begin the `generateNote()` function definition, which takes
    the frequency of the note to be generated as a parameter. You set the number of
    samples in the sound clip and the sample rate to both be 44,100, which means the
    resulting clip will be one second long. Then you divide the sample rate by the
    desired frequency to set the length `N` of the Karplus-Strong ring buffer ❸. If
    the `gShowPlot` flag is set ❹, you initialize the x and y range of the plot and
    initialize the x values to `[0, ... N-1]` using the `arange()` function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个 `matplotlib` 图形 ❶ 和一条线性图 ❷，然后将数据填充到图形中。接下来，你开始定义 `generateNote()` 函数，该函数以要生成的音符频率作为参数。你将音频片段的样本数和采样率都设置为
    44,100，这意味着生成的音频片段将是 1 秒钟长。然后，你将采样率除以所需的频率，以设置 Karplus-Strong 环形缓冲区的长度 `N` ❸。如果设置了
    `gShowPlot` 标志 ❹，你将初始化图表的 x 和 y 范围，并使用 `arange()` 函数将 x 值初始化为 `[0, ... N-1]`。
- en: You next initialize the ring buffer as a `deque` container with random numbers
    in the range [−0.5, 0.5], setting the maximum length of the `deque` to `N` ❺.
    You also initialize the samples buffer as a `numpy` array of floats ❻. You set
    the length of the array to be the number of samples the sound clip will contain.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将环形缓冲区初始化为一个包含范围在 [−0.5, 0.5] 之间的随机数的 `deque` 容器，并将 `deque` 的最大长度设置为 `N`
    ❺。你还将样本缓冲区初始化为一个 `numpy` 浮动数组 ❻。你将数组的长度设置为音频片段所包含的样本数。
- en: 'Next comes the heart of the `generateNote()` function, where you implement
    the steps of the Karplus-Strong algorithm and create the visualization:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `generateNote()` 函数的核心，在这里你实现了 Karplus-Strong 算法的步骤，并创建了可视化：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here you iterate over each element in the samples buffer and carry out the steps
    of the Karplus-Strong algorithm. With each iteration, you copy the first element
    in the ring buffer to the samples buffer ❶. Then you perform the low-pass filtering
    and attenuation by averaging the first two elements in the ring buffer and multiplying
    the result by 0.995 ❷. This attenuated value is appended to the end of the ring
    buffer ❸. Since the `deque` representing the ring buffer has a maximum length,
    the `append()` operation also removes the first element from the buffer.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你遍历样本缓冲区中的每个元素，并执行 Karplus-Strong 算法的步骤。在每次迭代中，你将环形缓冲区中的第一个元素复制到样本缓冲区 ❶。然后，你通过对环形缓冲区中的前两个元素求平均并将结果乘以
    0.995 来执行低通滤波和衰减 ❷。这个衰减后的值被附加到环形缓冲区的末尾 ❸。由于表示环形缓冲区的 `deque` 具有最大长度，`append()`
    操作还会移除缓冲区中的第一个元素。
- en: The `samples` array is converted into a 16-bit format by multiplying each value
    by 32,767 ❺ (a 16-bit signed integer can take values only from −32,768 to 32,767,
    and 0.5 × 65,534 = 32,767). Then the array is converted to a byte representation
    for the `wave` module, which you’ll use to save this data to a file ❻.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`samples` 数组通过将每个值乘以 32,767 转换为 16 位格式 ❺（16 位有符号整数只能取值从 −32,768 到 32,767，而
    0.5 × 65,534 = 32,767）。然后，数组被转换为 `wave` 模块的字节表示，你将使用该模块将数据保存到文件 ❻。'
- en: As the algorithm is running, you visualize how the ring buffer evolves ❹. For
    every thousand samples, you update the `matplotlib` graph with the values in the
    ring buffer, and this shows how the data changes with time.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当算法运行时，你可以可视化环形缓冲区的演变 ❹。每当有一千个样本时，你就使用环形缓冲区中的值更新 `matplotlib` 图表，显示数据如何随时间变化。
- en: '[Writing a WAV File](nsp-venkitachalam503045-0008.xhtml#rbh0606)'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[写入 WAV 文件](nsp-venkitachalam503045-0008.xhtml#rbh0606)'
- en: 'Once you have the audio data, you can write it to a WAV file using the Python
    `wave` module. Define a `writeWAVE()` function to carry this out:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你获得音频数据，你可以使用 Python 的 `wave` 模块将其写入 WAV 文件。定义一个 `writeWAVE()` 函数来执行此操作：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You create a WAV file ❶ and set its parameters using a single-channel, 16-bit,
    noncompressed format ❷. Then you write the data to the file ❸.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建一个 WAV 文件 ❶，并使用单声道、16 位、无压缩格式设置其参数 ❷。然后你将数据写入文件 ❸。
- en: '[Playing WAV Files with pyaudio](nsp-venkitachalam503045-0008.xhtml#rbh0607)'
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[使用 pyaudio 播放 WAV 文件](nsp-venkitachalam503045-0008.xhtml#rbh0607)'
- en: 'Now you’ll use the Python `pyaudio` module to play the WAV files generated
    by the algorithm. `pyaudio` is a high-performance, low-level library that gives
    you access to sound devices on a computer. For convenience, you encapsulate the
    code in a `NotePlayer` class, as shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将使用 Python 的 `pyaudio` 模块播放由算法生成的 WAV 文件。`pyaudio` 是一个高性能、低级别的库，可以让你访问计算机上的声音设备。为了方便，你将代码封装在一个
    `NotePlayer` 类中，如下所示：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the `NotePlayer` class’s constructor, you first create the `PyAudio` object
    that you’ll use to play the WAV file ❶. Then you open a 16-bit single-channel
    `PyAudio` output stream ❷. You also create an empty list that you’ll later fill
    with filenames of the five pentatonic note WAV files ❸.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `NotePlayer` 类的构造函数中，你首先创建用于播放 WAV 文件的 `PyAudio` 对象 ❶。然后，你打开一个 16 位单声道的 `PyAudio`
    输出流 ❷。你还会创建一个空的列表，稍后将用生成的五个五声音阶音符的 WAV 文件名填充 ❸。
- en: 'In Python, when all references to an object have been deleted, the object is
    destroyed by a process called *garbage collection*. At that time, the object’s
    `__del__()` method, also known as a *destructor*, is called, if one is defined.
    Here’s the `NotePlayer` class’s destructor:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，当对象的所有引用都被删除时，该对象会被称为*垃圾回收*的过程销毁。此时，如果已定义 `__del__()` 方法，也就是*析构函数*，该方法会被调用。以下是
    `NotePlayer` 类的析构函数：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This method ensures that the `PyAudio` stream is cleaned up when the `NotePlayer`
    object is destroyed. Failing to provide a `__del__()` method for a class can cause
    problems when objects are repeatedly created and destroyed, since some system-wide
    resources (like `pyaudio` in this case) may not be cleaned up properly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法确保当 `NotePlayer` 对象被销毁时，`PyAudio` 流被清理。如果一个类没有提供 `__del__()` 方法，可能会在对象反复创建和销毁时引发问题，因为某些系统级资源（例如
    `pyaudio`）可能无法正确清理。
- en: 'The remaining methods of the `NotePlayer` class are devoted to building up
    a list of possible notes and playing them. First, here’s the `add()` method, which
    is used to add a WAV filename to the class:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotePlayer` 类的其余方法致力于构建可能音符的列表并播放它们。首先是 `add()` 方法，它用于将一个 WAV 文件名添加到类中：'
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The method takes a filename corresponding to one of the generated WAV files
    as a parameter and adds it to the `notes` list you initialized in the class’s
    constructor. The class will draw on this list when it wants to play a WAV file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将一个与生成的 WAV 文件之一对应的文件名作为参数，并将其添加到你在类的构造函数中初始化的 `notes` 列表中。类会在需要播放 WAV 文件时使用这个列表。
- en: 'Next, let’s look at the `play()` method used to play a note:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看一下用于播放音符的 `play()` 方法：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here you open the desired WAV file using Python’s `wave` module ❶. Then you
    read `CHUNK` frames (defined globally as 1,024 in this case) from the file into
    `data` ❷. Next, within a `while` loop, you write the contents of `data` to the
    `PyAudio` output stream ❸ and read the next chunk of data from the WAV file ❹.
    Writing to the output stream has the effect of playing the audio through the default
    audio device of your computer, which is typically a speaker. You read the data
    in chunks to maintain the sample rate at the output side. If the chunks are too
    large and you take too much time in between reading and writing, the audio won’t
    sound right.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你使用 Python 的 `wave` 模块打开所需的 WAV 文件 ❶。然后，你从文件中读取 `CHUNK` 帧（此处全局定义为 1,024）到
    `data` 中 ❷。接下来，在 `while` 循环内，你将 `data` 的内容写入 `PyAudio` 输出流 ❸，并从 WAV 文件中读取下一个数据块
    ❹。写入输出流的效果是通过计算机的默认音频设备（通常是扬声器）播放音频。你按块读取数据是为了保持输出端的采样率。如果数据块过大，并且在读取和写入之间耗费的时间过长，音频就会出现问题。
- en: The `while` loop continues for as long as there’s more data to read—that is,
    until `data` is empty. At that point, you close the WAV file object ❺. You handle
    any exceptions that may happen during the playback process (for example, the user
    pressing CTRL-C) by printing the error ❻ and exiting the program.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`while` 循环会持续进行，直到没有更多数据可读——即，直到 `data` 为空。此时，你关闭 WAV 文件对象 ❺。你通过打印错误 ❻ 并退出程序来处理在播放过程中可能发生的任何异常（例如，用户按下
    CTRL-C）。'
- en: 'Finally, the `NotePlayer` class’s `playRandom()` method picks a random note
    from the five notes you’ve generated and plays it:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`NotePlayer` 类的 `playRandom()` 方法会从你生成的五个音符中随机选择一个并进行播放：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The method selects a random WAV filename from the `notes` list and passes that
    filename to the `play()` method to be played.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法从 `notes` 列表中选择一个随机的 WAV 文件名，并将该文件名传递给 `play()` 方法进行播放。
- en: '[Creating Notes and Parsing Arguments](nsp-venkitachalam503045-0008.xhtml#rbh0608)'
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[创建音符并解析参数](nsp-venkitachalam503045-0008.xhtml#rbh0608)'
- en: 'Now let’s look at the program’s `main()` function, which creates the notes
    and handles various command line options to play the notes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下程序的 `main()` 函数，它负责创建音符并处理各种命令行选项来播放音符：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: First you set up some command line options for the program using `argparse`,
    as discussed in earlier projects. The `--display` option will play each of the
    five notes in turn, while visualizing each note’s waveform using `matplotlib`.
    The `--play` option generates a random melody using the five notes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`argparse`为程序设置一些命令行选项，正如之前项目中讨论的那样。`--display`选项会依次播放五个音符，同时使用`matplotlib`可视化每个音符的波形。`--play`选项则使用这五个音符生成一个随机旋律。
- en: If the `--display` command line option was used ❶, you set up a `matplotlib`
    plot to show how the waveform evolves during the Karplus-Strong algorithm. The
    `plt.show(block=False)` call ensures that the `matplotlib` display method doesn’t
    block. This way, when you call this function, it will return immediately and go
    on to the next statement. This is the behavior you need, since you’re manually
    updating the plot every frame.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用了`--display`命令行选项 ❶，你会设置一个`matplotlib`图表，显示在Karplus-Strong算法过程中波形的演变。`plt.show(block=False)`调用确保`matplotlib`显示方法不会阻塞。这样，当你调用这个函数时，它会立即返回，并继续执行下一个语句。这是你需要的行为，因为你需要每一帧手动更新图表。
- en: 'You next create an instance of the `NotePlayer` class ❷. Then you generate
    WAV files of the five notes in the C minor pentatonic scale. The frequencies for
    the notes are defined in the global dictionary `pmNotes`, which looks like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你创建`NotePlayer`类的一个实例 ❷。然后你生成C小调五声音阶的五个音符的WAV文件。这些音符的频率在全局字典`pmNotes`中定义，内容如下所示：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To generate the notes, you iterate through the dictionary, first constructing
    a filename for the note using the dictionary key plus the *.wav* extension—for
    example, *C4.wav*. You use the `os.path.``exists()` method to see whether the
    WAV file for a particular note has been created ❸. If so, you skip the computation
    for that note. (This is a handy optimization if you’re running this program several
    times.) Otherwise, you generate the note using the `generateNote()` and `writeWAVE()`
    functions you defined earlier. Once the note is computed and the WAV file created,
    you add the note’s filename to the `NotePlayer` object’s list of notes ❹, and
    then you play the note if the `--display` command line option is used ❺.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成音符，你需要遍历字典，首先使用字典的键加上*.wav*扩展名构建音符的文件名——例如，*C4.wav*。你可以使用`os.path.exists()`方法检查特定音符的WAV文件是否已创建
    ❸。如果已经创建，则跳过该音符的计算。（如果你多次运行该程序，这是一个非常实用的优化。）否则，你会使用之前定义的`generateNote()`和`writeWAVE()`函数来生成音符。一旦音符计算完成并且WAV文件创建成功，你将音符的文件名添加到`NotePlayer`对象的音符列表中
    ❹，然后如果使用了`--display`命令行选项，你会播放这个音符 ❺。
- en: If the `--play` option is used, the `playRandom()` method in `NotePlayer` repeatedly
    plays a note at random from the five notes ❻. For a note sequence to sound even
    remotely musical, you need to add rests between the notes played, so you use the
    `random.``choice()` method from `numpy` to choose a random rest interval ❼. This
    method also lets you choose the probability of the rest interval, which you set
    so that a two-beat rest is the most probable and an eight-beat rest the least
    probable. Try changing these values to create your own style of random music!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用了`--play`选项，`NotePlayer`中的`playRandom()`方法会反复随机播放五个音符中的一个音符 ❻。为了使音符序列听起来有些音乐感，你需要在播放的音符之间添加休止符，因此你使用`numpy`中的`random.choice()`方法来选择一个随机的休止符间隔
    ❼。该方法还允许你选择休止符间隔的概率，你可以将其设置为最有可能出现的是两拍的休止符，而八拍的休止符最不可能出现。试着改变这些值，创造你自己的随机音乐风格吧！
- en: '[Running the Plucked String Simulation](nsp-venkitachalam503045-0008.xhtml#rah0604)'
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行拨弦模拟](nsp-venkitachalam503045-0008.xhtml#rah0604)'
- en: 'To run the code for this project, enter this in a command shell:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行该项目的代码，在命令行中输入以下内容：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see in [Figure 4-6](nsp-venkitachalam503045-0016.xhtml#fig4-6), the
    `matplotlib` plot shows how the Karplus-Strong algorithm converts the initial
    random displacements to create waves of the desired frequency.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图4-6](nsp-venkitachalam503045-0016.xhtml#fig4-6)中看到的，`matplotlib`的图表显示了Karplus-Strong算法如何将初始的随机位移转换为所需频率的波形。
- en: '![](images/nsp-venkitachalam503045-f04006.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f04006.jpg)'
- en: 'Figure 4-6: A sample run of the plucked string simulation'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-6：拨弦模拟的示例运行
- en: 'Now try playing a random sequence of notes using this command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用以下命令播放一个随机音符序列：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This should play a random note sequence using the generated WAV files of the
    pentatonic musical scale.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将播放一个使用生成的五声音阶WAV文件的随机音符序列。
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah0605)'
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[摘要](nsp-venkitachalam503045-0008.xhtml#rah0605)'
- en: In this project, you used the Karplus-Strong algorithm to simulate the sound
    of plucked strings and played notes from generated WAV files. You learned how
    to implement the Karplus-Strong algorithm using a `deque` container as a ring
    buffer. You also learned about the WAV file format and how to play WAV files using
    `pyaudio`, as well as how to use `matplotlib` to visualize a vibrating string.
    You even learned about the pentatonic musical scale!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你使用了Karplus-Strong算法来模拟弹奏弦乐的声音，并从生成的WAV文件中播放音符。你学习了如何使用`deque`容器作为环形缓冲区来实现Karplus-Strong算法。你还了解了WAV文件格式以及如何使用`pyaudio`播放WAV文件，并学会了如何使用`matplotlib`可视化振动的弦。你甚至学习了五声音阶！
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah0606)'
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实验！](nsp-venkitachalam503045-0008.xhtml#rah0606)'
- en: 'Here are some ideas for experiments:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些实验的想法：
- en: 1\. I’ve stated that the Karplus-Strong algorithm creates realistic plucked
    string sounds by generating overtones as well as the fundamental frequency of
    the note. But how do you know it’s working? By creating spectral plots of your
    WAV files, like the one in [Figure 4-2](nsp-venkitachalam503045-0016.xhtml#fig4-2).
    You can use the free program Audacity to do this. Open one of the WAV files in
    Audacity, and select **Analyze‣Plot** **Spectrum**. You should see that the sound
    contains many frequencies.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 我已经说过，Karplus-Strong算法通过生成泛音和音符的基频来创建逼真的弹奏弦乐声音。那么你如何知道它是否有效呢？通过创建你的WAV文件的谱图，就像[图4-2](nsp-venkitachalam503045-0016.xhtml#fig4-2)中显示的那样。你可以使用免费的程序Audacity来做到这一点。打开其中一个WAV文件，选择**分析‣绘制**
    **频谱**。你应该会看到声音包含了许多频率。
- en: 2\. Use the techniques you learned in this chapter to create a method that replicates
    the sound of two strings of different frequencies vibrating together. Remember,
    the Karplus-Strong algorithm produces a ring buffer full of sound amplitude values.
    You can combine two sounds by adding their amplitudes together.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 使用你在本章中学到的技巧，创建一种方法来复制两个不同频率的弦振动的声音。记住，Karplus-Strong算法生成一个充满声音幅度值的环形缓冲区。你可以通过将两个声音的幅度相加来合成这两个声音。
- en: 3\. Replicate the sound of two strings vibrating together, as described in the
    previous experiment, but add a time delay between the first and second string
    plucks.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 复制前一个实验中描述的两个弦振动的声音，但在第一次和第二次弦弹之间添加一个时间延迟。
- en: '4\. Write a method to read music from a text file and generate musical notes.
    Then play the music using these notes. You can use a format where the note names
    are followed by integer rest time intervals, like this: C4 1 F4 2 G4 1 . . .'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 写一个方法从文本文件中读取音乐并生成音符。然后使用这些音符播放音乐。你可以使用一种格式，其中音符名称后跟整数的休止时间间隔，例如：C4 1 F4
    2 G4 1 . . .
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah0607)'
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整代码](nsp-venkitachalam503045-0008.xhtml#rah0607)'
- en: 'Here’s the complete code for this project:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这个项目的完整代码：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
