- en: '[4](nsp-venkitachalam503045-0008.xhtml#rch04)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[4](nsp-venkitachalam503045-0008.xhtml#rch04)'
- en: Musical Overtones with Karplus-Strong
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Karplus-Strong生成的音乐泛音
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: One of the main characteristics of any musical sound is its pitch, or *frequency*.
    This is the sound’s number of vibrations per second in hertz (Hz). For example,
    the fourth string of an acoustic guitar produces a D note with a frequency of
    146.83 Hz. You can approximate this sound by creating a sine wave with a frequency
    of 146.83 Hz on a computer, as shown in [Figure 4-1](nsp-venkitachalam503045-0016.xhtml#fig4-1).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 任何音乐声音的主要特征之一是其音高，或*频率*。这表示声音每秒的振动次数，以赫兹（Hz）为单位。例如，原声吉他的第四根弦会产生一个频率为146.83 Hz的D音符。你可以通过在电脑上创建一个频率为146.83
    Hz的正弦波来近似这种声音，如[图4-1](nsp-venkitachalam503045-0016.xhtml#fig4-1)所示。
- en: Unfortunately, if you play this sine wave on your computer, it won’t sound anything
    like a guitar. Nor will it sound like a piano, or any other real-world musical
    instrument for that matter. What makes a computer sound so different from a musical
    instrument when playing the same note?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，如果你在电脑上播放这段正弦波，它听起来与吉他完全不相似。它也不会像钢琴或任何其他真实世界的乐器那样发声。那么，为什么电脑在播放相同音符时，与乐器的声音如此不同呢？
- en: '![](images/nsp-venkitachalam503045-f04001.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f04001.jpg)'
- en: 'Figure 4-1: A sine wave at 146.83 Hz'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-1：146.83 Hz的正弦波
- en: When you pluck a string on a guitar, the instrument produces a mix of frequencies
    with varying intensity. The sound is most intense when the note is first struck,
    and the intensity dies off over time. In the case of plucking a guitar’s D string,
    the dominant frequency you hear, called the *fundamental frequency*, is 146.83 Hz,
    but the sound also contains certain multiples of that frequency called *overtones*.
    In fact, the sound of any note on any instrument is composed of a fundamental
    frequency and overtones, and it’s the combination of these different frequencies
    at different intensities that makes a guitar sound like a guitar, a piano sound
    like a piano, and so on. By contrast, a pure sine wave generated by a computer
    contains only a fundamental frequency, and no overtones.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拨动吉他弦时，乐器会产生不同强度的频率混合。音符刚被拨动时，声音最为强烈，随时间推移音量逐渐减弱。在拨动吉他D弦时，你听到的主频率，被称为*基本频率*，是146.83
    Hz，但声音中也包含了该频率的某些倍频，称为*泛音*。事实上，任何乐器上演奏的任何音符都由基本频率和泛音组成，正是这些不同频率以不同强度的组合，才使得吉他听起来像吉他，钢琴听起来像钢琴，等等。相比之下，电脑生成的纯正弦波仅包含基本频率，不包含泛音。
- en: You can see the evidence of overtones in *spectral plots*, like the one in [Figure
    4-2](nsp-venkitachalam503045-0016.xhtml#fig4-2) representing the D string of a
    guitar. A spectral plot shows all the frequencies present in a sound at a particular
    moment in time, as well as the intensity of those frequencies. Notice that there
    are many different peaks in the spectral plot shown in the figure, telling us
    that there are many frequencies present in the sound of the guitar’s D string
    being plucked. Near the far left of the plot, the highest peak represents the
    fundamental frequency. The other peaks, representing the overtones, are less intense,
    but they still contribute to the quality of the sound.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*频谱图*中看到泛音的证据，就像[图4-2](nsp-venkitachalam503045-0016.xhtml#fig4-2)中显示的吉他D弦的频谱图。频谱图展示了在特定时间点上声音中存在的所有频率，以及这些频率的强度。注意到频谱图中有许多不同的峰值，这告诉我们吉他D弦被弹奏时，声音中有许多不同的频率存在。在频谱图的最左端，最高的峰值代表基本频率。其他的峰值代表泛音，它们的强度较弱，但仍然对声音的质量有所贡献。
- en: '![](images/nsp-venkitachalam503045-f04002.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f04002.jpg)'
- en: 'Figure 4-2: A spectral plot of the note D3 played on a guitar'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-2：吉他上演奏的D3音符的频谱图
- en: 'As you can see, to simulate the sound of a plucked string instrument on the
    computer, you need to be able to generate both the fundamental frequency and the
    overtones. The trick is to use the Karplus-Strong algorithm. In this project,
    you’ll generate five guitar-like notes of a musical scale (a series of related
    notes) using the Karplus-Strong algorithm. You’ll visualize the algorithm used
    to generate these notes and save the sounds as WAV files. You’ll also create a
    way to play them at random and learn how to do the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，要在计算机上模拟弹拨弦乐器的声音，你需要能够生成基频和泛音。诀窍是使用 Karplus-Strong 算法。在这个项目中，你将使用 Karplus-Strong
    算法生成五个类似吉他的音符（一个音阶中的一系列相关音符）。你将可视化生成这些音符所用的算法，并将声音保存为 WAV 文件。你还将创建一种随机播放它们的方法，并学习如何完成以下任务：
- en: • Implement a ring buffer using the Python `deque` class.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 Python 的 `deque` 类实现环形缓冲区。
- en: • Use `numpy` arrays.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 `numpy` 数组。
- en: • Play WAV files using `pyaudio`.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 `pyaudio` 播放 WAV 文件。
- en: • Plot a graph using `matplotlib`.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 `matplotlib` 绘制图表。
- en: • Play the pentatonic musical scale.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 演奏五声音阶。
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah0601)'
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[工作原理](nsp-venkitachalam503045-0008.xhtml#rah0601)'
- en: Imagine a string tied down at both ends, like a string on a guitar. When you
    pluck this string, it vibrates for a while, making a sound, and then settles back
    down to its resting position. At any given point in time while the string is vibrating,
    different parts of the string will be at different displacements from their resting
    position. These displacements can also be thought of as amplitudes of the sound
    wave produced by the vibrating string. The Karplus-Strong algorithm is a series
    of steps for generating and updating a series of these displacement or amplitude
    values to represent the motion of a wave along a plucked string. Play back those
    values as a WAV file and you get a pretty convincing simulation of a plucked string
    sound.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一根绳子两端被固定，就像吉他上的弦。当你拨动这根弦时，它会振动一段时间，发出声音，然后逐渐回到它的静止位置。在弦振动的任意时刻，弦的不同部分会有不同的位移量，这些位移可以视为由振动弦产生的声波的幅度。Karplus-Strong
    算法是一系列生成和更新这些位移或幅度值的步骤，用以表示弹拨弦上的波动运动。将这些值作为 WAV 文件播放，你就能得到一个相当逼真的弹拨弦声音模拟。
- en: The Karplus-Strong algorithm stores displacement values in a *ring buffer* (also
    known as a *circular buffer*), a fixed-length buffer (just an array of values)
    that wraps around itself. In other words, when you reach the end of the buffer,
    the next element you access will be the first element in the buffer. (See [“Implementing
    the Ring Buffer with deque”](nsp-venkitachalam503045-0016.xhtml#bh0604) on [page
    66](nsp-venkitachalam503045-0016.xhtml#p66) for more about ring buffers.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Karplus-Strong 算法将位移值存储在*环形缓冲区*（也称为*循环缓冲区*）中，这是一个固定长度的缓冲区（仅仅是一个值的数组），它会自行循环。换句话说，当你到达缓冲区的末尾时，接下来访问的元素将是缓冲区中的第一个元素。（有关环形缓冲区的更多信息，请参见[“用
    deque 实现环形缓冲区”](nsp-venkitachalam503045-0016.xhtml#bh0604)，位于[第66页](nsp-venkitachalam503045-0016.xhtml#p66)。）
- en: The length (*N*) of the ring buffer is related to the fundamental frequency
    of the note you want to simulate according to the equation *N* = *S*/*f*, where
    *S* is the sampling rate (more on this later) and *f* is the frequency. At the
    start of the simulation, the buffer is filled with random values in the range
    [−0.5, 0.5], which you might think of as representing the random displacement
    of a string when it’s first plucked. As the simulation progresses, the values
    are updated according to the steps of the Karplus-Strong algorithm, which we’ll
    outline next.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 环形缓冲区的长度 (*N*) 与你想要模拟的音符的基频有关，公式为 *N* = *S*/*f*，其中 *S* 是采样率（稍后会详细讲解），*f* 是频率。在模拟开始时，缓冲区会填充范围为
    [−0.5, 0.5] 的随机值，你可以认为这些值表示弦被拨动时的随机位移。随着模拟的进行，这些值会根据 Karplus-Strong 算法的步骤进行更新，接下来我们将概述这些步骤。
- en: In addition to the ring buffer, you’ll use a *samples buffer* to store the intensity
    of the sound at any particular time. This buffer represents the final sound data,
    and it’s built up based on the values in the ring buffer. The length of the samples
    buffer and the sampling rate determine the length of the sound clip.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了环形缓冲区外，你还将使用一个*样本缓冲区*来存储特定时间点的声音强度。这个缓冲区代表最终的声音数据，它是根据环形缓冲区中的值构建的。样本缓冲区的长度和采样率决定了声音片段的长度。
- en: '[The Simulation](nsp-venkitachalam503045-0008.xhtml#rbh0601)'
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[模拟过程](nsp-venkitachalam503045-0008.xhtml#rbh0601)'
- en: 'During each time step in the simulation, a value from the ring buffer is stored
    in the samples buffer, and then the values in the ring buffer are updated in a
    kind of feedback scheme, as shown in [Figure 4-3](nsp-venkitachalam503045-0016.xhtml#fig4-3).
    Once the samples buffer is full, you write its contents to a WAV file so the simulated
    note can be played back as audio. For each time step of the simulation, you follow
    these steps, which together make up the Karplus-Strong algorithm:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟的每个时间步长中，从环形缓冲区存储一个值到样本缓冲区中，然后环形缓冲区中的值在一种反馈方案中被更新，如[图4-3](nsp-venkitachalam503045-0016.xhtml#fig4-3)所示。一旦样本缓冲区满了，你就将其内容写入WAV文件，以便可以作为音频播放模拟的音符。在模拟的每个时间步长中，你按照以下步骤进行操作，这些步骤一起构成了Karplus-Strong算法：
- en: 1\. Store the first value from the ring buffer in the samples buffer.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 将环形缓冲区中的第一个值存储到样本缓冲区中。
- en: 2\. Calculate the average of the first two elements in the ring buffer.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 计算环形缓冲区中前两个元素的平均值。
- en: 3\. Multiply this average value by an attenuation factor (in this case, 0.995).
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 将这个平均值乘以衰减因子（在此案例中为0.995）。
- en: 4\. Append this value to the end of the ring buffer.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 将这个值附加到环形缓冲区的末尾。
- en: 5\. Remove the first element of the ring buffer.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5\. 移除环形缓冲区中的第一个元素。
- en: '![](images/nsp-venkitachalam503045-f04003.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f04003.jpg)'
- en: 'Figure 4-3: A ring buffer and the Karplus-Strong algorithm'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-3：环形缓冲区和Karplus-Strong算法
- en: This feedback scheme is designed to simulate a wave traveling through a vibrating
    string. The numbers in the ring buffer represent the energy of the wave at each
    point on the string. According to physics, the fundamental frequency of a vibrating
    string is inversely proportional to its length. Since we’re interested in generating
    sounds of a certain frequency, we choose a ring buffer length inversely proportional
    to the desired frequency (this is the *N* = *S*/*f* formula mentioned earlier).
    The averaging that happens in step 2 of the algorithm acts as a *low-pass filter*
    that cuts off higher frequencies and allows lower frequencies through, thereby
    eliminating higher harmonics (that is, larger multiples of the fundamental frequency)
    because you’re mainly interested in the fundamental frequency. The attenuation
    factor in step 3 simulates the loss of energy as the wave travels back and forth
    along the string. This corresponds to the fading of the sound over time.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个反馈方案旨在模拟波动穿过振动弦的过程。环形缓冲区中的数字表示弦上每个点的波能量。根据物理学，振动弦的基频与其长度成反比。因为我们有兴趣生成某个频率的声音，我们选择一个与所需频率成反比的环形缓冲区长度（这就是之前提到的*N*
    = *S*/*f*公式）。算法第2步中发生的平均化起到了*低通滤波器*的作用，截断了较高的频率并允许较低频率通过，从而消除了较高的谐波（即基频的较大倍数），因为我们主要关注基频。第3步中的衰减因子模拟了波动在弦上来回传播时的能量损失。这对应于声音随时间逐渐衰退。
- en: The samples buffer that you add to in step 1 of the simulation represents the
    amplitude of the generated sound over time. Storing the attenuated values at the
    end of the ring buffer (step 4) and removing the first item from the ring buffer
    (step 5) ensures that a steady stream of gradually attenuating values will be
    passed to the samples buffer to build up the simulated sound.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你在模拟的第1步中添加到的样本缓冲区代表了随时间变化的生成声音的振幅。在环形缓冲区的末尾存储衰减值（第4步）并从环形缓冲区中移除第一个项（第5步）确保了会有一个持续的、逐渐衰减的值流传递到样本缓冲区，从而构建模拟的声音。
- en: Let’s look at a simple example of the Karplus-Strong algorithm in action. [Table
    4-1](nsp-venkitachalam503045-0016.xhtml#tab4-1) represents a ring buffer at two
    consecutive time steps. Each value in the ring buffer represents the amplitude
    of the sound, which is the same as the displacement of a point on a plucked string
    from its rest position. The buffer has five elements, and they are initially filled
    with some numbers.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个Karplus-Strong算法实际应用的简单示例。[表4-1](nsp-venkitachalam503045-0016.xhtml#tab4-1)展示了环形缓冲区在两个连续时间步长的情况。环形缓冲区中的每个值代表声音的振幅，等同于弹拨弦上某一点相对于静止位置的位移。缓冲区有五个元素，它们最初被填充了一些数字。
- en: 'Table 4-1: A Ring Buffer at Two Time Steps in the Karplus-Strong Algorithm'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-1：Karplus-Strong算法中两个时间步长的环形缓冲区
- en: '| Time step 1 | 0.1 | −0.2 | 0.3 | 0.6 | −0.5 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 时间步长 1 | 0.1 | −0.2 | 0.3 | 0.6 | −0.5 |'
- en: '| Time step 2 | −0.2 | 0.3 | 0.6 | −0.5 | −0.04975 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 时间步长 2 | −0.2 | 0.3 | 0.6 | −0.5 | −0.04975 |'
- en: As you go from time step 1 to time step 2, you apply the Karplus-Strong algorithm
    as follows. The first value in the first row, 0.1, is removed, and all subsequent
    values from time step 1 are added in the same order to the second row, which represents
    time step 2\. The last value in time step 2 is the attenuated average of the first
    and second values of time step 1, which is calculated as 0.995 × ((0.1 + −0.2)
    ÷ 2) = −0.04975.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从时间步 1 到时间步 2 时，你应用 Karplus-Strong 算法，如下所示。第一行的第一个值 0.1 被移除，接下来时间步 1 中的所有值按相同顺序添加到第二行，表示时间步
    2。时间步 2 中的最后一个值是时间步 1 的前两个值的衰减平均值，计算方法是 0.995 × ((0.1 + −0.2) ÷ 2) = −0.04975。
- en: '[The WAV File Format](nsp-venkitachalam503045-0008.xhtml#rbh0602)'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[WAV 文件格式](nsp-venkitachalam503045-0008.xhtml#rbh0602)'
- en: The *Waveform Audio File Format (WAV)* is used to store audio data. This format
    is convenient for small audio projects because it’s simple and doesn’t require
    you to worry about complicated compression techniques.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*波形音频文件格式（WAV）* 用于存储音频数据。这个格式对于小型音频项目非常方便，因为它简单且不需要担心复杂的压缩技术。'
- en: In its simplest form, a WAV file consists of a series of values, where each
    value represents the amplitude of the stored sound at a given point in time. Each
    value is allotted a fixed number of bits, called the *resolution*. You’ll use
    16-bit resolution in this project. WAV files also have a set *sampling rate*,
    which is the number of times the audio is *sampled*, or read, every second. In
    this project, you use a sampling rate of 44,100 Hz, the rate used in audio CDs.
    In sum, when you generate a WAV file simulating the sound of a plucked string,
    it will contain 44,100 16-bit values for every second of audio.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的 WAV 文件格式由一系列值组成，其中每个值表示在某个时间点存储的声音的幅度。每个值都有一个固定的位数，称为 *分辨率*。在这个项目中，你将使用
    16 位分辨率。WAV 文件还具有一个固定的 *采样率*，即每秒读取声音的次数。在本项目中，你使用的采样率为 44,100 Hz，这是音频 CD 使用的采样率。总之，当你生成一个模拟拨弦声的
    WAV 文件时，它将包含每秒 44,100 个 16 位的值。
- en: 'For this project, you’ll be using Python’s `wave` module, which includes methods
    for working with WAV files. To get a feel for how it works, let’s generate a five-second
    audio clip of a 220 Hz sine wave using Python. First you represent a sine wave
    using this formula:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你将使用 Python 的 `wave` 模块，该模块包括用于处理 WAV 文件的方法。为了了解它是如何工作的，让我们用 Python 生成一个五秒钟的
    220 Hz 正弦波音频片段。首先，你可以使用以下公式表示正弦波：
- en: '*A* = sin(2π*ft*)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*A* = sin(2π*ft*)'
- en: 'Here, *A* is the amplitude of the wave, *f* is the frequency, and *t* is the
    current time index. Now you rewrite this equation as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*A* 是波的幅度，*f* 是频率，*t* 是当前的时间索引。现在，你将这个方程改写如下：
- en: '*A* = sin(2π*fi*/*R*)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*A* = sin(2π*fi*/*R*)'
- en: In this equation, *i* is the index of the sample, and *R* is the sampling rate.
    Using these two equations, you can create a five-second WAV file for a 200 Hz
    sine wave as follows. (This code is available in *sine.py* in the chapter’s GitHub
    repository.)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方程中，*i* 是样本的索引，*R* 是采样率。使用这两个方程，你可以生成一个五秒钟的 200 Hz 正弦波 WAV 文件，如下所示。（该代码可以在本章的
    GitHub 仓库中的 *sine.py* 文件中找到。）
- en: import numpy as np
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: import wave, math
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: import wave, math
- en: sRate = 44100
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: sRate = 44100
- en: nSamples = sRate * 5
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: nSamples = sRate * 5
- en: ❶ x = np.arange(nSamples)/float(sRate)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ x = np.arange(nSamples)/float(sRate)
- en: ❷ vals = np.sin(2.0*math.pi*220.0*x)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ vals = np.sin(2.0*math.pi*220.0*x)
- en: ❸ data = np.array(vals*32767, 'int16').tostring()
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ data = np.array(vals*32767, 'int16').tostring()
- en: file = wave.open('sine220.wav', 'wb')
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: file = wave.open('sine220.wav', 'wb')
- en: ❹ file.setparams((1, 2, sRate, nSamples, 'NONE', 'uncompressed'))
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ file.setparams((1, 2, sRate, nSamples, 'NONE', 'uncompressed'))
- en: ❺ file.writeframes(data)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ file.writeframes(data)
- en: file.close()
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: file.close()
- en: You create a `numpy` array of numbers from `0` to `nSamples − 1` and divide
    those numbers by the sample rate to get the time value, in seconds, when each
    sample of the audio clip is taken ❶. This array represents the *i*/*R* portion
    of the sine wave equation discussed earlier. Next, you use the array to create
    a second `numpy` array, this one containing sine wave amplitude values, again
    following the sine wave equation ❷. The `numpy` array is a fast and convenient
    way to apply functions such as the `sin()` function to many values at once.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建一个 `numpy` 数组，包含从 `0` 到 `nSamples − 1` 的数字，并将这些数字除以采样率，从而得到每个音频片段样本的时间值（单位为秒）
    ❶。这个数组表示先前讨论的正弦波方程中的 *i*/*R* 部分。接下来，你使用这个数组创建第二个 `numpy` 数组，其中包含正弦波幅度值，同样遵循正弦波方程
    ❷。`numpy` 数组是一种快速且方便的方法，可以一次性对多个值应用诸如 `sin()` 函数等操作。
- en: The computed sine wave values in the range [−1, 1] are scaled to 16-bit values
    and converted to a string so they can be written to a WAV file ❸. Then you set
    the parameters for the WAV file; in this case, it’s a single-channel (mono), 2-byte
    (16-bit), uncompressed format ❹. Finally, you write the data to the file ❺. [Figure
    4-4](nsp-venkitachalam503045-0016.xhtml#fig4-4) shows the generated *sine220.wav*
    file in Audacity, a free audio editor. As expected, you see a sine wave of frequency
    220 Hz, and when you play the file, you hear a 220 Hz tone for five seconds. (Note
    that you need to use the Zoom tool in Audacity to see the sine wave as shown in
    [Figure 4-4](nsp-venkitachalam503045-0016.xhtml#fig4-4).)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 计算得到的正弦波值在范围[−1, 1]内，经过缩放后转化为16位值，并转换为字符串，以便写入WAV文件❸。然后，你设置WAV文件的参数；在这种情况下，它是单声道（mono）、2字节（16位）、无压缩格式❹。最后，将数据写入文件❺。[图4-4](nsp-venkitachalam503045-0016.xhtml#fig4-4)显示了在免费音频编辑软件Audacity中生成的*sine220.wav*文件。正如预期的那样，你会看到一个220
    Hz的正弦波，播放该文件时，你会听到一个持续5秒钟的220 Hz音调。（请注意，使用Audacity的缩放工具才能查看图4-4中所示的正弦波。）
- en: '![](images/nsp-venkitachalam503045-f04004.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f04004.jpg)'
- en: 'Figure 4-4: A sine wave at 220 Hz, zoomed in'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-4：220 Hz正弦波，已缩放显示
- en: In your project, once you’ve filled the samples buffer with audio data, you’ll
    write it to a WAV file using the same pattern illustrated in [Figure 4-4](nsp-venkitachalam503045-0016.xhtml#fig4-4).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中，一旦填充完样本缓冲区的音频数据，你将按照[图4-4](nsp-venkitachalam503045-0016.xhtml#fig4-4)所示的模式，将数据写入WAV文件。
- en: '[The Minor Pentatonic Scale](nsp-venkitachalam503045-0008.xhtml#rbh0603)'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[小调五声音阶](nsp-venkitachalam503045-0008.xhtml#rbh0603)'
- en: A *musical scale* is a series of notes in increasing or decreasing pitch (frequency).
    Often, all notes in a piece of music are chosen from a particular scale. A *musical
    interval* is the difference between two pitches. A *semitone* is a basic building
    block of a scale and is the smallest musical interval in Western music. A *tone*
    is twice the length of a semitone. The *major scale*, one of the most common musical
    scales, is defined by the interval pattern *tone-tone-semitone-tone-tone-tone-semitone*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*音阶*是一个由音符按照升高或降低的音高（频率）排列的序列。通常，一首音乐中的所有音符都选自某一特定音阶。*音乐音程*是两个音高之间的差距。*半音*是音阶的基本构成块，是西方音乐中最小的音程。*全音*是半音的两倍长度。*大音阶*，作为最常见的音阶之一，其音程模式定义为*全音-全音-半音-全音-全音-全音-半音*。'
- en: We’ll briefly go into the pentatonic scale here, since you’ll be generating
    musical notes in that scale. This section will explain the source of the frequency
    numbers used in the final program to generate notes with the Karplus-Strong algorithm.
    The *pentatonic scale* is a five-note musical scale. A variant of this scale is
    the *minor pentatonic scale*, which is defined by the interval pattern *(tone+semitone)-tone-tone-(tone+semitone)-tone*.
    Thus, the C minor pentatonic scale consists of the notes C, E-flat, F, G, and
    B-flat. [Table 4-2](nsp-venkitachalam503045-0016.xhtml#tab4-2) lists the frequencies
    of the five notes of a C minor pentatonic scale that you’ll generate using the
    Karplus-Strong algorithm. (Here, C4 designates C in the fourth octave of a piano,
    or *middle C*, by convention.)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里简要介绍五声音阶，因为你将在该音阶中生成音乐音符。本节将解释最终程序中用于生成音符的频率数字的来源，这些频率数字是通过Karplus-Strong算法生成的。*五声音阶*是一个包含五个音符的音阶。该音阶的一个变种是*小调五声音阶*，其音程模式为*(全音+半音)-全音-全音-(全音+半音)-全音*。因此，C小调五声音阶由音符C、E-flat、F、G和B-flat组成。[表4-2](nsp-venkitachalam503045-0016.xhtml#tab4-2)列出了你将使用Karplus-Strong算法生成的C小调五声音阶五个音符的频率。（在这里，C4是指钢琴第四个八度中的C音，通常被称为*中央C*。）
- en: 'Table 4-2: Notes in a Minor Pentatonic Scale'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-2：小调五声音阶中的音符
- en: '| Note | Frequency (Hz) |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 音符 | 频率（Hz） |'
- en: '| --- | --- |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| C4 | 261.6 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| C4 | 261.6 |'
- en: '| E-flat | 311.1 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| E-flat | 311.1 |'
- en: '| F | 349.2 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| F | 349.2 |'
- en: '| G | 392.0 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| G | 392.0 |'
- en: '| B-flat | 466.2 |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| B-flat | 466.2 |'
- en: One aspect of this project will be stringing together random sequences of notes
    to create melodies. One of the reasons we’re focusing on a minor pentatonic scale
    is that the notes of this scale sound pleasing no matter what order they’re played
    in. Thus, the scale is particularly conducive to generating random melodies in
    a way that other scales, such as a major scale, are not.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的一个方面是将随机的音符序列串联起来，以创作旋律。我们专注于小调五声音阶的原因之一是，这种音阶的音符无论以什么顺序演奏都听起来悦耳。因此，这个音阶特别适合生成随机旋律，而其他音阶，如大音阶，则不太适合。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah0602)'
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[要求](nsp-venkitachalam503045-0008.xhtml#rah0602)'
- en: In this project, you’ll use the Python `wave` module to create audio files in
    the WAV format. To implement the Karplus-Strong algorithm, you’ll use the `deque`
    class from the Python `collections` module as a ring buffer and a `numpy` array
    as a samples buffer. You’ll also use `matplotlib` to visualize the simulated guitar
    string, and you’ll play back the WAV files with the `pyaudio` module.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用 Python 的 `wave` 模块来创建 WAV 格式的音频文件。为了实现 Karplus-Strong 算法，你将使用 Python
    `collections` 模块中的 `deque` 类作为环形缓冲区，使用 `numpy` 数组作为采样缓冲区。你还将使用 `matplotlib` 来可视化模拟的吉他弦，并使用
    `pyaudio` 模块播放 WAV 文件。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah0603)'
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah0603)'
- en: Now let’s develop the various pieces of code required to implement the Karplus-Strong
    algorithm and then put them together for the complete program. To see the full
    project code, skip ahead to [“The Complete Code”](nsp-venkitachalam503045-0016.xhtml#ah0607)
    on [page 74](nsp-venkitachalam503045-0016.xhtml#p74). You can also download the
    code from the book’s GitHub repository at [https://github.com/mkvenkit/pp2e/tree/main/karplus](https://github.com/mkvenkit/pp2e/tree/main/karplus).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开发实现 Karplus-Strong 算法所需的各种代码片段，然后将它们组合成完整的程序。要查看完整的项目代码，请跳到 [“完整代码”](nsp-venkitachalam503045-0016.xhtml#ah0607)
    位于 [第 74 页](nsp-venkitachalam503045-0016.xhtml#p74)。你还可以从本书的 GitHub 仓库下载代码：[https://github.com/mkvenkit/pp2e/tree/main/karplus](https://github.com/mkvenkit/pp2e/tree/main/karplus)。
- en: '[Implementing the Ring Buffer with deque](nsp-venkitachalam503045-0008.xhtml#rbh0604)'
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[使用 deque 实现环形缓冲区](nsp-venkitachalam503045-0008.xhtml#rbh0604)'
- en: Recall from earlier that the Karplus-Strong algorithm uses a ring buffer to
    generate a musical note. You’ll implement the ring buffer using a `deque` container
    (pronounced “deck”), which is part of Python’s `collections` module of specialized
    container data types. You can insert and remove elements from the beginning (head)
    or end (tail) of a `deque` (see [Figure 4-5](nsp-venkitachalam503045-0016.xhtml#fig4-5)).
    This insertion and removal process is a `O(1)`, or a “constant time” operation,
    which means it takes the same amount of time regardless of how big the `deque`
    container gets.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的内容回忆，Karplus-Strong 算法使用环形缓冲区来生成音乐音符。你将使用 `deque` 容器（发音为“deck”）实现环形缓冲区，它是
    Python `collections` 模块中一种专门的数据容器类型。你可以从 `deque` 的开始（头部）或末尾（尾部）插入和移除元素（见 [图 4-5](nsp-venkitachalam503045-0016.xhtml#fig4-5)）。这种插入和移除的过程是
    `O(1)`，即“常数时间”操作，这意味着无论 `deque` 容器有多大，它所需的时间都相同。
- en: '![](images/nsp-venkitachalam503045-f04005.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f04005.jpg)'
- en: 'Figure 4-5: A ring buffer implemented using `deque`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-5：使用 `deque` 实现的环形缓冲区
- en: 'The following code shows an example of how you would use `deque` in Python:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何在 Python 中使用 `deque` 的示例：
- en: '>>> `from collections import deque`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `from collections import deque`'
- en: ❶ >>> `d = deque(range(10), maxlen=10)`
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ >>> `d = deque(range(10), maxlen=10)`
- en: '>>> `print(d)`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `print(d)`'
- en: deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: deque([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], maxlen=10)
- en: ❷ >>> `d.append(10)`
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ >>> `d.append(10)`
- en: '>>> `print(d)`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> `print(d)`'
- en: deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], maxlen=10)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: deque([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], maxlen=10)
- en: You create the `deque` container by passing in a list created with the `range()`
    function ❶. You also specify the maximum length `maxlen` of the `deque` as `10`.
    Next, you append the element `10` to the end of the `deque` container ❷. When
    you then print the `deque`, you can see that `10` has been appended to the end
    of the `deque`, while the first element, `0`, has automatically been removed to
    maintain the `deque` container’s maximum length of 10 elements. This scheme will
    allow you to simultaneously implement steps 4 and 5 of the Karplus-Strong algorithm—adding
    a new value at the end of the ring buffer while removing the first value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过传入一个使用 `range()` 函数创建的列表 ❶ 来创建 `deque` 容器。你还指定了 `deque` 的最大长度 `maxlen` 为
    `10`。接下来，你将元素 `10` 添加到 `deque` 容器的末尾 ❷。然后，当你打印 `deque` 时，你可以看到 `10` 已经被添加到 `deque`
    的末尾，而第一个元素 `0` 已自动被移除，以保持 `deque` 容器的最大长度为 10 个元素。这个方案将允许你同时实现 Karplus-Strong
    算法的步骤 4 和步骤 5——在环形缓冲区的末尾添加一个新值，同时移除第一个值。
- en: '[Implementing the Karplus-Strong Algorithm](nsp-venkitachalam503045-0008.xhtml#rbh0605)'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[实现 Karplus-Strong 算法](nsp-venkitachalam503045-0008.xhtml#rbh0605)'
- en: You’ll now implement the Karplus-Strong algorithm in the `generateNote()` function,
    using a `deque` container to implement the ring buffer and a `numpy` array to
    implement the samples buffer. In the same function, you’ll also visualize the
    algorithm using `matplotlib`. The plot will show how the amplitudes of the plucked
    string change over time, in effect showing how the string moves as it vibrates.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在将在 `generateNote()` 函数中实现 Karplus-Strong 算法，使用 `deque` 容器来实现环形缓冲区，并使用 `numpy`
    数组来实现样本缓冲区。在同一个函数中，你还会使用 `matplotlib` 来可视化算法。该图形将展示拨弦振动时弦的振幅随时间变化的情况，实际上显示了弦如何在振动时运动。
- en: 'You begin with some setup:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你开始进行一些初始化设置：
- en: initialize plotting
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化绘图
- en: ❶ fig, ax = plt.subplots(1)
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ fig, ax = plt.subplots(1)
- en: ❷ line, = ax.plot([], [])
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ line, = ax.plot([], [])
- en: 'def generateNote(freq):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 'def generateNote(freq):'
- en: '"""generate note using Karplus-Strong algorithm"""'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '"""使用 Karplus-Strong 算法生成音符"""'
- en: nSamples = 44100
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: nSamples = 44100
- en: sampleRate = 44100
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: sampleRate = 44100
- en: ❸ N = int(sampleRate/freq)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ N = int(sampleRate/freq)
- en: '❹ if gShowPlot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '❹ 如果 gShowPlot:'
- en: '# set axis'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置坐标轴'
- en: ax.set_xlim([0, N])
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_xlim([0, N])
- en: ax.set_ylim([-1.0, 1.0])
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_ylim([-1.0, 1.0])
- en: line.set_xdata(np.arange(0, N))
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: line.set_xdata(np.arange(0, N))
- en: '# initialize ring buffer'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化环形缓冲区'
- en: ❺ buf = deque([random.random() - 0.5 for i in range(N)], maxlen=N)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ buf = deque([random.random() - 0.5 for i in range(N)], maxlen=N)
- en: '# init samples buffer'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化样本缓冲区'
- en: ❻ samples = np.array([0]*nSamples, 'float32')
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ samples = np.array([0]*nSamples, 'float32')
- en: First you create a `matplotlib` figure ❶ and a line plot ❷, which you’ll fill
    with data. Then you begin the `generateNote()` function definition, which takes
    the frequency of the note to be generated as a parameter. You set the number of
    samples in the sound clip and the sample rate to both be 44,100, which means the
    resulting clip will be one second long. Then you divide the sample rate by the
    desired frequency to set the length `N` of the Karplus-Strong ring buffer ❸. If
    the `gShowPlot` flag is set ❹, you initialize the x and y range of the plot and
    initialize the x values to `[0, ... N-1]` using the `arange()` function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你创建一个 `matplotlib` 图形 ❶ 和一条线性图 ❷，你将用数据填充它。然后你开始定义 `generateNote()` 函数，函数接受要生成的音符频率作为参数。你将音频片段的样本数和采样率都设置为
    44,100，这意味着生成的片段将持续一秒钟。接着，你将采样率除以期望的频率来设置 Karplus-Strong 环形缓冲区的长度 `N` ❸。如果设置了
    `gShowPlot` 标志 ❹，你初始化图形的 x 和 y 范围，并使用 `arange()` 函数将 x 值初始化为 `[0, ... N-1]`。
- en: You next initialize the ring buffer as a `deque` container with random numbers
    in the range [−0.5, 0.5], setting the maximum length of the `deque` to `N` ❺.
    You also initialize the samples buffer as a `numpy` array of floats ❻. You set
    the length of the array to be the number of samples the sound clip will contain.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将环形缓冲区初始化为一个包含在 [−0.5, 0.5] 范围内的随机数的 `deque` 容器，并将 `deque` 的最大长度设置为 `N`
    ❺。你还将样本缓冲区初始化为一个浮点型的 `numpy` 数组 ❻。你将数组的长度设置为音频片段将包含的样本数。
- en: 'Next comes the heart of the `generateNote()` function, where you implement
    the steps of the Karplus-Strong algorithm and create the visualization:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `generateNote()` 函数的核心部分，在这里你实现 Karplus-Strong 算法的步骤，并创建可视化效果：
- en: 'for i in range(nSamples):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 i 在范围 (nSamples) 中：
- en: ❶ samples[i] = buf[0]
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ samples[i] = buf[0]
- en: ❷ avg = 0.995*0.5*(buf[0] + buf[1])
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ avg = 0.995*0.5*(buf[0] + buf[1])
- en: ❸ buf.append(avg)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ buf.append(avg)
- en: '# plot of flag set'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置图形标志'
- en: '❹ if gShowPlot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '❹ 如果 gShowPlot:'
- en: 'if i % 1000 == 0:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 i % 1000 == 0：
- en: line.set_ydata(buf)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: line.set_ydata(buf)
- en: fig.canvas.draw()
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: fig.canvas.draw()
- en: fig.canvas.flush_events()
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: fig.canvas.flush_events()
- en: '# samples to 16-bit to string'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将样本转换为 16 位字符串'
- en: '# max value is 32767 for 16-bit'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '# 最大值为 32767，适用于 16 位'
- en: ❺ samples = np.array(samples * 32767, 'int16')
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ samples = np.array(samples * 32767, 'int16')
- en: ❻ return samples.tobytes()
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ return samples.tobytes()
- en: Here you iterate over each element in the samples buffer and carry out the steps
    of the Karplus-Strong algorithm. With each iteration, you copy the first element
    in the ring buffer to the samples buffer ❶. Then you perform the low-pass filtering
    and attenuation by averaging the first two elements in the ring buffer and multiplying
    the result by 0.995 ❷. This attenuated value is appended to the end of the ring
    buffer ❸. Since the `deque` representing the ring buffer has a maximum length,
    the `append()` operation also removes the first element from the buffer.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将遍历样本缓冲区中的每个元素，并执行 Karplus-Strong 算法的步骤。每次迭代时，你将环形缓冲区中的第一个元素复制到样本缓冲区 ❶。然后，你通过对环形缓冲区中的前两个元素进行平均并将结果乘以
    0.995 来执行低通滤波和衰减 ❷。这个衰减后的值将被附加到环形缓冲区的末尾 ❸。由于表示环形缓冲区的 `deque` 具有最大长度，因此 `append()`
    操作还会从缓冲区中删除第一个元素。
- en: The `samples` array is converted into a 16-bit format by multiplying each value
    by 32,767 ❺ (a 16-bit signed integer can take values only from −32,768 to 32,767,
    and 0.5 × 65,534 = 32,767). Then the array is converted to a byte representation
    for the `wave` module, which you’ll use to save this data to a file ❻.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`samples` 数组通过将每个值乘以 32,767 ❺（一个 16 位有符号整数的取值范围是从 −32,768 到 32,767，而 0.5 ×
    65,534 = 32,767）转换为 16 位格式。然后，这个数组被转换为字节表示，用于 `wave` 模块，你将使用它将数据保存到文件 ❻。'
- en: As the algorithm is running, you visualize how the ring buffer evolves ❹. For
    every thousand samples, you update the `matplotlib` graph with the values in the
    ring buffer, and this shows how the data changes with time.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当算法运行时，你可以可视化环形缓冲区的演变 ❹。对于每千个采样，你会用环形缓冲区中的值更新 `matplotlib` 图表，这显示了数据随时间的变化。
- en: '[Writing a WAV File](nsp-venkitachalam503045-0008.xhtml#rbh0606)'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[写入 WAV 文件](nsp-venkitachalam503045-0008.xhtml#rbh0606)'
- en: 'Once you have the audio data, you can write it to a WAV file using the Python
    `wave` module. Define a `writeWAVE()` function to carry this out:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了音频数据，你可以使用 Python `wave` 模块将其写入 WAV 文件。定义一个 `writeWAVE()` 函数来执行此操作：
- en: 'def writeWAVE(fname, data):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 'def writeWAVE(fname, data):'
- en: '# open file'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开文件'
- en: ❶ file = wave.open(fname, 'wb')
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ file = wave.open(fname, 'wb')
- en: '# WAV file parameters'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '# WAV 文件参数'
- en: nChannels = 1
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: nChannels = 1
- en: sampleWidth = 2
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: sampleWidth = 2
- en: frameRate = 44100
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: frameRate = 44100
- en: nFrames = 44100
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: nFrames = 44100
- en: '# set parameters'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置参数'
- en: ❷ file.setparams((nChannels, sampleWidth, frameRate, nFrames,
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ file.setparams((nChannels, sampleWidth, frameRate, nFrames,
- en: '''NONE'', ''noncompressed''))'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '''NONE'', ''noncompressed''))'
- en: ❸ file.writeframes(data)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ file.writeframes(data)
- en: file.close()
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: file.close()
- en: You create a WAV file ❶ and set its parameters using a single-channel, 16-bit,
    noncompressed format ❷. Then you write the data to the file ❸.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建一个 WAV 文件 ❶ 并使用单声道、16 位、无压缩格式设置其参数 ❷。然后，你将数据写入文件 ❸。
- en: '[Playing WAV Files with pyaudio](nsp-venkitachalam503045-0008.xhtml#rbh0607)'
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[使用 pyaudio 播放 WAV 文件](nsp-venkitachalam503045-0008.xhtml#rbh0607)'
- en: 'Now you’ll use the Python `pyaudio` module to play the WAV files generated
    by the algorithm. `pyaudio` is a high-performance, low-level library that gives
    you access to sound devices on a computer. For convenience, you encapsulate the
    code in a `NotePlayer` class, as shown here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将使用 Python `pyaudio` 模块来播放算法生成的 WAV 文件。`pyaudio` 是一个高性能、低级别的库，可以让你访问计算机上的声音设备。为了方便，你将代码封装在
    `NotePlayer` 类中，如下所示：
- en: 'class NotePlayer:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 'class NotePlayer:'
- en: '# constructor'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '# 构造函数'
- en: 'def __init__(self):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: '# init pyaudio'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化 pyaudio'
- en: ❶ self.pa = pyaudio.PyAudio()
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ self.pa = pyaudio.PyAudio()
- en: '# open stream'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开流'
- en: ❷ self.stream = self.pa.open(
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ self.stream = self.pa.open(
- en: format=pyaudio.paInt16,
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: format=pyaudio.paInt16,
- en: channels=1,
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: channels=1,
- en: rate=44100,
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: rate=44100,
- en: output=True)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: output=True)
- en: '# dictionary of notes'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '# 音符字典'
- en: ❸ self.notes = []
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ self.notes = []
- en: In the `NotePlayer` class’s constructor, you first create the `PyAudio` object
    that you’ll use to play the WAV file ❶. Then you open a 16-bit single-channel
    `PyAudio` output stream ❷. You also create an empty list that you’ll later fill
    with filenames of the five pentatonic note WAV files ❸.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `NotePlayer` 类的构造函数中，首先创建 `PyAudio` 对象，该对象将用于播放 WAV 文件 ❶。然后打开一个 16 位单声道的 `PyAudio`
    输出流 ❷。你还会创建一个空列表，稍后将用五个五声音阶音符的 WAV 文件名填充它 ❸。
- en: 'In Python, when all references to an object have been deleted, the object is
    destroyed by a process called *garbage collection*. At that time, the object’s
    `__del__()` method, also known as a *destructor*, is called, if one is defined.
    Here’s the `NotePlayer` class’s destructor:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，当对象的所有引用被删除时，对象会通过称为 *垃圾回收* 的过程被销毁。此时，如果定义了该对象的 `__del__()` 方法，也会调用它，即
    *析构函数*。以下是 `NotePlayer` 类的析构函数：
- en: 'def __del__(self):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __del__(self):'
- en: '# destructor'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '# 析构函数'
- en: self.stream.stop_stream()
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: self.stream.stop_stream()
- en: self.stream.close()
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: self.stream.close()
- en: self.pa.terminate()
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: self.pa.terminate()
- en: This method ensures that the `PyAudio` stream is cleaned up when the `NotePlayer`
    object is destroyed. Failing to provide a `__del__()` method for a class can cause
    problems when objects are repeatedly created and destroyed, since some system-wide
    resources (like `pyaudio` in this case) may not be cleaned up properly.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法确保在 `NotePlayer` 对象被销毁时，`PyAudio` 流会被清理。如果一个类没有提供 `__del__()` 方法，在对象被反复创建和销毁时，可能会出现问题，因为一些系统级资源（比如这里的
    `pyaudio`）可能没有得到正确清理。
- en: 'The remaining methods of the `NotePlayer` class are devoted to building up
    a list of possible notes and playing them. First, here’s the `add()` method, which
    is used to add a WAV filename to the class:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotePlayer` 类的其余方法致力于构建一个可能的音符列表并播放它们。首先，这是 `add()` 方法，用于将 WAV 文件名添加到类中：'
- en: 'def add(self, fileName):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'def add(self, fileName):'
- en: self.notes.append(fileName)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: self.notes.append(fileName)
- en: The method takes a filename corresponding to one of the generated WAV files
    as a parameter and adds it to the `notes` list you initialized in the class’s
    constructor. The class will draw on this list when it wants to play a WAV file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个文件名作为参数，对应于你在类构造函数中初始化的`notes`列表中的一个生成的WAV文件。类将在需要播放WAV文件时从这个列表中获取。
- en: 'Next, let’s look at the `play()` method used to play a note:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看看用于播放音符的`play()`方法：
- en: 'def play(self, fileName):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'def play(self, fileName):'
- en: 'try:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: print("playing " + fileName)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: print("正在播放 " + fileName)
- en: '# open WAV file'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开WAV文件'
- en: ❶ wf = wave.open(fileName, 'rb')
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ wf = wave.open(fileName, 'rb')
- en: '# read a chunk'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取一个数据块'
- en: ❷ data = wf.readframes(CHUNK)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ data = wf.readframes(CHUNK)
- en: '# read rest'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取其余部分'
- en: 'while data != b'''':'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 'while data != b'''':'
- en: ❸ self.stream.write(data)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ self.stream.write(data)
- en: ❹ data = wf.readframes(CHUNK)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ data = wf.readframes(CHUNK)
- en: '# clean up'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '# 清理'
- en: ❺ wf.close()
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ wf.close()
- en: 'except BaseException as err:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'except BaseException as err:'
- en: ❻ print(f"Exception! {err=}, {type(err)=}.\nExiting.")
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ print(f"异常！{err=}, {type(err)=}.\n退出程序。")
- en: exit(0)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: exit(0)
- en: Here you open the desired WAV file using Python’s `wave` module ❶. Then you
    read `CHUNK` frames (defined globally as 1,024 in this case) from the file into
    `data` ❷. Next, within a `while` loop, you write the contents of `data` to the
    `PyAudio` output stream ❸ and read the next chunk of data from the WAV file ❹.
    Writing to the output stream has the effect of playing the audio through the default
    audio device of your computer, which is typically a speaker. You read the data
    in chunks to maintain the sample rate at the output side. If the chunks are too
    large and you take too much time in between reading and writing, the audio won’t
    sound right.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你使用Python的`wave`模块打开所需的WAV文件❶。然后从文件中读取`CHUNK`帧（在本例中全局定义为1,024）到`data`❷。接着，在一个`while`循环中，你将`data`的内容写入到`PyAudio`输出流❸，并从WAV文件中读取下一块数据❹。写入输出流的效果是在计算机的默认音频设备（通常是扬声器）上播放音频。你按块读取数据以保持输出端的采样率。如果数据块过大且你在读取和写入之间花费了太多时间，音频就会播放不正常。
- en: The `while` loop continues for as long as there’s more data to read—that is,
    until `data` is empty. At that point, you close the WAV file object ❺. You handle
    any exceptions that may happen during the playback process (for example, the user
    pressing CTRL-C) by printing the error ❻ and exiting the program.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环会持续进行，直到没有更多的数据可读取，也就是直到`data`为空。此时，你关闭WAV文件对象❺。你处理播放过程中可能出现的任何异常（例如用户按下CTRL-C）并打印错误❻，然后退出程序。'
- en: 'Finally, the `NotePlayer` class’s `playRandom()` method picks a random note
    from the five notes you’ve generated and plays it:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`NotePlayer`类的`playRandom()`方法从你生成的五个音符中随机挑选一个并播放：
- en: 'def playRandom(self):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 'def playRandom(self):'
- en: '"""play a random note"""'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '"""播放一个随机音符"""'
- en: index = random.randint(0, len(self.notes)-1)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: index = random.randint(0, len(self.notes)-1)
- en: note = self.notes[index]
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: note = self.notes[index]
- en: self.play(note)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: self.play(note)
- en: The method selects a random WAV filename from the `notes` list and passes that
    filename to the `play()` method to be played.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法从`notes`列表中选择一个随机的WAV文件名，并将该文件名传递给`play()`方法以进行播放。
- en: '[Creating Notes and Parsing Arguments](nsp-venkitachalam503045-0008.xhtml#rbh0608)'
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[创建音符和解析参数](nsp-venkitachalam503045-0008.xhtml#rbh0608)'
- en: 'Now let’s look at the program’s `main()` function, which creates the notes
    and handles various command line options to play the notes:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看程序的`main()`函数，它创建音符并处理各种命令行选项来播放音符：
- en: 'def main():'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: --`snip`--
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: --`省略`--
- en: parser = argparse.ArgumentParser(description="Generating sounds with
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: parser = argparse.ArgumentParser(description="使用Karplus-Strong算法生成声音")
- en: Karplus-Strong Algorithm")
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Karplus-Strong算法")
- en: '# add arguments'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加参数'
- en: parser.add_argument('--display', action='store_true', required=False)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--display', action='store_true', required=False)
- en: parser.add_argument('--play', action='store_true', required=False)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--play', action='store_true', required=False)
- en: args = parser.parse_args()
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: args = parser.parse_args()
- en: '# show plot if flag set'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果设置了标志则显示图表'
- en: '❶ if args.display:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ if args.display:'
- en: gShowPlot = True
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: gShowPlot = True
- en: plt.show(block=False)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show(block=False)
- en: '# create note player'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建音符播放器'
- en: ❷ nplayer = NotePlayer()
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ nplayer = NotePlayer()
- en: print('creating notes...')
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: print('正在创建音符...')
- en: 'for name, freq in list(pmNotes.items()):'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 'for name, freq in list(pmNotes.items()):'
- en: fileName = name + '.wav'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: fileName = name + '.wav'
- en: '❸ if not os.path.exists(fileName) or args.display:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '❸ if not os.path.exists(fileName) or args.display:'
- en: data = generateNote(freq)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: data = generateNote(freq)
- en: print('creating ' + fileName + '...')
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: print('正在创建 ' + fileName + '...')
- en: writeWAVE(fileName, data)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: writeWAVE(fileName, data)
- en: 'else:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print('fileName already created. skipping...')
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: print('文件名已创建，跳过...')
- en: '# add note to player'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将音符添加到播放器'
- en: ❹ nplayer.add(name + '.wav')
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ nplayer.add(name + '.wav')
- en: '# play note if display flag set'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果设置了显示标志，则播放音符'
- en: 'if args.display:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果args.display为真：
- en: ❺ nplayer.play(name + '.wav')
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ nplayer.play(name + '.wav')
- en: time.sleep(0.5)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: time.sleep(0.5)
- en: '# play a random tune'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '# 播放一段随机旋律'
- en: 'if args.play:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.play:'
- en: 'while True:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'try:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: ❻ nplayer.playRandom()
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ nplayer.playRandom()
- en: '# rest - 1 to 8 beats'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '# 停顿 - 1到8拍'
- en: ❼ rest = np.random.choice([1, 2, 4, 8], 1,
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ rest = np.random.choice([1, 2, 4, 8], 1,
- en: p=[0.15, 0.7, 0.1, 0.05])
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: p=[0.15, 0.7, 0.1, 0.05])
- en: time.sleep(0.25*rest[0])
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: time.sleep(0.25*rest[0])
- en: 'except KeyboardInterrupt:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 'except KeyboardInterrupt:'
- en: exit()
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: exit()
- en: First you set up some command line options for the program using `argparse`,
    as discussed in earlier projects. The `--display` option will play each of the
    five notes in turn, while visualizing each note’s waveform using `matplotlib`.
    The `--play` option generates a random melody using the five notes.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你使用`argparse`为程序设置一些命令行选项，如在之前的项目中讨论的那样。`--display`选项将依次播放五个音符，并使用`matplotlib`可视化每个音符的波形。`--play`选项则会使用这五个音符生成一段随机旋律。
- en: If the `--display` command line option was used ❶, you set up a `matplotlib`
    plot to show how the waveform evolves during the Karplus-Strong algorithm. The
    `plt.show(block=False)` call ensures that the `matplotlib` display method doesn’t
    block. This way, when you call this function, it will return immediately and go
    on to the next statement. This is the behavior you need, since you’re manually
    updating the plot every frame.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用了`--display`命令行选项❶，你会设置一个`matplotlib`绘图来展示在Karplus-Strong算法过程中波形的变化。`plt.show(block=False)`调用确保`matplotlib`的显示方法不会阻塞。这样，当你调用这个函数时，它会立即返回并继续执行下一条语句。这是你所需要的行为，因为你每帧都在手动更新绘图。
- en: 'You next create an instance of the `NotePlayer` class ❷. Then you generate
    WAV files of the five notes in the C minor pentatonic scale. The frequencies for
    the notes are defined in the global dictionary `pmNotes`, which looks like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来你创建一个`NotePlayer`类的实例❷。然后，你生成C小调五声音阶的五个音符的WAV文件。音符的频率在全局字典`pmNotes`中定义，其结构如下：
- en: 'pmNotes = {''C4'': 262, ''Eb'': 311, ''F'': 349, ''G'': 391, ''Bb'': 466}'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 'pmNotes = {''C4'': 262, ''Eb'': 311, ''F'': 349, ''G'': 391, ''Bb'': 466}'
- en: To generate the notes, you iterate through the dictionary, first constructing
    a filename for the note using the dictionary key plus the *.wav* extension—for
    example, *C4.wav*. You use the `os.path.``exists()` method to see whether the
    WAV file for a particular note has been created ❸. If so, you skip the computation
    for that note. (This is a handy optimization if you’re running this program several
    times.) Otherwise, you generate the note using the `generateNote()` and `writeWAVE()`
    functions you defined earlier. Once the note is computed and the WAV file created,
    you add the note’s filename to the `NotePlayer` object’s list of notes ❹, and
    then you play the note if the `--display` command line option is used ❺.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成音符，你遍历字典，首先使用字典键加上*.wav*扩展名来构造音符的文件名——例如，*C4.wav*。你使用`os.path.``exists()`方法查看某个音符的WAV文件是否已经创建❸。如果已经创建，跳过该音符的计算。（如果你多次运行此程序，这是一个很有用的优化。）否则，你使用之前定义的`generateNote()`和`writeWAVE()`函数来生成音符。一旦音符计算完成并创建了WAV文件，你就将该音符的文件名添加到`NotePlayer`对象的音符列表中❹，如果使用了`--display`命令行选项，则播放该音符❺。
- en: If the `--play` option is used, the `playRandom()` method in `NotePlayer` repeatedly
    plays a note at random from the five notes ❻. For a note sequence to sound even
    remotely musical, you need to add rests between the notes played, so you use the
    `random.``choice()` method from `numpy` to choose a random rest interval ❼. This
    method also lets you choose the probability of the rest interval, which you set
    so that a two-beat rest is the most probable and an eight-beat rest the least
    probable. Try changing these values to create your own style of random music!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用了`--play`选项，`NotePlayer`中的`playRandom()`方法会从五个音符中随机播放一个音符❻。为了让音符序列听起来稍微有点旋律感，你需要在音符之间添加停顿，因此你使用`numpy`中的`random.``choice()`方法来选择一个随机的停顿间隔❼。该方法还允许你选择停顿间隔的概率，你可以设置使得一个两拍的停顿最为常见，而八拍的停顿最不常见。尝试调整这些值，创作属于你自己的随机音乐风格吧！
- en: '[Running the Plucked String Simulation](nsp-venkitachalam503045-0008.xhtml#rah0604)'
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行拨弦模拟](nsp-venkitachalam503045-0008.xhtml#rah0604)'
- en: 'To run the code for this project, enter this in a command shell:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这个项目的代码，在命令行中输入以下内容：
- en: $ `python ks.py --display`
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: $ `python ks.py --display`
- en: As you can see in [Figure 4-6](nsp-venkitachalam503045-0016.xhtml#fig4-6), the
    `matplotlib` plot shows how the Karplus-Strong algorithm converts the initial
    random displacements to create waves of the desired frequency.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 4-6](nsp-venkitachalam503045-0016.xhtml#fig4-6) 所示，`matplotlib` 图表展示了 Karplus-Strong
    算法如何将初始随机位移转化为所需频率的波形。
- en: '![](images/nsp-venkitachalam503045-f04006.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f04006.jpg)'
- en: 'Figure 4-6: A sample run of the plucked string simulation'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-6：拨弦仿真示例运行
- en: 'Now try playing a random sequence of notes using this command:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试使用以下命令播放一串随机音符：
- en: $ `python ks.py --play`
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: $ `python ks.py --play`
- en: This should play a random note sequence using the generated WAV files of the
    pentatonic musical scale.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会使用生成的五声音阶的 WAV 文件播放一串随机音符序列。
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah0605)'
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[总结](nsp-venkitachalam503045-0008.xhtml#rah0605)'
- en: In this project, you used the Karplus-Strong algorithm to simulate the sound
    of plucked strings and played notes from generated WAV files. You learned how
    to implement the Karplus-Strong algorithm using a `deque` container as a ring
    buffer. You also learned about the WAV file format and how to play WAV files using
    `pyaudio`, as well as how to use `matplotlib` to visualize a vibrating string.
    You even learned about the pentatonic musical scale!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，你使用 Karplus-Strong 算法模拟拨弦声，并通过生成的 WAV 文件播放音符。你学会了如何使用 `deque` 容器作为环形缓冲区实现
    Karplus-Strong 算法。你还了解了 WAV 文件格式以及如何使用 `pyaudio` 播放 WAV 文件，并学会了如何使用 `matplotlib`
    可视化振动的弦。你甚至了解了五声音阶！
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah0606)'
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实验！](nsp-venkitachalam503045-0008.xhtml#rah0606)'
- en: 'Here are some ideas for experiments:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些实验的想法：
- en: 1\. I’ve stated that the Karplus-Strong algorithm creates realistic plucked
    string sounds by generating overtones as well as the fundamental frequency of
    the note. But how do you know it’s working? By creating spectral plots of your
    WAV files, like the one in [Figure 4-2](nsp-venkitachalam503045-0016.xhtml#fig4-2).
    You can use the free program Audacity to do this. Open one of the WAV files in
    Audacity, and select **Analyze‣Plot** **Spectrum**. You should see that the sound
    contains many frequencies.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 我已经说明 Karplus-Strong 算法通过生成泛音以及音符的基频来创造逼真的拨弦声音。那么，你怎么知道它在工作呢？通过创建你的 WAV
    文件的频谱图，就像 [图 4-2](nsp-venkitachalam503045-0016.xhtml#fig4-2) 中的那样。你可以使用免费的程序 Audacity
    来完成这项工作。在 Audacity 中打开其中一个 WAV 文件，并选择 **Analyze‣Plot** **Spectrum**。你应该能看到声音包含了许多频率。
- en: 2\. Use the techniques you learned in this chapter to create a method that replicates
    the sound of two strings of different frequencies vibrating together. Remember,
    the Karplus-Strong algorithm produces a ring buffer full of sound amplitude values.
    You can combine two sounds by adding their amplitudes together.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 运用本章中学到的技巧，创建一个方法，模拟两根不同频率的弦一起振动的声音。记住，Karplus-Strong 算法产生的是一个充满声音振幅值的环形缓冲区。你可以通过将两个声音的振幅相加来组合这两种声音。
- en: 3\. Replicate the sound of two strings vibrating together, as described in the
    previous experiment, but add a time delay between the first and second string
    plucks.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 模拟两根弦振动的声音，像前面的实验一样，但在第一根和第二根弦拨动之间加入时间延迟。
- en: '4\. Write a method to read music from a text file and generate musical notes.
    Then play the music using these notes. You can use a format where the note names
    are followed by integer rest time intervals, like this: C4 1 F4 2 G4 1 . . .'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 编写一个方法，从文本文件中读取音乐并生成音乐音符。然后使用这些音符播放音乐。你可以使用一种格式，其中音符名称后面跟着整数的休止时间间隔，像这样：C4
    1 F4 2 G4 1 …。
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah0607)'
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整代码](nsp-venkitachalam503045-0008.xhtml#rah0607)'
- en: 'Here’s the complete code for this project:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此项目的完整代码：
- en: '"""'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: ks.py
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ks.py
- en: Uses the Karplus-Strong algorithm to generate musical notes
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Karplus-Strong 算法生成音乐音符
- en: in a pentatonic scale.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在五声音阶中。
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：Mahesh Venkitachalam
- en: '"""'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: import sys, os
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: import sys, os
- en: import time, random
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: import time, random
- en: import wave, argparse
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: import wave, argparse
- en: import numpy as np
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: from collections import deque
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: from collections import deque
- en: import matplotlib
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib
- en: to fix graph display issues on macOS
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复 macOS 上的图表显示问题
- en: matplotlib.use('TkAgg')
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: matplotlib.use('TkAgg')
- en: from matplotlib import pyplot as plt
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: from matplotlib import pyplot as plt
- en: import pyaudio
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: import pyaudio
- en: show plot of algorithm in action?
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是否显示算法运行时的图表？
- en: gShowPlot = False
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: gShowPlot = False
- en: notes of a pentatonic minor scale
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 五声音阶的音符
- en: piano C4-E(b)-F-G-B(b)-C5
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: piano C4-E(b)-F-G-B(b)-C5
- en: 'pmNotes = {''C4'': 262, ''Eb'': 311, ''F'': 349, ''G'':391, ''Bb'':466}'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 'pmNotes = {''C4'': 262, ''Eb'': 311, ''F'': 349, ''G'':391, ''Bb'':466}'
- en: CHUNK = 1024
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: CHUNK = 1024
- en: initialize plotting
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化绘图
- en: fig, ax = plt.subplots(1)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: fig, ax = plt.subplots(1)
- en: line, = ax.plot([], [])
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: line, = ax.plot([], [])
- en: write out WAV file
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入WAV文件
- en: 'def writeWAVE(fname, data):'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 'def writeWAVE(fname, data):'
- en: '"""write data to WAV file"""'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '"""写入数据到WAV文件"""'
- en: '# open file'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开文件'
- en: file = wave.open(fname, 'wb')
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: file = wave.open(fname, 'wb')
- en: '# WAV file parameters'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '# WAV文件参数'
- en: nChannels = 1
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: nChannels = 1
- en: sampleWidth = 2
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: sampleWidth = 2
- en: frameRate = 44100
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: frameRate = 44100
- en: nFrames = 44100
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: nFrames = 44100
- en: '# set parameters'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置参数'
- en: file.setparams((nChannels, sampleWidth, frameRate, nFrames,
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: file.setparams((nChannels, sampleWidth, frameRate, nFrames,
- en: '''NONE'', ''noncompressed''))'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '''NONE'', ''非压缩''))'
- en: file.writeframes(data)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: file.writeframes(data)
- en: file.close()
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: file.close()
- en: 'def generateNote(freq):'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 'def generateNote(freq):'
- en: '"""generate note using Karplus-Strong algorithm"""'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '"""使用Karplus-Strong算法生成音符"""'
- en: nSamples = 44100
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: nSamples = 44100
- en: sampleRate = 44100
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: sampleRate = 44100
- en: N = int(sampleRate/freq)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: N = int(sampleRate/freq)
- en: 'if gShowPlot:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 'if gShowPlot:'
- en: '# set axis'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置轴'
- en: ax.set_xlim([0, N])
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_xlim([0, N])
- en: ax.set_ylim([-1.0, 1.0])
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ax.set_ylim([-1.0, 1.0])
- en: line.set_xdata(np.arange(0, N))
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: line.set_xdata(np.arange(0, N))
- en: '# initialize ring buffer'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化环形缓冲区'
- en: buf = deque([random.random() - 0.5 for i in range(N)], maxlen=N)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: buf = deque([random.random() - 0.5 for i in range(N)], maxlen=N)
- en: '# init sample buffer'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化样本缓冲区'
- en: samples = np.array([0]*nSamples, 'float32')
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: samples = np.array([0]*nSamples, 'float32')
- en: 'for i in range(nSamples):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(nSamples):'
- en: samples[i] = buf[0]
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: samples[i] = buf[0]
- en: avg = 0.995*0.5*(buf[0] + buf[1])
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: avg = 0.995*0.5*(buf[0] + buf[1])
- en: buf.append(avg)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: buf.append(avg)
- en: '# plot of flag set'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果设置了标志，则绘制图表'
- en: 'if gShowPlot:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 'if gShowPlot:'
- en: 'if i % 1000 == 0:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 'if i % 1000 == 0:'
- en: line.set_ydata(buf)
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: line.set_ydata(buf)
- en: fig.canvas.draw()
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: fig.canvas.draw()
- en: fig.canvas.flush_events()
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: fig.canvas.flush_events()
- en: '# samples to 16-bit to string'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将样本转换为16位字符串'
- en: '# max value is 32767 for 16-bit'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '# 16位最大值为32767'
- en: samples = np.array(samples * 32767, 'int16')
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: samples = np.array(samples * 32767, 'int16')
- en: return samples.tobytes()
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: return samples.tobytes()
- en: play a WAV file
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放一个WAV文件
- en: 'class NotePlayer:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 'class NotePlayer:'
- en: '# constructor'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '# 构造函数'
- en: 'def __init__(self):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: '# init pyaudio'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化pyaudio'
- en: self.pa = pyaudio.PyAudio()
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: self.pa = pyaudio.PyAudio()
- en: '# open stream'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开流'
- en: self.stream = self.pa.open(
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: self.stream = self.pa.open(
- en: format=pyaudio.paInt16,
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: format=pyaudio.paInt16,
- en: channels=1,
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: channels=1,
- en: rate=44100,
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: rate=44100,
- en: output=True)
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: output=True)
- en: '# dictionary of notes'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '# 音符字典'
- en: self.notes = []
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: self.notes = []
- en: 'def __del__(self):'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __del__(self):'
- en: '# destructor'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '# 析构函数'
- en: self.stream.stop_stream()
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: self.stream.stop_stream()
- en: self.stream.close()
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: self.stream.close()
- en: self.pa.terminate()
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: self.pa.terminate()
- en: '# add a note'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加一个音符'
- en: 'def add(self, fileName):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 'def add(self, fileName):'
- en: self.notes.append(fileName)
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: self.notes.append(fileName)
- en: '# play a note'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '# 播放音符'
- en: 'def play(self, fileName):'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 'def play(self, fileName):'
- en: 'try:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: print("playing " + fileName)
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: print("正在播放 " + fileName)
- en: '# open WAV file'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开WAV文件'
- en: wf = wave.open(fileName, 'rb')
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: wf = wave.open(fileName, 'rb')
- en: '# read a chunk'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取一个数据块'
- en: data = wf.readframes(CHUNK)
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: data = wf.readframes(CHUNK)
- en: '# read rest'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '# 读取其余部分'
- en: 'while data != b'''':'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 'while data != b'''':'
- en: self.stream.write(data)
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: self.stream.write(data)
- en: data = wf.readframes(CHUNK)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: data = wf.readframes(CHUNK)
- en: '# clean up'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '# 清理'
- en: wf.close()
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: wf.close()
- en: 'except BaseException as err:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 'except BaseException as err:'
- en: print(f"Exception! {err=}, {type(err)=}.\nExiting.")
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: print(f"异常! {err=}, {type(err)=}。\n退出中。")
- en: exit(0)
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: exit(0)
- en: 'def playRandom(self):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 'def playRandom(self):'
- en: '"""play a random note"""'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '"""播放一个随机音符"""'
- en: index = random.randint(0, len(self.notes)-1)
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: index = random.randint(0, len(self.notes)-1)
- en: note = self.notes[index]
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: note = self.notes[index]
- en: self.play(note)
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: self.play(note)
- en: main() function
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: main() 函数
- en: 'def main():'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '# declare global var'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '# 声明全局变量'
- en: global gShowPlot
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: global gShowPlot
- en: parser = argparse.ArgumentParser(description="Generating sounds with
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: parser = argparse.ArgumentParser(description="使用Karplus-Strong算法生成声音")
- en: Karplus-Strong Algorithm.")
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: Karplus-Strong算法。")
- en: '# add arguments'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加参数'
- en: parser.add_argument('--display', action='store_true', required=False)
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--display', action='store_true', required=False)
- en: parser.add_argument('--play', action='store_true', required=False)
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--play', action='store_true', required=False)
- en: args = parser.parse_args()
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: args = parser.parse_args()
- en: '# show plot if flag set'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果设置了显示标志，则显示图表'
- en: 'if args.display:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.display:'
- en: gShowPlot = True
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: gShowPlot = True
- en: '# plt.ion()'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '# plt.ion()'
- en: plt.show(block=False)
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: plt.show(block=False)
- en: '# create note player'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建音符播放器'
- en: nplayer = NotePlayer()
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: nplayer = NotePlayer()
- en: print('creating notes...')
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: print('正在创建音符...')
- en: 'for name, freq in list(pmNotes.items()):'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 'for name, freq in list(pmNotes.items()):'
- en: fileName = name + '.wav'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: fileName = name + '.wav'
- en: 'if not os.path.exists(fileName) or args.display:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 'if not os.path.exists(fileName) or args.display:'
- en: data = generateNote(freq)
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: data = generateNote(freq)
- en: print('creating ' + fileName + '...')
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: print('正在创建 ' + fileName + '...')
- en: writeWAVE(fileName, data)
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: writeWAVE(fileName, data)
- en: 'else:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: print('fileName already created. skipping...')
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: print('文件名已创建，跳过...')
- en: '# add note to player'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '# 向播放器添加音符'
- en: nplayer.add(name + '.wav')
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: nplayer.add(name + '.wav')
- en: '# play note if display flag set'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '# 如果显示标志设置，播放音符'
- en: 'if args.display:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.display:'
- en: nplayer.play(name + '.wav')
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: nplayer.play(name + '.wav')
- en: time.sleep(0.5)
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: time.sleep(0.5)
- en: '# play a random tune'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '# 播放一个随机旋律'
- en: 'if args.play:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.play:'
- en: 'while True:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 'while True:'
- en: 'try:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 'try:'
- en: nplayer.playRandom()
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: nplayer.playRandom()
- en: '# rest - 1 to 8 beats'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '# rest - 1 到 8 拍'
- en: rest = np.random.choice([1, 2, 4, 8], 1,
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: rest = np.random.choice([1, 2, 4, 8], 1,
- en: p=[0.15, 0.7, 0.1, 0.05])
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: p=[0.15, 0.7, 0.1, 0.05])
- en: time.sleep(0.25*rest[0])
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: time.sleep(0.25*rest[0])
- en: 'except KeyboardInterrupt:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 'except KeyboardInterrupt:'
- en: exit()
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: exit()
- en: call main
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用 main
- en: 'if __name__ == ''__main__'':'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: main()
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: main()
