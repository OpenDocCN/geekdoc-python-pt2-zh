- en: '**10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10'
- en: ARE WE ALONE? EXPLORING THE FERMI PARADOX**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否孤独？探索费米悖论**
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: Scientists use the *Drake equation* to estimate the possible number of civilizations
    in the galaxy currently producing electromagnetic emissions, such as radio waves.
    In 2017, the equation was updated to account for new exoplanet discoveries by
    NASA’s Kepler satellite. The result, published in the scientific journal *Astrobiology*,
    was astonishing. For humanity to be the first and only technologically advanced
    species, the probability of an advanced civilization developing on a habitable
    alien planet would have to be less than 1 in 10 billion trillion! And yet, as
    Nobel Prize–winning physicist Enrico Fermi famously observed, “Where is everybody?”
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 科学家使用*德雷克方程*来估算当前在银河系中产生电磁辐射（如无线电波）的文明数量。2017年，德雷克方程进行了更新，以考虑到NASA开普勒卫星的新外星行星发现。这个结果在科学期刊《天体生物学》上发表，令人震惊。为了使人类成为第一个也是唯一一个技术先进的物种，在宜居的外星行星上发展出一个先进文明的概率必须低于1/10000万亿！然而，正如诺贝尔奖得主恩里科·费米著名的观察到的那样，“他们在哪里？”
- en: Fermi was more skeptical about interstellar travel than the existence of extraterrestrials,
    but his question became known as *Fermi’s paradox*, and it morphed into the conjecture
    “If they were out there, they’d be here.” According to the SETI Institute, even
    with modest rocket technology, an eager civilization could explore the entire
    galaxy, if not colonize it, within 10 million years. That may sound like a long
    time, but it’s only 1/1,000 the age of the Milky Way! As a result, some have come
    to accept Fermi’s paradox as proof we are alone in the cosmos. Others find holes
    in the argument.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 费米对星际旅行的怀疑超过了对外星生命存在的怀疑，但他的问题成为了*费米悖论*，并发展成了这样一个猜想：“如果他们在那里，他们就应该出现在这里。”根据SETI研究所的说法，即使使用适度的火箭技术，一个渴望的文明也能在1000万年内探索整个银河系，甚至是殖民它。听起来可能像是很长的时间，但这仅仅是银河系年龄的千分之一！因此，有些人开始接受费米悖论作为我们在宇宙中孤独的证据。也有人在这个论点中找到了漏洞。
- en: In this chapter, you’ll investigate the absence of alien radio transmissions
    by calculating the probability of one civilization detecting another based on
    the volume of their transmissions and output from the Drake equation. You’ll also
    use Python’s de facto standard GUI package, tkinter, to quickly and easily create
    a graphical model of the Milky Way.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将通过计算基于文明传输体积和德雷克方程输出的探测概率，调查外星无线电信号缺失的问题。你还将使用Python的事实标准GUI包tkinter，快速而轻松地创建银河系的图形模型。
- en: '**Project #17: Modeling the Milky Way**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #17：建模银河系**'
- en: Our galaxy, the Milky Way, is a fairly common spiral galaxy, like the one shown
    in [Figure 10-1](ch10.xhtml#ch10fig1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的银河系，银河系，是一个相当常见的螺旋星系，像[图 10-1](ch10.xhtml#ch10fig1)中所示。
- en: '![image](../images/f0188-01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0188-01.jpg)'
- en: '*Figure 10-1: Spiral galaxy NGC 6744, “Big Brother” to the Milky Way*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-1：螺旋星系NGC 6744，银河系的“哥哥”*'
- en: In cross-sectional view, the Milky Way is a flattened disc with a central bulge
    that most likely contains a supermassive black hole at its core. Four “spiral
    arms”—comprising relatively densely packed gas, dust, and stars—radiate from this
    central mass. The dimensions of the Milky Way are shown in [Figure 10-2](ch10.xhtml#ch10fig2).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从横截面来看，银河系是一个扁平的盘状结构，中央凸起部分最可能包含一个超大质量黑洞。四条“螺旋臂”——由相对密集的气体、尘埃和恒星组成——从这个中央物质区辐射出去。银河系的尺寸见于[图
    10-2](ch10.xhtml#ch10fig2)。
- en: '![image](../images/f0189-01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0189-01.jpg)'
- en: '*Figure 10-2: Schematic profile (edge view) of the Milky Way galaxy (LY = Light-Years)
    and a simplified model*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-2：银河系的示意剖面图（边缘视图）（LY = 光年）及简化模型*'
- en: The center of the galaxy is considered fairly inhospitable to life due to high
    levels of radiation associated with the more closely packed stars. So, for this
    project, you can treat the galaxy as a simple disc to discount some of the volume
    associated with the bulge but still leave room for some advanced civilizations
    near the core (see the Galactic Model in [Figure 10-2](ch10.xhtml#ch10fig2)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与更紧密分布的恒星相关的高辐射水平，银河系的中心被认为对生命来说是相当不适宜的。因此，对于这个项目，你可以将银河系视为一个简单的盘面，忽略掉一些与凸起部分相关的体积，但仍为核心附近的一些先进文明留下空间（见[图
    10-2](ch10.xhtml#ch10fig2)中的银河模型）。
- en: '**THE OBJECTIVE**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: For a given number of advanced galactic civilizations and an average radio bubble
    size, estimate the probability of *any* civilization detecting the radio transmissions
    of *any other* civilization. For perspective, post the size of Earth’s current
    radio bubble on a 2D graphical representation of the Milky Way.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定数量的高级银河系文明和平均无线电气泡大小，估算*任何*文明检测到*其他任何*文明的无线电信号的概率。为了更好理解，可以将地球当前无线电气泡的大小绘制在银河系的二维图形中。
- en: '**The Strategy**'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**策略**'
- en: 'Here are the steps needed to complete this project:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这个项目需要的步骤如下：
- en: Estimate the number of transmitting civilizations using the Drake equation.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用德雷克方程估算发射无线电信号的文明数量。
- en: Choose a size range for their radio bubbles.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择它们无线电气泡的大小范围。
- en: Generate a formula for estimating the probability of one civilization detecting
    another.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个公式，用于估算一个文明检测到另一个文明的概率。
- en: Build a graphical model of the galaxy and post Earth’s radio emissions bubble.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个银河系的图形模型，并展示地球的无线电辐射气泡。
- en: In order to keep the description close to the code, each of these tasks will
    be described in detail in its own section. Note that the first two steps don’t
    require the use of Python.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使描述更贴近代码，每个任务将会在各自的章节中详细描述。请注意，前两个步骤不需要使用 Python。
- en: '**Estimating the Number of Civilizations**'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**估算文明的数量**'
- en: 'You can manually estimate the number of advanced civilizations using the Drake
    equation:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用德雷克方程手动估算高级文明的数量：
- en: '*N* = *R^** · *f*[p] · *n*[e] · *f*[l] · *f*[i] · *f*[c] · *L*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*N* = *R^** · *f*[p] · *n*[e] · *f*[l] · *f*[i] · *f*[c] · *L*'
- en: 'where:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '*N* = The number of civilizations in our galaxy whose electromagnetic emissions
    are detectable'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*N* = 我们银河系中电磁辐射可被探测的文明数量'
- en: '*R*^* = The average rate of star formation in the galaxy (new stars per year)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*R*^* = 银河系中恒星的平均形成率（每年新星数量）'
- en: '*f*^p = The fraction of stars with planets'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*^p = 拥有行星的恒星的比例'
- en: '*n*^e = For stars with planets, the average number of planets with an environment
    suitable for life'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*^e = 有行星的恒星中，适合生命存在的行星的平均数量'
- en: '*f*^l = The fraction of planets that develop life'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*^l = 发展出生命的行星的比例'
- en: '*f*^i = The fraction of life-bearing planets with intelligent, civilized life'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*^i = 具有智慧和文明生命的适生行星的比例'
- en: '*f*^c = The fraction of civilizations that release detectable signs of their
    existence into space'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*^c = 发射可检测到的存在信号到太空的文明比例'
- en: '*L* = The length of time—in years—over which the civilizations release the
    detectable signals'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*L* = 文明释放可检测信号的时间长度——单位为年'
- en: Thanks to recent advances in the detection of exoplanets, the first three components
    (*R*^*, *f*^p, *n*^e) are becoming increasingly constrained. For *n*^e, recent
    studies suggest that 10 to 40 percent of all planets may be suitable for *some
    form* of life.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 得益于近期在系外行星探测方面的进展，前三个组件（*R*^*、*f*^p、*n*^e）变得越来越受限制。对于 *n*^e，最近的研究表明，10%到40%的行星可能适合某种形式的生命。
- en: For the remaining components, Earth is the only example. In the Earth’s 4.5-billion-year
    history, *Homo sapiens* has existed for only 200,000 years, civilization for only
    6,000 years, and radio transmissions for only 112 years. With respect to *L*,
    wars, plagues, ice ages, asteroid impacts, super-volcanoes, supernovas, and coronal
    mass ejections can disrupt a civilization’s ability to transmit radio signals.
    And the shorter the time of transmission, the less likely it is for civilizations
    to coexist.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其余的组件，地球是唯一的例子。在地球的45亿年历史中，*智人*仅存在20万年，文明存在6000年，无线电传播只有112年的历史。关于 *L*，战争、瘟疫、冰河时代、陨石撞击、超级火山、超新星爆发和日冕物质抛射等事件都可能扰乱文明传输无线电信号的能力。而且，传输时间越短，文明共存的可能性就越低。
- en: According to the Wikipedia article on the Drake equation (*[https://en.wikipedia.org/wiki/Drake_equation](https://en.wikipedia.org/wiki/Drake_equation)*),
    in 1961, Drake and his colleagues estimated the number of communicating civilizations
    in the galaxy to be between 1,000 and 100,000,000\. More recent updates have set
    the range from 1 (just us) to 15,600,000 ([Table 10-1](ch10.xhtml#ch10tab1)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 根据德雷克方程的维基百科文章（*[https://en.wikipedia.org/wiki/Drake_equation](https://en.wikipedia.org/wiki/Drake_equation)*），在1961年，德雷克和他的同事估算银河系中进行通讯的文明数量在1000到1亿之间。近期的更新将范围设置为从1（只有我们）到1560万（见[表10-1](ch10.xhtml#ch10tab1)）。
- en: '**Table 10-1:** Some Drake Equation Inputs and Results'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**表10-1：** 一些德雷克方程的输入和结果'
- en: '| **Parameter** | **Drake 1961**** | **Drake 2017** | **Your choices** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **德雷克 1961** | **德雷克 2017** | **你的选择** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| *R*^* | 1 | 3 |  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| *R*^* | 1 | 3 |  |'
- en: '| *f*[p] | 0.35 | 1 |  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| *f*[p] | 0.35 | 1 |  |'
- en: '| *n*^e | 3 | 0.2 |  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| *n*^e | 3 | 0.2 |  |'
- en: '| *f*[l] | 1 | 0.13 |  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| *f*[l] | 1 | 0.13 |  |'
- en: '| *f*[i] | 1 | 1 |  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| *f*[i] | 1 | 1 |  |'
- en: '| *f*[c] | 0.15 | 0.2 |  |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| *f*[c] | 0.15 | 0.2 |  |'
- en: '| *L* | 50 × 10⁶ | 1 × 10⁹ |  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| *L* | 50 × 10⁶ | 1 × 10⁹ |  |'
- en: '| *N* | 7.9 × 10⁶ | 15.6 × 10⁶ |  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| *N* | 7.9 × 10⁶ | 15.6 × 10⁶ |  |'
- en: '| **midpoint of ranges shown |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **范围的中点** |'
- en: For input to your program, you can use the estimates in the table, those you
    find online, or those you calculate yourself (in the final column of the table).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你的程序输入，你可以使用表格中的估算值，网上找到的值，或者你自己计算的值（表格的最后一列）。
- en: '**Selecting Radio Bubble Dimensions**'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**选择无线电气泡的尺寸**'
- en: Radio waves that aren’t focused into a beam for targeted transmission are incidental.
    Think of these as “planet leakage.” Because we choose not to broadcast our presence
    to aliens who might come and eat us, almost all of our transmissions are incidental.
    These transmissions currently form an expanding sphere around Earth with a diameter
    of around 225 light-years (LY).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 无线电波如果没有聚焦成一个用于定向传输的波束，就是偶然的。可以把这些看作是“行星泄漏”。因为我们选择不向可能会来吃掉我们的外星人广播我们的存在，几乎我们所有的传输都是偶然的。这些传输目前形成了一个扩展中的球体，围绕地球，直径大约是225光年（LY）。
- en: A 225 LY bubble sounds impressive, but it is the *detectable* size that really
    matters. A radio wave front is subject to the *inverse square law*, which means
    it continuously loses power density as it expands. Additional power loss can result
    from absorption or scattering. At some point, the signal becomes too weak to separate
    from background noise. Even with our best technology—the radio telescopes of the
    *Breakthrough Listen* program—we could detect our own radio bubble only out to
    about 16 LY.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 225光年的气泡听起来令人印象深刻，但真正重要的是*可检测*的大小。无线电波前受到*平方反比定律*的影响，这意味着它在扩展时会不断失去能量密度。额外的能量损失可能来自吸收或散射。某个时刻，信号变得太弱，无法与背景噪声区分开来。即使是我们的最佳技术——*突破聆听*项目的射电望远镜——我们也只能检测到自己大约16光年外的无线电气泡。
- en: Since we’re really investigating why *we* haven’t detected aliens, you should
    assume, for this project, that other civilizations have technology similar to
    our own. Another assumption should be that, like us, all aliens have a paranoid
    planetary consciousness and aren’t broadcasting “here we are” signals that would
    announce their presence. Investigating incidental bubble sizes ranging from a
    little smaller than those currently detectable to those a little larger than our
    own transmissions should be a reasonable place to start. This would suggest a
    diameter range of 30 to 250 LY. Although we can’t detect a 250 LY bubble, it will
    be interesting to see what the odds would be if we could.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们真正要探讨的是为什么*我们*还没有发现外星人，因此你应该假设，对于这个项目，其他文明的技术水平类似于我们自己。另一个假设是，像我们一样，所有外星人都具有偏执的行星意识，并且没有广播“我们在这里”的信号来宣布它们的存在。调查从当前可检测到的气泡稍小到比我们自身传输稍大的气泡大小应该是一个合理的起点。这将建议一个直径范围在30到250光年之间。尽管我们无法检测到250光年的气泡，但如果能够检测到，那会很有趣，看看几率是多少。
- en: '**Generating a Formula for the Probability of Detection**'
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**生成检测概率的公式**'
- en: As the number of advanced civilizations in the galaxy increases, the probability
    that one will detect another also increases. This is intuitive, but how do you
    assign the actual probabilities?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 随着银河系中先进文明数量的增加，检测到其他文明的概率也会增加。这是直观的，但如何分配实际的概率呢？
- en: The nice thing about computers is that they allow us to brute-force our way
    to solutions that may or may not be intuitive. One approach here would be to make
    a 3D model of the Milky Way disc, randomly distribute civilizations throughout,
    and measure the distances between them using one of Python’s many tools for calculating
    Euclidian distance. But with potentially hundreds of millions of civilizations
    to analyze, this method would be computationally expensive.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的一个好处是它们允许我们通过蛮力寻找解决方案，这些解决方案可能直观也可能不直观。这里的一种方法是制作一个银河系盘面的三维模型，随机分布文明，并使用Python的多个工具计算欧几里得距离来测量它们之间的距离。但由于可能需要分析数亿个文明，这种方法在计算上会非常昂贵。
- en: Since we’re dealing with huge unknowns, there’s no need to be super-accurate
    or precise. We just want to be in the ballpark, so an easy simplification is to
    compartmentalize the galaxy into a series of radio bubble “equivalent volumes”
    by dividing the volume of the galactic disc by the volume of a radio bubble (see
    [Figure 10-3](ch10.xhtml#ch10fig3)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处理的是巨大的未知数，因此无需非常精确或准确。我们只需要大致估算，所以一个简单的简化方法是将银河系分割成一系列无线电气泡的“等效体积”，通过将银河圆盘的体积除以无线电气泡的体积来实现（请参见[图
    10-3](ch10.xhtml#ch10fig3)）。
- en: '![image](../images/f0192-01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0192-01.jpg)'
- en: '*Figure 10-3: Modeling the galaxy using cubes with volumes equivalent to a
    200 LY radio bubble*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-3: 使用体积等于200光年无线电气泡的立方体来建模银河系*'
- en: 'You can find the volumes using the following equations, where *R* is the radius
    of the galactic disc and *r* is the radius of a radio bubble:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下方程来找到体积，其中 *R* 是银河圆盘的半径，*r* 是无线电气泡的半径：
- en: disc volume = π × *R*² × disc height
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 圆盘体积 = π × *R*² × 圆盘高度
- en: radio bubble volume = 4/3 × π × *r*³
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 无线电气泡体积 = 4/3 × π × *r*³
- en: scaled disc volume = disc volume / radio bubble volume
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放圆盘体积 = 圆盘体积 / 无线电气泡体积
- en: The scaled disc volume is the number of equivalent volumes that “fit” in the
    galaxy. Think of these as boxes numbered from 1 to the maximum number of volumes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放圆盘体积是能够“容纳”在银河系中的等效体积数量。可以将这些看作是从1到最大体积数量的编号箱子。
- en: To place civilizations, you simply choose a box number at random. Duplicate
    picks indicate multiple civilizations within the same box. Assume civilizations
    in the same box can detect each other. This isn’t strictly true (see [Figure 10-4](ch10.xhtml#ch10fig4)),
    but because you’ll be using large numbers of civilizations, the discrepancies
    will tend to cancel each other out, just as when you sum a lot of rounded numbers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要放置文明，您只需随机选择一个箱子编号。重复选择表示同一个箱子内有多个文明。假设同一箱子中的文明可以彼此检测到。虽然这并不完全正确（请参见[图 10-4](ch10.xhtml#ch10fig4)），但由于您将使用大量文明，这些差异通常会相互抵消，就像对很多四舍五入的数字求和时一样。
- en: '![image](../images/f0193-01.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0193-01.jpg)'
- en: '*Figure 10-4: Detection problems at the individual equivalent volume level*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-4: 在个体等效体积级别上的检测问题*'
- en: 'To avoid having to repeat this exercise every time you change the number of
    civilizations and/or radio bubble dimensions, you can capture the results as a
    formula—a *polynomial equation*—that can be used to generate all future probability
    estimates. A *polynomial* is the sum or difference of a collection of algebraic
    terms. The famous *quadratic equation* we all learned in school is a polynomial
    equation of the second degree (meaning that the exponents of the variables are
    no greater than 2):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免每次更改文明数量和/或无线电气泡维度时都需要重复此操作，您可以将结果作为公式—一个*多项式方程*—来捕获，这样就可以用来生成所有未来的概率估算。*多项式*是代数项的加法或减法。我们在学校学过的著名的*二次方程*就是一个二次多项式方程（意味着变量的指数不大于2）：
- en: '*ax*² + *bx* + *c* = 0'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*ax*² + *bx* + *c* = 0'
- en: Polynomials make nice curves, so they’re tailor-made for this problem. But for
    the formula to work with variable numbers of civilizations and bubble sizes, you’ll
    need to use the *ratio* of the number of civilizations to the total volume. The
    total volume is represented by the scaled disc volume, which is the same as the
    total number of equivalent volumes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式形成了美丽的曲线，因此它们非常适合这个问题。但为了让这个公式适用于变动的文明数量和气泡大小，您需要使用文明数量与总体积的*比率*。总体积由缩放后的圆盘体积表示，它与等效体积的总和相同。
- en: In [Figure 10-5](ch10.xhtml#ch10fig5), each dot represents the probability of
    detection for the ratio below it. The equation shown in the figure is the polynomial
    expression, which generates the line connecting the dots. With this formula, you
    can predict the probability for any ratio of civilizations per volume, up to a
    value of 5 (above this, we’ll just assume the probability is 1.0).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 10-5](ch10.xhtml#ch10fig5)中，每个点代表与其下方比率对应的检测概率。图中的方程是多项式表达式，它生成连接这些点的曲线。使用这个公式，您可以预测任何每体积文明数量比率的概率，直到比率值为5（超过此值时，我们假设概率为1.0）。
- en: '![image](../images/f0194-01.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0194-01.jpg)'
- en: '*Figure 10-5: Probability of detection versus ratio of number of civilizations
    to scaled galactic volume*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-5: 检测概率与文明数量与缩放银河体积比率的关系*'
- en: In [Figure 10-5](ch10.xhtml#ch10fig5), the civilizations-to-volume ratios are
    posted on the x-axis. A ratio of 0.5, for example, means that there are half as
    many civilizations as available radio bubble equivalent volumes, a ratio of 2
    means there are twice as many civilizations as volumes, and so on. The y-axis
    is the probability that an equivalent volume contains more than one civilization.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图10-5](ch10.xhtml#ch10fig5)中，文明与体积的比率显示在x轴上。例如，比率为0.5意味着文明数量是可用的无线电气泡等效体积的一半，比率为2意味着文明数量是体积的两倍，以此类推。y轴表示一个等效体积包含多个文明的概率。
- en: Another thing to note from [Figure 10-5](ch10.xhtml#ch10fig5) is that it takes
    a lot of civilizations to ensure that they all have a roommate. Imagine that 999,999
    out of 1,000,000 equivalent volumes contain at least two civilizations and you
    use your God-like powers to randomly place one new civilization. The odds are
    one in a million that this new civilization will end up in the remaining volume
    with a single occupant. That last equivalent volume is the proverbial needle in
    the haystack!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从[图10-5](ch10.xhtml#ch10fig5)中还可以注意到，要确保每个文明都有伴侣，文明的数量需要非常多。假设在1000000个等效体积中，999999个包含至少两个文明，而你用神一样的力量随机放置一个新的文明。这个新文明有100万分之一的概率会落入剩下的那个只有一个居民的体积。那个最后的等效体积，正如俗话所说，是“大海捞针”！
- en: '**NOTE**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*An axiom of computer modeling is to start simple and add complexity. The simplest
    “base case” assumption is that advanced civilizations are randomly distributed
    throughout the galaxy. In “[Challenge Projects](ch10.xhtml#lev246)” on [page 214](ch10.xhtml#page_214),
    you’ll get a chance to challenge this assumption using the concept of galactic
    habitable zones.*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算机建模的一个公理是从简单开始，逐步增加复杂性。最简单的“基础假设”是高级文明在银河系中随机分布。在[第214页](ch10.xhtml#page_214)的“[挑战项目](ch10.xhtml#lev246)”中，你将有机会使用银河宜居区的概念来挑战这一假设。*'
- en: '**The Probability-of-Detection Code**'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**检测概率代码**'
- en: The probability-of-detection code randomly chooses locations (radio bubble equivalent
    volumes) for a set number of locations and civilizations, counts how many locations
    occur only once (that is, contain only one civilization), and repeats the experiment
    multiple times to converge on a probability estimate. The process is then repeated
    for a new number of civilizations. The output is presented as probability versus
    the *ratio* of civilizations per volume, rather than the actual number of civilizations,
    and turned into a polynomial expression so that the results are easily portable.
    This means this program only needs to be run once.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 检测概率代码随机选择位置（无线电气泡等效体积）用于设定的地点和文明数量，计算仅出现一次的位置数（即只包含一个文明的位置），并重复多次实验以收敛到一个概率估计值。然后对于新的文明数量，重复该过程。输出结果是概率与每个体积的*文明比率*的关系，而不是文明的实际数量，并将其转换为多项式表达式，使结果便于传输。这意味着该程序只需要运行一次。
- en: To generate the polynomial equation and check that it fits the data, you’ll
    use NumPy and matplotlib. The NumPy library adds support for large, multidimensional
    arrays and matrices, and it includes many mathematical functions that operate
    on them. The matplotlib library supports 2D plotting and rudimentary 3D plotting,
    and NumPy represents its numerical mathematics extension.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成多项式方程并检查其是否符合数据，你将使用NumPy和matplotlib。NumPy库支持大型多维数组和矩阵，并包括许多对其操作的数学函数。matplotlib库支持2D绘图和基础的3D绘图，NumPy则是其数值数学扩展。
- en: There are several ways to install these scientific Python distributions. One
    way is to use SciPy, an open source Python library used for scientific and technical
    computing (see *[https://scipy.org/index.html](https://scipy.org/index.html)*).
    If you’re going to do a lot of data analysis and plotting, you may want to download
    and use a free package like Anaconda or Enthought Canopy, which works with Windows,
    Linux, and macOS. These packages spare you the task of finding and installing
    all the required data science libraries in the correct version. A listing of these
    types of packages, along with links to their websites, can be found at *[https://scipy.org/install.html](https://scipy.org/install.html)*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 安装这些科学 Python 发行版有几种方式。一种方法是使用 SciPy，这是一个用于科学和技术计算的开源 Python 库（见 *[https://scipy.org/index.html](https://scipy.org/index.html)*）。如果你要进行大量的数据分析和绘图，可能想要下载并使用一个免费的包，如
    Anaconda 或 Enthought Canopy，这些工具可以在 Windows、Linux 和 macOS 上使用。这些包可以帮你避免寻找并安装所有必要的数据科学库的麻烦，它们也会确保安装的是正确版本。可以在
    *[https://scipy.org/install.html](https://scipy.org/install.html)* 找到这些包的列表及其网站链接。
- en: 'Alternatively, you may want to download the products directly, using pip. I
    did this using the instructions at *[https://scipy.org/install.html](https://scipy.org/install.html)*.
    Because matplotlib requires a large number of dependencies, these need to be installed
    at the same time. For Windows, I ran the following Python 3–specific command from
    the PowerShell, launched from within my *Python35* folder (you can leave off the
    *3* in *python3* unless you have multiple versions installed):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你也可以直接使用 pip 下载产品。我就是通过 *[https://scipy.org/install.html](https://scipy.org/install.html)*
    上的说明进行操作的。由于 matplotlib 需要大量依赖项，因此这些依赖项需要同时安装。对于 Windows，我从 PowerShell 运行了以下 Python
    3 特定命令，PowerShell 是从我的 *Python35* 文件夹中启动的（除非你安装了多个版本的 Python，否则可以省略 *python3*
    中的 *3*）：
- en: $ python3 -m pip install --user numpy scipy matplotlib ipython jupyter pandas
    sympy nose
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: $ python3 -m pip install --user numpy scipy matplotlib ipython jupyter pandas
    sympy nose
- en: All the other modules you’ll need come bundled with Python. As for the code
    in [Listings 10-1](ch10.xhtml#ch10list1) and [10-2](ch10.xhtml#ch10list2), you
    can type it in or download a copy from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要的其他模块都已捆绑在 Python 中。至于 [列表 10-1](ch10.xhtml#ch10list1) 和 [10-2](ch10.xhtml#ch10list2)
    中的代码，你可以手动输入或从 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载副本。
- en: '***Calculating Probability of Detection for a Range of Civilizations***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计算不同文明数量的探测概率***'
- en: '[Listing 10-1](ch10.xhtml#ch10list1) imports modules and does all the work
    just described except for fitting the polynomial and displaying the matplotlib
    quality check.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10-1](ch10.xhtml#ch10list1) 导入模块并完成刚才描述的所有工作，除了拟合多项式和显示 matplotlib 的质量检查。'
- en: '*probability_of_detection.py,* part 1'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*probability_of_detection.py,* 第 1 部分'
- en: ➊ from random import randint
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ from random import randint
- en: from collections import Counter
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: from collections import Counter
- en: import numpy as np
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: import matplotlib.pyplot as plt
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: import matplotlib.pyplot as plt
- en: ➋ NUM_EQUIV_VOLUMES = 1000  # number of locations in which to place civilizations
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ NUM_EQUIV_VOLUMES = 1000  # 放置文明的位置数量'
- en: MAX_CIVS = 5000  # maximum number of advanced civilizations
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 'MAX_CIVS = 5000  # 高级文明的最大数量'
- en: TRIALS = 1000  # number of times to model a given number of civilizations
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 'TRIALS = 1000  # 模拟给定文明数量的次数'
- en: CIV_STEP_SIZE = 100  # civilizations count step size
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 'CIV_STEP_SIZE = 100  # 文明数量步长'
- en: ➌ x = []  # x values for polynomial fit
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ x = []  # 用于多项式拟合的 x 值'
- en: y = []  # y values for polynomial fit
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 'y = []  # 用于多项式拟合的 y 值'
- en: '➍ for num_civs in range(2, MAX_CIVS + 2, CIV_STEP_SIZE):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ 对于 num_civs 从 2 遍历到 MAX_CIVS + 2，步长为 CIV_STEP_SIZE:'
- en: civs_per_vol = num_civs / NUM_EQUIV_VOLUMES
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: civs_per_vol = num_civs / NUM_EQUIV_VOLUMES
- en: num_single_civs = 0
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: num_single_civs = 0
- en: '➎ for trial in range(TRIALS):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ 对于每次试验，遍历范围(TRIALS):'
- en: locations = []  # equivalent volumes containing a civilization
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 'locations = []  # 包含文明的等效体积'
- en: '➏ while len(locations) < num_civs:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '➏ 当 locations 的长度小于 num_civs 时:'
- en: location = randint(1, NUM_EQUIV_VOLUMES)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: location = randint(1, NUM_EQUIV_VOLUMES)
- en: locations.append(location)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: locations.append(location)
- en: ➐ overlap_count = Counter(locations)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ overlap_count = Counter(locations)
- en: overlap_rollup = Counter(overlap_count.values())
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: overlap_rollup = Counter(overlap_count.values())
- en: num_single_civs += overlap_rollup[1]
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: num_single_civs += overlap_rollup[1]
- en: ➑ prob = 1 - (num_single_civs / (num_civs * TRIALS))
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ prob = 1 - (num_single_civs / (num_civs * TRIALS))
- en: '# print ratio of civs-per-volume vs. probability of 2+ civs per location'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打印每个体积中的文明数与每个位置出现 2 个以上文明的概率之比'
- en: ➒ print("{:.4f}  {:.4f}".format(civs_per_vol, prob))
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ print("{:.4f}  {:.4f}".format(civs_per_vol, prob))
- en: ➓ x.append(civs_per_vol)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ➓ x.append(civs_per_vol)
- en: y.append(prob)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: y.append(prob)
- en: '*Listing 10-1: Imports modules, randomly chooses radio-bubble-equivalent-volume
    locations, and calculates the probability of multiple civilizations per location*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-1：导入模块，随机选择无线电泡沫等效体积的位置，并计算每个位置的多个文明的概率*'
- en: Import the familiar random module and Counter, for counting the number of civilizations
    at each location (designated by how many times a location has been chosen) ➊.
    How Counter works will be explained in a moment. You’ll use the NumPy and matplotlib
    imports to fit and display the polynomial.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 导入熟悉的 random 模块和 Counter，用于计算每个位置的文明数量（由位置被选择的次数表示） ➊。稍后将解释 Counter 如何工作。你将使用
    NumPy 和 matplotlib 导入来拟合并显示多项式。
- en: Assign some constants that represent user input for the number of equivalent
    volumes, the maximum number of civilizations, the number of trials—that is, how
    many times to repeat the experiment for a given number of civilizations—and a
    step size for the count ➋. Because the results are predictable, you can use a
    large step value of 100 without compromising accuracy. Note that you’ll get very
    similar results whether the number of equivalent volumes is 100 or 100,000+.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 分配一些常量来表示用户输入的等效体积数量、最大文明数量、实验次数——即，在给定数量的文明下实验重复多少次——以及计数的步长 ➋。由于结果是可预测的，你可以使用较大的步长值
    100，而不影响准确性。请注意，无论等效体积数量是 100 还是 100,000+，你将得到非常相似的结果。
- en: You’ll need a series of paired (*x*, *y*) values for the polynomial expression,
    so start two lists to hold these ➌. The x-value will be the ratio of civilizations
    per volume, and the y-value will be the corresponding probability of detection.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一系列配对的 (*x*, *y*) 值来表示多项式表达式，因此启动两个列表来保存这些 ➌。x 值将是每个体积中的文明比率，而 y 值将是相应的探测概率。
- en: Start a series of nested loops, with the highest loop representing the number
    of civilizations to model ➍. You need at least two civilizations for one to detect
    the other, and set the maximum to MAX_CIVS plus 2, to overshoot when calculating
    the polynomial. Use the CIV_STEP_SIZE constant for the step value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一系列嵌套循环，最外层循环表示要建模的文明数量 ➍。至少需要两个文明才能彼此探测，并将最大值设置为 MAX_CIVS 加 2，以便在计算多项式时超出预期。使用
    CIV_STEP_SIZE 常量作为步长值。
- en: Next, calculate the overall civs_per_vol ratio and start a counter named num_single_civs
    to keep track of the number of locations containing a single civilization.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，计算整体的 civs_per_vol 比率，并启动一个名为 num_single_civs 的计数器来跟踪包含单一文明的地点数量。
- en: You’ve chosen how many civilizations to distribute, so now use a for loop to
    go through the number of trials ➎. For each trial, you distribute the same number
    of civilizations. Assign an empty list to the variable locations and then, for
    each civilization ➏, pick a location number at random and append it to the list.
    Duplicate values in the list will represent locations containing multiple civilizations.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经选择了要分配多少个文明，现在使用 for 循环遍历实验次数 ➎。对于每次实验，分配相同数量的文明。将一个空列表分配给变量 locations，然后对于每个文明
    ➏，随机选择一个地点编号并将其添加到列表中。列表中的重复值将表示包含多个文明的位置。
- en: 'Run Counter on this list ➐ and get the values. End the loop by getting the
    number of locations that occur only once and add them to the num_single_civs counter.
    Here’s an example of how these three statements work:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表 ➐ 上运行 Counter 并获取值。通过获取只出现一次的地点数量并将它们加到 num_single_civs 计数器中来结束循环。以下是这三个语句如何工作的示例：
- en: '>>> from collections import Counter'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from collections import Counter'
- en: '>>> alist = [124, 452, 838, 124, 301]'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> alist = [124, 452, 838, 124, 301]'
- en: '>>> count = Counter(alist)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> count = Counter(alist)'
- en: '>>> count'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> count'
- en: 'Counter({124: 2, 452: 1, 301: 1, 838: 1})'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 'Counter({124: 2, 452: 1, 301: 1, 838: 1})'
- en: '>>> value_count = Counter(count.values())'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> value_count = Counter(count.values())'
- en: '>>> value_count'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> value_count'
- en: 'Counter({1: 3, 2: 1})'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 'Counter({1: 3, 2: 1})'
- en: '>>> value_count[1]'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> value_count[1]'
- en: '3'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: The alist list contains five numbers, with one (124) duplicated. Running Counter
    on this list produces a dictionary with the numbers as the keys and the number
    of times they occur as the values. Passing Counter the values in count—with the
    values() method—creates another dictionary with the previous values as keys and
    the number of times they occur as the new values. You want to know how many numbers
    occur only once, so use the dictionary method value_count[1] to return the number
    of nonduplicated numbers. These, of course, would represent radio-bubble-equivalent
    volumes containing a single civilization.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: alist 列表包含五个数字，其中一个（124）重复。在此列表上运行 Counter 会生成一个字典，数字作为键，数字出现的次数作为值。将 count
    中的值传递给 Counter——通过 values() 方法——会创建另一个字典，之前的值作为键，出现次数作为新的值。你需要知道有多少个数字只出现一次，因此可以使用字典方法
    value_count[1] 来返回没有重复的数字个数。这些数字当然代表了包含单一文明的无线电气泡等效体积。
- en: Now use the results from Counter to calculate the probability of multiple civilizations
    per location for the current number of civilizations being distributed ➑. This
    is 1 minus the number of single-occupancy locations divided by the number of civilizations
    in each trial times the number of trials.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用来自 Counter 的结果，计算每个位置上多个文明的概率，以当前文明数量为基础进行分布 ➑。这个值为 1 减去单一占据位置的数量，除以每次试验中的文明数量，再乘以试验次数。
- en: 'Follow this by printing the ratio of civilizations to volume and the probability
    that multiple civilizations share a location ➒. The first few lines of this output
    are as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来打印文明与体积的比率，以及多个文明共享一个位置的概率 ➒。以下是此输出的前几行：
- en: 0.0020  0.0020
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 0.0020  0.0020
- en: 0.1020  0.0970
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 0.1020  0.0970
- en: 0.2020  0.1832
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 0.2020  0.1832
- en: 0.3020  0.2607
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 0.3020  0.2607
- en: 0.4020  0.3305
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 0.4020  0.3305
- en: 0.5020  0.3951
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 0.5020  0.3951
- en: 0.6020  0.4516
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 0.6020  0.4516
- en: 0.7020  0.5041
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 0.7020  0.5041
- en: This printout serves as an initial QC step and is optional; comment it out if
    you want to speed up the runtime. Finish by appending the values to the x and
    y lists ➓.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出作为初步 QC 步骤，是可选的；如果你想加快运行速度，可以将其注释掉。最后，将这些值附加到 x 和 y 列表 ➓。
- en: '***Generating a Predictive Formula and Checking the Results***'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***生成预测公式并检查结果***'
- en: '[Listing 10-2](ch10.xhtml#ch10list2) uses NumPy to perform polynomial regression
    on the probability of detection versus the ratio of civilizations per volume calculated
    in [Listing 10-1](ch10.xhtml#ch10list1). You’ll use this polynomial equation in
    the next program to obtain probability estimates. To check that the resulting
    curve fits the data points, matplotlib displays the actual and predicted values.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-2](ch10.xhtml#ch10list2) 使用 NumPy 对检测概率与每单位体积中文明比率进行多项式回归，这些比率在 [清单
    10-1](ch10.xhtml#ch10list1) 中进行了计算。你将在下一个程序中使用此多项式方程来获取概率估计。为了检查结果曲线是否与数据点拟合，matplotlib
    会显示实际值和预测值。'
- en: '*probability_of_detection.py,* part 2'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*probability_of_detection.py,* 第 2 部分'
- en: ➊ coefficients = np.polyfit(x, y, 4)  # 4th order polynomial fit
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ coefficients = np.polyfit(x, y, 4)  # 4 次多项式拟合'
- en: ➋ p = np.poly1d(coefficients)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ p = np.poly1d(coefficients)
- en: print("\n{}".format(p))
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: print("\n{}".format(p))
- en: ➌ xp = np.linspace(0, 5)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ xp = np.linspace(0, 5)
- en: ➍ _ = plt.plot(x, y, '.', xp, p(xp), '-')
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ _ = plt.plot(x, y, '.', xp, p(xp), '-')
- en: ➎ plt.ylim(-0.5, 1.5)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ plt.ylim(-0.5, 1.5)
- en: ➏ plt.show()
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ plt.show()
- en: '*Listing 10-2: Performs polynomial regression and displays a QC plot*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-2：执行多项式回归并显示 QC 图*'
- en: Start by assigning a variable, coefficients, to the output from the NumPy polyfit()
    method ➊. This method takes as arguments the x and y lists and an integer representing
    the degree of the fitting polynomial. It returns a vector of coefficients, p,
    that minimizes the squared error.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将一个变量 coefficients 赋值为 NumPy polyfit() 方法的输出 ➊。该方法的参数为 x 和 y 列表以及表示拟合多项式次数的整数。它返回一个最小化平方误差的系数向量
    p。
- en: 'If you print the coefficients variable, you get the following output:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打印 coefficients 变量，你将得到如下输出：
- en: '[-0.00475677  0.066811   -0.3605069   0.92146096  0.0082604 ]'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[-0.00475677  0.066811   -0.3605069   0.92146096  0.0082604 ]'
- en: 'To get the full expression, pass the coefficients variable to poly1d and assign
    the results to a new variable ➋. Print this variable, and you’ll see a similar
    equation to that shown in [Figure 10-5](ch10.xhtml#ch10fig5):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得完整的表达式，将 coefficients 变量传递给 poly1d 并将结果赋值给一个新的变量 ➋。打印此变量，你将看到与 [图 10-5](ch10.xhtml#ch10fig5)
    中类似的方程：
- en: 4           3          2
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 4           3          2
- en: -0.004757 x + 0.06681 x - 0.3605 x + 0.9215 x + 0.00826
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: -0.004757 x + 0.06681 x - 0.3605 x + 0.9215 x + 0.00826
- en: To check that the polynomial adequately reproduces the input, you’ll want to
    plot the ratio of civilizations to volume on the x-axis, with probability on the
    y-axis. To get the x-axis values, you can use the NumPy linspace() method, which
    returns evenly spaced numbers over a specified interval. Use a range of (0, 5),
    as this will cover almost the full probability range.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: To post symbols for the calculated and predicted values, first pass the plot()
    method the x and y lists, plotting them using a period (dot), which is equivalent
    to the dots in [Figure 10-5](ch10.xhtml#ch10fig5) ➍. Then pass the predicted x-axis
    values (xp) and, to get the predicted y-axis probability, pass p the same variable,
    plotting the results using a dash.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Finish by limiting the y-axis to values of –0.5 and 1.5 ➎ and use the show()
    method to actually display the graph ([Figure 10-6](ch10.xhtml#ch10fig6)) ➏. The
    resultant plot is simple and sparse, as its only purpose is to confirm that the
    polynomial regression is working as intended. You can alter the polynomial fit
    by increasing or decreasing the third argument in step ➊.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0199-01.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-6: Calculated results (dots) versus results predicted by the polynomial
    (line)*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Armed with these results, you can now estimate the probability of detection
    for any number of civilizations in the blink of an eye. All Python needs to do
    is solve a polynomial equation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '**Building the Graphical Model**'
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The graphical model will be a 2D, top-down view of the galactic disc. Plotting
    the size of Earth’s present emissions bubble on this display will put in perspective
    both the size of the galaxy and our diminutive place within it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Modeling the Milky Way is all about modeling the spiral arms. Each spiral arm
    represents a *logarithmic spiral*, a geometric feature so common in nature it
    has been dubbed *spira mirabilis*—“miraculous spiral.” If you compare [Figure
    10-7](ch10.xhtml#ch10fig7) to [Figure 10-1](ch10.xhtml#ch10fig1), you can see
    how closely the structure of a hurricane resembles that of a galaxy. The eye of
    the hurricane can even be thought of as a supermassive black hole, with the eyewall
    representing the event horizon!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0199-02.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-7: Hurricane Igor*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Because spirals radiate out from a central point, or *pole*, you’ll more easily
    graph them with *polar coordinates* ([Figure 10-8](ch10.xhtml#ch10fig8)). With
    polar coordinates, the (*x*, *y*) coordinates used in the more familiar Cartesian
    coordinate system are replaced by (*r*, θ), where *r* is the distance from the
    center and θ is the angle made by *r* and the x-axis. The coordinates for the
    pole are (0, 0).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0200-01.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-8: Example polar coordinate system*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'The polar equation for a logarithmic spiral is:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '*r* = *ae*^(bθ)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: where *r* is the distance from the origin, θ is the angle from the x-axis, *e*
    is the base of natural logarithms, and *a* and *b* are arbitrary constants.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: You can use this formula to draw a single spiral; then, rotate and redraw the
    spiral three times to produce the four arms of the Milky Way. You’ll build the
    spirals out of circles of various sizes, which will represent stars. [Figure 10-9](ch10.xhtml#ch10fig9)
    is an example of one realization of the graphical model. Because the simulations
    are stochastic, each will be slightly different, and there are multiple variables
    you can tweak to change the appearance.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个公式绘制一个单独的螺旋线；然后，旋转并重新绘制螺旋线三次，来形成银河的四条臂。你将用不同大小的圆圈来构建螺旋，这些圆圈代表恒星。[图 10-9](ch10.xhtml#ch10fig9)是图形模型实现的一个例子。由于模拟是随机的，每次都会略有不同，并且有多个变量可以调整以改变外观。
- en: '![image](../images/f0200-02.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0200-02.jpg)'
- en: '*Figure 10-9: The Milky Way, modeled using logarithmic spirals*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-9：使用对数螺旋模型的银河系*'
- en: I generated the image in [Figure 10-9](ch10.xhtml#ch10fig9) with tkinter (pronounced
    “tee-kay-inter”), the default GUI library for developing desktop applications
    in Python. Although primarily designed for GUI elements such as windows, buttons,
    scroll bars, and so on, tkinter can also generate graphs, charts, screensavers,
    simple games, and more. Among its advantages is that, as part of the standard
    Python distribution, it’s portable across all operating systems and there’s no
    need to install external libraries. It’s also well documented and easy to use.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 [图 10-9](ch10.xhtml#ch10fig9) 中生成的图像使用了 tkinter（发音为“tee-kay-inter”），它是用于开发
    Python 桌面应用程序的默认 GUI 库。虽然 tkinter 主要用于开发 GUI 元素，如窗口、按钮、滚动条等，但它也可以生成图表、屏幕保护程序、简单的游戏等。它的优势之一是，作为标准
    Python 发行版的一部分，它能够跨所有操作系统运行，并且不需要安装额外的库。它还有良好的文档和易于使用的特点。
- en: 'Most Windows, macOS, and Linux machines come with tkinter already installed.
    If you don’t have it or need the latest version, you can download and install
    it from *[https://www.activestate.com/](https://www.activestate.com/)*. As always,
    if the module is already installed, you should be able to import it in the interpreter
    window with no errors:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Windows、macOS 和 Linux 机器都已预装 tkinter。如果你没有安装或者需要最新版本，可以从 *[https://www.activestate.com/](https://www.activestate.com/)*
    下载并安装它。和往常一样，如果模块已经安装，你应该可以在解释器窗口中正常导入而不出现错误：
- en: '>>> import tkinter'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> import tkinter'
- en: '>>>'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '>>>'
- en: Introductory Python books sometimes include overviews of tkinter, and you can
    find the official online documentation at *[https://docs.python.org/3/library/tk.html](https://docs.python.org/3/library/tk.html)*.
    Some other references on tkinter are included in “[Further Reading](ch10.xhtml#lev241)”
    on [page 212](ch10.xhtml#page_212).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一些入门级的 Python 书籍中会包括 tkinter 的概述，你可以在 *[https://docs.python.org/3/library/tk.html](https://docs.python.org/3/library/tk.html)*
    找到官方在线文档。关于 tkinter 的一些其他参考资料可在“[进一步阅读](ch10.xhtml#lev241)”中找到，位于 [第 212 页](ch10.xhtml#page_212)。
- en: '***Scaling the Graphical Model***'
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***缩放图形模型***'
- en: 'The scale of the graphical model is in light-years per pixel, and the width
    of each pixel will equate to the diameter of a radio bubble. As a result, when
    the radio bubble being investigated changes diameter, the scale units will change,
    and the graphical model will need to be rebuilt. The following equation will scale
    the model to the bubble:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图形模型的尺度单位是每像素光年，每个像素的宽度等于一个射电气泡的直径。因此，当研究中的射电气泡直径发生变化时，尺度单位也会变化，图形模型需要重新构建。以下方程将根据气泡调整模型的尺度：
- en: scaled disc radius = disc radius / bubble diameter
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放盘半径 = 盘半径 / 气泡直径
- en: where the disc radius is 50,000 and the length unit is light-years.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，盘半径为 50,000，长度单位为光年。
- en: When the selected radio bubble is small, the graphical model “zooms in,” and
    when it is large, it “zooms out” ([Figure 10-10](ch10.xhtml#ch10fig10)).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择的射电气泡较小时，图形模型会“放大”，而当它较大时，模型会“缩小”（[图 10-10](ch10.xhtml#ch10fig10)）。
- en: '![image](../images/f0201-01.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0201-01.jpg)'
- en: '*Figure 10-10: Impact of radio bubble diameter on the appearance of the galactic
    model*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-10：射电气泡直径对银河模型外观的影响*'
- en: '***The Galaxy Simulator Code***'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***银河模拟器代码***'
- en: The galaxy simulator code will calculate the probability of detection for any
    number of civilizations and radio bubble sizes, and then generate a graphical
    model of the galaxy. When a bubble the size of our current emissions bubble is
    used, it will post and annotate our bubble in red, in the approximate location
    of our solar system. You can download the code from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 银河模拟器代码将计算任何数量的文明和电波气泡大小的检测概率，然后生成银河系的图形模型。当使用与我们当前排放气泡大小相同的气泡时，它将在大致位置标出我们的气泡，并以红色注释，标示出大致太阳系的位置。你可以从*
    [https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载代码。
- en: '**Entering Inputs and Key Parameters**'
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**输入数据和关键参数**'
- en: '[Listing 10-3](ch10.xhtml#ch10list3) starts *galaxy_simulator.py* by importing
    modules and putting the frequently accessed user input near the top.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-3](ch10.xhtml#ch10list3) 通过导入模块并将常用的用户输入放在顶部来启动 *galaxy_simulator.py*。'
- en: '*galaxy_simulator.py,* part 1'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*galaxy_simulator.py，* 第 1 部分'
- en: ➊ import tkinter as tk
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ import tkinter as tk
- en: from random import randint, uniform, random
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 从 random 导入 randint、uniform、random
- en: import math
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 导入数学模块
- en: '#============================================================================='
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '#============================================================================='
- en: '➋ # MAIN INPUT'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ # 主要输入'
- en: '# scale (radio bubble diameter) in light-years:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '# 比例（电波气泡直径，单位光年）：'
- en: ➌ SCALE = 225  # enter 225 to see Earth's radio bubble
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ SCALE = 225  # 输入 225 查看地球的电波气泡'
- en: '# number of advanced civilizations from the Drake equation:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '# 根据德雷克方程计算的高级文明数量：'
- en: ➍ NUM_CIVS = 15600000
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ NUM_CIVS = 15600000
- en: '#============================================================================='
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '#============================================================================='
- en: '*Listing 10-3: Imports modules and assigns constants*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-3：导入模块并分配常量*'
- en: Import tkinter as tk, so you don’t have to type the full name when calling tkinter
    classes ➊. If you’re using Python 2, use Tkinter—with an uppercase *T*. You’ll
    also need the random and math modules.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 tkinter 为 tk，这样在调用 tkinter 类时就不必输入全名 ➊。如果你使用的是 Python 2，应该使用 Tkinter（注意 *T*
    大写）。你还需要 random 和 math 模块。
- en: Use a comment to highlight the main user-input section ➋ and assign the two
    inputs. Use SCALE for the diameter, in light-years, of the detectable electromagnetic
    bubble around each civilization ➌; NUM_CIVS is the number of civilizations to
    model, which you can determine using anything from the Drake equation to a total
    guess ➍.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用注释突出显示主要的用户输入部分 ➋ 并分配两个输入。使用 SCALE 表示可以探测到的电磁气泡的直径（单位：光年），即每个文明周围的可探测电磁气泡
    ➌；NUM_CIVS 是要建模的文明数量，你可以通过德雷克方程或者完全猜测来确定 ➍。
- en: '**Setting Up the tkinter Canvas and Assigning Constants**'
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**设置 tkinter 画布并分配常量**'
- en: The code in [Listing 10-4](ch10.xhtml#ch10list4) instantiates a tkinter window
    object with a canvas on which you can draw things. This is where the galaxy map,
    or graphical model, will appear. It also assigns constants related to the dimensions
    of the Milky Way.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-4](ch10.xhtml#ch10list4)中的代码实例化了一个 tkinter 窗口对象，并在其上创建一个画布，你可以在上面绘制内容。这就是银河地图或图形模型将展示的地方。它还分配了与银河系尺寸相关的常量。'
- en: '*galaxy_simulator.py,* part 2'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*galaxy_simulator.py，* 第 2 部分'
- en: '# set up display canvas'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置显示画布'
- en: ➊ root = tk.Tk()
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ root = tk.Tk()
- en: root.title("Milky Way galaxy")
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: root.title("银河系")
- en: ➋ c = tk.Canvas(root, width=1000, height=800, bg='black')
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ c = tk.Canvas(root, width=1000, height=800, bg='black')
- en: ➌ c.grid()
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ c.grid()
- en: ➍ c.configure(scrollregion=(-500, -400, 500, 400))
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ c.configure(scrollregion=(-500, -400, 500, 400))
- en: '# actual Milky Way dimensions (light-years)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '# 实际的银河系尺寸（光年）'
- en: ➎ DISC_RADIUS = 50000
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ DISC_RADIUS = 50000
- en: DISC_HEIGHT = 1000
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: DISC_HEIGHT = 1000
- en: ➏ DISC_VOL = math.pi * DISC_RADIUS**2 * DISC_HEIGHT
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ DISC_VOL = math.pi * DISC_RADIUS**2 * DISC_HEIGHT
- en: '*Listing 10-4: Sets up* tkinter *window and canvas and assigns constants*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-4：设置* tkinter *窗口和画布并分配常量*'
- en: Start by creating a window with the conventional name root ➊. This is a *top-level*
    window that will hold everything else. In the next line, give the window a title—“Milky
    Way galaxy”—which will appear in the upper left of the window frame (see [Figure
    10-9](ch10.xhtml#ch10fig9) for an example).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个名为 root 的窗口 ➊。这个是一个*顶级*窗口，它将包含其他所有元素。在接下来的代码行中，为窗口设置一个标题——“银河系”——它将在窗口框架的左上角显示（示例见[图
    10-9](ch10.xhtml#ch10fig9)）。
- en: Next, add a component, known as a *widget*, to the root window. *Widget* stands
    for “Windows gadget.” There are 21 core widgets in tkinter, including labels,
    frames, radio buttons, and scroll bars. Assign a Canvas widget to contain all
    the drawing objects ➋. This is a general-purpose widget intended for graphics
    and other complex layouts. Specify the parent window, the screen width and height,
    and the background color. Name the canvas c, for *canvas*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将一个组件，称为*widget*，添加到根窗口中。*Widget* 代表“Windows 小工具”。在 tkinter 中有 21 个核心小工具，包括标签、框架、单选按钮和滚动条。分配一个
    Canvas 小工具来包含所有绘图对象 ➋。这是一个通用的小工具，适用于图形和其他复杂布局。指定父窗口、屏幕宽度和高度以及背景颜色。将画布命名为 c，代表*canvas*。
- en: You can divide the Canvas widget into rows and columns, like a table or spreadsheet.
    Each cell in this grid can hold a different widget, and these widgets can span
    multiple cells. Within a cell, you can align a widget using the STICKY option.
    To manage each widget in a window, you’ll need to use the grid geometry manager.
    Since you’re using only one widget in this project, you don’t need to pass the
    manager anything ➌.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 Canvas 小工具划分为行和列，就像表格或电子表格一样。此网格中的每个单元格可以容纳不同的小工具，这些小工具可以跨越多个单元格。在单元格内，你可以使用
    STICKY 选项对齐小工具。为了管理窗口中的每个小工具，你需要使用 grid 布局管理器。由于在这个项目中你只使用了一个小工具，所以不需要传递任何管理器给它
    ➌。
- en: Finish by configuring the canvas to use a scrollregion ➍. This sets the origin
    coordinates (0, 0) to the center of the canvas. You need this to draw the galaxy’s
    spiral arms with polar coordinates. Without it, the default origin would be the
    top-left corner of the canvas.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，配置画布以使用滚动区域 ➍。这将原点坐标 (0, 0) 设置为画布的中心。你需要这个来用极坐标绘制银河的螺旋臂。如果没有它，默认的原点将是画布的左上角。
- en: The arguments passed to configure set the limits of the canvas. These should
    be half of the canvas width and height; for example, scroll limits of 600, 500
    will require canvas dimensions of 1200, 1000. The values shown here work well
    on a small laptop, but feel free to alter them later if you find you need a larger
    window.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给配置的参数设置了画布的限制。它们应该是画布宽度和高度的一半；例如，滚动限制为 600, 500 时，画布尺寸应为 1200, 1000。这里显示的值在小型笔记本电脑上运行良好，但如果你发现需要更大的窗口，可以稍后更改它们。
- en: Follow the input section with dimensional constants for the galaxy ➎. You could
    assign some of these variables within functions, but having them in the global
    space allows for a more logical flow to the code explanation. The first two are
    the radius and height of the galactic disc from [Figure 10-2](ch10.xhtml#ch10fig2).
    The final constant represents the disc volume ➏.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是跟随输入部分的银河系维度常数 ➎。你可以在函数内分配一些变量，但将它们放在全局空间可以让代码解释的流程更加合理。前两个常数是银河盘的半径和高度，来自[图
    10-2](ch10.xhtml#ch10fig2)。最后一个常数表示盘的体积 ➏。
- en: '**Scaling the Galaxy and Calculating the Probability of Detection**'
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**缩放银河系并计算探测概率**'
- en: '[Listing 10-5](ch10.xhtml#ch10list5) defines functions to scale the galaxy
    dimensions based on the diameter of the radio bubble in use and to calculate the
    probability of one civilization detecting another. The latter function is where
    you apply the polynomial equation built with the *probability_of_detection.py*
    program described previously.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10-5](ch10.xhtml#ch10list5) 定义了基于所使用的无线电气泡直径来缩放银河系尺寸的函数，并计算一个文明探测另一个文明的概率。后者的函数是应用之前描述的*probability_of_detection.py*程序所构建的多项式方程的地方。'
- en: '*galaxy_simulator.py,* part 3'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*galaxy_simulator.py,* 第 3 部分'
- en: '➊ def scale_galaxy():'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def scale_galaxy():'
- en: '"""Scale galaxy dimensions based on radio bubble size (scale)."""'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '"""根据无线电气泡大小（缩放）来缩放银河系尺寸。"""'
- en: disc_radius_scaled = round(DISC_RADIUS / SCALE)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: disc_radius_scaled = round(DISC_RADIUS / SCALE)
- en: ➋ bubble_vol = 4/3 * math.pi * (SCALE / 2)**3
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ bubble_vol = 4/3 * math.pi * (SCALE / 2)**3
- en: ➌ disc_vol_scaled = DISC_VOL/bubble_vol
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ disc_vol_scaled = DISC_VOL/bubble_vol
- en: ➍ return disc_radius_scaled, disc_vol_scaled
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ return disc_radius_scaled, disc_vol_scaled
- en: '➎ def detect_prob(disc_vol_scaled):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ def detect_prob(disc_vol_scaled):'
- en: '"""Calculate probability of galactic civilizations detecting each other."""'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '"""计算银河系文明互相探测的概率。"""'
- en: ➏ ratio = NUM_CIVS / disc_vol_scaled  # ratio of civs to scaled galaxy volume
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '➏ ratio = NUM_CIVS / disc_vol_scaled  # 文明数量与缩放后的银河体积的比率'
- en: ➐ if ratio < 0.002:  # set very low ratios to probability of 0
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '➐ if ratio < 0.002:  # 将非常低的比率设置为概率 0'
- en: detection_prob = 0
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: detection_prob = 0
- en: elif ratio >= 5:  # set high ratios to probability of 1
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 'elif ratio >= 5:  # 将高比率设置为概率 1'
- en: detection_prob = 1
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: detection_prob = 1
- en: '➑ else:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '➑ else:'
- en: detection_prob = -0.004757 * ratio**4 + 0.06681 * ratio**3 - 0.3605 * \
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: detection_prob = -0.004757 * ratio**4 + 0.06681 * ratio**3 - 0.3605 * \
- en: ratio**2 + 0.9215 * ratio + 0.00826
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ratio**2 + 0.9215 * ratio + 0.00826
- en: ➒ return round(detection_prob, 3)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ return round(detection_prob, 3)
- en: '*Listing 10-5: Scales galactic dimensions and calculates detection probability*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-5：缩放银河系尺寸并计算探测概率*'
- en: Define a function called scale_galaxy() to scale the galactic dimensions to
    the radio bubble size ➊. It will use the constants from the global space, so there
    is no need to pass it any arguments. Calculate the scaled disc radius and then
    the radio bubble volume, using the equation for the volume of a sphere, and assign
    the results to bubble_vol ➋.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为scale_galaxy()的函数，用于将银河系的尺寸缩放到电波气泡的大小 ➊。它将使用全局空间中的常量，因此无需传递任何参数。计算缩放后的盘面半径，然后使用球体体积公式计算电波气泡体积，并将结果赋值给bubble_vol
    ➋。
- en: Next, divide the actual disc volume by bubble_vol to get the scaled disc volume
    ➌. This is the number of radio bubble “equivalent volumes” that can fit in the
    galaxy. Each bubble constitutes a possible location for a civilization.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将实际的盘面体积除以bubble_vol，以得到缩放后的盘面体积 ➌。这表示可以容纳在银河系中的电波气泡“等效体积”的数量。每个气泡代表一个可能的文明位置。
- en: End the function by returning the disc_radius_scaled and disc_vol_scaled variables
    ➍.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 通过返回disc_radius_scaled和disc_vol_scaled变量来结束函数 ➍。
- en: Now, define a function called detect_prob() to calculate the probability of
    detection, which takes the scaled disc volume as an argument ➎. For the x term
    in the polynomial, calculate the ratio of the number of civilizations to the scaled
    disc volume ➏. Since the polynomial regression can have problems at the endpoints,
    use conditionals to set very small ratios to 0 and large ratios to 1 ➐. Otherwise,
    apply the polynomial expression generated by the *probability_of_detection.py*
    code ➑, then return the probability rounded to three decimal places ➒.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，定义一个名为detect_prob()的函数，用于计算探测概率，该函数以缩放后的盘面体积作为参数 ➎。对于多项式中的x项，计算文明数量与缩放后的盘面体积的比率
    ➏。由于多项式回归在端点可能存在问题，使用条件语句将非常小的比率设置为0，将大比率设置为1 ➐。否则，应用由*probability_of_detection.py*代码生成的多项式表达式
    ➑，然后返回保留三位小数的概率 ➒。
- en: '**Using Polar Coordinates**'
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用极坐标**'
- en: '[Listing 10-6](ch10.xhtml#ch10list6) defines a function to select random (*x*,
    *y*) locations using polar coordinates. This function will choose the locations
    of some of the stars posted in the graphical model. Because the display is 2D,
    there’s no need to choose a *z* location.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表10-6](ch10.xhtml#ch10list6)定义了一个函数，使用极坐标随机选择(*x*, *y*)位置。这个函数将选择图形模型中一些恒星的位置。由于显示是二维的，所以不需要选择*z*位置。'
- en: '*galaxy_simulator.py,* part 4'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*galaxy_simulator.py*，第4部分'
- en: '➊ def random_polar_coordinates(disc_radius_scaled):'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ 定义函数random_polar_coordinates(disc_radius_scaled):'
- en: '"""Generate uniform random (x, y) point within a disc for 2D display."""'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '"""在盘面内生成均匀随机的(x, y)点，供二维显示使用。"""'
- en: ➋ r = random()
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ r = random()
- en: ➌ theta = uniform(0, 2 * math.pi)
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ theta = uniform(0, 2 * math.pi)
- en: ➍ x = round(math.sqrt(r) * math.cos(theta) * disc_radius_scaled)
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ x = round(math.sqrt(r) * math.cos(theta) * disc_radius_scaled)
- en: y = round(math.sqrt(r) * math.sin(theta) * disc_radius_scaled)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: y = round(math.sqrt(r) * math.sin(theta) * disc_radius_scaled)
- en: ➎ return x, y
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ 返回x，y
- en: '*Listing 10-6: Defines a function to randomly pick an (*x, y*) pair with polar
    coordinates*'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表10-6：定义了一个函数，用于随机选择一个具有极坐标的(*x, y*)对*'
- en: The function takes the scaled disc radius as an argument ➊. Use the random()
    function to choose a float value between 0.0 and 1.0 and assign it to the variable
    r ➋. Next, randomly choose theta from a uniform distribution between 0 and 360
    degrees (2π is the radian equivalent of 360 degrees) ➌.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数以缩放后的盘面半径作为参数 ➊。使用`random()`函数从0.0到1.0之间随机选择一个浮动值，并将其赋值给变量r ➋。接下来，从0到360度之间的均匀分布中随机选择theta（2π是360度的弧度值）
    ➌。
- en: 'The transformation to generate points *evenly* over a *unit* disc is:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 生成均匀分布的点以覆盖*单位*盘面的变换是：
- en: '![image](../images/f0205-01.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0205-01.jpg)'
- en: The equations yield (*x*, *y*) values between -1 and 1\. To scale the results
    to the galactic disc, multiply by the scaled disc radius ➍. End the function by
    returning x and y ➎.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方程产生了介于-1和1之间的(*x*, *y*)值。为了将结果缩放到银河盘面，将其乘以缩放后的盘面半径 ➍。通过返回x和y来结束函数 ➎。
- en: '**Building Spiral Arms**'
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**构建螺旋臂**'
- en: '[Listing 10-7](ch10.xhtml#ch10list7) defines a function that builds the spiral
    arms using the logarithmic spiral equation. This spiral may be miraculous, but
    a large part of the magic is tinkering with the initial bare-bones spiral to flesh
    out the arm. You’ll accomplish this by varying the size of stars, randomly altering
    their positions a tiny amount, and duplicating the spiral for each arm in order
    to shift it slightly backward and dim its stars.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '*galaxy_simulator.py,* part 5'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def spirals(b, r, rot_fac, fuz_fac, arm):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '"""Build spiral arms for tkinter display using logarithmic spiral formula.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: b = arbitrary constant in logarithmic spiral equation
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: r = scaled galactic disc radius
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: rot_fac = rotation factor
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: fuz_fac = random shift in star position in arm, applied to 'fuzz' variable
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: arm = spiral arm (0 = main arm, 1 = trailing stars)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: ➋ spiral_stars = []
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '➌ fuzz = int(0.030 * abs(r)) # randomly shift star locations'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: theta_max_degrees = 520
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: ➍ for i in range(theta_max_degrees):  # range(0, 600, 2) for no black hole
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: theta = math.radians(i)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: x = r * math.exp(b * theta) * math.cos(theta + math.pi * rot_fac)\
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: + randint(-fuzz, fuzz) * fuz_fac
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: y = r * math.exp(b * theta) * math.sin(theta + math.pi * rot_fac)\
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: + randint(-fuzz, fuzz) * fuz_fac
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: spiral_stars.append((x, y))
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '➎ for x, y in spiral_stars:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '➏ if arm == 0 and int(x % 2) == 0:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: c.create_oval(x-2, y-2, x+2, y+2, fill='white', outline='')
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'elif arm == 0 and int(x % 2) != 0:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: c.create_oval(x-1, y-1, x+1, y+1, fill='white', outline='')
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '➐ elif arm == 1:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: c.create_oval(x, y, x, y, fill='white', outline='')
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 10-7: Defines the* spirals() *function*'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Define a function called spirals() ➊. Its parameters are listed in the function
    docstring. The first two parameters, b and r, are from the logarithmic spiral
    equation. The next, rot_fac, is the rotation factor that lets you move the spiral
    around the center point so you can produce a new spiral arm. The fuzz factor,
    fuz_fac, lets you tweak how far you move stars away from the center of the spiraling
    line. Finally, the arm parameter lets you specify either the leading arm or the
    trailing arm of faint stars. The trailing arm will be shifted—that is, plotted
    a little behind the leading arm—and its stars will be smaller.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Initialize an empty list to hold the locations of the stars that will make up
    the spiral ➋. Assign a fuzz variable, where you multiply an arbitrary constant
    by the absolute value of the scaled disc radius ➌. The spiral equation alone produces
    stars that are lined up (see the left two panels in [Figure 10-11](ch10.xhtml#ch10fig11)).
    Fuzzing will move stars in the spiral back and forth a little, to either side
    of the spiral line. You can see the effect on the bright stars in the rightmost
    panel in [Figure 10-11](ch10.xhtml#ch10fig11). I determined these values through
    trial and error; feel free to play with them if you like.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0206-01.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-11: Filling out the spiral arms by shifting spirals and randomly
    changing star positions*'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-11：通过偏移螺旋并随机改变星星位置来填充螺旋臂*'
- en: Now it’s time to build the spiral lines. First, use a range of values to represent
    θ in the logarithmic spiral equation ➍. A range of about 520 will produce the
    galaxy in [Figure 10-9](ch10.xhtml#ch10fig9), which has a central “black hole.”
    Otherwise, use a range of (0, 600, 2)—or similar—to produce a bright central core
    fully packed with stars ([Figure 10-12](ch10.xhtml#ch10fig12)). You can tinker
    with these values until you get your preferred result. Loop through the values
    in theta and apply the logarithmic spiral equation, using cosine for the x-value
    and sine for the y-value. Note that you add the fuzz value, multiplied by the
    fuzz factor, to the result. Append each (*x*, *y*) pair to the spiral_stars list.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候构建螺旋线了。首先，使用一系列值来表示对数螺旋方程中的θ ➍。大约520的范围会产生如[图 10-9](ch10.xhtml#ch10fig9)所示的银河，它有一个中央的“黑洞”。否则，使用范围（0，600，2）——或类似范围——来产生一个亮度集中、星星密集的核心（见[图
    10-12](ch10.xhtml#ch10fig12)）。你可以调整这些值，直到获得你喜欢的效果。遍历θ值，并应用对数螺旋方程，使用余弦值作为x值，正弦值作为y值。注意，你要将模糊值乘以模糊因子并加到结果中。将每个(*x*，*y*)坐标对附加到spiral_stars列表中。
- en: '![image](../images/f0207-01.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0207-01.jpg)'
- en: '*Figure 10-12: Graphical model without the central black hole (compare to [Figure
    10-9](ch10.xhtml#ch10fig9))*'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-12：没有中央黑洞的图形模型（与[图 10-9](ch10.xhtml#ch10fig9)对比）*'
- en: Later, in the main() function, you’ll specify the rot_fac variable, which will
    move the spiral around the center. After the program builds the four main arms,
    it will use rot_fac to build four new arms, slightly offset from the first four,
    to produce the band of dim, trailing stars seen to the left of each arc of bright
    stars in [Figure 10-11](ch10.xhtml#ch10fig11).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 后面，在main()函数中，你将指定rot_fac变量，它将使螺旋围绕中心旋转。程序构建了四个主要的臂后，它将使用rot_fac来构建四个新的臂，这些臂稍微偏移于前四个臂，形成左侧的暗淡、拖尾星星带，这在[图
    10-11](ch10.xhtml#ch10fig11)中可见。
- en: Now that you have the list of star locations, start a for loop through the (*x*,
    *y*) coordinates ➎. Then use a conditional statement to choose the main, leading
    arm and locations for which x is even ➏. For these, use the canvas widget’s create_oval()
    method to create a star object to post. This method’s first four arguments define
    a bounding box into which the oval fits. The larger the number after x and y,
    the larger the oval. Make the fill white and don’t use an outline; the default
    outline is a thin black line.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经得到了星星位置的列表，开始通过(*x*，*y*)坐标执行for循环 ➎。然后，使用条件语句来选择主要的、前导臂以及x值为偶数的位置 ➏。对于这些位置，使用canvas控件的create_oval()方法来创建一个星星对象并显示。此方法的前四个参数定义了一个包围框，椭圆形状将适应这个框。x和y后面的数字越大，椭圆也就越大。填充颜色为白色，并且不使用轮廓；默认轮廓是细黑线。
- en: If the x-value is odd, make the star a step smaller. And if the arm value is
    1, the star is in the shifted arm, so make it as small as possible ➐.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果x值是奇数，星星的步长要小一些。如果臂长值为1，星星就在偏移的臂上，所以要尽量让它变小 ➐。
- en: '**NOTE**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The star objects are for visual impact only. Neither their size nor number
    is to scale. To be realistic, they would be much, much smaller and much more numerous
    (over 100 billion!).*'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '*星星对象仅用于视觉效果。它们的大小和数量并不按比例缩放。要真实的话，它们应该小得多，而且数量会多得多（超过1000亿颗！）。*'
- en: '**Scattering Star Haze**'
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**星星散布效果**'
- en: The space between the spiral arms isn’t devoid of stars, so the next function
    ([Listing 10-8](ch10.xhtml#ch10list8)) randomly casts points across the galactic
    model, with no regard for spiral arms. Think of this as the glow you see in photographs
    of distant galaxies.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 螺旋臂之间的空间并非完全没有星星，因此接下来的函数（见[代码清单 10-8](ch10.xhtml#ch10list8)）会随机地在银河模型中投射点，而不考虑螺旋臂。可以把这看作是你在远处银河照片中看到的光晕效果。
- en: '*galaxy_simulator.py,* part 6'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '*galaxy_simulator.py,* 第6部分'
- en: '➊ def star_haze(disc_radius_scaled, density):'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def star_haze(disc_radius_scaled, density):'
- en: '"""Randomly distribute faint tkinter stars in galactic disc.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '"""在银河盘中随机分布微弱的tkinter星星。'
- en: disc_radius_scaled = galactic disc radius scaled to radio bubble diameter
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: disc_radius_scaled = 银河盘半径，按无线电气泡直径缩放
- en: density = multiplier to vary number of stars posted
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: density = 用来变化显示星星数量的乘数
- en: '"""'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: '➋ for i in range(0, disc_radius_scaled * density):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ for i in range(0, disc_radius_scaled * density):'
- en: ➌ x, y = random_polar_coordinates(disc_radius_scaled)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ x, y = random_polar_coordinates(disc_radius_scaled)
- en: ➍ c.create_text(x, y, fill='white', font=('Helvetica', '7'), text='.')
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ c.create_text(x, y, fill='white', font=('Helvetica', '7'), text='.')
- en: '*Listing 10-8: Defines the* star_haze() *function*'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*代码清单 10-8：定义了* star_haze() *函数*'
- en: 'Define the star_haze() function and pass it two arguments: the scaled disc
    radius and an integer multiplier that the function will use to increase the base
    number of random stars ➊. So, if you prefer a thick fog rather than a light haze,
    increase the value of the density value when you call the function in main().'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 定义star_haze()函数并传递两个参数：缩放后的圆盘半径和一个整数倍数，函数将用它来增加随机星星的基础数量 ➊。因此，如果你更喜欢浓雾而非轻雾，在调用主函数中的该函数时，请增加密度值。
- en: Start a for loop where the maximum range value is equal to the scaled disc radius
    multiplied by density ➋. By using the radius value, you scale the number of stars
    to the size of the disc being displayed. Then call the random_polar_coordinates()
    function to get an (*x*, *y*) pair ➌.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个for循环，其中最大范围值等于缩放后的圆盘半径乘以密度 ➋。通过使用半径值，你可以将星星的数量缩放到显示的圆盘大小。然后调用random_polar_coordinates()函数来获取(*x*,
    *y*)对 ➌。
- en: End by creating a display object for the canvas using the (*x*, *y*) pair ➍.
    Since you’ve already used the smallest oval size for the stars along and around
    the spiral, use the create_text() method instead of create_oval(). With this method,
    you can use a period to represent a star. The font size parameter will allow you
    to scale the haze stars until you find something aesthetically pleasing.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用(*x*, *y*)对 ➍ 创建一个画布显示对象。由于你已经使用最小的椭圆大小来表示沿螺旋星系分布的星星，改用create_text()方法代替create_oval()方法。在这个方法中，你可以用句点表示星星。字体大小参数将允许你缩放星雾星星，直到找到一个令人赏心悦目的效果。
- en: '[Figure 10-13](ch10.xhtml#ch10fig13) is a comparison between the galactic model
    without the star haze (left) and with the star haze (right).'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-13](ch10.xhtml#ch10fig13)是没有星雾（左）和有星雾（右）的银河模型的比较。'
- en: '![image](../images/f0208-01.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0208-01.jpg)'
- en: '*Figure 10-13: Galactic model without star haze (left) versus with star haze
    (right)*'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-13：没有星雾（左）与有星雾（右）的银河模型*'
- en: You can be creative with the haze. For example, you can make the stars more
    numerous and color them gray, or use a loop to vary both their size and color.
    Don’t use green, however, as there are no green stars in the universe!
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以发挥创意来设计星雾。例如，你可以增加星星的数量并将它们涂成灰色，或者使用循环来变化星星的大小和颜色。然而，不要使用绿色，因为宇宙中没有绿色的星星！
- en: '**Defining the main() Function**'
  id: totrans-332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**定义main()函数**'
- en: '[Listing 10-9](ch10.xhtml#ch10list9) defines the main() function in *galaxy_simulator.py*.
    It will make the calls to scale the galaxy, calculate the probability of detection,
    build the galaxy display, and post statistics. It will also run the tkinter main
    loop.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10-9](ch10.xhtml#ch10list9)定义了*galaxy_simulator.py*中的main()函数。它将调用缩放银河、计算检测概率、构建银河图像并发布统计数据。它还将运行tkinter的主循环。'
- en: '*galaxy_simulator.py,* part 8'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '*galaxy_simulator.py*，第8部分'
- en: 'def main():'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '"""Calculate detection probability & post galaxy display & statistics."""'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '"""计算检测概率并显示银河系图像及统计数据。"""'
- en: ➊ disc_radius_scaled, disc_vol_scaled = scale_galaxy()
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ disc_radius_scaled, disc_vol_scaled = scale_galaxy()
- en: detection_prob = detect_prob(disc_vol_scaled)
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: detection_prob = detect_prob(disc_vol_scaled)
- en: '# build 4 main spiral arms & 4 trailing arms'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '# 构建4个主螺旋臂和4个拖尾臂'
- en: ➋ spirals(b=-0.3, r=disc_radius_scaled, rot_fac=2, fuz_fac=1.5, arm=0)
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ spirals(b=-0.3, r=disc_radius_scaled, rot_fac=2, fuz_fac=1.5, arm=0)
- en: spirals(b=-0.3, r=disc_radius_scaled, rot_fac=1.91, fuz_fac=1.5, arm=1)
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: spirals(b=-0.3, r=disc_radius_scaled, rot_fac=1.91, fuz_fac=1.5, arm=1)
- en: spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=2, fuz_fac=1.5, arm=0)
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=2, fuz_fac=1.5, arm=0)
- en: spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=-2.09, fuz_fac=1.5, arm=1)
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=-2.09, fuz_fac=1.5, arm=1)
- en: spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=0.5, fuz_fac=1.5, arm=0)
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=0.5, fuz_fac=1.5, arm=0)
- en: spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=0.4, fuz_fac=1.5, arm=1)
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=0.4, fuz_fac=1.5, arm=1)
- en: spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=-0.5, fuz_fac=1.5, arm=0)
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=-0.5, fuz_fac=1.5, arm=0)
- en: spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=-0.6, fuz_fac=1.5, arm=1)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: spirals(b=-0.3, r=-disc_radius_scaled, rot_fac=-0.6, fuz_fac=1.5, arm=1)
- en: star_haze(disc_radius_scaled, density=8)
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: star_haze(disc_radius_scaled, density=8)
- en: '# display legend'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '# 显示图例'
- en: ➌ c.create_text(-455, -360, fill='white', anchor='w',
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ c.create_text(-455, -360, fill='white', anchor='w',
- en: text='One Pixel = {} LY'.format(SCALE))
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: text='一个像素 = {} 光年'.format(SCALE))
- en: c.create_text(-455, -330, fill='white', anchor='w',
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: c.create_text(-455, -330, fill='white', anchor='w',
- en: text='Radio Bubble Diameter = {} LY'.format(SCALE))
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: text='无线电气泡直径 = {} 光年'.format(SCALE))
- en: c.create_text(-455, -300, fill='white', anchor='w',
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: c.create_text(-455, -300, fill='white', anchor='w',
- en: text='Probability of detection for {:,} civilizations = {}'.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: text='检测到{:，}个文明的概率 = {}'。
- en: format(NUM_CIVS, detection_prob))
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: format(NUM_CIVS, detection_prob))
- en: '# post Earth''s 225 LY diameter bubble and annotate'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '# 显示地球225光年直径的气泡并注释'
- en: '➍ if SCALE == 225:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ 如果 SCALE == 225：
- en: ➎ c.create_rectangle(115, 75, 116, 76, fill='red', outline='')
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ c.create_rectangle(115, 75, 116, 76, fill='red', outline='')
- en: c.create_text(118, 72, fill='red', anchor='w',
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: c.create_text(118, 72, fill='red', anchor='w',
- en: text="<---------- Earth's Radio Bubble")
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: text="<---------- 地球的广播气泡")
- en: '# run tkinter loop'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '# 运行tkinter循环'
- en: ➏ root.mainloop()
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ root.mainloop()
- en: '➐ if __name__ == ''__main__'':'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ 如果 __name__ == '__main__'：
- en: main()
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: main()
- en: '*Listing 10-9: Defines and calls the* main() *function*'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-9：定义并调用* main() *函数*'
- en: Start main() by calling the scale_galaxy() function to get the scaled disc volume
    and radius ➊. Then call the detect_prob() function and pass it the disc_vol_scaled
    variable. Assign the results to a variable named detection_prob.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用scale_galaxy()函数来启动main()，以获取缩放后的盘面体积和半径 ➊。然后调用detect_prob()函数，并将disc_vol_scaled变量传递给它。将结果赋值给一个名为detection_prob的变量。
- en: Now build the galaxy display (graphical model) ➋. This calls the spirals() function
    multiple times, with small changes to each call. The arm parameter designates
    the bright main arms and the faint trailing arms. The rot_fac (rotation factor)
    variable determines where the spiral plots. The slight change in rotation factor
    between arms 0 and 1 (for example, 2 to 1.91) is what causes the faint arm to
    plot slightly offset from the bright arm. Finish the display by calling the star_haze()
    function. Again, feel free to experiment with any of these parameters.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建星系显示（图形模型） ➋。这会多次调用spirals()函数，每次调用时稍作调整。arm参数指定明亮的主臂和微弱的拖尾臂。rot_fac（旋转因子）变量决定了螺旋的绘制位置。臂0和臂1之间的旋转因子（例如，从2到1.91）的微小变化是导致微弱臂稍微偏离明亮臂绘制的原因。通过调用star_haze()函数来完成显示。同样，你可以尝试修改这些参数。
- en: Next, display a legend and statistics. Start with the scale ➌ and radio bubble
    diameter followed by the probability of detection for the given number of civilizations.
    Arguments include the x and y coordinates, a fill (text) color, a justification
    anchor—with left represented by w for “west”—and the text. Note the use of {:,}
    to insert a comma as a thousand separator. This is part of the newer *string format
    method*. You can read more about it at *[https://docs.python.org/3/library/string.html#string-formatting](https://docs.python.org/3/library/string.html#string-formatting)*.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，显示图例和统计数据。从比例 ➌ 和广播气泡直径开始，接着是给定文明数量的检测概率。参数包括x和y坐标、填充（文本）颜色、对齐锚点——其中左对齐用w代表“west”——以及文本。注意使用{:，}来插入千位分隔符。这是更新的*字符串格式方法*的一部分。你可以在*[https://docs.python.org/3/library/string.html#string-formatting](https://docs.python.org/3/library/string.html#string-formatting)*
    上了解更多。
- en: 'If the user has selected a radio bubble diameter of 225 LY ➍, then the display
    is at the same scale as our own emissions bubble, so post a red pixel at the approximate
    location of our solar system and annotate it ➎. There are a number of ways to
    display a single pixel using tkinter. Here, you use the create_rectangle() method,
    but you can also make a line that is one pixel long with the following statement:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户选择了225光年直径的广播气泡 ➍，则显示的尺度与我们自己的辐射气泡相同，因此在大约我们的太阳系位置上放置一个红色像素并进行注释 ➎。使用tkinter显示单个像素有多种方法。在这里，你使用create_rectangle()方法，但也可以使用以下语句绘制一个长为一个像素的线：
- en: c.create_line(115, 75, 116, 75, fill='red')
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: c.create_line(115, 75, 116, 75, fill='red')
- en: With the create_rectangle() method, the first two arguments are points (x0,
    y0), which correspond to the top-left corner, and (x1, y1), the location of the
    pixel just outside of the bottom-right corner. With the create_line() method,
    the arguments are for the starting and ending points. The default line width is
    one pixel.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 使用create_rectangle()方法时，前两个参数是点(x0, y0)，对应左上角，以及(x1, y1)，即位于右下角外侧的像素位置。使用create_line()方法时，参数则是起点和终点。默认线宽为一个像素。
- en: End the main() function by executing the tkinter mainloop() function, also known
    as the *event loop* ➏. This keeps the root window open until you close it.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行tkinter的mainloop()函数来结束main()函数，该函数也称为*事件循环* ➏。这会保持根窗口一直打开，直到你关闭它。
- en: Back in the global space, end the program by allowing it to be run stand-alone
    or called as a module in another program ➐.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 回到全局空间，通过允许程序独立运行或作为模块在另一个程序中调用来结束程序 ➐。
- en: The final display will look like [Figure 10-14](ch10.xhtml#ch10fig14), shown
    with the Earth’s radio bubble and a central black hole.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 最终显示效果如[图10-14](ch10.xhtml#ch10fig14)所示，展示了地球的广播气泡和一个中央黑洞。
- en: '![image](../images/f0210-01.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0210-01.jpg)'
- en: '*Figure 10-14: The final display, with Earth’s 225 LY diameter radio bubble
    posted on the galactic map*'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Note that, despite the fact that our radio bubble is no bigger than a pinprick
    at this scale, if civilizations had a detection range of 112.5 light-years, and
    if there were as many of these civilizations as predicted by current high-side
    parameters for the Drake equation, the probability of detection is 1!
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '**Results**'
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given the enormous uncertainty in the inputs and the use of simplifying assumptions,
    you’re not looking for accuracy here. What you’re looking for is *directionality*.
    Should we (or anyone like us) expect to detect another civilization that isn’t
    actively trying to contact us? Based on [Figure 10-15](ch10.xhtml#ch10fig15),
    probably not.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0211-01.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-15: Probability of one civilization detecting another for different
    radio bubble diameters and different numbers of civilizations in the galaxy*'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: With our current technology, we could detect emissions from a civilization as
    far away as 16 LY, which equates to a 32 LY diameter radio bubble. Even if the
    galaxy is filled with 15.6 million advanced civilizations, as predicted by the
    updated Drake equation in the Wikipedia article, the chance of detecting 32 LY
    radio bubbles is less than 4 percent!
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: 'Take another look at [Figure 10-14](ch10.xhtml#ch10fig14), and you can begin
    to appreciate the sheer enormity and emptiness of our galaxy. Astronomers even
    have a word for this: *Laniakea*, Hawaiian for “immeasurable heaven.”'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Earth is, as Carl Sagan described it, just a “mote of dust, suspended in a sunbeam.”
    And recent studies suggest that the window of opportunity for detecting civilizations
    with radio waves is much smaller than we thought. If other civilizations follow
    our lead and switch to digital signals and satellite communications, then their
    incidental radio leakage will drop by at least a factor of four. We all become
    unintentionally stealthy, blooming for a hundred years or so, then fading away.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Given these facts, it’s not surprising that the government no longer funds the
    search for extraterrestrial intelligence using radio telescopes. These days, efforts
    are shifting to optical methods that look for signature gases in the atmospheres
    of exoplanets, such as the waste products of life and industrial activity.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you gained experience using tkinter, matplotlib, and NumPy.
    You generated a polynomial expression for making reasonable estimates of the likelihood
    of detecting incidental alien radio transmissions, and you used the always-available
    tkinter module to add a cool visual component to the analysis.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Are We Alone? Philosophical Implications of the Discovery of Extraterrestrial
    Life* (BasicBooks, 1995) by Paul Davies is a thoughtful look at the search for
    alien life, told by an eminent scientist and award-winning science writer.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: “A New Formula Describing the Scaffold Structure of Spiral Galaxies” (*Monthly
    Notices of the Royal Astronomical Society*, July 21, 2009) by Harry I. Ringermacher
    and Lawrence R. Mead (*[https://arxiv.org/abs/0908.0892v1](https://arxiv.org/abs/0908.0892v1)*)
    provides formulas for modeling the shapes of spiral galaxies observed by the Hubble
    telescope.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '“Tkinter 8.5 Reference: A GUI for Python” (New Mexico Tech Computer Center,
    2013) by John W. Shipman is a useful supplement to the official tkinter docs.
    It can be found at *[http://infohost.nmt.edu/tcc/help/pubs/tkinter/tkinter.pdf](http://infohost.nmt.edu/tcc/help/pubs/tkinter/tkinter.pdf)*.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Another useful online tkinter resource is *[https://wiki.python.org/moin/TkInter/](https://wiki.python.org/moin/TkInter/)*.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '*Tkinter GUI Application Development HOTSHOT* (Packt Publishing, 2013) by Bhaskar
    Chaudhary uses a project-based approach to teach tkinter.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Projects**'
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try these three spin-off projects. You can find them in the appendix or download
    them from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '***A Galaxy Far, Far Away***'
  id: totrans-397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tired of living in the Milky Way galaxy? Heck, who isn’t? Fortunately, there’s
    more in heaven and earth than just logarithmic spirals. Use Python and tkinter
    to build us a new home—but not necessarily a realistic home. For inspiration,
    visit online articles like Alexandre Devert’s post on his Marmakoide’s Blog, “Spreading
    Points on a Disc and on a Sphere” (*[http://blog.marmakoide.org/](http://blog.marmakoide.org/)*).
    The example shown in [Figure 10-16](ch10.xhtml#ch10fig16) was built with *galaxy_practice.py*.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0213-01.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-16: Galaxy produced by the* galaxy_practice.py *program*'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '***Building a Galactic Empire***'
  id: totrans-401
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pick a location in the galaxy, an average travel speed of 5 to 10 percent of
    the speed of light, and a time step of 500,000 years. Then model the expansion
    of a space-faring empire. At each time step, calculate the size of the expanding
    *colonization bubble* and update the galaxy map. Check your results by placing
    the home-world location at the center of the galaxy, setting the speed to 1, and
    confirming that it takes 50,000 years to reach the edge of the galaxy.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: When you have the program up and running, you can perform interesting experiments.
    For example, you can test how fast we would need to go to explore the galaxy in
    10 million years, as mentioned in the introduction to this chapter (see [Figure
    10-17](ch10.xhtml#ch10fig17)).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0213-02.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-17: A core-located empire’s expansion using travel below light speed
    over 10 million years*'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: You could also estimate how much of the galaxy the *Star Trek* Federation could
    have explored in its first 100 years, assuming they averaged 100x light speed
    at warp 4 ([Figure 10-18](ch10.xhtml#ch10fig18)).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0214-01.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-18: Expansion of the* Star Trek *Federation in first 100 years under
    warp factor 4*'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: These figures were built with the *empire_practice.py* program.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '***A Roundabout Way to Predict Detectability***'
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another way to predict the probability of detection is to use polar coordinates
    to distribute civilizations—as xyz points—in the galactic disc and then round
    the points to the nearest radio bubble *radius*. Points that share the same location
    represent civilizations that could detect each other. But be careful—this method
    rounds using cubes rather than spheres, so you’ll need to convert the radius to
    the side of a cube that produces the same volume.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Write the program so that it predicts the probability of detecting 16 LY *radius*
    bubbles (the limit of our current technology) given 15,600,000 transmitting civilizations
    randomly distributed throughout the galaxy (updated Drake equation output from
    Wikipedia). Use the full 50,000 LY radius and 1,000 LY height of the galactic
    model when distributing the civilizations.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: For a solution, see *rounded_detection_practice.py*. Note that the program will
    take several minutes to run.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Projects**'
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are a few follow-up projects to try on your own. Remember that I don’t
    provide solutions to challenge projects.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a Barred-Spiral Galaxy***'
  id: totrans-416
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our understanding of the Milky Way evolves as we obtain and analyze new astronomical
    data. Scientists now believe that the core of the galaxy is elongated and bar
    shaped. Use the equations provided in the Ringermacher and Mead paper, cited in
    “[Further Reading](ch10.xhtml#lev241)” on [page 212](ch10.xhtml#page_212), to
    create a new tkinter visual model of the galaxy that honors the barred-spiral
    concept.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '***Adding Habitable Zones to Your Galaxy***'
  id: totrans-418
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Solar systems have *Goldilocks zones* that are favorable for the development
    of life. Planets orbiting in these zones stay warm enough for at least some of
    their water to remain in liquid state.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: There is also a theory that galaxies, like solar systems, have *habitable zones*
    in which life is more likely to develop. One definition of the habitable zone
    for the Milky Way places its inner boundary about 13,000 LY from the galactic
    center and its outer boundary about 33,000 LY from the center ([Figure 10-19](ch10.xhtml#ch10fig19)).
    The core is excluded due to the high levels of radiation, large number of supernovas,
    and complex orbit-disrupting gravitational fields resulting from all the closely
    spaced stars. The rim areas are condemned due to low metallicity, which is crucial
    to the development of planets.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0215-01.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-19: Approximate galactic habitable zone (shaded) superimposed on
    the Milky Way model*'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: A refinement of the habitable zone model excludes spiral arms, for reasons similar
    to those applied to the core. Our own existence doesn’t contradict this. Earth
    is located in the Orion “spur,” a relatively small feature between the Sagittarius
    and Perseus arms.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Edit the *galaxy_simulation.py* program so that it uses only the volume in the
    galactic habitable zone, however you define it. You should research what these
    volumes may be and what effect they’ll have on the number of civilizations (*N*)
    that the Drake equation calculates. Consider using *regions*, such as the core,
    spirals, outer rim, and so on, within which *N* is different but civilizations
    are still randomly distributed. Highlight these regions on the galactic map and
    post their probability-of-detection estimates.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑*galaxy_simulation.py*程序，使其仅使用银河适居带中的体积，无论你如何定义它。你应该研究这些体积可能是什么，以及它们对德雷克方程计算的文明数量（*N*）的影响。考虑使用*区域*，例如核心、螺旋臂、外缘等，在这些区域内，*N*不同，但文明仍然是随机分布的。突出显示这些区域在银河地图上的位置，并发布它们的探测概率估计值。
