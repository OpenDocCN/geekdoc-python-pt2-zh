- en: '**10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ARE WE ALONE? EXPLORING THE FERMI PARADOX**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Scientists use the *Drake equation* to estimate the possible number of civilizations
    in the galaxy currently producing electromagnetic emissions, such as radio waves.
    In 2017, the equation was updated to account for new exoplanet discoveries by
    NASA’s Kepler satellite. The result, published in the scientific journal *Astrobiology*,
    was astonishing. For humanity to be the first and only technologically advanced
    species, the probability of an advanced civilization developing on a habitable
    alien planet would have to be less than 1 in 10 billion trillion! And yet, as
    Nobel Prize–winning physicist Enrico Fermi famously observed, “Where is everybody?”
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Fermi was more skeptical about interstellar travel than the existence of extraterrestrials,
    but his question became known as *Fermi’s paradox*, and it morphed into the conjecture
    “If they were out there, they’d be here.” According to the SETI Institute, even
    with modest rocket technology, an eager civilization could explore the entire
    galaxy, if not colonize it, within 10 million years. That may sound like a long
    time, but it’s only 1/1,000 the age of the Milky Way! As a result, some have come
    to accept Fermi’s paradox as proof we are alone in the cosmos. Others find holes
    in the argument.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll investigate the absence of alien radio transmissions
    by calculating the probability of one civilization detecting another based on
    the volume of their transmissions and output from the Drake equation. You’ll also
    use Python’s de facto standard GUI package, `tkinter`, to quickly and easily create
    a graphical model of the Milky Way.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '**Project #17: Modeling the Milky Way**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our galaxy, the Milky Way, is a fairly common spiral galaxy, like the one shown
    in [Figure 10-1](ch10.xhtml#ch10fig1).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0188-01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-1: Spiral galaxy NGC 6744, “Big Brother” to the Milky Way*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: In cross-sectional view, the Milky Way is a flattened disc with a central bulge
    that most likely contains a supermassive black hole at its core. Four “spiral
    arms”—comprising relatively densely packed gas, dust, and stars—radiate from this
    central mass. The dimensions of the Milky Way are shown in [Figure 10-2](ch10.xhtml#ch10fig2).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0189-01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-2: Schematic profile (edge view) of the Milky Way galaxy (LY = Light-Years)
    and a simplified model*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The center of the galaxy is considered fairly inhospitable to life due to high
    levels of radiation associated with the more closely packed stars. So, for this
    project, you can treat the galaxy as a simple disc to discount some of the volume
    associated with the bulge but still leave room for some advanced civilizations
    near the core (see the Galactic Model in [Figure 10-2](ch10.xhtml#ch10fig2)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '**THE OBJECTIVE**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: For a given number of advanced galactic civilizations and an average radio bubble
    size, estimate the probability of *any* civilization detecting the radio transmissions
    of *any other* civilization. For perspective, post the size of Earth’s current
    radio bubble on a 2D graphical representation of the Milky Way.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定数量的高级银河文明和平均无线电气泡大小，估算*任何*文明检测到*任何其他*文明无线电传输的概率。为了提供视角，可以将地球当前的无线电气泡大小绘制在银河系的二维图形表示上。
- en: '**The Strategy**'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**策略**'
- en: 'Here are the steps needed to complete this project:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完成此项目所需的步骤：
- en: Estimate the number of transmitting civilizations using the Drake equation.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用德雷克方程估算传输文明的数量。
- en: Choose a size range for their radio bubbles.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择它们无线电气泡的大小范围。
- en: Generate a formula for estimating the probability of one civilization detecting
    another.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个公式来估算一个文明检测到另一个文明的概率。
- en: Build a graphical model of the galaxy and post Earth’s radio emissions bubble.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建银河系的图形模型，并绘制地球的无线电辐射气泡。
- en: In order to keep the description close to the code, each of these tasks will
    be described in detail in its own section. Note that the first two steps don’t
    require the use of Python.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使描述尽可能接近代码，以下任务将在各自的章节中详细描述。请注意，前两步并不需要使用Python。
- en: '**Estimating the Number of Civilizations**'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**估算文明数量**'
- en: 'You can manually estimate the number of advanced civilizations using the Drake
    equation:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以手动使用德雷克方程估算高级文明的数量：
- en: '*N* = *R^** · *f*[p] · *n*[e] · *f*[l] · *f*[i] · *f*[c] · *L*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*N* = *R^** · *f*[p] · *n*[e] · *f*[l] · *f*[i] · *f*[c] · *L*'
- en: 'where:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '*N* = The number of civilizations in our galaxy whose electromagnetic emissions
    are detectable'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*N* = 我们银河系中电磁辐射可被检测到的文明数量'
- en: '*R*^* = The average rate of star formation in the galaxy (new stars per year)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*R*^* = 银河系中恒星的平均形成率（每年新恒星数量）'
- en: '*f*^p = The fraction of stars with planets'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*^p = 拥有行星的恒星比例'
- en: '*n*^e = For stars with planets, the average number of planets with an environment
    suitable for life'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*^e = 对于拥有行星的恒星，适合生命存在的行星的平均数量'
- en: '*f*^l = The fraction of planets that develop life'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*^l = 发展出生命的行星的比例'
- en: '*f*^i = The fraction of life-bearing planets with intelligent, civilized life'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*^i = 具有智能、文明生命的生命承载行星的比例'
- en: '*f*^c = The fraction of civilizations that release detectable signs of their
    existence into space'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*^c = 将其存在迹象释放到太空中的文明的比例'
- en: '*L* = The length of time—in years—over which the civilizations release the
    detectable signals'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*L* = 文明释放可检测信号的时间长度（单位：年）'
- en: Thanks to recent advances in the detection of exoplanets, the first three components
    (*R*^*, *f*^p, *n*^e) are becoming increasingly constrained. For *n*^e, recent
    studies suggest that 10 to 40 percent of all planets may be suitable for *some
    form* of life.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 得益于近年来系外行星探测的进展，前三个组件（*R*^*，*f*^p，*n*^e）正变得越来越受限制。对于*n*^e，近期的研究表明，所有行星中可能有10%到40%的行星适合某种形式的生命存在。
- en: For the remaining components, Earth is the only example. In the Earth’s 4.5-billion-year
    history, *Homo sapiens* has existed for only 200,000 years, civilization for only
    6,000 years, and radio transmissions for only 112 years. With respect to *L*,
    wars, plagues, ice ages, asteroid impacts, super-volcanoes, supernovas, and coronal
    mass ejections can disrupt a civilization’s ability to transmit radio signals.
    And the shorter the time of transmission, the less likely it is for civilizations
    to coexist.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其余的组件，地球是唯一的例子。在地球的45亿年历史中，*智人*只存在了20万年，文明只存在了6,000年，无线电传输也仅有112年的历史。关于*L*，战争、瘟疫、冰河时代、小行星撞击、超级火山、超新星爆炸和日冕物质抛射等都可能破坏文明传播无线电信号的能力。传输时间越短，文明共存的可能性越小。
- en: According to the Wikipedia article on the Drake equation (*[https://en.wikipedia.org/wiki/Drake_equation](https://en.wikipedia.org/wiki/Drake_equation)*),
    in 1961, Drake and his colleagues estimated the number of communicating civilizations
    in the galaxy to be between 1,000 and 100,000,000\. More recent updates have set
    the range from 1 (just us) to 15,600,000 ([Table 10-1](ch10.xhtml#ch10tab1)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科上关于德雷克方程的文章（*[https://en.wikipedia.org/wiki/Drake_equation](https://en.wikipedia.org/wiki/Drake_equation)*），在1961年，德雷克及其同事估计银河系中有通讯的文明数量在1,000到1亿之间。最近的更新将这一范围定为1（只有我们）到15,600,000（[表格10-1](ch10.xhtml#ch10tab1)）。
- en: '**Table 10-1:** Some Drake Equation Inputs and Results'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**表格10-1：** 一些德雷克方程的输入和结果'
- en: '| **Parameter** | **Drake 1961**** | **Drake 2017** | **Your choices** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **德雷克1961年** | **德雷克2017年** | **您的选择** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| *R*^* | 1 | 3 |  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| *f*[p] | 0.35 | 1 |  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| *n*^e | 3 | 0.2 |  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| *f*[l] | 1 | 0.13 |  |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| *f*[i] | 1 | 1 |  |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '| *f*[c] | 0.15 | 0.2 |  |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '| *L* | 50 × 10⁶ | 1 × 10⁹ |  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: '| *N* | 7.9 × 10⁶ | 15.6 × 10⁶ |  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
- en: '| **midpoint of ranges shown |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: For input to your program, you can use the estimates in the table, those you
    find online, or those you calculate yourself (in the final column of the table).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '**Selecting Radio Bubble Dimensions**'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Radio waves that aren’t focused into a beam for targeted transmission are incidental.
    Think of these as “planet leakage.” Because we choose not to broadcast our presence
    to aliens who might come and eat us, almost all of our transmissions are incidental.
    These transmissions currently form an expanding sphere around Earth with a diameter
    of around 225 light-years (LY).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: A 225 LY bubble sounds impressive, but it is the *detectable* size that really
    matters. A radio wave front is subject to the *inverse square law*, which means
    it continuously loses power density as it expands. Additional power loss can result
    from absorption or scattering. At some point, the signal becomes too weak to separate
    from background noise. Even with our best technology—the radio telescopes of the
    *Breakthrough Listen* program—we could detect our own radio bubble only out to
    about 16 LY.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Since we’re really investigating why *we* haven’t detected aliens, you should
    assume, for this project, that other civilizations have technology similar to
    our own. Another assumption should be that, like us, all aliens have a paranoid
    planetary consciousness and aren’t broadcasting “here we are” signals that would
    announce their presence. Investigating incidental bubble sizes ranging from a
    little smaller than those currently detectable to those a little larger than our
    own transmissions should be a reasonable place to start. This would suggest a
    diameter range of 30 to 250 LY. Although we can’t detect a 250 LY bubble, it will
    be interesting to see what the odds would be if we could.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '**Generating a Formula for the Probability of Detection**'
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the number of advanced civilizations in the galaxy increases, the probability
    that one will detect another also increases. This is intuitive, but how do you
    assign the actual probabilities?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The nice thing about computers is that they allow us to brute-force our way
    to solutions that may or may not be intuitive. One approach here would be to make
    a 3D model of the Milky Way disc, randomly distribute civilizations throughout,
    and measure the distances between them using one of Python’s many tools for calculating
    Euclidian distance. But with potentially hundreds of millions of civilizations
    to analyze, this method would be computationally expensive.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Since we’re dealing with huge unknowns, there’s no need to be super-accurate
    or precise. We just want to be in the ballpark, so an easy simplification is to
    compartmentalize the galaxy into a series of radio bubble “equivalent volumes”
    by dividing the volume of the galactic disc by the volume of a radio bubble (see
    [Figure 10-3](ch10.xhtml#ch10fig3)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处理的是巨大的未知数，没必要追求超精确。我们只需要大致正确，因此一个简单的简化方法是将银河系划分为一系列无线电气泡“等效体积”，方法是将银河圆盘体积除以无线电气泡体积（见[图10-3](ch10.xhtml#ch10fig3)）。
- en: '![image](../images/f0192-01.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0192-01.jpg)'
- en: '*Figure 10-3: Modeling the galaxy using cubes with volumes equivalent to a
    200 LY radio bubble*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-3：用体积等同于200光年无线电气泡的立方体来建模银河系*'
- en: 'You can find the volumes using the following equations, where *R* is the radius
    of the galactic disc and *r* is the radius of a radio bubble:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下方程来求体积，其中*R*是银河圆盘的半径，*r*是无线电气泡的半径：
- en: disc volume = π × *R*² × disc height
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 圆盘体积 = π × *R*² × 圆盘高度
- en: radio bubble volume = 4/3 × π × *r*³
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 无线电气泡体积 = 4/3 × π × *r*³
- en: scaled disc volume = disc volume / radio bubble volume
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放圆盘体积 = 圆盘体积 / 无线电气泡体积
- en: The scaled disc volume is the number of equivalent volumes that “fit” in the
    galaxy. Think of these as boxes numbered from 1 to the maximum number of volumes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放圆盘体积是“适合”银河系的等效体积数量。可以把这些当作从1到最大体积数编号的盒子。
- en: To place civilizations, you simply choose a box number at random. Duplicate
    picks indicate multiple civilizations within the same box. Assume civilizations
    in the same box can detect each other. This isn’t strictly true (see [Figure 10-4](ch10.xhtml#ch10fig4)),
    but because you’ll be using large numbers of civilizations, the discrepancies
    will tend to cancel each other out, just as when you sum a lot of rounded numbers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要放置文明，你只需随机选择一个盒子编号。重复选择表示在同一个盒子内有多个文明。假设同一个盒子内的文明可以相互检测。这并不完全正确（见[图10-4](ch10.xhtml#ch10fig4)），但由于你将使用大量文明，误差往往会相互抵消，就像求和大量四舍五入的数字一样。
- en: '![image](../images/f0193-01.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0193-01.jpg)'
- en: '*Figure 10-4: Detection problems at the individual equivalent volume level*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-4：单个等效体积级别的检测问题*'
- en: 'To avoid having to repeat this exercise every time you change the number of
    civilizations and/or radio bubble dimensions, you can capture the results as a
    formula—a *polynomial equation*—that can be used to generate all future probability
    estimates. A *polynomial* is the sum or difference of a collection of algebraic
    terms. The famous *quadratic equation* we all learned in school is a polynomial
    equation of the second degree (meaning that the exponents of the variables are
    no greater than 2):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免每次更改文明数量和/或无线电气泡尺寸时都要重复这个过程，你可以将结果以公式的形式保存——一个*多项式方程*——该公式可以用于生成所有未来的概率估算。*多项式*是多个代数项的和或差。我们在学校学过的著名*二次方程*就是一个二次多项式方程（意味着变量的指数不大于2）：
- en: '*ax*² + *bx* + *c* = 0'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*ax*² + *bx* + *c* = 0'
- en: Polynomials make nice curves, so they’re tailor-made for this problem. But for
    the formula to work with variable numbers of civilizations and bubble sizes, you’ll
    need to use the *ratio* of the number of civilizations to the total volume. The
    total volume is represented by the scaled disc volume, which is the same as the
    total number of equivalent volumes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式会形成漂亮的曲线，因此它们非常适合解决这个问题。但为了让公式适用于不同数量的文明和气泡大小，你需要使用文明数量与总体积的*比率*。总体积由缩放圆盘体积表示，这与等效体积的总数相同。
- en: In [Figure 10-5](ch10.xhtml#ch10fig5), each dot represents the probability of
    detection for the ratio below it. The equation shown in the figure is the polynomial
    expression, which generates the line connecting the dots. With this formula, you
    can predict the probability for any ratio of civilizations per volume, up to a
    value of 5 (above this, we’ll just assume the probability is 1.0).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图10-5](ch10.xhtml#ch10fig5)中，每个点代表其下方比率的检测概率。图中显示的方程是多项式表达式，它生成了连接各点的线。通过这个公式，你可以预测任何文明数量与体积比率的概率，最大值为5（超过这个值时，我们假设概率为1.0）。
- en: '![image](../images/f0194-01.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0194-01.jpg)'
- en: '*Figure 10-5: Probability of detection versus ratio of number of civilizations
    to scaled galactic volume*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-5：检测概率与文明数量与缩放银河体积比率的关系*'
- en: In [Figure 10-5](ch10.xhtml#ch10fig5), the civilizations-to-volume ratios are
    posted on the x-axis. A ratio of 0.5, for example, means that there are half as
    many civilizations as available radio bubble equivalent volumes, a ratio of 2
    means there are twice as many civilizations as volumes, and so on. The y-axis
    is the probability that an equivalent volume contains more than one civilization.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图10-5](ch10.xhtml#ch10fig5)中，文明与体积的比率被显示在x轴上。例如，比率为0.5意味着文明的数量是可用广播泡泡等效体积的二分之一，比率为2则意味着文明的数量是体积的两倍，依此类推。y轴表示一个等效体积中包含多个文明的概率。
- en: Another thing to note from [Figure 10-5](ch10.xhtml#ch10fig5) is that it takes
    a lot of civilizations to ensure that they all have a roommate. Imagine that 999,999
    out of 1,000,000 equivalent volumes contain at least two civilizations and you
    use your God-like powers to randomly place one new civilization. The odds are
    one in a million that this new civilization will end up in the remaining volume
    with a single occupant. That last equivalent volume is the proverbial needle in
    the haystack!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的点来自于[图10-5](ch10.xhtml#ch10fig5)，即需要许多文明才能确保它们每个都有一个室友。假设1000000个等效体积中有999999个包含至少两个文明，你利用上帝般的力量随机放置一个新的文明。那么，新的文明最终出现在唯一一个有单一居民的剩余体积中的概率是百万分之一。那个最后的等效体积就像是大海捞针！
- en: '**NOTE**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*An axiom of computer modeling is to start simple and add complexity. The simplest
    “base case” assumption is that advanced civilizations are randomly distributed
    throughout the galaxy. In “[Challenge Projects](ch10.xhtml#lev246)” on [page 214](ch10.xhtml#page_214),
    you’ll get a chance to challenge this assumption using the concept of galactic
    habitable zones.*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算机建模的一个公理是从简单开始，再逐步增加复杂性。最简单的“基本假设”是，先进文明在银河系中是随机分布的。在[第214页](ch10.xhtml#page_214)的[“挑战项目”](ch10.xhtml#lev246)中，你将有机会利用银河适居区的概念来挑战这一假设。*'
- en: '**The Probability-of-Detection Code**'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**检测概率代码**'
- en: The probability-of-detection code randomly chooses locations (radio bubble equivalent
    volumes) for a set number of locations and civilizations, counts how many locations
    occur only once (that is, contain only one civilization), and repeats the experiment
    multiple times to converge on a probability estimate. The process is then repeated
    for a new number of civilizations. The output is presented as probability versus
    the *ratio* of civilizations per volume, rather than the actual number of civilizations,
    and turned into a polynomial expression so that the results are easily portable.
    This means this program only needs to be run once.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 检测概率代码随机选择一组位置（广播泡泡等效体积）进行定位，并统计其中有多少位置仅出现一次（即只包含一个文明），然后多次重复实验以收敛到一个概率估计。接着，该过程会为新的文明数量重新执行。输出结果以概率与每体积中文明的*比率*为横坐标，而非实际文明数量，并将其转化为多项式表达式，以便结果能够轻松迁移。这意味着这个程序只需运行一次。
- en: To generate the polynomial equation and check that it fits the data, you’ll
    use `NumPy` and `matplotlib`. The `NumPy` library adds support for large, multidimensional
    arrays and matrices, and it includes many mathematical functions that operate
    on them. The `matplotlib` library supports 2D plotting and rudimentary 3D plotting,
    and `NumPy` represents its numerical mathematics extension.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成多项式方程并检查它是否符合数据，你将使用`NumPy`和`matplotlib`。`NumPy`库支持大规模的多维数组和矩阵，并包含许多可以对其进行操作的数学函数。`matplotlib`库支持二维绘图和基本的三维绘图，而`NumPy`则是其数值数学扩展。
- en: There are several ways to install these scientific Python distributions. One
    way is to use `SciPy`, an open source Python library used for scientific and technical
    computing (see *[https://scipy.org/index.html](https://scipy.org/index.html)*).
    If you’re going to do a lot of data analysis and plotting, you may want to download
    and use a free package like Anaconda or Enthought Canopy, which works with Windows,
    Linux, and macOS. These packages spare you the task of finding and installing
    all the required data science libraries in the correct version. A listing of these
    types of packages, along with links to their websites, can be found at *[https://scipy.org/install.html](https://scipy.org/install.html)*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 安装这些科学 Python 发行版有几种方法。一种方法是使用`SciPy`，这是一个用于科学和技术计算的开源 Python 库（见 *[https://scipy.org/index.html](https://scipy.org/index.html)*）。如果你打算进行大量的数据分析和绘图，你可能想要下载并使用一个免费的包，比如
    Anaconda 或 Enthought Canopy，它们支持 Windows、Linux 和 macOS。这些包免去了你需要查找并安装所有必要的数据科学库的麻烦，且能保证正确的版本。你可以在
    *[https://scipy.org/install.html](https://scipy.org/install.html)* 上找到这些类型包的列表，并附带有它们的网站链接。
- en: 'Alternatively, you may want to download the products directly, using pip. I
    did this using the instructions at *[https://scipy.org/install.html](https://scipy.org/install.html)*.
    Because `matplotlib` requires a large number of dependencies, these need to be
    installed at the same time. For Windows, I ran the following Python 3–specific
    command from the PowerShell, launched from within my *Python35* folder (you can
    leave off the *3* in *python3* unless you have multiple versions installed):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可能希望直接使用 pip 下载这些产品。我使用了 *[https://scipy.org/install.html](https://scipy.org/install.html)*
    中的说明来执行这个操作。由于`matplotlib`需要大量的依赖项，这些依赖项需要同时安装。对于 Windows，我从我的 *Python35* 文件夹中启动
    PowerShell，并运行以下特定于 Python 3 的命令（如果你没有安装多个版本的 Python，`python3`中的 *3* 可以省略）：
- en: '[PRE0]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All the other modules you’ll need come bundled with Python. As for the code
    in [Listings 10-1](ch10.xhtml#ch10list1) and [10-2](ch10.xhtml#ch10list2), you
    can type it in or download a copy from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的所有其他模块都已经捆绑在 Python 中。至于 [清单 10-1](ch10.xhtml#ch10list1) 和 [10-2](ch10.xhtml#ch10list2)
    中的代码，你可以手动输入，也可以从 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载副本。
- en: '***Calculating Probability of Detection for a Range of Civilizations***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***计算一系列文明的检测概率***'
- en: '[Listing 10-1](ch10.xhtml#ch10list1) imports modules and does all the work
    just described except for fitting the polynomial and displaying the `matplotlib`
    quality check.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 10-1](ch10.xhtml#ch10list1) 导入模块并完成所有刚才描述的工作，除了拟合多项式和显示`matplotlib`质量检查。'
- en: '*probability_of_detection.py,* part 1'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*probability_of_detection.py,* 第一部分'
- en: '[PRE1]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 10-1: Imports modules, randomly chooses radio-bubble-equivalent-volume
    locations, and calculates the probability of multiple civilizations per location*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10-1：导入模块，随机选择无线电气泡等效体积位置，并计算每个位置的多文明概率*'
- en: Import the familiar `random` module and `Counter`, for counting the number of
    civilizations at each location (designated by how many times a location has been
    chosen) ➊. How `Counter` works will be explained in a moment. You’ll use the `NumPy`
    and `matplotlib` imports to fit and display the polynomial.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 导入熟悉的`random`模块和`Counter`模块，用于计算每个位置的文明数量（由该位置被选择的次数来表示）➊。关于`Counter`的工作原理稍后会解释。你将使用`NumPy`和`matplotlib`的导入来拟合并显示多项式。
- en: Assign some constants that represent user input for the number of equivalent
    volumes, the maximum number of civilizations, the number of trials—that is, how
    many times to repeat the experiment for a given number of civilizations—and a
    step size for the count ➋. Because the results are predictable, you can use a
    large step value of 100 without compromising accuracy. Note that you’ll get very
    similar results whether the number of equivalent volumes is 100 or 100,000+.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为一些常量赋值，这些常量表示用户输入的等效体积数、最大文明数、试验次数——即，给定文明数下重复实验的次数——以及计数的步长➋。因为结果是可预测的，你可以使用一个较大的步长值
    100 而不影响精度。注意，无论等效体积数是 100 还是 100,000+，你都会得到非常相似的结果。
- en: You’ll need a series of paired (*x*, *y*) values for the polynomial expression,
    so start two lists to hold these ➌. The x-value will be the ratio of civilizations
    per volume, and the y-value will be the corresponding probability of detection.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一系列配对的(*x*, *y*)值来表示多项式表达式，因此先创建两个列表来存储这些值➌。x 值将是每单位体积的文明数量，y 值将是相应的检测概率。
- en: Start a series of nested loops, with the highest loop representing the number
    of civilizations to model ➍. You need at least two civilizations for one to detect
    the other, and set the maximum to `MAX_CIVS` plus 2, to overshoot when calculating
    the polynomial. Use the `CIV_STEP_SIZE` constant for the step value.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '开始一系列嵌套循环，最高层循环表示要模拟的文明数量➍。你至少需要两个文明才能让一个发现另一个，将最大值设置为`MAX_CIVS`加2，以便在计算多项式时超出范围。使用`CIV_STEP_SIZE`常量作为步长值。  '
- en: Next, calculate the overall `civs_per_vol` ratio and start a counter named `num_single_civs`
    to keep track of the number of locations containing a single civilization.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，计算总体的`civs_per_vol`比率，并启动一个名为`num_single_civs`的计数器，用于跟踪包含单一文明的位置数量。  '
- en: You’ve chosen how many civilizations to distribute, so now use a `for` loop
    to go through the number of trials ➎. For each trial, you distribute the same
    number of civilizations. Assign an empty list to the variable `locations` and
    then, for each civilization ➏, pick a location number at random and append it
    to the list. Duplicate values in the list will represent locations containing
    multiple civilizations.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经选择了要分配的文明数量，现在使用`for`循环遍历试验次数➎。对于每个试验，你分配相同数量的文明。将一个空列表分配给变量`locations`，然后对于每个文明➏，随机选择一个位置编号并将其添加到列表中。列表中的重复值将表示包含多个文明的位置。
- en: 'Run `Counter` on this list ➐ and get the values. End the loop by getting the
    number of locations that occur only once and add them to the `num_single_civs`
    counter. Here’s an example of how these three statements work:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个列表➐上运行`Counter`并获取结果。通过获取仅出现一次的位置数量来结束循环，并将其添加到`num_single_civs`计数器中。以下是这三个语句如何工作的示例：  '
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `alist` list contains five numbers, with one (124) duplicated. Running `Counter`
    on this list produces a dictionary with the numbers as the keys and the number
    of times they occur as the values. Passing `Counter` the values in `count`—with
    the `values()` method—creates another dictionary with the previous values as keys
    and the number of times they occur as the new values. You want to know how many
    numbers occur only once, so use the dictionary method `value_count[1]` to return
    the number of nonduplicated numbers. These, of course, would represent radio-bubble-equivalent
    volumes containing a single civilization.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`alist`列表包含五个数字，其中一个（124）是重复的。在这个列表上运行`Counter`会生成一个字典，数字作为键，出现的次数作为值。将`Counter`与`count`中的值一起传递——使用`values()`方法——会创建另一个字典，原先的值变为键，出现的次数变为新值。你需要知道哪些数字只出现一次，因此使用字典方法`value_count[1]`返回未重复的数字数量。当然，这些数字将代表包含单一文明的无线电气泡等效体积。  '
- en: Now use the results from `Counter` to calculate the probability of multiple
    civilizations per location for the current number of civilizations being distributed
    ➑. This is 1 minus the number of single-occupancy locations divided by the number
    of civilizations in each trial times the number of trials.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '现在使用`Counter`的结果来计算每个位置上多个文明的概率，针对当前文明分布数量➑。这等于1减去单一占用位置的数量，除以每次试验中的文明数量，再乘以试验次数。  '
- en: 'Follow this by printing the ratio of civilizations to volume and the probability
    that multiple civilizations share a location ➒. The first few lines of this output
    are as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来打印文明与体积的比率，以及多个文明共享一个位置的概率➒。输出的前几行如下：  '
- en: '[PRE3]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This printout serves as an initial QC step and is optional; comment it out if
    you want to speed up the runtime. Finish by appending the values to the `x` and
    `y` lists ➓.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '这个输出用于初步的质量检查步骤，属于可选项；如果你想加快运行速度，可以将其注释掉。最后将这些值添加到`x`和`y`列表➓中。  '
- en: '***Generating a Predictive Formula and Checking the Results***'
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***生成预测公式并检查结果***  '
- en: '[Listing 10-2](ch10.xhtml#ch10list2) uses `NumPy` to perform polynomial regression
    on the probability of detection versus the ratio of civilizations per volume calculated
    in [Listing 10-1](ch10.xhtml#ch10list1). You’ll use this polynomial equation in
    the next program to obtain probability estimates. To check that the resulting
    curve fits the data points, `matplotlib` displays the actual and predicted values.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10-2](ch10.xhtml#ch10list2)使用`NumPy`对[列表 10-1](ch10.xhtml#ch10list1)中计算的每单位体积的文明比率与探测概率进行多项式回归。你将在下一个程序中使用这个多项式方程来获取概率估算值。为了检查结果曲线是否与数据点吻合，`matplotlib`将显示实际值和预测值。  '
- en: '*probability_of_detection.py,* part 2'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*probability_of_detection.py,* 第二部分  '
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 10-2: Performs polynomial regression and displays a QC plot*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 10-2：执行多项式回归并显示质量检查图*  '
- en: Start by assigning a variable, `coefficients`, to the output from the `NumPy`
    `polyfit()` method ➊. This method takes as arguments the `x` and `y` lists and
    an integer representing the degree of the fitting polynomial. It returns a vector
    of coefficients, `p`, that minimizes the squared error.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'If you print the `coefficients` variable, you get the following output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To get the full expression, pass the `coefficients` variable to `poly1d` and
    assign the results to a new variable ➋. Print this variable, and you’ll see a
    similar equation to that shown in [Figure 10-5](ch10.xhtml#ch10fig5):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To check that the polynomial adequately reproduces the input, you’ll want to
    plot the ratio of civilizations to volume on the x-axis, with probability on the
    y-axis. To get the x-axis values, you can use the `NumPy` `linspace()` method,
    which returns evenly spaced numbers over a specified interval. Use a range of
    `(0, 5)`, as this will cover almost the full probability range.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: To post symbols for the calculated and predicted values, first pass the `plot()`
    method the `x` and `y` lists, plotting them using a period (dot), which is equivalent
    to the dots in [Figure 10-5](ch10.xhtml#ch10fig5) ➍. Then pass the predicted x-axis
    values (`xp`) and, to get the predicted y-axis probability, pass `p` the same
    variable, plotting the results using a dash.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Finish by limiting the y-axis to values of `–0.5` and `1.5` ➎ and use the `show()`
    method to actually display the graph ([Figure 10-6](ch10.xhtml#ch10fig6)) ➏. The
    resultant plot is simple and sparse, as its only purpose is to confirm that the
    polynomial regression is working as intended. You can alter the polynomial fit
    by increasing or decreasing the third argument in step ➊.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0199-01.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-6: Calculated results (dots) versus results predicted by the polynomial
    (line)*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Armed with these results, you can now estimate the probability of detection
    for any number of civilizations in the blink of an eye. All Python needs to do
    is solve a polynomial equation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '**Building the Graphical Model**'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The graphical model will be a 2D, top-down view of the galactic disc. Plotting
    the size of Earth’s present emissions bubble on this display will put in perspective
    both the size of the galaxy and our diminutive place within it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Modeling the Milky Way is all about modeling the spiral arms. Each spiral arm
    represents a *logarithmic spiral*, a geometric feature so common in nature it
    has been dubbed *spira mirabilis*—“miraculous spiral.” If you compare [Figure
    10-7](ch10.xhtml#ch10fig7) to [Figure 10-1](ch10.xhtml#ch10fig1), you can see
    how closely the structure of a hurricane resembles that of a galaxy. The eye of
    the hurricane can even be thought of as a supermassive black hole, with the eyewall
    representing the event horizon!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0199-02.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-7: Hurricane Igor*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Because spirals radiate out from a central point, or *pole*, you’ll more easily
    graph them with *polar coordinates* ([Figure 10-8](ch10.xhtml#ch10fig8)). With
    polar coordinates, the (*x*, *y*) coordinates used in the more familiar Cartesian
    coordinate system are replaced by (*r*, θ), where *r* is the distance from the
    center and θ is the angle made by *r* and the x-axis. The coordinates for the
    pole are (0, 0).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0200-01.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-8: Example polar coordinate system*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'The polar equation for a logarithmic spiral is:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '*r* = *ae*^(bθ)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: where *r* is the distance from the origin, θ is the angle from the x-axis, *e*
    is the base of natural logarithms, and *a* and *b* are arbitrary constants.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: You can use this formula to draw a single spiral; then, rotate and redraw the
    spiral three times to produce the four arms of the Milky Way. You’ll build the
    spirals out of circles of various sizes, which will represent stars. [Figure 10-9](ch10.xhtml#ch10fig9)
    is an example of one realization of the graphical model. Because the simulations
    are stochastic, each will be slightly different, and there are multiple variables
    you can tweak to change the appearance.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0200-02.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-9: The Milky Way, modeled using logarithmic spirals*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: I generated the image in [Figure 10-9](ch10.xhtml#ch10fig9) with `tkinter` (pronounced
    “tee-kay-inter”), the default GUI library for developing desktop applications
    in Python. Although primarily designed for GUI elements such as windows, buttons,
    scroll bars, and so on, `tkinter` can also generate graphs, charts, screensavers,
    simple games, and more. Among its advantages is that, as part of the standard
    Python distribution, it’s portable across all operating systems and there’s no
    need to install external libraries. It’s also well documented and easy to use.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Most Windows, macOS, and Linux machines come with `tkinter` already installed.
    If you don’t have it or need the latest version, you can download and install
    it from *[https://www.activestate.com/](https://www.activestate.com/)*. As always,
    if the module is already installed, you should be able to import it in the interpreter
    window with no errors:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Introductory Python books sometimes include overviews of `tkinter`, and you
    can find the official online documentation at *[https://docs.python.org/3/library/tk.html](https://docs.python.org/3/library/tk.html)*.
    Some other references on `tkinter` are included in “[Further Reading](ch10.xhtml#lev241)”
    on [page 212](ch10.xhtml#page_212).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '***Scaling the Graphical Model***'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The scale of the graphical model is in light-years per pixel, and the width
    of each pixel will equate to the diameter of a radio bubble. As a result, when
    the radio bubble being investigated changes diameter, the scale units will change,
    and the graphical model will need to be rebuilt. The following equation will scale
    the model to the bubble:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: scaled disc radius = disc radius / bubble diameter
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: where the disc radius is 50,000 and the length unit is light-years.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: When the selected radio bubble is small, the graphical model “zooms in,” and
    when it is large, it “zooms out” ([Figure 10-10](ch10.xhtml#ch10fig10)).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0201-01.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-10: Impact of radio bubble diameter on the appearance of the galactic
    model*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '***The Galaxy Simulator Code***'
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The galaxy simulator code will calculate the probability of detection for any
    number of civilizations and radio bubble sizes, and then generate a graphical
    model of the galaxy. When a bubble the size of our current emissions bubble is
    used, it will post and annotate our bubble in red, in the approximate location
    of our solar system. You can download the code from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '**Entering Inputs and Key Parameters**'
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 10-3](ch10.xhtml#ch10list3) starts *galaxy_simulator.py* by importing
    modules and putting the frequently accessed user input near the top.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '*galaxy_simulator.py,* part 1'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 10-3: Imports modules and assigns constants*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Import `tkinter` as `tk`, so you don’t have to type the full name when calling
    `tkinter` classes ➊. If you’re using Python 2, use `Tkinter`—with an uppercase
    *T*. You’ll also need the `random` and `math` modules.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Use a comment to highlight the main user-input section ➋ and assign the two
    inputs. Use `SCALE` for the diameter, in light-years, of the detectable electromagnetic
    bubble around each civilization ➌; `NUM_CIVS` is the number of civilizations to
    model, which you can determine using anything from the Drake equation to a total
    guess ➍.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting Up the tkinter Canvas and Assigning Constants**'
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The code in [Listing 10-4](ch10.xhtml#ch10list4) instantiates a `tkinter` window
    object with a canvas on which you can draw things. This is where the galaxy map,
    or graphical model, will appear. It also assigns constants related to the dimensions
    of the Milky Way.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '*galaxy_simulator.py,* part 2'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 10-4: Sets up* tkinter *window and canvas and assigns constants*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a window with the conventional name `root` ➊. This is a *top-level*
    window that will hold everything else. In the next line, give the window a title—“Milky
    Way galaxy”—which will appear in the upper left of the window frame (see [Figure
    10-9](ch10.xhtml#ch10fig9) for an example).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Next, add a component, known as a *widget*, to the root window. *Widget* stands
    for “Windows gadget.” There are 21 core widgets in `tkinter`, including labels,
    frames, radio buttons, and scroll bars. Assign a `Canvas` widget to contain all
    the drawing objects ➋. This is a general-purpose widget intended for graphics
    and other complex layouts. Specify the parent window, the screen width and height,
    and the background color. Name the canvas `c`, for *canvas*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: You can divide the `Canvas` widget into rows and columns, like a table or spreadsheet.
    Each cell in this grid can hold a different widget, and these widgets can span
    multiple cells. Within a cell, you can align a widget using the `STICKY` option.
    To manage each widget in a window, you’ll need to use the `grid` geometry manager.
    Since you’re using only one widget in this project, you don’t need to pass the
    manager anything ➌.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Finish by configuring the `canvas` to use a `scrollregion` ➍. This sets the
    origin coordinates `(0, 0)` to the center of the `canvas`. You need this to draw
    the galaxy’s spiral arms with polar coordinates. Without it, the default origin
    would be the top-left corner of the `canvas`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The arguments passed to `configure` set the limits of the `canvas`. These should
    be half of the `canvas` width and height; for example, scroll limits of `600,
    500` will require `canvas` dimensions of `1200, 1000`. The values shown here work
    well on a small laptop, but feel free to alter them later if you find you need
    a larger window.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Follow the input section with dimensional constants for the galaxy ➎. You could
    assign some of these variables within functions, but having them in the global
    space allows for a more logical flow to the code explanation. The first two are
    the radius and height of the galactic disc from [Figure 10-2](ch10.xhtml#ch10fig2).
    The final constant represents the disc volume ➏.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '**Scaling the Galaxy and Calculating the Probability of Detection**'
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 10-5](ch10.xhtml#ch10list5) defines functions to scale the galaxy
    dimensions based on the diameter of the radio bubble in use and to calculate the
    probability of one civilization detecting another. The latter function is where
    you apply the polynomial equation built with the *probability_of_detection.py*
    program described previously.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '*galaxy_simulator.py,* part 3'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 10-5: Scales galactic dimensions and calculates detection probability*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Define a function called `scale_galaxy()` to scale the galactic dimensions to
    the radio bubble size ➊. It will use the constants from the global space, so there
    is no need to pass it any arguments. Calculate the scaled disc radius and then
    the radio bubble volume, using the equation for the volume of a sphere, and assign
    the results to `bubble_vol` ➋.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Next, divide the actual disc volume by `bubble_vol` to get the scaled disc volume
    ➌. This is the number of radio bubble “equivalent volumes” that can fit in the
    galaxy. Each bubble constitutes a possible location for a civilization.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: End the function by returning the `disc_radius_scaled` and `disc_vol_scaled`
    variables ➍.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Now, define a function called `detect_prob()` to calculate the probability of
    detection, which takes the scaled disc volume as an argument ➎. For the `x` term
    in the polynomial, calculate the ratio of the number of civilizations to the scaled
    disc volume ➏. Since the polynomial regression can have problems at the endpoints,
    use conditionals to set very small ratios to `0` and large ratios to `1` ➐. Otherwise,
    apply the polynomial expression generated by the *probability_of_detection.py*
    code ➑, then return the probability rounded to three decimal places ➒.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Polar Coordinates**'
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 10-6](ch10.xhtml#ch10list6) defines a function to select random (*x*,
    *y*) locations using polar coordinates. This function will choose the locations
    of some of the stars posted in the graphical model. Because the display is 2D,
    there’s no need to choose a *z* location.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '*galaxy_simulator.py,* part 4'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 10-6: Defines a function to randomly pick an (*x, y*) pair with polar
    coordinates*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The function takes the scaled disc radius as an argument ➊. Use the `random()`
    function to choose a float value between 0.0 and 1.0 and assign it to the variable
    `r` ➋. Next, randomly choose `theta` from a uniform distribution between 0 and
    360 degrees (2π is the radian equivalent of 360 degrees) ➌.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'The transformation to generate points *evenly* over a *unit* disc is:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0205-01.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: The equations yield (*x*, *y*) values between -1 and 1\. To scale the results
    to the galactic disc, multiply by the scaled disc radius ➍. End the function by
    returning `x` and `y` ➎.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '**Building Spiral Arms**'
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 10-7](ch10.xhtml#ch10list7) defines a function that builds the spiral
    arms using the logarithmic spiral equation. This spiral may be miraculous, but
    a large part of the magic is tinkering with the initial bare-bones spiral to flesh
    out the arm. You’ll accomplish this by varying the size of stars, randomly altering
    their positions a tiny amount, and duplicating the spiral for each arm in order
    to shift it slightly backward and dim its stars.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '*galaxy_simulator.py,* part 5'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 10-7: Defines the* spirals() *function*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Define a function called `spirals()` ➊. Its parameters are listed in the function
    docstring. The first two parameters, `b` and `r`, are from the logarithmic spiral
    equation. The next, `rot_fac`, is the rotation factor that lets you move the spiral
    around the center point so you can produce a new spiral arm. The fuzz factor,
    `fuz_fac`, lets you tweak how far you move stars away from the center of the spiraling
    line. Finally, the `arm` parameter lets you specify either the leading arm or
    the trailing arm of faint stars. The trailing arm will be shifted—that is, plotted
    a little behind the leading arm—and its stars will be smaller.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Initialize an empty list to hold the locations of the stars that will make up
    the spiral ➋. Assign a `fuzz` variable, where you multiply an arbitrary constant
    by the absolute value of the scaled disc radius ➌. The spiral equation alone produces
    stars that are lined up (see the left two panels in [Figure 10-11](ch10.xhtml#ch10fig11)).
    Fuzzing will move stars in the spiral back and forth a little, to either side
    of the spiral line. You can see the effect on the bright stars in the rightmost
    panel in [Figure 10-11](ch10.xhtml#ch10fig11). I determined these values through
    trial and error; feel free to play with them if you like.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0206-01.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-11: Filling out the spiral arms by shifting spirals and randomly
    changing star positions*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to build the spiral lines. First, use a range of values to represent
    θ in the logarithmic spiral equation ➍. A range of about `520` will produce the
    galaxy in [Figure 10-9](ch10.xhtml#ch10fig9), which has a central “black hole.”
    Otherwise, use a range of `(0, 600, 2)`—or similar—to produce a bright central
    core fully packed with stars ([Figure 10-12](ch10.xhtml#ch10fig12)). You can tinker
    with these values until you get your preferred result. Loop through the values
    in `theta` and apply the logarithmic spiral equation, using cosine for the x-value
    and sine for the y-value. Note that you add the `fuzz` value, multiplied by the
    fuzz factor, to the result. Append each (*x*, *y*) pair to the `spiral_stars`
    list.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0207-01.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-12: Graphical model without the central black hole (compare to [Figure
    10-9](ch10.xhtml#ch10fig9))*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Later, in the `main()` function, you’ll specify the `rot_fac` variable, which
    will move the spiral around the center. After the program builds the four main
    arms, it will use `rot_fac` to build four new arms, slightly offset from the first
    four, to produce the band of dim, trailing stars seen to the left of each arc
    of bright stars in [Figure 10-11](ch10.xhtml#ch10fig11).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the list of star locations, start a `for` loop through the
    (*x*, *y*) coordinates ➎. Then use a conditional statement to choose the main,
    leading arm and locations for which `x` is even ➏. For these, use the `canvas`
    widget’s `create_oval()` method to create a star object to post. This method’s
    first four arguments define a bounding box into which the oval fits. The larger
    the number after `x` and `y`, the larger the oval. Make the fill white and don’t
    use an outline; the default outline is a thin black line.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: If the x-value is odd, make the star a step smaller. And if the `arm` value
    is `1`, the star is in the shifted arm, so make it as small as possible ➐.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '*The star objects are for visual impact only. Neither their size nor number
    is to scale. To be realistic, they would be much, much smaller and much more numerous
    (over 100 billion!).*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '**Scattering Star Haze**'
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The space between the spiral arms isn’t devoid of stars, so the next function
    ([Listing 10-8](ch10.xhtml#ch10list8)) randomly casts points across the galactic
    model, with no regard for spiral arms. Think of this as the glow you see in photographs
    of distant galaxies.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '*galaxy_simulator.py,* part 6'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 10-8: Defines the* star_haze() *function*'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the `star_haze()` function and pass it two arguments: the scaled disc
    radius and an integer multiplier that the function will use to increase the base
    number of random stars ➊. So, if you prefer a thick fog rather than a light haze,
    increase the value of the density value when you call the function in `main()`.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Start a `for` loop where the maximum range value is equal to the scaled disc
    radius multiplied by `density` ➋. By using the radius value, you scale the number
    of stars to the size of the disc being displayed. Then call the `random_polar_coordinates()`
    function to get an (*x*, *y*) pair ➌.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: End by creating a display object for the canvas using the (*x*, *y*) pair ➍.
    Since you’ve already used the smallest oval size for the stars along and around
    the spiral, use the `create_text()` method instead of `create_oval()`. With this
    method, you can use a period to represent a star. The font size parameter will
    allow you to scale the haze stars until you find something aesthetically pleasing.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-13](ch10.xhtml#ch10fig13) is a comparison between the galactic model
    without the star haze (left) and with the star haze (right).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0208-01.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-13: Galactic model without star haze (left) versus with star haze
    (right)*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: You can be creative with the haze. For example, you can make the stars more
    numerous and color them gray, or use a loop to vary both their size and color.
    Don’t use green, however, as there are no green stars in the universe!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '**Defining the main() Function**'
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 10-9](ch10.xhtml#ch10list9) defines the `main()` function in *galaxy_simulator.py*.
    It will make the calls to scale the galaxy, calculate the probability of detection,
    build the galaxy display, and post statistics. It will also run the `tkinter`
    main loop.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '*galaxy_simulator.py,* part 8'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 10-9: Defines and calls the* main() *function*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Start `main()` by calling the `scale_galaxy()` function to get the scaled disc
    volume and radius ➊. Then call the `detect_prob()` function and pass it the `disc_vol_scaled`
    variable. Assign the results to a variable named `detection_prob`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Now build the galaxy display (graphical model) ➋. This calls the `spirals()`
    function multiple times, with small changes to each call. The `arm` parameter
    designates the bright main arms and the faint trailing arms. The `rot_fac` (rotation
    factor) variable determines where the spiral plots. The slight change in rotation
    factor between arms 0 and 1 (for example, `2` to `1.91`) is what causes the faint
    arm to plot slightly offset from the bright arm. Finish the display by calling
    the `star_haze()` function. Again, feel free to experiment with any of these parameters.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Next, display a legend and statistics. Start with the scale ➌ and radio bubble
    diameter followed by the probability of detection for the given number of civilizations.
    Arguments include the x and y coordinates, a fill (text) color, a justification
    anchor—with left represented by `w` for “west”—and the text. Note the use of `{:,}`
    to insert a comma as a thousand separator. This is part of the newer *string format
    method*. You can read more about it at *[https://docs.python.org/3/library/string.html#string-formatting](https://docs.python.org/3/library/string.html#string-formatting)*.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user has selected a radio bubble diameter of `225` LY ➍, then the display
    is at the same scale as our own emissions bubble, so post a red pixel at the approximate
    location of our solar system and annotate it ➎. There are a number of ways to
    display a single pixel using `tkinter`. Here, you use the `create_rectangle()`
    method, but you can also make a line that is one pixel long with the following
    statement:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With the `create_rectangle()` method, the first two arguments are points (`x0`,
    `y0`), which correspond to the top-left corner, and (`x1`, `y1`), the location
    of the pixel just outside of the bottom-right corner. With the `create_line()`
    method, the arguments are for the starting and ending points. The default line
    width is one pixel.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: End the `main()` function by executing the `tkinter` `mainloop()` function,
    also known as the *event loop* ➏. This keeps the `root` window open until you
    close it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Back in the global space, end the program by allowing it to be run stand-alone
    or called as a module in another program ➐.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: The final display will look like [Figure 10-14](ch10.xhtml#ch10fig14), shown
    with the Earth’s radio bubble and a central black hole.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0210-01.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-14: The final display, with Earth’s 225 LY diameter radio bubble
    posted on the galactic map*'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Note that, despite the fact that our radio bubble is no bigger than a pinprick
    at this scale, if civilizations had a detection range of 112.5 light-years, and
    if there were as many of these civilizations as predicted by current high-side
    parameters for the Drake equation, the probability of detection is 1!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '**Results**'
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given the enormous uncertainty in the inputs and the use of simplifying assumptions,
    you’re not looking for accuracy here. What you’re looking for is *directionality*.
    Should we (or anyone like us) expect to detect another civilization that isn’t
    actively trying to contact us? Based on [Figure 10-15](ch10.xhtml#ch10fig15),
    probably not.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0211-01.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-15: Probability of one civilization detecting another for different
    radio bubble diameters and different numbers of civilizations in the galaxy*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: With our current technology, we could detect emissions from a civilization as
    far away as 16 LY, which equates to a 32 LY diameter radio bubble. Even if the
    galaxy is filled with 15.6 million advanced civilizations, as predicted by the
    updated Drake equation in the Wikipedia article, the chance of detecting 32 LY
    radio bubbles is less than 4 percent!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Take another look at [Figure 10-14](ch10.xhtml#ch10fig14), and you can begin
    to appreciate the sheer enormity and emptiness of our galaxy. Astronomers even
    have a word for this: *Laniakea*, Hawaiian for “immeasurable heaven.”'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Earth is, as Carl Sagan described it, just a “mote of dust, suspended in a sunbeam.”
    And recent studies suggest that the window of opportunity for detecting civilizations
    with radio waves is much smaller than we thought. If other civilizations follow
    our lead and switch to digital signals and satellite communications, then their
    incidental radio leakage will drop by at least a factor of four. We all become
    unintentionally stealthy, blooming for a hundred years or so, then fading away.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Given these facts, it’s not surprising that the government no longer funds the
    search for extraterrestrial intelligence using radio telescopes. These days, efforts
    are shifting to optical methods that look for signature gases in the atmospheres
    of exoplanets, such as the waste products of life and industrial activity.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you gained experience using `tkinter`, `matplotlib`, and `NumPy`.
    You generated a polynomial expression for making reasonable estimates of the likelihood
    of detecting incidental alien radio transmissions, and you used the always-available
    `tkinter` module to add a cool visual component to the analysis.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Are We Alone? Philosophical Implications of the Discovery of Extraterrestrial
    Life* (BasicBooks, 1995) by Paul Davies is a thoughtful look at the search for
    alien life, told by an eminent scientist and award-winning science writer.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: “A New Formula Describing the Scaffold Structure of Spiral Galaxies” (*Monthly
    Notices of the Royal Astronomical Society*, July 21, 2009) by Harry I. Ringermacher
    and Lawrence R. Mead (*[https://arxiv.org/abs/0908.0892v1](https://arxiv.org/abs/0908.0892v1)*)
    provides formulas for modeling the shapes of spiral galaxies observed by the Hubble
    telescope.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '“Tkinter 8.5 Reference: A GUI for Python” (New Mexico Tech Computer Center,
    2013) by John W. Shipman is a useful supplement to the official `tkinter` docs.
    It can be found at *[http://infohost.nmt.edu/tcc/help/pubs/tkinter/tkinter.pdf](http://infohost.nmt.edu/tcc/help/pubs/tkinter/tkinter.pdf)*.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Another useful online `tkinter` resource is *[https://wiki.python.org/moin/TkInter/](https://wiki.python.org/moin/TkInter/)*.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '*Tkinter GUI Application Development HOTSHOT* (Packt Publishing, 2013) by Bhaskar
    Chaudhary uses a project-based approach to teach `tkinter`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Projects**'
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try these three spin-off projects. You can find them in the appendix or download
    them from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '***A Galaxy Far, Far Away***'
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tired of living in the Milky Way galaxy? Heck, who isn’t? Fortunately, there’s
    more in heaven and earth than just logarithmic spirals. Use Python and `tkinter`
    to build us a new home—but not necessarily a realistic home. For inspiration,
    visit online articles like Alexandre Devert’s post on his Marmakoide’s Blog, “Spreading
    Points on a Disc and on a Sphere” (*[http://blog.marmakoide.org/](http://blog.marmakoide.org/)*).
    The example shown in [Figure 10-16](ch10.xhtml#ch10fig16) was built with *galaxy_practice.py*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0213-01.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-16: Galaxy produced by the* galaxy_practice.py *program*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '***Building a Galactic Empire***'
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pick a location in the galaxy, an average travel speed of 5 to 10 percent of
    the speed of light, and a time step of 500,000 years. Then model the expansion
    of a space-faring empire. At each time step, calculate the size of the expanding
    *colonization bubble* and update the galaxy map. Check your results by placing
    the home-world location at the center of the galaxy, setting the speed to `1`,
    and confirming that it takes 50,000 years to reach the edge of the galaxy.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: When you have the program up and running, you can perform interesting experiments.
    For example, you can test how fast we would need to go to explore the galaxy in
    10 million years, as mentioned in the introduction to this chapter (see [Figure
    10-17](ch10.xhtml#ch10fig17)).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0213-02.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-17: A core-located empire’s expansion using travel below light speed
    over 10 million years*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: You could also estimate how much of the galaxy the *Star Trek* Federation could
    have explored in its first 100 years, assuming they averaged 100x light speed
    at warp 4 ([Figure 10-18](ch10.xhtml#ch10fig18)).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0214-01.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-18: Expansion of the* Star Trek *Federation in first 100 years under
    warp factor 4*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: These figures were built with the *empire_practice.py* program.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '***A Roundabout Way to Predict Detectability***'
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another way to predict the probability of detection is to use polar coordinates
    to distribute civilizations—as xyz points—in the galactic disc and then round
    the points to the nearest radio bubble *radius*. Points that share the same location
    represent civilizations that could detect each other. But be careful—this method
    rounds using cubes rather than spheres, so you’ll need to convert the radius to
    the side of a cube that produces the same volume.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Write the program so that it predicts the probability of detecting 16 LY *radius*
    bubbles (the limit of our current technology) given 15,600,000 transmitting civilizations
    randomly distributed throughout the galaxy (updated Drake equation output from
    Wikipedia). Use the full 50,000 LY radius and 1,000 LY height of the galactic
    model when distributing the civilizations.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: For a solution, see *rounded_detection_practice.py*. Note that the program will
    take several minutes to run.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '**Challenge Projects**'
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here are a few follow-up projects to try on your own. Remember that I don’t
    provide solutions to challenge projects.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a Barred-Spiral Galaxy***'
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our understanding of the Milky Way evolves as we obtain and analyze new astronomical
    data. Scientists now believe that the core of the galaxy is elongated and bar
    shaped. Use the equations provided in the Ringermacher and Mead paper, cited in
    “[Further Reading](ch10.xhtml#lev241)” on [page 212](ch10.xhtml#page_212), to
    create a new `tkinter` visual model of the galaxy that honors the barred-spiral
    concept.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '***Adding Habitable Zones to Your Galaxy***'
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Solar systems have *Goldilocks zones* that are favorable for the development
    of life. Planets orbiting in these zones stay warm enough for at least some of
    their water to remain in liquid state.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: There is also a theory that galaxies, like solar systems, have *habitable zones*
    in which life is more likely to develop. One definition of the habitable zone
    for the Milky Way places its inner boundary about 13,000 LY from the galactic
    center and its outer boundary about 33,000 LY from the center ([Figure 10-19](ch10.xhtml#ch10fig19)).
    The core is excluded due to the high levels of radiation, large number of supernovas,
    and complex orbit-disrupting gravitational fields resulting from all the closely
    spaced stars. The rim areas are condemned due to low metallicity, which is crucial
    to the development of planets.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0215-01.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-19: Approximate galactic habitable zone (shaded) superimposed on
    the Milky Way model*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: A refinement of the habitable zone model excludes spiral arms, for reasons similar
    to those applied to the core. Our own existence doesn’t contradict this. Earth
    is located in the Orion “spur,” a relatively small feature between the Sagittarius
    and Perseus arms.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Edit the *galaxy_simulation.py* program so that it uses only the volume in the
    galactic habitable zone, however you define it. You should research what these
    volumes may be and what effect they’ll have on the number of civilizations (*N*)
    that the Drake equation calculates. Consider using *regions*, such as the core,
    spirals, outer rim, and so on, within which *N* is different but civilizations
    are still randomly distributed. Highlight these regions on the galactic map and
    post their probability-of-detection estimates.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
