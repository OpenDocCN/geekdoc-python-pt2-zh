- en: '[6](nsp-venkitachalam503045-0008.xhtml#rch06)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[6](nsp-venkitachalam503045-0008.xhtml#rch06)'
- en: ASCII Art
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASCII 艺术
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: In the 1990s, when email ruled and graphics capabilities were limited, it was
    common to include a signature in your email that contained a graphic made of text,
    commonly called *ASCII art*. (ASCII is simply a character-encoding scheme.) [Figure
    6-1](nsp-venkitachalam503045-0019.xhtml#fig6-1) shows a couple of examples. Although
    the internet has made sharing images immeasurably easier, the humble text graphic
    isn’t quite dead yet.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1990 年代，当电子邮件盛行且图形能力有限时，通常会在电子邮件中附上一个由文本构成的图形签名，这种图形通常被称为 *ASCII 艺术*。（ASCII
    只是一个字符编码方案。）[图 6-1](nsp-venkitachalam503045-0019.xhtml#fig6-1) 显示了几个示例。尽管互联网让图像的分享变得异常容易，但谦逊的文本图形仍然没有完全消失。
- en: ASCII art has its origins in typewriter art created in the late 1800s. In the
    1960s, when computers had minimal graphics processing hardware, ASCII was used
    to represent images. These days, ASCII art continues as a form of expression on
    the internet, and you can find a variety of creative examples online.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII 艺术起源于 1800 年代末期的打字机艺术。在 1960 年代，当时计算机的图形处理硬件非常有限时，ASCII 被用来表示图像。如今，ASCII
    艺术作为一种表达形式仍在互联网上存在，你可以在网上找到各种创意的例子。
- en: '![](images/nsp-venkitachalam503045-f06001.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f06001.jpg)'
- en: 'Figure 6-1: Examples of ASCII art'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-1：ASCII 艺术示例
- en: 'In this project, you’ll use Python to create a program that generates ASCII
    art from graphical images. The program will let you specify the width of the output
    (the number of columns of text) and set a vertical scale factor. It also supports
    two mappings of grayscale values to ASCII characters: a sparse 10-level mapping
    and a more finely calibrated 70-level mapping.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用 Python 创建一个程序，从图形图像生成 ASCII 艺术。该程序允许你指定输出的宽度（文本列数）并设置垂直缩放因子。它还支持两种灰度值到
    ASCII 字符的映射：稀疏的 10 级映射和更加精细的 70 级映射。
- en: 'To generate your ASCII art from an image, you’ll learn how to do the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要从图像生成 ASCII 艺术，你需要学习以下内容：
- en: • Convert images to grayscale using `Pillow`, a fork of the Python Imaging Library
    (PIL).
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 `Pillow`（Python Imaging Library（PIL）的一个分支）将图像转换为灰度图。
- en: • Compute the average brightness of a grayscale image using `numpy`.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用 `numpy` 计算灰度图像的平均亮度。
- en: • Use a string as a quick lookup table for grayscale values.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用字符串作为灰度值的快速查找表。
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah0801)'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[它是如何工作的](nsp-venkitachalam503045-0008.xhtml#rah0801)'
- en: This project takes advantage of the fact that from a distance, we perceive grayscale
    images as the average value of their brightness. For example, in [Figure 6-2](nsp-venkitachalam503045-0019.xhtml#fig6-2),
    you can see a grayscale image of a building and, next to it, an image filled with
    the average brightness value of the building image. If you look at the images
    from across the room, they will look similar.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目利用了从远处看时，我们将灰度图像看作其亮度平均值的特点。例如，在 [图 6-2](nsp-venkitachalam503045-0019.xhtml#fig6-2)
    中，你可以看到一张建筑物的灰度图像，以及其旁边填充有建筑物图像的平均亮度值的图像。如果你从房间另一端看这些图像，它们会看起来非常相似。
- en: ASCII art is generated by splitting an image into tiles and replacing each tile
    with an ASCII character, based on the tile’s average brightness value. Brighter
    tiles are replaced with sparser ASCII characters (that is, characters that contain
    a lot of whitespace), such as a period (`.`) or colon (`:`), while darker tiles
    are replaced with denser ASCII characters, such as an ampersand (`@`) or dollar
    sign (`$`). From a distance, since our eyes have limited resolution, we sort of
    see the “average” values in ASCII art while losing the details that would otherwise
    make the art look less real.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII 艺术是通过将图像分割成瓦片，并根据每个瓦片的平均亮度值，将每个瓦片替换为一个 ASCII 字符来生成的。较亮的瓦片会被替换为稀疏的 ASCII
    字符（即包含大量空格的字符），例如句点（`.`）或冒号（`:`），而较暗的瓦片则被替换为密集的 ASCII 字符，例如和号（`@`）或美元符号（`$`）。从远处看，由于我们的眼睛分辨率有限，我们大致上能看到
    ASCII 艺术中的“平均”值，而失去的细节使得艺术作品看起来不那么真实。
- en: '![](images/nsp-venkitachalam503045-f06002.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f06002.jpg)'
- en: 'Figure 6-2: The average value of a grayscale image'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-2：灰度图像的平均值
- en: This program will take a given image and first convert it to 8-bit grayscale
    so that each pixel has a grayscale value in the range [0, 255] (the range of an
    8-bit integer). Think of this 8-bit value as the pixel’s *brightness*, with 0
    being black, 255 being white, and the values in between being shades of gray.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将接收一张给定的图像，首先将其转换为8位灰度图像，使得每个像素的灰度值在[0, 255]范围内（这是8位整数的范围）。可以把这个8位值看作是像素的*亮度*，其中0表示黑色，255表示白色，介于两者之间的是不同的灰度。
- en: Next, it will split the image into a grid of *M*×*N* tiles (where *M* is the
    number of rows and *N* the number of columns in the ASCII image). The program
    will then calculate the average brightness value for each tile in the grid and
    match it with an appropriate ASCII character by predefining a *ramp* (an increasing
    set of values) of ASCII characters to represent grayscale values in the range
    [0, 255]. It will use these ramp values as a lookup table for the brightness values.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它将把图像分割成*M*×*N*的网格（其中*M*是ASCII图像的行数，*N*是列数）。程序接着会计算网格中每个图块的平均亮度值，并通过预定义的ASCII字符*渐变*（一组递增的值）来匹配一个合适的ASCII字符，表示[0,
    255]范围内的灰度值。它将使用这些渐变值作为亮度值的查找表。
- en: The finished ASCII art is just a bunch of lines of text. To display the text,
    you’ll use a constant-width (also called *monospace*) font such as Courier because
    unless each text character has the same width, the characters in the image won’t
    line up properly along a grid, and you’ll end up with unevenly spaced and scrambled
    output.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的ASCII艺术仅仅是一些文本行。为了显示这些文本，你将使用一种固定宽度（也叫做*等宽*）字体，比如Courier，因为只有当每个字符的宽度相同时，图像中的字符才能正确地沿网格对齐，否则最终输出的字符将不均匀间隔并且杂乱无章。
- en: The *aspect ratio* (the ratio of width to height) of the font used also affects
    the final image. If the aspect ratio of the space taken up by a character is different
    from the aspect ratio of the image tile the character is replacing, the final
    ASCII image will appear distorted. In effect, you’re trying to replace an image
    tile with an ASCII character, so their shapes need to match. For example, if you
    were to split your image into square tiles and then replace each of the tiles
    with a font where characters are taller than they are wide, the final output would
    appear stretched vertically. To address this issue, you’ll scale the rows in your
    grid to match the Courier aspect ratio. (You can send the program command line
    arguments to modify the scaling to match other fonts.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所使用字体的*纵横比*（宽度与高度的比值）也会影响最终图像。如果一个字符所占的空间的纵横比与它所替换的图像块的纵横比不同，最终的ASCII图像就会出现失真。实际上，你是在尝试用ASCII字符替换图像块，因此它们的形状需要匹配。例如，如果你把图像分割成方形图块，然后用一个字符高于宽的字体替换每个图块，最终输出将呈现垂直拉伸的效果。为了解决这个问题，你需要将网格中的行缩放，以匹配Courier字体的纵横比。（你可以通过发送程序命令行参数来修改缩放，以匹配其他字体。）
- en: 'In sum, here are the steps the program takes to generate the ASCII image:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，程序生成ASCII图像的步骤如下：
- en: 1\. Convert the input image to grayscale.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 将输入图像转换为灰度图像。
- en: 2\. Split the image into *M*×*N* tiles.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 将图像分割成*M*×*N*的图块。
- en: 3\. Correct *M* (the number of rows) to match the image and font aspect ratio.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 校正*M*（行数），以匹配图像和字体的纵横比。
- en: 4\. Compute the average brightness for each image tile and then look up a suitable
    ASCII character for each.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4\. 计算每个图像块的平均亮度，然后查找一个合适的ASCII字符来表示每个块。
- en: 5\. Assemble rows of ASCII character strings and print them to a file to form
    the final image.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 5\. 将ASCII字符字符串组装成行，并将它们打印到文件中，形成最终的图像。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah0802)'
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[要求](nsp-venkitachalam503045-0008.xhtml#rah0802)'
- en: In this project, you’ll use `Pillow`, the friendly fork of the Python Imaging
    Library, to read in the images, access their underlying data, and create and modify
    them. You’ll also use the `numpy` library to compute averages.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你将使用`Pillow`，Python Imaging Library的友好分支，来读取图像、访问其底层数据，并创建和修改它们。你还将使用`numpy`库来计算平均值。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah0803)'
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah0803)'
- en: You’ll begin by defining the grayscale levels used to generate the ASCII art.
    Then you’ll look at how the image is split into tiles and how average brightness
    is computed for those tiles. Next, you’ll work on replacing the tiles with ASCII
    characters to generate the final output. Finally, you’ll set up command line parsing
    for the program to allow users to specify the output size, output filename, and
    so on.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你将首先定义用于生成ASCII艺术的灰度级别。然后，看看图像是如何拆分成瓦片，以及如何计算这些瓦片的平均亮度。接下来，你将替换瓦片中的字符，以生成最终输出。最后，你将设置程序的命令行解析，允许用户指定输出大小、输出文件名等。
- en: For the full project code, skip to [“The Complete Code”](nsp-venkitachalam503045-0019.xhtml#ah0807)
    on [page 109](nsp-venkitachalam503045-0019.xhtml#p109). You can also download
    the code for this project from [https://github.com/mkvenkit/pp2e/blob/main/ascii/ascii.py](https://github.com/mkvenkit/pp2e/blob/main/ascii/ascii.py).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的项目代码，请跳转至[“完整代码”](nsp-venkitachalam503045-0019.xhtml#ah0807)，位于[第109页](nsp-venkitachalam503045-0019.xhtml#p109)。你也可以从[https://github.com/mkvenkit/pp2e/blob/main/ascii/ascii.py](https://github.com/mkvenkit/pp2e/blob/main/ascii/ascii.py)下载此项目的代码。
- en: '[Defining the Grayscale Levels and Grid](nsp-venkitachalam503045-0008.xhtml#rbh0801)'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[定义灰度级和网格](nsp-venkitachalam503045-0008.xhtml#rbh0801)'
- en: As the first step in creating your program, define the scales you’ll use to
    convert image brightness values to ASCII characters as global values.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建程序的第一步，定义你将用于将图像亮度值转换为ASCII字符的灰度级别作为全局值。
- en: 70 levels of gray
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 70个灰度级
- en: gscale1 = "$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~<>i!lI;:,\"^`'.
    "
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: gscale1 = "$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~<>i!lI;:,\"^`'.
    "
- en: 10 levels of gray
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10个灰度级
- en: gscale2 = "@%#*+=-:. "
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: gscale2 = "@%#*+=-:. "
- en: The value `gscale1` is a 70-level grayscale ramp, while `gscale2` is a simpler
    10-level grayscale ramp. Both of these values are stored as strings, with a range
    of characters that progress from darkest to lightest. The program will use the
    `gscale2` ramp by default, but you’ll include a command line option to use the
    more nuanced `gscale1` ramp instead.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`gscale1`的值是70级灰度渐变条，而`gscale2`是一个较简单的10级灰度渐变条。这两个值都作为字符串存储，字符从最暗到最亮按顺序排列。程序默认使用`gscale2`渐变条，但你会加入一个命令行选项，以便使用更细致的`gscale1`渐变条。'
- en: NOTE To learn more about how characters are represented as grayscale values,
    see Paul Bourke’s “Character Representation of Grey Scale Images” at [http://paulbourke.net/dataformats/asciiart/](http://paulbourke.net/dataformats/asciiart/).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：要了解更多关于字符如何表示灰度值的信息，请查看Paul Bourke的《字符表示灰度图像》文章，地址为[http://paulbourke.net/dataformats/asciiart/](http://paulbourke.net/dataformats/asciiart/)。
- en: 'Now that you have your grayscale ramps, you can set up the image. The following
    code opens the image using `Pillow` and splits it into a grid:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了灰度渐变条，可以设置图像。以下代码使用`Pillow`打开图像并将其拆分成网格：
- en: open the image and convert to grayscale
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开图像并转换为灰度图
- en: image = Image.open(fileName).convert("L")
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: image = Image.open(fileName).convert("L")
- en: store the image dimensions
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储图像尺寸
- en: ❶ W, H = image.size[0], image.size[1]
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ W, H = image.size[0], image.size[1]
- en: compute the tile width
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算瓦片宽度
- en: ❷ w = W/cols
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ w = W/cols
- en: compute the tile height based on the aspect ratio and scale of the font
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据纵横比和字体缩放计算瓦片高度
- en: ❸ h = w/scale
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ h = w/scale
- en: compute the number of rows to use in the final grid
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算最终网格中要使用的行数
- en: ❹ rows = int(H/h)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ rows = int(H/h)
- en: First, `Image.``open()` opens the input image file, and `Image.``convert()`
    converts the image to grayscale. The `"L"` stands for *luminance*, a measure of
    the brightness of an image. You store the width and height (measured in pixels)
    of the input image ❶. Then you compute the width of a tile for the number of columns
    (`cols`) specified by the user ❷. (The program uses a default of 80 columns if
    the user doesn’t set another value in the command line.) You use floating-point,
    not integer, division to avoid truncation errors while calculating the dimensions
    of the tiles.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`Image.``open()`打开输入的图像文件，`Image.``convert()`将图像转换为灰度图。`"L"`表示*亮度*，即图像亮度的度量。你将输入图像的宽度和高度（以像素为单位）存储在变量中
    ❶。然后，你根据用户指定的列数（`cols`）计算每个瓦片的宽度 ❷。（如果用户没有在命令行中设置其他值，程序会使用默认的80列。）你使用浮点数除法，而不是整数除法，以避免计算瓦片尺寸时的截断错误。
- en: Once you know the width of a tile, you compute its height using the vertical
    scale factor passed in as `scale` ❸. This way, each tile will match the aspect
    ratio of the font you’re using to display the text so that the final image won’t
    be distorted. The value for `scale` can be passed in as an argument, or it’s set
    to a default of `0.43`, which works well for displaying the result in Courier.
    Having calculated the height of each row, you compute the number of rows in the
    grid ❹.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道了瓷砖的宽度，你就可以使用传入的垂直比例因子 `scale` ❸ 来计算其高度。这样，每个瓷砖的比例将与用于显示文本的字体的宽高比匹配，以避免最终图像变形。`scale`
    的值可以作为参数传入，或者默认为 `0.43`，该值在使用 Courier 字体显示结果时效果很好。计算出每一行的高度后，你可以计算网格中的行数 ❹。
- en: '[Computing the Average Brightness](nsp-venkitachalam503045-0008.xhtml#rbh0802)'
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[计算平均亮度](nsp-venkitachalam503045-0008.xhtml#rbh0802)'
- en: Next, you need a way to compute the average brightness for a tile in the grayscale
    image. The function `getAverageL()` does the job.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要一种方法来计算灰度图像中瓷砖的平均亮度。`getAverageL()` 函数完成了这项工作。
- en: 'def getAverageL(image):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getAverageL(image):'
- en: '# get the image as a numpy array'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将图像转换为 numpy 数组'
- en: ❶ im = np.array(image)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ im = np.array(image)
- en: '# get the dimensions'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取尺寸'
- en: w,h = im.shape
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: w,h = im.shape
- en: '# get the average'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取平均值'
- en: ❷ return np.average(im.reshape(w*h))
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回 np.average(im.reshape(w*h))
- en: The image tile is passed into the function as a PIL `Image` object. You convert
    the image into a `numpy` array ❶, at which point `im` becomes a two-dimensional
    array containing the brightness values of the image’s pixels. You store the dimensions
    (width and height) of the array and then use `numpy.reshape()` to convert the
    two-dimensional array into a flat one-dimensional array whose length is a product
    of the original array’s width and height (`w*h`). You pass the reshaped array
    to `numpy.average()`, which sums the array values and computes the average brightness
    level of the entire image tile ❷.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图像瓷砖作为一个 PIL `Image` 对象传递给函数。你将图像转换为一个 `numpy` 数组 ❶，此时 `im` 成为一个包含图像像素亮度值的二维数组。你存储该数组的尺寸（宽度和高度），然后使用
    `numpy.reshape()` 将二维数组转换为一个一维的扁平数组，该数组的长度是原数组宽度和高度的乘积（`w*h`）。你将重塑后的数组传递给 `numpy.average()`，它会求和数组值并计算整个图像瓷砖的平均亮度
    ❷。
- en: '[Generating the ASCII Content from the Image](nsp-venkitachalam503045-0008.xhtml#rbh0803)'
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[从图像生成 ASCII 内容](nsp-venkitachalam503045-0008.xhtml#rbh0803)'
- en: 'The main part of the program generates the ASCII content from the image:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的主要部分是从图像生成 ASCII 内容：
- en: an ASCII image is a list of character strings
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个 ASCII 图像是一个字符字符串的列表
- en: ❶ aimg = []
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ aimg = []
- en: generate the list of tile dimensions
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成瓷砖尺寸列表
- en: '❷ for j in range(rows):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对于 j 在 range(rows) 中：
- en: y1 = int(j*h)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: y1 = int(j*h)
- en: y2 = int((j+1)*h)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: y2 = int((j+1)*h)
- en: '# correct the last tile'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '# 修正最后一个瓷砖'
- en: 'if j == rows-1:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 j == rows-1:'
- en: ❸ y2 = H
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ y2 = H
- en: '# append an empty string'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加一个空字符串'
- en: ❹ aimg.append("")
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ aimg.append("")
- en: '❺ for i in range(cols):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 对于 i 在 range(cols) 中：
- en: '# crop the image to fit the tile'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '# 裁剪图像以适应瓷砖'
- en: x1 = int(i*w)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: x1 = int(i*w)
- en: x2 = int((i+1)*w)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: x2 = int((i+1)*w)
- en: '# correct the last tile'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '# 修正最后一个瓷砖'
- en: 'if i == cols-1:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 i == cols-1:'
- en: x2 = W
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: x2 = W
- en: '# crop the image to extract the tile into another Image object'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '# 裁剪图像并将瓷砖提取到另一个图像对象'
- en: ❻ img = image.crop((x1, y1, x2, y2))
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ img = image.crop((x1, y1, x2, y2))
- en: '# get the average luminance'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取平均亮度'
- en: ❼ avg = int(getAverageL(img))
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ avg = int(getAverageL(img))
- en: '# look up the ASCII character for grayscale value (avg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '# 查找灰度值（avg）对应的 ASCII 字符'
- en: 'if moreLevels:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '如果更多级别（moreLevels）:'
- en: ❽ gsval = gscale1[int((avg*69)/255)]
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ gsval = gscale1[int((avg*69)/255)]
- en: 'else:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: ❾ gsval = gscale2[int((avg*9)/255)]
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ gsval = gscale2[int((avg*9)/255)]
- en: '# append the ASCII character to the string'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将 ASCII 字符添加到字符串中'
- en: ❿ aimg[j] += gsval
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ aimg[j] += gsval
- en: In this section of the program, the ASCII image is first stored as a list of
    strings, which you initialize ❶. Next, you iterate through the rows of image tiles
    ❷, calculating the top and bottom y-coordinates of each image tile in a given
    row as *y1* and *y2*. These are floating-point calculations, but you truncate
    them to integers before passing them to an image-cropping method.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的这一部分，ASCII 图像首先存储为字符串列表，你会初始化它 ❶。接着，你遍历图像瓷砖的行 ❷，计算每个图像瓷砖在给定行中的上下 y 坐标，分别为
    *y1* 和 *y2*。这些是浮点数计算，但你会将它们截断为整数，再传递给图像裁剪方法。
- en: Next, because dividing the image into tiles creates edge tiles of the same size
    only when the image width is an integer multiple of the number of columns, you
    correct for the bottom y-coordinate of the tiles in the last row by setting the
    y-coordinate to the image’s actual height (`H`) ❸. By doing so, you ensure that
    the bottom edge of the image isn’t truncated.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，因为将图像分割成瓦片只有在图像宽度是列数的整数倍时才会创建大小相同的边缘瓦片，所以你通过将最后一行瓦片的 y 坐标设置为图像的实际高度 (`H`)
    ❸ 来修正瓦片的底部 y 坐标。这样，你可以确保图像的底边不会被截断。
- en: You add an empty string into the ASCII image list as a compact way to represent
    the current image row ❹. You’ll fill in this string next. Essentially, you’re
    treating the string as a list of characters that you can append to. Then you iterate
    over all the tiles in a given row of the image, column by column ❺. You compute
    the left and right x-coordinates of each tile as *x1* and *x2*. When you get to
    the last tile in the row, you set the right x-coordinate to the width of the image
    (`W`), for the same reasons you corrected the final y-coordinate to the image’s
    height.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你向 ASCII 图像列表中添加一个空字符串，用来紧凑地表示当前图像行 ❹。你接下来会填充这个字符串。本质上，你将这个字符串视作一个可以附加字符的字符列表。然后，你按列逐一遍历图像中某一行的所有瓦片
    ❺。你计算每个瓦片的左边和右边 x 坐标，分别为 *x1* 和 *x2*。当你到达这一行的最后一个瓦片时，你将右边的 x 坐标设置为图像的宽度 (`W`)，原因与修正最后一个
    y 坐标为图像高度时相同。
- en: You’ve now calculated (*x1*, *y1*) and (*x2*, *y2*), the coordinates of the
    top-left and bottom-right corners of the current image tile. You pass these coordinates
    to `image.crop()` to extract the tile from the complete image ❻. Then you pass
    that tile (which takes the form of a PIL `Image` object) to the `getAverageL()`
    function ❼, defined in [“Computing the Average Brightness”](nsp-venkitachalam503045-0019.xhtml#bh0802)
    on [page 105](nsp-venkitachalam503045-0019.xhtml#p105), to get the average brightness
    of the tile. You scale the average brightness value from [0, 255] to [0, 9], the
    range of values for the default 10-level grayscale ramp ❾. You then use `gscale2`
    (the stored ramp string) as a lookup table for the relevant ASCII character. The
    line at ❽ is similar, except it scales the brightness value to the [0, 69] range
    of the 70-level grayscale ramp. This line will be used only when the `moreLevels`
    command line flag has been set. Finally, you append the looked-up ASCII character,
    `gsval`, to the text row ❿, and the code loops until all rows are processed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经计算出了 (*x1*, *y1*) 和 (*x2*, *y2*)，即当前图像瓦片的左上角和右下角坐标。你将这些坐标传递给 `image.crop()`
    函数，从完整的图像中提取出瓦片 ❻。然后，你将该瓦片（以 PIL `Image` 对象的形式）传递给 `getAverageL()` 函数 ❼，该函数在 [“计算平均亮度”](nsp-venkitachalam503045-0019.xhtml#bh0802)
    章节中定义，位于 [第 105 页](nsp-venkitachalam503045-0019.xhtml#p105)，以获取瓦片的平均亮度。你将平均亮度值从
    [0, 255] 范围映射到 [0, 9]，这是默认 10 级灰度渐变的值范围 ❾。然后，你使用 `gscale2`（已存储的渐变字符串）作为查找表来查找相应的
    ASCII 字符。第 ❽ 行是类似的，只不过它将亮度值映射到 [0, 69] 范围，这是 70 级灰度渐变的范围。此行代码仅在设置了 `moreLevels`
    命令行标志时使用。最后，你将查找到的 ASCII 字符 `gsval` 添加到文本行 ❿，并且代码会循环直到所有行都处理完成。
- en: '[Creating Command Line Options](nsp-venkitachalam503045-0008.xhtml#rbh0804)'
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[创建命令行选项](nsp-venkitachalam503045-0008.xhtml#rbh0804)'
- en: 'Next, define some command line options for the program. This code uses the
    built-in `argparse.ArgumentParser` class:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为程序定义一些命令行选项。这段代码使用了内置的 `argparse.ArgumentParser` 类：
- en: parser = argparse.ArgumentParser(description="descStr")
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: parser = argparse.ArgumentParser(description="descStr")
- en: add expected arguments
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加预期的参数
- en: parser.add_argument('--file', dest='imgFile', required=True)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--file', dest='imgFile', required=True)
- en: parser.add_argument('--scale', dest='scale', required=False)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--scale', dest='scale', required=False)
- en: parser.add_argument('--out', dest='outFile', required=False)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--out', dest='outFile', required=False)
- en: parser.add_argument('--cols', dest='cols', required=False)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--cols', dest='cols', required=False)
- en: parser.add_argument('--morelevels', dest='moreLevels', action='store_true')
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--morelevels', dest='moreLevels', action='store_true')
- en: 'You include the following options:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你包括以下选项：
- en: --file Specifies the image file to input. This is the only required argument.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: --file 指定要输入的图像文件。这是唯一必需的参数。
- en: --scale Sets the vertical scale factor for a font other than Courier.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: --scale 设置除 Courier 外字体的垂直缩放因子。
- en: --out Sets the output filename for the generated ASCII art. Defaults to *out.txt*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: --out 设置生成的 ASCII 艺术的输出文件名。默认值为 *out.txt*。
- en: --cols Sets the number of text columns in the ASCII output.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: --cols 设置 ASCII 输出中的文本列数。
- en: --morelevels Selects the 70-level grayscale ramp instead of the default 10-level
    ramp.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: --morelevels 选择 70 级灰度渐变，而不是默认的 10 级渐变。
- en: '[Writing the ASCII Art Strings to a Text File](nsp-venkitachalam503045-0008.xhtml#rbh0805)'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[将 ASCII 艺术字符串写入文本文件](nsp-venkitachalam503045-0008.xhtml#rbh0805)'
- en: 'Finally, take the generated list of ASCII character strings and write those
    strings to a text file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将生成的 ASCII 字符串列表写入文本文件：
- en: open a new text file
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开一个新文本文件
- en: ❶ f = open(outFile, 'w')
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ f = open(outFile, 'w')
- en: write each string in the list to the new file
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将列表中的每个字符串写入新文件
- en: '❷ for row in aimg:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '❷ for row in aimg:'
- en: f.write(row + '\n')
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: f.write(row + '\n')
- en: clean up
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理
- en: ❸ f.close()
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ f.close()
- en: You use the built-in `open()` function to open a new text file for writing ❶.
    Then you iterate through each string in the `aimg` list and write it to the file
    ❷. When you’re done, you close the file object to release system resources ❸.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用内置的`open()`函数打开一个新文本文件用于写入 ❶。然后，你遍历 `aimg` 列表中的每个字符串并将其写入文件 ❷。完成后，你关闭文件对象以释放系统资源
    ❸。
- en: '[Running the ASCII Art Generator](nsp-venkitachalam503045-0008.xhtml#rah0804)'
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[运行 ASCII 艺术生成器](nsp-venkitachalam503045-0008.xhtml#rah0804)'
- en: 'To run your finished program, enter a command like the following one, replacing
    `data/robot.jpg` with the relative path to the image file you want to use:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行你完成的程序，输入类似以下的命令，将 `data/robot.jpg` 替换为你要使用的图像文件的相对路径：
- en: $ `python ascii.py --file` `data/robot.jpg` `--cols 100`
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: $ `python ascii.py --file` `data/robot.jpg` `--cols 100`
- en: '[Figure 6-3](nsp-venkitachalam503045-0019.xhtml#fig6-3) shows the ASCII art
    that results from sending the image *robot.jpg* (at the left). Try adding the
    `--morelevels` option to see how the 70-level grayscale ramp compares to the 10-level
    ramp.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](nsp-venkitachalam503045-0019.xhtml#fig6-3) 显示了发送图像*robot.jpg*（左侧）生成的
    ASCII 艺术。尝试添加`--morelevels`选项，看看 70 级灰度渐变与 10 级渐变的对比效果。'
- en: '![](images/nsp-venkitachalam503045-f06003.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f06003.jpg)'
- en: 'Figure 6-3: A sample run of *ascii.py*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-3：*ascii.py* 的示例运行
- en: Now you’re all set to create your own ASCII art!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已准备好创建自己的 ASCII 艺术了！
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah0805)'
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[总结](nsp-venkitachalam503045-0008.xhtml#rah0805)'
- en: In this project, you learned how to generate ASCII art from any input image.
    In the process, you learned how to split an image into a grid of tiles, how to
    compute the average brightness value of each tile, and how to replace each tile
    with a character based on the brightness values. Have fun creating your own ASCII
    art!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你学习了如何从任何输入图像生成 ASCII 艺术。在这个过程中，你学习了如何将图像分割成一个瓦片网格，如何计算每个瓦片的平均亮度值，以及如何根据亮度值用字符替换每个瓦片。祝你在创作自己的
    ASCII 艺术时玩得开心！
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah0806)'
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[实验！](nsp-venkitachalam503045-0008.xhtml#rah0806)'
- en: 'Here are some ideas for exploring ASCII art further:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些进一步探索 ASCII 艺术的想法：
- en: 1\. Run the program with the command line option `--scale 1.0`. How does the
    resulting image look? Experiment with different values for `scale`. Copy the output
    to a text editor and try setting the text to different fixed-width fonts to see
    how doing so affects the appearance of the final image.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1. 使用命令行选项`--scale 1.0`运行程序。生成的图像看起来如何？尝试不同的`scale`值。将输出复制到文本编辑器中，并尝试设置为不同的等宽字体，看看这样做如何影响最终图像的外观。
- en: '2\. Add a command line option `--invert` to the program to invert the generated
    ASCII images so that black appears white, and vice versa. (Hint: try subtracting
    the tile brightness value from 255 during lookup.)'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2. 为程序添加一个命令行选项`--invert`，使生成的 ASCII 图像反转，使黑色变为白色，反之亦然。（提示：在查找时尝试从 255 中减去瓦片亮度值。）
- en: '3\. In this project, you created lookup tables for grayscale values based on
    two hardcoded character ramps. Implement a command line option to pass in a different
    character ramp to create the ASCII art, like so:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3. 在这个项目中，你基于两个硬编码的字符渐变创建了灰度值查找表。实现一个命令行选项，传入不同的字符渐变来创建 ASCII 艺术，如下所示：
- en: $ ``python ascii.py --map "@$%^`."``
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ ``python ascii.py --map "@$%^`."``
- en: This should create the ASCII output using the given six-character ramp, where
    `@` maps to a brightness value of 0 and `.` maps to a value of 255.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将使用给定的六字符渐变生成 ASCII 输出，其中 `@` 映射到亮度值 0，`.` 映射到亮度值 255。
- en: '[The Complete Code](nsp-venkitachalam503045-0008.xhtml#rah0807)'
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[完整代码](nsp-venkitachalam503045-0008.xhtml#rah0807)'
- en: Here is the complete ASCII art program.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的 ASCII 艺术程序。
- en: '"""'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: ascii.py
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ascii.py
- en: A Python program that convert images to ASCII art.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一个将图像转换为 ASCII 艺术的 Python 程序。
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 作者：Mahesh Venkitachalam
- en: '"""'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: import sys, random, argparse
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: import sys, random, argparse
- en: import numpy as np
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: import numpy as np
- en: import math
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: import math
- en: from PIL import Image
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: from PIL import Image
- en: 'grayscale level values from:'
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灰度级值来自：
- en: http://paulbourke.net/dataformats/asciiart/
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: http://paulbourke.net/dataformats/asciiart/
- en: 70 levels of gray
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 70 级灰度
- en: gscale1 = "$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~<>i!lI;:,\"^`'.
    "
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: gscale1 = "$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1{}[]?-_+~<>i!lI;:,\"^`'.
    "
- en: 10 levels of gray
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 级灰度
- en: gscale2 = '@%#*+=-:. '
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: gscale2 = '@%#*+=-:. '
- en: 'def getAverageL(image):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 'def getAverageL(image):'
- en: '"""'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: given PIL Image, return average value of grayscale value
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 PIL 图像，返回灰度值的平均值
- en: '"""'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: '# get image as numpy array'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取图像作为 numpy 数组'
- en: im = np.array(image)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: im = np.array(image)
- en: '# get shape'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取形状'
- en: w,h = im.shape
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: w,h = im.shape
- en: '# get average'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取平均值'
- en: return np.average(im.reshape(w*h))
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: return np.average(im.reshape(w*h))
- en: 'def convertImageToAscii(fileName, cols, scale, moreLevels):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 'def convertImageToAscii(fileName, cols, scale, moreLevels):'
- en: '"""'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: given Image and dims (rows, cols) returns an m*n list of Images
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 给定图像和维度（行，列），返回一个 m*n 的图像列表
- en: '"""'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: '# declare globals'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '# 声明全局变量'
- en: global gscale1, gscale2
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: global gscale1, gscale2
- en: '# open image and convert to grayscale'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开图像并转换为灰度'
- en: image = Image.open(fileName).convert('L')
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: image = Image.open(fileName).convert('L')
- en: '# store dimensions'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '# 存储尺寸'
- en: W, H = image.size[0], image.size[1]
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: W, H = image.size[0], image.size[1]
- en: 'print("input image dims: {} x {}".format(W, H))'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: print("输入图像的尺寸：{} x {}".format(W, H))
- en: '# compute width of tile'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算瓦片宽度'
- en: w = W/cols
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: w = W/cols
- en: '# compute tile height based on aspect ratio and scale'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '# 根据宽高比和比例计算瓦片高度'
- en: h = w/scale
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: h = w/scale
- en: '# compute number of rows'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算行数'
- en: rows = int(H/h)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: rows = int(H/h)
- en: 'print("cols: {}, rows: {}".format(cols, rows))'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: print("列数：{}, 行数：{}".format(cols, rows))
- en: 'print("tile dims: {} x {}".format(w, h))'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: print("瓦片尺寸：{} x {}".format(w, h))
- en: '# check if image size is too small'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '# 检查图像大小是否过小'
- en: 'if cols > W or rows > H:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'if cols > W or rows > H:'
- en: print("Image too small for specified cols!")
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: print("图像太小，无法满足指定的列数！")
- en: exit(0)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: exit(0)
- en: '# an ASCII image is a list of character strings'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '# 一个 ASCII 图像是一个字符字符串的列表'
- en: aimg = []
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: aimg = []
- en: '# generate list of dimensions'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '# 生成尺寸列表'
- en: 'for j in range(rows):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(rows):'
- en: y1 = int(j*h)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: y1 = int(j*h)
- en: y2 = int((j+1)*h)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: y2 = int((j+1)*h)
- en: '# correct last tile'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '# 修正最后一个瓦片'
- en: 'if j == rows-1:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 'if j == rows-1:'
- en: y2 = H
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: y2 = H
- en: '# append an empty string'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加空字符串'
- en: aimg.append("")
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: aimg.append("")
- en: 'for i in range(cols):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(cols):'
- en: '# crop image to tile'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '# 裁剪图像为瓦片'
- en: x1 = int(i*w)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: x1 = int(i*w)
- en: x2 = int((i+1)*w)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: x2 = int((i+1)*w)
- en: '# correct last tile'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '# 修正最后一个瓦片'
- en: 'if i == cols-1:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 'if i == cols-1:'
- en: x2 = W
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: x2 = W
- en: '# crop image to extract tile'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '# 裁剪图像以提取瓦片'
- en: img = image.crop((x1, y1, x2, y2))
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: img = image.crop((x1, y1, x2, y2))
- en: '# get average luminance'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取平均亮度'
- en: avg = int(getAverageL(img))
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: avg = int(getAverageL(img))
- en: '# look up ASCII char'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '# 查找 ASCII 字符'
- en: 'if moreLevels:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 'if moreLevels:'
- en: gsval = gscale1[int((avg*69)/255)]
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: gsval = gscale1[int((avg*69)/255)]
- en: 'else:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: gsval = gscale2[int((avg*9)/255)]
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: gsval = gscale2[int((avg*9)/255)]
- en: '# append ASCII char to string'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将 ASCII 字符附加到字符串'
- en: aimg[j] += gsval
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: aimg[j] += gsval
- en: '# return image'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '# 返回图像'
- en: return aimg
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: return aimg
- en: main() function
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: main() 函数
- en: 'def main():'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: '# create parser'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建解析器'
- en: descStr = "This program converts an image into ASCII art."
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: descStr = "该程序将图像转换为 ASCII 艺术。"
- en: parser = argparse.ArgumentParser(description=descStr)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: parser = argparse.ArgumentParser(description=descStr)
- en: '# add expected arguments'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加预期参数'
- en: parser.add_argument('--file', dest='imgFile', required=True)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--file', dest='imgFile', required=True)
- en: parser.add_argument('--scale', dest='scale', required=False)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--scale', dest='scale', required=False)
- en: parser.add_argument('--out', dest='outFile', required=False)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--out', dest='outFile', required=False)
- en: parser.add_argument('--cols', dest='cols', required=False)
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--cols', dest='cols', required=False)
- en: parser.add_argument('--morelevels',dest='moreLevels',action='store_true')
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: parser.add_argument('--morelevels',dest='moreLevels',action='store_true')
- en: '# parse args'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '# 解析参数'
- en: args = parser.parse_args()
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: args = parser.parse_args()
- en: imgFile = args.imgFile
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: imgFile = args.imgFile
- en: '# set output file'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置输出文件'
- en: outFile = 'out.txt'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: outFile = 'out.txt'
- en: 'if args.outFile:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.outFile:'
- en: outFile = args.outFile
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: outFile = args.outFile
- en: '# set scale default as 0.43, which suits a Courier font'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置比例的默认值为 0.43，这适合使用 Courier 字体'
- en: scale = 0.43
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: scale = 0.43
- en: 'if args.scale:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.scale:'
- en: scale = float(args.scale)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: scale = float(args.scale)
- en: '# set cols'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置列数'
- en: cols = 80
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: cols = 80
- en: 'if args.cols:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args.cols:'
- en: cols = int(args.cols)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: cols = int(args.cols)
- en: print('generating ASCII art...')
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: print('正在生成 ASCII 艺术...')
- en: '# convert image to ASCII text'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将图像转换为 ASCII 文本'
- en: aimg = convertImageToAscii(imgFile, cols, scale, args.moreLevels)
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: aimg = convertImageToAscii(imgFile, cols, scale, args.moreLevels)
- en: '# open file'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '# 打开文件'
- en: f = open(outFile, 'w')
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: f = open(outFile, 'w')
- en: '# write to file'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '# 写入文件'
- en: 'for row in aimg:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 'for row in aimg:'
- en: f.write(row + '\n')
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: f.write(row + '\n')
- en: '# clean up'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '# 清理'
- en: f.close()
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: f.close()
- en: print("ASCII art written to {}.".format(outFile))
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: print("ASCII 艺术已写入 {}。".format(outFile))
- en: call main
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用 main
- en: 'if __name__ == ''__main__'':'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == ''__main__'':'
- en: main()
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: main()
