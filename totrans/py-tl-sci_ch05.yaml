- en: '**5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JUPYTER NOTEBOOK: AN INTERACTIVE JOURNAL FOR COMPUTATIONAL RESEARCH**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The classic Jupyter Notebook is the world’s most popular tool for data science.
    As a savable web-based application, Notebook lets you capture the entire computational
    process, from loading and exploring data to developing and executing code, and
    even documenting and presenting the results. It’s no wonder Notebook has become
    the default environment for code-based research.
  prefs: []
  type: TYPE_NORMAL
- en: To paraphrase James Bednar, director of custom services at Anaconda, *notebooks
    tell stories*. They’re designed to capture and convey a code-based narrative that
    has a linear flow and is composed of small, human-digestible steps. They can include
    documentation that concisely and precisely explains what’s going on. This helps
    scientists, researchers, developers, and students generate *reproducible* code-based
    research.
  prefs: []
  type: TYPE_NORMAL
- en: Like a personal science journal, a Jupyter notebook can serve as a complete
    record of a computational session. To make your work more understandable and repeatable,
    you can interleave inputs and outputs with narrative text, mathematical formulas,
    images, links, and more. You can also share your notebooks directly or turn them
    into interactive slideshows or dashboards.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we delve into the details of Jupyter Notebook using the classic
    version. In the next chapter, we’ll look at the newer implementation in JupyterLab,
    the next-generation interface for Project Jupyter. Except for some slight rearrangement
    of the menus, the newer version works the same and uses the same file formats
    as classic Notebook. In fact, the two can be run side by side on the same computer,
    and JupyterLab even comes with a button for launching the classic version.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the pages that follow, Jupyter Notebook or Notebook (uppercase “N”) refers
    to the application, whereas Jupyter notebook or notebook (lowercase “n”) refers
    to an actual notebook file generated by the application. These files have a .ipynb
    extension, which is short for “IPython notebook.”*'
  prefs: []
  type: TYPE_NORMAL
- en: To supplement this chapter, you can find a quick start guide at *[https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/](https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/)*
    and the full documentation at *[https://jupyter-notebook.readthedocs.io/en/stable/notebook.html](https://jupyter-notebook.readthedocs.io/en/stable/notebook.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing Jupyter Notebook**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jupyter Notebook is an open source package that comes preinstalled in Anaconda’s
    *base* environment. However, it’s not a good idea to work on projects in *base*,
    as that can get messy. To keep your project packages organized, safe, and sharable,
    they need to be in dedicated conda environments.
  prefs: []
  type: TYPE_NORMAL
- en: To use Jupyter Notebook with conda environments, you have two main options.
    You can install Jupyter Notebook directly in each conda environment, or you can
    link each environment to the Notebook installation in the *base* environment.
    To mimic what we did with Spyder in [Chapter 4](ch04.xhtml), let’s call the first
    option the *naive* approach and the second the *modular* approach. Although the
    modular approach is generally recommended, if a project needs to lock down a specific
    version of Notebook, you’ll need to use the naive approach.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Naive Approach***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The naive approach is to install Jupyter Notebook directly in each of your conda
    environments. Notebook can then import and use any packages installed in the same
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: This is the simplest approach, but it can become resource intensive over time
    as your *pkgs* folder becomes populated with different versions of Notebook. You
    might also struggle to keep all of the installations up to date and might not
    be able to see or switch to other environments from within Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing and Launching Jupyter Notebook Using Anaconda Navigator**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To install Jupyter Notebook in a new environment using Anaconda Navigator, first
    launch Navigator using the Start menu in Windows, or Launchpad in macOS, or by
    entering anaconda-navigator in a terminal in Linux. Then, in the Applications
    on pull-down menu near the top of the Home tab ([Figure 5-1](ch05.xhtml#ch05fig1)),
    activate the environment by selecting its name. In this example, we’re using *my_first_env*,
    created in [Chapter 2](ch02.xhtml). If you skipped this step in [Chapter 2](ch02.xhtml),
    see “Creating a New Environment” on [page 36](ch02.xhtml#ch00lev2sec19).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: The Anaconda Navigator Home tab showing the active environment
    (my_first_env) and the Notebook tile*'
  prefs: []
  type: TYPE_NORMAL
- en: Next, find the **Jupyter Notebook** app tile and then click the **Install**
    button. You might need to scroll down the Home tab to find the tile. This will
    install the most current version of Notebook available from the top channel in
    your Channels listing, located near the top of the Home tab. If you want to install
    a specific version of Jupyter Notebook, click the “gear” icon at the upper right
    of the Notebook tile to see a listing of available version numbers (see [Figure
    5-1](ch05.xhtml#ch05fig1)).
  prefs: []
  type: TYPE_NORMAL
- en: After a few moments, the Install button should change to a Launch button. This
    button starts a local web server on your computer that displays the Jupyter dashboard.
    Because it’s running locally, you don’t need an active internet connection. You’ll
    need to leave Navigator open, however, because it’s running the local server for
    Notebook that lets you interact with your web browser.
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing and Launching Jupyter Notebook Using the CLI**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To install Jupyter Notebook in a new environment using conda, first open Anaconda
    Prompt (in Windows) or a terminal (in macOS and Linux) and activate the conda
    environment. Let’s do this for *my_second_env* that we created in [Chapter 2](ch02.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you skipped this step in [Chapter 2](ch02.xhtml), create the environment
    using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, activate the environment by entering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use conda to install Notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To install a specific version, such as 6.4.1, you would use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To launch Notebook, enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This starts a local web server on your computer that displays the Jupyter dashboard.
    Because it’s running locally, you don’t need an active internet connection. You’ll
    need to leave your Prompt window or terminal open, however, because it’s running
    the local server for Notebook that lets you interact with your web browser.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*There are conda packages named notebook and jupyter. The notebook package
    is the classic Jupyter Notebook application. The larger jupyter package bundles
    Jupyter Notebook, Qt console, and IPython kernel.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Modular Approach***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The modular approach links each conda environment back to the Notebook package
    that was loaded in the *base* environment when you installed Anaconda. This approach
    is resource efficient, lets you easily keep the Notebook package up to date, and
    lets you see and choose among different environments from the same Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the modular approach with either Navigator or the CLI. For simplicity,
    let’s use the CLI. Open Anaconda Prompt (in Windows) or a terminal (in macOS or
    Linux) and enter the following to create a new environment named *my_jupe_env*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter y when prompted to accept the installation. Next, activate the new environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To link this environment with the Jupyter Notebook installation in the *base*
    environment, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Because we’re using the *ipykernel* package, we don’t need to explicitly install
    Python in the environment. However, if you do need to use a specific version of
    Python in your project, you’ll need to install it in the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, deactivate *my_jupe_env*, which returns you to *base*, and then install
    the *nb_conda_kernels* package (you’ll need to do this only once):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The nb_conda_kernels package enables a Jupyter instance in an environment to
    automatically recognize any other environment that has the ipykernel package installed.
    It’s this combination of nb_conda_kernels in the *base* environment and ipykernel
    in other conda environments that allows you to use a single installation of Jupyter
    Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start Notebook from *base* you’ll need to enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This starts a local web server on your computer that displays the Jupyter dashboard.
    Because it’s running locally, you don’t need an active internet connection. You’ll
    need to leave your Prompt window or terminal open, however, because it’s running
    the local server for Notebook that lets you interact with your web browser.
  prefs: []
  type: TYPE_NORMAL
- en: '**Your First Jupyter Notebook**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To begin, let’s work through an example. In this case, we’ll use a notebook
    to summarize the eruption cycle of the famous Old Faithful geyser in Yellowstone
    National Park. We’ll load some data, prepare it, plot it, and then add a decorative
    image.
  prefs: []
  type: TYPE_NORMAL
- en: If you launched Notebook in the previous sections, your browser opened a dashboard
    page like the one in [Figure 5-2](ch05.xhtml#ch05fig2). Shut it down now using
    the **Quit** button in the upper-right corner of the page, and then close the
    browser tab. If Navigator is open, close it by selecting **File** ▸ **Quit**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: The Jupyter dashboard appears in your browser when you start Jupyter
    Notebook.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Going forward, we’ll use the modular approach described in the previous section,
    so be sure to install the nb_conda_kernels package in your *base* environment
    if you haven’t done so already. To do this with the CLI, open Anaconda Prompt
    (Windows) or a terminal (macOS or Linux) and then activate *base*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The notebook package ships with Anaconda, so it’s already in the *base* environment.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Dedicated Project Folders***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Jupyter notebooks are saved to the folder from which you started the application.
    This means notebooks will tend to accumulate in your home or user directory. In
    addition, Anaconda uses dedicated folders to keep track of your installed packages
    and conda environments (see [Chapter 2](ch02.xhtml)). Although Anaconda is designed
    to work smoothly with this structure and help you navigate it, not everyone wants
    their project files scattered around their directory tree. As we discussed in
    the previous chapter, there are multiple benefits to keeping all your project
    files together in a single folder.
  prefs: []
  type: TYPE_NORMAL
- en: For this project, let’s store the conda environment and Jupyter notebooks in
    a folder named *my_nb_proj*, short for “my notebook project.” I’ll create this
    in my user directory in Windows, and I suggest that you use a similar location
    on your system. Although you can do this through Anaconda Navigator, the command
    line is more succinct, so we’ll use that going forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the directories for the project, open Anaconda Prompt (in Windows)
    or a terminal (in macOS or Linux) and enter the following (using your own directory
    path):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes a *my_nb_proj* directory with *notebooks* and *data* subdirectories.
    Next, create a conda environment named *my_nb_proj_env* in the project directory,
    activate it, and install some libraries (substitute your own path where needed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As described previously, the ipykernel package lets you use the Jupyter Notebook
    application in the *base* environment. The pandas package is Python’s primary
    data analysis library, and seaborn is a plotting library that includes some useful
    datasets. (We look at these libraries in more detail later in the book.)
  prefs: []
  type: TYPE_NORMAL
- en: At this point, your project directory structure should look like [Figure 5-3](ch05.xhtml#ch05fig3).
    Of course, with a real project, you might include additional folders for specific
    types of data, non-notebook scripts, miscellaneous items, and more.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-3: Directory structure for my_nb_proj*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Jupyter Notebook likes to save to its current directory. The first time you
    save a file, it’s easiest if you start Notebook from within that folder. Afterward,
    you can launch Notebook from anywhere and still access the file. To launch Notebook
    in your new *notebooks* folder, first activate the *base* environment (where Jupyter
    Notebook is installed), and then use the `cd` command to change directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Because this folder is already in my user directory, I could have also used
    the relative path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To start Notebook, enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You should now see the Jupyter dashboard in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: '***Navigating the Notebook Dashboard and User Interface***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Jupyter Notebook dashboard, also called the *Home page*, opens with an intuitive
    file explorer tab (see [Figure 5-4](ch05.xhtml#ch05fig4)). This tab displays notebook
    documents and other files in the directory from which you launched Notebook, known
    as the *current directory*. When you click a file or folder, you’re presented
    with standard options like duplicating, renaming, deleting, and so on. The dashboard
    also helps you to create new notebooks, exit the application, and manage currently
    running Jupyter processes and clusters used for parallel processing.
  prefs: []
  type: TYPE_NORMAL
- en: Because we launched Notebook from the empty *notebooks* folder, no files or
    folders are visible. Let’s fix that by creating a new notebook. Start by clicking
    the **New** button at the upper right of the Files tab to open a drop-down menu,
    as shown in [Figure 5-4](ch05.xhtml#ch05fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-4: Choosing a kernel from the Jupyter dashboard New menu*'
  prefs: []
  type: TYPE_NORMAL
- en: The menu offers you a choice of kernels in the various conda environments you’ve
    created, including ones not in the default *envs* folder. It’s able to do this
    thanks to the nb_conda_kernels package installed in *base* and the ipykernel package
    installed in each environment. At the bottom of the list, you have other choices
    including creating a new text file, folder, or terminal.
  prefs: []
  type: TYPE_NORMAL
- en: To activate the kernel in your *my_nb_proj* environment, select **Python [conda
    env:my_nb_proj_env]** from the list. This opens the notebook’s user interface
    (UI). The notebook UI is where you interactively build your notebook document.
    Its primary components are the menu bar, toolbar, and cells ([Figure 5-5](ch05.xhtml#ch05fig5)).
    I encourage you to take the quick interactive tour of these components by clicking
    **Help** ▸ **User Interface Tour** in the menu.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-5: The notebook user interface*'
  prefs: []
  type: TYPE_NORMAL
- en: At the right side of the menu bar, you’ll see the active kernel and conda environment
    (*Python[conda env:my_nb_proj_env]*). If this is not the name you expect, you’re
    using packages from a different environment, which might not contain packages
    you need or their correct versions.
  prefs: []
  type: TYPE_NORMAL
- en: The modular nature of Jupyter Notebook is the key to its success. It’s built
    of blocks, called *cells*, that can contain either code or “text” (such as headers,
    bulleted lists, images, and hyperlinks). Code cells can be run independently or
    all at once, and each has its own output area. This lets you break your computational
    problem into pieces and organize related ideas into cells. When you get a cell
    (or cells) working properly, you can move on. This is convenient for interactive
    exploration and is especially useful for long-running processes that you need
    to run only once per session.
  prefs: []
  type: TYPE_NORMAL
- en: '***Naming a Notebook***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s learn about the UI components and workflow by actively creating a notebook.
    First, give your new notebook a name by clicking **Untitled**, located just above
    the menu bar, entering **geyser** in the text box, and then clicking **Rename**
    ([Figure 5-6](ch05.xhtml#ch05fig6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-6: Renaming a notebook*'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should see a new file and folder appear in your project’s
    *notebooks* folder. The *geyser.ipynb* file is the notebook document. This is
    just a plaintext JSON file saved with a *.ipynb* extension. The *.ipynb_checkpoints*
    folder contains the *geyser-checkpoint.ipynb* file, which lets you restore your
    notebook back to a previous version.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also see the notebook file appear in your dashboard ([Figure 5-7](ch05.xhtml#ch05fig7)).
    If you click the box next to its name, you’ll launch a menu bar with options for
    working with the file, such as moving, renaming, and deleting it (the “trash can”
    icon).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-7: The Jupyter dashboard with the file actions menu active*'
  prefs: []
  type: TYPE_NORMAL
- en: To open the geyser notebook in the future, just click the filename in the dashboard.
    The “book” icon will turn green to indicate an actively running notebook, and
    you can use the drop-down menu just above the filename to filter all running notebooks.
    Note that you can’t access notebook files that are outside (above) the root of
    the directory tree shown in the dashboard. The root directory is the directory
    from which you started Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: '***Adding Text with a Markdown Cell***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s provide a descriptive header for the notebook, to let people know
    what it’s about and to cite the source of the geyser data. Click in the first
    cell, labeled `In [ ]:` on the left side. Next, on the toolbar, change the cell
    type from **Code** to **Markdown**, as depicted in [Figure 5-8](ch05.xhtml#ch05fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-8: Changing the cell type using the Toolbar*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Markdown* (*[https://daringfireball.net/projects/markdown/](https://daringfireball.net/projects/markdown/)*),
    a superset of the HTML markup language, lets you add explanatory text to your
    notebook. You can style this text in multiple ways, including text size, bold,
    italics, and strike-through. You can change colors, use style sheets, make lists,
    and add hyperlinks. You can even drag and drop images and videos into a Markdown
    cell.'
  prefs: []
  type: TYPE_NORMAL
- en: Some commonly used Markdown styles are listed in [Table 5-1](ch05.xhtml#ch05tab1).
    Insert your own text for words in ALL-CAPS. To see additional styles, search for
    “Markdown cells” at *[https://jupyter-notebook.readthedocs.io/](https://jupyter-notebook.readthedocs.io/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-1:** Common Markdown Styles'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Style syntax** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `# YOUR TEXT` | Heading size; # (largest) → ##### (smallest) |'
  prefs: []
  type: TYPE_TB
- en: '| `**YOUR TEXT**` | Makes text **bold** |'
  prefs: []
  type: TYPE_TB
- en: '| `*YOUR TEXT*` | Makes text *italic* |'
  prefs: []
  type: TYPE_TB
- en: '| `~~YOUR TEXT~~` | Strikes through text |'
  prefs: []
  type: TYPE_TB
- en: '| `- YOUR TEXT` | Creates a bulleted list (also accepts + and *) |'
  prefs: []
  type: TYPE_TB
- en: '| `<span style=``″``color:red``″``>YOUR TEXT</span>` | Changes text to the
    specified color (in JupyterLab) |'
  prefs: []
  type: TYPE_TB
- en: '| `[Text](URL)` | Inserts a hyperlink to a website URL |'
  prefs: []
  type: TYPE_TB
- en: '| `![title](FILENAME)``![title](URL)` | Inserts an image using a filename or
    URL address. You can also drag and drop an image into the cell. |'
  prefs: []
  type: TYPE_TB
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Heading choice in the style menu has been deprecated and no longer works.
    Notebook will direct you to the Markdown option for creating headers.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a header for your notebook, click in the cell and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to include a space after the hash marks. Your cell should look like
    [Figure 5-9](ch05.xhtml#ch05fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-9: Creating a header using a Markdown cell*'
  prefs: []
  type: TYPE_NORMAL
- en: To run the cell, click the **Run** button on the toolbar or, on your keyboard,
    press SHIFT-ENTER. Your cell should look like [Figure 5-10](ch05.xhtml#ch05fig10).
    Notice that “Applied Linear Regression” is in italics. To go back and edit the
    cell again, just double-click it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-10: The formatted header*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*SHIFT-ENTER executes a cell and advances the cursor to the next cell, creating
    a new cell if necessary. CTRL-ENTER executes the current cell but does not advance
    to the next one.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Adding Code and Making Plots with a Code Cell***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notebook supports in-browser code editing, and it includes features found in
    Spyder, like automatic syntax highlighting, indentation, and tab completion/introspection.
    In other words, you can execute code from the browser, and see the output of the
    computations, including plots and images, in dedicated output cells within the
    notebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin coding, click in the new code cell and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This time, use CTRL-ENTER to run the cell. You may have noticed that this is
    the opposite of the Jupyter Qt console, in which you execute code by pressing
    ENTER and add multiple lines without execution using CTRL-ENTER.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add another cell in a different way, from the menu bar click **Insert**
    ▸ **Insert Cell Below**. Click in this new cell and enter and run the following
    code to make a “violin plot”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The semicolon at the end of the line prevents Notebook from displaying the *textural*
    information about the plot object. Your notebook should now look like [Figure
    5-11](ch05.xhtml#ch05fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-11: The geyser.ipynb notebook with inline plot*'
  prefs: []
  type: TYPE_NORMAL
- en: Something important just happened. In the first cell, you imported packages,
    loaded the seaborn “geysers” dataset as a pandas DataFrame, peeked at the first
    five lines of the DataFrame (`df.head()`), and then changed the name of one of
    the columns to something more meaningful. In the second cell, you plotted the
    DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: The key here is that you isolated the (potentially) time-consuming steps of
    data loading and preparation in their own cell. If you import packages and load
    the dataset in the first cell (labeled `In [1]:`), you’re then free to “play”
    with the data in subsequent cells. There’s no reason to wait for data to load
    with each execution. You saw a similar cellular approach in Spyder (see “Defining
    Code Cells” on [page 81](ch04.xhtml#ch00lev2sec42)).
  prefs: []
  type: TYPE_NORMAL
- en: Another thing worth noting is that you used a magic command to make Matplotlib
    plot *inside* the notebook (you didn’t need to explicitly import the Matplotlib
    library, because it’s a dependency of seaborn). You can also add simple interactivity
    to the plot by using `%matplotlib notebook`, though this can slow down rendering.
    Magic commands were first introduced in [Chapter 3](ch03.xhtml). To see the list
    of magics, including *cell* magics, run `%lsmagic` in a cell. Cell magics are
    preceded by *two* percent signs (`%%`).
  prefs: []
  type: TYPE_NORMAL
- en: The plot itself shows that Old Faithful has a short and long eruption cycle.
    The longer you wait, the longer the eruption tends to last, so as a tourist, your
    patience is rewarded.
  prefs: []
  type: TYPE_NORMAL
- en: '***Working with Output Cells***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'By default, Notebook shows only the output of the last command in a code cell.
    Depending on the circumstance, you can get around this by using either the `print()`
    or `display()` functions. In the previous section, we used `display()` to show
    the head (first few rows) of the DataFrame. It also works to put multiple commands,
    separated by commas, on the same line. Alternatively, you can import the IPython
    InteractiveShell at the start of your notebook and set its interactivity option
    to “all”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Besides `all`, other `InteractiveShell` options include `none`, `last`, `last_expr`,
    and `last_expr_or_assign` (where “expr” stands for “expression” and “assign” stands
    for “assignment”).
  prefs: []
  type: TYPE_NORMAL
- en: For more control over output cells, use the Cell menu ([Figure 5-12](ch05.xhtml#ch05fig12)).
    The Current Outputs and All Output options let you hide output, clear output,
    or toggle scrolling for a single cell or the entire notebook, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-12: The Toggle Scrolling option adds a scrollbar to an output cell*'
  prefs: []
  type: TYPE_NORMAL
- en: The scrolling option is helpful if you’re displaying an object that’s too large
    for the output cell. [Figure 5-12](ch05.xhtml#ch05fig12) displays the full DataFrame
    in the geyser notebook (using `display(df)`), and toggling on the scrollbar allows
    you to view the last lines of the DataFrame.
  prefs: []
  type: TYPE_NORMAL
- en: '***Adding an Image with a Markdown Cell***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To finish off the notebook, let’s add Jim Peaco’s ariel view of Old Faithful,
    available from the National Park Service image gallery. Insert a new cell and
    change its type to **Markdown**. Enter and run the following code, which references
    the image’s web address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Assuming that you have an active internet connection, this produces the output
    in [Figure 5-13](ch05.xhtml#ch05fig13).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-13: Bottom half of notebook with National Park Service image of Old
    Faithful*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want control over the size of the image, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t want to worry about broken links, unreliable internet connections,
    or keeping track of external files, you can embed images in notebooks using **Edit**
    ▸ **Insert Image** from the menu bar, by pasting from your clipboard, or by dragging
    and dropping the image into the Markdown cell. Embedded images make your notebook
    more portable but have the disadvantage of increasing its file size and making
    code revisions less friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Markdown cells, and notebooks in general, make it easy to include code, equations,
    and graphics in formatted documents. In fact, many online articles, such as those
    on *Medium* and *Towards Data Science*, are created using Jupyter Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: '***Saving the Notebook***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notebook automatically saves after a set period, usually 120 seconds. You can
    override this by running the `%autosave n` magic command in a cell, where `n`
    is the number of seconds and `n=0` disables autosaving. This applies only to an
    individual notebook and for the current session. You’ll need to run the cell containing
    the magic command every time you open the notebook for it to take effect. For
    instructions on how to globally change autosave settings for all notebooks, search
    online for the `autosavetime` Jupyter extension (we’ll look at using extensions
    later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: To manually save your notebook at any time, use either the **Save** icon on
    the toolbar, the keyboard shortcut CTRL-S, or **File** ▸ **Save and Checkpoint**
    from the menu bar.
  prefs: []
  type: TYPE_NORMAL
- en: Each time you manually save your notebook, you create a *checkpoint* file in
    a folder named *.ipynb_checkpoints*, located in the same folder as the initial
    *.ipynb* file. You can reset your notebook to the checkpoint version by clicking
    **File** ▸ **Revert to Checkpoint** from the menu and then clicking on the date
    stamp for the last checkpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Checkpoints are important because autosaving updates only the *.ipynb* file.
    This lets you safely work for a while without saving manually. If you find you’ve
    gone down a blind alley or made some mistake, you can always restore back to an
    earlier copy using the checkpoint file.
  prefs: []
  type: TYPE_NORMAL
- en: '***Closing the Notebook***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To properly close your notebook, from the menu bar select **File** ▸ **Close
    and Halt**. Next, in the dashboard, press the **Quit** button, and then close
    the window.
  prefs: []
  type: TYPE_NORMAL
- en: If you are logged in to another server, as opposed to working locally, you’ll
    want to log out using either the **Logout** button at the upper right of the notebook
    or at the upper right of the Jupyter dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: '**Getting Help**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Help menu, though very intuitive, is useful enough to warrant a mention.
    In addition to the Notebook interface tour and documentation, it provides handy
    links to the documentation of many useful libraries like Python, NumPy, pandas,
    Matplotlib, and more ([Figure 5-14](ch05.xhtml#ch05fig14)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-14: The Help menu*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Keyboard Shortcuts***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also bring up a list of keyboard shortcuts for both *command* mode and
    *edit* mode. You may have noticed that cell borders start out blue and then switch
    to green when you click inside them. *Blue* cells indicate that you’re in command
    mode; *green* cells designate edit mode.
  prefs: []
  type: TYPE_NORMAL
- en: In command mode, the whole notebook is selected. In edit mode, the focus is
    on a single cell. Although there’s some overlap, keyboard shortcuts for the command
    mode ([Table 5-2](ch05.xhtml#ch05tab2)) help you manipulate *cells*, while shortcuts
    for the edit mode ([Table 5-3](ch05.xhtml#ch05tab3)) help you work with *text
    in cells*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-2:** Selected Command Mode Keyboard Shortcuts'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Shortcut** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| H | Show all keyboard shortcuts |'
  prefs: []
  type: TYPE_TB
- en: '| ENTER | Enter cell Edit mode |'
  prefs: []
  type: TYPE_TB
- en: '| SHIFT-ENTER | Run cell and select cell below |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-ENTER | Run selected cell |'
  prefs: []
  type: TYPE_TB
- en: '| F | Find and replace |'
  prefs: []
  type: TYPE_TB
- en: '| Y | Change cell mode to Code |'
  prefs: []
  type: TYPE_TB
- en: '| M | Change cell mode to Markdown |'
  prefs: []
  type: TYPE_TB
- en: '| 1 through 6 | Change cell to heading mode (1 = Largest; 6 = Smallest) |'
  prefs: []
  type: TYPE_TB
- en: '| UP | Select cell above |'
  prefs: []
  type: TYPE_TB
- en: '| DOWN | Select cell below |'
  prefs: []
  type: TYPE_TB
- en: '| A | Insert cell above |'
  prefs: []
  type: TYPE_TB
- en: '| B | Insert cell below |'
  prefs: []
  type: TYPE_TB
- en: '| X | Cut selected cell |'
  prefs: []
  type: TYPE_TB
- en: '| C | Copy selected cell |'
  prefs: []
  type: TYPE_TB
- en: '| V | Paste cells below |'
  prefs: []
  type: TYPE_TB
- en: '| SHIFT-V | Paste cells above |'
  prefs: []
  type: TYPE_TB
- en: '| D, D | Delete selected cell |'
  prefs: []
  type: TYPE_TB
- en: '| Z | Undo cell deletion |'
  prefs: []
  type: TYPE_TB
- en: '| SHIFT-M | Merge selected cells, or current cell with one below if only one
    selected |'
  prefs: []
  type: TYPE_TB
- en: '| S (or CTRL-S) | Save and Checkpoint |'
  prefs: []
  type: TYPE_TB
- en: '| L | Toggle line numbers |'
  prefs: []
  type: TYPE_TB
- en: '| O | Toggle output of selected cells |'
  prefs: []
  type: TYPE_TB
- en: '| I, I | Interrupt the kernel |'
  prefs: []
  type: TYPE_TB
- en: '| SPACE | Scroll notebook down |'
  prefs: []
  type: TYPE_TB
- en: '| SHIFT-SPACE | Scroll notebook up |'
  prefs: []
  type: TYPE_TB
- en: '**Table 5-3:** Selected Edit Mode Keyboard Shortcuts'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Shortcut** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-M (or ESC) | Enter Command mode |'
  prefs: []
  type: TYPE_TB
- en: '| UP | Move cursor up |'
  prefs: []
  type: TYPE_TB
- en: '| DOWN | Move cursor down |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-UP | Go to cell start |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-DOWN | Go to cell end |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-LEFT | Move one word left |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-RIGHT | Move one word right |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-] | Indent |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-[ | Dedent |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-/ | Toggle comment |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-D | Delete whole line |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-A | Select all |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-Z | Undo |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-Y | Redo |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-BACKSPACE | Delete word before |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-DELETE | Delete word after |'
  prefs: []
  type: TYPE_TB
- en: '| SHIFT-ENTER | Run cell and select below |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-ENTER | Run selected cells |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-SHIFT-hyphen | Split cell at cursor |'
  prefs: []
  type: TYPE_TB
- en: '| INSERT | Toggle overwrite flag |'
  prefs: []
  type: TYPE_TB
- en: '| CTRL-S | Save and Checkpoint |'
  prefs: []
  type: TYPE_TB
- en: To see the complete list of available shortcuts, click **Help** ▸ **Keyboard
    Shortcuts** or, on your keyboard, press H while in command mode. If these shortcuts
    aren’t enough, you can customize the command mode shortcuts from within the Notebook
    application itself, using the **Edit keyboard Shortcuts** item. A dialog will
    guide you through the process of adding custom keyboard shortcuts. Afterward,
    the keyboard shortcut set from within Notebook will be saved to your configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Command Palette***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can hover your cursor over items in the toolbar ([Figure 5-5](ch05.xhtml#ch05fig5))
    to reveal their purpose. These are straightforward except perhaps for the Command
    Palette icon, shaped like a keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: In Jupyter Notebook and JupyterLab, all user actions are processed through a
    centralized command system. These include the menu bar, context menus, keyboard
    shortcuts, and so on. For your convenience, the command palette provides a keyboard-driven
    way to search for and run these commands ([Figure 5-15](ch05.xhtml#ch05fig15)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-15: A portion of the Command Palette*'
  prefs: []
  type: TYPE_NORMAL
- en: You can also open the command palette using P in command mode and CTRL-SHIFT-P
    in edit mode. To exit the command palette, press the ESC key.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Notebook Extensions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can expand the functionality of the Notebook environment by using extensions
    written in JavaScript. These modules, referred to as *nbextensions*, are basically
    add-ons or plug-ins that do things like autocomplete code, hide coding cells,
    spellcheck Markdown cells, create a table of contents, open a “scratchpad” cell
    for isolated experimentation, and more. You can also write your own custom extensions.
    To see the complete list of available extensions, visit *[https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/nbextensions.html](https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/nbextensions.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Classic Notebook extensions won’t work in the JupyterLab version, which has
    its own set of extensions. You can read about these in the next chapter.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Installing Extensions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *jupyter_contrib_nbextensions* package is a collection of community-contributed
    nbextensions. To load these extensions locally in your browser, you need to install
    it in your *base* environment (if you’re using the modular approach) or your project
    environment (if using the naive approach). For example, to install in *base* using
    the CLI, first activate the environment with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, install the JavaScript and CSS files to a location where Notebook
    can find them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*CSS* (short for *Cascading Style Sheets*) describe how the HTML elements in
    notebooks are displayed. The `--user` flag installs into the user’s home Jupyter
    directories. Alternatively, using the `--system` flag will install into system-wide
    Jupyter directories.'
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve confirmed installation, restart the notebook server.
  prefs: []
  type: TYPE_NORMAL
- en: '***Enabling Extensions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You should now have an Nbextensions tab on the Jupyter Home page with a list
    of selectable nbextensions, as illustrated in [Figure 5-16](ch05.xhtml#ch05fig16).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-16: The new Nbextensions tab (shown truncated) on the Jupyter dashboard*'
  prefs: []
  type: TYPE_NORMAL
- en: Clicking an extension name launches its README file. For example, if you click
    the **Tree Filter** nbextension and scroll down, you’ll see a description of what
    it does and a demonstration of how to use it ([Figure 5-17](ch05.xhtml#ch05fig17)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-17: Clicking an nbextension name launches its descriptive README
    file.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking the checkbox beside an extension turns on that extension. You can
    also enable and disable nbextensions from the CLI (where <extension_name> represents
    the name of the extension):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'and:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: To learn more about the jupyter_contrib_nbextension package, visit *[https://jupyter-contrib-nbextensions.readthedocs.io/](https://jupyter-contrib-nbextensions.readthedocs.io/)*.
    To find the latest extensions, search online for “useful Jupyter Notebook extensions.”
  prefs: []
  type: TYPE_NORMAL
- en: '**Working with Widgets**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Widgets*, short for “Windows Gadgets,” are interactive objects such as sliders,
    radio buttons, drop-down menus, checkboxes, and the like. Widgets let you build
    a GUI for your notebook, making it easier to explore data, set up simulations,
    accept user input, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll use the *ipywidgets* extension to create widgets. Some
    examples are shown in [Figure 5-18](ch05.xhtml#ch05fig18). For a full list of
    widgets, along with their configurable parameters, visit the documentation at
    *[https://ipywidgets.readthedocs.io/en/stable/examples/Widget%20List.html](https://ipywidgets.readthedocs.io/en/stable/examples/Widget%20List.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-18: Some of the many widget types available in ipywidgets*'
  prefs: []
  type: TYPE_NORMAL
- en: We won’t cover every type of widget here, but we’ll cover enough for you to
    feel confident exploring on your own
  prefs: []
  type: TYPE_NORMAL
- en: '***Installing ipywidgets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ipywidgets extension can be installed like any package. The instructions
    that follow will use the CLI, but you can easily duplicate them using the Navigator
    GUI.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re using the naive approach, wherein the notebook package is installed
    in your conda environment, open Anaconda Prompt (Windows) or a terminal (macOS
    and Linux), activate the target environment, and then enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re using the modular approach, wherein your Jupyter Notebook and the
    IPython kernel are installed in different environments, you’ll need to also install
    the *widgetsnbextension* package in the environment containing the Jupyter Notebook
    server. The widgetsnbextension package configures the classic Jupyter Notebook
    to display and use widgets. Let’s do this now for the *base* and *my_nb_proj_env*
    environments (you’ll need to substitute your path to *my_nb_proj_env*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With the ipywidget package installed, you can easily create widgets either manually
    or by using the `interact` or `interactive` classes.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Widgets with Interact***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `ipywidgets.interact` class helps you generate widgets for exploring and
    interacting with data. Let’s try it out in a new notebook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Anaconda Prompt (in Windows) or a terminal (in macOS or Linux). You should
    be in the *base* environment (if not, enter conda activate base). Because we’re
    saving a new notebook, navigate to your *my_nb_proj\notebooks* directory before
    launching Jupyter Notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: From the Jupyter Dashboard, select **New** ▸ **Python [conda env:my_nb_proj_env]**.
    When the untitled notebook appears in your browser, rename it *widgets* and save
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first cell, enter and run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: With this code, you import NumPy, Matplotlib, and the interact class from ipywidgets
    ➊. You then use NumPy’s `linspace()` method to return an array of evenly spaced
    numbers over the specified interval (0-6), and assign it to the `x` variable (we
    look at NumPy in detail in [Chapter 18](ch18.xhtml)). Next, you define a short
    function that multiplies the `x` values by the sine of `x` times a scalar named
    `w` and plots the results. Finally, you call `interact()` and pass it the `sine_wave()`
    function ➋. This produces the slider widget shown in [Figure 5-19](ch05.xhtml#ch05fig19).
    Sliding the control nob redefines the value of `w` and automatically calls the
    `sine_wave()` function to update the plot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-19: Changing the slider interactively updates the sine wave plot.*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that you didn’t need to specify a slider widget. Ipywidgets detected that
    we passed the `sine_wave()` function a floating-point value (`w=1.0`) and knew
    to use a float slider. Had we passed an integer, it would’ve made an integer slider.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use `interact()` as a Python *decorator*. We covered decorators
    in [Chapter 13](ch13.xhtml); these are functions used to enhance the behavior
    of another function. To use `interact()` as a decorator, insert a new cell at
    the bottom of your *widgets* notebook and run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You must run the proceeding cell for this to work, as we aren’t reimporting
    the libraries or reassigning the `x` value. When you run the current cell, the
    decorator ➊ calls the sine wave function for you.
  prefs: []
  type: TYPE_NORMAL
- en: In these examples, `interact()` tries to update the plot as you move the slider,
    sometimes introducing latency in the display. To prevent `interact()` from immediately
    updating, you can instead import the `interact_manual()` method from ipywidgets
    and use it to call the `sine_wave()` function. In this case, the plot won’t update
    until you stop moving the slider and press the **Run Interact** button ([Figure
    5-20](ch05.xhtml#ch05fig20)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-20: The interact_manual() method produces a button for manually running
    interact.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you’ve seen, `interact` determines the type of widget to produce based on
    the input. If you pass it a Boolean, such as `x=True`, it will produce a checkbox.
    A string, like `x=`′`Hello, World!`′, produces a textbox. Passing a list or dictionary
    will generate a drop-down menu. For example, insert a new cell at the bottom of
    your *widgets* notebook and run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You should get the output shown in [Figure 5-21](ch05.xhtml#ch05fig21).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-21: An interact-generated drop-down menu*'
  prefs: []
  type: TYPE_NORMAL
- en: The `interact` class abstracts away a lot of decisions, so it’s easy to use.
    For more control, you’ll want to try the `interactive` class or manually generate
    the widgets.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Widgets with Interactive***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `ipywidgets.interactive` class gives you access to information that is bound
    to the widget, such as its keyword arguments and result. Unlike with `interact()`,
    you’ll need to explicitly show the widget on the screen using the `display()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example. Insert a new cell at the bottom of your widgets notebook
    and enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the cell and move the slider to a value of `8`. Now, insert a cell below
    and run this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The output should be `8`. This lets you use the widget’s result in subsequent
    code rather than just viewing the result.
  prefs: []
  type: TYPE_NORMAL
- en: '***Manually Creating Widgets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `interact` and `interactive` classes make creating widgets almost automatic.
    But if you want more control over the process, you can create them “manually”
    by specifying which widget you want. You’ll be able to define the layout and style,
    name the widgets, link them together, get events, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s work an example. Start by inserting a new cell at the bottom of your
    *widgets.ipynb* notebook, and then run this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This produces the integer slider bar in [Figure 5-22](ch05.xhtml#ch05fig22).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-22: A named integer slider bar*'
  prefs: []
  type: TYPE_NORMAL
- en: By building the widget directly, you’re able to specify additional parameters
    like the displayed name (`description`) and orientation (`horizontal` or `vertical`).
    To see all the available parameters, add `display(slider.keys)` to the current
    cell or, in a new cell, run `slider.keys`. You can find example use cases at the
    documentation link cited earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'A slider bar by itself isn’t much use, but as with the `interactive` class,
    you have access to the slider value, in this case through the `.value` attribute.
    In a new cell, run this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '***Handling Events***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A user interacting with a widget creates an *event*. For example, a *click*
    event occurs when you press a button widget. When you handle an event, you tell
    your program what to do with the results. This usually involves writing an “event
    handler” function.
  prefs: []
  type: TYPE_NORMAL
- en: To capture output and ensure that it’s displayed, you must send it to an `Output`
    widget or put the information you want to display into an `HTML` widget. Let’s
    look at an `Output` example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert a new cell at the bottom of your widgets notebook and then run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This produces the output in [Figure 5-23](ch05.xhtml#ch05fig23). Clicking a
    button prints out the button’s description (name).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-23: Handling a button click event*'
  prefs: []
  type: TYPE_NORMAL
- en: Each time you click a button, the output will hang around in the output cell,
    so import the `clear_output()` method from `IPython` ➊. This method will let you
    start fresh each time a button is clicked. Next, make three button widgets and
    an output widget to display the results ➋.
  prefs: []
  type: TYPE_NORMAL
- en: To handle the button click event, define a function called `event_handler()`
    that takes a button object as an argument ➌. Using the output widget, first clear
    the display to remove the output of any previous button clicks, and then print
    the name of the clicked button. Finally, for each button, use the `Button` widget’s
    `on_click()` method and pass it the event handler function ➍. This binds the function
    to the button click event.
  prefs: []
  type: TYPE_NORMAL
- en: '***Customizing Widgets***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The widgets provided by ipywidgets are attractive out of the box, but you can
    modify them if you want. The widget `layout` attribute gives you control over
    things like the widget size, borders, alignment, and position. You can also arrange
    widgets in gridded patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the events-handling code example from the previous section, add the following
    line above the `button1` variable assignment and change the `button1` code, as
    indicated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Run the cell and you should get the output shown in [Figure 5-24](ch05.xhtml#ch05fig24).
    As you might have guessed, *px* stands for *pixel*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-24: The new layout for the Python button (button1)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Conveniently, many widgets let you use predefined styles. In the previous example,
    change the `button1` assignment as follows and then run the cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The Python button should turn red. Other predefined button style choices are
    `primary` (blue), `success` (green), `info` (teal), and `warning` (orange).
  prefs: []
  type: TYPE_NORMAL
- en: If you need even more control, the `style` attribute exposes non-layout-related
    styling attributes of widgets. The properties of this attribute are widget specific;
    you can list them by using the `keys` property. For example, for `button1` in
    the previous example, you would run `button1.style.keys`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that you want the Python button to be pink, a color not available in
    the predefined styles. In this case, you’d first change `button1` back to its
    original state and then set its background color using the `style` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: These examples are just a small taste of what you can do. To see more options,
    visit the documentation at *[https://ipywidgets.readthedocs.io/en/latest/examples/Widget%20Styling.html](https://ipywidgets.readthedocs.io/en/latest/examples/Widget%20Styling.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Embedding Widgets in Other Formats***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Notebook menu bar provides a Widgets option for embedding interactive widgets
    into static web pages, Sphinx documentation (the familiar “Read the Docs” web
    pages), and HTML-converted notebooks on the *nbviewer* web app. Following are
    the menu items:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Save Notebook Widget State** Saves with the current widget state as metadata,
    allowing the notebook file to be rendered with rendered widgets.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clear Notebook Widget State** Deletes the saved state (you’ll need to restart
    the kernel).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Download Widget State** Triggers the downloading of a JSON file containing
    the serialized state of all the widget models currently in use.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Embed Widgets** Provides a dialog containing an HTML page, which embeds the
    current widgets. To support custom widgets, it uses the RequireJS embedder.'
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about embedding, visit *[https://ipywidgets.readthedocs.io/en/latest/embedding.html#](https://ipywidgets.readthedocs.io/en/latest/embedding.html#)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sharing Notebooks**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scientific work is rarely done in isolation. You’ll need a way to share your
    notebooks. In some cases, you’ll want to share an *executable* version; for example,
    for coworkers who will run and modify the notebook (think coders). In other cases,
    you’ll want to share a static copy of an *executed* notebook that contains all
    the generated plots and outputs (think non-coders). This latter group might include
    stakeholders who don’t want to install Notebook, deal with its data or package
    dependencies, or wait for long-running notebooks to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Notebooks are saved in JSON format and need to be rendered to be readable. In
    the following sections, we’ll talk about some of the methods for downloading and
    sharing notebooks.
  prefs: []
  type: TYPE_NORMAL
- en: '***Checking and Running Notebooks with the Kernel Menu***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A problem with notebooks is that cells can be run out of order, they can be
    deleted, and there’s no guarantee that the correct execution order is easily repeatable.
    And as we saw in previous chapters on the Jupyter Qt console and Spyder, imports
    and variable assignments that are resident in memory can cause confusion and unintended
    consequences.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, before sharing your work, it is strongly recommended that you
    click **Restart & Run All** from the **Kernel** menu ([Figure 5-25](ch05.xhtml#ch05fig25)).
    If errors occur, fix the first one, repeat the command, and move to the next.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-25: The Notebook Kernel menu*'
  prefs: []
  type: TYPE_NORMAL
- en: Another useful menu item is Interrupt. This is handy for long-running notebooks,
    in the event that you forgot to change a parameter or you recognize some error
    in the code or input.
  prefs: []
  type: TYPE_NORMAL
- en: '***Downloading Notebooks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Notebooks are automatically saved as interactive **.ipynb* files. You can email
    these directly to a colleague who uses Notebook. Alternatively, the **File** ▸
    **Download as** command lets you save your notebook in many different formats
    ([Figure 5-26](ch05.xhtml#ch05fig26)). Some of these formats, like PDF via LaTeX,
    require certain packages be installed (if they’re not, don’t worry, you’ll get
    an error message informing you of what’s needed). Among the more important formats
    are HTML and Python.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-26: The Notebook File menu*'
  prefs: []
  type: TYPE_NORMAL
- en: The Python option saves your notebook as a text file with a *.py* extension
    in your downloads folder. You can then run this file as a Python script in a console
    or an IDE like Spyder. Markdown cells, cell numbers, and other non-code material
    is commented out by using the `#` symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you download the geyser notebook from the previous section
    using Python (*.py*), you’ll get the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If you open this *geyser.py* file in Spyder and run it, you’ll see the tabular
    DataFrame output and the violin plot, but not the header or the image of Old Faithful.
  prefs: []
  type: TYPE_NORMAL
- en: You can also export your notebook from the command line using the *nbconvert*
    tool. This tool already powers the **Download as** menu option, but when used
    in the CLI (invoked as `jupyter nbconvert`), you can conveniently convert a batch
    of notebook files to another format with a single command. To learn more, visit
    *[https://nbconvert.readthedocs.io/](https://nbconvert.readthedocs.io/)*.
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve downloaded your notebook in the appropriate format, you’ll still
    need to share it. Email is one option, but for collaborative work, you’ll need
    to include any external data files that you used. And if your notebook uses third-party
    packages, you’ll want to share an environment or requirements file (see [Chapter
    2](ch02.xhtml)) so that those with whom you’re sharing can set up an identical
    environment. In the following sections, we’ll look at some convenient ways to
    share notebooks via third-party websites.
  prefs: []
  type: TYPE_NORMAL
- en: '***Sharing Notebooks via GitHub and Gist***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An easy and flexible way to deploy notebooks is to put them in a *code repository*.
    These sites store source code archives, provide version control to track changes,
    and have both public and private components. Although there are many free hosts
    to choose from, the most popular is *GitHub*.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub, Inc., a subsidiary of Microsoft, is a provider of internet hosting for
    software development and version control using the *Git* program. Git lets you
    store the notebooks you want to share in a folder on your computer, which you
    can think of as a *local* repository. To make this folder function as a repository,
    Git also stores snapshots (records of the state of versions at a specific point
    in time) and metadata in a hidden folder named *.git*. This lets it keep track
    of contents and changes to the files. You can also include supporting data files
    and folders.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub website lets you host clones of these Git repositories online for
    the purpose of sharing, performing collaborative work, and providing a safe backup.
    You can include a *README.md* file to describe what’s in the repository. Other
    users can download your notebooks to run and edit them. They can upload their
    changes using Git’s version control system, which ensures your original work isn’t
    overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see an example repository, follow this link: *[https://github.com/rlvaugh/Impractical_Python_Projects/](https://github.com/rlvaugh/Impractical_Python_Projects/)*.
    Be sure to scroll down to see the README file.'
  prefs: []
  type: TYPE_NORMAL
- en: You can run Git from the command line, but if you’re new to the process, or
    just want to share notebooks, I recommend using the *GitHub Desktop* GUI. The
    Desktop website (*[https://docs.github.com/en/desktop/](https://docs.github.com/en/desktop/)*)
    will walk you through the steps for setting up a free account and creating your
    first repository. In addition, a quick online search will reveal many excellent
    tutorials for using GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, if you want a fast, easy, and lightweight option for sharing
    a notebook, you can use *GitHub Gist*. Gist is basically a tool for sharing text,
    and because notebooks are saved in JSON format, they qualify. Gist is a simple
    solution for when you don’t need a big repository, yet you still get Git’s version
    control system. In fact, a *gist* is a Git repository, with full commit history,
    differences (diffs), fork and clone options, and more.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a gist, you have the option to add multiple files but with limits.
    For example, to add an Excel spreadsheet, you’ll need to save it as a comma-separated
    values (CSV) file. Likewise, you can’t add image files. Nor can you add directories.
    So, if your project is data heavy, you’ll probably want to create a full GitHub
    repository using GitHub Desktop or Git with the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Given that our *geyser.ipynb* notebook is simple and stand-alone, let’s add
    it to Gist. First, go to the website at *[https://gist.github.com/](https://gist.github.com/)*.
    If you already have a GitHub account, click **Sign in** on the right side of the
    Gist banner ([Figure 5-27](ch05.xhtml#ch05fig27)). Otherwise, click **Sign up**
    to create a free account.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-27: The GitHub Gist startup banner*'
  prefs: []
  type: TYPE_NORMAL
- en: After you sign in, click the plus sign (**+**) on the banner ([Figure 5-28](ch05.xhtml#ch05fig28))
    to create a gist.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-28: The GitHub Gist banner after sign-in*'
  prefs: []
  type: TYPE_NORMAL
- en: In the next window, you’ll see a large blank area for adding text ([Figure 5-29](ch05.xhtml#ch05fig29)).
    You’ll also be prompted to add a filename with extension. Enter **geyser.ipynb**
    and then, in the **Gist description** box, enter **Old Faithful eruption notebook**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-29: The Gist creation page*'
  prefs: []
  type: TYPE_NORMAL
- en: Now for the fun part. In the file explorer for your operating system, navigate
    to the *geyser.ipynb* file that we built earlier and drag and drop it into the
    blank text box area in the Gist creation page. You should see the JSON text file
    for your notebook ([Figure 5-30](ch05.xhtml#ch05fig30)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-30: The results of dragging and dropping the notebook into Gist*'
  prefs: []
  type: TYPE_NORMAL
- en: Finish by clicking the *arrow* on the green button in the lower right to see
    the save options. You can create a private (secret) or public gist ([Figure 5-31](ch05.xhtml#ch05fig31)).
    With the secret option, only people who know your URL can see the contents. Let’s
    keep this between us, so click **Create secret gist**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-31: The options for creating a gist*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If someone guesses or accidently discovers the URL to a secret gist, they’ll
    be able to see it. For better security, you’ll need to use GitHub Desktop or Git
    to create a private repository (see “Creating Your First Repository Using GitHub
    Desktop” at [https://docs.github.com/](https://docs.github.com/)).*'
  prefs: []
  type: TYPE_NORMAL
- en: After a few seconds, you should see your notebook fully rendered as a static
    HTML file. Output such as the violin plot will show up only if the notebook was
    executed prior to saving.
  prefs: []
  type: TYPE_NORMAL
- en: If you scroll down, you’ll see a box for adding comments. If you scroll to the
    top, you’ll see icons for actions such as deleting or editing files, as illustrated
    in [Figure 5-32](ch05.xhtml#ch05fig32). If you click Edit, the notebook will revert
    to the JSON format ([Figure 5-30](ch05.xhtml#ch05fig30)). Although it’s possible
    to edit this text and change the notebook, I doubt you’ll want to. Let’s look
    at some other options.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-32: Options for working with the gist*'
  prefs: []
  type: TYPE_NORMAL
- en: By clicking the **Download ZIP** button, users can download your gist as a folder
    on their machine, where they can edit and run the notebook. The Embed pull-down
    menu provides options for embedding the gist in a website (such as a blog post),
    copying a sharable link, or cloning the gist. The embed option works in any text
    field that supports JavaScript. To the left of the **Download ZIP** button, there’s
    an icon for saving the gist to your computer and using it in GitHub Desktop.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If your main reason for sharing notebooks on GitHub is to work collaboratively
    on the notebook’s content, you should clear the output from your notebook before
    adding it to the repository. This will make it easier to track changes to the
    code. To learn more, visit [https://mg.readthedocs.io/git-jupyter.html](https://mg.readthedocs.io/git-jupyter.html).*'
  prefs: []
  type: TYPE_NORMAL
- en: To see the full documentation for Gist, visit *[https://docs.github.com/en/github/writing-on-github/editing-and-sharing-content-with-gists/creating-gists/](https://docs.github.com/en/github/writing-on-github/editing-and-sharing-content-with-gists/creating-gists/)*.
    There’s also a notebook extension, called *gist-it*, for creating gists (*[https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/nbextensions/gist_it/readme.html](https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/nbextensions/gist_it/readme.html)*).
  prefs: []
  type: TYPE_NORMAL
- en: With your notebooks in a repository, you’ll have additional options for distributing
    them. Let’s look at some of the most popular.
  prefs: []
  type: TYPE_NORMAL
- en: '***Sharing Notebooks via Jupyter Notebook Viewer***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Jupyter nbviewer*, or *Notebook Viewer*, is a free service for rendering GitHub-hosted
    notebooks online. It’s useful for when the GitHub rendering engine has difficulty,
    such as with large notebooks, using a mobile device, or using some JavaScript-based
    libraries. Colleagues and stakeholders can use nbviewer to view inputs and outputs,
    but to execute code, they must download the notebook to a local Jupyter installation.'
  prefs: []
  type: TYPE_NORMAL
- en: To use nbviewer, you simply launch the website (*[https://nbviewer.jupyter.org/](https://nbviewer.jupyter.org/)*)
    and paste the notebook’s URL into a text box ([Figure 5-33](ch05.xhtml#ch05fig33)).
    This renders the notebook as a static HTML web page and gives you a stable link
    to that page that you can share with others. This link will remain active so long
    as the notebook location in the GitHub repository doesn’t change.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-33: The nbviewer web application*'
  prefs: []
  type: TYPE_NORMAL
- en: The application also supports browsing collections of notebooks and rendering
    notebooks in other formats, such as slides and scripts. To share multiple notebooks,
    first place them all in the same repository. Then, point nbviewer to the repository’s
    address, and it will automatically create a navigable index for users.
  prefs: []
  type: TYPE_NORMAL
- en: You can test nbviewer using the gist we made in the previous section. Just copy
    the link using either the Embed menu or the clipboard icon (see [Figure 5-32](ch05.xhtml#ch05fig32))
    and then paste it into nbviewer.
  prefs: []
  type: TYPE_NORMAL
- en: '***Sharing Notebooks via Binder***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Binder* (*[https://mybinder.org](https://mybinder.org)*) is a free website
    designed for use with *public* repositories such as on GitHub. Binder lets you
    run notebooks stored in these static repositories by building a *Docker image*
    of the repository. A Docker image is a combination of a filesystem and parameters
    (see *[https://www.docker.com/](https://www.docker.com/)*). When you share your
    notebook, via a URL, Binder provides both your code and all the software needed
    to run it. The user doesn’t need to download or install anything.'
  prefs: []
  type: TYPE_NORMAL
- en: Binder’s base environment is barebones. If your project uses any third-party
    packages, such as Matplotlib or NumPy, your GitHub repository should include either
    an *environment.yml* or a *requirements.txt* file. These files list your project’s
    package requirements (see the “Duplicating and Sharing Environments” on [page
    44](ch02.xhtml#ch00lev2sec22)). Binder will read the file and include any packages
    in the Docker image. It will update this image if you commit new changes to GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: After the image is built, you can use the Binder URL to share your notebook.
    Binder uses a free *JupyterHub* (*[https://jupyter.org/hub](https://jupyter.org/hub)*)
    server to host your repository. JupyterHub is an open source service that allows
    institutions to share notebooks across large pools of users. With the public IP
    address that you provide, users can interact with your code and environment within
    a live JupyterHub instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-34](ch05.xhtml#ch05fig34) shows the Binder start-up screen. I highly
    recommend viewing the “Zero-to-Binder” beginner tutorial by clicking the Python
    link visible at the top of this figure. Additional guidance (not shown) is included
    at the bottom of the home page.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-34: The Binder online form for sharing interactive notebooks*'
  prefs: []
  type: TYPE_NORMAL
- en: Users can execute your notebooks, so you’ll need to provide any data dependencies.
    If these data files require 10MB or less of memory, the simplest solution is to
    add them directly into your GitHub repository. Remember, this must be a public
    repository for Binder to access it, so you don’t want to include any sensitive
    information. And you need to keep in mind Binder downloads data only when the
    Docker image is built, not when the Binder link is clicked. Images are rebuilt
    only when there is a new commit to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: For data sizes between 10MB and a few hundred megabytes, you need to add a file
    called *postBuild* to your repository. This file is a shell script that is executed
    as part of the Docker image construction and is executed only once when a new
    image is built. To learn more, see the documentation at *[https://mybinder.readthedocs.io/en/latest/using/config_files.html#postbuild-run-code-after-installing-the-environment/](https://mybinder.readthedocs.io/en/latest/using/config_files.html#postbuild-run-code-after-installing-the-environment/)*.
  prefs: []
  type: TYPE_NORMAL
- en: It’s impractical to place large files in your GitHub repository or include them
    directly in the image that Binder builds. You’re better off using a library specific
    to the data format to stream the data as you’re using it. Alternatively, you can
    download it on demand as part of your code. For security reasons, outgoing traffic
    is restricted to HTTP or GitHub connections only, so you can’t use FTP sites to
    fetch data using Binder.
  prefs: []
  type: TYPE_NORMAL
- en: If a user changes your notebook through Binder, they will not be able to save
    or push changes to the GitHub repository. To save changes, they will need to download
    the notebook to their computer by clicking **File** ▸ **Download as** ▸ **Notebook
    (.ipynb)**.
  prefs: []
  type: TYPE_NORMAL
- en: Because of its data limits, saving issues, and lack of version control, Binder
    is best for viewing and running notebooks. To collaboratively *develop* notebooks,
    Git with GitHub is preferred.
  prefs: []
  type: TYPE_NORMAL
- en: '***Other Sharing Options***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Other options for sharing notebooks include—but are not limited to—*Jovian*
    (*[https://jovian.ai/docs/](https://jovian.ai/docs/)*), *Google Colaboratory*
    (*[https://colab.research.google.com/notebooks/intro.ipynb/](https://colab.research.google.com/notebooks/intro.ipynb/)*),
    and *Microsoft Azure Notebooks ([https://notebooks.azure.com/](https://notebooks.azure.com/)*).
    These options tend to require more setup than those we discussed previously and
    might not play well with GitHub. All require you have an account, and Jovian needs
    to be locally installed. The notebook interface will look a bit different in the
    Google and Microsoft options.
  prefs: []
  type: TYPE_NORMAL
- en: Colab lets users collaborate and run code that exploits Google’s cloud resources.
    This includes using free GPUs, saving documents to Google Drive, and running the
    *TensorFlow* machine learning library directly in the browser. In fact, Google
    has a “Seedbank” repository of example deep learning notebooks that you can open
    and run with the click of a button.
  prefs: []
  type: TYPE_NORMAL
- en: Jovian permits cell-level commenting and discussion to aid collaboration. Azure
    helps you to create interactive presentations from your notebooks and share them
    easily, though this is simple to do, regardless.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you want total control over who can access your notebooks and how
    they’re used, you can set up your own *JupyterHub* multiuser *Hub*. This lets
    you offer notebook servers to a class of students, a corporate data science workgroup,
    a scientific research project, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: To use JupyterHub, you need a Unix server (typically Linux) running somewhere
    that is accessible to your users on a network. This can require configuring a
    public server, something best done by an IT team to ensure security issues are
    properly addressed. To learn more, visit *[https://jupyterhub.readthedocs.io/en/latest/](https://jupyterhub.readthedocs.io/en/latest/)*
    and *[https://jupyter-server.readthedocs.io/en/latest/operators/public-server.html](https://jupyter-server.readthedocs.io/en/latest/operators/public-server.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If all you need is remote access to your personal machine, you can set up
    a public server with a single user by following the instructions at [https://jupyter-notebook.readthedocs.io/en/stable/public_server.html](https://jupyter-notebook.readthedocs.io/en/stable/public_server.html).*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Trusting Notebooks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’re running Notebook locally on your own computer, your notebook is as
    secure as your computer. But if you’re accessing a notebook remotely, sharing
    your notebooks, or creating a server for multiple users, the potential for hackers
    to exploit the notebook increases.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that a notebook includes output that exists in a context that
    can execute code (via JavaScript). Ideally, code should not execute just because
    a user opens a notebook, especially code that they didn’t write. But after a user
    decides to execute code in the notebook, it should be considered trusted, regardless
    of what it does.
  prefs: []
  type: TYPE_NORMAL
- en: 'To address this, the Jupyter developers have implemented security models designed
    to prevent execution of untrusted code without explicit user input. To ensure
    that a notebook is “trustworthy,” whenever it’s executed and saved, a signature
    is computed from a digest of the notebook’s contents along with a secret key.
    This is stored in a database, writable only by the current user. By default, here’s
    where this database is located:'
  prefs: []
  type: TYPE_NORMAL
- en: '*%APPDATA%/jupyter/nbsignatures.db* in Windows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*~/Library/Jupyter/nbsignatures.db* in macOS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*~/.local/share/jupyter/nbsignatures.db* in Linux'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each signature represents a series of outputs, which were produced by code that
    the user executed. As stated previously, any output generated and saved during
    an interactive session is considered trustworthy.
  prefs: []
  type: TYPE_NORMAL
- en: When a user opens a notebook, the server computes its signature. If it finds
    it in the user’s database, any HTML and JavaScript output will be trusted. Otherwise,
    it’s untrusted.
  prefs: []
  type: TYPE_NORMAL
- en: 'When collaborating on a notebook, other users will have different keys, so
    the notebook will be in an untrusted state when shared to them. There are three
    recommended methods for managing this situation:'
  prefs: []
  type: TYPE_NORMAL
- en: Rerun the notebook after opening (not always viable and you should trust the
    sender).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicitly trust notebooks via **File** ▸ **Trusted notebook** (see [Figure
    5-26](ch05.xhtml#ch05fig26)) or, at the CLI, run jupyter trust /path/to/notebook.ipynb.
    These methods load the notebook, compute a new signature, and add that signature
    to the user’s database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Share a “notebook signatures database” and use a configuration dedicated to
    the project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For detailed instructions on the last approach, along with more information
    on notebook and server security, see the documentation at *[https://jupyter-notebook.readthedocs.io/en/stable/security.html](https://jupyter-notebook.readthedocs.io/en/stable/security.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Turning Notebooks into Slideshows**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you complete your project, you can present the results directly from your
    notebook by turning it into a slideshow. This works much like Microsoft PowerPoint,
    with the notable difference being that you can run code live for a dynamic and
    immersive experience. Let’s work through an example using the modular approach,
    whereby you run Jupyter Notebook from the *base* environment.
  prefs: []
  type: TYPE_NORMAL
- en: '***Installing the RISE Extension***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To enable interactive coding in the slideshow, you’ll need to install the *Reveal.js
    – Jupyter/IPython Slideshow Extension (RISE)*. First, shut down any currently
    running Jupyter notebooks. Next, open Anaconda Prompt (on Windows) or a terminal
    (on macOS or Linux) and run the following in the *base* environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now, Notebook can find this extension and display it on the nbextensions tab
    on the Dashboard page. Make sure that you install RISE in the conda environment
    in which you installed Notebook.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a Slideshow***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s create a new notebook that we can use to demonstrate slideshow capabilities.
    Because we’re saving a new file, we’ll launch Notebook from the *notebooks* folder,
    created previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activate the *base* environment (where Jupyter Notebook is installed). Next,
    use the `cd` command and your personal path to open your *notebooks* directory
    and then start Notebook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When the Notebook dashboard opens in your browser, click the **New** button
    at the upper right of the Files tab to open a drop-down menu ([Figure 5-4](ch05.xhtml#ch05fig4)).
    To activate the kernel in your *my_nb_proj* environment, select **Python [conda
    env:my_nb_proj_env]** from the list. Remember, this lets us start Notebook from
    the *base* environment and then work in *another* environment.
  prefs: []
  type: TYPE_NORMAL
- en: When the blank notebook appears, click **Untitled** near the top of the window,
    rename the new notebook **slideshow** and save it. You should also see the new
    RISE icon on the far-right side of the toolbar ([Figure 5-35](ch05.xhtml#ch05fig35)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-35: The RISE icon at the end of the toolbar*'
  prefs: []
  type: TYPE_NORMAL
- en: From the top menu, click **View** ▸ **Cell Toolbar** ▸ **Slideshow**. The first
    empty cell in your notebook should now include a drop-down menu for selecting
    the slide type, as illustrated in [Figure 5-36](ch05.xhtml#ch05fig36).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-36: An empty notebook cell in slideshow mode. Note the menu for selecting
    the slide type on the right.*'
  prefs: []
  type: TYPE_NORMAL
- en: This menu gives you the six options, described in [Table 5-4](ch05.xhtml#ch05tab4).
    The most used are Slide, Skip, and Notes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-4:** The Slide Type Menu'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Slide type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Slide | Start a new slide. When presenting, use the left and right arrow
    keys to switch slides. |'
  prefs: []
  type: TYPE_TB
- en: '| Sub-slide | Create a subpage with transition animation. Use up and down arrow
    keys to switch. |'
  prefs: []
  type: TYPE_TB
- en: '| Fragment | Create a hidden part of a slide transitioned to using the spacebar.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Skip | Indicate that the selected slide should be skipped and not shown.
    Useful for hiding code that does not generate an in-show visualization. |'
  prefs: []
  type: TYPE_TB
- en: '| Notes | Indicate that the selected slide represents speaker notes. |'
  prefs: []
  type: TYPE_TB
- en: '| - | Indicate that the current cell should behave like the previous cell.
    |'
  prefs: []
  type: TYPE_TB
- en: Now, let’s make a short slideshow about *logarithmic spirals*, a common shape
    found in nature ([Figure 5-37](ch05.xhtml#ch05fig37)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-37: Some examples of the logarithmic spiral in nature*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by making a title slide. In the first cell, set the **Slide Type** menu
    to **Slide**. Then, using the top toolbar, change the cell type to **Markdown**
    and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: On your keyboard, press CTRL-ENTER to exit Markdown mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert a new cell beneath the title, set its types to **Slide** and **Markdown**,
    as before, and then enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Press CTRL-ENTER to execute the code.
  prefs: []
  type: TYPE_NORMAL
- en: Insert a new cell and set its types to **Slide** and **Code**. Next, enter the
    following code, which applies the polar equation and generates interactive slider
    bars. These sliders let you assess the impact of the a, b, and θ parameters. Don’t
    worry about all the details for now; we’ll go over the NumPy and Matplotlib libraries
    later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, insert a new cell below the previous cell and set its types to **Notes**
    and **Markdown**. This cell can prompt you on the meaning of the parameters while
    you’re describing the dynamic plot to your audience. Enter the following and then
    press CTRL-ENTER to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Cells representing “slide notes” must come immediately after the cell with which
    they’re associated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finish the presentation with a new cell whose types are set to **Slide** and
    **Markdown**. Enter the following and then press CTRL-ENTER:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: To launch the slideshow, first save the notebook, next click in the top cell,
    and then click the **RISE** button ([Figure 5-35](ch05.xhtml#ch05fig35)). To operate
    the slideshow, use the keyboard shortcuts in [Table 5-5](ch05.xhtml#ch05tab5).
    For a full list of shortcuts, including ones for operating a virtual chalkboard,
    click the **?** icon visible at the lower left of each slide.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-5:** Selected RISE Keyboard Shortcuts'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Shortcut** | **Result** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ALT-R | Enter or exit RISE (slideshow mode) |'
  prefs: []
  type: TYPE_TB
- en: '| SPACE | Move forward to next slide |'
  prefs: []
  type: TYPE_TB
- en: '| SHIFT-SPACE | Move back to previous slide |'
  prefs: []
  type: TYPE_TB
- en: '| SHIFT-ENTER | Evaluate and select next cell if visible |'
  prefs: []
  type: TYPE_TB
- en: '| HOME/END | Jump to start/end |'
  prefs: []
  type: TYPE_TB
- en: '| T | Open speaker notes window |'
  prefs: []
  type: TYPE_TB
- en: Use the spacebar to navigate to the code cell. If you haven’t executed this
    cell already, do so now by pressing either CTRL-ENTER or SHIFT-ENTER. You may
    need to manually adjust the window for the plot to fit correctly. Move the sliders
    slowly to see how the parameters affect the plot. You can’t do this in PowerPoint!
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Speaker Notes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Slideshow comes with a Speaker Notes window that can help you run the presentation.
    It shows the current slide, upcoming slide, speaker notes, and current and elapsed
    time ([Figure 5-38](ch05.xhtml#ch05fig38)). You can have this window open on your
    laptop screen while you’re projecting the slideshow. To enter this mode, press
    the T key while in the slideshow.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/05fig38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-38: The RISE Speaker Notes window*'
  prefs: []
  type: TYPE_NORMAL
- en: For remote meetings, Binder (discussed in “Sharing Notebooks via Binder” on
    [page 129](ch05.xhtml#ch00lev2sec71)) lets you host a live slideshow session for
    free within a browser, and users won’t need Python or Jupyter to view it. For
    non-live viewing, the slideshow can be exported to a single HTML file.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a lot more to slideshows than I can cover here. The Jupyter Project
    documentation doesn’t include much on the slideshow mode, but you can find plenty
    of detailed tutorials and tips by searching online for “Jupyter Notebook slideshow.”
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jupyter Notebook is wildly popular for good reason; it’s useful, easy, and fun!
    By allowing you to store all your analysis and commentary in one place, notebooks
    make it simple to document your work, share it, present it, and quickly pick up
    where you left off.
  prefs: []
  type: TYPE_NORMAL
- en: Despite this, don’t become *too* enamored with notebooks, because they’re not
    perfect. Their cellular organization encourages pollution of the global namespace,
    discourages writing reusable functions and classes, and makes source control and
    unit testing difficult. Those are some of the reasons why we learned about Spyder
    in [Chapter 4](ch04.xhtml), and why we’ll look at JupyterLab next. With knowledge
    of Notebook, Spyder, and JupyterLab, you’ll always be ready to apply the best
    tool to the task at hand.
  prefs: []
  type: TYPE_NORMAL
