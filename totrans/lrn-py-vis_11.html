<html><head></head><body>
		<section>
			<header>
				<h1 class="chapter"><span class="ChapterNumber"><span epub:type="pagebreak" id="Page_239" title="239"/>11</span><br/><span class="ChapterTitle">Mouse and Keyboard Interaction</span></h1>
			</header>
			<figure class="opener">
				<img alt="" src="image_fi/book_art/chapterart.png"/>
			</figure>
			<p class="ChapterIntro">In this chapter, you’ll learn how to program interactive sketches that respond to mouse and keyboard input. You can combine those input devices in interesting and useful ways. For example, many computer games use a combination of keys for player movement and the mouse for aiming. Here, you’ll program sketches that use the mouse to paint as well as to select items from a tool palette. You’ll also add shortcut keys to activate tools by using the keyboard.</p>
			<p>
				This chapter introduces system variables you can use to monitor mouse clicks and keypresses. You’ll also learn about <em>event functions </em>that execute whenever a particular type of mouse or keyboard event occurs.</p>
			<p>
				The first task you’ll complete is a simple doodling program. The second is a more elaborate paint app that includes a tool palette for selecting colors <span epub:type="pagebreak" id="Page_240" title="240"/>and brushes. When you’re programming interactive sketches, you need to be able to change the contents of the display window in response to user input so both programs are set up as animated sketches.</p>
			<h2 id="h1-500969c11-0001">Mouse Interaction</h2>
			<p class="BodyFirst">You can use mouse input to perform point-and-click operations. You can also program gesture-type motions that combine mouse movements and clicks, like a drag-and-drop or pan. Most mice include three buttons—a left button, a right button, and a clickable scroll wheel that doubles as a center button.</p>
			<h3 id="h2-500969c11-0001">Mouse Variables</h3>
			<p class="BodyFirst">Processing’s <code>mouseX</code> and <code>mouseY</code> variables hold the horizontal and vertical position of your mouse pointer in the display window. Processing also provides the system variables <code>pmouseX</code> and <code>pmouseY</code> that contain the mouse coordinates of the previous frame. There’s also a <code>mousePressed</code> variable that’s set to <code>True</code> whenever a mouse button is held down.</p>
			<p>
				The first task in this chapter focuses on Processing’s mouse variables to monitor the position of the mouse pointer and detect when mouse buttons are pressed. You’ll program a simple sketch for making <em>scratch art</em>. A sheet of scratch art paper is covered with a rainbow blend of colors, then coated in a layer of black (<a href="#figure11-1" id="figureanchor11-1">Figure 11-1</a>). The “scratcher” uses a plastic or wooden stylus to etch lines in the black surface, revealing the colors beneath.</p>
			<figure>
				<img alt="f11001" src="image_fi/500969c11/f11001.png"/>
				<figcaption>
					<p><a id="figure11-1">Figure 11-1</a>: The layers that make up a sheet of scratch art paper (left), and doodling with a stylus (right)</p>
				</figcaption>
			</figure>
			<p>You could buy scratch paper ready-made or make it yourself, but pixels are cheap and reusable!</p>
			<p>
				Create a new file and save it as <em>scratch_art</em>. Add the following code to get your mouse drawing a trail of white circles:</p>
			<pre><code><span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">setup</span>(): <span class="ProcessingBlue">size</span>(800, 400)<span class="ProcessingBlue">    frameRate</span>(20) <span class="ProcessingBlue">background</span>(<span class="ProcessingPurple">'#000000'</span>) <span class="ProcessingBlue">stroke</span>(<span class="ProcessingPurple">'#FFFFFF'</span>)<span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">draw</span>(): <span class="ProcessingBlue">circle</span>(<span class="ProcessingRaspberry">mouseX</span>, <span class="ProcessingRaspberry">mouseY</span>, 15)</code></pre>
			<p>
				Each frame, Processing draws a new circle positioned using the <code>mouseX</code> and <code>mouseY</code> values. Those coordinates are retrieved once each frame, and <span epub:type="pagebreak" id="Page_241" title="241"/>the frame rate is relatively low (20 fps). The <code>draw()</code> block has no <code>background()</code> function, so every circle drawn persists until you close the display window. If you move the mouse slowly, the circles will form a solid white line; wherever you move the mouse quickly, you’ll leave discernible gaps in the line (<a href="#figure11-2" id="figureanchor11-2">Figure 11-2</a>). The upper left corner of the display window always contains a circle, because the first x-y coordinate pair for the mouse is equal to (0, 0).</p>
			<figure>
				<img alt="f11002" src="image_fi/500969c11/f11002.png"/>
				<figcaption>
					<p><a id="figure11-2">Figure 11-2</a>: The faster you move your mouse, the larger the gaps in the line.</p>
				</figcaption>
			</figure>
			<p>
				You can increase the frame rate to fill in the line better, but you’ll still get gaps if you move the mouse fast enough. To ensure a continuous line, replace the <code>circle()</code> function with code for drawing lines:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">draw</span>(): <span class="ProcessingBlue">strokeWeight</span>(15) <span class="ProcessingBlue">line</span>(<span class="ProcessingRaspberry">mouseX</span>, <span class="ProcessingRaspberry">mouseY</span>, <span class="ProcessingRaspberry">pmouseX</span>, <span class="ProcessingRaspberry">pmouseY</span>)</code></pre>
			<p>
				The <code>strokeWeight()</code> argument of <code>15</code> matches the circle diameter from before. The <code>line()</code> function draws a line between the mouse coordinates of the current frame and those of the previous frame.</p>
			<p>
				Run the sketch. The first <code>line()</code> function will extend from the upper left corner (0, 0) to where your mouse pointer first enters the display window. In <a href="#figure11-3" id="figureanchor11-3">Figure 11-3</a>, my mouse enters the display window from the left edge (I’m drawing the wave from left to right).</p>
			<figure>
				<img alt="f11003" src="image_fi/500969c11/f11003.png"/>
				<figcaption>
					<p><a id="figure11-3">Figure 11-3</a>: Drawing a continuous line by using a <span class="LiteralInCaption"><code>line(</code></span><span class="LiteralInCaption"><code>)</code></span> function for each frame</p>
				</figcaption>
			</figure>
			<p><span epub:type="pagebreak" id="Page_242" title="242"/>To turn the “brush” on and off, insert an <code>if</code> statement to activate the <code>line()</code> function while the left mouse button is being pressed:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span><span class="LiteralGray">    strokeWeight(15)</span> <span class="ProcessingOlive">if</span> <span class="ProcessingRaspberry">mousePressed</span> <span class="ProcessingTealGreen">and</span> <span class="ProcessingRaspberry">mouseButton</span> == <span class="ProcessingKhaki">LEFT</span>:<span class="LiteralGray">        line(mouseX, mouseY, pmouseX, pmouseY)</span></code></pre>
			<p>
				The <code>mousePressed</code> variable holds a Boolean value that’s set to <code>True</code> while any mouse button is pressed. The <code>mouseButton</code> variable is equal to <code>LEFT</code>, <code>RIGHT</code>, or <code>CENTER</code>, depending on which button is pressed, and <code>0</code> if it’s none of them.</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="note">
					<h2><span class="NoteHead">NOTE</span></h2>
					<p>
							The <var>mousePressed</var> variable will revert to <var>False</var> as soon as the button is released; the <var>mouseButton</var> variable, however, will retain its value until a different button is pressed (or until the mouse is moved).</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<p>Run the sketch to confirm that Processing draws a white line while you’re holding down the left- mouse button.</p>
			<p>For the rainbow-color scratch art effect, insert code to base the stroke color on the position of the mouse pointer. The horizontal position will control hue, and the vertical position will control saturation:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span> <span class="ProcessingBlue">colorMode</span>(<span class="ProcessingKhaki">HSB</span>, 360, 100, 100) h = <span class="ProcessingRaspberry">mouseX</span> * 360.0 / <span class="ProcessingRaspberry">width</span> s = <span class="ProcessingRaspberry">mouseY</span> * 100.0 / <span class="ProcessingRaspberry">height</span> b = 100 <span class="ProcessingBlue">stroke</span>(h, s, b)<span class="LiteralGray">    . . .</span></code></pre>
			<p>
				In this example, you set the color mode to <code>HSB</code> (hue, saturation, brightness). The <code>h</code> variable is assigned a hue value between 0 and 360; the <code>s</code> variable is assigned a saturation value between 0 and 100. Both the <code>h</code> and <code>s</code> values are based on the mouse pointer’s position relative to the width and height of the display window. The color’s brightness value is always 100 percent.</p>
			<p>
				Run the sketch to test out the finished scratch art program (<a href="#figure11-4" id="figureanchor11-4">Figure 11-4</a>).</p>
			<figure>
				<img alt="f11004" src="image_fi/500969c11/f11004.png"/>
				<figcaption>
					<p><a id="figure11-4">Figure 11-4</a>: Doodling in the scratch art program</p>
				</figcaption>
			</figure>
			<p><span epub:type="pagebreak" id="Page_243" title="243"/>Now that you’ve seen Processing’s mouse variables, in the next task, you’ll learn about mouse event functions.</p>
			<h3 id="h2-500969c11-0002">Mouse Events</h3>
			<p class="BodyFirst">Processing offers a selection of mouse event functions that run each time a particular mouse event takes place. Those functions are <code>mouseClicked()</code>, <code>mouseDragged()</code>, <code>mouseMoved()</code>, <code>mousePressed()</code>, <code>mouseReleased()</code>, and <code>mouseWheel()</code>. You add code to an event function block that executes when the event function is triggered. To illustrate how this works, I’ll compare an example using a <code>mousePressed</code> variable with another that employs a <code>mousePressed()</code> event function.</p>
			<p>
				The following code uses the <code>mousePressed</code> system variable to switch the background color from red to blue with the press of a mouse button:</p>
			<pre><code><span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">draw</span>(): <span class="ProcessingBlue">background</span>(<span class="ProcessingPurple">'#FF0000'</span>) <span class="ProcessingGray"># red</span> <span class="ProcessingOlive">if</span> <span class="ProcessingRaspberry">mousePressed</span>: <span class="ProcessingBlue">background</span>(<span class="ProcessingPurple">'#0000FF'</span>) <span class="ProcessingGray"># blue</span></code></pre>
			<p>
				The background color is blue as long as the user is holding down a mouse button; otherwise, it’s red. The next example uses a mouse event—a <code>mousePressed()</code> function—to perform a similar operation:</p>
			<pre><code><span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">draw</span>(): <span class="ProcessingBlue">background</span>(<span class="ProcessingPurple">'#FF0000'</span>) <span class="ProcessingGray"># red</span> <span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">mousePressed</span>(): <span class="ProcessingBlue">background</span>(<span class="ProcessingPurple">'#0000FF'</span>) <span class="ProcessingGray"># blue</span></code></pre>
			<p>
				Each time a mouse button is pressed, the <code>mousePressed()</code> function executes the blue background line, and the display window will briefly flash blue (for a single frame). It immediately returns to red, regardless of how long you hold down the mouse button. This is because an event function executes just once per event; in other words, the background will not flash blue again until you release and then re-press the mouse button.</p>
			<h3 id="h2-500969c11-0003">Creating a Paint App</h3>
			<p class="BodyFirst">For the next exercise, you’ll program a basic painting app that will feature a tool palette for selecting color swatches and other options. You’ll use the <code>mousePressed()</code>, <code>mouseReleased()</code>, and <code>mouseWheel()</code> functions.</p>
			<p>
				The large dark blue area, to the right in <a href="#figure11-5" id="figureanchor11-5">Figure 11-5</a>, is your canvas for drawing; the tool palette sits against the left edge. You hold down the left-mouse button to draw.</p>
				<span epub:type="pagebreak" id="Page_244" title="244"/>
				<figure>
				<img alt="f11005" src="image_fi/500969c11/f11005.png"/>
				<figcaption>
					<p><a id="figure11-5">Figure 11-5</a>: The paint app with a (badly drawn) Python logo</p>
				</figcaption>
			</figure>
			<p>
				To begin, create a new sketch and save it as <em>paint_app</em>. You’ll use the Ernest font, created by Marc André “Mieps” Misman, to label the buttons in your tool palette. Download this font from the book’s GitHub web page:</p>
			<ol class="decimal">
				<li value="1">Open your web browser and go to <a class="LinkURL" href="https://github.com/tabreturn/processing.py-book/">https://github.com/tabreturn/processing.py-book/</a>.</li>
				<li value="2">Navigate to <em>chapter-11-mouse_and_keyboard_interaction</em>.</li>
				<li value="3">Download the <em>Ernest.ttf</em> file.</li>
				<li value="4">Create a new <em>data</em> subfolder within your sketch folder and place the <em>Ernest.ttf</em> file in it.</li>
			</ol>
			<p>Add the following code to set up your sketch. This defines the display window size, background color, font, and global variables for the paint app:</p>
			<pre><code><span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">setup</span>(): <span class="ProcessingBlue">size</span>(600, 600) <span class="ProcessingBlue">background</span>(<span class="ProcessingPurple">'#004477'</span>) ernest = <span class="ProcessingBlue">createFont</span>(<span class="ProcessingPurple">'Ernest.ttf'</span>, 20) <span class="ProcessingBlue">textFont</span>(ernest)
swatches = [<span class="ProcessingPurple">'#FF0000'</span>, <span class="ProcessingPurple">'#FF9900'</span>, <span class="ProcessingPurple">'#FFFF00'</span>, <span class="ProcessingPurple">            '#00FF00'</span>, <span class="ProcessingPurple">'#0099FF'</span>, <span class="ProcessingPurple">'#6633FF'</span>]
brushcolor = swatches[2]
brushshape = <span class="ProcessingKhaki">ROUND</span>
brushsize = 3
painting = <span class="ProcessingKhaki">False</span><span epub:type="pagebreak" id="Page_245" title="245"/>paintmode = <span class="ProcessingPurple">'free'</span>
palette = 60</code></pre>
			<p>
				You’ll use the global variables (<code>swatches</code>, <code>brushcolor</code>, and so on) to adjust and monitor the state of the brush. The default brush color is set to yellow. Later, you’ll use the <code>palette</code> variable to set the width of the tool palette. You haven’t added anything visual yet, so if you run the sketch, all you’ll see is a plain blue display window.</p>
			<h4 id="h3-500969c11-0001">Controlling the Draw Loop with loop() and noLoop() Functions</h4>
			<p class="BodyFirst">You’ll control the <code>draw()</code> function behavior by using mouse events. While the left mouse button is pressed, the <code>draw()</code> function will loop; once it’s released, the looping stops, which is a convenient way to control how the paint app works. Of course, the <code>draw()</code> function loops by default, so you’ll need the <code>loop()</code> and <code>noLoop()</code> functions to take control of this behavior.</p>
			<p>
				The <code>noLoop()</code> function stops Processing from continually executing the code in the <code>draw()</code> block. A <code>loop()</code> function reactivates the standard <code>draw()</code> function behavior, and a <code>redraw()</code> function is available if you need to execute the <code>draw()</code> code just once.</p>
			<p>
				To start, add a <code>noLoop()</code> function to the <code>setup()</code> block, and a <code>draw()</code> function that prints the frame count:</p>
			<pre><code><span class="LiteralGray">def setup():</span><span class="LiteralGray">    . . .</span> <span class="ProcessingBlue">noLoop</span>()<span class="LiteralGray">. . .</span><span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">draw</span>(): <span class="ProcessingBlue">print</span>(<span class="ProcessingRaspberry">frameCount</span>)</code></pre>
			<p>
				If you run the sketch, the console should display a single <code>1</code>, confirming that the <code>draw()</code> function has run only once.</p>
			<p>
				Now add code to the <code>draw()</code> function to make the mouse draw lines in the display window, and add two mouse events to start and stop the flow of paint:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span><span class="LiteralGray">    print(frameCount)</span> <span class="ProcessingTealGreen">global</span> painting, paintmode <span aria-label="annotation1" class="CodeAnnotation">1</span> <span class="ProcessingOlive">if</span> paintmode == <span class="ProcessingPurple">'free'</span>: <span aria-label="annotation2" class="CodeAnnotation">2</span> <span class="ProcessingOlive">if</span> painting: <span class="ProcessingBlue">stroke</span>(brushcolor) <span class="ProcessingBlue">strokeCap</span>(brushshape) <span class="ProcessingBlue">strokeWeight</span>(brushsize) <span aria-label="annotation3" class="CodeAnnotation">3</span> <span class="ProcessingBlue">line</span>(<span class="ProcessingRaspberry">mouseX</span>, <span class="ProcessingRaspberry">mouseY</span>, <span class="ProcessingRaspberry">pmouseX</span>, <span class="ProcessingRaspberry">pmouseY</span>) <span aria-label="annotation4" class="CodeAnnotation">4</span> <span class="ProcessingOlive">elif</span> <span class="ProcessingRaspberry">frameCount</span> &gt; 1: painting = <span class="ProcessingKhaki">True</span><span epub:type="pagebreak" id="Page_246" title="246"/><span aria-label="annotation5" class="CodeAnnotation">5</span> <span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">mousePressed</span>(): <span class="ProcessingGray"># start painting</span><span class="ProcessingOlive">    if</span> <span class="ProcessingRaspberry">mouseButton</span> == <span class="ProcessingKhaki">LEFT</span>: <span class="ProcessingBlue">loop</span>()<span aria-label="annotation6" class="CodeAnnotation">6</span> <span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">mouseReleased</span>(): <span class="ProcessingGray"># stop painting</span> <span class="ProcessingOlive">if</span> <span class="ProcessingRaspberry">mouseButton</span> == <span class="ProcessingKhaki">LEFT</span>: <span class="ProcessingTealGreen">global</span> painting painting = <span class="ProcessingKhaki">False</span> <span class="ProcessingBlue">noLoop</span>()</code></pre>
			<p>
				Read over this code while simulating the process in your mind, paying careful attention to when <code>painting</code> is equal to <code>True</code> or <code>False</code>, and when the <code>draw()</code> function is running continuously. The sketch begins with the <code>painting</code> variable set to <code>False</code>; the <code>draw()</code> function isn’t looping at this point. When you press the left mouse button <span aria-label="annotation5" class="CodeAnnotation">5</span>, the <code>loop()</code> function instructs Processing to resume looping the <code>draw()</code> function; when you release the button <span aria-label="annotation6" class="CodeAnnotation">6</span>, the <code>noLoop()</code> function halts the draw behavior again. The <code>paintmode</code> variable is set to <code>free</code> <span aria-label="annotation1" class="CodeAnnotation">1</span> by default, so Python checks whether you’re currently painting <span aria-label="annotation2" class="CodeAnnotation">2</span>. You’ll add other paint modes later. If <code>painting</code> is equal to <code>True</code>, Processing draws a line between the mouse coordinates of the current frame and those of the previous frame <span aria-label="annotation3" class="CodeAnnotation">3</span>; if not, it checks that the frame count has passed <code>1</code> <span aria-label="annotation4" class="CodeAnnotation">4</span> before setting the <code>painting</code> variable to <code>True</code>. The <code>if</code> <span aria-label="annotation2" class="CodeAnnotation">2</span> and <code>elif</code> <span aria-label="annotation4" class="CodeAnnotation">4</span> steps are necessary to avoid drawing straight lines between where you cease and resume painting (release the left button, move the mouse, and then press the button again), and the <code>frameCount &gt; 1</code> stops Processing from drawing a line from the upper left corner to where you first begin painting. In <a href="#figure11-6" id="figureanchor11-6">Figure 11-6</a>, the left screenshot depicts what happens if you omit those statements.</p>
			<figure>
				<img alt="f11006" src="image_fi/500969c11/f11006.png"/>
				<figcaption>
					<p><a id="figure11-6">Figure 11-6</a>: Processing drawing straight lines between the points where painting stops and starts (left), and your version of the program (right)</p>
				</figcaption>
			</figure>
			<p><span epub:type="pagebreak" id="Page_247" title="247"/>Run the sketch, and draw a few circles to test that the code is working. Watch the console and note that the frame count increases only while you’re pressing the left mouse button.</p>
			<h4 id="h3-500969c11-0002">Adding Selectable Color Swatches</h4>
			<p class="BodyFirst">The tool palette will include six color swatches that you can use to change the brush color. Add the following code to the bottom of the <code>draw()</code> block to render a black panel against the left edge of the display window, and within it, six color swatches based on the <code>swatches</code> list:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span><span class="LiteralGray">    . . .</span> <span class="ProcessingGray"># black panel</span> <span class="ProcessingBlue">noStroke</span>() <span class="ProcessingBlue">fill</span>(<span class="ProcessingPurple">'#000000'</span>) <span class="ProcessingBlue">rect</span>(0, 0, palette, <span class="ProcessingRaspberry">height</span>) <span class="ProcessingGray"># color swatches</span> <span class="ProcessingOlive">for</span> i, swatch <span class="ProcessingTealGreen">in</span> <span class="ProcessingBlue">enumerate</span>(swatches): sx = <span class="ProcessingBlue">int</span>(i%2) * palette/2 sy = <span class="ProcessingBlue">int</span>(i/2) * palette/2 <span class="ProcessingBlue">fill</span>(swatch) <span class="ProcessingBlue">square</span>(sx, sy, palette/2)<span class="LiteralGray">. . .</span></code></pre>
			<p>
				The <code>for</code> loop iterates the swatches list, drawing a grid of squares filled in different colors. Your program draws the panel (and swatch elements) after the brushstrokes to prevent unwanted strokes appearing over the palette as you select things.</p>
			<p>
				If a user clicks a color swatch, you must assign that color to the <code>brushcolor</code> variable; add code for this to the <code>mousePressed()</code> function:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">def mousePressed():</span><span class="LiteralGray">    . . .</span> <span class="ProcessingGray"># swatch select</span> <span class="ProcessingOlive">if</span> <span class="ProcessingRaspberry">mouseButton</span> == <span class="ProcessingKhaki">LEFT</span> <span class="ProcessingOlive">and</span> <span class="ProcessingRaspberry">mouseX</span> &lt; palette <span class="ProcessingTealGreen">and</span> <span class="ProcessingRaspberry">mouseY</span> &lt; 90: <span class="ProcessingTealGreen">global</span> brushcolor brushcolor = <span class="ProcessingBlue">get</span>(<span class="ProcessingRaspberry">mouseX</span>, <span class="ProcessingRaspberry">mouseY</span>)</code></pre>
			<p>
				The <code>if</code> statement tests for a left-click and checks that the mouse pointer is positioned somewhere over the color swatches. The <code>get()</code> function returns the color for the pixel under the mouse pointer and assigns it to the <code>brushcolor</code> variable. You add a <code>global</code> line to overwrite the <code>brushcolor</code> variable in the global scope, the same variable that the <code>draw()</code> function uses to apply the stroke for the brush color.</p>
			<p>
				Run the sketch. You can now select colors for painting (<a href="#figure11-7" id="figureanchor11-7">Figure 11-7</a>).</p>
				<span epub:type="pagebreak" id="Page_248" title="248"/>
				<figure>
				<img alt="f11007" src="image_fi/500969c11/f11007.png"/>
				<figcaption>
					<p><a id="figure11-7">Figure 11-7</a>: Click the swatches in the tool palette to change the brush’s color.</p>
				</figcaption>
			</figure>
			<p>Next, you’ll add a feature for resizing the brush, mapping this to the scroll wheel.</p>
			<h4 id="h3-500969c11-0003">Resizing the Brush by Using the Scroll Wheel</h4>
			<p class="BodyFirst">The <code>mouseWheel()</code> event function is used to execute code when the mouse wheel is moved. Additionally, you can use it to retrieve positive or negative values depending on the direction of the scroll wheel’s rotation. The direction of rotation for positive/negative values, however, depends on your system’s configuration. Your touch pad scroll should work for this too, usually with a two-finger drag.</p>
			<p>
				Add a <code>mouseWheel()</code> function to the very bottom of your code:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">mouseWheel</span>(e): <span class="ProcessingBlue">print</span>(e)</code></pre>
			<p>
				The <code>e</code> within the <code>mouseWheel()</code> function’s parentheses serves as a variable to which the event details are assigned. You may name this whatever you like; programmers commonly use <code>e</code> or <code>event</code>.</p>
			<p><span epub:type="pagebreak" id="Page_249" title="249"/>Run the sketch, position your mouse pointer somewhere over the display window, and use the scroll wheel. The console should display something like the following:</p>
			<pre><code>&lt;MouseEvent WHEEL@407,370 count:1 button:0&gt;</code></pre>
			<p>
				From this output, you can establish that the type of mouse event is <code>WHEEL</code>. At the moment of the event, the horizontal mouse position is 407, and the vertical position is 370 (<code>@407,370</code>). The scroll direction is positive (<code>count:1</code>). Of course, your values will vary somewhat.</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="note">
					<h2><span class="NoteHead">NOTE</span></h2>
					<p>
							You can also add this <var>event</var> variable to one of the other mouse functions—like <var>mousePressed()</var> or <var>mouseReleased()</var>. As an example, for <var>mousePressed(e)</var>, the <var>e</var> might hold something like <var>&lt;MouseEvent PRESS@407,370 count:1 button:37&gt;</var>.</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<p>
				Add code that uses the <code>mouseWheel()</code> function to adjust the brush size. This code will also display a brush preview below the swatches, which will reflect the active brush’s color, size, and shape:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span><span class="LiteralGray">    . . .</span> <span class="ProcessingGray"># brush preview</span> <span class="ProcessingBlue">fill</span>(brushcolor) <span class="ProcessingOlive">if</span> brushshape == <span class="ProcessingKhaki">ROUND</span>: <span class="ProcessingBlue">circle</span>(palette/2, 123, brushsize) <span aria-label="annotation1" class="CodeAnnotation">1</span> paintmode = <span class="ProcessingPurple">'free'</span><span class="LiteralGray">. . .</span><span class="LiteralGray">def mouseWheel(e):</span> <span class="ProcessingGray"># resize the brush</span> <span class="ProcessingTealGreen">global</span> brushsize, paintmode <span aria-label="annotation2" class="CodeAnnotation">2</span> paintmode = <span class="ProcessingPurple">'select'</span> <span aria-label="annotation3" class="CodeAnnotation">3</span> brushsize += e.count <span aria-label="annotation4" class="CodeAnnotation">4</span> <span class="ProcessingOlive">if</span> brushsize &lt; 3: brushsize = 3 <span aria-label="annotation5" class="CodeAnnotation">5</span> <span class="ProcessingOlive">if</span> brushsize &gt; 45: brushsize = 45 <span class="ProcessingBlue">redraw</span>()</code></pre>
			<p>
				You don’t want to paint while adjusting the brush size, so <code>paintmode</code> is switched to <code>select</code> <span aria-label="annotation2" class="CodeAnnotation">2</span>. The <code>e.count</code> is used to retrieve the negative/positive scroll value from the event variable, which is added to <code>brushsize</code> <span aria-label="annotation3" class="CodeAnnotation">3</span>. It’s necessary, however, to include checks (<code>if</code> statements) to ensure that the new brush size remains within a reasonable range (between <code>3</code> <span aria-label="annotation4" class="CodeAnnotation">4</span> and <code>45</code> <span aria-label="annotation5" class="CodeAnnotation">5</span>). Finally, the <code>redraw()</code> function runs the <code>draw()</code> function, just once, to update the brush preview and switch <code>paintmode</code> back to <code>free</code> <span aria-label="annotation1" class="CodeAnnotation">1</span>.</p>
			<p>
				Run the sketch to confirm that you can resize the brush by using the scroll wheel, which updates the brush preview in the palette (<a href="#figure11-8" id="figureanchor11-8">Figure 11-8</a>).</p>
				<span epub:type="pagebreak" id="Page_250" title="250"/>
				<figure>
				<img alt="f11008" src="image_fi/500969c11/f11008.png"/>
				<figcaption>
					<p><a id="figure11-8">Figure 11-8</a>: Painting with brushes of different sizes</p>
				</figcaption>
			</figure>
			<p>
				There’s one problem, though. When selecting swatches with a large brush, a blob of paint might extend into the dark blue canvas area (<a href="#figure11-9" id="figureanchor11-9">Figure 11-9</a>).</p>
			<figure>
				<img alt="f11009" src="image_fi/500969c11/f11009.png"/>
				<figcaption>
					<p><a id="figure11-9">Figure 11-9</a>: Selecting a color swatch with a large brush</p>
				</figcaption>
			</figure>
			<p>
				To solve this problem, add an <code>if</code> statement to the <code>draw()</code> function that disables painting while the mouse is over the palette. Use the <code>paintmode</code> variable to control this:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">def draw():</span><span class="LiteralGray">    print(frameCount)</span><span class="LiteralGray">    global painting, paintmode</span> <span class="ProcessingOlive">if</span> <span class="ProcessingRaspberry">mouseX</span> &lt; palette: paintmode = <span class="ProcessingPurple">'select'</span><span class="LiteralGray">    . . .</span></code></pre>
			<p>Run the sketch to confirm that you can select color swatches with large brushes, without blobs encroaching on the canvas area.</p>
			<p>
				Now that you understand how mouse events work, consult the online reference if you need a <code>mouseDragged()</code> or <code>mouseMoved()</code> function. You’ll try out a <code>mouseClicked()</code> function in <span class="xref">“Challenge #11: Adding Paint App Features” on page 252</span>. If you’d like to change the mouse pointer from an arrow to something else, you can use the <code>cursor()</code> function. For example, you can add a <code>cursor(CROSS)</code> function to the <code>setup()</code> block for a crosshair.</p>
			<h2 id="h1-500969c11-0002"><span epub:type="pagebreak" id="Page_251" title="251"/>Keyboard Interaction</h2>
			<p class="BodyFirst">Computers inherited their keyboard designs from typewriters. In the process, computer keyboards spawned various new keys, such as the arrow, escape, and function keys, and a number pad for more efficient numeric entry. They also have modifier keys (like <span class="KeyCaps">alt</span> and <span class="KeyCaps">ctrl</span>) that you can use in conjunction with other keys to perform specific operations. For example, the Z, X, C, and V keys combine with <span class="KeyCaps">ctrl</span> or <span class="KeyCaps"></span> to perform undo/cut/copy/paste operations.</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="note">
					<h2><span class="NoteHead">NOTE</span></h2>
					<p>
							The typewriter’s <span class="KeyCaps">shift</span> key could be credited as the original modifier key, taking its name from how it physically <em>shifted </em>a substantial part of the typewriting mechanism into a position for typing uppercase letters.</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<p>
				Keyboard interaction in Processing works similarly to mouse interaction, with system variables such as <code>key</code> and <code>keyPressed</code>, and event functions like <code>keyPressed()</code>, <code>keyReleased()</code>, and <code>keyTyped()</code>.</p>
			<p>Now, let’s add keyboard shortcuts to the paint app for selecting colors.</p>
			<h3 id="h2-500969c11-0004">Adding Keyboard Shortcuts to the Paint App</h3>
			<p class="BodyFirst">To program the shortcuts, you’ll combine the <code>key</code> system variable and <code>keyPressed()</code> event function. The <code>keyPressed()</code> function runs once each time a key is pressed. However, holding down a key may cause repeated function calls. The operating system controls this repetitive behavior, and configurations can vary among users. Processing stores the value of the most recently used key in the <code>key</code> system variable.</p>
			<p>
				Add a <code>keyPressed()</code> event function to the end of your code. For now, this will print the <code>key</code> value in the console:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">keyPressed</span>(): <span class="ProcessingBlue">print</span>(<span class="ProcessingRaspberry">key</span>)</code></pre>
			<p>
				Run the sketch and press different keys. Numbers, letters, and symbols display in the console as you might expect them to—you get a <code>1</code> when you press the 1 key, a <code>q</code> when you press the Q key, and so on. If <span class="KeyCaps">caps lock</span> is on, you get uppercase letters.</p>
			<aside epub:type="sidebar">
				<div class="top hr">
					<hr/>
				</div>
				<section class="note">
					<h2><span class="NoteHead">NOTE</span></h2>
					<p>
							Special keys, like the arrow and modifier keys, work a little differently. If you need to detect those, refer to the reference entry for <var>keyCode</var>.</p>
					<div class="bottom hr">
						<hr/>
					</div>
				</section>
			</aside>
			<p>
				To select different color swatches, replace the <code>print()</code> function with code that uses the number keys 1 to 6:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="LiteralGray">def keyPressed():</span> <span class="ProcessingTealGreen">global</span> brushcolor, paintmode paintmode = <span class="ProcessingPurple">'select'</span><span class="ProcessingPurple">    </span><span class="ProcessingGray"># color swatch shortcuts</span><span epub:type="pagebreak" id="Page_252" title="252"/> <span class="ProcessingOlive">if</span> <span class="ProcessingBlue">str</span>(<span class="ProcessingRaspberry">key</span>).isdigit(): k = <span class="ProcessingBlue">int</span>(<span class="ProcessingRaspberry">key</span>) - 1 <span class="ProcessingOlive">if</span> k &lt; <span class="ProcessingBlue">len</span>(swatches): brushcolor = swatches[k] <span class="ProcessingBlue">redraw</span>()</code></pre>
			<p>
				Python’s <code>isdigit()</code> method returns <code>True</code> if all of the characters in a string are digits. This works only on characters/strings and will handle most <code>key</code> values fine, returning <code>False</code> for any letters and symbols. However, Processing represents special keys (arrows and modifiers) by using numeric codes—in other words, integers, not strings. So, you use <code>str(key)</code> to convert any numeric codes to strings to prevent certain keypresses from crashing the app. If the <code>key</code> value is a digit, Python will subtract 1 from it and assign it to variable <code>k</code>. Because the <code>swatches</code> list is zero-indexed, color 1 is equal to <code>swatches[0]</code>, and so forth. The final <code>if</code> statement verifies that the index value (<code>k</code>) is less than the length of the swatches list—in other words, a number between 0 and 5. The <code>redraw()</code> function updates the brush preview.</p>
			<p>The paint app can paint in different colors, in strokes of varying thickness. Experiment with adding other features to your paint app.</p>
			<h4 class="HeadProject"><span>Challenge #11: Adding Paint App Features</span></h4>
			<p class="BodyFirst">One of the most useful features you can add is a Clear button so you don’t need to close and reopen the app when you want a blank, new canvas. You’ll program a button that resets the canvas to dark blue.</p>
			<p>
				Add a button labeled <code>CLEAR</code> to the palette:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">draw</span>():<span class="LiteralGray">    . . .</span> <span class="ProcessingGray"># clear button</span> <span class="ProcessingBlue">fill</span>(<span class="ProcessingPurple">'#FFFFFF'</span>) <span class="ProcessingBlue">text</span>(<span class="ProcessingPurple">'CLEAR'</span>, 10, <span class="ProcessingRaspberry">height</span>-12)</code></pre>
			<p>
				This draws <code>CLEAR</code>, in the Ernest font, in the lower left corner of the display window (<a href="#figure11-10" id="figureanchor11-10">Figure 11-10</a>).</p>
			<figure>
				<img alt="f11010" src="image_fi/500969c11/f11010.png"/>
				<figcaption>
					<p><a id="figure11-10">Figure 11-10</a>: The Clear button</p>
				</figcaption>
			</figure>
			<p><span epub:type="pagebreak" id="Page_253" title="253"/>You can use a <code>mouseClicked()</code> function to execute code when a mouse button is clicked, at the moment of release. Like the other mouse events, this code executes just once until you repeat the action. Add a <code>mouseClicked()</code> function to your code:</p>
			<pre><code><span class="LiteralGray">. . .</span><span class="ProcessingTealGreen">def</span> <span class="ProcessingBlueBold">mouseClicked</span>(): <span class="ProcessingBlue">circle</span>(<span class="ProcessingRaspberry">width</span>/2, <span class="ProcessingRaspberry">height</span>/2, <span class="ProcessingRaspberry">width</span>)</code></pre>
			<p>
				If you click anywhere in the display window, this code will draw a circle over the entire paint app. Now replace the <code>circle()</code> line with code that responds only to clicks over the Clear button and not anywhere outside that region. Additionally, this code must draw a dark blue square over the canvas area.</p>
			<p>
				Once you have the Clear button working correctly, try adding a Save (As Image) button, an eraser, more swatches, or maybe even a color mixer. If you need help, you can find the solution at <a class="LinkURL" href="https://github.com/tabreturn/processing.py-book/tree/master/chapter-11-mouse_and_keyboard_interaction/paint_app/">https://github.com/tabreturn/processing.py-book/tree/master/chapter-11-mouse_and_keyboard_interaction/paint_app/</a>.</p>
			<h2 id="h1-500969c11-0003">Summary</h2>
			<p class="BodyFirst">In this chapter, you learned how to add interactivity to your sketches by using mouse and keyboard input. You learned about Processing’s system variables for those input devices, as well as their event functions that execute, just once, when a specific event occurs.</p>
			<p>Processing supports a range of input devices, such as microphones, cameras, and game controllers, and I encourage you to explore those features. You can also connect an Arduino board to Processing if you want to build custom input devices.</p>
			<p>In this chapter, you programmed a simple tool palette for selecting color swatches. Many software and web development projects require graphic interface development, and many graphical user interface (GUI) toolkits provide sets of ready-made widgets for things like buttons, checkboxes, sliders, drop-down lists, and text fields. Processing has GUI libraries to explore if you want to build more complex interfaces. For Python (outside of Processing), Tkinter, PyQt, and Kivy are a few options.</p>
			<p>In the Afterword, I’ll point you to other useful resources and suggest the next steps you might consider taking in your creative coding adventures.</p>
		</section>
	</body></html>