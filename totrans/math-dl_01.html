<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch01"><span epub:type="pagebreak" id="page_1"/><strong><span class="big">1</span><br/>SETTING THE STAGE</strong></h2>&#13;
<div class="imagec"><img src="Images/common.jpg" alt="image" width="189" height="189"/></div>&#13;
<p class="noindents">Although this book has no traditional math exercises, we do need to play around with the concepts if we want to master them. We’ll have plenty of opportunities for that, but instead of pencil and paper exercises, we’ll use code.</p>&#13;
<p class="indent">This chapter will help you set the stage by configuring our working environment. Throughout the book, I’ll work in Linux, specifically Ubuntu 20.04, though what we’re doing most likely will work in later versions of Ubuntu and most other Linux distributions as well. For completeness, I’ve included sections on configuring macOS and Windows environments. I should point out that the expected operating system for deep learning is Linux, with most things working under macOS as well. Windows is typically an afterthought, and many deep learning toolkit ports are poorly maintained, though this is improving with time.</p>&#13;
<p class="indent">We’ll begin with some instructions for installing the expected software packages. Then we’ll take a quick look at the NumPy library for Python 3.<em>x</em>. NumPy is foundational to virtually all scientific uses of Python, and it’s essential that you know how to work with it at a basic level. Next, I’ll introduce SciPy. This is also a necessary toolkit for science, but we’ll only need the tiniest portion of it here. Finally, I’ll talk a bit about the Scikit-Learn toolkit, abbreviated here as <span class="literal">sklearn</span>. This valuable toolkit implements many of the traditional machine learning models.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_2"/>Throughout the book, I’ll often use running examples to illustrate concepts. All code snippets assume the following line has been executed:</p>&#13;
<p class="programs">import numpy as np</p>&#13;
<p class="indent">Also, in some places, the code will reference output from a snippet that appeared earlier in the chapter. The code examples are brief, so following one to the next shouldn’t be burdensome. I do recommend leaving a single Python session running as you work through a chapter, though this is not required.</p>&#13;
<h3 class="h3" id="ch01lev1_1">Installing the Toolkits</h3>&#13;
<p class="noindent">The end goal of this section is to have the following toolkits installed with <em>at least</em> the version number listed:</p>&#13;
<ul>&#13;
<li class="noindent">Python 3.8.5</li>&#13;
<li class="noindent">NumPy 1.17.4</li>&#13;
<li class="noindent">SciPy 1.4.1</li>&#13;
<li class="noindent">Matplotlib 3.1.2</li>&#13;
<li class="noindent">Scikit-Learn (<span class="literal">sklearn</span>) 0.23.2</li>&#13;
</ul>&#13;
<p class="noindent">Later versions than these almost certainly will work as well.</p>&#13;
<p class="indent">Let’s take a quick look at how we can install each of these toolkits in the major operating systems.</p>&#13;
<h4 class="h4" id="ch01lev2_1">Linux</h4>&#13;
<p class="noindent">For the following, the <span class="literal">$</span> prompt represents the command line, whereas <span class="literal">&gt;&gt;&gt;</span> is the Python prompt.</p>&#13;
<p class="indent">A fresh install of Ubuntu 20.04 desktop gives us Python 3.8.5 for free. Use the code</p>&#13;
<p class="programs"><span class="codestrong1">$ cat /etc/os-release</span></p>&#13;
<p class="noindent">to verify your operating system version and use <span class="literal">python3</span> to run Python, as <span class="literal">python</span> alone starts the older Python 2.7.</p>&#13;
<p class="indent">These commands install NumPy, SciPy, Matplotlib, and <span class="literal">sklearn</span>:</p>&#13;
<p class="programs"><span class="codestrong1">$ sudo apt-get install python3-pip<br/>&#13;
$ sudo apt-get install python3-numpy<br/>&#13;
$ sudo apt-get install python3-scipy<br/>&#13;
$ sudo pip3 install matplotlib<br/>&#13;
$ sudo pip3 install scikit-learn</span></p>&#13;
<p class="indent">Test the installation by starting Python 3 and importing each module: <span class="literal">numpy</span>, <span class="literal">scipy</span>, and <span class="literal">sklearn</span>. Then print the <span class="literal">__version__</span> string to make sure it meets or exceeds the versions listed above. For example, see the following code.</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_3"/>&gt;&gt;&gt;<span class="codestrong1"> import numpy; numpy.__version__</span><br/>&#13;
'1.17.4'<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">import scipy; scipy.__version__</span><br/>&#13;
'1.4.1'<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">import matplotlib; matplotlib.__version__</span><br/>&#13;
'3.1.2'<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">import sklearn; sklearn.__version__</span><br/>&#13;
'0.23.2'</p>&#13;
<h4 class="h4" id="ch01lev2_2">macOS</h4>&#13;
<p class="noindent">To install Python 3.<em>x</em> for Macintosh, go to <em><a href="https://www.python.org/">https://www.python.org/</a></em>, and under <strong>Downloads</strong>, choose <strong>Mac OS X</strong>. Then select the latest stable Python 3 release. At the time of this writing, it’s 3.9.2. When the download is complete, run the installer to get Python 3.9.2 set up.</p>&#13;
<p class="indent">After the installation, open a terminal window and verify the installation with the following:</p>&#13;
<p class="programs"><span class="codestrong1">$ python3 --version</span><br/>&#13;
Python 3.9.2</p>&#13;
<p class="indent">Assuming Python 3 installed correctly, now we can install the libraries using the terminal window and <span class="literal">pip3</span>, which the installer set up for us:</p>&#13;
<p class="programs">$ <span class="codestrong1">pip3 install numpy --user</span><br/>&#13;
$ <span class="codestrong1">pip3 install scipy --user</span><br/>&#13;
$ <span class="codestrong1">pip3 install matplotlib --user</span><br/>&#13;
$ <span class="codestrong1">pip3 install scikit-learn --user</span></p>&#13;
<p class="noindent">And, finally, we can check the versions of the libraries from within Python 3. Enter <strong>python3</strong> in the terminal to pull up a Python console, and then import <span class="literal">numpy</span>, <span class="literal">scipy</span>, <span class="literal">matplotlib</span>, and <span class="literal">sklearn</span> and print the version strings, as we did above, to verify that they meet or exceed the minimum versions.</p>&#13;
<h4 class="h4" id="ch01lev2_3">Windows</h4>&#13;
<p class="noindent">To install Python 3 and the toolkits for Windows 10, use the following steps:</p>&#13;
<ol>&#13;
<li class="noindent">Go to <em><a href="https://www.python.org/">https://www.python.org/</a></em> and click <strong>Downloads</strong> and <strong>Windows</strong>.</li>&#13;
<li class="noindent">At the bottom of the page, select the x86-64 executable installer.</li>&#13;
<li class="noindent">Run the installer, choosing the default options.</li>&#13;
<li class="noindent">Select <strong>Install for All Users</strong> and <strong>Add Python to the Windows PATH</strong>. This is important.</li>&#13;
</ol>&#13;
<p class="indent">When the installer finishes, Python will be available from the command prompt because we told the installer to add Python to the <span class="literal">PATH</span> environment <span epub:type="pagebreak" id="page_4"/>variable. Therefore, open the command prompt (WINDOWS-R, <span class="literal">cmd</span>), and enter <span class="literal">python</span>. If all goes well, you’ll be greeted by the Python startup message and see a <span class="literal">&gt;&gt;&gt;</span> interactive prompt. At the time of this writing, the version installed was 3.8.2. Note that to exit Python in Windows, use CTRL-Z, not CTRL-D.</p>&#13;
<p class="indent">The Python installer did us the courtesy of installing <span class="literal">pip</span> as well. We can use it directly from the Windows command prompt to install the libraries we need. At the prompt, enter the following lines to install the NumPy, SciPy, Matplotlib, and <span class="literal">sklearn</span> libraries:</p>&#13;
<p class="programs">&gt; <span class="codestrong1">pip install numpy</span><br/>&#13;
&gt; <span class="codestrong1">pip install scipy</span><br/>&#13;
&gt; <span class="codestrong1">pip install matplotlib</span><br/>&#13;
&gt; <span class="codestrong1">pip install sklearn</span></p>&#13;
<p class="noindent">For me, this installed NumPy 1.18.1, SciPy 1.4.1, Matplotlib 3.2.1, and <span class="literal">sklearn</span> 0.22.2, which meet the minimum versions above, so all is well.</p>&#13;
<p class="indent">To test things, start Python from the command prompt and import <span class="literal">numpy</span>, <span class="literal">scipy</span>, <span class="literal">matplotlib</span>, and <span class="literal">sklearn</span>. All three should load without error. To write Python code, install any editor you’re comfortable with, or simply use Notepad.</p>&#13;
<p class="indent">With your toolkits installed and good to go, let’s take a quick look at each library to become at least a bit more familiar with them. We’ll see examples throughout the book, but I recommend you look at the suggested documentation. It’s worth it.</p>&#13;
<h3 class="h3" id="ch01lev1_2">NumPy</h3>&#13;
<p class="noindent">We installed NumPy in the previous section. Now I’ll introduce some basic NumPy concepts and manipulations. A full tutorial is available online at <em><a href="https://docs.scipy.org/doc/numpy/user/quickstart.html">https://docs.scipy.org/doc/numpy/user/quickstart.html</a></em>.</p>&#13;
<p class="indent">Start Python. Then try the following at the prompt:</p>&#13;
<p class="programs">&gt;&gt;&gt;<span class="codestrong1"> import numpy as np</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">np.__version__</span><br/>&#13;
'1.16.2'</p>&#13;
<p class="indent">The first line loads NumPy and sets up a shortcut name for it, <span class="literal">np</span>. Using the shortcut name isn’t required, but doing so is nearly universal. We’ll assume <span class="literal">np</span> going forward. The second line displays the version. It should be at least what is shown above.</p>&#13;
<h4 class="h4" id="ch01lev2_4"><span epub:type="pagebreak" id="page_5"/>Defining Arrays</h4>&#13;
<p class="noindent">NumPy operates on arrays and is quite good at turning lists into arrays. Think about the sort of arrays one finds in a language like C or Java. NumPy provides an advantage because although Python is elegant, it’s too slow for scientific uses when simulating arrays with lists. Actual arrays are much faster. Here’s an example defining an array from a list, and then examining some of its properties:</p>&#13;
<p class="programs">&gt;&gt;&gt;<span class="codestrong1"> a = np.array([1,2,3,4])</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> a</span><br/>&#13;
    array([1, 2, 3, 4])<br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> a.size</span><br/>&#13;
    4<br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> a.shape</span><br/>&#13;
    (4,)<br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> a.dtype</span><br/>&#13;
    dtype('int64')</p>&#13;
<p class="indent">This example defines a list of four elements and then passes it to <span class="literal">np.array</span> to turn it into a NumPy array. Basic array properties include the size and the shape. The size is four elements. The shape is also four, as a tuple, showing that <span class="literal">a</span> is a vector, a one-dimensional (1D) array. The shape is four because array <span class="literal">a</span> has four elements. If <span class="literal">a</span> was two-dimensional (2D), the shape would have two values, one for each axis of the array. See the following example, where the shape of <span class="literal">b</span> tells us that <span class="literal">b</span> has two rows and four columns:</p>&#13;
<p class="programs">&gt;&gt;&gt;<span class="codestrong1"> b = np.array([[1,2,3,4],[5,6,7,8]])</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> print(b)</span><br/>&#13;
[[1 2 3 4]<br/>&#13;
 [5 6 7 8]]<br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> b.shape</span><br/>&#13;
<span class="codestrong1">(2, 4)</span></p>&#13;
<h4 class="h4" id="ch01lev2_5">Data Types</h4>&#13;
<p class="noindent">Python numeric data types come in two flavors: integers of arbitrary size (try <span class="literal">2**1000</span>) or floating-point numbers. NumPy, however, allows for arrays of many different types. Under the hood, NumPy is implemented in C, so it supports the same set of data types C supports. The previous example shows that the <span class="literal">np.array</span> function took the given list and, since every element of the list was an integer, created an array where each element was a signed 64-bit integer. <a href="ch01.xhtml#ch01tab01">Table 1-1</a> has the data types NumPy works with; we can let NumPy choose the data type for us, or we can specify it explictly.</p>&#13;
<p class="tabcap" id="ch01tab01"><span epub:type="pagebreak" id="page_6"/><strong>Table 1-1:</strong> NumPy Data Type Names, C Equivalents, and Range</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr class="borderb">&#13;
<th style="vertical-align: top"><p class="tab"><strong>NumPy name</strong></p></th>&#13;
<th style="vertical-align: top"><p class="tab"><strong>Equivalent C type</strong></p></th>&#13;
<th style="vertical-align: top"><p class="tab"><strong>Range</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="bg-g">&#13;
<td style="vertical-align: top"><p class="tab">float64</p></td>&#13;
<td style="vertical-align: top"><p class="tab">double</p></td>&#13;
<td style="vertical-align: top"><p class="tab">±[2.225 × 10<sup>–308</sup>, 1.798 × 10<sup>308</sup>]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">float32</p></td>&#13;
<td style="vertical-align: top"><p class="tab">float</p></td>&#13;
<td style="vertical-align: top"><p class="tab">±[1.175 × 10<sup>–38</sup>, 3.403 × 10<sup>38</sup>]</p></td>&#13;
</tr>&#13;
<tr class="bg-g">&#13;
<td style="vertical-align: top"><p class="tab">int64</p></td>&#13;
<td style="vertical-align: top"><p class="tab">long long</p></td>&#13;
<td style="vertical-align: top"><p class="tab">[–2<sup>63</sup>, 2<sup>63</sup>–1]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">uint64</p></td>&#13;
<td style="vertical-align: top"><p class="tab">unsigned long long</p></td>&#13;
<td style="vertical-align: top"><p class="tab">[0, 2<sup>64</sup>–1]</p></td>&#13;
</tr>&#13;
<tr class="bg-g">&#13;
<td style="vertical-align: top"><p class="tab">int32</p></td>&#13;
<td style="vertical-align: top"><p class="tab">long</p></td>&#13;
<td style="vertical-align: top"><p class="tab">[–2<sup>31</sup>, 2<sup>31</sup>–1]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">uint32</p></td>&#13;
<td style="vertical-align: top"><p class="tab">unsigned long</p></td>&#13;
<td style="vertical-align: top"><p class="tab">[0, 2<sup>32</sup>–1]</p></td>&#13;
</tr>&#13;
<tr class="bg-g">&#13;
<td style="vertical-align: top"><p class="tab">uint8</p></td>&#13;
<td style="vertical-align: top"><p class="tab">unsigned char</p></td>&#13;
<td style="vertical-align: top"><p class="tab">[0, 255 = 2<sup>2</sup>–1]</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Let’s look at some examples of arrays with specific data types:</p>&#13;
<p class="programs">&gt;&gt;&gt;<span class="codestrong1"> a = np.array([1,2,3,4], dtype="uint8")</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> a.dtype</span><br/>&#13;
dtype('uint8')<br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> a = np.array([1,2,3,4], dtype="int16")</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> a = np.array([1,2,3,4], dtype="uint32")</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> b = np.array([1,2,3,4.0])</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> b.dtype</span><br/>&#13;
dtype('float64')<br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> b = np.array([1,2,3,4.0], dtype="float32")</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> c = np.array([111,222,333,444], dtype="uint8")</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> c</span><br/>&#13;
array([111, 222,  77, 188], dtype=uint8)</p>&#13;
<p class="indent">The examples with array <span class="literal">a</span> use integer types, and the examples with array <span class="literal">b</span> use floating-point types. Notice that the first <span class="literal">b</span> example defaulted to a 64-bit float. NumPy did this because one of the input list elements was a float (<span class="literal">4.0</span>).</p>&#13;
<p class="indent">The last example defining array <span class="literal">c</span> seems to be a bug. But it isn’t. NumPy doesn’t warn us if the requested data type can’t hold the given values. Here, we have an 8-bit integer that can only hold values in the range [0, 255]. The first two, 111 and 222, fit, but the last two, 333 and 444, are too large. NumPy quietly kept only the lowest 8 bits of these values, which correspond to 77 and 188, respectively. The lesson is that NumPy expects you to know what you’re doing in regard to data types. Usually, this isn’t an issue, but it is something to keep in mind.</p>&#13;
<h4 class="h4" id="ch01lev2_6">2D Arrays</h4>&#13;
<p class="noindent">If a list turns into a 1D vector, we might suspect that a list of lists would turn into a 2D array. We’d be right:</p>&#13;
<p class="programs">&gt;&gt;&gt;<span class="codestrong1"> d = np.array([[1,2,3],[4,5,6],[7,8,9]])</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> d.shape</span><br/>&#13;
    (3, 3)<br/>&#13;
<span epub:type="pagebreak" id="page_7"/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> d.size</span><br/>&#13;
    9<br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> d</span><br/>&#13;
    array([[1, 2, 3],<br/>&#13;
           [4, 5, 6],<br/>&#13;
           [7, 8, 9]])</p>&#13;
<p class="indent">We see that a list of three sublists is mapped to a 3 × 3 array (a matrix). Subscripts on NumPy arrays count from zero, so referencing <span class="literal">d[1,2]</span> above returns 6.</p>&#13;
<h4 class="h4" id="ch01lev2_7">Zeros and Ones</h4>&#13;
<p class="noindent">Two particularly useful NumPy functions are <span class="literal">np.zeros</span> and <span class="literal">np.ones</span>. Both define arrays given a shape. The first initializes the array elements to zero, while the second initializes them to one. This is the primary way to create NumPy arrays from scratch:</p>&#13;
<p class="programs">&gt;&gt;&gt;<span class="codestrong1"> a = np.zeros((3,4), dtype="uint32")</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> a[0,3] = 42</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> a[1,1] = 66</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> a</span><br/>&#13;
array([[ 0,  0,  0, 42],<br/>&#13;
       [ 0, 66,  0,  0],<br/>&#13;
       [ 0,  0,  0,  0]], dtype=uint32)<br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> b = 11*np.ones((3,1))</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> b</span><br/>&#13;
array([[11.],<br/>&#13;
       [11.],<br/>&#13;
       [11.]])</p>&#13;
<p class="indent">The first argument is a tuple giving the size of each dimension. If we pass in a scalar, the resulting array is a 1D vector. Let’s look at the definition of <span class="literal">b</span>. Here, we multiply the 3 × 1 array by a scalar (<span class="literal">11</span>). This causes each element of the array, which was initialized to 1.0, to be multiplied by 11.</p>&#13;
<h4 class="h4" id="ch01lev2_8">Advanced Indexing</h4>&#13;
<p class="noindent">We saw simple array indexing in the examples above, where we indexed with a single value. NumPy supports more sophisticated array indexing. One type we’ll use often is a single index that returns a complete subarray. Here’s an example:</p>&#13;
<p class="programs">&gt;&gt;&gt;<span class="codestrong1"> a = np.arange(12).reshape((3,4))</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> a</span><br/>&#13;
array([[ 0,  1,  2,  3],<br/>&#13;
       [ 4,  5,  6,  7],<br/>&#13;
       [ 8,  9, 10, 11]])<br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> a[1]</span><br/>&#13;
<span epub:type="pagebreak" id="page_8"/>&#13;
array([4, 5, 6, 7])<br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> a[1] = [44,55,66,77]</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> a</span><br/>&#13;
array([[ 0,  1,  2,  3],<br/>&#13;
       [44, 55, 66, 77],<br/>&#13;
       [ 8,  9, 10, 11]])</p>&#13;
<p class="indent">This example introduces <span class="literal">np.arange</span>, which is the NumPy equivalent of Python’s <span class="literal">range</span> function. Notice the use of the <span class="literal">reshape</span> method to change the 12-element vector into a 3 × 4 matrix. Also, notice that <span class="literal">a[1]</span> returns the entire subarray, starting with the first index of the first dimension. This syntax is short for <span class="literal">a[1,:]</span> where <span class="literal">:</span> means all elements of the given dimension. This shorthand also works for assignments, as the next line shows.</p>&#13;
<p class="indent">The same syntax for indexing slices from a Python list works with NumPy. Here’s what that looks like if we continue with the example above:</p>&#13;
<p class="programs">&gt;&gt;&gt;<span class="codestrong1"> a[:2]</span><br/>&#13;
array([[ 0,  1,  2,  3],<br/>&#13;
       [44, 55, 66, 77]])<br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> a[:2,:]</span><br/>&#13;
array([[ 0,  1,  2,  3],<br/>&#13;
       [44, 55, 66, 77]])<br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> a[:2,:3]</span><br/>&#13;
array([[ 0,  1,  2],<br/>&#13;
       [44, 55, 66]])<br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> b = np.arange(12)</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> b</span><br/>&#13;
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])<br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> b[::2]</span><br/>&#13;
array([ 0,  2,  4,  6,  8, 10])<br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> b[::3]</span><br/>&#13;
<span class="codestrong1">array([0, 3, 6, 9])</span><br/>&#13;
&gt;&gt;&gt; b[::-1]<br/>&#13;
array([11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1,  0])</p>&#13;
<p class="indent">We see that <span class="literal">a[:2]</span> returns the first two rows with an implied <span class="literal">:</span> for the second dimension, as the following line shows. With our third command, we get a subarray in two dimensions by taking the first two rows and first three columns with <span class="literal">a[:2,:3]</span>. The examples with <span class="literal">b</span> show how to extract every other or every third element. The last example is particularly handy: it uses a negative increment to reverse the dimension. The increment is –1 to reverse all values. If it was –2, we’d get every other element of <span class="literal">b</span> in reverse order.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_9"/>NumPy uses <span class="literal">:</span> to indicate all the elements along a specific dimension. It also allows <span class="literal">...</span> (ellipsis) as a shorthand for “as many <span class="literal">:</span>s as needed.” For example, let’s define a three-dimensional (3D) array:</p>&#13;
<p class="programs">&gt;&gt;&gt;<span class="codestrong1"> a = np.arange(24).reshape((4,3,2))</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> a</span><br/>&#13;
array([[[ 0,  1],<br/>&#13;
        [ 2,  3],<br/>&#13;
        [ 4,  5]],<br/>&#13;
       [[ 6,  7],<br/>&#13;
        [ 8,  9],<br/>&#13;
        [10, 11]],<br/>&#13;
       [[12, 13],<br/>&#13;
        [14, 15],<br/>&#13;
        [16, 17]],<br/>&#13;
       [[18, 19],<br/>&#13;
        [20, 21],<br/>&#13;
        [22, 23]]])</p>&#13;
<p class="indent">You can think of array <span class="literal">a</span> as a collection of four 3 × 2 matrices. To update the second of these matrices, you could use the following:</p>&#13;
<p class="programs">&gt;&gt;&gt;<span class="codestrong1"> a[1,:,:] = [[11,22],[33,44],[55,66]]</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> a</span><br/>&#13;
array([[[ 0,  1],<br/>&#13;
        [ 2,  3],<br/>&#13;
        [ 4,  5]],<br/>&#13;
       [[11, 22],<br/>&#13;
        [33, 44],<br/>&#13;
        [55, 66]],<br/>&#13;
       [[12, 13],<br/>&#13;
        [14, 15],<br/>&#13;
        [16, 17]],<br/>&#13;
       [[18, 19],<br/>&#13;
        [20, 21],<br/>&#13;
        [22, 23]]])</p>&#13;
<p class="indent">Here, we specified the dimensions explicitly with <span class="literal">:</span> and showed that NumPy isn’t picky: it knows that a list of lists matched the expected shape of the subarray and updated array <span class="literal">a</span> accordingly. We get the same effect by using the ellipsis as seen next.</p>&#13;
<p class="programs"><span epub:type="pagebreak" id="page_10"/>&gt;&gt;&gt;<span class="codestrong1"> a[2,...] = [[99,99],[99,99],[99,99]]</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> a</span><br/>&#13;
array([[[ 0,  1],<br/>&#13;
        [ 2,  3],<br/>&#13;
        [ 4,  5]],<br/>&#13;
       [[11, 22],<br/>&#13;
        [33, 44],<br/>&#13;
        [55, 66]],<br/>&#13;
       [[99, 99],<br/>&#13;
        [99, 99],<br/>&#13;
        [99, 99]],<br/>&#13;
       [[18, 19],<br/>&#13;
        [20, 21],<br/>&#13;
        [22, 23]]])</p>&#13;
<p class="indent">We’ve now updated the third 3 × 2 subarray.</p>&#13;
<h4 class="h4" id="ch01lev2_9">Reading and Writing to Disk</h4>&#13;
<p class="noindent">NumPy arrays can be written to and loaded from disk by using <span class="literal">np.save</span> and <span class="literal">np.load</span>, like so:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">a = np.random.randint(0,5,(3,4))</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">a</span><br/>&#13;
array([[4, 2, 1, 3],<br/>&#13;
       [4, 0, 2, 4],<br/>&#13;
       [0, 4, 3, 1]])<br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">np.save("random.npy",a)</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">b = np.load("random.npy")</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">b</span><br/>&#13;
array([[4, 2, 1, 3],<br/>&#13;
       [4, 0, 2, 4],<br/>&#13;
       [0, 4, 3, 1]])</p>&#13;
<p class="indent">Here, we’re using <span class="literal">np.random.randint</span> to create a random 3 × 4 integer array with values in the range 0 through 5. NumPy has extensive libraries for random numbers. We write array <span class="literal">a</span> to disk as <span class="literal">random.npy</span>. The <span class="literal">.npy</span> extension is necessary and will be added if we don’t supply it. We then load the array back from disk using <span class="literal">np.load</span>.</p>&#13;
<p class="indent">We’ll encounter other NumPy functions throughout the book. I’ll explain them when they’re first introduced. Let’s move on now to a quick look at the SciPy library.</p>&#13;
<h3 class="h3" id="ch01lev1_3"><span epub:type="pagebreak" id="page_11"/>SciPy</h3>&#13;
<p class="noindent">SciPy adds a plethora of functionality to Python. It uses NumPy under the hood, so the two are often installed together. A full tutorial is available here: <em><a href="https://docs.scipy.org/doc/scipy/reference/tutorial/index.html">https://docs.scipy.org/doc/scipy/reference/tutorial/index.html</a></em>.</p>&#13;
<p class="indent">In this book, we’ll focus on the functions in the <span class="literal">scipy.stats</span> module. Start Python and try the following:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">import scipy</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">scipy.__version__</span><br/>&#13;
'1.2.1'</p>&#13;
<p class="indent">This loads the SciPy module and verifies that the version number is at least what it should be. Any later version of SciPy should work just fine.</p>&#13;
<p class="indent">As a quick test, let’s try the following:</p>&#13;
<p class="programs">&gt;&gt;&gt;<span class="codestrong1"> from scipy.stats import ttest_ind</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> a = np.random.normal(0,1,1000)</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> b = np.random.normal(0,0.5,1000)</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> c = np.random.normal(0.1,1,1000)</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> ttest_ind(a,b)</span><br/>&#13;
Ttest_indResult(statistic=-0.027161815649563964, pvalue=0.9783333836992686)<br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> ttest_ind(a,c)</span><br/>&#13;
Ttest_indResult(statistic=-2.295584443456226, pvalue=0.021802794508002675)</p>&#13;
<p class="indent">First, we load NumPy and then the <span class="literal">ttest_ind</span> function from SciPy’s <span class="literal">stats</span> module. This function takes two sets of data, say test scores from two classes, and asks the question: do these sets of data have the same average value? Or, more accurately, it asks: how strongly can we believe that the same process generated these two sets of data? The <em>t-test</em> is a classic method for answering this question. One way to evaluate its result is to look at the <em>p-value</em>. You can think of a <em>p</em>-value as the probability that the two sets would have the measured difference in average value if they came from the same generating process. A probability near 1 means we have a lot of confidence that the two sets are from the same process.</p>&#13;
<p class="indent">The variables <span class="literal">a</span>, <span class="literal">b</span>, and <span class="literal">c</span> are 1D arrays where the values from the array (here 1,000) are extracted from Gaussian curves, also called <em>normal curves</em>. We’ll get to these later, but for now, know that the numbers are pulled from a bell curve where values near the middle are more likely to be selected than those near the edges. The first two arguments to <span class="literal">normal</span> are the average value and the standard deviation, a measure of how spread out the bell curve is: the larger the standard deviation, the flatter, and wider, the curve.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_12"/>For this example, we’d expect <span class="literal">a</span> and <span class="literal">b</span> to be very similar, as they both have an average value of 0.0, though slightly different bell curve shapes. However, <span class="literal">c</span> has an average value of 0.1. We hope the t-test picks up on this and tells us that we might want to be careful in believing <span class="literal">a</span> and <span class="literal">c</span> were generated by the same process.</p>&#13;
<p class="indent">The output of the <span class="literal">ttest_ind</span> function lists the <em>p</em>-value (<span class="literal">pvalue</span>). And, as we expected, comparing <span class="literal">a</span> and <span class="literal">b</span> returns a <em>p</em>-value of 0.98, meaning that the probability we’d see the difference between the averages of these two sets of data, given they came from the same generating process, is about 98 percent. However, when we compare <span class="literal">a</span> and <span class="literal">c</span>, we get a <em>p</em>-value of 2.7 percent (0.027). This means there is about a 3 percent chance we’d see the difference between <span class="literal">a</span> and <span class="literal">c</span> if they were generated by the same process. Therefore, we conclude that <span class="literal">a</span> and <span class="literal">c</span> are from different processes. We state, then, that the difference between these two datasets is <em>statistically significant</em>.</p>&#13;
<p class="indent">Historically, <em>p</em>-values less than 0.05 have been considered statistically significant. However, this threshold is arbitrary, and recent experience in replicating experiments, especially in the soft sciences, has led to a call for a stricter threshold. Using a <em>p</em>-value of 0.05 means you’ll be wrong about 1 time in 20 (1/20 = 0.05), which is too generous a threshold. That said, a <em>p</em>-value close to 0.05 suggests that <em>something</em> is going on, and more investigation (and a larger dataset) is warranted.</p>&#13;
<h3 class="h3" id="ch01lev1_4">Matplotlib</h3>&#13;
<p class="noindent">We’ll use Matplotlib to generate graphs. Let’s verify its 2D and 3D plotting abilities here. First, a simple 2D example:</p>&#13;
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">import numpy as np</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">import matplotlib.pylab as plt</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">x = np.random.random(100)</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">plt.plot(x)</span><br/>&#13;
&gt;&gt;&gt; <span class="codestrong1">plt.show()</span></p>&#13;
<p class="indent">This example loads NumPy, with which Matplotlib works best, and generates a vector, <span class="literal">x</span>, of 100 random values, [0, 1), the output of <span class="literal">np.random.random</span>. We then use <span class="literal">plt.plot</span> to plot the vector and <span class="literal">plt.show</span> to display it. Matplotlib output is interactive. Play around with the plot to get familiar with how to use the plot window. For example, <a href="ch01.xhtml#ch01fig01">Figure 1-1</a> shows what the plot window looks like on Linux. Since the plot is random, you’ll see a different sequence of values, but the controls on the window will be the same.</p>&#13;
<span epub:type="pagebreak" id="page_13"/>&#13;
<div class="image" id="ch01fig01"><img src="Images/01fig01.jpg" alt="image" width="678" height="729"/></div>&#13;
<p class="figcap"><em>Figure 1-1: A sample Matplotlib plotting window</em></p>&#13;
<p class="indent">For 3D, give this a try:</p>&#13;
<p class="programs">&gt;&gt;&gt;<span class="codestrong1"> from mpl_toolkits.mplot3d import Axes3D</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> import matplotlib.pylab as plt</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> import numpy as np</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> x = np.random.random(20)</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> y = np.random.random(20)</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> z = np.random.random(20)</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> fig = plt.figure()</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> ax = fig.add_subplot(111, projection='3d')</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> ax.scatter(x,y,z)</span><br/>&#13;
&gt;&gt;&gt;<span class="codestrong1"> plt.show()</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_14"/>We first load the 3D axes toolkit, Matplotlib, and NumPy. Then, using NumPy, we generate three random vectors, [0, 1). These are our 3D points. Using <span class="literal">plt.figure</span> and <span class="literal">fig.add_subplot</span>, we set up a 3D projection. The <span class="literal">111</span> is shorthand telling Matplotlib that we want a grid of 1 × 1 and that the current plot should go in index 1 of that grid. So, <span class="literal">111</span> means a single plot. The <span class="literal">projection</span> keyword gets the plot ready for 3D. Finally, the scatter plot is made, <span class="literal">ax.scatter</span>, and shown, <span class="literal">plt.show</span>. As with the 2D plot, the 3D plot is interactive. Grab and hold with the mouse to rotate the plot.</p>&#13;
<h3 class="h3" id="ch01lev1_5">Scikit-Learn</h3>&#13;
<p class="noindent">The goal of this book is to cover the math of deep learning, not the implementation of deep learning. However, from time to time, it’ll be helpful to look at a simple neural network model or two. In those cases, we’ll make use of <span class="literal">sklearn</span>, in particular, the <span class="literal">MLPClassifier</span> class. Also, <span class="literal">sklearn</span> contains some useful tools for evaluating the performance of a model and for visualization of high-dimensional data.</p>&#13;
<p class="indent">As a quick example, let’s build a simple neural network to classify small 8×8-pixel grayscale images of handwritten digits. This dataset is built into <span class="literal">sklearn</span>. Here’s the code for the example:</p>&#13;
<p class="programs">   import numpy as np<br/>&#13;
   from sklearn.datasets import load_digits<br/>&#13;
   from sklearn.neural_network import MLPClassifier<br/>&#13;
<br/>&#13;
<span class="ent">❶</span> d = load_digits()<br/>&#13;
   digits = d["data"]<br/>&#13;
   labels = d["target"]<br/>&#13;
<br/>&#13;
   N = 200<br/>&#13;
<span class="ent">❷</span> idx = np.argsort(np.random.random(len(labels)))<br/>&#13;
   x_test, y_test = digits[idx[:N]], labels[idx[:N]]<br/>&#13;
   x_train, y_train = digits[idx[N:]], labels[idx[N:]]<br/>&#13;
<br/>&#13;
<span class="ent">❸</span> clf = MLPClassifier(hidden_layer_sizes=(128,))<br/>&#13;
   clf.fit(x_train, y_train)<br/>&#13;
<br/>&#13;
   score = clf.score(x_test, y_test)<br/>&#13;
   pred = clf.predict(x_test)<br/>&#13;
   err = np.where(y_test != pred)[0]<br/>&#13;
   print("score      : ", score)<br/>&#13;
   print("errors:")<br/>&#13;
   print("  actual   : ", y_test[err])<br/>&#13;
   print("  predicted: ", pred[err])</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_15"/>We first import NumPy. From <span class="literal">sklearn</span> itself, we import the <span class="literal">load_digits</span> function to return the small digit image dataset and the <span class="literal">MLPClassifier</span> class to train a traditional neural network, that is, a multilayer perceptron. We then get the digit data and pull out the images and their associated labels, 0 . . . 9 <span class="ent">❶</span>. The digit images are stored as 8 × 8 = 64-element vectors representing the image unraveled so the rows are laid end to end. The digits data-set includes 1,797 images, so <span class="literal">digits</span> is a 2D NumPy array with 1,797 rows, with 64 columns per row, and <span class="literal">labels</span> is a vector of 1,797 digit labels.</p>&#13;
<p class="indent">We randomize the order of the images, being careful to keep the right label with the right digit <span class="ent">❷</span> and extract train and test data (<span class="literal">x_train</span>, <span class="literal">x_test</span>) and labels (<span class="literal">y_train</span>, <span class="literal">y_test</span>). We’ll set the first 200 digit images aside to use as test data and train the model with the remaining 1,597 images. This leaves us with approximately 160 images of each digit to train with and about 20 of each digit for testing.</p>&#13;
<p class="indent">Next, we build the model by creating an instance of <span class="literal">MLPClassifier</span> <span class="ent">❸</span>. We’ll take all the defaults and specify only the size of the single hidden layer, which has 128 nodes. The input vectors are 64 elements, so we double that for the hidden layer. There’s no need to specify the output layer size explicitly; <span class="literal">sklearn</span> deduces it from the labels in <span class="literal">y_train</span>. Training the model is a simple call to <span class="literal">clf.fit</span> passing the training image vectors (<span class="literal">x_train</span>) and labels (<span class="literal">y_train</span>).</p>&#13;
<p class="indent">Training for a small dataset like this will take only a few seconds. When it’s done, the learned weights and biases are in the model (<span class="literal">clf</span>). We first get the score, the overall accuracy (<span class="literal">score</span>), and then the actual model class label predictions on the test set (<span class="literal">pred</span>). Any errors are captured in <span class="literal">err</span> by looking for places where the actual label (<span class="literal">y_test</span>) does not match the prediction. We end by showing the actual class label and predicted label for the errors.</p>&#13;
<p class="indent">Each time we run this code, we’ll get a different ordering of the digit data, which leads to a different train and test set. Additionally, neural networks are randomly initialized prior to training. So, we’ll get a different result each time. The first time I ran this code, I had an overall score of 0.97 (97 percent) accuracy. Guessing would give an accuracy of about 10 percent, so we can say that the model has learned rather well.</p>&#13;
<h3 class="h3" id="ch01lev1_6">Summary</h3>&#13;
<p class="noindent">In this chapter, we learned how to configure our working environment. I then introduced our suite of Python toolkits at a high level and supplied pointers on where to learn more. With the work environment secure and flourishing, the next chapter dives headfirst into probability theory.<span epub:type="pagebreak" id="page_16"/></p>&#13;
</div></body></html>