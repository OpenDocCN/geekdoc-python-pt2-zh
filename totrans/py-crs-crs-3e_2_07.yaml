- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Generating Data
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 生成数据
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: '*Data visualization* is the use of visual representations to explore and present
    patterns in datasets. It’s closely associated with *data analysis*, which uses
    code to explore the patterns and connections in a dataset. A dataset can be a
    small list of numbers that fits in a single line of code, or it can be terabytes
    of data that include many different kinds of information.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据可视化* 是利用视觉表示来探索和展示数据集中的模式。它与 *数据分析* 密切相关，数据分析使用代码来探索数据集中的模式和联系。一个数据集可以是一个简单的数字列表，可以用一行代码表示，或者它也可以是包含多种信息的数太字节数据。'
- en: Creating effective data visualizations is about more than just making information
    look nice. When a representation of a dataset is simple and visually appealing,
    its meaning becomes clear to viewers. People will see patterns and significance
    in your datasets that they never knew existed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 创建有效的数据可视化不仅仅是让信息看起来好看。当数据集的表示形式简单且具有视觉吸引力时，它的含义会变得对观众更为清晰。人们会在你的数据集中看到以前从未意识到的模式和意义。
- en: Fortunately, you don’t need a supercomputer to visualize complex data. Python
    is so efficient that with just a laptop, you can quickly explore datasets containing
    millions of individual data points. These data points don’t have to be numbers;
    with the basics you learned in the first part of this book, you can analyze non-numerical
    data as well.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你不需要超级计算机就能可视化复杂的数据。Python 非常高效，使用一台笔记本电脑，你就可以快速探索包含数百万个数据点的数据集。这些数据点不一定是数字；利用你在本书第一部分学到的基础知识，你也可以分析非数字数据。
- en: People use Python for data-intensive work in genetics, climate research, political
    and economic analysis, and much more. Data scientists have written an impressive
    array of visualization and analysis tools in Python, many of which are available
    to you as well. One of the most popular tools is Matplotlib, a mathematical plotting
    library. In this chapter, we’ll use Matplotlib to make simple plots, such as line
    graphs and scatter plots. Then we’ll create a more interesting dataset based on
    the concept of a random walk—a visualization generated from a series of random
    decisions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 人们使用 Python 进行基因学、气候研究、政治与经济分析等数据密集型工作。数据科学家们为 Python 编写了令人印象深刻的可视化和分析工具，其中许多工具也可以供你使用。最流行的工具之一是
    Matplotlib，一个数学绘图库。在本章中，我们将使用 Matplotlib 制作简单的图表，如折线图和散点图。接下来，我们将基于随机游走的概念创建一个更有趣的数据集——这是通过一系列随机决策生成的可视化。
- en: We’ll also use a package called Plotly, which creates visualizations that work
    well on digital devices, to analyze the results of rolling dice. Plotly generates
    visualizations that automatically resize to fit a variety of display devices.
    These visualizations can also include a number of interactive features, such as
    emphasizing particular aspects of the dataset when users hover over different
    parts of the visualization. Learning to use Matplotlib and Plotly will help you
    get started visualizing the kinds of data you’re most interested in.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用一个名为 Plotly 的包，它可以创建在数字设备上效果良好的可视化，来分析掷骰子的结果。Plotly 生成的可视化会自动调整大小，以适应各种显示设备。这些可视化还可以包括一些交互功能，例如当用户将鼠标悬停在可视化的不同部分时，突出显示数据集的某些方面。学习使用
    Matplotlib 和 Plotly 将帮助你开始可视化你最感兴趣的数据类型。
- en: Installing Matplotlib
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Matplotlib
- en: To use Matplotlib for your initial set of visualizations, you’ll need to install
    it using pip, just like we did with pytest in Chapter 11 (see “Installing pytest
    with pip” on page 210).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Matplotlib 进行初步的可视化，你需要像在第 11 章中安装 pytest（见“使用 pip 安装 pytest”，第 210 页）一样，使用
    pip 安装它。
- en: 'To install Matplotlib, enter the following command at a terminal prompt:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Matplotlib，在终端提示符下输入以下命令：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you use a command other than `python` to run programs or start a terminal
    session, such as `python3`, your command will look like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的命令不是 `python` 来运行程序或启动终端会话，比如 `python3`，那么你的命令应该像这样：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To see the kinds of visualizations you can make with Matplotlib, visit the Matplotlib
    home page at [https://matplotlib.org](https://matplotlib.org) and click **Plot
    types**. When you click a visualization in the gallery, you’ll see the code used
    to generate the plot.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你可以使用 Matplotlib 制作的可视化类型，访问 Matplotlib 官网 [https://matplotlib.org](https://matplotlib.org)，然后点击
    **Plot types**。当你点击画廊中的某个可视化时，你将看到生成该图表所使用的代码。
- en: Plotting a Simple Line Graph
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制简单的折线图
- en: Let’s plot a simple line graph using Matplotlib and then customize it to create
    a more informative data visualization. We’ll use the square number sequence 1,
    4, 9, 16, and 25 as the data for the graph.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a simple line graph, specify the numbers you want to work with and
    let Matplotlib do the rest:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '**mpl_squares.py**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We first import the `pyplot` module using the alias `plt` so we don’t have to
    type `pyplot` repeatedly. (You’ll see this convention often in online examples,
    so we’ll use it here.) The `pyplot` module contains a number of functions that
    help generate charts and plots.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: We create a list called `squares` to hold the data that we’ll plot. Then we
    follow another common Matplotlib convention by calling the `subplots()` function
    ❶. This function can generate one or more plots in the same figure. The variable
    `fig` represents the entire *figure*, which is the collection of plots that are
    generated. The variable `ax` represents a single plot in the figure; this is the
    variable we’ll use most of the time when defining and customizing a single plot.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `plot()` method, which tries to plot the data it’s given in
    a meaningful way. The function `plt.show()` opens Matplotlib’s viewer and displays
    the plot, as shown in [Figure 15-1](#figure15-1). The viewer allows you to zoom
    and navigate the plot, and you can save any plot images you like by clicking the
    disk icon.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c15/f15001.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-1: One of the simplest plots you can make in Matplotlib'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Changing the Label Type and Line Thickness
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although the plot in [Figure 15-1](#figure15-1) shows that the numbers are increasing,
    the label type is too small and the line is a little thin to read easily. Fortunately,
    Matplotlib allows you to adjust every feature of a visualization.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use a few of the available customizations to improve this plot’s readability.
    Let’s start by adding a title and labeling the axes:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '**mpl_squares.py**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `linewidth` parameter controls the thickness of the line that `plot()` generates
    ❶. Once a plot has been generated, there are many methods available to modify
    the plot before it’s presented. The `set_title()` method sets an overall title
    for the chart ❷. The `fontsize` parameters, which appear repeatedly throughout
    the code, control the size of the text in various elements on the chart.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The `set_xlabel()` and `set_ylabel()` methods allow you to set a title for each
    of the axes ❸, and the method `tick_params()` styles the tick marks ❹. Here `tick_params()`
    sets the font size of the tick mark labels to 14 on both axes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 15-2](#figure15-2), the resulting chart is much easier
    to read. The label type is bigger, and the line graph is thicker. It’s often worth
    experimenting with these values to see what works best in the resulting graph.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c15/f15002.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-2: The chart is much easier to read now.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Correcting the Plot
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we can read the chart better, we can see that the data is not plotted
    correctly. Notice at the end of the graph that the square of 4.0 is shown as 25!
    Let’s fix that.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'When you give `plot()` a single sequence of numbers, it assumes the first data
    point corresponds to an *x*-value of 0, but our first point corresponds to an
    *x*-value of 1\. We can override the default behavior by giving `plot()` both
    the input and output values used to calculate the squares:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '**mpl_squares.py**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now `plot()` doesn’t have to make any assumptions about how the output numbers
    were generated. The resulting plot, shown in [Figure 15-3](#figure15-3), is correct.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c15/f15003.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-3: The data is now plotted correctly.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: You can specify a number of arguments when calling `plot()` and use a number
    of methods to customize your plots after generating them. We’ll continue to explore
    these approaches to customization as we work with more interesting datasets throughout
    this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Using Built-in Styles
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Matplotlib has a number of predefined styles available. These styles contain
    a variety of default settings for background colors, gridlines, line widths, fonts,
    font sizes, and more. They can make your visualizations appealing without requiring
    much customization. To see the full list of available styles, run the following
    lines in a terminal session:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To use any of these styles, add one line of code before calling `subplots()`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '**mpl_squares.py**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code generates the plot shown in [Figure 15-4](#figure15-4). A wide variety
    of styles is available; play around with these styles to find some that you like.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c15/f15004.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-4: The built-in seaborn style'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Plotting and Styling Individual Points with scatter()
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, it’s useful to plot and style individual points based on certain
    characteristics. For example, you might plot small values in one color and larger
    values in a different color. You could also plot a large dataset with one set
    of styling options and then emphasize individual points by replotting them with
    different options.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'To plot a single point, pass the single *x*- and *y*-values of the point to
    `scatter()`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '**scatter_squares.py**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s style the output to make it more interesting. We’ll add a title, label
    the axes, and make sure all the text is large enough to read:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We call `scatter()` and use the `s` argument to set the size of the dots used
    to draw the graph ❶. When you run *scatter_squares.py* now, you should see a single
    point in the middle of the chart, as shown in [Figure 15-5](#figure15-5).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c15/f15005.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-5: Plotting a single point'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Plotting a Series of Points with scatter()
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To plot a series of points, we can pass `scatter()` separate lists of *x*-
    and *y*-values, like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '**scatter_squares.py**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `x_values` list contains the numbers to be squared, and `y_values` contains
    the square of each number. When these lists are passed to `scatter()`, Matplotlib
    reads one value from each list as it plots each point. The points to be plotted
    are (1, 1), (2, 4), (3, 9), (4, 16), and (5, 25); [Figure 15-6](#figure15-6) shows
    the result.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c15/f15006.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-6: A scatter plot with multiple points'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Calculating Data Automatically
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Writing lists by hand can be inefficient, especially when we have many points.
    Rather than writing out each value, let’s use a loop to do the calculations for
    us.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how this would look with 1,000 points:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '**scatter_squares.py**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We start with a range of *x*-values containing the numbers 1 through 1,000 ❶.
    Next, a list comprehension generates the *y*-values by looping through the *x*-values
    (`for x in x_values`), squaring each number (`x**2`), and assigning the results
    to `y_values`. We then pass the input and output lists to `scatter()` ❷. Because
    this is a large dataset, we use a smaller point size.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Before showing the plot, we use the `axis()` method to specify the range of
    each axis ❸. The `axis()` method requires four values: the minimum and maximum
    values for the *x*-axis and the *y*-axis. Here, we run the *x*-axis from 0 to
    1,100 and the *y*-axis from 0 to 1,100,000\. [Figure 15-7](#figure15-7) shows
    the result.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c15/f15007.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-7: Python can plot 1,000 points as easily as it plots 5 points.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Customizing Tick Labels
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the numbers on an axis get large enough, Matplotlib defaults to scientific
    notation for tick labels. This is usually a good thing, because larger numbers
    in plain notation take up a lot of unnecessary space on a visualization.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Almost every element of a chart is customizable, so you can tell Matplotlib
    to keep using plain notation if you prefer:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `ticklabel_format()` method allows you to override the default tick label
    style for any plot.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Defining Custom Colors
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To change the color of the points, pass the argument `color` to `scatter()`
    with the name of a color to use in quotation marks, as shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can also define custom colors using the RGB color model. To define a color,
    pass the `color` argument a tuple with three float values (one each for red, green,
    and blue, in that order), using values between 0 and 1\. For example, the following
    line creates a plot with light-green dots:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Values closer to 0 produce darker colors, and values closer to 1 produce lighter
    colors.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Using a Colormap
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *colormap* is a sequence of colors in a gradient that moves from a starting
    to an ending color. In visualizations, colormaps are used to emphasize patterns
    in data. For example, you might make low values a light color and high values
    a darker color. Using a colormap ensures that all points in the visualization
    vary smoothly and accurately along a well-designed color scale.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pyplot` module includes a set of built-in colormaps. To use one of these
    colormaps, you need to specify how `pyplot` should assign a color to each point
    in the dataset. Here’s how to assign a color to each point, based on its *y*-value:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '**scatter_squares.py**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `c` argument is similar to `color`, but it’s used to associate a sequence
    of values with a color mapping. We pass the list of *y*-values to `c`, and then
    tell `pyplot` which colormap to use with the `cmap` argument. This code colors
    the points with lower *y*-values light blue and the points with higher *y*-values
    dark blue. [Figure 15-8](#figure15-8) shows the resulting plot.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c15/f15008.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-8: A plot using the `Blues` colormap'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Saving Your Plots Automatically
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to save the plot to a file instead of showing it in the Matplotlib
    viewer, you can use `plt.savefig()` instead of `plt.show()`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first argument is a filename for the plot image, which will be saved in
    the same directory as *scatter_squares.py*. The second argument trims extra whitespace
    from the plot. If you want the extra whitespace around the plot, you can omit
    this argument. You can also call `savefig()` with a `Path` object, and write the
    output file anywhere you want on your system.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Random Walks
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll use Python to generate data for a random walk and then
    use Matplotlib to create a visually appealing representation of that data. A *random
    walk* is a path that’s determined by a series of simple decisions, each of which
    is left entirely to chance. You might imagine a random walk as the path a confused
    ant would take if it took every step in a random direction.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Random walks have practical applications in nature, physics, biology, chemistry,
    and economics. For example, a pollen grain floating on a drop of water moves across
    the surface of the water because it’s constantly pushed around by water molecules.
    Molecular motion in a water drop is random, so the path a pollen grain traces
    on the surface is a random walk. The code we’ll write next models many real-world
    situations.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Creating the RandomWalk Class
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a random walk, we’ll create a `RandomWalk` class, which will make
    random decisions about which direction the walk should take. The class needs three
    attributes: one variable to track the number of points in the walk, and two lists
    to store the *x*- and *y*-coordinates of each point in the walk.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll only need two methods for the `RandomWalk` class: the `__init__()` method
    and `fill_walk()`, which will calculate the points in the walk. Let’s start with
    the `__init__()` method:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '**random_walk.py**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To make random decisions, we’ll store possible moves in a list and use the `choice()`
    function (from the `random` module) to decide which move to make each time a step
    is taken ❶. We set the default number of points in a walk to `5000`, which is
    large enough to generate some interesting patterns but small enough to generate
    walks quickly ❷. Then we make two lists to hold the *x*- and *y*-values, and we
    start each walk at the point (0, 0) ❸.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做出随机决策，我们将在一个列表中存储可能的移动，并使用`choice()`函数（来自`random`模块）来决定每次走一步时的移动方向❶。我们将默认的步数设置为`5000`，这个值足够大，可以生成一些有趣的图案，同时又足够小，可以快速生成游走❷。然后我们创建两个列表来保存*
    x *和* y *的值，并将每次游走的起点设为(0, 0)❸。
- en: Choosing Directions
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择方向
- en: 'We’ll use the `fill_walk()` method to determine the full sequence of points
    in the walk. Add this method to *random_walk.py*:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`fill_walk()`方法来确定游走中的完整点序列。将此方法添加到*random_walk.py*中：
- en: '**random_walk.py**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**random_walk.py**'
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We first set up a loop that runs until the walk is filled with the correct
    number of points ❶. The main part of `fill_walk()` tells Python how to simulate
    four random decisions: Will the walk go right or left? How far will it go in that
    direction? Will it go up or down? How far will it go in that direction?'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置一个循环，直到游走填充了正确数量的点❶。`fill_walk()`的主要部分告诉Python如何模拟四个随机决策：游走是向右还是向左？在该方向上将移动多远？游走是向上还是向下？在该方向上将移动多远？
- en: We use `choice([1, -1])` to choose a value for `x_direction`, which returns
    either 1 for movement to the right or −1 for movement to the left ❷. Next, `choice([0,
    1, 2, 3, 4])` randomly selects a distance to move in that direction. We assign
    this value to `x_distance`. The inclusion of a 0 allows for the possibility of
    steps that have movement along only one axis.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`choice([1, -1])`来为`x_direction`选择一个值，返回值为1表示向右移动，返回值为−1表示向左移动❷。接着，`choice([0,
    1, 2, 3, 4])`会随机选择一个距离来决定在该方向上移动的步数。我们将该值赋给`x_distance`。包括0的选择允许步伐仅在一个轴上移动。
- en: We determine the length of each step in the *x-* and *y-*directions by multiplying
    the direction of movement by the distance chosen ❸ ❹. A positive result for `x_step`
    means move to the right, a negative result means move to the left, and 0 means
    move vertically. A positive result for `y_step` means move up, negative means
    move down, and 0 means move horizontally. If the values of both `x_step` and `y_step`
    are 0, the walk doesn’t go anywhere; when this happens, we continue the loop ❺.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将运动方向与选定的距离相乘来确定每一步在* x *和* y *方向上的步长❸❹。`x_step`为正值表示向右移动，负值表示向左移动，0表示垂直移动。`y_step`为正值表示向上移动，负值表示向下移动，0表示水平移动。如果`x_step`和`y_step`的值都为0，则表示游走没有前进；在这种情况下，我们会继续循环❺。
- en: To get the next *x*-value for the walk, we add the value in `x_step` to the
    last value stored in `x_values` ❻ and do the same for the *y*-values. When we
    have the new point’s coordinates, we append them to `x_values` and `y_values`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得下一个游走的* x *值，我们将`x_step`中的值加到`x_values`中最后存储的值❻，* y *值同理。获得新的点的坐标后，我们将它们附加到`x_values`和`y_values`中。
- en: Plotting the Random Walk
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制随机游走
- en: 'Here’s the code to plot all the points in the walk:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是绘制游走中所有点的代码：
- en: '**rw_visual.py**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**rw_visual.py**'
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We begin by importing `pyplot` and `RandomWalk`. We then create a random walk
    and assign it to `rw` ❶, making sure to call `fill_walk()`. To visualize the walk,
    we feed the walk’s *x*- and *y*-values to `scatter()` and choose an appropriate
    dot size ❷. By default, Matplotlib scales each axis independently. But that approach
    would stretch most walks out horizontally or vertically. Here we use the `set_aspect()`
    method to specify that both axes should have equal spacing between tick marks
    ❸.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`pyplot`和`RandomWalk`。然后我们创建一个随机游走并将其赋值给`rw`❶，确保调用`fill_walk()`。为了可视化游走，我们将游走的*
    x *和* y *值传递给`scatter()`并选择合适的点大小❷。默认情况下，Matplotlib会独立缩放每个坐标轴。但这种方式会使大多数游走在水平方向或垂直方向上拉伸。这里我们使用`set_aspect()`方法来指定两个坐标轴之间的刻度间距应保持相等❸。
- en: '[Figure 15-9](#figure15-9) shows the resulting plot with 5,000 points. The
    images in this section omit Matplotlib’s viewer, but you’ll continue to see it
    when you run *rw_visual.py*.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[图15-9](#figure15-9)展示了生成的包含5,000个点的图表。本节中的图像省略了Matplotlib的查看器，但当你运行*rw_visual.py*时，你仍然会看到它。'
- en: '![](image_fi/502703c15/f15009.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c15/f15009.png)'
- en: 'Figure 15-9: A random walk with 5,000 points'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图15-9：一个包含5,000个点的随机游走
- en: Generating Multiple Random Walks
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成多个随机游走
- en: 'Every random walk is different, and it’s fun to explore the various patterns
    that can be generated. One way to use the preceding code to make multiple walks
    without having to run the program several times is to wrap it in a `while` loop,
    like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每次随机漫步都是不同的，探索生成的各种模式非常有趣。使用前面的代码生成多个漫步而不需要多次运行程序的一种方式是将其包装在`while`循环中，如下所示：
- en: '**rw_visual.py**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**rw_visual.py**'
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code generates a random walk, displays it in Matplotlib’s viewer, and pauses
    with the viewer open. When you close the viewer, you’ll be asked whether you want
    to generate another walk. If you generate a few walks, you should see some that
    stay near the starting point, some that wander off mostly in one direction, some
    that have thin sections connecting larger groups of points, and many other kinds
    of walks. When you want to end the program, press N.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码生成一个随机漫步，将其显示在Matplotlib的查看器中，并暂停等待查看器关闭。当你关闭查看器时，系统会询问你是否要生成另一个漫步。如果你生成几个漫步，你应该会看到一些漫步保持在起点附近，一些漫步主要朝一个方向走，某些漫步有细长的部分连接着多个点，还有很多其他种类的漫步。当你想结束程序时，按N键。
- en: Styling the Walk
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 漫步的样式
- en: In this section, we’ll customize our plots to emphasize the important characteristics
    of each walk and deemphasize distracting elements. To do so, we identify the characteristics
    we want to emphasize, such as where the walk began, where it ended, and the path
    taken. Next, we identify the characteristics to deemphasize, such as tick marks
    and labels. The result should be a simple visual representation that clearly communicates
    the path taken in each random walk.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将自定义我们的图表，突出显示每次随机漫步的关键特征，并淡化干扰元素。为此，我们确定需要强调的特征，如漫步的起点、终点以及所走的路径。接下来，我们确定需要淡化的特征，如刻度标记和标签。最终结果应该是一个简单的视觉表示，清晰地传达每次随机漫步的路径。
- en: Coloring the Points
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 给点着色
- en: 'We’ll use a colormap to show the order of the points in the walk, and remove
    the black outline from each dot so the color of the dots will be clearer. To color
    the points according to their position in the walk, we pass the `c` argument a
    list containing the position of each point. Because the points are plotted in
    order, this list just contains the numbers from 0 to 4,999:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用颜色图来展示漫步中各点的顺序，并去除每个点的黑色轮廓，使点的颜色更加清晰。为了根据点在漫步中的位置为其着色，我们将包含每个点位置的列表传递给`c`参数。由于这些点是按顺序绘制的，这个列表只包含从0到4,999的数字：
- en: '**rw_visual.py**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**rw_visual.py**'
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We use `range()` to generate a list of numbers equal to the number of points
    in the walk ❶. We assign this list to `point_numbers`, which we’ll use to set
    the color of each point in the walk. We pass `point_numbers` to the `c` argument,
    use the `Blues` colormap, and then pass `edgecolors='none'` to get rid of the
    black outline around each point. The result is a plot that varies from light to
    dark blue, showing exactly how the walk moves from its starting point to its ending
    point. This is shown in [Figure 15-10](#figure15-10).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`range()`生成一个与漫步点数相等的数字列表❶。我们将这个列表赋值给`point_numbers`，并将其用于设置每个点的颜色。我们将`point_numbers`传递给`c`参数，使用`Blues`颜色图，然后传递`edgecolors='none'`来去除每个点周围的黑色轮廓。结果是一个从浅蓝到深蓝变化的图表，准确地显示了漫步从起点到终点的过程。如[图
    15-10](#figure15-10)所示。
- en: '![](image_fi/502703c15/f15010.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c15/f15010.png)'
- en: 'Figure 15-10: A random walk colored with the `Blues` colormap'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '图 15-10: 使用`Blues`颜色图着色的随机漫步'
- en: Plotting the Starting and Ending Points
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绘制起点和终点
- en: 'In addition to coloring points to show their position along the walk, it would
    be useful to see exactly where each walk begins and ends. To do so, we can plot
    the first and last points individually after the main series has been plotted.
    We’ll make the end points larger and color them differently to make them stand
    out:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过颜色来标识每个点在漫步中的位置外，显示每次漫步的起点和终点也是很有用的。为此，我们可以在主要序列绘制完成后，单独绘制第一个和最后一个点。我们将使终点的点更大，并使用不同的颜色使其更加突出：
- en: '**rw_visual.py**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**rw_visual.py**'
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To show the starting point, we plot the point (0, 0) in green and in a larger
    size (`s=100`) than the rest of the points. To mark the end point, we plot the
    last *x*- and *y*-values in red with a size of 100 as well. Make sure you insert
    this code just before the call to `plt.show()` so the starting and ending points
    are drawn on top of all the other points.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示起点，我们将点(0, 0)以绿色和比其他点更大的尺寸（`s=100`）绘制。为了标记终点，我们也将最后的 *x* 和 *y* 值以红色绘制，尺寸为100。确保将这段代码插入到`plt.show()`调用之前，以便起点和终点能够绘制在所有其他点的上面。
- en: When you run this code, you should be able to spot exactly where each walk begins
    and ends. If these end points don’t stand out clearly enough, adjust their color
    and size until they do.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，你应该能够准确找到每次漫步的开始和结束位置。如果这些端点不够显眼，可以调整它们的颜色和大小，直到它们清晰可见。
- en: Cleaning Up the Axes
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 清理坐标轴
- en: 'Let’s remove the axes in this plot so they don’t distract from the path of
    each walk. Here’s how to hide the axes:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们移除此图中的坐标轴，以避免它们分散每次漫步的注意力。以下是隐藏坐标轴的方法：
- en: '**rw_visual.py**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**rw_visual.py**'
- en: '[PRE22]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To modify the axes, we use the `ax.get_xaxis()` and `ax.get_yaxis()` methods
    to get each axis, and then chain the `set_visible()` method to make each axis
    invisible. As you continue to work with visualizations, you’ll frequently see
    this chaining of methods to customize different aspects of a visualization.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修改坐标轴，我们使用 `ax.get_xaxis()` 和 `ax.get_yaxis()` 方法来获取每个坐标轴，然后通过链式调用 `set_visible()`
    方法使每个坐标轴变得不可见。随着你继续进行可视化工作，你将经常看到这种方法链的使用，用来定制可视化的不同方面。
- en: Run *rw_visual.py* now; you should see a series of plots with no axes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行 *rw_visual.py*；你应该能看到一系列没有坐标轴的图表。
- en: Adding Plot Points
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加绘图点
- en: 'Let’s increase the number of points, to give us more data to work with. To
    do so, we increase the value of `num_points` when we make a `RandomWalk` instance
    and adjust the size of each dot when drawing the plot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们增加点的数量，以便为我们提供更多的数据来处理。为此，我们在创建 `RandomWalk` 实例时增加 `num_points` 的值，并在绘制图表时调整每个点的大小：
- en: '**rw_visual.py**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**rw_visual.py**'
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This example creates a random walk with 50,000 points and plots each point at
    size `s=1`. The resulting walk is wispy and cloudlike, as shown in [Figure 15-11](#figure15-11).
    We’ve created a piece of art from a simple scatter plot!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子创建了一个包含 50,000 个点的随机漫步，并且将每个点的大小设置为 `s=1`。最终的随机漫步呈现出云雾状，如 [图 15-11](#figure15-11)
    所示。我们已经从一个简单的散点图中创造出了一幅艺术作品！
- en: Experiment with this code to see how much you can increase the number of points
    in a walk before your system starts to slow down significantly or the plot loses
    its visual appeal.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整此代码，看看你可以在系统开始显著变慢或图表失去视觉吸引力之前，增加多少步数。
- en: '![](image_fi/502703c15/f15011.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502703c15/f15011.png)'
- en: 'Figure 15-11: A walk with 50,000 points'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15-11：50,000 个点的随机漫步
- en: Altering the Size to Fill the Screen
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调整大小以填充屏幕
- en: 'A visualization is much more effective at communicating patterns in data if
    it fits nicely on the screen. To make the plotting window better fit your screen,
    you can adjust the size of Matplotlib’s output. This is done in the `subplots()`
    call:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可视化能够很好地适应屏幕，它在传达数据模式时会更加有效。为了使绘图窗口更好地适应屏幕，你可以调整 Matplotlib 输出的大小。这是在 `subplots()`
    调用中完成的：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When creating a plot, you can pass `subplots()` a `figsize` argument, which
    sets the size of the figure. The `figsize` parameter takes a tuple that tells
    Matplotlib the dimensions of the plotting window in inches.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建图表时，你可以将 `subplots()` 的 `figsize` 参数传递进去，这样可以设置图形的大小。`figsize` 参数接受一个元组，告诉
    Matplotlib 绘图窗口的尺寸（单位为英寸）。
- en: 'Matplotlib assumes your screen resolution is 100 pixels per inch; if this code
    doesn’t give you an accurate plot size, adjust the numbers as necessary. Or, if
    you know your system’s resolution, you can pass `subplots()` the resolution using
    the `dpi` parameter:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 假设你的屏幕分辨率为每英寸 100 像素；如果这段代码没有给出准确的图表大小，请根据需要调整数字。或者，如果你知道系统的分辨率，可以使用
    `dpi` 参数将分辨率传递给 `subplots()`：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This should help make the most efficient use of the space available on your
    screen.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该有助于更有效地利用屏幕上可用的空间。
- en: Rolling Dice with Plotly
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Plotly 掷骰子
- en: In this section, we’ll use Plotly to produce interactive visualizations. Plotly
    is particularly useful when you’re creating visualizations that will be displayed
    in a browser, because the visualizations will scale automatically to fit the viewer’s
    screen. These visualizations are also interactive; when the user hovers over certain
    elements on the screen, information about those elements is highlighted. We’ll
    build our initial visualization in just a couple lines of code using *Plotly Express*,
    a subset of Plotly that focuses on generating plots with as little code as possible.
    Once we know our plot is correct, we’ll customize the output just as we did with
    Matplotlib.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 Plotly 来制作交互式可视化。Plotly 特别适用于在浏览器中显示的可视化，因为这些可视化会自动缩放以适应查看者的屏幕。它们也是交互式的；当用户将鼠标悬停在屏幕上的某些元素上时，这些元素的信息会被高亮显示。我们将使用
    *Plotly Express* 来构建最初的可视化，Plotly Express 是 Plotly 的一个子集，专注于以尽可能少的代码生成图表。一旦确认我们的图表正确无误，我们将像使用
    Matplotlib 一样自定义输出。
- en: In this project, we’ll analyze the results of rolling dice. When you roll one
    regular, six-sided die, you have an equal chance of rolling any of the numbers
    from 1 through 6\. However, when you use two dice, you’re more likely to roll
    certain numbers than others. We’ll try to determine which numbers are most likely
    to occur by generating a dataset that represents rolling dice. Then we’ll plot
    the results of a large number of rolls to determine which results are more likely
    than others.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: This work helps model games involving dice, but the core ideas also apply to
    games that involve chance of any kind, such as card games. It also relates to
    many real-world situations where randomness plays a significant factor.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Installing Plotly
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Install Plotly using pip, just as you did for Matplotlib:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Plotly Express depends on *pandas*, which is a library for working efficiently
    with data, so we need to install that as well. If you used `python3` or something
    else when installing Matplotlib, make sure you use the same command here.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: To see what kind of visualizations are possible with Plotly, visit the gallery
    of chart types at [https://plotly.com/python](https://plotly.com/python). Each
    example includes source code, so you can see how Plotly generates the visualizations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Die Class
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll create the following `Die` class to simulate the roll of one die:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '**die.py**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `__init__()` method takes one optional argument ❶. With the `Die` class,
    when an instance of our die is created, the number of sides will be six if no
    argument is included. If an argument *is* included, that value will set the number
    of sides on the die. (Dice are named for their number of sides: a six-sided die
    is a D6, an eight-sided die is a D8, and so on.)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The `roll()` method uses the `randint()` function to return a random number
    between 1 and the number of sides ❷. This function can return the starting value
    (1), the ending value (`num_sides`), or any integer between the two.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Rolling the Die
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before creating a visualization based on the `Die` class, let’s roll a D6,
    print the results, and check that the results look reasonable:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '**die_visual.py**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We create an instance of `Die` with the default six sides ❶. Then we roll the
    die `100` times ❷ and store the result of each roll in the list `results`. Here’s
    a sample set of results:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A quick scan of these results shows that the `Die` class seems to be working.
    We see the values 1 and 6, so we know the smallest and largest possible values
    are being returned, and because we don’t see 0 or 7, we know all the results are
    in the appropriate range. We also see each number from 1 through 6, which indicates
    that all possible outcomes are represented. Let’s determine exactly how many times
    each number appears.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the Results
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll analyze the results of rolling one D6 by counting how many times we roll
    each number:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '**die_visual.py**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Because we’re no longer printing the results, we can increase the number of
    simulated rolls to `1000` ❶. To analyze the rolls, we create the empty list `frequencies`
    to store the number of times each value is rolled. We then generate all the possible
    results we could get; in this example, that’s all the numbers from `1` to however
    many sides `die` has ❷. We loop through the possible values, count how many times
    each number appears in `results` ❸, and then append this value to `frequencies`
    ❹. We print this list before making a visualization:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'These results look reasonable: we see six frequencies, one for each possible
    number when you roll a D6\. We also see that no frequency is significantly higher
    than any other. Now let’s visualize these results.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Making a Histogram
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have the data we want, we can generate a visualization in just
    a couple lines of code using Plotly Express:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**die_visual.py**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We first import the `plotly.express` module, using the conventional alias `px`.
    We then use the `px.bar()` function to create a bar graph. In the simplest use
    of this function, we only need to pass a set of *x-*values and a set of *y-*values.
    Here the *x*-values are the possible results from rolling a single die, and the
    *y*-values are the frequencies for each possible result.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The final line calls `fig.show()`, which tells Plotly to render the resulting
    chart as an HTML file and open that file in a new browser tab. The result is shown
    in [Figure 15-12](#figure15-12).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: This is a really simple chart, and it’s certainly not complete. But this is
    exactly how Plotly Express is meant to be used; you write a couple lines of code,
    look at the plot, and make sure it represents the data the way you want it to.
    If you like what you see, you can move on to customizing elements of the chart
    such as labels and styles. But if you want to explore other possible chart types,
    you can do so now, without having spent extra time on customization work. Feel
    free to try this now by changing `px.bar()` to something like `px.scatter()` or
    `px.line()`. You can find a full list of available chart types at [https://plotly.com/python/plotly-express](https://plotly.com/python/plotly-express).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: This chart is dynamic and interactive. If you change the size of your browser
    window, the chart will resize to match the available space. If you hover over
    any of the bars, you’ll see a pop-up highlighting the specific data related to
    that bar.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c15/f15012.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-12: The initial plot produced by Plotly Express'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the Plot
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we know we have the correct kind of plot and our data is being represented
    accurately, we can focus on adding the appropriate labels and styles for the chart.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'The first way to customize a plot with Plotly is to use some optional parameters
    in the initial call that generates the plot, in this case, `px.bar()`. Here’s
    how to add an overall title and a label for each axis:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '**die_visual.py**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We first define the title that we want, here assigned to `title` ❶. To define
    axis labels, we write a dictionary ❷. The keys in the dictionary refer to the
    labels we want to customize, and the values are the custom labels we want to use.
    Here we give the *x*-axis the label `Result` and the *y*-axis the label `Frequency
    of Result`. The call to `px.bar()` now includes the optional arguments `title`
    and `labels`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Now when the plot is generated it includes an appropriate title and a label
    for each axis, as shown in [Figure 15-13](#figure15-13).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c15/f15013.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-13: A simple bar chart created with Plotly'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Rolling Two Dice
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rolling two dice results in larger numbers and a different distribution of
    results. Let’s modify our code to create two D6 dice to simulate the way we roll
    a pair of dice. Each time we roll the pair, we’ll add the two numbers (one from
    each die) and store the sum in `results`. Save a copy of *die_visual.py* as *dice_visual.py*
    and make the following changes:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '**dice_visual.py**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After creating two instances of `Die`, we roll the dice and calculate the sum
    of the two dice for each roll ❶. The smallest possible result (2) is the sum of
    the smallest number on each die. The largest possible result (12) is the sum of
    the largest number on each die, which we assign to `max_result` ❷. The variable
    `max_result` makes the code for generating `poss_results` much easier to read
    ❸. We could have written `range(2, 13)`, but this would work only for two D6 dice.
    When modeling real-world situations, it’s best to write code that can easily model
    a variety of situations. This code allows us to simulate rolling a pair of dice
    with any number of sides.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: After running this code, you should see a chart that looks like [Figure 15-14](#figure15-14).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c15/f15014.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-14: Simulated results of rolling two six-sided dice 1,000 times'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'This graph shows the approximate distribution of results you’re likely to get
    when you roll a pair of D6 dice. As you can see, you’re least likely to roll a
    2 or a 12 and most likely to roll a 7\. This happens because there are six ways
    to roll a 7: 1 and 6, 2 and 5, 3 and 4, 4 and 3, 5 and 2, and 6 and 1.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Further Customizations
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s one issue that we should address with the plot we just generated. Now
    that there are 11 bars, the default layout settings for the *x*-axis leave some
    of the bars unlabeled. While the default settings work well for most visualizations,
    this chart would look better with all of the bars labeled.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Plotly has an `update_layout()` method that can be used to make a wide variety
    of updates to a figure after it’s been created. Here’s how to tell Plotly to give
    each bar its own label:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '**dice_visual.py**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `update_layout()` method acts on the `fig` object, which represents the
    overall chart. Here we use the `xaxis_dtick` argument, which specifies the distance
    between tick marks on the *x*-axis. We set that spacing to `1`, so that every
    bar is labeled. When you run *dice_visual.py* again, you should see a label on
    each bar.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Rolling Dice of Different Sizes
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s create a six-sided die and a ten-sided die, and see what happens when
    we roll them 50,000 times:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '**dice_visual_d6d10.py**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To make a D10, we pass the argument `10` when creating the second `Die` instance
    ❶ and change the first loop to simulate 50,000 rolls instead of 1,000\. We change
    the title of the graph as well ❷.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-15](#figure15-15) shows the resulting chart. Instead of one most
    likely result, there are five such results. This happens because there’s still
    only one way to roll the smallest value (1 and 1) and the largest value (6 and
    10), but the smaller die limits the number of ways you can generate the middle
    numbers. There are six ways to roll a 7, 8, 9, 10, or 11, these are the most common
    results, and you’re equally likely to roll any one of them.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502703c15/f15015.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15-15: The results of rolling a six-sided die and a ten-sided die 50,000
    times'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Our ability to use Plotly to model the rolling of dice gives us considerable
    freedom in exploring this phenomenon. In just minutes, you can simulate a tremendous
    number of rolls using a large variety of dice.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Saving Figures
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you have a figure you like, you can always save the chart as an HTML file
    through your browser. But you can also do so programmatically. To save your chart
    as an HTML file, replace the call to `fig.show()` with a call to `fig.write_html()`:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `write_html()` method requires one argument: the name of the file to write
    to. If you only provide a filename, the file will be saved in the same directory
    as the *.py* file. You can also call `write_html()` with a `Path` object, and
    write the output file anywhere you want on your system.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned to generate datasets and create visualizations
    of that data. You created simple plots with Matplotlib and used a scatter plot
    to explore random walks. You also created a histogram with Plotly, and used it
    to explore the results of rolling dice of different sizes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Generating your own datasets with code is an interesting and powerful way to
    model and explore a wide variety of real-world situations. As you continue to
    work through the data visualization projects that follow, keep an eye out for
    situations you might be able to model with code. Look at the visualizations you
    see in news media, and see if you can identify those that were generated using
    methods similar to the ones you’re learning in these projects.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 16, you’ll download data from online sources and continue to use
    Matplotlib and Plotly to explore that data.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
