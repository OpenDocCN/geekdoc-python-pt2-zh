# 4

栈和队列

![](img/chapterart.png)

本章介绍了栈和队列，这两种数据结构根据插入数据的顺序来检索存储的数据。栈和队列非常相似，只需一些微小的实现差异。然而，栈返回的是最近插入的数据，而队列返回的是最旧的数据，这一点完全改变了算法的行为以及我们访问数据的效率。

栈是深度优先搜索的核心，深度优先搜索沿着单个路径深入，直到遇到死胡同。队列则实现广度优先搜索，广度优先搜索首先浅尝相邻路径，然后再深入探索。正如我们稍后将看到的，这一变化可以显著影响实际行为，例如我们如何浏览网页或进行咖啡研究。

## 栈

*栈*是一种*后进先出（LIFO）*的数据结构，操作方式类似于一堆纸：我们将新元素添加到栈的顶部，并从栈的顶部开始移除元素。严格来说，栈支持两种操作：

1.  压入：将一个新元素添加到栈的顶部。

1.  弹出：从栈的顶部移除元素并返回它。

由于元素是从栈顶提取的，下一个被移除的元素总是最近添加的。如果我们将元素 1、2、3、4 和 5 插入栈中，我们将按照 5、4、3、2、1 的顺序将它们取出。

你可以将栈想象成在一个非最优运行的沙拉吧中放置的生菜桶，这些桶每隔几年就会清空一次。服务员不断地把新生菜倒在桶的顶部，完全不顾底下日益变得粘糊的生菜堆积物。食客们看到顶部的新鲜生菜并将其舀到盘子里，完全不在意下面几层的可怕景象。

我们可以使用数组或链表来实现栈。

### 将栈实现为数组

当将栈实现为数组时，我们使用数组来存储栈中的值，并使用一个额外的变量来跟踪对应栈顶的索引——即我们数组中的最后一个元素：

```py
Stack {
    Integer: array_size
    Integer: top
    Array of values: array
}
```

初始时，我们将`top`索引设置为 -1，表示栈中没有任何元素。

当我们将一个新元素压入栈时，我们会将`top`索引增加到下一个空位，并将新值添加到该位置。这样，我们将数组从底部到顶部排序，如图 4-1 所示。如果数组的最后一项是新鲜脆嫩的生菜，那么数组的第一个元素代表栈底的那些物品。

![一个包含九个槽的数组，前五个槽中有值。最右边的有值的槽标记为“top”，它保存值 5。一个新值 9 被插入到 5 旁边的空槽中，成为新的“top”。](img/f04001.png)

图 4-1：将一个元素压入表示为数组的栈顶

在向固定大小的数组添加元素时，我们必须小心避免添加超过可用空间的元素。如果空间用尽，我们可能会使用数组扩展技术（如数组翻倍，参见第三章）来扩展数组，如以下代码所示。这样，当我们添加数据时，栈就可以增长，但需要注意的是，它会在某些插入操作中引入额外的成本。

```py
Push(Stack: s, Type: value):
    IF s.top == s.array_size – 1:
        Expand the size of the array
    s.top = s.top + 1
    s.array[s.top] = value
```

这段用于将元素推入实现为数组的栈的代码，首先检查是否有足够的空间插入新元素。如果没有，代码将扩展数组。然后，代码递增栈顶元素的索引，并在新的索引位置插入值。

当我们从栈中弹出一个元素时，我们再次使用`top`索引来查找正确的元素。我们将此元素从数组中移除，并递减`top`索引，如图 4-2 所示。换句话说，我们从箱子中取出最新的生菜，并向下移动一层，接近较旧的层次。

![一个九格的数组，前五个格子有值。最右边的格子标记为“top”。它保存着值 5。该格子被从栈中弹出，因此现在栈顶元素是第四个。](img/f04002.png)

图 4-2：从实现为数组的栈中弹出元素

从实现为数组的栈中弹出元素的代码，比插入的代码要简单：

```py
Pop(Stack: s):
    Type: value = null
    IF s.top > -1:
        value = s.array[s.top]
        s.top = s.top – 1
    return value
```

代码首先检查栈是否为空。如果栈不为空，代码将数组的最后一个元素复制到`value`中，然后递减指向最后一个元素的指针。代码返回栈顶元素的值，或者如果栈为空，则返回`null`。由于我们只是从数组的末尾添加或移除元素，因此不需要移动其他元素。

只要我们的栈有足够的空间，我们就可以以恒定的成本进行添加和移除操作。无论是有 10 个元素还是 10,000 个元素，添加或移除一个元素所需的操作次数是相同的。然而，在插入时，如果扩展数组的大小，我们会付出额外的成本，因此预先分配足够大的栈来适应使用场景是有帮助的。

### 栈作为链表

另外，我们可以将栈实现为链表或双向链表，如图 4-3 所示。这里，列表从左到右绘制，与前几章中的列表顺序相反，以显示与数组表示相同的顺序。我们的标准指针指向列表的头部，同时也充当栈顶部的指针。

```py
Stack {
    LinkedListNode: head
}
```

与填充新数组格子并更新索引不同，链表实现要求我们在链表中创建和删除节点，更新各自的节点指针，并更新指向栈顶部的指针。

![作为链表实现的栈的示意图。一个指针同时表示列表的头部和栈的顶部。](img/f04003.png)

图 4-3：作为链表实现的栈

我们通过将元素添加到链表的前端来将项推入栈中：

```py
Push(Stack: s, Type: value):
    LinkedListNode: node = LinkedListNode(value)
    node.next = s.head
    s.head = node
```

推入的代码首先创建一个新的链表节点。然后，它通过更新新节点的 `next` 指针和栈的 `head` 指针，将该节点插入到链表的前端。

同样，当我们从栈中弹出一个项时，我们返回头节点的值并将头节点指针移动到列表中的下一个项：

```py
Pop(Stack: s):
    Type: value = null
 IF s.head != null:
        value = s.head.value
        s.head = s.head.next
    return value
```

代码从默认返回值 `null` 开始。如果栈不为空（`s.head != null`），代码会将返回值更新为头节点的值，然后将头指针更新为栈中的下一个节点。最后，它返回 `value`。

除了存储额外指针的内存开销外，指针的分配还会为推入和弹出操作增加小而恒定的成本。我们不再是设置单一的数组值并递增索引。然而，正如所有动态数据结构一样，这种权衡带来了更大的灵活性：链表可以随着数据的增减而扩展或收缩。我们不再需要担心填满数组，或为扩展数组大小而支付额外的成本。

## 队列

*队列* 是一种 *先进先出（FIFO）* 数据结构，运作方式就像你最喜欢的咖啡吧的排队方式：我们将新元素添加到队列的末尾，并从前端移除旧元素。正式地说，队列支持两个操作：

1.  入队 将一个新元素添加到队列的末尾。

1.  出队 从队列的前端移除元素并返回它。

如果我们按顺序入队五个元素 1、2、3、4、5，那么我们会按相同的顺序将它们取出：1、2、3、4、5。

队列保持元素添加的顺序，从而实现像按顺序处理到达的项目等有用的行为。例如，FIFO（先进先出）特性允许我们最喜欢的咖啡馆按顺序为顾客服务。由于其令人惊叹的菜单，这家店总是排着一队期待的顾客等候他们的早晨咖啡。新顾客进入店内并在队列末尾入队。下一个被服务的顾客是队列前端的人。他们下单，从队列前端出队，并急切地期待着完美的早晨开始。

与栈类似，队列既可以是数组形式，也可以是链表形式。

### 队列作为数组

为了用数组实现队列，我们追踪两个索引：队列中的第一个和最后一个元素。当我们入队一个新元素时，我们将其添加到当前最后一个元素后面，并递增末尾索引，如图 4-4 所示。

![ 一个包含九个槽位的数组，其中前五个槽位有值。最左边的槽位标记为“front”。最右边有值的槽位标记为“back”，它存储着值 5。一个新值 9 被插入到 5 旁边的空槽位，成为新的“back”。前端元素保持不变。](img/f04004.png)

图 4-4：在表示为数组的队列中入队一个元素

当我们出队一个元素时，我们移除前端元素并相应地递增前端索引，如图 4-5 所示。

![一个包含九个箱子的数组，前六个箱子中有值。最左侧的箱子标记为“前端”。最右侧有值的箱子标记为“后端”，它包含值 9。前端的箱子已从数组中出队，因此现在前端元素是第二个箱子。原本包含已删除元素的箱子现在是空的。](img/f04005.png)

图 4-5：在作为数组表示的队列中出队一个元素

从固定数组中出队时，我们很快会遇到一个问题：一块空闲空间会在数组的前面积累。为了解决这个问题，我们可以选择将队列环绕到数组的末尾，或者将元素向下移动以填补空间。正如我们在第一章中看到的，移动元素是很昂贵的，因为每次出队操作都需要移动所有剩余的元素。然而，环绕是一种更好的解决方案，尽管它要求我们在入队和出队过程中小心地处理索引递增超过数组末尾的问题，如图 4-6 所示。

![一个九个箱子的数组，前四个箱子为空，后五个箱子中有值。包含第一个值的箱子标记为“前端”，最右侧的箱子标记为“后端”。当一个新值添加到第一个空箱子时，该箱子现在被标记为“后端”。列表的前端没有变化。](img/f04006.png)

图 4-6：使用数组表示队列可能会导致元素环绕。

虽然环绕增加了实现的复杂性，但它避免了移动元素的高昂成本。

### 链表中的队列

将队列实现为链表或双向链表是一个更好的主意。除了维护指向列表头部（队列前端）的特殊指针外，我们还需要维护一个指向列表最后一个元素，即尾部或后端的指针：

```py
Queue {
    LinkedListNode: front
    LinkedListNode: back
}
```

如图 4-7 所示，这个列表类似于我们在图 4-3 中用于堆栈的链表。队列中的每个元素都链接到紧随其后的元素，允许我们从队列的前端到后端遍历`next`指针。

![作为链表表示的队列。右箭头连接每个元素，额外的指针指示队列的前后元素](img/f04007.png)

图 4-7：作为链表表示的队列，具有指向队列前后元素的额外指针

一旦再次插入和删除操作，我们需要更新列表中的节点以及我们的特殊指针节点：

```py
Enqueue(Queue: q, Type: value):
    LinkedListNode: node = LinkedListNode(value)
  ❶ IF q.back == null:
        q.front = node
        q.back = node
    ELSE:
      ❷ q.back.next = node
      ❸ q.back = node
```

当我们向队列中添加新元素时，我们使用队列的`back`指针来找到正确的插入位置。代码首先为插入的值创建一个新节点，然后检查队列是否为空❶。如果为空，代码通过将队列的`front`和`back`指针都指向新节点来添加新节点。两个指针都需要更新，否则它们将不指向有效的节点。

如果队列不为空，代码通过修改当前最后一个节点的`next`指针，将新节点添加到列表的末尾❷。最后，代码更新队列的`back`指针，使其指向新节点，表示它是队列中的新最后一个节点❸。除非队列之前为空，否则`front`指针不会改变。

删除操作主要更新队列前端的指针：

```py
Dequeue(Queue: q):
  ❶ IF q.front == null:
        return null

  ❷ Type: value = q.front.value
  ❸ q.front = q.front.next
    IF q.front == null:
        q.back = null
    return value
```

代码首先检查队列中是否有元素，通过测试队列的`front`指针是否指向某个元素，或者是否为`null`❶。如果队列为空（`q.front == null`），代码立即返回`null`。如果队列中至少有一个元素，代码将该值保存以便稍后返回❷。然后，代码更新`q.front`，使其指向队列中的下一个元素❸。在出队最后一个元素时，我们还需要小心更新`back`指针。如果前面的元素不再指向有效的元素，那么队列就为空，我们也将`back`指针设置为`null`。

入队和出队操作都需要恒定数量的操作，无论队列的大小如何。每次操作都需要调整一些指针。我们不关心数据结构中其他的内容；即使我们正在将元素附加到一个贯穿整个计算机内存的链表末尾，也没关系。

## 顺序的重要性

我们插入或移除元素的顺序可能对算法的行为产生巨大影响（在沙拉吧的情况下，可能还影响到顾客的健康）。当我们需要存储保持插入顺序时，队列最为有效。例如，在处理进入的网络请求时，我们希望优先处理早期的请求。相比之下，当我们希望首先处理最新的项目时，我们使用堆栈。例如，编程语言可能会使用堆栈来处理函数调用。当调用一个新函数时，当前的状态会被压入堆栈，执行跳转到新函数。当函数执行完毕时，最后的状态会被弹出堆栈，程序返回到调用该函数的位置。

我们可以通过选择不同的数据结构来改变搜索算法的整体行为。假设我们正在探索我们最喜欢的在线百科全书，以研究咖啡研磨方法。当我们浏览 burr grinders 页面时，我们看到有链接指向其他有趣的选项。如果我们跟踪其中一个链接，就会到达另一页信息，并伴随有新的潜在主题分支。无论我们使用堆栈还是队列来跟踪我们稍后想要追寻的主题，这将会影响我们咖啡探索的方式，正如我们将在接下来的两个部分中看到的。

### 深度优先搜索

*深度优先搜索*是一种算法，它沿着单一路径不断深入，直到遇到死胡同。然后，算法会回退到上一个分支点，并检查其他选项。它使用堆栈维护一个未来状态的列表，始终选择最近插入的选项作为下一个尝试的目标。

在咖啡研究示例中，假设我们从关于 burr grinders 的页面开始深度优先搜索，并迅速找到三个额外的主题来进行深入研究。我们将这些主题推入堆栈中，如图 4-8(1)所示。大多数搜索将按照遇到的顺序添加选项。为了保持一致性，在这个示例中，我们按逆字母顺序添加元素，因此我们从 A 开始研究，一直到 Z（或最后的字母）。

为了简化，图 4-8 将每个主题（网页）表示为一个字母。它们之间的线条代表网页链接。这种结构被称为*图*，我们将在第十五章详细讨论。阴影节点表示我们已探索过的主题，圆圈标记的主题表示我们在该次搜索迭代中正在检查的主题。堆栈数据，即存储待探索选项的内容，表示为图右侧的`Next`数组。

一旦我们完成了关于 burr grinders（A）的所有阅读，我们便转到下一个主题：blade grinders（B）。此时，我们的搜索在等待探索 B、F 和 H 主题。我们从堆栈顶部取出 B 主题，打开该页面，开始阅读，并发现更多感兴趣的主题（C）。显然，咖啡是一个深奥且复杂的话题；我们可以花一生的时间去研究它的细节。我们将新的 C 主题推入堆栈顶部，以便以后调查，如图 4-8(2)所示。因此，较新的主题被优先作为下一个探索领域。

搜索以这种方式继续，优先考虑最近添加的主题，使得这种搜索特别适合那些总是想要探索最近看到的主题的人。我们不断深入每个主题分支，直到碰到死胡同，并返回堆栈中的早期项目。对于这个示例，已访问的节点不会被重新访问或加入堆栈，但堆栈中可能包含重复项。图 4-8 中的其余子图说明了这一过程。

![深度优先搜索的示意图，经过九个步骤搜索九个主题，在一个分支图中。主题通过字母 A 到 I 表示。每一步，我们都前进到一个新主题。即将到来的主题列在右侧的一列中。最上面的主题总是我们正在探索的分支中的下一个主题，除非我们已经到达该分支的末端。](img/f04008_new.png)

图 4-8：深度优先搜索：使用堆栈来跟踪下一个要探索的主题

### 广度优先搜索

*广度优先搜索*使用类似深度优先搜索的逻辑来探索主题，但通过队列存储未来的状态。在每一步，搜索会优先探索等待时间最长的选项，有效地在更深层次之前扩展到不同的方向。图 4-9 展示了上一节中与咖啡研磨机相关网站的广度优先搜索。圆圈表示主题，线条是它们之间的链接。阴影区域的主题已被探索，而被圈出的主题是我们在当前迭代中正在研究的主题。

在图 4-9(1)中，我们阅读了一页关于平刀磨豆机的页面（A），并按反向字母顺序记下了三个未来感兴趣的主题（B，F 和 H）。队列中的第一个主题与堆栈中的最后一个主题相同——这是两种数据结构之间的关键排序差异。

我们继续研究，从队列前端取出一个项目（H），阅读该页面，并将任何新的感兴趣的项目添加到队列的后端。在图 4-9(2)中，我们探索下一页，但立即遇到死胡同。

在图 4-9(3)中，搜索继续进行，前进到队列中的下一个主题（F）。在这里，我们发现了新的主题（I 和 G），并将这些新链接添加到队列中。

我们不再进一步跟随这些主题，而是从队列前端取出下一个项目（B），如图 4-9(4)所示，探索从初始页面出发的最后一个链接。再次强调，搜索只会将队列中没有的未探索节点添加进去。

![正在进行的广度优先搜索示意图，经过九个步骤搜索九个主题，在一个分支图中。主题通过字母 A 到 I 表示。每一步，我们都前进到一个新主题。即将到来的主题列在右侧的一列中。最上面的主题总是当前分支头部一层之外的下一个主题，直到该层已被探索完毕。](img/f04009.png)

图 4-9：广度优先搜索：使用队列来跟踪下一个要探索的主题

随着搜索的进行，它的优点变得越来越明显：我们不是在深入探讨每一个主题后再返回之前的内容，而是沿着主题的前沿进行探索，优先考虑广度而非深度。我们可能在深入了解每种研磨机制及其发明者的历史之前，先概览五种不同类型的研磨机。这个搜索方法非常适合那些不希望让旧话题滞留的人，他们更愿意在进入新话题之前把旧话题解决掉。

由于深度优先搜索和广度优先搜索每次只探索一个选项，因此它们的工作速度相同：深度优先搜索在广度优先搜索浅尝辄止地探索许多路径时，会深入探索少数几条路径。然而，搜索的实际行为却截然不同。

## 为什么这很重要

不同的数据结构不仅允许程序员以不同的方式使用数据，而且对与数据交互的算法行为有着深远的影响。栈和队列都存储对象，都可以用数组或链表来实现，并且都能高效地处理插入和删除。从单纯存储数据的角度来看，任何一种都足够。然而，它们处理数据的方式，特别是返回项的顺序，使得这两种相似的数据结构表现出截然不同的行为。栈返回的是最新存储的数据，非常适合优先处理最新的项。与此相反，队列始终返回最早存储的数据，非常适合处理按到达顺序排列的项。

当我们努力有效地使用数据结构时，效率并不是唯一需要考虑的因素。在为特定算法设计或选择数据结构时，我们必须考虑该数据结构的特性如何影响算法的行为。正如本章中的搜索示例所展示的那样，我们可以通过简单地更换数据结构，将行为从广度优先搜索转变为深度优先搜索。后续章节将更详细地介绍这一逻辑，并用它来设计其他有助于算法行为和性能的数据结构。
