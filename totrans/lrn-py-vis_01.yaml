- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Hello, World!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Hello, World!
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: When learning a new programming language, it’s a long-standing tradition that
    the first code you write is to display the message ‘Hello, World!’ In keeping
    with that tradition, you’ll do that here too—but that’s not all. This chapter
    introduces everything you need to understand the fundamentals of Processing, and
    you’ll quickly move on from a simple ‘Hello, World!’ to drawing with code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习一门新的编程语言时，传统的第一行代码通常是显示 “Hello, World!” 消息。延续这一传统，你在这里也会写出这样的代码——但这不仅仅是全部。本章将介绍你需要了解的
    Processing 基础知识，之后你将快速从简单的 “Hello, World!” 过渡到使用代码绘图。
- en: To get started, you’ll set up Python Mode for Processing so you can create your
    own sketches. Along the way, you’ll learn the basic rules of writing code in Processing,
    as well as how to deal with errors, use variables, and perform arithmetic operations.
    You’ll also learn about how Processing handles color and how to measure angles
    using radians. By the end of this chapter, you’ll be comfortable drawing colorful
    geometric shapes by using various Processing functions. Let’s get started.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用，你需要为 Processing 设置 Python 模式，这样你就可以创建自己的草图。在此过程中，你将学习如何在 Processing 中编写代码的基本规则，以及如何处理错误、使用变量和执行算术运算。你还将了解
    Processing 如何处理颜色，以及如何使用弧度测量角度。到本章结束时，你将能够通过使用各种 Processing 函数绘制色彩斑斓的几何图形。让我们开始吧。
- en: Processing Installation and Python Mode Setup
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Processing 安装与 Python 模式设置
- en: Before writing any code, you first need to set up Python Mode for Processing.
    Head over to the Processing downloads web page ([https://processing.org/download/](https://processing.org/download/))
    and grab the version of Processing appropriate for your system (Windows, Linux,
    or macOS). As of January 2021, Processing 3.5.4 is the latest stable release.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何代码之前，你需要为 Processing 设置 Python 模式。前往 Processing 的下载页面（[https://processing.org/download/](https://processing.org/download/)）并下载适合你系统的
    Processing 版本（Windows、Linux 或 macOS）。截至 2021 年 1 月，Processing 3.5.4 是最新的稳定版本。
- en: 'Processing does not employ an installation program. Instead, you simply extract
    the file you have downloaded (usually a *.zip* archive) and run the application.
    The exact process varies slightly between operating systems:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 不使用安装程序。相反，你只需解压你下载的文件（通常是 *.zip* 压缩包）并运行应用程序。具体过程在操作系统之间稍有不同：
- en: On Windows, unzip all of the contents by right-clicking the file and selecting
    **Extract All**, and then follow the instructions. Extract or move the folder
    to any location on your computer, including your *Program Files* folder or *Desktop*.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 上，通过右键点击文件并选择 **提取全部** 来解压所有内容，然后按照指示操作。将文件夹提取或移动到计算机上的任何位置，包括 *Program
    Files* 文件夹或 *Desktop*。
- en: On macOS, unzip the file by double-clicking it, and then move the extracted
    app to any location on your computer, including your *Applications* folder or
    *Desktop*.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 macOS 上，双击文件进行解压，然后将提取出来的应用程序移到计算机上的任何位置，包括 *Applications* 文件夹或 *Desktop*。
- en: TheLinux version of Processing is a *.tar* archive. Extract or move the folder
    to any location on your computer, including your home folder or desktop.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Processing 的 Linux 版本是一个 *.tar* 压缩包。将文件夹提取或移动到计算机上的任何位置，包括你的主文件夹或桌面。
- en: Once you’re finished, open the newly extracted folder. [Figure 1-1](#figure1-1)
    shows an abridged listing of what you can expect to see in your file manager.
    Next, locate and run the executable file named *processing*. On macOS, you’ll
    just have a single file named *processing*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，打开新提取的文件夹。[图 1-1](#figure1-1) 显示了你在文件管理器中能看到的简化列表。接下来，定位并运行名为 *processing*
    的可执行文件。在 macOS 上，你将只有一个名为 *processing* 的文件。
- en: '![f01001](image_fi/500969c01/f01001.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![f01001](image_fi/500969c01/f01001.png)'
- en: 'Figure 1-1: The contents of a freshly extracted *processing* folder for Windows
    or Linux'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-1：Windows 或 Linux 的新提取的 *processing* 文件夹内容
- en: The application layout may vary slightly among systems and Processing versions,
    but the key elements are outlined in [Figure 1-2](#figure1-2). If you’re a Mac
    user, you’ll find the *menu bar* in its usual position at the top of your screen.
    Note that the upper right button in the Processing interface is labeled *Java*.
    This is because Processing comes bundled with Java mode as the default.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的布局在不同系统和 Processing 版本中可能略有不同，但关键元素已在 [图 1-2](#figure1-2) 中概述。如果你是 Mac
    用户，你会在屏幕顶部找到 *菜单栏*。请注意，Processing 界面右上角的按钮标记为 *Java*。这是因为 Processing 默认包含了 Java
    模式。
- en: '![f01002](image_fi/500969c01/f01002.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![f01002](image_fi/500969c01/f01002.png)'
- en: 'Figure 1-2: The Processing interface'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-2：Processing 界面
- en: Next, activate Python Mode. Click the **Java** button and select **Add Mode**
    from the drop-down menu; then, from the Contribution Manager window that appears,
    choose **Python Mode for Processing**. Finally, click **Install**. You can now
    change between Python and Java mode by using the drop-down menu. Switch to Python
    ([Figure 1-3](#figure1-3)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，激活Python模式。点击**Java**按钮，从下拉菜单中选择**添加模式**；然后，在弹出的贡献管理器窗口中选择**Python模式 for
    Processing**。最后，点击**安装**。现在，你可以通过下拉菜单在Python和Java模式之间切换。切换到Python模式（见[图1-3](#figure1-3)）。
- en: '![f01003](image_fi/500969c01/f01003.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![f01003](image_fi/500969c01/f01003.png)'
- en: 'Figure 1-3: The button to the right indicates that Python Mode is activated.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-3：右侧的按钮表示已激活Python模式。
- en: You’re now ready to write your first lines of code!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你准备好编写你的第一行代码了！
- en: Your First Sketch
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的第一个草图
- en: Processing refers to programs as *sketches*. Given the visual and artistic nature
    of what you are likely to produce, it’s a fitting term. Select **File**▶**New**
    to create a new sketch, or use the associated keyboard shortcut (listed alongside
    the menu entry).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Processing将程序称为*草图*。考虑到你可能制作的内容的视觉和艺术性质，这个词非常合适。选择**文件**▶**新建**来创建一个新的草图，或者使用菜单旁边列出的快捷键。
- en: 'Enter the following lines of code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下代码：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I’ll go through the specifics of this code in a bit. For now, save the sketch
    by using **File**▶**Save As** and name it *hello_world*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我稍后会详细讲解这段代码。现在，使用**文件**▶**另存为**保存草图，并将其命名为*hello_world*。
- en: 'You will notice that Processing creates a new folder named *hello_world*; within
    it, there are two files: *hello_world.pyde* and *sketch.properties* ([Figure 1-4](#figure1-4)).
    Depending on your system’s configuration, you may or may not see the file extension
    (*.pyde*). To reopen any sketch, locate and open the *.pyde* file.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，Processing创建了一个名为*hello_world*的新文件夹；其中有两个文件：*hello_world.pyde*和*sketch.properties*（见[图1-4](#figure1-4)）。根据你的系统配置，你可能看不到文件扩展名（*.pyde*）。要重新打开任何草图，只需找到并打开*.pyde*文件。
- en: '![f01004](image_fi/500969c01/f01004.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![f01004](image_fi/500969c01/f01004.png)'
- en: 'Figure 1-4: The contents of your *hello_world* sketch folder'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-4：你的*hello_world*草图文件夹内容
- en: You may want to add other assets to your sketch folders, such as images and
    fonts, but more on that later.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想在草图文件夹中添加其他资源，如图片和字体，不过这些稍后再讲。
- en: 'Next, click the play (▶) button to execute the code. Better yet, use the associated
    keyboard shortcut: ctrl-R for Windows and Linux, or -R for macOS. A gray 500
    × 500 pixel *display window* should appear. In the console, which is the black
    area at the bottom of the editor, Processing should display `Hello, World!` ([Figure
    1-5](#figure1-5)).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击播放（▶）按钮执行代码。更好的方式是使用关联的快捷键：Windows和Linux使用ctrl-R，macOS使用-R。此时，应该会出现一个灰色的500
    × 500像素的*显示窗口*。在编辑器底部的黑色区域，即控制台中，Processing应该显示`Hello, World!`（见[图1-5](#figure1-5)）。
- en: 'Now let’s get back to the code you entered in this file; it uses two Processing
    functions: `size()` and `print()`. *Functions* are named instructions, sort of
    like dog commands for computers. Some commands are simple, like “sit,” but something
    like “fetch” may involve specifying what it is that Fido should retrieve.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回到你在这个文件中输入的代码，它使用了两个Processing函数：`size()`和`print()`。*函数*是命名的指令，有点像是给计算机的狗命令。有些命令很简单，比如“坐下”，但像“取物”这样的命令可能需要指定Fido应该取回的具体物品。
- en: 'Python functions consist of a function name followed by opening and closing
    *parentheses*, which is where you provide arguments. In the case of my dog-command
    analogy, “ball” could be an argument for “fetch.” The `size()` function ([Figure
    1-6](#figure1-6)) takes two arguments: the first represents the width of your
    sketch, and the second is the height.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Python函数由函数名称和开闭*括号*组成，在括号内提供参数。在我使用的狗命令类比中，“球”可以是“取物”的一个参数。`size()`函数（见[图1-6](#figure1-6)）接受两个参数：第一个表示草图的宽度，第二个是高度。
- en: In this case, the display window is 500 pixels wide by 500 pixels high.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，显示窗口的宽度为500像素，高度为500像素。
- en: '![f01005](image_fi/500969c01/f01005.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![f01005](image_fi/500969c01/f01005.png)'
- en: 'Figure 1-5: Display window (left) and an editor with `′Hello, World!′` displayed
    in the console (right)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-5：显示窗口（左）和控制台中显示`′Hello, World!′`的编辑器（右）
- en: '![f01006](image_fi/500969c01/f01006.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![f01006](image_fi/500969c01/f01006.png)'
- en: 'Figure 1-6: Anatomy of a `size()` function'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-6：`size()`函数的结构
- en: 'The `print()` function writes to the console. This function takes a single
    argument: the phrase `''Hello, World!''` Because this is text—or technically,
    *string* data—you need to wrap it in quotation marks. You can use single or double
    quotes, but be sure to use the same type for both opening and closing quotes.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`print()`函数用于输出到控制台。此函数接受一个参数：字符串`''Hello, World!''`。因为这是文本数据——或者严格来说，是*字符串*数据——你需要将其放在引号中。你可以使用单引号或双引号，但请确保开闭引号类型一致。'
- en: 'Python classifies every value according to a *data type*, which determines
    how the value is handled and the operations you can perform on it. For example,
    you can perform arithmetic operations—like division or subtraction—on numeric
    data types but not on strings. In this chapter, you’ll deal with three data types:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Python 会根据*数据类型*对每个值进行分类，这决定了该值的处理方式以及你可以在其上执行的操作。例如，你可以对数值数据类型执行算术操作——如除法或减法——但不能对字符串执行。
    在本章中，你将处理三种数据类型：
- en: String Text data, like ‘Hello, World!’
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符串 文本数据，如‘Hello, World!’
- en: Integer Numbers without decimal points, such as 1, –27, or 422
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整数 没有小数点的数字，如1、–27或422
- en: Floating-point Numbers that include a decimal point, such as 1.618
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浮点数 包含小数点的数字，如1.618
- en: What separates Processing code from standard Python code are some of its functions;
    the `size()` function, for example, is Processing-specific. In other words, it
    won’t work outside the Processing environment. The `print()` function, on the
    other hand, is a built-in element of the standard Python programming language.
    It works in Processing’s Python Mode and any other Python program.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 代码与标准 Python 代码的不同之处在于它的一些函数；例如，`size()`函数是 Processing 特有的。换句话说，它在
    Processing 环境之外无法使用。另一方面，`print()`函数是标准 Python 编程语言的内置元素。它在 Processing 的 Python
    模式和任何其他 Python 程序中都能工作。
- en: Throughout this book, I usually refer to Processing-exclusive features in the
    context of *Processing,* and standard Python features with the term *Python*.
    If this is confusing, think of them as one and the same. At this point, distinguishing
    Processing from Python isn’t crucial; you will understand the differences in time.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我通常在*Processing*的上下文中提到 Processing 特有的功能，而将标准 Python 功能称为*Python*。如果这让你感到困惑，可以把它们看作是同一个东西。此时，区分
    Processing 和 Python 并不关键；你会随着时间的推移理解其中的差异。
- en: Comments
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: 'If you want Python to ignore any part of your code, you can comment it out.
    This feature is useful for leaving notes, in plain English, to yourself or anybody
    else editing your code. Let’s add a few comments to your *hello_world* file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望 Python 忽略代码中的某部分，可以将其注释掉。这个功能对于自己或其他编辑代码的人留下便于理解的英文注释非常有用。让我们在你的*hello_world*文件中添加几个注释：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Comments come in two types: single- and multiline. As shown here, use a `#`
    character for single-line comments 1 and `''''''` (or `"""`) for multiline comments
    2.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注释分为两种类型：单行注释和多行注释。如图所示，单行注释使用`#`字符，1 多行注释使用`'''`（或`"""`）2。
- en: While working through the tasks in this book, add comments to remind yourself
    how the code works. Comments are also useful for debugging code. For instance,
    if you suspect that some lines are causing your program to fail, you can temporarily
    disable them by commenting them out.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本书任务的过程中，添加注释以提醒自己代码的工作原理。注释在调试代码时也非常有用。例如，如果你怀疑某些代码行导致程序失败，你可以通过注释掉这些行来暂时禁用它们。
- en: Whitespace
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空白字符
- en: 'Python, and by extension Processing’s Python Mode, is whitespace-sensitive.
    You need to be careful where you insert space characters or tabs. As an example,
    add a few spaces to the beginning of the `size()` line; then run the sketch:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Python 以及扩展的 Processing Python 模式，对空白字符非常敏感。你需要小心插入空格字符或制表符的位置。例如，给`size()`这一行添加一些空格，然后运行草图：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you run the sketch, the message bar turns red, and Processing displays
    an error message ([Figure 1-7](#figure1-7)). Python relies on indentation to distinguish
    blocks of code. The indented line breaks the program because Python did not encounter
    any code to define a new block for the `size()` function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行草图时，消息栏会变为红色，Processing 会显示错误信息（[图 1-7](#figure1-7)）。Python 依赖缩进来区分代码块。缩进的行会导致程序出错，因为
    Python 没有遇到任何代码来定义`size()`函数的新代码块。
- en: '![f01007](image_fi/500969c01/f01007.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![f01007](image_fi/500969c01/f01007.png)'
- en: 'Figure 1-7: A whitespace error'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-7：空白错误
- en: Correct the code by removing the problematic space characters you’ve just added.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过删除你刚刚添加的空格字符来修正代码。
- en: You’ll come to understand more about when and where to use indentation as you
    progress through these chapters. For now, though, pay careful attention to any
    space and tab characters that affect the indentation of your code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你在这些章节中的学习，你会逐渐理解什么时候以及在哪里使用缩进。但现在，注意代码中的空格和制表符字符，这些都会影响代码的缩进。
- en: Errors
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误
- en: 'Whitespace issues are not the only error type you will encounter. On occasion,
    you’re likely to miss the odd parenthesis, comma, or quotation mark, especially
    when starting out. Try removing the closing parenthesis from your `size()` function,
    like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 空格问题并不是你会遇到的唯一错误类型。偶尔你可能会漏掉某个括号、逗号或引号，特别是在刚开始时。试着从你的`size()`函数中去掉闭括号，像这样：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now run the code and observe the console output. Note the suggestion in the
    message bar ([Figure 1-8](#figure1-8)). Pretty smart, huh?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行代码并观察控制台输出。注意消息栏中的提示（[图1-8](#figure1-8)）。相当聪明吧？
- en: '![f01008](image_fi/500969c01/f01008.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![f01008](image_fi/500969c01/f01008.png)'
- en: 'Figure 1-8: The alert in the message bar (red) suggests a possible cause for
    the error that Processing encountered.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-8：消息栏中的警告（红色）提示了Processing遇到错误的可能原因。
- en: This is an example of a *syntax error*, and it’s not the first you’ll encounter.
    Just as English sentences must begin with a capital letter and end with a full
    stop, Python functions must have an opening and a closing parenthesis. When you
    have multiple arguments, you need to separate them using commas. This set of rules
    is called *syntax*. If you don’t conform to the rules, Python will be confounded
    and report an error.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个*语法错误*的例子，而这并不是你第一次遇到这种错误。就像英语句子必须以大写字母开头并以句号结尾一样，Python函数必须有一个开括号和一个闭括号。当你有多个参数时，需要用逗号将它们分隔开。这套规则被称为*语法*。如果你不遵守这些规则，Python会感到困惑并报告错误。
- en: Error messages are not always so clear or accurate, but they can provide a clue
    as to where to start searching for bugs. Copying and pasting the messages into
    a search engine can sometimes help you find a solution.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息并不总是如此清晰或准确，但它们可以为你提供一个线索，帮助你开始搜索 bug。有时，将错误信息复制并粘贴到搜索引擎中，能帮助你找到解决方案。
- en: Color
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 颜色
- en: You can describe colors in various ways in Processing. To keep things simple,
    I’ll stick with *hexadecimal* values for the first example. If you’re familiar
    with graphics software like Adobe Photoshop, Adobe Illustrator, Inkscape, or GIMP,
    you may have seen hexadecimal values in the color picker for those programs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在Processing中，你可以用多种方式描述颜色。为了简化起见，我将采用*十六进制*值作为第一个示例。如果你熟悉像Adobe Photoshop、Adobe
    Illustrator、Inkscape或GIMP这样的图形软件，你可能已经在这些程序的颜色选择器中看到过十六进制值。
- en: Processing includes its own color selector ([Figure 1-9](#figure1-9)), which
    you can access from the menu bar by selecting **Tools**▶**Color Selector**. You
    can use this color selector to mix and sample color values. The value that begins
    with a hash mark (#) is the hexadecimal; you use the **Copy** button to copy it,
    so that you can paste it into the code editor.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Processing包含了自己的颜色选择器（[图1-9](#figure1-9)），你可以通过菜单栏选择**工具**▶**颜色选择器**来访问它。你可以使用这个颜色选择器来混合和采样颜色值。以#号开头的值是十六进制值；你可以使用**复制**按钮将其复制，然后粘贴到代码编辑器中。
- en: '![f01009](image_fi/500969c01/f01009.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![f01009](image_fi/500969c01/f01009.png)'
- en: 'Figure 1-9: Processing color selector'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-9：Processing颜色选择器
- en: 'Your screen displays color pixels by mixing three primary colors—much as you
    mix red, yellow, and blue paint in art class. However, your screen relies on red,
    green, and blue primaries instead. Furthermore, because light blends color in
    an *additive* manner, pixels that combine all three primaries at full intensity
    appear as white. Conversely, a complete absence of any color results in a black
    pixel. Other colors contain varied quantities of red, green, and blue. For example,
    a bright red mixture is created as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你的屏幕通过混合三种原色显示颜色——就像你在美术课上混合红、黄、蓝颜料一样。然而，你的屏幕使用的是红、绿、蓝三种原色。此外，由于光以*加法*的方式混合颜色，当所有三种原色以最大强度结合时，像素显示为白色。相反，完全没有颜色的像素显示为黑色。其他颜色则包含了不同量的红、绿、蓝。例如，亮红色的混合如下：
- en: 100% | 0% | 0%
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 100% | 0% | 0%
- en: 'A hexadecimal color value is composed of six hexadecimal digits (`0`, `1`,
    `2`, . . . , `9`, `A`, `B`, `C`, `D`, `E`, `F`) and can be split into three pairs.
    Each pair corresponds to a primary color. Here’s the value for bright red:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制颜色值由六个十六进制数字（`0`、`1`、`2`、……、`9`、`A`、`B`、`C`、`D`、`E`、`F`）组成，并可以分为三对，每一对对应一个原色。下面是亮红色的值：
- en: '`#FF0000`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`#FF0000`'
- en: 'The `FF` represents a red quantity; the middle `00` is for green; the rightmost
    `00` is for blue. For reasons I won’t get into here, `FF` is the equivalent of
    100 percent. Also, remember that you are mixing light, so `#FFFFFF` is white,
    and `#000000` is black. Here are some other examples:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`FF` 代表红色量；中间的 `00` 是绿色；最右边的 `00` 是蓝色。由于一些原因，`FF` 相当于 100%。另外，记住你正在混合光线，所以
    `#FFFFFF` 是白色，`#000000` 是黑色。这里还有其他一些例子：'
- en: 100 percent blue `#0000FF`
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 100% 蓝色 `#0000FF`
- en: Dark green `#006600`
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 深绿色 `#006600`
- en: Dark gray `#505050`
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 深灰色 `#505050`
- en: Use the selector to experiment further and observe how the hexadecimal values
    change as you select different colors.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用选择器进一步实验，观察当你选择不同颜色时，十六进制值是如何变化的。
- en: 'The `fill()` function sets the color used to fill shapes. It accepts up to
    four arguments, depending on the color system you are using. For hexadecimal color,
    use a single argument: the six-digit value prefixed with a `#`, wrapped in quotes.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`fill()` 函数设置用于填充形状的颜色。根据你使用的颜色系统，它最多接受四个参数。对于十六进制颜色，只需使用一个参数：以 `#` 开头的六位数值，放在引号中。'
- en: 'Add the following line to the bottom of your *hello_world* sketch:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 *hello_world* 草图底部添加以下代码：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You have now set the fill color to red. To see this in effect, let’s draw a
    rectangle. The `rect()` function is used for drawing rectangles, and it takes
    four arguments:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经将填充颜色设置为红色。为了看到效果，让我们绘制一个矩形。`rect()` 函数用于绘制矩形，它接受四个参数：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first two arguments specify the location of the rectangle’s upper left corner
    ([Figure 1-10](#figure1-10)). Processing’s x-coordinates begin from the left edge
    of the display window; the y-coordinates begin from the top edge.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个参数指定矩形左上角的位置（[图 1-10](#figure1-10)）。Processing 的 x 坐标从显示窗口的左边缘开始；y 坐标从顶部边缘开始。
- en: '![f01010](image_fi/500969c01/f01010.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![f01010](image_fi/500969c01/f01010.png)'
- en: 'Figure 1-10: Processing’s coordinate system'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-10：Processing 的坐标系统
- en: 'The x-y coordinate for the upper left corner of the display window is (0, 0),
    and the lower right is (500, 500). So to move the rectangle down, increase the
    y-coordinate value. Add a new rectangle line to your *hello_world* sketch:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 显示窗口的左上角坐标是 (0, 0)，右下角是 (500, 500)。因此，要将矩形向下移动，增加 y 坐标值。在你的 *hello_world* 草图中添加一条新的矩形代码：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run the sketch to confirm that the output matches [Figure 1-11](#figure1-11).
    Experiment with the `rect()` arguments to affect the rectangle’s size and position.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图，确认输出与 [图 1-11](#figure1-11) 匹配。尝试修改 `rect()` 的参数，调整矩形的大小和位置。
- en: '![f01011](image_fi/500969c01/f01011.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![f01011](image_fi/500969c01/f01011.png)'
- en: 'Figure 1-11: `rect(100, 150, 200, 300)`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-11：`rect(100, 150, 200, 300)`
- en: You now should be familiar with Processing’s coordinate system. The `rect()`
    is one of many drawing functions; you’ll be introduced to a few more shortly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该熟悉了 Processing 的坐标系统。`rect()` 是许多绘图函数之一；稍后你将了解更多。
- en: In this section, you’ve also learned to define color using hexadecimal values
    that describe different quantities of red, green, and blue light. And you now
    can use a color picker, like the one included with Processing, to mix and sample
    any values you require. You’ll see other systems for defining color in Processing,
    but for most of this book, you’ll use hexadecimal.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你还学会了使用十六进制值定义颜色，这些值描述了不同量的红、绿、蓝光。你现在可以使用像 Processing 自带的颜色选择器来混合和采样任何你需要的值。你会看到在
    Processing 中还有其他定义颜色的系统，但在本书的大部分内容中，你将使用十六进制值。
- en: Fills and Strokes
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 填充和描边
- en: 'When you write a `fill()` line, every shape thereafter is filled in with the
    color you specify. That color won’t change until Processing encounters the next
    `fill()` line. In this way, Processing is like painting: you grab a brush and
    dip it in paint, and then everything you paint is influenced by the brush and
    color you last selected. When you want to paint in a different style or color,
    you change out your brush or dip it in a different pot. If you want to disable
    the fill altogether, use `noFill()`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一条 `fill()` 代码时，之后的每个形状都会使用你指定的颜色进行填充。直到 Processing 遇到下一条 `fill()` 代码，这个颜色才会改变。这样，Processing
    就像是画画：你拿起画笔，蘸上颜料，然后你画的每一笔都会受到上次选择的画笔和颜色的影响。当你想以不同的风格或颜色画画时，你更换画笔或蘸取不同的颜料。如果你想完全禁用填充，可以使用
    `noFill()`。
- en: 'Add the following code to the end of your *hello_world* file to draw a smaller
    red rectangle, an orange square, and a square with no fill:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 *hello_world* 文件末尾添加以下代码，绘制一个较小的红色矩形、一个橙色正方形以及一个没有填充的正方形：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For a square, you have two options: use a `rect()` 1 with matching width and
    height (third and fourth) arguments. Or, use the `square()` 2 function, which
    takes three arguments: x, y, and extent.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个正方形，你有两个选择：使用 `rect()` 1 函数，并传入匹配的宽度和高度（第三个和第四个）参数。或者，使用 `square()` 2 函数，它需要三个参数：x、y
    和范围。
- en: Processing interprets lines of code from top to bottom. As a result, shapes
    at the bottom of your code appear at the top of the visual “stack.” So the previous
    code produces the shapes in [Figure 1-12](#figure1-12).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 会从上到下解释代码行。因此，代码底部的形状会出现在视觉“堆栈”的顶部。所以前面的代码会生成[图 1-12](#figure1-12)
    中的形状。
- en: '![f01012](image_fi/500969c01/f01012.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![f01012](image_fi/500969c01/f01012.png)'
- en: 'Figure 1-12: The no-fill square—the last line of your code—is the topmost shape.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-12：没有填充的正方形——代码的最后一行是最上面的形状。
- en: '*Stroke* is another term for *outline*, and you’re likely to use the following
    three stroke functions: `stroke()` to change the color, `strokeWeight()` to change
    the width, and `noStroke()` to disable the stroke altogether. Like `fill()` and
    `noFill()`, the stroke functions affect everything below them.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*描边* 是 *轮廓* 的另一种说法，你可能会使用以下三种描边函数：`stroke()` 用于更改颜色，`strokeWeight()` 用于更改宽度，`noStroke()`
    用于完全禁用描边。与 `fill()` 和 `noFill()` 类似，描边函数会影响它们下面的所有内容。'
- en: 'For a white stroke, 3 pixels in width, insert the following lines above the
    shape code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得 3 像素宽的白色描边，可以在形状代码之前插入以下代码：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `stroke()` line affects every shape that follows it. [Figure 1-13](#figure1-13)
    shows how all of the shapes now have white strokes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`stroke()` 行会影响它之后的每个形状。[图 1-13](#figure1-13) 显示了现在所有形状都有白色描边。'
- en: '![f01013](image_fi/500969c01/f01013.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![f01013](image_fi/500969c01/f01013.png)'
- en: 'Figure 1-13: Adding white strokes'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-13：添加白色描边
- en: For thicker strokes, you may want to specify whether the corners and tips are
    rounded or sharp. For more information, consult the relevant Processing.py reference
    entries for `strokeCap()` and `strokeJoin()`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更粗的描边，你可能需要指定角落和尖端是圆形的还是尖锐的。有关更多信息，请查阅相关的 Processing.py 参考条目，了解 `strokeCap()`
    和 `strokeJoin()`。
- en: Background Color
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 背景颜色
- en: 'To change the background color, use the `background()` function. Add a background
    line to the end of your sketch:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改背景颜色，使用 `background()` 函数。在你的代码末尾添加一个背景行：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the sketch and note how everything has disappeared; the entire display
    window is now a flat shade of blue. This is because `background(''#004477'')`
    draws over everything before it, which will be useful when you start working with
    animation. For now, move that line to the top of your code so you can see the
    shapes again ([Figure 1-14](#figure1-14)):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码并注意到所有内容都消失了；整个显示窗口现在是一个平坦的蓝色。这是因为 `background('#004477')` 会覆盖它之前的所有内容，当你开始处理动画时，这会非常有用。现在，将该行移动到代码顶部，这样你可以再次看到形状
    ([图 1-14](#figure1-14))：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the background function can also accept an image as an argument (I’ll
    introduce images in Chapter 2).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`background` 函数也可以接受图像作为参数（我将在第二章中介绍图像）。
- en: '![f01014](image_fi/500969c01/f01014.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![f01014](image_fi/500969c01/f01014.png)'
- en: 'Figure 1-14: Adding a background color'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-14：添加背景颜色
- en: Color Modes
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色模式
- en: 'I’ll use hexadecimal color values for the rest of the chapter, but here’s a
    quick introduction to other color modes, because at some point, you may need to
    express colors in something other than hexadecimal. For example, say you want
    to write code that darkens a bright red fill. First, you will recall that this
    is a shade of bright red:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章中使用十六进制颜色值，但这里先简单介绍其他颜色模式，因为在某些情况下，你可能需要使用非十六进制的颜色表示。例如，假设你想写一个代码来加深鲜红色的填充。首先，你会回忆起这是一种鲜红色：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can also represent this color as the following in RGB:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将这个颜色表示为 RGB 格式：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this arrangement, each red/green/blue value is comma-separated. As you might
    have already deduced, `255` is equivalent to `FF` (which itself is equivalent
    to 100 percent). To make the red half as bright, you can subtract `127` from `255`.
    However, trying to subtract `127` from `FF` is tricky because you’re dealing with
    a mix of hexadecimal and decimal numbers. In this instance, it’s easier to stick
    with decimal values (255 – 127 = 128).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种安排中，每个红/绿/蓝值是以逗号分隔的。正如你可能已经推断出来的，`255` 等于 `FF`（它本身等于 100%）。为了使红色变得一半亮度，你可以从
    `255` 中减去 `127`。然而，试图从 `FF` 中减去 `127` 会有点复杂，因为你在处理十六进制和十进制数字的混合。在这种情况下，使用十进制值更容易（255
    – 127 = 128）。
- en: 'To use the `fill(255, 0, 0)` cits `colorMode()` set to `RGB`. You don’t need
    to specify this, though, as it’s the default mode. Here’s how it works: if Processing
    detects a single argument in quotes (like `''#FF0000''`), it interprets it as
    hexadecimal, but if you provide three arguments, it automatically knows that you
    are using the system of 0 to 255.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fill(255, 0, 0)`时，`colorMode()`设置为`RGB`。不过，你不需要显式指定这个，因为它是默认模式。它的工作原理是：如果Processing检测到一个带引号的单一参数（例如`'#FF0000'`），它会将其解读为十六进制，但如果你提供三个参数，它会自动识别你正在使用0到255的系统。
- en: 'However, you can use another mode: HSB. Once set to `HSB` mode, the three `fill()`
    arguments represent *hue*, *saturation*, and *brightness*, respectively. To better
    understand how those variables affect color, let’s take a look at the color picker
    of GIMP, an open source image editor ([Figure 1-15](#figure1-15)).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以使用另一种模式：HSB。一旦设置为`HSB`模式，三个`fill()`参数分别表示*色相*、*饱和度*和*亮度*。为了更好地理解这些变量如何影响颜色，我们来看一下GIMP这款开源图像编辑器的颜色选择器（[图1-15](#figure1-15)）。
- en: Rotating the large triangle adjusts the H value between 0 and 360 degrees; the
    H (hue) field corresponds to the white line at the triangle’s lower right tip.
    You move the small white circle (inside the triangle) to adjust the S (saturation)
    and V (value) fields. *Value* and *brightness* are interchangeable terms in this
    context, so the V corresponds to the B in HSB.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转大三角形调整色相值H在0到360度之间；H（色相）字段对应三角形右下角的白色线条。你可以移动三角形内部的小白圆圈来调整S（饱和度）和V（亮度）字段。*亮度*和*值*在这个上下文中是可以互换的术语，因此V对应于HSB中的B。
- en: '![f01015](image_fi/500969c01/f01015.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![f01015](image_fi/500969c01/f01015.png)'
- en: 'Figure 1-15: Hue: 330 degrees; saturation: 90 percent; value/brightness: 80
    percent'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-15：色相：330度；饱和度：90%；亮度/值：80%
- en: 'If you have GIMP installed, or software with a similar color picker, I encourage
    you to experiment with it. To mimic the GIMP scheme in Processing, set the color
    mode accordingly:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你安装了GIMP，或者有类似的颜色选择器软件，我鼓励你进行实验。为了在Processing中模仿GIMP的配色方案，可以相应地设置颜色模式：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `HSB` represents the mode, `360` represents the range of degrees for hue,
    and the two `100` arguments represent a range of 0 to 100 percent for saturation
    and brightness. You would now write a red fill as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`HSB`代表模式，`360`表示色相的度数范围，两个`100`参数表示饱和度和亮度的0到100百分比范围。现在你可以这样写一个红色填充：'
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is because bright red lies at 0 degrees of rotation on the hue ring (which
    begins at “East” in the GIMP mixer) and has a saturation and brightness of 100
    percent ([Figure 1-16](#figure1-16)).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为鲜红色位于色相环的0度位置（从GIMP调色器中的“东”开始），其饱和度和亮度为100%（[图1-16](#figure1-16)）。
- en: '![f01016](image_fi/500969c01/f01016.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![f01016](image_fi/500969c01/f01016.png)'
- en: 'Figure 1-16: Hue: 0 degrees; saturation: 100 percent; value/brightness: 100
    percent'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-16：色相：0度；饱和度：100%；亮度/值：100%
- en: In HSB mode, shifting along the color spectrum—from red to orange to yellow
    to green, and so on—is a simple matter of adding to or subtracting from the H
    value. Attempting the same in RGB mode is not so easy, as you need to adjust the
    proportions of each primary color.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在HSB模式下，在色谱上移动——从红色到橙色，再到黄色、绿色，依此类推——只需要对H值进行加减。尝试在RGB模式下做同样的事情就不那么容易，因为你需要调整每种原色的比例。
- en: The chapters to come will cover even more on color. Consult the relevant Processing.py
    reference entries for `colorMode()` and `fill()` if you need more detail.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节将进一步介绍颜色相关的内容。如果你需要更多细节，请参考`colorMode()`和`fill()`的相关Processing.py参考文档。
- en: 2D Primitives
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2D 基本图形
- en: 'Let’s move on to drawing basic shapes. Begin a new sketch (**File**▶**New**)
    and save it as *primitives_2d* (**File**▶**Save As**). Add this code to set things
    up before proceeding:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们开始绘制基本形状。新建一个草图（**文件**▶**新建**）并将其保存为*primitives_2d*（**文件**▶**另存为**）。在继续之前，添加以下代码来进行设置：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now when you run the sketch, thanks to `background('#004477')`, an empty blue
    display window appears. Any shapes that you draw will have no fill and a white
    stroke of 3 pixels.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行草图时，由于`background('#004477')`，会出现一个空白的蓝色显示窗口。你绘制的任何形状将没有填充，边框是3像素的白色。
- en: 'Next, draw three points by using the `point()` function ([Figure 1-17](#figure1-17)):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过`point()`函数绘制三个点（[图1-17](#figure1-17)）：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `point()` function accepts two arguments, which represent the x- and y-coordinates.
    The active `strokeWeight()` determines the size of the points.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`point()`函数接受两个参数，分别表示x和y坐标。当前的`strokeWeight()`决定了点的大小。'
- en: '![f01017](image_fi/500969c01/f01017.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![f01017](image_fi/500969c01/f01017.png)'
- en: 'Figure 1-17: Three points drawn with the `point()` function'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-17：通过`point()`函数绘制的三个点
- en: What follows are descriptions for several drawing functions, along with code
    to add to your working sketch. Experiment with the arguments to see how the finished
    version ([Figure 1-18](#figure1-18)) responds.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是几个绘图函数的描述，以及要添加到你的工作草图中的代码。尝试调整参数，看看完成后的效果如何（见[图1-18](#figure1-18)）。
- en: '![f01018](image_fi/500969c01/f01018.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![f01018](image_fi/500969c01/f01018.png)'
- en: 'Figure 1-18: An assortment of 2D primitives'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-18：各种2D基本图形
- en: triangle()
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: triangle()
- en: 'The `triangle()` function draws a triangle. The six arguments represent three
    x-y coordinate pairs. I have grouped each x-y pair by removing the space character
    after every other argument so it’s easier to read:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`triangle()`函数绘制一个三角形。六个参数表示三对x-y坐标。我将每一对x-y坐标通过去掉每两个参数之间的空格进行了分组，这样更容易阅读：'
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Python is not sensitive to whitespace between arguments, so if you find it helpful
    to format your code in a similar fashion, feel free to do so.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Python对参数之间的空白不敏感，所以如果你发现将代码格式化成这种方式对你有帮助，可以随意使用这种格式。
- en: ellipse()
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ellipse()
- en: 'The `ellipse()` function draws an ellipse. The first pair of arguments represents
    an x-y coordinate that marks the center of the ellipse; the second pair of arguments
    represents the ellipse’s width and height:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`ellipse()`函数绘制一个椭圆。第一个参数对表示椭圆的中心点坐标，第二对参数表示椭圆的宽度和高度：'
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For a circle, you can use the `ellipse()` function with matching width and
    height (third and fourth) arguments. Alternatively, you can use the `circle()`
    function, which takes three arguments: x, y, and diameter.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于圆形，你可以使用`ellipse()`函数，传入相等的宽度和高度（第三个和第四个）参数。或者，你可以使用`circle()`函数，它需要三个参数：x，y和直径。
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `circle()` and `square()` functions are relatively new to Processing, so
    you may find that many of the examples (**File**▶**Examples**) and online code
    rely on only `ellipse()` and `rect()`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`circle()`和`square()`函数在Processing中是相对较新的，因此你可能会发现很多示例（**文件**▶**示例**）和在线代码仅使用`ellipse()`和`rect()`。'
- en: quad()
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: quad()
- en: 'The `quad()` function draws a *quadrilateral* (a four-sided polygon). Essentially,
    it’s like a triangle function with an extra point, and its eight arguments represent
    four x-y coordinate pairs:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`quad()`函数绘制一个*四边形*（四边形）。本质上，它就像一个三角形函数，只是多了一个点，八个参数表示四对x-y坐标：'
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: line()
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: line()
- en: 'The `line()` function draws a straight line between two points. The first pair
    of arguments represents the starting x-y coordinates, and the second pair, the
    ending x-y coordinates:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`line()`函数绘制一条直线，连接两个点。第一对参数表示起始的x-y坐标，第二对表示结束的x-y坐标：'
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As with points and shapes, the width of a line is affected by any preceding
    `strokeWeight()` function.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 和点和形状一样，线条的宽度会受到前面任何`strokeWeight()`函数的影响。
- en: The 2D primitive functions provide an easy way to draw shapes in the display
    window. There’s one more shape function to review, `arc()`, but it’s a bit more
    involved than the other shapes. Variables and arithmetic operators will prove
    useful for drawing arcs, so I’ll cover those first. Before moving on, though,
    here’s a quick challenge to practice what you’ve learned so far.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 2D基本图形函数提供了一种简便的方法来在显示窗口中绘制图形。还有一个图形函数需要复习，那就是`arc()`，但是它比其他图形函数稍微复杂一些。变量和算术运算符对于绘制弧形将非常有用，因此我将先介绍这些内容。不过，在继续之前，这里有一个小挑战，帮助你巩固所学的内容。
- en: 'Challenge #1: Rainbow Task'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战任务#1：彩虹任务
- en: 'Begin a new sketch (**File**▶**New**) and save it as *rainbow* (**File**▶**Save
    As**). Add this code to get started:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个新的草图（**文件**▶**新建**）并将其保存为*rainbow*（**文件**▶**另存为**）。添加以下代码来开始：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Using what you’ve learned so far, complete the rainbow in [Figure 1-19](#figure1-19).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你迄今为止学到的内容，完成[图1-19](#figure1-19)中的彩虹。
- en: 'Clue: think about how you can overlap shapes to mask others. If you need help,
    you can access the solution at [https://github.com/tabreturn/processing.py-book/tree/master/chapter-01-hello,world!/rainbow/](https://github.com/tabreturn/processing.py-book/tree/master/chapter-01-hello,world!/rainbow/).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：考虑如何重叠图形来遮盖其他图形。如果需要帮助，可以访问解决方案：[https://github.com/tabreturn/processing.py-book/tree/master/chapter-01-hello,world!/rainbow/](https://github.com/tabreturn/processing.py-book/tree/master/chapter-01-hello,world!/rainbow/)。
- en: '![f01019](image_fi/500969c01/f01019.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![f01019](image_fi/500969c01/f01019.png)'
- en: 'Figure 1-19: Recreate this rainbow.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-19：重新创建这个彩虹。
- en: Variables
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: '*Variables* are placeholders for information—much like when you use letters
    in algebra to represent a value. In fact, Python variables look and behave quite
    similarly.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量*是信息的占位符——就像你在代数中使用字母表示一个值一样。事实上，Python 变量的外观和行为非常相似。'
- en: 'Begin a new sketch and save it as *variables*. To keep things simple, you’ll
    print values to the console area. Add the following code to set up the sketch
    and print its width and height (in pixels):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 开始一个新的草图并将其保存为 *variables*。为了简化操作，你将把值打印到控制台区域。添加以下代码来设置草图并打印其宽度和高度（以像素为单位）：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you run the sketch, the display window’s width and height should be printed
    to the console, as shown in [Figure 1-20](#figure1-20).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行草图，显示窗口的宽度和高度应该会被打印到控制台，如[图 1-20](#figure1-20)所示。
- en: But notice that you never explicitly defined `width` or `height`. Processing
    automatically assigned the width and height of the display window to these two
    variables. From this, you can establish that `width` and `height` are variables
    for which Processing maintains the values. Predefined variables like these are
    called *system variables*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，你从未明确地定义 `width` 或 `height`。Processing 会自动将显示窗口的宽度和高度赋值给这两个变量。由此可知，`width`
    和 `height` 是由 Processing 维护其值的变量。这些预定义的变量称为 *系统变量*。
- en: 'However, you are not limited to system variables; you can also define your
    own. When declaring new variables, assign them a value by using an equal sign
    (`=`), which is called the *assignment operator*. Try this out with a new variable
    named `x`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你并不局限于使用系统变量；你也可以定义自己的变量。声明新变量时，通过使用等号 (`=`) 为其赋值，这个操作符被称为 *赋值运算符*。尝试用一个名为
    `x` 的新变量来实现这一点：
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![f01020](image_fi/500969c01/f01020.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![f01020](image_fi/500969c01/f01020.png)'
- en: 'Figure 1-20: Printing variables to the console'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-20：将变量打印到控制台
- en: The variable `x` is equal to 10, so the `print()` function displays a `10` in
    the console.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `x` 等于 10，因此 `print()` 函数在控制台显示 `10`。
- en: 'You can name your variables whatever you like, provided that the name contains
    only alphanumeric and underscore characters, doesn’t begin with a number, and
    doesn’t clash with any reserved keywords or variables (like `width`). For example,
    the following shows several possible variable names (the comments indicate which
    are correct):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随意命名你的变量，只要名称中只包含字母数字字符和下划线，不以数字开头，并且不与任何保留的关键字或变量（如 `width`）冲突。例如，以下展示了几个可能的变量名（注释标明哪些是正确的）：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Whether you should name a multiword variable using *camelCase*, underscores,
    or another convention is a matter of style (and vociferous debate), but it’s good
    to decide on a naming convention and stick to it, as you’ll make extensive use
    of variables in Processing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 是否应该使用 *camelCase*、下划线或其他命名规则来命名多单词变量，是一种风格问题（也是争论不休的话题），但最好决定一个命名约定并坚持使用，因为你将在
    Processing 中大量使用变量。
- en: 'Now, add three more variables to your script for use as arguments in a `rect()`
    function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，向你的脚本中添加三个变量，用作 `rect()` 函数的参数：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `y` variable indicates the y-coordinate; `w` indicates the width; and `h`
    indicates the height value for the `rect()` function. Notice that the `h` value
    is equal to the `w` value (of 100). You’ve already defined `x` as equal to 10\.
    Run the sketch to confirm that it displays a white square positioned near the
    upper left corner of the display window ([Figure 1-21](#figure1-21)).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`y` 变量表示 y 坐标；`w` 表示宽度；`h` 表示 `rect()` 函数的高度值。请注意，`h` 值等于 `w` 值（即 100）。你已经将
    `x` 定义为 10。运行草图确认它在显示窗口的左上角附近显示了一个白色的正方形（见[图 1-21](#figure1-21)）。'
- en: '![f01021](image_fi/500969c01/f01021.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![f01021](image_fi/500969c01/f01021.png)'
- en: 'Figure 1-21: A square using variables as coordinates'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-21：使用变量作为坐标的正方形
- en: Experiment further on your own with shapes and variables. In the next section,
    you’ll learn to use variables to perform mathematical calculations.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 自己进一步实验形状和变量。在下一节中，你将学习如何使用变量进行数学计算。
- en: Arithmetic Operators
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符
- en: '*Arithmetic operators* perform arithmetic operations on *operands*; this is
    far simpler than it probably sounds. For instance, in the expression 1 + 3, the
    plus sign is the operator, and the numbers 1 and 3 are the operands. To better
    understand how this all works in Python, let’s go through some examples.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*算术运算符*对*操作数*执行算术运算；这比听起来要简单得多。例如，在表达式 1 + 3 中，"+" 是运算符，而数字 1 和 3 是操作数。为了更好地理解
    Python 中这一切是如何工作的，我们来看一些示例。'
- en: Basic Operations
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本操作
- en: 'Add the following line to the end of your *variables* sketch to calculate what
    variable `x` plus 2 is equal to:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的*变量*草图末尾添加以下一行，计算变量`x`加2的结果：
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Run the sketch and check the bottom line of the console output. I’m guessing
    the code did exactly what you expected. Earlier in the chapter, you assigned a
    value of 10 to variable `x`, and 10 + 2 is equal to 12, which is what you will
    see in your console.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图并检查控制台输出的最后一行。我猜测代码会做你预期的事情。在本章的早些时候，你为变量`x`分配了一个值10，而10 + 2等于12，这就是你在控制台上看到的结果。
- en: 'You can also subtract (see the comments for the result):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以进行减法运算（请参阅注释以查看结果）：
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Use the `*` operator for multiplication:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`*`运算符进行乘法：
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now try this line, but before running it, see if you can predict the result:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试这一行，但在运行之前，看看你是否能预测结果：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The console displays a `7` and not a `9` because multiplication occurs before
    addition. Certain operators take precedence over others. Remember PEMDAS? It’s
    an acronym to help you recall the *order of operations*, which is parentheses
    first, then exponents, then multiplication/division, then addition/subtraction.
    (Some people may be more familiar with the acronyms BEDMAS or BODMAS, which use
    the terms *brackets* for *parentheses,* and *of* or *order* to indicate exponents.)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台显示的是`7`而不是`9`，因为乘法先于加法发生。某些运算符的优先级高于其他运算符。还记得PEMDAS吗？它是一个助记符，帮助你记住*运算顺序*，即首先是括号，然后是指数运算，然后是乘法/除法，最后是加法/减法。（有些人可能更熟悉BEDMAS或BODMAS，它们使用*括号*替代*括号*，以及*of*或*order*来表示指数运算。）
- en: 'If you want the addition to happen first, use parentheses:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想先进行加法运算，请使用括号：
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For division, use a forward slash (`/`):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 对于除法，使用正斜杠(`/`)：
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Be aware that dividing two integers always produces an integer result (integers
    are whole numbers, as opposed to those with a decimal point). For example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，除以两个整数总是产生整数结果（整数是没有小数点的整数）。例如：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Processing discards any decimal digits, effectively rounding down the result.
    Note, however, that this is Python 2 behavior. At the time of this writing, Processing’s
    Python Mode uses Python 2.7\. If you ever find yourself writing Python 3 code,
    the result will be 1.5.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Processing会丢弃任何小数位，实质上将结果向下取整。然而，需要注意的是，这种行为是Python 2的特性。在本文写作时，Processing的Python模式使用的是Python
    2.7。如果你写的是Python 3代码，结果将是1.5。
- en: 'For floating-point division in Python 2, define at least one of your operands
    by using a decimal point:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 2中进行浮点数除法时，定义至少一个操作数时使用小数点：
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This line displays a 1.5 in Python versions 2 and 3\. This book avoids any Python
    code that isn’t compatible with Python 3\. Rest assured, you can apply your newly
    acquired coding skills in Python 2 and 3 development. Should Processing switch
    to Python 3, your code will still run fine.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行在Python 2和3版本中显示1.5。 本书避免使用任何与Python 3不兼容的Python代码。请放心，你可以将你新获得的编码技能应用于Python
    2和3的开发。如果Processing切换到Python 3，你的代码仍然可以正常运行。
- en: Of course, division-by-zero operations will result in errors ([Figure 1-22](#figure1-22)).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除零操作将导致错误（[图1-22](#figure1-22)）。
- en: '![f01022](image_fi/500969c01/f01022.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![f01022](image_fi/500969c01/f01022.png)'
- en: 'Figure 1-22: Division-by-zero error'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-22：除零错误
- en: Processing uses other arithmetic operators (for floor division and exponents)
    that aren’t necessary to review here. The modulo operator, however, warrants a
    brief introduction.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Processing使用其他算术运算符（如地板除法和指数运算），这些在这里没有必要复习。然而，模运算符值得简单介绍。
- en: Modulo Operator
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模运算符
- en: The *modulo operator* calculates the remainder of a division operation and is
    expressed as a percentage sign (`%`). Take 5 divided by 2 as an example. You could
    say the answer is 2.5, or you could say the answer is 2 remainder 1, because 2
    “goes into” 5 twice with 1 left over.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*模运算符*计算除法运算的余数，并用百分号符号（`%`）表示。以5除以2为例。你可以说答案是2.5，或者你可以说答案是2余1，因为2“可以”除5两次，剩下1。'
- en: 'The modulo operator performs the latter operation and provides the remainder.
    Here’s some code contrasting division and modulus (as before, the comments show
    the output):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 模运算符执行后者操作并提供余数。下面是对比除法和取模运算的一些代码（如之前所示，注释中显示了输出结果）：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It may not be evident why this operator is useful. However, many important
    algorithms, such as those used in cryptography, use modular arithmetic. For now,
    consider that modulo operations resulting in a `0` indicate that numbers divide
    exactly. Among other uses, this is handy for establishing whether a number is
    odd or even:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 可能现在还不明显为什么这个运算符很有用。然而，许多重要的算法，如加密算法，使用模运算。暂时考虑一下，模运算结果为`0`表示数字整除得出精确的结果。除此之外，这对于判断一个数字是奇数还是偶数非常有用：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You’ll use the modulo operator in the chapters to come.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将使用取模运算符。
- en: Arcs
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弧
- en: 'Now that I’ve covered variables and some basic math, I can introduce the `arc()`
    function, which is used to draw elliptical arcs. Let’s look at a few examples
    to see how this one works. Create a new sketch and save it as *disk_space_analyzer*.
    Add the following setup code that will define some visual parameters to get started:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经介绍了变量和一些基础数学内容，接下来可以介绍`arc()`函数，它用于绘制椭圆弧。让我们通过几个示例来看一下它是如何工作的。创建一个新的草图并保存为*disk_space_analyzer*。添加以下设置代码，定义一些视觉参数以便开始：
- en: '[PRE37]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `arc()` function takes the following arguments, expanded across multiple
    lines here for easier comprehension (recall that Python is not sensitive to whitespace
    between function arguments):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`arc()`函数接受以下参数，这里将它们分多行显示以便更容易理解（请记住，Python对函数参数之间的空白不敏感）：'
- en: '[PRE38]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add an arc to your sketch by using a `start_angle` of `0` and `end_angle` of
    `2`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`start_angle`为`0`，`end_angle`为`2`，在草图中添加一个弧：
- en: '[PRE39]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The green overlay in [Figure 1-23](#figure1-23) helps illustrate how the arguments
    work. Processing draws the arc along the perimeter of an invisible ellipse centered
    in the display window. The center of this ellipse has an x-y coordinate of `width/2`,
    `height/2`; it’s 200 pixels wide and 200 pixels high. An angle of `0` is positioned
    at East, which opens clockwise to an angle of `2`, which looks more like around
    115 degrees of rotation.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-23](#figure1-23)中的绿色叠加帮助说明了参数是如何工作的。Processing会沿着一个不可见椭圆的边界绘制弧线，该椭圆的中心位于显示窗口的中间，x-y坐标为`width/2`，`height/2`；它的宽度为200像素，高度为200像素。角度`0`位于东面，顺时针打开到角度`2`，看起来大约是115度的旋转角度。'
- en: 'The reason for this large angle is that Processing uses *radians* and not degrees
    to measure angles; 1 radian is equal to roughly 57.3 degrees. Why use radians?
    Radians, a standard unit of angular measure used in many areas of mathematics,
    provide more natural and elegant formulas for circular motion. Think about this:
    why are there 360 degrees in a full circle? Why not 300 or 100, or even a million
    degrees? While I’m on the topic, why are there 60 minutes in an hour? Or 24 hours
    in a day? Much of this has to do with ancient counting systems.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个大角度的原因是Processing使用*弧度*而非度数来衡量角度；1弧度大约等于57.3度。为什么要使用弧度呢？弧度作为一种标准的角度单位，在许多数学领域中使用，它为圆周运动提供了更自然和优雅的公式。想一想：为什么完整的圆是360度？为什么不是300度、100度，甚至是百万度？顺便提一下，为什么一小时有60分钟？一天有24小时？这些都与古老的计数系统有关。
- en: '![f01023](image_fi/500969c01/f01023.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![f01023](image_fi/500969c01/f01023.png)'
- en: 'Figure 1-23: An arc with a start angle value of 0 and end angle of 2'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-23：起始角度为0，结束角度为2的弧
- en: Rather than dividing a circle into an arbitrary number of slices (like 360),
    the radian system is based on a proportional measurement involving a circle’s
    *radius*. [Figure 1-24](#figure1-24) illustrates how radians are defined. Beginning
    with the left graphic, take the radius of any circle; create an arc of that same
    length; then measure the angle formed between the tips of the arc and the center
    of the circle to derive one radian.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与将一个圆分割成任意数量的切片（比如360度）不同，弧度系统基于与圆的*半径*相关的比例度量。[图1-24](#figure1-24)展示了弧度是如何定义的。从左边的图示开始，取任何圆的半径；创建一个相同长度的弧；然后测量弧的两端和圆心之间的角度，从而得出一个弧度。
- en: '![f01024](image_fi/500969c01/f01024.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![f01024](image_fi/500969c01/f01024.png)'
- en: 'Figure 1-24: Defining a radian'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-24：定义弧度
- en: If 1 radian is equal to approximately 57.3 degrees, 2 radians equal 114.6 degrees.
    This makes 180 degrees equivalent to roughly 3.142 radians ([Figure 1-25](#figure1-25)).
    Do you recognize that number? Yep, it’s pi!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果1弧度大约等于57.3度，那么2弧度等于114.6度。这使得180度大致等于3.142弧度（[图1-25](#figure1-25)）。你认识这个数字吗？没错，它就是圆周率π！
- en: '![f01025](image_fi/500969c01/f01025.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![f01025](image_fi/500969c01/f01025.png)'
- en: 'Figure 1-25: Measuring the number of radians in a half- and full circle'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-25：测量半圆和圆周的弧度数量
- en: Processing provides the `degrees()` and `radians()` functions for converting
    between the systems, but you should be fine working in radians if you can remember
    a few key measurements. For starters, 0 degrees is equal to 0 radians, and 180
    degrees is equal to *π* radians. Therefore, 360 degrees is equal to 2π radians.
    In Processing, you can use the system variable `PI` instead of writing a lengthy
    decimal.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Processing提供了`degrees()`和`radians()`函数，用于在两种单位之间进行转换，但如果你能记住一些关键的度量单位，使用弧度应该不会有问题。首先，0度等于0弧度，180度等于*π*弧度。因此，360度等于2π弧度。在Processing中，你可以使用系统变量`PI`来代替写出冗长的小数。
- en: 'Add the following code to draw a half-circle and a full circle using `arc()`
    functions:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码，使用`arc()`函数绘制半圆和完整圆：
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Run the sketch. The first new arc begins at `0` and ends at `PI`, resulting
    in a half-circle; the second outermost and largest arc has an end angle of `PI*2`,
    and therefore, it appears as a complete circle.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 运行草图。第一个新弧形从`0`开始，结束于`PI`，形成半圆；第二个最外层、最大的弧形结束角度为`PI*2`，因此它呈现为一个完整的圆。
- en: 'If you want to close an arc, so as to form a “slice,” add an additional `PIE`
    argument. Add the following line to test this out:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想关闭一个弧形，使其形成“切片”，可以添加一个额外的`PIE`参数。添加以下代码来测试：
- en: '[PRE41]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The arc spans from 3.4 radians (around 10 o’clock) to ~4.7 radians (12 o’clock).
    [Figure 1-26](#figure1-26) depicts the final result. You can identify the most
    recent arc by its slice shape.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 该弧形从3.4弧度（大约10点钟方向）延伸到约4.7弧度（12点钟方向）。[图1-26](#figure1-26)展示了最终结果。你可以通过其切片形状识别出最新的弧形。
- en: '![f01026](image_fi/500969c01/f01026.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![f01026](image_fi/500969c01/f01026.png)'
- en: 'Figure 1-26: Here are four arcs, and one of them is a complete circle. The
    slice-like arc (upper left) uses the `PIE` argument.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-26：这里有四个弧形，其中一个是完整的圆。切片状的弧形（左上）使用了`PIE`参数。
- en: 'Challenge #2: Disk Usage Analyzer'
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '挑战 #2：磁盘使用分析器'
- en: Now for a final challenge before moving on to Chapter 2. A *disk usage analyzer*
    presents a graphical representation of a disk drive’s contents. The Linux GNOME
    Disk Usage Analyzer (also known as *Baobab*) is one example of such software,
    and its charts make good use of arcs.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是进入第二章之前的最后一个挑战。*磁盘使用分析器*展示了磁盘驱动器内容的图形表示。Linux GNOME磁盘使用分析器（也被称为*Baobab*）就是这种软件的一个例子，其图表很好地利用了弧形。
- en: Recreate the ring chart graphic in [Figure 1-27](#figure1-27) by using what
    you have learned thus far. Begin by commenting out your existing arc lines, and
    then continue to work in the same sketch file. (The text and number labels have
    been added to assist you with calculations; do not add them to your recreation.)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用到目前为止学到的知识，重新创建[图1-27](#figure1-27)中的环形图形。首先将现有的弧线注释掉，然后继续在同一个草图文件中工作。（文本和数字标签已经添加，以帮助你进行计算；在重新创建时不要添加它们。）
- en: '![f01027](image_fi/500969c01/f01027.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![f01027](image_fi/500969c01/f01027.png)'
- en: 'Figure 1-27: Disk usage analyzer chart'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-27：磁盘使用分析器图表
- en: If you need help, remember you can access all of the solutions to the challenges
    at [https://github.com/tabreturn/processing.py-book/](https://github.com/tabreturn/processing.py-book/).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要帮助，记得可以访问[https://github.com/tabreturn/processing.py-book/](https://github.com/tabreturn/processing.py-book/)查看所有挑战的解决方案。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: You now have Python Mode for Processing up and running. You also know how to
    set up a new sketch, set the size of your display window, and apply a background
    color. You’ve learned to display messages like ‘Hello, World!’ in the console
    and draw shapes using 2D primitive functions. You’ve also learned about color
    and how to define the color of your strokes and fills in hexadecimal, or using
    RGB and HSB color modes. In addition, you should understand how to use radians
    to measure angles and work with the `arc()` function.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功运行了Python模式的Processing。你也学会了如何设置新的草图，设置显示窗口的大小，并应用背景颜色。你已经学会了在控制台中显示“Hello,
    World!”等消息，并使用2D基本函数绘制图形。你还学会了颜色的使用，并且知道如何使用十六进制、RGB和HSB颜色模式来定义线条和填充的颜色。此外，你应该理解如何使用弧度来度量角度，并使用`arc()`函数。
- en: While getting started with Processing, you’ve also learned a few Python programming
    fundamentals, like how to manage whitespace, add code comments, and use arithmetic
    operators to perform mathematical operations. You’ve also seen how to use Python
    variables, which are placeholders for data. Processing includes system variables,
    like `width` and `height`, but you can store values in your own variables, provided
    that the variable names adhere to Python’s naming rules.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用Processing的同时，你也学习了一些Python编程基础知识，比如如何管理空白字符、添加代码注释，以及使用算术运算符执行数学操作。你还了解了如何使用Python变量，它们是数据的占位符。Processing包含了系统变量，比如`width`和`height`，但你也可以将值存储在自己的变量中，只要变量名遵循Python的命名规则。
- en: In Chapter 2, you’ll learn how to draw more organic, as opposed to geometric,
    shapes. You’ll also gain insight into the inner workings of vector graphics software
    like Adobe Illustrator and Inkscape.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2章中，你将学习如何绘制更具有机感的形状，而不是几何形状。你还将深入了解像Adobe Illustrator和Inkscape这样的矢量图形软件的内部工作原理。
