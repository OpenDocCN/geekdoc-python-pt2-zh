- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hello, World!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: When learning a new programming language, it’s a long-standing tradition that
    the first code you write is to display the message ‘Hello, World!’ In keeping
    with that tradition, you’ll do that here too—but that’s not all. This chapter
    introduces everything you need to understand the fundamentals of Processing, and
    you’ll quickly move on from a simple ‘Hello, World!’ to drawing with code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: To get started, you’ll set up Python Mode for Processing so you can create your
    own sketches. Along the way, you’ll learn the basic rules of writing code in Processing,
    as well as how to deal with errors, use variables, and perform arithmetic operations.
    You’ll also learn about how Processing handles color and how to measure angles
    using radians. By the end of this chapter, you’ll be comfortable drawing colorful
    geometric shapes by using various Processing functions. Let’s get started.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Processing Installation and Python Mode Setup
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before writing any code, you first need to set up Python Mode for Processing.
    Head over to the Processing downloads web page ([https://processing.org/download/](https://processing.org/download/))
    and grab the version of Processing appropriate for your system (Windows, Linux,
    or macOS). As of January 2021, Processing 3.5.4 is the latest stable release.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'Processing does not employ an installation program. Instead, you simply extract
    the file you have downloaded (usually a *.zip* archive) and run the application.
    The exact process varies slightly between operating systems:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, unzip all of the contents by right-clicking the file and selecting
    **Extract All**, and then follow the instructions. Extract or move the folder
    to any location on your computer, including your *Program Files* folder or *Desktop*.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On macOS, unzip the file by double-clicking it, and then move the extracted
    app to any location on your computer, including your *Applications* folder or
    *Desktop*.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TheLinux version of Processing is a *.tar* archive. Extract or move the folder
    to any location on your computer, including your home folder or desktop.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you’re finished, open the newly extracted folder. [Figure 1-1](#figure1-1)
    shows an abridged listing of what you can expect to see in your file manager.
    Next, locate and run the executable file named *processing*. On macOS, you’ll
    just have a single file named *processing*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![f01001](image_fi/500969c01/f01001.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-1: The contents of a freshly extracted *processing* folder for Windows
    or Linux'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The application layout may vary slightly among systems and Processing versions,
    but the key elements are outlined in [Figure 1-2](#figure1-2). If you’re a Mac
    user, you’ll find the *menu bar* in its usual position at the top of your screen.
    Note that the upper right button in the Processing interface is labeled *Java*.
    This is because Processing comes bundled with Java mode as the default.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![f01002](image_fi/500969c01/f01002.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-2: The Processing interface'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Next, activate Python Mode. Click the **Java** button and select **Add Mode**
    from the drop-down menu; then, from the Contribution Manager window that appears,
    choose **Python Mode for Processing**. Finally, click **Install**. You can now
    change between Python and Java mode by using the drop-down menu. Switch to Python
    ([Figure 1-3](#figure1-3)).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![f01003](image_fi/500969c01/f01003.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-3: The button to the right indicates that Python Mode is activated.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: You’re now ready to write your first lines of code!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Your First Sketch
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Processing refers to programs as *sketches*. Given the visual and artistic nature
    of what you are likely to produce, it’s a fitting term. Select **File**▶**New**
    to create a new sketch, or use the associated keyboard shortcut (listed alongside
    the menu entry).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following lines of code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: I’ll go through the specifics of this code in a bit. For now, save the sketch
    by using **File**▶**Save As** and name it *hello_world*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that Processing creates a new folder named *hello_world*; within
    it, there are two files: *hello_world.pyde* and *sketch.properties* ([Figure 1-4](#figure1-4)).
    Depending on your system’s configuration, you may or may not see the file extension
    (*.pyde*). To reopen any sketch, locate and open the *.pyde* file.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![f01004](image_fi/500969c01/f01004.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-4: The contents of your *hello_world* sketch folder'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: You may want to add other assets to your sketch folders, such as images and
    fonts, but more on that later.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, click the play (▶) button to execute the code. Better yet, use the associated
    keyboard shortcut: ctrl-R for Windows and Linux, or -R for macOS. A gray 500
    × 500 pixel *display window* should appear. In the console, which is the black
    area at the bottom of the editor, Processing should display `Hello, World!` ([Figure
    1-5](#figure1-5)).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s get back to the code you entered in this file; it uses two Processing
    functions: `size()` and `print()`. *Functions* are named instructions, sort of
    like dog commands for computers. Some commands are simple, like “sit,” but something
    like “fetch” may involve specifying what it is that Fido should retrieve.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'Python functions consist of a function name followed by opening and closing
    *parentheses*, which is where you provide arguments. In the case of my dog-command
    analogy, “ball” could be an argument for “fetch.” The `size()` function ([Figure
    1-6](#figure1-6)) takes two arguments: the first represents the width of your
    sketch, and the second is the height.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the display window is 500 pixels wide by 500 pixels high.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![f01005](image_fi/500969c01/f01005.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-5: Display window (left) and an editor with `′Hello, World!′` displayed
    in the console (right)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![f01006](image_fi/500969c01/f01006.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-6: Anatomy of a `size()` function'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'The `print()` function writes to the console. This function takes a single
    argument: the phrase `''Hello, World!''` Because this is text—or technically,
    *string* data—you need to wrap it in quotation marks. You can use single or double
    quotes, but be sure to use the same type for both opening and closing quotes.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`print()`函数用于输出到控制台。此函数接受一个参数：字符串`''Hello, World!''`。因为这是文本数据——或者严格来说，是*字符串*数据——你需要将其放在引号中。你可以使用单引号或双引号，但请确保开闭引号类型一致。'
- en: 'Python classifies every value according to a *data type*, which determines
    how the value is handled and the operations you can perform on it. For example,
    you can perform arithmetic operations—like division or subtraction—on numeric
    data types but not on strings. In this chapter, you’ll deal with three data types:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Python 会根据*数据类型*对每个值进行分类，这决定了该值的处理方式以及你可以在其上执行的操作。例如，你可以对数值数据类型执行算术操作——如除法或减法——但不能对字符串执行。
    在本章中，你将处理三种数据类型：
- en: String Text data, like ‘Hello, World!’
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符串 文本数据，如‘Hello, World!’
- en: Integer Numbers without decimal points, such as 1, –27, or 422
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整数 没有小数点的数字，如1、–27或422
- en: Floating-point Numbers that include a decimal point, such as 1.618
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浮点数 包含小数点的数字，如1.618
- en: What separates Processing code from standard Python code are some of its functions;
    the `size()` function, for example, is Processing-specific. In other words, it
    won’t work outside the Processing environment. The `print()` function, on the
    other hand, is a built-in element of the standard Python programming language.
    It works in Processing’s Python Mode and any other Python program.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 代码与标准 Python 代码的不同之处在于它的一些函数；例如，`size()`函数是 Processing 特有的。换句话说，它在
    Processing 环境之外无法使用。另一方面，`print()`函数是标准 Python 编程语言的内置元素。它在 Processing 的 Python
    模式和任何其他 Python 程序中都能工作。
- en: Throughout this book, I usually refer to Processing-exclusive features in the
    context of *Processing,* and standard Python features with the term *Python*.
    If this is confusing, think of them as one and the same. At this point, distinguishing
    Processing from Python isn’t crucial; you will understand the differences in time.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我通常在*Processing*的上下文中提到 Processing 特有的功能，而将标准 Python 功能称为*Python*。如果这让你感到困惑，可以把它们看作是同一个东西。此时，区分
    Processing 和 Python 并不关键；你会随着时间的推移理解其中的差异。
- en: Comments
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: 'If you want Python to ignore any part of your code, you can comment it out.
    This feature is useful for leaving notes, in plain English, to yourself or anybody
    else editing your code. Let’s add a few comments to your *hello_world* file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望 Python 忽略代码中的某部分，可以将其注释掉。这个功能对于自己或其他编辑代码的人留下便于理解的英文注释非常有用。让我们在你的*hello_world*文件中添加几个注释：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Comments come in two types: single- and multiline. As shown here, use a `#`
    character for single-line comments 1 and `''''''` (or `"""`) for multiline comments
    2.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注释分为两种类型：单行注释和多行注释。如图所示，单行注释使用`#`字符，1 多行注释使用`'''`（或`"""`）2。
- en: While working through the tasks in this book, add comments to remind yourself
    how the code works. Comments are also useful for debugging code. For instance,
    if you suspect that some lines are causing your program to fail, you can temporarily
    disable them by commenting them out.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本书任务的过程中，添加注释以提醒自己代码的工作原理。注释在调试代码时也非常有用。例如，如果你怀疑某些代码行导致程序失败，你可以通过注释掉这些行来暂时禁用它们。
- en: Whitespace
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空白字符
- en: 'Python, and by extension Processing’s Python Mode, is whitespace-sensitive.
    You need to be careful where you insert space characters or tabs. As an example,
    add a few spaces to the beginning of the `size()` line; then run the sketch:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Python 以及扩展的 Processing Python 模式，对空白字符非常敏感。你需要小心插入空格字符或制表符的位置。例如，给`size()`这一行添加一些空格，然后运行草图：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you run the sketch, the message bar turns red, and Processing displays
    an error message ([Figure 1-7](#figure1-7)). Python relies on indentation to distinguish
    blocks of code. The indented line breaks the program because Python did not encounter
    any code to define a new block for the `size()` function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行草图时，消息栏会变为红色，Processing 会显示错误信息（[图 1-7](#figure1-7)）。Python 依赖缩进来区分代码块。缩进的行会导致程序出错，因为
    Python 没有遇到任何代码来定义`size()`函数的新代码块。
- en: '![f01007](image_fi/500969c01/f01007.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![f01007](image_fi/500969c01/f01007.png)'
- en: 'Figure 1-7: A whitespace error'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-7：空白错误
- en: Correct the code by removing the problematic space characters you’ve just added.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过删除你刚刚添加的空格字符来修正代码。
- en: You’ll come to understand more about when and where to use indentation as you
    progress through these chapters. For now, though, pay careful attention to any
    space and tab characters that affect the indentation of your code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Errors
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whitespace issues are not the only error type you will encounter. On occasion,
    you’re likely to miss the odd parenthesis, comma, or quotation mark, especially
    when starting out. Try removing the closing parenthesis from your `size()` function,
    like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now run the code and observe the console output. Note the suggestion in the
    message bar ([Figure 1-8](#figure1-8)). Pretty smart, huh?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![f01008](image_fi/500969c01/f01008.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-8: The alert in the message bar (red) suggests a possible cause for
    the error that Processing encountered.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of a *syntax error*, and it’s not the first you’ll encounter.
    Just as English sentences must begin with a capital letter and end with a full
    stop, Python functions must have an opening and a closing parenthesis. When you
    have multiple arguments, you need to separate them using commas. This set of rules
    is called *syntax*. If you don’t conform to the rules, Python will be confounded
    and report an error.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Error messages are not always so clear or accurate, but they can provide a clue
    as to where to start searching for bugs. Copying and pasting the messages into
    a search engine can sometimes help you find a solution.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Color
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can describe colors in various ways in Processing. To keep things simple,
    I’ll stick with *hexadecimal* values for the first example. If you’re familiar
    with graphics software like Adobe Photoshop, Adobe Illustrator, Inkscape, or GIMP,
    you may have seen hexadecimal values in the color picker for those programs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Processing includes its own color selector ([Figure 1-9](#figure1-9)), which
    you can access from the menu bar by selecting **Tools**▶**Color Selector**. You
    can use this color selector to mix and sample color values. The value that begins
    with a hash mark (#) is the hexadecimal; you use the **Copy** button to copy it,
    so that you can paste it into the code editor.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![f01009](image_fi/500969c01/f01009.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-9: Processing color selector'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Your screen displays color pixels by mixing three primary colors—much as you
    mix red, yellow, and blue paint in art class. However, your screen relies on red,
    green, and blue primaries instead. Furthermore, because light blends color in
    an *additive* manner, pixels that combine all three primaries at full intensity
    appear as white. Conversely, a complete absence of any color results in a black
    pixel. Other colors contain varied quantities of red, green, and blue. For example,
    a bright red mixture is created as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 100% | 0% | 0%
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'A hexadecimal color value is composed of six hexadecimal digits (`0`, `1`,
    `2`, . . . , `9`, `A`, `B`, `C`, `D`, `E`, `F`) and can be split into three pairs.
    Each pair corresponds to a primary color. Here’s the value for bright red:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '`#FF0000`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FF` represents a red quantity; the middle `00` is for green; the rightmost
    `00` is for blue. For reasons I won’t get into here, `FF` is the equivalent of
    100 percent. Also, remember that you are mixing light, so `#FFFFFF` is white,
    and `#000000` is black. Here are some other examples:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 100 percent blue `#0000FF`
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dark green `#006600`
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dark gray `#505050`
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the selector to experiment further and observe how the hexadecimal values
    change as you select different colors.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fill()` function sets the color used to fill shapes. It accepts up to
    four arguments, depending on the color system you are using. For hexadecimal color,
    use a single argument: the six-digit value prefixed with a `#`, wrapped in quotes.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line to the bottom of your *hello_world* sketch:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You have now set the fill color to red. To see this in effect, let’s draw a
    rectangle. The `rect()` function is used for drawing rectangles, and it takes
    four arguments:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first two arguments specify the location of the rectangle’s upper left corner
    ([Figure 1-10](#figure1-10)). Processing’s x-coordinates begin from the left edge
    of the display window; the y-coordinates begin from the top edge.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![f01010](image_fi/500969c01/f01010.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-10: Processing’s coordinate system'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'The x-y coordinate for the upper left corner of the display window is (0, 0),
    and the lower right is (500, 500). So to move the rectangle down, increase the
    y-coordinate value. Add a new rectangle line to your *hello_world* sketch:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run the sketch to confirm that the output matches [Figure 1-11](#figure1-11).
    Experiment with the `rect()` arguments to affect the rectangle’s size and position.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![f01011](image_fi/500969c01/f01011.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-11: `rect(100, 150, 200, 300)`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: You now should be familiar with Processing’s coordinate system. The `rect()`
    is one of many drawing functions; you’ll be introduced to a few more shortly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ve also learned to define color using hexadecimal values
    that describe different quantities of red, green, and blue light. And you now
    can use a color picker, like the one included with Processing, to mix and sample
    any values you require. You’ll see other systems for defining color in Processing,
    but for most of this book, you’ll use hexadecimal.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Fills and Strokes
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you write a `fill()` line, every shape thereafter is filled in with the
    color you specify. That color won’t change until Processing encounters the next
    `fill()` line. In this way, Processing is like painting: you grab a brush and
    dip it in paint, and then everything you paint is influenced by the brush and
    color you last selected. When you want to paint in a different style or color,
    you change out your brush or dip it in a different pot. If you want to disable
    the fill altogether, use `noFill()`.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the end of your *hello_world* file to draw a smaller
    red rectangle, an orange square, and a square with no fill:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For a square, you have two options: use a `rect()` 1 with matching width and
    height (third and fourth) arguments. Or, use the `square()` 2 function, which
    takes three arguments: x, y, and extent.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个正方形，你有两个选择：使用 `rect()` 1 函数，并传入匹配的宽度和高度（第三个和第四个）参数。或者，使用 `square()` 2 函数，它需要三个参数：x、y
    和范围。
- en: Processing interprets lines of code from top to bottom. As a result, shapes
    at the bottom of your code appear at the top of the visual “stack.” So the previous
    code produces the shapes in [Figure 1-12](#figure1-12).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Processing 会从上到下解释代码行。因此，代码底部的形状会出现在视觉“堆栈”的顶部。所以前面的代码会生成[图 1-12](#figure1-12)
    中的形状。
- en: '![f01012](image_fi/500969c01/f01012.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![f01012](image_fi/500969c01/f01012.png)'
- en: 'Figure 1-12: The no-fill square—the last line of your code—is the topmost shape.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-12：没有填充的正方形——代码的最后一行是最上面的形状。
- en: '*Stroke* is another term for *outline*, and you’re likely to use the following
    three stroke functions: `stroke()` to change the color, `strokeWeight()` to change
    the width, and `noStroke()` to disable the stroke altogether. Like `fill()` and
    `noFill()`, the stroke functions affect everything below them.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*描边* 是 *轮廓* 的另一种说法，你可能会使用以下三种描边函数：`stroke()` 用于更改颜色，`strokeWeight()` 用于更改宽度，`noStroke()`
    用于完全禁用描边。与 `fill()` 和 `noFill()` 类似，描边函数会影响它们下面的所有内容。'
- en: 'For a white stroke, 3 pixels in width, insert the following lines above the
    shape code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得 3 像素宽的白色描边，可以在形状代码之前插入以下代码：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `stroke()` line affects every shape that follows it. [Figure 1-13](#figure1-13)
    shows how all of the shapes now have white strokes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`stroke()` 行会影响它之后的每个形状。[图 1-13](#figure1-13) 显示了现在所有形状都有白色描边。'
- en: '![f01013](image_fi/500969c01/f01013.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![f01013](image_fi/500969c01/f01013.png)'
- en: 'Figure 1-13: Adding white strokes'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-13：添加白色描边
- en: For thicker strokes, you may want to specify whether the corners and tips are
    rounded or sharp. For more information, consult the relevant Processing.py reference
    entries for `strokeCap()` and `strokeJoin()`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更粗的描边，你可能需要指定角落和尖端是圆形的还是尖锐的。有关更多信息，请查阅相关的 Processing.py 参考条目，了解 `strokeCap()`
    和 `strokeJoin()`。
- en: Background Color
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 背景颜色
- en: 'To change the background color, use the `background()` function. Add a background
    line to the end of your sketch:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改背景颜色，使用 `background()` 函数。在你的代码末尾添加一个背景行：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the sketch and note how everything has disappeared; the entire display
    window is now a flat shade of blue. This is because `background(''#004477'')`
    draws over everything before it, which will be useful when you start working with
    animation. For now, move that line to the top of your code so you can see the
    shapes again ([Figure 1-14](#figure1-14)):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码并注意到所有内容都消失了；整个显示窗口现在是一个平坦的蓝色。这是因为 `background('#004477')` 会覆盖它之前的所有内容，当你开始处理动画时，这会非常有用。现在，将该行移动到代码顶部，这样你可以再次看到形状
    ([图 1-14](#figure1-14))：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the background function can also accept an image as an argument (I’ll
    introduce images in Chapter 2).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`background` 函数也可以接受图像作为参数（我将在第二章中介绍图像）。
- en: '![f01014](image_fi/500969c01/f01014.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![f01014](image_fi/500969c01/f01014.png)'
- en: 'Figure 1-14: Adding a background color'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-14：添加背景颜色
- en: Color Modes
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色模式
- en: 'I’ll use hexadecimal color values for the rest of the chapter, but here’s a
    quick introduction to other color modes, because at some point, you may need to
    express colors in something other than hexadecimal. For example, say you want
    to write code that darkens a bright red fill. First, you will recall that this
    is a shade of bright red:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本章中使用十六进制颜色值，但这里先简单介绍其他颜色模式，因为在某些情况下，你可能需要使用非十六进制的颜色表示。例如，假设你想写一个代码来加深鲜红色的填充。首先，你会回忆起这是一种鲜红色：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can also represent this color as the following in RGB:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将这个颜色表示为 RGB 格式：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this arrangement, each red/green/blue value is comma-separated. As you might
    have already deduced, `255` is equivalent to `FF` (which itself is equivalent
    to 100 percent). To make the red half as bright, you can subtract `127` from `255`.
    However, trying to subtract `127` from `FF` is tricky because you’re dealing with
    a mix of hexadecimal and decimal numbers. In this instance, it’s easier to stick
    with decimal values (255 – 127 = 128).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种安排中，每个红/绿/蓝值是以逗号分隔的。正如你可能已经推断出来的，`255` 等于 `FF`（它本身等于 100%）。为了使红色变得一半亮度，你可以从
    `255` 中减去 `127`。然而，试图从 `FF` 中减去 `127` 会有点复杂，因为你在处理十六进制和十进制数字的混合。在这种情况下，使用十进制值更容易（255
    – 127 = 128）。
- en: 'To use the `fill(255, 0, 0)` cits `colorMode()` set to `RGB`. You don’t need
    to specify this, though, as it’s the default mode. Here’s how it works: if Processing
    detects a single argument in quotes (like `''#FF0000''`), it interprets it as
    hexadecimal, but if you provide three arguments, it automatically knows that you
    are using the system of 0 to 255.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you can use another mode: HSB. Once set to `HSB` mode, the three `fill()`
    arguments represent *hue*, *saturation*, and *brightness*, respectively. To better
    understand how those variables affect color, let’s take a look at the color picker
    of GIMP, an open source image editor ([Figure 1-15](#figure1-15)).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Rotating the large triangle adjusts the H value between 0 and 360 degrees; the
    H (hue) field corresponds to the white line at the triangle’s lower right tip.
    You move the small white circle (inside the triangle) to adjust the S (saturation)
    and V (value) fields. *Value* and *brightness* are interchangeable terms in this
    context, so the V corresponds to the B in HSB.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![f01015](image_fi/500969c01/f01015.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-15: Hue: 330 degrees; saturation: 90 percent; value/brightness: 80
    percent'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have GIMP installed, or software with a similar color picker, I encourage
    you to experiment with it. To mimic the GIMP scheme in Processing, set the color
    mode accordingly:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `HSB` represents the mode, `360` represents the range of degrees for hue,
    and the two `100` arguments represent a range of 0 to 100 percent for saturation
    and brightness. You would now write a red fill as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is because bright red lies at 0 degrees of rotation on the hue ring (which
    begins at “East” in the GIMP mixer) and has a saturation and brightness of 100
    percent ([Figure 1-16](#figure1-16)).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![f01016](image_fi/500969c01/f01016.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-16: Hue: 0 degrees; saturation: 100 percent; value/brightness: 100
    percent'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: In HSB mode, shifting along the color spectrum—from red to orange to yellow
    to green, and so on—is a simple matter of adding to or subtracting from the H
    value. Attempting the same in RGB mode is not so easy, as you need to adjust the
    proportions of each primary color.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The chapters to come will cover even more on color. Consult the relevant Processing.py
    reference entries for `colorMode()` and `fill()` if you need more detail.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 2D Primitives
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s move on to drawing basic shapes. Begin a new sketch (**File**▶**New**)
    and save it as *primitives_2d* (**File**▶**Save As**). Add this code to set things
    up before proceeding:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now when you run the sketch, thanks to `background('#004477')`, an empty blue
    display window appears. Any shapes that you draw will have no fill and a white
    stroke of 3 pixels.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, draw three points by using the `point()` function ([Figure 1-17](#figure1-17)):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `point()` function accepts two arguments, which represent the x- and y-coordinates.
    The active `strokeWeight()` determines the size of the points.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![f01017](image_fi/500969c01/f01017.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-17: Three points drawn with the `point()` function'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: What follows are descriptions for several drawing functions, along with code
    to add to your working sketch. Experiment with the arguments to see how the finished
    version ([Figure 1-18](#figure1-18)) responds.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![f01018](image_fi/500969c01/f01018.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-18: An assortment of 2D primitives'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: triangle()
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `triangle()` function draws a triangle. The six arguments represent three
    x-y coordinate pairs. I have grouped each x-y pair by removing the space character
    after every other argument so it’s easier to read:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Python is not sensitive to whitespace between arguments, so if you find it helpful
    to format your code in a similar fashion, feel free to do so.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: ellipse()
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ellipse()` function draws an ellipse. The first pair of arguments represents
    an x-y coordinate that marks the center of the ellipse; the second pair of arguments
    represents the ellipse’s width and height:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For a circle, you can use the `ellipse()` function with matching width and
    height (third and fourth) arguments. Alternatively, you can use the `circle()`
    function, which takes three arguments: x, y, and diameter.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `circle()` and `square()` functions are relatively new to Processing, so
    you may find that many of the examples (**File**▶**Examples**) and online code
    rely on only `ellipse()` and `rect()`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: quad()
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `quad()` function draws a *quadrilateral* (a four-sided polygon). Essentially,
    it’s like a triangle function with an extra point, and its eight arguments represent
    four x-y coordinate pairs:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: line()
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `line()` function draws a straight line between two points. The first pair
    of arguments represents the starting x-y coordinates, and the second pair, the
    ending x-y coordinates:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As with points and shapes, the width of a line is affected by any preceding
    `strokeWeight()` function.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The 2D primitive functions provide an easy way to draw shapes in the display
    window. There’s one more shape function to review, `arc()`, but it’s a bit more
    involved than the other shapes. Variables and arithmetic operators will prove
    useful for drawing arcs, so I’ll cover those first. Before moving on, though,
    here’s a quick challenge to practice what you’ve learned so far.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Challenge #1: Rainbow Task'
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Begin a new sketch (**File**▶**New**) and save it as *rainbow* (**File**▶**Save
    As**). Add this code to get started:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Using what you’ve learned so far, complete the rainbow in [Figure 1-19](#figure1-19).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Clue: think about how you can overlap shapes to mask others. If you need help,
    you can access the solution at [https://github.com/tabreturn/processing.py-book/tree/master/chapter-01-hello,world!/rainbow/](https://github.com/tabreturn/processing.py-book/tree/master/chapter-01-hello,world!/rainbow/).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![f01019](image_fi/500969c01/f01019.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-19: Recreate this rainbow.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Variables* are placeholders for information—much like when you use letters
    in algebra to represent a value. In fact, Python variables look and behave quite
    similarly.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin a new sketch and save it as *variables*. To keep things simple, you’ll
    print values to the console area. Add the following code to set up the sketch
    and print its width and height (in pixels):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you run the sketch, the display window’s width and height should be printed
    to the console, as shown in [Figure 1-20](#figure1-20).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: But notice that you never explicitly defined `width` or `height`. Processing
    automatically assigned the width and height of the display window to these two
    variables. From this, you can establish that `width` and `height` are variables
    for which Processing maintains the values. Predefined variables like these are
    called *system variables*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you are not limited to system variables; you can also define your
    own. When declaring new variables, assign them a value by using an equal sign
    (`=`), which is called the *assignment operator*. Try this out with a new variable
    named `x`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![f01020](image_fi/500969c01/f01020.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-20: Printing variables to the console'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The variable `x` is equal to 10, so the `print()` function displays a `10` in
    the console.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'You can name your variables whatever you like, provided that the name contains
    only alphanumeric and underscore characters, doesn’t begin with a number, and
    doesn’t clash with any reserved keywords or variables (like `width`). For example,
    the following shows several possible variable names (the comments indicate which
    are correct):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Whether you should name a multiword variable using *camelCase*, underscores,
    or another convention is a matter of style (and vociferous debate), but it’s good
    to decide on a naming convention and stick to it, as you’ll make extensive use
    of variables in Processing.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add three more variables to your script for use as arguments in a `rect()`
    function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `y` variable indicates the y-coordinate; `w` indicates the width; and `h`
    indicates the height value for the `rect()` function. Notice that the `h` value
    is equal to the `w` value (of 100). You’ve already defined `x` as equal to 10\.
    Run the sketch to confirm that it displays a white square positioned near the
    upper left corner of the display window ([Figure 1-21](#figure1-21)).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![f01021](image_fi/500969c01/f01021.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-21: A square using variables as coordinates'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Experiment further on your own with shapes and variables. In the next section,
    you’ll learn to use variables to perform mathematical calculations.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic Operators
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Arithmetic operators* perform arithmetic operations on *operands*; this is
    far simpler than it probably sounds. For instance, in the expression 1 + 3, the
    plus sign is the operator, and the numbers 1 and 3 are the operands. To better
    understand how this all works in Python, let’s go through some examples.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Basic Operations
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add the following line to the end of your *variables* sketch to calculate what
    variable `x` plus 2 is equal to:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Run the sketch and check the bottom line of the console output. I’m guessing
    the code did exactly what you expected. Earlier in the chapter, you assigned a
    value of 10 to variable `x`, and 10 + 2 is equal to 12, which is what you will
    see in your console.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also subtract (see the comments for the result):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Use the `*` operator for multiplication:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now try this line, but before running it, see if you can predict the result:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The console displays a `7` and not a `9` because multiplication occurs before
    addition. Certain operators take precedence over others. Remember PEMDAS? It’s
    an acronym to help you recall the *order of operations*, which is parentheses
    first, then exponents, then multiplication/division, then addition/subtraction.
    (Some people may be more familiar with the acronyms BEDMAS or BODMAS, which use
    the terms *brackets* for *parentheses,* and *of* or *order* to indicate exponents.)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want the addition to happen first, use parentheses:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For division, use a forward slash (`/`):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Be aware that dividing two integers always produces an integer result (integers
    are whole numbers, as opposed to those with a decimal point). For example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Processing discards any decimal digits, effectively rounding down the result.
    Note, however, that this is Python 2 behavior. At the time of this writing, Processing’s
    Python Mode uses Python 2.7\. If you ever find yourself writing Python 3 code,
    the result will be 1.5.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'For floating-point division in Python 2, define at least one of your operands
    by using a decimal point:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This line displays a 1.5 in Python versions 2 and 3\. This book avoids any Python
    code that isn’t compatible with Python 3\. Rest assured, you can apply your newly
    acquired coding skills in Python 2 and 3 development. Should Processing switch
    to Python 3, your code will still run fine.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Of course, division-by-zero operations will result in errors ([Figure 1-22](#figure1-22)).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![f01022](image_fi/500969c01/f01022.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-22: Division-by-zero error'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Processing uses other arithmetic operators (for floor division and exponents)
    that aren’t necessary to review here. The modulo operator, however, warrants a
    brief introduction.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Modulo Operator
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *modulo operator* calculates the remainder of a division operation and is
    expressed as a percentage sign (`%`). Take 5 divided by 2 as an example. You could
    say the answer is 2.5, or you could say the answer is 2 remainder 1, because 2
    “goes into” 5 twice with 1 left over.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'The modulo operator performs the latter operation and provides the remainder.
    Here’s some code contrasting division and modulus (as before, the comments show
    the output):'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It may not be evident why this operator is useful. However, many important
    algorithms, such as those used in cryptography, use modular arithmetic. For now,
    consider that modulo operations resulting in a `0` indicate that numbers divide
    exactly. Among other uses, this is handy for establishing whether a number is
    odd or even:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You’ll use the modulo operator in the chapters to come.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Arcs
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that I’ve covered variables and some basic math, I can introduce the `arc()`
    function, which is used to draw elliptical arcs. Let’s look at a few examples
    to see how this one works. Create a new sketch and save it as *disk_space_analyzer*.
    Add the following setup code that will define some visual parameters to get started:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `arc()` function takes the following arguments, expanded across multiple
    lines here for easier comprehension (recall that Python is not sensitive to whitespace
    between function arguments):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add an arc to your sketch by using a `start_angle` of `0` and `end_angle` of
    `2`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The green overlay in [Figure 1-23](#figure1-23) helps illustrate how the arguments
    work. Processing draws the arc along the perimeter of an invisible ellipse centered
    in the display window. The center of this ellipse has an x-y coordinate of `width/2`,
    `height/2`; it’s 200 pixels wide and 200 pixels high. An angle of `0` is positioned
    at East, which opens clockwise to an angle of `2`, which looks more like around
    115 degrees of rotation.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this large angle is that Processing uses *radians* and not degrees
    to measure angles; 1 radian is equal to roughly 57.3 degrees. Why use radians?
    Radians, a standard unit of angular measure used in many areas of mathematics,
    provide more natural and elegant formulas for circular motion. Think about this:
    why are there 360 degrees in a full circle? Why not 300 or 100, or even a million
    degrees? While I’m on the topic, why are there 60 minutes in an hour? Or 24 hours
    in a day? Much of this has to do with ancient counting systems.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![f01023](image_fi/500969c01/f01023.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-23: An arc with a start angle value of 0 and end angle of 2'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Rather than dividing a circle into an arbitrary number of slices (like 360),
    the radian system is based on a proportional measurement involving a circle’s
    *radius*. [Figure 1-24](#figure1-24) illustrates how radians are defined. Beginning
    with the left graphic, take the radius of any circle; create an arc of that same
    length; then measure the angle formed between the tips of the arc and the center
    of the circle to derive one radian.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![f01024](image_fi/500969c01/f01024.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-24: Defining a radian'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: If 1 radian is equal to approximately 57.3 degrees, 2 radians equal 114.6 degrees.
    This makes 180 degrees equivalent to roughly 3.142 radians ([Figure 1-25](#figure1-25)).
    Do you recognize that number? Yep, it’s pi!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![f01025](image_fi/500969c01/f01025.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-25: Measuring the number of radians in a half- and full circle'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Processing provides the `degrees()` and `radians()` functions for converting
    between the systems, but you should be fine working in radians if you can remember
    a few key measurements. For starters, 0 degrees is equal to 0 radians, and 180
    degrees is equal to *π* radians. Therefore, 360 degrees is equal to 2π radians.
    In Processing, you can use the system variable `PI` instead of writing a lengthy
    decimal.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to draw a half-circle and a full circle using `arc()`
    functions:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Run the sketch. The first new arc begins at `0` and ends at `PI`, resulting
    in a half-circle; the second outermost and largest arc has an end angle of `PI*2`,
    and therefore, it appears as a complete circle.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to close an arc, so as to form a “slice,” add an additional `PIE`
    argument. Add the following line to test this out:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The arc spans from 3.4 radians (around 10 o’clock) to ~4.7 radians (12 o’clock).
    [Figure 1-26](#figure1-26) depicts the final result. You can identify the most
    recent arc by its slice shape.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![f01026](image_fi/500969c01/f01026.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-26: Here are four arcs, and one of them is a complete circle. The
    slice-like arc (upper left) uses the `PIE` argument.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Challenge #2: Disk Usage Analyzer'
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now for a final challenge before moving on to Chapter 2. A *disk usage analyzer*
    presents a graphical representation of a disk drive’s contents. The Linux GNOME
    Disk Usage Analyzer (also known as *Baobab*) is one example of such software,
    and its charts make good use of arcs.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Recreate the ring chart graphic in [Figure 1-27](#figure1-27) by using what
    you have learned thus far. Begin by commenting out your existing arc lines, and
    then continue to work in the same sketch file. (The text and number labels have
    been added to assist you with calculations; do not add them to your recreation.)
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![f01027](image_fi/500969c01/f01027.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-27: Disk usage analyzer chart'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: If you need help, remember you can access all of the solutions to the challenges
    at [https://github.com/tabreturn/processing.py-book/](https://github.com/tabreturn/processing.py-book/).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You now have Python Mode for Processing up and running. You also know how to
    set up a new sketch, set the size of your display window, and apply a background
    color. You’ve learned to display messages like ‘Hello, World!’ in the console
    and draw shapes using 2D primitive functions. You’ve also learned about color
    and how to define the color of your strokes and fills in hexadecimal, or using
    RGB and HSB color modes. In addition, you should understand how to use radians
    to measure angles and work with the `arc()` function.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: While getting started with Processing, you’ve also learned a few Python programming
    fundamentals, like how to manage whitespace, add code comments, and use arithmetic
    operators to perform mathematical operations. You’ve also seen how to use Python
    variables, which are placeholders for data. Processing includes system variables,
    like `width` and `height`, but you can store values in your own variables, provided
    that the variable names adhere to Python’s naming rules.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 2, you’ll learn how to draw more organic, as opposed to geometric,
    shapes. You’ll also gain insight into the inner workings of vector graphics software
    like Adobe Illustrator and Inkscape.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
