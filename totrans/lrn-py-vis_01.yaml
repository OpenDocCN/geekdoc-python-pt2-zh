- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hello, World!
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: When learning a new programming language, it’s a long-standing tradition that
    the first code you write is to display the message ‘Hello, World!’ In keeping
    with that tradition, you’ll do that here too—but that’s not all. This chapter
    introduces everything you need to understand the fundamentals of Processing, and
    you’ll quickly move on from a simple ‘Hello, World!’ to drawing with code.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, you’ll set up Python Mode for Processing so you can create your
    own sketches. Along the way, you’ll learn the basic rules of writing code in Processing,
    as well as how to deal with errors, use variables, and perform arithmetic operations.
    You’ll also learn about how Processing handles color and how to measure angles
    using radians. By the end of this chapter, you’ll be comfortable drawing colorful
    geometric shapes by using various Processing functions. Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Processing Installation and Python Mode Setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before writing any code, you first need to set up Python Mode for Processing.
    Head over to the Processing downloads web page ([https://processing.org/download/](https://processing.org/download/))
    and grab the version of Processing appropriate for your system (Windows, Linux,
    or macOS). As of January 2021, Processing 3.5.4 is the latest stable release.
  prefs: []
  type: TYPE_NORMAL
- en: 'Processing does not employ an installation program. Instead, you simply extract
    the file you have downloaded (usually a *.zip* archive) and run the application.
    The exact process varies slightly between operating systems:'
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, unzip all of the contents by right-clicking the file and selecting
    **Extract All**, and then follow the instructions. Extract or move the folder
    to any location on your computer, including your *Program Files* folder or *Desktop*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On macOS, unzip the file by double-clicking it, and then move the extracted
    app to any location on your computer, including your *Applications* folder or
    *Desktop*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TheLinux version of Processing is a *.tar* archive. Extract or move the folder
    to any location on your computer, including your home folder or desktop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you’re finished, open the newly extracted folder. [Figure 1-1](#figure1-1)
    shows an abridged listing of what you can expect to see in your file manager.
    Next, locate and run the executable file named *processing*. On macOS, you’ll
    just have a single file named *processing*.
  prefs: []
  type: TYPE_NORMAL
- en: '![f01001](image_fi/500969c01/f01001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-1: The contents of a freshly extracted *processing* folder for Windows
    or Linux'
  prefs: []
  type: TYPE_NORMAL
- en: The application layout may vary slightly among systems and Processing versions,
    but the key elements are outlined in [Figure 1-2](#figure1-2). If you’re a Mac
    user, you’ll find the *menu bar* in its usual position at the top of your screen.
    Note that the upper right button in the Processing interface is labeled *Java*.
    This is because Processing comes bundled with Java mode as the default.
  prefs: []
  type: TYPE_NORMAL
- en: '![f01002](image_fi/500969c01/f01002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-2: The Processing interface'
  prefs: []
  type: TYPE_NORMAL
- en: Next, activate Python Mode. Click the **Java** button and select **Add Mode**
    from the drop-down menu; then, from the Contribution Manager window that appears,
    choose **Python Mode for Processing**. Finally, click **Install**. You can now
    change between Python and Java mode by using the drop-down menu. Switch to Python
    ([Figure 1-3](#figure1-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f01003](image_fi/500969c01/f01003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-3: The button to the right indicates that Python Mode is activated.'
  prefs: []
  type: TYPE_NORMAL
- en: You’re now ready to write your first lines of code!
  prefs: []
  type: TYPE_NORMAL
- en: Your First Sketch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Processing refers to programs as *sketches*. Given the visual and artistic nature
    of what you are likely to produce, it’s a fitting term. Select **File**▶**New**
    to create a new sketch, or use the associated keyboard shortcut (listed alongside
    the menu entry).
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: I’ll go through the specifics of this code in a bit. For now, save the sketch
    by using **File**▶**Save As** and name it *hello_world*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that Processing creates a new folder named *hello_world*; within
    it, there are two files: *hello_world.pyde* and *sketch.properties* ([Figure 1-4](#figure1-4)).
    Depending on your system’s configuration, you may or may not see the file extension
    (*.pyde*). To reopen any sketch, locate and open the *.pyde* file.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f01004](image_fi/500969c01/f01004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-4: The contents of your *hello_world* sketch folder'
  prefs: []
  type: TYPE_NORMAL
- en: You may want to add other assets to your sketch folders, such as images and
    fonts, but more on that later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, click the play (▶) button to execute the code. Better yet, use the associated
    keyboard shortcut: ctrl-R for Windows and Linux, or -R for macOS. A gray 500
    × 500 pixel *display window* should appear. In the console, which is the black
    area at the bottom of the editor, Processing should display `Hello, World!` ([Figure
    1-5](#figure1-5)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s get back to the code you entered in this file; it uses two Processing
    functions: `size()` and `print()`. *Functions* are named instructions, sort of
    like dog commands for computers. Some commands are simple, like “sit,” but something
    like “fetch” may involve specifying what it is that Fido should retrieve.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python functions consist of a function name followed by opening and closing
    *parentheses*, which is where you provide arguments. In the case of my dog-command
    analogy, “ball” could be an argument for “fetch.” The `size()` function ([Figure
    1-6](#figure1-6)) takes two arguments: the first represents the width of your
    sketch, and the second is the height.'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the display window is 500 pixels wide by 500 pixels high.
  prefs: []
  type: TYPE_NORMAL
- en: '![f01005](image_fi/500969c01/f01005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-5: Display window (left) and an editor with `′Hello, World!′` displayed
    in the console (right)'
  prefs: []
  type: TYPE_NORMAL
- en: '![f01006](image_fi/500969c01/f01006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-6: Anatomy of a `size()` function'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `print()` function writes to the console. This function takes a single
    argument: the phrase `''Hello, World!''` Because this is text—or technically,
    *string* data—you need to wrap it in quotation marks. You can use single or double
    quotes, but be sure to use the same type for both opening and closing quotes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python classifies every value according to a *data type*, which determines
    how the value is handled and the operations you can perform on it. For example,
    you can perform arithmetic operations—like division or subtraction—on numeric
    data types but not on strings. In this chapter, you’ll deal with three data types:'
  prefs: []
  type: TYPE_NORMAL
- en: String Text data, like ‘Hello, World!’
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Integer Numbers without decimal points, such as 1, –27, or 422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Floating-point Numbers that include a decimal point, such as 1.618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What separates Processing code from standard Python code are some of its functions;
    the `size()` function, for example, is Processing-specific. In other words, it
    won’t work outside the Processing environment. The `print()` function, on the
    other hand, is a built-in element of the standard Python programming language.
    It works in Processing’s Python Mode and any other Python program.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, I usually refer to Processing-exclusive features in the
    context of *Processing,* and standard Python features with the term *Python*.
    If this is confusing, think of them as one and the same. At this point, distinguishing
    Processing from Python isn’t crucial; you will understand the differences in time.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want Python to ignore any part of your code, you can comment it out.
    This feature is useful for leaving notes, in plain English, to yourself or anybody
    else editing your code. Let’s add a few comments to your *hello_world* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Comments come in two types: single- and multiline. As shown here, use a `#`
    character for single-line comments 1 and `''''''` (or `"""`) for multiline comments
    2.'
  prefs: []
  type: TYPE_NORMAL
- en: While working through the tasks in this book, add comments to remind yourself
    how the code works. Comments are also useful for debugging code. For instance,
    if you suspect that some lines are causing your program to fail, you can temporarily
    disable them by commenting them out.
  prefs: []
  type: TYPE_NORMAL
- en: Whitespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python, and by extension Processing’s Python Mode, is whitespace-sensitive.
    You need to be careful where you insert space characters or tabs. As an example,
    add a few spaces to the beginning of the `size()` line; then run the sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When you run the sketch, the message bar turns red, and Processing displays
    an error message ([Figure 1-7](#figure1-7)). Python relies on indentation to distinguish
    blocks of code. The indented line breaks the program because Python did not encounter
    any code to define a new block for the `size()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![f01007](image_fi/500969c01/f01007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-7: A whitespace error'
  prefs: []
  type: TYPE_NORMAL
- en: Correct the code by removing the problematic space characters you’ve just added.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll come to understand more about when and where to use indentation as you
    progress through these chapters. For now, though, pay careful attention to any
    space and tab characters that affect the indentation of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whitespace issues are not the only error type you will encounter. On occasion,
    you’re likely to miss the odd parenthesis, comma, or quotation mark, especially
    when starting out. Try removing the closing parenthesis from your `size()` function,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now run the code and observe the console output. Note the suggestion in the
    message bar ([Figure 1-8](#figure1-8)). Pretty smart, huh?
  prefs: []
  type: TYPE_NORMAL
- en: '![f01008](image_fi/500969c01/f01008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-8: The alert in the message bar (red) suggests a possible cause for
    the error that Processing encountered.'
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of a *syntax error*, and it’s not the first you’ll encounter.
    Just as English sentences must begin with a capital letter and end with a full
    stop, Python functions must have an opening and a closing parenthesis. When you
    have multiple arguments, you need to separate them using commas. This set of rules
    is called *syntax*. If you don’t conform to the rules, Python will be confounded
    and report an error.
  prefs: []
  type: TYPE_NORMAL
- en: Error messages are not always so clear or accurate, but they can provide a clue
    as to where to start searching for bugs. Copying and pasting the messages into
    a search engine can sometimes help you find a solution.
  prefs: []
  type: TYPE_NORMAL
- en: Color
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can describe colors in various ways in Processing. To keep things simple,
    I’ll stick with *hexadecimal* values for the first example. If you’re familiar
    with graphics software like Adobe Photoshop, Adobe Illustrator, Inkscape, or GIMP,
    you may have seen hexadecimal values in the color picker for those programs.
  prefs: []
  type: TYPE_NORMAL
- en: Processing includes its own color selector ([Figure 1-9](#figure1-9)), which
    you can access from the menu bar by selecting **Tools**▶**Color Selector**. You
    can use this color selector to mix and sample color values. The value that begins
    with a hash mark (#) is the hexadecimal; you use the **Copy** button to copy it,
    so that you can paste it into the code editor.
  prefs: []
  type: TYPE_NORMAL
- en: '![f01009](image_fi/500969c01/f01009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-9: Processing color selector'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your screen displays color pixels by mixing three primary colors—much as you
    mix red, yellow, and blue paint in art class. However, your screen relies on red,
    green, and blue primaries instead. Furthermore, because light blends color in
    an *additive* manner, pixels that combine all three primaries at full intensity
    appear as white. Conversely, a complete absence of any color results in a black
    pixel. Other colors contain varied quantities of red, green, and blue. For example,
    a bright red mixture is created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 100% | 0% | 0%
  prefs: []
  type: TYPE_NORMAL
- en: 'A hexadecimal color value is composed of six hexadecimal digits (`0`, `1`,
    `2`, . . . , `9`, `A`, `B`, `C`, `D`, `E`, `F`) and can be split into three pairs.
    Each pair corresponds to a primary color. Here’s the value for bright red:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#FF0000`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FF` represents a red quantity; the middle `00` is for green; the rightmost
    `00` is for blue. For reasons I won’t get into here, `FF` is the equivalent of
    100 percent. Also, remember that you are mixing light, so `#FFFFFF` is white,
    and `#000000` is black. Here are some other examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 100 percent blue `#0000FF`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dark green `#006600`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dark gray `#505050`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the selector to experiment further and observe how the hexadecimal values
    change as you select different colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fill()` function sets the color used to fill shapes. It accepts up to
    four arguments, depending on the color system you are using. For hexadecimal color,
    use a single argument: the six-digit value prefixed with a `#`, wrapped in quotes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line to the bottom of your *hello_world* sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You have now set the fill color to red. To see this in effect, let’s draw a
    rectangle. The `rect()` function is used for drawing rectangles, and it takes
    four arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first two arguments specify the location of the rectangle’s upper left corner
    ([Figure 1-10](#figure1-10)). Processing’s x-coordinates begin from the left edge
    of the display window; the y-coordinates begin from the top edge.
  prefs: []
  type: TYPE_NORMAL
- en: '![f01010](image_fi/500969c01/f01010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-10: Processing’s coordinate system'
  prefs: []
  type: TYPE_NORMAL
- en: 'The x-y coordinate for the upper left corner of the display window is (0, 0),
    and the lower right is (500, 500). So to move the rectangle down, increase the
    y-coordinate value. Add a new rectangle line to your *hello_world* sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Run the sketch to confirm that the output matches [Figure 1-11](#figure1-11).
    Experiment with the `rect()` arguments to affect the rectangle’s size and position.
  prefs: []
  type: TYPE_NORMAL
- en: '![f01011](image_fi/500969c01/f01011.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-11: `rect(100, 150, 200, 300)`'
  prefs: []
  type: TYPE_NORMAL
- en: You now should be familiar with Processing’s coordinate system. The `rect()`
    is one of many drawing functions; you’ll be introduced to a few more shortly.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ve also learned to define color using hexadecimal values
    that describe different quantities of red, green, and blue light. And you now
    can use a color picker, like the one included with Processing, to mix and sample
    any values you require. You’ll see other systems for defining color in Processing,
    but for most of this book, you’ll use hexadecimal.
  prefs: []
  type: TYPE_NORMAL
- en: Fills and Strokes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you write a `fill()` line, every shape thereafter is filled in with the
    color you specify. That color won’t change until Processing encounters the next
    `fill()` line. In this way, Processing is like painting: you grab a brush and
    dip it in paint, and then everything you paint is influenced by the brush and
    color you last selected. When you want to paint in a different style or color,
    you change out your brush or dip it in a different pot. If you want to disable
    the fill altogether, use `noFill()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the end of your *hello_world* file to draw a smaller
    red rectangle, an orange square, and a square with no fill:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For a square, you have two options: use a `rect()` 1 with matching width and
    height (third and fourth) arguments. Or, use the `square()` 2 function, which
    takes three arguments: x, y, and extent.'
  prefs: []
  type: TYPE_NORMAL
- en: Processing interprets lines of code from top to bottom. As a result, shapes
    at the bottom of your code appear at the top of the visual “stack.” So the previous
    code produces the shapes in [Figure 1-12](#figure1-12).
  prefs: []
  type: TYPE_NORMAL
- en: '![f01012](image_fi/500969c01/f01012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-12: The no-fill square—the last line of your code—is the topmost shape.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Stroke* is another term for *outline*, and you’re likely to use the following
    three stroke functions: `stroke()` to change the color, `strokeWeight()` to change
    the width, and `noStroke()` to disable the stroke altogether. Like `fill()` and
    `noFill()`, the stroke functions affect everything below them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a white stroke, 3 pixels in width, insert the following lines above the
    shape code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `stroke()` line affects every shape that follows it. [Figure 1-13](#figure1-13)
    shows how all of the shapes now have white strokes.
  prefs: []
  type: TYPE_NORMAL
- en: '![f01013](image_fi/500969c01/f01013.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-13: Adding white strokes'
  prefs: []
  type: TYPE_NORMAL
- en: For thicker strokes, you may want to specify whether the corners and tips are
    rounded or sharp. For more information, consult the relevant Processing.py reference
    entries for `strokeCap()` and `strokeJoin()`.
  prefs: []
  type: TYPE_NORMAL
- en: Background Color
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To change the background color, use the `background()` function. Add a background
    line to the end of your sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the sketch and note how everything has disappeared; the entire display
    window is now a flat shade of blue. This is because `background(''#004477'')`
    draws over everything before it, which will be useful when you start working with
    animation. For now, move that line to the top of your code so you can see the
    shapes again ([Figure 1-14](#figure1-14)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that the background function can also accept an image as an argument (I’ll
    introduce images in Chapter 2).
  prefs: []
  type: TYPE_NORMAL
- en: '![f01014](image_fi/500969c01/f01014.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-14: Adding a background color'
  prefs: []
  type: TYPE_NORMAL
- en: Color Modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I’ll use hexadecimal color values for the rest of the chapter, but here’s a
    quick introduction to other color modes, because at some point, you may need to
    express colors in something other than hexadecimal. For example, say you want
    to write code that darkens a bright red fill. First, you will recall that this
    is a shade of bright red:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also represent this color as the following in RGB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this arrangement, each red/green/blue value is comma-separated. As you might
    have already deduced, `255` is equivalent to `FF` (which itself is equivalent
    to 100 percent). To make the red half as bright, you can subtract `127` from `255`.
    However, trying to subtract `127` from `FF` is tricky because you’re dealing with
    a mix of hexadecimal and decimal numbers. In this instance, it’s easier to stick
    with decimal values (255 – 127 = 128).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `fill(255, 0, 0)` cits `colorMode()` set to `RGB`. You don’t need
    to specify this, though, as it’s the default mode. Here’s how it works: if Processing
    detects a single argument in quotes (like `''#FF0000''`), it interprets it as
    hexadecimal, but if you provide three arguments, it automatically knows that you
    are using the system of 0 to 255.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you can use another mode: HSB. Once set to `HSB` mode, the three `fill()`
    arguments represent *hue*, *saturation*, and *brightness*, respectively. To better
    understand how those variables affect color, let’s take a look at the color picker
    of GIMP, an open source image editor ([Figure 1-15](#figure1-15)).'
  prefs: []
  type: TYPE_NORMAL
- en: Rotating the large triangle adjusts the H value between 0 and 360 degrees; the
    H (hue) field corresponds to the white line at the triangle’s lower right tip.
    You move the small white circle (inside the triangle) to adjust the S (saturation)
    and V (value) fields. *Value* and *brightness* are interchangeable terms in this
    context, so the V corresponds to the B in HSB.
  prefs: []
  type: TYPE_NORMAL
- en: '![f01015](image_fi/500969c01/f01015.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-15: Hue: 330 degrees; saturation: 90 percent; value/brightness: 80
    percent'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have GIMP installed, or software with a similar color picker, I encourage
    you to experiment with it. To mimic the GIMP scheme in Processing, set the color
    mode accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HSB` represents the mode, `360` represents the range of degrees for hue,
    and the two `100` arguments represent a range of 0 to 100 percent for saturation
    and brightness. You would now write a red fill as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is because bright red lies at 0 degrees of rotation on the hue ring (which
    begins at “East” in the GIMP mixer) and has a saturation and brightness of 100
    percent ([Figure 1-16](#figure1-16)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f01016](image_fi/500969c01/f01016.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-16: Hue: 0 degrees; saturation: 100 percent; value/brightness: 100
    percent'
  prefs: []
  type: TYPE_NORMAL
- en: In HSB mode, shifting along the color spectrum—from red to orange to yellow
    to green, and so on—is a simple matter of adding to or subtracting from the H
    value. Attempting the same in RGB mode is not so easy, as you need to adjust the
    proportions of each primary color.
  prefs: []
  type: TYPE_NORMAL
- en: The chapters to come will cover even more on color. Consult the relevant Processing.py
    reference entries for `colorMode()` and `fill()` if you need more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 2D Primitives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s move on to drawing basic shapes. Begin a new sketch (**File**▶**New**)
    and save it as *primitives_2d* (**File**▶**Save As**). Add this code to set things
    up before proceeding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now when you run the sketch, thanks to `background('#004477')`, an empty blue
    display window appears. Any shapes that you draw will have no fill and a white
    stroke of 3 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, draw three points by using the `point()` function ([Figure 1-17](#figure1-17)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `point()` function accepts two arguments, which represent the x- and y-coordinates.
    The active `strokeWeight()` determines the size of the points.
  prefs: []
  type: TYPE_NORMAL
- en: '![f01017](image_fi/500969c01/f01017.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-17: Three points drawn with the `point()` function'
  prefs: []
  type: TYPE_NORMAL
- en: What follows are descriptions for several drawing functions, along with code
    to add to your working sketch. Experiment with the arguments to see how the finished
    version ([Figure 1-18](#figure1-18)) responds.
  prefs: []
  type: TYPE_NORMAL
- en: '![f01018](image_fi/500969c01/f01018.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-18: An assortment of 2D primitives'
  prefs: []
  type: TYPE_NORMAL
- en: triangle()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `triangle()` function draws a triangle. The six arguments represent three
    x-y coordinate pairs. I have grouped each x-y pair by removing the space character
    after every other argument so it’s easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Python is not sensitive to whitespace between arguments, so if you find it helpful
    to format your code in a similar fashion, feel free to do so.
  prefs: []
  type: TYPE_NORMAL
- en: ellipse()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ellipse()` function draws an ellipse. The first pair of arguments represents
    an x-y coordinate that marks the center of the ellipse; the second pair of arguments
    represents the ellipse’s width and height:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For a circle, you can use the `ellipse()` function with matching width and
    height (third and fourth) arguments. Alternatively, you can use the `circle()`
    function, which takes three arguments: x, y, and diameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `circle()` and `square()` functions are relatively new to Processing, so
    you may find that many of the examples (**File**▶**Examples**) and online code
    rely on only `ellipse()` and `rect()`.
  prefs: []
  type: TYPE_NORMAL
- en: quad()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `quad()` function draws a *quadrilateral* (a four-sided polygon). Essentially,
    it’s like a triangle function with an extra point, and its eight arguments represent
    four x-y coordinate pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: line()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `line()` function draws a straight line between two points. The first pair
    of arguments represents the starting x-y coordinates, and the second pair, the
    ending x-y coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As with points and shapes, the width of a line is affected by any preceding
    `strokeWeight()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The 2D primitive functions provide an easy way to draw shapes in the display
    window. There’s one more shape function to review, `arc()`, but it’s a bit more
    involved than the other shapes. Variables and arithmetic operators will prove
    useful for drawing arcs, so I’ll cover those first. Before moving on, though,
    here’s a quick challenge to practice what you’ve learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Challenge #1: Rainbow Task'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Begin a new sketch (**File**▶**New**) and save it as *rainbow* (**File**▶**Save
    As**). Add this code to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Using what you’ve learned so far, complete the rainbow in [Figure 1-19](#figure1-19).
  prefs: []
  type: TYPE_NORMAL
- en: 'Clue: think about how you can overlap shapes to mask others. If you need help,
    you can access the solution at [https://github.com/tabreturn/processing.py-book/tree/master/chapter-01-hello,world!/rainbow/](https://github.com/tabreturn/processing.py-book/tree/master/chapter-01-hello,world!/rainbow/).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f01019](image_fi/500969c01/f01019.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-19: Recreate this rainbow.'
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Variables* are placeholders for information—much like when you use letters
    in algebra to represent a value. In fact, Python variables look and behave quite
    similarly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin a new sketch and save it as *variables*. To keep things simple, you’ll
    print values to the console area. Add the following code to set up the sketch
    and print its width and height (in pixels):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you run the sketch, the display window’s width and height should be printed
    to the console, as shown in [Figure 1-20](#figure1-20).
  prefs: []
  type: TYPE_NORMAL
- en: But notice that you never explicitly defined `width` or `height`. Processing
    automatically assigned the width and height of the display window to these two
    variables. From this, you can establish that `width` and `height` are variables
    for which Processing maintains the values. Predefined variables like these are
    called *system variables*.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you are not limited to system variables; you can also define your
    own. When declaring new variables, assign them a value by using an equal sign
    (`=`), which is called the *assignment operator*. Try this out with a new variable
    named `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![f01020](image_fi/500969c01/f01020.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-20: Printing variables to the console'
  prefs: []
  type: TYPE_NORMAL
- en: The variable `x` is equal to 10, so the `print()` function displays a `10` in
    the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can name your variables whatever you like, provided that the name contains
    only alphanumeric and underscore characters, doesn’t begin with a number, and
    doesn’t clash with any reserved keywords or variables (like `width`). For example,
    the following shows several possible variable names (the comments indicate which
    are correct):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Whether you should name a multiword variable using *camelCase*, underscores,
    or another convention is a matter of style (and vociferous debate), but it’s good
    to decide on a naming convention and stick to it, as you’ll make extensive use
    of variables in Processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add three more variables to your script for use as arguments in a `rect()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `y` variable indicates the y-coordinate; `w` indicates the width; and `h`
    indicates the height value for the `rect()` function. Notice that the `h` value
    is equal to the `w` value (of 100). You’ve already defined `x` as equal to 10\.
    Run the sketch to confirm that it displays a white square positioned near the
    upper left corner of the display window ([Figure 1-21](#figure1-21)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f01021](image_fi/500969c01/f01021.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-21: A square using variables as coordinates'
  prefs: []
  type: TYPE_NORMAL
- en: Experiment further on your own with shapes and variables. In the next section,
    you’ll learn to use variables to perform mathematical calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Arithmetic operators* perform arithmetic operations on *operands*; this is
    far simpler than it probably sounds. For instance, in the expression 1 + 3, the
    plus sign is the operator, and the numbers 1 and 3 are the operands. To better
    understand how this all works in Python, let’s go through some examples.'
  prefs: []
  type: TYPE_NORMAL
- en: Basic Operations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add the following line to the end of your *variables* sketch to calculate what
    variable `x` plus 2 is equal to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Run the sketch and check the bottom line of the console output. I’m guessing
    the code did exactly what you expected. Earlier in the chapter, you assigned a
    value of 10 to variable `x`, and 10 + 2 is equal to 12, which is what you will
    see in your console.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also subtract (see the comments for the result):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `*` operator for multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try this line, but before running it, see if you can predict the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The console displays a `7` and not a `9` because multiplication occurs before
    addition. Certain operators take precedence over others. Remember PEMDAS? It’s
    an acronym to help you recall the *order of operations*, which is parentheses
    first, then exponents, then multiplication/division, then addition/subtraction.
    (Some people may be more familiar with the acronyms BEDMAS or BODMAS, which use
    the terms *brackets* for *parentheses,* and *of* or *order* to indicate exponents.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want the addition to happen first, use parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For division, use a forward slash (`/`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Be aware that dividing two integers always produces an integer result (integers
    are whole numbers, as opposed to those with a decimal point). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Processing discards any decimal digits, effectively rounding down the result.
    Note, however, that this is Python 2 behavior. At the time of this writing, Processing’s
    Python Mode uses Python 2.7\. If you ever find yourself writing Python 3 code,
    the result will be 1.5.
  prefs: []
  type: TYPE_NORMAL
- en: 'For floating-point division in Python 2, define at least one of your operands
    by using a decimal point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This line displays a 1.5 in Python versions 2 and 3\. This book avoids any Python
    code that isn’t compatible with Python 3\. Rest assured, you can apply your newly
    acquired coding skills in Python 2 and 3 development. Should Processing switch
    to Python 3, your code will still run fine.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, division-by-zero operations will result in errors ([Figure 1-22](#figure1-22)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f01022](image_fi/500969c01/f01022.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-22: Division-by-zero error'
  prefs: []
  type: TYPE_NORMAL
- en: Processing uses other arithmetic operators (for floor division and exponents)
    that aren’t necessary to review here. The modulo operator, however, warrants a
    brief introduction.
  prefs: []
  type: TYPE_NORMAL
- en: Modulo Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *modulo operator* calculates the remainder of a division operation and is
    expressed as a percentage sign (`%`). Take 5 divided by 2 as an example. You could
    say the answer is 2.5, or you could say the answer is 2 remainder 1, because 2
    “goes into” 5 twice with 1 left over.
  prefs: []
  type: TYPE_NORMAL
- en: 'The modulo operator performs the latter operation and provides the remainder.
    Here’s some code contrasting division and modulus (as before, the comments show
    the output):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'It may not be evident why this operator is useful. However, many important
    algorithms, such as those used in cryptography, use modular arithmetic. For now,
    consider that modulo operations resulting in a `0` indicate that numbers divide
    exactly. Among other uses, this is handy for establishing whether a number is
    odd or even:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You’ll use the modulo operator in the chapters to come.
  prefs: []
  type: TYPE_NORMAL
- en: Arcs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that I’ve covered variables and some basic math, I can introduce the `arc()`
    function, which is used to draw elliptical arcs. Let’s look at a few examples
    to see how this one works. Create a new sketch and save it as *disk_space_analyzer*.
    Add the following setup code that will define some visual parameters to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `arc()` function takes the following arguments, expanded across multiple
    lines here for easier comprehension (recall that Python is not sensitive to whitespace
    between function arguments):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Add an arc to your sketch by using a `start_angle` of `0` and `end_angle` of
    `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The green overlay in [Figure 1-23](#figure1-23) helps illustrate how the arguments
    work. Processing draws the arc along the perimeter of an invisible ellipse centered
    in the display window. The center of this ellipse has an x-y coordinate of `width/2`,
    `height/2`; it’s 200 pixels wide and 200 pixels high. An angle of `0` is positioned
    at East, which opens clockwise to an angle of `2`, which looks more like around
    115 degrees of rotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this large angle is that Processing uses *radians* and not degrees
    to measure angles; 1 radian is equal to roughly 57.3 degrees. Why use radians?
    Radians, a standard unit of angular measure used in many areas of mathematics,
    provide more natural and elegant formulas for circular motion. Think about this:
    why are there 360 degrees in a full circle? Why not 300 or 100, or even a million
    degrees? While I’m on the topic, why are there 60 minutes in an hour? Or 24 hours
    in a day? Much of this has to do with ancient counting systems.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f01023](image_fi/500969c01/f01023.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-23: An arc with a start angle value of 0 and end angle of 2'
  prefs: []
  type: TYPE_NORMAL
- en: Rather than dividing a circle into an arbitrary number of slices (like 360),
    the radian system is based on a proportional measurement involving a circle’s
    *radius*. [Figure 1-24](#figure1-24) illustrates how radians are defined. Beginning
    with the left graphic, take the radius of any circle; create an arc of that same
    length; then measure the angle formed between the tips of the arc and the center
    of the circle to derive one radian.
  prefs: []
  type: TYPE_NORMAL
- en: '![f01024](image_fi/500969c01/f01024.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-24: Defining a radian'
  prefs: []
  type: TYPE_NORMAL
- en: If 1 radian is equal to approximately 57.3 degrees, 2 radians equal 114.6 degrees.
    This makes 180 degrees equivalent to roughly 3.142 radians ([Figure 1-25](#figure1-25)).
    Do you recognize that number? Yep, it’s pi!
  prefs: []
  type: TYPE_NORMAL
- en: '![f01025](image_fi/500969c01/f01025.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-25: Measuring the number of radians in a half- and full circle'
  prefs: []
  type: TYPE_NORMAL
- en: Processing provides the `degrees()` and `radians()` functions for converting
    between the systems, but you should be fine working in radians if you can remember
    a few key measurements. For starters, 0 degrees is equal to 0 radians, and 180
    degrees is equal to *π* radians. Therefore, 360 degrees is equal to 2π radians.
    In Processing, you can use the system variable `PI` instead of writing a lengthy
    decimal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to draw a half-circle and a full circle using `arc()`
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Run the sketch. The first new arc begins at `0` and ends at `PI`, resulting
    in a half-circle; the second outermost and largest arc has an end angle of `PI*2`,
    and therefore, it appears as a complete circle.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to close an arc, so as to form a “slice,” add an additional `PIE`
    argument. Add the following line to test this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The arc spans from 3.4 radians (around 10 o’clock) to ~4.7 radians (12 o’clock).
    [Figure 1-26](#figure1-26) depicts the final result. You can identify the most
    recent arc by its slice shape.
  prefs: []
  type: TYPE_NORMAL
- en: '![f01026](image_fi/500969c01/f01026.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-26: Here are four arcs, and one of them is a complete circle. The
    slice-like arc (upper left) uses the `PIE` argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Challenge #2: Disk Usage Analyzer'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now for a final challenge before moving on to Chapter 2. A *disk usage analyzer*
    presents a graphical representation of a disk drive’s contents. The Linux GNOME
    Disk Usage Analyzer (also known as *Baobab*) is one example of such software,
    and its charts make good use of arcs.
  prefs: []
  type: TYPE_NORMAL
- en: Recreate the ring chart graphic in [Figure 1-27](#figure1-27) by using what
    you have learned thus far. Begin by commenting out your existing arc lines, and
    then continue to work in the same sketch file. (The text and number labels have
    been added to assist you with calculations; do not add them to your recreation.)
  prefs: []
  type: TYPE_NORMAL
- en: '![f01027](image_fi/500969c01/f01027.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-27: Disk usage analyzer chart'
  prefs: []
  type: TYPE_NORMAL
- en: If you need help, remember you can access all of the solutions to the challenges
    at [https://github.com/tabreturn/processing.py-book/](https://github.com/tabreturn/processing.py-book/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You now have Python Mode for Processing up and running. You also know how to
    set up a new sketch, set the size of your display window, and apply a background
    color. You’ve learned to display messages like ‘Hello, World!’ in the console
    and draw shapes using 2D primitive functions. You’ve also learned about color
    and how to define the color of your strokes and fills in hexadecimal, or using
    RGB and HSB color modes. In addition, you should understand how to use radians
    to measure angles and work with the `arc()` function.
  prefs: []
  type: TYPE_NORMAL
- en: While getting started with Processing, you’ve also learned a few Python programming
    fundamentals, like how to manage whitespace, add code comments, and use arithmetic
    operators to perform mathematical operations. You’ve also seen how to use Python
    variables, which are placeholders for data. Processing includes system variables,
    like `width` and `height`, but you can store values in your own variables, provided
    that the variable names adhere to Python’s naming rules.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 2, you’ll learn how to draw more organic, as opposed to geometric,
    shapes. You’ll also gain insight into the inner workings of vector graphics software
    like Adobe Illustrator and Inkscape.
  prefs: []
  type: TYPE_NORMAL
