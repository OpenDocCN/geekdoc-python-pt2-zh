<html><head></head><body>
<h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_151"/><strong><span class="blue"><span class="big">9</span></span><br/>UNPACKING YOUR PERSONAL ITEMS</strong></h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">Now that the space station is operational, it’s time to unpack your personal items and the various tools and pieces of equipment you’ll need as you carry out your work.</p>
<p class="indent">In this chapter, you’ll build the code for objects that can move between rooms (<em>props</em>). When you play the game, you’ll be able to discover new items, pick them up, move them around, and use them to solve puzzles.</p>
<h3 class="h3" id="lev117"><strong>ADDING THE PROPS INFORMATION</strong></h3>
<p class="noindent">You’ve already added some information about props in <a href="ch05.xhtml#ch05">Chapter 5</a> when you added the image filenames and descriptions to the <code>objects</code> dictionary. The <code>objects</code> dictionary contains information about <em>what</em> an item is. In this chapter, we’ll add information to tell the game <em>where</em> the props go.</p>
<p class="indent">You might be wondering why we’re handling the props separately from the scenery. We do this because their information is used in different ways: the <code>scenery</code> dictionary stores information using the room as the key. This makes sense, because the program needs to get information about <span epub:type="pagebreak" id="page_152"/>all the scenery in a room at the same time. After the scenery information is added to the room map, the <code>scenery</code> dictionary is not needed again until the player enters a new room.</p>
<p class="indent">By contrast, props move around, so the information for a prop might be needed at any time in any room. If that information is buried in a list of scenery items, it’s harder to find and change.</p>
<p class="indent">We’ll create a new dictionary called <code>props</code> to store information about props. We’ll use the object number as a key, and each entry will be a list that contains the following:</p>
<ul>
<li class="noindent">The number of the room the prop is in</li>
<li class="noindent">The <em>y</em> position of the prop in the room (in tiles)</li>
<li class="noindent">The <em>x</em> position of the prop in the room (in tiles)</li>
</ul>
<p class="indent">For example, here’s the entry for the hammer, which is object 65:</p>
<pre>65: [50, 1, 7]</pre>
<p class="indent">It’s in room 50, at <em>y</em> position 1 and <em>x</em> position 7.</p>
<p class="indent">Objects that are not in the game world or that are being carried by the player will have a room number of 0, which is not a real location in the game. Some objects aren’t in the game world until they’ve been created or after they’ve been destroyed, for example. These would be stored in room 0.</p>
<div class="sidebar1">
<p class="sidebart"><strong>TIP</strong></p>
<p class="spara">The <code>props</code> and <code>objects</code> dictionaries use the same keys. If you want to know what item 65 is in the <code>props</code> dictionary, read its details in the <code>objects</code> dictionary.</p>
</div>
<p class="indent"><a href="ch09.xhtml#ch09list1">Listing 9-1</a> shows the code for adding the props information to the game. Open <em>listing8-10.py</em>, your final program from the previous chapter. Add the new <code>PROPS</code> section after the <code>show_text()</code> function in the <code>DISPLAY</code> section and before the <code>START</code> section. Only add the new lines, and save the new program as <em>listing9-1.py</em>. If you want to avoid typing the data, you can copy and paste it from the <em>data-chapter9.py</em> file.</p>
<p class="indent">You can run the program with <span class="codestrong">pgzrun listing9-1.py</span>. It won’t do anything new yet, but you can check whether there are any error messages in the command line window.</p>
<p class="margin"><em>listing9-1.py</em></p>
<pre>   <span class="gray">--<span class="codeitalic1">snip</span>--</span><br/>       <span class="gray">screen.draw.text(text_to_show,</span><br/>                        <span class="gray">(20, text_lines[line_number]), color=GREEN)</span><br/><br/><br/>   <span class="red">###############</span><br/>   <span class="red">##   PROPS   ##</span><br/>   <span class="red">###############</span><br/><span epub:type="pagebreak" id="page_153"/>   <span class="red"># Props are objects that may move between rooms, appear or disappear.</span><br/>   <span class="red"># All props must be set up here. Props not yet in the game go into room 0.</span><br/>   <span class="red"># object number : [room, y, x]</span><br/><span class="ent">➊</span> props = {<br/>       20: [31, 0, 4], 21: [26, 0, 1], 22: [41, 0, 2], 23: [39, 0, 5],<br/>       24: [45, 0, 2],<br/><span class="ent">➋</span>     25: [32, 0, 2], 26: [27, 12, 5], <span class="red"># two sides of same door</span><br/>       40: [0, 8, 6], 53: [45, 1, 5], 54: [0, 0, 0], 55: [0, 0, 0],<br/>       56: [0, 0, 0], 57: [35, 4, 6], 58: [0, 0, 0], 59: [31, 1, 7],<br/>       60: [0, 0, 0], 61: [36, 1, 1], 62: [36, 1, 6], 63: [0, 0, 0],<br/>       64: [27, 8, 3], 65: [50, 1, 7], 66: [39, 5, 6], 67: [46, 1, 1],<br/>       68: [0, 0, 0], 69: [30, 3, 3], 70: [47, 1, 3],<br/><span class="ent">➌</span>     71: [0, LANDER_Y, LANDER_X], 72: [0, 0, 0], 73: [27, 4, 6],<br/>       74: [28, 1, 11], 75: [0, 0, 0], 76: [41, 3, 5], 77: [0, 0, 0],<br/>       78: [35, 9, 11], 79: [26, 3, 2], 80: [41, 7, 5], 81: [29, 1, 1]<br/>       }<br/><br/>   checksum = 0<br/>   <span class="orange">for</span> key, prop <span class="orange">in</span> props.items():<br/><span class="ent">➍</span>     <span class="orange">if</span> key != 71: <span class="red"># 71 is skipped because it's different each game.</span><br/>           checksum += (prop[0] * key<br/>                        + prop[1] * (key + 1)<br/>                        + prop[2] * (key + 2))<br/><span class="ent">➎</span> <span class="purple">print</span>(<span class="purple">len</span>(props), <span class="green">"props"</span>)<br/>   <span class="orange">assert</span> <span class="purple">len</span>(props) == 37, <span class="green">"Expected 37 prop items"</span><br/>   <span class="purple">print</span>(<span class="green">"Prop checksum:"</span>, checksum)<br/><span class="ent">➏</span> <span class="orange">assert</span> checksum == 61414, <span class="green">"Error in props data"</span><br/><br/><span class="ent">➐</span> in_my_pockets = [55]<br/>   selected_item = 0 <span class="red"># the first item</span><br/>   item_carrying = in_my_pockets[selected_item]<br/><br/><br/>   <span class="gray">###############</span><br/>   <span class="gray">##   START   ##</span><br/>   <span class="gray">###############</span><br/>   <span class="gray">--<span class="codeitalic1">snip</span>--</span></pre>
<p class="listing" id="ch09list1"><em>Listing 9-1: Adding the props information to</em> Escape</p>
<p class="indent">We start the new <code>PROPS</code> section by creating the dictionary to store the information about the props <span class="ent">➊</span>. This dictionary lists the position locations for all the props, starting with some doors (20 to 24) and including a rescue ship (40) and the carryable items starting at 53.</p>
<p class="indent">There is just one oddity to draw your attention to. We count doors as props rather than scenery, because they’re not always there: when they’re open, they’re removed from the room. Most doors stay open when they’re opened until the game ends. However, the door that connects rooms 27 and 32 can also shut, meaning players can see it from both sides. As a result, we need two props to represent this door <span class="ent">➋</span>, showing it in the top of room 27 and the bottom of room 32. These two doors are object numbers 25 and 26.</p>
<p class="indent">Prop 71 is the Poodle lander, which crash-landed on the planet surface before the game began. We use the <code>LANDER_Y</code> and <code>LANDER_X</code> variables from the <span epub:type="pagebreak" id="page_154"/><code>VARIABLES</code> part of the program <span class="ent">➌</span> to position the lander, because its location will change with each new game. The Poodle landed with such force that it might have become covered with Martian soil. It lives in room 0 until the player can dig it up.</p>
<p class="indent">As with the scenery information (see <a href="ch06.xhtml#ch06">Chapter 6</a>), I’ve used a checksum here to help you spot whether you made an error entering the data. It might not be possible to play the game all the way to the end if a mistake is made here. The only prop missing from the checksum calculation is number 71, because its position uses different random numbers in each game <span class="ent">➍</span>.</p>
<p class="indent">If you want to change the props data, the easiest thing to do is to comment out the two checksum instructions <span class="ent">➏</span> like this to turn them off:</p>
<pre><span class="red">#assert len(props) == 37, "Expected 37 prop items"</span><br/><span class="red">#assert checksum == 61414, "Error in props data"</span></pre>
<p class="indent">The program shows the checksum total and number of data items in the command line window <span class="ent">➎</span>, so if you change the props data, you can use this information to update the numbers in the two <code>assert</code> instructions so they are correct for your customized data. If you do this, you can continue using these lines rather than commenting them out.</p>
<p class="indent">The program also sets up two new variables and a list we’ll need later in the chapter. The <code>in_my_pockets</code> <span class="ent">➐</span> list stores all the items the player has picked up, also known as their <em>inventory</em>. One of these items is always selected, so the player is ready to do something with it. The <code>selected_item</code> variable stores its index number in the <code>in_my_pockets</code> list. The <code>item_carrying</code> variable stores the object number of the item the player has selected. You can think of the <code>item_carrying</code> variable as being the number of the object in their hands. I’ll tell you more about these variables later in this chapter.</p>
<h3 class="h3" id="lev118"><strong>ADDING PROPS TO THE ROOM MAP</strong></h3>
<p class="noindent">We’ve added the information about where the props are located, so now let’s display the props. We’ll make it so that when props are located in the current room, they’re put into the <code>room_map</code> list as the player enters the room. Then the <code>draw()</code> function uses that list to draw the room.</p>
<p class="indent">We’ll place the instructions to add the props to the room map into the <code>MAKE MAP</code> part of the program, inside the <code>generate_map()</code> function. We’ll simply add these instructions after the instructions you added in <a href="ch08.xhtml#ch08">Chapter 8</a> for working out the <code>top_left_x</code> and <code>top_left_y</code> variables, just above the start of the <code>GAME LOOP</code> section.</p>
<p class="indent">Because the new instructions are all part of the <code>generate_map()</code> function, you need to indent them by at least four spaces.</p>
<p class="indent">Add the new instructions shown in <a href="ch09.xhtml#ch09list2">Listing 9-2</a> to your program, and save it as <em>listing9-2.py</em>. Run the program with <span class="codestrong">pgzrun listing9-2.py</span>. You should see that new objects have appeared in some of the rooms, as shown in <a href="ch09.xhtml#ch09fig1">Figure 9-1</a>.</p>
<div class="image"><span epub:type="pagebreak" id="page_155"/><a id="ch09fig1"/><img src="../images/fig9-1.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 9-1: That door wasn’t there a minute ago! That air canister might come in handy, though.</em></p>
<p class="margin"><em>listing9-2.py</em></p>
<pre>   <span class="gray">--<span class="codeitalic1">snip</span>--</span><br/>       <span class="gray">top_left_x = center_x - 0.5 * room_pixel_width</span> <br/>       <span class="gray">top_left_y = (center_y - 0.5 * room_pixel_height) + 110</span><br/><br/><span class="ent">➊</span>     <span class="orange">for</span> prop_number, prop_info <span class="orange">in</span> props.items():<br/><span class="ent">➋</span>         prop_room = prop_info[0]<br/>           prop_y = prop_info[1]<br/>           prop_x = prop_info[2]<br/><span class="ent">➌</span>         <span class="orange">if</span> (prop_room == current_room <span class="orange">and</span><br/><span class="ent">➍</span>             room_map[prop_y][prop_x] <span class="orange">in</span> [0, 39, 2]):<br/><span class="ent">➎</span>                 room_map[prop_y][prop_x] = prop_number<br/><span class="ent">➏</span>                 image_here = objects[prop_number][0]<br/>                   image_width = image_here.get_width()<br/>                   image_width_in_tiles = <span class="purple">int</span>(image_width / TILE_SIZE)<br/><span class="ent">➐</span>                 <span class="orange">for</span> tile_number <span class="orange">in</span> <span class="purple">range</span>(1, image_width_in_tiles):<br/>                       room_map[prop_y][prop_x + tile_number] = 255<br/><br/><br/>   <span class="gray">###############</span><br/>   <span class="gray">## GAME LOOP ##</span><br/>   <span class="gray">###############</span><br/>   <span class="gray">--<span class="codeitalic1">snip</span>--</span></pre>
<p class="listing" id="ch09list2"><em>Listing 9-2: Adding the props to the room map for the current room</em></p>
<p class="indent">In the new code, we start by setting up a loop to go through the items in the <code>props</code> dictionary <span class="ent">➊</span>. For each item, the dictionary key goes into the variable <code>prop_number</code>, and the list with the position information goes into the list <code>prop_info</code>.</p>
<p class="indent">To make the program easier to read, I’ve set up some variables to store the information from the <code>prop_info</code> list <span class="ent">➋</span>. The program extracts the information for the room number (and puts it into <code>prop_room</code>) and the <em>y</em> and <em>x</em> positions (which go into the <code>prop_y</code> and <code>prop_x</code> variables).</p>
<p class="indent"><span epub:type="pagebreak" id="page_156"/>We add a check to see whether the <code>prop_room</code> matches the room the player is in <span class="ent">➌</span> and whether the prop is sitting on the floor <span class="ent">➍</span>. The floor check puts the three different floor types in a list (0 for inside, 2 for soil, and 39 for the pressure pad in room 26). The program checks the prop’s position to see what’s in that location in the room map. If it’s one of these floor types, it means the object is sitting on the floor in full view. If not, the prop is hidden inside an item of scenery and shouldn’t be visible yet. For example, if a cabinet is in the prop’s location instead of the floor, the prop won’t be shown onscreen. The player can still find the prop by examining the cabinet at that location, though.</p>
<p class="indent">If the prop is in the room and on the floor, the room map is updated with the prop number <span class="ent">➎</span>.</p>
<p class="indent">Some props, like doors, are wider than one tile. So we add the number 255 to any tiles that the prop covers other than the first one <span class="ent">➐</span>. This is similar to the code we used to mark wide scenery earlier in the <code>generate_map()</code> function (see <a href="ch06.xhtml#ch06list4">Listing 6-4</a> on <a href="ch06.xhtml#page_106">page 106</a>).</p>
<div class="sidebar1">
<p class="sidebart"><strong>GETTING INFORMATION FROM A FUNCTION: ROLLING DICE</strong></p>
<p class="spara">In <a href="ch08.xhtml#ch08">Chapter 8</a>, you learned how to send information (or <em>arguments</em>) to a function. Let’s look more closely at how to get information <em>back</em> from a function. We’ll use this skill to create a function that tells us what object the player is standing on.</p>
<p class="spara1"><a href="ch09.xhtml#ch09list3">Listing 9-3</a> shows a simple program that sends a number back from a function and puts it into a variable. This isn’t part of the <em>Escape</em> game, so create a new file by clicking <strong>File</strong> <span class="ent">▸</span> <strong>New</strong> first.</p>
<p class="spara1">Save the program as <em>listing9-3.py</em>. This program doesn’t use Pygame Zero, so you can run it using <strong>Run</strong> <span class="ent">▸</span> <strong>Run Module</strong> in the script window. The program simulates a 10-sided die.</p>
<p class="margin"><em>listing9-3.py</em></p>
<pre><span class="ent">➊</span> import random<br/><br/><span class="ent">➋</span> <span class="orange">def</span> <span class="blue">get_number</span>():<br/><span class="ent">➌</span>     die_number = random.randint(1, 10)<br/><span class="ent">➍</span>     <span class="orange">return</span> die_number<br/><br/><span class="ent">➎</span> random_number = get_number()<br/><span class="ent">➏</span> <span class="purple">print</span>(random_number)</pre>
<p class="listing" id="ch09list3"><em>Listing 9-3: A 10-sided die simulator shows how to send a number back from a function.</em></p>
<p class="spara1">This program starts by telling Python to use the <code>random</code> module <span class="ent">➊</span>, which gives Python new functions for making random choices. We then create a new function called <code>get_number()</code> <span class="ent">➋</span>, which generates a random number between 1 and 10 <span class="ent">➌</span> and puts the result into a variable called <code>dice_number</code>.</p>
<p class="spara1"><span epub:type="pagebreak" id="page_157"/>Normally, when you start a function (known as <em>calling</em> a function in Python jargon), you use its name, like this:</p>
<pre>get_number()</pre>
<p class="spara1">This time, we not only start the function, but tell Python to put the result from the function into a variable called <code>random_number</code> <span class="ent">➎</span>. When the function sends its result back using the <code>return</code> command <span class="ent">➍</span>, the result goes into the <code>random_number</code> variable. The main part of the program can then print out its value <span class="ent">➏</span>.</p>
<p class="spara1">This code shows that the way to get information from a function is to set up a variable to store the information when the function is started <span class="ent">➎</span> and to use the <code>return</code> instruction to send that information back when the function finishes <span class="ent">➍</span>. You can send strings and lists back too, not just numbers. Where possible, this is the best way to enable other parts of the program to use information from a function. This technique enables the main part of the program to get information from a function’s local variable (in this case <code>dice_number</code>), which would usually only be visible inside that function.</p>
<p class="spara1">You won’t need this program again, so you can close it when you’ve finished experimenting with it.</p>
</div>
<h3 class="h3" id="lev119"><strong>FINDING AN OBJECT NUMBER FROM THE ROOM MAP</strong></h3>
<p class="noindent">Shortly, we’ll add the code to enable you to pick up objects in the space station. First we need a way to find out which object is being picked up.</p>
<p class="indent">When the player interacts with scenery or props, we need to find the number of the object they’re using. Normally, this is simple. If the room map shows that the object number of the prop at the player’s location is 65, that’s a hammer. The program can show a description of the hammer, and let the player pick it up or use it.</p>
<p class="indent">Identifying the object number gets tricky with wide objects that span multiple tiles. We use the number 255 to mark tiles covered by a wide object, but that number doesn’t correspond to a prop. The program needs to work out what the real object number is by moving left in the room map until it finds a number that isn’t 255.</p>
<p class="indent">For example, if the player examines the rightmost third of a door, the program would see that this position contains 255, so it would check the position to the left. That position also contains 255, so the program would check farther left. If that tile contains a number other than 255, the program knows it’s found the real object number, which might be 20 (one of the doors), for example. Using the object number 20, the program can then let the player examine or open the door.</p>
<p class="indent">We’ll create two functions that will work out the object number, shown in <a href="ch09.xhtml#ch09list4">Listing 9-4</a>. You need to add these to <a href="ch09.xhtml#ch09list2">Listing 9-2</a>, so click <strong>File</strong> <span class="ent">▸</span> <strong>Open</strong> to open <em>listing9-2.py</em> again if necessary. We’ll start a new section of the <span epub:type="pagebreak" id="page_158"/>program called <code>PROP INTERACTIONS</code>. Put this after the <code>PROPS</code> section. This new section will be where we put the code for picking up and dropping props.</p>
<p class="indent">Save the updated program as <em>listing9-4.py</em>. It won’t do anything new yet, but you can run it using <span class="codestrong">pgzrun listing9-4.py</span> to check that you haven’t added any mistakes. Look in the command line window for any error messages.</p>
<p class="margin"><em>listing9-4.py</em></p>
<pre>   <span class="gray">--<span class="codeitalic1">snip</span>--</span><br/>   <span class="gray">in_my_pockets = [55]</span><br/>   <span class="gray">selected_item = 0 # the first item</span><br/>   <span class="gray">item_carrying = in_my_pockets[selected_item]</span><br/><br/>   <span class="red">#######################</span><br/>   <span class="red">## PROP INTERACTIONS ##</span><br/>   <span class="red">#######################</span><br/><br/><span class="ent">➊</span> <span class="orange">def</span> <span class="blue">find_object_start_x</span>():<br/><span class="ent">➋</span>     checker_x = player_x<br/><span class="ent">➌</span>     <span class="orange">while</span> room_map[player_y][checker_x] == 255:<br/><span class="ent">➍</span>         checker_x -= 1<br/><span class="ent">➎</span>     <span class="orange">return</span> checker_x<br/><br/><span class="ent">➏</span> <span class="orange">def</span> <span class="blue">get_item_under_player</span>():<br/><span class="ent">➐</span>     item_x = find_object_start_x()<br/><span class="ent">➑</span>     item_player_is_on = room_map[player_y][item_x]<br/><span class="ent">➒</span>     <span class="orange">return</span> item_player_is_on<br/><br/>   --<span class="codeitalic1">snip</span>--</pre>
<p class="listing" id="ch09list4"><em>Listing 9-4: Finding the real object number</em></p>
<p class="indent">Before we get into how this code works, I’ll explain how the game loop lets players interact with props and scenery:</p>
<ol>
<li class="noindent">When the player presses a movement key, the program changes the player’s position (even if that puts them somewhere impossible, like inside a wall).</li>
<li class="noindent">The program carries out any actions the player requires using the object at the player’s location. This means the player and the object are in the same position in the room at this time.</li>
<li class="noindent">If the player is standing somewhere they’re not allowed to be (such as inside a wall), the program moves them back to where they were.</li>
</ol>
<p class="indent">The entire process happens so fast you never see the player go inside the wall or other piece of scenery. This way, the player can use a movement key plus an action key to examine or use the scenery. For example, you can walk into a wall and press the spacebar to examine the wall and see a description of it. This process also works with an object the player is standing on, such as a prop on the floor.</p>
<p class="indent">The first new function we added in <a href="ch09.xhtml#ch09list4">Listing 9-4</a> is <code>find_object_start_x()</code> <span class="ent">➊</span>. This function finds the start position of whatever object is at the player’s position, going left to find the real object number if the location contains 255.</p>
<p class="indent"><span epub:type="pagebreak" id="page_159"/>To do this, the function sets the variable <code>checker_x</code> to be the same as the player’s <em>x</em> position <span class="ent">➋</span>. We use a loop that keeps going for as long as the room map contains 255 at the <em>x</em> position of <code>checker_x</code> and at the player’s <em>y</em> position <span class="ent">➌</span>. Inside that loop is a single instruction to reduce <code>checker_x</code> by 1 <span class="ent">➍</span>, moving 1 tile to the left. When the loop finishes, <code>checker_x</code> contains the left position where the object begins. That number is then sent back <span class="ent">➎</span> to the instruction that started the function.</p>
<p class="indent">The second new function is <code>get_item_under_player()</code> <span class="ent">➏</span>, which works out which object is at the player’s position. It uses the first function to find out where the object starts and stores the <em>x</em> position in the variable <code>item_x</code> <span class="ent">➐</span>. Then it looks at the room map data for that position to see what object is there <span class="ent">➑</span> and sends that number back to the instruction that started the function <span class="ent">➒</span>.</p>
<h3 class="h3" id="lev120"><strong>PICKING UP OBJECTS</strong></h3>
<p class="noindent">Now that these functions are in place, we can create a couple of functions for picking up objects and then storing them in a player’s inventory. Then we’ll add some keyboard controls.</p>
<h4 class="h4" id="lev121"><strong>PICKING UP PROPS</strong></h4>
<p class="noindent">Add the two functions shown in <a href="ch09.xhtml#ch09list5">Listing 9-5</a> to the end of the <code>PROP INTERACTIONS</code> section of the program, just after where you added the code in <a href="ch09.xhtml#ch09list4">Listing 9-4</a>.</p>
<p class="indent">Save this program as <em>listing9-5.py</em>. You can check for any errors by running it using <span class="codestrong">pgzrun listing9-5.py</span>, but you won’t see any difference yet. This code adds some new functions but doesn’t include any key controls to enable the player to use them.</p>
<p class="margin"><em>listing9-5.py</em></p>
<pre>   <span class="gray">--<span class="codeitalic1">snip</span>--</span><br/>       <span class="gray">item_player_is_on = room_map[player_y][item_x]</span><br/>       <span class="gray">return item_player_is_on</span><br/><br/>   <span class="orange">def</span> <span class="blue">pick_up_object</span>():<br/>       <span class="orange">global</span> room_map<br/><span class="ent">➊</span>     item_player_is_on = get_item_under_player()<br/><span class="ent">➋</span>     <span class="orange">if</span> item_player_is_on <span class="orange">in</span> items_player_may_carry:<br/><span class="ent">➌</span>         room_map[player_y][player_x] = get_floor_type()<br/><span class="ent">➍</span>         add_object(item_player_is_on)<br/>           show_text(<span class="green">"Now carrying "</span> + objects[item_player_is_on][3], 0)<br/>           sounds.pickup.play()<br/>           time.sleep(0.5)<br/><span class="ent">➎</span>     <span class="orange">else</span>:<br/>           show_text(<span class="green">"You can't carry that!"</span>, 0)<br/><br/><span class="ent">➏</span> <span class="orange">def</span> <span class="blue">add_object</span>(item): <span class="red"># Adds item to inventory.</span><br/>       <span class="orange">global</span> selected_item, item_carrying<br/><span class="ent">➐</span>     in_my_pockets.append(item)<br/><span class="ent">➑</span>     item_carrying = item<br/><span class="ent">➒</span>     selected_item = <span class="purple">len</span>(in_my_pockets) - 1<br/><span epub:type="pagebreak" id="page_160"/>       display_inventory()<br/><span class="ent">➓</span>     props[item][0] = 0 <span class="red"># Carried objects go into room 0 (off the map).</span><br/><br/>   <span class="orange">def</span> <span class="blue">display_inventory</span>():<br/>       <span class="purple">print</span>(in_my_pockets)<br/>   --<span class="codeitalic1">snip</span>--</pre>
<p class="listing" id="ch09list5"><em>Listing 9-5: Adding the functions to pick up objects</em></p>
<p class="indent">The function <code>pick_up_object()</code> will start when the player presses the <em>get</em> key (G) to pick up an item. It begins by putting the object number for the item at the player’s position into the variable <code>item_player_is_on</code> <span class="ent">➊</span>. If the item is carryable <span class="ent">➋</span>, the rest of the function picks it up.</p>
<p class="indent">To remove the item from the floor, the program replaces the room map at the player’s position with the object number for the floor (either soil or floor tiles) <span class="ent">➌</span>. The <code>get_floor_type()</code> function is used to find out what the floor type should be in this room. When the room is redrawn, the item will disappear from the floor, so it looks like it’s been picked up. The item is then added to the list of items the player is carrying, using the <code>add_object()</code> function <span class="ent">➍</span>.</p>
<p class="indent">We then show a message onscreen telling the player they picked up an item and play a sound effect. We add a short delay of half a second using the <code>time.sleep(0.5)</code> instruction to make sure the confirmation message isn’t overwritten if the player holds down the key too long.</p>
<p class="indent">If the item isn’t carryable, we show a message telling them they can’t carry it <span class="ent">➎</span>. For example, scenery can’t be carried, so we need to tell players that. Otherwise, they might just think they’re pressing the wrong key or the program isn’t working.</p>
<p class="indent">The <code>add_object()</code> function adds an item to the <code>in_my_pockets</code> list, which stores the items the player is carrying (their inventory). At the start of the function, the object number this function receives is put into the local variable <code>item</code> <span class="ent">➏</span>. The item is added to the end of the <code>in_my_pockets_list</code> using <code>append()</code> <span class="ent">➐</span>.</p>
<p class="indent">We use the global variable <code>item_carrying</code> to store the object number of whatever’s in the player’s hands, so it is set to be the object number of this item <span class="ent">➑</span>. We set the <code>selected_item</code> variable as the last item in the list, meaning the item the player just picked up is selected <span class="ent">➒</span>. These variables will be important when objects are used later on, and when the <code>display_inventory()</code> function shows the list of items on the screen. For now, that function just prints out the list in the command line window.</p>
<p class="indent">Finally, we set the item’s position in the <code>props</code> dictionary to be room 0 <span class="ent">➓</span>. This means the item just picked up is not shown in the game map anywhere. If we didn’t do this, the item would reappear in the room again when the player next entered it.</p>
<h4 class="h4" id="lev122"><strong>ADDING THE KEYBOARD CONTROLS</strong></h4>
<p class="noindent">To enable the new functions to work their magic, we need to add the keyboard control too. We’ll use the G key as our get key.</p>
<p class="indent"><span epub:type="pagebreak" id="page_161"/>Place the new instructions, shown in <a href="ch09.xhtml#ch09list6">Listing 9-6</a>, in the <code>game_loop()</code> function in the <code>GAME LOOP</code> section of the program. The new instruction belongs after the exit checks have been made and before the player is moved back if they’re standing somewhere they shouldn’t be.</p>
<p class="margin"><em>listing9-6.py</em></p>
<pre>   <span class="gray">--<span class="codeitalic1">snip</span>--</span><br/>           <span class="gray">player_frame = 0</span><br/>           <span class="gray">start_room()</span><br/>           <span class="gray">return</span> <br/><br/><span class="ent">➊</span>     <span class="orange">if</span> keyboard.g:<br/><span class="ent">➋</span>         pick_up_object()<br/><br/>     <span class="gray"># If the player is standing somewhere they shouldn't, move them back.</span><br/>       <span class="gray">if room_map[player_y][player_x] not in items_player_may_stand_on: #\</span> <br/>       <span class="gray">#           or hazard_map[player_y][player_x] != 0:</span><br/>   <span class="gray">--<span class="codeitalic1">snip</span>--</span></pre>
<p class="listing" id="ch09list6"><em>Listing 9-6: Adding the keyboard control</em></p>
<p class="indent">You need to indent the first new instruction by four spaces <span class="ent">➊</span>, because it’s inside the <code>game_loop()</code> function. Indent the second one <span class="ent">➋</span> by four more spaces, because it belongs to the <code>if</code> instruction above. These instructions run the <code>pick_up_object()</code> function <span class="ent">➋</span> when the player presses the G key <span class="ent">➊</span>.</p>
<p class="indent">Save the listing as <em>listing9-6.py</em>. When you run <span class="codestrong">pgzrun listing9-6.py</span>, you should be able to pick up objects.</p>
<p class="indent">Test it starting with the air canister in the first room. Just walk onto it and press G. You’ll hear a sound and see a message, and the object will disappear from the room.</p>
<p class="indent">The command line window (where you entered the <code>pgzrun</code> instruction) will also show the inventory list every time you pick up an object, like this:</p>
<pre>[55, 59]</pre>
<p class="indent">Each time, you’ll see a new item added to the end of the list. Item 55, the yoyo, is in your pocket at the start of the game.</p>
<h3 class="h3" id="lev123"><strong>ADDING THE INVENTORY FUNCTIONALITY</strong></h3>
<p class="noindent">Now you can pick up props that you find around the space station. We should add an easy way to see what you’re carrying and to choose different items to use. We’ll make a new <code>display_inventory()</code> function that displays a strip at the top of the game window showing the items the player is carrying.</p>
<p class="indent">We’ll then add controls so the player can press the <small>TAB</small> key to select the next item in the list. The selected item has a box drawn around it, and its description is shown underneath. <a href="ch09.xhtml#ch09fig2">Figure 9-2</a> shows you what it will look like.</p>
<div class="image"><a id="ch09fig2"/><img src="../images/fig9-2.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 9-2:</em> The inventory at the top of the game window</p>
<h4 class="h4" id="lev124"><span epub:type="pagebreak" id="page_162"/><strong>DISPLAYING THE INVENTORY</strong></h4>
<p class="noindent"><a href="ch09.xhtml#ch09list7">Listing 9-7</a> shows you the code to add. <a href="ch09.xhtml#ch09list5">Listing 9-5</a> included some code for the <code>display_inventory()</code> function. Replace that with the new code. Save this listing as <em>listing9-7.py</em>. When you run the program using <span class="codestrong">pgzrun listing9-7.py</span>, you’ll be able to see items added to your inventory at the top of the screen as you collect them.</p>
<p class="margin"><em>listing9-7.py</em></p>
<pre>   <span class="gray">--<span class="codeitalic1">snip</span>--</span><br/>       <span class="gray">selected_item = len(in_my_pockets) - 1     </span><br/>       <span class="gray">display_inventory()</span><br/>       <span class="gray">props[item][0] = 0 # Carried objects go into room 0 (off the map).</span><br/><br/>   <span class="gray">def display_inventory():</span><br/><span class="ent">➊</span>     box = Rect((0, 45), (800, 105))<br/>       screen.draw.filled_rect(box, BLACK)<br/><br/><span class="ent">➋</span>     <span class="orange">if</span> <span class="purple">len</span>(in_my_pockets) == 0:<br/>           <span class="orange">return</span><br/><br/><span class="ent">➌</span>     start_display = (selected_item // 16) * 16<br/><span class="ent">➍</span>     list_to_show = in_my_pockets[start_display : start_display + 16]<br/><span class="ent">➎</span>     selected_marker = selected_item % 16<br/><br/><span class="ent">➏</span>     <span class="orange">for</span> item_counter <span class="orange">in</span> <span class="purple">range</span>(<span class="purple">len</span>(list_to_show)):<br/>           item_number = list_to_show[item_counter]<br/>           image = objects[item_number][0]<br/><span class="ent">➐</span>         screen.blit(image, (25 + (46 * item_counter), 90))<br/><br/>       box_left = (selected_marker * 46) - 3<br/><span class="ent">➑</span>     box = Rect((22 + box_left, 85), (40, 40))<br/>       screen.draw.rect(box, WHITE)<br/>       item_highlighted = in_my_pockets[selected_item]<br/>       description = objects[item_highlighted][2]<br/><span class="ent">➒</span>     screen.draw.text(description, (20, 130), color=<span class="green">"white"</span>)<br/><br/>   <span class="gray">###############</span><br/>   <span class="gray">##   START   ##</span><br/>   <span class="gray">###############</span><br/><br/>   <span class="gray">clock.schedule_interval(game_loop, 0.03)</span><br/>   <span class="gray">generate_map()</span><br/>   <span class="gray">clock.schedule_interval(adjust_wall_transparency, 0.05)</span><br/><span class="ent">➓</span> clock.schedule_unique(display_inventory, 1)</pre>
<p class="listing" id="ch09list7"><em>Listing 9-7: Displaying the inventory</em></p>
<p class="indent">The new <code>display_inventory()</code> function starts by drawing a black box over the inventory area to clear it <span class="ent">➊</span>. If the player isn’t carrying anything, the function returns without taking any further action because there are no items to display <span class="ent">➋</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_163"/>There is only room to show 16 items on the screen, but the player could carry many more items than that. If the <code>in_my_pockets</code> list is too long to fit on the screen, the program shows it 16 items at a time. The player can select any of the items shown on the screen by pressing the <small>TAB</small> key to move through them, from left to right. If the last item displayed is selected and they press <small>TAB</small>, the next chunk of the list is shown. If the player presses <small>TAB</small> on the final item in the list, the start of the list appears again.</p>
<p class="indent">We store the part of the <code>in_my_pockets</code> list currently displayed on the screen in another list called <code>list_to_show</code> and use a loop to display it <span class="ent">➏</span>. The loop puts numbers into a variable called <code>item_counter</code>, which is used to extract the right image to draw each time, and also work out where to draw it <span class="ent">➐</span>.</p>
<p class="indent">The clever bit is working out which items should go into <code>list_to_show</code>. In the <code>start_display</code> variable, we store the index number for the first item in <code>in_my_pockets</code> that the program should draw <span class="ent">➌</span>. The <code>//</code> operator divides the selected item number by 16, rounding down. The result is then multiplied by 16 to get the index number for the first item in the batch. For example, if the selected item is number 9, you’d divide 9 by 16 (0.5625), round down (0), and multiply by 16 (still 0), getting a result of 0. That’s the start of the list, which makes sense, because we know there’s room for 16 items onscreen and that 9 is less than 16. If you wanted to see the group of items that includes item 22, you’d divide 22 by 16 (1.375), round down (1), and multiply by 16, getting a result of 16. That’s the start of the next batch, because the first batch has index numbers that range from 0 to 15.</p>
<p class="indent">We create the <code>list_to_show</code> list using a technique called <em>list slicing</em>, which is simply using just a part of a list. When you give Python two list indexes with a colon between them, the program will cut out that part of the list. The section we’re using starts at the <code>start_display</code> index and finishes 15 items later <span class="ent">➍</span>. A list slice leaves out the last item, so we use <code>start_display + 16</code> as the end point.</p>
<p class="indent">We also need another calculation to work out which item to highlight as the selected item from the new list <span class="ent">➎</span>. The item will have an index between 0 and 15, and we’ll store it in <code>selected_marker</code>. We calculate it as the remainder after we divide the selected item number by 16. For example, if the selected item is number 18, it will be at index number 2 when the second group of items is displayed. (The first item is at index 0, remember.) Python has the modulo operator <code>%</code>, which you can use to get the remainder after a division.</p>
<p class="indent">To highlight the selected item on the screen, we draw a box around it using a Rect positioned at its left edge <span class="ent">➑</span>. Unlike the filled rectangles you’ve seen (for example <span class="ent">➊</span>), this instruction draws a hollow box with a white edge.</p>
<p class="indent">The description for the selected item is displayed underneath the inventory <span class="ent">➒</span>, so players can <small>TAB</small> through their items to read their descriptions again.</p>
<p class="indent">Finally, when the program first runs, it needs to display the inventory. This is scheduled with a slight delay <span class="ent">➓</span> to avoid any problems that are caused by trying to use a <code>screen.blit()</code> instruction before Pygame Zero has finished starting up. While <code>clock.schedule_interval()</code> is used to run a function regularly, <code>clock.schedule_unique()</code> is used to run a function just once, after a delay.</p>
<h4 class="h4" id="lev125"><span epub:type="pagebreak" id="page_164"/><strong>ADDING THE TAB KEYBOARD CONTROL</strong></h4>
<p class="noindent">When you run the program, you can see the inventory, but you have no way to cycle between items yet, so the latest item you collected is always selected. Let’s add the keyboard control that enables you to <small>TAB</small> through the inventory to select different items.</p>
<p class="indent">Place the new instructions in <a href="ch09.xhtml#ch09list8">Listing 9-8</a> into the <code>game_loop()</code> function, just after where you added the keyboard control to get items in <a href="ch09.xhtml#ch09list6">Listing 9-6</a>. You need to indent them by at least four spaces because they’re inside the <code>game_loop()</code> function.</p>
<p class="indent">Save this listing as <em>listing9-8.py</em>. When you run the program using <span class="codestrong">pgzrun listing9-8.py</span>, you’ll be able to press the <small>TAB</small> key to select different items in your inventory. (The <small>TAB</small> key is usually on the left side of the keyboard and might have a picture of two arrows on it.)</p>
<p class="indent">Pick up a few items before testing the new keyboard control, or skip ahead to the next section to fill up your inventory with more items to test with.</p>
<p class="margin"><em>listing9-8.py</em></p>
<pre>   <span class="gray">--<span class="codeitalic1">snip</span>--</span><br/>       <span class="gray">if keyboard.g:</span><br/>           <span class="gray">pick_up_object()</span><br/><br/><span class="ent">➊</span>     <span class="orange">if</span> keyboard.tab <span class="orange">and</span> <span class="purple">len</span>(in_my_pockets) &gt; 0:<br/><span class="ent">➋</span>         selected_item += 1<br/><span class="ent">➌</span>         if selected_item &gt; <span class="purple">len</span>(in_my_pockets) - 1:<br/>               selected_item = 0<br/><span class="ent">➍</span>         item_carrying = in_my_pockets[selected_item]<br/><span class="ent">➎</span>         display_inventory()<br/><br/><span class="ent">➏</span>     <span class="orange">if</span> keyboard.d <span class="orange">and</span> item_carrying:<br/><span class="ent">➐</span>         drop_object(old_player_y, old_player_x)<br/><br/><span class="ent">➑</span>     <span class="orange">if</span> keyboard.space:<br/><span class="ent">➒</span>         examine_object()<br/>   --<span class="codeitalic1">snip</span>--</pre>
<p class="listing" id="ch09list8"><em>Listing 9-8: Enabling the <small>TAB</small> key to select items in the inventory</em></p>
<p class="indent">The first chunk of instructions runs when the player presses the <small>TAB</small> key, but only if the <code>in_my_pockets</code> list contains some items (so its length is more than 0) <span class="ent">➊</span>.</p>
<p class="indent">To select the next item in the inventory, we increase the <code>selected_item</code> variable by 1 <span class="ent">➋</span> when the <small>TAB</small> key is pressed. This variable stores an index number (which starts at 0), so the program subtracts 1 from the length of the list to see whether the <code>selected_item</code> is now past the end of the list <span class="ent">➌</span>. If it is, the selected item is reset to be the first item again, at 0.</p>
<p class="indent">We set the variable <code>item_carrying</code> as the object number of the selected item (which is taken from the <code>in_my_pockets</code> list) <span class="ent">➍</span>. For example, if the <code>in_my_pockets</code> list contained the object numbers 55 and 65, and the <span epub:type="pagebreak" id="page_165"/><code>selected_item</code> was 0, <code>item_carrying</code> would contain 55 (the first item from <code>in_my_pockets</code>). Finally, the inventory is displayed using the <code>display_</code><code>inventory()</code> function you created earlier <span class="ent">➎</span>.</p>
<p class="indent">While we’re working with this part of the program, we’ve added the keyboard controls for dropping and examining items too. When the player presses the D key and the <code>item_carrying</code> variable is not <code>False</code>, the <code>drop_object()</code> function runs <span class="ent">➏</span>. This function is sent the player’s old <em>y</em> and <em>x</em> positions as the location for dropping the item <span class="ent">➐</span>. Remember that the player’s current location might be inside a wall because of where we are in the game loop. We know that their most recent position before any movement is a safe place to drop something.</p>
<p class="indent">We also added the instructions to start the <code>examine_object()</code> function <span class="ent">➒</span> when the spacebar is pressed <span class="ent">➑</span>.</p>
<p class="indent">Don’t press D or the spacebar in the game yet: pressing them will cause the program to crash because we haven’t added the functions for them. We’ll add them shortly.</p>
<h4 class="h4" id="lev126"><strong>TESTING THE INVENTORY</strong></h4>
<p class="noindent">We want to test the program properly, but at the moment you don’t have many items in your inventory. To save time, we’ll tweak the code to give you a fuller inventory so you can test the display and the <small>TAB</small> control.</p>
<p class="indent">We’ll fill the <code>in_my_pockets</code> list with items when the game begins. The quickest way to do this is to change the instruction that sets up that list in the <code>PROPS</code> section of the program, like this (but don’t do this yet!):</p>
<pre>in_my_pockets = items_player_may_carry</pre>
<p class="indent">That would mean you start the game carrying all the items it’s possible to carry. If you do that, it might spoil your enjoyment of the game, though. You’ll be carrying some items you might prefer not to see until later in the game. It’ll make some of the puzzle solutions obvious.</p>
<p class="indent">Instead, I recommend you create a test list like this:</p>
<pre>in_my_pockets = [55, 59, 61, 64, 65, 66, 67] * 3</pre>
<p class="indent">This line creates a list that contains that sequence of items three times. You’ll end up with an inventory that contains three of each item (which is impossible in the real game), but it will enable you to test that the inventory works correctly when it contains more than 16 items.</p>
<p class="indent">When you’ve finished testing, change the code back again. Otherwise, you might get unexpected results when playing the game. Here’s what that line should look like:</p>
<pre>in_my_pockets = [55]</pre>
<h3 class="h3" id="lev127"><span epub:type="pagebreak" id="page_166"/><strong>DROPPING OBJECTS</strong></h3>
<p class="noindent">Being able to collect stuff strewn all over the space station is great fun, but sometimes you’ll want to put it down, so you can either work with it or leave it somewhere. We’ll need two new functions for dropping items that will work a bit like the opposites of the functions for picking up items.</p>
<p class="indent">The <code>drop_object()</code> function (the opposite of the <code>pick_up_object()</code> function) will let you drop an object on the floor where the player was most recently standing. You added the keyboard control to start this function in <a href="ch09.xhtml#ch09list8">Listing 9-8</a>.</p>
<p class="indent">The <code>remove_object()</code> function is like the <code>add_object()</code> function in reverse: it takes items out of the inventory and updates it.</p>
<p class="indent">Add the new functions, shown in <a href="ch09.xhtml#ch09list9">Listing 9-9</a>, to the end of the <code>PROP INTERACTIONS</code> part of the program. Save the new program as <em>listing9-9.py</em>.</p>
<p class="indent">When you run the program using <span class="codestrong">pgzrun listing9-9.py</span>, you’ll be able to drop objects. That includes the yoyo you start the game carrying and any new objects you pick up as you explore the space station.</p>
<p class="margin"><em>listing9-9.py</em></p>
<pre>   <span class="gray">--<span class="codeitalic1">snip</span>--</span><br/>       <span class="gray">description = objects[item_highlighted][2]</span><br/>       <span class="gray">screen.draw.text(description, (20, 130), color="white")</span><br/><br/><span class="ent">➊</span> <span class="orange">def</span> <span class="blue">drop_object</span>(old_y, old_x):<br/>       <span class="orange">global</span> room_map, props<br/><span class="ent">➋</span>     <span class="orange">if</span> room_map[old_y][old_x] <span class="orange">in</span> [0, 2, 39]: <span class="red"># places you can drop things</span><br/><span class="ent">➌</span>         props[item_carrying][0] = current_room<br/>           props[item_carrying][1] = old_y<br/>           props[item_carrying][2] = old_x<br/><span class="ent">➍</span>         room_map[old_y][old_x] = item_carrying<br/>           show_text(<span class="green">"You have dropped "</span> + objects[item_carrying][3], 0)<br/>           sounds.drop.play()<br/><span class="ent">➎</span>         remove_object(item_carrying)<br/>           time.sleep(0.5)<br/><span class="ent">➏</span>     <span class="orange">else</span>: <span class="red"># This only happens if there is already a prop here</span><br/>           show_text(<span class="green">"You can't drop that there."</span>, 0)<br/>           time.sleep(0.5)<br/><br/>   <span class="orange">def</span> <span class="blue">remove_object</span>(item): # Takes item out of inventory<br/>       <span class="orange">global</span> selected_item, in_my_pockets, item_carrying<br/><span class="ent">➐</span>     in_my_pockets.remove(item)<br/><span class="ent">➑</span>     selected_item = selected_item - 1<br/><span class="ent">➒</span>     <span class="orange">if</span> selected_item &lt; 0:<br/>           selected_item = 0<br/><span class="ent">➓</span>     <span class="orange">if</span> <span class="purple">len</span>(in_my_pockets) == 0: <span class="red"># If they're not carrying anything</span><br/>           item_carrying = False <span class="red"># Set item_carrying to False</span><br/>       <span class="orange">else</span>: <span class="red"># Otherwise set it to the new selected item</span><br/>           item_carrying = in_my_pockets[selected_item]<br/>       display_inventory()<br/><br/><span epub:type="pagebreak" id="page_167"/>   <span class="gray">###############</span><br/>   <span class="gray">##   START   ##</span><br/>   <span class="gray">###############</span><br/>   <span class="gray">--<span class="codeitalic1">snip</span>--</span></pre>
<p class="listing" id="ch09list9"><em>Listing 9-9: Adding the functions for dropping objects</em></p>
<p class="indent">The <code>drop_object()</code> function needs two pieces of information: the player’s old <em>y</em> and <em>x</em> positions. If the player moved this time through the <code>game_loop()</code> function, this will be the position they were in before they tried to move. If not, these numbers will be the same position as where they currently are. We know this is a sensible place to drop an item that won’t put the object inside a wall. The player’s old position goes into the variables <code>old_y</code> and <code>old_x</code> within this function <span class="ent">➊</span>.</p>
<p class="indent">The program checks whether the room map at the player’s old position is a type of floor. If so, it’s okay to drop a prop here, so the drop instructions are used. If not <span class="ent">➏</span>, the player sees a message telling them they can’t drop objects there. This will happen, for example, if there is already a prop in that position.</p>
<p class="indent">If the player can drop the item, we need to update the <code>props</code> dictionary. The variable <code>item_carrying</code> contains the number of the object the player is carrying. Its entry in the <code>props</code> dictionary is a list. The first list item (index 0) is the room the prop is in, the second item (index 1) is its <em>y</em> position, and the third item is its <em>x</em> position (index 2). These values are set to be the current room and the player’s old position <span class="ent">➌</span>.</p>
<p class="indent">The room map for the current room also needs to be updated, so the room contains the dropped item <span class="ent">➍</span>. The game will show a message and play a sound to tell the player that they’ve successfully dropped something and then the item is removed from the inventory using the <code>remove_object()</code> function <span class="ent">➎</span>.</p>
<p class="indent">The <code>remove_object()</code> function takes an item from the player’s inventory and updates the <code>selected_item</code> variable. The object number sent to this function is stored in the variable <code>item</code>, and then <code>remove()</code> <span class="ent">➐</span> removes it from the <code>in_my_pockets</code> list. Now that the selected item has been removed, the number of the selected item is reduced by 1 <span class="ent">➑</span>, so the previous item in the list is now selected. If this means the selected item is now less than 0, the selected item is reset to 0 <span class="ent">➒</span>. This happens if the player drops the first item from their inventory.</p>
<p class="indent">If the player’s hands are now empty, the <code>item_carrying</code> variable is set to <code>False</code> <span class="ent">➓</span>. Otherwise, it’s set to the number of their selected item. Finally, <code>display</code><code>_inventory()</code> redraws the inventory to show the item has been removed.</p>
<div class="sidebar">
<p class="sidebart" id="ch09sb1"><strong>TRAINING MISSION #1</strong></p>
<p class="spara">It’s time to do a safety drill. Can you pick up the air canister and deliver it to the sick bay? Drop it near the middle bed. To test whether the program is working correctly, leave the room after your delivery and come back to make sure it’s still there.</p>
</div>
<h3 class="h3" id="lev128"><span epub:type="pagebreak" id="page_168"/><strong>EXAMINING OBJECTS</strong></h3>
<p class="noindent">As you explore the space station, you’ll want to study objects closely to see how they might help with your mission. The <em>examine</em> instruction shows the long description for an object and works for scenery and props. By examining an object, you can also sometimes find other objects. For example, when you examine a cupboard, you might find something inside it.</p>
<p class="indent">Pressing the spacebar triggers the <code>examine_object()</code> function. (You added the keyboard control in <a href="ch09.xhtml#ch09list8">Listing 9-8</a>.) Place the new function, shown in <a href="ch09.xhtml#ch09list10">Listing 9-10</a>, after the <code>remove_object()</code> function you added in <a href="ch09.xhtml#ch09list9">Listing 9-9</a>.</p>
<p class="indent">Save your program as <em>listing9-10.py</em>. Run the program using <span class="codestrong">pgzrun listing9-10.py</span>. You can now examine objects by walking up to or onto them and pressing the spacebar. For example, if you press the up arrow key and the spacebar when you’re against the wall at the back of the room, you can examine the wall.</p>
<p class="margin"><em>listing9-10.py</em></p>
<pre>   <span class="gray">--<span class="codeitalic1">snip</span>--</span><br/>           <span class="gray">item_carrying = in_my_pockets[selected_item]</span><br/>       <span class="gray">display_inventory()</span><br/><br/>   <span class="orange">def</span> <span class="blue">examine_object</span>():<br/><span class="ent">➊</span>     item_player_is_on = get_item_under_player()<br/><span class="ent">➋</span>     left_tile_of_item = find_object_start_x()<br/><span class="ent">➌</span>     <span class="orange">if</span> item_player_is_on <span class="orange">in</span> [0, 2]: <span class="red"># don't describe the floor</span><br/>           <span class="orange">return</span><br/><span class="ent">➍</span>     description = <span class="green">"You see: "</span> + objects[item_player_is_on][2]<br/><span class="ent">➎</span>     <span class="orange">for</span> prop_number, details <span class="orange">in</span> props.items():<br/>           <span class="red"># props = object number: [room number, y, x]</span><br/><span class="ent">➏</span>         if details[0] == current_room: <span class="red"># if prop is in the room</span><br/>               <span class="red"># If prop is hidden (= at player's location but not on map)</span><br/>               <span class="orange">if</span> (details[1] == player_y<br/>                   <span class="orange">and</span> details[2] == left_tile_of_item<br/>                   <span class="orange">and</span> room_map[details[1]][details[2]] != prop_number):<br/><span class="ent">➐</span>                 add_object(prop_number)<br/><span class="ent">➑</span>                 description = <span class="green">"You found "</span> + objects[prop_number][3]<br/>                   sounds.combine.play()<br/><span class="ent">➒</span>     show_text(description, 0)<br/><span class="ent">➓</span>     time.sleep(0.5)<br/><br/>   <span class="gray">###############</span><br/>   <span class="gray">##   START   ##</span><br/>   <span class="gray">###############</span><br/>   <span class="gray">--<span class="codeitalic1">snip</span>--</span></pre>
<p class="listing" id="ch09list10"><em>Listing 9-10: Adding the code to examine objects</em></p>
<p class="indent"><a href="ch09.xhtml#ch09list10">Listing 9-10</a> builds on the work you’ve already done adding functions in this chapter. We start by getting the number of the object the player wants to examine and storing it in <code>item_player_is_on</code> <span class="ent">➊</span>. At this point in the <code>game_loop()</code> function, the player’s position will be on or possibly inside the item they want to examine, if it’s a piece of scenery. We put the starting <em>x</em> position of the item into the variable <code>left_tile_of_item</code> <span class="ent">➋</span>. If there isn’t an <span epub:type="pagebreak" id="page_169"/>object to examine at the player’s location, the function finishes without taking any further action <span class="ent">➌</span>. Ignoring an empty space feels more natural than describing the floor, especially if you make a mistake with the controls. If there is an item at the player’s location, the description of the object goes into the <code>description</code> variable, taken from the long description from the <code>objects</code> dictionary <span class="ent">➍</span>.</p>
<p class="indent">The program then checks whether there’s an item hidden <em>inside</em> the item the player is examining. We use a loop to go through all the items in the props dictionary <span class="ent">➎</span>. If an item is in the current room at the player’s position, but the room map at that position doesn’t contain the prop number <span class="ent">➏</span>, it means the item is hidden. We therefore add the hidden object to the player’s inventory <span class="ent">➐</span>, and give the player a message that tells them they found something. This message uses the object’s short description to tell them what they’ve found <span class="ent">➑</span>.</p>
<p class="indent">At the end of the function, the description is shown <span class="ent">➒</span>, and we’ve put a short pause here to stop it being immediately overwritten if the player holds the key down <span class="ent">➓</span>.</p>
<p class="indent">If you want to hide props inside scenery in your own game design, make sure you give players a strong hint about where you’ve hidden something. In <em>Escape</em>, you might find objects in cupboards. If you see something unusual, it’s usually a good idea to examine it to learn about it, and you might find something else of interest. You won’t need to search every chair, bed, and wall panel though.</p>
<p class="indent">If you decide to hide props in wide scenery (such as a bed), make sure you hide your prop in the <em>x</em> position of the scenery item, not in a space that would be covered by 255 in the room map.</p>
<div class="sidebar">
<p class="sidebart" id="ch09sb2"><strong>TRAINING MISSION #2</strong></p>
<p class="spara">Can you find the MP3 player? It’s in the sleeping quarters that belong to the person you named <code>FRIEND2</code> in <a href="ch04.xhtml#ch04">Chapter 4</a>. If you’re using my code, it’s in Leo’s sleeping quarters.</p>
</div>
<p class="indent">Now that all the props are unpacked, you can relax with your yoyo and see what else you can find. In the next chapter, you’ll add a new section to the program that enables you to use the props you come across.</p>
<h3 class="h3" id="lev129"><strong>ARE YOU FIT TO FLY?</strong></h3>
<p class="noindentb">Check the following boxes to confirm that you’ve learned the key lessons in this chapter.</p>
<p class="square"><img src="../images/box.jpg" alt="Images"/>  Information about the position of props is stored in the <code>props</code> dictionary.</p>
<p class="square"><img src="../images/box.jpg" alt="Images"/>  The prop number is the dictionary key, and each entry contains a list with the room number and <em>y</em> and <em>x</em> positions of the prop.</p>
<p class="square"><span epub:type="pagebreak" id="page_170"/><img src="../images/box.jpg" alt="Images"/>  To receive a number from a function, set up a variable to store that information when you call the function. For example, <span class="codeitalic">variable_name</span> <code>=</code> <span class="codeitalic">function_name</span><code>()</code>.</p>
<p class="square"><img src="../images/box.jpg" alt="Images"/>  To send a number (or anything else) back from a function, use the <code>return</code> instruction.</p>
<p class="square"><img src="../images/box.jpg" alt="Images"/>  The <code>//</code> operator is used for division and rounds the result down, removing any decimal in the answer.</p>
<p class="square"><img src="../images/box.jpg" alt="Images"/>  The <code>%</code> operator gives you the remainder after dividing two numbers: <code>5 % 2</code> is <code>1</code>.</p>
<p class="square"><img src="../images/box.jpg" alt="Images"/>  You can change the value of variables and lists to help test the program, for example, creating a full inventory at the start. Remember to change them back afterward!</p>
<p class="square"><img src="../images/box.jpg" alt="Images"/>  You can hide props inside scenery, but make sure they’re in the position where the scenery starts, and give players a strong hint about where it’s worth searching.</p>
<div class="image" id="ch09sb3"><img src="../images/f0170-01.jpg" alt="image"/></div>
</body></html>