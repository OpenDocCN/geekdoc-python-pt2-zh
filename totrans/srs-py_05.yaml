- en: '**5**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5**'
- en: '**DISTRIBUTING YOUR SOFTWARE**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**发布你的软件**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: It’s safe to say that at some point, you will want to distribute your software.
    As tempted as you might be to just zip your code and upload it to the internet,
    Python provides tools to make it easier for your end users to get your software
    to work. You should already be familiar with using *setup.py* to install Python
    applications and libraries, but you have probably never delved into how it works
    behind the scenes or how to make a *setup.py* of your own.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 可以肯定地说，某个时刻，你会希望发布你的软件。尽管你可能很想直接压缩你的代码并上传到互联网，Python提供了工具来使你的最终用户更容易使用你的软件。你应该已经熟悉使用*setup.py*来安装Python应用程序和库，但你可能从未深入了解过它背后的工作原理，或者如何创建你自己的*setup.py*。
- en: In this chapter, you’ll learn the history of *setup.py*, how the file works,
    and how to create your own custom *setup.py*. We’ll also take a look at some of
    the less well-known capabilities of the package installation tool `pip` and how
    to make your software downloadable via `pip`. Finally, we’ll see how to use Python’s
    entry points to make functions easy to find between programs. With these skills,
    you can make your published software accessible for end users.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解*setup.py*的历史、该文件的工作原理，以及如何创建你自己的自定义*setup.py*。我们还将深入探讨一些打包安装工具`pip`的鲜为人知的功能，以及如何通过`pip`使你的软件可下载。最后，我们将看看如何使用Python的入口点，使得不同程序之间的函数可以轻松找到。掌握这些技能后，你就能让你的发布软件对最终用户更加可访问。
- en: '**A Bit of setup.py History**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**setup.py的历史**'
- en: The `distutils` library, originally created by software developer Greg Ward,
    has been part of the standard Python library since 1998\. Ward sought to create
    an easy way for developers to automate the installation process for their end
    users. Packages provide the *setup.py* file as the standard Python script for
    their installation, and they can use `distutils` to install themselves, as shown
    in [Listing 5-1](ch05.xhtml#ch5list1).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`distutils`库最初由软件开发者Greg Ward创建，自1998年起就成为Python标准库的一部分。Ward旨在为开发者创建一个简便的方式，以便自动化其终端用户的安装过程。软件包提供*setup.py*文件作为标准的Python安装脚本，并可以使用`distutils`进行安装，如[列表
    5-1](ch05.xhtml#ch5list1)所示。'
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 5-1: Building a setup.py using distutils*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-1：使用distutils构建setup.py*'
- en: With the *setup.py* file as the root of a project, all users have to do to build
    or install your software is run that file with the appropriate command as its
    argument. Even if your distribution includes C modules in addition to native Python
    ones, `distutils` can handle them automatically.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将*setup.py*文件作为项目的根文件，所有用户需要做的就是运行该文件，并将适当的命令作为参数传递。即使你的分发包除了本地Python模块外还包含C模块，`distutils`也能自动处理它们。
- en: Development of `distutils` was abandoned in 2000; since then, other developers
    have picked up where it left off. One of the notable successors is the packaging
    library known as `setuptools`, which offers more frequent updates and advanced
    features, such as automatic dependency handling, the `Egg` distribution format,
    and the `easy_install` command. Since `distutils` was still the accepted means
    of packaging software included with the Python Standard Library at the time of
    development, `setuptools` provided a degree of backward compatibility with it.
    [Listing 5-2](ch05.xhtml#ch5list2) shows how you’d use `setuptools` to build the
    same installation package as in [Listing 5-1](ch05.xhtml#ch5list1).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`distutils`的开发在2000年停止；从那时起，其他开发者接手了它的工作。一个显著的继任者是名为`setuptools`的打包库，它提供了更多的更新和高级功能，如自动依赖管理、`Egg`分发格式和`easy_install`命令。由于`distutils`在开发时仍然是Python标准库中接受的软件打包方式，`setuptools`在一定程度上保持了与其的向后兼容性。[列表
    5-2](ch05.xhtml#ch5list2)展示了如何使用`setuptools`构建与[列表 5-1](ch05.xhtml#ch5list1)相同的安装包。'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 5-2: Building a setup.py using setuptools*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-2：使用setuptools构建setup.py*'
- en: Eventually, development on `setuptools` slowed down too, but it wasn’t long
    before another group of developers forked it to create a new library called `distribute`,
    which offered several advantages over `setuptools`, including fewer bugs and Python
    3 support.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，`setuptools`的开发也放缓了，但没过多久，另一组开发者将其分叉，创建了一个新的库，名为`distribute`，它相比`setuptools`提供了几个优点，包括更少的BUG和对Python
    3的支持。
- en: 'All the best stories have a twist ending, though: in March 2013, the teams
    behind `setuptools` and `distribute` decided to merge their codebases under the
    aegis of the original `setuptools` project. So `distribute` is now deprecated,
    and `setuptools` is once more the canonical way to handle advanced Python installations.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 所有最好的故事都有一个转折结局：2013年3月，`setuptools` 和 `distribute` 背后的团队决定将它们的代码库合并到原始 `setuptools`
    项目的旗下。因此，`distribute` 现在已经被弃用，`setuptools` 再次成为处理高级 Python 安装的标准方式。
- en: While all this was happening, another project, known as `distutils2`, was developed
    with the intention of completely replacing `distutils` in the Python Standard
    Library. Unlike both `distutils` and `setuptools`, it stored package metadata
    in a plaintext file, *setup.cfg*, which was easier both for developers to write
    and for external tools to read. However, `distutils2` retained some of the failings
    of `distutils`, such as its obtuse command-based design, and lacked support for
    entry points and native script execution on Windows—both features provided by
    `setuptools`. For these and other reasons, plans to include `distutils2`, renamed
    as `packaging`, in the Python 3.3 Standard Library fell through, and the project
    was abandoned in 2012.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一切发生的同时，另一个名为 `distutils2` 的项目也在开发中，旨在完全替代 Python 标准库中的 `distutils`。与 `distutils`
    和 `setuptools` 不同，它将包的元数据存储在一个纯文本文件 *setup.cfg* 中，这对于开发者来说更容易编写，对于外部工具来说更容易读取。然而，`distutils2`
    保留了 `distutils` 的一些缺点，例如命令行设计的晦涩，并且缺乏对 Windows 上入口点和原生脚本执行的支持——这两者是 `setuptools`
    提供的特性。由于这些原因以及其他原因，将 `distutils2`（即 `packaging`）包含进 Python 3.3 标准库的计划未能实现，且该项目在
    2012 年被放弃。
- en: There is still a chance for `packaging` to rise from the ashes through `distlib`,
    an up-and-coming effort to replace `distutils`. Before release, it was rumored
    that the `distlib` package would become part of the Standard Library in Python
    3.4, but that never came to be. Including the best features from `packaging`,
    `distlib` implements the basic groundwork described in the packaging-related PEPs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`packaging` 仍然有机会通过 `distlib` 重新崛起，后者是一个新兴的替代 `distutils` 的项目。在发布之前，曾有传闻称 `distlib`
    包会成为 Python 3.4 标准库的一部分，但最终并未实现。`distlib` 包含了 `packaging` 的最佳特性，执行了与打包相关的 PEP
    中描述的基本工作。'
- en: 'So, to recap:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，回顾一下：
- en: distutils is part of the Python Standard Library and can handle simple package
    installations.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: distutils 是 Python 标准库的一部分，能够处理简单的包安装。
- en: setuptools, the standard for advanced package installations, was at first deprecated
    but is now back in active development and the de facto standard.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setuptools`，作为高级包安装的标准，最初曾被弃用，但现在已经重新进入活跃开发状态，并成为事实上的标准。'
- en: distribute has been merged back into `setuptools` as of version 0.7; distutils2
    (aka `packaging`) has been abandoned.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distribute` 已经在版本 0.7 中合并回 `setuptools`；`distutils2`（即 `packaging`）已被废弃。'
- en: distlib *might* replace `distutils` in the future.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distlib` *可能* 会在未来取代 `distutils`。'
- en: 'There are other packaging libraries out there, but these are the five you’ll
    encounter the most. Be careful when researching these libraries on the internet:
    plenty of documentation is outdated due to the complicated history outlined above.
    The official documentation is up-to-date, however.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他的打包库存在，但这些是你最常遇到的五个。研究这些库时要小心：由于上述复杂的历史，很多文档已经过时。然而，官方文档是最新的。
- en: In short, `setuptools` is the distribution library to use for the time being,
    but keep an eye out for `distlib` in the future.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`setuptools` 是目前使用的分发库，但未来要关注 `distlib`。
- en: '**Packaging with setup.cfg**'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 setup.cfg 进行打包**'
- en: 'You’ve probably already tried to write a *setup.py* for a package at some point,
    either by copying one from another project or by skimming through the documentation
    and building it yourself. Building a *setup.py* is not an intuitive task. Choosing
    the right tool to use is just the first challenge. In this section, I want to
    introduce you to one of the recent improvements to `setuptools`: the *setup.cfg*
    file support.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在某个时刻尝试过为某个包编写 *setup.py*，无论是从其他项目中复制，还是通过浏览文档自己构建。编写 *setup.py* 不是一项直观的任务。选择使用哪个工具只是第一道难题。在本节中，我想向你介绍
    `setuptools` 的一个近期改进：*setup.cfg* 文件支持。
- en: 'This is what a *setup.py* using a *setup.cfg* file looks like:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用 *setup.cfg* 文件的 *setup.py* 的样子：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Two lines of code—it is that simple. The actual metadata the setup requires
    is stored in *setup.cfg*, as in [Listing 5-3](ch05.xhtml#ch5list3).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 两行代码——就是这么简单。setup.py 所需的实际元数据存储在 *setup.cfg* 中，如 [Listing 5-3](ch05.xhtml#ch5list3)
    所示。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 5-3: The setup.cfg metadata*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-3：setup.cfg 元数据*'
- en: As you can see, *setup.cfg* uses a format that’s easy to write and read, directly
    inspired by `distutils2`. Many other tools, such as `Sphinx` or `Wheel`, also
    read configuration from this *setup.cfg* file—that alone is a good argument to
    start using it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，*setup.cfg* 使用了一种易于编写和阅读的格式，直接受到了`distutils2`的启发。许多其他工具，如`Sphinx`或`Wheel`，也从这个
    *setup.cfg* 文件中读取配置—仅这一点就是开始使用它的一个有力论据。
- en: In [Listing 5-3](ch05.xhtml#ch5list3), the description of the project is read
    from the *README.rst* file. It’s good practice to always have a README file—preferably
    in the RST format—so users can quickly understand what the project is about. With
    just these basic *setup.py* and *setup.cfg* files, your package is ready to be
    published and used by other developers and applications. The `setuptools` documentation
    provides more details if needed, for example, if you have some extra steps in
    your installation process or want to include extra files.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [清单 5-3](ch05.xhtml#ch5list3) 中，项目的描述是从 *README.rst* 文件中读取的。良好的实践是始终包含一个 README
    文件—最好是 RST 格式—以便用户快速了解项目的内容。仅凭这些基本的 *setup.py* 和 *setup.cfg* 文件，你的包就已经准备好发布，并供其他开发者和应用程序使用。如果需要，`setuptools`
    文档提供了更多细节，例如，如果你在安装过程中有额外的步骤，或者想要包含额外的文件。
- en: 'Another useful packaging tool is `pbr`, short for *Python Build Reasonableness*.
    The project was started in OpenStack as an extension of `setuptools` to facilitate
    installation and deployment of packages. The `pbr` packaging tool, used alongside
    `setuptools`, implements features absent from `setuptools`, including these:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的打包工具是 `pbr`，即 *Python Build Reasonableness* 的缩写。该项目最初在 OpenStack 中启动，作为
    `setuptools` 的扩展，旨在简化包的安装和部署。`pbr` 打包工具与 `setuptools` 一起使用，实现了 `setuptools` 中缺失的功能，包括以下这些：
- en: Automatic generation of Sphinx documentation
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动生成 Sphinx 文档
- en: Automatic generation of *AUTHORS* and *ChangeLog* files based on `git` history
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 `git` 历史自动生成 *AUTHORS* 和 *ChangeLog* 文件
- en: Automatic creation of file lists for `git`
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动创建 `git` 的文件列表
- en: Version management based on `git` tags using semantic versioning
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 `git` 标签使用语义化版本控制进行版本管理
- en: And all this with little to no effort on your part. To use `pbr`, you just need
    to enable it, as shown in [Listing 5-4](ch05.xhtml#ch5list4).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都几乎不需要你做任何额外的工作。要使用 `pbr`，你只需启用它，如 [清单 5-4](ch05.xhtml#ch5list4) 所示。
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 5-4: setup.py using pbr*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-4：使用 pbr 的 setup.py*'
- en: The `setup_requires` parameter indicates to `setuptools` that `pbr` must be
    installed prior to using `setuptools`. The `pbr=True` argument makes sure that
    the `pbr` extension for `setuptools` is loaded and called.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup_requires` 参数指示 `setuptools` 在使用之前必须安装 `pbr`。`pbr=True` 参数确保 `setuptools`
    加载并调用 `pbr` 扩展。'
- en: Once enabled, the `python setup.py` command is enhanced with the `pbr` features.
    Calling `python setup.py –version` will, for example, return the version number
    of the project based on existing `git` tags. Running `python setup.py sdist` would
    create a source tarball with automatically generated *ChangeLog* and *AUTHORS*
    files.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用，`python setup.py` 命令将增强 `pbr` 功能。例如，调用 `python setup.py --version` 将根据现有的
    `git` 标签返回项目的版本号。运行 `python setup.py sdist` 将创建一个源代码 tarball，并自动生成 *ChangeLog*
    和 *AUTHORS* 文件。
- en: '**The Wheel Format Distribution Standard**'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Wheel 格式分发标准**'
- en: For most of Python’s existence, there’s been no official standard distribution
    format. While different distribution tools generally use some common archive format—even
    the `Egg` format introduced by `setuptools` is just a zip file with a different
    extension—their metadata and package structures are incompatible with each other.
    This problem was compounded when an official installation standard was finally
    defined in PEP 376 that was also incompatible with existing formats.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 的大部分历史中，并没有官方的标准分发格式。尽管不同的分发工具通常使用一些通用的归档格式—甚至由 `setuptools` 引入的 `Egg`
    格式仅仅是一个具有不同扩展名的 zip 文件—它们的元数据和包结构彼此不兼容。当官方安装标准终于在 PEP 376 中定义时，这个问题更为严重，因为它与现有格式也不兼容。
- en: To solve these problems, PEP 427 was written to define a new standard for Python
    distribution packages called `Wheel`. The reference implementation of this format
    is available as a tool, also called `Wheel`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，PEP 427 被编写出来，定义了 Python 分发包的新标准，称为 `Wheel`。该格式的参考实现可作为工具使用，亦称为 `Wheel`。
- en: '`Wheel` is supported by `pip` starting with version 1.4\. If you’re using `setuptools`
    and have the `Wheel` package installed, it automatically integrates itself as
    a `setuptools` command named `bdist_wheel`. If you don’t have `Wheel` installed,
    you can install it using the command `pip install wheel`. [Listing 5-5](ch05.xhtml#ch5list5)
    shows some of the output when calling `bdist_wheel`, abridged for print.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wheel` 从版本 1.4 开始被 `pip` 支持。如果你使用 `setuptools` 并且已经安装了 `Wheel` 包，它会自动集成为一个名为
    `bdist_wheel` 的 `setuptools` 命令。如果你没有安装 `Wheel`，可以通过命令 `pip install wheel` 来安装它。[列表
    5-5](ch05.xhtml#ch5list5) 显示了调用 `bdist_wheel` 时的部分输出，已缩短以便打印。'
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 5-5: Calling setup.py bdist_wheel*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-5：调用 setup.py bdist_wheel*'
- en: 'The `bdist_wheel` command creates a *.whl* file in the *dist* directory ➊.
    As with the `Egg` format, a `Wheel` archive is just a zip file with a different
    extension. However, `Wheel` archives do not require installation—you can load
    and run your code just by adding a slash followed by the name of your module:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`bdist_wheel` 命令会在 *dist* 目录中创建一个 *.whl* 文件 ➊。与 `Egg` 格式一样，`Wheel` 存档只是一个具有不同扩展名的压缩文件。然而，`Wheel`
    存档不需要安装——你只需添加一个斜杠后跟模块名，就可以加载并运行你的代码：'
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You might be surprised to learn this is not a feature introduced by the `Wheel`
    format itself. Python can also run regular zip files, just like with Java’s *.jar*
    files:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶地发现，这并不是 `Wheel` 格式本身引入的功能。Python 也可以运行常规的 zip 文件，就像 Java 的 *.jar* 文件一样：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is equivalent to:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这等价于：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In other words, the `__main__` module for your program will be automatically
    imported from `__main__.py`. You can also import `__main__` from a module you
    specify by appending a slash followed by the module name, just as with `Wheel`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你程序的 `__main__` 模块会从 `__main__.py` 自动导入。你也可以通过追加斜杠后跟模块名，从指定的模块导入 `__main__`，就像使用
    `Wheel` 一样：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is equivalent to:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这等价于：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: One of the advantages of `Wheel` is that its naming conventions allow you to
    specify whether your distribution is intended for a specific architecture and/or
    Python implementation (CPython, PyPy, Jython, and so on). This is particularly
    useful if you need to distribute modules written in C.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wheel` 的一个优势是，它的命名约定允许你指定你的发行版是针对特定架构和/或 Python 实现（如 CPython、PyPy、Jython 等）。如果你需要分发用
    C 编写的模块，这一点特别有用。'
- en: By default, `Wheel` packages are tied to the major version of Python that you
    used to build them. When called with `python2 setup.py bdist_wheel`, the pattern
    of a `Wheel` filename will be something like *library-version-py2-none-any.whl*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Wheel` 包与构建它时所用的 Python 主要版本绑定。当使用 `python2 setup.py bdist_wheel` 调用时，`Wheel`
    文件名的格式会类似于 *library-version-py2-none-any.whl*。
- en: 'If your code is compatible with all major Python versions (that is, Python
    2 and Python 3), you can build a universal `Wheel`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码兼容所有主要的 Python 版本（即 Python 2 和 Python 3），你可以构建一个通用的 `Wheel`：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The resulting filename will be different and contains both Python major versions—something
    like *library-version-py2.py3-none-any.whl*. Building a universal `Wheel` avoids
    ending up with two different `Wheel`s when only one would cover both Python major
    versions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的文件名会有所不同，并且包含两个 Python 主要版本——类似于 *library-version-py2.py3-none-any.whl*。构建一个通用的
    `Wheel` 可以避免当只需要一个 `Wheel` 覆盖两个 Python 主要版本时，产生两个不同的 `Wheel` 文件。
- en: 'If you don’t want to pass the `--universal` flag each time you are building
    a `Wheel`, you can just add this to your *setup.cfg* file:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想在每次构建 `Wheel` 时都传递 `--universal` 标志，可以将其添加到你的 *setup.cfg* 文件中：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the `Wheel` you build contains binary programs or libraries (like a Python
    extension written in C), the binary `Wheel` might not be as portable as you imagine.
    It will work by default on some platforms, such as Darwin (macOS) or Microsoft
    Windows, but it might not work on all Linux distributions. The PEP 513 (*[https://www.python.org/dev/peps/pep-0513](https://www.python.org/dev/peps/pep-0513)*)
    targets this Linux problem by defining a new platform tag named `manylinux1` and
    a minimal set of libraries that are guaranteed to be available on that platform.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你构建的 `Wheel` 包含二进制程序或库（例如用 C 编写的 Python 扩展），那么二进制 `Wheel` 可能没有你想象的那样便捷跨平台。它默认可以在一些平台上工作，比如
    Darwin（macOS）或微软 Windows，但可能无法在所有 Linux 发行版上运行。PEP 513 (*[https://www.python.org/dev/peps/pep-0513](https://www.python.org/dev/peps/pep-0513)*)
    通过定义一个新的平台标签 `manylinux1` 和一组保证在该平台上可用的最小库，来解决这个 Linux 问题。
- en: '`Wheel` is a great format for distributing ready-to-install libraries and applications,
    so you are encouraged to build and upload them to PyPI as well.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wheel` 是一个用于分发准备安装的库和应用程序的优秀格式，因此建议你构建并将它们上传到 PyPI。'
- en: '**Sharing Your Work with the World**'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**与世界分享你的作品**'
- en: Once you have a proper *setup.py* file, it is easy to build a source tarball
    that can be distributed. The `sdist setuptools` command does just that, as demonstrated
    in [Listing 5-6](ch05.xhtml#ch5list6).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你拥有一个合适的 *setup.py* 文件，构建一个可以分发的源代码 tarball 就变得很简单。`sdist setuptools` 命令正是完成这项工作的命令，正如[列表
    5-6](ch05.xhtml#ch5list6)所示。
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 5-6: Using setup.py sdist to build a source tarball*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-6：使用 setup.py sdist 构建源 tarball*'
- en: The `sdist` command creates a tarball under the *dist* directory of the source
    tree. The tarball contains all the Python modules that are part of the source
    tree. As seen in the previous section, you can also build `Wheel` archives using
    the `bdist_wheel` command. `Wheel` archives are a bit faster to install as they’re
    already in the correct format for installation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`sdist` 命令会在源代码树的 *dist* 目录下创建一个 tarball。该 tarball 包含源代码树中的所有 Python 模块。如前一节所示，你也可以使用
    `bdist_wheel` 命令构建 `Wheel` 归档文件。`Wheel` 归档的安装速度更快，因为它们已经是正确的安装格式。'
- en: The final step to make that code accessible is to export your package somewhere
    users can install it via `pip`. That means publishing your project to PyPI.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使代码可用的最后一步是将你的软件包导出到用户可以通过 `pip` 安装的地方。这意味着将你的项目发布到 PyPI。
- en: If it’s your first time exporting to PyPI, it pays to test out the publishing
    process in a safe sandbox rather than on the production server. You can use the
    PyPI staging server for this purpose; it replicates all the functionality of the
    main index but is solely for testing purposes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次将软件发布到 PyPI，建议先在安全的沙盒中测试发布过程，而不是直接在生产服务器上进行。你可以使用 PyPI 测试服务器，它复制了主索引的所有功能，但仅用于测试目的。
- en: 'The first step is to register your project on the test server. Start by opening
    your *~/.pypirc* file and adding these lines:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将你的项目注册到测试服务器。首先，打开你的 *~/.pypirc* 文件并添加以下内容：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Save the file, and now you can register your project in the index:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，现在你可以在索引中注册你的项目：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This connects to the test PyPI server instance and creates a new entry. Don’t
    forget to use the `-r` option; otherwise, the real production PyPI instance would
    be used!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将连接到测试 PyPI 服务器实例并创建一个新的条目。不要忘记使用 `-r` 选项；否则，会使用真实的生产 PyPI 实例！
- en: Obviously, if a project with the same name is already registered there, the
    process will fail. Retry with a new name, and once you get your program registered
    and receive the `OK` response, you can upload a source distribution tarball, as
    shown in [Listing 5-7](ch05.xhtml#ch5list7).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，如果有同名的项目已经在 PyPI 注册，过程将会失败。请尝试使用一个新的名称，一旦你的程序成功注册并收到 `OK` 响应，你就可以上传源代码分发的
    tarball，如[列表 5-7](ch05.xhtml#ch5list7)所示。
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 5-7: Uploading your tarball to PyPI*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-7：将 tarball 上传到 PyPI*'
- en: Alternatively, you could upload a `Wheel` archive, as in [Listing 5-8](ch05.xhtml#ch5list8).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以上传一个 `Wheel` 格式的归档文件，如[列表 5-8](ch05.xhtml#ch5list8)所示。
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 5-8: Uploading a Wheel archive to PyPI*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-8：将 Wheel 归档上传到 PyPI*'
- en: 'Once those operations are finished, you and other users can search for the
    uploaded packages on the PyPI staging server, and even install those packages
    using `pip`, by specifying the test server using the `-i` option:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些操作完成，你和其他用户就可以在 PyPI 测试服务器上搜索已上传的软件包，甚至可以使用 `pip` 安装这些软件包，只需要使用 `-i` 选项指定测试服务器：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If everything checks out, you can upload your project to the main PyPI server.
    Just make sure to add your credentials and the details for the server to your
    `~/.pypirc` file first, like so:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，你可以将你的项目上传到主 PyPI 服务器。在此之前，确保将你的凭证和服务器的详细信息添加到 `~/.pypirc` 文件中，如下所示：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now if you run `register` and `upload` with the `-r pypi` switch, your package
    should be uploaded to PyPI.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你使用 `-r pypi` 选项运行 `register` 和 `upload`，你的软件包应该会被上传到 PyPI。
- en: '**NOTE**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*PyPI can keep several versions of your software in its index, allowing you
    to install specific and older versions, if you ever need to. Just pass the version
    number to the pip install command; for example, pip install foobar==1.0.2.*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*PyPI 可以在其索引中保留多个版本的软件，这样你就可以安装特定的旧版本，如果你需要的话。只需要在 pip install 命令中指定版本号；例如，pip
    install foobar==1.0.2。*'
- en: This process is straightforward to use and allows for any number of uploads.
    You can release your software as often as you want, and your users can install
    and update as often as they need.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程非常简便，允许进行任意数量的上传。你可以根据需要频繁发布你的软件，用户也可以根据需要频繁安装和更新。
- en: '**Entry Points**'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**入口点**'
- en: You may have already used `setuptools` entry points without knowing anything
    about them. Software distributed using `setuptools` includes important metadata
    describing features such as its required dependencies and—more relevantly to this
    topic—a list of *entry points*. Entry points are methods by which other Python
    programs can discover the dynamic features a package provides.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在不知情的情况下使用了`setuptools`入口点。通过`setuptools`分发的软件包括描述特性的重要元数据，例如所需的依赖关系，以及——对本主题更为相关的——*入口点*的列表。入口点是其他Python程序可以用来发现一个包提供的动态功能的方法。
- en: 'The following example shows how to provide an entry point named `rebuildd`
    in the `console_scripts` entry point group:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何在`console_scripts`入口点组中提供一个名为`rebuildd`的入口点：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Any Python package can register entry points. Entry points are organized in
    groups: each group is made of a list of key and value pairs. Those pairs use the
    format `path`.to.module:variable_name. In the previous example, the key is `rebuildd`,
    and the value is `rebuildd:main`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Python包都可以注册入口点。入口点按组组织：每个组由一组键值对组成。这些键值对使用格式`path.to.module:variable_name`。在前面的示例中，键是`rebuildd`，值是`rebuildd:main`。
- en: The list of entry points can be manipulated using various tools, from `setuptools`
    to `epi`, as I’ll show here. In the following sections, we discuss how we can
    use entry points to add extensibility to our software.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 入口点的列表可以通过各种工具进行操作，从`setuptools`到`epi`，正如我将在这里展示的那样。在接下来的几节中，我们将讨论如何使用入口点为我们的软件添加扩展性。
- en: '***Visualizing Entry Points***'
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***可视化入口点***'
- en: The easiest way to visualize the entry points available in a package is to use
    a package called `entry point inspector`. You can install it by running `pip install
    entry-point-inspector`. When installed, it provides the command `epi` that you
    can run from your terminal to interactively discover the entry points provided
    by installed packages. [Listing 5-9](ch05.xhtml#ch5list9) shows an example of
    running `epi group list` on my system.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化包中可用入口点的最简单方法是使用名为`entry point inspector`的包。你可以通过运行`pip install entry-point-inspector`来安装它。安装后，它提供了命令`epi`，你可以从终端运行它，交互式地发现已安装包提供的入口点。[清单
    5-9](ch05.xhtml#ch5list9)展示了在我的系统上运行`epi group list`的示例。
- en: '[PRE21]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 5-9: Getting a list of entry point groups*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-9：获取入口点组列表*'
- en: The output from `epi group list` in [Listing 5-9](ch05.xhtml#ch5list9) shows
    the different packages on a system that provide entry points. Each item in this
    table is the name of an entry point group. Note that this list includes `console_scripts`,
    which we’ll discuss shortly. We can use the `epi` command with the `show` command
    to show details of a particular entry point group, as in [Listing 5-10](ch05.xhtml#ch5list10).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`epi group list`的输出在[清单 5-9](ch05.xhtml#ch5list9)中展示了系统上提供入口点的不同包。表格中的每一项都是一个入口点组的名称。请注意，这个列表包括了`console_scripts`，我们稍后会讨论它。我们可以使用`epi`命令与`show`命令来显示特定入口点组的详细信息，如[清单
    5-10](ch05.xhtml#ch5list10)所示。
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 5-10: Showing details of an entry point group*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-10：显示入口点组的详细信息*'
- en: We can see that in the group `console_scripts`, an entry point named `coverage`
    refers to the member `main` of the module `coverage`. This entry point in particular,
    provided by the package `coverage 3.4`, indicates which Python function to call
    when the command line script `coverage` is executed. Here, the function `coverage.main`
    is to be called.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在`console_scripts`组中，一个名为`coverage`的入口点指向模块`coverage`的成员`main`。这个入口点，特别是由`coverage
    3.4`包提供，指示在执行命令行脚本`coverage`时应调用哪个Python函数。在这里，应该调用的函数是`coverage.main`。
- en: The `epi` tool is just a thin layer on top of the complete Python library `pkg_resources`.
    This module allows us to discover entry points for any Python library or program.
    Entry points are valuable for various things, including console scripts and dynamic
    code discovery, as you’ll see in the next few sections.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`epi`工具只是位于完整Python库`pkg_resources`之上的一层薄薄的封装。这个模块允许我们发现任何Python库或程序的入口点。入口点对于多种用途很有价值，包括控制台脚本和动态代码发现，正如你将在接下来的几节中看到的那样。'
- en: '***Using Console Scripts***'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用控制台脚本***'
- en: When writing a Python application, you almost always have to provide a launchable
    program—a Python script that the end user can run—that needs to be installed inside
    a directory somewhere in the system path.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写Python应用程序时，你几乎总是需要提供一个可启动的程序——一个用户可以运行的Python脚本——并且该程序需要安装在系统路径中的某个目录内。
- en: 'Most projects have a launchable program similar to this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数项目都有一个类似这样的可启动程序：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This kind of script is a best-case scenario: many projects have a much longer
    script installed in the system path. However, such scripts pose some major issues:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种脚本是最佳情况：许多项目在系统路径中安装了更长的脚本。然而，这些脚本存在一些主要问题：
- en: There’s no way the user can know where the Python interpreter is or which version
    it uses.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户无法知道Python解释器的位置或它使用的是哪个版本。
- en: This script leaks binary code that can’t be imported by software or unit tests.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该脚本泄漏了无法被软件或单元测试导入的二进制代码。
- en: There’s no easy way to define where to install this script.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有简单的方法来定义安装该脚本的位置。
- en: It’s not obvious how to install this in a portable way (for example, on both
    Unix and Windows).
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何以便携方式安装这个程序（例如，在Unix和Windows上）并不显而易见。
- en: 'Helping us circumvent these problems, `setuptools` offers the `console_scripts`
    feature. This entry point can be used to make `setuptools` install a tiny program
    in the system path that calls a specific function in one of your modules. With
    `setuptools`, you can specify a function call to start your program by setting
    up a key/value pair in the `console_scripts` entry point group: the key is the
    script name that will be installed, and the value is the Python path to your function
    (something like `my_module.main`).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们绕过这些问题，`setuptools`提供了`console_scripts`功能。此入口点可以用于使`setuptools`在系统路径中安装一个小程序，该程序调用你模块中的特定函数。使用`setuptools`，你可以通过在`console_scripts`入口点组中设置键/值对来指定一个函数调用来启动你的程序：键是将要安装的脚本名称，值是指向你的函数的Python路径（类似`my_module.main`）。
- en: 'Let’s imagine a `foobar` program that consists of a client and a server. Each
    part is written in its module—`foobar.client` and `foobar.server`, respectively,
    in *foobar/client.py*:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个`foobar`程序，由客户端和服务器组成。每个部分分别写在自己的模块中——`foobar.client`和`foobar.server`，它们分别位于*foobar/client.py*中：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And in *foobar/server.py*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在*foobar/server.py*中：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Of course, this program doesn’t do much of anything—our client and server don’t
    even talk to each other. For our example, though, they just need to print a message
    letting us know they have started successfully.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个程序并没有做太多事情——我们的客户端和服务器甚至没有互相通信。不过，对于我们的示例来说，它们只需要打印一条消息，告诉我们它们已成功启动。
- en: We can now write the following *setup.py* file in the root directory with entry
    points defined in *setup.py*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在根目录中编写以下*setup.py*文件，其中在*setup.py*中定义了入口点。
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We define entry points using the format `module.submodule:function`. You can
    see here that we’ve defined an entry point each for both `client` and `server`
    ➊.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`module.submodule:function`的格式定义入口点。你可以看到，我们为`client`和`server`分别定义了一个入口点
    ➊。
- en: When `python setup.py install` is run, `setuptools` will create a script that
    will look like the one in [Listing 5-11](ch05.xhtml#ch5list11).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行`python setup.py install`时，`setuptools`会创建一个脚本，该脚本看起来像[列表 5-11](ch05.xhtml#ch5list11)中的内容。
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 5-11: A console script generated by setuptools*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-11：由setuptools生成的控制台脚本*'
- en: This code scans the entry points of the `foobar` package and retrieves the `foobar`
    key from the `console_scripts` group, which is used to locate and run the corresponding
    function. The return value of the `load_entry_point` will then be a reference
    to the function `foobar.client.main`, which will be called without any arguments
    and whose return value will be used as an exit code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码扫描`foobar`包的入口点并从`console_scripts`组中获取`foobar`键，该键用于定位并运行相应的函数。`load_entry_point`的返回值将是对函数`foobar.client.main`的引用，该函数将在没有任何参数的情况下被调用，并且它的返回值将作为退出代码使用。
- en: Notice that this code uses `pkg_resources` to discover and load entry point
    files from within your Python programs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这段代码使用`pkg_resources`来发现并加载你Python程序中的入口点文件。
- en: '**NOTE**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re using pbr on top of setuptools, the generated script is simpler
    (and therefore faster) than the default one built by setuptools, as it will call
    the function you wrote in the entry point without having to search the entry point
    list dynamically at runtime.*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你在`setuptools`上使用了pbr，生成的脚本会比`setuptools`默认构建的脚本更简洁（因此更快速），因为它将直接调用你在入口点中编写的函数，而无需在运行时动态搜索入口点列表。*'
- en: Using console scripts is a technique that removes the burden of writing portable
    scripts, while ensuring that your code stays in your Python package and can be
    imported (and tested) by other programs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用控制台脚本是一种技术，它消除了编写便携脚本的负担，同时确保你的代码保持在Python包中，并可以被其他程序导入（和测试）。
- en: '***Using Plugins and Drivers***'
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用插件和驱动程序***'
- en: Entry points make it easy to discover and dynamically load code deployed by
    other packages, but this is not their only use. Any application can propose and
    register entry points and groups and then use them as it wishes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 入口点使得发现和动态加载其他包部署的代码变得容易，但这并不是它们唯一的用途。任何应用程序都可以提出并注册入口点和组，然后按需使用它们。
- en: In this section, we’re going to create a `cron`-style daemon `pycrond` that
    will allow any Python program to register a command to be run once every few seconds
    by registering an entry point in the group `pytimed`. The attribute indicated
    by this entry point should be an object that returns `number_of_seconds, callable`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个 `cron` 风格的守护进程 `pycrond`，它将允许任何 Python 程序注册一个命令，使其每隔几秒钟运行一次，通过在
    `pytimed` 组中注册一个入口点。该入口点所指示的属性应为返回 `number_of_seconds, callable` 的对象。
- en: 'Here’s our implementation of `pycrond` using `pkg_resources` to discover entry
    points, in a program I’ve named *pytimed.py*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们使用 `pkg_resources` 来发现入口点的 `pycrond` 实现，在我命名为 *pytimed.py* 的程序中：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This program consists of an infinite loop that iterates over each entry point
    of the `pytimed` group. Each entry point is loaded using the `load()` method.
    The program then calls the returned method, which needs to return the number of
    seconds to wait before calling the callable as well as the aforementioned callable.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序包含一个无限循环，它遍历 `pytimed` 组的每个入口点。每个入口点都使用 `load()` 方法加载。然后程序调用返回的方法，该方法需要返回在调用可调用对象之前等待的秒数以及上述可调用对象。
- en: 'The program in *pytimed.py* is a very simplistic and naive implementation,
    but it is sufficient for our example. Now we can write another Python program,
    named *hello.py*, that needs one of its functions called on a periodic basis:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*pytimed.py* 中的程序是一个非常简单和天真的实现，但它足以用于我们的示例。现在我们可以编写另一个 Python 程序，命名为 *hello.py*，它需要定期调用其中的一个函数：'
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Once we have that function defined, we register it using the appropriate entry
    points in *setup.py*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了这个函数，就可以使用适当的入口点在 *setup.py* 中注册它。
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The *setup.py* script registers an entry point in the group `pytimed` with the
    key `hello` and the value pointing to the function `hello.say_hello`. Once that
    package is installed using that *setup.py*—for example, using `pip install`—the
    `pytimed` script can detect the newly added entry point.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*setup.py* 脚本在 `pytimed` 组中注册一个入口点，键为 `hello`，值指向 `hello.say_hello` 函数。一旦通过该
    *setup.py* 安装了该包——例如使用 `pip install`——`pytimed` 脚本就能检测到新添加的入口点。'
- en: 'At startup, `pytimed` will scan the group `pytimed` and find the key `hello`.
    It will then call the `hello.say_hello` function, getting two values: the number
    of seconds to wait between each call and the function to call, 2 seconds and `print_hello`
    in this case. By running the program, as we do in [Listing 5-12](ch05.xhtml#ch5list12),
    you can see “Hello, world!” printed on the screen every 2 seconds.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 启动时，`pytimed` 将扫描 `pytimed` 组并找到键 `hello`。然后，它将调用 `hello.say_hello` 函数，得到两个值：每次调用之间等待的秒数和要调用的函数，这里是
    2 秒和 `print_hello`。通过运行程序，就像我们在 [Listing 5-12](ch05.xhtml#ch5list12) 中所做的那样，你可以看到“Hello,
    world!” 每 2 秒打印一次。
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 5-12: Running pytimed*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-12: 运行 pytimed*'
- en: 'The possibilities this mechanism offers are immense: you can build driver systems,
    hook systems, and extensions easily and generically. Implementing this mechanism
    by hand in every program you make would be tedious, but fortunately, there’s a
    Python library that can take care of the boring parts for us.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制提供的可能性是巨大的：你可以轻松而通用地构建驱动程序系统、挂钩系统和扩展。如果每个程序都手动实现这个机制，肯定会很繁琐，但幸运的是，Python
    有一个库可以帮我们处理这些枯燥的部分。
- en: 'The `stevedore` library provides support for dynamic plugins based on the same
    mechanism demonstrated in our previous examples. The use case in this example
    is already simplistic, but we can still simplify it further in this script, *pytimed_stevedore.py*:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`stevedore` 库提供了基于我们之前示例中演示的相同机制的动态插件支持。本示例中的使用案例已经很简单，但我们仍然可以在这个脚本中进一步简化它，*pytimed_stevedore.py*：'
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `ExtensionManager` class of `stevedore` provides a simple way to load all
    extensions of an entry point group. The name is passed as a first argument. The
    argument `invoke_on_load=True` makes sure that each function of the group is called
    once discovered. This makes the results accessible directly from the `obj` attribute
    of the extension.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`stevedore` 的 `ExtensionManager` 类提供了一种简单的方法来加载入口点组的所有扩展。名称作为第一个参数传递。参数 `invoke_on_load=True`
    确保每个组的函数在被发现后都会被调用。这样，结果可以直接通过扩展的 `obj` 属性访问。'
- en: If you look through the `stevedore` documentation, you will see that `ExtensionManager`
    has a variety of subclasses that can handle different situations, such as loading
    specific extensions based on their names or the result of a function. All of those
    are commonly used models you can apply to your program in order to implement those
    patterns directly.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`stevedore`的文档，你会看到`ExtensionManager`有多种子类，可以处理不同的情况，例如根据扩展名或函数结果加载特定扩展。所有这些常用模型可以应用到你的程序中，直接实现这些模式。
- en: For example, we might want to load and run only one extension from our entry
    point group. Leveraging the `stevedore.driver.DriverManager` class allows us to
    do that, as [Listing 5-13](ch05.xhtml#ch5list13) shows.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能只想从入口点组中加载并运行一个扩展。利用`stevedore.driver.DriverManager`类，我们可以实现这一点，如[列出5-13](ch05.xhtml#ch5list13)所示。
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 5-13: Using stevedore to run a single extension from an entry point*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出5-13：使用stevedore从入口点运行单个扩展*'
- en: In this case, only one extension is loaded and selected by name. This allows
    us to quickly build a *driver system* in which only one extension is loaded and
    used by a program.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只有一个扩展按名称加载和选择。这使我们能够快速构建一个*驱动程序系统*，其中只有一个扩展被程序加载和使用。
- en: '**Summary**'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: The packaging ecosystem in Python has a bumpy history; however, the situation
    is now settling. The `setuptools` library provides a complete solution to packaging,
    not only to transport your code in different formats and upload it to PyPI, but
    also to handle connection with other software and libraries via entry points.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Python的打包生态系统经历了曲折的历史；然而，现在局势正在逐步稳定。`setuptools`库提供了完整的打包解决方案，不仅可以以不同格式传输代码并上传到PyPI，还可以通过入口点处理与其他软件和库的连接。
- en: '**Nick Coghlan on Packaging**'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Nick Coghlan谈打包**'
- en: Nick is a Python core developer working at Red Hat. He has written several PEP
    proposals, including PEP 426 (Metadata for Python Software Packages 2.0), and
    he is acting as delegate for our Benevolent Dictator for Life, Guido van Rossum,
    author of Python.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Nick是Red Hat的Python核心开发者。他撰写了几份PEP提案，包括PEP 426（Python软件包元数据2.0），并且担任我们的终身独裁者Guido
    van Rossum（Python的作者）的代表。
- en: '**The number of packaging solutions (distutils, setuptools, distutils2, distlib,
    bento, pbr, and so on) for Python is quite extensive. In your opinion, what are
    the reasons for such fragmentation and divergence?**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python的打包解决方案（distutils、setuptools、distutils2、distlib、bento、pbr等）种类繁多。你认为这种碎片化和分歧的原因是什么？**'
- en: The short answer is that software publication, distribution, and integration
    is a complex problem with plenty of room for multiple solutions tailored for different
    use cases. In my recent talks on this, I have noted that the problem is mainly
    one of age, with the different packaging tools being born into different eras
    of software distribution.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，软件发布、分发和集成是一个复杂的问题，有足够的空间为不同的使用场景量身定制多种解决方案。在我最近的相关讲座中，我提到问题主要是由于时代差异，不同的打包工具诞生于不同的软件分发时代。
- en: '**PEP 426, which defines a new metadata format for Python packages, is still
    fairly recent and not yet approved. How do you think it will tackle current packaging
    problems?**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**PEP 426，定义了Python包的新元数据格式，仍然相对较新，尚未获得批准。你认为它将如何解决当前的打包问题？**'
- en: PEP 426 originally started as part of the `Wheel` format definition, but Daniel
    Holth realized that `Wheel` could work with the existing metadata format defined
    by `setuptools`. PEP 426 is thus a consolidation of the existing `setuptools`
    metadata with some of the ideas from `distutils2` and other packaging systems
    (such as `RPM` and `npm`). It addresses some of the frustrations encountered with
    existing tools (for example, with cleanly separating different kinds of dependencies).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 426最初是作为`Wheel`格式定义的一部分开始的，但Daniel Holth意识到`Wheel`可以与`setuptools`定义的现有元数据格式兼容。因此，PEP
    426是对现有`setuptools`元数据的整合，并融合了`distutils2`及其他打包系统（如`RPM`和`npm`）的一些理念。它解决了现有工具所遇到的一些问题（例如，清晰地区分不同类型的依赖关系）。
- en: The main gains will be a REST API on PyPI offering full metadata access, as
    well as (hopefully) the ability to automatically generate distribution policy–compliant
    packages from upstream metadata.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的进展将是在PyPI上提供REST API，提供完整的元数据访问，以及（希望）从上游元数据自动生成符合分发政策的打包文件。
- en: '**The `Wheel` format is somewhat recent and not widely used yet, but it seems
    promising. Why is it not part of the Standard Library?**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**`Wheel`格式相对较新，尚未广泛使用，但似乎很有前景。为什么它不是标准库的一部分？**'
- en: 'It turns out the Standard Library is not really a suitable place for packaging
    standards: it evolves too slowly, and an addition to a later version of the Standard
    Library cannot be used with earlier versions of Python. So, at the Python language
    summit earlier this year, we tweaked the PEP process to allow `distutils-sig`
    to manage the full approval cycle for packaging-related PEPs, and `python-dev`
    will only be involved for proposals that involve changing CPython directly (such
    as `pip` bootstrapping).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，标准库并不是打包标准的合适场所：它的发展速度太慢，而且标准库的后续版本的新增内容无法与早期版本的 Python 一起使用。因此，在今年早些时候的
    Python 语言峰会上，我们对 PEP 流程进行了调整，允许 `distutils-sig` 管理与打包相关的 PEP 的完整审批周期，而 `python-dev`
    仅在涉及直接修改 CPython 的提案（例如 `pip` 引导程序）时参与。
- en: '**What is the future for **Wheel** packages?**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**`Wheel` 包的未来是什么？**'
- en: We still have some tweaks to make before `Wheel` is suitable for use on Linux.
    However, `pip` is adopting `Wheel` as an alternative to the `Egg` format, allowing
    local caching of builds for fast virtual environment creation, and PyPI allows
    uploads of `Wheel` archives for Windows and macOS.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Wheel` 适用于 Linux 之前，我们仍需进行一些调整。不过，`pip` 已将 `Wheel` 作为 `Egg` 格式的替代方案，允许对构建进行本地缓存，以便快速创建虚拟环境，并且
    PyPI 允许上传适用于 Windows 和 macOS 的 `Wheel` 档案。
