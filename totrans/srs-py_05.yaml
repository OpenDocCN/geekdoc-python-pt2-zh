- en: '**5**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5**'
- en: '**DISTRIBUTING YOUR SOFTWARE**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**分发你的软件**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: It’s safe to say that at some point, you will want to distribute your software.
    As tempted as you might be to just zip your code and upload it to the internet,
    Python provides tools to make it easier for your end users to get your software
    to work. You should already be familiar with using *setup.py* to install Python
    applications and libraries, but you have probably never delved into how it works
    behind the scenes or how to make a *setup.py* of your own.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 可以肯定地说，在某个时刻，你会希望分发你的软件。虽然你可能会忍不住直接将代码打包并上传到互联网，Python 提供了工具来帮助你的最终用户更轻松地使用你的软件。你应该已经熟悉使用
    *setup.py* 来安装 Python 应用程序和库，但你可能从未深入了解过它的背后原理或如何创建你自己的 *setup.py*。
- en: In this chapter, you’ll learn the history of *setup.py*, how the file works,
    and how to create your own custom *setup.py*. We’ll also take a look at some of
    the less well-known capabilities of the package installation tool pip and how
    to make your software downloadable via pip. Finally, we’ll see how to use Python’s
    entry points to make functions easy to find between programs. With these skills,
    you can make your published software accessible for end users.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 *setup.py* 的历史、它是如何工作的以及如何创建你自己的定制 *setup.py*。我们还将看一些包安装工具 pip 的不太为人知的功能，以及如何通过
    pip 让你的软件可以下载。最后，我们将了解如何使用 Python 的入口点使得函数在程序之间更容易找到。有了这些技能，你就可以让发布的软件更容易为最终用户所使用。
- en: '**A Bit of setup.py History**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**setup.py 的一点历史**'
- en: The distutils library, originally created by software developer Greg Ward, has
    been part of the standard Python library since 1998\. Ward sought to create an
    easy way for developers to automate the installation process for their end users.
    Packages provide the *setup.py* file as the standard Python script for their installation,
    and they can use distutils to install themselves, as shown in [Listing 5-1](ch05.xhtml#ch5list1).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: distutils 库最初由软件开发者 Greg Ward 创建，自 1998 年以来一直是标准 Python 库的一部分。Ward 希望为开发者提供一种简便的方式，帮助他们自动化为最终用户安装软件包的过程。软件包提供
    *setup.py* 文件作为标准的 Python 脚本进行安装，开发者可以使用 distutils 来进行安装，如 [Listing 5-1](ch05.xhtml#ch5list1)
    所示。
- en: '#!/usr/bin/python'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '#!/usr/bin/python'
- en: from distutils.core import setup
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: from distutils.core import setup
- en: setup(name="rebuildd",
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: setup(name="rebuildd",
- en: description="Debian packages rebuild tool",
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: description="Debian 软件包重建工具",
- en: author="Julien Danjou",
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: author="Julien Danjou",
- en: author_email="acid@debian.org",
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: author_email="acid@debian.org",
- en: url="http://julien.danjou.info/software/rebuildd.html",
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: url="http://julien.danjou.info/software/rebuildd.html",
- en: packages=['rebuildd'])
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: packages=['rebuildd'])
- en: '*Listing 5-1: Building a setup.py using distutils*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 5-1: 使用 distutils 构建 setup.py*'
- en: With the *setup.py* file as the root of a project, all users have to do to build
    or install your software is run that file with the appropriate command as its
    argument. Even if your distribution includes C modules in addition to native Python
    ones, distutils can handle them automatically.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以 *setup.py* 文件为项目根基，用户只需运行该文件并传入相应的命令作为参数，即可构建或安装你的软件。即使你的分发版除了原生 Python 模块外还包含
    C 模块，distutils 也能自动处理它们。
- en: Development of distutils was abandoned in 2000; since then, other developers
    have picked up where it left off. One of the notable successors is the packaging
    library known as setuptools, which offers more frequent updates and advanced features,
    such as automatic dependency handling, the Egg distribution format, and the easy_install
    command. Since distutils was still the accepted means of packaging software included
    with the Python Standard Library at the time of development, setuptools provided
    a degree of backward compatibility with it. [Listing 5-2](ch05.xhtml#ch5list2)
    shows how you’d use setuptools to build the same installation package as in [Listing
    5-1](ch05.xhtml#ch5list1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: distutils 的开发在 2000 年被放弃；从那时起，其他开发者接手了它的后续工作。一个显著的继承者是名为 setuptools 的打包库，它提供了更频繁的更新和更多高级功能，比如自动处理依赖关系、Egg
    分发格式以及 easy_install 命令。由于 distutils 在开发时仍是 Python 标准库中接受的软件打包方式，setuptools 提供了与其一定程度的向后兼容性。
    [Listing 5-2](ch05.xhtml#ch5list2) 展示了如何使用 setuptools 构建与 [Listing 5-1](ch05.xhtml#ch5list1)
    中相同的安装包。
- en: '#!/usr/bin/env python'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '#!/usr/bin/env python'
- en: import setuptools
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: import setuptools
- en: setuptools.setup(
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: setuptools.setup(
- en: name="rebuildd",
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: name="rebuildd",
- en: version="0.2",
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: version="0.2",
- en: author="Julien Danjou",
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: author="Julien Danjou",
- en: author_email="acid@debian.org",
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: author_email="acid@debian.org",
- en: description="Debian packages rebuild tool",
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: description="Debian 软件包重建工具",
- en: license="GPL",
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: license="GPL",
- en: url="http://julien.danjou.info/software/rebuildd/",
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: url="http://julien.danjou.info/software/rebuildd/",
- en: packages=['rebuildd'],
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: packages=['rebuildd'],
- en: classifiers=[
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: classifiers=[
- en: '"Development Status :: 2 - Pre-Alpha",'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '"开发状态 :: 2 - 初期版本",'
- en: '"Intended Audience :: Developers",'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '"目标受众 :: 开发人员",'
- en: '"Intended Audience :: Information Technology",'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '"目标受众 :: 信息技术",'
- en: '"License :: OSI Approved :: GNU General Public License (GPL)", "Operating System
    :: OS Independent",'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '"许可证 :: OSI 认可 :: GNU 通用公共许可证（GPL）", "操作系统 :: 跨平台",'
- en: '"Programming Language :: Python"'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '"编程语言 :: Python"'
- en: '],'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: )
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*Listing 5-2: Building a setup.py using setuptools*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-2：使用 setuptools 构建 setup.py*'
- en: Eventually, development on setuptools slowed down too, but it wasn’t long before
    another group of developers forked it to create a new library called distribute,
    which offered several advantages over setuptools, including fewer bugs and Python
    3 support.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，setuptools 的开发也放缓了，但很快，另一组开发人员将其分支出来，创建了一个名为 distribute 的新库，该库在 setuptools
    的基础上提供了几个优点，包括减少了 bug 和对 Python 3 的支持。
- en: 'All the best stories have a twist ending, though: in March 2013, the teams
    behind setuptools and distribute decided to merge their codebases under the aegis
    of the original setuptools project. So distribute is now deprecated, and setuptools
    is once more the canonical way to handle advanced Python installations.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，所有最好的故事都有反转：在 2013 年 3 月，setuptools 和 distribute 背后的团队决定将他们的代码库合并到原始 setuptools
    项目下。因此，distribute 现在已被弃用，setuptools 再次成为处理高级 Python 安装的规范方式。
- en: While all this was happening, another project, known as distutils2, was developed
    with the intention of completely replacing distutils in the Python Standard Library.
    Unlike both distutils and setuptools, it stored package metadata in a plaintext
    file, *setup.cfg*, which was easier both for developers to write and for external
    tools to read. However, distutils2 retained some of the failings of distutils,
    such as its obtuse command-based design, and lacked support for entry points and
    native script execution on Windows—both features provided by setuptools. For these
    and other reasons, plans to include distutils2, renamed as packaging, in the Python
    3.3 Standard Library fell through, and the project was abandoned in 2012.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一切发生的同时，另一个名为 distutils2 的项目也在开发，目的是完全取代 Python 标准库中的 distutils。与 distutils
    和 setuptools 不同，distutils2 将包的元数据存储在纯文本文件 *setup.cfg* 中，这既便于开发人员编写，也便于外部工具读取。然而，distutils2
    保留了 distutils 的一些缺点，例如它难以理解的基于命令的设计，并且缺乏对入口点和 Windows 本地脚本执行的支持——这两项功能是 setuptools
    提供的。由于这些原因，原本计划将 distutils2（更名为 packaging）纳入 Python 3.3 标准库的计划未能实现，该项目在 2012 年被放弃。
- en: There is still a chance for packaging to rise from the ashes through distlib,
    an up-and-coming effort to replace distutils. Before release, it was rumored that
    the distlib package would become part of the Standard Library in Python 3.4, but
    that never came to be. Including the best features from packaging, distlib implements
    the basic groundwork described in the packaging-related PEPs.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 distlib，打破困境的打包工具仍有机会从废墟中崛起，这是一个旨在取代 distutils 的新兴项目。在发布之前，有传言称 distlib 包将成为
    Python 3.4 标准库的一部分，但这一计划并未实现。distlib 在集成打包的最佳特性基础上，实施了打包相关 PEPs 中描述的基本工作框架。
- en: 'So, to recap:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，简而言之：
- en: distutils is part of the Python Standard Library and can handle simple package
    installations.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: distutils 是 Python 标准库的一部分，可以处理简单的包安装。
- en: setuptools, the standard for advanced package installations, was at first deprecated
    but is now back in active development and the de facto standard.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: setuptools，作为高级包安装的标准，最初被弃用，但现在已经重新进入积极开发阶段，并成为事实上的标准。
- en: distribute has been merged back into setuptools as of version 0.7; distutils2
    (aka packaging) has been abandoned.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: distribute 已在版本 0.7 中并入 setuptools；distutils2（即 packaging）已被废弃。
- en: distlib *might* replace distutils in the future.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: distlib *可能* 在未来取代 distutils。
- en: 'There are other packaging libraries out there, but these are the five you’ll
    encounter the most. Be careful when researching these libraries on the internet:
    plenty of documentation is outdated due to the complicated history outlined above.
    The official documentation is up-to-date, however.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他打包库，但这五个是你最常遇到的。在互联网上查找这些库时要小心：由于上文提到的复杂历史，很多文档已经过时。不过，官方文档是最新的。
- en: In short, setuptools is the distribution library to use for the time being,
    but keep an eye out for distlib in the future.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，setuptools 目前是使用的打包库，但未来要留意 distlib 的发展。
- en: '**Packaging with setup.cfg**'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 setup.cfg 进行打包**'
- en: 'You’ve probably already tried to write a *setup.py* for a package at some point,
    either by copying one from another project or by skimming through the documentation
    and building it yourself. Building a *setup.py* is not an intuitive task. Choosing
    the right tool to use is just the first challenge. In this section, I want to
    introduce you to one of the recent improvements to setuptools: the *setup.cfg*
    file support.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a *setup.py* using a *setup.cfg* file looks like:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: import setuptools
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: setuptools.setup()
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Two lines of code—it is that simple. The actual metadata the setup requires
    is stored in *setup.cfg*, as in [Listing 5-3](ch05.xhtml#ch5list3).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[metadata]'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: name = foobar
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: author = Dave Null
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: author-email = foobar@example.org
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: license = MIT
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'long_description = file: README.rst'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: url = http://pypi.python.org/pypi/foobar
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: requires-python = >=2.6
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: classifiers =
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Development Status :: 4 - Beta'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Environment :: Console'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Intended Audience :: Developers'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Intended Audience :: Information Technology'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'License :: OSI Approved :: Apache Software License'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Operating System :: OS Independent'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Programming Language :: Python'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-3: The setup.cfg metadata*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, *setup.cfg* uses a format that’s easy to write and read, directly
    inspired by distutils2. Many other tools, such as Sphinx or Wheel, also read configuration
    from this *setup.cfg* file—that alone is a good argument to start using it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 5-3](ch05.xhtml#ch5list3), the description of the project is read
    from the *README.rst* file. It’s good practice to always have a README file—preferably
    in the RST format—so users can quickly understand what the project is about. With
    just these basic *setup.py* and *setup.cfg* files, your package is ready to be
    published and used by other developers and applications. The setuptools documentation
    provides more details if needed, for example, if you have some extra steps in
    your installation process or want to include extra files.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful packaging tool is pbr, short for *Python Build Reasonableness*.
    The project was started in OpenStack as an extension of setuptools to facilitate
    installation and deployment of packages. The pbr packaging tool, used alongside
    setuptools, implements features absent from setuptools, including these:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Automatic generation of Sphinx documentation
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic generation of *AUTHORS* and *ChangeLog* files based on git history
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic creation of file lists for git
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version management based on git tags using semantic versioning
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And all this with little to no effort on your part. To use pbr, you just need
    to enable it, as shown in [Listing 5-4](ch05.xhtml#ch5list4).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: import setuptools
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: setuptools.setup(setup_requires=['pbr'], pbr=True)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-4: setup.py using pbr*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The setup_requires parameter indicates to setuptools that pbr must be installed
    prior to using setuptools. The pbr=True argument makes sure that the pbr extension
    for setuptools is loaded and called.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Once enabled, the python setup.py command is enhanced with the pbr features.
    Calling python setup.py –version will, for example, return the version number
    of the project based on existing git tags. Running python setup.py sdist would
    create a source tarball with automatically generated *ChangeLog* and *AUTHORS*
    files.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '**The Wheel Format Distribution Standard**'
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For most of Python’s existence, there’s been no official standard distribution
    format. While different distribution tools generally use some common archive format—even
    the Egg format introduced by setuptools is just a zip file with a different extension—their
    metadata and package structures are incompatible with each other. This problem
    was compounded when an official installation standard was finally defined in PEP
    376 that was also incompatible with existing formats.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: To solve these problems, PEP 427 was written to define a new standard for Python
    distribution packages called Wheel. The reference implementation of this format
    is available as a tool, also called Wheel.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Wheel is supported by pip starting with version 1.4\. If you’re using setuptools
    and have the Wheel package installed, it automatically integrates itself as a
    setuptools command named bdist_wheel. If you don’t have Wheel installed, you can
    install it using the command pip install wheel. [Listing 5-5](ch05.xhtml#ch5list5)
    shows some of the output when calling bdist_wheel, abridged for print.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: $ python setup.py bdist_wheel
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: running bdist_wheel
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: running build
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: running build_py
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: creating build/lib
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: creating build/lib/daiquiri
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: creating build/lib/daiquiri/tests
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: copying daiquiri/tests/__init__.py -> build/lib/daiquiri/tests
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: running egg_info
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: writing requirements to daiquiri.egg-info/requires.txt
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: writing daiquiri.egg-info/PKG-INFO
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: writing top-level names to daiquiri.egg-info/top_level.txt
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: writing dependency_links to daiquiri.egg-info/dependency_links.txt
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: writing pbr to daiquiri.egg-info/pbr.json
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: writing manifest file 'daiquiri.egg-info/SOURCES.txt'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: installing to build/bdist.macosx-10.12-x86_64/wheel
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: running install
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: running install_lib
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: running install_scripts
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: creating build/bdist.macosx-10.12-x86_64/wheel/daiquiri-1.3.0.dist-info/WHEEL
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: ➊ creating '/Users/jd/Source/daiquiri/dist/daiquiri-1.3.0-py2.py3-none-any.whl'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: and adding '.' to it
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: adding 'daiquiri/__init__.py'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: adding 'daiquiri/formatter.py'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: adding 'daiquiri/handlers.py'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-5: Calling setup.py bdist_wheel*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'The bdist_wheel command creates a *.whl* file in the *dist* directory ➊. As
    with the Egg format, a Wheel archive is just a zip file with a different extension.
    However, Wheel archives do not require installation—you can load and run your
    code just by adding a slash followed by the name of your module:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: $ python wheel-0.21.0-py2.py3-none-any.whl/wheel -h
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'usage: wheel [-h]'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '{keygen,sign,unsign,verify,unpack,install,install-'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: scripts,convert,help}
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'positional arguments:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be surprised to learn this is not a feature introduced by the Wheel
    format itself. Python can also run regular zip files, just like with Java’s *.jar*
    files:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: python foobar.zip
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'This is equivalent to:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: PYTHONPATH=foobar.zip python -m __main__
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, the __main__ module for your program will be automatically
    imported from __main__.py. You can also import __main__ from a module you specify
    by appending a slash followed by the module name, just as with Wheel:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: python foobar.zip/mymod
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'This is equivalent to:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: PYTHONPATH=foobar.zip python -m mymod.__main__
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of Wheel is that its naming conventions allow you to specify
    whether your distribution is intended for a specific architecture and/or Python
    implementation (CPython, PyPy, Jython, and so on). This is particularly useful
    if you need to distribute modules written in C.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: By default, Wheel packages are tied to the major version of Python that you
    used to build them. When called with python2 setup.py bdist_wheel, the pattern
    of a Wheel filename will be something like *library-version-py2-none-any.whl*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'If your code is compatible with all major Python versions (that is, Python
    2 and Python 3), you can build a universal Wheel:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: python setup.py bdist_wheel --universal
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The resulting filename will be different and contains both Python major versions—something
    like *library-version-py2.py3-none-any.whl*. Building a universal Wheel avoids
    ending up with two different Wheels when only one would cover both Python major
    versions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t want to pass the --universal flag each time you are building a
    Wheel, you can just add this to your *setup.cfg* file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[wheel]'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: universal=1
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: If the Wheel you build contains binary programs or libraries (like a Python
    extension written in C), the binary Wheel might not be as portable as you imagine.
    It will work by default on some platforms, such as Darwin (macOS) or Microsoft
    Windows, but it might not work on all Linux distributions. The PEP 513 (*[https://www.python.org/dev/peps/pep-0513](https://www.python.org/dev/peps/pep-0513)*)
    targets this Linux problem by defining a new platform tag named manylinux1 and
    a minimal set of libraries that are guaranteed to be available on that platform.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Wheel is a great format for distributing ready-to-install libraries and applications,
    so you are encouraged to build and upload them to PyPI as well.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '**Sharing Your Work with the World**'
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have a proper *setup.py* file, it is easy to build a source tarball
    that can be distributed. The sdist setuptools command does just that, as demonstrated
    in [Listing 5-6](ch05.xhtml#ch5list6).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: $ python setup.py sdist
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: running sdist
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[pbr] Generating AUTHORS'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: running egg_info
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: writing requirements to ceilometer.egg-info/requires.txt
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: writing ceilometer.egg-info/PKG-INFO
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: writing top-level names to ceilometer.egg-info/top_level.txt
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: writing dependency_links to ceilometer.egg-info/dependency_links.txt
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: writing entry points to ceilometer.egg-info/entry_points.txt
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[pbr] Processing SOURCES.txt'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[pbr] 处理 SOURCES.txt'
- en: '[pbr] In git context, generating filelist from git'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[pbr] 在 git 上生成文件列表'
- en: 'warning: no previously-included files matching ''*.pyc'' found anywhere in'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：没有找到任何匹配 '*.pyc' 的文件
- en: distribution
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 发布
- en: writing manifest file 'ceilometer.egg-info/SOURCES.txt'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 写入清单文件 'ceilometer.egg-info/SOURCES.txt'
- en: running check
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行检查
- en: copying setup.cfg -> ceilometer-2014.1.a6-g772e1a7
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 复制 setup.cfg -> ceilometer-2014.1.a6-g772e1a7
- en: Writing ceilometer-2014.1.a6-g772e1a7/setup.cfg
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 写入 ceilometer-2014.1.a6-g772e1a7/setup.cfg
- en: --snip--
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: Creating tar archive
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 tar 压缩包
- en: removing 'ceilometer-2014.1.a6.g772e1a7' (and everything under it)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 移除 'ceilometer-2014.1.a6.g772e1a7'（以及其下的所有内容）
- en: '*Listing 5-6: Using setup.py sdist to build a source tarball*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 5-6：使用 setup.py sdist 构建源代码 tar 包*'
- en: The sdist command creates a tarball under the *dist* directory of the source
    tree. The tarball contains all the Python modules that are part of the source
    tree. As seen in the previous section, you can also build Wheel archives using
    the bdist_wheel command. Wheel archives are a bit faster to install as they’re
    already in the correct format for installation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: sdist 命令会在源代码树的 *dist* 目录下创建一个 tar 包。这个 tar 包包含了所有源代码树中的 Python 模块。如前一节所述，你也可以使用
    bdist_wheel 命令构建 Wheel 格式的归档。Wheel 格式的归档安装速度更快，因为它们已经是安装所需的正确格式。
- en: The final step to make that code accessible is to export your package somewhere
    users can install it via pip. That means publishing your project to PyPI.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让代码可以访问的最后一步是将你的包导出到用户可以通过pip安装的地方。这意味着将项目发布到PyPI。
- en: If it’s your first time exporting to PyPI, it pays to test out the publishing
    process in a safe sandbox rather than on the production server. You can use the
    PyPI staging server for this purpose; it replicates all the functionality of the
    main index but is solely for testing purposes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次导出到PyPI，最好在一个安全的沙盒中测试发布过程，而不是在生产服务器上。你可以使用PyPI的测试服务器进行此目的；它复制了主索引的所有功能，但仅用于测试。
- en: 'The first step is to register your project on the test server. Start by opening
    your *~/.pypirc* file and adding these lines:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将项目注册到测试服务器。首先打开你的 *~/.pypirc* 文件，并添加以下几行：
- en: '[distutils]'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[distutils]'
- en: index-servers =
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: index-servers =
- en: testpypi [testpypi]
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: testpypi [testpypi]
- en: username = <your username>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 用户名 = <你的用户名>
- en: password = <your password>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: password = <你的密码>
- en: repository = https://testpypi.python.org/pypi
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库 = https://testpypi.python.org/pypi
- en: 'Save the file, and now you can register your project in the index:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，现在你可以在索引中注册你的项目了：
- en: $ python setup.py register -r testpypi
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: $ python setup.py register -r testpypi
- en: running register
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 运行注册
- en: running egg_info
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 egg_info
- en: writing requirements to ceilometer.egg-info/requires.txt
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 写入依赖要求到 ceilometer.egg-info/requires.txt
- en: writing ceilometer.egg-info/PKG-INFO
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 写入 ceilometer.egg-info/PKG-INFO
- en: writing top-level names to ceilometer.egg-info/top_level.txt
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 写入顶级名称到 ceilometer.egg-info/top_level.txt
- en: writing dependency_links to ceilometer.egg-info/dependency_links.txt
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 写入依赖链接到 ceilometer.egg-info/dependency_links.txt
- en: writing entry points to ceilometer.egg-info/entry_points.txt
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 写入入口点到 ceilometer.egg-info/entry_points.txt
- en: '[pbr] Reusing existing SOURCES.txt'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[pbr] 重用现有的 SOURCES.txt'
- en: running check
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 运行检查
- en: Registering ceilometer to https://testpypi.python.org/pypi
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正在注册 ceilometer 到 https://testpypi.python.org/pypi
- en: 'Server response (200): OK'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应（200）：OK
- en: This connects to the test PyPI server instance and creates a new entry. Don’t
    forget to use the -r option; otherwise, the real production PyPI instance would
    be used!
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这会连接到测试 PyPI 服务器实例并创建一个新条目。别忘了使用 -r 选项；否则会使用真实的生产 PyPI 实例！
- en: Obviously, if a project with the same name is already registered there, the
    process will fail. Retry with a new name, and once you get your program registered
    and receive the OK response, you can upload a source distribution tarball, as
    shown in [Listing 5-7](ch05.xhtml#ch5list7).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，如果一个同名的项目已经在那注册过了，过程将会失败。请重新尝试使用一个新的名称，一旦你成功注册了程序并收到OK响应，你就可以上传源代码的tar包，参考[清单5-7](ch05.xhtml#ch5list7)。
- en: $ python setup.py sdist upload -r testpypi
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: $ python setup.py sdist upload -r testpypi
- en: running sdist
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 sdist
- en: '[pbr] Writing ChangeLog'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[pbr] 写入 ChangeLog'
- en: '[pbr] Generating AUTHORS'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[pbr] 生成 AUTHORS'
- en: running egg_info
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 egg_info
- en: writing requirements to ceilometer.egg-info/requires.txt
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 写入依赖要求到 ceilometer.egg-info/requires.txt
- en: writing ceilometer.egg-info/PKG-INFO
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 写入 ceilometer.egg-info/PKG-INFO
- en: writing top-level names to ceilometer.egg-info/top_level.txt
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 写入顶级名称到 ceilometer.egg-info/top_level.txt
- en: writing dependency_links to ceilometer.egg-info/dependency_links.txt
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 写入依赖链接到 ceilometer.egg-info/dependency_links.txt
- en: writing entry points to ceilometer.egg-info/entry_points.txt
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 写入入口点到 ceilometer.egg-info/entry_points.txt
- en: '[pbr] Processing SOURCES.txt'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[pbr] In git context, generating filelist from git'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'warning: no previously-included files matching ''*.pyc'' found anywhere in'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: distribution
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: writing manifest file 'ceilometer.egg-info/SOURCES.txt'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: running check
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: creating ceilometer-2014.1.a6.g772e1a7
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: copying setup.cfg -> ceilometer-2014.1.a6.g772e1a7
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Writing ceilometer-2014.1.a6.g772e1a7/setup.cfg
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Creating tar archive
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: removing 'ceilometer-2014.1.a6.g772e1a7' (and everything under it)
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: running upload Submitting dist/ceilometer-2014.1.a6.g772e1a7.tar.gz to https://testpypi
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: .python.org/pypi
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Server response (200): OK'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-7: Uploading your tarball to PyPI*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you could upload a Wheel archive, as in [Listing 5-8](ch05.xhtml#ch5list8).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: $ python setup.py bdist_wheel upload -r testpypi
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: running bdist_wheel
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: running build
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: running build_py
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: running egg_info
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: writing requirements to ceilometer.egg-info/requires.txt
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: writing ceilometer.egg-info/PKG-INFO
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: writing top-level names to ceilometer.egg-info/top_level.txt
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: writing dependency_links to ceilometer.egg-info/dependency_links.txt
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: writing entry points to ceilometer.egg-info/entry_points.txt
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[pbr] Reusing existing SOURCES.txt'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: installing to build/bdist.linux-x86_64/wheel
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: running install
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: running install_lib
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: creating build/bdist.linux-x86_64/wheel
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: --snip--
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: creating build/bdist.linux-x86_64/wheel/ceilometer-2014.1.a6.g772e1a7
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: .dist-info/WHEEL
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: running upload
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Submitting /home/jd/Source/ceilometer/dist/ceilometer-2014.1.a6
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: .g772e1a7-py27-none-any.whl to https://testpypi.python.org/pypi
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Server response (200): OK'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-8: Uploading a Wheel archive to PyPI*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Once those operations are finished, you and other users can search for the
    uploaded packages on the PyPI staging server, and even install those packages
    using pip, by specifying the test server using the -i option:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: $ pip install -i https://testpypi.python.org/pypi ceilometer
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything checks out, you can upload your project to the main PyPI server.
    Just make sure to add your credentials and the details for the server to your
    ~/.pypirc file first, like so:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[distutils]'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: index-servers =
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: pypi
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: testpypi
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[pypi]'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: username = <your username>
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: password = <your password> [testpypi]
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: repository = https://testpypi.python.org/pypi
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: username = <your username>
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: password = <your password>
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Now if you run register and upload with the -r pypi switch, your package should
    be uploaded to PyPI.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '*PyPI can keep several versions of your software in its index, allowing you
    to install specific and older versions, if you ever need to. Just pass the version
    number to the pip install command; for example, pip install foobar==1.0.2.*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: This process is straightforward to use and allows for any number of uploads.
    You can release your software as often as you want, and your users can install
    and update as often as they need.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '**Entry Points**'
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have already used setuptools entry points without knowing anything about
    them. Software distributed using setuptools includes important metadata describing
    features such as its required dependencies and—more relevantly to this topic—a
    list of *entry points*. Entry points are methods by which other Python programs
    can discover the dynamic features a package provides.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在不知情的情况下使用过 setuptools 入口点。使用 setuptools 分发的软件包括描述其所需依赖项等特性的重要元数据——更与本主题相关的是，包含了一个
    *入口点* 的列表。入口点是其他 Python 程序可以通过它们发现一个包所提供的动态特性的方式。
- en: 'The following example shows how to provide an entry point named rebuildd in
    the console_scripts entry point group:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何在 console_scripts 入口点组中提供一个名为 rebuildd 的入口点：
- en: '#!/usr/bin/python'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '#!/usr/bin/python'
- en: from distutils.core import setup
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: from distutils.core import setup
- en: setup(name="rebuildd",
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: setup(name="rebuildd",
- en: description="Debian packages rebuild tool",
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: description="Debian 包重建工具",
- en: author="Julien Danjou",
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: author="Julien Danjou",
- en: author_email="acid@debian.org",
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: author_email="acid@debian.org",
- en: url="http://julien.danjou.info/software/rebuildd.html",
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: url="http://julien.danjou.info/software/rebuildd.html",
- en: entry_points={
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: entry_points={
- en: '''console_scripts'': ['
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '''console_scripts'': ['
- en: '''rebuildd = rebuildd:main'','
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '''rebuildd = rebuildd:main'','
- en: '],'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: '},'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: packages=['rebuildd'])
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: packages=['rebuildd'])
- en: 'Any Python package can register entry points. Entry points are organized in
    groups: each group is made of a list of key and value pairs. Those pairs use the
    format path.to.module:variable_name. In the previous example, the key is rebuildd,
    and the value is rebuildd:main.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 Python 包都可以注册入口点。入口点按组进行组织：每组由一系列键值对组成。这些键值对采用 path.to.module:variable_name
    的格式。在前面的示例中，键是 rebuildd，值是 rebuildd:main。
- en: The list of entry points can be manipulated using various tools, from setuptools
    to epi, as I’ll show here. In the following sections, we discuss how we can use
    entry points to add extensibility to our software.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 入口点的列表可以使用各种工具进行操作，从 setuptools 到 epi，正如我在这里将展示的那样。在接下来的部分中，我们将讨论如何利用入口点为我们的软件添加扩展性。
- en: '***Visualizing Entry Points***'
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***可视化入口点***'
- en: The easiest way to visualize the entry points available in a package is to use
    a package called entry point inspector. You can install it by running pip install
    entry-point-inspector. When installed, it provides the command epi that you can
    run from your terminal to interactively discover the entry points provided by
    installed packages. [Listing 5-9](ch05.xhtml#ch5list9) shows an example of running
    epi group list on my system.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 查看包中可用入口点的最简单方法是使用名为 entry point inspector 的包。你可以通过运行 `pip install entry-point-inspector`
    来安装它。安装后，它提供了一个名为 epi 的命令，你可以从终端运行该命令，交互式地发现已安装软件包提供的入口点。[列表 5-9](ch05.xhtml#ch5list9)
    展示了我在系统上运行 epi group list 的示例。
- en: $ epi group list
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: $ epi group list
- en: '---------------------------'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '---------------------------'
- en: '| Name                    |'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '| 名称                    |'
- en: '--------------------------'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '--------------------------'
- en: '| console_scripts |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| console_scripts |'
- en: '| distutils.commands |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| distutils.commands |'
- en: '| distutils.setup_keywords |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| distutils.setup_keywords |'
- en: '| egg_info.writers |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| egg_info.writers |'
- en: '| epi.commands |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| epi.commands |'
- en: '| flake8.extension |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| flake8.extension |'
- en: '| setuptools.file_finders |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| setuptools.file_finders |'
- en: '| setuptools.installation |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| setuptools.installation |'
- en: '--------------------------'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '--------------------------'
- en: '*Listing 5-9: Getting a list of entry point groups*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-9：获取入口点组的列表*'
- en: The output from epi group list in [Listing 5-9](ch05.xhtml#ch5list9) shows the
    different packages on a system that provide entry points. Each item in this table
    is the name of an entry point group. Note that this list includes console_scripts,
    which we’ll discuss shortly. We can use the epi command with the show command
    to show details of a particular entry point group, as in [Listing 5-10](ch05.xhtml#ch5list10).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-9](ch05.xhtml#ch5list9) 中来自 epi group list 的输出显示了系统中提供入口点的不同软件包。表格中的每一项是一个入口点组的名称。请注意，此列表包括
    console_scripts，我们稍后会讨论。我们可以使用 epi 命令与 show 命令来显示特定入口点组的详细信息，如[列表 5-10](ch05.xhtml#ch5list10)所示。'
- en: $ epi group show console_scripts
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: $ epi group show console_scripts
- en: '-------------------------------------------------'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '-------------------------------------------------'
- en: '| Name     | Module   | Member | Distribution | Error |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 名称     | 模块   | 成员 | 分发版本 | 错误 |'
- en: '-------------------------------------------------'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '-------------------------------------------------'
- en: '| coverage | coverage | main   | coverage 3.4 |       |'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '| coverage | coverage | main   | coverage 3.4 |       |'
- en: '*Listing 5-10: Showing details of an entry point group*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 5-10：显示入口点组的详细信息*'
- en: We can see that in the group console_scripts, an entry point named coverage
    refers to the member main of the module coverage. This entry point in particular,
    provided by the package coverage 3.4, indicates which Python function to call
    when the command line script coverage is executed. Here, the function coverage.main
    is to be called.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: The epi tool is just a thin layer on top of the complete Python library pkg_resources.
    This module allows us to discover entry points for any Python library or program.
    Entry points are valuable for various things, including console scripts and dynamic
    code discovery, as you’ll see in the next few sections.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Console Scripts***'
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When writing a Python application, you almost always have to provide a launchable
    program—a Python script that the end user can run—that needs to be installed inside
    a directory somewhere in the system path.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'Most projects have a launchable program similar to this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '#!/usr/bin/python'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: import mysoftware
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: mysoftware.SomeClass(sys.argv).run()
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of script is a best-case scenario: many projects have a much longer
    script installed in the system path. However, such scripts pose some major issues:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: There’s no way the user can know where the Python interpreter is or which version
    it uses.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This script leaks binary code that can’t be imported by software or unit tests.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s no easy way to define where to install this script.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s not obvious how to install this in a portable way (for example, on both
    Unix and Windows).
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Helping us circumvent these problems, setuptools offers the console_scripts
    feature. This entry point can be used to make setuptools install a tiny program
    in the system path that calls a specific function in one of your modules. With
    setuptools, you can specify a function call to start your program by setting up
    a key/value pair in the console_scripts entry point group: the key is the script
    name that will be installed, and the value is the Python path to your function
    (something like my_module.main).'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s imagine a foobar program that consists of a client and a server. Each
    part is written in its module—foobar.client and foobar.server, respectively, in
    *foobar/client.py*:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: print("Client started")
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'And in *foobar/server.py*:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: print("Server started")
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this program doesn’t do much of anything—our client and server don’t
    even talk to each other. For our example, though, they just need to print a message
    letting us know they have started successfully.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: We can now write the following *setup.py* file in the root directory with entry
    points defined in *setup.py*.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: from setuptools import setup
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: setup(
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: name="foobar",
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: version="1",
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: description="Foo!",
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: author="Julien Danjou",
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: author_email="julien@danjou.info",
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: packages=["foobar"],
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: entry_points={
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '"console_scripts": ['
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: ➊ "foobard = foobar.server:main",
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '"foobar = foobar.client:main",'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '],'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: We define entry points using the format module.submodule:function. You can see
    here that we’ve defined an entry point each for both client and server ➊.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: When python setup.py install is run, setuptools will create a script that will
    look like the one in [Listing 5-11](ch05.xhtml#ch5list11).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '#!/usr/bin/python'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'EASY-INSTALL-ENTRY-SCRIPT: ''foobar==1'',''console_scripts'',''foobar'''
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: __requires__ = 'foobar==1'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: import sys
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: from pkg_resources import load_entry_point
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: sys.exit(
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: load_entry_point('foobar==1', 'console_scripts', 'foobar')()
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: )
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-11: A console script generated by setuptools*'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: This code scans the entry points of the foobar package and retrieves the foobar
    key from the console_scripts group, which is used to locate and run the corresponding
    function. The return value of the load_entry_point will then be a reference to
    the function foobar.client.main, which will be called without any arguments and
    whose return value will be used as an exit code.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this code uses pkg_resources to discover and load entry point files
    from within your Python programs.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '*If you’re using pbr on top of setuptools, the generated script is simpler
    (and therefore faster) than the default one built by setuptools, as it will call
    the function you wrote in the entry point without having to search the entry point
    list dynamically at runtime.*'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Using console scripts is a technique that removes the burden of writing portable
    scripts, while ensuring that your code stays in your Python package and can be
    imported (and tested) by other programs.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Plugins and Drivers***'
  id: totrans-355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Entry points make it easy to discover and dynamically load code deployed by
    other packages, but this is not their only use. Any application can propose and
    register entry points and groups and then use them as it wishes.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’re going to create a cron-style daemon pycrond that will
    allow any Python program to register a command to be run once every few seconds
    by registering an entry point in the group pytimed. The attribute indicated by
    this entry point should be an object that returns number_of_seconds, callable.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our implementation of pycrond using pkg_resources to discover entry
    points, in a program I’ve named *pytimed.py*:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: import pkg_resources
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: import time
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: seconds_passed = 0
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'for entry_point in pkg_resources.iter_entry_points(''pytimed''):'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: seconds, callable = entry_point.load()()
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'except:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '# Ignore failure'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'if seconds_passed % seconds == 0:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: callable()
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: time.sleep(1)
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: seconds_passed += 1
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: This program consists of an infinite loop that iterates over each entry point
    of the pytimed group. Each entry point is loaded using the load() method. The
    program then calls the returned method, which needs to return the number of seconds
    to wait before calling the callable as well as the aforementioned callable.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'The program in *pytimed.py* is a very simplistic and naive implementation,
    but it is sufficient for our example. Now we can write another Python program,
    named *hello.py*, that needs one of its functions called on a periodic basis:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'def print_hello():'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: print("Hello, world!")
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'def say_hello():'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: return 2, print_hello
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Once we have that function defined, we register it using the appropriate entry
    points in *setup.py*.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: from setuptools import setup
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: setup(
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: name="hello",
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: version="1",
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: packages=["hello"],
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: entry_points={
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '"pytimed": ['
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '"hello = hello:say_hello",'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '],'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '},)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: The *setup.py* script registers an entry point in the group pytimed with the
    key hello and the value pointing to the function hello.say_hello. Once that package
    is installed using that *setup.py*—for example, using pip install—the pytimed
    script can detect the newly added entry point.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'At startup, pytimed will scan the group pytimed and find the key hello. It
    will then call the hello.say_hello function, getting two values: the number of
    seconds to wait between each call and the function to call, 2 seconds and print_hello
    in this case. By running the program, as we do in [Listing 5-12](ch05.xhtml#ch5list12),
    you can see “Hello, world!” printed on the screen every 2 seconds.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '>>> import pytimed'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '>>> pytimed.main()'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Hello, world!
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Hello, world!
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Hello, world!
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-12: Running pytimed*'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'The possibilities this mechanism offers are immense: you can build driver systems,
    hook systems, and extensions easily and generically. Implementing this mechanism
    by hand in every program you make would be tedious, but fortunately, there’s a
    Python library that can take care of the boring parts for us.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'The stevedore library provides support for dynamic plugins based on the same
    mechanism demonstrated in our previous examples. The use case in this example
    is already simplistic, but we can still simplify it further in this script, *pytimed_stevedore.py*:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: from stevedore.extension import ExtensionManager
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: import time
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: seconds_passed = 0
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: extensions = ExtensionManager('pytimed', invoke_on_load=True)
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'for extension in extensions:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'try:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'seconds, callable = extension.obj except:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '# Ignore failure'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'if seconds_passed % seconds == 0:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: callable()
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: time.sleep(1)
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: seconds_passed += 1
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: The ExtensionManager class of stevedore provides a simple way to load all extensions
    of an entry point group. The name is passed as a first argument. The argument
    invoke_on_load=True makes sure that each function of the group is called once
    discovered. This makes the results accessible directly from the obj attribute
    of the extension.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: If you look through the stevedore documentation, you will see that ExtensionManager
    has a variety of subclasses that can handle different situations, such as loading
    specific extensions based on their names or the result of a function. All of those
    are commonly used models you can apply to your program in order to implement those
    patterns directly.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: For example, we might want to load and run only one extension from our entry
    point group. Leveraging the stevedore.driver.DriverManager class allows us to
    do that, as [Listing 5-13](ch05.xhtml#ch5list13) shows.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: from stevedore.driver import DriverManager
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: import time
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: 'def main(name):'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: seconds_passed = 0
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: seconds, callable = DriverManager('pytimed', name, invoke_on_load=True).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: driver
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'while True:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: 'if seconds_passed % seconds == 0:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: callable()
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: time.sleep(1)
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: seconds_passed += 1
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: main("hello")
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 5-13: Using stevedore to run a single extension from an entry point*'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: In this case, only one extension is loaded and selected by name. This allows
    us to quickly build a *driver system* in which only one extension is loaded and
    used by a program.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The packaging ecosystem in Python has a bumpy history; however, the situation
    is now settling. The setuptools library provides a complete solution to packaging,
    not only to transport your code in different formats and upload it to PyPI, but
    also to handle connection with other software and libraries via entry points.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '**Nick Coghlan on Packaging**'
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Nick is a Python core developer working at Red Hat. He has written several PEP
    proposals, including PEP 426 (Metadata for Python Software Packages 2.0), and
    he is acting as delegate for our Benevolent Dictator for Life, Guido van Rossum,
    author of Python.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '**The number of packaging solutions (distutils, setuptools, distutils2, distlib,
    bento, pbr, and so on) for Python is quite extensive. In your opinion, what are
    the reasons for such fragmentation and divergence?**'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: The short answer is that software publication, distribution, and integration
    is a complex problem with plenty of room for multiple solutions tailored for different
    use cases. In my recent talks on this, I have noted that the problem is mainly
    one of age, with the different packaging tools being born into different eras
    of software distribution.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '**PEP 426, which defines a new metadata format for Python packages, is still
    fairly recent and not yet approved. How do you think it will tackle current packaging
    problems?**'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: PEP 426 originally started as part of the Wheel format definition, but Daniel
    Holth realized that Wheel could work with the existing metadata format defined
    by setuptools. PEP 426 is thus a consolidation of the existing setuptools metadata
    with some of the ideas from distutils2 and other packaging systems (such as RPM
    and npm). It addresses some of the frustrations encountered with existing tools
    (for example, with cleanly separating different kinds of dependencies).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: The main gains will be a REST API on PyPI offering full metadata access, as
    well as (hopefully) the ability to automatically generate distribution policy–compliant
    packages from upstream metadata.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '**The Wheel format is somewhat recent and not widely used yet, but it seems
    promising. Why is it not part of the Standard Library?**'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out the Standard Library is not really a suitable place for packaging
    standards: it evolves too slowly, and an addition to a later version of the Standard
    Library cannot be used with earlier versions of Python. So, at the Python language
    summit earlier this year, we tweaked the PEP process to allow distutils-sig to
    manage the full approval cycle for packaging-related PEPs, and python-dev will
    only be involved for proposals that involve changing CPython directly (such as
    pip bootstrapping).'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '**What is the future for **Wheel** packages?**'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: We still have some tweaks to make before Wheel is suitable for use on Linux.
    However, pip is adopting Wheel as an alternative to the Egg format, allowing local
    caching of builds for fast virtual environment creation, and PyPI allows uploads
    of Wheel archives for Windows and macOS.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
