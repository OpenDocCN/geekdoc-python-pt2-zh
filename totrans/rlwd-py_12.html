<html><head></head><body>
<h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_268"/><span epub:type="pagebreak" id="page_269"/><span class="big">12</span><br/>ARE WE LIVING IN A COMPUTER SIMULATION?</h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindent">In 2003, the philosopher Nick Bostrom postulated that we live in a computer simulation run by our advanced, possibly post-human, descendants. Today, many scientists and big thinkers, including Neil DeGrasse Tyson and Elon Musk, believe there’s a good chance this <em>simulation hypothesis</em> is true. It certainly explains why mathematics so elegantly describes nature, why observers seem to influence quantum events, and why we appear to be alone in the universe.</p>&#13;
<p class="indent">Even stranger, <em>you</em> could be the only real thing in this simulation. Perhaps you’re a brain in a vat, immersing yourself in a historical simulation. For computational efficiency, the simulation might render only those things with which you currently interact. When you go inside and close your door, the world outside might turn off like a refrigerator light. How would you really know one way or the other?</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_270"/>Scientists take this hypothesis seriously, holding debates and publishing papers on how we might devise some test to prove it. In this chapter, you’ll attempt to answer the question using an approach proposed by physicists: you’ll build a simple simulated world and then analyze it for clues that might give the simulation away. In doing so, you’ll work through this project backward, writing the code before coming up with the problem-solving strategy. You’ll find that even the simplest model can provide profound insights on the nature of our existence.</p>&#13;
<h3 class="h3ab" id="ch00lev1sec92"><strong>Project #16: Life, the Universe, and Yertle’s Pond</strong></h3>&#13;
<p class="noindent">The ability to simulate reality isn’t just a far-off dream. Physicists have used the world’s most powerful supercomputers to accomplish this feat, simulating subatomic particle behavior at a scale of a few femtometers (10<sup>-15</sup> m). Although the simulation represents only a tiny piece of the cosmos, it’s indistinguishable from what we understand to be reality.</p>&#13;
<p class="indent">But don’t worry, you won’t need a supercomputer or a degree in physics to solve this problem. All you need is the <span class="literal">turtle</span> module, a drawing program designed for kids. You used <span class="literal">turtle</span> to simulate the Apollo 8 mission in <a href="ch06.xhtml">Chapter 6</a>. Here, you’ll use it to understand one of the foundational features of computer models. You’ll then apply that knowledge to devise the same basic strategy that physicists plan to apply to the simulation hypothesis.</p>&#13;
<div class="sidebar96">&#13;
<p class="Problem-Head">THE OBJECTIVE</p>&#13;
<p class="Body-Problem">Identify a feature of a computer simulation that might be detectable by those being simulated.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev2sec64"><strong><em>The Pond Simulation Code</em></strong></h4>&#13;
<p class="noindent">The <em>pond_sim.py</em> code creates a <span class="literal">turtle</span>-based simulation of a pond that includes a mud island, a floating log, and a snapping turtle named Yertle. Yertle will swim out to the log, swim back, and then swim out again. You can download the code from the book’s website at <em><a href="https://nostarch.com/real-world-python/">https://nostarch.com/real-world-python/</a></em>.</p>&#13;
<p class="indent">The <span class="literal">turtle</span> module ships with Python, so you don’t have to install anything. For an overview of the module, see “Using the turtle Module” on <a href="ch06.xhtml#page_127">page 127</a>.</p>&#13;
<h5 class="h5"><strong>Importing turtle, Setting Up the Screen, and Drawing the Island</strong></h5>&#13;
<p class="noindent"><a href="ch12.xhtml#ch012list1">Listing 12-1</a> imports <span class="literal">turtle</span>, sets up a <span class="literal">screen</span> object to use as a pond, and draws a mud island for Yertle to survey his domain.</p>&#13;
<pre><span class="codeitalic1">pond_sim.py</span>, part 1&#13;
import turtle&#13;
&#13;
pond = turtle.Screen()&#13;
pond.setup(600, 400)&#13;
<span epub:type="pagebreak" id="page_271"/>pond.bgcolor('light blue')&#13;
pond.title("Yertle's Pond")&#13;
&#13;
mud = turtle.Turtle('circle')&#13;
mud.shapesize(stretch_wid=5, stretch_len=5, outline=None)&#13;
mud.pencolor('tan')&#13;
mud.fillcolor('tan')</pre>&#13;
<p class="listing"><a id="ch012list1"/>Listing 12-1: Importing the <span class="codeitalic">turtle</span> module and drawing a pond and mud island</p>&#13;
<p class="indent">After importing the <span class="literal">turtle</span> module, assign a <span class="literal">screen</span> object to a variable named <span class="literal">pond</span>. Use the <span class="literal">turtle</span> <span class="literal">setup()</span> method to set the screen size, in pixels, and then color the background light blue. You can find tables of <span class="literal">turtle</span> colors and their names on multiple sites, such as <em><a href="https://trinket.io/docs/colors">https://trinket.io/docs/colors</a></em>. Finish the pond by providing a title for the screen.</p>&#13;
<p class="indent">Next, make a circular mud island for Yertle to sunbathe on. Use the <span class="literal">Turtle()</span> class to instantiate a <span class="literal">turtle</span> object named <span class="literal">mud</span>. Although <span class="literal">turtle</span> comes with a method for drawing circles, it’s easier here to just pass the constructor the <span class="literal">'circle'</span> argument, which produces a circular <span class="literal">turtle</span> object. This circle shape is too small to make much of an island, however, so use the <span class="literal">shapesize()</span> method to stretch it out. Finish the island by setting its outline and fill colors to tan.</p>&#13;
<h5 class="h5"><strong>Drawing the Log, a Knothole, and Yertle</strong></h5>&#13;
<p class="noindent"><a href="ch12.xhtml#ch012list2">Listing 12-2</a> completes the program by drawing the log, complete with knothole and Yertle the turtle. It then moves Yertle so that he can leave his island to check out the log.</p>&#13;
<pre><span class="codeitalic1">pond_sim.py</span>, part 2&#13;
   SIDE = 80&#13;
   ANGLE = 90&#13;
   log = turtle.Turtle()&#13;
   log.hideturtle()&#13;
   log.pencolor('peru')&#13;
   log.fillcolor('peru')&#13;
   log.speed(0)&#13;
<span class="ent">➊</span> log.penup()&#13;
   log.setpos(215, -30)&#13;
   log.lt(45)&#13;
   log.begin_fill()&#13;
<span class="ent">➋</span> for _ in range(2):&#13;
       log.fd(SIDE)&#13;
       log.lt(ANGLE)&#13;
       log.fd(SIDE / 4)&#13;
       log.lt(ANGLE)&#13;
   log.end_fill()&#13;
   &#13;
   knot = turtle.Turtle()&#13;
   knot.hideturtle()&#13;
   knot.speed(0)&#13;
   knot.penup()&#13;
   knot.setpos(245, 5)&#13;
   knot.begin_fill()&#13;
   <span epub:type="pagebreak" id="page_272"/>knot.circle(5)&#13;
   knot.end_fill()&#13;
   &#13;
   yertle = turtle.Turtle('turtle')&#13;
   yertle.color('green')&#13;
   yertle.speed(1)  # Slowest.&#13;
   yertle.fd(200)&#13;
   yertle.lt(180)&#13;
   yertle.fd(200)&#13;
<span class="ent">➌</span> yertle.rt(176)&#13;
   yertle.fd(200)</pre>&#13;
<p class="listing"><a id="ch012list2"/>Listing 12-2: Drawing a log and a turtle and then moving the turtle around</p>&#13;
<p class="indent">You’ll draw a rectangle to represent the log, so start by assigning two constants, <span class="literal">SIDE</span> and <span class="literal">ANGLE</span>. The first represents the length of the log, in pixels; the second is the angle, in degrees, by which you’ll turn the turtle at each corner of the rectangle.</p>&#13;
<p class="indent">By default, all turtles initially appear at the center of the screen, at coordinates (0, 0). Since you’ll place your log off to the side, after you instantiate the <span class="literal">log</span> object, use the <span class="literal">hideturtle()</span> method to make it invisible. This way, you don’t have to watch it fly across the screen to get to its final position.</p>&#13;
<p class="indent">Color the log brown, using <span class="literal">peru</span> for the log color. Then set the object’s <span class="literal">speed</span> to the fastest setting (oddly, <span class="literal">0</span>). This way, you won’t have to watch it slowly draw on the screen. And so you don’t see the path it takes from the screen’s center to its edge, pick up the drawing pen using the <span class="literal">penup()</span> method <span class="ent">➊</span>.</p>&#13;
<p class="indent">Use the <span class="literal">setpos()</span> method—for <em>set position</em>—to place the log near the right edge of the screen. Then turn the object left by 45 degrees and call the <span class="literal">begin_fill()</span> method.</p>&#13;
<p class="indent">You can save a few lines of code by drawing the rectangle using a <span class="literal">for</span> loop <span class="ent">➋</span>. You’ll loop twice, drawing two sides of the rectangle with each loop. Make the log’s width 20 pixels by dividing <span class="literal">SIDE</span> by <span class="literal">4</span>. After the loop, call <span class="literal">end_fill()</span> to color the log brown.</p>&#13;
<p class="indent">Give the log some character by adding a knothole, represented by a <span class="literal">knot</span> turtle. To draw the knothole, call the <span class="literal">circle()</span> method and pass it <span class="literal">5</span>, for a radius of five pixels. Note that you don’t need to specify a fill color as black is the default.</p>&#13;
<p class="indent">Finally, end the program by drawing Yertle, the king of all he surveys. Yertle is an old turtle, so set his drawing speed to the slowest setting of <span class="literal">1</span>. Have him swim out and inspect the log and then turn around and swim back. Yertle is a touch senile, and he forgets what he just did. So, have him swim back out—only this time, angle his course so that he’s no longer swimming due east <span class="ent">➌</span>. Run the program, and you should get the results shown in <a href="ch12.xhtml#ch012fig1">Figure 12-1</a>.</p>&#13;
<p class="indent">Look carefully at this figure. Despite the simplicity of the simulation, it contains powerful insights into whether we, like Yertle, dwell in a computer simulation.</p>&#13;
<div class="image"><img src="../images/fig12_01.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch012fig1"/>Figure 12-1: Screenshot of completed simulation</p>&#13;
<h4 class="h4" id="ch00lev2sec65"><strong><em>Implications of the Pond Simulation</em></strong></h4>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_273"/>Because of finite computational resources, all computer simulations require a framework of some type on which to “hang” their model of reality. Whether it’s called a grid, a lattice, a mesh, a matrix, or whatever, it provides a way to both distribute objects in 2D or 3D space and assign them a property, such as mass, temperature, color, or something else.</p>&#13;
<p class="indent">The <span class="literal">turtle</span> module uses the pixels in your monitor as its coordinate system, as well as to store properties. The pixel locations define the shapes, such as the log’s outline, and the pixel color property helps differentiate one shape from another.</p>&#13;
<p class="indent">Pixels form an <em>orthogonal</em> pattern, which means the rows and columns of pixels intersect at right angles. Although individual pixels are square and too small to easily see, you can use the <span class="literal">turtle</span> module’s <span class="literal">dot()</span> method to generate a facsimile, as in the following snippet:</p>&#13;
<pre>&gt;&gt;&gt; <span class="codestrong1">import turtle</span>&#13;
&gt;&gt;&gt; &#13;
&gt;&gt;&gt; <span class="codestrong1">t = turtle.Turtle()</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">t.hideturtle()</span>&#13;
&gt;&gt;&gt; <span class="codestrong1">t.penup()</span>&#13;
&gt;&gt;&gt; &#13;
&gt;&gt;&gt; <span class="codestrong1">def dotfunc(x, y):</span>&#13;
       <span class="codestrong1">t.setpos(x, y)</span>&#13;
       <span class="codestrong1">for _ in range(10):</span>&#13;
              <span class="codestrong1">t.dot()</span>&#13;
              <span class="codestrong1">t.fd(10)</span>&#13;
&#13;
&gt;&gt;&gt; <span class="codestrong1">for i in range(0, 100, 10):</span>&#13;
       <span class="codestrong1">dotfunc(0, -i)</span></pre>&#13;
<p class="indent">This produces the pattern in <a href="ch12.xhtml#ch012fig2">Figure 12-2</a>.</p>&#13;
<div class="image"><img src="../images/fig12_02.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch012fig2"/>Figure 12-2: Orthogonal grid of black dots representing the centers of square pixels</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_274"/>In the <span class="literal">turtle</span> world, pixels are true atoms: indivisible. A line can’t be shorter than one pixel. Movement can occur only as integers of pixels (though you can input float values without raising an error). The smallest object possible is one pixel in size.</p>&#13;
<p class="indent">An implication of this is that the simulation’s grid determines the smallest feature you can observe. Since we can observe incredibly small subatomic particles, our grid, assuming we’re a simulation, must be incredibly fine. This leads many scientists to seriously doubt the simulation conjecture, since it would require a staggering amount of computer memory. Still, who knows what our distant descendants, or aliens, are capable of?</p>&#13;
<p class="indent">Besides setting a limit on the size of objects, a simulation grid might force a preferred orientation, or <em>anisotropy</em>, on the fabric of the cosmos. Anisotropy is the directional dependence of a material, such as the way wood splits more easily along its grain rather than across it. If you look closely at Yertle’s paths in the turtle simulation (<a href="ch12.xhtml#ch012fig3">Figure 12-3</a>), you can see evidence of anisotropy. His upper, slightly angled path zigzags, while the lower, east-west path is perfectly straight.</p>&#13;
<div class="image"><img src="../images/fig12_03.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch012fig3"/>Figure 12-3: The angled versus straight path</p>&#13;
<p class="indent">Drawing a nonorthogonal line on an orthogonal grid isn’t pretty. But there’s more involved than just aesthetics. Moving along the <em>x</em> or <em>y</em> direction requires only integer addition or subtraction (<a href="ch12.xhtml#ch012fig4">Figure 12-4</a>, left). Moving at an angle requires trigonometry to calculate the partial movement in the <em>x</em> and <em>y</em> directions (<a href="ch12.xhtml#ch012fig4">Figure 12-4</a>, right).</p>&#13;
<p class="indent">For a computer, mathematical calculations equal work, so we can surmise that moving at an angle takes more energy. By timing the two calculations in <a href="ch12.xhtml#ch012fig4">Figure 12-4</a>, we can get a relative measure of this difference in energy.</p>&#13;
<div class="image"><img src="../images/fig12_04.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch012fig4"/>Figure 12-4: Movement <span class="normal">along</span> rows or columns (left) requires simpler arithmetic than moving <span class="normal">across</span> them (right)</p>&#13;
<h4 class="h4" id="ch00lev2sec66"><strong><em>Measuring the Cost of Crossing the Lattice</em></strong></h4>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_275"/>To time the difference between drawing a line diagonally across a pixel grid and drawing the line along it, you need to draw two lines of equal length. But remember, <span class="literal">turtle</span> works only with integers. You need to find an angle for which all sides of a triangle—the opposite, adjacent, and hypotenuse in <a href="ch12.xhtml#ch012fig4">Figure 12-4</a>—are integers. This way, you’ll know that your angled line is the same length as your straight line.</p>&#13;
<p class="indent">To find these angles, you can use a <em>Pythagorean triple</em>, a set of positive integers <em>a</em>, <em>b</em>, and <em>c</em> that fit the right triangle rule <em>a</em><sup>2</sup> + <em>b</em><sup>2</sup> = <em>c</em><sup>2</sup>. The best-known triple is 3-4-5, but you’ll want a longer line, to ensure that the runtime of the drawing function isn’t less than the measurement precision of your computer’s clock. Fortunately, you can find other, larger triples online. The triplet 62-960-962 is a good choice, as it’s long but will still fit in a <span class="literal">turtle</span> screen.</p>&#13;
<h5 class="h5"><strong>The Line Comparison Code</strong></h5>&#13;
<p class="noindent">To compare the cost of drawing a diagonal line to the cost of drawing a straight one, <a href="ch12.xhtml#ch012list3">Listing 12-3</a> uses <span class="literal">turtle</span> to draw the two lines. The first line is parallel to the <em>x</em>-axis (that is, east-west), and the second line is at a shallow angle to the <em>x</em>-axis. You can figure out the correct degree of the angle using trigonometry; in this case, it’s 3.695220532 degrees. The listing draws these lines many times using a <span class="literal">for</span> loop and records the time it takes to draw each one using the built-in <span class="literal">time</span> module. The final comparison uses the averages of these runs.</p>&#13;
<p class="indent">You need to use averages because your central processing unit (CPU) is constantly running multiple processes. The operating system schedules these processes behind the scenes, executing one while delaying another until a resource, such as input/output, becomes available. Consequently, it’s difficult to record the <em>absolute</em> runtime of a given function. Calculating the average time of many runs compensates for this.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_276"/>You can download the code, <em>line_compare.py</em>, from the book’s website.</p>&#13;
<pre><span class="codeitalic1">line_compare.py</span>&#13;
from time import perf_counter&#13;
import statistics&#13;
import turtle&#13;
&#13;
turtle.setup(1200, 600)&#13;
screen = turtle.Screen()&#13;
&#13;
ANGLES = (0, 3.695220532)  # In degrees.&#13;
NUM_RUNS = 20&#13;
SPEED = 0&#13;
for angle in ANGLES:&#13;
 <span class="ent">➊</span> times = []&#13;
    for _ in range(NUM_RUNS):&#13;
        line = turtle.Turtle()&#13;
        line.speed(SPEED)  &#13;
        line.hideturtle()&#13;
        line.penup()&#13;
        line.lt(angle)&#13;
        line.setpos(-470, 0)&#13;
        line.pendown()&#13;
        line.showturtle()&#13;
     <span class="ent">➋</span> start_time = perf_counter()&#13;
        line.fd(962)&#13;
        end_time = perf_counter()&#13;
        times.append(end_time - start_time)&#13;
        &#13;
    line_ave = statistics.mean(times)&#13;
    print("Angle {} degrees: average time for {} runs at speed {} = {:.5f}"&#13;
          .format(angle, NUM_RUNS, SPEED, line_ave))</pre>&#13;
<p class="listing"><a id="ch012list3"/>Listing 12-3: Drawing a straight line and an angled line and recording the runtimes for each</p>&#13;
<p class="indent">Start by importing <span class="literal">perf_counter</span>—short for <em>performance counter</em>—from the <span class="literal">time</span> module. This function returns the float value of time in seconds. It gives you a more precise answer than <span class="literal">time.clock()</span>, which it replaces as of Python 3.8.</p>&#13;
<p class="indent">Next, import the <span class="literal">statistics</span> module to help you calculate the average of many simulation runs. Then import <span class="literal">turtle</span> and set up the <span class="literal">turtle</span> <span class="literal">screen</span>. You can customize the screen for your monitor, but remember, you need to be able to see a line 962 pixels long.</p>&#13;
<p class="indent">Now, assign some key values for the simulation. Put the angles for a straight line and a diagonal line in a tuple named <span class="literal">ANGLES</span> and then assign a variable to hold the number of times to run the <span class="literal">for</span> loop and the speed at which to draw the line.</p>&#13;
<p class="indent">Start looping through the angles in the <span class="literal">ANGLES</span> tuple. Create an empty list to hold the time measurements <span class="ent">➊</span> before setting up a <span class="literal">turtle</span> object, as you’ve done before. Rotate the <span class="literal">turtle</span> object left by the <span class="literal">angle</span> amount and then use <span class="literal">setpos()</span> to move it to the far-left side of the screen.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_277"/>Move the turtle forward by 962 pixels, sandwiching this command between calls to <span class="literal">perf_counter()</span> to time the movement <span class="ent">➋</span>. Subtract the end time from the start time and append the result to the <span class="literal">times</span> list.</p>&#13;
<p class="indent">Finish by using the <span class="literal">statistics.mean()</span> function to find the average runtime for each line. Print the results to five decimal places. After the program runs, the <span class="literal">turtle</span> screen should look like <a href="ch12.xhtml#ch012fig5">Figure 12-5</a>.</p>&#13;
<div class="image"><img src="../images/fig12_05.jpg" alt="Image"/></div>&#13;
<p class="figcap"><a id="ch012fig5"/>Figure 12-5: Completed <span class="codeitalic">turtle</span> screen for <span class="normal">line_compare.py</span></p>&#13;
<p class="indent">Because you used a Pythagorean triple, the angled line truly ends on a pixel. It doesn’t just snap to the nearest pixel. Consequently, you can be confident that the straight and angled lines have the same length and that you’re comparing apples to apples when it comes to the timing measurements.</p>&#13;
<h4 class="h4" id="ch00lev2sec67"><strong><em>Results</em></strong></h4>&#13;
<p class="noindent">If you draw each line 500 times and then compare the results, you should see that it takes roughly 2.4 times as long to draw the angled line as the straight line.</p>&#13;
<pre>Angle 0 degrees: average time for 500 runs at speed 0 = 0.06492&#13;
Angle 3.695220532 degrees: average time for 500 runs at speed 0 = 0.15691</pre>&#13;
<p class="indent">Your times will likely differ slightly, as they’re affected by other programs you may have running concurrently on your computer. As noted previously, CPU scheduling will manage all these processes so that your system is fast, efficient, and fair.</p>&#13;
<p class="indent">If you repeat the exercise for 1,000 runs, you should get similar results. (If you decide to do so, you’ll want to get yourself a cup of coffee and some of that good pie.) The angled line will take about 2.7 times as long to draw.</p>&#13;
<pre>Angle 0 degrees: average time for 1000 runs at speed 0 = 0.10911&#13;
Angle 3.695220532 degrees: average time for 1000 runs at speed 0 = 0.29681</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_278"/>You’ve been running a short function at a high drawing speed. If you’re worried that <span class="literal">turtle</span> performs optimizations to achieve speed at the expense of accuracy, you can slow it down and rerun the program. With the drawing speed set to normal (<span class="literal">speed = 6</span>), the angled line takes about 2.6 times as long to draw, close to the outcome with the fastest speed.</p>&#13;
<pre>Angle 0 degrees: average time for 500 runs at speed 6 = 1.12522&#13;
Angle 3.695220532 degrees: average time for 500 runs at speed 6 = 2.90180</pre>&#13;
<p class="indent">Clearly, moving across the pixel grid requires more work than moving along it.</p>&#13;
<h4 class="h4" id="ch00lev2sec68"><strong><em>The Strategy</em></strong></h4>&#13;
<p class="noindent">The goal of this project was to identify a way for simulated beings, perhaps us, to find evidence of the simulation. At this point, we know at least two things. First, if we’re living in a simulation, the grid is extremely small, as we can observe subatomic particles. Second, if these small particles cross the simulation’s grid at an angle, we should expect to find computational resistance that translates into something measurable. This resistance might look like a loss of energy, a scattering of particles, a reduction in velocity, or something similar.</p>&#13;
<p class="indent">In 2012, physicists Silas R. Beane, from the University of Bonn, and Zohreh Davoudi and Martin J. Savage, from the University of Washington, published a paper arguing exactly this point. According to the authors, if the laws of physics, which appear continuous, are superimposed on a discrete grid, the grid spacing might impose a limitation on physical processes.</p>&#13;
<p class="indent">They proposed investigating this by observing <em>ultra-high energy cosmic rays (UHECRs)</em>. UHECRs are the fastest particles in the universe, and they are affected by increasingly smaller features as they get more energetic. But there’s a limit to how much energy these particles can have. Known as the GZK cutoff and confirmed by experiments in 2007, this limit is consistent with the kind of boundary a simulation grid might cause. Such a boundary should also cause UHECRs to travel preferentially along the grid’s axes and scatter particles that try to cross it.</p>&#13;
<p class="indent">Not surprisingly, there are many potential obstacles to this approach. UHECRs are rare, and anomalous behavior might not be obvious. If the spacing of the grid is significantly smaller than 10<sup>-12</sup> femtometers, we probably can’t detect it. There may not even <em>be</em> a grid, at least as we understand it, as the technology in use may far exceed our own. And, as the philosopher Preston Greene pointed out in 2019, there may be a moral obstacle to the entire project. If we live in a simulation, our discovery of it may trigger its end!</p>&#13;
<h3 class="h3" id="ch00lev1sec93"><strong>Summary</strong></h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_279"/>From a coding standpoint, building Yertle’s simulated world was simple. But a big part of coding is solving problems, and the small amount of work you did had major implications. No, we didn’t make the leap to cosmic rays, but we started the right conversation. The basic premise that a computer simulation requires a grid that could imprint observable signatures on the universe is an idea that transcends nitty-gritty details.</p>&#13;
<p class="indent">In the book <em>Harry Potter and the Deathly Hallows</em>, Harry asks the wizard Dumbledore, “Tell me one last thing. Is this real? Or has this been happening inside my head?” Dumbledore replies, “Of course it is happening inside your head, Harry, but why on Earth should that mean that it is not real?”</p>&#13;
<p class="indent">Even if our world isn’t located at the “fundamental level of reality,” as Nick Bostrom postulates, you can still take pleasure in your ability to solve problems such as this. As Descartes might’ve said, had he lived today, “I code, therefore I am.” Onward!</p>&#13;
<h3 class="h3" id="ch00lev1sec94"><strong>Further Reading</strong></h3>&#13;
<p class="noindent">“Are We Living in a Simulated Universe? Here’s What Scientists Say” (NBC News, 2019), by Dan Falk, provides an overview of the simulation hypothesis.</p>&#13;
<p class="indent">“Neil deGrasse Tyson Says ‘It’s Very Likely’ the Universe Is a Simulation” (ExtremeTech, 2016), by Graham Templeton, is an article with an embedded video of the Isaac Asimov Memorial Debate, hosted by astrophysicist Neil deGrasse Tyson, that addresses the possibility that we’re living in a simulation.</p>&#13;
<p class="indent">“Are We Living in a Computer Simulation? Let’s Not Find Out” (<em>New York Times</em>, 2019), by Preston Greene, presents a philosophical argument against investigating the simulation hypothesis.</p>&#13;
<p class="indent">“We Are Not Living in a Simulation. Probably.” (Fast Company, 2018), by Glenn McDonald, argues that the universe is too big and too detailed to be simulated computationally.</p>&#13;
<h3 class="h3" id="ch00lev1sec95"><strong>Moving On</strong></h3>&#13;
<p class="noindent">There’s never enough time in life to do all the things we want, and that goes double for writing a book. The challenge projects that follow represent the ghosts of chapters not yet written. There was no time to finish these (or in some cases, even start them), but you might have better luck. As always, the book provides no solutions for challenge projects—not that you’ll need them.</p>&#13;
<p class="indent">This is the real world, baby, and you’re ready for it.</p>&#13;
<h3 class="h3" id="ch00lev1sec96"><strong>Challenge Project: Finding a Safe Space</strong></h3>&#13;
<p class="noindent">The award-winning 1970 novel <em>Ringworld</em> introduced the world to the Pierson’s puppeteer, a sentient and highly advanced alien herbivore. Being herd animals, puppeteers were extremely cowardly and cautious. When <span epub:type="pagebreak" id="page_280"/>they realized that the core of the Milky Way had exploded and the radiation would reach them in 20,000 years, they started fleeing the galaxy immediately!</p>&#13;
<p class="indent">In this project, you’re part of a 29th-century diplomatic team assigned to the puppeteer ambassador. Your job is to select a state, within the conterminous United States, that they’ll find suitably safe for the puppeteer embassy. You’ll need to screen each state for natural hazards, such as earthquakes, volcanoes, tornadoes, and hurricanes, and present the ambassador with a map summarizing the results. Don’t worry that the data you’ll use is hundreds of years out-of-date; just pretend it’s current to the year 2850 CE.</p>&#13;
<p class="indent">You can find earthquake data at <em><a href="https://earthquake.usgs.gov/earthquakes/feed/v1.0/csv.php/">https://earthquake.usgs.gov/earthquakes/feed/v1.0/csv.php/</a></em>. Use dots to plot the epicenters of those quakes that are 6.0 or greater in magnitude.</p>&#13;
<p class="indent">You can post the tornado data as the average number per year per state (see <em><a href="https://www.ncdc.noaa.gov/climate-information/extreme-events/us-tornado-climatology">https://www.ncdc.noaa.gov/climate-information/extreme-events/us-tornado-climatology</a></em>). Use a choropleth format like you did in <a href="ch11.xhtml">Chapter 11</a>.</p>&#13;
<p class="indent">You can find a listing of dangerous volcanoes in Table 2 of the 2018 Update to the U.S. Geological Survey National Volcanic Threat Assessment (<em><a href="https://pubs.usgs.gov/sir/2018/5140/sir20185140.pdf">https://pubs.usgs.gov/sir/2018/5140/sir20185140.pdf</a></em>). Represent these as dots on the map, but assign them a different color or shape than the earthquake data. Also, ignore the ashfall from Yellowstone. Assume the experts monitoring this supervolcano can predict an eruption soon enough for the ambassador to safely flee the planet.</p>&#13;
<p class="indent">To find hurricane tracks, visit the National Oceanic and Atmospheric Administration site (<em><a href="https://coast.noaa.gov/digitalcoast/data/">https://coast.noaa.gov/digitalcoast/data/</a></em>) and search for “Historical Hurricane Tracks.” Download and post the Category 4 and higher storm segments on the map.</p>&#13;
<p class="indent">Try to think like a puppeteer and use the final composite map to choose a candidate state for the embassy. You might have to ignore a tornado or two. America is a dangerous place!</p>&#13;
<h3 class="h3" id="ch00lev1sec97"><strong>Challenge Project: Here Comes the Sun</strong></h3>&#13;
<p class="noindent">In 2018, 13-year-old Georgia Hutchinson from Woodside, California, won $25,000 at the Broadcom Masters nationwide science, technology, engineering, and mathematics (STEM) competition for middle-school students. Her entry, “Designing a Data-Driven Dual-Axis Solar Tracker,” will make solar panels cheaper and more efficient by eliminating the need for costly light sensors.</p>&#13;
<p class="indent">This new sun tracker is based on the premise that we already know the location of the sun at any moment from any given point on Earth. It uses public data from the National Oceanic and Atmospheric Administration to continuously determine the sun’s position and tilt the solar panels for maximum power production.</p>&#13;
<p class="indent">Write a Python program that calculates the sun’s position based on a location of your choosing. To get started, check out the Wikipedia page “Position of the Sun” (<em><a href="https://en.wikipedia.org/wiki/Position_of_the_Sun">https://en.wikipedia.org/wiki/Position_of_the_Sun</a></em>).</p>&#13;
<h3 class="h3" id="ch00lev1sec98"><strong>Challenge Project: Seeing Through a Dog’s Eyes</strong></h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_281"/>Use your knowledge of computer vision to write a Python program that takes an image and simulates what a dog would see. To get started, check out <em><a href="https://www.akc.org/expert-advice/health/are-dogs-color-blind/">https://www.akc.org/expert-advice/health/are-dogs-color-blind/</a></em> and <em><a href="https://dog-vision.andraspeter.com/">https://dog-vision.andraspeter.com/</a></em>.</p>&#13;
<h3 class="h3" id="ch00lev1sec99"><strong>Challenge Project: Customized Word Search</strong></h3>&#13;
<p class="noindent">Boy, does your Granny love doing word searches! For her birthday, use Python to design and print her customized word searches using family names, vintage TV shows like <em>Matlock</em> and <em>Columbo</em>, or the common names of her prescription drugs. Allow the words to print horizontally, vertically, and diagonally.</p>&#13;
<h3 class="h3" id="ch00lev1sec100"><strong>Challenge Project: Simplifying a Celebration Slideshow</strong></h3>&#13;
<p class="noindent">Your spouse, sibling, parent, best friend, or whoever is having a celebration dinner, and you’re in charge of the slideshow. You have tons of pictures in the cloud, many featuring the honoree, but the filenames just list the date and time at which they were taken, providing no clue as to the contents. It looks like you’ll spend your Saturday sifting through them all.</p>&#13;
<p class="indent">But wait, didn’t you learn about face recognition in that book <em>Real-WorldPython</em>? All you really need to do is find a few training images and do a bit of coding.</p>&#13;
<p class="indent">First, pick someone in your personal digital photo collection to represent the guest of honor. Next, write a Python program that searches through your folders, finds photos containing this person, and copies the photos into a special folder for your review. When training, be sure to include face profiles as well as frontal views, and include a profile Haar cascade when detecting faces.</p>&#13;
<h3 class="h3" id="ch00lev1sec101"><strong>Challenge Project: What a Tangled Web We Weave</strong></h3>&#13;
<p class="noindent">Use Python and the <span class="literal">turtle</span> module to simulate a spider building a web. For some guidance on web construction, see <em><a href="https://www.brisbaneinsects.com/brisbane_weavers/index.htm">https://www.brisbaneinsects.com/brisbane_weavers/index.htm</a></em> and <em><a href="http://recursiveprocess.com/mathprojects/index.php/2015/06/09/spider-webs-creepy-or-cool/">http://recursiveprocess.com/mathprojects/index.php/2015/06/09/spider-webs-creepy-or-cool/</a></em>.</p>&#13;
<h3 class="h3" id="ch00lev1sec102"><strong>Challenge Project: Go Tell It on the Mountain</strong></h3>&#13;
<p class="noindent">“What’s the closest mountain to Houston, Texas?” This seemingly straightforward question, asked on Quora, isn’t easy to answer. For one thing, you need to consider mountains in Mexico, as well as those in the United States. For another, there’s no universally accepted definition of a mountain.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_282"/>To make this somewhat easier, use one of the UN Environmental Program’s definitions of <em>mountainous terrain</em>. Find prominences with an elevation of at least 2,500 m (8,200 feet) and consider them mountains. Calculate their distance from the center of Houston to find the closest.</p>&#13;
</body></html>