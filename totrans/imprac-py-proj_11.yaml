- en: '**11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11**'
- en: THE MONTY HALL PROBLEM**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**蒙提霍尔问题**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: 'As host of the TV game show *Let’s Make a Deal*, Monty Hall would show contestants
    three closed doors and ask them to choose one. Behind one door was a valuable
    prize; behind the other two were smelly old goats. As soon as the contestant chose
    a door, Monty would open one of the remaining doors to reveal a goat. The contestant
    was then given a final choice: switch doors or stay with their initial pick.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为电视游戏节目 *Let's Make a Deal* 的主持人，Monty Hall 会展示给参赛者三个封闭的门，并要求他们选择一个。一个门后面藏着一个宝贵的奖品，而另外两个门后面则是臭味扑鼻的老山羊。一旦参赛者选择了一个门，Monty
    就会打开剩下的一个门，露出一只山羊。然后，参赛者会面临最后的选择：是更换门，还是坚持原来的选择。
- en: In 1990, Marilyn vos Savant, “the world’s smartest woman,” stated in her weekly
    *Parade* magazine column, “Ask Marilyn,” that the contestant should choose to
    switch doors. Though her answer was correct, it ignited a firestorm of hate mail,
    gender profiling, and academic persecution. Many math professors embarrassed themselves
    in the process, but there was a bright side to the ugly affair. The heated discussion
    exposed the public to the science of statistics, and an exercise that vos Savant
    proposed found its way into thousands of classrooms. These manual tests—later
    duplicated by computers—all vindicated her derided “female logic.”
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 1990 年，"世界上最聪明的女人" Marilyn vos Savant 在她每周的 *Parade* 杂志专栏《问玛丽莲》中指出，参赛者应该选择更换门。虽然她的回答是正确的，但却引发了大量的仇恨邮件、性别偏见和学术迫害。在这个过程中，许多数学教授感到尴尬，但这场丑陋的事件也有光明的一面。激烈的讨论让公众接触到了统计学的科学，vos
    Savant 提出的一个实验也进入了成千上万的教室。这些手动测试——后来由计算机复制——最终证明了她那被讽刺的“女性逻辑”是正确的。
- en: In this chapter, you’ll use *Monte Carlo simulation (MCS)*, a method for modeling
    the probability of different outcomes from a range of random inputs, to verify
    that vos Savant was right. After that, you’ll use tkinter to build a fun graphical
    interface that addresses her request for schoolchildren to help with the experiment.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用 *蒙特卡洛模拟（MCS）*，这是一种通过一系列随机输入来建模不同结果的概率的方法，来验证 vos Savant 的结论是否正确。之后，你将使用
    tkinter 构建一个有趣的图形界面，来满足她要求学校儿童帮助实验的请求。
- en: '**Monte Carlo Simulation**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**蒙特卡洛模拟**'
- en: Imagine you want to know the probability of rolling a die six times and getting
    a different face with each roll. If you’re a math whiz, you’d probably just compute
    this using the deterministic equation 6! / 6⁶ or
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你想知道投掷一个骰子六次，每次得到不同的面朝上的概率。如果你是一个数学天才，你可能会直接通过确定性方程 6! / 6⁶ 来计算这个概率，或者
- en: '![image](../images/f0218-01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0218-01.jpg)'
- en: 'yielding 0.015\. If you’re not so mathematically inclined, you could get the
    same answer with Python and a lot of rolls:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果为 0.015。如果你不那么擅长数学，你也可以使用 Python 和大量的投掷来得到相同的答案：
- en: '>>> from random import randint'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from random import randint'
- en: '>>> trials = 100000'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> trials = 100000'
- en: '>>> success = 0'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> success = 0'
- en: '>>> for trial in range(trials):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for trial in range(trials):'
- en: faces = set()
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: faces = set()
- en: 'for rolls in range(6):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 'for rolls in range(6):'
- en: roll = randint(1, 6)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: roll = randint(1, 6)
- en: faces.add(roll)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: faces.add(roll)
- en: 'if len(faces) == 6:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 'if len(faces) == 6:'
- en: success += 1
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: success += 1
- en: '>>> print("probability of success = {}".format(success/trials))'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print("成功的概率 = {}".format(success/trials))'
- en: probability of success = 0.01528
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的概率 = 0.01528
- en: This example uses a for loop and randint to randomly pick a number between 1
    and 6, representing one of the faces on the die, six times in a row. It adds each
    result to a set named faces, which doesn’t permit duplicates. The only way for
    the length of the set to reach 6 is if each roll yields a unique number, which
    equals a success case. An outer for loop performs the six-roll trial 100,000 times.
    Dividing the number of successes by the number of trials yields the same probability,
    0.015, as the deterministic equation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例使用了一个 for 循环和 randint 函数，随机选取 1 到 6 之间的数字，表示骰子上的六个面之一，连续投掷六次。它将每次的结果添加到一个名为
    faces 的集合中，集合不允许重复。集合的长度达到 6 的唯一方法是每次投掷的结果都是唯一的，这样就算作一次成功。外层的 for 循环会执行 100,000
    次这个六次投掷的实验。将成功次数除以实验次数，可以得到与确定性方程相同的概率值 0.015。
- en: Monte Carlo simulation uses *repeated random sampling*—in this case, each roll
    of the die is a random sample—to predict different outcomes under a specified
    range of conditions. For this example, the range of conditions was one six-faced
    die, six rolls with no repeats per trial, and 100,000 trials. Of course, MCS is
    usually applied to more complex problems—those with lots of variables and wide
    ranges of uncertainty, where the results cannot be easily predicted.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡洛模拟使用*反复随机抽样*——在这个例子中，每一次掷骰子都是一个随机样本——来预测在指定条件范围内的不同结果。对于这个例子，条件范围是一个六面骰子，每次试验六次掷骰子且不重复，试验次数为100,000次。当然，MCS通常应用于更复杂的问题——那些有大量变量和广泛不确定性的情况，其中结果无法轻易预测。
- en: 'There are multiple types of MCS, but most applications follow these basic steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种类型的MCS，但大多数应用遵循以下基本步骤：
- en: List the input variables.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出输入变量。
- en: Provide a probability distribution for each variable.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个变量提供一个概率分布。
- en: 'Start a loop:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始一个循环：
- en: Randomly select a value from the distributions for each input.
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机从每个输入的分布中选择一个值。
- en: Use the values in a deterministic calculation, which is a calculation that will
    always produce the same output from the same input.
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这些值进行确定性计算，即从相同输入中始终产生相同输出的计算。
- en: Repeat a specified number of times.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复指定次数。
- en: Aggregate the results and generate statistics, such as the average outcome for
    the calculation.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汇总结果并生成统计数据，例如计算的平均结果。
- en: 'For the die-roll example, these steps were:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于掷骰子示例，这些步骤是：
- en: Input variables = the results of six die rolls.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入变量 = 六次掷骰子的结果。
- en: Probability distribution for roll = uniform (1/6 for each face).
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掷骰子的概率分布 = 均匀分布（每个面为1/6）。
- en: 'Loop:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环：
- en: Randomly selected value = die roll (draw from distribution).
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机选择的值 = 掷骰子（从分布中抽取）。
- en: Calculation = add the six values to a set and, if set length equals 6, add 1
    to success variable.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算 = 将六个值加到一个集合中，如果集合长度等于6，则成功变量加1。
- en: Repeat = 100,000 times.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复 = 100,000次。
- en: 'Aggregate: divide success variable by 100,0000 for probability calculation.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汇总：将成功变量除以100,0000来计算概率。
- en: Nassim Taleb, the critically acclaimed author of *The Black Swan* and *Fooled
    by Randomness*, is a fan of MCS. He posits that our brains are designed to get
    us out of trouble quickly, rather than handle complicated uncertainty or probability
    problems. We aren’t cut out for highly skewed distributions and nonlinearities,
    but some people’s brains are inherently more capable of understanding risks using
    MCS than other methods. In real life, we don’t observe probability distributions;
    we just observe events.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 纳西姆·尼古拉斯·塔勒布（Nassim Taleb），《黑天鹅》和《随机的愚弄》一书的备受好评的作者，是MCS的支持者。他认为我们的脑袋设计用来迅速帮助我们摆脱困境，而不是处理复杂的不确定性或概率问题。我们并不适应高度偏斜的分布和非线性问题，但有些人的大脑天生就比其他方法更能通过MCS理解风险。在现实生活中，我们并不观察概率分布；我们只是观察事件。
- en: Each MCS run represents a single event, such as whether you run out of money
    in retirement. For many of us, MCS makes risk real. It helps us understand how
    bad or good things can be—something we can’t always glean from mathematical abstractions.
    With the insight from MCS, we can prepare to both defend against the downside
    and exploit the upside.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每次MCS运行代表一个单独事件，例如是否在退休时用尽资金。对于我们很多人来说，MCS使得风险变得真实。它帮助我们理解事情可能的好坏——这是我们从数学抽象中无法轻易获得的。通过MCS得到的洞察，我们可以为防范风险并利用机会做准备。
- en: To support the math behind the Monty Hall problem, you’ll use an MCS application
    like the preceding die-roll example. Then, in [Chapter 12](ch12.xhtml#ch12), you’ll
    use MCS to build a nest-egg simulator to plan your (or your parents’) secure retirement.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证蒙提霍尔问题的数学推导，你将使用像前面的掷骰子示例这样的MCS应用。然后，在[第12章](ch12.xhtml#ch12)中，你将使用MCS构建一个退休资金模拟器，以规划你（或你父母）的安全退休。
- en: '**Project #18: Verify vos Savant**'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #18：验证Vos Savant**'
- en: To verify that vos Savant was right, use a Monte Carlo approach and simulate
    tens of thousands of “games” in order to see how things shake out. This can be
    a bare-bones program, since the goal is a simple confirmation with no embellishments.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证Vos Savant是对的，可以使用蒙特卡洛方法模拟数万次“游戏”，以查看结果如何。这可以是一个基础程序，因为目标是一个简单的确认，没有多余的修饰。
- en: '**THE OBJECTIVE**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Write a simple Python program that uses Monte Carlo simulation to determine
    the probability of winning the Monty Hall problem by changing the initial pick.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个简单的Python程序，使用蒙特卡洛模拟来确定通过改变初始选择来赢得蒙提霍尔问题的概率。
- en: '***The Strategy***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: The correct response to the Monty Hall problem is to switch doors after Monty
    reveals the goat. Statistically, this will double your chances of winning!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙提霍尔问题的正确答案是在蒙提揭示山羊后换门。从统计学角度来看，这样做会将你获胜的概率翻倍！
- en: Look at [Figure 11-1](ch11.xhtml#ch11fig1). At the start of the game, all the
    doors are closed, and the odds of a given door hiding the prize are 1 in 3\. The
    user can choose only one door, which means the odds of the prize being behind
    one of the other two doors are 2 in 3\. After the goat is revealed, the odds remain
    2 in 3, but they revert to the remaining door. Remember, Monty knows where the
    prize is hidden, and he will never reveal *that* door. So the probability of success
    is 1/3 for staying with your first choice versus 2/3 for switching.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[图 11-1](ch11.xhtml#ch11fig1)。在游戏开始时，所有的门都关闭，某一扇门藏有奖品的概率是1/3。用户只能选择一扇门，这意味着奖品可能藏在其他两扇门中的概率是2/3。山羊被揭示后，概率依然是2/3，但这2/3的概率转移到了剩下的那扇门。记住，蒙提知道奖品藏在哪里，并且他永远不会揭示*那扇*门。所以，如果坚持选择最初的门，成功的概率是1/3，而换门的成功概率是2/3。
- en: '![image](../images/f0220-01.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0220-01.jpg)'
- en: '*Figure 11-1: Odds of winning the Monty Hall problem before and after a goat
    is revealed*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-1：蒙提霍尔问题中奖的概率变化（揭示山羊前后）*'
- en: If you’re dubious about the math, you can use MCS to provide corroborating evidence,
    just as we did with the die-roll example. You simply need to pick a winning door
    at random, choose a contestant’s pick at random, and record how many times the
    two coincide. Repeat this thousands of times, and you will converge on the deterministic
    mathematical solution.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对数学公式有所怀疑，可以使用MCS来提供佐证，就像我们在掷骰子的例子中所做的那样。你只需要随机选择一个获胜的门，随机选择一个参赛者的选择，并记录两者相遇的次数。重复这个过程几千次，你会收敛到确定性的数学解。
- en: '***The vos Savant Verification Code***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Vos Savant 验证码***'
- en: The *monty_hall_mcs.py* program described in this section will automate the
    process of choosing doors and recording the results so that you can run thousands
    of trials and evaluate them in less than a second. You can download the code from
    *[https://www.nostarch.com/impracticalpython.com/](https://www.nostarch.com/impracticalpython.com/)*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个章节中描述的*monty_hall_mcs.py*程序将自动化选择门并记录结果的过程，这样你可以运行数千次试验并在不到一秒钟的时间内评估它们。你可以从*[https://www.nostarch.com/impracticalpython.com/](https://www.nostarch.com/impracticalpython.com/)*下载代码。
- en: '**Getting the Number of Runs Input**'
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**获取运行次数输入**'
- en: '[Listing 11-1](ch11.xhtml#ch11list1) starts the *monty_hall_mcs.py* program
    by asking the user how many runs—or games—they want to simulate. You’ll also provide
    the user with a default value. This is a great way to guide a user to a reasonable
    first response, as well as save them a few keystrokes.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-1](ch11.xhtml#ch11list1)通过询问用户想要模拟多少次运行（或游戏）来启动*monty_hall_mcs.py*程序。你还会提供一个默认值。这是引导用户给出合理初步回答的好方法，同时也能为他们节省一些敲键盘的时间。'
- en: '*monty_hall_mcs.py,* part 1'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*monty_hall_mcs.py,* 第一部分'
- en: ➊ import random
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ import random
- en: '➋ def user_prompt(prompt, default=None):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ def user_prompt(prompt, default=None):'
- en: '"""Allow use of default values in input."""'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '"""允许在输入时使用默认值。"""'
- en: '➌ prompt = ''{} [{}]: ''.format(prompt, default)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ prompt = ''{} [{}]: ''.format(prompt, default)'
- en: ➍ response = input(prompt)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ response = input(prompt)
- en: '➎ if not response and default:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ if not response and default:'
- en: return default
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: return default
- en: 'else:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: return response
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: return response
- en: '# input number of times to run simulation'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '# 输入运行模拟的次数'
- en: ➏ num_runs = int(user_prompt("Input number of runs", "20000"))
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ num_runs = int(user_prompt("输入运行次数", "20000"))
- en: '*Listing 11-1: Imports modules and defines the* user_prompt() *function*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-1：导入模块并定义* user_prompt() *函数*'
- en: Start by importing the random module to run MCS ➊. Next, define a function,
    called user_prompt(), that asks the user to either input the number of games to
    run or else accept a default value, if provided ➋. This function takes two arguments;
    the first is the text prompt that tells the user what to do, and the second is
    the default value, which will start out as None. Immediately redefine the prompt
    variable so that it will display with the default value in brackets, per convention
    ➌. Assign the user’s input to a variable named response ➍. If the user presses
    ENTER without providing any input and a default value exists, the user_prompt()
    function will return the default value ➎. Otherwise, the function returns the
    user’s input. Use the function to determine the number of runs to make by assigning
    the returned value to the num_runs variable ➏. Each run will represent a contestant
    playing the game once.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入随机模块以运行 MCS ➊。接下来，定义一个名为 user_prompt() 的函数，要求用户输入要运行的游戏次数，或者如果提供了默认值，则接受默认值
    ➋。此函数接受两个参数；第一个是文本提示，告诉用户该做什么，第二个是默认值，初始为 None。立即重新定义提示变量，使其按照惯例显示带有默认值的括号 ➌。将用户的输入赋值给名为
    response 的变量 ➍。如果用户按 Enter 键而没有提供任何输入，并且存在默认值，则 user_prompt() 函数将返回默认值 ➎。否则，函数返回用户的输入。使用此函数通过将返回值赋给
    num_runs 变量来确定运行的次数 ➏。每次运行将代表一位参赛者玩一次游戏。
- en: '**Running MCS and Displaying the Results**'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**运行MCS并显示结果**'
- en: '[Listing 11-2](ch11.xhtml#ch11list2) picks the winning door and the user’s
    first choice at random, then aggregates and presents the statistics. Interestingly,
    the user’s second choice—to switch doors or not—isn’t required to get the correct
    answer. If the initial choice is the winning door, the correct answer is to not
    change doors. Likewise, if the initial choice and the winning door differ, the
    correct answer is to change doors. There’s no reason to model what a contestant
    might or might not do.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-2](ch11.xhtml#ch11list2) 随机选择获胜门和用户的第一次选择，然后汇总并展示统计数据。有趣的是，用户的第二次选择——是否换门——并不是得出正确答案所必需的。如果初始选择是获胜门，正确的答案是不要换门。同样，如果初始选择和获胜门不同，正确的答案是换门。没有必要模拟参赛者可能做的或不做的事情。'
- en: '*monty_hall_mcs.py,* part 2'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*monty_hall_mcs.py,* 第2部分'
- en: '# assign counters for ways to win'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '# 分配胜利方式的计数器'
- en: ➊ first_choice_wins = 0
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ first_choice_wins = 0
- en: pick_change_wins = 0
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: pick_change_wins = 0
- en: ➋ doors = ['a', 'b', 'c']
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ doors = ['a', 'b', 'c']
- en: '# run Monte Carlo'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '# 运行蒙特卡罗模拟'
- en: '➌ for i in range(num_runs):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ for i in range(num_runs):'
- en: winner = random.choice(doors)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: winner = random.choice(doors)
- en: pick = random.choice(doors)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: pick = random.choice(doors)
- en: '➍ if pick == winner:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ if pick == winner:'
- en: first_choice_wins += 1
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: first_choice_wins += 1
- en: 'else:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: pick_change_wins += 1
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: pick_change_wins += 1
- en: ➎ print("Wins with original pick = {}".format(first_choice_wins))
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ print("原选择获胜次数 = {}".format(first_choice_wins))
- en: print("Wins with changed pick = {}".format(pick_change_wins))
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: print("更改选择获胜次数 = {}".format(pick_change_wins))
- en: 'print("Probability of winning with initial guess: {:.2f}"'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("初始猜测获胜的概率: {:.2f}"'
- en: .format(first_choice_wins / num_runs))
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: .format(first_choice_wins / num_runs))
- en: 'print("Probability of winning by switching: {:.2f}"'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("通过换门获胜的概率: {:.2f}"'
- en: .format(pick_change_wins / num_runs))
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: .format(pick_change_wins / num_runs))
- en: ➏ input("\nPress Enter key to exit.")
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ input("\n按 Enter 键退出。")
- en: '*Listing 11-2: Runs the Monte Carlo simulation and displays the results*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-2：运行蒙特卡罗模拟并显示结果*'
- en: Assign two variables to keep track of whether switching or staying put is the
    winning outcome ➊. Then, create a list to represent the three doors ➋.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 分配两个变量来跟踪是否换门或保持原选择是获胜的结果 ➊。然后，创建一个列表来表示三扇门 ➋。
- en: MCS starts with a for loop that goes through the number of runs ➌. Inside that
    loop, choose the winning door and the user’s first choice from the doors list,
    using random.choice(), and assign them to variables.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: MCS 从一个 for 循环开始，该循环遍历运行次数 ➌。在循环内，从 doors 列表中随机选择获胜门和用户的第一次选择，使用 random.choice()，并将它们赋值给变量。
- en: Since this is a binary system—the user switches or doesn’t—you’ll only need
    a conditional that adds to the counters based on the relationship of the pick
    variable to the winning variable ➍.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个二元系统——用户换门或不换门——你只需要一个条件语句，根据 pick 变量和 winner 变量的关系来更新计数器 ➍。
- en: Finish the program by presenting the final results. Display the actual counts,
    plus the calculated probabilities ➎. Then let the user know the program is finished
    ➏.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 完成程序并展示最终结果。显示实际计数和计算出的概率 ➎。然后告知用户程序已完成 ➏。
- en: 'Here’s an example output for the default 20,000 runs:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认20,000次运行的输出示例：
- en: 'Input number of runs [20000]:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '输入运行次数 [20000]:'
- en: Wins with original pick = 6628
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 原始选择获胜次数 = 6628
- en: Wins with changed pick = 13372
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 更换选择后获胜次数 = 13372
- en: 'Probability of winning with initial guess: 0.33'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 初始猜测的获胜概率：0.33
- en: 'Probability of winning by switching: 0.67'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更换选择的获胜概率：0.67
- en: Press Enter key to exit.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 按下回车键退出。
- en: Some people aren’t impressed with a computer printout. They need something more
    convincing, so in the next project, you’ll repackage your code in a more hands-on
    format—one that’s complete with doors, prizes, and goats. This will also satisfy
    Marilyn vos Savant’s appeal for schoolchildren to join in and help restore her
    honor.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人对计算机打印输出不感兴趣。他们需要更有说服力的东西，因此在下一个项目中，你将以一种更具动手性质的方式重新包装你的代码——一种完整的、有门、有奖品和有山羊的格式。这也将满足Marilyn
    vos Savant的呼吁，让学生们参与进来，帮助恢复她的声誉。
- en: '**Project #19: The Monty Hall Game**'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目#19：蒙提霍尔游戏**'
- en: The three-door game used in the Monty Hall problem is simple enough for you
    to build with tkinter. You began working with tkinter graphics in [Chapter 10](ch10.xhtml#ch10).
    Now you’ll build on this knowledge by adding interactive buttons for the user
    to click.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙提霍尔问题中的三门游戏足够简单，可以使用tkinter构建。你已经在[第10章](ch10.xhtml#ch10)开始接触tkinter图形。现在，你将在此基础上增加交互按钮供用户点击。
- en: '**THE OBJECTIVE**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Simulate the Monty Hall problem using a GUI built with tkinter. Keep track of
    whether switching doors or staying put results in a win. In addition, update and
    display these statistics as the game is played.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用tkinter构建的GUI模拟蒙提霍尔问题。跟踪更换门或保持不变是否会导致获胜。此外，在游戏进行时更新并显示这些统计数据。
- en: '***A Brief Introduction to Object-Oriented Programming***'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***面向对象编程简要介绍***'
- en: The tkinter module was written using *object-oriented programming (OOP)*. OOP
    is a language model built around data structures, known as *objects*, consisting
    of *data* and *methods* and the interactions between them—as opposed to the *actions*
    and *logic* used in procedural programming. Objects are built from *classes*,
    which are like blueprints for the objects.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: tkinter模块是使用*面向对象编程（OOP）*编写的。OOP是一种围绕数据结构（称为*对象*）构建的语言模型，包含*数据*和*方法*以及它们之间的交互——与过程化编程中使用的*动作*和*逻辑*不同。对象是由*类*构建的，类就像对象的蓝图。
- en: OOP is an abstract concept and easier to appreciate when you’re writing large,
    complex programs. It reduces code duplication and makes code easier to update,
    maintain, and reuse. As a result, most commercial software is now built using
    OOP.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: OOP是一个抽象概念，写大型复杂程序时更容易理解。它减少了代码重复，使代码更易于更新、维护和重用。因此，大多数商业软件现在都是使用OOP构建的。
- en: 'If you implemented OOP in small programs, like the ones we’ve written so far,
    most of them would feel overengineered. In fact, one of my all-time favorite quotes,
    attributed to British computer scientist Joe Armstrong, concerns this aspect of
    OOP: “The problem with object-oriented languages is they’ve got all this implicit
    environment that they carry around with them. You wanted a banana, but what you
    got was a gorilla holding the banana and the entire jungle!”'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在小型程序中实现了OOP，就像我们迄今为止编写的那些程序，它们大多数会显得过于复杂。事实上，我最喜欢的一句名言，来自英国计算机科学家乔·阿姆斯特朗，正是关于OOP的这一方面：“面向对象语言的问题在于，它们携带着所有这些隐性环境。你想要一个香蕉，但你得到的是一个拿着香蕉的猩猩和整个丛林！”
- en: Despite this, the objects produced by OOP lend themselves very well to GUIs
    and gaming, even for some small projects. Let’s look at an example using a *Dungeons
    and Dragons*–type board game in which players can be different characters, such
    as dwarves, elves, and wizards. These games use character cards to list important
    information for each character type. If you let your playing piece represent a
    dwarf, it inherits the characteristics on the card (see [Figure 11-2](ch11.xhtml#ch11fig2)).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，OOP所生成的对象非常适合用于GUI和游戏，即使是一些小型项目。让我们看一个使用*地下城与龙*类型的桌面游戏的例子，玩家可以选择不同的角色，比如矮人、精灵和巫师。这些游戏使用角色卡片列出每个角色类型的重要信息。如果你让你的棋子代表矮人，它就会继承卡片上的特征（见[图11-2](ch11.xhtml#ch11fig2)）。
- en: '![image](../images/f0224-01.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0224-01.jpg)'
- en: '*Figure 11-2: A dwarf character card from a role-playing board game*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-2：角色扮演游戏中的矮人角色卡片*'
- en: '[Listings 11-3](ch11.xhtml#ch11list3) and [11-4](ch11.xhtml#ch11list4) reproduce
    board game–style play, letting you create virtual cards for a dwarf and an elf,
    name your pieces, and have them fight. The outcome of the fight will impact one
    of the character’s *body points*, which represent the character’s health. Be sure
    to note how OOP can allow you to easily create many identical objects—in this
    case, dwarves or elves—by “stamping” them out of the predefined template, called
    a *class*.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单11-3](ch11.xhtml#ch11list3)和[11-4](ch11.xhtml#ch11list4)重现了类似桌游的玩法，允许你为矮人和精灵创建虚拟卡片，命名你的棋子，并让它们进行战斗。战斗的结果会影响某个角色的*身体点数*，即代表角色生命的健康值。请注意，面向对象编程（OOP）如何允许你通过“复制”预定义的模板——即*类*——轻松地创建多个相同的对象，在这种情况下是矮人或精灵。'
- en: ➊ >>> import random
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> import random
- en: '➋ >>> class Dwarf(object):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ >>> class Dwarf(object):'
- en: '➌ def __init__(self, name):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ >>> def __init__(self, name):'
- en: ➍ self.name = name
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ self.name = name
- en: self.attack = 3
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: self.attack = 3
- en: self.defend = 4
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: self.defend = 4
- en: self.body = 5
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: self.body = 5
- en: '➎ def talk(self):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ def talk(self):'
- en: print("I'm a blade-man, I'll cut ya!!!")
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: print("我是一个刀客，我会砍你！！！")
- en: ➏ >>> lenn = Dwarf("Lenn")
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ >>> lenn = Dwarf("Lenn")
- en: '>>> print("Dwarf name = {}".format(lenn.name))'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print("矮人名称 = {}".format(lenn.name))'
- en: Dwarf name = Lenn
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 矮人名称 = Lenn
- en: '>>> print("Lenn''s attack strength = {}".format(lenn.attack))'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print("Lenn的攻击力 = {}".format(lenn.attack))'
- en: Lenn's attack strength = 3
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Lenn的攻击力 = 3
- en: '>>>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '>>>'
- en: ➐ >>> lenn.talk()
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ >>> lenn.talk()
- en: I'm a blade-man, I'll cut ya!!!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我是一个刀客，我会砍你！！！
- en: '*Listing 11-3: Imports* random *module, creates a* Dwarf *class, and instantiates
    a dwarf object*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单11-3：导入* random *模块，创建一个* Dwarf *类，并实例化一个矮人对象*'
- en: Start by importing random to simulate rolling a die ➊; this is how your character
    will fight. Now define a class for a dwarf character, capitalizing the first letter
    of the class name, and pass it an object argument, which will be the name of your
    dwarf ➋. A class is a template for creating objects of a certain type. For example,
    when you create a list or dictionary, you are creating them from a class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入random来模拟掷骰子 ➊；这就是你的角色如何进行战斗的方式。现在为矮人角色定义一个类，类名的首字母大写，并传入一个对象参数，即你矮人的名字
    ➋。类是创建某一类型对象的模板。例如，当你创建一个列表或字典时，你是从一个类中创建它们的。
- en: The Dwarf class definition is like the card in [Figure 11-2](ch11.xhtml#ch11fig2);
    it is basically the genetic blueprint for a dwarf. It will assign *attributes*,
    like strength and vitality, and *methods*, like how the character moves or talks.
    Attributes are variables scoped to an *instance* of the class, and methods are
    attributes that also happen to be functions, which are passed a reference to their
    instance when they run. A class is a data type, and when you create an object
    of that data type, it is also known as an instance of that class. The process
    of setting the initial values and behaviors of the instance is called *instantiation*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Dwarf类定义就像[图11-2](ch11.xhtml#ch11fig2)中的卡片；它基本上是矮人的基因蓝图。它会分配*属性*，如力量和生命力，和*方法*，如角色如何移动或讲话。属性是作用于类的*实例*的变量，而方法是也恰好是函数的属性，当它们运行时会传入对它们实例的引用。类是一种数据类型，当你创建该数据类型的对象时，它也被称为该类的实例。设置实例的初始值和行为的过程称为*实例化*。
- en: 'Next, define a *constructor* method, also referred to as the *initialization*
    method. It sets up the initial attribute values for your object ➌. The __init__()
    method is a special built-in method that Python automatically invokes as soon
    as a new object is created. In this case, you’ll pass two arguments: self and
    the name of your object.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个*构造函数*方法，也叫*初始化*方法。它为你的对象设置初始的属性值 ➌。`__init__()`方法是一个特殊的内置方法，Python会在创建新对象时自动调用它。在这个方法中，你将传入两个参数：self
    和你的对象名称。
- en: The self parameter is a reference to the instance of this class that is being
    created, or a reference to the instance a method was invoked on, technically referred
    to as a *context* instance. If you create a new dwarf and name it “Steve,” self
    will become Steve behind the scenes. For example, self.attack becomes “Steve’s
    attack.” If you create another dwarf named “Sue,” self for that object will become
    “Sue.” This way, the scope of Steve’s health attribute is kept separate from Sue’s.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: self参数是对正在创建的类实例的引用，或者是方法被调用时的实例引用，技术上称为*上下文*实例。如果你创建一个新的矮人并命名为“Steve”，那么self将在幕后变成Steve。例如，self.attack会变成“Steve的攻击力”。如果你创建另一个矮人并命名为“Sue”，那么该对象的self将变成“Sue”。这样，Steve的健康属性范围与Sue的健康属性就被区分开了。
- en: Next, list some attributes for a dwarf beneath the constructor definition ➍.
    You’ll want a name so you can tell one dwarf from another, as well as the value
    of key combat characteristics. Notice how this list resembles the card in [Figure
    11-2](ch11.xhtml#ch11fig2).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在构造函数定义下列出一些矮人的属性 ➍。你需要一个名字以便区分不同的矮人，还有一些关键战斗属性。注意，这个列表与[图11-2](ch11.xhtml#ch11fig2)中的卡片相似。
- en: Define a talk() method and pass it self ➎. By passing it self, you link the
    method to the object. In more comprehensive games, methods might include behaviors
    like movement and the ability to disarm traps.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个talk()方法，并传递self ➎。通过传递self，你将方法与对象关联。在更全面的游戏中，方法可能包括诸如移动和解除陷阱的行为。
- en: With the class definition complete, create an instance of the Dwarf class and
    assign this object to the local variable lenn, the dwarf’s name ➏. Now, print
    the name and attack attributes to demonstrate that you have access to them. Finish
    by invoking the talk() method ➐. This should display a message.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义完成后，创建一个Dwarf类的实例，并将该对象分配给本地变量lenn，这是矮人的名字 ➏。现在，打印名字和攻击属性，以展示你已经可以访问它们。最后调用talk()方法
    ➐。这应该显示一条信息。
- en: '[Listing 11-4](ch11.xhtml#ch11list4) creates an elf character, using the same
    process you used in [Listing 11-3](ch11.xhtml#ch11list3), and has it fight the
    dwarf. The elf’s body attribute is updated to reflect the outcome of the battle.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单11-4](ch11.xhtml#ch11list4)创建一个精灵角色，使用你在[清单11-3](ch11.xhtml#ch11list3)中使用的相同过程，并让它与矮人战斗。精灵的生命属性会根据战斗结果进行更新。'
- en: '➊ >>> class Elf(object):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ >>> class Elf(object):'
- en: 'def __init__(self, name):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name):'
- en: self.name = name
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: self.name = name
- en: self.attack = 4
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: self.attack = 4
- en: self.defend = 4
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: self.defend = 4
- en: self.body = 4
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: self.body = 4
- en: '>>> esseden = Elf("Esseden")'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> esseden = Elf("Esseden")'
- en: '>>> print("Elf name = {}".format(esseden.name))'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print("精灵名字 = {}".format(esseden.name))'
- en: Elf name = Esseden
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵名字 = Esseden
- en: '>>> print("Esseden body value = {}".format(esseden.body))'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print("Esseden生命值 = {}".format(esseden.body))'
- en: Esseden body value = 4
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Esseden生命值 = 4
- en: '>>>'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '>>>'
- en: ➋ >>> lenn_attack_roll = random.randrange(1, lenn.attack + 1)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> lenn_attack_roll = random.randrange(1, lenn.attack + 1)
- en: '>>> print("Lenn attack roll = {}".format(lenn_attack_roll))'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print("Lenn攻击掷骰 = {}".format(lenn_attack_roll))'
- en: Lenn attack roll = 3
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Lenn攻击掷骰 = 3
- en: ➌ >>> esseden_defend_roll = random.randrange(1, esseden.defend + 1)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ >>> esseden_defend_roll = random.randrange(1, esseden.defend + 1)
- en: '>>> print("Esseden defend roll = {}".format(esseden_defend_roll))'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print("Esseden防御掷骰 = {}".format(esseden_defend_roll))'
- en: Esseden defend roll = 1
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Esseden防御掷骰 = 1
- en: '>>>'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '>>>'
- en: ➍ >>> damage = lenn_attack_roll - esseden_defend_roll
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ >>> damage = lenn_attack_roll - esseden_defend_roll
- en: '>>> if damage > 0:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> if damage > 0:'
- en: esseden.body -= damage
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: esseden.body -= damage
- en: ➎ >>> print("Esseden body value = {}".format(esseden.body))
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ >>> print("Esseden生命值 = {}".format(esseden.body))
- en: Esseden body value = 2
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Esseden生命值 = 2
- en: '*Listing 11-4: Creates an* Elf *class, instantiates an elf object, simulates
    a battle, and updates an object attribute*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单11-4：创建一个* 精灵 *类，实例化一个精灵对象，模拟一场战斗，并更新对象属性*'
- en: Define an Elf class and provide some attributes ➊. Make them slightly different
    from the dwarf’s and well balanced, like an elf. Instantiate an elf named Esseden
    and access his name and body attributes using print.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个精灵类，并提供一些属性 ➊。使它们与矮人有所不同，并且像精灵一样平衡。实例化一个名为Esseden的精灵，并使用print访问他的名字和生命属性。
- en: Have your two characters interact using the roll of a virtual die with a maximum
    value equal to the character’s attack or defend value. Use the random module to
    choose a roll value in a range of 1 to Lenn’s attack attribute plus 1 ➋, then
    repeat this process to get Esseden’s defense ➌. Calculate the damage to Esseden
    by subtracting Esseden’s roll value from Lenn’s roll value ➍, and if the damage
    is a positive number, subtract it from Esseden’s body attribute. Use print() to
    confirm the elf’s current health ➎.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟骰子的掷骰结果来让你的两个角色进行互动，虚拟骰的最大值等于角色的攻击或防御值。使用random模块从1到Lenn的攻击属性加1的范围中选择一个掷骰值
    ➋，然后重复此过程获取Esseden的防御值 ➌。通过将Esseden的掷骰值从Lenn的掷骰值中减去 ➍，计算对Esseden的伤害，如果伤害为正数，则从Esseden的生命属性中扣除它。使用print()来确认精灵的当前生命值
    ➎。
- en: As you can imagine, building many similar characters and keeping track of their
    changing attributes could quickly get complicated with procedural programming.
    OOP provides a modular structure for your program, makes it easy to hide complexity
    and ownership of scope with encapsulation, permits problem solving in bite-sized
    chunks, and produces sharable templates that can be modified and used elsewhere.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，构建许多相似的角色并跟踪它们变化的属性，在过程式编程中会变得非常复杂。面向对象编程（OOP）为你的程序提供了模块化结构，便于通过封装隐藏复杂性和作用域的所有权，允许以小块的方式解决问题，并生成可共享的模板，可以在其他地方修改和使用。
- en: '***The Strategy and Pseudocode***'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略与伪代码***'
- en: 'Now back to our three-door game. The rules for the game form the bulk of the
    pseudocode for the program:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到我们的三门游戏。游戏的规则构成了程序伪代码的主体部分：
- en: Initialize game window and show closed doors and instructions
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化游戏窗口并显示已关闭的门和说明
- en: Choose winning door at random
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 随机选择获胜门
- en: Get player's door choice
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 获取玩家的门选择
- en: Reveal a door that isn't the winning door or the player's choice
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 显示不是获胜门或玩家选择的门
- en: Get player's choice to switch doors or not
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 获取玩家是否换门的选择
- en: 'If player switches:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家换门：
- en: Reveal new door
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 显示新门
- en: 'If winner:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果获胜者：
- en: Record as win for switching
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 记录换门后的胜利
- en: 'Otherwise:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: Record as win for staying put
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 记录保持原样的胜利
- en: 'Else if player stays with first choice:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 否则如果玩家坚持初始选择：
- en: Reveal chosen door
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 显示玩家选择的门
- en: 'If winner:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果获胜者：
- en: Record as win for staying put
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 记录保持原样的胜利
- en: 'Otherwise:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: Record as win for switching
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 记录换门后的胜利
- en: Display number of wins for each strategy in game window
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏窗口中显示每种策略的获胜次数
- en: Reset game and close all doors
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 重置游戏并关闭所有门
- en: It’s useful to start designing a game by sketching out how the game window should
    look, complete with instructions, messages, and button types. I doubt you want
    to see my crude scribblings, so instead check out [Figure 11-3](ch11.xhtml#ch11fig3).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 开始设计游戏时，最好先草拟出游戏窗口的外观，包括说明、消息和按钮类型。我猜你不想看到我粗糙的涂鸦，所以不妨看看[图 11-3](ch11.xhtml#ch11fig3)。
- en: '![image](../images/f0227-01.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0227-01.jpg)'
- en: '*Figure 11-3: View of the game window after the first round of play*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-3：第一轮游戏后的游戏窗口视图*'
- en: This is how the finished game will look after the first round, with the win
    statistics visible at the far right. Note that the radio buttons for changing
    doors are grayed out until an initial pick has been made.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是游戏完成后的第一轮样式，右侧显示了获胜统计数据。请注意，换门的单选按钮在玩家做出初始选择之前是灰色的，无法操作。
- en: '***Game Assets***'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***游戏资产***'
- en: '*Game assets* is a fancy term for things that you’ll need to build the game.
    These will consist of a series of images to represent the doors, goats, and prize
    ([Figure 11-4](ch11.xhtml#ch11fig4)).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*游戏资产*是指构建游戏时需要的各种元素。这些元素将包括一系列图像，用于表示门、山羊和奖品（[图 11-4](ch11.xhtml#ch11fig4)）。'
- en: '![image](../images/f0228-01.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0228-01.jpg)'
- en: '*Figure 11-4: Building-block images for the* monty_hall_gui.py *program*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-4：*monty_hall_gui.py* 程序的构建块图像*'
- en: I used Microsoft PowerPoint to composite the 3 base images into 10 images that
    represent all the possible states of the game ([Figure 11-5](ch11.xhtml#ch11fig5)).
    This was a design decision; with extra lines of code, I could have obtained the
    same results using only the base images.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 Microsoft PowerPoint 将三张基础图像合成了 10 张图像，表示游戏的所有可能状态（[图 11-5](ch11.xhtml#ch11fig5)）。这是一个设计决策；通过增加几行代码，我也可以仅使用基础图像获得相同的结果。
- en: '![image](../images/f0228-02.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0228-02.jpg)'
- en: '*Figure 11-5: Composited images for the* monty_hall_gui.py *program*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-5：*monty_hall_gui.py* 程序的合成图像*'
- en: '***The Monty Hall Game Code***'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***蒙提霍尔游戏代码***'
- en: The *monty_hall_gui.py* program described in this section turns the Monty Hall
    problem into a fun and educational game. You will also need the 10 game assets
    shown in [Figure 11-5](ch11.xhtml#ch11fig5). Download them from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    and keep all the files in the same folder.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中描述的 *monty_hall_gui.py* 程序将蒙提霍尔问题转化为一个有趣且富有教育意义的游戏。你还需要[图 11-5](ch11.xhtml#ch11fig5)中显示的
    10 个游戏资产。请从 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载它们，并将所有文件保存在同一个文件夹中。
- en: '**Importing Modules and Defining the Game Class**'
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**导入模块并定义游戏类**'
- en: '[Listing 11-5](ch11.xhtml#ch11list5) imports modules and defines the Game class
    and the initialization method, __init__().'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-5](ch11.xhtml#ch11list5) 导入了模块并定义了游戏类和初始化方法 __init__()。'
- en: '*monty_hall_gui.py,* part 1'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*monty_hall_gui.py，* 第一部分'
- en: ➊ import random
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ import random
- en: import tkinter as tk
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: import tkinter as tk
- en: '➋ class Game(tk.Frame):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ class Game(tk.Frame):'
- en: '"""GUI application for Monty Hall Problem game."""'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '"""蒙提霍尔问题游戏的 GUI 应用程序。"""'
- en: ➌ doors = ('a', 'b', 'c')
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ doors = ('a', 'b', 'c')
- en: '➍ def __init__(self, parent):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ def __init__(self, parent):'
- en: '"""Initialize the frame."""'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '"""初始化框架。"""'
- en: ➎ super(Game, self).__init__(parent)  # parent will be the root window
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ super(Game, self).__init__(parent)  # 父对象将是根窗口
- en: ➏ self.parent = parent
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ self.parent = parent
- en: self.img_file = 'all_closed.png'  # current image of doors
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: self.img_file = 'all_closed.png'  # 当前的门图片
- en: self.choice = ''  # player's door choice
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: self.choice = ''  # 玩家选择的门
- en: self.winner = ''  # winning door
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: self.winner = ''  # 获胜的门
- en: self.reveal = ''  # revealed goat door
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: self.reveal = ''  # 揭示的山羊门
- en: ➐ self.first_choice_wins = 0  # counter for statistics
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ self.first_choice_wins = 0  # 统计用的计数器
- en: self.pick_change_wins = 0  # counter for statistics
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: self.pick_change_wins = 0  # 统计用的计数器
- en: ➑ self.create_widgets()
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ self.create_widgets()
- en: '*Listing 11-5: Imports modules and defines the* Game *class and* _ _init_ _()
    *method*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-5：导入模块并定义* Game *类和* _ _init_ _() *方法*'
- en: Start by importing the random and tkinter modules ➊. Next, define a class called
    Game ➋. The *ancestor* for this class, shown in parentheses, will be a tkinter
    Frame class. This means that the Game class is *derived* from the existing Frame
    “base” class and will conveniently inherit useful methods from it. The Frame widget
    mainly serves as a geometry master for other widgets, helping to group them into
    complex layouts.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入 random 和 tkinter 模块 ➊。接下来，定义一个名为 Game 的类 ➋。该类的 *祖先*，在括号中显示，将是 tkinter 的
    Frame 类。这意味着 Game 类是从现有的 Frame “基类”派生出来的，并且将方便地继承其中的有用方法。Frame 小部件主要作为其他小部件的几何布局管理器，帮助将它们组合成复杂的布局。
- en: Note that classes have their own docstring conventions, which you can find at
    *[https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/)*.
    As stated in [Chapter 1](ch01.xhtml#ch01), I will mainly show single-line docstrings
    in this book for brevity.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，类有其自己的文档字符串约定，您可以在 *[https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/)*
    找到相关信息。如[第1章](ch01.xhtml#ch01)所述，本书为了简洁起见，主要展示单行文档字符串。
- en: Every instance of Game will use the same three doors, so you can use a *class
    attribute* for this ➌. Any variable assigned a value outside of a method becomes
    a class attribute, much as variables assigned outside of functions in procedural
    programs become global variables. You don’t want this attribute to get changed
    inadvertently, so make it immutable by using a tuple. Later, you’ll make lists
    from this tuple whenever you want to manipulate the doors.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Game 实例将使用相同的三扇门，因此你可以使用 *类属性* 来表示这一点 ➌。任何在方法外部赋值的变量都会成为类属性，类似于程序性程序中在函数外部赋值的变量成为全局变量。为了防止该属性被意外修改，可以使用元组使其不可变。以后，当你想操作门时，可以从这个元组创建列表。
- en: Now, just as with the earlier dwarf and elf examples, define an initializer
    method for the game object ➍. A self parameter is required, but you’ll also need
    a parent, which will be the root window that will hold the game.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像之前的矮人和精灵示例一样，为游戏对象定义一个初始化方法 ➍。需要一个 self 参数，但你还需要一个父对象，即将承载游戏的根窗口。
- en: A base class can also be called a *superclass*, and the super() function lets
    you invoke the method of a superclass to gain access to inherited methods—in this
    case, from a parent class. First, pass Game to super(), which means you want to
    invoke a method of the superclass of Game, which is Frame ➎. Then pass it self
    as an argument to reference the newly instantiated Game object. The __init__(parent)
    part of the statement invokes the initializer method of Frame with parent (the
    root window) as the argument. Now attributes in the prebuilt tkinter Frame class
    can be used by your Game object. Note that this statement can be simplified to
    super().__init__().
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 基类也可以称为 *父类*，而 super() 函数让你调用父类的方法以访问继承的方法——在本例中，来自父类。首先，将 Game 传递给 super()，这意味着你希望调用
    Game 的父类 Frame 的方法 ➎。然后，将 self 作为参数传递，以引用新实例化的 Game 对象。语句中的 __init__(parent) 部分调用了
    Frame 的初始化方法，并将 parent（根窗口）作为参数传入。现在，预构建的 tkinter Frame 类中的属性可以被 Game 对象使用。请注意，这个语句可以简化为
    super().__init__()。
- en: Next, assign values to a series of instance attributes ➏. It is best to initialize
    attributes through the __init__() method, as it is the first method called after
    an object is created. This way, these attributes will be immediately available
    to any other methods in the class. Start by assigning the parent, which will be
    the root window, to the instance. Then name an attribute to hold one of the image
    files (shown in [Figure 11-5](ch11.xhtml#ch11fig5)) and assign it the image with
    all the doors closed, which is what the player will see at the start of each game.
    Next, name attributes for the player’s door choice, the winning door, and the
    door used to reveal the first goat.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Use a counter to keep track of the number of wins achieved if the player sticks
    with the first door choice and another to record wins achieved when the player
    switches doors ➐. Finally, call a method that will create the label, button, and
    text widgets needed to run the game ➑.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating Widgets for Images and Instructions**'
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 11-6](ch11.xhtml#ch11list6) defines the first part of the create_widgets()
    method, used to build the labels, buttons, and text widgets for the game. The
    first two widgets will be tkinter labels used to display the images in [Figure
    11-5](ch11.xhtml#ch11fig5) and to provide game instructions.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '*monty_hall_gui.py,* part 2'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def create_widgets(self):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '"""Create label, button, and text widgets for game."""'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '# create label to hold image of doors'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: ➋ img = tk.PhotoImage(file='all_closed.png')
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: ➌ self.photo_lbl = tk.Label(self.parent, image=img,
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: text='', borderwidth=0)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: ➍ self.photo_lbl.grid(row=0, column=0, columnspan=10, sticky='W')
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: ➎ self.photo_lbl.image = img
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '# create the instruction label'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: ➏ instr_input = [
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: ('Behind one door is CASH!', 1, 0, 5, 'W'),
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: ('Behind the others:  GOATS!!!', 2, 0, 5, 'W'),
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: ('Pick a door:', 1, 3, 1, 'E')
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '➐ for text, row, column, columnspan, sticky in instr_input:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: instr_lbl = tk.Label(self.parent, text=text)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: instr_lbl.grid(row=row, column=column, columnspan=columnspan,
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: sticky=sticky, ➑ipadx=30)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-6: Defines a method to create widgets*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Define a method, called create_widgets(), that takes self as an argument ➊.
    Then assign an attribute to hold an image of the doors ➋. Note that you don’t
    have to precede this attribute name with self, as it will be used only locally
    within the method. The PhotoImage class, which takes the image filename as an
    argument, is used by tkinter to display images in canvas, label, text, or button
    widgets. After this step, you can use the image in a tkinter label, so assign
    a photo_lbl variable, pass it the parent and image as arguments, and specify no
    text and a thin border ➌.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: To place the label in the parent window, use the grid() method and pass it the
    first row and first column, let the image span 10 columns, and left-justify it
    using W ➍. This will fill the top part of the window with the image of the closed
    doors. The columnspan option lets the widget span more than one column. The value
    won’t affect the image size but *will* change the number of locations available
    for placing the instruction text and other widgets below the image. For example,
    if you set columnspan=2, you’ll have only two columns available for placing instructions,
    buttons, and messages.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Finish the photo label by creating a reference to the image object ➎. If you
    don’t do this, the image won’t always show up.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: According to the tkinter documentation, tkinter is a layer built over another
    product (Tk), and the interface between the two doesn’t handle references to image
    objects properly. The Tk widget holds a reference to the internal object, but
    tkinter doesn’t. Python uses a garbage-collector module to automatically reclaim
    memory from objects no longer needed. When the garbage collector in Python’s memory
    allocator discards the tkinter object, tkinter tells Tk to release the image.
    But because it’s in use, Tk can’t, so it sets it to transparent instead. Suggestions
    for solving the problem include using a global variable, using an instance attribute,
    or as you did here, adding an attribute to the widget instance (photo_lbl.image
    = img). For more information, see *[http://effbot.org/tkinterbook/photoimage.htm](http://effbot.org/tkinterbook/photoimage.htm)*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Finally, add the instruction text as label widgets. The process is to provide
    a list of parameters and then loop through them to build the widgets. Start with
    a list of tuples ➏, where each tuple contains the options for making a Label object;
    you can see what each represents in the next statement ➐. As you progress through
    the for loop, create each label in the parent window and assign it some text.
    Then use the grid() method to place the text, based on the information in the
    list of tuples, into the window.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Use the ipadx option with grid() ➑. This option refers to internal padding in
    the x-direction within the label, so you can play with it to tweak the appearance
    of the text in the window. In this case, you add 30 pixels to the label so that
    the text will align in a visually pleasing way.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating Radio Buttons and Text Widgets**'
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 11-7](ch11.xhtml#ch11list7) continues the definition of the create_widgets()
    method by creating radio button widgets for the three doors. The player makes
    their initial door choice by selecting the A, B, or C radio button. Their choice
    is then processed by the win_reveal() method, which you’ll build later. This method
    will determine the winning door and reveal a goat.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Another set of radio buttons is created to get the player’s choice to switch
    doors or not. The result will be processed by the show_final() method, also defined
    later. Besides revealing what’s behind the player’s final door choice, this method
    will update the win statistics, using Text widgets defined at the end of this
    listing.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '*monty_hall_gui.py,* part 3'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '# create radio buttons for getting initial user choice'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: ➊ self.door_choice = tk.StringVar()
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: self.door_choice.set(None)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: ➋ a = tk.Radiobutton(self.parent, text='A', variable=self.door_choice,
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: value='a', command=self.win_reveal)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: b = tk.Radiobutton(self.parent, text='B', variable=self.door_choice,
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: value='b', command=self.win_reveal)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: c = tk.Radiobutton(self.parent, text='C', variable=self.door_choice,
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: value='c', command=self.win_reveal)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '# create widgets for changing door choice'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: ➌ self.change_door = tk.StringVar()
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: self.change_door.set(None)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: ➍ instr_lbl = tk.Label(self.parent, text='Change doors?')
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: instr_lbl.grid(row=2, column=3, columnspan=1, sticky='E')
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: ➎ self.yes = tk.Radiobutton(self.parent, state='disabled', text='Y',
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: variable=self.change_door, value='y',
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: command=self.show_final)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: self.no = tk.Radiobutton(self.parent, state='disabled', text='N',
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: variable=self.change_door, value='n',
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: command=self.show_final)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '# create text widgets for win statistics'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: ➏ defaultbg = self.parent.cget('bg')
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: ➐ self.unchanged_wins_txt = tk.Text(self.parent, width=20,
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: height=1, wrap=tk.WORD,
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: bg=defaultbg, fg='black',
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: borderwidth=0)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: self.changed_wins_txt = tk.Text(self.parent, width=20,
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: height=1, wrap=tk.WORD, bg=defaultbg,
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: fg='black', borderwidth=0)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-7: Builds radio buttons and text widgets for the* create_widgets()
    *method*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating radio buttons for doors A, B, and C. When a user interacts
    with a tkinter widget, the result is an *event*. You can use variables to track
    these events, such as when the player selects a door by pressing a radio button.
    For widget-specific variables, tkinter has a variable class. Use the *string*
    variable class, StringVar, and assign it to a variable named door_choice ➊. Immediately
    use the set() method to assign the variable a value of None.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Next, set up the button widgets for the three doors ➋. The player will click
    on one of these for their first door pick. Use the Radiobutton class and pass
    it the parent window, the text to display, the door_choice variable you just assigned,
    a value equal to the door name, and a command. The command calls the win_reveal()
    method, which you’ll define shortly. Note that you don’t include the parentheses
    after the method name.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Repeat this process for buttons B and C. This is mainly a cut-and-paste exercise,
    because all you need to change are the door designations.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Now, build the radio buttons for switching doors. Start by making another string
    variable, as you did for the initial door choice ➌. This will hold either y or
    n, depending on which radio button is selected.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Build an instruction label using the Label class ➍. Then build the self.yes
    radio button ➎. Use the Radiobutton class, pass it the parent window, and set
    its state to disabled. This way, the window will initialize with the yes/no buttons
    grayed out, so the player can’t jump the gun and try to change a door before first
    choosing one. The text parameter is the button name; use an abbreviated Y for
    *yes*. Set the widget’s variable argument to the change_door variable, set its
    value to y, and call the show_final() function. Repeat the process for the no
    button.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: The last widgets you’ll need are Text widgets to show the counts for switching
    doors versus staying put. Use the Text class to display the statistics and set
    the text box color to match the parent window. To do this, use cget() to get the
    background (bg) color of parent and then assign it to a variable ➏. The cget()
    method returns the current value for a tkinter option as a string.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Create a text object to display the wins for sticking with the first choice
    ➐. You need to pass the widget the parent window, a width and height, how to wrap
    text if it extends beyond a row, a background color, a foreground color—the text
    color—and a border width for the text box. Note that you don’t include any actual
    text; this will be added later by the show_final() method.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Finish with another text widget to display the number of wins attributed to
    switching doors.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '**Arranging the Widgets**'
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 11-8](ch11.xhtml#ch11list8) completes the create_widgets() method
    by using the tkinter Grid geometry manager to position the remaining nongridded
    widgets in the game window.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '*monty_hall_gui.py,* part 4'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '# place the widgets in the frame'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: ➊ a.grid(row=1, column=4, sticky='W', padx=20)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: b.grid(row=1, column=4, sticky='N', padx=20)
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: c.grid(row=1, column=4, sticky='E', padx=20)
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: self.yes.grid(row=2, column=4, sticky='W', padx=20)
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: self.no.grid(row=2, column=4, sticky='N', padx=20)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: ➋ self.unchanged_wins_txt.grid(row=1, column=5, columnspan=5)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: self.changed_wins_txt.grid(row=2, column=5, columnspan=5)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-8: Calls the* grid() *method on the widgets to position them in
    the frame*'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Use grid() to position the door buttons in the parent window ➊. Group the three
    door buttons together in the same row and column and separate them using the sticky
    justification: W means left, N is center, and E is right. Use padx to tweak the
    positions laterally. Repeat this process for the remaining buttons, then position
    the win statistics text widgets and allow them to span the five columns on the
    right side of the window ➋.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '**Updating the Door Image**'
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You’ll need to open and close doors throughout the game, so [Listing 11-9](ch11.xhtml#ch11list9)
    defines a helper method to update the door image as appropriate. Note that, with
    OOP, you don’t need to pass a filename to the method as an argument. All the methods
    for an object have direct access to attributes that begin with self.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '*monty_hall_gui.py,* part 5'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def update_image(self):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '"""Update current doors image."""'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: ➋ img = tk.PhotoImage(file=self.img_file)
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: ➌ self.photo_lbl.configure(image=img)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: ➍ self.photo_lbl.image = img
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-9: Defines a method to update the current door image*'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Define a function, called update_image(), that takes self as an argument ➊.
    Then use the PhotoImage class as you did in [Listing 11-6](ch11.xhtml#ch11list6)
    ➋. The filename, *self.img_file*, will be updated in other methods.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Because you’ve already created the label that holds the door image, use the
    configure() method to change the label—in this case, by loading a new image ➌.
    You can use either configure() or config(). Finish by assigning the image to a
    widget attribute to fend off garbage collection ➍, as described for [Listing 11-6](ch11.xhtml#ch11list6).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '**Selecting the Winning Door and Revealing a Goat**'
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 11-10](ch11.xhtml#ch11list10) defines a method that selects the winning
    door and the reveal door and then opens and closes the reveal door. It also activates
    the yes/no buttons, which are grayed out until the player makes their first door
    choice.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '*monty_hall_gui.py,* part 6'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def win_reveal(self):'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '"""Randomly pick winner and reveal unchosen door with goat."""'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: ➋ door_list = list(self.doors)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: ➌ self.choice = self.door_choice.get()
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: self.winner = random.choice(door_list)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: ➍ door_list.remove(self.winner)
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '➎ if self.choice in door_list:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: door_list.remove(self.choice)
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: self.reveal = door_list[0]
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: self.reveal = random.choice(door_list)
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: ➏ self.img_file = ('reveal_{}.png'.format(self.reveal))
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: self.update_image()
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '# turn on and clear yes/no buttons'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: ➐ self.yes.config(state='normal')
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: self.no.config(state='normal')
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: self.change_door.set(None)
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '# close doors 2 seconds after opening'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: ➑ self.img_file = 'all_closed.png'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: self.parent.after(2000, self.update_image)
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-10: Defines a method to randomly select the winning door and reveal
    door*'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Define a method, called win_reveal(), that takes self as an argument ➊. Immediately
    make a list of the doors from the class attribute doors ➋. You’ll alter this list
    based on the player’s first door choice and then the winning door, picked at random
    by the program.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Now, assign a self.choice attribute to the self.door_choice string variable,
    accessed with the get() method ➌. The value of this attribute was determined by
    the door radio button that the user clicked as their first choice. Next, choose
    the winning door, at random, from the door list.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Remove the winning door from the door list ➍. Then use a conditional to see
    whether the player’s choice is still in the door list; if it is, remove it so
    that it can’t be revealed ➎. This will leave only one door in the list, so assign
    it to the self.reveal attribute.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: If the player picked the winning door, there are two doors left in the list,
    so randomly choose one of them and assign it to self.reveal. Update the self.img_file
    attribute for this door ➏, then call the method that updates the photo label to
    show the new image. [Figure 11-6](ch11.xhtml#ch11fig6) is an example of the reveal
    image for door B.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0235-01.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: The reveal image for Door B*'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Next, set the state of the yes and no buttons to normal ➐. After this, they
    will no longer be grayed out. End the method by changing the image file to *all_closed.png*
    and calling the self.update_image() method on the parent window after 2,000 milliseconds
    have elapsed ➑. This will ensure the doors stay open no longer than 2 seconds.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '**Revealing the Player’s Final Choice**'
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 11-11](ch11.xhtml#ch11list11) defines the first part of a function
    that takes the player’s final door choice and reveals what’s behind it. The function
    will also keep track of the number of wins for switching doors or staying put.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '*monty_hall_gui.py,* part 7'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '➊ def show_final(self):'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '"""Reveal image behind user''s final door choice & count wins."""'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: ➋ door_list = list(self.doors)
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: ➌ switch_doors = self.change_door.get()
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '➍ if switch_doors == ''y'':'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: door_list.remove(self.choice)
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: door_list.remove(self.reveal)
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: ➎ new_pick = door_list[0]
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '➏ if new_pick == self.winner:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: self.img_file = 'money_{}.png'.format(new_pick)
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: self.pick_change_wins += 1
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: self.img_file = 'goat_{}.png'.format(new_pick)
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: self.first_choice_wins += 1
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '➐ elif switch_doors == ''n'':'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '➑ if self.choice == self.winner:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: self.img_file = 'money_{}.png'.format(self.choice)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: self.first_choice_wins += 1
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: self.img_file = 'goat_{}.png'.format(self.choice)
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: self.pick_change_wins += 1
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '# update door image'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: ➒ self.update_image()
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-11: Defines a method to reveal the player’s final choice and update
    win lists*'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Define a method, called show_final(), that takes—you guessed it—self as an argument
    ➊. Make a new copy of the door list ➋, then get the self.change_doors variable
    and assign it to an attribute named switch_doors ➌. This variable will hold either
    a 'y' or an 'n', depending on which radio button the player clicked.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: If the player chose to switch doors ➍, remove their first choice and the revealed
    door from the list and assign a new_pick attribute to the remaining door ➎. If
    this new pick is the winning door ➏, reference the proper image and advance the
    self.pick_change_wins counter. Otherwise, set the image to a goat and advance
    the self.first_choice_wins counter.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: If the player decides to not change doors ➐ and if their first choice was the
    winning door ➑, reveal the money bag and advance the self.first_choice_wins counter.
    Otherwise, show a goat and advance the self.pick_change_wins counter.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Finish by calling the update_image() method to update the image ➒. Again, you
    don’t need to pass it the name of the new image file, as it can access the self.img_file
    attribute that you changed in the preceding code.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '**Displaying Statistics**'
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 11-12](ch11.xhtml#ch11list12) completes the show_final() method by
    updating the game window for the number of wins statistics, disabling the yes/no
    buttons, and closing all the doors.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '*monty_hall_gui.py,* part 8'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '# update displayed statistics'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: ➊ self.unchanged_wins_txt.delete(1.0, 'end')
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: ➋ self.unchanged_wins_txt.insert(1.0, 'Unchanged wins = {:d}'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: .format(self.first_choice_wins))
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: self.changed_wins_txt.delete(1.0, 'end')
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: self.changed_wins_txt.insert(1.0, 'Changed wins = {:d}'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: .format(self.pick_change_wins))
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '# turn off yes/no buttons and clear door choice buttons'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: ➌ self.yes.config(state='disabled')
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: self.no.config(state='disabled')
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: ➍ self.door_choice.set(None)
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '➎ # close doors 2 seconds after opening'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: self.img_file = 'all_closed.png'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: self.parent.after(2000, self.update_image)
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-12: Displays win statistics, disables the yes/no buttons, and closes
    all the doors*'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Start by deleting any text in the self.unchanged_wins_txt text widget ➊. Begin
    deleting at a text index of 1.0. The format is line.column, so you are specifying
    the first line and first column of the text widget (line numbering starts at 1,
    column numbering at 0). Finish with 'end', which will ensure that all the text
    after the starting index is deleted.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Next, use the insert() method to add the self.first_choice_wins attribute value,
    along with some descriptive text, to the text widget ➋. Begin inserting at text
    index 1.0.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Repeat this process for the self.changed_wins_txt text widget, and then disable
    the yes/no buttons by setting their config state to 'disabled' ➌. Set the self.door_choice
    string variable back to None, and you’re ready to start a new game ➍.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: End the method by closing the doors, as you did in [Listing 11-10](ch11.xhtml#ch11list10)
    ➎.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting Up the Root Window and Running the Event Loop**'
  id: totrans-411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 11-13](ch11.xhtml#ch11list13) completes the *monty_hall_gui.py* program
    by setting up the tkinter root window, instantiating the game object, and running
    mainloop(). Alternatively, this code could be encapsulated in a main() function.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '*monty_hall_gui.py,* part 9'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '# set up root window & run event loop'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: ➊ root = tk.Tk()
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: ➋ root.title('Monty Hall Problem')
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: ➌ root.geometry('1280x820')  # pics are 1280 x 720
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: ➍ game = Game(root)
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: root.mainloop()
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 11-13: Sets up the* root *window, creates a game object, and runs*
    mainloop()'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: The Tk class is instantiated without arguments ➊. This creates a top-level tkinter
    widget, which will be the main window of the game application. Assign it to a
    variable named root.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Give the window a title ➋ and a size in pixels ➌. Note that the size of the
    images influences the geometry so that they fit attractively in the window, with
    ample room below for instructions and messages.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Now, create the game ➍. Pass it the root window, which will be the *master*
    that will contain the game. This results in a new game being placed inside the
    root window.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Finish by invoking the mainloop() method on root, which keeps the window open
    and waiting to handle events.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you used a simple Monte Carlo simulation to confirm that switching
    doors is the best strategy for the Monty Hall problem. You then used tkinter to
    build a fun interface to let schoolchildren test this conclusion manually, game
    by game. Best of all, you learned how to use object-oriented programming to build
    interactive widgets that respond to user input.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Useful tkinter references can be found in “[Further Reading](ch10.xhtml#lev241)”
    on [page 212](ch10.xhtml#page_212).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: You can find a summary of the 1990 Monty Hall problem controversy online at
    *[http://marilynvossavant.com/game-show-problem/](http://marilynvossavant.com/game-show-problem/)*.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: The Birthday Paradox**'
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How many people need to be in a room for there to be a 50/50 chance that two
    of them share the same birth month and day? According to the *birthday paradox*,
    not that many! As with the Monty Hall problem, the outcome is counterintuitive.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Use MCS to determine how many people it takes to reach the 50 percent mark.
    Have the program print out the number of people and the probability for a range
    of room occupants. If you find yourself looking up how to format dates, stop and
    simplify! You can find a solution, *birthday_paradox_practice.py*, in the appendix
    or online at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
