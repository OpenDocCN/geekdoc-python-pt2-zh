- en: '**11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11'
- en: THE MONTY HALL PROBLEM**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**蒙提霍尔问题**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: 'As host of the TV game show *Let’s Make a Deal*, Monty Hall would show contestants
    three closed doors and ask them to choose one. Behind one door was a valuable
    prize; behind the other two were smelly old goats. As soon as the contestant chose
    a door, Monty would open one of the remaining doors to reveal a goat. The contestant
    was then given a final choice: switch doors or stay with their initial pick.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为电视游戏节目《*让我们做交易*》的主持人，蒙提·霍尔会给参赛者展示三扇关闭的门，并要求他们选择其中一扇。背后有一个珍贵的奖品；另外两扇门后面是臭臭的山羊。参赛者一选择了门，蒙提就会打开剩下的其中一扇，露出一只山羊。然后，参赛者会得到最后的选择：换门还是坚持原来的选择。
- en: In 1990, Marilyn vos Savant, “the world’s smartest woman,” stated in her weekly
    *Parade* magazine column, “Ask Marilyn,” that the contestant should choose to
    switch doors. Though her answer was correct, it ignited a firestorm of hate mail,
    gender profiling, and academic persecution. Many math professors embarrassed themselves
    in the process, but there was a bright side to the ugly affair. The heated discussion
    exposed the public to the science of statistics, and an exercise that vos Savant
    proposed found its way into thousands of classrooms. These manual tests—later
    duplicated by computers—all vindicated her derided “female logic.”
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在1990年，"世界上最聪明的女人"玛丽琳·沃斯·萨万特在她的周刊《*Parade*》杂志专栏《问玛丽琳》中表示，参赛者应该选择换门。尽管她的答案是正确的，但却引发了一场关于仇恨邮件、性别刻板印象和学术迫害的风暴。许多数学教授在这个过程中让自己尴尬，但这场丑陋事件也有光明的一面。激烈的讨论让公众接触到了统计学的科学，沃斯·萨万特提出的一个练习也进入了成千上万的课堂。这些手动测试——后来被计算机复制——都证实了她被嘲笑的“女性逻辑”是正确的。
- en: In this chapter, you’ll use *Monte Carlo simulation (MCS)*, a method for modeling
    the probability of different outcomes from a range of random inputs, to verify
    that vos Savant was right. After that, you’ll use `tkinter` to build a fun graphical
    interface that addresses her request for schoolchildren to help with the experiment.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将使用*蒙特卡洛模拟（MCS）*，这是一种通过对一系列随机输入的不同结果建模来验证沃斯·萨万特是对的。之后，你将使用`tkinter`来构建一个有趣的图形界面，来响应她要求学生们帮助做实验的请求。
- en: '**Monte Carlo Simulation**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**蒙特卡洛模拟**'
- en: Imagine you want to know the probability of rolling a die six times and getting
    a different face with each roll. If you’re a math whiz, you’d probably just compute
    this using the deterministic equation 6! / 6⁶ or
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想知道掷骰子六次，每次都得到不同的面朝上的概率。如果你是数学天才，你可能会直接使用确定性公式6! / 6⁶来计算，或者
- en: '![image](../images/f0218-01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0218-01.jpg)'
- en: 'yielding 0.015\. If you’re not so mathematically inclined, you could get the
    same answer with Python and a lot of rolls:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 得到0.015。如果你不那么擅长数学，也可以通过Python和大量掷骰子得到相同的答案：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This example uses a `for` loop and `randint` to randomly pick a number between
    1 and 6, representing one of the faces on the die, six times in a row. It adds
    each result to a set named `faces`, which doesn’t permit duplicates. The only
    way for the length of the set to reach 6 is if each roll yields a unique number,
    which equals a success case. An outer `for` loop performs the six-roll trial 100,000
    times. Dividing the number of successes by the number of trials yields the same
    probability, 0.015, as the deterministic equation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用了`for`循环和`randint`函数，随机选择1到6之间的一个数字，代表骰子的一面，并重复6次。它将每个结果添加到名为`faces`的集合中，该集合不允许重复。集合长度达到6的唯一方式是每次掷骰子都会得到一个唯一的数字，这样就算作一次成功。外层的`for`循环会执行这个六次掷骰子的实验100,000次。成功次数与实验次数的比值就是与确定性公式相同的概率0.015。
- en: Monte Carlo simulation uses *repeated random sampling*—in this case, each roll
    of the die is a random sample—to predict different outcomes under a specified
    range of conditions. For this example, the range of conditions was one six-faced
    die, six rolls with no repeats per trial, and 100,000 trials. Of course, MCS is
    usually applied to more complex problems—those with lots of variables and wide
    ranges of uncertainty, where the results cannot be easily predicted.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡洛模拟使用*重复随机抽样*——在这个例子中，每一次掷骰子就是一次随机抽样——来预测在指定条件范围下的不同结果。在这个例子中，条件范围是一个六面骰子，每次掷骰子没有重复，进行100,000次试验。当然，MCS通常应用于更复杂的问题——那些有许多变量和不确定性范围广的问题，其结果无法轻易预测。
- en: 'There are multiple types of MCS, but most applications follow these basic steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种类型的MCS，但大多数应用遵循以下基本步骤：
- en: List the input variables.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出输入变量。
- en: Provide a probability distribution for each variable.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个变量提供概率分布。
- en: 'Start a loop:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动循环：
- en: Randomly select a value from the distributions for each input.
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从每个输入的分布中随机选择一个值。
- en: Use the values in a deterministic calculation, which is a calculation that will
    always produce the same output from the same input.
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用确定性计算中的值，确定性计算是一种总是从相同输入产生相同输出的计算。
- en: Repeat a specified number of times.
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复指定的次数。
- en: Aggregate the results and generate statistics, such as the average outcome for
    the calculation.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合结果并生成统计数据，例如计算的平均结果。
- en: 'For the die-roll example, these steps were:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于掷骰子的示例，步骤如下：
- en: Input variables = the results of six die rolls.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入变量 = 六次掷骰子的结果。
- en: Probability distribution for roll = uniform (1/6 for each face).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投掷概率分布 = 均匀分布（每个面朝上的概率为 1/6）。
- en: 'Loop:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环：
- en: Randomly selected value = die roll (draw from distribution).
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机选择的值 = 掷骰子结果（从分布中抽取）。
- en: Calculation = add the six values to a set and, if set length equals 6, add 1
    to `success` variable.
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算 = 将六个值添加到一个集合中，并且如果集合的长度等于 6，则将 `success` 变量加 1。
- en: Repeat = 100,000 times.
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复 = 100,000 次。
- en: 'Aggregate: divide `success` variable by 100,0000 for probability calculation.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合：将 `success` 变量除以 100,0000 以计算概率。
- en: Nassim Taleb, the critically acclaimed author of *The Black Swan* and *Fooled
    by Randomness*, is a fan of MCS. He posits that our brains are designed to get
    us out of trouble quickly, rather than handle complicated uncertainty or probability
    problems. We aren’t cut out for highly skewed distributions and nonlinearities,
    but some people’s brains are inherently more capable of understanding risks using
    MCS than other methods. In real life, we don’t observe probability distributions;
    we just observe events.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 纳西姆·塔勒布（Nassim Taleb），《黑天鹅》和《随机的愚弄》一书的广受好评作者，是 MCS 的支持者。他认为我们的大脑是为了迅速摆脱困境而设计的，而不是处理复杂的不确定性或概率问题。我们不擅长处理高度偏斜的分布和非线性，但有些人的大脑天生更能够通过
    MCS 理解风险，而不是其他方法。在现实生活中，我们不会观察概率分布；我们只是观察事件。
- en: Each MCS run represents a single event, such as whether you run out of money
    in retirement. For many of us, MCS makes risk real. It helps us understand how
    bad or good things can be—something we can’t always glean from mathematical abstractions.
    With the insight from MCS, we can prepare to both defend against the downside
    and exploit the upside.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每次 MCS 运行代表一个单一事件，例如你在退休期间是否会用完钱。对于许多人来说，MCS 使风险变得真实。它帮助我们理解事情可能变得多糟或多好——这是我们无法仅从数学抽象中得到的。通过
    MCS 获得的洞察力，我们可以为防范风险和利用机遇做好准备。
- en: To support the math behind the Monty Hall problem, you’ll use an MCS application
    like the preceding die-roll example. Then, in [Chapter 12](ch12.xhtml#ch12), you’ll
    use MCS to build a nest-egg simulator to plan your (or your parents’) secure retirement.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持蒙提霍尔问题背后的数学原理，你将使用如前面的掷骰子示例这样的 MCS 应用。然后，在[第 12 章](ch12.xhtml#ch12)中，你将使用
    MCS 构建一个退休金模拟器，规划你（或你父母）的安全退休生活。
- en: '**Project #18: Verify vos Savant**'
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #18：验证 vos Savant**'
- en: To verify that vos Savant was right, use a Monte Carlo approach and simulate
    tens of thousands of “games” in order to see how things shake out. This can be
    a bare-bones program, since the goal is a simple confirmation with no embellishments.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证 vos Savant 的说法是否正确，使用蒙特卡洛方法模拟成千上万次“游戏”，以观察结果如何。这可以是一个简化的程序，因为目标只是简单地确认，没有任何附加内容。
- en: '**THE OBJECTIVE**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Write a simple Python program that uses Monte Carlo simulation to determine
    the probability of winning the Monty Hall problem by changing the initial pick.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个简单的 Python 程序，使用蒙特卡洛模拟来确定通过更改初始选择来赢得蒙提霍尔问题的概率。
- en: '***The Strategy***'
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: The correct response to the Monty Hall problem is to switch doors after Monty
    reveals the goat. Statistically, this will double your chances of winning!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙提霍尔问题的正确解答是在蒙提揭示了山羊后换门。从统计学角度来看，这将使你赢的机会翻倍！
- en: Look at [Figure 11-1](ch11.xhtml#ch11fig1). At the start of the game, all the
    doors are closed, and the odds of a given door hiding the prize are 1 in 3\. The
    user can choose only one door, which means the odds of the prize being behind
    one of the other two doors are 2 in 3\. After the goat is revealed, the odds remain
    2 in 3, but they revert to the remaining door. Remember, Monty knows where the
    prize is hidden, and he will never reveal *that* door. So the probability of success
    is 1/3 for staying with your first choice versus 2/3 for switching.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[图11-1](ch11.xhtml#ch11fig1)。在游戏开始时，所有的门都是关闭的，每个门隐藏奖品的概率是1/3。用户只能选择一扇门，这意味着奖品隐藏在其他两扇门中的概率是2/3。在揭示羊之后，概率仍然是2/3，但它会转移到剩下的那扇门。记住，蒙提知道奖品在哪里隐藏，并且他永远不会揭示*那个*门。所以，留在原选择的成功概率是1/3，而切换选择的成功概率是2/3。
- en: '![image](../images/f0220-01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0220-01.jpg)'
- en: '*Figure 11-1: Odds of winning the Monty Hall problem before and after a goat
    is revealed*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-1：蒙提霍尔问题在揭示羊之后的获胜概率*'
- en: If you’re dubious about the math, you can use MCS to provide corroborating evidence,
    just as we did with the die-roll example. You simply need to pick a winning door
    at random, choose a contestant’s pick at random, and record how many times the
    two coincide. Repeat this thousands of times, and you will converge on the deterministic
    mathematical solution.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对数学计算有疑虑，你可以使用MCS来提供支持证据，就像我们在掷骰子示例中所做的那样。你只需随机选择一扇中奖门，随机选择一个参赛者的选择，并记录两者匹配的次数。重复这个过程数千次，你将会收敛到确定性的数学解。
- en: '***The vos Savant Verification Code***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Vos Savant验证代码***'
- en: The *monty_hall_mcs.py* program described in this section will automate the
    process of choosing doors and recording the results so that you can run thousands
    of trials and evaluate them in less than a second. You can download the code from
    *[https://www.nostarch.com/impracticalpython.com/](https://www.nostarch.com/impracticalpython.com/)*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中描述的*monty_hall_mcs.py*程序将自动化选择门和记录结果的过程，使你能够运行数千次试验并在不到一秒钟的时间内评估它们。你可以从*[https://www.nostarch.com/impracticalpython.com/](https://www.nostarch.com/impracticalpython.com/)*下载代码。
- en: '**Getting the Number of Runs Input**'
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**获取运行次数输入**'
- en: '[Listing 11-1](ch11.xhtml#ch11list1) starts the *monty_hall_mcs.py* program
    by asking the user how many runs—or games—they want to simulate. You’ll also provide
    the user with a default value. This is a great way to guide a user to a reasonable
    first response, as well as save them a few keystrokes.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单11-1](ch11.xhtml#ch11list1)通过询问用户他们希望模拟多少次运行（或游戏）来启动*monty_hall_mcs.py*程序。你还会为用户提供一个默认值。这是引导用户给出合理首次回应的好方法，同时也能节省他们一些按键操作。'
- en: '*monty_hall_mcs.py,* part 1'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*monty_hall_mcs.py*，第1部分'
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 11-1: Imports modules and defines the* user_prompt() *function*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单11-1：导入模块并定义* user_prompt() *函数*'
- en: Start by importing the `random` module to run MCS ➊. Next, define a function,
    called `user_prompt()`, that asks the user to either input the number of games
    to run or else accept a default value, if provided ➋. This function takes two
    arguments; the first is the text prompt that tells the user what to do, and the
    second is the default value, which will start out as `None`. Immediately redefine
    the `prompt` variable so that it will display with the default value in brackets,
    per convention ➌. Assign the user’s input to a variable named `response` ➍. If
    the user presses ENTER without providing any input and a default value exists,
    the `user_prompt()` function will return the default value ➎. Otherwise, the function
    returns the user’s input. Use the function to determine the number of runs to
    make by assigning the returned value to the `num_runs` variable ➏. Each run will
    represent a contestant playing the game once.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入`random`模块以运行MCS ➊。接下来，定义一个名为`user_prompt()`的函数，提示用户输入要运行的游戏次数，或者在提供默认值的情况下接受默认值
    ➋。此函数接受两个参数；第一个是提示用户执行操作的文本，第二个是默认值，初始值为`None`。立即重新定义`prompt`变量，以便按照约定在括号中显示默认值
    ➌。将用户的输入赋值给名为`response`的变量 ➍。如果用户按下ENTER键而没有输入任何内容，并且存在默认值，`user_prompt()`函数将返回默认值
    ➎。否则，函数将返回用户的输入。使用此函数通过将返回值赋给`num_runs`变量来确定运行的次数 ➏。每次运行将代表一个参赛者进行一次游戏。
- en: '**Running MCS and Displaying the Results**'
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**运行MCS并显示结果**'
- en: '[Listing 11-2](ch11.xhtml#ch11list2) picks the winning door and the user’s
    first choice at random, then aggregates and presents the statistics. Interestingly,
    the user’s second choice—to switch doors or not—isn’t required to get the correct
    answer. If the initial choice is the winning door, the correct answer is to not
    change doors. Likewise, if the initial choice and the winning door differ, the
    correct answer is to change doors. There’s no reason to model what a contestant
    might or might not do.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-2](ch11.xhtml#ch11list2) 随机选择获胜的门和用户的第一次选择，然后汇总并展示统计数据。有趣的是，用户的第二次选择——是否换门——并不是获得正确答案所必需的。如果最初选择的是获胜的门，正确答案是不要换门。同样，如果最初选择和获胜的门不同，正确答案是换门。没有必要模拟参赛者可能会做什么或不做什么。'
- en: '*monty_hall_mcs.py,* part 2'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*monty_hall_mcs.py*，第 2 部分'
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 11-2: Runs the Monte Carlo simulation and displays the results*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-2：运行蒙特卡洛模拟并展示结果*'
- en: Assign two variables to keep track of whether switching or staying put is the
    winning outcome ➊. Then, create a list to represent the three doors ➋.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 分配两个变量来跟踪切换或不切换是否是获胜的结果 ➊。然后，创建一个列表来表示三个门 ➋。
- en: MCS starts with a `for` loop that goes through the number of runs ➌. Inside
    that loop, choose the winning door and the user’s first choice from the `doors`
    list, using `random.choice()`, and assign them to variables.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: MCS 从一个 `for` 循环开始，该循环遍历运行次数 ➌。在该循环内部，使用 `random.choice()` 从 `doors` 列表中选择获胜的门和用户的第一次选择，并将它们分配给变量。
- en: Since this is a binary system—the user switches or doesn’t—you’ll only need
    a conditional that adds to the counters based on the relationship of the `pick`
    variable to the `winning` variable ➍.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个二进制系统——用户切换或者不切换——你只需要一个条件，根据 `pick` 变量和 `winning` 变量的关系来增加计数器 ➍。
- en: Finish the program by presenting the final results. Display the actual counts,
    plus the calculated probabilities ➎. Then let the user know the program is finished
    ➏.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 完成程序，展示最终结果。显示实际的计数值，以及计算出的概率 ➎。然后，让用户知道程序已经完成 ➏。
- en: 'Here’s an example output for the default 20,000 runs:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认情况下 20,000 次运行的示例输出：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Some people aren’t impressed with a computer printout. They need something more
    convincing, so in the next project, you’ll repackage your code in a more hands-on
    format—one that’s complete with doors, prizes, and goats. This will also satisfy
    Marilyn vos Savant’s appeal for schoolchildren to join in and help restore her
    honor.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人对计算机打印输出不感兴趣，他们需要更有说服力的东西。所以在下一个项目中，你将以更具互动性的方式重新包装代码——包括门、奖品和山羊。这样也能满足 Marilyn
    vos Savant 对学童参与并帮助恢复她的荣誉的呼吁。
- en: '**Project #19: The Monty Hall Game**'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #19：蒙提霍尔游戏**'
- en: The three-door game used in the Monty Hall problem is simple enough for you
    to build with `tkinter`. You began working with `tkinter` graphics in [Chapter
    10](ch10.xhtml#ch10). Now you’ll build on this knowledge by adding interactive
    buttons for the user to click.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙提霍尔问题中的三扇门游戏足够简单，你可以使用 `tkinter` 构建。你在[第 10 章](ch10.xhtml#ch10)中已经开始使用 `tkinter`
    图形界面。现在，你将通过添加交互按钮让用户点击来进一步构建这些知识。
- en: '**THE OBJECTIVE**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Simulate the Monty Hall problem using a GUI built with `tkinter`. Keep track
    of whether switching doors or staying put results in a win. In addition, update
    and display these statistics as the game is played.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `tkinter` 构建的 GUI 模拟蒙提霍尔问题。跟踪切换门或保持不变是否会导致获胜。此外，在游戏进行时更新并展示这些统计数据。
- en: '***A Brief Introduction to Object-Oriented Programming***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***面向对象编程简介***'
- en: The `tkinter` module was written using *object-oriented programming (OOP)*.
    OOP is a language model built around data structures, known as *objects*, consisting
    of *data* and *methods* and the interactions between them—as opposed to the *actions*
    and *logic* used in procedural programming. Objects are built from *classes*,
    which are like blueprints for the objects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`tkinter` 模块是使用*面向对象编程（OOP）*编写的。OOP 是一种围绕数据结构构建的语言模型，这些数据结构称为*对象*，由*数据*和*方法*以及它们之间的交互组成——与过程式编程中使用的*操作*和*逻辑*不同。对象是由*类*构建的，类就像是对象的蓝图。'
- en: OOP is an abstract concept and easier to appreciate when you’re writing large,
    complex programs. It reduces code duplication and makes code easier to update,
    maintain, and reuse. As a result, most commercial software is now built using
    OOP.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: OOP 是一个抽象的概念，写大型复杂程序时更容易理解。它减少了代码重复，使代码更容易更新、维护和重用。因此，现在大多数商业软件都是使用 OOP 构建的。
- en: 'If you implemented OOP in small programs, like the ones we’ve written so far,
    most of them would feel overengineered. In fact, one of my all-time favorite quotes,
    attributed to British computer scientist Joe Armstrong, concerns this aspect of
    OOP: “The problem with object-oriented languages is they’ve got all this implicit
    environment that they carry around with them. You wanted a banana, but what you
    got was a gorilla holding the banana and the entire jungle!”'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在小程序中实现了面向对象编程（OOP），就像我们到目前为止写的那些程序，大部分程序会显得过于复杂。事实上，我最喜欢的一句名言，来自英国计算机科学家乔·阿姆斯特朗，正是关于OOP的这一方面：“面向对象语言的问题在于它们携带了所有这些隐式环境。你想要的是一根香蕉，但你得到的是一只拿着香蕉和整个丛林的猩猩！”
- en: Despite this, the objects produced by OOP lend themselves very well to GUIs
    and gaming, even for some small projects. Let’s look at an example using a *Dungeons
    and Dragons*–type board game in which players can be different characters, such
    as dwarves, elves, and wizards. These games use character cards to list important
    information for each character type. If you let your playing piece represent a
    dwarf, it inherits the characteristics on the card (see [Figure 11-2](ch11.xhtml#ch11fig2)).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，OOP生成的对象非常适合图形用户界面（GUI）和游戏，甚至适用于一些小型项目。我们来看一个例子，使用类似《龙与地下城》类型的桌面游戏，在游戏中玩家可以扮演不同的角色，比如矮人、精灵和巫师。这些游戏使用角色卡来列出每个角色类型的重要信息。如果你让你的棋子代表一个矮人，它将继承卡片上的特征（见[图11-2](ch11.xhtml#ch11fig2)）。
- en: '![image](../images/f0224-01.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0224-01.jpg)'
- en: '*Figure 11-2: A dwarf character card from a role-playing board game*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-2：角色扮演桌游中的矮人角色卡*'
- en: '[Listings 11-3](ch11.xhtml#ch11list3) and [11-4](ch11.xhtml#ch11list4) reproduce
    board game–style play, letting you create virtual cards for a dwarf and an elf,
    name your pieces, and have them fight. The outcome of the fight will impact one
    of the character’s *body points*, which represent the character’s health. Be sure
    to note how OOP can allow you to easily create many identical objects—in this
    case, dwarves or elves—by “stamping” them out of the predefined template, called
    a *class*.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单11-3](ch11.xhtml#ch11list3)和[11-4](ch11.xhtml#ch11list4)再现了桌游风格的玩法，让你创建虚拟卡片，表示矮人和精灵，命名你的棋子并让它们进行战斗。战斗的结果将影响其中一个角色的*生命值*，即角色的健康状况。请务必注意，OOP可以让你轻松创建许多相同的对象——在这种情况下，是矮人或精灵——通过从预定义的模板“打印”它们，这个模板叫做*类*。'
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 11-3: Imports* random *module, creates a* Dwarf *class, and instantiates
    a dwarf object*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单11-3：导入* random *模块，创建一个* Dwarf *类，并实例化一个矮人对象*'
- en: Start by importing `random` to simulate rolling a die ➊; this is how your character
    will fight. Now define a class for a dwarf character, capitalizing the first letter
    of the class name, and pass it an `object` argument, which will be the name of
    your dwarf ➋. A class is a template for creating objects of a certain type. For
    example, when you create a list or dictionary, you are creating them from a class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入`random`模块来模拟掷骰子 ➊；这将是你角色战斗的方式。现在定义一个矮人角色的类，将类名的首字母大写，并传递一个`object`参数，这将是你的矮人名字
    ➋。类是创建某种类型对象的模板。例如，当你创建一个列表或字典时，你是在从一个类创建它们。
- en: The `Dwarf` class definition is like the card in [Figure 11-2](ch11.xhtml#ch11fig2);
    it is basically the genetic blueprint for a dwarf. It will assign *attributes*,
    like strength and vitality, and *methods*, like how the character moves or talks.
    Attributes are variables scoped to an *instance* of the class, and methods are
    attributes that also happen to be functions, which are passed a reference to their
    instance when they run. A class is a data type, and when you create an object
    of that data type, it is also known as an instance of that class. The process
    of setting the initial values and behaviors of the instance is called *instantiation*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dwarf`类的定义就像[图11-2](ch11.xhtml#ch11fig2)中的卡片；它基本上是一个矮人的遗传蓝图。它将分配*属性*，比如力量和活力，以及*方法*，比如角色如何移动或说话。属性是类的*实例*范围内的变量，而方法是属性，它们恰好是函数，当运行时会传递一个指向它们实例的引用。类是一种数据类型，当你创建该数据类型的对象时，它也被称为该类的一个实例。设置实例的初始值和行为的过程称为*实例化*。'
- en: 'Next, define a *constructor* method, also referred to as the *initialization*
    method. It sets up the initial attribute values for your object ➌. The `__init__()`
    method is a special built-in method that Python automatically invokes as soon
    as a new object is created. In this case, you’ll pass two arguments: `self` and
    the `name` of your object.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个*构造函数*方法，也称为*初始化*方法。它为你的对象设置初始属性值 ➌。`__init__()`方法是一个特殊的内建方法，Python会在创建新对象时自动调用它。在这种情况下，你将传递两个参数：`self`和对象的`name`。
- en: The `self` parameter is a reference to the instance of this class that is being
    created, or a reference to the instance a method was invoked on, technically referred
    to as a *context* instance. If you create a new dwarf and name it “Steve,” `self`
    will become Steve behind the scenes. For example, `self.attack` becomes “Steve’s
    attack.” If you create another dwarf named “Sue,” `self` for that object will
    become “Sue.” This way, the scope of Steve’s health attribute is kept separate
    from Sue’s.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`self`参数是对正在创建的类实例的引用，或者是对调用方法时实例的引用，技术上称为*上下文*实例。如果你创建一个新的矮人并命名为“Steve”，那么幕后`self`将变成Steve。例如，`self.attack`就变成了“Steve的攻击”。如果你再创建一个名为“Sue”的矮人，那么这个对象的`self`就会变成“Sue”。这样，Steve的生命属性的作用域就与Sue的分开了。'
- en: Next, list some attributes for a dwarf beneath the constructor definition ➍.
    You’ll want a name so you can tell one dwarf from another, as well as the value
    of key combat characteristics. Notice how this list resembles the card in [Figure
    11-2](ch11.xhtml#ch11fig2).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在构造函数定义下方列出一些矮人的属性 ➍。你需要一个名字，以便区分不同的矮人，还需要一些关键战斗特征的数值。注意，这个列表与[图 11-2](ch11.xhtml#ch11fig2)中的卡片很相似。
- en: Define a `talk()` method and pass it `self` ➎. By passing it `self`, you link
    the method to the object. In more comprehensive games, methods might include behaviors
    like movement and the ability to disarm traps.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个`talk()`方法，并传递`self` ➎。通过传递`self`，你将方法与对象关联起来。在更复杂的游戏中，方法可能包括移动行为和解除陷阱的能力。
- en: With the class definition complete, create an instance of the `Dwarf` class
    and assign this object to the local variable `lenn`, the dwarf’s name ➏. Now,
    print the name and attack attributes to demonstrate that you have access to them.
    Finish by invoking the `talk()` method ➐. This should display a message.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 完成类定义后，创建一个`Dwarf`类的实例，并将该对象赋值给本地变量`lenn`，即矮人的名字 ➏。接着，打印名字和攻击属性，以证明你可以访问它们。最后，调用`talk()`方法
    ➐，此时应显示一条信息。
- en: '[Listing 11-4](ch11.xhtml#ch11list4) creates an elf character, using the same
    process you used in [Listing 11-3](ch11.xhtml#ch11list3), and has it fight the
    dwarf. The elf’s `body` attribute is updated to reflect the outcome of the battle.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-4](ch11.xhtml#ch11list4)创建了一个精灵角色，采用了与[清单 11-3](ch11.xhtml#ch11list3)中相同的过程，并让它与矮人对战。精灵的`body`属性被更新，以反映战斗结果。'
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 11-4: Creates an* Elf *class, instantiates an elf object, simulates
    a battle, and updates an object attribute*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-4：创建一个* Elf *类，实例化一个精灵对象，模拟战斗，并更新对象属性*'
- en: Define an `Elf` class and provide some attributes ➊. Make them slightly different
    from the dwarf’s and well balanced, like an elf. Instantiate an elf named `Esseden`
    and access his `name` and `body` attributes using `print`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个`Elf`类，并提供一些属性 ➊。使它们与矮人的属性略有不同，并且平衡得当，像一个精灵一样。实例化一个名为`Esseden`的精灵，并使用`print`访问他的`name`和`body`属性。
- en: Have your two characters interact using the roll of a virtual die with a maximum
    value equal to the character’s attack or defend value. Use the `random` module
    to choose a roll value in a range of 1 to Lenn’s `attack` attribute plus 1 ➋,
    then repeat this process to get Esseden’s defense ➌. Calculate the damage to Esseden
    by subtracting Esseden’s roll value from Lenn’s roll value ➍, and if the damage
    is a positive number, subtract it from Esseden’s body attribute. Use `print()`
    to confirm the elf’s current health ➎.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让你的两个角色通过掷一个虚拟骰子来互动，骰子的最大值等于角色的攻击或防御值。使用`random`模块在1到Lenn的`attack`属性加1之间选择一个骰子值
    ➋，然后重复此过程以获得Esseden的防御值 ➌。通过将Esseden的掷骰值从Lenn的掷骰值中减去 ➍，计算对Esseden的伤害，如果伤害为正数，则从Esseden的`body`属性中减去它。使用`print()`确认精灵的当前生命值
    ➎。
- en: As you can imagine, building many similar characters and keeping track of their
    changing attributes could quickly get complicated with procedural programming.
    OOP provides a modular structure for your program, makes it easy to hide complexity
    and ownership of scope with encapsulation, permits problem solving in bite-sized
    chunks, and produces sharable templates that can be modified and used elsewhere.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想象的那样，构建许多相似的角色并跟踪它们不断变化的属性，在过程化编程中会变得非常复杂。面向对象编程（OOP）为你的程序提供了模块化结构，使得隐藏复杂性和作用域所有权变得简单，并且允许以小块解决问题，同时生成可以共享、修改并在其他地方使用的模板。
- en: '***The Strategy and Pseudocode***'
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略和伪代码***'
- en: 'Now back to our three-door game. The rules for the game form the bulk of the
    pseudocode for the program:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到我们的三门游戏。游戏的规则构成了程序的伪代码的主体：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It’s useful to start designing a game by sketching out how the game window should
    look, complete with instructions, messages, and button types. I doubt you want
    to see my crude scribblings, so instead check out [Figure 11-3](ch11.xhtml#ch11fig3).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 开始设计游戏时，首先画出游戏窗口的样子是很有用的，窗口应该包含指令、消息和按钮类型。我怀疑你不会想看到我粗糙的草图，所以不如看看[图 11-3](ch11.xhtml#ch11fig3)。
- en: '![image](../images/f0227-01.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0227-01.jpg)'
- en: '*Figure 11-3: View of the game window after the first round of play*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-3：游戏窗口在第一轮播放后的视图*'
- en: This is how the finished game will look after the first round, with the win
    statistics visible at the far right. Note that the radio buttons for changing
    doors are grayed out until an initial pick has been made.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是游戏完成后第一轮的样子，右侧显示了获胜统计信息。注意，在做出初次选择之前，更换门的单选按钮是灰色的。
- en: '***Game Assets***'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***游戏资源***'
- en: '*Game assets* is a fancy term for things that you’ll need to build the game.
    These will consist of a series of images to represent the doors, goats, and prize
    ([Figure 11-4](ch11.xhtml#ch11fig4)).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*游戏资源*是指构建游戏时所需要的物品。这些资源将包括一系列用于表示门、山羊和奖品的图像（见[图 11-4](ch11.xhtml#ch11fig4)）。'
- en: '![image](../images/f0228-01.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0228-01.jpg)'
- en: '*Figure 11-4: Building-block images for the* monty_hall_gui.py *program*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-4：* monty_hall_gui.py *程序的构建块图像*'
- en: I used Microsoft PowerPoint to composite the 3 base images into 10 images that
    represent all the possible states of the game ([Figure 11-5](ch11.xhtml#ch11fig5)).
    This was a design decision; with extra lines of code, I could have obtained the
    same results using only the base images.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了Microsoft PowerPoint将3个基础图像合成成10个图像，代表游戏的所有可能状态（见[图 11-5](ch11.xhtml#ch11fig5)）。这是一个设计决策；通过增加几行代码，我也可以仅使用基础图像获得相同的结果。
- en: '![image](../images/f0228-02.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0228-02.jpg)'
- en: '*Figure 11-5: Composited images for the* monty_hall_gui.py *program*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-5：* monty_hall_gui.py *程序的合成图像*'
- en: '***The Monty Hall Game Code***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***蒙提·霍尔游戏代码***'
- en: The *monty_hall_gui.py* program described in this section turns the Monty Hall
    problem into a fun and educational game. You will also need the 10 game assets
    shown in [Figure 11-5](ch11.xhtml#ch11fig5). Download them from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    and keep all the files in the same folder.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*monty_hall_gui.py*程序将蒙提·霍尔问题转变为一个有趣且具有教育意义的游戏。你还将需要[图 11-5](ch11.xhtml#ch11fig5)中显示的10个游戏资源。从*
    [https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载它们，并将所有文件保存在同一文件夹中。'
- en: '**Importing Modules and Defining the Game Class**'
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**导入模块并定义游戏类**'
- en: '[Listing 11-5](ch11.xhtml#ch11list5) imports modules and defines the `Game`
    class and the initialization method, `__init__()`.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-5](ch11.xhtml#ch11list5)导入模块并定义`Game`类以及初始化方法`__init__()`。'
- en: '*monty_hall_gui.py,* part 1'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*monty_hall_gui.py,* 第1部分'
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 11-5: Imports modules and defines the* Game *class and* _ _init_ _()
    *method*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-5：导入模块并定义* Game *类和* _ _init_ _() *方法*'
- en: Start by importing the `random` and `tkinter` modules ➊. Next, define a class
    called `Game` ➋. The *ancestor* for this class, shown in parentheses, will be
    a `tkinter` `Frame` class. This means that the `Game` class is *derived* from
    the existing `Frame` “base” class and will conveniently inherit useful methods
    from it. The `Frame` widget mainly serves as a geometry master for other widgets,
    helping to group them into complex layouts.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入`random`和`tkinter`模块 ➊。接下来，定义一个名为`Game`的类 ➋。这个类的*祖先*（在括号中显示）将是`tkinter`的`Frame`类。这意味着`Game`类是从现有的`Frame`“基础”类派生出来的，并将方便地继承它的一些有用方法。`Frame`小部件主要作为其他小部件的几何布局主控，帮助将它们组合成复杂的布局。
- en: Note that classes have their own docstring conventions, which you can find at
    *[https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/)*.
    As stated in [Chapter 1](ch01.xhtml#ch01), I will mainly show single-line docstrings
    in this book for brevity.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，类有其自己的文档字符串规范，你可以在*[https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/)*上找到。正如在[第
    1 章](ch01.xhtml#ch01)中所述，为了简洁起见，本书将主要展示单行文档字符串。
- en: Every instance of `Game` will use the same three doors, so you can use a *class
    attribute* for this ➌. Any variable assigned a value outside of a method becomes
    a class attribute, much as variables assigned outside of functions in procedural
    programs become global variables. You don’t want this attribute to get changed
    inadvertently, so make it immutable by using a tuple. Later, you’ll make lists
    from this tuple whenever you want to manipulate the doors.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Game`实例都将使用相同的三个门，因此可以使用*类属性*来实现 ➌。任何在方法外部赋值的变量都会成为类属性，类似于在过程化程序中函数外部赋值的变量会成为全局变量。为了防止该属性被意外修改，可以通过使用元组使其不可变。稍后，当你想操作门时，可以从该元组创建列表。
- en: Now, just as with the earlier dwarf and elf examples, define an initializer
    method for the game object ➍. A `self` parameter is required, but you’ll also
    need a `parent`, which will be the `root` window that will hold the game.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像之前的矮人和精灵示例一样，为游戏对象定义一个初始化方法 ➍。需要一个`self`参数，但你还需要一个`parent`，它将是容纳游戏的`root`窗口。
- en: A base class can also be called a *superclass*, and the `super()` function lets
    you invoke the method of a superclass to gain access to inherited methods—in this
    case, from a parent class. First, pass `Game` to `super()`, which means you want
    to invoke a method of the superclass of `Game`, which is `Frame` ➎. Then pass
    it `self` as an argument to reference the newly instantiated `Game` object. The
    `__init__(parent)` part of the statement invokes the initializer method of `Frame`
    with `parent` (the root window) as the argument. Now attributes in the prebuilt
    `tkinter` `Frame` class can be used by your `Game` object. Note that this statement
    can be simplified to `super().__init__()`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 基类也可以称为*超类*，而`super()`函数让你调用超类的方法，从而访问继承的方法——在这种情况下，来自父类的方法。首先，将`Game`传递给`super()`，这意味着你想调用`Game`的超类方法，即`Frame`
    ➎。然后，将`self`作为参数传递，引用新实例化的`Game`对象。`__init__(parent)`语句部分调用`Frame`的初始化方法，并将`parent`（根窗口）作为参数传递。现在，你的`Game`对象可以使用预构建的`tkinter`
    `Frame`类中的属性。注意，这个语句可以简化为`super().__init__()`。
- en: Next, assign values to a series of instance attributes ➏. It is best to initialize
    attributes through the `__init__()` method, as it is the first method called after
    an object is created. This way, these attributes will be immediately available
    to any other methods in the class. Start by assigning the parent, which will be
    the `root` window, to the instance. Then name an attribute to hold one of the
    image files (shown in [Figure 11-5](ch11.xhtml#ch11fig5)) and assign it the image
    with all the doors closed, which is what the player will see at the start of each
    game. Next, name attributes for the player’s door choice, the winning door, and
    the door used to reveal the first goat.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，给一系列实例属性赋值 ➏。最好通过`__init__()`方法初始化属性，因为这是在创建对象后第一个被调用的方法。这样，这些属性将立即对类中的其他方法可用。首先，将`parent`（即根窗口）赋给实例。然后，命名一个属性来保存图像文件之一（如[图
    11-5](ch11.xhtml#ch11fig5)所示），并将其赋值为显示所有门关闭的图像，这将在每局游戏开始时显示给玩家。接下来，命名属性以保存玩家选择的门、获胜的门以及用来揭示第一只山羊的门。
- en: Use a counter to keep track of the number of wins achieved if the player sticks
    with the first door choice and another to record wins achieved when the player
    switches doors ➐. Finally, call a method that will create the label, button, and
    text widgets needed to run the game ➑.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个计数器来跟踪玩家选择第一个门时获得的胜利次数，另一个计数器来记录玩家换门后获得的胜利次数 ➐。最后，调用一个方法，创建运行游戏所需的标签、按钮和文本控件
    ➑。
- en: '**Creating Widgets for Images and Instructions**'
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**为图像和说明创建控件**'
- en: '[Listing 11-6](ch11.xhtml#ch11list6) defines the first part of the `create_widgets()`
    method, used to build the labels, buttons, and text widgets for the game. The
    first two widgets will be `tkinter` labels used to display the images in [Figure
    11-5](ch11.xhtml#ch11fig5) and to provide game instructions.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-6](ch11.xhtml#ch11list6)定义了`create_widgets()`方法的第一部分，该方法用于构建游戏所需的标签、按钮和文本控件。前两个控件将是`tkinter`标签，用于显示[图
    11-5](ch11.xhtml#ch11fig5)中的图像以及提供游戏说明。'
- en: '*monty_hall_gui.py,* part 2'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 11-6: Defines a method to create widgets*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Define a method, called `create_widgets()`, that takes `self` as an argument
    ➊. Then assign an attribute to hold an image of the doors ➋. Note that you don’t
    have to precede this attribute name with `self`, as it will be used only locally
    within the method. The `PhotoImage` class, which takes the image filename as an
    argument, is used by `tkinter` to display images in canvas, label, text, or button
    widgets. After this step, you can use the image in a `tkinter` label, so assign
    a `photo_lbl` variable, pass it the parent and image as arguments, and specify
    no text and a thin border ➌.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: To place the label in the parent window, use the `grid()` method and pass it
    the first row and first column, let the image span 10 columns, and left-justify
    it using `W` ➍. This will fill the top part of the window with the image of the
    closed doors. The `columnspan` option lets the widget span more than one column.
    The value won’t affect the image size but *will* change the number of locations
    available for placing the instruction text and other widgets below the image.
    For example, if you set `columnspan=2`, you’ll have only two columns available
    for placing instructions, buttons, and messages.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Finish the photo label by creating a reference to the image object ➎. If you
    don’t do this, the image won’t always show up.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: According to the `tkinter` documentation, `tkinter` is a layer built over another
    product (`Tk`), and the interface between the two doesn’t handle references to
    image objects properly. The `Tk` widget holds a reference to the internal object,
    but `tkinter` doesn’t. Python uses a garbage-collector module to automatically
    reclaim memory from objects no longer needed. When the garbage collector in Python’s
    memory allocator discards the `tkinter` object, `tkinter` tells `Tk` to release
    the image. But because it’s in use, `Tk` can’t, so it sets it to transparent instead.
    Suggestions for solving the problem include using a global variable, using an
    instance attribute, or as you did here, adding an attribute to the widget instance
    (`photo_lbl.image = img`). For more information, see *[http://effbot.org/tkinterbook/photoimage.htm](http://effbot.org/tkinterbook/photoimage.htm)*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Finally, add the instruction text as label widgets. The process is to provide
    a list of parameters and then loop through them to build the widgets. Start with
    a list of tuples ➏, where each tuple contains the options for making a `Label`
    object; you can see what each represents in the next statement ➐. As you progress
    through the `for` loop, create each label in the `parent` window and assign it
    some text. Then use the `grid()` method to place the text, based on the information
    in the list of tuples, into the window.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Use the `ipadx` option with `grid()` ➑. This option refers to internal padding
    in the x-direction within the label, so you can play with it to tweak the appearance
    of the text in the window. In this case, you add 30 pixels to the label so that
    the text will align in a visually pleasing way.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ipadx`选项与`grid()` ➑。该选项指的是标签内x方向的内边距，因此你可以调整它以微调窗口中文本的外观。在这种情况下，你为标签添加了30像素，使文本在视觉上对齐。
- en: '**Creating Radio Buttons and Text Widgets**'
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建单选按钮和文本小部件**'
- en: '[Listing 11-7](ch11.xhtml#ch11list7) continues the definition of the `create_widgets()`
    method by creating radio button widgets for the three doors. The player makes
    their initial door choice by selecting the A, B, or C radio button. Their choice
    is then processed by the `win_reveal()` method, which you’ll build later. This
    method will determine the winning door and reveal a goat.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 11-7](ch11.xhtml#ch11list7)通过为三个门创建单选按钮小部件，继续定义`create_widgets()`方法。玩家通过选择A、B或C单选按钮来做出初始的门选择。然后，由`win_reveal()`方法处理他们的选择，你稍后会定义这个方法。该方法将确定获胜的门并揭示一只山羊。'
- en: Another set of radio buttons is created to get the player’s choice to switch
    doors or not. The result will be processed by the `show_final()` method, also
    defined later. Besides revealing what’s behind the player’s final door choice,
    this method will update the win statistics, using `Text` widgets defined at the
    end of this listing.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个单选按钮组被创建用来获取玩家是否选择换门。结果将由稍后定义的`show_final()`方法处理。除了揭示玩家最终选择的门背后是什么，这个方法还将使用在本列表末尾定义的`Text`小部件更新胜利统计数据。
- en: '*monty_hall_gui.py,* part 3'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*monty_hall_gui.py,* 第三部分'
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 11-7: Builds radio buttons and text widgets for the* create_widgets()
    *method*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-7: 为* create_widgets() *方法构建单选按钮和文本小部件*'
- en: Start by creating radio buttons for doors A, B, and C. When a user interacts
    with a `tkinter` widget, the result is an *event*. You can use variables to track
    these events, such as when the player selects a door by pressing a radio button.
    For widget-specific variables, `tkinter` has a variable class. Use the *string*
    variable class, `StringVar`, and assign it to a variable named `door_choice` ➊.
    Immediately use the `set()` method to assign the variable a value of `None`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建A、B和C门的单选按钮。当用户与`tkinter`小部件进行交互时，结果是一个*事件*。你可以使用变量来跟踪这些事件，例如，当玩家通过按下单选按钮选择一个门时。对于小部件特定的变量，`tkinter`有一个变量类。使用*string*变量类`StringVar`，并将其分配给名为`door_choice`的变量
    ➊。立即使用`set()`方法将该变量的值设置为`None`。
- en: Next, set up the button widgets for the three doors ➋. The player will click
    on one of these for their first door pick. Use the `Radiobutton` class and pass
    it the parent window, the text to display, the `door_choice` variable you just
    assigned, a value equal to the door name, and a command. The command calls the
    `win_reveal()` method, which you’ll define shortly. Note that you don’t include
    the parentheses after the method name.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为三个门设置按钮小部件 ➋。玩家将点击其中一个作为他们的第一个门选择。使用`Radiobutton`类，并传递父窗口、要显示的文本、你刚分配的`door_choice`变量、与门名相等的值和一个命令。该命令调用`win_reveal()`方法，你很快会定义它。请注意，方法名后面不包括括号。
- en: Repeat this process for buttons B and C. This is mainly a cut-and-paste exercise,
    because all you need to change are the door designations.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对按钮B和C重复此过程。这主要是一个复制粘贴的练习，因为你只需要更改门的标识。
- en: Now, build the radio buttons for switching doors. Start by making another string
    variable, as you did for the initial door choice ➌. This will hold either `y`
    or `n`, depending on which radio button is selected.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构建切换门的单选按钮。首先创建另一个字符串变量，就像你为初始门选择所做的那样 ➌。这个变量将保存`y`或`n`，取决于选择了哪个单选按钮。
- en: Build an instruction label using the `Label` class ➍. Then build the `self.yes`
    radio button ➎. Use the `Radiobutton` class, pass it the parent window, and set
    its state to `disabled`. This way, the window will initialize with the yes/no
    buttons grayed out, so the player can’t jump the gun and try to change a door
    before first choosing one. The text parameter is the button name; use an abbreviated
    Y for *yes*. Set the widget’s variable argument to the `change_door` variable,
    set its value to `y`, and call the `show_final()` function. Repeat the process
    for the no button.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The last widgets you’ll need are `Text` widgets to show the counts for switching
    doors versus staying put. Use the `Text` class to display the statistics and set
    the text box color to match the parent window. To do this, use `cget()` to get
    the background (`bg`) color of `parent` and then assign it to a variable ➏. The
    `cget()` method returns the current value for a `tkinter` option as a string.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Create a text object to display the wins for sticking with the first choice
    ➐. You need to pass the widget the parent window, a width and height, how to wrap
    text if it extends beyond a row, a background color, a foreground color—the text
    color—and a border width for the text box. Note that you don’t include any actual
    text; this will be added later by the `show_final()` method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Finish with another text widget to display the number of wins attributed to
    switching doors.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '**Arranging the Widgets**'
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 11-8](ch11.xhtml#ch11list8) completes the `create_widgets()` method
    by using the `tkinter` `Grid` geometry manager to position the remaining nongridded
    widgets in the game window.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '*monty_hall_gui.py,* part 4'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 11-8: Calls the* grid() *method on the widgets to position them in
    the frame*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `grid()` to position the door buttons in the parent window ➊. Group the
    three door buttons together in the same row and column and separate them using
    the `sticky` justification: `W` means left, `N` is center, and `E` is right. Use
    `padx` to tweak the positions laterally. Repeat this process for the remaining
    buttons, then position the win statistics text widgets and allow them to span
    the five columns on the right side of the window ➋.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '**Updating the Door Image**'
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You’ll need to open and close doors throughout the game, so [Listing 11-9](ch11.xhtml#ch11list9)
    defines a helper method to update the door image as appropriate. Note that, with
    OOP, you don’t need to pass a filename to the method as an argument. All the methods
    for an object have direct access to attributes that begin with `self`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '*monty_hall_gui.py,* part 5'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 11-9: Defines a method to update the current door image*'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Define a function, called `update_image()`, that takes `self` as an argument
    ➊. Then use the `PhotoImage` class as you did in [Listing 11-6](ch11.xhtml#ch11list6)
    ➋. The filename, *self.img_file*, will be updated in other methods.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Because you’ve already created the label that holds the door image, use the
    `configure()` method to change the label—in this case, by loading a new image
    ➌. You can use either `configure()` or `config()`. Finish by assigning the image
    to a widget attribute to fend off garbage collection ➍, as described for [Listing
    11-6](ch11.xhtml#ch11list6).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '**Selecting the Winning Door and Revealing a Goat**'
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 11-10](ch11.xhtml#ch11list10) defines a method that selects the winning
    door and the reveal door and then opens and closes the reveal door. It also activates
    the yes/no buttons, which are grayed out until the player makes their first door
    choice.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '*monty_hall_gui.py,* part 6'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 11-10: Defines a method to randomly select the winning door and reveal
    door*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Define a method, called `win_reveal()`, that takes `self` as an argument ➊.
    Immediately make a list of the doors from the class attribute `doors` ➋. You’ll
    alter this list based on the player’s first door choice and then the winning door,
    picked at random by the program.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Now, assign a `self.choice` attribute to the `self.door_choice` string variable,
    accessed with the `get()` method ➌. The value of this attribute was determined
    by the door radio button that the user clicked as their first choice. Next, choose
    the winning door, at random, from the door list.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Remove the winning door from the door list ➍. Then use a conditional to see
    whether the player’s choice is still in the door list; if it is, remove it so
    that it can’t be revealed ➎. This will leave only one door in the list, so assign
    it to the `self.reveal` attribute.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: If the player picked the winning door, there are two doors left in the list,
    so randomly choose one of them and assign it to `self.reveal`. Update the `self.img_file`
    attribute for this door ➏, then call the method that updates the photo label to
    show the new image. [Figure 11-6](ch11.xhtml#ch11fig6) is an example of the reveal
    image for door B.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0235-01.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: The reveal image for Door B*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Next, set the state of the yes and no buttons to `normal` ➐. After this, they
    will no longer be grayed out. End the method by changing the image file to *all_closed.png*
    and calling the `self.update_image()` method on the `parent` window after 2,000
    milliseconds have elapsed ➑. This will ensure the doors stay open no longer than
    2 seconds.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '**Revealing the Player’s Final Choice**'
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 11-11](ch11.xhtml#ch11list11) defines the first part of a function
    that takes the player’s final door choice and reveals what’s behind it. The function
    will also keep track of the number of wins for switching doors or staying put.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '*monty_hall_gui.py,* part 7'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 11-11: Defines a method to reveal the player’s final choice and update
    win lists*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Define a method, called `show_final()`, that takes—you guessed it—`self` as
    an argument ➊. Make a new copy of the door list ➋, then get the `self.change_doors`
    variable and assign it to an attribute named `switch_doors` ➌. This variable will
    hold either a `'y'` or an `'n'`, depending on which radio button the player clicked.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: If the player chose to switch doors ➍, remove their first choice and the revealed
    door from the list and assign a `new_pick` attribute to the remaining door ➎.
    If this new pick is the winning door ➏, reference the proper image and advance
    the `self.pick_change_wins` counter. Otherwise, set the image to a goat and advance
    the `self.first_choice_wins` counter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: If the player decides to not change doors ➐ and if their first choice was the
    winning door ➑, reveal the money bag and advance the `self.first_choice_``wins`
    counter. Otherwise, show a goat and advance the `self.pick_change_wins` counter.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Finish by calling the `update_image()` method to update the image ➒. Again,
    you don’t need to pass it the name of the new image file, as it can access the
    `self.img_file` attribute that you changed in the preceding code.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '**Displaying Statistics**'
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 11-12](ch11.xhtml#ch11list12) completes the `show_final()` method
    by updating the game window for the number of wins statistics, disabling the yes/no
    buttons, and closing all the doors.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '*monty_hall_gui.py,* part 8'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 11-12: Displays win statistics, disables the yes/no buttons, and closes
    all the doors*'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Start by deleting any text in the `self.unchanged_wins_txt` text widget ➊. Begin
    deleting at a text index of `1.0`. The format is `line.column`, so you are specifying
    the first line and first column of the text widget (line numbering starts at 1,
    column numbering at 0). Finish with `'end'`, which will ensure that all the text
    after the starting index is deleted.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Next, use the `insert()` method to add the `self.first_choice_wins` attribute
    value, along with some descriptive text, to the text widget ➋. Begin inserting
    at text index `1.0`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Repeat this process for the `self.changed_wins_txt` text widget, and then disable
    the yes/no buttons by setting their `config` state to `'disabled'` ➌. Set the
    `self.door_choice` string variable back to `None`, and you’re ready to start a
    new game ➍.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: End the method by closing the doors, as you did in [Listing 11-10](ch11.xhtml#ch11list10)
    ➎.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting Up the Root Window and Running the Event Loop**'
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[Listing 11-13](ch11.xhtml#ch11list13) completes the *monty_hall_gui.py* program
    by setting up the `tkinter` `root` window, instantiating the game object, and
    running `mainloop()`. Alternatively, this code could be encapsulated in a `main()`
    function.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '*monty_hall_gui.py,* part 9'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 11-13: Sets up the* root *window, creates a game object, and runs*
    mainloop()'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The `Tk` class is instantiated without arguments ➊. This creates a top-level
    `tkinter` widget, which will be the main window of the game application. Assign
    it to a variable named `root`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Give the window a title ➋ and a size in pixels ➌. Note that the size of the
    images influences the geometry so that they fit attractively in the window, with
    ample room below for instructions and messages.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Now, create the game ➍. Pass it the `root` window, which will be the *master*
    that will contain the game. This results in a new game being placed inside the
    `root` window.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Finish by invoking the `mainloop()` method on `root`, which keeps the window
    open and waiting to handle events.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you used a simple Monte Carlo simulation to confirm that switching
    doors is the best strategy for the Monty Hall problem. You then used `tkinter`
    to build a fun interface to let schoolchildren test this conclusion manually,
    game by game. Best of all, you learned how to use object-oriented programming
    to build interactive widgets that respond to user input.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '**Further Reading**'
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Useful `tkinter` references can be found in “[Further Reading](ch10.xhtml#lev241)”
    on [page 212](ch10.xhtml#page_212).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: You can find a summary of the 1990 Monty Hall problem controversy online at
    *[http://marilynvossavant.com/game-show-problem/](http://marilynvossavant.com/game-show-problem/)*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**Practice Project: The Birthday Paradox**'
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How many people need to be in a room for there to be a 50/50 chance that two
    of them share the same birth month and day? According to the *birthday paradox*,
    not that many! As with the Monty Hall problem, the outcome is counterintuitive.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Use MCS to determine how many people it takes to reach the 50 percent mark.
    Have the program print out the number of people and the probability for a range
    of room occupants. If you find yourself looking up how to format dates, stop and
    simplify! You can find a solution, *birthday_paradox_practice.py*, in the appendix
    or online at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
