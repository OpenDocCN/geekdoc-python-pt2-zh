- en: '**11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11**'
- en: THE MONTY HALL PROBLEM**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**蒙提霍尔问题**'
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: 'As host of the TV game show *Let’s Make a Deal*, Monty Hall would show contestants
    three closed doors and ask them to choose one. Behind one door was a valuable
    prize; behind the other two were smelly old goats. As soon as the contestant chose
    a door, Monty would open one of the remaining doors to reveal a goat. The contestant
    was then given a final choice: switch doors or stay with their initial pick.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为电视游戏节目 *Let's Make a Deal* 的主持人，Monty Hall 会展示给参赛者三个封闭的门，并要求他们选择一个。一个门后面藏着一个宝贵的奖品，而另外两个门后面则是臭味扑鼻的老山羊。一旦参赛者选择了一个门，Monty
    就会打开剩下的一个门，露出一只山羊。然后，参赛者会面临最后的选择：是更换门，还是坚持原来的选择。
- en: In 1990, Marilyn vos Savant, “the world’s smartest woman,” stated in her weekly
    *Parade* magazine column, “Ask Marilyn,” that the contestant should choose to
    switch doors. Though her answer was correct, it ignited a firestorm of hate mail,
    gender profiling, and academic persecution. Many math professors embarrassed themselves
    in the process, but there was a bright side to the ugly affair. The heated discussion
    exposed the public to the science of statistics, and an exercise that vos Savant
    proposed found its way into thousands of classrooms. These manual tests—later
    duplicated by computers—all vindicated her derided “female logic.”
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 1990 年，"世界上最聪明的女人" Marilyn vos Savant 在她每周的 *Parade* 杂志专栏《问玛丽莲》中指出，参赛者应该选择更换门。虽然她的回答是正确的，但却引发了大量的仇恨邮件、性别偏见和学术迫害。在这个过程中，许多数学教授感到尴尬，但这场丑陋的事件也有光明的一面。激烈的讨论让公众接触到了统计学的科学，vos
    Savant 提出的一个实验也进入了成千上万的教室。这些手动测试——后来由计算机复制——最终证明了她那被讽刺的“女性逻辑”是正确的。
- en: In this chapter, you’ll use *Monte Carlo simulation (MCS)*, a method for modeling
    the probability of different outcomes from a range of random inputs, to verify
    that vos Savant was right. After that, you’ll use tkinter to build a fun graphical
    interface that addresses her request for schoolchildren to help with the experiment.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将使用 *蒙特卡洛模拟（MCS）*，这是一种通过一系列随机输入来建模不同结果的概率的方法，来验证 vos Savant 的结论是否正确。之后，你将使用
    tkinter 构建一个有趣的图形界面，来满足她要求学校儿童帮助实验的请求。
- en: '**Monte Carlo Simulation**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**蒙特卡洛模拟**'
- en: Imagine you want to know the probability of rolling a die six times and getting
    a different face with each roll. If you’re a math whiz, you’d probably just compute
    this using the deterministic equation 6! / 6⁶ or
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你想知道投掷一个骰子六次，每次得到不同的面朝上的概率。如果你是一个数学天才，你可能会直接通过确定性方程 6! / 6⁶ 来计算这个概率，或者
- en: '![image](../images/f0218-01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0218-01.jpg)'
- en: 'yielding 0.015\. If you’re not so mathematically inclined, you could get the
    same answer with Python and a lot of rolls:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果为 0.015。如果你不那么擅长数学，你也可以使用 Python 和大量的投掷来得到相同的答案：
- en: '>>> from random import randint'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> from random import randint'
- en: '>>> trials = 100000'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> trials = 100000'
- en: '>>> success = 0'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> success = 0'
- en: '>>> for trial in range(trials):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> for trial in range(trials):'
- en: faces = set()
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: faces = set()
- en: 'for rolls in range(6):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 'for rolls in range(6):'
- en: roll = randint(1, 6)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: roll = randint(1, 6)
- en: faces.add(roll)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: faces.add(roll)
- en: 'if len(faces) == 6:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 'if len(faces) == 6:'
- en: success += 1
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: success += 1
- en: '>>> print("probability of success = {}".format(success/trials))'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print("成功的概率 = {}".format(success/trials))'
- en: probability of success = 0.01528
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的概率 = 0.01528
- en: This example uses a for loop and randint to randomly pick a number between 1
    and 6, representing one of the faces on the die, six times in a row. It adds each
    result to a set named faces, which doesn’t permit duplicates. The only way for
    the length of the set to reach 6 is if each roll yields a unique number, which
    equals a success case. An outer for loop performs the six-roll trial 100,000 times.
    Dividing the number of successes by the number of trials yields the same probability,
    0.015, as the deterministic equation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例使用了一个 for 循环和 randint 函数，随机选取 1 到 6 之间的数字，表示骰子上的六个面之一，连续投掷六次。它将每次的结果添加到一个名为
    faces 的集合中，集合不允许重复。集合的长度达到 6 的唯一方法是每次投掷的结果都是唯一的，这样就算作一次成功。外层的 for 循环会执行 100,000
    次这个六次投掷的实验。将成功次数除以实验次数，可以得到与确定性方程相同的概率值 0.015。
- en: Monte Carlo simulation uses *repeated random sampling*—in this case, each roll
    of the die is a random sample—to predict different outcomes under a specified
    range of conditions. For this example, the range of conditions was one six-faced
    die, six rolls with no repeats per trial, and 100,000 trials. Of course, MCS is
    usually applied to more complex problems—those with lots of variables and wide
    ranges of uncertainty, where the results cannot be easily predicted.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙特卡洛模拟使用*反复随机抽样*——在这个例子中，每一次掷骰子都是一个随机样本——来预测在指定条件范围内的不同结果。对于这个例子，条件范围是一个六面骰子，每次试验六次掷骰子且不重复，试验次数为100,000次。当然，MCS通常应用于更复杂的问题——那些有大量变量和广泛不确定性的情况，其中结果无法轻易预测。
- en: 'There are multiple types of MCS, but most applications follow these basic steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种类型的MCS，但大多数应用遵循以下基本步骤：
- en: List the input variables.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出输入变量。
- en: Provide a probability distribution for each variable.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个变量提供一个概率分布。
- en: 'Start a loop:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始一个循环：
- en: Randomly select a value from the distributions for each input.
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机从每个输入的分布中选择一个值。
- en: Use the values in a deterministic calculation, which is a calculation that will
    always produce the same output from the same input.
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用这些值进行确定性计算，即从相同输入中始终产生相同输出的计算。
- en: Repeat a specified number of times.
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复指定次数。
- en: Aggregate the results and generate statistics, such as the average outcome for
    the calculation.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汇总结果并生成统计数据，例如计算的平均结果。
- en: 'For the die-roll example, these steps were:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于掷骰子示例，这些步骤是：
- en: Input variables = the results of six die rolls.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入变量 = 六次掷骰子的结果。
- en: Probability distribution for roll = uniform (1/6 for each face).
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掷骰子的概率分布 = 均匀分布（每个面为1/6）。
- en: 'Loop:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环：
- en: Randomly selected value = die roll (draw from distribution).
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机选择的值 = 掷骰子（从分布中抽取）。
- en: Calculation = add the six values to a set and, if set length equals 6, add 1
    to success variable.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算 = 将六个值加到一个集合中，如果集合长度等于6，则成功变量加1。
- en: Repeat = 100,000 times.
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复 = 100,000次。
- en: 'Aggregate: divide success variable by 100,0000 for probability calculation.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汇总：将成功变量除以100,0000来计算概率。
- en: Nassim Taleb, the critically acclaimed author of *The Black Swan* and *Fooled
    by Randomness*, is a fan of MCS. He posits that our brains are designed to get
    us out of trouble quickly, rather than handle complicated uncertainty or probability
    problems. We aren’t cut out for highly skewed distributions and nonlinearities,
    but some people’s brains are inherently more capable of understanding risks using
    MCS than other methods. In real life, we don’t observe probability distributions;
    we just observe events.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 纳西姆·尼古拉斯·塔勒布（Nassim Taleb），《黑天鹅》和《随机的愚弄》一书的备受好评的作者，是MCS的支持者。他认为我们的脑袋设计用来迅速帮助我们摆脱困境，而不是处理复杂的不确定性或概率问题。我们并不适应高度偏斜的分布和非线性问题，但有些人的大脑天生就比其他方法更能通过MCS理解风险。在现实生活中，我们并不观察概率分布；我们只是观察事件。
- en: Each MCS run represents a single event, such as whether you run out of money
    in retirement. For many of us, MCS makes risk real. It helps us understand how
    bad or good things can be—something we can’t always glean from mathematical abstractions.
    With the insight from MCS, we can prepare to both defend against the downside
    and exploit the upside.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每次MCS运行代表一个单独事件，例如是否在退休时用尽资金。对于我们很多人来说，MCS使得风险变得真实。它帮助我们理解事情可能的好坏——这是我们从数学抽象中无法轻易获得的。通过MCS得到的洞察，我们可以为防范风险并利用机会做准备。
- en: To support the math behind the Monty Hall problem, you’ll use an MCS application
    like the preceding die-roll example. Then, in [Chapter 12](ch12.xhtml#ch12), you’ll
    use MCS to build a nest-egg simulator to plan your (or your parents’) secure retirement.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证蒙提霍尔问题的数学推导，你将使用像前面的掷骰子示例这样的MCS应用。然后，在[第12章](ch12.xhtml#ch12)中，你将使用MCS构建一个退休资金模拟器，以规划你（或你父母）的安全退休。
- en: '**Project #18: Verify vos Savant**'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目 #18：验证Vos Savant**'
- en: To verify that vos Savant was right, use a Monte Carlo approach and simulate
    tens of thousands of “games” in order to see how things shake out. This can be
    a bare-bones program, since the goal is a simple confirmation with no embellishments.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证Vos Savant是对的，可以使用蒙特卡洛方法模拟数万次“游戏”，以查看结果如何。这可以是一个基础程序，因为目标是一个简单的确认，没有多余的修饰。
- en: '**THE OBJECTIVE**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Write a simple Python program that uses Monte Carlo simulation to determine
    the probability of winning the Monty Hall problem by changing the initial pick.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个简单的Python程序，使用蒙特卡洛模拟来确定通过改变初始选择来赢得蒙提霍尔问题的概率。
- en: '***The Strategy***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略***'
- en: The correct response to the Monty Hall problem is to switch doors after Monty
    reveals the goat. Statistically, this will double your chances of winning!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙提霍尔问题的正确答案是在蒙提揭示山羊后换门。从统计学角度来看，这样做会将你获胜的概率翻倍！
- en: Look at [Figure 11-1](ch11.xhtml#ch11fig1). At the start of the game, all the
    doors are closed, and the odds of a given door hiding the prize are 1 in 3\. The
    user can choose only one door, which means the odds of the prize being behind
    one of the other two doors are 2 in 3\. After the goat is revealed, the odds remain
    2 in 3, but they revert to the remaining door. Remember, Monty knows where the
    prize is hidden, and he will never reveal *that* door. So the probability of success
    is 1/3 for staying with your first choice versus 2/3 for switching.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[图 11-1](ch11.xhtml#ch11fig1)。在游戏开始时，所有的门都关闭，某一扇门藏有奖品的概率是1/3。用户只能选择一扇门，这意味着奖品可能藏在其他两扇门中的概率是2/3。山羊被揭示后，概率依然是2/3，但这2/3的概率转移到了剩下的那扇门。记住，蒙提知道奖品藏在哪里，并且他永远不会揭示*那扇*门。所以，如果坚持选择最初的门，成功的概率是1/3，而换门的成功概率是2/3。
- en: '![image](../images/f0220-01.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0220-01.jpg)'
- en: '*Figure 11-1: Odds of winning the Monty Hall problem before and after a goat
    is revealed*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-1：蒙提霍尔问题中奖的概率变化（揭示山羊前后）*'
- en: If you’re dubious about the math, you can use MCS to provide corroborating evidence,
    just as we did with the die-roll example. You simply need to pick a winning door
    at random, choose a contestant’s pick at random, and record how many times the
    two coincide. Repeat this thousands of times, and you will converge on the deterministic
    mathematical solution.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对数学公式有所怀疑，可以使用MCS来提供佐证，就像我们在掷骰子的例子中所做的那样。你只需要随机选择一个获胜的门，随机选择一个参赛者的选择，并记录两者相遇的次数。重复这个过程几千次，你会收敛到确定性的数学解。
- en: '***The vos Savant Verification Code***'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Vos Savant 验证码***'
- en: The *monty_hall_mcs.py* program described in this section will automate the
    process of choosing doors and recording the results so that you can run thousands
    of trials and evaluate them in less than a second. You can download the code from
    *[https://www.nostarch.com/impracticalpython.com/](https://www.nostarch.com/impracticalpython.com/)*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个章节中描述的*monty_hall_mcs.py*程序将自动化选择门并记录结果的过程，这样你可以运行数千次试验并在不到一秒钟的时间内评估它们。你可以从*[https://www.nostarch.com/impracticalpython.com/](https://www.nostarch.com/impracticalpython.com/)*下载代码。
- en: '**Getting the Number of Runs Input**'
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**获取运行次数输入**'
- en: '[Listing 11-1](ch11.xhtml#ch11list1) starts the *monty_hall_mcs.py* program
    by asking the user how many runs—or games—they want to simulate. You’ll also provide
    the user with a default value. This is a great way to guide a user to a reasonable
    first response, as well as save them a few keystrokes.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-1](ch11.xhtml#ch11list1)通过询问用户想要模拟多少次运行（或游戏）来启动*monty_hall_mcs.py*程序。你还会提供一个默认值。这是引导用户给出合理初步回答的好方法，同时也能为他们节省一些敲键盘的时间。'
- en: '*monty_hall_mcs.py,* part 1'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*monty_hall_mcs.py,* 第一部分'
- en: ➊ import random
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ import random
- en: '➋ def user_prompt(prompt, default=None):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ def user_prompt(prompt, default=None):'
- en: '"""Allow use of default values in input."""'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '"""允许在输入时使用默认值。"""'
- en: '➌ prompt = ''{} [{}]: ''.format(prompt, default)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ prompt = ''{} [{}]: ''.format(prompt, default)'
- en: ➍ response = input(prompt)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ response = input(prompt)
- en: '➎ if not response and default:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ if not response and default:'
- en: return default
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: return default
- en: 'else:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: return response
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: return response
- en: '# input number of times to run simulation'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '# 输入运行模拟的次数'
- en: ➏ num_runs = int(user_prompt("Input number of runs", "20000"))
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ num_runs = int(user_prompt("输入运行次数", "20000"))
- en: '*Listing 11-1: Imports modules and defines the* user_prompt() *function*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-1：导入模块并定义* user_prompt() *函数*'
- en: Start by importing the random module to run MCS ➊. Next, define a function,
    called user_prompt(), that asks the user to either input the number of games to
    run or else accept a default value, if provided ➋. This function takes two arguments;
    the first is the text prompt that tells the user what to do, and the second is
    the default value, which will start out as None. Immediately redefine the prompt
    variable so that it will display with the default value in brackets, per convention
    ➌. Assign the user’s input to a variable named response ➍. If the user presses
    ENTER without providing any input and a default value exists, the user_prompt()
    function will return the default value ➎. Otherwise, the function returns the
    user’s input. Use the function to determine the number of runs to make by assigning
    the returned value to the num_runs variable ➏. Each run will represent a contestant
    playing the game once.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入随机模块以运行 MCS ➊。接下来，定义一个名为 user_prompt() 的函数，要求用户输入要运行的游戏次数，或者如果提供了默认值，则接受默认值
    ➋。此函数接受两个参数；第一个是文本提示，告诉用户该做什么，第二个是默认值，初始为 None。立即重新定义提示变量，使其按照惯例显示带有默认值的括号 ➌。将用户的输入赋值给名为
    response 的变量 ➍。如果用户按 Enter 键而没有提供任何输入，并且存在默认值，则 user_prompt() 函数将返回默认值 ➎。否则，函数返回用户的输入。使用此函数通过将返回值赋给
    num_runs 变量来确定运行的次数 ➏。每次运行将代表一位参赛者玩一次游戏。
- en: '**Running MCS and Displaying the Results**'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**运行MCS并显示结果**'
- en: '[Listing 11-2](ch11.xhtml#ch11list2) picks the winning door and the user’s
    first choice at random, then aggregates and presents the statistics. Interestingly,
    the user’s second choice—to switch doors or not—isn’t required to get the correct
    answer. If the initial choice is the winning door, the correct answer is to not
    change doors. Likewise, if the initial choice and the winning door differ, the
    correct answer is to change doors. There’s no reason to model what a contestant
    might or might not do.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-2](ch11.xhtml#ch11list2) 随机选择获胜门和用户的第一次选择，然后汇总并展示统计数据。有趣的是，用户的第二次选择——是否换门——并不是得出正确答案所必需的。如果初始选择是获胜门，正确的答案是不要换门。同样，如果初始选择和获胜门不同，正确的答案是换门。没有必要模拟参赛者可能做的或不做的事情。'
- en: '*monty_hall_mcs.py,* part 2'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*monty_hall_mcs.py,* 第2部分'
- en: '# assign counters for ways to win'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '# 分配胜利方式的计数器'
- en: ➊ first_choice_wins = 0
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ first_choice_wins = 0
- en: pick_change_wins = 0
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: pick_change_wins = 0
- en: ➋ doors = ['a', 'b', 'c']
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ doors = ['a', 'b', 'c']
- en: '# run Monte Carlo'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '# 运行蒙特卡罗模拟'
- en: '➌ for i in range(num_runs):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ for i in range(num_runs):'
- en: winner = random.choice(doors)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: winner = random.choice(doors)
- en: pick = random.choice(doors)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: pick = random.choice(doors)
- en: '➍ if pick == winner:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ if pick == winner:'
- en: first_choice_wins += 1
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: first_choice_wins += 1
- en: 'else:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: pick_change_wins += 1
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: pick_change_wins += 1
- en: ➎ print("Wins with original pick = {}".format(first_choice_wins))
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ print("原选择获胜次数 = {}".format(first_choice_wins))
- en: print("Wins with changed pick = {}".format(pick_change_wins))
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: print("更改选择获胜次数 = {}".format(pick_change_wins))
- en: 'print("Probability of winning with initial guess: {:.2f}"'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("初始猜测获胜的概率: {:.2f}"'
- en: .format(first_choice_wins / num_runs))
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: .format(first_choice_wins / num_runs))
- en: 'print("Probability of winning by switching: {:.2f}"'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("通过换门获胜的概率: {:.2f}"'
- en: .format(pick_change_wins / num_runs))
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: .format(pick_change_wins / num_runs))
- en: ➏ input("\nPress Enter key to exit.")
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ input("\n按 Enter 键退出。")
- en: '*Listing 11-2: Runs the Monte Carlo simulation and displays the results*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-2：运行蒙特卡罗模拟并显示结果*'
- en: Assign two variables to keep track of whether switching or staying put is the
    winning outcome ➊. Then, create a list to represent the three doors ➋.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 分配两个变量来跟踪是否换门或保持原选择是获胜的结果 ➊。然后，创建一个列表来表示三扇门 ➋。
- en: MCS starts with a for loop that goes through the number of runs ➌. Inside that
    loop, choose the winning door and the user’s first choice from the doors list,
    using random.choice(), and assign them to variables.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: MCS 从一个 for 循环开始，该循环遍历运行次数 ➌。在循环内，从 doors 列表中随机选择获胜门和用户的第一次选择，使用 random.choice()，并将它们赋值给变量。
- en: Since this is a binary system—the user switches or doesn’t—you’ll only need
    a conditional that adds to the counters based on the relationship of the pick
    variable to the winning variable ➍.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个二元系统——用户换门或不换门——你只需要一个条件语句，根据 pick 变量和 winner 变量的关系来更新计数器 ➍。
- en: Finish the program by presenting the final results. Display the actual counts,
    plus the calculated probabilities ➎. Then let the user know the program is finished
    ➏.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 完成程序并展示最终结果。显示实际计数和计算出的概率 ➎。然后告知用户程序已完成 ➏。
- en: 'Here’s an example output for the default 20,000 runs:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认20,000次运行的输出示例：
- en: 'Input number of runs [20000]:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '输入运行次数 [20000]:'
- en: Wins with original pick = 6628
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 原始选择获胜次数 = 6628
- en: Wins with changed pick = 13372
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 更换选择后获胜次数 = 13372
- en: 'Probability of winning with initial guess: 0.33'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 初始猜测的获胜概率：0.33
- en: 'Probability of winning by switching: 0.67'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更换选择的获胜概率：0.67
- en: Press Enter key to exit.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 按下回车键退出。
- en: Some people aren’t impressed with a computer printout. They need something more
    convincing, so in the next project, you’ll repackage your code in a more hands-on
    format—one that’s complete with doors, prizes, and goats. This will also satisfy
    Marilyn vos Savant’s appeal for schoolchildren to join in and help restore her
    honor.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人对计算机打印输出不感兴趣。他们需要更有说服力的东西，因此在下一个项目中，你将以一种更具动手性质的方式重新包装你的代码——一种完整的、有门、有奖品和有山羊的格式。这也将满足Marilyn
    vos Savant的呼吁，让学生们参与进来，帮助恢复她的声誉。
- en: '**Project #19: The Monty Hall Game**'
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**项目#19：蒙提霍尔游戏**'
- en: The three-door game used in the Monty Hall problem is simple enough for you
    to build with tkinter. You began working with tkinter graphics in [Chapter 10](ch10.xhtml#ch10).
    Now you’ll build on this knowledge by adding interactive buttons for the user
    to click.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 蒙提霍尔问题中的三门游戏足够简单，可以使用tkinter构建。你已经在[第10章](ch10.xhtml#ch10)开始接触tkinter图形。现在，你将在此基础上增加交互按钮供用户点击。
- en: '**THE OBJECTIVE**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标**'
- en: Simulate the Monty Hall problem using a GUI built with tkinter. Keep track of
    whether switching doors or staying put results in a win. In addition, update and
    display these statistics as the game is played.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用tkinter构建的GUI模拟蒙提霍尔问题。跟踪更换门或保持不变是否会导致获胜。此外，在游戏进行时更新并显示这些统计数据。
- en: '***A Brief Introduction to Object-Oriented Programming***'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***面向对象编程简要介绍***'
- en: The tkinter module was written using *object-oriented programming (OOP)*. OOP
    is a language model built around data structures, known as *objects*, consisting
    of *data* and *methods* and the interactions between them—as opposed to the *actions*
    and *logic* used in procedural programming. Objects are built from *classes*,
    which are like blueprints for the objects.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: tkinter模块是使用*面向对象编程（OOP）*编写的。OOP是一种围绕数据结构（称为*对象*）构建的语言模型，包含*数据*和*方法*以及它们之间的交互——与过程化编程中使用的*动作*和*逻辑*不同。对象是由*类*构建的，类就像对象的蓝图。
- en: OOP is an abstract concept and easier to appreciate when you’re writing large,
    complex programs. It reduces code duplication and makes code easier to update,
    maintain, and reuse. As a result, most commercial software is now built using
    OOP.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: OOP是一个抽象概念，写大型复杂程序时更容易理解。它减少了代码重复，使代码更易于更新、维护和重用。因此，大多数商业软件现在都是使用OOP构建的。
- en: 'If you implemented OOP in small programs, like the ones we’ve written so far,
    most of them would feel overengineered. In fact, one of my all-time favorite quotes,
    attributed to British computer scientist Joe Armstrong, concerns this aspect of
    OOP: “The problem with object-oriented languages is they’ve got all this implicit
    environment that they carry around with them. You wanted a banana, but what you
    got was a gorilla holding the banana and the entire jungle!”'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在小型程序中实现了OOP，就像我们迄今为止编写的那些程序，它们大多数会显得过于复杂。事实上，我最喜欢的一句名言，来自英国计算机科学家乔·阿姆斯特朗，正是关于OOP的这一方面：“面向对象语言的问题在于，它们携带着所有这些隐性环境。你想要一个香蕉，但你得到的是一个拿着香蕉的猩猩和整个丛林！”
- en: Despite this, the objects produced by OOP lend themselves very well to GUIs
    and gaming, even for some small projects. Let’s look at an example using a *Dungeons
    and Dragons*–type board game in which players can be different characters, such
    as dwarves, elves, and wizards. These games use character cards to list important
    information for each character type. If you let your playing piece represent a
    dwarf, it inherits the characteristics on the card (see [Figure 11-2](ch11.xhtml#ch11fig2)).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，OOP所生成的对象非常适合用于GUI和游戏，即使是一些小型项目。让我们看一个使用*地下城与龙*类型的桌面游戏的例子，玩家可以选择不同的角色，比如矮人、精灵和巫师。这些游戏使用角色卡片列出每个角色类型的重要信息。如果你让你的棋子代表矮人，它就会继承卡片上的特征（见[图11-2](ch11.xhtml#ch11fig2)）。
- en: '![image](../images/f0224-01.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0224-01.jpg)'
- en: '*Figure 11-2: A dwarf character card from a role-playing board game*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-2：角色扮演游戏中的矮人角色卡片*'
- en: '[Listings 11-3](ch11.xhtml#ch11list3) and [11-4](ch11.xhtml#ch11list4) reproduce
    board game–style play, letting you create virtual cards for a dwarf and an elf,
    name your pieces, and have them fight. The outcome of the fight will impact one
    of the character’s *body points*, which represent the character’s health. Be sure
    to note how OOP can allow you to easily create many identical objects—in this
    case, dwarves or elves—by “stamping” them out of the predefined template, called
    a *class*.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单11-3](ch11.xhtml#ch11list3)和[11-4](ch11.xhtml#ch11list4)重现了类似桌游的玩法，允许你为矮人和精灵创建虚拟卡片，命名你的棋子，并让它们进行战斗。战斗的结果会影响某个角色的*身体点数*，即代表角色生命的健康值。请注意，面向对象编程（OOP）如何允许你通过“复制”预定义的模板——即*类*——轻松地创建多个相同的对象，在这种情况下是矮人或精灵。'
- en: ➊ >>> import random
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ >>> import random
- en: '➋ >>> class Dwarf(object):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ >>> class Dwarf(object):'
- en: '➌ def __init__(self, name):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ >>> def __init__(self, name):'
- en: ➍ self.name = name
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ self.name = name
- en: self.attack = 3
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: self.attack = 3
- en: self.defend = 4
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: self.defend = 4
- en: self.body = 5
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: self.body = 5
- en: '➎ def talk(self):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ def talk(self):'
- en: print("I'm a blade-man, I'll cut ya!!!")
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: print("我是一个刀客，我会砍你！！！")
- en: ➏ >>> lenn = Dwarf("Lenn")
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ >>> lenn = Dwarf("Lenn")
- en: '>>> print("Dwarf name = {}".format(lenn.name))'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print("矮人名称 = {}".format(lenn.name))'
- en: Dwarf name = Lenn
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 矮人名称 = Lenn
- en: '>>> print("Lenn''s attack strength = {}".format(lenn.attack))'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print("Lenn的攻击力 = {}".format(lenn.attack))'
- en: Lenn's attack strength = 3
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Lenn的攻击力 = 3
- en: '>>>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '>>>'
- en: ➐ >>> lenn.talk()
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ >>> lenn.talk()
- en: I'm a blade-man, I'll cut ya!!!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我是一个刀客，我会砍你！！！
- en: '*Listing 11-3: Imports* random *module, creates a* Dwarf *class, and instantiates
    a dwarf object*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单11-3：导入* random *模块，创建一个* Dwarf *类，并实例化一个矮人对象*'
- en: Start by importing random to simulate rolling a die ➊; this is how your character
    will fight. Now define a class for a dwarf character, capitalizing the first letter
    of the class name, and pass it an object argument, which will be the name of your
    dwarf ➋. A class is a template for creating objects of a certain type. For example,
    when you create a list or dictionary, you are creating them from a class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入random来模拟掷骰子 ➊；这就是你的角色如何进行战斗的方式。现在为矮人角色定义一个类，类名的首字母大写，并传入一个对象参数，即你矮人的名字
    ➋。类是创建某一类型对象的模板。例如，当你创建一个列表或字典时，你是从一个类中创建它们的。
- en: The Dwarf class definition is like the card in [Figure 11-2](ch11.xhtml#ch11fig2);
    it is basically the genetic blueprint for a dwarf. It will assign *attributes*,
    like strength and vitality, and *methods*, like how the character moves or talks.
    Attributes are variables scoped to an *instance* of the class, and methods are
    attributes that also happen to be functions, which are passed a reference to their
    instance when they run. A class is a data type, and when you create an object
    of that data type, it is also known as an instance of that class. The process
    of setting the initial values and behaviors of the instance is called *instantiation*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Dwarf类定义就像[图11-2](ch11.xhtml#ch11fig2)中的卡片；它基本上是矮人的基因蓝图。它会分配*属性*，如力量和生命力，和*方法*，如角色如何移动或讲话。属性是作用于类的*实例*的变量，而方法是也恰好是函数的属性，当它们运行时会传入对它们实例的引用。类是一种数据类型，当你创建该数据类型的对象时，它也被称为该类的实例。设置实例的初始值和行为的过程称为*实例化*。
- en: 'Next, define a *constructor* method, also referred to as the *initialization*
    method. It sets up the initial attribute values for your object ➌. The __init__()
    method is a special built-in method that Python automatically invokes as soon
    as a new object is created. In this case, you’ll pass two arguments: self and
    the name of your object.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，定义一个*构造函数*方法，也叫*初始化*方法。它为你的对象设置初始的属性值 ➌。`__init__()`方法是一个特殊的内置方法，Python会在创建新对象时自动调用它。在这个方法中，你将传入两个参数：self
    和你的对象名称。
- en: The self parameter is a reference to the instance of this class that is being
    created, or a reference to the instance a method was invoked on, technically referred
    to as a *context* instance. If you create a new dwarf and name it “Steve,” self
    will become Steve behind the scenes. For example, self.attack becomes “Steve’s
    attack.” If you create another dwarf named “Sue,” self for that object will become
    “Sue.” This way, the scope of Steve’s health attribute is kept separate from Sue’s.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: self参数是对正在创建的类实例的引用，或者是方法被调用时的实例引用，技术上称为*上下文*实例。如果你创建一个新的矮人并命名为“Steve”，那么self将在幕后变成Steve。例如，self.attack会变成“Steve的攻击力”。如果你创建另一个矮人并命名为“Sue”，那么该对象的self将变成“Sue”。这样，Steve的健康属性范围与Sue的健康属性就被区分开了。
- en: Next, list some attributes for a dwarf beneath the constructor definition ➍.
    You’ll want a name so you can tell one dwarf from another, as well as the value
    of key combat characteristics. Notice how this list resembles the card in [Figure
    11-2](ch11.xhtml#ch11fig2).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在构造函数定义下列出一些矮人的属性 ➍。你需要一个名字以便区分不同的矮人，还有一些关键战斗属性。注意，这个列表与[图11-2](ch11.xhtml#ch11fig2)中的卡片相似。
- en: Define a talk() method and pass it self ➎. By passing it self, you link the
    method to the object. In more comprehensive games, methods might include behaviors
    like movement and the ability to disarm traps.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个talk()方法，并传递self ➎。通过传递self，你将方法与对象关联。在更全面的游戏中，方法可能包括诸如移动和解除陷阱的行为。
- en: With the class definition complete, create an instance of the Dwarf class and
    assign this object to the local variable lenn, the dwarf’s name ➏. Now, print
    the name and attack attributes to demonstrate that you have access to them. Finish
    by invoking the talk() method ➐. This should display a message.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义完成后，创建一个Dwarf类的实例，并将该对象分配给本地变量lenn，这是矮人的名字 ➏。现在，打印名字和攻击属性，以展示你已经可以访问它们。最后调用talk()方法
    ➐。这应该显示一条信息。
- en: '[Listing 11-4](ch11.xhtml#ch11list4) creates an elf character, using the same
    process you used in [Listing 11-3](ch11.xhtml#ch11list3), and has it fight the
    dwarf. The elf’s body attribute is updated to reflect the outcome of the battle.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单11-4](ch11.xhtml#ch11list4)创建一个精灵角色，使用你在[清单11-3](ch11.xhtml#ch11list3)中使用的相同过程，并让它与矮人战斗。精灵的生命属性会根据战斗结果进行更新。'
- en: '➊ >>> class Elf(object):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ >>> class Elf(object):'
- en: 'def __init__(self, name):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, name):'
- en: self.name = name
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: self.name = name
- en: self.attack = 4
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: self.attack = 4
- en: self.defend = 4
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: self.defend = 4
- en: self.body = 4
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: self.body = 4
- en: '>>> esseden = Elf("Esseden")'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> esseden = Elf("Esseden")'
- en: '>>> print("Elf name = {}".format(esseden.name))'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print("精灵名字 = {}".format(esseden.name))'
- en: Elf name = Esseden
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 精灵名字 = Esseden
- en: '>>> print("Esseden body value = {}".format(esseden.body))'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print("Esseden生命值 = {}".format(esseden.body))'
- en: Esseden body value = 4
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Esseden生命值 = 4
- en: '>>>'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '>>>'
- en: ➋ >>> lenn_attack_roll = random.randrange(1, lenn.attack + 1)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ >>> lenn_attack_roll = random.randrange(1, lenn.attack + 1)
- en: '>>> print("Lenn attack roll = {}".format(lenn_attack_roll))'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print("Lenn攻击掷骰 = {}".format(lenn_attack_roll))'
- en: Lenn attack roll = 3
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Lenn攻击掷骰 = 3
- en: ➌ >>> esseden_defend_roll = random.randrange(1, esseden.defend + 1)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ >>> esseden_defend_roll = random.randrange(1, esseden.defend + 1)
- en: '>>> print("Esseden defend roll = {}".format(esseden_defend_roll))'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> print("Esseden防御掷骰 = {}".format(esseden_defend_roll))'
- en: Esseden defend roll = 1
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Esseden防御掷骰 = 1
- en: '>>>'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '>>>'
- en: ➍ >>> damage = lenn_attack_roll - esseden_defend_roll
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ >>> damage = lenn_attack_roll - esseden_defend_roll
- en: '>>> if damage > 0:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '>>> if damage > 0:'
- en: esseden.body -= damage
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: esseden.body -= damage
- en: ➎ >>> print("Esseden body value = {}".format(esseden.body))
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ >>> print("Esseden生命值 = {}".format(esseden.body))
- en: Esseden body value = 2
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Esseden生命值 = 2
- en: '*Listing 11-4: Creates an* Elf *class, instantiates an elf object, simulates
    a battle, and updates an object attribute*'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单11-4：创建一个* 精灵 *类，实例化一个精灵对象，模拟一场战斗，并更新对象属性*'
- en: Define an Elf class and provide some attributes ➊. Make them slightly different
    from the dwarf’s and well balanced, like an elf. Instantiate an elf named Esseden
    and access his name and body attributes using print.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个精灵类，并提供一些属性 ➊。使它们与矮人有所不同，并且像精灵一样平衡。实例化一个名为Esseden的精灵，并使用print访问他的名字和生命属性。
- en: Have your two characters interact using the roll of a virtual die with a maximum
    value equal to the character’s attack or defend value. Use the random module to
    choose a roll value in a range of 1 to Lenn’s attack attribute plus 1 ➋, then
    repeat this process to get Esseden’s defense ➌. Calculate the damage to Esseden
    by subtracting Esseden’s roll value from Lenn’s roll value ➍, and if the damage
    is a positive number, subtract it from Esseden’s body attribute. Use print() to
    confirm the elf’s current health ➎.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟骰子的掷骰结果来让你的两个角色进行互动，虚拟骰的最大值等于角色的攻击或防御值。使用random模块从1到Lenn的攻击属性加1的范围中选择一个掷骰值
    ➋，然后重复此过程获取Esseden的防御值 ➌。通过将Esseden的掷骰值从Lenn的掷骰值中减去 ➍，计算对Esseden的伤害，如果伤害为正数，则从Esseden的生命属性中扣除它。使用print()来确认精灵的当前生命值
    ➎。
- en: As you can imagine, building many similar characters and keeping track of their
    changing attributes could quickly get complicated with procedural programming.
    OOP provides a modular structure for your program, makes it easy to hide complexity
    and ownership of scope with encapsulation, permits problem solving in bite-sized
    chunks, and produces sharable templates that can be modified and used elsewhere.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，构建许多相似的角色并跟踪它们变化的属性，在过程式编程中会变得非常复杂。面向对象编程（OOP）为你的程序提供了模块化结构，便于通过封装隐藏复杂性和作用域的所有权，允许以小块的方式解决问题，并生成可共享的模板，可以在其他地方修改和使用。
- en: '***The Strategy and Pseudocode***'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***策略与伪代码***'
- en: 'Now back to our three-door game. The rules for the game form the bulk of the
    pseudocode for the program:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到我们的三门游戏。游戏的规则构成了程序伪代码的主体部分：
- en: Initialize game window and show closed doors and instructions
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化游戏窗口并显示已关闭的门和说明
- en: Choose winning door at random
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 随机选择获胜门
- en: Get player's door choice
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 获取玩家的门选择
- en: Reveal a door that isn't the winning door or the player's choice
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 显示不是获胜门或玩家选择的门
- en: Get player's choice to switch doors or not
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 获取玩家是否换门的选择
- en: 'If player switches:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家换门：
- en: Reveal new door
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 显示新门
- en: 'If winner:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果获胜者：
- en: Record as win for switching
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 记录换门后的胜利
- en: 'Otherwise:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: Record as win for staying put
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 记录保持原样的胜利
- en: 'Else if player stays with first choice:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 否则如果玩家坚持初始选择：
- en: Reveal chosen door
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 显示玩家选择的门
- en: 'If winner:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果获胜者：
- en: Record as win for staying put
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 记录保持原样的胜利
- en: 'Otherwise:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: Record as win for switching
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 记录换门后的胜利
- en: Display number of wins for each strategy in game window
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏窗口中显示每种策略的获胜次数
- en: Reset game and close all doors
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 重置游戏并关闭所有门
- en: It’s useful to start designing a game by sketching out how the game window should
    look, complete with instructions, messages, and button types. I doubt you want
    to see my crude scribblings, so instead check out [Figure 11-3](ch11.xhtml#ch11fig3).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 开始设计游戏时，最好先草拟出游戏窗口的外观，包括说明、消息和按钮类型。我猜你不想看到我粗糙的涂鸦，所以不妨看看[图 11-3](ch11.xhtml#ch11fig3)。
- en: '![image](../images/f0227-01.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0227-01.jpg)'
- en: '*Figure 11-3: View of the game window after the first round of play*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-3：第一轮游戏后的游戏窗口视图*'
- en: This is how the finished game will look after the first round, with the win
    statistics visible at the far right. Note that the radio buttons for changing
    doors are grayed out until an initial pick has been made.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是游戏完成后的第一轮样式，右侧显示了获胜统计数据。请注意，换门的单选按钮在玩家做出初始选择之前是灰色的，无法操作。
- en: '***Game Assets***'
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***游戏资产***'
- en: '*Game assets* is a fancy term for things that you’ll need to build the game.
    These will consist of a series of images to represent the doors, goats, and prize
    ([Figure 11-4](ch11.xhtml#ch11fig4)).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '*游戏资产*是指构建游戏时需要的各种元素。这些元素将包括一系列图像，用于表示门、山羊和奖品（[图 11-4](ch11.xhtml#ch11fig4)）。'
- en: '![image](../images/f0228-01.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0228-01.jpg)'
- en: '*Figure 11-4: Building-block images for the* monty_hall_gui.py *program*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-4：*monty_hall_gui.py* 程序的构建块图像*'
- en: I used Microsoft PowerPoint to composite the 3 base images into 10 images that
    represent all the possible states of the game ([Figure 11-5](ch11.xhtml#ch11fig5)).
    This was a design decision; with extra lines of code, I could have obtained the
    same results using only the base images.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用 Microsoft PowerPoint 将三张基础图像合成了 10 张图像，表示游戏的所有可能状态（[图 11-5](ch11.xhtml#ch11fig5)）。这是一个设计决策；通过增加几行代码，我也可以仅使用基础图像获得相同的结果。
- en: '![image](../images/f0228-02.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0228-02.jpg)'
- en: '*Figure 11-5: Composited images for the* monty_hall_gui.py *program*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-5：*monty_hall_gui.py* 程序的合成图像*'
- en: '***The Monty Hall Game Code***'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***蒙提霍尔游戏代码***'
- en: The *monty_hall_gui.py* program described in this section turns the Monty Hall
    problem into a fun and educational game. You will also need the 10 game assets
    shown in [Figure 11-5](ch11.xhtml#ch11fig5). Download them from *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    and keep all the files in the same folder.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中描述的 *monty_hall_gui.py* 程序将蒙提霍尔问题转化为一个有趣且富有教育意义的游戏。你还需要[图 11-5](ch11.xhtml#ch11fig5)中显示的
    10 个游戏资产。请从 *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*
    下载它们，并将所有文件保存在同一个文件夹中。
- en: '**Importing Modules and Defining the Game Class**'
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**导入模块并定义游戏类**'
- en: '[Listing 11-5](ch11.xhtml#ch11list5) imports modules and defines the Game class
    and the initialization method, __init__().'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-5](ch11.xhtml#ch11list5) 导入了模块并定义了游戏类和初始化方法 __init__()。'
- en: '*monty_hall_gui.py,* part 1'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*monty_hall_gui.py，* 第一部分'
- en: ➊ import random
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ import random
- en: import tkinter as tk
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: import tkinter as tk
- en: '➋ class Game(tk.Frame):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '➋ class Game(tk.Frame):'
- en: '"""GUI application for Monty Hall Problem game."""'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '"""蒙提霍尔问题游戏的 GUI 应用程序。"""'
- en: ➌ doors = ('a', 'b', 'c')
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ doors = ('a', 'b', 'c')
- en: '➍ def __init__(self, parent):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ def __init__(self, parent):'
- en: '"""Initialize the frame."""'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '"""初始化框架。"""'
- en: ➎ super(Game, self).__init__(parent)  # parent will be the root window
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ super(Game, self).__init__(parent)  # 父对象将是根窗口
- en: ➏ self.parent = parent
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ self.parent = parent
- en: self.img_file = 'all_closed.png'  # current image of doors
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: self.img_file = 'all_closed.png'  # 当前的门图片
- en: self.choice = ''  # player's door choice
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: self.choice = ''  # 玩家选择的门
- en: self.winner = ''  # winning door
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: self.winner = ''  # 获胜的门
- en: self.reveal = ''  # revealed goat door
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: self.reveal = ''  # 揭示的山羊门
- en: ➐ self.first_choice_wins = 0  # counter for statistics
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ self.first_choice_wins = 0  # 统计用的计数器
- en: self.pick_change_wins = 0  # counter for statistics
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: self.pick_change_wins = 0  # 统计用的计数器
- en: ➑ self.create_widgets()
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ self.create_widgets()
- en: '*Listing 11-5: Imports modules and defines the* Game *class and* _ _init_ _()
    *method*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-5：导入模块并定义* Game *类和* _ _init_ _() *方法*'
- en: Start by importing the random and tkinter modules ➊. Next, define a class called
    Game ➋. The *ancestor* for this class, shown in parentheses, will be a tkinter
    Frame class. This means that the Game class is *derived* from the existing Frame
    “base” class and will conveniently inherit useful methods from it. The Frame widget
    mainly serves as a geometry master for other widgets, helping to group them into
    complex layouts.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入 random 和 tkinter 模块 ➊。接下来，定义一个名为 Game 的类 ➋。该类的 *祖先*，在括号中显示，将是 tkinter 的
    Frame 类。这意味着 Game 类是从现有的 Frame “基类”派生出来的，并且将方便地继承其中的有用方法。Frame 小部件主要作为其他小部件的几何布局管理器，帮助将它们组合成复杂的布局。
- en: Note that classes have their own docstring conventions, which you can find at
    *[https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/)*.
    As stated in [Chapter 1](ch01.xhtml#ch01), I will mainly show single-line docstrings
    in this book for brevity.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，类有其自己的文档字符串约定，您可以在 *[https://www.python.org/dev/peps/pep-0257/](https://www.python.org/dev/peps/pep-0257/)*
    找到相关信息。如[第1章](ch01.xhtml#ch01)所述，本书为了简洁起见，主要展示单行文档字符串。
- en: Every instance of Game will use the same three doors, so you can use a *class
    attribute* for this ➌. Any variable assigned a value outside of a method becomes
    a class attribute, much as variables assigned outside of functions in procedural
    programs become global variables. You don’t want this attribute to get changed
    inadvertently, so make it immutable by using a tuple. Later, you’ll make lists
    from this tuple whenever you want to manipulate the doors.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Game 实例将使用相同的三扇门，因此你可以使用 *类属性* 来表示这一点 ➌。任何在方法外部赋值的变量都会成为类属性，类似于程序性程序中在函数外部赋值的变量成为全局变量。为了防止该属性被意外修改，可以使用元组使其不可变。以后，当你想操作门时，可以从这个元组创建列表。
- en: Now, just as with the earlier dwarf and elf examples, define an initializer
    method for the game object ➍. A self parameter is required, but you’ll also need
    a parent, which will be the root window that will hold the game.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像之前的矮人和精灵示例一样，为游戏对象定义一个初始化方法 ➍。需要一个 self 参数，但你还需要一个父对象，即将承载游戏的根窗口。
- en: A base class can also be called a *superclass*, and the super() function lets
    you invoke the method of a superclass to gain access to inherited methods—in this
    case, from a parent class. First, pass Game to super(), which means you want to
    invoke a method of the superclass of Game, which is Frame ➎. Then pass it self
    as an argument to reference the newly instantiated Game object. The __init__(parent)
    part of the statement invokes the initializer method of Frame with parent (the
    root window) as the argument. Now attributes in the prebuilt tkinter Frame class
    can be used by your Game object. Note that this statement can be simplified to
    super().__init__().
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 基类也可以称为 *父类*，而 super() 函数让你调用父类的方法以访问继承的方法——在本例中，来自父类。首先，将 Game 传递给 super()，这意味着你希望调用
    Game 的父类 Frame 的方法 ➎。然后，将 self 作为参数传递，以引用新实例化的 Game 对象。语句中的 __init__(parent) 部分调用了
    Frame 的初始化方法，并将 parent（根窗口）作为参数传入。现在，预构建的 tkinter Frame 类中的属性可以被 Game 对象使用。请注意，这个语句可以简化为
    super().__init__()。
- en: Next, assign values to a series of instance attributes ➏. It is best to initialize
    attributes through the __init__() method, as it is the first method called after
    an object is created. This way, these attributes will be immediately available
    to any other methods in the class. Start by assigning the parent, which will be
    the root window, to the instance. Then name an attribute to hold one of the image
    files (shown in [Figure 11-5](ch11.xhtml#ch11fig5)) and assign it the image with
    all the doors closed, which is what the player will see at the start of each game.
    Next, name attributes for the player’s door choice, the winning door, and the
    door used to reveal the first goat.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为一系列实例属性分配值 ➏。最好通过__init__()方法初始化属性，因为它是在创建对象后第一个被调用的方法。这样，这些属性会立即对类中的任何其他方法可用。首先，分配父级，这将是根窗口。然后定义一个属性，用于存储其中一个图像文件（如[图11-5](ch11.xhtml#ch11fig5)所示），并将其分配为所有门关闭的图像，这是玩家在每次游戏开始时看到的。接下来，定义属性来保存玩家选择的门、获胜的门，以及用来揭示第一只山羊的门。
- en: Use a counter to keep track of the number of wins achieved if the player sticks
    with the first door choice and another to record wins achieved when the player
    switches doors ➐. Finally, call a method that will create the label, button, and
    text widgets needed to run the game ➑.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用计数器跟踪玩家坚持最初选择的门时取得的胜利次数，并使用另一个计数器记录玩家换门后获得的胜利次数 ➐。最后，调用一个方法，创建运行游戏所需的标签、按钮和文本小部件
    ➑。
- en: '**Creating Widgets for Images and Instructions**'
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建图像和说明的小部件**'
- en: '[Listing 11-6](ch11.xhtml#ch11list6) defines the first part of the create_widgets()
    method, used to build the labels, buttons, and text widgets for the game. The
    first two widgets will be tkinter labels used to display the images in [Figure
    11-5](ch11.xhtml#ch11fig5) and to provide game instructions.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-6](ch11.xhtml#ch11list6) 定义了create_widgets()方法的第一部分，用于构建游戏的标签、按钮和文本小部件。前两个小部件将是tkinter标签，用于显示[图11-5](ch11.xhtml#ch11fig5)中的图像，并提供游戏说明。'
- en: '*monty_hall_gui.py,* part 2'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*monty_hall_gui.py，* 第2部分'
- en: '➊ def create_widgets(self):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def create_widgets(self):'
- en: '"""Create label, button, and text widgets for game."""'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '"""为游戏创建标签、按钮和文本小部件。"""'
- en: '# create label to hold image of doors'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建标签以显示门的图像'
- en: ➋ img = tk.PhotoImage(file='all_closed.png')
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ img = tk.PhotoImage(file='all_closed.png')
- en: ➌ self.photo_lbl = tk.Label(self.parent, image=img,
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ self.photo_lbl = tk.Label(self.parent, image=img,
- en: text='', borderwidth=0)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: text='', borderwidth=0)
- en: ➍ self.photo_lbl.grid(row=0, column=0, columnspan=10, sticky='W')
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ self.photo_lbl.grid(row=0, column=0, columnspan=10, sticky='W')
- en: ➎ self.photo_lbl.image = img
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ self.photo_lbl.image = img
- en: '# create the instruction label'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建说明标签'
- en: ➏ instr_input = [
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ instr_input = [
- en: ('Behind one door is CASH!', 1, 0, 5, 'W'),
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: ('在一扇门后面是现金！', 1, 0, 5, 'W'),
- en: ('Behind the others:  GOATS!!!', 2, 0, 5, 'W'),
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '(''在其他选项后面: GOATS!!!'', 2, 0, 5, ''W''),'
- en: ('Pick a door:', 1, 3, 1, 'E')
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ('选择一扇门:', 1, 3, 1, 'E')
- en: ']'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '➐ for text, row, column, columnspan, sticky in instr_input:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '➐ 对于text、row、column、columnspan、sticky中的每一项:'
- en: instr_lbl = tk.Label(self.parent, text=text)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: instr_lbl = tk.Label(self.parent, text=text)
- en: instr_lbl.grid(row=row, column=column, columnspan=columnspan,
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: instr_lbl.grid(row=row, column=column, columnspan=columnspan,
- en: sticky=sticky, ➑ipadx=30)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: sticky=sticky, ➑ipadx=30)
- en: '*Listing 11-6: Defines a method to create widgets*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-6：定义了一个创建小部件的方法*'
- en: Define a method, called create_widgets(), that takes self as an argument ➊.
    Then assign an attribute to hold an image of the doors ➋. Note that you don’t
    have to precede this attribute name with self, as it will be used only locally
    within the method. The PhotoImage class, which takes the image filename as an
    argument, is used by tkinter to display images in canvas, label, text, or button
    widgets. After this step, you can use the image in a tkinter label, so assign
    a photo_lbl variable, pass it the parent and image as arguments, and specify no
    text and a thin border ➌.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个方法，称为create_widgets()，该方法接受self作为参数 ➊。然后为该方法分配一个属性，用于存储门的图像 ➋。请注意，你不必在该属性名前加上self，因为它只会在方法内部局部使用。tkinter使用PhotoImage类，该类以图像文件名作为参数，用于在画布、标签、文本或按钮小部件中显示图像。完成这一步后，你可以在tkinter标签中使用该图像，因此定义一个photo_lbl变量，将父级和图像作为参数传递，并指定无文本和细边框
    ➌。
- en: To place the label in the parent window, use the grid() method and pass it the
    first row and first column, let the image span 10 columns, and left-justify it
    using W ➍. This will fill the top part of the window with the image of the closed
    doors. The columnspan option lets the widget span more than one column. The value
    won’t affect the image size but *will* change the number of locations available
    for placing the instruction text and other widgets below the image. For example,
    if you set columnspan=2, you’ll have only two columns available for placing instructions,
    buttons, and messages.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要将标签放入父窗口中，使用 `grid()` 方法并传递给它第一行和第一列，让图像横跨 10 列，并使用 W ➍ 使其左对齐。这将填充窗口顶部的闭门图像。`columnspan`
    选项允许小部件跨越多于一列。该值不会影响图像的大小，但*会*改变放置指示文本和其他小部件的可用位置数量。例如，如果你将 `columnspan=2`，那么你将只有两个列可以放置指示、按钮和消息。
- en: Finish the photo label by creating a reference to the image object ➎. If you
    don’t do this, the image won’t always show up.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建对图像对象的引用 ➎ 来完成照片标签。如果你不这样做，图像将无法始终显示。
- en: According to the tkinter documentation, tkinter is a layer built over another
    product (Tk), and the interface between the two doesn’t handle references to image
    objects properly. The Tk widget holds a reference to the internal object, but
    tkinter doesn’t. Python uses a garbage-collector module to automatically reclaim
    memory from objects no longer needed. When the garbage collector in Python’s memory
    allocator discards the tkinter object, tkinter tells Tk to release the image.
    But because it’s in use, Tk can’t, so it sets it to transparent instead. Suggestions
    for solving the problem include using a global variable, using an instance attribute,
    or as you did here, adding an attribute to the widget instance (photo_lbl.image
    = img). For more information, see *[http://effbot.org/tkinterbook/photoimage.htm](http://effbot.org/tkinterbook/photoimage.htm)*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 tkinter 文档，tkinter 是建立在另一个产品 (Tk) 之上的一层，而这两者之间的接口并未正确处理对图像对象的引用。Tk 小部件持有对内部对象的引用，但
    tkinter 并没有。Python 使用垃圾回收模块自动回收不再需要的对象的内存。当 Python 内存分配器的垃圾回收器丢弃 tkinter 对象时，tkinter
    会告诉 Tk 释放图像。但由于图像仍在使用中，Tk 无法释放，因此它将图像设置为透明。解决此问题的建议包括使用全局变量、使用实例属性，或者像你在这里所做的那样，为小部件实例添加属性（`photo_lbl.image
    = img`）。更多信息，请参考 *[http://effbot.org/tkinterbook/photoimage.htm](http://effbot.org/tkinterbook/photoimage.htm)*。
- en: Finally, add the instruction text as label widgets. The process is to provide
    a list of parameters and then loop through them to build the widgets. Start with
    a list of tuples ➏, where each tuple contains the options for making a Label object;
    you can see what each represents in the next statement ➐. As you progress through
    the for loop, create each label in the parent window and assign it some text.
    Then use the grid() method to place the text, based on the information in the
    list of tuples, into the window.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加作为标签小部件的指示文本。这个过程是提供一系列参数，然后通过它们来循环构建小部件。首先，创建一个包含元组的列表 ➏，每个元组包含创建 Label
    对象的选项；你可以在下一个语句 ➐ 中看到每个元组所代表的内容。随着你在 for 循环中逐步执行，为每个标签在父窗口中创建并赋予一些文本。然后，使用 `grid()`
    方法根据元组列表中的信息，将文本放置到窗口中。
- en: Use the ipadx option with grid() ➑. This option refers to internal padding in
    the x-direction within the label, so you can play with it to tweak the appearance
    of the text in the window. In this case, you add 30 pixels to the label so that
    the text will align in a visually pleasing way.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ipadx` 选项与 `grid()` 配合使用 ➑。此选项指的是标签内 x 方向的内边距，你可以调整它来微调文本在窗口中的显示效果。在这种情况下，你为标签添加了
    30 像素，以使文本对齐得更加美观。
- en: '**Creating Radio Buttons and Text Widgets**'
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建单选按钮和文本小部件**'
- en: '[Listing 11-7](ch11.xhtml#ch11list7) continues the definition of the create_widgets()
    method by creating radio button widgets for the three doors. The player makes
    their initial door choice by selecting the A, B, or C radio button. Their choice
    is then processed by the win_reveal() method, which you’ll build later. This method
    will determine the winning door and reveal a goat.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-7](ch11.xhtml#ch11list7) 继续定义 `create_widgets()` 方法，通过为三个门创建单选按钮小部件。玩家通过选择
    A、B 或 C 单选按钮来做出初始的门选择。然后，他们的选择将由 `win_reveal()` 方法处理，你将在后续的部分构建这个方法。该方法将确定获胜的门并揭示一只山羊。'
- en: Another set of radio buttons is created to get the player’s choice to switch
    doors or not. The result will be processed by the show_final() method, also defined
    later. Besides revealing what’s behind the player’s final door choice, this method
    will update the win statistics, using Text widgets defined at the end of this
    listing.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组单选按钮用于获取玩家是否选择更换门的决定。结果将由 show_final() 方法处理，后者也会在稍后定义。除了揭示玩家最终选择的门后面是什么外，该方法还会更新胜利统计，使用在本清单末尾定义的
    Text 小部件。
- en: '*monty_hall_gui.py,* part 3'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*monty_hall_gui.py,* 第3部分'
- en: '# create radio buttons for getting initial user choice'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建用于获取初始用户选择的单选按钮'
- en: ➊ self.door_choice = tk.StringVar()
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ self.door_choice = tk.StringVar()
- en: self.door_choice.set(None)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: self.door_choice.set(None)
- en: ➋ a = tk.Radiobutton(self.parent, text='A', variable=self.door_choice,
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ a = tk.Radiobutton(self.parent, text='A', variable=self.door_choice,
- en: value='a', command=self.win_reveal)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: value='a', command=self.win_reveal)
- en: b = tk.Radiobutton(self.parent, text='B', variable=self.door_choice,
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: b = tk.Radiobutton(self.parent, text='B', variable=self.door_choice,
- en: value='b', command=self.win_reveal)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: value='b', command=self.win_reveal)
- en: c = tk.Radiobutton(self.parent, text='C', variable=self.door_choice,
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: c = tk.Radiobutton(self.parent, text='C', variable=self.door_choice,
- en: value='c', command=self.win_reveal)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: value='c', command=self.win_reveal)
- en: '# create widgets for changing door choice'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建小部件以更改门的选择'
- en: ➌ self.change_door = tk.StringVar()
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ self.change_door = tk.StringVar()
- en: self.change_door.set(None)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: self.change_door.set(None)
- en: ➍ instr_lbl = tk.Label(self.parent, text='Change doors?')
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ instr_lbl = tk.Label(self.parent, text='更改门吗？')
- en: instr_lbl.grid(row=2, column=3, columnspan=1, sticky='E')
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: instr_lbl.grid(row=2, column=3, columnspan=1, sticky='E')
- en: ➎ self.yes = tk.Radiobutton(self.parent, state='disabled', text='Y',
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ self.yes = tk.Radiobutton(self.parent, state='disabled', text='Y',
- en: variable=self.change_door, value='y',
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: variable=self.change_door, value='y',
- en: command=self.show_final)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: command=self.show_final)
- en: self.no = tk.Radiobutton(self.parent, state='disabled', text='N',
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: self.no = tk.Radiobutton(self.parent, state='disabled', text='N',
- en: variable=self.change_door, value='n',
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: variable=self.change_door, value='n',
- en: command=self.show_final)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: command=self.show_final)
- en: '# create text widgets for win statistics'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建用于显示胜利统计的文本小部件'
- en: ➏ defaultbg = self.parent.cget('bg')
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ defaultbg = self.parent.cget('bg')
- en: ➐ self.unchanged_wins_txt = tk.Text(self.parent, width=20,
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ self.unchanged_wins_txt = tk.Text(self.parent, width=20,
- en: height=1, wrap=tk.WORD,
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: height=1, wrap=tk.WORD,
- en: bg=defaultbg, fg='black',
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: bg=defaultbg, fg='black',
- en: borderwidth=0)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: borderwidth=0)
- en: self.changed_wins_txt = tk.Text(self.parent, width=20,
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: self.changed_wins_txt = tk.Text(self.parent, width=20,
- en: height=1, wrap=tk.WORD, bg=defaultbg,
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: height=1, wrap=tk.WORD, bg=defaultbg,
- en: fg='black', borderwidth=0)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: fg='black', borderwidth=0)
- en: '*Listing 11-7: Builds radio buttons and text widgets for the* create_widgets()
    *method*'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-7: 为* create_widgets() *方法构建单选按钮和文本小部件*'
- en: Start by creating radio buttons for doors A, B, and C. When a user interacts
    with a tkinter widget, the result is an *event*. You can use variables to track
    these events, such as when the player selects a door by pressing a radio button.
    For widget-specific variables, tkinter has a variable class. Use the *string*
    variable class, StringVar, and assign it to a variable named door_choice ➊. Immediately
    use the set() method to assign the variable a value of None.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建门 A、B 和 C 的单选按钮。当用户与 tkinter 小部件交互时，结果是一个*事件*。你可以使用变量来跟踪这些事件，例如当玩家通过按下单选按钮选择一扇门时。对于特定于小部件的变量，tkinter
    有一个变量类。使用*字符串*变量类 StringVar，并将其分配给名为 door_choice 的变量 ➊。立即使用 set() 方法将变量的值设置为 None。
- en: Next, set up the button widgets for the three doors ➋. The player will click
    on one of these for their first door pick. Use the Radiobutton class and pass
    it the parent window, the text to display, the door_choice variable you just assigned,
    a value equal to the door name, and a command. The command calls the win_reveal()
    method, which you’ll define shortly. Note that you don’t include the parentheses
    after the method name.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，设置三个门的按钮小部件 ➋。玩家将点击这些按钮中的一个，作为他们的第一次门选择。使用 Radiobutton 类，并传递父窗口、显示的文本、刚刚分配的
    door_choice 变量、一个等于门名的值以及一个命令。该命令会调用 win_reveal() 方法，稍后你会定义这个方法。注意，你不需要在方法名后加上括号。
- en: Repeat this process for buttons B and C. This is mainly a cut-and-paste exercise,
    because all you need to change are the door designations.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对 B 和 C 按钮重复此过程。这主要是一个复制粘贴的练习，因为你只需要更改门的名称。
- en: Now, build the radio buttons for switching doors. Start by making another string
    variable, as you did for the initial door choice ➌. This will hold either y or
    n, depending on which radio button is selected.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构建用于切换门的单选按钮。像你为初始门选择创建的字符串变量 ➌ 一样，创建另一个字符串变量。根据选中的单选按钮，它将保存 y 或 n。
- en: Build an instruction label using the Label class ➍. Then build the self.yes
    radio button ➎. Use the Radiobutton class, pass it the parent window, and set
    its state to disabled. This way, the window will initialize with the yes/no buttons
    grayed out, so the player can’t jump the gun and try to change a door before first
    choosing one. The text parameter is the button name; use an abbreviated Y for
    *yes*. Set the widget’s variable argument to the change_door variable, set its
    value to y, and call the show_final() function. Repeat the process for the no
    button.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Label 类构建一个指示标签 ➍。然后构建 self.yes 单选按钮 ➎。使用 Radiobutton 类，将父窗口传递给它，并将其状态设置为禁用。这样，窗口会初始化时，yes/no
    按钮是灰色的，防止玩家在选择一个门之前就试图更改门。text 参数是按钮的名称；使用简化的 Y 来表示 *yes*。将小部件的变量参数设置为 change_door
    变量，将其值设置为 y，并调用 show_final() 函数。对 no 按钮重复这个过程。
- en: The last widgets you’ll need are Text widgets to show the counts for switching
    doors versus staying put. Use the Text class to display the statistics and set
    the text box color to match the parent window. To do this, use cget() to get the
    background (bg) color of parent and then assign it to a variable ➏. The cget()
    method returns the current value for a tkinter option as a string.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的最后几个小部件是 Text 小部件，用于显示更换门与保持原门的次数。使用 Text 类来显示统计信息，并将文本框的颜色设置为与父窗口匹配。为此，使用
    cget() 方法获取父窗口的背景色（bg），然后将其分配给变量 ➏。cget() 方法返回 tkinter 选项的当前值，作为字符串。
- en: Create a text object to display the wins for sticking with the first choice
    ➐. You need to pass the widget the parent window, a width and height, how to wrap
    text if it extends beyond a row, a background color, a foreground color—the text
    color—and a border width for the text box. Note that you don’t include any actual
    text; this will be added later by the show_final() method.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个文本对象来显示坚持选择第一个选项的胜利次数 ➐。你需要将父窗口、宽度和高度、当文本超出一行时如何换行、背景色、前景色（即文本颜色）以及文本框的边框宽度传递给小部件。请注意，实际的文本不会被包含在内；这将在稍后的
    show_final() 方法中添加。
- en: Finish with another text widget to display the number of wins attributed to
    switching doors.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后再添加一个文本小部件，显示因更换门而获得的胜利次数。
- en: '**Arranging the Widgets**'
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**排列小部件**'
- en: '[Listing 11-8](ch11.xhtml#ch11list8) completes the create_widgets() method
    by using the tkinter Grid geometry manager to position the remaining nongridded
    widgets in the game window.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-8](ch11.xhtml#ch11list8) 完成了 create_widgets() 方法，通过使用 tkinter Grid 布局管理器将剩余的未网格化小部件定位到游戏窗口中。'
- en: '*monty_hall_gui.py,* part 4'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*monty_hall_gui.py*，第 4 部分'
- en: '# place the widgets in the frame'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '# 将小部件放置在框架中'
- en: ➊ a.grid(row=1, column=4, sticky='W', padx=20)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ a.grid(row=1, column=4, sticky='W', padx=20)
- en: b.grid(row=1, column=4, sticky='N', padx=20)
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: b.grid(row=1, column=4, sticky='N', padx=20)
- en: c.grid(row=1, column=4, sticky='E', padx=20)
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: c.grid(row=1, column=4, sticky='E', padx=20)
- en: self.yes.grid(row=2, column=4, sticky='W', padx=20)
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: self.yes.grid(row=2, column=4, sticky='W', padx=20)
- en: self.no.grid(row=2, column=4, sticky='N', padx=20)
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: self.no.grid(row=2, column=4, sticky='N', padx=20)
- en: ➋ self.unchanged_wins_txt.grid(row=1, column=5, columnspan=5)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ self.unchanged_wins_txt.grid(row=1, column=5, columnspan=5)
- en: self.changed_wins_txt.grid(row=2, column=5, columnspan=5)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: self.changed_wins_txt.grid(row=2, column=5, columnspan=5)
- en: '*Listing 11-8: Calls the* grid() *method on the widgets to position them in
    the frame*'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-8：调用* grid() *方法对小部件进行定位*'
- en: 'Use grid() to position the door buttons in the parent window ➊. Group the three
    door buttons together in the same row and column and separate them using the sticky
    justification: W means left, N is center, and E is right. Use padx to tweak the
    positions laterally. Repeat this process for the remaining buttons, then position
    the win statistics text widgets and allow them to span the five columns on the
    right side of the window ➋.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 grid() 方法将门按钮定位到父窗口 ➊。将三个门按钮组合在同一行和列中，并使用 sticky 对齐方式分隔它们：W 表示左对齐，N 表示居中，E
    表示右对齐。使用 padx 来稍微调整它们的横向位置。对其余的按钮重复此过程，然后将胜利统计文本小部件定位到窗口右侧的五列区域 ➋。
- en: '**Updating the Door Image**'
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**更新门的图像**'
- en: You’ll need to open and close doors throughout the game, so [Listing 11-9](ch11.xhtml#ch11list9)
    defines a helper method to update the door image as appropriate. Note that, with
    OOP, you don’t need to pass a filename to the method as an argument. All the methods
    for an object have direct access to attributes that begin with self.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个游戏过程中，你将需要打开和关闭门，因此 [列表 11-9](ch11.xhtml#ch11list9) 定义了一个辅助方法来根据需要更新门的图像。请注意，在面向对象编程（OOP）中，你无需将文件名作为参数传递给该方法。所有对象的方法都有直接访问以
    self 开头的属性。
- en: '*monty_hall_gui.py,* part 5'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '*monty_hall_gui.py*，第 5 部分'
- en: '➊ def update_image(self):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def update_image(self):'
- en: '"""Update current doors image."""'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '"""更新当前门的图片。"""'
- en: ➋ img = tk.PhotoImage(file=self.img_file)
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ img = tk.PhotoImage(file=self.img_file)
- en: ➌ self.photo_lbl.configure(image=img)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ self.photo_lbl.configure(image=img)
- en: ➍ self.photo_lbl.image = img
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ self.photo_lbl.image = img
- en: '*Listing 11-9: Defines a method to update the current door image*'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-9：定义一个方法来更新当前门的图片*'
- en: Define a function, called update_image(), that takes self as an argument ➊.
    Then use the PhotoImage class as you did in [Listing 11-6](ch11.xhtml#ch11list6)
    ➋. The filename, *self.img_file*, will be updated in other methods.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个函数，名为 `update_image()`，将 `self` 作为参数 ➊。然后使用 `PhotoImage` 类，正如在 [列表 11-6](ch11.xhtml#ch11list6)
    中所做的那样 ➋。文件名 *self.img_file* 会在其他方法中更新。
- en: Because you’ve already created the label that holds the door image, use the
    configure() method to change the label—in this case, by loading a new image ➌.
    You can use either configure() or config(). Finish by assigning the image to a
    widget attribute to fend off garbage collection ➍, as described for [Listing 11-6](ch11.xhtml#ch11list6).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你已经创建了存放门图片的标签，使用 `configure()` 方法来改变标签——在本例中，是加载一个新的图片 ➌。你可以使用 `configure()`
    或 `config()` 方法。最后，通过将图片分配给一个小部件属性来防止垃圾回收 ➍，如 [列表 11-6](ch11.xhtml#ch11list6)
    所述。
- en: '**Selecting the Winning Door and Revealing a Goat**'
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**选择获胜门并揭示山羊**'
- en: '[Listing 11-10](ch11.xhtml#ch11list10) defines a method that selects the winning
    door and the reveal door and then opens and closes the reveal door. It also activates
    the yes/no buttons, which are grayed out until the player makes their first door
    choice.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11-10](ch11.xhtml#ch11list10) 定义了一个方法，选择获胜门和揭示门，然后打开和关闭揭示门。它还激活了是/否按钮，直到玩家做出第一次门选择之前，这些按钮都是灰色的。'
- en: '*monty_hall_gui.py,* part 6'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '*monty_hall_gui.py，* 第6部分'
- en: '➊ def win_reveal(self):'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def win_reveal(self):'
- en: '"""Randomly pick winner and reveal unchosen door with goat."""'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '"""随机选择获胜门并揭示未选的门，显示山羊。"""'
- en: ➋ door_list = list(self.doors)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ door_list = list(self.doors)
- en: ➌ self.choice = self.door_choice.get()
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ self.choice = self.door_choice.get()
- en: self.winner = random.choice(door_list)
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: self.winner = random.choice(door_list)
- en: ➍ door_list.remove(self.winner)
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ door_list.remove(self.winner)
- en: '➎ if self.choice in door_list:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ if self.choice in door_list:'
- en: door_list.remove(self.choice)
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: door_list.remove(self.choice)
- en: self.reveal = door_list[0]
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: self.reveal = door_list[0]
- en: 'else:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: self.reveal = random.choice(door_list)
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: self.reveal = random.choice(door_list)
- en: ➏ self.img_file = ('reveal_{}.png'.format(self.reveal))
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ self.img_file = ('reveal_{}.png'.format(self.reveal))
- en: self.update_image()
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: self.update_image()
- en: '# turn on and clear yes/no buttons'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '# 启动并清除是/否按钮'
- en: ➐ self.yes.config(state='normal')
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ self.yes.config(state='normal')
- en: self.no.config(state='normal')
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: self.no.config(state='normal')
- en: self.change_door.set(None)
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: self.change_door.set(None)
- en: '# close doors 2 seconds after opening'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '# 门在打开后的 2 秒关闭'
- en: ➑ self.img_file = 'all_closed.png'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: ➑ self.img_file = 'all_closed.png'
- en: self.parent.after(2000, self.update_image)
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: self.parent.after(2000, self.update_image)
- en: '*Listing 11-10: Defines a method to randomly select the winning door and reveal
    door*'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11-10：定义一个方法来随机选择获胜门并揭示门*'
- en: Define a method, called win_reveal(), that takes self as an argument ➊. Immediately
    make a list of the doors from the class attribute doors ➋. You’ll alter this list
    based on the player’s first door choice and then the winning door, picked at random
    by the program.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为 `win_reveal()` 的方法，将 `self` 作为参数 ➊。立即根据类属性 `doors` 创建一个门的列表 ➋。你将根据玩家的第一个门选择和程序随机挑选的获胜门来修改这个列表。
- en: Now, assign a self.choice attribute to the self.door_choice string variable,
    accessed with the get() method ➌. The value of this attribute was determined by
    the door radio button that the user clicked as their first choice. Next, choose
    the winning door, at random, from the door list.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将一个 `self.choice` 属性分配给 `self.door_choice` 字符串变量，并使用 `get()` 方法访问它 ➌。该属性的值由用户点击的门单选按钮（作为其第一个选择）决定。接下来，从门列表中随机选择一个获胜的门。
- en: Remove the winning door from the door list ➍. Then use a conditional to see
    whether the player’s choice is still in the door list; if it is, remove it so
    that it can’t be revealed ➎. This will leave only one door in the list, so assign
    it to the self.reveal attribute.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 从门列表中移除获胜的门 ➍。然后使用条件语句检查玩家的选择是否仍在门列表中；如果在，移除它，以便不被揭示 ➎。这样列表中只剩下一个门，将其分配给 `self.reveal`
    属性。
- en: If the player picked the winning door, there are two doors left in the list,
    so randomly choose one of them and assign it to self.reveal. Update the self.img_file
    attribute for this door ➏, then call the method that updates the photo label to
    show the new image. [Figure 11-6](ch11.xhtml#ch11fig6) is an example of the reveal
    image for door B.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家选择了获胜的门，列表中剩下两个门，所以随机选择其中一个并将其赋值给self.reveal。更新该门的self.img_file属性➏，然后调用更新图片标签的方法以显示新图片。[图11-6](ch11.xhtml#ch11fig6)是门B揭示图片的示例。
- en: '![image](../images/f0235-01.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f0235-01.jpg)'
- en: '*Figure 11-6: The reveal image for Door B*'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-6：门B的揭示图片*'
- en: Next, set the state of the yes and no buttons to normal ➐. After this, they
    will no longer be grayed out. End the method by changing the image file to *all_closed.png*
    and calling the self.update_image() method on the parent window after 2,000 milliseconds
    have elapsed ➑. This will ensure the doors stay open no longer than 2 seconds.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，设置是和否按钮的状态为正常➐。此后，它们将不再是灰色的。方法的结束是将图片文件更改为*all_closed.png*，并在2000毫秒后调用父窗口的self.update_image()方法➑。这将确保门不会保持打开超过2秒钟。
- en: '**Revealing the Player’s Final Choice**'
  id: totrans-358
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**揭示玩家的最终选择**'
- en: '[Listing 11-11](ch11.xhtml#ch11list11) defines the first part of a function
    that takes the player’s final door choice and reveals what’s behind it. The function
    will also keep track of the number of wins for switching doors or staying put.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 11-11](ch11.xhtml#ch11list11) 定义了一个函数的第一部分，该函数接受玩家的最终门选择并揭示其背后是什么。该函数还会跟踪更换门或坚持初选的获胜次数。'
- en: '*monty_hall_gui.py,* part 7'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '*monty_hall_gui.py,* 第7部分'
- en: '➊ def show_final(self):'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '➊ def show_final(self):'
- en: '"""Reveal image behind user''s final door choice & count wins."""'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '"""揭示用户最终选择的门背后内容并计算获胜次数。"""'
- en: ➋ door_list = list(self.doors)
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ door_list = list(self.doors)
- en: ➌ switch_doors = self.change_door.get()
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ switch_doors = self.change_door.get()
- en: '➍ if switch_doors == ''y'':'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '➍ if switch_doors == ''y'':'
- en: door_list.remove(self.choice)
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: door_list.remove(self.choice)
- en: door_list.remove(self.reveal)
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: door_list.remove(self.reveal)
- en: ➎ new_pick = door_list[0]
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: ➎ new_pick = door_list[0]
- en: '➏ if new_pick == self.winner:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '➏ if new_pick == self.winner:'
- en: self.img_file = 'money_{}.png'.format(new_pick)
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: self.img_file = 'money_{}.png'.format(new_pick)
- en: self.pick_change_wins += 1
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: self.pick_change_wins += 1
- en: 'else:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: self.img_file = 'goat_{}.png'.format(new_pick)
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: self.img_file = 'goat_{}.png'.format(new_pick)
- en: self.first_choice_wins += 1
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: self.first_choice_wins += 1
- en: '➐ elif switch_doors == ''n'':'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '➐ elif switch_doors == ''n'':'
- en: '➑ if self.choice == self.winner:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '➑ if self.choice == self.winner:'
- en: self.img_file = 'money_{}.png'.format(self.choice)
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: self.img_file = 'money_{}.png'.format(self.choice)
- en: self.first_choice_wins += 1
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: self.first_choice_wins += 1
- en: 'else:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 否则：
- en: self.img_file = 'goat_{}.png'.format(self.choice)
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: self.img_file = 'goat_{}.png'.format(self.choice)
- en: self.pick_change_wins += 1
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: self.pick_change_wins += 1
- en: '# update door image'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '# 更新门图片'
- en: ➒ self.update_image()
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: ➒ self.update_image()
- en: '*Listing 11-11: Defines a method to reveal the player’s final choice and update
    win lists*'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 11-11：定义了一个方法，用于揭示玩家的最终选择并更新获胜记录*'
- en: Define a method, called show_final(), that takes—you guessed it—self as an argument
    ➊. Make a new copy of the door list ➋, then get the self.change_doors variable
    and assign it to an attribute named switch_doors ➌. This variable will hold either
    a 'y' or an 'n', depending on which radio button the player clicked.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个名为show_final()的方法，接受self作为参数➊。创建一个新的门列表副本➋，然后获取self.change_doors变量并将其赋值给名为switch_doors的属性➌。该变量将根据玩家点击的单选按钮，保存'y'或'n'。
- en: If the player chose to switch doors ➍, remove their first choice and the revealed
    door from the list and assign a new_pick attribute to the remaining door ➎. If
    this new pick is the winning door ➏, reference the proper image and advance the
    self.pick_change_wins counter. Otherwise, set the image to a goat and advance
    the self.first_choice_wins counter.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家选择了更换门➜，从列表中移除他们的首次选择和被揭示的门，并将新选项赋值给剩余的门➎。如果这个新选择是获胜的门➏，则显示正确的图片并增加self.pick_change_wins计数器。否则，设置图片为山羊并增加self.first_choice_wins计数器。
- en: If the player decides to not change doors ➐ and if their first choice was the
    winning door ➑, reveal the money bag and advance the self.first_choice_wins counter.
    Otherwise, show a goat and advance the self.pick_change_wins counter.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家决定不更换门➐，并且他们的首次选择是获胜的门➑，则揭示金钱袋，并增加self.first_choice_wins计数器。否则，显示一只山羊，并增加self.pick_change_wins计数器。
- en: Finish by calling the update_image() method to update the image ➒. Again, you
    don’t need to pass it the name of the new image file, as it can access the self.img_file
    attribute that you changed in the preceding code.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用update_image()方法来更新图片➒。同样，您无需传递新图片文件的名称，因为它可以访问您在前面的代码中更改的self.img_file属性。
- en: '**Displaying Statistics**'
  id: totrans-389
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**显示统计信息**'
- en: '[Listing 11-12](ch11.xhtml#ch11list12) completes the show_final() method by
    updating the game window for the number of wins statistics, disabling the yes/no
    buttons, and closing all the doors.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-12](ch11.xhtml#ch11list12) 完成了 show_final() 方法，通过更新游戏窗口中胜利统计的数量，禁用是/否按钮，并关闭所有门。'
- en: '*monty_hall_gui.py,* part 8'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '*monty_hall_gui.py,* 第 8 部分'
- en: '# update displayed statistics'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '# 更新显示的统计信息'
- en: ➊ self.unchanged_wins_txt.delete(1.0, 'end')
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ self.unchanged_wins_txt.delete(1.0, 'end')
- en: ➋ self.unchanged_wins_txt.insert(1.0, 'Unchanged wins = {:d}'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ self.unchanged_wins_txt.insert(1.0, '未改变的胜利 = {:d}'
- en: .format(self.first_choice_wins))
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: .format(self.first_choice_wins))
- en: self.changed_wins_txt.delete(1.0, 'end')
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: self.changed_wins_txt.delete(1.0, 'end')
- en: self.changed_wins_txt.insert(1.0, 'Changed wins = {:d}'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: self.changed_wins_txt.insert(1.0, '改变的胜利 = {:d}'
- en: .format(self.pick_change_wins))
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: .format(self.pick_change_wins))
- en: '# turn off yes/no buttons and clear door choice buttons'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '# 关闭是/否按钮并清除门选择按钮'
- en: ➌ self.yes.config(state='disabled')
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ self.yes.config(state='disabled')
- en: self.no.config(state='disabled')
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: self.no.config(state='disabled')
- en: ➍ self.door_choice.set(None)
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ self.door_choice.set(None)
- en: '➎ # close doors 2 seconds after opening'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '➎ # 打开后 2 秒钟关闭门'
- en: self.img_file = 'all_closed.png'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: self.img_file = 'all_closed.png'
- en: self.parent.after(2000, self.update_image)
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: self.parent.after(2000, self.update_image)
- en: '*Listing 11-12: Displays win statistics, disables the yes/no buttons, and closes
    all the doors*'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-12: 显示胜利统计，禁用是/否按钮，并关闭所有门*'
- en: Start by deleting any text in the self.unchanged_wins_txt text widget ➊. Begin
    deleting at a text index of 1.0. The format is line.column, so you are specifying
    the first line and first column of the text widget (line numbering starts at 1,
    column numbering at 0). Finish with 'end', which will ensure that all the text
    after the starting index is deleted.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 首先删除 self.unchanged_wins_txt 文本小部件中的任何文本 ➊。 从文本索引 1.0 开始删除。格式是行.列，因此您指定的是文本小部件的第一行和第一列（行编号从
    1 开始，列编号从 0 开始）。最后使用 'end'，确保删除从起始索引之后的所有文本。
- en: Next, use the insert() method to add the self.first_choice_wins attribute value,
    along with some descriptive text, to the text widget ➋. Begin inserting at text
    index 1.0.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 insert() 方法将 self.first_choice_wins 属性值和一些描述性文本添加到文本小部件 ➋ 中。从文本索引 1.0
    开始插入。
- en: Repeat this process for the self.changed_wins_txt text widget, and then disable
    the yes/no buttons by setting their config state to 'disabled' ➌. Set the self.door_choice
    string variable back to None, and you’re ready to start a new game ➍.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 对 self.changed_wins_txt 文本小部件执行相同的操作，然后通过将其配置状态设置为 'disabled' ➌ 来禁用是/否按钮。将 self.door_choice
    字符串变量重置为 None，准备开始新游戏 ➍。
- en: End the method by closing the doors, as you did in [Listing 11-10](ch11.xhtml#ch11list10)
    ➎.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 通过关闭门来结束方法，就像在[清单 11-10](ch11.xhtml#ch11list10)中所做的那样 ➎。
- en: '**Setting Up the Root Window and Running the Event Loop**'
  id: totrans-411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**设置根窗口并运行事件循环**'
- en: '[Listing 11-13](ch11.xhtml#ch11list13) completes the *monty_hall_gui.py* program
    by setting up the tkinter root window, instantiating the game object, and running
    mainloop(). Alternatively, this code could be encapsulated in a main() function.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-13](ch11.xhtml#ch11list13) 完成了 *monty_hall_gui.py* 程序，通过设置 tkinter 根窗口，实例化游戏对象，并运行
    mainloop()。或者，代码也可以封装在 main() 函数中。'
- en: '*monty_hall_gui.py,* part 9'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '*monty_hall_gui.py,* 第 9 部分'
- en: '# set up root window & run event loop'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置根窗口并运行事件循环'
- en: ➊ root = tk.Tk()
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ root = tk.Tk()
- en: ➋ root.title('Monty Hall Problem')
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ root.title('蒙提霍尔问题')
- en: ➌ root.geometry('1280x820')  # pics are 1280 x 720
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '➌ root.geometry(''1280x820'')  # 图像大小为 1280 x 720'
- en: ➍ game = Game(root)
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ game = Game(root)
- en: root.mainloop()
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: root.mainloop()
- en: '*Listing 11-13: Sets up the* root *window, creates a game object, and runs*
    mainloop()'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-13: 设置根窗口，创建游戏对象，并运行 mainloop()*'
- en: The Tk class is instantiated without arguments ➊. This creates a top-level tkinter
    widget, which will be the main window of the game application. Assign it to a
    variable named root.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: Tk 类在没有参数的情况下被实例化 ➊。这会创建一个顶级 tkinter 小部件，它将成为游戏应用程序的主窗口。将其分配给名为 root 的变量。
- en: Give the window a title ➋ and a size in pixels ➌. Note that the size of the
    images influences the geometry so that they fit attractively in the window, with
    ample room below for instructions and messages.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 给窗口设置标题 ➋ 和像素大小 ➌。注意，图像的大小会影响几何布局，以便它们能在窗口中适当地显示，底部留有足够的空间用于显示说明和消息。
- en: Now, create the game ➍. Pass it the root window, which will be the *master*
    that will contain the game. This results in a new game being placed inside the
    root window.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建游戏 ➍。将根窗口传递给它，根窗口将成为包含游戏的 *主窗口*。这将导致新游戏被放置在根窗口内。
- en: Finish by invoking the mainloop() method on root, which keeps the window open
    and waiting to handle events.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过调用root上的mainloop()方法，保持窗口开启并等待处理事件。
- en: '**Summary**'
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you used a simple Monte Carlo simulation to confirm that switching
    doors is the best strategy for the Monty Hall problem. You then used tkinter to
    build a fun interface to let schoolchildren test this conclusion manually, game
    by game. Best of all, you learned how to use object-oriented programming to build
    interactive widgets that respond to user input.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你使用了一个简单的蒙特卡洛模拟来验证切换门是蒙提·霍尔问题的最佳策略。然后，你使用tkinter构建了一个有趣的界面，让小学生通过一局一局的游戏手动验证这个结论。最重要的是，你学会了如何使用面向对象编程来构建响应用户输入的交互式小部件。
- en: '**Further Reading**'
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: Useful tkinter references can be found in “[Further Reading](ch10.xhtml#lev241)”
    on [page 212](ch10.xhtml#page_212).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 有关tkinter的有用参考资料可以在“[进一步阅读](ch10.xhtml#lev241)”中找到，位于[第212页](ch10.xhtml#page_212)。
- en: You can find a summary of the 1990 Monty Hall problem controversy online at
    *[http://marilynvossavant.com/game-show-problem/](http://marilynvossavant.com/game-show-problem/)*.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在网上找到1990年蒙提·霍尔问题争议的总结，网址是*[http://marilynvossavant.com/game-show-problem/](http://marilynvossavant.com/game-show-problem/)*。
- en: '**Practice Project: The Birthday Paradox**'
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实践项目：生日悖论**'
- en: How many people need to be in a room for there to be a 50/50 chance that two
    of them share the same birth month and day? According to the *birthday paradox*,
    not that many! As with the Monty Hall problem, the outcome is counterintuitive.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 需要多少人才能让房间里有50%的机会两个人生日相同？根据*生日悖论*，其实并不需要那么多！与蒙提·霍尔问题一样，结果是反直觉的。
- en: Use MCS to determine how many people it takes to reach the 50 percent mark.
    Have the program print out the number of people and the probability for a range
    of room occupants. If you find yourself looking up how to format dates, stop and
    simplify! You can find a solution, *birthday_paradox_practice.py*, in the appendix
    or online at *[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MCS来确定达到50%的概率需要多少人。让程序输出一系列房间人数及其对应的概率。如果你发现自己在查找如何格式化日期，停下来并简化！你可以在附录中或在线找到解决方案，*birthday_paradox_practice.py*，网址是*[https://www.nostarch.com/impracticalpython/](https://www.nostarch.com/impracticalpython/)*。
