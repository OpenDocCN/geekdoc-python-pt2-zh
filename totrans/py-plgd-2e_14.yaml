- en: '[10](nsp-venkitachalam503045-0008.xhtml#rch10)'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[10](nsp-venkitachalam503045-0008.xhtml#rch10)'
- en: Conway’s Game of Life on a Torus
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在圆环上的康威生命游戏
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
- en: 'In [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03), we implemented Conway’s
    Game of Life using Python and the `matplotlib` library. You may recall one interesting
    aspect of that project: it used toroidal boundary conditions. [Figure 3-2](nsp-venkitachalam503045-0015.xhtml#fig3-2)
    on [page 48](nsp-venkitachalam503045-0015.xhtml#p48) showed how we were effectively
    treating the flat, 2D grid of the simulation as a 3D toroidal surface, thanks
    to how the boundary conditions stitched the edges together. In the [previous chapter](nsp-venkitachalam503045-0023.xhtml#ch09),
    you were introduced to OpenGL and learned how to render 3D objects. Let’s now
    put together your experience with the Game of Life and OpenGL to re-create the
    Conway’s simulation in 3D, on an actual torus.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](nsp-venkitachalam503045-0015.xhtml#ch03)中，我们使用Python和`matplotlib`库实现了康威生命游戏。你可能还记得那个项目的一个有趣方面：它使用了圆环边界条件。图[3-2](nsp-venkitachalam503045-0015.xhtml#fig3-2)在[第48页](nsp-venkitachalam503045-0015.xhtml#p48)上展示了我们如何有效地将模拟的平面2D网格视为3D圆环表面，这要归功于边界条件将边缘连接在一起。在[前一章](nsp-venkitachalam503045-0023.xhtml#ch09)，你接触了OpenGL并学会了如何渲染3D物体。现在，让我们将你在生命游戏和OpenGL中的经验结合起来，重新创建3D的康威模拟，并将其放在真实的圆环表面上。
- en: In this project, you’ll start by computing the 3D geometry of a torus. Then
    you’ll arrange the vertices of the torus in a way that’s easy to draw and color
    in OpenGL. You’ll set up a revolving camera to view the torus from all sides and
    also implement some basic lighting in the shaders. Finally, you’ll adapt the Game
    of Life code from [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03) to color
    the grid on the torus. As the simulation proceeds, you’ll see the Game of Life
    come alive on the surface of the torus!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，你将首先计算圆环的3D几何形状。然后，你将以易于在OpenGL中绘制和着色的方式排列圆环的顶点。你将设置一个旋转的相机，以便从各个角度查看圆环，并且在着色器中实现一些基本的光照。最后，你将根据[第3章](nsp-venkitachalam503045-0015.xhtml#ch03)中的生命游戏代码，为圆环上的网格着色。随着模拟的进行，你将看到生命游戏在圆环表面上栩栩如生！
- en: 'Here are the main topics covered in this project:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本项目中涵盖的主要主题：
- en: • Using matrix math to construct the 3D geometry of a torus
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 使用矩阵运算构建圆环的3D几何形状
- en: • Implementing a coloring scheme for the Game of Life grid on the torus
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 为圆环上的生命游戏网格实现一种着色方案
- en: • Implementing a revolving camera in OpenGL
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 在OpenGL中实现旋转相机
- en: • Implementing simple lighting in OpenGL
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: • 在OpenGL中实现简单的光照
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah1201)'
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[它是如何工作的](nsp-venkitachalam503045-0008.xhtml#rah1201)'
- en: Before getting into the code, let’s consider how you can render, light, and
    view a 3D torus using OpenGL. It all begins with computing the vertices that make
    up the torus.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入代码之前，我们先考虑一下如何使用OpenGL渲染、照明并查看3D圆环。所有这些都从计算构成圆环的顶点开始。
- en: '[Computing Vertices](nsp-venkitachalam503045-0008.xhtml#rbh1201)'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[计算顶点](nsp-venkitachalam503045-0008.xhtml#rbh1201)'
- en: A torus is essentially a collection of circles, or rings, arranged in a circle
    around a central point. However, you can’t actually draw circles with OpenGL;
    they need to be *discretized*, or represented as a series of vertices connected
    by straight lines. The simplified model in [Figure 10-1](nsp-venkitachalam503045-0024.xhtml#fig10-1)
    illustrates how you can begin defining the torus as a collection of vertices.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 圆环本质上是由一系列圆形或环形组成，这些圆形围绕中心点排列。然而，你实际上无法在OpenGL中绘制圆形；它们需要被*离散化*，或者说用一系列由直线连接的顶点来表示。图[10-1](nsp-venkitachalam503045-0024.xhtml#fig10-1)中的简化模型展示了如何将圆环定义为顶点集合。
- en: '![](images/nsp-venkitachalam503045-f10001.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f10001.jpg)'
- en: 'Figure 10-1: A torus rendering model. The simplified torus is on the left.
    An individual “ring” that makes up the torus is on the right.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-1：圆环渲染模型。左侧是简化的圆环，右侧是构成圆环的单个“环”。
- en: The right side of [Figure 10-1](nsp-venkitachalam503045-0024.xhtml#fig10-1)
    shows a ring with radius *r* discretized to have *M* = 5 points. The left side
    of [Figure 10-1](nsp-venkitachalam503045-0024.xhtml#fig10-1) models a simple torus
    with major radius *R* by arranging *N* = 6 such discretized rings (labeled 0 through 5)
    around a central point. (The *major radius* is the distance from the center of
    the torus’s hole to the center of its outer ring.) Don’t worry about the blocky
    nature of the torus shown in the figure. It gets smoother as you increase the
    values of *N* and *M*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-1](nsp-venkitachalam503045-0024.xhtml#fig10-1)的右侧显示了半径为 *r* 的圆环，其离散化为
    *M* = 5 个点。左侧的 [图 10-1](nsp-venkitachalam503045-0024.xhtml#fig10-1) 模拟了一个简单的托勒斯，其主半径为
    *R*，通过围绕一个中心点排列 *N* = 6 个这样的离散化圆环（标号为 0 到 5）。(*主半径*是托勒斯孔中心到外环中心的距离。) 不必担心图中显示的托勒斯的块状特性，随着
    *N* 和 *M* 值的增大，它会变得更加平滑。'
- en: The torus is filled out by drawing bands to connect adjacent rings. You’ll draw
    the bands using `GL_TRIANGLE_STRIP` primitives, and each cell in the Game of Life
    simulation will consist of two adjacent triangles on a strip, which together form
    a *quad*, or quadrilateral. When a cell is ON you’ll color its quad black, and
    when a cell is OFF you’ll color it white.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过绘制带状图连接相邻的圆环来填充托勒斯。你将使用 `GL_TRIANGLE_STRIP` 原语来绘制这些带状图，而生命游戏模拟中的每个单元格将由两个相邻的三角形构成，这些三角形共同形成一个
    *四边形*。当单元格为 ON 时，你将把其四边形涂成黑色，当单元格为 OFF 时，你将其四边形涂成白色。
- en: To compute the vertices of the torus, you first need to define a coordinate
    system for it. Let’s assume that the torus is on the XY plane, centered at the
    origin, with the line through the center of the torus aligned along the z-axis,
    as shown in [Figure 10-2](nsp-venkitachalam503045-0024.xhtml#fig10-2).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算托勒斯的顶点，首先需要为它定义一个坐标系统。假设托勒斯位于 XY 平面，中心在原点，穿过托勒斯中心的直线沿着 z 轴对齐，如[图 10-2](nsp-venkitachalam503045-0024.xhtml#fig10-2)所示。
- en: '![](images/nsp-venkitachalam503045-f10002.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f10002.jpg)'
- en: 'Figure 10-2: The rendering strategy for the torus'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-2：托勒斯的渲染策略
- en: 'The vertices for a circle *C*[3] on the torus at an angle θ relative to the
    x-axis can be computed as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在与 x 轴成角度 θ 的托勒斯圆环上，圆 *C*[3] 的顶点可以按以下方式计算：
- en: 1\. Compute the vertices for a circle *C*[1] of radius *r* in the XZ plane and
    with the center at the origin.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1\. 计算半径为 *r*，中心在原点的 XZ 平面上的圆 *C*[1] 的顶点。
- en: 2\. Rotate the circle *C*[1] around the z-axis by the angle θ. This gives you
    the circle *C*[2].
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2\. 将圆 *C*[1] 绕 z 轴旋转角度 θ。这样，你就得到了圆 *C*[2]。
- en: 3\. Translate the circle *C*[2] by *R* amount along the angle θ to get the circle
    *C*[3] in the correct position on the torus.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3\. 将圆 *C*[2] 按照角度 θ 平移 *R* 的距离，得到正确位置上的圆 *C*[3]，从而在托勒斯上获得正确的位置。
- en: 'You may recall the use of parametric equations to define a circle in the spirograph
    project in [Chapter 2](nsp-venkitachalam503045-0013.xhtml#ch02). We’re going to
    use the same concept here. The vertices marking the circumference of a circle
    *C*[1] of radius *r* on the XZ plane centered at the origin are given by:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能记得在[第2章](nsp-venkitachalam503045-0013.xhtml#ch02)的螺旋图项目中使用了参数方程来定义一个圆。我们将在这里使用相同的概念。标记
    XZ 平面上原点处半径为 *r* 的圆 *C*[1] 圆周的顶点由以下公式给出：
- en: '*P* = (*r* cos(α), 0, *r* sin(α))'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*P* = (*r* cos(α), 0, *r* sin(α))'
- en: Here, α is the angle made by the point *P* with respect to the x-axis. As α
    varies from 0 to 360 degrees (or 2π radians), a circle will be formed by the *P* points.
    Notice that the y-coordinates of the points are zero in the previous equation.
    This is expected, since the circle is on the XZ plane.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，α 是点 *P* 与 x 轴之间的角度。当 α 从 0 到 360 度（或 2π 弧度）变化时，点 *P* 会形成一个圆。注意，前述方程中点的 y
    坐标为零。这是可以预期的，因为该圆位于 XZ 平面上。
- en: 'You must now rotate the points around the z-axis by angle θ. The rotation matrix
    for this operation is given by:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你必须绕 z 轴旋转这些点，旋转角度为 θ。这个操作的旋转矩阵为：
- en: '![](images/nsp-venkitachalam503045-m10001.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m10001.jpg)'
- en: Once you rotate the points, you need to translate them to the right place. This
    is done using the following translation matrix. (This format was discussed in
    [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09).)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你旋转了这些点，你需要将它们平移到正确的位置。这是通过使用以下平移矩阵来完成的。（此格式在[第9章](nsp-venkitachalam503045-0023.xhtml#ch09)中已讨论。）
- en: '![](images/nsp-venkitachalam503045-m10002.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m10002.jpg)'
- en: 'Thus, the transformed points on a ring on the torus are given by:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，托勒斯上的圆环的变换后的点由以下公式给出：
- en: '*P*ʹ = *T* × *R* [θ,Z] × *P*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*ʹ = *T* × *R* [θ,Z] × *P*'
- en: 'which is the same as:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下公式相同：
- en: '![](images/nsp-venkitachalam503045-m10003.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m10003.jpg)'
- en: In the previous equation, *P* is first multiplied by the rotation matrix, which
    aligns it correctly, and is then multiplied by the translation matrix, which “pushes”
    the points to the right place on the torus. Notice that *P* is represented with
    *homogeneous* coordinates (*x*, *y*, *z*, 1.0), discussed in the [previous chapter](nsp-venkitachalam503045-0023.xhtml#ch09).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的公式中，*P* 首先与旋转矩阵相乘，这样它就能正确对齐，然后再与平移矩阵相乘，将点“推”到圆环上的正确位置。请注意，*P* 是用*齐次*坐标（*x*,
    *y*, *z*, 1.0）表示的，齐次坐标在[上一章](nsp-venkitachalam503045-0023.xhtml#ch09)中已有讨论。
- en: '[Computing Normals for Lighting](nsp-venkitachalam503045-0008.xhtml#rbh1202)'
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[计算光照的法向量](nsp-venkitachalam503045-0008.xhtml#rbh1202)'
- en: For the torus to look nice, you’ll need to apply lighting to the geometry, which
    in turn means you’ll need to compute the *normal vectors* for the points *P* calculated
    in the previous section. The lighting on a surface depends on the orientation
    of the surface to the incoming light, and the orientation can be quantified by
    the normal vector, which is the vector perpendicular to the surface at a particular
    point. Take a look at [Figure 10-3](nsp-venkitachalam503045-0024.xhtml#fig10-3)
    to see an example.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让圆环看起来更漂亮，你需要对几何体应用光照，这意味着你需要计算前一部分中计算的点*P*的*法向量*。表面的光照依赖于表面与入射光的方向，而这个方向可以通过法向量来量化，法向量是垂直于特定点表面的向量。查看[图
    10-3](nsp-venkitachalam503045-0024.xhtml#fig10-3)来查看示例。
- en: '![](images/nsp-venkitachalam503045-f10003.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f10003.jpg)'
- en: 'Figure 10-3: Computing normal vectors'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-3：计算法向量
- en: 'Because of the geometry of the torus, the normal vector for point *s* on a
    ring is in the same direction as the line connecting point *s* to the center of
    the ring. This means that the normal vectors are the same as rotated points. The
    translation doesn’t matter, as the direction of the normals is unaffected by it.
    You can therefore compute the normals as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于圆环的几何形状，环上点 *s* 的法向量与连接点 *s* 和圆环中心的线相同。这意味着法向量与旋转的点相同。平移无关紧要，因为它不会影响法向量的方向。因此，你可以按如下方式计算法向量：
- en: '*N* = *R*[θ,Z] × *P*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*N* = *R*[θ,Z] × *P*'
- en: Note that you need to *normalize* the normal vectors before doing any lighting
    computations. You do this by dividing the normal by its magnitude.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在进行任何光照计算之前，你需要对法向量进行*归一化*。你可以通过将法向量除以其大小来完成这一过程。
- en: The actual lighting will come from a single light source at a fixed position.
    This will be defined in the vertex shader.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的光照将来自一个固定位置的单一光源。这将在顶点着色器中定义。
- en: '[Rendering](nsp-venkitachalam503045-0008.xhtml#rbh1203)'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[渲染](nsp-venkitachalam503045-0008.xhtml#rbh1203)'
- en: Now that you have the vertices and normals for the torus, let’s talk about how
    to render it using OpenGL. You first need to split it up into bands, as shown
    in [Figure 10-4](nsp-venkitachalam503045-0024.xhtml#fig10-4). Each band is the
    region between two adjacent rings on the torus.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了圆环的顶点和法向量，我们来讨论如何使用 OpenGL 渲染它。你需要首先将它分割成多个带状区域，如[图 10-4](nsp-venkitachalam503045-0024.xhtml#fig10-4)所示。每个带状区域是圆环上两个相邻圆环之间的区域。
- en: '![](images/nsp-venkitachalam503045-f10004.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f10004.jpg)'
- en: 'Figure 10-4: Rendering the torus with triangle strips'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-4：使用三角带渲染圆环
- en: 'Each of the bands is rendered using OpenGL as a `GL_TRIANGLE_STRIP` primitive.
    Besides forming the building blocks of the torus, these triangle strips also provide
    a convenient way to create the Game of Life simulation grid: each cell in the
    grid is represented by a quad formed from two adjacent triangles in the strip.
    [Figure 10-5](nsp-venkitachalam503045-0024.xhtml#fig10-5) gives a closer look
    at one band in the torus.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每个带状区域都通过 OpenGL 作为 `GL_TRIANGLE_STRIP` 基元进行渲染。除了构成圆环的基本构建块外，这些三角带还提供了一种便捷的方式来创建生命游戏的模拟网格：网格中的每个单元格由一对相邻的三角形组成，形成一个四边形。[图
    10-5](nsp-venkitachalam503045-0024.xhtml#fig10-5)展示了圆环中一个带状区域的近景。
- en: '![](images/nsp-venkitachalam503045-f10005.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f10005.jpg)'
- en: 'Figure 10-5: Rendering a band from triangle strips'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-5：从三角带渲染带状区域
- en: 'The band is formed by the adjacent rings *C*⁰ and *C*¹. Each ring has *M* vertices.
    The triangle strip making up the band is formed as *M* pairs of vertices that
    zigzag back and forth between the rings:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 带状区域由相邻的圆环 *C*⁰ 和 *C*¹ 形成。每个圆环有 *M* 个顶点。构成带状区域的三角带由 *M* 对顶点组成，这些顶点在圆环之间来回交替：
- en: '![](images/nsp-venkitachalam503045-m10004.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m10004.jpg)'
- en: 'But there’s one additional pair of vertices you need to add: ![](images/nsp-venkitachalam503045-m10005.jpg).
    You need to repeat the first two vertices to close out the gap at the end of the
    band. Hence, the total number of vertices in the triangle strip that forms the
    band is given by 2 × *M* + 2.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你需要添加另外一对顶点：![](images/nsp-venkitachalam503045-m10005.jpg)。你需要重复前两个顶点，以关闭带末尾的空隙。因此，构成该带的三角带中的顶点总数为2
    × *M* + 2。
- en: 'The band shown in [Figure 10-5](nsp-venkitachalam503045-0024.xhtml#fig10-5)
    was composed of rings ![](images/nsp-venkitachalam503045-m10006.jpg). The torus
    is divided into *N* bands, where *N* is the number of rings:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-5](nsp-venkitachalam503045-0024.xhtml#fig10-5)中展示的带状物由环组成！[](images/nsp-venkitachalam503045-m10006.jpg)。圆环被分为*N*个带，其中*N*是环的数量：'
- en: '![](images/nsp-venkitachalam503045-m10007.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m10007.jpg)'
- en: Notice how the last band wraps around by coming back to the first ring, *C*⁰.
    This means the total number of vertices needed to render the torus is given by
    *N* × (2 × *M* + 2). You’ll see more details of the implementation as you look
    at the code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后一个带如何通过回到第一个环*C*⁰来绕回去。这意味着渲染圆环所需的顶点总数由*N* × (2 × *M* + 2)给出。你将在查看代码时看到更多实现的细节。
- en: Now let’s take a look at the coloring scheme for the torus.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下圆环的上色方案。
- en: '[Coloring the Triangle Strips](nsp-venkitachalam503045-0008.xhtml#rbh1204)'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[为三角带上色](nsp-venkitachalam503045-0008.xhtml#rbh1204)'
- en: 'You need to color the cells in the Game of Life simulation individually. You
    know that each cell is a quad—two triangles that are part of a larger triangle
    strip. As an example, the quad made of vertices ![](images/nsp-venkitachalam503045-m10008.jpg)
    is composed of two triangles: ![](images/nsp-venkitachalam503045-m10009.jpg) and
    ![](images/nsp-venkitachalam503045-m10010.jpg). Each vertex has a corresponding
    color associated with it, which is a triplet of the form (*r*, *g*, *b*), denoting
    the red, green, and blue components of the color. By default, the color of the
    first vertex in the quad (in this case, ![](images/nsp-venkitachalam503045-m10011.jpg))
    sets the value for the first triangle in the quad, and the color of the second
    vertex (![](images/nsp-venkitachalam503045-m10012.jpg)) sets the value for the
    second triangle in the quad. As long as you set these two colors to be identical,
    you’ll color the quad uniformly. We’ll discuss OpenGL’s vertex color convention
    further when we look at the code.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为《生命游戏》模拟中的每个单元格单独上色。你知道每个单元格是一个四边形——由两个三角形组成，是一个较大的三角带的一部分。举例来说，由顶点组成的四边形！[](images/nsp-venkitachalam503045-m10008.jpg)由两个三角形组成：！[](images/nsp-venkitachalam503045-m10009.jpg)和！[](images/nsp-venkitachalam503045-m10010.jpg)。每个顶点都有一个对应的颜色，与之相关的是一个三元组（*r*，*g*，*b*），表示颜色的红、绿、蓝成分。默认情况下，四边形中第一个顶点（在此例中为！[](images/nsp-venkitachalam503045-m10011.jpg)）的颜色为四边形中第一个三角形设置颜色，而第二个顶点（！[](images/nsp-venkitachalam503045-m10012.jpg)）的颜色为第二个三角形设置颜色。只要你将这两种颜色设置为相同，你就能均匀地为四边形上色。当我们查看代码时，我们会进一步讨论OpenGL的顶点颜色约定。
- en: NOTE The OpenGL function called `glProvokingVertex()` changes the convention
    of which color value is mapped to the vertex.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 OpenGL函数`glProvokingVertex()`改变了颜色值映射到顶点的约定。
- en: '[Controlling the Camera](nsp-venkitachalam503045-0008.xhtml#rbh1205)'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[控制相机](nsp-venkitachalam503045-0008.xhtml#rbh1205)'
- en: To view the torus, you’ll create a camera that revolves around the origin of
    the 3D scene and looks down at an angle from above. [Figure 10-6](nsp-venkitachalam503045-0024.xhtml#fig10-6)
    shows the camera setup.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看圆环形体，你需要创建一个围绕3D场景原点旋转的相机，并从上方以一定角度向下观察。[图10-6](nsp-venkitachalam503045-0024.xhtml#fig10-6)展示了相机的设置。
- en: '![](images/nsp-venkitachalam503045-f10006.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f10006.jpg)'
- en: 'Figure 10-6: Implementing a revolving camera'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-6：实现旋转相机
- en: 'Think of the camera, represented by point *E*, as being placed on a cylinder
    of radius *R* at a height *H* from the origin. The camera points toward the origin
    *O*. The camera is defined by the mutually perpendicular vectors *V*, *U*, and
    *N*, where *V* is the *view vector* that points from *E* to *O*; *U* is the *up
    vector*, which is up relative to the camera; and *N* is a vector perpendicular
    to both *V* and *U*. For every time step, you move the camera by a constant distance
    along the rim of the cylinder. This movement is parameterized by the angle β,
    as shown in [Figure 10-6](nsp-venkitachalam503045-0024.xhtml#fig10-6). As you
    learned in [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09), you use a `lookAt()`
    method to set up the view, which takes three parameters: the eye, the center,
    and the up vector. The center is just the origin: (0, 0, 0). The 3D coordinates
    of the eye are given by:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将相机（由点 *E* 表示）想象成被放置在半径为 *R* 的圆柱上，距离原点 *H* 的高度。相机指向原点 *O*。相机由互相垂直的向量 *V*、*U*
    和 *N* 定义，其中 *V* 是从 *E* 指向 *O* 的 *视点向量*；*U* 是相对于相机的 *向上向量*；*N* 是与 *V* 和 *U* 都垂直的向量。在每个时间步长，你沿着圆柱的边缘按恒定距离移动相机。这个移动由角度
    β 参数化，如 [图 10-6](nsp-venkitachalam503045-0024.xhtml#fig10-6) 所示。如你在 [第 9 章](nsp-venkitachalam503045-0023.xhtml#ch09)
    中学到的，你可以使用 `lookAt()` 方法来设置视图，该方法需要三个参数：眼睛、中心和向上向量。中心就是原点：(0, 0, 0)。眼睛的三维坐标由以下给出：
- en: '*E* = (*R* cos(β), *R* sin(β), *H*)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*E* = (*R* cos(β), *R* sin(β), *H*)'
- en: 'As the camera moves along the rim of the cylinder, it will keep its direction
    pointed to *O*, and the up vector *U* will keep changing as well. To compute the
    up vector *U*, start with an initial guess *U*ʹ that’s parallel to the z-axis.
    Then find *N*, the vector perpendicular to the plane given by *U*ʹ and *V*. It
    can be calculated as:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当相机沿着圆柱的边缘移动时，它将始终指向 *O*，并且向上向量 *U* 也会不断变化。为了计算向上向量 *U*，从一个初步猜测 *U*ʹ 开始，该猜测与
    z 轴平行。然后，找到 *N*，即垂直于 *U*ʹ 和 *V* 所定义平面的向量。可以通过以下方式计算：
- en: '*N* = *V* × *U*ʹ'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*N* = *V* × *U*ʹ'
- en: '*N* is given by the cross product of *V* and *U*ʹ. Now, what happens if you
    take the cross product of *N* and *V*? You get a vector perpendicular to the NV
    plane, which is the up vector *U* that you’re looking for!'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*N* 由 *V* 和 *U*ʹ 的叉积给出。那么，如果你将 *N* 和 *V* 的叉积计算出来会发生什么呢？你会得到一个垂直于 NV 平面的向量，这正是你需要的向上向量
    *U*！'
- en: '*U* = *N* × *V* = (*V* × *U*ʹ) × *V*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*U* = *N* × *V* = (*V* × *U*ʹ) × *V*'
- en: 'Once *U* is calculated, make sure that it’s normalized before use. Once that’s
    done, you’ll have everything you need to set up the camera with `lookAt()`: *E*
    (the eye), *O* (the center), and *U* (the up vector).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算出 *U*，确保在使用之前将其归一化。完成这一点后，你就能拥有设置相机所需的一切：`lookAt()` 方法中的 *E*（眼睛），*O*（中心）和
    *U*（向上向量）。
- en: '[Mapping the Grid to the Torus](nsp-venkitachalam503045-0008.xhtml#rbh1206)'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[将网格映射到环面](nsp-venkitachalam503045-0008.xhtml#rbh1206)'
- en: Finally, let’s look at how the 2D Game of Life simulation grid maps to the 3D
    torus because of the grid’s toroidal boundary conditions. [Figure 10-7](nsp-venkitachalam503045-0024.xhtml#fig10-7)
    shows the mapping.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来看看二维生命游戏仿真网格如何映射到三维环面，因为网格的环面边界条件。[图 10-7](nsp-venkitachalam503045-0024.xhtml#fig10-7)
    展示了这种映射。
- en: '![](images/nsp-venkitachalam503045-f10007.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-f10007.jpg)'
- en: 'Figure 10-7: Mapping the simulation grid to a torus'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-7：将仿真网格映射到环面
- en: 'The two-dimensional Game of Life grid has *NX* columns and *NY* rows. You can
    see on the right of the figure how the *NX* points that divide each row wrap around
    the tube of the torus. The point indices go from 0 to *NX* − 1\. The next index,
    *NX*, is the same as 0 because of the wrap. A similar wrap happens in the y-direction,
    where you have *NY* cells: the point with index *NY* is the same as the point
    with index 0.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 二维生命游戏网格有 *NX* 列和 *NY* 行。你可以在图的右侧看到，*NX* 个点将每一行分割开，并且它们绕着环面的圆柱部分循环。点的索引从 0 到
    *NX* − 1。下一个索引，*NX*，与 0 相同，这是因为有环绕现象。y 方向上也发生类似的环绕，你有 *NY* 个单元格：索引为 *NY* 的点与索引为
    0 的点相同。
- en: You saw earlier how each ring in the torus is discretized to have *M* points.
    To go from the two-dimensional grid to the torus, set *NX* = *M*. Similarly, set
    *NY* = *N*, where *N* is the number of bands on the torus.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前看到过环面上的每个环是如何被离散化为 *M* 个点的。为了从二维网格转换到环面，设定 *NX* = *M*。同样，设定 *NY* = *N*，其中
    *N* 是环面上的带数。
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah1202)'
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[需求](nsp-venkitachalam503045-0008.xhtml#rah1202)'
- en: We’ll use `PyOpenGL` and GLFW for OpenGL rendering, as in [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09),
    and `numpy` for matrix/vector computations.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `PyOpenGL` 和 GLFW 进行 OpenGL 渲染，正如在 [第9章](nsp-venkitachalam503045-0023.xhtml#ch09)
    中所述，`numpy` 用于矩阵/向量计算。
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah1203)'
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[代码](nsp-venkitachalam503045-0008.xhtml#rah1203)'
- en: 'The code for this project is organized into several files:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的代码被组织成几个文件：
- en: torus.py This contains the geometry computation and rendering code for the torus.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: torus.py 该文件包含圆环的几何计算和渲染代码。
- en: gol.py This implements Conway’s Game of Life, adapted from [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: gol.py 该文件实现了 Conway 的生命游戏，改编自 [第3章](nsp-venkitachalam503045-0015.xhtml#ch03)。
- en: camera.py This contains the implementation for the revolving camera for viewing
    the torus.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: camera.py 该文件包含用于旋转相机以查看圆环的实现。
- en: gol_torus.py This is the main file that sets up OpenGL and GLFW and calls the
    rendering code from other modules.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: gol_torus.py 这是设置 OpenGL 和 GLFW 的主文件，并从其他模块调用渲染代码。
- en: The full project code is available online at [https://github.com/mkvenkit/pp2e/blob/main/gol_torus](https://github.com/mkvenkit/pp2e/blob/main/gol_torus).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的项目代码可以在 [https://github.com/mkvenkit/pp2e/blob/main/gol_torus](https://github.com/mkvenkit/pp2e/blob/main/gol_torus)
    上找到。
- en: '[Rendering the Torus](nsp-venkitachalam503045-0008.xhtml#rbh1207)'
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[渲染圆环](nsp-venkitachalam503045-0008.xhtml#rbh1207)'
- en: We’ll first consider the code for rendering the torus, which is encapsulated
    in a class called `Torus` defined in the file *torus.py*. To see the complete
    code listing, skip ahead to [“The Complete Torus Rendering Code”](nsp-venkitachalam503045-0024.xhtml#ah1207)
    on [page 203](nsp-venkitachalam503045-0024.xhtml#p203).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先考虑用于渲染圆环的代码，它封装在名为 `Torus` 的类中，该类定义在文件 *torus.py* 中。要查看完整的代码列表，请跳到 [“完整的圆环渲染代码”](nsp-venkitachalam503045-0024.xhtml#ah1207)
    在 [第203页](nsp-venkitachalam503045-0024.xhtml#p203)。
- en: Defining the Shaders
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义着色器
- en: 'First, define the GLSL shaders for the torus. Here’s the vertex shader, which
    takes the per-vertex attributes of position, color, and normal and computes the
    transformed inputs for the fragment shader:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义圆环的 GLSL 着色器。以下是顶点着色器，它接受每个顶点的位置信息、颜色和法向量，并计算传递给片段着色器的变换输入：
- en: strVS = """
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: strVS = """
- en: version 410 core
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: version 410 core
- en: layout(location = 0) in vec3 aVert;
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: layout(location = 0) in vec3 aVert;
- en: layout(location = 1) in vec3 aColor;
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: layout(location = 1) in vec3 aColor;
- en: layout(location = 2) in vec3 aNormal;
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: layout(location = 2) in vec3 aNormal;
- en: uniform mat4 uMVMatrix;
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: uniform mat4 uMVMatrix;
- en: uniform mat4 uPMatrix;
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: uniform mat4 uPMatrix;
- en: ❶ flat out vec3 vColor;
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ flat out vec3 vColor;
- en: ❷ out vec3 vNormal;
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ out vec3 vNormal;
- en: ❸ out vec3 fragPos;
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ out vec3 fragPos;
- en: void main() {
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: void main() {
- en: // transform vertex
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: // 变换顶点
- en: gl_Position = uPMatrix * uMVMatrix * vec4(aVert, 1.0);
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: gl_Position = uPMatrix * uMVMatrix * vec4(aVert, 1.0);
- en: ❹ fragPos = aVert;
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ fragPos = aVert;
- en: vColor = aColor;
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: vColor = aColor;
- en: vNormal = aNormal;
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: vNormal = aNormal;
- en: '}'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"""'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: You define the vertex shader code as a string stored in `strVS`. The attribute
    variables for the shader are `aVert`, `aColor`, and `aNormal`, representing the
    coordinates, color, and normal vector for each vertex. Notice the `flat` qualifier
    when you initialize `vColor`, one of the outputs of the vertex shader ❶, indicating
    that this variable won’t be interpolated in the fragment shader. In effect, we’re
    saying that this variable will remain constant across the primitive (one of the
    triangles in a triangle strip). This ensures that every Game of Life cell will
    be a single color. This type of shading across a primitive is called *flat shading*.
    The next vertex shader output is `vNormal` ❷, which by default will be interpolated
    in the fragment shader. You need this so you can compute lighting across a primitive,
    but later you’ll see how to modify this shader code to support flat shading. The
    other output is called `fragPos` ❸. In the main shader code, you set this output
    to `aVert` ❹ so it can be passed into the fragment shader for lighting calculations.
    The shader also computes `gl_Position` and passes to the fragment shader the color
    and normal data as it is received.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你将顶点着色器代码定义为存储在 `strVS` 字符串中的内容。着色器的属性变量有 `aVert`、`aColor` 和 `aNormal`，分别表示每个顶点的坐标、颜色和法向量。请注意，当你初始化
    `vColor` 时，使用了 `flat` 关键字，这是顶点着色器的输出之一❶，表示该变量在片段着色器中不会进行插值。实际上，我们是在说明这个变量将在整个图元中保持恒定（即三角形带中的一个三角形）。这确保了每个“生命游戏”单元格将是单一的颜色。这种图元着色方法称为
    *平面着色*。下一个顶点着色器的输出是 `vNormal` ❷，它默认会在片段着色器中进行插值。你需要这个变量来计算图元的光照效果，但稍后你将看到如何修改着色器代码以支持平面着色。另一个输出是
    `fragPos` ❸。在主着色器代码中，你将此输出设置为 `aVert` ❹，以便将其传递到片段着色器中进行光照计算。着色器还会计算 `gl_Position`
    并将接收到的颜色和法向数据传递给片段着色器。
- en: Here’s the fragment shader, which applies lighting and computes the final color
    of the fragment. It’s defined as another string, called `strFS`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是片段着色器，它应用光照并计算片段的最终颜色。它被定义为另一个字符串，叫做 `strFS`。
- en: strFS = """
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: strFS = """
- en: version 410 core
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: version 410 core
- en: flat in vec3 vColor;
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: flat in vec3 vColor;
- en: in vec3 vNormal;
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: in vec3 vNormal;
- en: in vec3 fragPos;
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: in vec3 fragPos;
- en: out vec4 fragColor;
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: out vec4 fragColor;
- en: void main() {
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: void main() {
- en: ❶ vec3 lightPos = vec3(10.0, 10.0, 10.0);
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ vec3 lightPos = vec3(10.0, 10.0, 10.0);
- en: ❷ vec3 lightColor = vec3(1.0, 1.0, 1.0);
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ vec3 lightColor = vec3(1.0, 1.0, 1.0);
- en: ❸ vec3 lightDir = normalize(lightPos - fragPos);
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ vec3 lightDir = normalize(lightPos - fragPos);
- en: float diff = max(dot(vNormal, lightDir), 0.0);
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: float diff = max(dot(vNormal, lightDir), 0.0);
- en: vec3 diffuse = diff * lightColor;
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: vec3 diffuse = diff * lightColor;
- en: float ambient = 0.1;
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: float ambient = 0.1;
- en: ❹ vec3 result = (ambient + diffuse) * vColor.xyz;
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ vec3 result = (ambient + diffuse) * vColor.xyz;
- en: fragColor = vec4(result, 1.0);
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: fragColor = vec4(result, 1.0);
- en: '}'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '"""'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '"""'
- en: Notice that the color, normal, and fragment position variables, which were outputs
    from the vertex shader, are now inputs to the fragment shader. In the main shader
    code, you define the position ❶ and color ❷ for a light source. Then you compute
    the light direction ❸. The resulting color ❹ is a mix of ambient and diffuse components
    of the light and is set as the output from the fragment shader.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，颜色、法向量和片段位置变量（它们是顶点着色器的输出）现在是片段着色器的输入。在主着色器代码中，你定义了光源的位置信息❶和颜色❷。然后你计算光线的方向❸。最终的颜色❹是环境光和漫反射光成分的混合，并作为片段着色器的输出。
- en: Keep in mind that `fragPos` and `vNormal` are computed for each fragment via
    interpolation, whereas `vColor` is constant for a given primitive. The net effect
    is that the intrinsic color of a primitive (a triangle strip, in this case) remains
    constant, while the perceived color varies across the primitive based on its orientation
    with respect to the light source. This is exactly what you need to set each Game
    of Life cell to a solid color, while varying that color to create the appearance
    of lighting.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`fragPos` 和 `vNormal` 是通过插值计算得出的每个片段的值，而 `vColor` 对于给定的图元是恒定的。最终效果是图元（在此案例中是三角形带）的固有颜色保持不变，而感知颜色则根据图元相对于光源的方向在图元内发生变化。这正是你需要的，它可以将每个“生命游戏”单元格设置为一种固体颜色，同时变化颜色以创建光照效果。
- en: Initializing the Torus Class
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始化 Torus 类
- en: 'Now let’s look at the initialization code in the `Torus` class constructor:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下 `Torus` 类构造函数中的初始化代码：
- en: 'class Torus:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Torus:'
- en: '""" OpenGL 3D scene class"""'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '""" OpenGL 3D 场景类"""'
- en: '# initialization'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始化'
- en: '❶ def __init__(self, R, r, NX, NY):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '❶ def __init__(self, R, r, NX, NY):'
- en: global strVS, strFS
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: global strVS, strFS
- en: '# modify shader for flat shading'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '# 修改着色器以实现平面着色'
- en: '# create shader'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建着色器'
- en: ❷ self.program = glutils.loadShaders(strVS, strFS)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ self.program = glutils.loadShaders(strVS, strFS)
- en: glProvokingVertex(GL_FIRST_VERTEX_CONVENTION)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: glProvokingVertex(GL_FIRST_VERTEX_CONVENTION)
- en: self.pMatrixUniform = glGetUniformLocation(self.program,
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: self.pMatrixUniform = glGetUniformLocation(self.program,
- en: b'uPMatrix')
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: b'uPMatrix')
- en: self.mvMatrixUniform = glGetUniformLocation(self.program,
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: self.mvMatrixUniform = glGetUniformLocation(self.program,
- en: b'uMVMatrix')
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: b'uMVMatrix')
- en: '# torus geometry'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '# 环面几何'
- en: self.R = R
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: self.R = R
- en: self.r = r
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: self.r = r
- en: '# grid size'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '# 网格大小'
- en: self.NX = NX
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: self.NX = NX
- en: self.NY = NY
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: self.NY = NY
- en: '# no. of points'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '# 点的数量'
- en: ❸ self.N = self.NX
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ self.N = self.NX
- en: self.M = self.NY
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: self.M = self.NY
- en: '# time'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '# 时间'
- en: self.t = 0
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: self.t = 0
- en: '# compute parameters for glMultiDrawArrays'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '# 为 glMultiDrawArrays 计算参数'
- en: M1 = 2*self.M + 2
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: M1 = 2*self.M + 2
- en: ❹ self.first_indices = [2*M1*i for i in range(self.N)]
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ self.first_indices = [2*M1*i for i in range(self.N)]
- en: self.counts = [2*M1 for i in range(self.N)]
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: self.counts = [2*M1 for i in range(self.N)]
- en: '# colors: {(i, j) : (r, g, b)}'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '# 颜色: {(i, j) : (r, g, b)}'
- en: '# with NX * NY entries'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '# 具有 NX * NY 项'
- en: ❺ self.colors_dict = self.init_colors(self.NX, self.NY)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ self.colors_dict = self.init_colors(self.NX, self.NY)
- en: '# create an empty array to hold colors'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建一个空数组以保存颜色'
- en: ❻ self.colors = np.zeros((3*self.N*(2*self.M + 2), ), np.float32)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ self.colors = np.zeros((3*self.N*(2*self.M + 2), ), np.float32)
- en: '# get vertices, normals, indices'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '# 获取顶点、法线、索引'
- en: ❼ vertices, normals = self.compute_vertices()
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ vertices, normals = self.compute_vertices()
- en: ❽ self.compute_colors()
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ self.compute_colors()
- en: '# set up vertex buffer objects'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '# 设置顶点缓冲对象'
- en: ❾ self.setup_vao(vertices, normals, self.colors)
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ self.setup_vao(vertices, normals, self.colors)
- en: 'The `Torus` class has the following parameters in its constructor ❶: the radius
    `R` of the outer ring of the torus, the radius `r` of the torus tube, and `NX`
    and `NY` for the number of Game of Life simulation cells in the x- and y-directions.
    The constructor’s first order of business is to load the shaders. You use the
    `loadShaders()` method ❷ defined in the common *glutils.py* file. In the subsequent
    lines, you store the variables passed into the `Torus` constructor in instance
    variables such as `self.R` so they can be accessed later from other methods. Then
    you set `N`, the number of points on the outer circle of the torus, to be `NX`,
    the number of cells in the x-direction ❸. You similarly set `M`, the number of
    points along the smaller radius `r` of the torus, to `NY`. This scheme is discussed
    in the [“Mapping the Grid to the Torus”](nsp-venkitachalam503045-0024.xhtml#bh1206)
    section.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`Torus` 类在其构造函数 ❶ 中具有以下参数：环面外环的半径 `R`，环面管道的半径 `r`，以及用于表示“生命游戏”模拟单元在 x 和 y 方向的数量的
    `NX` 和 `NY`。构造函数的首要任务是加载着色器。你使用了在公共 *glutils.py* 文件中定义的 `loadShaders()` 方法 ❷。在后续行中，你将传递给
    `Torus` 构造函数的变量存储到实例变量中，例如 `self.R`，以便在后续方法中访问。然后，你将 `N`（环面外圆上的点数）设置为 `NX`（x 方向上的单元数）
    ❸。你类似地将 `M`（环面较小半径 `r` 上的点数）设置为 `NY`。这个方案在 [“将网格映射到环面”](nsp-venkitachalam503045-0024.xhtml#bh1206)
    部分中进行了讨论。'
- en: Next, you do some additional preparation for rendering the triangle strips that
    will form the bands along the outer ring of the torus. You’ll eventually be using
    the `glMultiDrawArrays()` OpenGL method to render all the triangle strips at once.
    This method is an efficient way to draw multiple triangle strip primitives using
    just one function call. As you saw in the [“Rendering”](nsp-venkitachalam503045-0024.xhtml#bh1203)
    section, each triangle strip has 2*M* + 2 vertices, and you have *N* of these
    strips. So, the starting indices for these triangle strips will be [0, (2*M* +
    2), (2*M* + 2) × 2, . . . , (2*M* + 2) × *N*]. Accordingly, you set `first_indices`
    and `counts` ❹, which will be required parameters when you call `glMultiDrawArrays()`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你做了一些额外的准备工作，用于渲染将形成环面外环带的三角形条带。最终，你将使用 `glMultiDrawArrays()` OpenGL 方法一次性渲染所有的三角形条带。该方法是一种高效的方式，通过一个函数调用绘制多个三角形条带原语。正如你在
    [“渲染”](nsp-venkitachalam503045-0024.xhtml#bh1203) 部分中看到的，每个三角形条带有 2*M* + 2 个顶点，你有
    *N* 个这样的条带。因此，这些三角形条带的起始索引将是 [0, (2*M* + 2), (2*M* + 2) × 2, . . . , (2*M* + 2)
    × *N*]。因此，你设置了 `first_indices` 和 `counts` ❹，这些将在调用 `glMultiDrawArrays()` 时作为必需的参数。
- en: The `init_colors()` method ❺ initializes `color_dict`, which maps each grid
    cell to a color—black or white. We’ll look at the details of the `init_colors()`
    method soon. You initialize the `numpy` array `colors` to zeros ❻. You’ll later
    populate this array with the correct values. You conclude the constructor by computing
    the vertices and normals for the torus ❼, as well as the colors ❽, and by setting
    up the vertex array object (VAO) for rendering the torus ❾.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`init_colors()`方法❺初始化了`color_dict`，该字典将每个网格单元映射到一个颜色——黑色或白色。稍后我们将详细查看`init_colors()`方法。你将`numpy`数组`colors`初始化为零❻。随后，你会用正确的值填充这个数组。构造函数的结尾部分计算了环面的顶点和法线❼，以及颜色❽，并设置了用于渲染环面的顶点数组对象（VAO）❾。'
- en: 'Now let’s look at the `Torus` class’s `init_colors()` method that was just
    mentioned:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下刚才提到的`Torus`类的`init_colors()`方法：
- en: 'def init_colors(self, NX, NY):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'def init_colors(self, NX, NY):'
- en: '"""initialize color dictionary"""'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '"""初始化颜色字典"""'
- en: colors = {}
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: colors = {}
- en: c1 = [1.0, 1.0, 1.0]
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: c1 = [1.0, 1.0, 1.0]
- en: 'for i in range(NX):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(NX):'
- en: 'for j in range(NY):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(NY):'
- en: ❶ colors[(i, j)] = c1
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ colors[(i, j)] = c1
- en: return colors
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: return colors
- en: The `init_colors()` method creates a dictionary called `colors` mapping from
    simulation cell index (*i*, *j*) to the color that should be applied to the cell.
    To begin, you simply set all the cell color values to `c1`, which is just plain
    white ❶. As the Game of Life simulation unfolds, the values in this dictionary
    will be updated to turn cells on and off.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`init_colors()`方法创建了一个名为`colors`的字典，该字典将仿真单元的索引（*i*，*j*）映射到应应用于该单元的颜色。开始时，你将所有单元的颜色值简单地设置为`c1`，即纯白色❶。随着“生命游戏”仿真的展开，这个字典中的值将被更新，控制单元的开启和关闭。'
- en: Calculating the Vertices
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 计算顶点
- en: 'The next few methods we’ll consider work together to compute all the torus
    vertices. We begin with the `compute_vertices()` method:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将考虑的几个方法一起工作，用于计算所有的环面顶点。我们从`compute_vertices()`方法开始：
- en: 'def compute_vertices(self):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'def compute_vertices(self):'
- en: R, r, N, M = self.R, self.r, self.N, self.M
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: R, r, N, M = self.R, self.r, self.N, self.M
- en: '# create an empty array to hold vertices/normals'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '# 创建一个空数组来存储顶点/法线'
- en: vertices = []
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: vertices = []
- en: normals = []
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: normals = []
- en: 'for i in range(N):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(N):'
- en: '# for all M points around a ring'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '# 对于环上的所有M个点'
- en: 'for j in range(M+1):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(M+1):'
- en: '# compute angle theta of point'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算点的角度theta'
- en: ❶ theta = (j % M) *2*math.pi/M
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ theta = (j % M) *2*math.pi/M
- en: '#---ring #1------'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '#---环 #1------'
- en: '# compute angle'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算角度'
- en: ❷ alpha1 = i*2*math.pi/N
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ alpha1 = i*2*math.pi/N
- en: '# compute transforms'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算变换'
- en: ❸ RM1, TM1 = self.compute_rt(R, alpha1)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ RM1, TM1 = self.compute_rt(R, alpha1)
- en: '# compute points'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算点'
- en: ❹ Pt1, NV1 = self.compute_pt(r, theta, RM1, TM1)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ Pt1, NV1 = self.compute_pt(r, theta, RM1, TM1)
- en: '#---ring #2------'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '#---环 #2------'
- en: '# index of next ring'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '# 下一个环的索引'
- en: ❺ ip1 = (i + 1) % N
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ ip1 = (i + 1) % N
- en: '# compute angle'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算角度'
- en: ❻ alpha2 = ip1*2*math.pi/N
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ alpha2 = ip1*2*math.pi/N
- en: '# compute transforms'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算变换'
- en: RM2, TM2 = self.compute_rt(R, alpha2)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: RM2, TM2 = self.compute_rt(R, alpha2)
- en: '# compute points'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算点'
- en: Pt2, NV2 = self.compute_pt(r, theta, RM2, TM2)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Pt2, NV2 = self.compute_pt(r, theta, RM2, TM2)
- en: '# store vertices/normals in right order for GL_TRIANGLE_STRIP'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '# 以正确的顺序存储顶点/法线以供GL_TRIANGLE_STRIP使用'
- en: ❼ vertices.append(Pt1[0:3])
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ vertices.append(Pt1[0:3])
- en: vertices.append(Pt2[0:3])
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: vertices.append(Pt2[0:3])
- en: '# add normals'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '# 添加法线'
- en: normals.append(NV1[0:3])
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: normals.append(NV1[0:3])
- en: normals.append(NV2[0:3])
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: normals.append(NV2[0:3])
- en: '# return vertices and colors in correct format'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '# 返回顶点和颜色的正确格式'
- en: ❽ vertices = np.array(vertices, np.float32).reshape(-1)
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ vertices = np.array(vertices, np.float32).reshape(-1)
- en: normals = np.array(normals, np.float32).reshape(-1)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: normals = np.array(normals, np.float32).reshape(-1)
- en: '# print(vertices.shape)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '# print(vertices.shape)'
- en: return vertices, normals
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: return vertices, normals
- en: The `compute_vertices()` method begins by creating empty lists to store the
    vertices and normals. Then you compute the vertices and normals for the torus,
    using a nested loop to implement the strategy we discussed in the [“Rendering”](nsp-venkitachalam503045-0024.xhtml#bh1203)
    section. The outer loop iterates over the `N` rings that make up the torus. The
    inner loop iterates over the `M` points on each of those rings. Within the loops,
    you first compute the angle `theta` subtended by a point on the ring with index
    `j` ❶. You use `j % M` and have the inner loop iterate over range `[0, M+1)` so
    that when *j* is equal to `M`, `(j % M)` rolls back to `0`. This is to complete
    the last segment of the ring.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`compute_vertices()` 方法首先通过创建空列表来存储顶点和法线。然后，你使用嵌套循环来计算环形面的顶点和法线，采用我们在 [“渲染”](nsp-venkitachalam503045-0024.xhtml#bh1203)
    部分讨论的策略。外层循环遍历组成环形面的 `N` 个环形面，内层循环遍历每个环形面上的 `M` 个点。在循环内部，你首先计算出索引为 `j` ❶ 的环形面上的点所对的角度
    `theta`。你使用 `j % M`，并让内层循环遍历范围 `[0, M+1)`，这样当 *j* 等于 `M` 时，`(j % M)` 会回滚到 `0`。这是为了完成环形面的最后一段。'
- en: The torus is rendered as a set of bands (triangle strips), and each band consists
    of two adjacent rings of points. You compute `alpha1`, the angle subtended by
    the first ring in a band, at index `i` ❷, and use `alpha1` to compute the rotation
    and translation matrices for this first ring using the `compute_rt()` method ❸.
    Then you pass these matrices to the `compute_pt()` method to calculate the vertex
    and normal for the point on the ring at angle `theta` ❹. We’ll look at how the
    `compute_rt()` and `compute_pt()` methods work soon.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 环形面被渲染为一组带状图形（平面条带），每个带状图形由两个相邻的环形面上的点组成。你计算了带状图形中第一个环形面上角度为 `alpha1` 的值，在索引
    `i` 处 ❷，并使用 `alpha1` 来计算这个第一个环形面上的旋转和平移矩阵，使用 `compute_rt()` 方法 ❸。然后你将这些矩阵传递给 `compute_pt()`
    方法，以计算在角度 `theta` 处的环形面上点的顶点和法线 ❹。我们很快将详细了解 `compute_rt()` 和 `compute_pt()` 方法是如何工作的。
- en: Next, you move on to the adjacent ring at index `i+1`, using `ip1 = (i+1) %
    N` to ensure that you roll back to zero at the end ❺. You compute the angle `alpha2`
    of the ring at index `ip1` ❻ and then compute the vertex and normal for the point
    on the `ip1` ring at angle `theta`, just as you did for the first ring.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你转向下一个索引为 `i+1` 的相邻环形面，使用 `ip1 = (i+1) % N` 来确保在末尾时返回到零 ❺。你计算索引为 `ip1` 的环形面上的角度
    `alpha2` ❻，然后计算索引为 `ip1` 的环形面上在角度 `theta` 处的顶点和法线，就像你为第一个环形面做的那样。
- en: Beginning at ❼, you append the vertices and normals for the adjacent rings to
    the lists you created at the beginning of the method. You pick only the first
    three coordinates of each vertex and normal, as in `Pt1[0:3]`, since all the matrix
    transformations are done with homogeneous coordinates in the form (*x*, *y*, *z*,
    *w*), and you need only (*x*, *y*, *z*). This action stores the vertices and normals
    in a Python list of triplets of the form `[[x1, y1, z1], [x2, y2, z2], ...]`.
    However, OpenGL expects vertex attributes to be provided in a flat array with
    a known size. Therefore, you convert the `vertices` and `normals` lists into `numpy`
    arrays of 32-bit floats ❽, using `reshape(-1)` to ensure that they’re flat arrays
    of the form `[x1, y1, z1, x2, y2, z2, ...]`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 从 ❼ 开始，你将相邻环形面的顶点和法线附加到方法开始时创建的列表中。你只选择每个顶点和法线的前三个坐标，如 `Pt1[0:3]`，因为所有矩阵变换都使用齐次坐标（*x*，*y*，*z*，*w*）进行，而你只需要
    (*x*，*y*，*z*)。此操作将顶点和法线存储在一个包含三元组的 Python 列表中，格式为 `[[x1, y1, z1], [x2, y2, z2],
    ...]`。然而，OpenGL 希望以平面数组的形式提供顶点属性，并且已知数组的大小。因此，你将 `vertices` 和 `normals` 列表转换为
    32 位浮点的 `numpy` 数组 ❽，使用 `reshape(-1)` 来确保它们是平面数组，格式为 `[x1, y1, z1, x2, y2, z2,
    ...]`。
- en: 'Now let’s look at the `compute_rt()` and `compute_pt()` methods that helped
    you compute the vertices and normals. We’ll start with `compute_rt()`, which calculates
    the rotation and translation matrices needed to render a given ring in the torus:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下 `compute_rt()` 和 `compute_pt()` 方法，它们帮助你计算了顶点和法线。我们从 `compute_rt()`
    开始，它计算了渲染给定环形面环所需的旋转和平移矩阵：
- en: 'def compute_rt(self, R, alpha):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 'def compute_rt(self, R, alpha):'
- en: '# compute position of ring'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算环形面的位置'
- en: ❶ Tx = R*math.cos(alpha)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Tx = R*math.cos(alpha)
- en: Ty = R*math.sin(alpha)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Ty = R*math.sin(alpha)
- en: Tz = 0.0
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Tz = 0.0
- en: '# rotation matrix'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '# 旋转矩阵'
- en: ❷ RM = np.array([
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ RM = np.array([
- en: '[math.cos(alpha), -math.sin(alpha), 0.0, 0.0],'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[math.cos(alpha), -math.sin(alpha), 0.0, 0.0],'
- en: '[math.sin(alpha), math.cos(alpha), 0.0, 0.0],'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[math.sin(alpha), math.cos(alpha), 0.0, 0.0],'
- en: '[0.0, 0.0, 1.0, 0.0],'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[0.0, 0.0, 1.0, 0.0],'
- en: '[0.0, 0.0, 0.0, 1.0]'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[0.0, 0.0, 0.0, 1.0]'
- en: '], dtype=np.float32)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '], dtype=np.float32)'
- en: '# translation matrix'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '# 平移矩阵'
- en: ❸ TM = np.array([
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ TM = np.array([
- en: '[1.0, 0.0, 0.0, Tx],'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[1.0, 0.0, 0.0, Tx],'
- en: '[0.0, 1.0, 0.0, Ty],'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[0.0, 1.0, 0.0, Ty],'
- en: '[0.0, 0.0, 1.0, Tz],'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[0.0, 0.0, 1.0, Tz],'
- en: '[0.0, 0.0, 0.0, 1.0]'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[0.0, 0.0, 0.0, 1.0]'
- en: '], dtype=np.float32)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '], dtype=np.float32)'
- en: return (RM, TM)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: return (RM, TM)
- en: You first calculate the translation components of the matrix ❶, using parametric
    equations. Then you create the rotation matrix ❷ and translation matrix ❸ as `numpy`
    arrays. You’ve seen these matrices before in the [“Computing Vertices”](nsp-venkitachalam503045-0024.xhtml#bh1201)
    section. You return the arrays at the end of the method.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: You first calculate the translation components of the matrix ❶, using parametric
    equations. Then you create the rotation matrix ❷ and translation matrix ❸ as `numpy`
    arrays. You’ve seen these matrices before in the [“Computing Vertices”](nsp-venkitachalam503045-0024.xhtml#bh1201)
    section. You return the arrays at the end of the method.
- en: 'Here’s the other helper method, `compute_pt()`, which uses the translation
    and rotation matrices to determine the vertex and normal vector of a given point
    on a ring of the torus:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 'Here’s the other helper method, `compute_pt()`, which uses the translation
    and rotation matrices to determine the vertex and normal vector of a given point
    on a ring of the torus:'
- en: 'def compute_pt(self, r, theta, RM, TM):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 'def compute_pt(self, r, theta, RM, TM):'
- en: '# compute point coords'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '# compute point coords'
- en: ❶ P = np.array([r*math.cos(theta), 0.0, r*math.sin(theta), 1.0],
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ P = np.array([r*math.cos(theta), 0.0, r*math.sin(theta), 1.0],
- en: dtype=np.float32)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: dtype=np.float32)
- en: '# print(P)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '# print(P)'
- en: '# apply rotation - this also gives us the vertex normals'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '# apply rotation - this also gives us the vertex normals'
- en: ❷ NV = np.dot(RM, P)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ NV = np.dot(RM, P)
- en: '# apply translation'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '# apply translation'
- en: ❸ Pt = np.dot(TM, NV)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Pt = np.dot(TM, NV)
- en: return (Pt, NV)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: return (Pt, NV)
- en: You compute the point `P` at angle `theta` on a ring lying on the XZ plane ❶.
    Then you apply a rotation to this point by multiplying it by the rotation matrix
    ❷. This also gives you the point’s normal vector. You multiply the normal by the
    translation matrix to give you the vertex on the torus ❸.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: You compute the point `P` at angle `theta` on a ring lying on the XZ plane ❶.
    Then you apply a rotation to this point by multiplying it by the rotation matrix
    ❷. This also gives you the point’s normal vector. You multiply the normal by the
    translation matrix to give you the vertex on the torus ❸.
- en: Managing Cell Colors
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Managing Cell Colors
- en: Now we’ll examine some methods that help set the colors of the cells on the
    torus. First is the `compute_colors()` method, which we originally called as part
    of the `Torus` class’s constructor. It sets the color of each triangle in the
    triangle strips that make up the torus, based on the values determined by the
    Game of Life simulation.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Now we’ll examine some methods that help set the colors of the cells on the
    torus. First is the `compute_colors()` method, which we originally called as part
    of the `Torus` class’s constructor. It sets the color of each triangle in the
    triangle strips that make up the torus, based on the values determined by the
    Game of Life simulation.
- en: 'def compute_colors(self):'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 'def compute_colors(self):'
- en: R, r, N, M = self.R, self.r, self.N, self.M
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: R, r, N, M = self.R, self.r, self.N, self.M
- en: '# the points on the ring are generated on the X-Z plane'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '# the points on the ring are generated on the X-Z plane'
- en: '# then they are rotated and translated into the correct'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '# then they are rotated and translated into the correct'
- en: '# position on the torus'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '# position on the torus'
- en: '# for all N rings around the torus'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '# for all N rings around the torus'
- en: 'for i in range(N):'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 'for i in range(N):'
- en: '# for all M points around a ring'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '# for all M points around a ring'
- en: 'for j in range(M+1):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 'for j in range(M+1):'
- en: '# j value'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '# j value'
- en: jj = j % M
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: jj = j % M
- en: '# store colors - same color applies to (V_i_j, V_ip1_j)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '# store colors - same color applies to (V_i_j, V_ip1_j)'
- en: ❶ col = self.colors_dict[(i, jj)]
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ col = self.colors_dict[(i, jj)]
- en: '# get index into array'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '# get index into array'
- en: ❷ index = 3*(2*i*(M+1) + 2*j)
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ index = 3*(2*i*(M+1) + 2*j)
- en: '# set color'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '# set color'
- en: ❸ self.colors[index:index+3] = col
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ self.colors[index:index+3] = col
- en: ❹ self.colors[index+3:index+6] = col
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ self.colors[index+3:index+6] = col
- en: This method follows the logic described in [“Coloring the Triangle Strips”](nsp-venkitachalam503045-0024.xhtml#bh1204)
    on [page 185](nsp-venkitachalam503045-0024.xhtml#p185) to update the values in
    the `colors` array, which was initialized as an array of all zeros. You retrieve
    the color for cell `(i, jj)` from `colors_dict`, the dictionary mapping cells
    to colors that you created earlier ❶. (You define `jj = j % M` so it rolls over
    to zero at the end.) Then you compute the index into the `colors` array at which
    you should update the new computed values ❷. Each pair of rings that makes up
    a band has `2*(M+1)` vertices, and there are `N` of these pairs. Starting at each
    location in the array, you store three sequential values (the RGB components of
    a cell’s color). Hence, the index of the *j*th color in a ring for the *i*th segment
    of the torus will be given by `3*(2*i*(M+1) + 2*j)`. Note that you use `j` and
    not `jj` in computing the index, since you’re storing the computed values here
    and you don’t want the index to roll over to zero. Now that you have the index,
    you update the `colors` array with the new computed values. You update the array
    both at `[index:index+3]` ❸ and at `[index+3:index+6]` ❹ since each cell on the
    torus is a quad, made of two adjacent triangles.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now look at `recalc_colors()`, a method for updating the color values
    stored on the GPU at each step in the Game of Life simulation:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'def recalc_colors(self):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '# get colors'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: self.compute_colors()
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '# bind VAO'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(self.vao)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '# set buffer data'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: ❶ glBufferSubData(GL_ARRAY_BUFFER, 0, 4*len(self.colors), self.colors)
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '# unbind VAO'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(0)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: For every step of the simulation, the colors of the cells are updated, which
    means you need to update the colors of all the triangle strips on the torus, and
    you need to do it efficiently so you don’t slow down the rendering. The `recalc_colors()`
    method does this using the OpenGL `glBufferSubData()` method ❶. The vertices,
    normals, and colors are stored in attribute arrays on the GPU. The vertices and
    normals don’t change, so you computed them only once in the beginning, with a
    call to `compute_vertices()` in the class’s constructor method. When the colors
    change, `glBufferSubData()` updates the color attribute arrays rather than creating
    them afresh.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the Torus
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Finally, here’s the `render()` method that draws the torus:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'def render(self, pMatrix, mvMatrix):'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '# use shader'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: ❶ glUseProgram(self.program)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '# set proj matrix'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: ❷ glUniformMatrix4fv(self.pMatrixUniform, 1, GL_FALSE, pMatrix)
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '# set modelview matrix'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: ❸ glUniformMatrix4fv(self.mvMatrixUniform, 1, GL_FALSE, mvMatrix)
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '# bind VAO'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: ❹ glBindVertexArray(self.vao)
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '# draw'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: ❺ glMultiDrawArrays(GL_TRIANGLE_STRIP, self.first_indices,
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: self.counts, self.N)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '# unbind VAO'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(0)
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: This method is similar to the render methods you saw in the [previous chapter](nsp-venkitachalam503045-0023.xhtml#ch09).
    You make a call to use the shader program ❶ and set the projection ❷ and modelview
    ❸ matrix uniform variables. Then you bind to the vertex array object ❹, which
    you created by calling `setup_vao()` in the class’s constructor. The VAO has all
    the attribute array buffers you need. Next, you use the `glMultiDrawArrays()`
    method to draw `N` triangle strips ❺. You already computed `first_indices` and
    `counts` in the `Torus` constructor.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[Implementing the Game of Life Simulation](nsp-venkitachalam503045-0008.xhtml#rbh1208)'
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03), you implemented Conway’s
    Game of Life (GOL) by using `matplotlib` to visualize the updated values of the
    simulation grid. Here you’ll adapt the earlier implementation to update a dictionary
    of cell colors instead, which will be used to update the colors of the torus.
    The relevant code is encapsulated in a class called `GOL`, declared in the file
    *gol.py*. To see the complete code listing, skip ahead to [“The Complete Game
    of Life Simulation Code”](nsp-venkitachalam503045-0024.xhtml#ah1208) on [page
    209](nsp-venkitachalam503045-0024.xhtml#p209).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: The Class Constructor
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, let’s look at the `GOL` class constructor:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'class GOL:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '❶ def __init__(self, NX, NY, glider):'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '"""GOL constructor"""'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '# a grid of NX x NY random values'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: self.NX, self.NY = NX, NY
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'if glider:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: ❷ self.addGlider(1, 1, NX, NY)
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: ❸ self.grid = np.random.choice([1, 0], NX * NY,
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: p=[0.2, 0.8]).reshape(NX, NY)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: The `GOL` constructor takes as input the grid dimensions `NX` and `NY`, as well
    as a Boolean flag `glider` ❶. If this flag is set, you initialize the simulation
    grid with the “glider” pattern using the `addGlider()` method ❷. Since we already
    discussed this method in [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03),
    we won’t examine it here. If the `glider` flag isn’t set, you just initialize
    the grid to random ones and zeros ❸.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: The `GOL` class uses an `update()` method to update the simulation grid at each
    time step. Again, this is identical to the previous implementation.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The get_colors() Method
  id: totrans-327
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `get_colors()` method is what distinguishes this chapter’s Game of Life
    implementation from that of [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03).
    The method builds up a dictionary mapping of each Game of Life cell to its color
    value at a given step in the simulation: black for ON or white for OFF. This dictionary
    is passed to the `Torus` object when the scene is updated.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'def get_colors(self):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: colors = {}
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: ❶ c1 = np.array([1.0, 1.0, 1.0], np.float32)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: ❷ c2 = np.array([0.0, 0.0, 0.0], np.float32)
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(self.NX):'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range (self.NY):'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.grid[i, j] == 1:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: colors[(i, j)] = c2
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'else :'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: colors[(i, j)] = c1
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: return colors
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Here you iterate through all the cells in the simulation grid and set the RGB
    colors based on whether the grid value is `0` or `1`. The possible colors are
    defined as `c1` for white ❶ or `c2` for black ❷. These colors will be used while
    rendering the torus.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你遍历模拟网格中的所有单元格，并根据网格值是 `0` 还是 `1` 来设置 RGB 颜色。可用的颜色定义为 `c1` 对应白色 ❶ 或 `c2`
    对应黑色 ❷。这些颜色将在渲染圆环时使用。
- en: '[Creating the Camera](nsp-venkitachalam503045-0008.xhtml#rbh1209)'
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[创建相机](nsp-venkitachalam503045-0008.xhtml#rbh1209)'
- en: In [“Controlling the Camera”](nsp-venkitachalam503045-0024.xhtml#bh1205) on
    [page 185](nsp-venkitachalam503045-0024.xhtml#p185), we discussed how to build
    a camera that orbits around the torus. Now let’s look at the implementation. The
    code is encapsulated in the class `OrbitCamera`, which is declared in the file
    *camera.py*. To see the complete code listing, skip ahead to [“The Complete Camera
    Code”](nsp-venkitachalam503045-0024.xhtml#ah1209) on [page 211](nsp-venkitachalam503045-0024.xhtml#p211).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“控制相机”](nsp-venkitachalam503045-0024.xhtml#bh1205) 章节的 [第185页](nsp-venkitachalam503045-0024.xhtml#p185)中，我们讨论了如何构建一个围绕圆环旋转的相机。现在让我们来看一下实现。代码封装在
    `OrbitCamera` 类中，该类在 *camera.py* 文件中声明。要查看完整的代码列表，请跳到 [“完整的相机代码”](nsp-venkitachalam503045-0024.xhtml#ah1209)
    章节的 [第211页](nsp-venkitachalam503045-0024.xhtml#p211)。
- en: Constructing the Class
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建类
- en: 'Here’s the constructor for the `OrbitCamera` class:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `OrbitCamera` 类的构造函数：
- en: 'class OrbitCamera:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 'class OrbitCamera:'
- en: '"""helper class for viewing"""'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '"""用于查看的辅助类"""'
- en: 'def __init__(self, height, radius, beta_step=1):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, height, radius, beta_step=1):'
- en: ❶ self.radius = radius
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ self.radius = 半径
- en: ❷ self.beta = 0
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ self.beta = 0
- en: ❸ self.beta_step = beta_step
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ self.beta_step = beta_step
- en: ❹ self.height = height
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ self.height = height
- en: '# initial eye vector is (-R, 0, -H)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '# 初始眼睛向量是 (-R, 0, -H)'
- en: rr = radius/math.sqrt(2.0)
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: rr = 半径 / math.sqrt(2.0)
- en: ❺ self.eye = np.array([rr, rr, height], np.float32)
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ self.eye = np.array([rr, rr, height], np.float32)
- en: '# compute up vector'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '# 计算 up 向量'
- en: ❻ self.up = self.__compute_up_vector(self.eye )
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ self.up = self.__compute_up_vector(self.eye )
- en: '# center is origin'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '# center 是原点'
- en: ❼ self.center = np.array([0, 0, 0], np.float32)
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ self.center = np.array([0, 0, 0], np.float32)
- en: You start by setting the camera parameters passed into the `OrbitCamera` constructor.
    These include the camera’s orbit radius ❶ and `beta`, the angle that the view
    vector (projected on the XY plane) makes with the x-axis ❷. You also set the amount
    `beta` should increment with each time step of the camera rotation ❸ and the height
    of the camera from the XY plane ❹.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先设置传递给 `OrbitCamera` 构造函数的相机参数。这些包括相机的轨道半径 ❶ 和 `beta`，即视图向量（投影到 XY 平面上）与 x
    轴之间的角度 ❷。你还设置了每次相机旋转时 `beta` 应该增加的量 ❸，以及相机距离 XY 平面的高度 ❹。
- en: 'Next, you set the initial value of the eye position to be midway between the
    positive x- and positive y-axis, at a distance `R` from the origin, suspended
    at the specified `height` ❺. You can calculate this as:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将眼睛位置的初始值设置为在正 x 轴和正 y 轴之间的中点，距离原点的距离为 `R`，并悬挂在指定的 `height` 高度上 ❺。你可以这样计算：
- en: '![](images/nsp-venkitachalam503045-m10013.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![](images/nsp-venkitachalam503045-m10013.jpg)'
- en: Finally, you compute the camera’s up vector ❻ and set the center as the origin
    (0, 0, 0) ❼. Remember that these are the pieces of information, along with the
    eye position, that OpenGL needs to model a camera.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你计算相机的 up 向量 ❻ 并将中心设置为原点 (0, 0, 0) ❼。记住，这些信息以及眼睛的位置是 OpenGL 用来建模相机所需的内容。
- en: Calculating the Up Vector
  id: totrans-363
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 计算 Up 向量
- en: 'Here’s the method that you call in the `OrbitCamera` class constructor to compute
    the up vector:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在 `OrbitCamera` 类构造函数中调用的一个方法，用于计算 up 向量：
- en: 'def __compute_up_vector(self, E):'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __compute_up_vector(self, E):'
- en: '# N = (E x k) x E'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '# N = (E x k) x E'
- en: Z = np.array([0, 0, 1], np.float32)
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: Z = np.array([0, 0, 1], np.float32)
- en: ❶ U = np.cross(np.cross(E, Z), E)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ U = np.cross(np.cross(E, Z), E)
- en: '# normalize'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '# 归一化'
- en: ❷ U = U / np.linalg.norm(U)
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ U = U / np.linalg.norm(U)
- en: return U
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 U
- en: The `__compute_up_vector()` method calculates the up vector `U` based on the
    method we discussed earlier in [“Controlling the Camera”](nsp-venkitachalam503045-0024.xhtml#bh1205)
    on [page 185](nsp-venkitachalam503045-0024.xhtml#p185). Specifically, you use
    cross products and the initial up vector guess of (0, 0, 1) to compute the correct
    up vector ❶. Then you normalize the up vector ❷ before returning it.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`__compute_up_vector()` 方法基于我们在 [“控制相机”](nsp-venkitachalam503045-0024.xhtml#bh1205)
    章节的 [第185页](nsp-venkitachalam503045-0024.xhtml#p185)中讨论的方法来计算 up 向量 `U`。具体来说，你使用叉乘和初始的
    up 向量猜测 (0, 0, 1) 来计算正确的 up 向量 ❶。然后，你对 up 向量进行归一化 ❷，最后返回它。'
- en: Rotating the Camera
  id: totrans-373
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 旋转相机
- en: 'The `OrbitCamera` class’s `rotate()` method is called every time you need to
    rotate the camera around the torus by one step. Here’s the method’s definition:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'def rotate(self):'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '"""rotate by one step and compute new camera parameters"""'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: ❶ self.beta = (self.beta + self.beta_step) % 360
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '# recalculate eye E'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: ❷ self.eye = np.array([self.radius*math.cos(math.radians(self.beta)),
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: self.radius*math.sin(math.radians(self.beta)),
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: self.height], np.float32)
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '# up vector'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: ❸ self.up = self.__compute_up_vector(self.eye)
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: You increase the angle `beta` by the increment `beta_step`, using the `%` operator
    to ensure that the angle rolls over to 0 when it reaches 360 degrees ❶. Then you
    use the new `beta` value to compute the updated eye position ❷, and you use the
    new eye position to compute the new up vector with the `__compute_up_vector()`
    method ❸.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[Putting Everything Together](nsp-venkitachalam503045-0008.xhtml#rbh1210)'
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve built all the classes necessary for rendering the torus. Now you need
    some code to bring those classes together, create and manage the OpenGL window,
    and coordinate the rendered objects. Create the class `RenderWindow` (defined
    in *gol_torus.py*) for this purpose. It’s similar to the `RenderWindow` class
    used in [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09), so we’ll discuss
    only the parts of the code that are unique to the current project. To see the
    complete code listing, skip ahead to [“The Complete RenderWindow Code”](nsp-venkitachalam503045-0024.xhtml#ah1210)
    on [page 211](nsp-venkitachalam503045-0024.xhtml#p211).
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: The main() Function
  id: totrans-387
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we examine the `RenderWindow` class, let’s look the program’s `main()`
    function, which sets the whole simulation in motion. This function is also defined
    in *gol_torus.py*.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'def main():'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: print("Starting GOL. Press ESC to quit.")
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '# parse arguments'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: parser = argparse.ArgumentParser(description="Runs Conway's Game of Life
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: simulation on a Torus.")
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '# add arguments'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: ❶ parser.add_argument('--glider', action='store_true', required=False)
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: args = parser.parse_args()
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: glider = False
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'if args.glider:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: ❷ glider = True
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: ❸ rw = RenderWindow(glider)
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: ❹ rw.run()
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: You add a command line argument called `--glider` so you can bring up the torus
    with just a glider pattern on it ❶ and set the corresponding flag ❷. Then you
    create a `RenderWindow` object ❸, which initializes all the other objects needed
    for the program, and start the rendering with a call to the `RenderWindow` object’s
    `run()` method ❹.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: The RenderWindow Constructor
  id: totrans-403
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The constructor on the `RenderWindow` class starts with the standard GLFW OpenGL
    setup you saw in [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09), including
    setting the window size, calling the render methods, and handling window and keyboard
    events. Then the constructor goes on with the following Game of Life–specific
    initializations:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'class RenderWindow:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, glider):'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: --`snip`--
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '# create 3D'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: NX = 64
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: NY = 64
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: R = 4.0
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: r = 1.0
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: ❶ self.torus = Torus(R, r, NX, NY)
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: ❷ self.gol = GOL(NX, NY, glider)
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '# create a camera'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: ❸ self.camera = OrbitCamera(5.0, 10.0)
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '# exit flag'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: ❹ self.exitNow = False
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '# rotation flag'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: ❺ self.rotate = True
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '# skip count'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: ❻ self.skip = 0
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: First you set some parameters for the simulation, including the number of cells
    in the grid and the inner and outer radiuses of the torus. Then you create the
    `Torus` object using these parameters ❶, as well as the `GOL` object that will
    manage the simulation ❷. You also create the orbiting camera at a radius of 5
    units from the origin and a height of 10 units from the XY plane ❸.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Next, you set the exit flag used to quit the program ❹, and you initialize the
    rotation flag to `True` ❺. Finally, you set a `skip` variable ❻, which you’ll
    use to control the frequency at which the simulation updates. You’ll see how the
    `skip` variable works later in this section.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: The run() and step() Methods
  id: totrans-425
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `run()` method of the `RenderWindow` object is responsible for running
    the simulation, with help from the `step()` method. Let’s take a look at the `run()`
    method first:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'def run(self):'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '# initializer timer'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwSetTime(0)
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: t = 0.0
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '❶ while not glfw.glfwWindowShouldClose(self.win) and not self.exitNow:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '# update every x seconds'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: currT = glfw.glfwGetTime()
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '❷ if currT - t > 0.05:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '# update time'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: t = currT
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '# set viewport'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: ❸ self.width, self.height = glfw.glfwGetFramebufferSize(self.win)
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: self.aspect = self.width/float(self.height)
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: glViewport(0, 0, self.width, self.height)
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '# clear'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '# build projection matrix'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: pMatrix = glutils.perspective(60.0, self.aspect, 0.1, 100.0)
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: mvMatrix = glutils.lookAt(self.camera.eye, self.camera.center,
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: self.camera.up)
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '# render'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: ❹ self.torus.render(pMatrix, mvMatrix)
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '# step'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '❺ if self.rotate:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: self.step()
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwSwapBuffers(self.win)
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '# poll for and process events'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwPollEvents()
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '# end'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwTerminate()
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: The rendering scheme is designed to keep rendering frames in a loop until the
    window is closed or the ESC key is pressed ❶. Before you proceed, you check whether
    the time elapsed since the last render is greater than 0.05 seconds ❷. This helps
    maintain a maximum frame rate. Starting at ❸, you perform some standard OpenGL
    operations, such as setting the viewport, clearing the screen, and computing the
    current transformation that needs to be set into the vertex shader. Then you render
    the torus ❹ and call the `step()` method ❺, which will rotate the camera and update
    the Game of Life simulation by one time step. Once the rendering is done, you
    swap the OpenGL buffers and poll for further window events. If you exit the loop,
    you call the `glfwTerminate()` method for cleanup.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the `step()` method that increments the camera and the simulation:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'def step(self):'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '❶ if self.skip == 9:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '# update GOL'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: ❷ self.gol.update()
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: ❸ colors = self.gol.get_colors()
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: ❹ self.torus.set_colors(colors)
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '# step'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: ❺ self.torus.step()
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '# reset'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: ❻ self.skip = 0
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '# update skip'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: ❼ self.skip += 1
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '# rotate camera'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: ❽ self.camera.rotate()
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: Every time this method is called, it rotates the camera by one step ❽. You also
    want to update the Game of Life simulation, but doing so at the same rate that
    the camera moves would not be visually pleasing. You therefore use the `skip`
    variable to slow down the simulation by a factor of 9 relative to the camera motion.
    This variable starts from `0` and is incremented each time the `step()` method
    is called ❼. When `skip` gets to `9` ❶, you update the simulation by one time
    step. To do this, you first call the `GOL` class’s `update()` method ❷, which
    turns cells on or off according to the Conway’s Game of Life rules. Then you get
    the updated cell colors from the simulation ❸, set them to the torus ❹, and call
    `torus.step()` ❺, which will update the attribute buffers with the new colors.
    Finally, you reset the `skip` variable to `0` so the process can repeat ❻.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '[Running the 3D Game of Life Simulation](nsp-venkitachalam503045-0008.xhtml#rah1204)'
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we’re ready to run the code. Enter the following at the terminal:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: $ `python gol_torus.py`
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-8](nsp-venkitachalam503045-0024.xhtml#fig10-8) shows the output.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f10008.jpg)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-8: A rendering of the Game of Life on a torus'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: The program will open a window that shows the torus you meticulously constructed,
    with the Game of Life simulation running on its surface! As the simulation evolves,
    try to find some of the familiar Game of Life patterns you saw in [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03).
    Notice that the light direction remains constant while the camera orbits the torus.
    As the camera turns, you’ll be able to see the light and dark portions of the
    torus.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s try the glider option:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: $ `python gol_torus.py --glider`
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-9](nsp-venkitachalam503045-0024.xhtml#fig10-9) shows the output.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f10009.jpg)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-9: A Game of Life glider on a torus'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: Sit back and enjoy watching the lone glider make its way along the surface of
    the torus!
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah1205)'
  id: totrans-487
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you implemented Conway’s Game of Life on a torus. You learned
    how to compute the vertices of a torus and how to render it using OpenGL, and
    you saw how code can be adapted from one context (a flat rendering of the Game
    of Life simulation) to another (a 3D rendering of the same simulation). In the
    process, I hope you’ve gotten a more intuitive feeling for how the toroidal boundary
    conditions we discussed in [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03) work.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah1206)'
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few experiments you can try with this project:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: 1\. In this chapter’s implementation, the torus is lit by a single light source.
    Try adding another light source in the shader code. Now the computed color of
    a vertex will be the sum of contributions from both light sources. Try changing
    the positions and colors of the light sources and see the effect on the torus
    lighting.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. To get a representative view of the simulation, you defined a camera that
    revolves around the z-axis of the torus, in a plane parallel to the XY plane.
    Now create a camera that flies over the torus instead. Your camera will start
    by looking down at the torus along the negative z-axis and will move in a circle
    along the XZ plane, at a fixed distance from the center of the torus. Think about
    how you will compute the eye point, view direction, and up vector for each step
    of the movement.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[The Complete Torus Rendering Code](nsp-venkitachalam503045-0008.xhtml#rah1207)'
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s the complete listing for the file *torus.py*:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: torus.py
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: A Python OpenGL program that generates a torus.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: import OpenGL
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: from OpenGL.GL import *
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: import math, sys, os
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: import glutils
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: import glfw
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: strVS = """
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: version 330 core
  id: totrans-507
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: layout(location = 0) in vec3 aVert;
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: layout(location = 1) in vec3 aColor;
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: layout(location = 2) in vec3 aNormal;
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: uniform mat4 uMVMatrix;
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: uniform mat4 uPMatrix;
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: flat out vec3 vColor;
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: out vec3 vNormal;
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: out vec3 fragPos;
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: void main() {
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: // transform vertex
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: gl_Position = uPMatrix * uMVMatrix * vec4(aVert, 1.0);
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: fragPos = aVert;
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: vColor = aColor;
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: vNormal = aNormal;
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: strFS = """
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: version 330 core
  id: totrans-525
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: flat in vec3 vColor;
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: in vec3 vNormal;
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: in vec3 fragPos;
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: out vec4 fragColor;
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: void main() {
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: vec3 lightPos = vec3(10.0, 10.0, 10.0);
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: vec3 lightColor = vec3(1.0, 1.0, 1.0);
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: vec3 lightDir = normalize(lightPos - fragPos);
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: float diff = max(dot(vNormal, lightDir), 0.0);
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: vec3 diffuse = diff * lightColor;
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: float ambient = 0.1;
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: vec3 result = (ambient + diffuse) * vColor.xyz;
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: fragColor = vec4(result, 1.0);
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: 'class Torus:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '""" OpenGL 3D scene class"""'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '# initialization'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, R, r, NX, NY):'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: global strVS, strFS
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '# create shader'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: self.program = glutils.loadShaders(strVS, strFS)
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: glProvokingVertex(GL_FIRST_VERTEX_CONVENTION)
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: self.pMatrixUniform = glGetUniformLocation(self.program,
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: b'uPMatrix')
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: self.mvMatrixUniform = glGetUniformLocation(self.program,
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: b'uMVMatrix')
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '# torus geometry'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: self.R = R
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: self.r = r
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '# grid size'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: self.NX = NX
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: self.NY = NY
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '# no. of points'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: self.N = self.NX
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: self.M = self.NY
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '# time'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: self.t = 0
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '# compute parameters for glMultiDrawArrays'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: M1 = 2*self.M + 2
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: self.first_indices = [2*M1*i for i in range(self.N)]
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: self.counts = [2*M1 for i in range(self.N)]
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '# colors: {(i, j) : (r, g, b)}'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '# with NX * NY entries'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: self.colors_dict = self.init_colors(self.NX, self.NY)
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '# create an empty array to hold colors'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: self.colors = np.zeros((3*self.N*(2*self.M + 2), ), np.float32)
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '# get vertices, normals, indices'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: vertices, normals = self.compute_vertices()
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: self.compute_colors()
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: '# set up vertex buffer objects'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: self.setup_vao(vertices, normals, self.colors)
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: 'def init_colors(self, NX, NY):'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '"""initialize color dictionary"""'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: colors = {}
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: c1 = [1.0, 1.0, 1.0]
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(NX):'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range (NY):'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: colors[(i, j)] = c1
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: return colors
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: 'def compute_rt(self, R, alpha):'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '# compute position of ring'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: Tx = R*math.cos(alpha)
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: Ty = R*math.sin(alpha)
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: Tz = 0.0
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '# rotation matrix'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: RM = np.array([
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: '[math.cos(alpha), -math.sin(alpha), 0.0, 0.0],'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '[math.sin(alpha), math.cos(alpha), 0.0, 0.0],'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '[0.0, 0.0, 1.0, 0.0],'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '[0.0, 0.0, 0.0, 1.0]'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: '], dtype=np.float32)'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '# translation matrix'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: TM = np.array([
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '[1.0, 0.0, 0.0, Tx],'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '[0.0, 1.0, 0.0, Ty],'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '[0.0, 0.0, 1.0, Tz],'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: '[0.0, 0.0, 0.0, 1.0]'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '], dtype=np.float32)'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: return (RM, TM)
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: 'def compute_pt(self, r, theta, RM, TM):'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '# compute point coords'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: P = np.array([r*math.cos(theta), 0.0, r*math.sin(theta), 1.0],
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: dtype=np.float32)
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '# print(P)'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '# apply rotation - this also gives us the vertex normals'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: NV = np.dot(RM, P)
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '# normalize'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: '# NV = NV / np.linalg.norm(NV)'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: '# apply translation'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: Pt = np.dot(TM, NV)
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: return (Pt, NV)
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: 'def compute_vertices(self):'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: '"""compute vertices for the torus'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: 'returns np float32 array of n coords (x, y, z): shape (3*n, )'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: R, r, N, M = self.R, self.r, self.N, self.M
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: '# create an empty array to hold vertices/normals'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: vertices = []
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: normals = []
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: '# the points on the ring are generated on the X-Z plane'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: '# then they are rotated and translated into the correct'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: '# position on the torus'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: '# for all N rings around the torus'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(N):'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '# for all M points around a ring'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(M+1):'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '# compute angle theta of point'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: theta = (j % M) *2*math.pi/M
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: '#---ring #1------'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '# compute angle'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: alpha1 = i*2*math.pi/N
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: '# compute transforms'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: RM1, TM1 = self.compute_rt(R, alpha1)
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: '# compute points'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: Pt1, NV1 = self.compute_pt(r, theta, RM1, TM1)
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: '#---ring #2------'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: '# index of next ring'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: ip1 = (i + 1) % N
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '# compute angle'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: alpha2 = ip1*2*math.pi/N
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: '# compute transforms'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: RM2, TM2 = self.compute_rt(R, alpha2)
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: '# compute points'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: Pt2, NV2 = self.compute_pt(r, theta, RM2, TM2)
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: '# store vertices/normals in right order for GL_TRIANGLE_STRIP'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: vertices.append(Pt1[0:3])
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: vertices.append(Pt2[0:3])
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: '# add normals'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: normals.append(NV1[0:3])
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: normals.append(NV2[0:3])
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '# return vertices and colors in correct format'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: vertices = np.array(vertices, np.float32).reshape(-1)
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: normals = np.array(normals, np.float32).reshape(-1)
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '# print(vertices.shape)'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: return vertices, normals
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: 'def compute_colors(self):'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '"""compute vertices for the torus'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: 'returns np float32 array of n coords (x, y, z): shape (3*n, )'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: R, r, N, M = self.R, self.r, self.N, self.M
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: '# the points on the ring are generated on the X-Z plane'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '# then they are rotated and translated into the correct'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: '# position on the torus'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: '# for all N rings around the torus'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(N):'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '# for all M points around a ring'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(M+1):'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '# j value'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: jj = j % M
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: '# store colors - same color applies to (V_i_j, V_ip1_j)'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: col = self.colors_dict[(i, jj)]
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '# get index into array'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: index = 3*(2*i*(M+1) + 2*j)
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '# set color'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: self.colors[index:index+3] = col
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: self.colors[index+3:index+6] = col
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: 'def setup_vao(self, vertices, normals, colors):'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: '# set up vertex array object (VAO)'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: self.vao = glGenVertexArrays(1)
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(self.vao)
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: '# --------'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: '# vertices'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '# --------'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: self.vertexBuffer = glGenBuffers(1)
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '# set buffer data'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: glBufferData(GL_ARRAY_BUFFER, 4*len(vertices), vertices,
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: GL_STATIC_DRAW)
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '# enable vertex attribute array'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: glEnableVertexAttribArray(0)
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: '# set buffer data pointer'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, None)
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: '# normals'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: '# --------'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: self.normalBuffer = glGenBuffers(1)
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: glBindBuffer(GL_ARRAY_BUFFER, self.normalBuffer)
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: '# set buffer data'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: glBufferData(GL_ARRAY_BUFFER, 4*len(normals), normals,
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: GL_STATIC_DRAW)
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: '# enable vertex attribute array'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: glEnableVertexAttribArray(2)
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: '# set buffer data pointer'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, None)
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: '# --------'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: '# colors'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: '# --------'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: self.colorBuffer = glGenBuffers(1)
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: '# set buffer data'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: glBufferData(GL_ARRAY_BUFFER, 4*len(colors), colors,
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: GL_STATIC_DRAW)
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '# enable color attribute array'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: glEnableVertexAttribArray(1)
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: '# set buffer data pointer'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, None)
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: '# unbind VAO'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(0)
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: 'def set_colors(self, colors):'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: self.colors_dict = colors
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: self.recalc_colors()
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: 'def recalc_colors(self):'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: '# get colors'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: self.compute_colors()
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: '# bind VAO'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(self.vao)
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: '# --------'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: '# colors'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: '# --------'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: glBindBuffer(GL_ARRAY_BUFFER, self.colorBuffer)
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: '# set buffer data'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: glBufferSubData(GL_ARRAY_BUFFER, 0, 4*len(self.colors), self.colors)
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: '# unbind VAO'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(0)
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: '# step'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: 'def step(self):'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: '# recompute colors'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: self.recalc_colors()
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: '# render'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: 'def render(self, pMatrix, mvMatrix):'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: '# use shader'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: glUseProgram(self.program)
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: '# set proj matrix'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: glUniformMatrix4fv(self.pMatrixUniform, 1, GL_FALSE, pMatrix)
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: '# set modelview matrix'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: glUniformMatrix4fv(self.mvMatrixUniform, 1, GL_FALSE, mvMatrix)
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: '# bind VAO'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(self.vao)
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: '# draw'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: glMultiDrawArrays(GL_TRIANGLE_STRIP, self.first_indices,
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: self.counts, self.N)
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: '# unbind VAO'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: glBindVertexArray(0)
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: '[The Complete Game of Life Simulation Code](nsp-venkitachalam503045-0008.xhtml#rah1208)'
  id: totrans-759
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s the full code listing for the file *gol.py*.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: gol.py
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: Implements Conway's Game of Life.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: 'class GOL:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: '"""GOL - class that implements Conway''s Game of Life'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, NX, NY, glider):'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: '"""GOL constructor"""'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: '# a grid of NX x NY random values'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: self.NX, self.NY = NX, NY
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: 'if glider:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: self.addGlider(1, 1, NX, NY)
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: self.grid = np.random.choice([1, 0], NX * NY, p=[0.2, 0.8]).reshape(NX, NY)
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: 'def addGlider(self, i, j, NX, NY):'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: '"""adds a glider with top left cell at (i, j)"""'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: self.grid = np.zeros(NX * NY).reshape(NX, NY)
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: glider = np.array([[0,    0, 1],
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: '[1,  0, 1],'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: '[0,  1, 1]])'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: self.grid[i:i+3, j:j+3] = glider
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: 'def update(self):'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: '"""update the GOL simulation by one time step"""'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: '# copy grid since we require 8 neighbors for calculation'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: '# and we go line by line'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: newGrid = self.grid.copy()
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: NX, NY = self.NX, self.NY
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(NX):'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(NY):'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: '# compute 8-neighbor sum'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: '# using toroidal boundary conditions - x and y wrap around'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: '# so that the simulation takes place on a toroidal surface'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: total = (self.grid[i, (j-1) % NY] + self.grid[i, (j+1) % NY] +
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: self.grid[(i-1) % NX, j] + self.grid[(i+1) % NX, j] +
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: self.grid[(i-1) % NX, (j-1) % NY] + self.grid[(i-1) % NX, (j+1) % NY] +
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: self.grid[(i+1) % NX, (j-1) % NY] + self.grid[(i+1) % NX, (j+1) % NY])
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: '# apply Conway''s rules'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.grid[i, j]  == 1:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: 'if (total < 2) or (total > 3):'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: newGrid[i, j] = 0
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: 'if total == 3:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
- en: newGrid[i, j] = 1
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: '# update data'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: self.grid[:] = newGrid[:]
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: 'def get_colors(self):'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: '"""returns a dictionary of colors"""'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: colors = {}
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: c1 = np.array([1.0, 1.0, 1.0], np.float32)
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: c2 = np.array([0.0, 0.0, 0.0], np.float32)
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(self.NX):'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range (self.NY):'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.grid[i, j] == 1:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: colors[(i, j)] = c2
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
- en: 'else :'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: colors[(i, j)] = c1
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: return colors
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: '[The Complete Camera Code](nsp-venkitachalam503045-0008.xhtml#rah1209)'
  id: totrans-821
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s the complete code in the file *camera.py*:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: camera.py
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: A simple camera class for OpenGL rendering.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: import math
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: 'class OrbitCamera:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: '"""helper class for viewing"""'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, height, radius, beta_step=1):'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: self.radius = radius
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: self.beta = 0
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: self.beta_step = beta_step
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: self.height = height
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: '# initial eye vector is (-R, 0, -H)'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
- en: rr = radius/math.sqrt(2.0)
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: self.eye = np.array([rr, rr, height], np.float32)
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
- en: '# compute up vector'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: self.up = self.__compute_up_vector(self.eye )
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: '# center is origin'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: self.center = np.array([0, 0, 0], np.float32)
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: 'def __compute_up_vector(self, E):'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
- en: '"""compute up vector'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: N = (E x k) x E
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: '# N = (E x k) x E'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: Z = np.array([0, 0, 1], np.float32)
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: U = np.cross(np.cross(E, Z), E)
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: '# normalize'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: U = U / np.linalg.norm(U)
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: return U
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: 'def rotate(self):'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: '"""rotate by one step and compute new camera parameters"""'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: self.beta = (self.beta + self.beta_step) % 360
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
- en: '# recalculate eye E'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: self.eye = np.array([self.radius*math.cos(math.radians(self.beta)),
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: self.radius*math.sin(math.radians(self.beta)),
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: self.height], np.float32)
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: '# up vector'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
- en: self.up = self.__compute_up_vector(self.eye)
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: '[The Complete RenderWindow Code](nsp-venkitachalam503045-0008.xhtml#rah1210)'
  id: totrans-863
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The complete code listing for *gol_torus.py*, including the `RenderWindow` class
    and the `main()` function, follows.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: gol_torus.py
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: Python OpenGL program that displays a torus.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: 'Author: Mahesh Venkitachalam'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: import OpenGL
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: from OpenGL.GL import *
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: import numpy, math, sys, os
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: import argparse
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: import glutils
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: import glfw
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: from torus import Torus
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: from camera import OrbitCamera
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: from gol import GOL
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: 'class RenderWindow:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: '"""GLFW Rendering window class"""'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, glider):'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: '# save current working directory'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
- en: cwd = os.getcwd()
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: '# initialize glfw - this changes cwd'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwInit()
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: '# restore cwd'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: os.chdir(cwd)
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: '# version hints'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MAJOR, 3)
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MINOR, 3)
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwWindowHint(glfw.GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE)
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwWindowHint(glfw.GLFW_OPENGL_PROFILE, glfw.GLFW_OPENGL_CORE_PROFILE)
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: '# make a window'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: self.width, self.height = 640, 480
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
- en: self.aspect = self.width/float(self.height)
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: self.win = glfw.glfwCreateWindow(self.width, self.height, b'gol_torus')
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
- en: '# make context current'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwMakeContextCurrent(self.win)
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
- en: '# initialize GL'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: glViewport(0, 0, self.width, self.height)
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: glEnable(GL_DEPTH_TEST)
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: '#glClearColor(0.2, 0.2, 0.2, 1.0)'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: glClearColor(0.11764706, 0.11764706, 0.11764706, 1.0)
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: '# set window callbacks'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwSetMouseButtonCallback(self.win, self.onMouseButton)
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwSetKeyCallback(self.win, self.onKeyboard)
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: '# create 3D'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: NX = 64
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
- en: NY = 64
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: R = 4.0
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: r = 1.0
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: self.torus = Torus(R, r, NX, NY)
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: self.gol = GOL(NX, NY, glider)
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: '# create a camera'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: self.camera = OrbitCamera(5.0, 10.0)
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: '# exit flag'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: self.exitNow = False
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: '# rotation flag'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: self.rotate = True
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
- en: '# skip count'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: self.skip = 0
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
- en: 'def onMouseButton(self, win, button, action, mods):'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: '# print ''mouse button: '', win, button, action, mods'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: pass
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: 'def onKeyboard(self, win, key, scancode, action, mods):'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: '# print ''keyboard: '', win, key, scancode, action, mods'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
- en: 'if action == glfw.GLFW_PRESS:'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: '# ESC to quit'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: 'if key == glfw.GLFW_KEY_ESCAPE:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: self.exitNow = True
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: 'elif key == glfw.GLFW_KEY_R:'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: self.rotate = not self.rotate
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: 'def run(self):'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: '# initializer timer'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwSetTime(0)
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
- en: t = 0.0
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: 'while not glfw.glfwWindowShouldClose(self.win) and not self.exitNow:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: '# update every x seconds'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: currT = glfw.glfwGetTime()
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: 'if currT - t > 0.05:'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
- en: '# update time'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: t = currT
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
- en: '# set viewport'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: self.width, self.height = glfw.glfwGetFramebufferSize(self.win)
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: self.aspect = self.width/float(self.height)
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
- en: glViewport(0, 0, self.width, self.height)
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: '# clear'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: '# build projection matrix'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: pMatrix = glutils.perspective(60.0, self.aspect, 0.1, 100.0)
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: mvMatrix = glutils.lookAt(self.camera.eye, self.camera.center, self.camera.up)
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: '# render'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: self.torus.render(pMatrix, mvMatrix)
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: '# step'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.rotate:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: self.step()
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwSwapBuffers(self.win)
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: '# poll for and process events'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwPollEvents()
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: '# end'
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwTerminate()
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
- en: 'def step(self):'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.skip == 9:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: '# update GOL'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: self.gol.update()
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: colors = self.gol.get_colors()
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: self.torus.set_colors(colors)
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: '# step'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: self.torus.step()
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: '# reset'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: self.skip = 0
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
- en: '# update skip'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: self.skip += 1
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: '# rotate camera'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: self.camera.rotate()
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: main() function
  id: totrans-976
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def main():'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: print("Starting GOL. Press ESC to quit.")
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
- en: '# parse arguments'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: parser = argparse.ArgumentParser(description="Runs Conway's Game of Life simulation
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: on a Torus.")
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: '# add arguments'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: parser.add_argument('--glider', action='store_true', required=False)
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: args = parser.parse_args()
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: '# set args'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
- en: glider = False
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: 'if args.glider:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: glider = True
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: rw = RenderWindow(glider)
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: rw.run()
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: call main
  id: totrans-991
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
- en: main()
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
