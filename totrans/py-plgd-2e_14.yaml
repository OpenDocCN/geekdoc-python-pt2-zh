- en: '[10](nsp-venkitachalam503045-0008.xhtml#rch10)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conway’s Game of Life on a Torus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-circle-image.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03), we implemented Conway’s
    Game of Life using Python and the `matplotlib` library. You may recall one interesting
    aspect of that project: it used toroidal boundary conditions. [Figure 3-2](nsp-venkitachalam503045-0015.xhtml#fig3-2)
    on [page 48](nsp-venkitachalam503045-0015.xhtml#p48) showed how we were effectively
    treating the flat, 2D grid of the simulation as a 3D toroidal surface, thanks
    to how the boundary conditions stitched the edges together. In the [previous chapter](nsp-venkitachalam503045-0023.xhtml#ch09),
    you were introduced to OpenGL and learned how to render 3D objects. Let’s now
    put together your experience with the Game of Life and OpenGL to re-create the
    Conway’s simulation in 3D, on an actual torus.'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll start by computing the 3D geometry of a torus. Then
    you’ll arrange the vertices of the torus in a way that’s easy to draw and color
    in OpenGL. You’ll set up a revolving camera to view the torus from all sides and
    also implement some basic lighting in the shaders. Finally, you’ll adapt the Game
    of Life code from [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03) to color
    the grid on the torus. As the simulation proceeds, you’ll see the Game of Life
    come alive on the surface of the torus!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the main topics covered in this project:'
  prefs: []
  type: TYPE_NORMAL
- en: • Using matrix math to construct the 3D geometry of a torus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Implementing a coloring scheme for the Game of Life grid on the torus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Implementing a revolving camera in OpenGL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: • Implementing simple lighting in OpenGL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How It Works](nsp-venkitachalam503045-0008.xhtml#rah1201)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before getting into the code, let’s consider how you can render, light, and
    view a 3D torus using OpenGL. It all begins with computing the vertices that make
    up the torus.
  prefs: []
  type: TYPE_NORMAL
- en: '[Computing Vertices](nsp-venkitachalam503045-0008.xhtml#rbh1201)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A torus is essentially a collection of circles, or rings, arranged in a circle
    around a central point. However, you can’t actually draw circles with OpenGL;
    they need to be *discretized*, or represented as a series of vertices connected
    by straight lines. The simplified model in [Figure 10-1](nsp-venkitachalam503045-0024.xhtml#fig10-1)
    illustrates how you can begin defining the torus as a collection of vertices.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f10001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-1: A torus rendering model. The simplified torus is on the left.
    An individual “ring” that makes up the torus is on the right.'
  prefs: []
  type: TYPE_NORMAL
- en: The right side of [Figure 10-1](nsp-venkitachalam503045-0024.xhtml#fig10-1)
    shows a ring with radius *r* discretized to have *M* = 5 points. The left side
    of [Figure 10-1](nsp-venkitachalam503045-0024.xhtml#fig10-1) models a simple torus
    with major radius *R* by arranging *N* = 6 such discretized rings (labeled 0 through 5)
    around a central point. (The *major radius* is the distance from the center of
    the torus’s hole to the center of its outer ring.) Don’t worry about the blocky
    nature of the torus shown in the figure. It gets smoother as you increase the
    values of *N* and *M*.
  prefs: []
  type: TYPE_NORMAL
- en: The torus is filled out by drawing bands to connect adjacent rings. You’ll draw
    the bands using `GL_TRIANGLE_STRIP` primitives, and each cell in the Game of Life
    simulation will consist of two adjacent triangles on a strip, which together form
    a *quad*, or quadrilateral. When a cell is ON you’ll color its quad black, and
    when a cell is OFF you’ll color it white.
  prefs: []
  type: TYPE_NORMAL
- en: To compute the vertices of the torus, you first need to define a coordinate
    system for it. Let’s assume that the torus is on the XY plane, centered at the
    origin, with the line through the center of the torus aligned along the z-axis,
    as shown in [Figure 10-2](nsp-venkitachalam503045-0024.xhtml#fig10-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f10002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-2: The rendering strategy for the torus'
  prefs: []
  type: TYPE_NORMAL
- en: 'The vertices for a circle *C*[3] on the torus at an angle θ relative to the
    x-axis can be computed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Compute the vertices for a circle *C*[1] of radius *r* in the XZ plane and
    with the center at the origin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. Rotate the circle *C*[1] around the z-axis by the angle θ. This gives you
    the circle *C*[2].
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 3\. Translate the circle *C*[2] by *R* amount along the angle θ to get the circle
    *C*[3] in the correct position on the torus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You may recall the use of parametric equations to define a circle in the spirograph
    project in [Chapter 2](nsp-venkitachalam503045-0013.xhtml#ch02). We’re going to
    use the same concept here. The vertices marking the circumference of a circle
    *C*[1] of radius *r* on the XZ plane centered at the origin are given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '*P* = (*r* cos(α), 0, *r* sin(α))'
  prefs: []
  type: TYPE_NORMAL
- en: Here, α is the angle made by the point *P* with respect to the x-axis. As α
    varies from 0 to 360 degrees (or 2π radians), a circle will be formed by the *P* points.
    Notice that the y-coordinates of the points are zero in the previous equation.
    This is expected, since the circle is on the XZ plane.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must now rotate the points around the z-axis by angle θ. The rotation matrix
    for this operation is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-m10001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you rotate the points, you need to translate them to the right place. This
    is done using the following translation matrix. (This format was discussed in
    [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09).)
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-m10002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Thus, the transformed points on a ring on the torus are given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '*P*ʹ = *T* × *R* [θ,Z] × *P*'
  prefs: []
  type: TYPE_NORMAL
- en: 'which is the same as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-m10003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous equation, *P* is first multiplied by the rotation matrix, which
    aligns it correctly, and is then multiplied by the translation matrix, which “pushes”
    the points to the right place on the torus. Notice that *P* is represented with
    *homogeneous* coordinates (*x*, *y*, *z*, 1.0), discussed in the [previous chapter](nsp-venkitachalam503045-0023.xhtml#ch09).
  prefs: []
  type: TYPE_NORMAL
- en: '[Computing Normals for Lighting](nsp-venkitachalam503045-0008.xhtml#rbh1202)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the torus to look nice, you’ll need to apply lighting to the geometry, which
    in turn means you’ll need to compute the *normal vectors* for the points *P* calculated
    in the previous section. The lighting on a surface depends on the orientation
    of the surface to the incoming light, and the orientation can be quantified by
    the normal vector, which is the vector perpendicular to the surface at a particular
    point. Take a look at [Figure 10-3](nsp-venkitachalam503045-0024.xhtml#fig10-3)
    to see an example.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f10003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-3: Computing normal vectors'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of the geometry of the torus, the normal vector for point *s* on a
    ring is in the same direction as the line connecting point *s* to the center of
    the ring. This means that the normal vectors are the same as rotated points. The
    translation doesn’t matter, as the direction of the normals is unaffected by it.
    You can therefore compute the normals as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*N* = *R*[θ,Z] × *P*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that you need to *normalize* the normal vectors before doing any lighting
    computations. You do this by dividing the normal by its magnitude.
  prefs: []
  type: TYPE_NORMAL
- en: The actual lighting will come from a single light source at a fixed position.
    This will be defined in the vertex shader.
  prefs: []
  type: TYPE_NORMAL
- en: '[Rendering](nsp-venkitachalam503045-0008.xhtml#rbh1203)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you have the vertices and normals for the torus, let’s talk about how
    to render it using OpenGL. You first need to split it up into bands, as shown
    in [Figure 10-4](nsp-venkitachalam503045-0024.xhtml#fig10-4). Each band is the
    region between two adjacent rings on the torus.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f10004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-4: Rendering the torus with triangle strips'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the bands is rendered using OpenGL as a `GL_TRIANGLE_STRIP` primitive.
    Besides forming the building blocks of the torus, these triangle strips also provide
    a convenient way to create the Game of Life simulation grid: each cell in the
    grid is represented by a quad formed from two adjacent triangles in the strip.
    [Figure 10-5](nsp-venkitachalam503045-0024.xhtml#fig10-5) gives a closer look
    at one band in the torus.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f10005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-5: Rendering a band from triangle strips'
  prefs: []
  type: TYPE_NORMAL
- en: 'The band is formed by the adjacent rings *C*⁰ and *C*¹. Each ring has *M* vertices.
    The triangle strip making up the band is formed as *M* pairs of vertices that
    zigzag back and forth between the rings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-m10004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'But there’s one additional pair of vertices you need to add: ![](images/nsp-venkitachalam503045-m10005.jpg).
    You need to repeat the first two vertices to close out the gap at the end of the
    band. Hence, the total number of vertices in the triangle strip that forms the
    band is given by 2 × *M* + 2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The band shown in [Figure 10-5](nsp-venkitachalam503045-0024.xhtml#fig10-5)
    was composed of rings ![](images/nsp-venkitachalam503045-m10006.jpg). The torus
    is divided into *N* bands, where *N* is the number of rings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-m10007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice how the last band wraps around by coming back to the first ring, *C*⁰.
    This means the total number of vertices needed to render the torus is given by
    *N* × (2 × *M* + 2). You’ll see more details of the implementation as you look
    at the code.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s take a look at the coloring scheme for the torus.
  prefs: []
  type: TYPE_NORMAL
- en: '[Coloring the Triangle Strips](nsp-venkitachalam503045-0008.xhtml#rbh1204)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You need to color the cells in the Game of Life simulation individually. You
    know that each cell is a quad—two triangles that are part of a larger triangle
    strip. As an example, the quad made of vertices ![](images/nsp-venkitachalam503045-m10008.jpg)
    is composed of two triangles: ![](images/nsp-venkitachalam503045-m10009.jpg) and
    ![](images/nsp-venkitachalam503045-m10010.jpg). Each vertex has a corresponding
    color associated with it, which is a triplet of the form (*r*, *g*, *b*), denoting
    the red, green, and blue components of the color. By default, the color of the
    first vertex in the quad (in this case, ![](images/nsp-venkitachalam503045-m10011.jpg))
    sets the value for the first triangle in the quad, and the color of the second
    vertex (![](images/nsp-venkitachalam503045-m10012.jpg)) sets the value for the
    second triangle in the quad. As long as you set these two colors to be identical,
    you’ll color the quad uniformly. We’ll discuss OpenGL’s vertex color convention
    further when we look at the code.'
  prefs: []
  type: TYPE_NORMAL
- en: NOTE The OpenGL function called `glProvokingVertex()` changes the convention
    of which color value is mapped to the vertex.
  prefs: []
  type: TYPE_NORMAL
- en: '[Controlling the Camera](nsp-venkitachalam503045-0008.xhtml#rbh1205)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To view the torus, you’ll create a camera that revolves around the origin of
    the 3D scene and looks down at an angle from above. [Figure 10-6](nsp-venkitachalam503045-0024.xhtml#fig10-6)
    shows the camera setup.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f10006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-6: Implementing a revolving camera'
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of the camera, represented by point *E*, as being placed on a cylinder
    of radius *R* at a height *H* from the origin. The camera points toward the origin
    *O*. The camera is defined by the mutually perpendicular vectors *V*, *U*, and
    *N*, where *V* is the *view vector* that points from *E* to *O*; *U* is the *up
    vector*, which is up relative to the camera; and *N* is a vector perpendicular
    to both *V* and *U*. For every time step, you move the camera by a constant distance
    along the rim of the cylinder. This movement is parameterized by the angle β,
    as shown in [Figure 10-6](nsp-venkitachalam503045-0024.xhtml#fig10-6). As you
    learned in [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09), you use a `lookAt()`
    method to set up the view, which takes three parameters: the eye, the center,
    and the up vector. The center is just the origin: (0, 0, 0). The 3D coordinates
    of the eye are given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '*E* = (*R* cos(β), *R* sin(β), *H*)'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the camera moves along the rim of the cylinder, it will keep its direction
    pointed to *O*, and the up vector *U* will keep changing as well. To compute the
    up vector *U*, start with an initial guess *U*ʹ that’s parallel to the z-axis.
    Then find *N*, the vector perpendicular to the plane given by *U*ʹ and *V*. It
    can be calculated as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*N* = *V* × *U*ʹ'
  prefs: []
  type: TYPE_NORMAL
- en: '*N* is given by the cross product of *V* and *U*ʹ. Now, what happens if you
    take the cross product of *N* and *V*? You get a vector perpendicular to the NV
    plane, which is the up vector *U* that you’re looking for!'
  prefs: []
  type: TYPE_NORMAL
- en: '*U* = *N* × *V* = (*V* × *U*ʹ) × *V*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once *U* is calculated, make sure that it’s normalized before use. Once that’s
    done, you’ll have everything you need to set up the camera with `lookAt()`: *E*
    (the eye), *O* (the center), and *U* (the up vector).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Mapping the Grid to the Torus](nsp-venkitachalam503045-0008.xhtml#rbh1206)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, let’s look at how the 2D Game of Life simulation grid maps to the 3D
    torus because of the grid’s toroidal boundary conditions. [Figure 10-7](nsp-venkitachalam503045-0024.xhtml#fig10-7)
    shows the mapping.
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f10007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-7: Mapping the simulation grid to a torus'
  prefs: []
  type: TYPE_NORMAL
- en: 'The two-dimensional Game of Life grid has *NX* columns and *NY* rows. You can
    see on the right of the figure how the *NX* points that divide each row wrap around
    the tube of the torus. The point indices go from 0 to *NX* − 1\. The next index,
    *NX*, is the same as 0 because of the wrap. A similar wrap happens in the y-direction,
    where you have *NY* cells: the point with index *NY* is the same as the point
    with index 0.'
  prefs: []
  type: TYPE_NORMAL
- en: You saw earlier how each ring in the torus is discretized to have *M* points.
    To go from the two-dimensional grid to the torus, set *NX* = *M*. Similarly, set
    *NY* = *N*, where *N* is the number of bands on the torus.
  prefs: []
  type: TYPE_NORMAL
- en: '[Requirements](nsp-venkitachalam503045-0008.xhtml#rah1202)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll use `PyOpenGL` and GLFW for OpenGL rendering, as in [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09),
    and `numpy` for matrix/vector computations.
  prefs: []
  type: TYPE_NORMAL
- en: '[The Code](nsp-venkitachalam503045-0008.xhtml#rah1203)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code for this project is organized into several files:'
  prefs: []
  type: TYPE_NORMAL
- en: torus.py This contains the geometry computation and rendering code for the torus.
  prefs: []
  type: TYPE_NORMAL
- en: gol.py This implements Conway’s Game of Life, adapted from [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03).
  prefs: []
  type: TYPE_NORMAL
- en: camera.py This contains the implementation for the revolving camera for viewing
    the torus.
  prefs: []
  type: TYPE_NORMAL
- en: gol_torus.py This is the main file that sets up OpenGL and GLFW and calls the
    rendering code from other modules.
  prefs: []
  type: TYPE_NORMAL
- en: The full project code is available online at [https://github.com/mkvenkit/pp2e/blob/main/gol_torus](https://github.com/mkvenkit/pp2e/blob/main/gol_torus).
  prefs: []
  type: TYPE_NORMAL
- en: '[Rendering the Torus](nsp-venkitachalam503045-0008.xhtml#rbh1207)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ll first consider the code for rendering the torus, which is encapsulated
    in a class called `Torus` defined in the file *torus.py*. To see the complete
    code listing, skip ahead to [“The Complete Torus Rendering Code”](nsp-venkitachalam503045-0024.xhtml#ah1207)
    on [page 203](nsp-venkitachalam503045-0024.xhtml#p203).
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Shaders
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, define the GLSL shaders for the torus. Here’s the vertex shader, which
    takes the per-vertex attributes of position, color, and normal and computes the
    transformed inputs for the fragment shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You define the vertex shader code as a string stored in `strVS`. The attribute
    variables for the shader are `aVert`, `aColor`, and `aNormal`, representing the
    coordinates, color, and normal vector for each vertex. Notice the `flat` qualifier
    when you initialize `vColor`, one of the outputs of the vertex shader ❶, indicating
    that this variable won’t be interpolated in the fragment shader. In effect, we’re
    saying that this variable will remain constant across the primitive (one of the
    triangles in a triangle strip). This ensures that every Game of Life cell will
    be a single color. This type of shading across a primitive is called *flat shading*.
    The next vertex shader output is `vNormal` ❷, which by default will be interpolated
    in the fragment shader. You need this so you can compute lighting across a primitive,
    but later you’ll see how to modify this shader code to support flat shading. The
    other output is called `fragPos` ❸. In the main shader code, you set this output
    to `aVert` ❹ so it can be passed into the fragment shader for lighting calculations.
    The shader also computes `gl_Position` and passes to the fragment shader the color
    and normal data as it is received.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s the fragment shader, which applies lighting and computes the final color
    of the fragment. It’s defined as another string, called `strFS`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the color, normal, and fragment position variables, which were outputs
    from the vertex shader, are now inputs to the fragment shader. In the main shader
    code, you define the position ❶ and color ❷ for a light source. Then you compute
    the light direction ❸. The resulting color ❹ is a mix of ambient and diffuse components
    of the light and is set as the output from the fragment shader.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that `fragPos` and `vNormal` are computed for each fragment via
    interpolation, whereas `vColor` is constant for a given primitive. The net effect
    is that the intrinsic color of a primitive (a triangle strip, in this case) remains
    constant, while the perceived color varies across the primitive based on its orientation
    with respect to the light source. This is exactly what you need to set each Game
    of Life cell to a solid color, while varying that color to create the appearance
    of lighting.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the Torus Class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s look at the initialization code in the `Torus` class constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Torus` class has the following parameters in its constructor ❶: the radius
    `R` of the outer ring of the torus, the radius `r` of the torus tube, and `NX`
    and `NY` for the number of Game of Life simulation cells in the x- and y-directions.
    The constructor’s first order of business is to load the shaders. You use the
    `loadShaders()` method ❷ defined in the common *glutils.py* file. In the subsequent
    lines, you store the variables passed into the `Torus` constructor in instance
    variables such as `self.R` so they can be accessed later from other methods. Then
    you set `N`, the number of points on the outer circle of the torus, to be `NX`,
    the number of cells in the x-direction ❸. You similarly set `M`, the number of
    points along the smaller radius `r` of the torus, to `NY`. This scheme is discussed
    in the [“Mapping the Grid to the Torus”](nsp-venkitachalam503045-0024.xhtml#bh1206)
    section.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you do some additional preparation for rendering the triangle strips that
    will form the bands along the outer ring of the torus. You’ll eventually be using
    the `glMultiDrawArrays()` OpenGL method to render all the triangle strips at once.
    This method is an efficient way to draw multiple triangle strip primitives using
    just one function call. As you saw in the [“Rendering”](nsp-venkitachalam503045-0024.xhtml#bh1203)
    section, each triangle strip has 2*M* + 2 vertices, and you have *N* of these
    strips. So, the starting indices for these triangle strips will be [0, (2*M* +
    2), (2*M* + 2) × 2, . . . , (2*M* + 2) × *N*]. Accordingly, you set `first_indices`
    and `counts` ❹, which will be required parameters when you call `glMultiDrawArrays()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `init_colors()` method ❺ initializes `color_dict`, which maps each grid
    cell to a color—black or white. We’ll look at the details of the `init_colors()`
    method soon. You initialize the `numpy` array `colors` to zeros ❻. You’ll later
    populate this array with the correct values. You conclude the constructor by computing
    the vertices and normals for the torus ❼, as well as the colors ❽, and by setting
    up the vertex array object (VAO) for rendering the torus ❾.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at the `Torus` class’s `init_colors()` method that was just
    mentioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `init_colors()` method creates a dictionary called `colors` mapping from
    simulation cell index (*i*, *j*) to the color that should be applied to the cell.
    To begin, you simply set all the cell color values to `c1`, which is just plain
    white ❶. As the Game of Life simulation unfolds, the values in this dictionary
    will be updated to turn cells on and off.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the Vertices
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The next few methods we’ll consider work together to compute all the torus
    vertices. We begin with the `compute_vertices()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `compute_vertices()` method begins by creating empty lists to store the
    vertices and normals. Then you compute the vertices and normals for the torus,
    using a nested loop to implement the strategy we discussed in the [“Rendering”](nsp-venkitachalam503045-0024.xhtml#bh1203)
    section. The outer loop iterates over the `N` rings that make up the torus. The
    inner loop iterates over the `M` points on each of those rings. Within the loops,
    you first compute the angle `theta` subtended by a point on the ring with index
    `j` ❶. You use `j % M` and have the inner loop iterate over range `[0, M+1)` so
    that when *j* is equal to `M`, `(j % M)` rolls back to `0`. This is to complete
    the last segment of the ring.
  prefs: []
  type: TYPE_NORMAL
- en: The torus is rendered as a set of bands (triangle strips), and each band consists
    of two adjacent rings of points. You compute `alpha1`, the angle subtended by
    the first ring in a band, at index `i` ❷, and use `alpha1` to compute the rotation
    and translation matrices for this first ring using the `compute_rt()` method ❸.
    Then you pass these matrices to the `compute_pt()` method to calculate the vertex
    and normal for the point on the ring at angle `theta` ❹. We’ll look at how the
    `compute_rt()` and `compute_pt()` methods work soon.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you move on to the adjacent ring at index `i+1`, using `ip1 = (i+1) %
    N` to ensure that you roll back to zero at the end ❺. You compute the angle `alpha2`
    of the ring at index `ip1` ❻ and then compute the vertex and normal for the point
    on the `ip1` ring at angle `theta`, just as you did for the first ring.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning at ❼, you append the vertices and normals for the adjacent rings to
    the lists you created at the beginning of the method. You pick only the first
    three coordinates of each vertex and normal, as in `Pt1[0:3]`, since all the matrix
    transformations are done with homogeneous coordinates in the form (*x*, *y*, *z*,
    *w*), and you need only (*x*, *y*, *z*). This action stores the vertices and normals
    in a Python list of triplets of the form `[[x1, y1, z1], [x2, y2, z2], ...]`.
    However, OpenGL expects vertex attributes to be provided in a flat array with
    a known size. Therefore, you convert the `vertices` and `normals` lists into `numpy`
    arrays of 32-bit floats ❽, using `reshape(-1)` to ensure that they’re flat arrays
    of the form `[x1, y1, z1, x2, y2, z2, ...]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at the `compute_rt()` and `compute_pt()` methods that helped
    you compute the vertices and normals. We’ll start with `compute_rt()`, which calculates
    the rotation and translation matrices needed to render a given ring in the torus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You first calculate the translation components of the matrix ❶, using parametric
    equations. Then you create the rotation matrix ❷ and translation matrix ❸ as `numpy`
    arrays. You’ve seen these matrices before in the [“Computing Vertices”](nsp-venkitachalam503045-0024.xhtml#bh1201)
    section. You return the arrays at the end of the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the other helper method, `compute_pt()`, which uses the translation
    and rotation matrices to determine the vertex and normal vector of a given point
    on a ring of the torus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You compute the point `P` at angle `theta` on a ring lying on the XZ plane ❶.
    Then you apply a rotation to this point by multiplying it by the rotation matrix
    ❷. This also gives you the point’s normal vector. You multiply the normal by the
    translation matrix to give you the vertex on the torus ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Cell Colors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we’ll examine some methods that help set the colors of the cells on the
    torus. First is the `compute_colors()` method, which we originally called as part
    of the `Torus` class’s constructor. It sets the color of each triangle in the
    triangle strips that make up the torus, based on the values determined by the
    Game of Life simulation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This method follows the logic described in [“Coloring the Triangle Strips”](nsp-venkitachalam503045-0024.xhtml#bh1204)
    on [page 185](nsp-venkitachalam503045-0024.xhtml#p185) to update the values in
    the `colors` array, which was initialized as an array of all zeros. You retrieve
    the color for cell `(i, jj)` from `colors_dict`, the dictionary mapping cells
    to colors that you created earlier ❶. (You define `jj = j % M` so it rolls over
    to zero at the end.) Then you compute the index into the `colors` array at which
    you should update the new computed values ❷. Each pair of rings that makes up
    a band has `2*(M+1)` vertices, and there are `N` of these pairs. Starting at each
    location in the array, you store three sequential values (the RGB components of
    a cell’s color). Hence, the index of the *j*th color in a ring for the *i*th segment
    of the torus will be given by `3*(2*i*(M+1) + 2*j)`. Note that you use `j` and
    not `jj` in computing the index, since you’re storing the computed values here
    and you don’t want the index to roll over to zero. Now that you have the index,
    you update the `colors` array with the new computed values. You update the array
    both at `[index:index+3]` ❸ and at `[index+3:index+6]` ❹ since each cell on the
    torus is a quad, made of two adjacent triangles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now look at `recalc_colors()`, a method for updating the color values
    stored on the GPU at each step in the Game of Life simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For every step of the simulation, the colors of the cells are updated, which
    means you need to update the colors of all the triangle strips on the torus, and
    you need to do it efficiently so you don’t slow down the rendering. The `recalc_colors()`
    method does this using the OpenGL `glBufferSubData()` method ❶. The vertices,
    normals, and colors are stored in attribute arrays on the GPU. The vertices and
    normals don’t change, so you computed them only once in the beginning, with a
    call to `compute_vertices()` in the class’s constructor method. When the colors
    change, `glBufferSubData()` updates the color attribute arrays rather than creating
    them afresh.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the Torus
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Finally, here’s the `render()` method that draws the torus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This method is similar to the render methods you saw in the [previous chapter](nsp-venkitachalam503045-0023.xhtml#ch09).
    You make a call to use the shader program ❶ and set the projection ❷ and modelview
    ❸ matrix uniform variables. Then you bind to the vertex array object ❹, which
    you created by calling `setup_vao()` in the class’s constructor. The VAO has all
    the attribute array buffers you need. Next, you use the `glMultiDrawArrays()`
    method to draw `N` triangle strips ❺. You already computed `first_indices` and
    `counts` in the `Torus` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[Implementing the Game of Life Simulation](nsp-venkitachalam503045-0008.xhtml#rbh1208)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03), you implemented Conway’s
    Game of Life (GOL) by using `matplotlib` to visualize the updated values of the
    simulation grid. Here you’ll adapt the earlier implementation to update a dictionary
    of cell colors instead, which will be used to update the colors of the torus.
    The relevant code is encapsulated in a class called `GOL`, declared in the file
    *gol.py*. To see the complete code listing, skip ahead to [“The Complete Game
    of Life Simulation Code”](nsp-venkitachalam503045-0024.xhtml#ah1208) on [page
    209](nsp-venkitachalam503045-0024.xhtml#p209).
  prefs: []
  type: TYPE_NORMAL
- en: The Class Constructor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'First, let’s look at the `GOL` class constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `GOL` constructor takes as input the grid dimensions `NX` and `NY`, as well
    as a Boolean flag `glider` ❶. If this flag is set, you initialize the simulation
    grid with the “glider” pattern using the `addGlider()` method ❷. Since we already
    discussed this method in [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03),
    we won’t examine it here. If the `glider` flag isn’t set, you just initialize
    the grid to random ones and zeros ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The `GOL` class uses an `update()` method to update the simulation grid at each
    time step. Again, this is identical to the previous implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The get_colors() Method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `get_colors()` method is what distinguishes this chapter’s Game of Life
    implementation from that of [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03).
    The method builds up a dictionary mapping of each Game of Life cell to its color
    value at a given step in the simulation: black for ON or white for OFF. This dictionary
    is passed to the `Torus` object when the scene is updated.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here you iterate through all the cells in the simulation grid and set the RGB
    colors based on whether the grid value is `0` or `1`. The possible colors are
    defined as `c1` for white ❶ or `c2` for black ❷. These colors will be used while
    rendering the torus.
  prefs: []
  type: TYPE_NORMAL
- en: '[Creating the Camera](nsp-venkitachalam503045-0008.xhtml#rbh1209)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [“Controlling the Camera”](nsp-venkitachalam503045-0024.xhtml#bh1205) on
    [page 185](nsp-venkitachalam503045-0024.xhtml#p185), we discussed how to build
    a camera that orbits around the torus. Now let’s look at the implementation. The
    code is encapsulated in the class `OrbitCamera`, which is declared in the file
    *camera.py*. To see the complete code listing, skip ahead to [“The Complete Camera
    Code”](nsp-venkitachalam503045-0024.xhtml#ah1209) on [page 211](nsp-venkitachalam503045-0024.xhtml#p211).
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the Class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here’s the constructor for the `OrbitCamera` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You start by setting the camera parameters passed into the `OrbitCamera` constructor.
    These include the camera’s orbit radius ❶ and `beta`, the angle that the view
    vector (projected on the XY plane) makes with the x-axis ❷. You also set the amount
    `beta` should increment with each time step of the camera rotation ❸ and the height
    of the camera from the XY plane ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you set the initial value of the eye position to be midway between the
    positive x- and positive y-axis, at a distance `R` from the origin, suspended
    at the specified `height` ❺. You can calculate this as:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-m10013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, you compute the camera’s up vector ❻ and set the center as the origin
    (0, 0, 0) ❼. Remember that these are the pieces of information, along with the
    eye position, that OpenGL needs to model a camera.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the Up Vector
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here’s the method that you call in the `OrbitCamera` class constructor to compute
    the up vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `__compute_up_vector()` method calculates the up vector `U` based on the
    method we discussed earlier in [“Controlling the Camera”](nsp-venkitachalam503045-0024.xhtml#bh1205)
    on [page 185](nsp-venkitachalam503045-0024.xhtml#p185). Specifically, you use
    cross products and the initial up vector guess of (0, 0, 1) to compute the correct
    up vector ❶. Then you normalize the up vector ❷ before returning it.
  prefs: []
  type: TYPE_NORMAL
- en: Rotating the Camera
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `OrbitCamera` class’s `rotate()` method is called every time you need to
    rotate the camera around the torus by one step. Here’s the method’s definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You increase the angle `beta` by the increment `beta_step`, using the `%` operator
    to ensure that the angle rolls over to 0 when it reaches 360 degrees ❶. Then you
    use the new `beta` value to compute the updated eye position ❷, and you use the
    new eye position to compute the new up vector with the `__compute_up_vector()`
    method ❸.
  prefs: []
  type: TYPE_NORMAL
- en: '[Putting Everything Together](nsp-venkitachalam503045-0008.xhtml#rbh1210)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve built all the classes necessary for rendering the torus. Now you need
    some code to bring those classes together, create and manage the OpenGL window,
    and coordinate the rendered objects. Create the class `RenderWindow` (defined
    in *gol_torus.py*) for this purpose. It’s similar to the `RenderWindow` class
    used in [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09), so we’ll discuss
    only the parts of the code that are unique to the current project. To see the
    complete code listing, skip ahead to [“The Complete RenderWindow Code”](nsp-venkitachalam503045-0024.xhtml#ah1210)
    on [page 211](nsp-venkitachalam503045-0024.xhtml#p211).
  prefs: []
  type: TYPE_NORMAL
- en: The main() Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we examine the `RenderWindow` class, let’s look the program’s `main()`
    function, which sets the whole simulation in motion. This function is also defined
    in *gol_torus.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You add a command line argument called `--glider` so you can bring up the torus
    with just a glider pattern on it ❶ and set the corresponding flag ❷. Then you
    create a `RenderWindow` object ❸, which initializes all the other objects needed
    for the program, and start the rendering with a call to the `RenderWindow` object’s
    `run()` method ❹.
  prefs: []
  type: TYPE_NORMAL
- en: The RenderWindow Constructor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The constructor on the `RenderWindow` class starts with the standard GLFW OpenGL
    setup you saw in [Chapter 9](nsp-venkitachalam503045-0023.xhtml#ch09), including
    setting the window size, calling the render methods, and handling window and keyboard
    events. Then the constructor goes on with the following Game of Life–specific
    initializations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: First you set some parameters for the simulation, including the number of cells
    in the grid and the inner and outer radiuses of the torus. Then you create the
    `Torus` object using these parameters ❶, as well as the `GOL` object that will
    manage the simulation ❷. You also create the orbiting camera at a radius of 5
    units from the origin and a height of 10 units from the XY plane ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you set the exit flag used to quit the program ❹, and you initialize the
    rotation flag to `True` ❺. Finally, you set a `skip` variable ❻, which you’ll
    use to control the frequency at which the simulation updates. You’ll see how the
    `skip` variable works later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The run() and step() Methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `run()` method of the `RenderWindow` object is responsible for running
    the simulation, with help from the `step()` method. Let’s take a look at the `run()`
    method first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The rendering scheme is designed to keep rendering frames in a loop until the
    window is closed or the ESC key is pressed ❶. Before you proceed, you check whether
    the time elapsed since the last render is greater than 0.05 seconds ❷. This helps
    maintain a maximum frame rate. Starting at ❸, you perform some standard OpenGL
    operations, such as setting the viewport, clearing the screen, and computing the
    current transformation that needs to be set into the vertex shader. Then you render
    the torus ❹ and call the `step()` method ❺, which will rotate the camera and update
    the Game of Life simulation by one time step. Once the rendering is done, you
    swap the OpenGL buffers and poll for further window events. If you exit the loop,
    you call the `glfwTerminate()` method for cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the `step()` method that increments the camera and the simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Every time this method is called, it rotates the camera by one step ❽. You also
    want to update the Game of Life simulation, but doing so at the same rate that
    the camera moves would not be visually pleasing. You therefore use the `skip`
    variable to slow down the simulation by a factor of 9 relative to the camera motion.
    This variable starts from `0` and is incremented each time the `step()` method
    is called ❼. When `skip` gets to `9` ❶, you update the simulation by one time
    step. To do this, you first call the `GOL` class’s `update()` method ❷, which
    turns cells on or off according to the Conway’s Game of Life rules. Then you get
    the updated cell colors from the simulation ❸, set them to the torus ❹, and call
    `torus.step()` ❺, which will update the attribute buffers with the new colors.
    Finally, you reset the `skip` variable to `0` so the process can repeat ❻.
  prefs: []
  type: TYPE_NORMAL
- en: '[Running the 3D Game of Life Simulation](nsp-venkitachalam503045-0008.xhtml#rah1204)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we’re ready to run the code. Enter the following at the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 10-8](nsp-venkitachalam503045-0024.xhtml#fig10-8) shows the output.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f10008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-8: A rendering of the Game of Life on a torus'
  prefs: []
  type: TYPE_NORMAL
- en: The program will open a window that shows the torus you meticulously constructed,
    with the Game of Life simulation running on its surface! As the simulation evolves,
    try to find some of the familiar Game of Life patterns you saw in [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03).
    Notice that the light direction remains constant while the camera orbits the torus.
    As the camera turns, you’ll be able to see the light and dark portions of the
    torus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s try the glider option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 10-9](nsp-venkitachalam503045-0024.xhtml#fig10-9) shows the output.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/nsp-venkitachalam503045-f10009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10-9: A Game of Life glider on a torus'
  prefs: []
  type: TYPE_NORMAL
- en: Sit back and enjoy watching the lone glider make its way along the surface of
    the torus!
  prefs: []
  type: TYPE_NORMAL
- en: '[Summary](nsp-venkitachalam503045-0008.xhtml#rah1205)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you implemented Conway’s Game of Life on a torus. You learned
    how to compute the vertices of a torus and how to render it using OpenGL, and
    you saw how code can be adapted from one context (a flat rendering of the Game
    of Life simulation) to another (a 3D rendering of the same simulation). In the
    process, I hope you’ve gotten a more intuitive feeling for how the toroidal boundary
    conditions we discussed in [Chapter 3](nsp-venkitachalam503045-0015.xhtml#ch03) work.
  prefs: []
  type: TYPE_NORMAL
- en: '[Experiments!](nsp-venkitachalam503045-0008.xhtml#rah1206)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are a few experiments you can try with this project:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. In this chapter’s implementation, the torus is lit by a single light source.
    Try adding another light source in the shader code. Now the computed color of
    a vertex will be the sum of contributions from both light sources. Try changing
    the positions and colors of the light sources and see the effect on the torus
    lighting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 2\. To get a representative view of the simulation, you defined a camera that
    revolves around the z-axis of the torus, in a plane parallel to the XY plane.
    Now create a camera that flies over the torus instead. Your camera will start
    by looking down at the torus along the negative z-axis and will move in a circle
    along the XZ plane, at a fixed distance from the center of the torus. Think about
    how you will compute the eye point, view direction, and up vector for each step
    of the movement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[The Complete Torus Rendering Code](nsp-venkitachalam503045-0008.xhtml#rah1207)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s the complete listing for the file *torus.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[The Complete Game of Life Simulation Code](nsp-venkitachalam503045-0008.xhtml#rah1208)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s the full code listing for the file *gol.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: gol.py
  prefs: []
  type: TYPE_NORMAL
- en: Implements Conway's Game of Life.
  prefs: []
  type: TYPE_NORMAL
- en: 'Author: Mahesh Venkitachalam'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: import numpy as np
  prefs: []
  type: TYPE_NORMAL
- en: 'class GOL:'
  prefs: []
  type: TYPE_NORMAL
- en: '"""GOL - class that implements Conway''s Game of Life'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, NX, NY, glider):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""GOL constructor"""'
  prefs: []
  type: TYPE_NORMAL
- en: '# a grid of NX x NY random values'
  prefs: []
  type: TYPE_NORMAL
- en: self.NX, self.NY = NX, NY
  prefs: []
  type: TYPE_NORMAL
- en: 'if glider:'
  prefs: []
  type: TYPE_NORMAL
- en: self.addGlider(1, 1, NX, NY)
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: self.grid = np.random.choice([1, 0], NX * NY, p=[0.2, 0.8]).reshape(NX, NY)
  prefs: []
  type: TYPE_NORMAL
- en: 'def addGlider(self, i, j, NX, NY):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""adds a glider with top left cell at (i, j)"""'
  prefs: []
  type: TYPE_NORMAL
- en: self.grid = np.zeros(NX * NY).reshape(NX, NY)
  prefs: []
  type: TYPE_NORMAL
- en: glider = np.array([[0,    0, 1],
  prefs: []
  type: TYPE_NORMAL
- en: '[1,  0, 1],'
  prefs: []
  type: TYPE_NORMAL
- en: '[0,  1, 1]])'
  prefs: []
  type: TYPE_NORMAL
- en: self.grid[i:i+3, j:j+3] = glider
  prefs: []
  type: TYPE_NORMAL
- en: 'def update(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""update the GOL simulation by one time step"""'
  prefs: []
  type: TYPE_NORMAL
- en: '# copy grid since we require 8 neighbors for calculation'
  prefs: []
  type: TYPE_NORMAL
- en: '# and we go line by line'
  prefs: []
  type: TYPE_NORMAL
- en: newGrid = self.grid.copy()
  prefs: []
  type: TYPE_NORMAL
- en: NX, NY = self.NX, self.NY
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(NX):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range(NY):'
  prefs: []
  type: TYPE_NORMAL
- en: '# compute 8-neighbor sum'
  prefs: []
  type: TYPE_NORMAL
- en: '# using toroidal boundary conditions - x and y wrap around'
  prefs: []
  type: TYPE_NORMAL
- en: '# so that the simulation takes place on a toroidal surface'
  prefs: []
  type: TYPE_NORMAL
- en: total = (self.grid[i, (j-1) % NY] + self.grid[i, (j+1) % NY] +
  prefs: []
  type: TYPE_NORMAL
- en: self.grid[(i-1) % NX, j] + self.grid[(i+1) % NX, j] +
  prefs: []
  type: TYPE_NORMAL
- en: self.grid[(i-1) % NX, (j-1) % NY] + self.grid[(i-1) % NX, (j+1) % NY] +
  prefs: []
  type: TYPE_NORMAL
- en: self.grid[(i+1) % NX, (j-1) % NY] + self.grid[(i+1) % NX, (j+1) % NY])
  prefs: []
  type: TYPE_NORMAL
- en: '# apply Conway''s rules'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.grid[i, j]  == 1:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if (total < 2) or (total > 3):'
  prefs: []
  type: TYPE_NORMAL
- en: newGrid[i, j] = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'else:'
  prefs: []
  type: TYPE_NORMAL
- en: 'if total == 3:'
  prefs: []
  type: TYPE_NORMAL
- en: newGrid[i, j] = 1
  prefs: []
  type: TYPE_NORMAL
- en: '# update data'
  prefs: []
  type: TYPE_NORMAL
- en: self.grid[:] = newGrid[:]
  prefs: []
  type: TYPE_NORMAL
- en: 'def get_colors(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '"""returns a dictionary of colors"""'
  prefs: []
  type: TYPE_NORMAL
- en: colors = {}
  prefs: []
  type: TYPE_NORMAL
- en: c1 = np.array([1.0, 1.0, 1.0], np.float32)
  prefs: []
  type: TYPE_NORMAL
- en: c2 = np.array([0.0, 0.0, 0.0], np.float32)
  prefs: []
  type: TYPE_NORMAL
- en: 'for i in range(self.NX):'
  prefs: []
  type: TYPE_NORMAL
- en: 'for j in range (self.NY):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.grid[i, j] == 1:'
  prefs: []
  type: TYPE_NORMAL
- en: colors[(i, j)] = c2
  prefs: []
  type: TYPE_NORMAL
- en: 'else :'
  prefs: []
  type: TYPE_NORMAL
- en: colors[(i, j)] = c1
  prefs: []
  type: TYPE_NORMAL
- en: return colors
  prefs: []
  type: TYPE_NORMAL
- en: '[The Complete Camera Code](nsp-venkitachalam503045-0008.xhtml#rah1209)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s the complete code in the file *camera.py*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[The Complete RenderWindow Code](nsp-venkitachalam503045-0008.xhtml#rah1210)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The complete code listing for *gol_torus.py*, including the `RenderWindow` class
    and the `main()` function, follows.
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: gol_torus.py
  prefs: []
  type: TYPE_NORMAL
- en: Python OpenGL program that displays a torus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Author: Mahesh Venkitachalam'
  prefs: []
  type: TYPE_NORMAL
- en: '"""'
  prefs: []
  type: TYPE_NORMAL
- en: import OpenGL
  prefs: []
  type: TYPE_NORMAL
- en: from OpenGL.GL import *
  prefs: []
  type: TYPE_NORMAL
- en: import numpy, math, sys, os
  prefs: []
  type: TYPE_NORMAL
- en: import argparse
  prefs: []
  type: TYPE_NORMAL
- en: import glutils
  prefs: []
  type: TYPE_NORMAL
- en: import glfw
  prefs: []
  type: TYPE_NORMAL
- en: from torus import Torus
  prefs: []
  type: TYPE_NORMAL
- en: from camera import OrbitCamera
  prefs: []
  type: TYPE_NORMAL
- en: from gol import GOL
  prefs: []
  type: TYPE_NORMAL
- en: 'class RenderWindow:'
  prefs: []
  type: TYPE_NORMAL
- en: '"""GLFW Rendering window class"""'
  prefs: []
  type: TYPE_NORMAL
- en: 'def __init__(self, glider):'
  prefs: []
  type: TYPE_NORMAL
- en: '# save current working directory'
  prefs: []
  type: TYPE_NORMAL
- en: cwd = os.getcwd()
  prefs: []
  type: TYPE_NORMAL
- en: '# initialize glfw - this changes cwd'
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwInit()
  prefs: []
  type: TYPE_NORMAL
- en: '# restore cwd'
  prefs: []
  type: TYPE_NORMAL
- en: os.chdir(cwd)
  prefs: []
  type: TYPE_NORMAL
- en: '# version hints'
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MAJOR, 3)
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwWindowHint(glfw.GLFW_CONTEXT_VERSION_MINOR, 3)
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwWindowHint(glfw.GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE)
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwWindowHint(glfw.GLFW_OPENGL_PROFILE, glfw.GLFW_OPENGL_CORE_PROFILE)
  prefs: []
  type: TYPE_NORMAL
- en: '# make a window'
  prefs: []
  type: TYPE_NORMAL
- en: self.width, self.height = 640, 480
  prefs: []
  type: TYPE_NORMAL
- en: self.aspect = self.width/float(self.height)
  prefs: []
  type: TYPE_NORMAL
- en: self.win = glfw.glfwCreateWindow(self.width, self.height, b'gol_torus')
  prefs: []
  type: TYPE_NORMAL
- en: '# make context current'
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwMakeContextCurrent(self.win)
  prefs: []
  type: TYPE_NORMAL
- en: '# initialize GL'
  prefs: []
  type: TYPE_NORMAL
- en: glViewport(0, 0, self.width, self.height)
  prefs: []
  type: TYPE_NORMAL
- en: glEnable(GL_DEPTH_TEST)
  prefs: []
  type: TYPE_NORMAL
- en: '#glClearColor(0.2, 0.2, 0.2, 1.0)'
  prefs: []
  type: TYPE_NORMAL
- en: glClearColor(0.11764706, 0.11764706, 0.11764706, 1.0)
  prefs: []
  type: TYPE_NORMAL
- en: '# set window callbacks'
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwSetMouseButtonCallback(self.win, self.onMouseButton)
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwSetKeyCallback(self.win, self.onKeyboard)
  prefs: []
  type: TYPE_NORMAL
- en: '# create 3D'
  prefs: []
  type: TYPE_NORMAL
- en: NX = 64
  prefs: []
  type: TYPE_NORMAL
- en: NY = 64
  prefs: []
  type: TYPE_NORMAL
- en: R = 4.0
  prefs: []
  type: TYPE_NORMAL
- en: r = 1.0
  prefs: []
  type: TYPE_NORMAL
- en: self.torus = Torus(R, r, NX, NY)
  prefs: []
  type: TYPE_NORMAL
- en: self.gol = GOL(NX, NY, glider)
  prefs: []
  type: TYPE_NORMAL
- en: '# create a camera'
  prefs: []
  type: TYPE_NORMAL
- en: self.camera = OrbitCamera(5.0, 10.0)
  prefs: []
  type: TYPE_NORMAL
- en: '# exit flag'
  prefs: []
  type: TYPE_NORMAL
- en: self.exitNow = False
  prefs: []
  type: TYPE_NORMAL
- en: '# rotation flag'
  prefs: []
  type: TYPE_NORMAL
- en: self.rotate = True
  prefs: []
  type: TYPE_NORMAL
- en: '# skip count'
  prefs: []
  type: TYPE_NORMAL
- en: self.skip = 0
  prefs: []
  type: TYPE_NORMAL
- en: 'def onMouseButton(self, win, button, action, mods):'
  prefs: []
  type: TYPE_NORMAL
- en: '# print ''mouse button: '', win, button, action, mods'
  prefs: []
  type: TYPE_NORMAL
- en: pass
  prefs: []
  type: TYPE_NORMAL
- en: 'def onKeyboard(self, win, key, scancode, action, mods):'
  prefs: []
  type: TYPE_NORMAL
- en: '# print ''keyboard: '', win, key, scancode, action, mods'
  prefs: []
  type: TYPE_NORMAL
- en: 'if action == glfw.GLFW_PRESS:'
  prefs: []
  type: TYPE_NORMAL
- en: '# ESC to quit'
  prefs: []
  type: TYPE_NORMAL
- en: 'if key == glfw.GLFW_KEY_ESCAPE:'
  prefs: []
  type: TYPE_NORMAL
- en: self.exitNow = True
  prefs: []
  type: TYPE_NORMAL
- en: 'elif key == glfw.GLFW_KEY_R:'
  prefs: []
  type: TYPE_NORMAL
- en: self.rotate = not self.rotate
  prefs: []
  type: TYPE_NORMAL
- en: 'def run(self):'
  prefs: []
  type: TYPE_NORMAL
- en: '# initializer timer'
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwSetTime(0)
  prefs: []
  type: TYPE_NORMAL
- en: t = 0.0
  prefs: []
  type: TYPE_NORMAL
- en: 'while not glfw.glfwWindowShouldClose(self.win) and not self.exitNow:'
  prefs: []
  type: TYPE_NORMAL
- en: '# update every x seconds'
  prefs: []
  type: TYPE_NORMAL
- en: currT = glfw.glfwGetTime()
  prefs: []
  type: TYPE_NORMAL
- en: 'if currT - t > 0.05:'
  prefs: []
  type: TYPE_NORMAL
- en: '# update time'
  prefs: []
  type: TYPE_NORMAL
- en: t = currT
  prefs: []
  type: TYPE_NORMAL
- en: '# set viewport'
  prefs: []
  type: TYPE_NORMAL
- en: self.width, self.height = glfw.glfwGetFramebufferSize(self.win)
  prefs: []
  type: TYPE_NORMAL
- en: self.aspect = self.width/float(self.height)
  prefs: []
  type: TYPE_NORMAL
- en: glViewport(0, 0, self.width, self.height)
  prefs: []
  type: TYPE_NORMAL
- en: '# clear'
  prefs: []
  type: TYPE_NORMAL
- en: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
  prefs: []
  type: TYPE_NORMAL
- en: '# build projection matrix'
  prefs: []
  type: TYPE_NORMAL
- en: pMatrix = glutils.perspective(60.0, self.aspect, 0.1, 100.0)
  prefs: []
  type: TYPE_NORMAL
- en: mvMatrix = glutils.lookAt(self.camera.eye, self.camera.center, self.camera.up)
  prefs: []
  type: TYPE_NORMAL
- en: '# render'
  prefs: []
  type: TYPE_NORMAL
- en: self.torus.render(pMatrix, mvMatrix)
  prefs: []
  type: TYPE_NORMAL
- en: '# step'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.rotate:'
  prefs: []
  type: TYPE_NORMAL
- en: self.step()
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwSwapBuffers(self.win)
  prefs: []
  type: TYPE_NORMAL
- en: '# poll for and process events'
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwPollEvents()
  prefs: []
  type: TYPE_NORMAL
- en: '# end'
  prefs: []
  type: TYPE_NORMAL
- en: glfw.glfwTerminate()
  prefs: []
  type: TYPE_NORMAL
- en: 'def step(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'if self.skip == 9:'
  prefs: []
  type: TYPE_NORMAL
- en: '# update GOL'
  prefs: []
  type: TYPE_NORMAL
- en: self.gol.update()
  prefs: []
  type: TYPE_NORMAL
- en: colors = self.gol.get_colors()
  prefs: []
  type: TYPE_NORMAL
- en: self.torus.set_colors(colors)
  prefs: []
  type: TYPE_NORMAL
- en: '# step'
  prefs: []
  type: TYPE_NORMAL
- en: self.torus.step()
  prefs: []
  type: TYPE_NORMAL
- en: '# reset'
  prefs: []
  type: TYPE_NORMAL
- en: self.skip = 0
  prefs: []
  type: TYPE_NORMAL
- en: '# update skip'
  prefs: []
  type: TYPE_NORMAL
- en: self.skip += 1
  prefs: []
  type: TYPE_NORMAL
- en: '# rotate camera'
  prefs: []
  type: TYPE_NORMAL
- en: self.camera.rotate()
  prefs: []
  type: TYPE_NORMAL
- en: main() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'def main():'
  prefs: []
  type: TYPE_NORMAL
- en: print("Starting GOL. Press ESC to quit.")
  prefs: []
  type: TYPE_NORMAL
- en: '# parse arguments'
  prefs: []
  type: TYPE_NORMAL
- en: parser = argparse.ArgumentParser(description="Runs Conway's Game of Life simulation
  prefs: []
  type: TYPE_NORMAL
- en: on a Torus.")
  prefs: []
  type: TYPE_NORMAL
- en: '# add arguments'
  prefs: []
  type: TYPE_NORMAL
- en: parser.add_argument('--glider', action='store_true', required=False)
  prefs: []
  type: TYPE_NORMAL
- en: args = parser.parse_args()
  prefs: []
  type: TYPE_NORMAL
- en: '# set args'
  prefs: []
  type: TYPE_NORMAL
- en: glider = False
  prefs: []
  type: TYPE_NORMAL
- en: 'if args.glider:'
  prefs: []
  type: TYPE_NORMAL
- en: glider = True
  prefs: []
  type: TYPE_NORMAL
- en: rw = RenderWindow(glider)
  prefs: []
  type: TYPE_NORMAL
- en: rw.run()
  prefs: []
  type: TYPE_NORMAL
- en: call main
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'if __name__ == ''__main__'':'
  prefs: []
  type: TYPE_NORMAL
- en: main()
  prefs: []
  type: TYPE_NORMAL
