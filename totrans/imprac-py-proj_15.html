<html><head></head><body>
<h2 class="h2" id="ch15"><span epub:type="pagebreak" id="page_325"/><strong><span class="big">15</span><br/>IMPROVING YOUR ASTROPHOTOGRAPHY WITH PLANET STACKING</strong></h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">If you’ve ever looked through a telescope at Jupiter, Mars, or Saturn, you were probably a little disappointed. The planets appeared small and featureless. You wanted to zoom in and crank up the magnification, but it didn’t work. Anything bigger than about 200x magnification tends to be blurry.</p>
<p class="indent">The problem is air turbulence, or what astronomers call <em>seeing</em>. Even on a clear night, the air is constantly in motion, with thermal updrafts and downdrafts that can easily blur the pinpoints of light that represent celestial objects. But with the commercialization of the <em>charge-coupled device (CCD)</em> in the 1980s, astronomers found a way to overcome the turbulence. Digital photography permits a technique known as <em>image stacking</em>, in which many photos—some good, some bad—are averaged together, or stacked, into a single image. With enough photos, the persistent, unchanging features <span epub:type="pagebreak" id="page_326"/>(like a planet’s surface) dominate transient features (like a stray cloud). This allows astrophotographers to increase magnification limits, as well as compensate for less-than-optimal seeing conditions.</p>
<p class="indent">In this chapter, you’ll use a third-party Python module called <span class="literal">pillow</span> to stack hundreds of images of Jupiter. The result will be a single image with a higher signal-to-noise ratio than any of the individual frames. You’ll also work with files in different folders than your Python code and manipulate both the files and folders using the Python operating system (<span class="literal">os</span>) and shell utilities (<span class="literal">shutil</span>) modules.</p>
<h3 class="h3a" id="lev361"><strong>Project #23: Stacking Jupiter</strong></h3>
<p class="noindent">Large, bright, and colorful, the gas giant Jupiter is a favorite target of astrophotographers. Even amateur telescopes can resolve its orange striping, caused by linear cloud bands, and the Great Red Spot, an oval-shaped storm so large it could swallow the Earth (see <a href="ch15.xhtml#ch15fig1">Figure 15-1</a>).</p>
<div class="image"><a id="ch15fig1"/><img src="../images/f0326-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-1: Jupiter as photographed by the Cassini spacecraft</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_327"/>Jupiter is a great subject for studying image stacking. Its linear cloud bands and Great Red Spot provide the eye with calibration points for judging improvements in edge definition and clarity, and its relatively large size makes it easy to detect noise.</p>
<p class="indent">Noise manifests itself as “graininess.” Each color band has its own artifacts, resulting in colored speckles across an image. The main sources of noise are the camera (electronic readout noise and thermal signal) and photon noise from the light itself, as a variable number of photons strike the sensor over time. Noise artifacts are fortunately random in nature and can be largely canceled out by stacking images.</p>
<div class="sidebar">
<p class="sidebart"><strong>THE OBJECTIVE</strong></p>
<p class="spara">Write programs that crop, scale, stack, and enhance images to create a clearer photograph of Jupiter.</p>
</div>
<h3 class="h3" id="lev362"><strong>The pillow Module</strong></h3>
<p class="noindent">To work with images, you’ll need a free third-party Python module called <span class="literal">pillow</span>. It’s the successor project to the Python Imaging Library (PIL), which was discontinued in 2011. The <span class="literal">pillow</span> module “forked” the PIL repository and upgraded the code for Python 3.</p>
<p class="indent">You can use <span class="literal">pillow</span> on Windows, macOS, and Linux, and it supports many image formats including PNG, JPEG, GIF, BMP, and TIFF. It offers standard image-manipulation procedures, such as altering individual pixels, masking, handling transparency, filtering and enhancing, and adding text. But the real strength of <span class="literal">pillow</span> is its ability to edit many images with ease.</p>
<p class="indent">Installing <span class="literal">pillow</span> is easy with the pip tool (for more about pip, see “<a href="ch06.xhtml#lev136">Manipulating Word Documents with <span class="literal">python-docx</span></a>” on <a href="ch06.xhtml#page_110">page 110</a>). From the command line, enter <span class="codestrong1">pip install pillow</span>.</p>
<p class="indent">Most major Linux distributions include <span class="literal">pillow</span> in packages that previously contained PIL, so you may already have <span class="literal">pillow</span> on your system. Regardless of your platform, if PIL is already installed, you’ll need to uninstall it before installing <span class="literal">pillow</span>. For more installation instructions, see <em><a href="http://pillow.readthedocs.io/en/latest/installation.html">http://pillow.readthedocs.io/en/latest/installation.html</a></em>.</p>
<h3 class="h3" id="lev363"><strong>Working with Files and Folders</strong></h3>
<p class="noindent">In all the previous projects in this book, you’ve kept supporting files and modules in the same folder as your Python code. This was handy for simple projects, but not very realistic for broad use, and it’s certainly not good when you’re dealing with the hundreds of image files you’ll generate in this project. Fortunately, Python ships with several modules that can help with this, like <span class="literal">os</span> and <span class="literal">shutil</span>. But first, I’ll briefly discuss directory paths.</p>
<h4 class="h4" id="lev364"><span epub:type="pagebreak" id="page_328"/><strong><em>Directory Paths</em></strong></h4>
<p class="noindent">The directory path is the address to a file or folder. It starts with a root directory, which is designated with a letter (such as <em>C:\</em>) in Windows, and a forward slash (<em>/</em>) in Unix-based systems. Additional drives in Windows are assigned a different letter than <em>C</em>, those in macOS are placed under <em>/volume</em>, and those in Unix under <em>/mnt</em> (for “mount”).</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>I use the Windows operating system for the examples in this chapter, but you can achieve the same result on macOS and other systems. And as is commonly done, I use the terms</em> directory <em>and</em> folder <em>interchangeably here.</em></p>
</div>
<p class="indent">Pathnames appear differently depending on the operating system. Windows separates folders with a backslash (<em>\</em>), while macOS and Unix systems use a forward slash (<em>/</em>). Also, in Unix, folder and file names are case sensitive.</p>
<p class="indent">If you’re writing your program in Windows and type in pathnames with backslashes, other platforms won’t recognize the paths. Fortunately, the <span class="literal">os.path.join()</span> method will automatically ensure your pathname is suitable for whatever operating system Python is running on. Let’s take a look at this, and other examples, in <a href="ch15.xhtml#ch15list1">Listing 15-1</a>.</p>
<p class="programs"><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong1">import os</span><br/><span class="ent">➋</span> &gt;&gt;&gt; <span class="codestrong1">os.getcwd()</span><br/>   'C:\\Python35\\Lib\\idlelib'<br/><span class="ent">➌</span> &gt;&gt;&gt; <span class="codestrong1">os.chdir('C:\\Python35\\Python 3 Stuff')</span><br/>   &gt;&gt;&gt; <span class="codestrong1">os.getcwd()</span><br/>   'C:\\Python35\\Python 3 Stuff'<br/><span class="ent">➍</span> &gt;&gt;&gt; <span class="codestrong1">os.chdir(r'C:\Python35\Python 3 Stuff\Planet Stacking')</span><br/>   &gt;&gt;&gt; <span class="codestrong1">os.getcwd()</span><br/><span class="ent">➎</span> 'C:\\Python35\\Python 3 Stuff\\Planet Stacking'<br/><span class="ent">➏</span> &gt;&gt;&gt; <span class="codestrong1">os.path.join('Planet Stacking', 'stack_8', '8file262.jpg')</span><br/>   'Planet Stacking\\stack_8\\8file262.jpg'<br/><span class="ent">➐</span> &gt;&gt;&gt; <span class="codestrong1">os.path.normpath('C:/Python35/Python 3 Stuff')</span><br/>   'C:\\Python35\\Python 3 Stuff'<br/><span class="ent">➑</span> &gt;&gt;&gt; <span class="codestrong1">os.chdir('C:/Python35')</span><br/>   &gt;&gt;&gt; <span class="codestrong1">os.getcwd()</span><br/>   'C:\\Python35'</p>
<p class="listing" id="ch15list1"><em>Listing 15-1: Working with Windows pathnames using the</em> <span class="codeitalic">os</span> <em>module</em></p>
<p class="indent">After importing the <span class="literal">os</span> module for access to operating system–dependent functionality <span class="ent">➊</span>, get the <em>current working directory</em>, or <em>cwd</em> <span class="ent">➋</span>. The cwd is assigned to a process when it starts up; that is, when you run a script from your shell, the cwd of the shell and the script will be the same. For a Python program, the cwd is the folder that contains the program. When you get the cwd, you’re shown the full path. Note that you must use extra backslashes in order to escape the backslash characters used as file separators.</p>
<p class="indent">Next, you change the cwd using the <span class="literal">os.chdir()</span> method <span class="ent">➌</span>, passing it the full path in quotes, using double backslashes. Then you get the cwd again to see the new path.</p>
<p class="indent"><span epub:type="pagebreak" id="page_329"/>If you don’t want to type the double backslash, you can enter an <span class="codestrong">r</span> before the pathname argument string to convert it to a <em>raw string</em> <span class="ent">➍</span>. Raw strings use different rules for backslash escape sequences, but even a raw string can’t end in a single backslash. The path will still be displayed with double backslashes <span class="ent">➎</span>.</p>
<p class="indent">If you want your program to be compatible with all operating systems, use the <span class="literal">os.path.join()</span> method and pass it the folder names and filenames without a separator character <span class="ent">➏</span>. The <span class="literal">os.path</span> methods are aware of the system you’re using and return the proper separators. This allows for platform-independent manipulation of filenames and folder names.</p>
<p class="indent">The <span class="literal">os.path.normpath()</span> method corrects separators for the system you are using <span class="ent">➐</span>. In the Windows example shown, incorrect Unix-type separators are replaced with backslashes. Native Windows also supports use of the forward slash and will automatically make the conversion <span class="ent">➑</span>.</p>
<p class="indent">The full directory path—from the root down—is called the <em>absolute path</em>. You can use shortcuts, called <em>relative paths</em>, to make working with directories easier. Relative paths are interpreted from the perspective of the current working directory. Whereas absolute paths start with a forward slash or drive label, relative paths do not. In the following code snippet, you can change directories without entering an absolute path—Python is aware of the new location because it is <em>within</em> the cwd. Behind the scenes, the relative path is joined to the path leading to the cwd to make a complete absolute path.</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">os.getcwd()</span><br/>'C:\\Python35\\Python 3 Stuff'<br/>&gt;&gt;&gt; <span class="codestrong1">os.chdir('Planet Stacking')</span><br/>&gt;&gt;&gt; <span class="codestrong1">os.getcwd()</span><br/>'C:\\Python35\\Python 3 Stuff\\Planet Stacking'</p>
<p class="indent">You can identify folders and save more typing with dot (<span class="literal">.</span>) and dot-dot (<span class="literal">..</span>). For example, in Windows, <span class="literal">.\</span> refers to the cwd, and <span class="literal">..\</span> refers to the parent directory that holds the cwd. You can also use a dot to get the absolute path to your cwd:</p>
<p class="programs">&gt;&gt;&gt; <span class="codestrong1">os.path.abspath('.')</span><br/>'C:\\Python35\\Python 3 Stuff\\Planet Stacking\\for_book'</p>
<p class="indent">Dot folders can be used in Windows, macOS, and Linux. For more on the <span class="literal">os</span> module, see <em><a href="https://docs.python.org/3/library/os.html">https://docs.python.org/3/library/os.html</a></em>.</p>
<h4 class="h4" id="lev365"><strong><em>The Shell Utilities Module</em></strong></h4>
<p class="noindent">The shell utilities module, <span class="literal">shutil</span>, provides high-level functions for working with files and folders, such as copying, moving, renaming, and deleting. Since it’s part of the Python standard library, you can load <span class="literal">shutil</span> simply by typing <span class="codestrong1">import shutil</span>. You’ll see example uses for the module in this chapter’s code sections. Meanwhile, you can find the module’s documentation at <em><a href="https://docs.python.org/3.7/library/shutil.html">https://docs.python.org/3.7/library/shutil.html</a></em>.</p>
<h3 class="h3" id="lev366"><span epub:type="pagebreak" id="page_330"/><strong>The Video</strong></h3>
<p class="noindent">Brooks Clark recorded the color video of Jupiter used in this project on a windy night in Houston, Texas. It consists of a 101 MB <em>.mov</em> file with a runtime of about 16 seconds.</p>
<p class="indent">The length of the video is intentionally short. Jupiter’s rotation period is about 10 hours, which means still photos may blur with exposure times of only a minute, and features you want to reinforce through stacking video frames can change positions, greatly complicating the process.</p>
<p class="indent">To convert the video frames to individual images, I used Free Studio, a freeware set of multimedia programs developed by DVDVideoSoft. The Free Video to JPG Converter tool permits the capture of images at constant time or frame intervals. I set the interval to sample frames across the full length of the video, to improve the odds of capturing some images when the air was still and the seeing good.</p>
<p class="indent">A few hundred images should be enough for stacking to show demonstrable improvement. In this case, I captured 256 frames.</p>
<p class="indent">You can find the folder of images, named <em>video_frames</em>, online with the book’s resources at <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>. Download this folder and retain the name.</p>
<p class="indent">An example frame from the video, in grayscale, is shown in <a href="ch15.xhtml#ch15fig2">Figure 15-2</a>. Jupiter’s cloud bands are faint and fuzzy, the Great Red Spot isn’t apparent, and the image suffers from low contrast, a common side effect of magnification. Noise artifacts also give Jupiter a grainy appearance.</p>
<div class="image"><a id="ch15fig2"/><img src="../images/f0330-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-2: Example frame from the video of Jupiter</em></p>
<p class="indent">In addition to those issues, the wind shook the camera, and imprecise tracking caused the planet to drift laterally to the left-hand side of the frame. You can see an example of <em>lateral drift</em> in <a href="ch15.xhtml#ch15fig3">Figure 15-3</a>, in which I have overlaid five randomly chosen frames with the black background set to transparent.</p>
<div class="image"><a id="ch15fig3"/><img src="../images/f0330-02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-3: An example of shake and drift in the Jupiter video based on five randomly chosen frames</em></p>
<p class="indent">Movement isn’t necessarily a bad thing, because shifting the image around can <span epub:type="pagebreak" id="page_331"/>smooth defects associated with the CCD sensor surface, dust on the lens or sensor, and so on. But the key assumption in image stacking is that the images perfectly align so that persistent features, like Jupiter’s cloud bands, reinforce each other as you average the images. For the signal-to-noise ratio to be high, the images must be registered.</p>
<p class="indent"><em>Image registration</em> is the process of transforming data to the same coordinate system so that it can be compared and integrated. Registration is arguably the hardest part of image stacking. Astronomers typically use commercial software—such as RegiStax, RegiStar, Deep Sky Stacker, or CCDStack—to help them align and stack their astrophotos. You’ll get your hands dirty, however, and do this yourself using Python.</p>
<h3 class="h3" id="lev367"><strong>The Strategy</strong></h3>
<p class="noindent">The steps required to stack the images are as follows (the first one has already been completed):</p>
<ol>
<li class="noindent">Extract images from video recording.</li>
<li class="noindent">Crop images around Jupiter.</li>
<li class="noindent">Scale cropped images to the same size.</li>
<li class="noindent">Stack images into a single image.</li>
<li class="noindent">Enhance and filter the final image.</li>
</ol>
<h3 class="h3" id="lev368"><strong>The Code</strong></h3>
<p class="noindent">You can incorporate all the steps into one program, but I chose to distribute them across three programs. This is because you generally want to stop and check results along the way, plus you may want to run later processes, such as enhancement, without having to completely rerun the whole workflow. The first program will crop and scale the images, the second will stack them, and the third will enhance them.</p>
<h4 class="h4" id="lev369"><strong><em>The Cropping and Scaling Code</em></strong></h4>
<p class="noindent">First, you need to register the images. For large, bright objects like the moon and Jupiter, one approach in astrophotography is to crop each image so that its four borders are tangent with the surface of the body. This removes most of the sky and mitigates any shake and drift issues. Scaling the cropped images will ensure they are all the same size and will smooth them slightly to reduce noise.</p>
<p class="indent">You can download <em>crop_n_scale_images.py</em> from <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>. Keep it in the directory that holds the folder of captured video frames.</p>
<h5 class="h5" id="lev370"><span epub:type="pagebreak" id="page_332"/><strong>Importing Modules and Defining the main() Function</strong></h5>
<p class="noindent"><a href="ch15.xhtml#ch15list2">Listing 15-2</a> performs imports and defines the <span class="literal">main()</span> function that runs the <em>crop_n_scale_images.py</em> program.</p>
<p class="margin"><em>crop_n_scale_images.py,</em> part 1</p>
<p class="programs"><span class="ent">➊</span> import os<br/>   import sys<br/><span class="ent">➋</span> import shutil<br/><span class="ent">➌</span> from PIL import Image, ImageOps<br/><br/>   def main():<br/>       """Get starting folder, copy folder, run crop function, &amp; clean folder."""<br/>       # get name of folder in cwd with original video images<br/>    <span class="ent">➍</span> frames_folder = 'video_frames'<br/><br/>       # prepare files &amp; folders<br/>    <span class="ent">➎</span> del_folders('cropped')<br/>    <span class="ent">➏</span> shutil.copytree(frames_folder, 'cropped')<br/><br/>       # run cropping function<br/>       print("start cropping and scaling...")<br/>    <span class="ent">➐</span> os.chdir('cropped')<br/>       crop_images()<br/>    <span class="ent">➑</span> clean_folder(prefix_to_save='cropped')  # delete uncropped originals<br/><br/>       print("Done! \n")</p>
<p class="listing" id="ch15list2"><em>Listing 15-2: Imports modules and defines the</em> <span class="codeitalic">main()</span> <em>function</em></p>
<p class="indent">Start by importing both the operating system (<span class="literal">os</span>) and system (<span class="literal">sys</span>) <span class="ent">➊</span>. The <span class="literal">os</span> import already includes an import of <span class="literal">sys</span>, but this feature may go away in the future, so it’s best to manually import <span class="literal">sys</span> yourself. The <span class="literal">shutil</span> module contains the shell utilities described earlier <span class="ent">➋</span>. From the imaging library, you’ll use <span class="literal">Image</span> to load, crop, convert, and filter images; you’ll also use <span class="literal">ImageOps</span> to scale images <span class="ent">➌</span>. Note you must use PIL, not <span class="literal">pillow</span>, in the <span class="literal">import</span> statement.</p>
<p class="indent">Start the <span class="literal">main()</span> function by assigning the name of the starting folder to the <span class="literal">frames_folder</span> variable <span class="ent">➍</span>. This folder contains all the original images captured from the video.</p>
<p class="indent">You’ll store the cropped images in a new folder named <em>cropped</em>, but the shell utilities won’t create this folder if it already exists, so call the <span class="literal">del_folders()</span> function that you’ll write in a moment <span class="ent">➎</span>. As written, this function won’t throw an error if the folder doesn’t exist, so it can be run safely at any time.</p>
<p class="indent">You should always work off a copy of original images, so use the <span class="literal">shutil.copytree()</span> method to copy the folder containing the originals to a new folder named <em>cropped</em> <span class="ent">➏</span>. Now, switch to this folder <span class="ent">➐</span> and call the <span class="literal">crop_images()</span> function, which will crop and scale the images. Follow this with the <span class="literal">clean_folder()</span> function, which removes the original video frames that were copied into the <em>cropped</em> folder and are still hanging around <span class="ent">➑</span>. <span epub:type="pagebreak" id="page_333"/>Note that you use the parameter name when you pass the argument to the <span class="literal">clean_folder()</span> function, since this makes the purpose of the function more obvious.</p>
<p class="indent">Print <span class="literal">Done!</span> to let the user know when the program is finished.</p>
<h5 class="h5" id="lev371"><strong>Deleting and Cleaning Folders</strong></h5>
<p class="noindent"><a href="ch15.xhtml#ch15list3">Listing 15-3</a> defines helper functions to delete files and folders in <em>crop_n_scale_images.py</em>. The <span class="literal">shutil</span> module will refuse to make a new folder if one with the same name already exists in the target directory. If you want to run the program more than once, you first have to remove or rename existing folders. The program will also rename images once they have been cropped, and you’ll want to delete the original images before you start stacking them. Since there will be hundreds of image files, these functions will automate an otherwise laborious task.</p>
<p class="margin"><em>crop_n_scale_images.py,</em> part 2</p>
<p class="programs"><span class="ent">➊</span> def del_folders(name):<br/>       """If a folder with a named prefix exists in directory, delete it."""<br/>    <span class="ent">➋</span> contents = os.listdir()<br/>    <span class="ent">➌</span> for item in contents:<br/>        <span class="ent">➍</span> if os.path.isdir(item) and item.startswith(name):<br/>            <span class="ent">➎</span> shutil.rmtree(item)<br/><br/><span class="ent">➏</span> def clean_folder(prefix_to_save):<br/>       """Delete all files in folder except those with a named prefix."""<br/>    <span class="ent">➐</span> files = os.listdir()<br/>       for file in files:<br/>        <span class="ent">➑</span> if not file.startswith(prefix_to_save):<br/>            <span class="ent">➒</span> os.remove(file)</p>
<p class="listing" id="ch15list3"><em>Listing 15-3: Defines functions to delete folders and files</em></p>
<p class="indent">Define a function called <span class="literal">del_folders()</span> for deleting folders <span class="ent">➊</span>. The only argument will be the name of a folder you want to remove.</p>
<p class="indent">Next, list the contents of the folder <span class="ent">➋</span>, then start looping through the contents <span class="ent">➌</span>. If the function encounters an item that starts with the folder name and is also a directory <span class="ent">➍</span>, use <span class="literal">shutil.rmtree()</span> to delete the folder <span class="ent">➎</span>. As you’ll see in a moment, a different method is used to delete a folder than to delete a file.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Always be careful when using the</em> <span class="codeitalic">rmtree()</span> <em>method, as it</em> permanently <em>deletes folders and their contents. You can wipe much of your system, lose important documents unrelated to Python projects, and break your computer!</em></p>
</div>
<p class="indent">Now, define a helper function to “clean” a folder and pass it the name of files <em>that you don’t want to delete</em> <span class="ent">➏</span>. This is a little counterintuitive at first, but since you only want to keep the last batch of images you’ve processed, you don’t have to worry about explicitly listing any other files in the folder. If the files don’t start with the prefix you provide, such as <em>cropped</em>, then they are automatically removed.</p>
<p class="indent"><span epub:type="pagebreak" id="page_334"/>The process is similar to the last function. List the contents of the folder <span class="ent">➐</span> and start looping through the list. If the file doesn’t start with the prefix you provided <span class="ent">➑</span>, use <span class="literal">os.remove()</span> to delete it <span class="ent">➒</span>.</p>
<h5 class="h5" id="lev372"><strong>Cropping, Scaling, and Saving Images</strong></h5>
<p class="noindent"><a href="ch15.xhtml#ch15list4">Listing 15-4</a> registers the frames captured from the video by fitting a box around Jupiter and cropping the image to the box (<a href="ch15.xhtml#ch15fig4">Figure 15-4</a>). This technique works well with bright images on a field of black (see “<a href="ch15.xhtml#lev376">Further Reading</a>” on <a href="ch15.xhtml#page_343">page 343</a> for another example).</p>
<div class="image"><a id="ch15fig4"/><img src="../images/f0334-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-4: Cropping the original video frame to Jupiter to align the images</em></p>
<p class="indent">By cropping the images tightly around Jupiter, you resolve all of the drift and shake issues.</p>
<p class="indent">Each cropped image is also scaled to a larger and consistent size and smoothed slightly to reduce noise. The cropped and scaled images will be kept in their own folder, which the <span class="literal">main()</span> function creates, later.</p>
<p class="margin"><em>crop_n_scale_images.py,</em> part 3</p>
<p class="programs"><span class="ent">➊</span> def crop_images():<br/>       """Crop and scale images of a planet to box around planet."""<br/>    <span class="ent">➋</span> files = os.listdir()<br/>    <span class="ent">➌</span> for file_num, file in enumerate(files, start=1):<br/>        <span class="ent">➍</span> with Image.open(file) as img:<br/>            <span class="ent">➎</span> gray = img.convert('L')<br/>            <span class="ent">➏</span> bw = gray.point(lambda x: 0 if x &lt; 90 else 255)<br/>            <span class="ent">➐</span> box = bw.getbbox()<br/>               padded_box = (box[0]-20, box[1]-20, box[2]+20, box[3]+20)<br/>            <span class="ent">➑</span> cropped = img.crop(padded_box)<br/>               scaled = ImageOps.fit(cropped, (860, 860),<br/>                                     Image.LANCZOS, 0, (0.5, 0.5))<br/>               file_name = 'cropped_{}.jpg'.format(file_num)<br/>            <span class="ent">➒</span> scaled.save(file_name, "JPEG")<br/><br/>   if __name__ == '__main__':<br/>       main()</p>
<p class="listing" id="ch15list4"><em>Listing 15-4: Crops initial video frames to a box around Jupiter and rescales</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_335"/>The <span class="literal">crop_images()</span> function takes no argument <span class="ent">➊</span> but will ultimately work on a copy—named <em>cropped</em>—of the folder containing the original video frames. You made this copy in the <span class="literal">main()</span> function prior to calling this function.</p>
<p class="indent">Start the function by making a list of the contents of the current (<em>cropped</em>) folder <span class="ent">➋</span>. The program will number each image sequentially, so use <span class="literal">enumerate()</span> with the <span class="literal">for</span> loop and set the <span class="literal">start</span> option to <span class="literal">1</span> <span class="ent">➌</span>. If you haven’t used <span class="literal">enumerate()</span> before, it’s a handy built-in function that acts as an automatic counter; the count will be assigned to the <span class="literal">file_num</span> variable.</p>
<p class="indent">Next, name a variable, <span class="literal">img</span>, to hold the image and use the <span class="literal">open()</span> method to open the file <span class="ent">➍</span>.</p>
<p class="indent">To fit the borders of a bounding box to Jupiter, you need all the non-Jupiter parts of an image to be black <span class="literal">(0, 0, 0)</span>. Unfortunately, there are stray, noise-related, nonblack pixels beyond Jupiter, and the edge of the planet is diffuse and gradational. These issues result in nonuniform box shapes, as shown in <a href="ch15.xhtml#ch15fig5">Figure 15-5</a>. Fortunately, you can easily resolve these by converting the image to black and white. You can then use this converted image to determine the proper box dimensions for each color photo.</p>
<div class="image"><a id="ch15fig5"/><img src="../images/f0335-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-5: Irregularly sized cropped images due to problems defining the bounding box dimensions</em></p>
<p class="indent">To eliminate the noise effects that compromise the bounding-box technique, convert the loaded image to the “L” mode—consisting of 8-bit black and white pixels—and name the variable <span class="literal">gray</span>, for grayscale <span class="ent">➎</span>. With this mode there is only one channel (versus the three channels for RGB color images), so you only need to decide on a single value when thresholding—that is, setting a limit above or below which an action occurs.</p>
<p class="indent">Assign a new variable, called <span class="literal">bw</span>, to hold a true black-and-white image <span class="ent">➏</span>. Use the <span class="literal">point()</span> method, used to change pixel values, and a lambda function <span epub:type="pagebreak" id="page_336"/>to set any value below 90 to black (<span class="literal">0</span>) and all other values to white (<span class="literal">255</span>). The threshold value was determined through trial and error. The <span class="literal">point()</span> method now returns a clean image for fitting the bounding box (<a href="ch15.xhtml#ch15fig6">Figure 15-6</a>).</p>
<div class="image"><a id="ch15fig6"/><img src="../images/f0336-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-6: Screen capture of one of the original video frames converted to pure black and white</em></p>
<p class="indent">Now, call the <span class="literal">Image</span> module’s <span class="literal">getbox()</span> method on <span class="literal">bw</span> <span class="ent">➐</span>. This method prunes off black borders by fitting a bounding box to the nonzero regions of an image. It returns a tuple with the left, upper, right, and lower pixel coordinates of the box.</p>
<p class="indent">If you use <span class="literal">box</span> to crop the video frames, you get an image with borders tangent to Jupiter’s surface (see the middle image in <a href="ch15.xhtml#ch15fig7">Figure 15-7</a>). This is what you want, but it’s not visually pleasing. So, add some black padding by assigning a new box variable, named <span class="literal">padded_box</span>, with its edges extended 20 pixels in all four directions (see the rightmost image in <a href="ch15.xhtml#ch15fig7">Figure 15-7</a>). Because the padding is consistent and applied to all images, it doesn’t compromise the results of cropping.</p>
<div class="image"><a id="ch15fig7"/><img src="../images/f0336-02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-7: Initial crop tangent to Jupiter’s surface (</em><span class="codeitalic">box</span><em>) and final crop with padding (</em><span class="codeitalic">padded_box</span><em>)</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_337"/>Continue by cropping each image with the <span class="literal">crop()</span> method <span class="ent">➑</span>. This method takes <span class="literal">padded_box</span> as an argument.</p>
<p class="indent">To scale the image, use the <span class="literal">ImageOps.fit()</span> method. This takes the image, a size as a pixel width-and-height tuple, a resampling method, a border (<span class="literal">0</span> = no border), and even cropping from the center, designated by the tuple <span class="literal">(0.5, 0.5)</span>. The <span class="literal">pillow</span> module has several algorithm choices for resizing an image, but I chose the popular <em>Lanczos</em> filter. Enlarging an image tends to reduce its sharpness, but Lanczos can produce <em>ringing artifacts</em> along strong edges; this helps increase <em>perceived</em> sharpness. This unintended edge enhancement can help the eye focus on features of interest, which are faint and blurry in the original video frames.</p>
<p class="indent">After scaling, assign a <span class="literal">file_name</span> variable. Each of the 256 cropped images will start with <em>cropped_</em> and end with the number of the image, which you pass to the replacement field of the <span class="literal">format()</span> method. End the function by saving the file <span class="ent">➒</span>.</p>
<p class="indent">Back in the global scope, add the code that lets the program run as a module or in stand-alone mode.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>I save the files using JPEG format because it is universally readable, handles gradations in color well, and takes up very little memory. JPEG uses “lossy” compression, however, which causes a tiny bit of image deterioration each time a file is saved; you can adjust the degree of compression at the expense of storage size. In most cases, when working with astrophotographs, you’ll want to use one of the many lossless formats available, such as TIFF.</em></p>
</div>
<p class="indent">At this point in the workflow, you’ve cropped the original video frames down to a box around Jupiter; then you scaled the cropped images to a larger, consistent size (<a href="ch15.xhtml#ch15fig8">Figure 15-8</a>).</p>
<div class="image"><a id="ch15fig8"/><img src="../images/f0337-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-8: Relative sizes of images after cropping and scaling</em></p>
<p class="indent">In the next section, you write the code that stacks the cropped and scaled images.</p>
<h4 class="h4" id="lev373"><strong><em>The Stacking Code</em></strong></h4>
<p class="noindent">The <em>stack_images.py</em> code takes the images produced by the last program and averages them so that a single stacked image is produced. You can download it from the book’s resources at <em><a href="https://www.nostarch.com/impracticalpython/">https://www.nostarch.com/impracticalpython/</a></em>. Keep it in the same folder as the <em>crop_n_scale_images.py</em> program.</p>
<p class="indent"><span epub:type="pagebreak" id="page_338"/><a href="ch15.xhtml#ch15list5">Listing 15-5</a> imports modules, loads images, creates lists of color channels (red, blue, green), averages the channels, recombines the channels, and creates and saves the final stacked image. It’s simple enough that we won’t bother with a <span class="literal">main()</span> function.</p>
<p class="margin"><em>stack_images.py</em></p>
<p class="programs"><span class="ent">➊</span> import os<br/>   from PIL import Image<br/><br/>   print("\nstart stacking images...")<br/><br/>   # list images in directory<br/><span class="ent">➋</span> os.chdir('cropped')<br/>   images = os.listdir()<br/><br/>   # loop through images and extract RGB channels as separate lists<br/><span class="ent">➌</span> red_data = []<br/>   green_data = []<br/>   blue_data = []<br/><span class="ent">➍</span> for image in images:<br/>       with Image.open(image) as img:<br/>           if image == images[0]:  # get size of 1st cropped image<br/>               img_size = img.size  # width-height tuple to use later<br/>        <span class="ent">➎</span> red_data.append(list(img.getdata(0)))<br/>           green_data.append(list(img.getdata(1)))<br/>           blue_data.append(list(img.getdata(2)))<br/><br/><span class="ent">➏</span> ave_red = [round(sum(x) / len(red_data)) for x in zip(*red_data)]<br/>   ave_blue = [round(sum(x) / len(blue_data)) for x in zip(*blue_data)]<br/>   ave_green = [round(sum(x) / len(green_data)) for x in zip(*green_data)]<br/><br/><span class="ent">➐</span> merged_data = [(x) for x in zip(ave_red, ave_green, ave_blue)]<br/><span class="ent">➑</span> stacked = Image.new('RGB', (img_size))<br/><span class="ent">➒</span> stacked.putdata(merged_data)<br/>   stacked.show()<br/><br/><span class="ent">➓</span> os.chdir('..')<br/>   stacked.save('jupiter_stacked.tif', 'TIFF')</p>
<p class="listing" id="ch15list5"><em>Listing 15-5: Splits out and averages color channels, then recombines into a single image</em></p>
<p class="indent">Start by repeating some of the imports you used in the previous program <span class="ent">➊</span>. Next, change the current directory to the <em>cropped</em> folder, which contains the cropped and scaled images of Jupiter <span class="ent">➋</span>, and immediately make a list of the images in the folder using <span class="literal">os.listdir()</span>.</p>
<p class="indent">With <span class="literal">pillow</span>, you can manipulate individual pixels or groups of pixels, and you can do this for individual color channels, such as red, blue, and green. To demonstrate this, you’ll work on individual color channels to stack the images.</p>
<p class="indent">Create three empty lists to hold the RGB pixel data <span class="ent">➌</span>, then start looping through the images list <span class="ent">➍</span>. First, open the image. Then, get the width and height of the first image, in pixels, as a tuple. Remember, in the <span epub:type="pagebreak" id="page_339"/>previous program, you scaled all the small cropped images to a larger size. You’ll need these dimensions later for creating the new stacked image, and <span class="literal">size</span> automatically retrieves this info for you.</p>
<p class="indent">Now use the <span class="literal">getdata()</span> method to get the pixel data for the selected image <span class="ent">➎</span>. Pass the method the index of the color channel you want: <span class="literal">0</span> for red, <span class="literal">1</span> for green, and <span class="literal">2</span> for blue. Append the results to a data list, as appropriate. The data from each image will form a separate list in the data lists.</p>
<p class="indent">To average the values in each list, use list comprehension to sum the pixels in all the images and divide by the total number of images <span class="ent">➏</span>. Note that you use <span class="literal">zip</span> with the splat (<span class="literal">*</span>) operator. Your <span class="literal">red_data</span> list, for example, is a list of lists, with each nested list representing one of the 256 image files. Using <span class="literal">zip</span> with <span class="literal">*</span> unpacks the contents of the lists so that the first pixel in image1 is summed with the first pixel in image2, and so on.</p>
<p class="indent">To merge the averaged color channels, use list comprehension with <span class="literal">zip</span> <span class="ent">➐</span>. Next, create a new image, named <span class="literal">stacked</span>, using <span class="literal">Image.new()</span> <span class="ent">➑</span>. Pass the method a color mode (<span class="literal">'RGB'</span>) and the <span class="literal">img_size</span> tuple containing the desired width and height of the image in pixels, which was obtained earlier from one of the cropped images.</p>
<p class="indent">Populate the new <span class="literal">stacked</span> image using the <span class="literal">putdata()</span> method and pass it the <span class="literal">merged_data</span> list <span class="ent">➒</span>. This method copies data from a sequence object into an image, starting at the upper-left corner <span class="literal">(0, 0)</span>. Display the final image using the <span class="literal">show()</span> method. Finish by changing the folder to the parent directory and saving the image as a TIFF file named <em>jupiter_stacked.tif</em> <span class="ent">➓</span>.</p>
<p class="indent">If you compare one of the original video frames to the final stacked image (<em>jupiter_stacked.tif</em>), as in <a href="ch15.xhtml#ch15fig9">Figure 15-9</a>, you’ll see a clear improvement in edge definition and the signal-to-noise ratio. This is best appreciated in color, so if you haven’t run the program, take the time to download <em>Figure 15-9.pdf</em> from the website. When the image is viewed in color, the benefits of the stacking include smoother, “creamier” white bands, better-defined red bands, and a more obvious Great Red Spot. There is still room for improvement, however, so next you’ll write a program to enhance the final stacked image.</p>
<div class="image"><a id="ch15fig9"/><img src="../images/f0339-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-9: An original video frame compared to final stacked image (</em>jupiter_stacked.tif<em>)</em></p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_340"/><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>If the Great Red Spot looks pinkish to you in the stacked image, that’s because it is! It fades from time to time, and many published pictures of Jupiter have exaggerated colors due to processing, so this subtle coloration gets lost. This is probably for the best, as “Great Pink Spot” just doesn’t have the same ring to it.</em></p>
</div>
<h4 class="h4" id="lev374"><strong><em>The Enhancing Code</em></strong></h4>
<p class="noindent">You’ve successfully stacked all the video frames, but Jupiter is still crooked, and its features are faint. You can further improve the stacked image using filters, enhancers, and transforms found in <span class="literal">pillow</span>. As you enhance images, you get further and further from the “ground truth” raw data. For this reason, I chose to isolate the enhancement process in a separate program.</p>
<p class="indent">In general, the first steps after stacking are to enhance details, using high-pass filters or an unsharp mask algorithm, and then to fine-tune brightness, contrast, and color. The code will use <span class="literal">pillow</span>’s image enhancement capability to apply these steps—though in a different order. You can download the code as <em>enhance_image.py</em> from <em><a href="https://nostarch.com/impracticalpython/">https://nostarch.com/impracticalpython/</a></em>. Keep it in the same folder as the previous Python programs.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The processing of astronomical images can be quite involved, and whole books have been written on the subject. Some of the standard steps have been omitted in this workflow. For instance, the original video was not calibrated, and distortion effects due to turbulence were not corrected. Advanced software, such as RegiStax or AviStack, can prevent blurring by warping individual images so that distorted features, like the edges of cloud bands, overlap properly in all images.</em></p>
</div>
<p class="indent"><a href="ch15.xhtml#ch15list6">Listing 15-6</a> imports <span class="literal">pillow</span> classes and opens, enhances, and saves the stacked image generated by the previous code. Because there are many possible options for enhancing images, I chose to modularize this program despite its small size.</p>
<p class="margin"><em>enhance_image.py</em></p>
<p class="programs"><span class="ent">➊</span> from PIL import Image, ImageFilter, ImageEnhance<br/><br/><span class="ent">➋</span> def main():<br/>       """Get an image and enhance, show, and save it."""<br/>    <span class="ent">➌</span> in_file = 'jupiter_stacked.tif'<br/>       img = Image.open(in_file)<br/>    <span class="ent">➍</span> img_enh = enhance_image(img)<br/>       img_enh.show()<br/>       img_enh.save('enhanced.tif', 'TIFF')<br/><br/><span class="ent">➎</span> def enhance_image(image):<br/>       """Improve an image using pillow filters &amp; transforms."""<br/>    <span class="ent">➏</span> enhancer = ImageEnhance.Brightness(image)<br/>    <span class="ent">➐</span> img_enh = enhancer.enhance(0.75)  # 0.75 looks good<br/><br/>    <span class="ent">➑</span> enhancer = ImageEnhance.Contrast(img_enh)<br/>       img_enh = enhancer.enhance(1.6)<br/>   <span epub:type="pagebreak" id="page_341"/>    enhancer = ImageEnhance.Color(img_enh)<br/>       img_enh = enhancer.enhance(1.7)<br/><br/>    <span class="ent">➒</span> img_enh = img_enh.rotate(angle=133, expand=True)<br/><br/>    <span class="ent">➓</span> img_enh = img_enh.filter(ImageFilter.SHARPEN)<br/><br/>       return img_enh<br/><br/>   if __name__ == '__main__':<br/>       main()</p>
<p class="listing" id="ch15list6"><em>Listing 15-6: Opens an image, enhances it, and saves it using a new name</em></p>
<p class="indent">The import is familiar except for the last two <span class="ent">➊</span>. These new modules, <span class="literal">ImageFilter</span> and <span class="literal">ImageEnhance</span>, contain predefined filters and classes that can be used to alter images with blurring, sharpening, brightening, smoothing, and more (see <em><a href="https://pillow.readthedocs.io/en/5.1.x/">https://pillow.readthedocs.io/en/5.1.x/</a></em> for a full listing of what’s in each module).</p>
<p class="indent">Start by defining the <span class="literal">main()</span> function <span class="ent">➋</span>. Assign the stacked image to a variable named <span class="literal">in_file</span>, then pass it to <span class="literal">Image.open()</span> to open the file <span class="ent">➌</span>. Next, call an <span class="literal">enhance_image()</span> function and pass it the image variable <span class="ent">➍</span>. Show the enhanced image and then save it as a TIFF file, which results in no deterioration in image quality.</p>
<p class="indent">Now, define an enhancement function, <span class="literal">enhance_image()</span>, that takes an image as an argument <span class="ent">➎</span>. To paraphrase the <span class="literal">pillow</span> documentation, all enhancement classes implement a common interface containing a single method, <span class="literal">enhance(factor)</span>, that returns an enhanced image. The <span class="literal">factor</span> parameter is a floating-point value controlling the enhancement. A value of <span class="literal">1.0</span> returns a copy of the original; lower values diminish color, brightness, contrast, and so on; and higher values increase these qualities.</p>
<p class="indent">To change the brightness of an image, you first create an instance of the <span class="literal">ImageEnhance</span> module’s <span class="literal">Brightness</span> class, passing it the original image <span class="ent">➏</span>. Mimic the <span class="literal">pillow</span> docs and name this object <span class="literal">enhancer</span>. To make the final, enhanced image, you call the object’s <span class="literal">enhance()</span> method and pass it the <span class="literal">factor</span> argument <span class="ent">➐</span>. In this case, you decrease brightness by 0.25. The <span class="literal"># 0.75</span> comment at the end of the line is a useful way to experiment with different factors. Use this comment to store values you like; that way, you can remember and restore them if other test values don’t yield pleasing results.</p>
<p class="indent">Continue enhancing the image, moving to contrast <span class="ent">➑</span>. If you don’t want to adjust the contrast manually, you can take a chance and use <span class="literal">pillow</span>’s automatic contrast method. First, import <span class="literal">ImageOps</span> from PIL. Then, replace the two lines starting with step <span class="ent">➑</span> with the single line: <span class="literal">img_enh = ImageOps.autocontrast(img_enh)</span>.</p>
<p class="indent">Next, punch up the color. This will help to make the Great Red Spot more visible.</p>
<p class="indent">No one wants to look at a tilted Jupiter, so transform the image by rotating it to a more “conventional” view, where the cloud bands are horizontal and the Great Red Spot is to the lower right. Call the <span class="literal">Image</span> module’s <span epub:type="pagebreak" id="page_342"/><span class="literal">rotate()</span> method on the image and pass it an angle, measured counterclockwise in degrees, and have it automatically expand the output image to make it large enough to hold the entire rotated image <span class="ent">➒</span>.</p>
<p class="indent">Now, sharpen the image. Even on high-quality images, sharpening may be needed to ameliorate the interpolation effects of converting data, resizing and rotating images, and so on. Although some astrophotography resources recommend placing it first, in most image-processing workflows, it comes last. This is because it is dependent on the final size of the image (viewing distance), as well as the media being used. Sharpening can also increase noise artifacts and is a “lossy” operation that can remove data—things you don’t want to happen prior to other edits.</p>
<p class="indent">Sharpening is a little different from the previous enhancements, as you use the <span class="literal">ImageFilter</span> class. No intermediate step is needed; you can build the new image with a single line by calling the <span class="literal">filter()</span> method on the image object and passing it the predefined <span class="literal">SHARPEN</span> filter <span class="ent">➓</span>. The <span class="literal">pillow</span> module has other filters that help define edges, such as <span class="literal">UnsharpMask</span> and <span class="literal">EDGE_ENHANCE</span>, but for this image, the results are indiscernible from <span class="literal">SHARPEN</span>.</p>
<p class="indent">Finish by returning the image and applying the code to run the program as a module or in stand-alone mode.</p>
<p class="indent">The final enhanced image is compared to a random video frame and the final stacked image in <a href="ch15.xhtml#ch15fig10">Figure 15-10</a>. All the images have been rotated for ease of comparison.</p>
<div class="image"><a id="ch15fig10"/><img src="../images/f0342-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-10: A random video frame, the results of stacking 256 frames, and the final enhanced image</em></p>
<p class="indent">You can see the improvement best when you view it in color. If you want to see a color version prior to running the program, view or download <em>Figure 15-10.pdf</em> from the website.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>If you’re familiar with</em> <span class="codeitalic">pillow</span><em>, you may be aware that you can use the</em> <span class="codeitalic">Image.blend()</span> <em>method to stack images with only a few lines of code. To my eye, however, the resulting image is noticeably noisier than that obtained by breaking out and averaging the individual color channels, as you did with the</em> stack_images.py <em>program.</em></p>
</div>
<h3 class="h3" id="lev375"><span epub:type="pagebreak" id="page_343"/><strong>Summary</strong></h3>
<p class="noindent">The final image in <a href="ch15.xhtml#ch15fig10">Figure 15-10</a> will never win any awards or be featured in <em>Sky &amp; Telescope</em> magazine, but the point was to take on a challenge. And the result is a marked improvement over a single image captured from the video. The colors are brighter, the cloud bands sharper, and the Great Red Spot better defined. You can also make out the turbulent zone downwind of the Great Red Spot (refer to <a href="ch15.xhtml#ch15fig1">Figure 15-1</a>).</p>
<p class="indent">Despite starting with rough input, you were able to register the images, remove noise through stacking, and enhance the final image using filters and transforms. And all these steps were accomplished with the freely available <span class="literal">pillow</span> fork of the Python Imaging Library. You also gained experience with the Python <span class="literal">shutil</span> and <span class="literal">os</span> modules, which you used to manipulate files and folders.</p>
<p class="indent">For more advanced image processing, you can use OpenSource Computer Vision (OpenCV), which you implement by installing and importing the <span class="literal">cv2</span> and <span class="literal">NumPy</span> modules. Other options involve <span class="literal">matplotlib</span>, <span class="literal">SciPy</span>, and <span class="literal">NumPy</span>. As always with Python, there’s more than one way to skin a cat!</p>
<h3 class="h3" id="lev376"><strong>Further Reading</strong></h3>
<p class="noindent"><em>Automate the Boring Stuff with Python: Practical Programming for Total Beginners</em> (No Starch Press, 2015) by Al Sweigart includes several useful chapters on working with files, folders, and <span class="literal">pillow</span>.</p>
<p class="indent">Online resources for using Python with astronomy include Python for Astronomers (<em><a href="https://prappleizer.github.io/">https://prappleizer.github.io/</a></em>) and Practical Python for Astronomers (<em><a href="https://python4astronomers.github.io/">https://python4astronomers.github.io/</a></em>).</p>
<p class="indent">If you want to learn more about the OpenCV-Python library, you can find tutorials at <em><a href="https://docs.opencv.org/3.4.2/d0/de3/tutorial_py_intro.html">https://docs.opencv.org/3.4.2/d0/de3/tutorial_py_intro.html</a></em>. Note that knowledge of <span class="literal">NumPy</span> is a prerequisite for the tutorials and for writing optimized OpenCV code. Alternatively, SimpleCV lets you get started with computer vision and image manipulation with a smaller learning curve than OpenCV but only works with Python 2.</p>
<p class="indent"><em>Astrophotography</em> (Rocky Nook, 2014) by Thierry Legault is an indispensable resource for anyone interested in serious astrophotography. A comprehensive and readable reference, it covers all aspects of the subject, from equipment selection through image processing.</p>
<p class="indent">“Aligning Sun Images Using Python” (LabJG, 2013), a blog by James Gilbert, contains code for cropping the sun using the bounding-box technique. It also includes a clever method for realigning rotated images of the sun using sunspots as registration points. You can find it at <em><a href="https://labjg.wordpress.com/2013/04/01/aligning-sun-images-using-python/">https://labjg.wordpress.com/2013/04/01/aligning-sun-images-using-python/</a></em>.</p>
<p class="indent">A Google research team figured out how to use stacking to remove watermarks from images on stock photography websites and how the websites could better protect their property. You can read about it at <em><a href="https://research.googleblog.com/2017/08/making-visible-watermarks-more-effective.html">https://research.googleblog.com/2017/08/making-visible-watermarks-more-effective.html</a></em>.</p>
<h3 class="h3" id="lev377"><span epub:type="pagebreak" id="page_344"/><strong>Challenge Project: Vanishing Act</strong></h3>
<p class="noindent">Image-stacking techniques can do more than just remove noise—they can remove anything that moves at a photo site, including people. Adobe Photoshop, for example, has a stack script that makes nonstationary objects magically vanish. It relies on a statistical average known as the <em>median</em>, which is simply the “middle” value in a list of numbers arranged from smallest to largest. The process requires multiple photos—preferably taken with a tripod-mounted camera—so that the objects you want to remove change positions from one image to the next, while the background remains constant. You typically need 10 to 30 pictures taken about 20 seconds apart, or similarly spaced frames extracted from a video.</p>
<p class="indent">With the mean, you sum numbers and divide by the total. With the median, you sort numbers and choose the middle value. In <a href="ch15.xhtml#ch15fig11">Figure 15-11</a>, a row of five images is shown with the same pixel location outlined in each. In the fourth image, a blackbird has flown by and ruined the splendid white background. If you stack with the mean, the bird’s presence lingers. But do a median stack on the images—that is, sort the red, green, and blue channels and take the middle values—and you get the background value for each channel (<span class="literal">255</span>). No trace of the bird remains.</p>
<div class="image"><a id="ch15fig11"/><img src="../images/f0344-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-11: Five white images with the same pixel highlighted and its RGB values displayed. Median-stacking removes the black pixel.</em></p>
<p class="indent">When you average using the median, spurious values get pushed to the ends of the list. This makes it easy to remove outliers, such as satellites or airplanes in astrophotos, so long as the number of images containing the outlier is less than half the number of images.</p>
<p class="indent">Armed with this knowledge, write an image-stacking program that will remove unwanted tourists from your vacation happy snaps. For testing, you can download the <em>moon_cropped</em> folder from the website, which contains five synthetic images of the moon, each “ruined” by a passing plane (see <a href="ch15.xhtml#ch15fig12">Figure 15-12</a>).</p>
<div class="image"><span epub:type="pagebreak" id="page_345"/><a id="ch15fig12"/><img src="../images/f0345-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-12: Synthetic moon photos for testing the median averaging approach</em></p>
<p class="indent">Your final stacked image should contain no evidence of the plane (<a href="ch15.xhtml#ch15fig13">Figure 15-13</a>).</p>
<div class="image"><a id="ch15fig13"/><img src="../images/f0345-02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-13: Result of stacking the images in the</em> moon_cropped <em>folder using median averaging</em></p>
<p class="indent">As this is a challenge project, no solution is provided.<span epub:type="pagebreak" id="page_346"/></p>
</body></html>