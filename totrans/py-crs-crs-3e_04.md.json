["```py\n$ **python -m pip install --user pygame**\n```", "```py\nimport sys\n\nimport pygame\n\nclass AlienInvasion:\n    \"\"\"Overall class to manage game assets and behavior.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the game, and create game resources.\"\"\"\n❶         pygame.init()\n\n❷         self.screen = pygame.display.set_mode((1200, 800))\n        pygame.display.set_caption(\"Alien Invasion\")\n\n    def run_game(self):\n        \"\"\"Start the main loop for the game.\"\"\"\n❸         while True:\n            # Watch for keyboard and mouse events.\n❹             for event in pygame.event.get():\n❺                 if event.type == pygame.QUIT:\n                    sys.exit()\n\n            # Make the most recently drawn screen visible.\n❻             pygame.display.flip()\n\nif __name__ == '__main__':\n    # Make a game instance, and run the game.\n    ai = AlienInvasion()\n    ai.run_game()\n```", "```py\n def __init__(self):\n \"\"\"Initialize the game, and create game resources.\"\"\"\n pygame.init()\n self.clock = pygame.time.Clock()\n  *--snip--*\n```", "```py\n def run_game(self):\n \"\"\"Start the main loop for the game.\"\"\"\n while True:\n  *--snip--*\n pygame.display.flip()\n            self.clock.tick(60)\n```", "```py\n def __init__(self):\n  *--snip--*\n pygame.display.set_caption(\"Alien Invasion\")\n\n        # Set the background color.\n❶         self.bg_color = (230, 230, 230)\n\n def run_game(self):\n  *--snip--*\n for event in pygame.event.get():\n if event.type == pygame.QUIT:\n sys.exit()\n\n            # Redraw the screen during each pass through the loop.\n❷             self.screen.fill(self.bg_color)\n\n # Make the most recently drawn screen visible.\n pygame.display.flip()\n self.clock.tick(60)\n```", "```py\nclass Settings:\n    \"\"\"A class to store all settings for Alien Invasion.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the game's settings.\"\"\"\n        # Screen settings\n        self.screen_width = 1200\n        self.screen_height = 800\n        self.bg_color = (230, 230, 230)\n```", "```py\n*--snip--*\nimport pygame\n\nfrom settings import Settings\n\nclass AlienInvasion:\n \"\"\"Overall class to manage game assets and behavior.\"\"\"\n\n def __init__(self):\n \"\"\"Initialize the game, and create game resources.\"\"\"\n pygame.init()\n self.clock = pygame.time.Clock()\n❶  self.settings = Settings()\n\n❷         self.screen = pygame.display.set_mode(\n            (self.settings.screen_width, self.settings.screen_height))\n pygame.display.set_caption(\"Alien Invasion\")\n\n def run_game(self):\n  *--snip--*\n # Redraw the screen during each pass through the loop.\n❸             self.screen.fill(self.settings.bg_color)\n\n # Make the most recently drawn screen visible.\n pygame.display.flip()\n self.clock.tick(60)\n*--snip--*\n```", "```py\nimport pygame\n\nclass Ship:\n    \"\"\"A class to manage the ship.\"\"\"\n\n    def __init__(self, ai_game):\n        \"\"\"Initialize the ship and set its starting position.\"\"\"\n❶         self.screen = ai_game.screen\n❷         self.screen_rect = ai_game.screen.get_rect()\n\n        # Load the ship image and get its rect.\n❸         self.image = pygame.image.load('images/ship.bmp')\n        self.rect = self.image.get_rect()\n\n        # Start each new ship at the bottom center of the screen.\n❹         self.rect.midbottom = self.screen_rect.midbottom\n\n❺     def blitme(self):\n        \"\"\"Draw the ship at its current location.\"\"\"\n        self.screen.blit(self.image, self.rect)\n```", "```py\n*--snip--*\nfrom settings import Settings\nfrom ship import Ship\n\nclass AlienInvasion:\n \"\"\"Overall class to manage game assets and behavior.\"\"\"\n\n def __init__(self):\n  *--snip--*\n pygame.display.set_caption(\"Alien Invasion\")\n\n❶         self.ship = Ship(self)\n\n def run_game(self):\n  *--snip--*\n # Redraw the screen during each pass through the loop.\n self.screen.fill(self.settings.bg_color)\n❷             self.ship.blitme()\n\n # Make the most recently drawn screen visible.\n pygame.display.flip()\n self.clock.tick(60)\n*--snip--*\n```", "```py\n def run_game(self):\n \"\"\"Start the main loop for the game.\"\"\"\n while True:\n❶  self._check_events()\n\n # Redraw the screen during each pass through the loop.\n  *--snip--*\n\n❷  def _check_events(self):\n        \"\"\"Respond to keypresses and mouse events.\"\"\"\n        for event in pygame.event.get():\n if event.type == pygame.QUIT:\n sys.exit()\n```", "```py\n def run_game(self):\n \"\"\"Start the main loop for the game.\"\"\"\n while True:\n self._check_events()\n  self._update_screen()\n self.clock.tick(60)\n\n def _check_events(self):\n  *--snip--*\n\n def _update_screen(self):\n        \"\"\"Update images on the screen, and flip to the new screen.\"\"\"\n        self.screen.fill(self.settings.bg_color)\n self.ship.blitme()\n\n pygame.display.flip()\n```", "```py\n def _check_events(self):\n \"\"\"Respond to keypresses and mouse events.\"\"\"\n for event in pygame.event.get():\n if event.type == pygame.QUIT:\n sys.exit()\n❶             elif event.type == pygame.KEYDOWN:\n❷                 if event.key == pygame.K_RIGHT:\n                    # Move the ship to the right.\n❸                     self.ship.rect.x += 1\n```", "```py\nclass Ship:\n \"\"\"A class to manage the ship.\"\"\"\n\n def __init__(self, ai_game):\n  *--snip--*\n # Start each new ship at the bottom center of the screen.\n self.rect.midbottom = self.screen_rect.midbottom\n\n # Movement flag; start with a ship that's not moving.\n❶         self.moving_right = False\n\n❷     def update(self):\n        \"\"\"Update the ship's position based on the movement flag.\"\"\"\n        if self.moving_right:\n            self.rect.x += 1\n\n def blitme(self):\n  *--snip--*\n```", "```py\n def _check_events(self):\n \"\"\"Respond to keypresses and mouse events.\"\"\"\n for event in pygame.event.get():\n  *--snip--*\n elif event.type == pygame.KEYDOWN:\n if event.key == pygame.K_RIGHT:\n❶                     self.ship.moving_right = True\n❷             elif event.type == pygame.KEYUP:\n                if event.key == pygame.K_RIGHT:\n                    self.ship.moving_right = False\n```", "```py\n def run_game(self):\n \"\"\"Start the main loop for the game.\"\"\"\n while True:\n self._check_events()\n  self.ship.update()\n self._update_screen()\n self.clock.tick(60)\n```", "```py\n def __init__(self, ai_game):\n  *--snip--*\n     # Movement flags; start with a ship that's not moving.\n self.moving_right = False\n     self.moving_left = False\n\n def update(self):\n     \"\"\"Update the ship's position based on movement flags.\"\"\"\n if self.moving_right:\n self.rect.x += 1\n     if self.moving_left:\n            self.rect.x -= 1\n```", "```py\n def _check_events(self):\n \"\"\"Respond to keypresses and mouse events.\"\"\"\n for event in pygame.event.get():\n  *--snip--*\n elif event.type == pygame.KEYDOWN:\n if event.key == pygame.K_RIGHT:\n self.ship.moving_right = True\n                elif event.key == pygame.K_LEFT:\n                    self.ship.moving_left = True\n\n elif event.type == pygame.KEYUP:\n if event.key == pygame.K_RIGHT:\n self.ship.moving_right = False\n                elif event.key == pygame.K_LEFT:\n                    self.ship.moving_left = False\n```", "```py\nclass Settings:\n \"\"\"A class to store all settings for Alien Invasion.\"\"\"\n\n def __init__(self):\n  *--snip--*\n\n        # Ship settings\n        self.ship_speed = 1.5\n```", "```py\nclass Ship:\n \"\"\"A class to manage the ship.\"\"\"\n\n    def __init__(self, ai_game):\n \"\"\"Initialize the ship and set its starting position.\"\"\"\n self.screen = ai_game.screen\n❶         self.settings = ai_game.settings\n  *--snip--*\n\n # Start each new ship at the bottom center of the screen.\n  self.rect.midbottom = self.screen_rect.midbottom\n\n        # Store a float for the ship's exact horizontal position.\n❷         self.x = float(self.rect.x)\n\n # Movement flags; start with a ship that's not moving.\n self.moving_right = False\n self.moving_left = False\n\n def update(self):\n \"\"\"Update the ship's position based on movement flags.\"\"\"\n        # Update the ship's x value, not the rect.\n if self.moving_right:\n❸             self.x += self.settings.ship_speed\n if self.moving_left:\n            self.x -= self.settings.ship_speed\n\n        # Update rect object from self.x.\n❹         self.rect.x = self.x\n\n def blitme(self):\n  *--snip--*\n```", "```py\n def update(self):\n \"\"\"Update the ship's position based on movement flags.\"\"\"\n # Update the ship's x value, not the rect.\n❶      if self.moving_right and self.rect.right < self.screen_rect.right:\n self.x += self.settings.ship_speed\n❷      if self.moving_left and self.rect.left > 0:\n self.x -= self.settings.ship_speed\n\n # Update rect object from self.x.\n self.rect.x = self.x\n```", "```py\n def _check_events(self):\n \"\"\"Respond to keypresses and mouse events.\"\"\"\n for event in pygame.event.get():\n if event.type == pygame.QUIT:\n sys.exit()\n elif event.type == pygame.KEYDOWN:\n  self._check_keydown_events(event)\n elif event.type == pygame.KEYUP:\n  self._check_keyup_events(event)\n\n    def _check_keydown_events(self, event):\n        \"\"\"Respond to keypresses.\"\"\"\n if event.key == pygame.K_RIGHT:\n self.ship.moving_right = True\n elif event.key == pygame.K_LEFT:\n self.ship.moving_left = True\n\n    def _check_keyup_events(self, event):\n        \"\"\"Respond to key releases.\"\"\"\n if event.key == pygame.K_RIGHT:\n self.ship.moving_right = False\n elif event.key == pygame.K_LEFT:\n self.ship.moving_left = False\n```", "```py\n def _check_keydown_events(self, event):\n  *--snip--*\n elif event.key == pygame.K_LEFT:\n self.ship.moving_left = True\n        elif event.key == pygame.K_q:\n            sys.exit()\n```", "```py\n def __init__(self):\n \"\"\"Initialize the game, and create game resources.\"\"\"\n pygame.init()\n self.settings = Settings()\n\n❶         self.screen = pygame.display.set_mode((0, 0), pygame.FULLSCREEN)\n❷         self.settings.screen_width = self.screen.get_rect().width\n        self.settings.screen_height = self.screen.get_rect().height\n        pygame.display.set_caption(\"Alien Invasion\")\n```", "```py\n def __init__(self):\n  *--snip--*\n        # Bullet settings\n        self.bullet_speed = 2.0\n     self.bullet_width = 3\n     self.bullet_height = 15\n     self.bullet_color = (60, 60, 60)\n```", "```py\nimport pygame\nfrom pygame.sprite import Sprite\n\nclass Bullet(Sprite):\n    \"\"\"A class to manage bullets fired from the ship.\"\"\"\n\n    def __init__(self, ai_game):\n        \"\"\"Create a bullet object at the ship's current position.\"\"\"\n        super().__init__()\n        self.screen = ai_game.screen\n        self.settings = ai_game.settings\n        self.color = self.settings.bullet_color\n\n        # Create a bullet rect at (0, 0) and then set correct position.\n❶         self.rect = pygame.Rect(0, 0, self.settings.bullet_width,\n            self.settings.bullet_height)\n❷         self.rect.midtop = ai_game.ship.rect.midtop\n\n        # Store the bullet's position as a float.\n❸         self.y = float(self.rect.y)\n```", "```py`Next we create the bullet’s `rect` attribute ❶. The bullet isn’t based on an image, so we have to build a `rect` from scratch using the `pygame.Rect()` class. This class requires the *x*- and *y*-coordinates of the top-left corner of the `rect`, and the width and height of the `rect`. We initialize the `rect` at (0, 0), but we’ll move it to the correct location in the next line, because the bullet’s position depends on the ship’s position. We get the width and height of the bullet from the values stored in `self.settings`.    We set the bullet’s `midtop` attribute to match the ship’s `midtop` attribute ❷. This will make the bullet emerge from the top of the ship, making it look like the bullet is fired from the ship. We use a float for the bullet’s *y*-coordinate so we can make fine adjustments to the bullet’s speed ❸.    Here’s the second part of *bullet.py*, `update()` and `draw_bullet()`:    **bullet.py**    ```", "```py    The `update()` method manages the bullet’s position. When a bullet is fired, it moves up the screen, which corresponds to a decreasing *y*-coordinate value. To update the position, we subtract the amount stored in `settings.bullet_speed` from `self.y` ❶. We then use the value of `self.y` to set the value of `self.rect.y` ❷.    The `bullet_speed` setting allows us to increase the speed of the bullets as the game progresses or as needed to refine the game’s behavior. Once a bullet is fired, we never change the value of its *x*-coordinate, so it will travel vertically in a straight line even if the ship moves.    When we want to draw a bullet, we call `draw_bullet()`. The `draw.rect()` function fills the part of the screen defined by the bullet’s `rect` with the color stored in `self.color` ❸.    ### Storing Bullets in a Group    Now that we have a `Bullet` class and the necessary settings defined, we can write code to fire a bullet each time the player presses the spacebar. We’ll create a group in `AlienInvasion` to store all the active bullets so we can manage the bullets that have already been fired. This group will be an instance of the `pygame.sprite.Group` class, which behaves like a list with some extra functionality that’s helpful when building games. We’ll use this group to draw bullets to the screen on each pass through the main loop and to update each bullet’s position.    First, we’ll import the new `Bullet` class:    **alien_invasion.py**    ```", "```py    Next we’ll create the group that holds the bullets in `__init__()`:    **alien_invasion.py**    ```", "```py    Then we need to update the position of the bullets on each pass through the `while` loop:    **alien_invasion.py**    ```", "```py    When you call `update()` on a group, the group automatically calls `update()` for each sprite in the group. The line `self.bullets.update()` calls `bullet.update()` for each bullet we place in the group `bullets`.    ### Firing Bullets    In `AlienInvasion`, we need to modify `_check_keydown_events()` to fire a bullet when the player presses the spacebar. We don’t need to change `_check_keyup_events()` because nothing happens when the spacebar is released. We also need to modify `_update_screen()` to make sure each bullet is drawn to the screen before we call `flip()`.    There will be a bit of work to do when we fire a bullet, so let’s write a new method, `_fire_bullet()`, to handle this work:    **alien_invasion.py**    ```", "```py    We call `_fire_bullet()` when the spacebar is pressed ❶. In `_fire_bullet()`, we make an instance of `Bullet` and call it `new_bullet` ❷. We then add it to the group `bullets` using the `add()` method ❸. The `add()` method is similar to `append()`, but it’s written specifically for Pygame groups.    The `bullets.sprites()` method returns a list of all sprites in the group `bullets`. To draw all fired bullets to the screen, we loop through the sprites in `bullets` and call `draw_bullet()` on each one ❹. We place this loop before the line that draws the ship, so the bullets don’t start out on top of the ship.    When you run *alien_invasion.py* now, you should be able to move the ship right and left and fire as many bullets as you want. The bullets travel up the screen and disappear when they reach the top, as shown in [Figure 12-3](#figure12-3). You can alter the size, color, and speed of the bullets in *settings.py*.  ![](image_fi/502703c12/f12003.png)    Figure 12-3: The ship after firing a series of bullets      ### Deleting Old Bullets    At the moment, the bullets disappear when they reach the top, but only because Pygame can’t draw them above the top of the screen. The bullets actually continue to exist; their *y*-coordinate values just grow increasingly negative. This is a problem because they continue to consume memory and processing power.    We need to get rid of these old bullets, or the game will slow down from doing so much unnecessary work. To do this, we need to detect when the `bottom` value of a bullet’s `rect` has a value of 0, which indicates the bullet has passed off the top of the screen:    **alien_invasion.py**    ```", "```py    When you use a `for` loop with a list (or a group in Pygame), Python expects that the list will stay the same length as long as the loop is running. That means you can’t remove items from a list or group within a `for` loop, so we have to loop over a copy of the group. We use the `copy()` method to set up the `for` loop ❶, which leaves us free to modify the original `bullets` group inside the loop. We check each bullet to see whether it has disappeared off the top of the screen ❷. If it has, we remove it from `bullets` ❸. We insert a `print()` call to show how many bullets currently exist in the game and verify they’re being deleted when they reach the top of the screen ❹.    If this code works correctly, we can watch the terminal output while firing bullets and see that the number of bullets decreases to zero after each series of bullets has cleared the top of the screen. After you run the game and verify that bullets are being deleted properly, remove the `print()` call. If you leave it in, the game will slow down significantly because it takes more time to write output to the terminal than it does to draw graphics to the game window.    ### Limiting the Number of Bullets    Many shooting games limit the number of bullets a player can have on the screen at one time; doing so encourages players to shoot accurately. We’ll do the same in *Alien Invasion*.    First, store the number of bullets allowed in *settings.py*:    **settings.py**    ```", "```py    This limits the player to three bullets at a time. We’ll use this setting in `AlienInvasion` to check how many bullets exist before creating a new bullet in `_fire_bullet()`:    **alien_invasion.py**    ```", "```py    When the player presses the spacebar, we check the length of `bullets`. If `len(self.bullets)` is less than three, we create a new bullet. But if three bullets are already active, nothing happens when the spacebar is pressed. When you run the game now, you should only be able to fire bullets in groups of three.    ### Creating the _update_bullets() Method    We want to keep the `AlienInvasion` class reasonably well organized, so now that we’ve written and checked the bullet management code, we can move it to a separate method. We’ll create a new method called `_update_bullets()` and add it just before `_update_screen()`:    **alien_invasion.py**    ```", "```py    The code for `_update_bullets()` is cut and pasted from `run_game()`; all we’ve done here is clarify the comments.    The `while` loop in `run_game()` looks simple again:    **alien_invasion.py**    ```", "```py    Now our main loop contains only minimal code, so we can quickly read the method names and understand what’s happening in the game. The main loop checks for player input, and then updates the position of the ship and any bullets that have been fired. We then use the updated positions to draw a new screen and tick the clock at the end of each pass through the loop.    Run *alien_invasion.py* one more time, and make sure you can still fire bullets without errors.    ## Summary    In this chapter, you learned to make a plan for a game and learned the basic structure of a game written in Pygame. You learned to set a background color and store settings in a separate class where you can adjust them more easily. You saw how to draw an image to the screen and give the player control over the movement of game elements. You created elements that move on their own, like bullets flying up a screen, and you deleted objects that are no longer needed. You also learned to refactor code in a project on a regular basis to facilitate ongoing development.    In Chapter 13, we’ll add aliens to *Alien Invasion*. By the end of the chapter, you’ll be able to shoot down aliens, hopefully before they reach your ship!```"]